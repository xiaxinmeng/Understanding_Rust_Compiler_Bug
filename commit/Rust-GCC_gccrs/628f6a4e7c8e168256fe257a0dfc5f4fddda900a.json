{"sha": "628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4ZjZhNGU3YzhlMTY4MjU2ZmUyNTdhMGRmYzVmNGZkZGRhOTAwYQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2004-09-28T07:59:54Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2004-09-28T07:59:54Z"}, "message": "backport: basic-block.h: Include vec.h, errors.h.\n\n2004-09-24  Ben Elliston  <bje@au.ibm.com>\n\t    Steven Bosscher  <stevenb@suse.de>\n\t    Andrew Pinski  <pinskia@physics.uc.edu>\n\n\tMerge from edge-vector-branch:\n\t* basic-block.h: Include vec.h, errors.h. Instantiate a VEC(edge).\n\t(struct edge_def): Remove pred_next, succ_next members.\n\t(struct basic_block_def): Remove pred, succ members.  Add preds\n\tand succs members of type VEC(edge).\n\t(FALLTHRU_EDGE): Redefine using EDGE_SUCC.\n\t(BRANCH_EDGE): Likewise.\n\t(EDGE_CRITICAL_P): Redefine using EDGE_COUNT.\n\t(EDGE_COUNT, EDGE_I, EDGE_PRED, EDGE_SUCC): New.\n\t(edge_iterator): New.\n\t(ei_start, ei_last, ei_end_p, ei_one_before_end_p): New.\n\t(ei_next, ei_prev, ei_edge, ei_safe_edge): Likewise.\n\t(FOR_EACH_EDGE): New.\n\t* bb-reorder.c (find_traces): Use FOR_EACH_EDGE and EDGE_* macros\n\twhere applicable.\n\t(rotate_loop): Likewise.\n\t(find_traces_1_route): Likewise.\n\t(bb_to_key): Likewise.\n\t(connect_traces): Likewise.\n\t(copy_bb_p): Likewise.\n\t(find_rarely_executed_basic_blocks_and_crossing_edges): Likewise.\n\t(add_labels_and_missing_jumps): Likewise.\n\t(fix_up_fall_thru_edges): Likewise.\n\t(find_jump_block): Likewise.\n\t(fix_crossing_conditional_branches): Likewise.\n\t(fix_crossing_unconditional_branches): Likewise.\n\t(add_reg_crossing_jump_notes): Likewise.\n\t* bt-load.c (augment_live_range): Likewise.\n\t* cfg.c (clear_edges): Likewise.\n\t(unchecked_make_edge): Likewise.\n\t(cached_make_edge): Likewise.\n\t(make_single_succ_edge): Likewise.\n\t(remove_edge): Likewise.\n\t(redirect_edge_succ_nodup): Likewise.\n\t(check_bb_profile): Likewise.\n\t(dump_flow_info): Likewise.\n\t(alloc_aux_for_edges): Likewise.\n\t(clear_aux_for_edges): Likewise.\n\t(dump_cfg_bb_info): Likewise.\n\t* cfganal.c (forwarder_block_p): Likewise.\n\t(can_fallthru): Likewise.\n\t(could_fall_through): Likewise.\n\t(mark_dfs_back_edges): Likewise.\n\t(set_edge_can_fallthru_flag): Likewise.\n\t(find_unreachable_blocks): Likewise.\n\t(create_edge_list): Likewise.\n\t(verify_edge_list): Likewise.\n\t(add_noreturn_fake_exit_edges): Likewise.\n\t(connect_infinite_loops_to_exit): Likewise.\n\t(flow_reverse_top_sort_order_compute): Likewise.\n\t(flow_depth_first_order_compute): Likewise.\n\t(flow_preorder_transversal_compute): Likewise.\n\t(flow_dfs_compute_reverse_execute): Likewise.\n\t(dfs_enumerate_from): Likewise.\n\t(compute_dominance_frontiers_1): Likewise.\n\t* cfgbuild.c (make_edges): Likewise.\n\t(compute_outgoing_frequencies): Likewise.\n\t(find_many_sub_basic_blocks): Likewise.\n\t(find_sub_basic_blocks): Likewise.\n\t* cfgcleanup.c (try_simplify_condjump): Likewise.\n\t(thread_jump): Likewise.\n\t(try_forward_edges): Likewise.\n\t(merge_blocks_move): Likewise.\n\t(outgoing_edges_match): Likewise.\n\t(try_crossjump_to_edge): Likewise.\n\t(try_crossjump_bb): Likewise.\n\t(try_optimize_cfg): Likewise.\n\t(merge_seq_blocks): Likewise.\n\t* cfgexpand.c (expand_gimple_tailcall): Likewise.\n\t(expand_gimple_basic_block): Likewise.\n\t(construct_init_block): Likewise.\n\t(construct_exit_block): Likewise.\n\t* cfghooks.c (verify_flow_info): Likewise.\n\t(dump_bb): Likewise.\n\t(delete_basic_block): Likewise.\n\t(split_edge): Likewise.\n\t(merge_blocks): Likewise.\n\t(make_forwarder_block): Likewise.\n\t(tidy_fallthru_edges): Likewise.\n\t(can_duplicate_block_p): Likewise.\n\t(duplicate_block): Likewise.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t(fixup_fallthru_exit_predecessor): Likewise.\n\t(can_copy_bbs_p): Likewise.\n\t(copy_bbs): Likewise.\n\t* cfgloop.c (flow_loops_cfg_dump): Likewise.\n\t(flow_loop_entry_edges_find): Likewise.\n\t(flow_loop_exit_edges_find): Likewise.\n\t(flow_loop_nodes_find): Likewise.\n\t(mark_single_exit_loops): Likewise.\n\t(flow_loop_pre_header_scan): Likewise.\n\t(flow_loop_pre_header_find): Likewise.\n\t(update_latch_info): Likewise.\n\t(canonicalize_loop_headers): Likewise.\n\t(flow_loops_find): Likewise.\n\t(get_loop_body_in_bfs_order): Likewise.\n\t(get_loop_exit_edges): Likewise.\n\t(num_loop_branches): Likewise.\n\t(verify_loop_structure): Likewise.\n\t(loop_latch_edge): Likewise.\n\t(loop_preheader_edge): Likewise.\n\t* cfgloopanal.c (mark_irreducible_loops): Likewise.\n\t(expected_loop_iterations): Likewise.\n\t* cfgloopmanip.c (remove_bbs): Likewise.\n\t(fix_bb_placement): Likewise.\n\t(fix_irreducible_loops): Likewise.\n\t(remove_path): Likewise.\n\t(scale_bbs_frequencies): Likewise.\n\t(loopify): Likewise.\n\t(unloop): Likewise.\n\t(fix_loop_placement): Likewise.\n\t(loop_delete_branch_edge): Likewise.\n\t(duplicate_loop_to_header_edge): Likewise.\n\t(mfb_keep_just): Likewise.\n\t(create_preheader): Likewise.\n\t(force_single_succ_latches): Likewise.\n\t(loop_split_edge_with): Likewise.\n\t(create_loop_notes): Likewise.\n\t* cfgrtl.c (rtl_split_block): Likewise.\n\t(rtl_merge_blocks): Likewise.\n\t(rtl_can_merge_blocks): Likewise.\n\t(try_redirect_by_replacing_jump): Likewise.\n\t(force_nonfallthru_and_redirect): Likewise.\n\t(rtl_tidy_fallthru_edge): Likewise.\n\t(commit_one_edge_insertion): Likewise.\n\t(commit_edge_insertions): Likewise.\n\t(commit_edge_insertions_watch_calls): Likewise.\n\t(rtl_verify_flow_info_1): Likewise.\n\t(rtl_verify_flow_info): Likewise.\n\t(purge_dead_edges): Likewise.\n\t(cfg_layout_redirect_edge_and_branch): Likewise.\n\t(cfg_layout_can_merge_blocks_p): Likewise.\n\t(rtl_flow_call_edges_add): Likewise.\n\t* cse.c (cse_cc_succs): Likewise.\n\t* df.c (hybrid_search): Likewise.\n\t* dominance.c (calc_dfs_tree_nonrec): Likewise.\n\t(calc_dfs_tree): Likewise.\n\t(calc_idoms): Likewise.\n\t(recount_dominator): Likewise.\n\t* domwalk.c (walk_dominator_tree): Likewise.\n\t* except.c (emit_to_new_bb_before): Likewise.\n\t(connect_post_landing_pads): Likewise.\n\t(sjlj_emit_function_enter): Likewise.\n\t(sjlj_emit_function_exit): Likewise.\n\t(finish_eh_generation): Likewise.\n\t* final.c (compute_alignments): Likewise.\n\t* flow.c (calculate_global_regs_live): Likewise.\n\t(initialize_uninitialized_subregs): Likewise.\n\t(init_propagate_block_info): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t* gcse.c (find_implicit_sets): Likewise.\n\t(bypass_block): Likewise.\n\t(bypass_conditional_jumps): Likewise.\n\t(compute_pre_data): Likewise.\n\t(insert_insn_end_bb): Likewise.\n\t(insert_store): Likewise.\n\t(remove_reachable_equiv_notes): Likewise.\n\t* global.c (global_conflicts): Likewise.\n\t(calculate_reg_pav): Likewise.\n\t* graph.c (print_rtl_graph_with_bb): Likewise.\n\t* ifcvt.c (mark_loop_exit_edges): Likewise.\n\t(merge_if_block): Likewise.\n\t(find_if_header): Likewise.\n\t(block_jumps_and_fallthru_p): Likewise.\n\t(find_if_block): Likewise.\n\t(find_cond_trap): Likewise.\n\t(block_has_only_trap): Likewise.\n\t(find_if_case1): Likewise.\n\t(find_if_case_2): Likewise.\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Likewise.\n\t(perfect_nestify): Likewise.\n\t* lcm.c (compute_antinout_edge): Likewise.\n\t(compute_laterin): Likewise.\n\t(compute_available): Likewise.\n\t(compute_nearerout): Likewise.\n\t* loop-doloop.c (doloop_modify): Likewise.\n\t* loop-init.c (loop_optimizer_init): Likewise.\n\t* loop-invariant.c (find_exits): Likewise.\n\t* loop-iv.c (simplify_using_initial_values): Likewise.\n\t(check_simple_exit): Likewise.\n\t(find_simple_exit): Likewise.\n\t* loop-unroll.c (peel_loop_completely): Likewise.\n\t(unroll_loop_constant_iterations): Likewise.\n\t(unroll_loop_runtime_iterations): Likewise.\n\t* loop-unswitch.c (may_unswitch_on): Likewise.\n\t(unswitch_loop): Likewise.\n\t* modulo-sched.c (generate_prolog_epilog): Likewise.\n\t(sms_schedule): Likewise.\n\t* postreload-gcse.c (eliminate_partially_redundant_load):\n\tLikewise.\n\t* predict.c (can_predict_insn_p): Likewise.\n\t(set_even_probabilities): Likewise.\n\t(combine_predictions_for_bb): Likewise.\n\t(predict_loops): Likewise.\n\t(estimate_probability): Likewise.\n\t(tree_predict_by_opcode): Likewise.\n\t(tree_estimate_probability): Likewise.\n\t(last_basic_block_p): Likewise.\n\t(propagate_freq): Likewise.\n\t(estimate_loops_at_level): Likewise.\n\t(estimate_bb_frequencies): Likewise.\n\t* profile.c (instrument_edges): Likewise.\n\t(get_exec_counts): Likewise.\n\t(compute_branch_probabilities): Likewise.\n\t(branch_prob): Likewise.\n\t* ra-build.c (live_in): Likewise.\n\t* ra-rewrite.c (rewrite_program2): Likewise.\n\t* ra.c (reg_alloc): Likewise.\n\t* reg-stack.c (reg_to_stack): Likewise.\n\t(convert_regs_entry): Likewise.\n\t(compensate_edge): Likewise.\n\t(convert_regs_1): Likewise,\n\t(convert_regs_2): Likewise.\n\t(convert_regs): Likewise.\n\t* regrename.c (copyprop_hardreg_forward): Likewise.\n\t* reload1.c (fixup_abnormal_edges): Likewise.\n\t* sbitmap.c (sbitmap_intersection_of_succs): Likewise.\n\t(sbitmap_insersection_of_preds): Likewise.\n\t(sbitmap_union_of_succs): Likewise.\n\t(sbitmap_union_of_preds): Likewise.\n\t* sched-ebb.c (compute_jump_reg_dependencies): Likewise.\n\t(fix_basic_block_boundaries): Likewise.\n\t(sched_ebbs): Likewise.\n\t* sched-rgn.c (build_control_flow): Likewise.\n\t(find_rgns): Likewise.\n\t* tracer.c (find_best_successor): Likewise.\n\t(find_best_predecessor): Likewise.\n\t(tail_duplicate): Likewise.\n\t* tree-cfg.c (make_edges): Likewise.\n\t(make_ctrl_stmt_edges): Likewise.\n\t(make_goto_expr_edges): Likewise.\n\t(tree_can_merge_blocks_p): Likewise.\n\t(tree_merge_blocks): Likewise.\n\t(cfg_remove_useless_stmts_bb): Likewise.\n\t(remove_phi_nodes_and_edges_for_unreachable_block): Likewise.\n\t(tree_block_forwards_to): Likewise.\n\t(cleanup_control_expr_graph): Likewise.\n\t(find_taken_edge): Likewise.\n\t(dump_cfg_stats): Likewise.\n\t(tree_cfg2vcg): Likewise.\n\t(disband_implicit_edges): Likewise.\n\t(tree_find_edge_insert_loc): Likewise.\n\t(bsi_commit_edge_inserts): Likewise.\n\t(tree_split_edge): Likewise.\n\t(tree_verify_flow_info): Likewise.\n\t(tree_make_forwarder_block): Likewise.\n\t(tree_forwarder_block_p): Likewise.\n\t(thread_jumps): Likewise.\n\t(tree_try_redirect_by_replacing_jump): Likewise.\n\t(tree_split_block): Likewise.\n\t(add_phi_args_after_copy_bb): Likewise.\n\t(rewrite_to_new_ssa_names_bb): Likewise.\n\t(dump_function_to_file): Likewise.\n\t(print_pred_bbs): Likewise.\n\t(print_loop): Likewise.\n\t(tree_flow_call_edges_add): Likewise.\n\t(split_critical_edges): Likewise.\n\t(execute_warn_function_return): Likewise.\n\t(extract_true_false_edges_from_block): Likewise.\n\t* tree-if-conv.c (tree_if_conversion): Likewise.\n\t(if_convertable_bb_p): Likewise.\n\t(find_phi_replacement_condition): Likewise.\n\t(combine_blocks): Likewise.\n\t* tree-into-ssa.c (compute_global_livein): Likewise.\n\t(ssa_mark_phi_uses): Likewise.\n\t(ssa_rewrite_initialize_block): Likewise.\n\t(rewrite_add_phi_arguments): Likewise.\n\t(ssa_rewrite_phi_arguments): Likewise.\n\t(insert_phi_nodes_for): Likewise.\n\t(rewrite_into_ssa): Likewise.\n\t(rewrite_ssa_into_ssa): Likewise.\n\t* tree-mudflap.c (mf_build_check_statement_for): Likewise.\n\t* tree-outof-ssa.c (coalesce_abnormal_edges): Likewise.\n\t(rewrite_trees): Likewise.\n\t* tree-pretty-print.c (dump_bb_header): Likewise.\n\t(dump_implicit_edges): Likewise.\n\t* tree-sra.c (insert_edge_copies): Likewise.\n\t(find_obviously_necessary_stmts): Likewise.\n\t(remove_data_stmt): Likewise.\n\t* tree-ssa-dom.c (thread_across_edge): Likewise.\n\t(dom_opt_finalize_block): Likewise.\n\t(single_incoming_edge_ignoring_loop_edges): Likewise.\n\t(record_equivalences_from_incoming_edges): Likewise.\n\t(cprop_into_successor_phis): Likewise.\n\t* tree-ssa-live.c (live_worklist): Likewise.\n\t(calculate_live_on_entry): Likewise.\n\t(calculate_live_on_exit): Likewise.\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Likewise.\n\t(copy_loop_headers): Likewise.\n\t* tree-ssa-loop-im.c (loop_commit_inserts): Likewise.\n\t(fill_always_executed_in): Likewise.\n\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Likewise.\n\t* tree-ssa-loop-ivopts.c (find_interesting_uses): Likewise.\n\t(compute_phi_arg_on_exit): Likewise.\n\t* tree-ssa-loop-manip.c (add_exit_phis_edge): Likewise.\n\t(get_loops_exit): Likewise.\n\t(split_loop_exit_edge): Likewise.\n\t(ip_normal_pos): Likewise.\n\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions):\n\tLikewise.\n\t* tree-ssa-phiopt.c (candidate_bb_for_phi_optimization): Likewise.\n\t(replace_phi_with_stmt): Likewise.\n\t(value_replacement): Likewise.\n\t* tree-ssa-pre.c (compute_antic_aux): Likewise.\n\t(insert_aux): Likewise.\n\t(init_pre): Likewise.\n\t* tree-ssa-propagate.c (simulate_stmt): Likewise.\n\t(simulate_block): Likewise.\n\t(ssa_prop_init): Likewise.\n\t* tree-ssa-threadupdate.c (thread_block): Likewise.\n\t(create_block_for_threading): Likewise.\n\t(remove_last_stmt_and_useless_edges): Likewise.\n\t* tree-ssa.c (verify_phi_args): Likewise.\n\t(verify_ssa): Likewise.\n\t* tree_tailcall.c (independent_of_stmt_p): Likewise.\n\t(find_tail_calls): Likewise.\n\t(eliminate_tail_call): Likewise.\n\t(tree_optimize_tail_calls_1): Likewise.\n\t* tree-vectorizer.c (vect_transform_loop): Likewise.\n\t* var-tracking.c (prologue_stack_adjust): Likewise.\n\t(vt_stack_adjustments): Likewise.\n\t(vt_find_locations): Likewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n\t* config/i386/i386.c (ix86_pad_returns): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n\nCo-Authored-By: Andrew Pinski <pinskia@physics.uc.edu>\nCo-Authored-By: Steven Bosscher <stevenb@suse.de>\n\nFrom-SVN: r88222", "tree": {"sha": "bed4a5579487b418bb321141005a316e87e11b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed4a5579487b418bb321141005a316e87e11b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/comments", "author": null, "committer": null, "parents": [{"sha": "5be9b7a1750e019b85286348a325f00819daca52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be9b7a1750e019b85286348a325f00819daca52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5be9b7a1750e019b85286348a325f00819daca52"}], "stats": {"total": 3566, "additions": 2170, "deletions": 1396}, "files": [{"sha": "563ef3e375a1b255fa2da8cf3fd077db3cfa6cdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1,3 +1,334 @@\n+2004-09-24  Ben Elliston  <bje@au.ibm.com>\n+\t    Steven Bosscher  <stevenb@suse.de>\n+\t    Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tMerge from edge-vector-branch:\n+\t* basic-block.h: Include vec.h, errors.h. Instantiate a VEC(edge).\n+\t(struct edge_def): Remove pred_next, succ_next members.\n+\t(struct basic_block_def): Remove pred, succ members.  Add preds\n+\tand succs members of type VEC(edge).\n+\t(FALLTHRU_EDGE): Redefine using EDGE_SUCC.\n+\t(BRANCH_EDGE): Likewise.\n+\t(EDGE_CRITICAL_P): Redefine using EDGE_COUNT.\n+\t(EDGE_COUNT, EDGE_I, EDGE_PRED, EDGE_SUCC): New.\n+\t(edge_iterator): New.\n+\t(ei_start, ei_last, ei_end_p, ei_one_before_end_p): New.\n+\t(ei_next, ei_prev, ei_edge, ei_safe_edge): Likewise.\n+\t(FOR_EACH_EDGE): New.\n+\t* bb-reorder.c (find_traces): Use FOR_EACH_EDGE and EDGE_* macros\n+\twhere applicable.\n+\t(rotate_loop): Likewise.\n+\t(find_traces_1_route): Likewise.\n+\t(bb_to_key): Likewise.\n+\t(connect_traces): Likewise.\n+\t(copy_bb_p): Likewise.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): Likewise.\n+\t(add_labels_and_missing_jumps): Likewise.\n+\t(fix_up_fall_thru_edges): Likewise.\n+\t(find_jump_block): Likewise.\n+\t(fix_crossing_conditional_branches): Likewise.\n+\t(fix_crossing_unconditional_branches): Likewise.\n+\t(add_reg_crossing_jump_notes): Likewise.\n+\t* bt-load.c (augment_live_range): Likewise.\n+\t* cfg.c (clear_edges): Likewise.\n+\t(unchecked_make_edge): Likewise.\n+\t(cached_make_edge): Likewise.\n+\t(make_single_succ_edge): Likewise.\n+\t(remove_edge): Likewise.\n+\t(redirect_edge_succ_nodup): Likewise.\n+\t(check_bb_profile): Likewise.\n+\t(dump_flow_info): Likewise.\n+\t(alloc_aux_for_edges): Likewise.\n+\t(clear_aux_for_edges): Likewise.\n+\t(dump_cfg_bb_info): Likewise.\n+\t* cfganal.c (forwarder_block_p): Likewise.\n+\t(can_fallthru): Likewise.\n+\t(could_fall_through): Likewise.\n+\t(mark_dfs_back_edges): Likewise.\n+\t(set_edge_can_fallthru_flag): Likewise.\n+\t(find_unreachable_blocks): Likewise.\n+\t(create_edge_list): Likewise.\n+\t(verify_edge_list): Likewise.\n+\t(add_noreturn_fake_exit_edges): Likewise.\n+\t(connect_infinite_loops_to_exit): Likewise.\n+\t(flow_reverse_top_sort_order_compute): Likewise.\n+\t(flow_depth_first_order_compute): Likewise.\n+\t(flow_preorder_transversal_compute): Likewise.\n+\t(flow_dfs_compute_reverse_execute): Likewise.\n+\t(dfs_enumerate_from): Likewise.\n+\t(compute_dominance_frontiers_1): Likewise.\n+\t* cfgbuild.c (make_edges): Likewise.\n+\t(compute_outgoing_frequencies): Likewise.\n+\t(find_many_sub_basic_blocks): Likewise.\n+\t(find_sub_basic_blocks): Likewise.\n+\t* cfgcleanup.c (try_simplify_condjump): Likewise.\n+\t(thread_jump): Likewise.\n+\t(try_forward_edges): Likewise.\n+\t(merge_blocks_move): Likewise.\n+\t(outgoing_edges_match): Likewise.\n+\t(try_crossjump_to_edge): Likewise.\n+\t(try_crossjump_bb): Likewise.\n+\t(try_optimize_cfg): Likewise.\n+\t(merge_seq_blocks): Likewise.\n+\t* cfgexpand.c (expand_gimple_tailcall): Likewise.\n+\t(expand_gimple_basic_block): Likewise.\n+\t(construct_init_block): Likewise.\n+\t(construct_exit_block): Likewise.\n+\t* cfghooks.c (verify_flow_info): Likewise.\n+\t(dump_bb): Likewise.\n+\t(delete_basic_block): Likewise.\n+\t(split_edge): Likewise.\n+\t(merge_blocks): Likewise.\n+\t(make_forwarder_block): Likewise.\n+\t(tidy_fallthru_edges): Likewise.\n+\t(can_duplicate_block_p): Likewise.\n+\t(duplicate_block): Likewise.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t(fixup_fallthru_exit_predecessor): Likewise.\n+\t(can_copy_bbs_p): Likewise.\n+\t(copy_bbs): Likewise.\n+\t* cfgloop.c (flow_loops_cfg_dump): Likewise.\n+\t(flow_loop_entry_edges_find): Likewise.\n+\t(flow_loop_exit_edges_find): Likewise.\n+\t(flow_loop_nodes_find): Likewise.\n+\t(mark_single_exit_loops): Likewise.\n+\t(flow_loop_pre_header_scan): Likewise.\n+\t(flow_loop_pre_header_find): Likewise.\n+\t(update_latch_info): Likewise.\n+\t(canonicalize_loop_headers): Likewise.\n+\t(flow_loops_find): Likewise.\n+\t(get_loop_body_in_bfs_order): Likewise.\n+\t(get_loop_exit_edges): Likewise.\n+\t(num_loop_branches): Likewise.\n+\t(verify_loop_structure): Likewise.\n+\t(loop_latch_edge): Likewise.\n+\t(loop_preheader_edge): Likewise.\n+\t* cfgloopanal.c (mark_irreducible_loops): Likewise.\n+\t(expected_loop_iterations): Likewise.\n+\t* cfgloopmanip.c (remove_bbs): Likewise.\n+\t(fix_bb_placement): Likewise.\n+\t(fix_irreducible_loops): Likewise.\n+\t(remove_path): Likewise.\n+\t(scale_bbs_frequencies): Likewise.\n+\t(loopify): Likewise.\n+\t(unloop): Likewise.\n+\t(fix_loop_placement): Likewise.\n+\t(loop_delete_branch_edge): Likewise.\n+\t(duplicate_loop_to_header_edge): Likewise.\n+\t(mfb_keep_just): Likewise.\n+\t(create_preheader): Likewise.\n+\t(force_single_succ_latches): Likewise.\n+\t(loop_split_edge_with): Likewise.\n+\t(create_loop_notes): Likewise.\n+\t* cfgrtl.c (rtl_split_block): Likewise.\n+\t(rtl_merge_blocks): Likewise.\n+\t(rtl_can_merge_blocks): Likewise.\n+\t(try_redirect_by_replacing_jump): Likewise.\n+\t(force_nonfallthru_and_redirect): Likewise.\n+\t(rtl_tidy_fallthru_edge): Likewise.\n+\t(commit_one_edge_insertion): Likewise.\n+\t(commit_edge_insertions): Likewise.\n+\t(commit_edge_insertions_watch_calls): Likewise.\n+\t(rtl_verify_flow_info_1): Likewise.\n+\t(rtl_verify_flow_info): Likewise.\n+\t(purge_dead_edges): Likewise.\n+\t(cfg_layout_redirect_edge_and_branch): Likewise.\n+\t(cfg_layout_can_merge_blocks_p): Likewise.\n+\t(rtl_flow_call_edges_add): Likewise.\n+\t* cse.c (cse_cc_succs): Likewise.\n+\t* df.c (hybrid_search): Likewise.\n+\t* dominance.c (calc_dfs_tree_nonrec): Likewise.\n+\t(calc_dfs_tree): Likewise.\n+\t(calc_idoms): Likewise.\n+\t(recount_dominator): Likewise.\n+\t* domwalk.c (walk_dominator_tree): Likewise.\n+\t* except.c (emit_to_new_bb_before): Likewise.\n+\t(connect_post_landing_pads): Likewise.\n+\t(sjlj_emit_function_enter): Likewise.\n+\t(sjlj_emit_function_exit): Likewise.\n+\t(finish_eh_generation): Likewise.\n+\t* final.c (compute_alignments): Likewise.\n+\t* flow.c (calculate_global_regs_live): Likewise.\n+\t(initialize_uninitialized_subregs): Likewise.\n+\t(init_propagate_block_info): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t* gcse.c (find_implicit_sets): Likewise.\n+\t(bypass_block): Likewise.\n+\t(bypass_conditional_jumps): Likewise.\n+\t(compute_pre_data): Likewise.\n+\t(insert_insn_end_bb): Likewise.\n+\t(insert_store): Likewise.\n+\t(remove_reachable_equiv_notes): Likewise.\n+\t* global.c (global_conflicts): Likewise.\n+\t(calculate_reg_pav): Likewise.\n+\t* graph.c (print_rtl_graph_with_bb): Likewise.\n+\t* ifcvt.c (mark_loop_exit_edges): Likewise.\n+\t(merge_if_block): Likewise.\n+\t(find_if_header): Likewise.\n+\t(block_jumps_and_fallthru_p): Likewise.\n+\t(find_if_block): Likewise.\n+\t(find_cond_trap): Likewise.\n+\t(block_has_only_trap): Likewise.\n+\t(find_if_case1): Likewise.\n+\t(find_if_case_2): Likewise.\n+\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Likewise.\n+\t(perfect_nestify): Likewise.\n+\t* lcm.c (compute_antinout_edge): Likewise.\n+\t(compute_laterin): Likewise.\n+\t(compute_available): Likewise.\n+\t(compute_nearerout): Likewise.\n+\t* loop-doloop.c (doloop_modify): Likewise.\n+\t* loop-init.c (loop_optimizer_init): Likewise.\n+\t* loop-invariant.c (find_exits): Likewise.\n+\t* loop-iv.c (simplify_using_initial_values): Likewise.\n+\t(check_simple_exit): Likewise.\n+\t(find_simple_exit): Likewise.\n+\t* loop-unroll.c (peel_loop_completely): Likewise.\n+\t(unroll_loop_constant_iterations): Likewise.\n+\t(unroll_loop_runtime_iterations): Likewise.\n+\t* loop-unswitch.c (may_unswitch_on): Likewise.\n+\t(unswitch_loop): Likewise.\n+\t* modulo-sched.c (generate_prolog_epilog): Likewise.\n+\t(sms_schedule): Likewise.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load):\n+\tLikewise.\n+\t* predict.c (can_predict_insn_p): Likewise.\n+\t(set_even_probabilities): Likewise.\n+\t(combine_predictions_for_bb): Likewise.\n+\t(predict_loops): Likewise.\n+\t(estimate_probability): Likewise.\n+\t(tree_predict_by_opcode): Likewise.\n+\t(tree_estimate_probability): Likewise.\n+\t(last_basic_block_p): Likewise.\n+\t(propagate_freq): Likewise.\n+\t(estimate_loops_at_level): Likewise.\n+\t(estimate_bb_frequencies): Likewise.\n+\t* profile.c (instrument_edges): Likewise.\n+\t(get_exec_counts): Likewise.\n+\t(compute_branch_probabilities): Likewise.\n+\t(branch_prob): Likewise.\n+\t* ra-build.c (live_in): Likewise.\n+\t* ra-rewrite.c (rewrite_program2): Likewise.\n+\t* ra.c (reg_alloc): Likewise.\n+\t* reg-stack.c (reg_to_stack): Likewise.\n+\t(convert_regs_entry): Likewise.\n+\t(compensate_edge): Likewise.\n+\t(convert_regs_1): Likewise,\n+\t(convert_regs_2): Likewise.\n+\t(convert_regs): Likewise.\n+\t* regrename.c (copyprop_hardreg_forward): Likewise.\n+\t* reload1.c (fixup_abnormal_edges): Likewise.\n+\t* sbitmap.c (sbitmap_intersection_of_succs): Likewise.\n+\t(sbitmap_insersection_of_preds): Likewise.\n+\t(sbitmap_union_of_succs): Likewise.\n+\t(sbitmap_union_of_preds): Likewise.\n+\t* sched-ebb.c (compute_jump_reg_dependencies): Likewise.\n+\t(fix_basic_block_boundaries): Likewise.\n+\t(sched_ebbs): Likewise.\n+\t* sched-rgn.c (build_control_flow): Likewise.\n+\t(find_rgns): Likewise.\n+\t* tracer.c (find_best_successor): Likewise.\n+\t(find_best_predecessor): Likewise.\n+\t(tail_duplicate): Likewise.\n+\t* tree-cfg.c (make_edges): Likewise.\n+\t(make_ctrl_stmt_edges): Likewise.\n+\t(make_goto_expr_edges): Likewise.\n+\t(tree_can_merge_blocks_p): Likewise.\n+\t(tree_merge_blocks): Likewise.\n+\t(cfg_remove_useless_stmts_bb): Likewise.\n+\t(remove_phi_nodes_and_edges_for_unreachable_block): Likewise.\n+\t(tree_block_forwards_to): Likewise.\n+\t(cleanup_control_expr_graph): Likewise.\n+\t(find_taken_edge): Likewise.\n+\t(dump_cfg_stats): Likewise.\n+\t(tree_cfg2vcg): Likewise.\n+\t(disband_implicit_edges): Likewise.\n+\t(tree_find_edge_insert_loc): Likewise.\n+\t(bsi_commit_edge_inserts): Likewise.\n+\t(tree_split_edge): Likewise.\n+\t(tree_verify_flow_info): Likewise.\n+\t(tree_make_forwarder_block): Likewise.\n+\t(tree_forwarder_block_p): Likewise.\n+\t(thread_jumps): Likewise.\n+\t(tree_try_redirect_by_replacing_jump): Likewise.\n+\t(tree_split_block): Likewise.\n+\t(add_phi_args_after_copy_bb): Likewise.\n+\t(rewrite_to_new_ssa_names_bb): Likewise.\n+\t(dump_function_to_file): Likewise.\n+\t(print_pred_bbs): Likewise.\n+\t(print_loop): Likewise.\n+\t(tree_flow_call_edges_add): Likewise.\n+\t(split_critical_edges): Likewise.\n+\t(execute_warn_function_return): Likewise.\n+\t(extract_true_false_edges_from_block): Likewise.\n+\t* tree-if-conv.c (tree_if_conversion): Likewise.\n+\t(if_convertable_bb_p): Likewise.\n+\t(find_phi_replacement_condition): Likewise.\n+\t(combine_blocks): Likewise.\n+\t* tree-into-ssa.c (compute_global_livein): Likewise.\n+\t(ssa_mark_phi_uses): Likewise.\n+\t(ssa_rewrite_initialize_block): Likewise.\n+\t(rewrite_add_phi_arguments): Likewise.\n+\t(ssa_rewrite_phi_arguments): Likewise.\n+\t(insert_phi_nodes_for): Likewise.\n+\t(rewrite_into_ssa): Likewise.\n+\t(rewrite_ssa_into_ssa): Likewise.\n+\t* tree-mudflap.c (mf_build_check_statement_for): Likewise.\n+\t* tree-outof-ssa.c (coalesce_abnormal_edges): Likewise.\n+\t(rewrite_trees): Likewise.\n+\t* tree-pretty-print.c (dump_bb_header): Likewise.\n+\t(dump_implicit_edges): Likewise.\n+\t* tree-sra.c (insert_edge_copies): Likewise.\n+\t(find_obviously_necessary_stmts): Likewise.\n+\t(remove_data_stmt): Likewise.\n+\t* tree-ssa-dom.c (thread_across_edge): Likewise.\n+\t(dom_opt_finalize_block): Likewise.\n+\t(single_incoming_edge_ignoring_loop_edges): Likewise.\n+\t(record_equivalences_from_incoming_edges): Likewise.\n+\t(cprop_into_successor_phis): Likewise.\n+\t* tree-ssa-live.c (live_worklist): Likewise.\n+\t(calculate_live_on_entry): Likewise.\n+\t(calculate_live_on_exit): Likewise.\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Likewise.\n+\t(copy_loop_headers): Likewise.\n+\t* tree-ssa-loop-im.c (loop_commit_inserts): Likewise.\n+\t(fill_always_executed_in): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Likewise.\n+\t* tree-ssa-loop-ivopts.c (find_interesting_uses): Likewise.\n+\t(compute_phi_arg_on_exit): Likewise.\n+\t* tree-ssa-loop-manip.c (add_exit_phis_edge): Likewise.\n+\t(get_loops_exit): Likewise.\n+\t(split_loop_exit_edge): Likewise.\n+\t(ip_normal_pos): Likewise.\n+\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions):\n+\tLikewise.\n+\t* tree-ssa-phiopt.c (candidate_bb_for_phi_optimization): Likewise.\n+\t(replace_phi_with_stmt): Likewise.\n+\t(value_replacement): Likewise.\n+\t* tree-ssa-pre.c (compute_antic_aux): Likewise.\n+\t(insert_aux): Likewise.\n+\t(init_pre): Likewise.\n+\t* tree-ssa-propagate.c (simulate_stmt): Likewise.\n+\t(simulate_block): Likewise.\n+\t(ssa_prop_init): Likewise.\n+\t* tree-ssa-threadupdate.c (thread_block): Likewise.\t\n+\t(create_block_for_threading): Likewise.\n+\t(remove_last_stmt_and_useless_edges): Likewise.\n+\t* tree-ssa.c (verify_phi_args): Likewise.\n+\t(verify_ssa): Likewise.\n+\t* tree_tailcall.c (independent_of_stmt_p): Likewise.\n+\t(find_tail_calls): Likewise.\n+\t(eliminate_tail_call): Likewise.\n+\t(tree_optimize_tail_calls_1): Likewise.\n+\t* tree-vectorizer.c (vect_transform_loop): Likewise.\n+\t* var-tracking.c (prologue_stack_adjust): Likewise.\n+\t(vt_stack_adjustments): Likewise.\n+\t(vt_find_locations): Likewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n+\t* config/i386/i386.c (ix86_pad_returns): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n+\n 2004-09-28  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/16532"}, {"sha": "04ddee063352cd457ef984879828c79f07d2db79", "filename": "gcc/basic-block.h", "status": "modified", "additions": 116, "deletions": 13, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -28,6 +28,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"partition.h\"\n #include \"hard-reg-set.h\"\n #include \"predict.h\"\n+#include \"vec.h\"\n+#include \"errors.h\"\n \n /* Head of register set linked list.  */\n typedef bitmap_head regset_head;\n@@ -147,12 +149,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n typedef HOST_WIDEST_INT gcov_type;\n \n /* Control flow edge information.  */\n-struct edge_def GTY((chain_next (\"%h.pred_next\")))\n+struct edge_def GTY(())\n {\n-  /* Links through the predecessor and successor lists.  */\n-  struct edge_def *pred_next;\n-  struct edge_def *succ_next;\n-\n   /* The two blocks at the ends of the edge.  */\n   struct basic_block_def *src;\n   struct basic_block_def *dest;\n@@ -176,6 +174,7 @@ struct edge_def GTY((chain_next (\"%h.pred_next\")))\n };\n \n typedef struct edge_def *edge;\n+DEF_VEC_GC_P(edge);\n \n #define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n #define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed\n@@ -250,8 +249,8 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   tree stmt_list;\n \n   /* The edges into and out of the block.  */\n-  edge pred;\n-  edge succ;\n+  VEC(edge) *preds;\n+  VEC(edge) *succs;\n \n   /* Liveness info.  */\n \n@@ -539,12 +538,12 @@ struct edge_list\n #define NUM_EDGES(el)\t\t\t((el)->num_edges)\n \n /* BB is assumed to contain conditional jump.  Return the fallthru edge.  */\n-#define FALLTHRU_EDGE(bb)\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n-\t\t\t\t\t ? (bb)->succ : (bb)->succ->succ_next)\n+#define FALLTHRU_EDGE(bb)\t\t(EDGE_SUCC ((bb), 0)->flags & EDGE_FALLTHRU \\\n+\t\t\t\t\t ? EDGE_SUCC ((bb), 0) : EDGE_SUCC ((bb), 1))\n \n /* BB is assumed to contain conditional jump.  Return the branch edge.  */\n-#define BRANCH_EDGE(bb)\t\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n-\t\t\t\t\t ? (bb)->succ->succ_next : (bb)->succ)\n+#define BRANCH_EDGE(bb)\t\t\t(EDGE_SUCC ((bb), 0)->flags & EDGE_FALLTHRU \\\n+\t\t\t\t\t ? EDGE_SUCC ((bb), 1) : EDGE_SUCC ((bb), 0))\n \n /* Return expected execution frequency of the edge E.  */\n #define EDGE_FREQUENCY(e)\t\t(((e)->src->frequency \\\n@@ -553,8 +552,112 @@ struct edge_list\n \t\t\t\t\t / REG_BR_PROB_BASE)\n \n /* Return nonzero if edge is critical.  */\n-#define EDGE_CRITICAL_P(e)\t\t((e)->src->succ->succ_next \\\n-\t\t\t\t\t && (e)->dest->pred->pred_next)\n+#define EDGE_CRITICAL_P(e)\t\t(EDGE_COUNT ((e)->src->succs) >= 2 \\\n+\t\t\t\t\t && EDGE_COUNT ((e)->dest->preds) >= 2)\n+\n+#define EDGE_COUNT(ev)\t\t\tVEC_length (edge, (ev))\n+#define EDGE_I(ev,i)\t\t\tVEC_index  (edge, (ev), (i))\n+#define EDGE_PRED(bb,i)\t\t\tVEC_index  (edge, (bb)->preds, (i))\n+#define EDGE_SUCC(bb,i)\t\t\tVEC_index  (edge, (bb)->succs, (i))\n+\n+/* Iterator object for edges.  */\n+\n+typedef struct {\n+  unsigned index;\n+  VEC(edge) *container;\n+} edge_iterator;\n+\n+/* Return an iterator pointing to the start of an edge vector.  */\n+static inline edge_iterator\n+ei_start (VEC(edge) *ev)\n+{\n+  edge_iterator i;\n+\n+  i.index = 0;\n+  i.container = ev;\n+\n+  return i;\n+}\n+\n+/* Return an iterator pointing to the last element of an edge\n+   vector. */\n+static inline edge_iterator\n+ei_last (VEC(edge) *ev)\n+{\n+  edge_iterator i;\n+\n+  i.index = EDGE_COUNT (ev) - 1;\n+  i.container = ev;\n+\n+  return i;\n+}\n+\n+/* Is the iterator `i' at the end of the sequence?  */\n+static inline bool\n+ei_end_p (edge_iterator i)\n+{\n+  return (i.index == EDGE_COUNT (i.container));\n+}\n+\n+/* Is the iterator `i' at one position before the end of the\n+   sequence?  */\n+static inline bool\n+ei_one_before_end_p (edge_iterator i)\n+{\n+  return (i.index + 1 == EDGE_COUNT (i.container));\n+}\n+\n+/* Advance the iterator to the next element.  */\n+static inline void\n+ei_next (edge_iterator *i)\n+{\n+  gcc_assert (i->index < EDGE_COUNT (i->container));\n+  i->index++;\n+}\n+\n+/* Move the iterator to the previous element.  */\n+static inline void\n+ei_prev (edge_iterator *i)\n+{\n+  gcc_assert (i->index > 0);\n+  i->index--;\n+}\n+\n+/* Return the edge pointed to by the iterator `i'.  */\n+static inline edge\n+ei_edge (edge_iterator i)\n+{\n+  return EDGE_I (i.container, i.index);\n+}\n+\n+/* Return an edge pointed to by the iterator.  Do it safely so that\n+   NULL is returned when the iterator is pointing at the end of the\n+   sequence.  */\n+static inline edge\n+ei_safe_edge (edge_iterator i)\n+{\n+  return !ei_end_p (i) ? ei_edge (i) : NULL;\n+}\n+\n+/* This macro serves as a convenient way to iterate each edge in a\n+   vector of predeccesor or successor edges.  It must not be used when\n+   an element might be removed during the traversal, otherwise\n+   elements will be missed.  Instead, use a for-loop like that shown\n+   in the following pseudo-code:\n+   \n+   FOR (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+     {\n+\tIF (e != taken_edge)\n+\t  ssa_remove_edge (e);\n+\tELSE\n+\t  ei_next (&ei);\n+     }\n+*/\n+\n+#define FOR_EACH_EDGE(EDGE,ITER,EDGE_VEC) \\\n+  for ((EDGE) = NULL, (ITER) = ei_start ((EDGE_VEC)); \\\n+       ((EDGE) = ei_safe_edge ((ITER))); \\\n+       ei_next (&(ITER)))\n \n struct edge_list * create_edge_list (void);\n void free_edge_list (struct edge_list *);"}, {"sha": "1d0b097de203e99f7a2236a10bc1740625634e51", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -229,6 +229,7 @@ find_traces (int *n_traces, struct trace *traces)\n   int i;\n   int number_of_rounds;\n   edge e;\n+  edge_iterator ei;\n   fibheap_t heap;\n \n   /* Add one extra round of trace collection when partitioning hot/cold\n@@ -243,7 +244,7 @@ find_traces (int *n_traces, struct trace *traces)\n   heap = fibheap_new ();\n   max_entry_frequency = 0;\n   max_entry_count = 0;\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       bbd[e->dest->index].heap = heap;\n       bbd[e->dest->index].node = fibheap_insert (heap, bb_to_key (e->dest),\n@@ -311,7 +312,9 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n   do\n     {\n       edge e;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n \t    && e->dest->rbi->visited != trace_n\n \t    && (e->flags & EDGE_CAN_FALLTHRU)\n@@ -382,17 +385,17 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t  prev_bb->rbi->next = best_bb->rbi->next;\n \n \t  /* Try to get rid of uncond jump to cond jump.  */\n-\t  if (prev_bb->succ && !prev_bb->succ->succ_next)\n+\t  if (EDGE_COUNT (prev_bb->succs) == 1)\n \t    {\n-\t      basic_block header = prev_bb->succ->dest;\n+\t      basic_block header = EDGE_SUCC (prev_bb, 0)->dest;\n \n \t      /* Duplicate HEADER if it is a small block containing cond jump\n \t\t in the end.  */\n \t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0)\n \t\t  && !find_reg_note (BB_END (header), REG_CROSSING_JUMP, \n \t\t\t\t     NULL_RTX))\n \t\t{\n-\t\t  copy_bb (header, prev_bb->succ, prev_bb, trace_n);\n+\t\t  copy_bb (header, EDGE_SUCC (prev_bb, 0), prev_bb, trace_n);\n \t\t}\n \t    }\n \t}\n@@ -448,6 +451,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       struct trace *trace;\n       edge best_edge, e;\n       fibheapkey_t key;\n+      edge_iterator ei;\n \n       bb = fibheap_extract_min (*heap);\n       bbd[bb->index].heap = NULL;\n@@ -498,7 +502,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t     bb->index, *n_traces - 1);\n \n \t  /* Select the successor that will be placed after BB.  */\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      gcc_assert (!(e->flags & EDGE_FAKE));\n \n@@ -537,12 +541,12 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  /* If the best destination has multiple predecessors, and can be\n \t     duplicated cheaper than a jump, don't allow it to be added\n \t     to a trace.  We'll duplicate it when connecting traces.  */\n-\t  if (best_edge && best_edge->dest->pred->pred_next\n+\t  if (best_edge && EDGE_COUNT (best_edge->dest->preds) >= 2\n \t      && copy_bb_p (best_edge->dest, 0))\n \t    best_edge = NULL;\n \n \t  /* Add all non-selected successors to the heaps.  */\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if (e == best_edge\n \t\t  || e->dest == EXIT_BLOCK_PTR\n@@ -637,9 +641,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t\t  /* Check whether there is another edge from BB.  */\n \t\t\t  edge another_edge;\n-\t\t\t  for (another_edge = bb->succ;\n-\t\t\t       another_edge;\n-\t\t\t       another_edge = another_edge->succ_next)\n+\t\t\t  FOR_EACH_EDGE (another_edge, ei, bb->succs)\n \t\t\t    if (another_edge != best_edge)\n \t\t\t      break;\n \n@@ -678,18 +680,17 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t  */\n \n-\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    if (e != best_edge\n \t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n \t\t\t&& !e->dest->rbi->visited\n-\t\t\t&& !e->dest->pred->pred_next\n+\t\t\t&& EDGE_COUNT (e->dest->preds) == 1\n \t\t\t&& !(e->flags & EDGE_CROSSING)\n-\t\t\t&& e->dest->succ\n-\t\t\t&& (e->dest->succ->flags & EDGE_CAN_FALLTHRU)\n-\t\t\t&& !(e->dest->succ->flags & EDGE_COMPLEX)\n-\t\t\t&& !e->dest->succ->succ_next\n-\t\t\t&& e->dest->succ->dest == best_edge->dest\n+\t\t\t&& EDGE_COUNT (e->dest->succs) == 1\n+\t\t\t&& (EDGE_SUCC (e->dest, 0)->flags & EDGE_CAN_FALLTHRU)\n+\t\t\t&& !(EDGE_SUCC (e->dest, 0)->flags & EDGE_COMPLEX)\n+\t\t\t&& EDGE_SUCC (e->dest, 0)->dest == best_edge->dest\n \t\t\t&& 2 * e->dest->frequency >= EDGE_FREQUENCY (best_edge))\n \t\t      {\n \t\t\tbest_edge = e;\n@@ -712,7 +713,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       /* The trace is terminated so we have to recount the keys in heap\n \t (some block can have a lower key because now one of its predecessors\n \t is an end of the trace).  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR\n \t      || e->dest->rbi->visited)\n@@ -801,7 +802,7 @@ static fibheapkey_t\n bb_to_key (basic_block bb)\n {\n   edge e;\n-\n+  edge_iterator ei;\n   int priority = 0;\n \n   /* Do not start in probably never executed blocks.  */\n@@ -812,7 +813,7 @@ bb_to_key (basic_block bb)\n \n   /* Prefer blocks whose predecessor is an end of some trace\n      or whose predecessor edge is EDGE_DFS_BACK.  */\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if ((e->src != ENTRY_BLOCK_PTR && bbd[e->src->index].end_of_trace >= 0)\n \t  || (e->flags & EDGE_DFS_BACK))\n@@ -969,9 +970,10 @@ connect_traces (int n_traces, struct trace *traces)\n       /* Find the predecessor traces.  */\n       for (t2 = t; t2 > 0;)\n \t{\n+\t  edge_iterator ei;\n \t  best = NULL;\n \t  best_len = 0;\n-\t  for (e = traces[t2].first->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, traces[t2].first->preds)\n \t    {\n \t      int si = e->src->index;\n \n@@ -1016,9 +1018,10 @@ connect_traces (int n_traces, struct trace *traces)\n       while (1)\n \t{\n \t  /* Find the continuation of the chain.  */\n+\t  edge_iterator ei;\n \t  best = NULL;\n \t  best_len = 0;\n-\t  for (e = traces[t].last->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, traces[t].last->succs)\n \t    {\n \t      int di = e->dest->index;\n \n@@ -1058,12 +1061,13 @@ connect_traces (int n_traces, struct trace *traces)\n \t      basic_block next_bb = NULL;\n \t      bool try_copy = false;\n \n-\t      for (e = traces[t].last->succ; e; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, traces[t].last->succs)\n \t\tif (e->dest != EXIT_BLOCK_PTR\n \t\t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t\t    && !(e->flags & EDGE_COMPLEX)\n \t\t    && (!best || e->probability > best->probability))\n \t\t  {\n+\t\t    edge_iterator ei;\n \t\t    edge best2 = NULL;\n \t\t    int best2_len = 0;\n \n@@ -1079,7 +1083,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\tcontinue;\n \t\t      }\n \n-\t\t    for (e2 = e->dest->succ; e2; e2 = e2->succ_next)\n+\t\t    FOR_EACH_EDGE (e2, ei, e->dest->succs)\n \t\t      {\n \t\t\tint di = e2->dest->index;\n \n@@ -1177,24 +1181,17 @@ copy_bb_p (basic_block bb, int code_may_grow)\n   int size = 0;\n   int max_size = uncond_jump_length;\n   rtx insn;\n-  int n_succ;\n-  edge e;\n \n   if (!bb->frequency)\n     return false;\n-  if (!bb->pred || !bb->pred->pred_next)\n+  if (EDGE_COUNT (bb->preds) < 2)\n     return false;\n   if (!can_duplicate_block_p (bb))\n     return false;\n \n   /* Avoid duplicating blocks which have many successors (PR/13430).  */\n-  n_succ = 0;\n-  for (e = bb->succ; e; e = e->succ_next)\n-    {\n-      n_succ++;\n-      if (n_succ > 8)\n-\treturn false;\n-    }\n+  if (EDGE_COUNT (bb->succs) > 8)\n+    return false;\n \n   if (code_may_grow && maybe_hot_bb_p (bb))\n     max_size *= 8;\n@@ -1262,6 +1259,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   bool has_hot_blocks = false;\n   edge e;\n   int i;\n+  edge_iterator ei;\n \n   /* Mark which partition (hot/cold) each basic block belongs in.  */\n   \n@@ -1281,7 +1279,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n      the hot partition (if there is one).  */\n   \n   if (has_hot_blocks)\n-    for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n       if (e->dest->index >= 0)\n \t{\n \t  BB_SET_PARTITION (e->dest, BB_HOT_PARTITION);\n@@ -1294,7 +1292,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   if (targetm.have_named_sections)\n     {\n       FOR_EACH_BB (bb)\n-\tfor (e = bb->succ; e; e = e->succ_next)\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n \t  {\n \t    if (e->src != ENTRY_BLOCK_PTR\n \t\t&& e->dest != EXIT_BLOCK_PTR\n@@ -1384,7 +1382,7 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n  \t\t    /* bb just falls through.  */\n  \t\t    {\n  \t\t      /* make sure there's only one successor */\n-\t\t      gcc_assert (src->succ && !src->succ->succ_next);\n+\t\t      gcc_assert (EDGE_COUNT (src->succs) == 1);\n \t\t      \n \t\t      /* Find label in dest block.  */\n \t\t      label = block_label (dest);\n@@ -1432,9 +1430,13 @@ fix_up_fall_thru_edges (void)\n   FOR_EACH_BB (cur_bb)\n     {\n       fall_thru = NULL;\n-      succ1 = cur_bb->succ;\n-      if (succ1)\n-  \tsucc2 = succ1->succ_next;\n+      if (EDGE_COUNT (cur_bb->succs) > 0)\n+\tsucc1 = EDGE_SUCC (cur_bb, 0);\n+      else\n+\tsucc1 = NULL;\n+\n+      if (EDGE_COUNT (cur_bb->succs) > 1)\n+  \tsucc2 = EDGE_SUCC (cur_bb, 1);\n       else\n   \tsucc2 = NULL;\n       \n@@ -1522,7 +1524,7 @@ fix_up_fall_thru_edges (void)\n \t\t\t partition as bb it's falling through from.  */\n \n \t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n-\t\t      new_bb->succ->flags |= EDGE_CROSSING;\n+\t\t      EDGE_SUCC (new_bb, 0)->flags |= EDGE_CROSSING;\n  \t\t    }\n \t\t  \n  \t\t  /* Add barrier after new jump */\n@@ -1557,8 +1559,9 @@ find_jump_block (basic_block jump_dest)\n   basic_block source_bb = NULL; \n   edge e;\n   rtx insn;\n+  edge_iterator ei;\n \n-  for (e = jump_dest->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, jump_dest->preds)\n     if (e->flags & EDGE_CROSSING)\n       {\n \tbasic_block src = e->src;\n@@ -1619,11 +1622,15 @@ fix_crossing_conditional_branches (void)\n   FOR_EACH_BB (cur_bb)\n     {\n       crossing_edge = NULL;\n-      succ1 = cur_bb->succ;\n-      if (succ1)\n- \tsucc2 = succ1->succ_next;\n+      if (EDGE_COUNT (cur_bb->succs) > 0)\n+\tsucc1 = EDGE_SUCC (cur_bb, 0);\n+      else\n+\tsucc1 = NULL;\n+    \n+      if (EDGE_COUNT (cur_bb->succs) > 1)\n+\tsucc2 = EDGE_SUCC (cur_bb, 1);\n       else\n- \tsucc2 = NULL;\n+\tsucc2 = NULL;\n       \n       /* We already took care of fall-through edges, so only one successor\n \t can be a crossing edge.  */\n@@ -1738,10 +1745,10 @@ fix_crossing_conditional_branches (void)\n \t\t will be a successor for new_bb and a predecessor\n \t\t for 'dest'.  */\n \t      \n-\t      if (!new_bb->succ)\n+\t      if (EDGE_COUNT (new_bb->succs) == 0)\n \t\tnew_edge = make_edge (new_bb, dest, 0);\n \t      else\n-\t\tnew_edge = new_bb->succ;\n+\t\tnew_edge = EDGE_SUCC (new_bb, 0);\n \t      \n \t      crossing_edge->flags &= ~EDGE_CROSSING;\n \t      new_edge->flags |= EDGE_CROSSING;\n@@ -1769,7 +1776,7 @@ fix_crossing_unconditional_branches (void)\n   FOR_EACH_BB (cur_bb)\n     {\n       last_insn = BB_END (cur_bb);\n-      succ = cur_bb->succ;\n+      succ = EDGE_SUCC (cur_bb, 0);\n \n       /* Check to see if bb ends in a crossing (unconditional) jump.  At\n          this point, no crossing jumps should be conditional.  */\n@@ -1839,9 +1846,10 @@ add_reg_crossing_jump_notes (void)\n {\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   FOR_EACH_BB (bb)\n-    for (e = bb->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n       if ((e->flags & EDGE_CROSSING)\n \t  && JUMP_P (BB_END (e->src)))\n \tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP, "}, {"sha": "b0ced417518e807e039bc6f34e7686661308d04e", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -879,6 +879,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n   else\n     {\n       edge e;\n+      edge_iterator ei;\n       int new_block = new_bb->index;\n \n       gcc_assert (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb));\n@@ -900,7 +901,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \t  dump_hard_reg_set (*btrs_live_in_range);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      for (e = head_bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, head_bb->preds)\n \t*tos++ = e->src;\n     }\n \n@@ -910,6 +911,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n       if (!bitmap_bit_p (live_range, bb->index))\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n \t  bitmap_set_bit (live_range, bb->index);\n \t  IOR_HARD_REG_SET (*btrs_live_in_range,\n@@ -923,7 +925,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  for (e = bb->pred; e != NULL; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      basic_block pred = e->src;\n \t      if (!bitmap_bit_p (live_range, pred->index))"}, {"sha": "0669bed74c5e2dbfd29e3151658c8041cff3ff17", "filename": "gcc/cfg.c", "status": "modified", "additions": 101, "deletions": 73, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -144,34 +144,20 @@ clear_edges (void)\n {\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   FOR_EACH_BB (bb)\n     {\n-      edge e = bb->succ;\n-\n-      while (e)\n-\t{\n-\t  edge next = e->succ_next;\n-\n-\t  free_edge (e);\n-\t  e = next;\n-\t}\n-\n-      bb->succ = NULL;\n-      bb->pred = NULL;\n-    }\n-\n-  e = ENTRY_BLOCK_PTR->succ;\n-  while (e)\n-    {\n-      edge next = e->succ_next;\n-\n-      free_edge (e);\n-      e = next;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tfree_edge (e);\n+      VEC_truncate (edge, bb->succs, 0);\n+      VEC_truncate (edge, bb->preds, 0);\n     }\n \n-  EXIT_BLOCK_PTR->pred = NULL;\n-  ENTRY_BLOCK_PTR->succ = NULL;\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    free_edge (e);\n+  VEC_truncate (edge, EXIT_BLOCK_PTR->preds, 0);\n+  VEC_truncate (edge, ENTRY_BLOCK_PTR->succs, 0);\n \n   gcc_assert (!n_edges);\n }\n@@ -284,15 +270,13 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   e = ggc_alloc_cleared (sizeof (*e));\n   n_edges++;\n \n-  e->succ_next = src->succ;\n-  e->pred_next = dst->pred;\n+  VEC_safe_insert (edge, src->succs, 0, e);\n+  VEC_safe_insert (edge, dst->preds, 0, e);\n+\n   e->src = src;\n   e->dest = dst;\n   e->flags = flags;\n \n-  src->succ = e;\n-  dst->pred = e;\n-\n   return e;\n }\n \n@@ -304,6 +288,7 @@ cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int fla\n {\n   int use_edge_cache;\n   edge e;\n+  edge_iterator ei;\n \n   /* Don't bother with edge cache for ENTRY or EXIT, if there aren't that\n      many edges to them, or we didn't allocate memory for it.  */\n@@ -324,7 +309,7 @@ cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int fla\n \n       /* Fall through.  */\n     case 0:\n-      for (e = src->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, src->succs)\n \tif (e->dest == dst)\n \t  {\n \t    e->flags |= flags;\n@@ -368,30 +353,42 @@ make_single_succ_edge (basic_block src, basic_block dest, int flags)\n void\n remove_edge (edge e)\n {\n-  edge last_pred = NULL;\n-  edge last_succ = NULL;\n   edge tmp;\n   basic_block src, dest;\n+  bool found = false;\n+  edge_iterator ei;\n \n   src = e->src;\n   dest = e->dest;\n-  for (tmp = src->succ; tmp && tmp != e; tmp = tmp->succ_next)\n-    last_succ = tmp;\n \n-  gcc_assert (tmp);\n-  if (last_succ)\n-    last_succ->succ_next = e->succ_next;\n-  else\n-    src->succ = e->succ_next;\n+  for (ei = ei_start (src->succs); (tmp = ei_safe_edge (ei)); )\n+    {\n+      if (tmp == e)\n+\t{\n+\t  VEC_ordered_remove (edge, src->succs, ei.index);\n+\t  found = true;\n+\t  break;\n+\t}\n+      else\n+\tei_next (&ei);\n+    }\n \n-  for (tmp = dest->pred; tmp && tmp != e; tmp = tmp->pred_next)\n-    last_pred = tmp;\n+  gcc_assert (found);\n \n-  gcc_assert (tmp);\n-  if (last_pred)\n-    last_pred->pred_next = e->pred_next;\n-  else\n-    dest->pred = e->pred_next;\n+  found = false;\n+  for (ei = ei_start (dest->preds); (tmp = ei_safe_edge (ei)); )\n+    {\n+      if (tmp == e)\n+\t{\n+\t  VEC_ordered_remove (edge, dest->preds, ei.index);\n+\t  found = true;\n+\t  break;\n+\t}\n+      else\n+\tei_next (&ei);\n+    }\n+\n+  gcc_assert (found);\n \n   free_edge (e);\n }\n@@ -401,16 +398,27 @@ remove_edge (edge e)\n void\n redirect_edge_succ (edge e, basic_block new_succ)\n {\n-  edge *pe;\n+  edge tmp;\n+  edge_iterator ei;\n+  bool found = false;\n \n   /* Disconnect the edge from the old successor block.  */\n-  for (pe = &e->dest->pred; *pe != e; pe = &(*pe)->pred_next)\n-    continue;\n-  *pe = (*pe)->pred_next;\n+  for (ei = ei_start (e->dest->preds); (tmp = ei_safe_edge (ei)); )\n+    {\n+      if (tmp == e)\n+\t{\n+\t  VEC_ordered_remove (edge, e->dest->preds, ei.index);\n+\t  found = true;\n+\t  break;\n+\t}\n+      else\n+\tei_next (&ei);\n+    }\n+\n+  gcc_assert (found);\n \n   /* Reconnect the edge to the new successor block.  */\n-  e->pred_next = new_succ->pred;\n-  new_succ->pred = e;\n+  VEC_safe_insert (edge, new_succ->preds, 0, e);\n   e->dest = new_succ;\n }\n \n@@ -420,9 +428,10 @@ edge\n redirect_edge_succ_nodup (edge e, basic_block new_succ)\n {\n   edge s;\n+  edge_iterator ei;\n \n   /* Check whether the edge is already present.  */\n-  for (s = e->src->succ; s; s = s->succ_next)\n+  FOR_EACH_EDGE (s, ei, e->src->succs)\n     if (s->dest == new_succ && s != e)\n       break;\n \n@@ -447,17 +456,27 @@ redirect_edge_succ_nodup (edge e, basic_block new_succ)\n void\n redirect_edge_pred (edge e, basic_block new_pred)\n {\n-  edge *pe;\n+  edge tmp;\n+  edge_iterator ei;\n+  bool found = false;\n \n   /* Disconnect the edge from the old predecessor block.  */\n-  for (pe = &e->src->succ; *pe != e; pe = &(*pe)->succ_next)\n-    continue;\n+  for (ei = ei_start (e->src->succs); (tmp = ei_safe_edge (ei)); )\n+    {\n+      if (tmp == e)\n+\t{\n+\t  VEC_ordered_remove (edge, e->src->succs, ei.index);\n+\t  found = true;\n+\t  break;\n+\t}\n+      else\n+\tei_next (&ei);\n+    }\n \n-  *pe = (*pe)->succ_next;\n+  gcc_assert (found);\n \n   /* Reconnect the edge to the new predecessor block.  */\n-  e->succ_next = new_pred->succ;\n-  new_pred->succ = e;\n+  VEC_safe_insert (edge, new_pred->succs, 0, e);\n   e->src = new_pred;\n }\n \n@@ -482,35 +501,37 @@ check_bb_profile (basic_block bb, FILE * file)\n   edge e;\n   int sum = 0;\n   gcov_type lsum;\n+  edge_iterator ei;\n \n   if (profile_status == PROFILE_ABSENT)\n     return;\n \n   if (bb != EXIT_BLOCK_PTR)\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tsum += e->probability;\n-      if (bb->succ && abs (sum - REG_BR_PROB_BASE) > 100)\n+      if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n \tfprintf (file, \"Invalid sum of outgoing probabilities %.1f%%\\n\",\n \t\t sum * 100.0 / REG_BR_PROB_BASE);\n       lsum = 0;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tlsum += e->count;\n-      if (bb->succ && (lsum - bb->count > 100 || lsum - bb->count < -100))\n+      if (EDGE_COUNT (bb->succs)\n+\t  && (lsum - bb->count > 100 || lsum - bb->count < -100))\n \tfprintf (file, \"Invalid sum of outgoing counts %i, should be %i\\n\",\n \t\t (int) lsum, (int) bb->count);\n     }\n   if (bb != ENTRY_BLOCK_PTR)\n     {\n       sum = 0;\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tsum += EDGE_FREQUENCY (e);\n       if (abs (sum - bb->frequency) > 100)\n \tfprintf (file,\n \t\t \"Invalid sum of incoming frequencies %i, should be %i\\n\",\n \t\t sum, bb->frequency);\n       lsum = 0;\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tlsum += e->count;\n       if (lsum - bb->count > 100 || lsum - bb->count < -100)\n \tfprintf (file, \"Invalid sum of incoming counts %i, should be %i\\n\",\n@@ -577,6 +598,7 @@ dump_flow_info (FILE *file)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n       fprintf (file, \"\\nBasic block %d \", bb->index);\n       fprintf (file, \"prev %d, next %d, \",\n@@ -591,11 +613,11 @@ dump_flow_info (FILE *file)\n       fprintf (file, \".\\n\");\n \n       fprintf (file, \"Predecessors: \");\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tdump_edge_info (file, e, 0);\n \n       fprintf (file, \"\\nSuccessors: \");\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tdump_edge_info (file, e, 1);\n \n       fprintf (file, \"\\nRegisters live at start:\");\n@@ -788,8 +810,9 @@ alloc_aux_for_edges (int size)\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    alloc_aux_for_edge (e, size);\n \t}\n     }\n@@ -805,7 +828,8 @@ clear_aux_for_edges (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \te->aux = NULL;\n     }\n }\n@@ -843,6 +867,7 @@ static void\n dump_cfg_bb_info (FILE *file, basic_block bb)\n {\n   unsigned i;\n+  edge_iterator ei;\n   bool first = true;\n   static const char * const bb_bitnames[] =\n     {\n@@ -867,11 +892,11 @@ dump_cfg_bb_info (FILE *file, basic_block bb)\n   fprintf (file, \"\\n\");\n \n   fprintf (file, \"Predecessors: \");\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     dump_edge_info (file, e, 0);\n \n   fprintf (file, \"\\nSuccessors: \");\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     dump_edge_info (file, e, 1);\n   fprintf (file, \"\\n\\n\");\n }\n@@ -902,6 +927,7 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n {\n   edge c;\n   int prob;\n+  edge_iterator ei;\n \n   bb->count -= count;\n   if (bb->count < 0)\n@@ -935,12 +961,14 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n \tfprintf (dump_file, \"Edge frequencies of bb %i has been reset, \"\n \t\t \"frequency of block should end up being 0, it is %i\\n\",\n \t\t bb->index, bb->frequency);\n-      bb->succ->probability = REG_BR_PROB_BASE;\n-      for (c = bb->succ->succ_next; c; c = c->succ_next)\n+      EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+      ei = ei_start (bb->succs);\n+      ei_next (&ei);\n+      for (; (c = ei_safe_edge (ei)); ei_next (&ei))\n \tc->probability = 0;\n     }\n   else\n-    for (c = bb->succ; c; c = c->succ_next)\n+    FOR_EACH_EDGE (c, ei, bb->succs)\n       c->probability = ((c->probability * REG_BR_PROB_BASE) / (double) prob);\n \n   if (bb != taken_edge->src)"}, {"sha": "30aa5c40db3269440dc481bda3ec798dddff3b14", "filename": "gcc/cfganal.c", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -85,7 +85,7 @@ forwarder_block_p (basic_block bb)\n   rtx insn;\n \n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n-      || !bb->succ || bb->succ->succ_next)\n+      || EDGE_COUNT (bb->succs) != 1)\n     return false;\n \n   for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n@@ -105,15 +105,16 @@ can_fallthru (basic_block src, basic_block target)\n   rtx insn = BB_END (src);\n   rtx insn2;\n   edge e;\n+  edge_iterator ei;\n \n   if (target == EXIT_BLOCK_PTR)\n     return true;\n   if (src->next_bb != target)\n     return 0;\n-  for (e = src->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, src->succs)\n     if (e->dest == EXIT_BLOCK_PTR\n \t&& e->flags & EDGE_FALLTHRU)\n-    return 0;\n+      return 0;\n \n   insn2 = BB_HEAD (target);\n   if (insn2 && !active_insn_p (insn2))\n@@ -130,13 +131,14 @@ bool\n could_fall_through (basic_block src, basic_block target)\n {\n   edge e;\n+  edge_iterator ei;\n \n   if (target == EXIT_BLOCK_PTR)\n     return true;\n-  for (e = src->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, src->succs)\n     if (e->dest == EXIT_BLOCK_PTR\n \t&& e->flags & EDGE_FALLTHRU)\n-    return 0;\n+      return 0;\n   return true;\n }\n \f\n@@ -153,7 +155,7 @@ could_fall_through (basic_block src, basic_block target)\n bool\n mark_dfs_back_edges (void)\n {\n-  edge *stack;\n+  edge_iterator *stack;\n   int *pre;\n   int *post;\n   int sp;\n@@ -167,7 +169,7 @@ mark_dfs_back_edges (void)\n   post = xcalloc (last_basic_block, sizeof (int));\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -177,19 +179,19 @@ mark_dfs_back_edges (void)\n   sbitmap_zero (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n \n   while (sp)\n     {\n-      edge e;\n+      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n-      e->flags &= ~EDGE_DFS_BACK;\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n+      ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n \n       /* Check if the edge destination has been visited yet.  */\n       if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n@@ -198,11 +200,11 @@ mark_dfs_back_edges (void)\n \t  SET_BIT (visited, dest->index);\n \n \t  pre[dest->index] = prenum++;\n-\t  if (dest->succ)\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n \t    {\n \t      /* Since the DEST node has been visited for the first\n \t\t time, check its successors.  */\n-\t      stack[sp++] = dest->succ;\n+\t      stack[sp++] = ei_start (dest->succs);\n \t    }\n \t  else\n \t    post[dest->index] = postnum++;\n@@ -212,13 +214,13 @@ mark_dfs_back_edges (void)\n \t  if (dest != EXIT_BLOCK_PTR && src != ENTRY_BLOCK_PTR\n \t      && pre[src->index] >= pre[dest->index]\n \t      && post[dest->index] == 0)\n-\t    e->flags |= EDGE_DFS_BACK, found = true;\n+\t    ei_edge (ei)->flags |= EDGE_DFS_BACK, found = true;\n \n-\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+\t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n \t    post[src->index] = postnum++;\n \n-\t  if (e->succ_next)\n-\t    stack[sp - 1] = e->succ_next;\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack[sp - 1]);\n \t  else\n \t    sp--;\n \t}\n@@ -242,8 +244,9 @@ set_edge_can_fallthru_flag (void)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  e->flags &= ~EDGE_CAN_FALLTHRU;\n \n@@ -254,15 +257,15 @@ set_edge_can_fallthru_flag (void)\n \n       /* If the BB ends with an invertible condjump all (2) edges are\n \t CAN_FALLTHRU edges.  */\n-      if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n+      if (EDGE_COUNT (bb->succs) != 2)\n \tcontinue;\n       if (!any_condjump_p (BB_END (bb)))\n \tcontinue;\n       if (!invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0))\n \tcontinue;\n       invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0);\n-      bb->succ->flags |= EDGE_CAN_FALLTHRU;\n-      bb->succ->succ_next->flags |= EDGE_CAN_FALLTHRU;\n+      EDGE_SUCC (bb, 0)->flags |= EDGE_CAN_FALLTHRU;\n+      EDGE_SUCC (bb, 1)->flags |= EDGE_CAN_FALLTHRU;\n     }\n }\n \n@@ -274,6 +277,7 @@ void\n find_unreachable_blocks (void)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block *tos, *worklist, bb;\n \n   tos = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n@@ -287,7 +291,7 @@ find_unreachable_blocks (void)\n      be only one.  It isn't inconceivable that we might one day directly\n      support Fortran alternate entry points.  */\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       *tos++ = e->dest;\n \n@@ -301,7 +305,7 @@ find_unreachable_blocks (void)\n     {\n       basic_block b = *--tos;\n \n-      for (e = b->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, b->succs)\n \tif (!(e->dest->flags & BB_REACHABLE))\n \t  {\n \t    *tos++ = e->dest;\n@@ -333,6 +337,7 @@ create_edge_list (void)\n   int num_edges;\n   int block_count;\n   basic_block bb;\n+  edge_iterator ei;\n \n   block_count = n_basic_blocks + 2;   /* Include the entry and exit blocks.  */\n \n@@ -342,8 +347,7 @@ create_edge_list (void)\n      edges on each basic block.  */\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n-\tnum_edges++;\n+      num_edges += EDGE_COUNT (bb->succs);\n     }\n \n   elist = xmalloc (sizeof (struct edge_list));\n@@ -355,7 +359,7 @@ create_edge_list (void)\n \n   /* Follow successors of blocks, and register these edges.  */\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-    for (e = bb->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n       elist->index_to_edge[num_edges++] = e;\n \n   return elist;\n@@ -408,10 +412,11 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n   int pred, succ, index;\n   edge e;\n   basic_block bb, p, s;\n+  edge_iterator ei;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  pred = e->src->index;\n \t  succ = e->dest->index;\n@@ -439,14 +444,14 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n       {\n \tint found_edge = 0;\n \n-\tfor (e = p->succ; e; e = e->succ_next)\n+\tFOR_EACH_EDGE (e, ei, p->succs)\n \t  if (e->dest == s)\n \t    {\n \t      found_edge = 1;\n \t      break;\n \t    }\n \n-\tfor (e = s->pred; e; e = e->pred_next)\n+\tFOR_EACH_EDGE (e, ei, s->preds)\n \t  if (e->src == p)\n \t    {\n \t      found_edge = 1;\n@@ -471,8 +476,9 @@ edge\n find_edge (basic_block pred, basic_block succ)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = pred->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, pred->succs)\n     if (e->dest == succ)\n       return e;\n \n@@ -537,14 +543,14 @@ static void\n remove_fake_predecessors (basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = bb->pred; e;)\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n     {\n-      edge tmp = e;\n-\n-      e = e->pred_next;\n-      if ((tmp->flags & EDGE_FAKE) == EDGE_FAKE)\n-\tremove_edge (tmp);\n+      if ((e->flags & EDGE_FAKE) == EDGE_FAKE)\n+\tremove_edge (e);\n+      else\n+\tei_next (&ei);\n     }\n }\n \n@@ -580,7 +586,7 @@ add_noreturn_fake_exit_edges (void)\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    if (bb->succ == NULL)\n+    if (EDGE_COUNT (bb->succs) == 0)\n       make_single_succ_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n@@ -626,13 +632,13 @@ connect_infinite_loops_to_exit (void)\n void\n flow_reverse_top_sort_order_compute (int *rts_order)\n {\n-  edge *stack;\n+  edge_iterator *stack;\n   int sp;\n   int postnum = 0;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -642,39 +648,39 @@ flow_reverse_top_sort_order_compute (int *rts_order)\n   sbitmap_zero (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n \n   while (sp)\n     {\n-      edge e;\n+      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n       if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  SET_BIT (visited, dest->index);\n \n-\t  if (dest->succ)\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = dest->succ;\n+\t    stack[sp++] = ei_start (dest->succs);\n \t  else\n \t    rts_order[postnum++] = dest->index;\n \t}\n       else\n \t{\n-\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+\t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n \t   rts_order[postnum++] = src->index;\n \n-\t  if (e->succ_next)\n-\t    stack[sp - 1] = e->succ_next;\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack[sp - 1]);\n \t  else\n \t    sp--;\n \t}\n@@ -694,14 +700,14 @@ flow_reverse_top_sort_order_compute (int *rts_order)\n int\n flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n {\n-  edge *stack;\n+  edge_iterator *stack;\n   int sp;\n   int dfsnum = 0;\n   int rcnum = n_basic_blocks - 1;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -711,18 +717,18 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   sbitmap_zero (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n \n   while (sp)\n     {\n-      edge e;\n+      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n       if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n@@ -735,25 +741,25 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n \n \t  dfsnum++;\n \n-\t  if (dest->succ)\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = dest->succ;\n+\t    stack[sp++] = ei_start (dest->succs);\n \t  else if (rc_order)\n \t    /* There are no successors for the DEST node so assign\n \t       its reverse completion number.  */\n \t    rc_order[rcnum--] = dest->index;\n \t}\n       else\n \t{\n-\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR\n+\t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR\n \t      && rc_order)\n \t    /* There are no more successors for the SRC node\n \t       so assign its reverse completion number.  */\n \t    rc_order[rcnum--] = src->index;\n \n-\t  if (e->succ_next)\n-\t    stack[sp - 1] = e->succ_next;\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack[sp - 1]);\n \t  else\n \t    sp--;\n \t}\n@@ -789,8 +795,7 @@ struct dfst_node\n void\n flow_preorder_transversal_compute (int *pot_order)\n {\n-  edge e;\n-  edge *stack;\n+  edge_iterator *stack, ei;\n   int i;\n   int max_successors;\n   int sp;\n@@ -808,10 +813,7 @@ flow_preorder_transversal_compute (int *pot_order)\n \n   FOR_EACH_BB (bb)\n     {\n-      max_successors = 0;\n-      for (e = bb->succ; e; e = e->succ_next)\n-\tmax_successors++;\n-\n+      max_successors = EDGE_COUNT (bb->succs);\n       dfst[bb->index].node\n \t= (max_successors\n \t   ? xcalloc (max_successors, sizeof (struct dfst_node *)) : NULL);\n@@ -824,17 +826,17 @@ flow_preorder_transversal_compute (int *pot_order)\n   sbitmap_zero (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n \n   while (sp)\n     {\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n       if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n@@ -850,14 +852,14 @@ flow_preorder_transversal_compute (int *pot_order)\n \t      dfst[dest->index].up = &dfst[src->index];\n \t    }\n \n-\t  if (dest->succ)\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = dest->succ;\n+\t    stack[sp++] = ei_start (dest->succs);\n \t}\n \n-      else if (e->succ_next)\n-\tstack[sp - 1] = e->succ_next;\n+      else if (! ei_one_before_end_p (ei))\n+\tei_next (&stack[sp - 1]);\n       else\n \tsp--;\n     }\n@@ -960,13 +962,14 @@ flow_dfs_compute_reverse_execute (depth_first_search_ds data)\n {\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   while (data->sp > 0)\n     {\n       bb = data->stack[--data->sp];\n \n       /* Perform depth-first search on adjacent vertices.  */\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!TEST_BIT (data->visited_blocks,\n \t\t       e->src->index - (INVALID_BLOCK + 1)))\n \t  flow_dfs_compute_reverse_add_bb (data, e->src);\n@@ -1007,10 +1010,11 @@ dfs_enumerate_from (basic_block bb, int reverse,\n   while (sp)\n     {\n       edge e;\n+      edge_iterator ei;\n       lbb = st[--sp];\n       if (reverse)\n         {\n-          for (e = lbb->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, lbb->preds)\n \t    if (!(e->src->flags & BB_VISITED) && predicate (e->src, data))\n \t      {\n \t        gcc_assert (tv != rslt_max);\n@@ -1020,7 +1024,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n         }\n       else\n         {\n-          for (e = lbb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, lbb->succs)\n \t    if (!(e->dest->flags & BB_VISITED) && predicate (e->dest, data))\n \t      {\n \t        gcc_assert (tv != rslt_max);\n@@ -1056,6 +1060,7 @@ static void\n compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block c;\n \n   SET_BIT (done, bb->index);\n@@ -1072,7 +1077,7 @@ compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n     }\n       \n   /* Find blocks conforming to rule (1) above.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n@@ -1106,7 +1111,7 @@ compute_dominance_frontiers (bitmap *frontiers)\n \n   sbitmap_zero (done);\n \n-  compute_dominance_frontiers_1 (frontiers, ENTRY_BLOCK_PTR->succ->dest, done);\n+  compute_dominance_frontiers_1 (frontiers, EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest, done);\n \n   sbitmap_free (done);\n "}, {"sha": "f5bf3e839cdb3005576e5c934c245dc1cd327e15", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -251,8 +251,9 @@ make_edges (basic_block min, basic_block max, int update_p)\n         FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n \t  {\n \t    edge e;\n+\t    edge_iterator ei;\n \n-\t    for (e = bb->succ; e ; e = e->succ_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      if (e->dest != EXIT_BLOCK_PTR)\n \t\tSET_BIT (edge_cache[bb->index], e->dest->index);\n \t  }\n@@ -270,6 +271,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n       enum rtx_code code;\n       int force_fallthru = 0;\n       edge e;\n+      edge_iterator ei;\n \n       if (LABEL_P (BB_HEAD (bb))\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n@@ -388,7 +390,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n       /* Find out if we can drop through to the next block.  */\n       insn = NEXT_INSN (insn);\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n \t  {\n \t    insn = 0;\n@@ -640,8 +642,9 @@ static void\n compute_outgoing_frequencies (basic_block b)\n {\n   edge e, f;\n+  edge_iterator ei;\n \n-  if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (b->succs) == 2)\n     {\n       rtx note = find_reg_note (BB_END (b), REG_BR_PROB, NULL);\n       int probability;\n@@ -660,16 +663,16 @@ compute_outgoing_frequencies (basic_block b)\n \t}\n     }\n \n-  if (b->succ && !b->succ->succ_next)\n+  if (EDGE_COUNT (b->succs) == 1)\n     {\n-      e = b->succ;\n+      e = EDGE_SUCC (b, 0);\n       e->probability = REG_BR_PROB_BASE;\n       e->count = b->count;\n       return;\n     }\n   guess_outgoing_edge_probabilities (b);\n   if (b->count)\n-    for (e = b->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, b->succs)\n       e->count = ((b->count * e->probability + REG_BR_PROB_BASE / 2)\n \t\t  / REG_BR_PROB_BASE);\n }\n@@ -709,14 +712,15 @@ find_many_sub_basic_blocks (sbitmap blocks)\n     FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n       {\n \tedge e;\n+\tedge_iterator ei;\n \n \tif (STATE (bb) == BLOCK_ORIGINAL)\n \t  continue;\n \tif (STATE (bb) == BLOCK_NEW)\n \t  {\n \t    bb->count = 0;\n \t    bb->frequency = 0;\n-\t    for (e = bb->pred; e; e = e->pred_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->preds)\n \t      {\n \t\tbb->count += e->count;\n \t\tbb->frequency += EDGE_FREQUENCY (e);\n@@ -751,12 +755,13 @@ find_sub_basic_blocks (basic_block bb)\n   FOR_BB_BETWEEN (b, min, max->next_bb, next_bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n       if (b != min)\n \t{\n \t  b->count = 0;\n \t  b->frequency = 0;\n-\t  for (e = b->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, b->preds)\n \t    {\n \t      b->count += e->count;\n \t      b->frequency += EDGE_FREQUENCY (e);"}, {"sha": "eccaab4605e9a8169fd6c01a1b1caf525d50bd71", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 106, "deletions": 96, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -124,9 +124,7 @@ try_simplify_condjump (basic_block cbranch_block)\n   rtx cbranch_insn;\n \n   /* Verify that there are exactly two successors.  */\n-  if (!cbranch_block->succ\n-      || !cbranch_block->succ->succ_next\n-      || cbranch_block->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (cbranch_block->succs) != 2)\n     return false;\n \n   /* Verify that we've got a normal conditional branch at the end\n@@ -142,11 +140,11 @@ try_simplify_condjump (basic_block cbranch_block)\n      be the last block in the function, and must contain just the\n      unconditional jump.  */\n   jump_block = cbranch_fallthru_edge->dest;\n-  if (jump_block->pred->pred_next\n+  if (EDGE_COUNT (jump_block->preds) >= 2\n       || jump_block->next_bb == EXIT_BLOCK_PTR\n       || !FORWARDER_BLOCK_P (jump_block))\n     return false;\n-  jump_dest_block = jump_block->succ->dest;\n+  jump_dest_block = EDGE_SUCC (jump_block, 0)->dest;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -290,9 +288,9 @@ thread_jump (int mode, edge e, basic_block b)\n \n   /* At the moment, we do handle only conditional jumps, but later we may\n      want to extend this code to tablejumps and others.  */\n-  if (!e->src->succ->succ_next || e->src->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (e->src->succs) != 2)\n     return NULL;\n-  if (!b->succ || !b->succ->succ_next || b->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (b->succs) != 2)\n     {\n       BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n       return NULL;\n@@ -421,7 +419,8 @@ static bool\n try_forward_edges (int mode, basic_block b)\n {\n   bool changed = false;\n-  edge e, next, *threaded_edges = NULL;\n+  edge_iterator ei;\n+  edge e, *threaded_edges = NULL;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -437,23 +436,24 @@ try_forward_edges (int mode, basic_block b)\n       && find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n     return false;\n \n-  for (e = b->succ; e; e = next)\n+  for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )\n     {\n       basic_block target, first;\n       int counter;\n       bool threaded = false;\n       int nthreaded_edges = 0;\n       bool may_thread = first_pass | (b->flags & BB_DIRTY);\n \n-      next = e->succ_next;\n-\n       /* Skip complex edges because we don't know how to update them.\n \n          Still handle fallthru edges, as we can succeed to forward fallthru\n          edge to the same place as the branch edge of conditional branch\n          and turn conditional branch to an unconditional branch.  */\n       if (e->flags & EDGE_COMPLEX)\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       target = first = e->dest;\n       counter = 0;\n@@ -480,13 +480,13 @@ try_forward_edges (int mode, basic_block b)\n \t  may_thread |= target->flags & BB_DIRTY;\n \n \t  if (FORWARDER_BLOCK_P (target)\n-\t      && !(target->succ->flags & EDGE_CROSSING)\n-\t      && target->succ->dest != EXIT_BLOCK_PTR)\n+  \t      && !(EDGE_SUCC (target, 0)->flags & EDGE_CROSSING)\n+\t      && EDGE_SUCC (target, 0)->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n-\t      if (target == target->succ->dest)\n+\t      if (target == EDGE_SUCC (target, 0)->dest)\n \t\tcounter = n_basic_blocks;\n-\t      new_target = target->succ->dest;\n+\t      new_target = EDGE_SUCC (target, 0)->dest;\n \t    }\n \n \t  /* Allow to thread only over one edge at time to simplify updating\n@@ -538,7 +538,7 @@ try_forward_edges (int mode, basic_block b)\n \t     it must appear before the JUMP_INSN.  */\n \t  if ((mode & CLEANUP_PRE_LOOP) && optimize)\n \t    {\n-\t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n+\t      rtx insn = (EDGE_SUCC (target, 0)->flags & EDGE_FALLTHRU\n \t\t\t  ? BB_HEAD (target) : prev_nonnote_insn (BB_END (target)));\n \n \t      if (!NOTE_P (insn))\n@@ -597,6 +597,7 @@ try_forward_edges (int mode, basic_block b)\n \t\tfprintf (dump_file,\n \t\t\t \"Forwarding edge %i->%i to %i failed.\\n\",\n \t\t\t b->index, e->dest->index, target->index);\n+\t      ei_next (&ei);\n \t      continue;\n \t    }\n \n@@ -614,7 +615,7 @@ try_forward_edges (int mode, basic_block b)\n \t    {\n \t      edge t;\n \n-\t      if (first->succ->succ_next)\n+\t      if (EDGE_COUNT (first->succs) > 1)\n \t\t{\n \t\t  gcc_assert (n < nthreaded_edges);\n \t\t  t = threaded_edges [n++];\n@@ -638,7 +639,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t  if (n < nthreaded_edges\n \t\t      && first == threaded_edges [n]->src)\n \t\t    n++;\n-\t\t  t = first->succ;\n+\t\t  t = EDGE_SUCC (first, 0);\n \t\t}\n \n \t      t->count -= edge_count;\n@@ -649,7 +650,9 @@ try_forward_edges (int mode, basic_block b)\n \t  while (first != target);\n \n \t  changed = true;\n+\t  continue;\n \t}\n+      ei_next (&ei);\n     }\n \n   if (threaded_edges)\n@@ -837,6 +840,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       edge tmp_edge, b_fallthru_edge;\n       bool c_has_outgoing_fallthru;\n       bool b_has_incoming_fallthru;\n+      edge_iterator ei;\n \n       /* Avoid overactive code motion, as the forwarder blocks should be\n          eliminated by edge redirection instead.  One exception might have\n@@ -849,13 +853,13 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \t and loop notes.  This is done by squeezing out all the notes\n \t and leaving them there to lie.  Not ideal, but functional.  */\n \n-      for (tmp_edge = c->succ; tmp_edge; tmp_edge = tmp_edge->succ_next)\n+      FOR_EACH_EDGE (tmp_edge, ei, c->succs)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n \n       c_has_outgoing_fallthru = (tmp_edge != NULL);\n \n-      for (tmp_edge = b->pred; tmp_edge; tmp_edge = tmp_edge->pred_next)\n+      FOR_EACH_EDGE (tmp_edge, ei, b->preds)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n \n@@ -1214,21 +1218,20 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n   int nehedges1 = 0, nehedges2 = 0;\n   edge fallthru1 = 0, fallthru2 = 0;\n   edge e1, e2;\n+  edge_iterator ei;\n \n   /* If BB1 has only one successor, we may be looking at either an\n      unconditional jump, or a fake edge to exit.  */\n-  if (bb1->succ && !bb1->succ->succ_next\n-      && (bb1->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n+  if (EDGE_COUNT (bb1->succs) == 1\n+      && (EDGE_SUCC (bb1, 0)->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n       && (!JUMP_P (BB_END (bb1)) || simplejump_p (BB_END (bb1))))\n-    return (bb2->succ &&  !bb2->succ->succ_next\n-\t    && (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n+    return (EDGE_COUNT (bb2->succs) == 1\n+\t    && (EDGE_SUCC (bb2, 0)->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n \t    && (!JUMP_P (BB_END (bb2)) || simplejump_p (BB_END (bb2))));\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n-  if (bb1->succ\n-      && bb1->succ->succ_next\n-      && !bb1->succ->succ_next->succ_next\n+  if (EDGE_COUNT (bb1->succs) == 2\n       && any_condjump_p (BB_END (bb1))\n       && onlyjump_p (BB_END (bb1)))\n     {\n@@ -1237,9 +1240,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       rtx set1, set2, cond1, cond2;\n       enum rtx_code code1, code2;\n \n-      if (!bb2->succ\n-\t  || !bb2->succ->succ_next\n-\t  || bb2->succ->succ_next->succ_next\n+      if (EDGE_COUNT (bb2->succs) != 2\n \t  || !any_condjump_p (BB_END (bb2))\n \t  || !onlyjump_p (BB_END (bb2)))\n \treturn false;\n@@ -1252,10 +1253,10 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       /* Get around possible forwarders on fallthru edges.  Other cases\n          should be optimized out already.  */\n       if (FORWARDER_BLOCK_P (f1->dest))\n-\tf1 = f1->dest->succ;\n+\tf1 = EDGE_SUCC (f1->dest, 0);\n \n       if (FORWARDER_BLOCK_P (f2->dest))\n-\tf2 = f2->dest->succ;\n+\tf2 = EDGE_SUCC (f2->dest, 0);\n \n       /* To simplify use of this function, return false if there are\n \t unneeded forwarder blocks.  These will get eliminated later\n@@ -1425,9 +1426,13 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n   /* Search the outgoing edges, ensure that the counts do match, find possible\n      fallthru and exception handling edges since these needs more\n      validation.  */\n-  for (e1 = bb1->succ, e2 = bb2->succ; e1 && e2;\n-       e1 = e1->succ_next, e2 = e2->succ_next)\n+  if (EDGE_COUNT (bb1->succs) != EDGE_COUNT (bb2->succs))\n+    return false;\n+\n+  FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n+      e2 = EDGE_SUCC (bb2, ei.index);\n+      \n       if (e1->flags & EDGE_EH)\n \tnehedges1++;\n \n@@ -1441,18 +1446,17 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n     }\n \n   /* If number of edges of various types does not match, fail.  */\n-  if (e1 || e2\n-      || nehedges1 != nehedges2\n+  if (nehedges1 != nehedges2\n       || (fallthru1 != 0) != (fallthru2 != 0))\n     return false;\n \n   /* fallthru edges must be forwarded to the same destination.  */\n   if (fallthru1)\n     {\n       basic_block d1 = (forwarder_block_p (fallthru1->dest)\n-\t\t\t? fallthru1->dest->succ->dest: fallthru1->dest);\n+\t\t\t? EDGE_SUCC (fallthru1->dest, 0)->dest: fallthru1->dest);\n       basic_block d2 = (forwarder_block_p (fallthru2->dest)\n-\t\t\t? fallthru2->dest->succ->dest: fallthru2->dest);\n+\t\t\t? EDGE_SUCC (fallthru2->dest, 0)->dest: fallthru2->dest);\n \n       if (d1 != d2)\n \treturn false;\n@@ -1487,6 +1491,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   basic_block redirect_to, redirect_from, to_remove;\n   rtx newpos1, newpos2;\n   edge s;\n+  edge_iterator ei;\n \n   newpos1 = newpos2 = NULL_RTX;\n \n@@ -1506,15 +1511,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n      about multiple entry or chained forwarders, as they will be optimized\n      away.  We do this to look past the unconditional jump following a\n      conditional jump that is required due to the current CFG shape.  */\n-  if (src1->pred\n-      && !src1->pred->pred_next\n+  if (EDGE_COUNT (src1->preds) == 1\n       && FORWARDER_BLOCK_P (src1))\n-    e1 = src1->pred, src1 = e1->src;\n+    e1 = EDGE_PRED (src1, 0), src1 = e1->src;\n \n-  if (src2->pred\n-      && !src2->pred->pred_next\n+  if (EDGE_COUNT (src2->preds) == 1\n       && FORWARDER_BLOCK_P (src2))\n-    e2 = src2->pred, src2 = e2->src;\n+    e2 = EDGE_PRED (src2, 0), src2 = e2->src;\n \n   /* Nothing to do if we reach ENTRY, or a common source block.  */\n   if (src1 == ENTRY_BLOCK_PTR || src2 == ENTRY_BLOCK_PTR)\n@@ -1524,16 +1527,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \n   /* Seeing more than 1 forwarder blocks would confuse us later...  */\n   if (FORWARDER_BLOCK_P (e1->dest)\n-      && FORWARDER_BLOCK_P (e1->dest->succ->dest))\n+      && FORWARDER_BLOCK_P (EDGE_SUCC (e1->dest, 0)->dest))\n     return false;\n \n   if (FORWARDER_BLOCK_P (e2->dest)\n-      && FORWARDER_BLOCK_P (e2->dest->succ->dest))\n+      && FORWARDER_BLOCK_P (EDGE_SUCC (e2->dest, 0)->dest))\n     return false;\n \n   /* Likewise with dead code (possibly newly created by the other optimizations\n      of cfg_cleanup).  */\n-  if (!src1->pred || !src2->pred)\n+  if (EDGE_COUNT (src1->preds) == 0 || EDGE_COUNT (src2->preds) == 0)\n     return false;\n \n   /* Look for the common insn sequence, part the first ...  */\n@@ -1606,19 +1609,20 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   redirect_to->flags |= BB_DIRTY;\n \n   /* Recompute the frequencies and counts of outgoing edges.  */\n-  for (s = redirect_to->succ; s; s = s->succ_next)\n+  FOR_EACH_EDGE (s, ei, redirect_to->succs)\n     {\n       edge s2;\n+      edge_iterator ei;\n       basic_block d = s->dest;\n \n       if (FORWARDER_BLOCK_P (d))\n-\td = d->succ->dest;\n+\td = EDGE_SUCC (d, 0)->dest;\n \n-      for (s2 = src1->succ; ; s2 = s2->succ_next)\n+      FOR_EACH_EDGE (s2, ei, src1->succs)\n \t{\n \t  basic_block d2 = s2->dest;\n \t  if (FORWARDER_BLOCK_P (d2))\n-\t    d2 = d2->succ->dest;\n+\t    d2 = EDGE_SUCC (d2, 0)->dest;\n \t  if (d == d2)\n \t    break;\n \t}\n@@ -1630,16 +1634,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n          into infinite loop.  */\n       if (FORWARDER_BLOCK_P (s->dest))\n \t{\n-\t  s->dest->succ->count += s2->count;\n+\t  EDGE_SUCC (s->dest, 0)->count += s2->count;\n \t  s->dest->count += s2->count;\n \t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n \n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n-\t  s2->dest->succ->count -= s2->count;\n-\t  if (s2->dest->succ->count < 0)\n-\t    s2->dest->succ->count = 0;\n+\t  EDGE_SUCC (s2->dest, 0)->count -= s2->count;\n+\t  if (EDGE_SUCC (s2->dest, 0)->count < 0)\n+\t    EDGE_SUCC (s2->dest, 0)->count = 0;\n \t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t  if (s2->dest->frequency < 0)\n@@ -1669,9 +1673,9 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     newpos1 = NEXT_INSN (newpos1);\n \n   redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n-  to_remove = redirect_from->succ->dest;\n+  to_remove = EDGE_SUCC (redirect_from, 0)->dest;\n \n-  redirect_edge_and_branch_force (redirect_from->succ, redirect_to);\n+  redirect_edge_and_branch_force (EDGE_SUCC (redirect_from, 0), redirect_to);\n   delete_basic_block (to_remove);\n \n   update_forwarder_flag (redirect_from);\n@@ -1686,12 +1690,14 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n static bool\n try_crossjump_bb (int mode, basic_block bb)\n {\n-  edge e, e2, nexte2, nexte, fallthru;\n+  edge e, e2, fallthru;\n   bool changed;\n-  int n = 0, max;\n+  unsigned max, ix, ix2;\n+  basic_block ev, ev2;\n+  edge_iterator ei;\n \n   /* Nothing to do if there is not at least two incoming edges.  */\n-  if (!bb->pred || !bb->pred->pred_next)\n+  if (EDGE_COUNT (bb->preds) < 2)\n     return false;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -1705,27 +1711,30 @@ try_crossjump_bb (int mode, basic_block bb)\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition\n-      && (BB_PARTITION (bb->pred->src) != BB_PARTITION (bb->pred->pred_next->src)\n-\t  || (bb->pred->flags & EDGE_CROSSING)))\n+      && (BB_PARTITION (EDGE_PRED (bb, 0)->src) != BB_PARTITION (EDGE_PRED (bb, 1)->src)\n+\t  || (EDGE_PRED (bb, 0)->flags & EDGE_CROSSING)))\n     return false;\n \n   /* It is always cheapest to redirect a block that ends in a branch to\n      a block that falls through into BB, as that adds no branches to the\n      program.  We'll try that combination first.  */\n   fallthru = NULL;\n   max = PARAM_VALUE (PARAM_MAX_CROSSJUMP_EDGES);\n-  for (e = bb->pred; e ; e = e->pred_next, n++)\n+\n+  if (EDGE_COUNT (bb->preds) > max)\n+    return false;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (e->flags & EDGE_FALLTHRU)\n-\tfallthru = e;\n-      if (n > max)\n-\treturn false;\n+        fallthru = e;\n     }\n \n   changed = false;\n-  for (e = bb->pred; e; e = nexte)\n+  for (ix = 0, ev = bb; ix < EDGE_COUNT (ev->preds); )\n     {\n-      nexte = e->pred_next;\n+      e = EDGE_PRED (ev, ix);\n+      ix++;\n \n       /* As noted above, first try with the fallthru predecessor.  */\n       if (fallthru)\n@@ -1744,7 +1753,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  if (try_crossjump_to_edge (mode, e, fallthru))\n \t    {\n \t      changed = true;\n-\t      nexte = bb->pred;\n+\t      ix = 0;\n+\t      ev = bb;\n \t      continue;\n \t    }\n \t}\n@@ -1761,12 +1771,13 @@ try_crossjump_bb (int mode, basic_block bb)\n \t can eliminate redundant checks of crossjump(A,B) by arbitrarily\n \t choosing to do the check from the block for which the edge\n \t in question is the first successor of A.  */\n-      if (e->src->succ != e)\n+      if (EDGE_SUCC (e->src, 0) != e)\n \tcontinue;\n \n-      for (e2 = bb->pred; e2; e2 = nexte2)\n+      for (ix2 = 0, ev2 = bb; ix2 < EDGE_COUNT (ev2->preds); )\n \t{\n-\t  nexte2 = e2->pred_next;\n+\t  e2 = EDGE_PRED (ev2, ix2);\n+\t  ix2++;\n \n \t  if (e2 == e)\n \t    continue;\n@@ -1792,7 +1803,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  if (try_crossjump_to_edge (mode, e, e2))\n \t    {\n \t      changed = true;\n-\t      nexte = bb->pred;\n+\t      ev2 = bb;\n+\t      ix = 0;\n \t      break;\n \t    }\n \t}\n@@ -1844,7 +1856,7 @@ try_optimize_cfg (int mode)\n \t      bool changed_here = false;\n \n \t      /* Delete trivially dead basic blocks.  */\n-\t      while (b->pred == NULL)\n+\t      while (EDGE_COUNT (b->preds) == 0)\n \t\t{\n \t\t  c = b->prev_bb;\n \t\t  if (dump_file)\n@@ -1858,20 +1870,20 @@ try_optimize_cfg (int mode)\n \t\t}\n \n \t      /* Remove code labels no longer used.  */\n-\t      if (b->pred->pred_next == NULL\n-\t\t  && (b->pred->flags & EDGE_FALLTHRU)\n-\t\t  && !(b->pred->flags & EDGE_COMPLEX)\n+\t      if (EDGE_COUNT (b->preds) == 1\n+\t\t  && (EDGE_PRED (b, 0)->flags & EDGE_FALLTHRU)\n+\t\t  && !(EDGE_PRED (b, 0)->flags & EDGE_COMPLEX)\n \t\t  && LABEL_P (BB_HEAD (b))\n \t\t  /* If the previous block ends with a branch to this\n \t\t     block, we can't delete the label.  Normally this\n \t\t     is a condjump that is yet to be simplified, but\n \t\t     if CASE_DROPS_THRU, this can be a tablejump with\n \t\t     some element going to the same place as the\n \t\t     default (fallthru).  */\n-\t\t  && (b->pred->src == ENTRY_BLOCK_PTR\n-\t\t      || !JUMP_P (BB_END (b->pred->src))\n+\t\t  && (EDGE_PRED (b, 0)->src == ENTRY_BLOCK_PTR\n+\t\t      || !JUMP_P (BB_END (EDGE_PRED (b, 0)->src))\n \t\t      || ! label_is_jump_target_p (BB_HEAD (b),\n-\t\t\t\t\t\t   BB_END (b->pred->src))))\n+\t\t\t\t\t\t   BB_END (EDGE_PRED (b, 0)->src))))\n \t\t{\n \t\t  rtx label = BB_HEAD (b);\n \n@@ -1892,13 +1904,13 @@ try_optimize_cfg (int mode)\n \n \t      /* If we fall through an empty block, we can remove it.  */\n \t      if (!(mode & CLEANUP_CFGLAYOUT)\n-\t\t  && b->pred->pred_next == NULL\n-\t\t  && (b->pred->flags & EDGE_FALLTHRU)\n+\t\t  && EDGE_COUNT (b->preds) == 1\n+\t\t  && (EDGE_PRED (b, 0)->flags & EDGE_FALLTHRU)\n \t\t  && !LABEL_P (BB_HEAD (b))\n \t\t  && FORWARDER_BLOCK_P (b)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n-\t\t  && (b->succ->flags & EDGE_FALLTHRU)\n+\t\t  && (EDGE_SUCC (b, 0)->flags & EDGE_FALLTHRU)\n \t\t  && n_basic_blocks > 1)\n \t\t{\n \t\t  if (dump_file)\n@@ -1907,17 +1919,17 @@ try_optimize_cfg (int mode)\n \t\t\t     b->index);\n \n \t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n-\t\t  redirect_edge_succ_nodup (b->pred, b->succ->dest);\n+\t\t  redirect_edge_succ_nodup (EDGE_PRED (b, 0), EDGE_SUCC (b, 0)->dest);\n \t\t  delete_basic_block (b);\n \t\t  changed = true;\n \t\t  b = c;\n \t\t}\n \n-\t      if ((s = b->succ) != NULL\n-\t\t  && s->succ_next == NULL\n+\t      if (EDGE_COUNT (b->succs) == 1\n+\t\t  && (s = EDGE_SUCC (b, 0))\n \t\t  && !(s->flags & EDGE_COMPLEX)\n \t\t  && (c = s->dest) != EXIT_BLOCK_PTR\n-\t\t  && c->pred->pred_next == NULL\n+\t\t  && EDGE_COUNT (c->preds) == 1\n \t\t  && b != c)\n \t\t{\n \t\t  /* When not in cfg_layout mode use code aware of reordering\n@@ -1959,12 +1971,11 @@ try_optimize_cfg (int mode)\n \t\t non-trivial jump instruction without side-effects, we\n \t\t can either delete the jump entirely, or replace it\n \t\t with a simple unconditional jump.  */\n-\t      if (b->succ\n-\t\t  && ! b->succ->succ_next\n-\t\t  && b->succ->dest != EXIT_BLOCK_PTR\n+\t      if (EDGE_COUNT (b->succs) == 1\n+\t\t  && EDGE_SUCC (b, 0)->dest != EXIT_BLOCK_PTR\n \t\t  && onlyjump_p (BB_END (b))\n \t\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t\t  && try_redirect_by_replacing_jump (b->succ, b->succ->dest,\n+\t\t  && try_redirect_by_replacing_jump (EDGE_SUCC (b, 0), EDGE_SUCC (b, 0)->dest,\n \t\t\t\t\t\t     (mode & CLEANUP_CFGLAYOUT) != 0))\n \t\t{\n \t\t  update_forwarder_flag (b);\n@@ -2049,12 +2060,11 @@ merge_seq_blocks (void)\n \n   for (bb = ENTRY_BLOCK_PTR->next_bb; bb != EXIT_BLOCK_PTR; )\n     {\n-      if (bb->succ\n-\t  && !bb->succ->succ_next\n-\t  && can_merge_blocks_p (bb, bb->succ->dest))\n+      if (EDGE_COUNT (bb->succs) == 1\n+\t  && can_merge_blocks_p (bb, EDGE_SUCC (bb, 0)->dest))\n \t{\n \t  /* Merge the blocks and retry.  */\n-\t  merge_blocks (bb, bb->succ->dest);\n+\t  merge_blocks (bb, EDGE_SUCC (bb, 0)->dest);\n \t  changed = true;\n \t  continue;\n \t}"}, {"sha": "ee0d534ac553f692af3e3416749963c069f9be30", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -924,6 +924,7 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n {\n   rtx last = get_last_insn ();\n   edge e;\n+  edge_iterator ei;\n   int probability;\n   gcov_type count;\n \n@@ -948,13 +949,11 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n      all edges here, or redirecting the existing fallthru edge to\n      the exit block.  */\n \n-  e = bb->succ;\n   probability = 0;\n   count = 0;\n-  while (e)\n-    {\n-      edge next = e->succ_next;\n \n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+    {\n       if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n \t{\n \t  if (e->dest != EXIT_BLOCK_PTR)\n@@ -970,8 +969,8 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n \t  probability += e->probability;\n \t  remove_edge (e);\n \t}\n-\n-      e = next;\n+      else\n+\tei_next (&ei);\n     }\n \n   /* This is somewhat ugly: the call_expr expander often emits instructions\n@@ -1020,6 +1019,7 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n   tree stmt = NULL;\n   rtx note, last;\n   edge e;\n+  edge_iterator ei;\n \n   if (dump_file)\n     {\n@@ -1050,11 +1050,8 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n \n   NOTE_BASIC_BLOCK (note) = bb;\n \n-  e = bb->succ;\n-  while (e)\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      edge next = e->succ_next;\n-\n       /* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.  */\n       e->flags &= ~EDGE_EXECUTABLE;\n \n@@ -1063,8 +1060,8 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n          rediscover them.  In the future we should get this fixed properly.  */\n       if (e->flags & EDGE_ABNORMAL)\n \tremove_edge (e);\n-\n-      e = next;\n+      else\n+\tei_next (&ei);\n     }\n \n   for (; !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -1129,8 +1126,9 @@ construct_init_block (void)\n {\n   basic_block init_block, first_block;\n   edge e = NULL, e2;\n+  edge_iterator ei;\n \n-  for (e2 = ENTRY_BLOCK_PTR->succ; e2; e2 = e2->succ_next)\n+  FOR_EACH_EDGE (e2, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       /* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.\n \n@@ -1173,7 +1171,9 @@ construct_exit_block (void)\n   rtx head = get_last_insn ();\n   rtx end;\n   basic_block exit_block;\n-  edge e, e2, next;\n+  edge e, e2;\n+  unsigned ix;\n+  edge_iterator ei;\n \n   /* Make sure the locus is set to the end of the function, so that\n      epilogue line numbers and warnings are set properly.  */\n@@ -1199,16 +1199,21 @@ construct_exit_block (void)\n \t\t\t\t   EXIT_BLOCK_PTR->prev_bb);\n   exit_block->frequency = EXIT_BLOCK_PTR->frequency;\n   exit_block->count = EXIT_BLOCK_PTR->count;\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = next)\n+\n+  ix = 0;\n+  while (ix < EDGE_COUNT (EXIT_BLOCK_PTR->preds))\n     {\n-      next = e->pred_next;\n+      e = EDGE_I (EXIT_BLOCK_PTR->preds, ix);\n       if (!(e->flags & EDGE_ABNORMAL))\n-        redirect_edge_succ (e, exit_block);\n+\tredirect_edge_succ (e, exit_block);\n+      else\n+\tix++;\n     }\n+\n   e = make_edge (exit_block, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n   e->probability = REG_BR_PROB_BASE;\n   e->count = EXIT_BLOCK_PTR->count;\n-  for (e2 = EXIT_BLOCK_PTR->pred; e2; e2 = e2->pred_next)\n+  FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR->preds)\n     if (e2 != e)\n       {\n         e->count -= e2->count;"}, {"sha": "b3fde683cb998ef9c7814d8c754f5d8e0f251a50", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -106,6 +106,7 @@ verify_flow_info (void)\n     {\n       int n_fallthru = 0;\n       edge e;\n+      edge_iterator ei;\n \n       if (bb->count < 0)\n \t{\n@@ -119,7 +120,7 @@ verify_flow_info (void)\n \t         bb->index, bb->frequency);\n \t  err = 1;\n \t}\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (last_visited [e->dest->index + 2] == bb)\n \t    {\n@@ -165,7 +166,7 @@ verify_flow_info (void)\n \t  err = 1;\n \t}\n \n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if (e->dest != bb)\n \t    {\n@@ -184,11 +185,12 @@ verify_flow_info (void)\n   /* Complete edge checksumming for ENTRY and EXIT.  */\n   {\n     edge e;\n+    edge_iterator ei;\n \n-    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n       edge_checksum[e->dest->index + 2] += (size_t) e;\n \n-    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n       edge_checksum[e->dest->index + 2] -= (size_t) e;\n   }\n \n@@ -221,6 +223,7 @@ void\n dump_bb (basic_block bb, FILE *outf, int indent)\n {\n   edge e;\n+  edge_iterator ei;\n   char *s_indent;\n  \n   s_indent = alloca ((size_t) indent + 1);\n@@ -245,12 +248,12 @@ dump_bb (basic_block bb, FILE *outf, int indent)\n   putc ('\\n', outf);\n \n   fprintf (outf, \";;%s pred:      \", s_indent);\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     dump_edge_info (outf, e, 0);\n   putc ('\\n', outf);\n \n   fprintf (outf, \";;%s succ:      \", s_indent);\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     dump_edge_info (outf, e, 1);\n   putc ('\\n', outf);\n \n@@ -360,13 +363,13 @@ delete_basic_block (basic_block bb)\n \n   /* Remove the edges into and out of this block.  Note that there may\n      indeed be edges in, if we are removing an unreachable loop.  */\n-  while (bb->pred != NULL)\n-    remove_edge (bb->pred);\n-  while (bb->succ != NULL)\n-    remove_edge (bb->succ);\n+  while (EDGE_COUNT (bb->preds) != 0)\n+    remove_edge (EDGE_PRED (bb, 0));\n+  while (EDGE_COUNT (bb->succs) != 0)\n+    remove_edge (EDGE_SUCC (bb, 0));\n \n-  bb->pred = NULL;\n-  bb->succ = NULL;\n+  VEC_truncate (edge, bb->preds, 0);\n+  VEC_truncate (edge, bb->succs, 0);\n \n   if (dom_computed[CDI_DOMINATORS])\n     delete_from_dominance_info (CDI_DOMINATORS, bb);\n@@ -393,11 +396,11 @@ split_edge (edge e)\n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n   ret->frequency = freq;\n-  ret->succ->probability = REG_BR_PROB_BASE;\n-  ret->succ->count = count;\n+  EDGE_SUCC (ret, 0)->probability = REG_BR_PROB_BASE;\n+  EDGE_SUCC (ret, 0)->count = count;\n \n   if (dom_computed[CDI_DOMINATORS])\n-    set_immediate_dominator (CDI_DOMINATORS, ret, ret->pred->src);\n+    set_immediate_dominator (CDI_DOMINATORS, ret, EDGE_PRED (ret, 0)->src);\n \n   if (dom_computed[CDI_DOMINATORS] >= DOM_NO_FAST_QUERY)\n     {\n@@ -410,21 +413,22 @@ split_edge (edge e)\n \t ret, provided that all other predecessors of e->dest are\n \t dominated by e->dest.  */\n \n-      if (get_immediate_dominator (CDI_DOMINATORS, ret->succ->dest)\n-\t  == ret->pred->src)\n+      if (get_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (ret, 0)->dest)\n+\t  == EDGE_PRED (ret, 0)->src)\n \t{\n-\t  for (f = ret->succ->dest->pred; f; f = f->pred_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (f, ei, EDGE_SUCC (ret, 0)->dest->preds)\n \t    {\n-\t      if (f == ret->succ)\n+\t      if (f == EDGE_SUCC (ret, 0))\n \t\tcontinue;\n \n \t      if (!dominated_by_p (CDI_DOMINATORS, f->src,\n-\t\t\t\t   ret->succ->dest))\n+\t\t\t\t   EDGE_SUCC (ret, 0)->dest))\n \t\tbreak;\n \t    }\n \n \t  if (!f)\n-\t    set_immediate_dominator (CDI_DOMINATORS, ret->succ->dest, ret);\n+\t    set_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (ret, 0)->dest, ret);\n \t}\n     };\n \n@@ -500,6 +504,7 @@ void\n merge_blocks (basic_block a, basic_block b)\n {\n   edge e;\n+  edge_iterator ei;\n \n   if (!cfg_hooks->merge_blocks)\n     internal_error (\"%s does not support merge_blocks.\", cfg_hooks->name);\n@@ -510,17 +515,18 @@ merge_blocks (basic_block a, basic_block b)\n      partway though the merge of blocks for conditional_execution we'll\n      be merging a TEST block with THEN and ELSE successors.  Free the\n      whole lot of them and hope the caller knows what they're doing.  */\n-  while (a->succ)\n-    remove_edge (a->succ);\n+\n+  while (EDGE_COUNT (a->succs) != 0)\n+   remove_edge (EDGE_SUCC (a, 0));\n \n   /* Adjust the edges out of B for the new owner.  */\n-  for (e = b->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, b->succs)\n     e->src = a;\n-  a->succ = b->succ;\n+  a->succs = b->succs;\n   a->flags |= b->flags;\n \n   /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n-  b->pred = b->succ = NULL;\n+  b->preds = b->succs = NULL;\n   a->global_live_at_end = b->global_live_at_end;\n \n   if (dom_computed[CDI_DOMINATORS])\n@@ -542,7 +548,8 @@ edge\n make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \t\t      void (*new_bb_cbk) (basic_block))\n {\n-  edge e, next_e, fallthru;\n+  edge e, fallthru;\n+  edge_iterator ei;\n   basic_block dummy, jump;\n \n   if (!cfg_hooks->make_forwarder_block)\n@@ -554,11 +561,13 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   bb = fallthru->dest;\n \n   /* Redirect back edges we want to keep.  */\n-  for (e = dummy->pred; e; e = next_e)\n+  for (ei = ei_start (dummy->preds); (e = ei_safe_edge (ei)); )\n     {\n-      next_e = e->pred_next;\n       if (redirect_edge_p (e))\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       dummy->frequency -= EDGE_FREQUENCY (e);\n       dummy->count -= e->count;\n@@ -630,12 +639,14 @@ tidy_fallthru_edges (void)\n \t merge the flags for the duplicate edges.  So we do not want to\n \t check that the edge is not a FALLTHRU edge.  */\n \n-      if ((s = b->succ) != NULL\n-\t  && ! (s->flags & EDGE_COMPLEX)\n-\t  && s->succ_next == NULL\n-\t  && s->dest == c\n-\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n-\ttidy_fallthru_edge (s);\n+      if (EDGE_COUNT (b->succs) == 1)\n+\t{\n+\t  s = EDGE_SUCC (b, 0);\n+\t  if (! (s->flags & EDGE_COMPLEX)\n+\t      && s->dest == c\n+\t      && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n+\t    tidy_fallthru_edge (s);\n+\t}\n     }\n }\n \n@@ -645,6 +656,7 @@ bool\n can_duplicate_block_p (basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n \n   if (!cfg_hooks->can_duplicate_block_p)\n     internal_error (\"%s does not support can_duplicate_block_p.\",\n@@ -655,7 +667,7 @@ can_duplicate_block_p (basic_block bb)\n \n   /* Duplicating fallthru block to exit would require adding a jump\n      and splitting the real last BB.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n        return false;\n \n@@ -671,14 +683,15 @@ duplicate_block (basic_block bb, edge e)\n   edge s, n;\n   basic_block new_bb;\n   gcov_type new_count = e ? e->count : 0;\n+  edge_iterator ei;\n \n   if (!cfg_hooks->duplicate_block)\n     internal_error (\"%s does not support duplicate_block.\",\n \t\t    cfg_hooks->name);\n \n   if (bb->count < new_count)\n     new_count = bb->count;\n-  gcc_assert (bb->pred);\n+  gcc_assert (EDGE_COUNT (bb->preds) > 0);\n #ifdef ENABLE_CHECKING\n   gcc_assert (can_duplicate_block_p (bb));\n #endif\n@@ -687,7 +700,7 @@ duplicate_block (basic_block bb, edge e)\n \n   new_bb->loop_depth = bb->loop_depth;\n   new_bb->flags = bb->flags;\n-  for (s = bb->succ; s; s = s->succ_next)\n+  FOR_EACH_EDGE (s, ei, bb->succs)\n     {\n       /* Since we are creating edges from a new block to successors\n \t of another block (which therefore are known to be disjoint), there"}, {"sha": "2d88a376b2e6b5668fb84ab0c27a075681e0979c", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -632,14 +632,16 @@ fixup_reorder_chain (void)\n       rtx bb_end_insn;\n       basic_block nb;\n       basic_block old_bb;\n+      edge_iterator ei;\n \n-      if (bb->succ == NULL)\n+      if (EDGE_COUNT (bb->succs) == 0)\n \tcontinue;\n \n       /* Find the old fallthru edge, and another non-EH edge for\n \t a taken jump.  */\n       e_taken = e_fall = NULL;\n-      for (e = bb->succ; e ; e = e->succ_next)\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  e_fall = e;\n \telse if (! (e->flags & EDGE_EH))\n@@ -790,11 +792,11 @@ fixup_reorder_chain (void)\n \t  /* Make sure new bb is tagged for correct section (same as\n \t     fall-thru source, since you cannot fall-throu across\n \t     section boundaries).  */\n-\t  BB_COPY_PARTITION (e_fall->src, bb->pred->src);\n+\t  BB_COPY_PARTITION (e_fall->src, EDGE_PRED (bb, 0)->src);\n \t  if (flag_reorder_blocks_and_partition\n \t      && targetm.have_named_sections)\n \t    {\n-\t      if (BB_PARTITION (bb->pred->src) == BB_COLD_PARTITION)\n+\t      if (BB_PARTITION (EDGE_PRED (bb, 0)->src) == BB_COLD_PARTITION)\n \t\t{\n \t\t  rtx new_note;\n \t\t  rtx note = BB_HEAD (e_fall->src);\n@@ -810,7 +812,7 @@ fixup_reorder_chain (void)\n \t\t}\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-\t\t  && (bb->succ->flags & EDGE_CROSSING))\n+  \t\t  && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t    }\n@@ -860,8 +862,12 @@ fixup_reorder_chain (void)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n-      for (e = bb->succ; e && !(e->flags & EDGE_FALLTHRU); e = e->succ_next)\n-\tcontinue;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  break;\n+\n       if (e && !can_fallthru (e->src, e->dest))\n \tforce_nonfallthru (e);\n     }\n@@ -916,14 +922,15 @@ static void\n fixup_fallthru_exit_predecessor (void)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block bb = NULL;\n \n   /* This transformation is not valid before reload, because we might\n      separate a call from the instruction that copies the return\n      value.  */\n   gcc_assert (reload_completed);\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       bb = e->src;\n \n@@ -1225,7 +1232,8 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n   for (i = 0; i < n; i++)\n     {\n       /* In case we should redirect abnormal edge during duplication, fail.  */\n-      for (e = bbs[i]->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n \tif ((e->flags & EDGE_ABNORMAL)\n \t    && e->dest->rbi->duplicated)\n \t  {\n@@ -1307,10 +1315,11 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n     new_edges[j] = NULL;\n   for (i = 0; i < n; i++)\n     {\n+      edge_iterator ei;\n       new_bb = new_bbs[i];\n       bb = bbs[i];\n \n-      for (e = new_bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, new_bb->succs)\n \t{\n \t  for (j = 0; j < n_edges; j++)\n \t    if (edges[j] && edges[j]->src == bb && edges[j]->dest == e->dest)"}, {"sha": "a38af1643ae1798c812baa70f57baaeee26ac89d", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 62, "deletions": 42, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -64,9 +64,10 @@ flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n   FOR_EACH_BB (bb)\n     {\n       edge succ;\n+      edge_iterator ei;\n \n       fprintf (file, \";; %d succs { \", bb->index);\n-      for (succ = bb->succ; succ; succ = succ->succ_next)\n+      FOR_EACH_EDGE (succ, ei, bb->succs)\n \tfprintf (file, \"%d \", succ->dest->index);\n       fprintf (file, \"}\\n\");\n     }\n@@ -242,10 +243,11 @@ static void\n flow_loop_entry_edges_find (struct loop *loop)\n {\n   edge e;\n+  edge_iterator ei;\n   int num_entries;\n \n   num_entries = 0;\n-  for (e = loop->header->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (flow_loop_outside_edge_p (loop, e))\n \tnum_entries++;\n@@ -256,7 +258,7 @@ flow_loop_entry_edges_find (struct loop *loop)\n   loop->entry_edges = xmalloc (num_entries * sizeof (edge *));\n \n   num_entries = 0;\n-  for (e = loop->header->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (flow_loop_outside_edge_p (loop, e))\n \tloop->entry_edges[num_entries++] = e;\n@@ -284,8 +286,9 @@ flow_loop_exit_edges_find (struct loop *loop)\n   bbs = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n+      edge_iterator ei;\n       node = bbs[i];\n-      for (e = node->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, node->succs)\n \t{\n \t  basic_block dest = e->dest;\n \n@@ -306,8 +309,9 @@ flow_loop_exit_edges_find (struct loop *loop)\n   num_exits = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n+      edge_iterator ei;\n       node = bbs[i];\n-      for (e = node->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, node->succs)\n \t{\n \t  basic_block dest = e->dest;\n \n@@ -348,10 +352,11 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \t{\n \t  basic_block node;\n \t  edge e;\n+\t  edge_iterator ei;\n \n \t  node = stack[--sp];\n \n-\t  for (e = node->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, node->preds)\n \t    {\n \t      basic_block ancestor = e->src;\n \n@@ -390,9 +395,10 @@ mark_single_exit_loops (struct loops *loops)\n \n   FOR_EACH_BB (bb)\n     {\n+      edge_iterator ei;\n       if (bb->loop_father == loops->tree_root)\n \tcontinue;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR)\n \t    continue;\n@@ -407,7 +413,7 @@ mark_single_exit_loops (struct loops *loops)\n \t      /* If we have already seen an exit, mark this by the edge that\n \t\t surely does not occur as any exit.  */\n \t      if (loop->single_exit)\n-\t\tloop->single_exit = ENTRY_BLOCK_PTR->succ;\n+\t\tloop->single_exit = EDGE_SUCC (ENTRY_BLOCK_PTR, 0);\n \t      else\n \t\tloop->single_exit = e;\n \t    }\n@@ -420,7 +426,7 @@ mark_single_exit_loops (struct loops *loops)\n       if (!loop)\n \tcontinue;\n \n-      if (loop->single_exit == ENTRY_BLOCK_PTR->succ)\n+      if (loop->single_exit == EDGE_SUCC (ENTRY_BLOCK_PTR, 0))\n \tloop->single_exit = NULL;\n     }\n \n@@ -448,17 +454,18 @@ flow_loop_pre_header_scan (struct loop *loop)\n   /* Count number of edges along trace from loop header to\n      root of pre-header extended basic block.  Usually this is\n      only one or two edges.  */\n-  for (num = 1; ebb->pred->src != ENTRY_BLOCK_PTR && ! ebb->pred->pred_next;\n+  for (num = 1;\n+       EDGE_PRED (ebb, 0)->src != ENTRY_BLOCK_PTR && EDGE_COUNT (ebb->preds) == 1;\n        num++)\n-    ebb = ebb->pred->src;\n+    ebb = EDGE_PRED (ebb, 0)->src;\n \n   loop->pre_header_edges = xmalloc (num * sizeof (edge));\n   loop->num_pre_header_edges = num;\n \n   /* Store edges in order that they are followed.  The source of the first edge\n      is the root node of the pre-header extended basic block and the\n      destination of the last last edge is the loop header.  */\n-  for (e = loop->entry_edges[0]; num; e = e->src->pred)\n+  for (e = loop->entry_edges[0]; num; e = EDGE_PRED (e->src, 0))\n     loop->pre_header_edges[--num] = e;\n }\n \n@@ -470,11 +477,12 @@ flow_loop_pre_header_find (basic_block header)\n {\n   basic_block pre_header;\n   edge e;\n+  edge_iterator ei;\n \n   /* If block p is a predecessor of the header and is the only block\n      that the header does not dominate, then it is the pre-header.  */\n   pre_header = NULL;\n-  for (e = header->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, header->preds)\n     {\n       basic_block node = e->src;\n \n@@ -630,9 +638,9 @@ update_latch_info (basic_block jump)\n {\n   alloc_aux_for_block (jump, sizeof (int));\n   HEADER_BLOCK (jump) = 0;\n-  alloc_aux_for_edge (jump->pred, sizeof (int));\n-  LATCH_EDGE (jump->pred) = 0;\n-  set_immediate_dominator (CDI_DOMINATORS, jump, jump->pred->src);\n+  alloc_aux_for_edge (EDGE_PRED (jump, 0), sizeof (int));\n+  LATCH_EDGE (EDGE_PRED (jump, 0)) = 0;\n+  set_immediate_dominator (CDI_DOMINATORS, jump, EDGE_PRED (jump, 0)->src);\n }\n \n /* A callback for make_forwarder block, to redirect all edges except for\n@@ -670,10 +678,11 @@ canonicalize_loop_headers (void)\n   /* Split blocks so that each loop has only single latch.  */\n   FOR_EACH_BB (header)\n     {\n+      edge_iterator ei;\n       int num_latches = 0;\n       int have_abnormal_edge = 0;\n \n-      for (e = header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \t{\n \t  basic_block latch = e->src;\n \n@@ -693,16 +702,16 @@ canonicalize_loop_headers (void)\n \tHEADER_BLOCK (header) = num_latches;\n     }\n \n-  if (HEADER_BLOCK (ENTRY_BLOCK_PTR->succ->dest))\n+  if (HEADER_BLOCK (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest))\n     {\n       basic_block bb;\n \n       /* We could not redirect edges freely here. On the other hand,\n \t we can simply split the edge from entry block.  */\n-      bb = split_edge (ENTRY_BLOCK_PTR->succ);\n+      bb = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n \n-      alloc_aux_for_edge (bb->succ, sizeof (int));\n-      LATCH_EDGE (bb->succ) = 0;\n+      alloc_aux_for_edge (EDGE_SUCC (bb, 0), sizeof (int));\n+      LATCH_EDGE (EDGE_SUCC (bb, 0)) = 0;\n       alloc_aux_for_block (bb, sizeof (int));\n       HEADER_BLOCK (bb) = 0;\n     }\n@@ -711,6 +720,7 @@ canonicalize_loop_headers (void)\n     {\n       int max_freq, is_heavy;\n       edge heavy, tmp_edge;\n+      edge_iterator ei;\n \n       if (HEADER_BLOCK (header) <= 1)\n \tcontinue;\n@@ -719,11 +729,11 @@ canonicalize_loop_headers (void)\n       is_heavy = 1;\n       heavy = NULL;\n       max_freq = 0;\n-      for (e = header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \tif (LATCH_EDGE (e) &&\n \t    EDGE_FREQUENCY (e) > max_freq)\n \t  max_freq = EDGE_FREQUENCY (e);\n-      for (e = header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \tif (LATCH_EDGE (e) &&\n \t    EDGE_FREQUENCY (e) >= max_freq / HEAVY_EDGE_RATIO)\n \t  {\n@@ -817,19 +827,20 @@ flow_loops_find (struct loops *loops, int flags)\n   num_loops = 0;\n   FOR_EACH_BB (header)\n     {\n+      edge_iterator ei;\n       int more_latches = 0;\n \n       header->loop_depth = 0;\n \n       /* If we have an abnormal predecessor, do not consider the\n \t loop (not worth the problems).  */\n-      for (e = header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \tif (e->flags & EDGE_ABNORMAL)\n \t  break;\n       if (e)\n \tcontinue;\n \n-      for (e = header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \t{\n \t  basic_block latch = e->src;\n \n@@ -893,6 +904,7 @@ flow_loops_find (struct loops *loops, int flags)\n       for (b = 0; b < n_basic_blocks; b++)\n \t{\n \t  struct loop *loop;\n+\t  edge_iterator ei;\n \n \t  /* Search the nodes of the CFG in reverse completion order\n \t     so that we can find outer loops first.  */\n@@ -908,7 +920,7 @@ flow_loops_find (struct loops *loops, int flags)\n \t  num_loops++;\n \n \t  /* Look for the latch for this header block.  */\n-\t  for (e = header->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, header->preds)\n \t    {\n \t      basic_block latch = e->src;\n \n@@ -1096,6 +1108,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   while (i < loop->num_nodes)\n     {\n       edge e;\n+      edge_iterator ei;\n       \n       if (!bitmap_bit_p (visited, bb->index))\n         { \n@@ -1104,7 +1117,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n           blocks[i++] = bb;\n         }\n       \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n         { \n           if (flow_bb_inside_loop_p (loop, e->dest))\n             { \n@@ -1132,20 +1145,21 @@ get_loop_exit_edges (const struct loop *loop, unsigned int *n_edges)\n   edge *edges, e;\n   unsigned i, n;\n   basic_block * body;\n+  edge_iterator ei;\n \n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   body = get_loop_body (loop);\n   n = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n-    for (e = body[i]->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, body[i]->succs)\n       if (!flow_bb_inside_loop_p (loop, e->dest))\n \tn++;\n   edges = xmalloc (n * sizeof (edge));\n   *n_edges = n;\n   n = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n-    for (e = body[i]->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, body[i]->succs)\n       if (!flow_bb_inside_loop_p (loop, e->dest))\n \tedges[n++] = e;\n   free (body);\n@@ -1166,7 +1180,7 @@ num_loop_branches (const struct loop *loop)\n   body = get_loop_body (loop);\n   n = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n-    if (body[i]->succ && body[i]->succ->succ_next)\n+    if (EDGE_COUNT (body[i]->succs) >= 2)\n       n++;\n   free (body);\n \n@@ -1317,21 +1331,19 @@ verify_loop_structure (struct loops *loops)\n \tcontinue;\n \n       if ((loops->state & LOOPS_HAVE_PREHEADERS)\n-\t  && (!loop->header->pred->pred_next\n-\t      || loop->header->pred->pred_next->pred_next))\n+\t  && EDGE_COUNT (loop->header->preds) != 2)\n \t{\n \t  error (\"Loop %d's header does not have exactly 2 entries.\", i);\n \t  err = 1;\n \t}\n       if (loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n \t{\n-\t  if (!loop->latch->succ\n-\t      || loop->latch->succ->succ_next)\n+\t  if (EDGE_COUNT (loop->latch->succs) != 1)\n \t    {\n \t      error (\"Loop %d's latch does not have exactly 1 successor.\", i);\n \t      err = 1;\n \t    }\n-\t  if (loop->latch->succ->dest != loop->header)\n+\t  if (EDGE_SUCC (loop->latch, 0)->dest != loop->header)\n \t    {\n \t      error (\"Loop %d's latch does not have header as successor.\", i);\n \t      err = 1;\n@@ -1362,11 +1374,12 @@ verify_loop_structure (struct loops *loops)\n       irreds = sbitmap_alloc (last_basic_block);\n       FOR_EACH_BB (bb)\n \t{\n+\t  edge_iterator ei;\n \t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n \t    SET_BIT (irreds, bb->index);\n \t  else\n \t    RESET_BIT (irreds, bb->index);\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t      e->flags |= EDGE_ALL_FLAGS + 1;\n \t}\n@@ -1377,6 +1390,8 @@ verify_loop_structure (struct loops *loops)\n       /* Compare.  */\n       FOR_EACH_BB (bb)\n \t{\n+\t  edge_iterator ei;\n+\n \t  if ((bb->flags & BB_IRREDUCIBLE_LOOP)\n \t      && !TEST_BIT (irreds, bb->index))\n \t    {\n@@ -1389,7 +1404,7 @@ verify_loop_structure (struct loops *loops)\n \t      error (\"Basic block %d should not be marked irreducible.\", bb->index);\n \t      err = 1;\n \t    }\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if ((e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t\t  && !(e->flags & (EDGE_ALL_FLAGS + 1)))\n@@ -1417,9 +1432,10 @@ verify_loop_structure (struct loops *loops)\n       memset (sizes, 0, sizeof (unsigned) * loops->num);\n       FOR_EACH_BB (bb)\n \t{\n+\t  edge_iterator ei;\n \t  if (bb->loop_father == loops->tree_root)\n \t    continue;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n@@ -1482,9 +1498,11 @@ edge\n loop_latch_edge (const struct loop *loop)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next)\n-    continue;\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+    if (e->src == loop->latch)\n+      break;\n \n   return e;\n }\n@@ -1494,9 +1512,11 @@ edge\n loop_preheader_edge (const struct loop *loop)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = loop->header->pred; e->src == loop->latch; e = e->pred_next)\n-    continue;\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+    if (e->src != loop->latch)\n+      break;\n \n   return e;\n }"}, {"sha": "87c85e329d8314bd61485d47dfe587dd0d60bc90", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -267,6 +267,7 @@ mark_irreducible_loops (struct loops *loops)\n {\n   basic_block act;\n   edge e;\n+  edge_iterator ei;\n   int i, src, dest;\n   struct graph *g;\n   int *queue1 = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n@@ -278,15 +279,15 @@ mark_irreducible_loops (struct loops *loops)\n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n       act->flags &= ~BB_IRREDUCIBLE_LOOP;\n-      for (e = act->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, act->succs)\n \te->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   /* Create the edge lists.  */\n   g = new_graph (last_basic_block + loops->num);\n \n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-    for (e = act->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, act->succs)\n       {\n         /* Ignore edges to exit.  */\n         if (e->dest == EXIT_BLOCK_PTR)\n@@ -415,6 +416,7 @@ unsigned\n expected_loop_iterations (const struct loop *loop)\n {\n   edge e;\n+  edge_iterator ei;\n \n   if (loop->header->count)\n     {\n@@ -423,7 +425,7 @@ expected_loop_iterations (const struct loop *loop)\n       count_in = 0;\n       count_latch = 0;\n \n-      for (e = loop->header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, loop->header->preds)\n \tif (e->src == loop->latch)\n \t  count_latch = e->count;\n \telse\n@@ -444,7 +446,7 @@ expected_loop_iterations (const struct loop *loop)\n       freq_in = 0;\n       freq_latch = 0;\n \n-      for (e = loop->header->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, loop->header->preds)\n \tif (e->src == loop->latch)\n \t  freq_latch = EDGE_FREQUENCY (e);\n \telse"}, {"sha": "e5ec7bddaabddec37a757555986222075c3d4b97", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -96,7 +96,7 @@ remove_bbs (basic_block *bbs, int nbbs)\n static int\n find_path (edge e, basic_block **bbs)\n {\n-  gcc_assert (!e->dest->pred->pred_next);\n+  gcc_assert (EDGE_COUNT (e->dest->preds) <= 1);\n \n   /* Find bbs in the path.  */\n   *bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n@@ -115,9 +115,10 @@ static bool\n fix_bb_placement (struct loops *loops, basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n   struct loop *loop = loops->tree_root, *act;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n@@ -180,6 +181,7 @@ fix_bb_placements (struct loops *loops, basic_block from)\n \n   while (qbeg != qend)\n     {\n+      edge_iterator ei;\n       from = *qbeg;\n       qbeg++;\n       if (qbeg == qtop)\n@@ -200,7 +202,7 @@ fix_bb_placements (struct loops *loops, basic_block from)\n \t}\n \n       /* Something has changed, insert predecessors into queue.  */\n-      for (e = from->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, from->preds)\n \t{\n \t  basic_block pred = e->src;\n \t  struct loop *nca;\n@@ -262,10 +264,11 @@ fix_irreducible_loops (basic_block from)\n \n   while (stack_top)\n     {\n+      edge_iterator ei;\n       bb = stack[--stack_top];\n       RESET_BIT (on_stack, bb->index);\n \n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t  break;\n       if (e)\n@@ -276,13 +279,10 @@ fix_irreducible_loops (basic_block from)\n \tedges = get_loop_exit_edges (bb->loop_father, &n_edges);\n       else\n \t{\n-\t  n_edges = 0;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n-\t    n_edges++;\n+\t  n_edges = EDGE_COUNT (bb->succs);\n \t  edges = xmalloc (n_edges * sizeof (edge));\n-\t  n_edges = 0;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n-\t    edges[n_edges++] = e;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    edges[ei.index] = e;\n \t}\n \n       for (i = 0; i < n_edges; i++)\n@@ -329,8 +329,8 @@ remove_path (struct loops *loops, edge e)\n      e, but we only have basic block dominators.  This is easy to\n      fix -- when e->dest has exactly one predecessor, this corresponds\n      to blocks dominated by e->dest, if not, split the edge.  */\n-  if (e->dest->pred->pred_next)\n-    e = loop_split_edge_with (e, NULL_RTX)->pred;\n+  if (EDGE_COUNT (e->dest->preds) > 1)\n+    e = EDGE_PRED (loop_split_edge_with (e, NULL_RTX), 0);\n \n   /* It may happen that by removing path we remove one or more loops\n      we belong to.  In this case first unloop the loops, then proceed\n@@ -354,8 +354,9 @@ remove_path (struct loops *loops, edge e)\n     SET_BIT (seen, rem_bbs[i]->index);\n   for (i = 0; i < nrem; i++)\n     {\n+      edge_iterator ei;\n       bb = rem_bbs[i];\n-      for (ae = rem_bbs[i]->succ; ae; ae = ae->succ_next)\n+      FOR_EACH_EDGE (ae, ei, rem_bbs[i]->succs)\n \tif (ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index))\n \t  {\n \t    SET_BIT (seen, ae->dest->index);\n@@ -457,9 +458,10 @@ scale_bbs_frequencies (basic_block *bbs, int nbbs, int num, int den)\n \n   for (i = 0; i < nbbs; i++)\n     {\n+      edge_iterator ei;\n       bbs[i]->frequency = (bbs[i]->frequency * num) / den;\n       bbs[i]->count = RDIV (bbs[i]->count * num, den);\n-      for (e = bbs[i]->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n \te->count = (e->count * num) /den;\n     }\n }\n@@ -498,14 +500,15 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   int freq, prob, tot_prob;\n   gcov_type cnt;\n   edge e;\n+  edge_iterator ei;\n \n   loop->header = header_edge->dest;\n   loop->latch = latch_edge->src;\n \n   freq = EDGE_FREQUENCY (header_edge);\n   cnt = header_edge->count;\n-  prob = switch_bb->succ->probability;\n-  tot_prob = prob + switch_bb->succ->succ_next->probability;\n+  prob = EDGE_SUCC (switch_bb, 0)->probability;\n+  tot_prob = prob + EDGE_SUCC (switch_bb, 1)->probability;\n   if (tot_prob == 0)\n     tot_prob = 1;\n \n@@ -537,7 +540,7 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   /* Fix frequencies.  */\n   switch_bb->frequency = freq;\n   switch_bb->count = cnt;\n-  for (e = switch_bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, switch_bb->succs)\n     e->count = (switch_bb->count * e->probability) / REG_BR_PROB_BASE;\n   scale_loop_frequencies (loop, prob, tot_prob);\n   scale_loop_frequencies (succ_bb->loop_father, tot_prob - prob, tot_prob);\n@@ -617,7 +620,7 @@ unloop (struct loops *loops, struct loop *loop)\n   loops->parray[loop->num] = NULL;\n   flow_loop_free (loop);\n \n-  remove_edge (latch->succ);\n+  remove_edge (EDGE_SUCC (latch, 0));\n   fix_bb_placements (loops, latch);\n \n   /* If the loop was inside an irreducible region, we would have to somehow\n@@ -642,11 +645,12 @@ fix_loop_placement (struct loop *loop)\n   basic_block *body;\n   unsigned i;\n   edge e;\n+  edge_iterator ei;\n   struct loop *father = loop->pred[0], *act;\n \n   body = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n-    for (e = body[i]->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, body[i]->succs)\n       if (!flow_bb_inside_loop_p (loop, e->dest))\n \t{\n \t  act = find_common_loop (loop, e->dest->loop_father);\n@@ -772,16 +776,16 @@ loop_delete_branch_edge (edge e, int really_delete)\n   int irr;\n   edge snd;\n \n-  gcc_assert (src->succ->succ_next);\n+  gcc_assert (EDGE_COUNT (src->succs) > 1);\n   \n   /* Cannot handle more than two exit edges.  */\n-  if (src->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (src->succs) > 2)\n     return false;\n   /* And it must be just a simple branch.  */\n   if (!any_condjump_p (BB_END (src)))\n     return false;\n \n-  snd = e == src->succ ? src->succ->succ_next : src->succ;\n+  snd = e == EDGE_SUCC (src, 0) ? EDGE_SUCC (src, 1) : EDGE_SUCC (src, 0);\n   newdest = snd->dest;\n   if (newdest == EXIT_BLOCK_PTR)\n     return false;\n@@ -795,8 +799,8 @@ loop_delete_branch_edge (edge e, int really_delete)\n \n   if (!redirect_edge_and_branch (e, newdest))\n     return false;\n-  src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  src->succ->flags |= irr;\n+  EDGE_SUCC (src, 0)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  EDGE_SUCC (src, 0)->flags |= irr;\n   \n   return true;\n }\n@@ -1003,11 +1007,12 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t    new_bbs[i]->rbi->duplicated = 1;\n \t  for (i = 0; i < n; i++)\n \t    {\n+\t      edge_iterator ei;\n \t      new_bb = new_bbs[i];\n \t      if (new_bb->loop_father == target)\n \t\tnew_bb->flags |= BB_IRREDUCIBLE_LOOP;\n \n-\t      for (ae = new_bb->succ; ae; ae = ae->succ_next)\n+\t      FOR_EACH_EDGE (ae, ei, new_bb->succs)\n \t\tif (ae->dest->rbi->duplicated\n \t\t    && (ae->src->loop_father == target\n \t\t\t|| ae->dest->loop_father == target))\n@@ -1113,10 +1118,10 @@ mfb_keep_just (edge e)\n static void\n mfb_update_loops (basic_block jump)\n {\n-  struct loop *loop = jump->succ->dest->loop_father;\n+  struct loop *loop = EDGE_SUCC (jump, 0)->dest->loop_father;\n \n   if (dom_computed[CDI_DOMINATORS])\n-    set_immediate_dominator (CDI_DOMINATORS, jump, jump->pred->src);\n+    set_immediate_dominator (CDI_DOMINATORS, jump, EDGE_PRED (jump, 0)->src);\n   add_bb_to_loop (jump, loop);\n   loop->latch = jump;\n }\n@@ -1134,10 +1139,11 @@ create_preheader (struct loop *loop, int flags)\n   struct loop *cloop, *ploop;\n   int nentry = 0;\n   bool irred = false;\n+  edge_iterator ei;\n \n   cloop = loop->outer;\n \n-  for (e = loop->header->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (e->src == loop->latch)\n \tcontinue;\n@@ -1147,9 +1153,11 @@ create_preheader (struct loop *loop, int flags)\n   gcc_assert (nentry);\n   if (nentry == 1)\n     {\n-      for (e = loop->header->pred; e->src == loop->latch; e = e->pred_next);\n-      if (!(flags & CP_SIMPLE_PREHEADERS)\n-\t  || !e->src->succ->succ_next)\n+      FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\tif (e->src != loop->latch)\n+\t  break;\n+\n+      if (!(flags & CP_SIMPLE_PREHEADERS) || EDGE_COUNT (e->src->succs) == 1)\n \treturn NULL;\n     }\n \n@@ -1167,7 +1175,7 @@ create_preheader (struct loop *loop, int flags)\n \n   /* Reorganize blocks so that the preheader is not stuck in the middle of the\n      loop.  */\n-  for (e = dummy->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, dummy->preds)\n     if (e->src != loop->latch)\n       break;\n   move_block_after (dummy, e->src);\n@@ -1178,7 +1186,7 @@ create_preheader (struct loop *loop, int flags)\n   if (irred)\n     {\n       dummy->flags |= BB_IRREDUCIBLE_LOOP;\n-      dummy->succ->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (dummy, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   if (dump_file)\n@@ -1210,13 +1218,14 @@ force_single_succ_latches (struct loops *loops)\n \n   for (i = 1; i < loops->num; i++)\n     {\n+      edge_iterator ei;\n       loop = loops->parray[i];\n-      if (loop->latch != loop->header\n-\t  && !loop->latch->succ->succ_next)\n+      if (loop->latch != loop->header && EDGE_COUNT (loop->latch->succs) == 1)\n \tcontinue;\n \n-      for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next)\n-\tcontinue;\n+      FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\tif (e->src == loop->latch)\n+\t  break;\n \n       loop_split_edge_with (e, NULL_RTX);\n     }\n@@ -1245,7 +1254,7 @@ loop_split_edge_with (edge e, rtx insns)\n   add_bb_to_loop (new_bb, loop_c);\n   new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n \n-  new_e = new_bb->succ;\n+  new_e = EDGE_SUCC (new_bb, 0);\n   if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n     {\n       new_bb->flags |= BB_IRREDUCIBLE_LOOP;\n@@ -1323,9 +1332,9 @@ create_loop_notes (void)\n \t\t      && onlyjump_p (insn))\n \t\t    {\n \t\t      pbb = BLOCK_FOR_INSN (insn);\n-\t\t      gcc_assert (pbb && pbb->succ && !pbb->succ->succ_next);\n+\t\t      gcc_assert (pbb && EDGE_COUNT (pbb->succs) == 1);\n \n-\t\t      if (!flow_bb_inside_loop_p (loop, pbb->succ->dest))\n+\t\t      if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (pbb, 0)->dest))\n \t\t\tinsn = BB_HEAD (first[loop->num]);\n \t\t    }\n \t\t  else"}, {"sha": "bba68819a80c32726f8a8f6e83247f83cbb25ee9", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 163, "deletions": 95, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -459,6 +459,7 @@ rtl_split_block (basic_block bb, void *insnp)\n   basic_block new_bb;\n   rtx insn = insnp;\n   edge e;\n+  edge_iterator ei;\n \n   if (!insn)\n     {\n@@ -482,9 +483,9 @@ rtl_split_block (basic_block bb, void *insnp)\n   BB_END (bb) = insn;\n \n   /* Redirect the outgoing edges.  */\n-  new_bb->succ = bb->succ;\n-  bb->succ = NULL;\n-  for (e = new_bb->succ; e; e = e->succ_next)\n+  new_bb->succs = bb->succs;\n+  bb->succs = NULL;\n+  FOR_EACH_EDGE (e, ei, new_bb->succs)\n     e->src = new_bb;\n \n   if (bb->global_live_at_start)\n@@ -625,10 +626,12 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n-  return (a->succ && !a->succ->succ_next && a->succ->dest == b\n-\t  && !b->pred->pred_next && a != b\n+  return (EDGE_COUNT (a->succs) == 1\n+\t  && EDGE_SUCC (a, 0)->dest == b\n+\t  && EDGE_COUNT (b->preds) == 1\n+\t  && a != b\n \t  /* Must be simple edge.  */\n-\t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && !(EDGE_SUCC (a, 0)->flags & EDGE_COMPLEX)\n \t  && a->next_bb == b\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n@@ -668,7 +671,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   edge tmp;\n   rtx set;\n   int fallthru = 0;\n-\n+  edge_iterator ei;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -686,7 +689,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     return NULL;\n \n   /* Verify that all targets will be TARGET.  */\n-  for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n+  FOR_EACH_EDGE (tmp, ei, src->succs)\n     if (tmp->dest != target && tmp != e)\n       break;\n \n@@ -814,9 +817,10 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     }\n \n   /* Keep only one edge out and set proper flags.  */\n-  while (src->succ->succ_next)\n-    remove_edge (src->succ);\n-  e = src->succ;\n+  while (EDGE_COUNT (src->succs) > 1)\n+    remove_edge (e);\n+\n+  e = EDGE_SUCC (src, 0);\n   if (fallthru)\n     e->flags = EDGE_FALLTHRU;\n   else\n@@ -1040,28 +1044,37 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       if (e->src == ENTRY_BLOCK_PTR)\n \t{\n \t  /* We can't redirect the entry block.  Create an empty block\n-             at the start of the function which we use to add the new\n-             jump.  */\n-\t  edge *pe1;\n-\t  basic_block bb\n-\t    = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n-\n+\t     at the start of the function which we use to add the new\n+\t     jump.  */\n+\t  edge tmp;\n+\t  edge_iterator ei;\n+\t  bool found = false;\n+\t  \n+\t  basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n+\t  \n \t  /* Change the existing edge's source to be the new block, and add\n \t     a new edge from the entry block to the new block.  */\n \t  e->src = bb;\n-\t  for (pe1 = &ENTRY_BLOCK_PTR->succ; *pe1; pe1 = &(*pe1)->succ_next)\n-\t    if (*pe1 == e)\n-\t      {\n-\t\t*pe1 = e->succ_next;\n-\t\tbreak;\n-\t      }\n-\t  e->succ_next = 0;\n-\t  bb->succ = e;\n+\t  for (ei = ei_start (ENTRY_BLOCK_PTR->succs); (tmp = ei_safe_edge (ei)); )\n+\t    {\n+\t      if (tmp == e)\n+\t\t{\n+\t\t  VEC_ordered_remove (edge, ENTRY_BLOCK_PTR->succs, ei.index);\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tei_next (&ei);\n+\t    }\n+\t  \n+\t  gcc_assert (found);\n+\t  \n+\t  VEC_safe_insert (edge, bb->succs, 0, e);\n \t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n \t}\n     }\n \n-  if (e->src->succ->succ_next || abnormal_edge_flags)\n+  if (EDGE_COUNT (e->src->succs) >= 2 || abnormal_edge_flags)\n     {\n       /* Create the new structures.  */\n \n@@ -1113,7 +1126,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t    }\n \t  if (JUMP_P (BB_END (jump_block))\n \t      && !any_condjump_p (BB_END (jump_block))\n-\t      && (jump_block->succ->flags & EDGE_CROSSING))\n+\t      && (EDGE_SUCC (jump_block, 0)->flags & EDGE_CROSSING))\n \t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n \t      (REG_CROSSING_JUMP, NULL_RTX, \n \t       REG_NOTES (BB_END (jump_block)));\n@@ -1193,6 +1206,12 @@ rtl_tidy_fallthru_edge (edge e)\n {\n   rtx q;\n   basic_block b = e->src, c = b->next_bb;\n+  edge e2;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e2, ei, b->succs)\n+    if (e == e2)\n+      break;\n \n   /* ??? In a late-running flow pass, other folks may have deleted basic\n      blocks by nopping out blocks, leaving multiple BARRIERs between here\n@@ -1215,7 +1234,7 @@ rtl_tidy_fallthru_edge (edge e)\n   if (JUMP_P (q)\n       && onlyjump_p (q)\n       && (any_uncondjump_p (q)\n-\t  || (b->succ == e && e->succ_next == NULL)))\n+\t  || (EDGE_SUCC (b, 0) == e && ei.index == EDGE_COUNT (b->succs) - 1)))\n     {\n #ifdef HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n@@ -1303,8 +1322,9 @@ rtl_split_edge (edge edge_in)\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n       edge e;\n+      edge_iterator ei;\n \n-      for (e = edge_in->dest->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, edge_in->dest->preds)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n \n@@ -1518,7 +1538,8 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n   /* Special case -- avoid inserting code between call and storing\n      its return value.  */\n-  if (watch_calls && (e->flags & EDGE_FALLTHRU) && !e->dest->pred->pred_next\n+  if (watch_calls && (e->flags & EDGE_FALLTHRU)\n+      && EDGE_COUNT (e->dest->preds) == 1\n       && e->src != ENTRY_BLOCK_PTR\n       && CALL_P (BB_END (e->src)))\n     {\n@@ -1538,7 +1559,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n     {\n       /* Figure out where to put these things.  If the destination has\n          one predecessor, insert there.  Except for the exit block.  */\n-      if (e->dest->pred->pred_next == NULL && e->dest != EXIT_BLOCK_PTR)\n+      if (EDGE_COUNT (e->dest->preds) == 1 && e->dest != EXIT_BLOCK_PTR)\n \t{\n \t  bb = e->dest;\n \n@@ -1564,7 +1585,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n       /* If the source has one successor and the edge is not abnormal,\n          insert there.  Except for the entry block.  */\n       else if ((e->flags & EDGE_ABNORMAL) == 0\n-\t       && e->src->succ->succ_next == NULL\n+\t       && EDGE_COUNT (e->src->succs) == 1\n \t       && e->src != ENTRY_BLOCK_PTR)\n \t{\n \t  bb = e->src;\n@@ -1619,7 +1640,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      NOTE_BASIC_BLOCK (new_note) = bb;\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-\t\t  && (bb->succ->flags & EDGE_CROSSING))\n+  \t\t  && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t      if (after == bb_note)\n@@ -1645,9 +1666,9 @@ commit_one_edge_insertion (edge e, int watch_calls)\n          for the (single) epilogue, which already has a fallthru edge\n          to EXIT.  */\n \n-      e = bb->succ;\n+      e = EDGE_SUCC (bb, 0);\n       gcc_assert (e->dest == EXIT_BLOCK_PTR\n-\t\t  && !e->succ_next && (e->flags & EDGE_FALLTHRU));\n+\t\t  && EDGE_COUNT (bb->succs) == 1 && (e->flags & EDGE_FALLTHRU));\n \n       e->flags &= ~EDGE_FALLTHRU;\n       emit_barrier_after (last);\n@@ -1677,17 +1698,15 @@ commit_edge_insertions (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      edge e, next;\n+      edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = next)\n-\t{\n-\t  next = e->succ_next;\n-\t  if (e->insns.r)\n-\t    {\n-\t      changed = true;\n-\t      commit_one_edge_insertion (e, false);\n-\t    }\n-\t}\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->insns.r)\n+\t  {\n+\t    changed = true;\n+\t    commit_one_edge_insertion (e, false);\n+\t  }\n     }\n \n   if (!changed)\n@@ -1724,17 +1743,15 @@ commit_edge_insertions_watch_calls (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      edge e, next;\n+      edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = next)\n-\t{\n-\t  next = e->succ_next;\n-\t  if (e->insns.r)\n-\t    {\n-\t      changed = true;\n-\t      commit_one_edge_insertion (e, true);\n-\t    }\n-\t}\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->insns.r)\n+\t  {\n+\t    changed = true;\n+\t    commit_one_edge_insertion (e, true);\n+\t  }\n     }\n \n   if (!changed)\n@@ -1963,10 +1980,11 @@ rtl_verify_flow_info_1 (void)\n       int n_fallthru = 0, n_eh = 0, n_call = 0, n_abnormal = 0, n_branch = 0;\n       edge e, fallthru = NULL;\n       rtx note;\n+      edge_iterator ei;\n \n       if (INSN_P (BB_END (bb))\n \t  && (note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX))\n-\t  && bb->succ && bb->succ->succ_next\n+\t  && EDGE_COUNT (bb->succs) >= 2\n \t  && any_condjump_p (BB_END (bb)))\n \t{\n \t  if (INTVAL (XEXP (note, 0)) != BRANCH_EDGE (bb)->probability\n@@ -1977,7 +1995,7 @@ rtl_verify_flow_info_1 (void)\n \t      err = 1;\n \t    }\n \t}\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    {\n@@ -2144,7 +2162,9 @@ rtl_verify_flow_info (void)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       edge e;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n       if (!e)\n@@ -2258,9 +2278,11 @@ rtl_verify_flow_info (void)\n bool\n purge_dead_edges (basic_block bb)\n {\n-  edge e, next;\n+  edge e;\n   rtx insn = BB_END (bb), note;\n   bool purged = false;\n+  bool found;\n+  edge_iterator ei;\n \n   /* If this instruction cannot trap, remove REG_EH_REGION notes.  */\n   if (NONJUMP_INSN_P (insn)\n@@ -2275,23 +2297,31 @@ purge_dead_edges (basic_block bb)\n     }\n \n   /* Cleanup abnormal edges caused by exceptions or non-local gotos.  */\n-  for (e = bb->succ; e; e = next)\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      next = e->succ_next;\n       if (e->flags & EDGE_EH)\n \t{\n \t  if (can_throw_internal (BB_END (bb)))\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t}\n       else if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n \t  if (CALL_P (BB_END (bb))\n \t      && (! (note = find_reg_note (insn, REG_EH_REGION, NULL))\n \t\t  || INTVAL (XEXP (note, 0)) >= 0))\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t}\n       else\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       remove_edge (e);\n       bb->flags |= BB_DIRTY;\n@@ -2302,6 +2332,7 @@ purge_dead_edges (basic_block bb)\n     {\n       rtx note;\n       edge b,f;\n+      edge_iterator ei;\n \n       /* We do care only about conditional jumps and simplejumps.  */\n       if (!any_condjump_p (insn)\n@@ -2320,10 +2351,8 @@ purge_dead_edges (basic_block bb)\n \t    remove_note (insn, note);\n \t}\n \n-      for (e = bb->succ; e; e = next)\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n-\t  next = e->succ_next;\n-\n \t  /* Avoid abnormal flags to leak from computed jumps turned\n \t     into simplejumps.  */\n \n@@ -2333,22 +2362,32 @@ purge_dead_edges (basic_block bb)\n \t  if ((e->flags & EDGE_FALLTHRU) && any_condjump_p (insn))\n \t    /* A conditional jump can fall through into the next\n \t       block, so we should keep the edge.  */\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t  else if (e->dest != EXIT_BLOCK_PTR\n \t\t   && BB_HEAD (e->dest) == JUMP_LABEL (insn))\n \t    /* If the destination block is the target of the jump,\n \t       keep the edge.  */\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t  else if (e->dest == EXIT_BLOCK_PTR && returnjump_p (insn))\n \t    /* If the destination block is the exit block, and this\n \t       instruction is a return, then keep the edge.  */\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t  else if ((e->flags & EDGE_EH) && can_throw_internal (insn))\n \t    /* Keep the edges that correspond to exceptions thrown by\n \t       this instruction and rematerialize the EDGE_ABNORMAL\n \t       flag we just cleared above.  */\n \t    {\n \t      e->flags |= EDGE_ABNORMAL;\n+\t      ei_next (&ei);\n \t      continue;\n \t    }\n \n@@ -2358,7 +2397,7 @@ purge_dead_edges (basic_block bb)\n \t  remove_edge (e);\n \t}\n \n-      if (!bb->succ || !purged)\n+      if (EDGE_COUNT (bb->succs) == 0 || !purged)\n \treturn purged;\n \n       if (dump_file)\n@@ -2368,10 +2407,10 @@ purge_dead_edges (basic_block bb)\n \treturn purged;\n \n       /* Redistribute probabilities.  */\n-      if (!bb->succ->succ_next)\n+      if (EDGE_COUNT (bb->succs) == 1)\n \t{\n-\t  bb->succ->probability = REG_BR_PROB_BASE;\n-\t  bb->succ->count = bb->count;\n+\t  EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+\t  EDGE_SUCC (bb, 0)->count = bb->count;\n \t}\n       else\n \t{\n@@ -2395,8 +2434,8 @@ purge_dead_edges (basic_block bb)\n \t from non-local gotos and the like.  If there were, we shouldn't\n \t have created the sibcall in the first place.  Second, there\n \t should of course never have been a fallthru edge.  */\n-      gcc_assert (bb->succ && !bb->succ->succ_next);\n-      gcc_assert (bb->succ->flags == (EDGE_SIBCALL | EDGE_ABNORMAL));\n+      gcc_assert (EDGE_COUNT (bb->succs) == 1);\n+      gcc_assert (EDGE_SUCC (bb, 0)->flags == (EDGE_SIBCALL | EDGE_ABNORMAL));\n \n       return 0;\n     }\n@@ -2406,28 +2445,33 @@ purge_dead_edges (basic_block bb)\n      as these are only created by conditional branches.  If we find such an\n      edge we know that there used to be a jump here and can then safely\n      remove all non-fallthru edges.  */\n-  for (e = bb->succ; e && (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU));\n-       e = e->succ_next)\n-    ;\n+  found = false;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (! (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU)))\n+      {\n+\tfound = true;\n+\tbreak;\n+      }\n \n-  if (!e)\n+  if (!found)\n     return purged;\n \n-  for (e = bb->succ; e; e = next)\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      next = e->succ_next;\n       if (!(e->flags & EDGE_FALLTHRU))\n \t{\n \t  bb->flags |= BB_DIRTY;\n \t  remove_edge (e);\n \t  purged = true;\n \t}\n+      else\n+\tei_next (&ei);\n     }\n \n-  gcc_assert (bb->succ && !bb->succ->succ_next);\n+  gcc_assert (EDGE_COUNT (bb->succs) == 1);\n \n-  bb->succ->probability = REG_BR_PROB_BASE;\n-  bb->succ->count = bb->count;\n+  EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+  EDGE_SUCC (bb, 0)->count = bb->count;\n \n   if (dump_file)\n     fprintf (dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n@@ -2543,10 +2587,28 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n          of conditional jump, remove it.  */\n-      if (src->succ->succ_next\n-\t  && !src->succ->succ_next->succ_next)\n+      if (EDGE_COUNT (src->succs) == 2)\n \t{\n-\t  edge s = e->succ_next ? e->succ_next : src->succ;\n+\t  bool found = false;\n+\t  unsigned ix = 0;\n+\t  edge tmp, s;\n+\t  edge_iterator ei;\n+\n+\t  FOR_EACH_EDGE (tmp, ei, src->succs)\n+\t    if (e == tmp)\n+\t      {\n+\t\tfound = true;\n+\t\tix = ei.index;\n+\t\tbreak;\n+\t      }\n+\n+\t  gcc_assert (found);\n+\n+\t  if (EDGE_COUNT (src->succs) > (ix + 1))\n+\t    s = EDGE_SUCC (src, ix + 1);\n+\t  else\n+\t    s = EDGE_SUCC (src, 0);\n+\n \t  if (s->dest == dest\n \t      && any_condjump_p (BB_END (src))\n \t      && onlyjump_p (BB_END (src)))\n@@ -2680,10 +2742,12 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n-  return (a->succ && !a->succ->succ_next && a->succ->dest == b\n-\t  && !b->pred->pred_next && a != b\n+  return (EDGE_COUNT (a->succs) == 1\n+\t  && EDGE_SUCC (a, 0)->dest == b\n+\t  && EDGE_COUNT (b->preds) == 1\n+\t  && a != b\n \t  /* Must be simple edge.  */\n-\t  && !(a->succ->flags & EDGE_COMPLEX)\n+\t  && !(EDGE_SUCC (a, 0)->flags & EDGE_COMPLEX)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n@@ -2707,7 +2771,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   /* We should have fallthru edge in a, or we can do dummy redirection to get\n      it cleaned up.  */\n   if (JUMP_P (BB_END (a)))\n-    try_redirect_by_replacing_jump (a->succ, b, true);\n+    try_redirect_by_replacing_jump (EDGE_SUCC (a, 0), b, true);\n   gcc_assert (!JUMP_P (BB_END (a)));\n \n   /* Possible line number notes should appear in between.  */\n@@ -2906,8 +2970,9 @@ rtl_flow_call_edges_add (sbitmap blocks)\n       if (need_fake_edge_p (insn))\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->dest == EXIT_BLOCK_PTR)\n \t      {\n \t\tinsert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n@@ -2955,8 +3020,11 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \n #ifdef ENABLE_CHECKING\n \t      if (split_at_insn == BB_END (bb))\n-\t\tfor (e = bb->succ; e; e = e->succ_next)\n-\t\t  gcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t{\n+\t\t  edge_iterator ei;\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t    gcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t}\n #endif\n \n \t      /* Note that the following may create a new basic block"}, {"sha": "9862013ec45d16737f87201dbd503f714353dc44", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -6715,7 +6715,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n       while (multiple_test_bb != test_bb)\n \t{\n \t  bb[num_bb++] = multiple_test_bb;\n-\t  multiple_test_bb = multiple_test_bb->pred->src;\n+\t  multiple_test_bb = EDGE_PRED (multiple_test_bb, 0)->src;\n \t}\n     }\n "}, {"sha": "540d390d50cba2dae06387060005a91456e8ca70", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -14909,46 +14909,49 @@ static void\n ix86_pad_returns (void)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n-  {\n-    basic_block bb = e->src;\n-    rtx ret = BB_END (bb);\n-    rtx prev;\n-    bool replace = false;\n-\n-    if (GET_CODE (ret) != JUMP_INSN || GET_CODE (PATTERN (ret)) != RETURN\n-\t|| !maybe_hot_bb_p (bb))\n-      continue;\n-    for (prev = PREV_INSN (ret); prev; prev = PREV_INSN (prev))\n-      if (active_insn_p (prev) || GET_CODE (prev) == CODE_LABEL)\n-\tbreak;\n-    if (prev && GET_CODE (prev) == CODE_LABEL)\n-      {\n-\tedge e;\n-\tfor (e = bb->pred; e; e = e->pred_next)\n-\t  if (EDGE_FREQUENCY (e) && e->src->index >= 0\n-\t      && !(e->flags & EDGE_FALLTHRU))\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    {\n+      basic_block bb = e->src;\n+      rtx ret = BB_END (bb);\n+      rtx prev;\n+      bool replace = false;\n+\n+      if (GET_CODE (ret) != JUMP_INSN || GET_CODE (PATTERN (ret)) != RETURN\n+\t  || !maybe_hot_bb_p (bb))\n+\tcontinue;\n+      for (prev = PREV_INSN (ret); prev; prev = PREV_INSN (prev))\n+\tif (active_insn_p (prev) || GET_CODE (prev) == CODE_LABEL)\n+\t  break;\n+      if (prev && GET_CODE (prev) == CODE_LABEL)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (EDGE_FREQUENCY (e) && e->src->index >= 0\n+\t\t&& !(e->flags & EDGE_FALLTHRU))\n+\t      replace = true;\n+\t}\n+      if (!replace)\n+\t{\n+\t  prev = prev_active_insn (ret);\n+\t  if (prev\n+\t      && ((GET_CODE (prev) == JUMP_INSN && any_condjump_p (prev))\n+\t\t  || GET_CODE (prev) == CALL_INSN))\n \t    replace = true;\n-      }\n-    if (!replace)\n-      {\n-\tprev = prev_active_insn (ret);\n-\tif (prev\n-\t    && ((GET_CODE (prev) == JUMP_INSN && any_condjump_p (prev))\n-\t\t|| GET_CODE (prev) == CALL_INSN))\n-\t  replace = true;\n-\t/* Empty functions get branch mispredict even when the jump destination\n-\t   is not visible to us.  */\n-\tif (!prev && cfun->function_frequency > FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n-\t  replace = true;\n-      }\n-    if (replace)\n-      {\n-        emit_insn_before (gen_return_internal_long (), ret);\n-\tdelete_insn (ret);\n-      }\n-  }\n+\t  /* Empty functions get branch mispredict even when the jump destination\n+\t     is not visible to us.  */\n+\t  if (!prev && cfun->function_frequency > FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+\t    replace = true;\n+\t}\n+      if (replace)\n+\t{\n+\t  emit_insn_before (gen_return_internal_long (), ret);\n+\t  delete_insn (ret);\n+\t}\n+    }\n }\n \n /* Implement machine specific optimizations.  We implement padding of returns"}, {"sha": "6cb3b6a56520b8a228045c47eece6771d8f95705", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -2034,7 +2034,7 @@ ia64_expand_prologue (void)\n     {\n       edge e;\n \n-      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \tif ((e->flags & EDGE_FAKE) == 0\n \t    && (e->flags & EDGE_FALLTHRU) != 0)\n \t  break;"}, {"sha": "f12f7b35941d058771558afcb40ade2882aa295f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -13555,7 +13555,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t    && DEFAULT_ABI != ABI_AIX\n \t\t\t\t    && flag_pic\n \t\t\t\t    && ! info->lr_save_p\n-\t\t\t\t    && EXIT_BLOCK_PTR->pred != NULL);\n+\t\t\t\t    && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0);\n     if (save_LR_around_toc_setup)\n       {\n \trtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);"}, {"sha": "ca577c5de6b3d49b99b308e3d09c5ed9cf9be7ba", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -7392,6 +7392,7 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n   rtx last_insns[2];\n   unsigned int i;\n   rtx newreg;\n+  edge_iterator ei;\n \n   /* We expect to have two successors.  Look at both before picking\n      the final mode for the comparison.  If we have more successors\n@@ -7402,16 +7403,15 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n   found_equiv = false;\n   mode = GET_MODE (cc_src);\n   insn_count = 0;\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       rtx insn;\n       rtx end;\n \n       if (e->flags & EDGE_COMPLEX)\n \tcontinue;\n \n-      if (! e->dest->pred\n-\t  || e->dest->pred->pred_next\n+      if (EDGE_COUNT (e->dest->preds) != 1\n \t  || e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n "}, {"sha": "ee10362660dd7e7007249a63fa8698e9e99c672a", "filename": "gcc/df.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -3796,18 +3796,19 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n   int changed;\n   int i = bb->index;\n   edge e;\n+  edge_iterator ei;\n \n   SET_BIT (visited, bb->index);\n   gcc_assert (TEST_BIT (pending, bb->index));\n   RESET_BIT (pending, i);\n \n-#define HS(E_ANTI, E_ANTI_NEXT, E_ANTI_BB, E_ANTI_START_BB, IN_SET,\t\\\n-\t   E, E_NEXT, E_BB, E_START_BB, OUT_SET)\t\t\t\\\n+#define HS(E_ANTI, E_ANTI_BB, E_ANTI_START_BB, IN_SET,\t\t\t\\\n+\t   E, E_BB, E_START_BB, OUT_SET)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /*  Calculate <conf_op> of predecessor_outs.  */\t\t\t\\\n       bitmap_zero (IN_SET[i]);\t\t\t\t\t\t\\\n-      for (e = bb->E_ANTI; e; e = e->E_ANTI_NEXT)\t\t\t\\\n+      FOR_EACH_EDGE (e, ei, bb->E_ANTI)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (e->E_ANTI_BB == E_ANTI_START_BB)\t\t\t\t\\\n \t    continue;\t\t\t\t\t\t\t\\\n@@ -3827,7 +3828,7 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n       if (!changed)\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      for (e = bb->E; e; e = e->E_NEXT)\t\t\t\t\t\\\n+      FOR_EACH_EDGE (e, ei, bb->E)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (e->E_BB == E_START_BB || e->E_BB->index == i)\t\t\\\n \t    continue;\t\t\t\t\t\t\t\\\n@@ -3838,7 +3839,7 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n \t  SET_BIT (pending, e->E_BB->index);\t\t\t\t\\\n       \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      for (e = bb->E; e; e = e->E_NEXT)\t\t\t\t\t\\\n+      FOR_EACH_EDGE (e, ei, bb->E)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (e->E_BB == E_START_BB || e->E_BB->index == i)\t\t\\\n \t    continue;\t\t\t\t\t\t\t\\\n@@ -3852,11 +3853,11 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n     } while (0)\n \n   if (dataflow->dir == DF_FORWARD)\n-    HS (pred, pred_next, src, ENTRY_BLOCK_PTR, dataflow->in,\n-\tsucc, succ_next, dest, EXIT_BLOCK_PTR, dataflow->out);\n+    HS (preds, src, ENTRY_BLOCK_PTR, dataflow->in,\n+\tsuccs, dest, EXIT_BLOCK_PTR, dataflow->out);\n   else\n-    HS (succ, succ_next, dest, EXIT_BLOCK_PTR, dataflow->out,\n-\tpred, pred_next, src, ENTRY_BLOCK_PTR, dataflow->in);\n+    HS (succs, dest, EXIT_BLOCK_PTR, dataflow->out,\n+\tpreds, src, ENTRY_BLOCK_PTR, dataflow->in);\n }\n \n /* This function will perform iterative bitvector dataflow described by"}, {"sha": "680c4561c9d8c73d7d91de81abc34aa770468330", "filename": "gcc/dominance.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -206,27 +206,28 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n   /* We call this _only_ if bb is not already visited.  */\n   edge e;\n   TBB child_i, my_i = 0;\n-  edge *stack;\n+  edge_iterator *stack;\n+  edge_iterator ei, einext;\n   int sp;\n   /* Start block (ENTRY_BLOCK_PTR for forward problem, EXIT_BLOCK for backward\n      problem).  */\n   basic_block en_block;\n   /* Ending block.  */\n   basic_block ex_block;\n \n-  stack = xmalloc ((n_basic_blocks + 3) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 3) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Initialize our border blocks, and the first edge.  */\n   if (reverse)\n     {\n-      e = bb->pred;\n+      ei = ei_start (bb->preds);\n       en_block = EXIT_BLOCK_PTR;\n       ex_block = ENTRY_BLOCK_PTR;\n     }\n   else\n     {\n-      e = bb->succ;\n+      ei = ei_start (bb->succs);\n       en_block = ENTRY_BLOCK_PTR;\n       ex_block = EXIT_BLOCK_PTR;\n     }\n@@ -238,9 +239,9 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n \n       /* This loop traverses edges e in depth first manner, and fills the\n          stack.  */\n-      while (e)\n+      while (!ei_end_p (ei))\n \t{\n-\t  edge e_next;\n+\t  e = ei_edge (ei);\n \n \t  /* Deduce from E the current and the next block (BB and BN), and the\n \t     next edge.  */\n@@ -253,22 +254,22 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n \t         with the next edge out of the current node.  */\n \t      if (bn == ex_block || di->dfs_order[bn->index])\n \t\t{\n-\t\t  e = e->pred_next;\n+\t\t  ei_next (&ei);\n \t\t  continue;\n \t\t}\n \t      bb = e->dest;\n-\t      e_next = bn->pred;\n+\t      einext = ei_start (bn->preds);\n \t    }\n \t  else\n \t    {\n \t      bn = e->dest;\n \t      if (bn == ex_block || di->dfs_order[bn->index])\n \t\t{\n-\t\t  e = e->succ_next;\n+\t\t  ei_next (&ei);\n \t\t  continue;\n \t\t}\n \t      bb = e->src;\n-\t      e_next = bn->succ;\n+\t      einext = ei_start (bn->succs);\n \t    }\n \n \t  gcc_assert (bn != en_block);\n@@ -283,13 +284,13 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n \t  di->dfs_parent[child_i] = my_i;\n \n \t  /* Save the current point in the CFG on the stack, and recurse.  */\n-\t  stack[sp++] = e;\n-\t  e = e_next;\n+\t  stack[sp++] = ei;\n+\t  ei = einext;\n \t}\n \n       if (!sp)\n \tbreak;\n-      e = stack[--sp];\n+      ei = stack[--sp];\n \n       /* OK.  The edge-list was exhausted, meaning normally we would\n          end the recursion.  After returning from the recursive call,\n@@ -300,10 +301,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n          the block not yet completed (the parent of the one above)\n          in e->src.  This could be used e.g. for computing the number of\n          descendants or the tree depth.  */\n-      if (reverse)\n-\te = e->pred_next;\n-      else\n-\te = e->succ_next;\n+      ei_next (&ei);\n     }\n   free (stack);\n }\n@@ -341,7 +339,7 @@ calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n \n       FOR_EACH_BB_REVERSE (b)\n \t{\n-\t  if (b->succ)\n+\t  if (EDGE_COUNT (b->succs) > 0)\n \t    {\n \t      if (di->dfs_order[b->index] == 0)\n \t\tsaw_unconnected = true;\n@@ -478,6 +476,8 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n {\n   TBB v, w, k, par;\n   basic_block en_block;\n+  edge_iterator ei, einext;\n+\n   if (reverse)\n     en_block = EXIT_BLOCK_PTR;\n   else\n@@ -488,43 +488,38 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n   while (v > 1)\n     {\n       basic_block bb = di->dfs_to_bb[v];\n-      edge e, e_next;\n+      edge e;\n \n       par = di->dfs_parent[v];\n       k = v;\n+\n+      ei = (reverse) ? ei_start (bb->succs) : ei_start (bb->preds);\n+\n       if (reverse)\n \t{\n-\t  e = bb->succ;\n-\n \t  /* If this block has a fake edge to exit, process that first.  */\n \t  if (bitmap_bit_p (di->fake_exit_edge, bb->index))\n \t    {\n-\t      e_next = e;\n+\t      einext = ei;\n+\t      einext.index = 0;\n \t      goto do_fake_exit_edge;\n \t    }\n \t}\n-      else\n-\te = bb->pred;\n \n       /* Search all direct predecessors for the smallest node with a path\n          to them.  That way we have the smallest node with also a path to\n          us only over nodes behind us.  In effect we search for our\n          semidominator.  */\n-      for (; e ; e = e_next)\n+      while (!ei_end_p (ei))\n \t{\n \t  TBB k1;\n \t  basic_block b;\n \n-\t  if (reverse)\n-\t    {\n-\t      b = e->dest;\n-\t      e_next = e->succ_next;\n-\t    }\n-\t  else\n-\t    {\n-\t      b = e->src;\n-\t      e_next = e->pred_next;\n-\t    }\n+\t  e = ei_edge (ei);\n+\t  b = (reverse) ? e->dest : e->src;\n+\t  einext = ei;\n+\t  ei_next (&einext);\n+\n \t  if (b == en_block)\n \t    {\n \t    do_fake_exit_edge:\n@@ -539,6 +534,8 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n \t    k1 = di->key[eval (di, k1)];\n \t  if (k1 < k)\n \t    k = k1;\n+\n+\t  ei = einext;\n \t}\n \n       di->key[v] = k;\n@@ -870,12 +867,13 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n {\n   basic_block dom_bb = NULL;\n   edge e;\n+  edge_iterator ei;\n \n   gcc_assert (dom_computed[dir]);\n \n   if (dir == CDI_DOMINATORS)\n     {\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  /* Ignore the predecessors that either are not reachable from\n \t     the entry block, or whose dominator was not determined yet.  */\n@@ -888,7 +886,7 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n     }\n   else\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (!dominated_by_p (dir, e->dest, bb))\n \t    dom_bb = nearest_common_dominator (dir, dom_bb, e->dest);"}, {"sha": "15b1dff82dbfc2c755d921a9cd212e4c05e09dc9", "filename": "gcc/domwalk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -201,7 +201,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n     {\n       /* The destination block may have become unreachable, in\n \t which case there's no point in optimizing it.  */\n-      if (dest->pred)\n+      if (EDGE_COUNT (dest->preds) > 0)\n \twalk_dominator_tree (walk_data, dest);\n     }\n "}, {"sha": "f6d6dd1666c09acad859eb90dcec9376fa0bfedc", "filename": "gcc/except.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1449,13 +1449,16 @@ emit_to_new_bb_before (rtx seq, rtx insn)\n   rtx last;\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   /* If there happens to be an fallthru edge (possibly created by cleanup_cfg\n      call), we don't want it to go into newly created landing pad or other EH \n      construct.  */\n-  for (e = BLOCK_FOR_INSN (insn)->pred; e; e = e->pred_next)\n+  for (ei = ei_start (BLOCK_FOR_INSN (insn)->preds); (e = ei_safe_edge (ei)); )\n     if (e->flags & EDGE_FALLTHRU)\n       force_nonfallthru (e);\n+    else\n+      ei_next (&ei);\n   last = emit_insn_before (seq, insn);\n   if (BARRIER_P (last))\n     last = PREV_INSN (last);\n@@ -1623,8 +1626,8 @@ connect_post_landing_pads (void)\n \t  emit_jump (outer->post_landing_pad);\n \t  src = BLOCK_FOR_INSN (region->resume);\n \t  dest = BLOCK_FOR_INSN (outer->post_landing_pad);\n-\t  while (src->succ)\n-\t    remove_edge (src->succ);\n+\t  while (EDGE_COUNT (src->succs) > 0)\n+\t    remove_edge (EDGE_SUCC (src, 0));\n \t  e = make_edge (src, dest, 0);\n \t  e->probability = REG_BR_PROB_BASE;\n \t  e->count = src->count;\n@@ -1991,10 +1994,10 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \t    || NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_BASIC_BLOCK))\n       break;\n   if (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n-    insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n+    insert_insn_on_edge (seq, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n   else\n     {\n-      rtx last = BB_END (ENTRY_BLOCK_PTR->succ->dest);\n+      rtx last = BB_END (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest);\n       for (; ; fn_begin = NEXT_INSN (fn_begin))\n \tif ((NOTE_P (fn_begin)\n \t     && NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n@@ -2018,6 +2021,7 @@ sjlj_emit_function_exit (void)\n {\n   rtx seq;\n   edge e;\n+  edge_iterator ei;\n \n   start_sequence ();\n \n@@ -2031,7 +2035,7 @@ sjlj_emit_function_exit (void)\n      post-dominates all can_throw_internal instructions.  This is\n      the last possible moment.  */\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       break;\n   if (e)\n@@ -2198,16 +2202,18 @@ finish_eh_generation (void)\n     commit_edge_insertions ();\n   FOR_EACH_BB (bb)\n     {\n-      edge e, next;\n+      edge e;\n+      edge_iterator ei;\n       bool eh = false;\n-      for (e = bb->succ; e; e = next)\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n-\t  next = e->succ_next;\n \t  if (e->flags & EDGE_EH)\n \t    {\n \t      remove_edge (e);\n \t      eh = true;\n \t    }\n+\t  else\n+\t    ei_next (&ei);\n \t}\n       if (eh)\n \trtl_make_eh_edge (NULL, bb, BB_END (bb));"}, {"sha": "493f63ddfebee4002a27c4200ee11d80c6a11a47", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -677,14 +677,15 @@ compute_alignments (void)\n       rtx label = BB_HEAD (bb);\n       int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n       edge e;\n+      edge_iterator ei;\n \n       if (!LABEL_P (label)\n \t  || probably_never_executed_bb_p (bb))\n \tcontinue;\n       max_log = LABEL_ALIGN (label);\n       max_skip = LABEL_ALIGN_MAX_SKIP;\n \n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);"}, {"sha": "4914d72a4a090b8e2bde36da072ef3191d7960b0", "filename": "gcc/flow.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1091,6 +1091,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       int rescan, changed;\n       basic_block bb;\n       edge e;\n+      edge_iterator ei;\n \n       bb = *qhead++;\n       if (qhead == qend)\n@@ -1100,8 +1101,8 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       /* Begin by propagating live_at_start from the successor blocks.  */\n       CLEAR_REG_SET (new_live_at_end);\n \n-      if (bb->succ)\n-\tfor (e = bb->succ; e; e = e->succ_next)\n+      if (EDGE_COUNT (bb->succs) > 0)\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n \t  {\n \t    basic_block sb = e->dest;\n \n@@ -1257,7 +1258,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n       /* Queue all predecessors of BB so that we may re-examine\n \t their live_at_end.  */\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  basic_block pb = e->src;\n \t  if (pb->aux == NULL)\n@@ -1362,8 +1363,9 @@ initialize_uninitialized_subregs (void)\n   edge e;\n   int reg, did_something = 0;\n   find_regno_partial_param param;\n+  edge_iterator ei;\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       basic_block bb = e->dest;\n       regset map = bb->global_live_at_start;\n@@ -1827,19 +1829,19 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n       int i;\n \n       /* Identify the successor blocks.  */\n-      bb_true = bb->succ->dest;\n-      if (bb->succ->succ_next != NULL)\n+      bb_true = EDGE_SUCC (bb, 0)->dest;\n+      if (EDGE_COUNT (bb->succs) > 1)\n \t{\n-\t  bb_false = bb->succ->succ_next->dest;\n+\t  bb_false = EDGE_SUCC (bb, 1)->dest;\n \n-\t  if (bb->succ->flags & EDGE_FALLTHRU)\n+\t  if (EDGE_SUCC (bb, 0)->flags & EDGE_FALLTHRU)\n \t    {\n \t      basic_block t = bb_false;\n \t      bb_false = bb_true;\n \t      bb_true = t;\n \t    }\n \t  else\n-\t    gcc_assert (bb->succ->succ_next->flags & EDGE_FALLTHRU);\n+\t    gcc_assert (EDGE_SUCC (bb, 1)->flags & EDGE_FALLTHRU);\n \t}\n       else\n \t{\n@@ -1921,9 +1923,9 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t    && (TYPE_RETURNS_STACK_DEPRESSED\n \t\t(TREE_TYPE (current_function_decl))))\n       && (flags & PROP_SCAN_DEAD_STORES)\n-      && (bb->succ == NULL\n-\t  || (bb->succ->succ_next == NULL\n-\t      && bb->succ->dest == EXIT_BLOCK_PTR\n+      && (EDGE_COUNT (bb->succs) == 0\n+\t  || (EDGE_COUNT (bb->succs) == 1\n+\t      && EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n \t      && ! current_function_calls_eh_return)))\n     {\n       rtx insn, set;"}, {"sha": "0545b05a5cd8355eabafdd2e3dbd9bb10982344f", "filename": "gcc/function.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -4956,6 +4956,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n #if defined (HAVE_epilogue) || defined(HAVE_return)\n   rtx epilogue_end = NULL_RTX;\n #endif\n+  edge_iterator ei;\n \n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n@@ -4975,16 +4976,16 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       /* Can't deal with multiple successors of the entry block\n          at the moment.  Function should always have at least one\n          entry point.  */\n-      gcc_assert (ENTRY_BLOCK_PTR->succ && !ENTRY_BLOCK_PTR->succ->succ_next);\n+      gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1);\n \n-      insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n+      insert_insn_on_edge (seq, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n       inserted = 1;\n     }\n #endif\n \n   /* If the exit block has no non-fake predecessors, we don't need\n      an epilogue.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if ((e->flags & EDGE_FAKE) == 0)\n       break;\n   if (e == NULL)\n@@ -5000,10 +5001,9 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t emit (conditional) return instructions.  */\n \n       basic_block last;\n-      edge e_next;\n       rtx label;\n \n-      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n       if (e == NULL)\n@@ -5021,6 +5021,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \n       if (BB_HEAD (last) == label && LABEL_P (label))\n \t{\n+\t  edge_iterator ei2;\n \t  rtx epilogue_line_note = NULL_RTX;\n \n \t  /* Locate the line number associated with the closing brace,\n@@ -5034,18 +5035,23 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t\tbreak;\n \t      }\n \n-\t  for (e = last->pred; e; e = e_next)\n+\t  for (ei2 = ei_start (last->preds); (e = ei_safe_edge (ei2)); )\n \t    {\n \t      basic_block bb = e->src;\n \t      rtx jump;\n \n-\t      e_next = e->pred_next;\n \t      if (bb == ENTRY_BLOCK_PTR)\n-\t\tcontinue;\n+\t\t{\n+\t\t  ei_next (&ei2);\n+\t\t  continue;\n+\t\t}\n \n \t      jump = BB_END (bb);\n \t      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)\n-\t\tcontinue;\n+\t\t{\n+\t\t  ei_next (&ei2);\n+\t\t  continue;\n+\t\t}\n \n \t      /* If we have an unconditional jump, we can replace that\n \t\t with a simple return instruction.  */\n@@ -5060,16 +5066,25 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t      else if (condjump_p (jump))\n \t\t{\n \t\t  if (! redirect_jump (jump, 0, 0))\n-\t\t    continue;\n+\t\t    {\n+\t\t      ei_next (&ei2);\n+\t\t      continue;\n+\t\t    }\n \n \t\t  /* If this block has only one successor, it both jumps\n \t\t     and falls through to the fallthru block, so we can't\n \t\t     delete the edge.  */\n-\t\t  if (bb->succ->succ_next == NULL)\n-\t\t    continue;\n+\t\t  if (EDGE_COUNT (bb->succs) == 1)\n+\t\t    {\n+\t\t      ei_next (&ei2);\n+\t\t      continue;\n+\t\t    }\n \t\t}\n \t      else\n-\t\tcontinue;\n+\t\t{\n+\t\t  ei_next (&ei2);\n+\t\t  continue;\n+\t\t}\n \n \t      /* Fix up the CFG for the successful change we just made.  */\n \t      redirect_edge_succ (e, EXIT_BLOCK_PTR);\n@@ -5081,7 +5096,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t  emit_barrier_after (BB_END (last));\n \t  emit_return_into_block (last, epilogue_line_note);\n \t  epilogue_end = BB_END (last);\n-\t  last->succ->flags &= ~EDGE_FALLTHRU;\n+\t  EDGE_SUCC (last, 0)->flags &= ~EDGE_FALLTHRU;\n \t  goto epilogue_done;\n \t}\n     }\n@@ -5091,7 +5106,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n      There really shouldn't be a mixture -- either all should have\n      been converted or none, however...  */\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       break;\n   if (e == NULL)\n@@ -5152,7 +5167,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \n #ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n     {\n       basic_block bb = e->src;\n       rtx insn = BB_END (bb);\n@@ -5161,7 +5176,10 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \n       if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn))\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       start_sequence ();\n       emit_insn (gen_sibcall_epilogue ());\n@@ -5176,6 +5194,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \n       i = PREV_INSN (insn);\n       newinsn = emit_insn_before (seq, insn);\n+      ei_next (&ei);\n     }\n #endif\n "}, {"sha": "9250f128d1f4d4ce7bfaee54eacbb648edbb71d0", "filename": "gcc/gcse.c", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -3400,7 +3400,7 @@ find_implicit_sets (void)\n   count = 0;\n   FOR_EACH_BB (bb)\n     /* Check for more than one successor.  */\n-    if (bb->succ && bb->succ->succ_next)\n+    if (EDGE_COUNT (bb->succs) > 1)\n       {\n \tcond = fis_get_condition (BB_END (bb));\n \n@@ -3413,7 +3413,7 @@ find_implicit_sets (void)\n \t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n \t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n \n-\t    if (dest && ! dest->pred->pred_next\n+\t    if (dest && EDGE_COUNT (dest->preds) == 1\n \t\t&& dest != EXIT_BLOCK_PTR)\n \t      {\n \t\tnew = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n@@ -3570,9 +3570,11 @@ static int\n bypass_block (basic_block bb, rtx setcc, rtx jump)\n {\n   rtx insn, note;\n-  edge e, enext, edest;\n+  edge e, edest;\n   int i, change;\n   int may_be_loop_header;\n+  unsigned removed_p;\n+  edge_iterator ei;\n \n   insn = (setcc != NULL) ? setcc : jump;\n \n@@ -3584,30 +3586,40 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n     find_used_regs (&XEXP (note, 0), NULL);\n \n   may_be_loop_header = false;\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e->flags & EDGE_DFS_BACK)\n       {\n \tmay_be_loop_header = true;\n \tbreak;\n       }\n \n   change = 0;\n-  for (e = bb->pred; e; e = enext)\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n     {\n-      enext = e->pred_next;\n+      removed_p = 0;\n+\t  \n       if (e->flags & EDGE_COMPLEX)\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       /* We can't redirect edges from new basic blocks.  */\n       if (e->src->index >= bypass_last_basic_block)\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       /* The irreducible loops created by redirecting of edges entering the\n \t loop from outside would decrease effectiveness of some of the following\n \t optimizations, so prevent this.  */\n       if (may_be_loop_header\n \t  && !(e->flags & EDGE_DFS_BACK))\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       for (i = 0; i < reg_use_count; i++)\n \t{\n@@ -3651,9 +3663,11 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t    }\n \t  else if (GET_CODE (new) == LABEL_REF)\n \t    {\n+\t      edge_iterator ei2;\n+\n \t      dest = BLOCK_FOR_INSN (XEXP (new, 0));\n \t      /* Don't bypass edges containing instructions.  */\n-\t      for (edest = bb->succ; edest; edest = edest->succ_next)\n+\t      FOR_EACH_EDGE (edest, ei2, bb->succs)\n \t\tif (edest->dest == dest && edest->insns.r)\n \t\t  {\n \t\t    dest = NULL;\n@@ -3670,7 +3684,9 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc))))\n \t    {\n \t      edge e2;\n-\t      for (e2 = e->src->succ; e2; e2 = e2->succ_next)\n+\t      edge_iterator ei2;\n+\n+\t      FOR_EACH_EDGE (e2, ei2, e->src->succs)\n \t\tif (e2->dest == dest)\n \t\t  {\n \t\t    dest = NULL;\n@@ -3704,9 +3720,12 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t\t   e->src->index, old_dest->index, dest->index);\n \t\t}\n \t      change = 1;\n+\t      removed_p = 1;\n \t      break;\n \t    }\n \t}\n+      if (!removed_p)\n+\tei_next (&ei);\n     }\n   return change;\n }\n@@ -3739,7 +3758,7 @@ bypass_conditional_jumps (void)\n \t\t  EXIT_BLOCK_PTR, next_bb)\n     {\n       /* Check for more than one predecessor.  */\n-      if (bb->pred && bb->pred->pred_next)\n+      if (EDGE_COUNT (bb->preds) > 1)\n \t{\n \t  setcc = NULL_RTX;\n \t  for (insn = BB_HEAD (bb);\n@@ -3886,12 +3905,13 @@ compute_pre_data (void)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n       /* If the current block is the destination of an abnormal edge, we\n \t kill all trapping expressions because we won't be able to properly\n \t place the instruction on the edge.  So make them neither\n \t anticipatable nor transparent.  This is fairly conservative.  */\n-      for (e = bb->pred; e ; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->flags & EDGE_ABNORMAL)\n \t  {\n \t    sbitmap_difference (antloc[bb->index], antloc[bb->index], trapping_expr);\n@@ -3931,8 +3951,9 @@ static int\n pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr, basic_block bb, char *visited)\n {\n   edge pred;\n-\n-  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n+  edge_iterator ei;\n+  \n+  FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n       basic_block pred_bb = pred->src;\n \n@@ -4051,7 +4072,8 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \n   if (JUMP_P (insn)\n       || (NONJUMP_INSN_P (insn)\n-\t  && (bb->succ->succ_next || (bb->succ->flags & EDGE_ABNORMAL))))\n+\t  && (EDGE_COUNT (bb->succs) > 1\n+\t      || EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL)))\n     {\n #ifdef HAVE_cc0\n       rtx note;\n@@ -4092,7 +4114,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n   /* Likewise if the last insn is a call, as will happen in the presence\n      of exception handling.  */\n   else if (CALL_P (insn)\n-\t   && (bb->succ->succ_next || (bb->succ->flags & EDGE_ABNORMAL)))\n+\t   && (EDGE_COUNT (bb->succs) > 1 || EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL))\n     {\n       /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n \t we search backward and place the instructions before the first\n@@ -4810,6 +4832,7 @@ static int\n hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb, char *visited)\n {\n   edge pred;\n+  edge_iterator ei;\n   int visited_allocated_locally = 0;\n \n \n@@ -4819,7 +4842,7 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n       visited = xcalloc (last_basic_block, 1);\n     }\n \n-  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n+  FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n       basic_block pred_bb = pred->src;\n \n@@ -6188,6 +6211,7 @@ insert_store (struct ls_expr * expr, edge e)\n   rtx reg, insn;\n   basic_block bb;\n   edge tmp;\n+  edge_iterator ei;\n \n   /* We did all the deleted before this insert, so if we didn't delete a\n      store, then we haven't set the reaching reg yet either.  */\n@@ -6204,7 +6228,7 @@ insert_store (struct ls_expr * expr, edge e)\n      insert it at the start of the BB, and reset the insert bits on the other\n      edges so we don't try to insert it on the other edges.  */\n   bb = e->dest;\n-  for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)\n+  FOR_EACH_EDGE (tmp, ei, e->dest->preds)\n     if (!(tmp->flags & EDGE_FAKE))\n       {\n \tint index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n@@ -6218,7 +6242,7 @@ insert_store (struct ls_expr * expr, edge e)\n      insertion vector for these edges, and insert at the start of the BB.  */\n   if (!tmp && bb != EXIT_BLOCK_PTR)\n     {\n-      for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)\n+      FOR_EACH_EDGE (tmp, ei, e->dest->preds)\n \t{\n \t  int index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n \t  RESET_BIT (pre_insert_map[index], expr->index);\n@@ -6256,33 +6280,40 @@ insert_store (struct ls_expr * expr, edge e)\n static void\n remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n {\n-  edge *stack = xmalloc (sizeof (edge) * n_basic_blocks), act;\n+  edge_iterator *stack, ei;\n+  int sp;\n+  edge act;\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n-  int stack_top = 0;\n   rtx last, insn, note;\n   rtx mem = smexpr->pattern;\n \n+  stack = xmalloc (sizeof (edge_iterator) * n_basic_blocks);\n+  sp = 0;\n+  ei = ei_start (bb->succs);\n+\n   sbitmap_zero (visited);\n-  act = bb->succ;\n \n+  act = (EDGE_COUNT (ei.container) > 0 ? EDGE_I (ei.container, 0) : NULL);\n   while (1)\n     {\n       if (!act)\n \t{\n-\t  if (!stack_top)\n+\t  if (!sp)\n \t    {\n \t      free (stack);\n \t      sbitmap_free (visited);\n \t      return;\n \t    }\n-\t  act = stack[--stack_top];\n+\t  act = ei_edge (stack[--sp]);\n \t}\n       bb = act->dest;\n \n       if (bb == EXIT_BLOCK_PTR\n \t  || TEST_BIT (visited, bb->index))\n \t{\n-\t  act = act->succ_next;\n+\t  if (!ei_end_p (ei))\n+\t      ei_next (&ei);\n+\t  act = (! ei_end_p (ei)) ? ei_edge (ei) : NULL;\n \t  continue;\n \t}\n       SET_BIT (visited, bb->index);\n@@ -6310,12 +6341,17 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n \t\t       INSN_UID (insn));\n \t    remove_note (insn, note);\n \t  }\n-      act = act->succ_next;\n-      if (bb->succ)\n+\n+      if (!ei_end_p (ei))\n+\tei_next (&ei);\n+      act = (! ei_end_p (ei)) ? ei_edge (ei) : NULL;\n+\n+      if (EDGE_COUNT (bb->succs) > 0)\n \t{\n \t  if (act)\n-\t    stack[stack_top++] = act;\n-\t  act = bb->succ;\n+\t    stack[sp++] = ei;\n+\t  ei = ei_start (bb->succs);\n+\t  act = (EDGE_COUNT (ei.container) > 0 ? EDGE_I (ei.container, 0) : NULL);\n \t}\n     }\n }"}, {"sha": "424bdad73f5ad8e7b8b80059dde03900328f2dd1", "filename": "gcc/global.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -748,8 +748,9 @@ global_conflicts (void)\n \t   regs live across such edges.  */\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n-\t  for (e = b->pred; e ; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, b->preds)\n \t    if (e->flags & EDGE_ABNORMAL)\n \t      break;\n \n@@ -2339,12 +2340,14 @@ calculate_reg_pav (void)\n       sbitmap_zero (wset);\n       for (i = 0; i < nel; i++)\n \t{\n+\t  edge_iterator ei;\n+\n \t  bb = bb_array [i];\n \t  changed_p = 0;\n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    changed_p = modify_bb_reg_pav (bb, e->src, changed_p);\n \t  if (changed_p)\n-\t    for (e = bb->succ; e; e = e->succ_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      {\n \t\tsucc = e->dest;\n \t\tif (succ->index != EXIT_BLOCK && !TEST_BIT (wset, succ->index))"}, {"sha": "cd232db985a9c333d92095a1d9674e6e76a45ea0", "filename": "gcc/graph.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -308,6 +308,7 @@ print_rtl_graph_with_bb (const char *base, rtx rtx_first)\n \t  if ((i = end[INSN_UID (tmp_rtx)]) >= 0)\n \t    {\n \t      edge e;\n+\t      edge_iterator ei;\n \n \t      bb = BASIC_BLOCK (i);\n \n@@ -316,7 +317,7 @@ print_rtl_graph_with_bb (const char *base, rtx rtx_first)\n \n \t      /* Now specify the edges to all the successors of this\n \t\t basic block.  */\n-\t      for (e = bb->succ; e ; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t{\n \t\t  if (e->dest != EXIT_BLOCK_PTR)\n \t\t    {"}, {"sha": "709a6756f4cb97a75f7cc2156883b3c049a91aa8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -65,8 +65,8 @@\n #define MAX_CONDITIONAL_EXECUTE   (BRANCH_COST + 1)\n #endif\n \n-#define NULL_EDGE\t((struct edge_def *)NULL)\n-#define NULL_BLOCK\t((struct basic_block_def *)NULL)\n+#define NULL_EDGE\t((edge) NULL)\n+#define NULL_BLOCK\t((basic_block) NULL)\n \n /* # of IF-THEN or IF-THEN-ELSE blocks we looked at  */\n static int num_possible_if_blocks;\n@@ -126,7 +126,8 @@ mark_loop_exit_edges (void)\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if (find_common_loop (bb->loop_father, e->dest->loop_father)\n \t\t  != bb->loop_father)\n@@ -249,11 +250,11 @@ static basic_block\n block_fallthru (basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = bb->succ;\n-       e != NULL_EDGE && (e->flags & EDGE_FALLTHRU) == 0;\n-       e = e->succ_next)\n-    ;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_FALLTHRU)\n+      break;\n \n   return (e) ? e->dest : NULL_BLOCK;\n }\n@@ -2226,7 +2227,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n-      if (combo_bb->succ == NULL_EDGE)\n+      if (EDGE_COUNT (combo_bb->succs) == 0)\n \t{\n \t  if (find_reg_note (last, REG_NORETURN, NULL))\n \t    ;\n@@ -2242,11 +2243,11 @@ merge_if_block (struct ce_if_block * ce_info)\n          blocks taking us to our final destination.  */\n       else if (JUMP_P (last))\n \t;\n-      else if (combo_bb->succ->dest == EXIT_BLOCK_PTR\n+      else if (EDGE_SUCC (combo_bb, 0)->dest == EXIT_BLOCK_PTR\n \t       && CALL_P (last)\n \t       && SIBLING_CALL_P (last))\n \t;\n-      else if ((combo_bb->succ->flags & EDGE_EH)\n+      else if ((EDGE_SUCC (combo_bb, 0)->flags & EDGE_EH)\n \t       && can_throw_internal (last))\n \t;\n       else\n@@ -2259,8 +2260,7 @@ merge_if_block (struct ce_if_block * ce_info)\n      is more than one remaining edge, it must come from elsewhere.  There\n      may be zero incoming edges if the THEN block didn't actually join\n      back up (as with a call to abort).  */\n-  else if ((join_bb->pred == NULL\n-\t    || join_bb->pred->pred_next == NULL)\n+  else if (EDGE_COUNT (join_bb->preds) < 2\n \t   && join_bb != EXIT_BLOCK_PTR)\n     {\n       /* We can merge the JOIN.  */\n@@ -2277,13 +2277,13 @@ merge_if_block (struct ce_if_block * ce_info)\n \n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n-      if (combo_bb->succ->succ_next != NULL_EDGE\n-\t  || combo_bb->succ->dest != join_bb)\n+      if (EDGE_COUNT (combo_bb->succs) > 1\n+\t  || EDGE_SUCC (combo_bb, 0)->dest != join_bb)\n \tabort ();\n \n       /* Remove the jump and cruft from the end of the COMBO block.  */\n       if (join_bb != EXIT_BLOCK_PTR)\n-\ttidy_fallthru_edge (combo_bb->succ);\n+\ttidy_fallthru_edge (EDGE_SUCC (combo_bb, 0));\n     }\n \n   num_updated_if_blocks++;\n@@ -2302,11 +2302,12 @@ find_if_header (basic_block test_bb, int pass)\n   edge else_edge;\n \n   /* The kind of block we're looking for has exactly two successors.  */\n-  if ((then_edge = test_bb->succ) == NULL_EDGE\n-      || (else_edge = then_edge->succ_next) == NULL_EDGE\n-      || else_edge->succ_next != NULL_EDGE)\n+  if (EDGE_COUNT (test_bb->succs) != 2)\n     return NULL;\n \n+  then_edge = EDGE_SUCC (test_bb, 0);\n+  else_edge = EDGE_SUCC (test_bb, 1);\n+\n   /* Neither edge should be abnormal.  */\n   if ((then_edge->flags & EDGE_COMPLEX)\n       || (else_edge->flags & EDGE_COMPLEX))\n@@ -2378,17 +2379,16 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n   rtx insn;\n   rtx end;\n   int n_insns = 0;\n+  edge_iterator ei;\n \n   if (!cur_bb || !target_bb)\n     return -1;\n \n   /* If no edges, obviously it doesn't jump or fallthru.  */\n-  if (cur_bb->succ == NULL_EDGE)\n+  if (EDGE_COUNT (cur_bb->succs) == 0)\n     return FALSE;\n \n-  for (cur_edge = cur_bb->succ;\n-       cur_edge != NULL_EDGE;\n-       cur_edge = cur_edge->succ_next)\n+  FOR_EACH_EDGE (cur_edge, ei, cur_bb->succs)\n     {\n       if (cur_edge->flags & EDGE_COMPLEX)\n \t/* Anything complex isn't what we want.  */\n@@ -2445,24 +2445,22 @@ find_if_block (struct ce_if_block * ce_info)\n   basic_block then_bb = ce_info->then_bb;\n   basic_block else_bb = ce_info->else_bb;\n   basic_block join_bb = NULL_BLOCK;\n-  edge then_succ = then_bb->succ;\n-  edge else_succ = else_bb->succ;\n   int then_predecessors;\n   int else_predecessors;\n   edge cur_edge;\n   basic_block next;\n+  edge_iterator ei;\n \n   ce_info->last_test_bb = test_bb;\n \n   /* Discover if any fall through predecessors of the current test basic block\n      were && tests (which jump to the else block) or || tests (which jump to\n      the then block).  */\n   if (HAVE_conditional_execution && reload_completed\n-      && test_bb->pred != NULL_EDGE\n-      && test_bb->pred->pred_next == NULL_EDGE\n-      && test_bb->pred->flags == EDGE_FALLTHRU)\n+      && EDGE_COUNT (test_bb->preds) == 1\n+      && EDGE_PRED (test_bb, 0)->flags == EDGE_FALLTHRU)\n     {\n-      basic_block bb = test_bb->pred->src;\n+      basic_block bb = EDGE_PRED (test_bb, 0)->src;\n       basic_block target_bb;\n       int max_insns = MAX_CONDITIONAL_EXECUTE;\n       int n_insns;\n@@ -2495,10 +2493,10 @@ find_if_block (struct ce_if_block * ce_info)\n \t      total_insns += n_insns;\n \t      blocks++;\n \n-\t      if (bb->pred == NULL_EDGE || bb->pred->pred_next != NULL_EDGE)\n+\t      if (EDGE_COUNT (bb->preds) != 1)\n \t\tbreak;\n \n-\t      bb = bb->pred->src;\n+\t      bb = EDGE_PRED (bb, 0)->src;\n \t      n_insns = block_jumps_and_fallthru_p (bb, target_bb);\n \t    }\n \t  while (n_insns >= 0 && (total_insns + n_insns) <= max_insns);\n@@ -2515,19 +2513,15 @@ find_if_block (struct ce_if_block * ce_info)\n \n   /* Count the number of edges the THEN and ELSE blocks have.  */\n   then_predecessors = 0;\n-  for (cur_edge = then_bb->pred;\n-       cur_edge != NULL_EDGE;\n-       cur_edge = cur_edge->pred_next)\n+  FOR_EACH_EDGE (cur_edge, ei, then_bb->preds)\n     {\n       then_predecessors++;\n       if (cur_edge->flags & EDGE_COMPLEX)\n \treturn FALSE;\n     }\n \n   else_predecessors = 0;\n-  for (cur_edge = else_bb->pred;\n-       cur_edge != NULL_EDGE;\n-       cur_edge = cur_edge->pred_next)\n+  FOR_EACH_EDGE (cur_edge, ei, else_bb->preds)\n     {\n       else_predecessors++;\n       if (cur_edge->flags & EDGE_COMPLEX)\n@@ -2540,9 +2534,9 @@ find_if_block (struct ce_if_block * ce_info)\n     return FALSE;\n \n   /* The THEN block of an IF-THEN combo must have zero or one successors.  */\n-  if (then_succ != NULL_EDGE\n-      && (then_succ->succ_next != NULL_EDGE\n-          || (then_succ->flags & EDGE_COMPLEX)\n+  if (EDGE_COUNT (then_bb->succs) > 0\n+      && (EDGE_COUNT (then_bb->succs) > 1\n+          || (EDGE_SUCC (then_bb, 0)->flags & EDGE_COMPLEX)\n \t  || (flow2_completed && tablejump_p (BB_END (then_bb), NULL, NULL))))\n     return FALSE;\n \n@@ -2552,9 +2546,9 @@ find_if_block (struct ce_if_block * ce_info)\n      Check for the last insn of the THEN block being an indirect jump, which\n      is listed as not having any successors, but confuses the rest of the CE\n      code processing.  ??? we should fix this in the future.  */\n-  if (then_succ == NULL)\n+  if (EDGE_COUNT (then_bb->succs) == 0)\n     {\n-      if (else_bb->pred->pred_next == NULL_EDGE)\n+      if (EDGE_COUNT (else_bb->preds) == 1)\n \t{\n \t  rtx last_insn = BB_END (then_bb);\n \n@@ -2577,7 +2571,7 @@ find_if_block (struct ce_if_block * ce_info)\n \n   /* If the THEN block's successor is the other edge out of the TEST block,\n      then we have an IF-THEN combo without an ELSE.  */\n-  else if (then_succ->dest == else_bb)\n+  else if (EDGE_SUCC (then_bb, 0)->dest == else_bb)\n     {\n       join_bb = else_bb;\n       else_bb = NULL_BLOCK;\n@@ -2586,13 +2580,12 @@ find_if_block (struct ce_if_block * ce_info)\n   /* If the THEN and ELSE block meet in a subsequent block, and the ELSE\n      has exactly one predecessor and one successor, and the outgoing edge\n      is not complex, then we have an IF-THEN-ELSE combo.  */\n-  else if (else_succ != NULL_EDGE\n-\t   && then_succ->dest == else_succ->dest\n-\t   && else_bb->pred->pred_next == NULL_EDGE\n-\t   && else_succ->succ_next == NULL_EDGE\n-\t   && ! (else_succ->flags & EDGE_COMPLEX)\n+  else if (EDGE_COUNT (else_bb->succs) == 1\n+\t   && EDGE_SUCC (then_bb, 0)->dest == EDGE_SUCC (else_bb, 0)->dest\n+\t   && EDGE_COUNT (else_bb->preds) == 1\n+\t   && ! (EDGE_SUCC (else_bb, 0)->flags & EDGE_COMPLEX)\n \t   && ! (flow2_completed && tablejump_p (BB_END (else_bb), NULL, NULL)))\n-    join_bb = else_succ->dest;\n+    join_bb = EDGE_SUCC (else_bb, 0)->dest;\n \n   /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */\n   else\n@@ -2726,7 +2719,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);\n-  if (trap_bb->pred == NULL)\n+  if (EDGE_COUNT (trap_bb->preds) == 0)\n     delete_basic_block (trap_bb);\n \n   /* If the non-trap block and the test are now adjacent, merge them.\n@@ -2771,7 +2764,7 @@ block_has_only_trap (basic_block bb)\n     return NULL_RTX;\n \n   /* The block must have no successors.  */\n-  if (bb->succ)\n+  if (EDGE_COUNT (bb->succs) > 0)\n     return NULL_RTX;\n \n   /* The only instruction in the THEN block must be the trap.  */\n@@ -2866,7 +2859,6 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest, new_bb;\n-  edge then_succ = then_bb->succ;\n   int then_bb_index, bb_cost;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -2888,15 +2880,15 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* THEN has one successor.  */\n-  if (!then_succ || then_succ->succ_next != NULL)\n+  if (EDGE_COUNT (then_bb->succs) != 1)\n     return FALSE;\n \n   /* THEN does not fall through, but is not strange either.  */\n-  if (then_succ->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n+  if (EDGE_SUCC (then_bb, 0)->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n     return FALSE;\n \n   /* THEN has one predecessor.  */\n-  if (then_bb->pred->pred_next != NULL)\n+  if (EDGE_COUNT (then_bb->preds) != 1)\n     return FALSE;\n \n   /* THEN must do something.  */\n@@ -2916,7 +2908,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* Registers set are dead, or are predicable.  */\n   if (! dead_or_predicable (test_bb, then_bb, else_bb,\n-\t\t\t    then_bb->succ->dest, 1))\n+\t\t\t    EDGE_SUCC (then_bb, 0)->dest, 1))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -2957,7 +2949,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n-  edge else_succ = else_bb->succ;\n+  edge else_succ;\n   int bb_cost;\n   rtx note;\n \n@@ -2980,15 +2972,17 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* ELSE has one successor.  */\n-  if (!else_succ || else_succ->succ_next != NULL)\n+  if (EDGE_COUNT (else_bb->succs) != 1)\n     return FALSE;\n+  else\n+    else_succ = EDGE_SUCC (else_bb, 0);\n \n   /* ELSE outgoing edge is not complex.  */\n   if (else_succ->flags & EDGE_COMPLEX)\n     return FALSE;\n \n   /* ELSE has one predecessor.  */\n-  if (else_bb->pred->pred_next != NULL)\n+  if (EDGE_COUNT (else_bb->preds) != 1)\n     return FALSE;\n \n   /* THEN is not EXIT.  */"}, {"sha": "cc6c9bcd04dbc7208dc19de2bff0efc6963cd7bb", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1868,7 +1868,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       /* Create the new iv, and insert it's increment on the latch\n          block.  */\n \n-      bb = temp->latch->pred->src;\n+      bb = EDGE_PRED (temp->latch, 0)->src;\n       bsi = bsi_last (bb);\n       create_iv (newlowerbound,\n \t\t build_int_cst (integer_type_node, LL_STEP (newloop)),\n@@ -2282,7 +2282,7 @@ perfect_nestify (struct loops *loops,\n       VEC_safe_push (tree, phis, PHI_ARG_DEF (phi, 0));\n       mark_for_rewrite (PHI_RESULT (phi));\n     }\n-  e = redirect_edge_and_branch (preheaderbb->succ, headerbb);\n+  e = redirect_edge_and_branch (EDGE_SUCC (preheaderbb, 0), headerbb);\n   unmark_all_for_rewrite ();\n   bb_ann (olddest)->phi_nodes = NULL;\n   /* Add back the old exit phis.  */\n@@ -2294,7 +2294,7 @@ perfect_nestify (struct loops *loops,\n       phiname = VEC_pop (tree, phis);\n       \n       phi = create_phi_node (phiname, preheaderbb);\n-      add_phi_arg (&phi, def, preheaderbb->pred);\n+      add_phi_arg (&phi, def, EDGE_PRED (preheaderbb, 0));\n     } \n       \n   nestify_update_pending_stmts (e);\n@@ -2332,7 +2332,7 @@ perfect_nestify (struct loops *loops,\n   /* Create the new iv.  */\n   ivvar = create_tmp_var (integer_type_node, \"perfectiv\");\n   add_referenced_tmp_var (ivvar);\n-  bsi = bsi_last (newloop->latch->pred->src);\n+  bsi = bsi_last (EDGE_PRED (newloop->latch, 0)->src);\n   create_iv (VEC_index (tree, lbounds, 0),\n \t     build_int_cst (integer_type_node, \n \t\t\t    VEC_index (int, steps, 0)),"}, {"sha": "c3e5f93313aae815239bdc473a8fc21dce5799bc", "filename": "gcc/lcm.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -102,6 +102,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend;\n   unsigned int qlen;\n+  edge_iterator ei;\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n@@ -126,7 +127,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \n   /* Mark blocks which are predecessors of the exit block so that we\n      can easily identify them below.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     e->src->aux = EXIT_BLOCK_PTR;\n \n   /* Iterate until the worklist is empty.  */\n@@ -157,7 +158,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t/* If the in state of this block changed, then we need\n \t   to add the predecessors of this block to the worklist\n \t   if they are not already on the worklist.  */\n-\tfor (e = bb->pred; e; e = e->pred_next)\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n \t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n \t    {\n \t      *qin++ = e->src;\n@@ -251,6 +252,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend, bb;\n   unsigned int qlen;\n+  edge_iterator ei;\n \n   num_edges = NUM_EDGES (edge_list);\n \n@@ -280,7 +282,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      do not want to be overly optimistic.  Consider an outgoing edge from\n      the entry block.  That edge should always have a LATER value the\n      same as EARLIEST for that edge.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     sbitmap_copy (later[(size_t) e->aux], earliest[(size_t) e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n@@ -310,12 +312,12 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n \n       /* Compute the intersection of LATERIN for each incoming edge to B.  */\n       sbitmap_ones (laterin[bb->index]);\n-      for (e = bb->pred; e != NULL; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tsbitmap_a_and_b (laterin[bb->index], laterin[bb->index],\n \t\t\t later[(size_t)e->aux]);\n \n       /* Calculate LATER for all outgoing edges.  */\n-      for (e = bb->succ; e != NULL; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (sbitmap_union_of_diff_cg (later[(size_t) e->aux],\n \t\t\t\t      earliest[(size_t) e->aux],\n \t\t\t\t      laterin[e->src->index],\n@@ -336,7 +338,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      for the EXIT block.  We allocated an extra entry in the LATERIN array\n      for just this purpose.  */\n   sbitmap_ones (laterin[last_basic_block]);\n-  for (e = EXIT_BLOCK_PTR->pred; e != NULL; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     sbitmap_a_and_b (laterin[last_basic_block],\n \t\t     laterin[last_basic_block],\n \t\t     later[(size_t) e->aux]);\n@@ -478,6 +480,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend, bb;\n   unsigned int qlen;\n+  edge_iterator ei;\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n@@ -501,7 +504,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \n   /* Mark blocks which are successors of the entry block so that we\n      can easily identify them below.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     e->dest->aux = ENTRY_BLOCK_PTR;\n \n   /* Iterate until the worklist is empty.  */\n@@ -534,7 +537,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \t/* If the out state of this block changed, then we need\n \t   to add the successors of this block to the worklist\n \t   if they are not already on the worklist.  */\n-\tfor (e = bb->succ; e; e = e->succ_next)\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n \t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      *qin++ = e->dest;\n@@ -604,6 +607,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   int num_edges, i;\n   edge e;\n   basic_block *worklist, *tos, bb;\n+  edge_iterator ei;\n \n   num_edges = NUM_EDGES (edge_list);\n \n@@ -624,7 +628,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n      do not want to be overly optimistic.  Consider an incoming edge to\n      the exit block.  That edge should always have a NEARER value the\n      same as FARTHEST for that edge.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     sbitmap_copy (nearer[(size_t)e->aux], farthest[(size_t)e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit\n@@ -644,12 +648,12 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n \n       /* Compute the intersection of NEARER for each outgoing edge from B.  */\n       sbitmap_ones (nearerout[bb->index]);\n-      for (e = bb->succ; e != NULL; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tsbitmap_a_and_b (nearerout[bb->index], nearerout[bb->index],\n \t\t\t nearer[(size_t) e->aux]);\n \n       /* Calculate NEARER for all incoming edges.  */\n-      for (e = bb->pred; e != NULL; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (sbitmap_union_of_diff_cg (nearer[(size_t) e->aux],\n \t\t\t\t      farthest[(size_t) e->aux],\n \t\t\t\t      nearerout[e->dest->index],\n@@ -667,7 +671,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n      for just this purpose.  */\n   sbitmap_ones (nearerout[last_basic_block]);\n-  for (e = ENTRY_BLOCK_PTR->succ; e != NULL; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     sbitmap_a_and_b (nearerout[last_basic_block],\n \t\t     nearerout[last_basic_block],\n \t\t     nearer[(size_t) e->aux]);\n@@ -912,8 +916,9 @@ static void\n make_preds_opaque (basic_block b, int j)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = b->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, b->preds)\n     {\n       basic_block pb = e->src;\n "}, {"sha": "1b5ca4dc6d22fa2228598bfa79113e7ead9c0ff3", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -358,11 +358,11 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       /* Expand the condition testing the assumptions and if it does not pass,\n \t reset the count register to 0.  */\n       add_test (XEXP (ass, 0), preheader, set_zero);\n-      preheader->succ->flags &= ~EDGE_FALLTHRU;\n-      cnt = preheader->succ->count;\n-      preheader->succ->probability = 0;\n-      preheader->succ->count = 0;\n-      irr = preheader->succ->flags & EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (preheader, 0)->flags &= ~EDGE_FALLTHRU;\n+      cnt = EDGE_SUCC (preheader, 0)->count;\n+      EDGE_SUCC (preheader, 0)->probability = 0;\n+      EDGE_SUCC (preheader, 0)->count = 0;\n+      irr = EDGE_SUCC (preheader, 0)->flags & EDGE_IRREDUCIBLE_LOOP;\n       te = make_edge (preheader, new_preheader, EDGE_FALLTHRU | irr);\n       te->probability = REG_BR_PROB_BASE;\n       te->count = cnt;\n@@ -374,7 +374,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       for (ass = XEXP (ass, 1); ass; ass = XEXP (ass, 1))\n \t{\n \t  bb = loop_split_edge_with (te, NULL_RTX);\n-\t  te = bb->succ;\n+\t  te = EDGE_SUCC (bb, 0);\n \t  add_test (XEXP (ass, 0), bb, set_zero);\n \t  make_edge (bb, set_zero, irr);\n \t}"}, {"sha": "8db45ec0e40f593d7134287f264f795f81b90a7e", "filename": "gcc/loop-init.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -35,6 +35,7 @@ loop_optimizer_init (FILE *dumpfile)\n {\n   struct loops *loops = xcalloc (1, sizeof (struct loops));\n   edge e;\n+  edge_iterator ei;\n   static bool first_time = true;\n \n   if (first_time)\n@@ -45,9 +46,12 @@ loop_optimizer_init (FILE *dumpfile)\n \n   /* Avoid annoying special cases of edges going to exit\n      block.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n-    if ((e->flags & EDGE_FALLTHRU) && e->src->succ->succ_next)\n+\n+  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n+    if ((e->flags & EDGE_FALLTHRU) && EDGE_COUNT (e->src->succs) > 1)\n       split_edge (e);\n+    else\n+      ei_next (&ei);\n \n   /* Find the loops.  */\n "}, {"sha": "21dc8b881446cee226c9a311d283501ec72d5c66", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -219,6 +219,7 @@ find_exits (struct loop *loop, basic_block *body,\n \t    bitmap may_exit, bitmap has_exit)\n {\n   unsigned i;\n+  edge_iterator ei;\n   edge e;\n   struct loop *outermost_exit = loop, *aexit;\n   bool has_call = false;\n@@ -239,7 +240,7 @@ find_exits (struct loop *loop, basic_block *body,\n \t\t}\n \t    }\n \n-\t  for (e = body[i]->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, body[i]->succs)\n \t    {\n \t      if (flow_bb_inside_loop_p (loop, e->dest))\n \t\tcontinue;"}, {"sha": "e4d757a079875095d9b3f1039b714c8d2e167685", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1782,6 +1782,8 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n   while (1)\n     {\n+      basic_block tmp_bb;\n+\n       insn = BB_END (e->src);\n       if (any_condjump_p (insn))\n \t{\n@@ -1813,8 +1815,12 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t    }\n \t}\n \n-      e = e->src->pred;\n-      if (e->pred_next\n+      /* This is a bit subtle.  Store away e->src in tmp_bb, since we\n+\t modify `e' and this can invalidate the subsequent count of\n+\t e->src's predecessors by looking at the wrong block.  */\n+      tmp_bb = e->src;\n+      e = EDGE_PRED (tmp_bb, 0);\n+      if (EDGE_COUNT (tmp_bb->preds) > 1\n \t  || e->src == ENTRY_BLOCK_PTR)\n \tbreak;\n     }\n@@ -2493,7 +2499,7 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n {\n   basic_block exit_bb;\n   rtx condition, at;\n-  edge ei;\n+  edge ein;\n \n   exit_bb = e->src;\n   desc->simple_p = false;\n@@ -2510,18 +2516,18 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n   if (!any_condjump_p (BB_END (exit_bb)))\n     return;\n \n-  ei = exit_bb->succ;\n-  if (ei == e)\n-    ei = ei->succ_next;\n+  ein = EDGE_SUCC (exit_bb, 0);\n+  if (ein == e)\n+    ein = EDGE_SUCC (exit_bb, 1);\n \n   desc->out_edge = e;\n-  desc->in_edge = ei;\n+  desc->in_edge = ein;\n \n   /* Test whether the condition is suitable.  */\n-  if (!(condition = get_condition (BB_END (ei->src), &at, false, false)))\n+  if (!(condition = get_condition (BB_END (ein->src), &at, false, false)))\n     return;\n \n-  if (ei->flags & EDGE_FALLTHRU)\n+  if (ein->flags & EDGE_FALLTHRU)\n     {\n       condition = reversed_condition (condition);\n       if (!condition)\n@@ -2543,13 +2549,14 @@ find_simple_exit (struct loop *loop, struct niter_desc *desc)\n   edge e;\n   struct niter_desc act;\n   bool any = false;\n+  edge_iterator ei;\n \n   desc->simple_p = false;\n   body = get_loop_body (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      for (e = body[i]->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, body[i]->succs)\n \t{\n \t  if (flow_bb_inside_loop_p (loop, e->dest))\n \t    continue;"}, {"sha": "6ea0987e97e17875813b0b20aa5313ad57826d0d", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -454,7 +454,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned HOST_WIDE_INT npeel;\n   unsigned n_remove_edges, i;\n-  edge *remove_edges, ei;\n+  edge *remove_edges, ein;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   struct split_ivs_info *si_info = NULL;\n \n@@ -495,12 +495,12 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       free (remove_edges);\n     }\n \n-  ei = desc->in_edge;\n+  ein = desc->in_edge;\n   free_simple_loop_desc (loop);\n \n   /* Now remove the unreachable part of the last iteration and cancel\n      the loop.  */\n-  remove_path (loops, ei);\n+  remove_path (loops, ein);\n \n   if (dump_file)\n     fprintf (dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n@@ -748,15 +748,15 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n       basic_block exit_block = desc->in_edge->src->rbi->copy;\n       /* Find a new in and out edge; they are in the last copy we have made.  */\n       \n-      if (exit_block->succ->dest == desc->out_edge->dest)\n+      if (EDGE_SUCC (exit_block, 0)->dest == desc->out_edge->dest)\n \t{\n-\t  desc->out_edge = exit_block->succ;\n-\t  desc->in_edge = exit_block->succ->succ_next;\n+\t  desc->out_edge = EDGE_SUCC (exit_block, 0);\n+\t  desc->in_edge = EDGE_SUCC (exit_block, 1);\n \t}\n       else\n \t{\n-\t  desc->out_edge = exit_block->succ->succ_next;\n-\t  desc->in_edge = exit_block->succ;\n+\t  desc->out_edge = EDGE_SUCC (exit_block, 1);\n+\t  desc->in_edge = EDGE_SUCC (exit_block, 0);\n \t}\n     }\n \n@@ -1008,11 +1008,11 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n \n-      swtch = loop_split_edge_with (swtch->pred, branch_code);\n+      swtch = loop_split_edge_with (EDGE_PRED (swtch, 0), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      swtch->succ->probability = REG_BR_PROB_BASE - p;\n+      EDGE_SUCC (swtch, 0)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n-\t\t     swtch->succ->flags & EDGE_IRREDUCIBLE_LOOP);\n+\t\t     EDGE_SUCC (swtch, 0)->flags & EDGE_IRREDUCIBLE_LOOP);\n       e->probability = p;\n     }\n \n@@ -1025,11 +1025,11 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n \n-      swtch = loop_split_edge_with (swtch->succ, branch_code);\n+      swtch = loop_split_edge_with (EDGE_SUCC (swtch, 0), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      swtch->succ->probability = REG_BR_PROB_BASE - p;\n+      EDGE_SUCC (swtch, 0)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n-\t\t     swtch->succ->flags & EDGE_IRREDUCIBLE_LOOP);\n+\t\t     EDGE_SUCC (swtch, 0)->flags & EDGE_IRREDUCIBLE_LOOP);\n       e->probability = p;\n     }\n \n@@ -1061,15 +1061,15 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       basic_block exit_block = desc->in_edge->src->rbi->copy;\n       /* Find a new in and out edge; they are in the last copy we have made.  */\n       \n-      if (exit_block->succ->dest == desc->out_edge->dest)\n+      if (EDGE_SUCC (exit_block, 0)->dest == desc->out_edge->dest)\n \t{\n-\t  desc->out_edge = exit_block->succ;\n-\t  desc->in_edge = exit_block->succ->succ_next;\n+\t  desc->out_edge = EDGE_SUCC (exit_block, 0);\n+\t  desc->in_edge = EDGE_SUCC (exit_block, 1);\n \t}\n       else\n \t{\n-\t  desc->out_edge = exit_block->succ->succ_next;\n-\t  desc->in_edge = exit_block->succ;\n+\t  desc->out_edge = EDGE_SUCC (exit_block, 1);\n+\t  desc->in_edge = EDGE_SUCC (exit_block, 0);\n \t}\n     }\n "}, {"sha": "49608151ff75212201503c68a8e5ce474f56f045", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -180,14 +180,14 @@ may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n   enum machine_mode mode;\n \n   /* BB must end in a simple conditional jump.  */\n-  if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (bb->succs) != 2)\n     return NULL_RTX;\n   if (!any_condjump_p (BB_END (bb)))\n     return NULL_RTX;\n \n   /* With branches inside loop.  */\n-  if (!flow_bb_inside_loop_p (loop, bb->succ->dest)\n-      || !flow_bb_inside_loop_p (loop, bb->succ->succ_next->dest))\n+  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (bb, 0)->dest)\n+      || !flow_bb_inside_loop_p (loop, EDGE_SUCC (bb, 1)->dest))\n     return NULL_RTX;\n \n   /* It must be executed just once each iteration (because otherwise we\n@@ -414,16 +414,15 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   /* Some sanity checking.  */\n   if (!flow_bb_inside_loop_p (loop, unswitch_on))\n     abort ();\n-  if (!unswitch_on->succ || !unswitch_on->succ->succ_next ||\n-      unswitch_on->succ->succ_next->succ_next)\n+  if (EDGE_COUNT (unswitch_on->succs) != 2)\n     abort ();\n   if (!just_once_each_iteration_p (loop, unswitch_on))\n     abort ();\n   if (loop->inner)\n     abort ();\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->dest))\n+  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 0)->dest))\n     abort ();\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->succ_next->dest))\n+  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 1)->dest))\n     abort ();\n \n   entry = loop_preheader_edge (loop);\n@@ -444,7 +443,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   unswitch_on_alt = unswitch_on->rbi->copy;\n   true_edge = BRANCH_EDGE (unswitch_on_alt);\n   false_edge = FALLTHRU_EDGE (unswitch_on);\n-  latch_edge = loop->latch->rbi->copy->succ;\n+  latch_edge = EDGE_SUCC (loop->latch->rbi->copy, 0);\n \n   /* Create a block with the condition.  */\n   prob = true_edge->probability;\n@@ -463,19 +462,19 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   if (irred_flag)\n     {\n       switch_bb->flags |= BB_IRREDUCIBLE_LOOP;\n-      switch_bb->succ->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      switch_bb->succ->succ_next->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (switch_bb, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (switch_bb, 1)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n   else\n     {\n       switch_bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n-      switch_bb->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-      switch_bb->succ->succ_next->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (switch_bb, 0)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_SUCC (switch_bb, 1)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n   nloop = loopify (loops, latch_edge,\n-\t\t   loop->header->rbi->copy->pred, switch_bb, true);\n+\t\t   EDGE_PRED (loop->header->rbi->copy, 0), switch_bb, true);\n \n   /* Remove branches that are now unreachable in new loops.  */\n   remove_path (loops, true_edge);"}, {"sha": "ea68597cb6cead015d1205a84896d08bc69820d3", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -671,9 +671,9 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n   rtx orig_loop_bct = NULL_RTX;\n \n   /* Loop header edge.  */\n-  e = ps->g->bb->pred;\n+  e = EDGE_PRED (ps->g->bb, 0);\n   if (e->src == ps->g->bb)\n-    e = e->pred_next;\n+    e = EDGE_PRED (ps->g->bb, 1);\n \n   /* Generate the prolog, inserting its insns on the loop-entry edge.  */\n   start_sequence ();\n@@ -726,9 +726,9 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n       loop_exit_label_insn = emit_label (loop_exit_label);\n     }\n \n-  e = ps->g->bb->succ;\n+  e = EDGE_SUCC (ps->g->bb, 0);\n   if (e->dest == ps->g->bb)\n-    e = e->succ_next;\n+    e = EDGE_SUCC (ps->g->bb, 1);\n \n   e->insns.r = get_insns ();\n   end_sequence ();\n@@ -742,7 +742,7 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n       basic_block epilog_bb = BLOCK_FOR_INSN (last_epilog_insn);\n       basic_block precond_bb = BLOCK_FOR_INSN (precond_jump);\n       basic_block orig_loop_bb = BLOCK_FOR_INSN (precond_exit_label_insn);\n-      edge epilog_exit_edge = epilog_bb->succ;\n+      edge epilog_exit_edge = EDGE_SUCC (epilog_bb, 0);\n \n       /* Do loop preconditioning to take care of cases were the loop count is\n \t less than the stage count.  Update the CFG properly.  */\n@@ -851,28 +851,25 @@ sms_schedule (FILE *dump_file)\n \tcontinue;\n \n       /* Check if bb has two successors, one being itself.  */\n-      e = bb->succ;\n-      if (!e || !e->succ_next || e->succ_next->succ_next)\n+      if (EDGE_COUNT (bb->succs) != 2)\n \tcontinue;\n \n-      if (e->dest != bb && e->succ_next->dest != bb)\n+      if (EDGE_SUCC (bb, 0)->dest != bb && EDGE_SUCC (bb, 1)->dest != bb)\n \tcontinue;\n \n-      if ((e->flags & EDGE_COMPLEX)\n-\t  || (e->succ_next->flags & EDGE_COMPLEX))\n+      if ((EDGE_SUCC (bb, 0)->flags & EDGE_COMPLEX)\n+\t  || (EDGE_SUCC (bb, 1)->flags & EDGE_COMPLEX))\n \tcontinue;\n \n       /* Check if bb has two predecessors, one being itself.  */\n-      /* In view of above tests, suffices to check e->pred_next->pred_next?  */\n-      e = bb->pred;\n-      if (!e || !e->pred_next || e->pred_next->pred_next)\n+      if (EDGE_COUNT (bb->preds) != 2)\n \tcontinue;\n \n-      if (e->src != bb && e->pred_next->src != bb)\n+      if (EDGE_PRED (bb, 0)->src != bb && EDGE_PRED (bb, 1)->src != bb)\n \tcontinue;\n \n-      if ((e->flags & EDGE_COMPLEX)\n-\t  || (e->pred_next->flags & EDGE_COMPLEX))\n+      if ((EDGE_PRED (bb, 0)->flags & EDGE_COMPLEX)\n+\t  || (EDGE_PRED (bb, 1)->flags & EDGE_COMPLEX))\n \tcontinue;\n \n       /* For debugging.  */\n@@ -884,9 +881,9 @@ sms_schedule (FILE *dump_file)\n \t}\n \n       get_block_head_tail (bb->index, &head, &tail);\n-      pre_header_edge = bb->pred;\n-      if (bb->pred->src != bb)\n-\tpre_header_edge = bb->pred->pred_next;\n+      pre_header_edge = EDGE_PRED (bb, 0);\n+      if (EDGE_PRED (bb, 0)->src != bb)\n+\tpre_header_edge = EDGE_PRED (bb, 1);\n \n       /* Perfrom SMS only on loops that their average count is above threshold.  */\n       if (bb->count < pre_header_edge->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD)\n@@ -926,9 +923,9 @@ sms_schedule (FILE *dump_file)\n       if ( !(count_reg = doloop_register_get (tail, &comp)))\n \tcontinue;\n \n-      e = bb->pred;\n+      e = EDGE_PRED (bb, 0);\n       if (e->src == bb)\n-\tpre_header = e->pred_next->src;\n+\tpre_header = EDGE_PRED (bb, 1)->src;\n       else\n \tpre_header = e->src;\n \n@@ -987,9 +984,9 @@ sms_schedule (FILE *dump_file)\n \n       get_block_head_tail (g->bb->index, &head, &tail);\n \n-      pre_header_edge = g->bb->pred;\n-      if (g->bb->pred->src != g->bb)\n-\tpre_header_edge = g->bb->pred->pred_next;\n+      pre_header_edge = EDGE_PRED (g->bb, 0);\n+      if (EDGE_PRED (g->bb, 0)->src != g->bb)\n+\tpre_header_edge = EDGE_PRED (g->bb, 1);\n \n       if (stats_file)\n \t{"}, {"sha": "144cc5f67b687e137bd57b59e64a211efe5c60da", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -968,11 +968,12 @@ static bool\n bb_has_well_behaved_predecessors (basic_block bb)\n {\n   edge pred;\n+  edge_iterator ei;\n \n-  if (! bb->pred)\n+  if (EDGE_COUNT (bb->preds) == 0)\n     return false;\n \n-  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n+  FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n       if ((pred->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (pred))\n \treturn false;\n@@ -1023,6 +1024,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n   int npred_ok = 0;\n   gcov_type ok_count = 0; /* Redundant load execution count.  */\n   gcov_type critical_count = 0; /* Execution count of critical edges.  */\n+  edge_iterator ei;\n \n   /* The execution count of the loads to be added to make the\n      load fully redundant.  */\n@@ -1038,7 +1040,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n     return;\n \n   /* Check potential for replacing load with copy for predecessors.  */\n-  for (pred = bb->pred; pred; pred = pred->pred_next)\n+  FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n       rtx next_pred_bb_end;\n "}, {"sha": "8611f30d8aa55bf513a5608f3c0d9e9503b4ee9a", "filename": "gcc/predict.c", "status": "modified", "additions": 55, "deletions": 40, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -248,7 +248,7 @@ can_predict_insn_p (rtx insn)\n {\n   return (JUMP_P (insn)\n \t  && any_condjump_p (insn)\n-\t  && BLOCK_FOR_INSN (insn)->succ->succ_next);\n+\t  && EDGE_COUNT (BLOCK_FOR_INSN (insn)->succs) >= 2);\n }\n \n /* Predict edge E by given predictor if possible.  */\n@@ -287,13 +287,15 @@ static void\n dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n \t\t basic_block bb, int used)\n {\n-  edge e = bb->succ;\n+  edge e;\n+  edge_iterator ei;\n \n   if (!file)\n     return;\n \n-  while (e && (e->flags & EDGE_FALLTHRU))\n-    e = e->succ_next;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (! (e->flags & EDGE_FALLTHRU))\n+      break;\n \n   fprintf (file, \"  %s heuristics%s: %.1f%%\",\n \t   predictor_info[predictor].name,\n@@ -321,11 +323,12 @@ set_even_probabilities (basic_block bb)\n {\n   int nedges = 0;\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n       nedges ++;\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n       e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n     else\n@@ -430,22 +433,22 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n \n       /* Save the prediction into CFG in case we are seeing non-degenerated\n \t conditional jump.  */\n-      if (bb->succ->succ_next)\n+      if (EDGE_COUNT (bb->succs) > 1)\n \t{\n \t  BRANCH_EDGE (bb)->probability = combined_probability;\n \t  FALLTHRU_EDGE (bb)->probability\n \t    = REG_BR_PROB_BASE - combined_probability;\n \t}\n     }\n-  else if (bb->succ->succ_next)\n+  else if (EDGE_COUNT (bb->succs) > 1)\n     {\n       int prob = INTVAL (XEXP (prob_note, 0));\n \n       BRANCH_EDGE (bb)->probability = prob;\n       FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - prob;\n     }\n   else\n-    bb->succ->probability = REG_BR_PROB_BASE;\n+    EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n }\n \n /* Combine predictions into single probability and store them into CFG.\n@@ -463,11 +466,12 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n   struct edge_prediction *pred;\n   int nedges = 0;\n   edge e, first = NULL, second = NULL;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n       {\n-        nedges ++;\n+\tnedges ++;\n \tif (first && !second)\n \t  second = e;\n \tif (!first)\n@@ -547,7 +551,7 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n       int predictor = pred->predictor;\n       int probability = pred->probability;\n \n-      if (pred->edge != bb->succ)\n+      if (pred->edge != EDGE_SUCC (bb, 0))\n \tprobability = REG_BR_PROB_BASE - probability;\n       dump_prediction (file, predictor, probability, bb,\n \t\t       !first_match || best_predictor == predictor);\n@@ -651,6 +655,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t{\n \t  int header_found = 0;\n \t  edge e;\n+\t  edge_iterator ei;\n \n \t  bb = bbs[j];\n \n@@ -664,7 +669,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \n \t  /* Loop branch heuristics - predict an edge back to a\n \t     loop's head as taken.  */\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->dest == loop->header\n \t\t&& e->src == loop->latch)\n \t      {\n@@ -675,7 +680,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t  /* Loop exit heuristics - predict an edge exiting the loop if the\n \t     conditional has no loop header successors as not taken.  */\n \t  if (!header_found)\n-\t    for (e = bb->succ; e; e = e->succ_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      if (e->dest->index < 0\n \t\t  || !flow_bb_inside_loop_p (loop, e->dest))\n \t\tpredict_edge\n@@ -814,18 +819,19 @@ estimate_probability (struct loops *loops_info)\n     {\n       rtx last_insn = BB_END (bb);\n       edge e;\n+      edge_iterator ei;\n \n       if (! can_predict_insn_p (last_insn))\n \tcontinue;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  /* Predict early returns to be probable, as we've already taken\n \t     care for error returns and other are often used for fast paths\n \t     trought function.  */\n \t  if ((e->dest == EXIT_BLOCK_PTR\n-\t       || (e->dest->succ && !e->dest->succ->succ_next\n-\t\t   && e->dest->succ->dest == EXIT_BLOCK_PTR))\n+\t       || (EDGE_COUNT (e->dest->succs) == 1\n+\t\t   && EDGE_SUCC (e->dest, 0)->dest == EXIT_BLOCK_PTR))\n \t       && !predicted_by_p (bb, PRED_NULL_RETURN)\n \t       && !predicted_by_p (bb, PRED_CONST_RETURN)\n \t       && !predicted_by_p (bb, PRED_NEGATIVE_RETURN)\n@@ -1021,12 +1027,13 @@ tree_predict_by_opcode (basic_block bb)\n   tree type;\n   tree val;\n   bitmap visited;\n+  edge_iterator ei;\n \n   if (!stmt || TREE_CODE (stmt) != COND_EXPR)\n     return;\n-  for (then_edge = bb->succ; then_edge; then_edge = then_edge->succ_next)\n+  FOR_EACH_EDGE (then_edge, ei, bb->succs)\n     if (then_edge->flags & EDGE_TRUE_VALUE)\n-       break;\n+      break;\n   cond = TREE_OPERAND (stmt, 0);\n   if (!COMPARISON_CLASS_P (cond))\n     return;\n@@ -1180,8 +1187,9 @@ apply_return_prediction (int *heads)\n   int phi_num_args, i;\n   enum br_predictor pred;\n   enum prediction direction;\n+  edge_iterator ei;\n \n-  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     {\n       return_stmt = last_stmt (e->src);\n       if (TREE_CODE (return_stmt) == RETURN_EXPR)\n@@ -1297,19 +1305,21 @@ tree_estimate_probability (void)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  /* Predict early returns to be probable, as we've already taken\n \t     care for error returns and other cases are often used for\n \t     fast paths trought function.  */\n \t  if (e->dest == EXIT_BLOCK_PTR\n \t      && TREE_CODE (last_stmt (bb)) == RETURN_EXPR\n-\t      && bb->pred && bb->pred->pred_next)\n+\t      && EDGE_COUNT (bb->preds) > 1)\n \t    {\n \t      edge e1;\n+\t      edge_iterator ei1;\n \n-\t      for (e1 = bb->pred; e1; e1 = e1->pred_next)\n+\t      FOR_EACH_EDGE (e1, ei1, bb->preds)\n \t      \tif (!predicted_by_p (e1->src, PRED_NULL_RETURN)\n \t\t    && !predicted_by_p (e1->src, PRED_CONST_RETURN)\n \t\t    && !predicted_by_p (e1->src, PRED_NEGATIVE_RETURN)\n@@ -1447,8 +1457,8 @@ last_basic_block_p (basic_block bb)\n \n   return (bb->next_bb == EXIT_BLOCK_PTR\n \t  || (bb->next_bb->next_bb == EXIT_BLOCK_PTR\n-\t      && bb->succ && !bb->succ->succ_next\n-\t      && bb->succ->dest->next_bb == EXIT_BLOCK_PTR));\n+\t      && EDGE_COUNT (bb->succs) == 1\n+\t      && EDGE_SUCC (bb, 0)->dest->next_bb == EXIT_BLOCK_PTR));\n }\n \n /* Sets branch probabilities according to PREDiction and\n@@ -1462,6 +1472,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n \t\t\t  enum prediction taken)\n {\n   edge e;\n+  edge_iterator ei;\n   int y;\n \n   if (heads[bb->index] < 0)\n@@ -1501,7 +1512,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n \n   if (y == last_basic_block)\n     return;\n-  for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (y)->succs)\n     if (e->dest->index >= 0\n \t&& dominated_by_p (CDI_POST_DOMINATORS, e->dest, bb))\n       predict_edge_def (e, pred, taken);\n@@ -1557,9 +1568,10 @@ propagate_freq (struct loop *loop)\n     {\n       if (BLOCK_INFO (bb)->tovisit)\n \t{\n+\t  edge_iterator ei;\n \t  int count = 0;\n \n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n \t      count++;\n \t    else if (BLOCK_INFO (e->src)->tovisit\n@@ -1575,6 +1587,7 @@ propagate_freq (struct loop *loop)\n   last = head;\n   for (bb = head; bb; bb = nextbb)\n     {\n+      edge_iterator ei;\n       sreal cyclic_probability, frequency;\n \n       memcpy (&cyclic_probability, &real_zero, sizeof (real_zero));\n@@ -1587,12 +1600,12 @@ propagate_freq (struct loop *loop)\n       if (bb != head)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n \t      abort ();\n #endif\n \n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (EDGE_INFO (e)->back_edge)\n \t      {\n \t\tsreal_add (&cyclic_probability, &cyclic_probability,\n@@ -1637,23 +1650,23 @@ propagate_freq (struct loop *loop)\n       BLOCK_INFO (bb)->tovisit = 0;\n \n       /* Compute back edge frequencies.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest == head)\n \t  {\n \t    sreal tmp;\n-\n+\t    \n \t    /* EDGE_INFO (e)->back_edge_prob\n-\t\t  = ((e->probability * BLOCK_INFO (bb)->frequency)\n-\t\t     / REG_BR_PROB_BASE); */\n-\n+\t       = ((e->probability * BLOCK_INFO (bb)->frequency)\n+\t       / REG_BR_PROB_BASE); */\n+\t    \n \t    sreal_init (&tmp, e->probability, 0);\n \t    sreal_mul (&tmp, &tmp, &BLOCK_INFO (bb)->frequency);\n \t    sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n \t\t       &tmp, &real_inv_br_prob_base);\n \t  }\n \n       /* Propagate to successor blocks.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (!(e->flags & EDGE_DFS_BACK)\n \t    && BLOCK_INFO (e->dest)->npredecessors)\n \t  {\n@@ -1664,10 +1677,10 @@ propagate_freq (struct loop *loop)\n \t\t  nextbb = e->dest;\n \t\telse\n \t\t  BLOCK_INFO (last)->next = e->dest;\n-\n+\t\t\n \t\tlast = e->dest;\n \t      }\n-\t   }\n+\t  }\n     }\n }\n \n@@ -1686,7 +1699,8 @@ estimate_loops_at_level (struct loop *first_loop)\n \n       estimate_loops_at_level (loop->inner);\n \n-      if (loop->latch->succ)  /* Do not do this for dummy function loop.  */\n+      /* Do not do this for dummy function loop.  */\n+      if (EDGE_COUNT (loop->latch->succs) > 0)\n \t{\n \t  /* Find current loop back edge and mark it.  */\n \t  e = loop_latch_edge (loop);\n@@ -1787,17 +1801,18 @@ estimate_bb_frequencies (struct loops *loops)\n \n       mark_dfs_back_edges ();\n \n-      ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n+      EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->probability = REG_BR_PROB_BASE;\n \n       /* Set up block info for each basic block.  */\n       alloc_aux_for_blocks (sizeof (struct block_info_def));\n       alloc_aux_for_edges (sizeof (struct edge_info_def));\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n \t  BLOCK_INFO (bb)->tovisit = 0;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      sreal_init (&EDGE_INFO (e)->back_edge_prob, e->probability, 0);\n \t      sreal_mul (&EDGE_INFO (e)->back_edge_prob,"}, {"sha": "2bad285e1d96ce1b8947022b35b27cc7a811fea9", "filename": "gcc/profile.c", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -142,8 +142,9 @@ instrument_edges (struct edge_list *el)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  struct edge_info *inf = EDGE_INFO (e);\n \n@@ -239,7 +240,9 @@ get_exec_counts (void)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n \t  num_edges++;\n     }\n@@ -295,11 +298,12 @@ compute_branch_probabilities (void)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (!EDGE_INFO (e)->ignore)\n \t  BB_INFO (bb)->succ_count++;\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!EDGE_INFO (e)->ignore)\n \t  BB_INFO (bb)->pred_count++;\n     }\n@@ -317,7 +321,9 @@ compute_branch_probabilities (void)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n \t  {\n \t    num_edges++;\n@@ -380,9 +386,10 @@ compute_branch_probabilities (void)\n \t      if (bi->succ_count == 0)\n \t\t{\n \t\t  edge e;\n+\t\t  edge_iterator ei;\n \t\t  gcov_type total = 0;\n \n-\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    total += e->count;\n \t\t  bb->count = total;\n \t\t  bi->count_valid = 1;\n@@ -391,9 +398,10 @@ compute_branch_probabilities (void)\n \t      else if (bi->pred_count == 0)\n \t\t{\n \t\t  edge e;\n+\t\t  edge_iterator ei;\n \t\t  gcov_type total = 0;\n \n-\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    total += e->count;\n \t\t  bb->count = total;\n \t\t  bi->count_valid = 1;\n@@ -405,15 +413,16 @@ compute_branch_probabilities (void)\n \t      if (bi->succ_count == 1)\n \t\t{\n \t\t  edge e;\n+\t\t  edge_iterator ei;\n \t\t  gcov_type total = 0;\n \n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    total += e->count;\n \n \t\t  /* Seedgeh for the invalid edge, and set its count.  */\n-\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n \t\t      break;\n \n@@ -432,15 +441,16 @@ compute_branch_probabilities (void)\n \t      if (bi->pred_count == 1)\n \t\t{\n \t\t  edge e;\n+\t\t  edge_iterator ei;\n \t\t  gcov_type total = 0;\n \n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    total += e->count;\n \n \t\t  /* Search for the invalid edge, and set its count.  */\n-\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    if (!EDGE_INFO (e)->count_valid && !EDGE_INFO (e)->ignore)\n \t\t      break;\n \n@@ -485,6 +495,7 @@ compute_branch_probabilities (void)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n+      edge_iterator ei;\n       rtx note;\n \n       if (bb->count < 0)\n@@ -493,7 +504,7 @@ compute_branch_probabilities (void)\n \t\t bb->index, (int)bb->count);\n \t  bb->count = 0;\n \t}\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  /* Function may return twice in the cased the called function is\n \t     setjmp or calls fork, but we can't represent this by extra\n@@ -518,21 +529,21 @@ compute_branch_probabilities (void)\n \t}\n       if (bb->count)\n \t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    e->probability = (e->count * REG_BR_PROB_BASE + bb->count / 2) / bb->count;\n \t  if (bb->index >= 0\n \t      && block_ends_with_condjump_p (bb)\n-\t      && bb->succ->succ_next)\n+\t      && EDGE_COUNT (bb->succs) >= 2)\n \t    {\n \t      int prob;\n \t      edge e;\n \t      int index;\n \n \t      /* Find the branch edge.  It is possible that we do have fake\n \t\t edges here.  */\n-\t      for (e = bb->succ; e->flags & (EDGE_FAKE | EDGE_FALLTHRU);\n-\t\t   e = e->succ_next)\n-\t\tcontinue; /* Loop body has been intentionally left blank.  */\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (!(e->flags & (EDGE_FAKE | EDGE_FALLTHRU)))\n+\t\t  break;\n \n \t      prob = e->probability;\n \t      index = prob * 20 / REG_BR_PROB_BASE;\n@@ -561,7 +572,7 @@ compute_branch_probabilities (void)\n          tree based profile guessing put into code.  */\n       else if (profile_status == PROFILE_ABSENT\n \t       && !ir_type ()\n-\t       && bb->succ && bb->succ->succ_next\n+\t       && EDGE_COUNT (bb->succs) > 1\n \t       && (note = find_reg_note (BB_END (bb), REG_BR_PROB, 0)))\n \t{\n \t  int prob = INTVAL (XEXP (note, 0));\n@@ -578,27 +589,26 @@ compute_branch_probabilities (void)\n \t{\n \t  int total = 0;\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n \t      total ++;\n \t  if (total)\n \t    {\n-\t      for (e = bb->succ; e; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n \t\t  e->probability = REG_BR_PROB_BASE / total;\n \t\telse\n \t\t  e->probability = 0;\n \t    }\n \t  else\n \t    {\n-\t      for (e = bb->succ; e; e = e->succ_next)\n-\t\ttotal ++;\n-\t      for (e = bb->succ; e; e = e->succ_next)\n+\t      total += EDGE_COUNT (bb->succs);\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\te->probability = REG_BR_PROB_BASE / total;\n \t    }\n \t  if (bb->index >= 0\n \t      && block_ends_with_condjump_p (bb)\n-\t      && bb->succ->succ_next)\n+\t      && EDGE_COUNT (bb->succs) >= 2)\n \t    num_branches++, num_never_executed;\n \t}\n     }\n@@ -789,22 +799,23 @@ branch_prob (void)\n       int need_exit_edge = 0, need_entry_edge = 0;\n       int have_exit_edge = 0, have_entry_edge = 0;\n       edge e;\n+      edge_iterator ei;\n \n       /* Functions returning multiple times are not handled by extra edges.\n          Instead we simply allow negative counts on edges from exit to the\n          block past call and corresponding probabilities.  We can't go\n          with the extra edges because that would result in flowgraph that\n \t needs to have fake edges outside the spanning tree.  */\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n \t       && e->dest != EXIT_BLOCK_PTR)\n \t    need_exit_edge = 1;\n \t  if (e->dest == EXIT_BLOCK_PTR)\n \t    have_exit_edge = 1;\n \t}\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n \t       && e->src != ENTRY_BLOCK_PTR)\n@@ -915,11 +926,12 @@ branch_prob (void)\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \n \t  offset = gcov_write_tag (GCOV_TAG_ARCS);\n \t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      struct edge_info *i = EDGE_INFO (e);\n \t      if (!i->ignore)\n@@ -1037,10 +1049,10 @@ branch_prob (void)\n \n \t      /* Notice GOTO expressions we eliminated while constructing the\n \t\t CFG.  */\n-\t      if (bb->succ && !bb->succ->succ_next && bb->succ->goto_locus)\n+\t      if (EDGE_COUNT (bb->succs) == 1 && EDGE_SUCC (bb, 0)->goto_locus)\n \t\t{\n \t\t  /* ??? source_locus type is marked deprecated in input.h.  */\n-\t\t  source_locus curr_location = bb->succ->goto_locus;\n+\t\t  source_locus curr_location = EDGE_SUCC (bb, 0)->goto_locus;\n \t\t  /* ??? The FILE/LINE API is inconsistent for these cases.  */\n #ifdef USE_MAPPED_LOCATION \n \t\t  output_location (LOCATION_FILE (curr_location),"}, {"sha": "b66e0972c7d7ea9cc800664141d1afe59711e0f4", "filename": "gcc/ra-build.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -924,6 +924,7 @@ live_in (struct df *df, struct curr_use *use, rtx insn)\n      are allowed.  */\n   while (1)\n     {\n+      unsigned int i;\n       int uid = INSN_UID (insn);\n       basic_block bb = BLOCK_FOR_INSN (insn);\n       number_seen[uid]++;\n@@ -940,7 +941,7 @@ live_in (struct df *df, struct curr_use *use, rtx insn)\n \t  edge e;\n \t  unsigned HOST_WIDE_INT undef = use->undefined;\n \t  struct ra_bb_info *info = (struct ra_bb_info *) bb->aux;\n-\t  if ((e = bb->pred) == NULL)\n+\t  if (EDGE_COUNT (bb->preds) == 0)\n \t    return;\n \t  /* We now check, if we already traversed the predecessors of this\n \t     block for the current pass and the current set of undefined\n@@ -952,8 +953,9 @@ live_in (struct df *df, struct curr_use *use, rtx insn)\n \t  info->pass = loc_vpass;\n \t  info->undefined = undef;\n \t  /* All but the last predecessor are handled recursively.  */\n-\t  for (; e->pred_next; e = e->pred_next)\n+\t  for (e = NULL, i = 0; i < EDGE_COUNT (bb->preds) - 1; i++)\n \t    {\n+\t      e = EDGE_PRED (bb, i);\n \t      insn = live_in_edge (df, use, e);\n \t      if (insn)\n \t\tlive_in (df, use, insn);"}, {"sha": "fa00e3706482d6bd4181b494c0f78ba4f9b8bf7b", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1350,13 +1350,17 @@ rewrite_program2 (bitmap new_deaths)\n \t  int in_ir = 0;\n \t  edge e;\n \t  int num = 0;\n+\t  edge_iterator ei;\n \t  bitmap_iterator bi;\n \n \t  HARD_REG_SET cum_colors, colors;\n \t  CLEAR_HARD_REG_SET (cum_colors);\n-\t  for (e = bb->pred; e && num < 5; e = e->pred_next, num++)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      int j;\n+\n+\t      if (num >= 5)\n+\t\tbreak;\n \t      CLEAR_HARD_REG_SET (colors);\n \t      EXECUTE_IF_SET_IN_BITMAP (live_at_end[e->src->index], 0, j, bi)\n \t\t{\n@@ -1366,6 +1370,7 @@ rewrite_program2 (bitmap new_deaths)\n \t\t    update_spill_colors (&colors, web, 1);\n \t\t}\n \t      IOR_HARD_REG_SET (cum_colors, colors);\n+\t      num++;\n \t    }\n \t  if (num == 5)\n \t    in_ir = 1;"}, {"sha": "0b84dfc90b0e9be119bdaef7fdc1ba6054711b0d", "filename": "gcc/ra.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -682,7 +682,9 @@ reg_alloc (void)\n   if (last)\n     {\n       edge e;\n-      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n \t  basic_block bb = e->src;\n \t  last = BB_END (bb);"}, {"sha": "61e1186d07abb5b0383353df4d5c75eb834b0910", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -3116,9 +3116,9 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t  if (note || (was_call && nonlocal_goto_handler_labels))\n \t\t    {\n \t\t      edge eh_edge;\n+\t\t      edge_iterator ei;\n \n-\t\t      for (eh_edge = bb->succ; eh_edge\n-\t\t\t   ; eh_edge = eh_edge->succ_next)\n+\t\t      FOR_EACH_EDGE (eh_edge, ei, bb->succs)\n \t\t\tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n \t\t\t  break;\n "}, {"sha": "b13753863a44e52ecca234320a2edf16e9f89df5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -442,7 +442,9 @@ reg_to_stack (FILE *file)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       edge e;\n-      for (e = bb->pred; e; e = e->pred_next)\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!(e->flags & EDGE_DFS_BACK)\n \t    && e->src != ENTRY_BLOCK_PTR)\n \t  BLOCK_INFO (bb)->predecessors++;\n@@ -2528,6 +2530,7 @@ convert_regs_entry (void)\n {\n   int inserted = 0;\n   edge e;\n+  edge_iterator ei;\n   basic_block block;\n \n   FOR_EACH_BB_REVERSE (block)\n@@ -2557,7 +2560,7 @@ convert_regs_entry (void)\n      Note that we are inserting converted code here.  This code is\n      never seen by the convert_regs pass.  */\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       basic_block block = e->dest;\n       block_info bi = BLOCK_INFO (block);\n@@ -2717,7 +2720,7 @@ compensate_edge (edge e, FILE *file)\n      instead of to the edge, because emit_swap can do minimal\n      insn scheduling.  We can do this when there is only one\n      edge out, and it is not abnormal.  */\n-  else if (block->succ->succ_next == NULL && !(e->flags & EDGE_ABNORMAL))\n+  else if (EDGE_COUNT (block->succs) == 1 && !(e->flags & EDGE_ABNORMAL))\n     {\n       /* change_stack kills values in regstack.  */\n       tmpstack = regstack;\n@@ -2764,6 +2767,7 @@ convert_regs_1 (FILE *file, basic_block block)\n   rtx insn, next;\n   edge e, beste = NULL;\n   bool control_flow_insn_deleted = false;\n+  edge_iterator ei;\n \n   inserted = 0;\n   deleted = 0;\n@@ -2774,7 +2778,7 @@ convert_regs_1 (FILE *file, basic_block block)\n      if multiple such exists, take one with largest count, prefer critical\n      one (as splitting critical edges is more expensive), or one with lowest\n      index, to avoid random changes with different orders of the edges.  */\n-  for (e = block->pred; e ; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, block->preds)\n     {\n       if (e->flags & EDGE_DFS_BACK)\n \t;\n@@ -2923,7 +2927,7 @@ convert_regs_1 (FILE *file, basic_block block)\n   bi->stack_out = regstack;\n \n   /* Compensate the back edges, as those wasn't visited yet.  */\n-  for (e = block->succ; e ; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, block->succs)\n     {\n       if (e->flags & EDGE_DFS_BACK\n \t  || (e->dest == EXIT_BLOCK_PTR))\n@@ -2933,7 +2937,7 @@ convert_regs_1 (FILE *file, basic_block block)\n \t  inserted |= compensate_edge (e, file);\n \t}\n     }\n-  for (e = block->pred; e ; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, block->preds)\n     {\n       if (e != beste && !(e->flags & EDGE_DFS_BACK)\n \t  && e->src != ENTRY_BLOCK_PTR)\n@@ -2967,6 +2971,7 @@ convert_regs_2 (FILE *file, basic_block block)\n   do\n     {\n       edge e;\n+      edge_iterator ei;\n \n       block = *--sp;\n \n@@ -2983,12 +2988,12 @@ convert_regs_2 (FILE *file, basic_block block)\n \t stack the successor in all cases and hand over the task of\n \t fixing up the discrepancy to convert_regs_1.  */\n \n-      for (e = block->succ; e ; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, block->succs)\n \tif (! (e->flags & EDGE_DFS_BACK))\n \t  {\n \t    BLOCK_INFO (e->dest)->predecessors--;\n \t    if (!BLOCK_INFO (e->dest)->predecessors)\n-\t       *sp++ = e->dest;\n+\t      *sp++ = e->dest;\n \t  }\n \n       inserted |= convert_regs_1 (file, block);\n@@ -3009,6 +3014,7 @@ convert_regs (FILE *file)\n   int inserted;\n   basic_block b;\n   edge e;\n+  edge_iterator ei;\n \n   /* Initialize uninitialized registers on function entry.  */\n   inserted = convert_regs_entry ();\n@@ -3022,7 +3028,7 @@ convert_regs (FILE *file)\n      prevent double fxch that often appears at the head of a loop.  */\n \n   /* Process all blocks reachable from all entry points.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     inserted |= convert_regs_2 (file, e->dest);\n \n   /* ??? Process all unreachable blocks.  Though there's no excuse"}, {"sha": "330ed3b4284c342b1d47a5e8c47c42a5cffeec10", "filename": "gcc/regrename.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1750,14 +1750,13 @@ copyprop_hardreg_forward (void)\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (bb->pred)\n-\tfor (bbp = bb; bbp && bbp != bb->pred->src; bbp = bbp->prev_bb);\n-      if (bb->pred\n-\t  && ! bb->pred->pred_next\n-\t  && ! (bb->pred->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n-\t  && bb->pred->src != ENTRY_BLOCK_PTR\n+      if (EDGE_COUNT (bb->preds) > 0)\n+\tfor (bbp = bb; bbp && bbp != EDGE_PRED (bb, 0)->src; bbp = bbp->prev_bb);\n+      if (EDGE_COUNT (bb->preds) == 1\n+\t  && ! (EDGE_PRED (bb, 0)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+\t  && EDGE_PRED (bb, 0)->src != ENTRY_BLOCK_PTR\n \t  && bbp)\n-\tall_vd[bb->index] = all_vd[bb->pred->src->index];\n+\tall_vd[bb->index] = all_vd[EDGE_PRED (bb, 0)->src->index];\n       else\n \tinit_value_data (all_vd + bb->index);\n "}, {"sha": "3a8c19e9711102ea370f261f4b2f23b2fbac1586", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -8033,10 +8033,11 @@ fixup_abnormal_edges (void)\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n+      edge_iterator ei;\n \n       /* Look for cases we are interested in - calls or instructions causing\n          exceptions.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->flags & EDGE_ABNORMAL_CALL)\n \t    break;\n@@ -8049,7 +8050,7 @@ fixup_abnormal_edges (void)\n \t{\n \t  rtx insn = BB_END (bb), stop = NEXT_INSN (BB_END (bb));\n \t  rtx next;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_FALLTHRU)\n \t      break;\n \t  /* Get past the new insns generated. Allow notes, as the insns may"}, {"sha": "554a42580760b17dbb72a5f57229f2690812cb87", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -514,24 +514,27 @@ sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src, int bb)\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n   edge e;\n+  unsigned ix;\n \n-  for (e = b->succ; e != 0; e = e->succ_next)\n+  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n+      e = EDGE_SUCC (b, ix);\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n-\n+      \n       sbitmap_copy (dst, src[e->dest->index]);\n       break;\n     }\n \n   if (e == 0)\n     sbitmap_ones (dst);\n   else\n-    for (e = e->succ_next; e != 0; e = e->succ_next)\n+    for (++ix; ix < EDGE_COUNT (b->succs); ix++)\n       {\n \tunsigned int i;\n \tsbitmap_ptr p, r;\n \n+\te = EDGE_SUCC (b, ix);\n \tif (e->dest == EXIT_BLOCK_PTR)\n \t  continue;\n \n@@ -551,9 +554,11 @@ sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src, int bb)\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n   edge e;\n+  unsigned ix;\n \n-  for (e = b->pred; e != 0; e = e->pred_next)\n+  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n+      e = EDGE_PRED (b, ix);\n       if (e->src == ENTRY_BLOCK_PTR)\n \tcontinue;\n \n@@ -564,11 +569,12 @@ sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src, int bb)\n   if (e == 0)\n     sbitmap_ones (dst);\n   else\n-    for (e = e->pred_next; e != 0; e = e->pred_next)\n+    for (++ix; ix < EDGE_COUNT (b->preds); ix++)\n       {\n \tunsigned int i;\n \tsbitmap_ptr p, r;\n \n+\te = EDGE_PRED (b, ix);\n \tif (e->src == ENTRY_BLOCK_PTR)\n \t  continue;\n \n@@ -588,24 +594,27 @@ sbitmap_union_of_succs (sbitmap dst, sbitmap *src, int bb)\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n   edge e;\n+  unsigned ix;\n \n-  for (e = b->succ; e != 0; e = e->succ_next)\n+  for (ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n+      e = EDGE_SUCC (b, ix);\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n \n       sbitmap_copy (dst, src[e->dest->index]);\n       break;\n     }\n \n-  if (e == 0)\n+  if (ix == EDGE_COUNT (b->succs))\n     sbitmap_zero (dst);\n   else\n-    for (e = e->succ_next; e != 0; e = e->succ_next)\n+    for (ix++; ix < EDGE_COUNT (b->succs); ix++)\n       {\n \tunsigned int i;\n \tsbitmap_ptr p, r;\n \n+\te = EDGE_SUCC (b, ix);\n \tif (e->dest == EXIT_BLOCK_PTR)\n \t  continue;\n \n@@ -625,8 +634,9 @@ sbitmap_union_of_preds (sbitmap dst, sbitmap *src, int bb)\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n   edge e;\n+  unsigned ix;\n \n-  for (e = b->pred; e != 0; e = e->pred_next)\n+  for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n       if (e->src== ENTRY_BLOCK_PTR)\n \tcontinue;\n@@ -635,14 +645,15 @@ sbitmap_union_of_preds (sbitmap dst, sbitmap *src, int bb)\n       break;\n     }\n \n-  if (e == 0)\n+  if (ix == EDGE_COUNT (b->preds))\n     sbitmap_zero (dst);\n   else\n-    for (e = e->pred_next; e != 0; e = e->pred_next)\n+    for (ix++; ix < EDGE_COUNT (b->preds); ix++)\n       {\n \tunsigned int i;\n \tsbitmap_ptr p, r;\n \n+\te = EDGE_PRED (b, ix);\n \tif (e->src == ENTRY_BLOCK_PTR)\n \t  continue;\n "}, {"sha": "286d047a24513c38dc23a8b1c2c1238109a27bef", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -175,7 +175,9 @@ compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,\n {\n   basic_block b = BLOCK_FOR_INSN (insn);\n   edge e;\n-  for (e = b->succ; e; e = e->succ_next)\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, b->succs)\n     if (e->flags & EDGE_FALLTHRU)\n       /* The jump may be a by-product of a branch that has been merged\n \t in the main codepath after being conditionalized.  Therefore\n@@ -280,6 +282,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t    {\n \t      edge f;\n \t      rtx h;\n+\t      edge_iterator ei;\n \n \t      /* An obscure special case, where we do have partially dead\n \t         instruction scheduled after last control flow instruction.\n@@ -291,9 +294,10 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t         A safer solution can be to bring the code into sequence,\n \t         do the split and re-emit it back in case this will ever\n \t         trigger problem.  */\n-\t      f = bb->prev_bb->succ;\n-\t      while (f && !(f->flags & EDGE_FALLTHRU))\n-\t\tf = f->succ_next;\n+\n+\t      FOR_EACH_EDGE (f, ei, bb->prev_bb->succs)\n+\t\tif (f->flags & EDGE_FALLTHRU)\n+\t\t  break;\n \n \t      if (f)\n \t\t{\n@@ -588,11 +592,12 @@ schedule_ebbs (FILE *dump_file)\n       for (;;)\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \t  tail = BB_END (bb);\n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n \t      || LABEL_P (BB_HEAD (bb->next_bb)))\n \t    break;\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if ((e->flags & EDGE_FALLTHRU) != 0)\n \t      break;\n \t  if (! e)"}, {"sha": "7fe01978fdb5a8863c72c62f901e885ec8fec838", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -390,9 +390,9 @@ build_control_flow (struct edge_list *edge_list)\n   unreachable = 0;\n   FOR_EACH_BB (b)\n     {\n-      if (b->pred == NULL\n-\t  || (b->pred->src == b\n-\t      && b->pred->pred_next == NULL))\n+      if (EDGE_COUNT (b->preds) == 0\n+\t  || (EDGE_PRED (b, 0)->src == b\n+\t      && EDGE_COUNT (b->preds) == 1))\n \tunreachable = 1;\n     }\n \n@@ -615,7 +615,7 @@ find_rgns (struct edge_list *edge_list)\n   char no_loops = 1;\n   int node, child, loop_head, i, head, tail;\n   int count = 0, sp, idx = 0;\n-  int current_edge = out_edges[ENTRY_BLOCK_PTR->succ->dest->index];\n+  int current_edge = out_edges[EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->index];\n   int num_bbs, num_insns, unreachable;\n   int too_large_failure;\n   basic_block bb;\n@@ -802,6 +802,7 @@ find_rgns (struct edge_list *edge_list)\n \t  if (TEST_BIT (header, bb->index) && TEST_BIT (inner, bb->index))\n \t    {\n \t      edge e;\n+\t      edge_iterator ei;\n \t      basic_block jbb;\n \n \t      /* Now check that the loop is reducible.  We do this separate\n@@ -842,7 +843,7 @@ find_rgns (struct edge_list *edge_list)\n \n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n-\t      for (e = bb->succ; e; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (e->dest != EXIT_BLOCK_PTR)\n \t\t  --degree[e->dest->index];\n \n@@ -860,9 +861,8 @@ find_rgns (struct edge_list *edge_list)\n \t\t  FOR_EACH_BB (jbb)\n \t\t    /* Leaf nodes have only a single successor which must\n \t\t       be EXIT_BLOCK.  */\n-\t\t    if (jbb->succ\n-\t\t\t&& jbb->succ->dest == EXIT_BLOCK_PTR\n-\t\t\t&& jbb->succ->succ_next == NULL)\n+\t\t    if (EDGE_COUNT (jbb->succs) == 1\n+\t\t\t&& EDGE_SUCC (jbb, 0)->dest == EXIT_BLOCK_PTR)\n \t\t      {\n \t\t\tqueue[++tail] = jbb->index;\n \t\t\tSET_BIT (in_queue, jbb->index);\n@@ -878,7 +878,7 @@ find_rgns (struct edge_list *edge_list)\n \t\t{\n \t\t  edge e;\n \n-\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    {\n \t\t      if (e->src == ENTRY_BLOCK_PTR)\n \t\t\tcontinue;\n@@ -935,7 +935,7 @@ find_rgns (struct edge_list *edge_list)\n \t\t  edge e;\n \t\t  child = queue[++head];\n \n-\t\t  for (e = BASIC_BLOCK (child)->pred; e; e = e->pred_next)\n+\t\t  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (child)->preds)\n \t\t    {\n \t\t      node = e->src->index;\n \n@@ -990,9 +990,7 @@ find_rgns (struct edge_list *edge_list)\n \t\t\t  CONTAINING_RGN (child) = nr_regions;\n \t\t\t  queue[head] = queue[tail--];\n \n-\t\t\t  for (e = BASIC_BLOCK (child)->succ;\n-\t\t\t       e;\n-\t\t\t       e = e->succ_next)\n+\t\t\t  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (child)->succs)\n \t\t\t    if (e->dest != EXIT_BLOCK_PTR)\n \t\t\t      --degree[e->dest->index];\n \t\t\t}"}, {"sha": "968d093b7230095771dfdca330f66fbe073ad421", "filename": "gcc/tracer.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -118,8 +118,9 @@ find_best_successor (basic_block bb)\n {\n   edge e;\n   edge best = NULL;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (!best || better_p (e, best))\n       best = e;\n   if (!best || ignore_bb_p (best->dest))\n@@ -136,8 +137,9 @@ find_best_predecessor (basic_block bb)\n {\n   edge e;\n   edge best = NULL;\n+  edge_iterator ei;\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     if (!best || better_p (e, best))\n       best = e;\n   if (!best || ignore_bb_p (best->src))\n@@ -269,14 +271,17 @@ tail_duplicate (void)\n \t      blocks[bb2->index] = NULL;\n \t    }\n \t  traced_insns += bb2->frequency * counts [bb2->index];\n-\t  if (bb2->pred && bb2->pred->pred_next\n+\t  if (EDGE_COUNT (bb2->preds) > 1\n \t      && can_duplicate_block_p (bb2))\n \t    {\n-\t      edge e = bb2->pred;\n+\t      edge e;\n+\t      edge_iterator ei;\n \t      basic_block old = bb2;\n \n-\t      while (e->src != bb)\n-\t\te = e->pred_next;\n+\t      FOR_EACH_EDGE (e, ei, bb2->preds)\n+\t\tif (e->src == bb)\n+\t\t  break;\n+\n \t      nduplicated += counts [bb2->index];\n \t      bb2 = duplicate_block (bb2, e);\n \n@@ -319,18 +324,19 @@ tail_duplicate (void)\n static void\n layout_superblocks (void)\n {\n-  basic_block end = ENTRY_BLOCK_PTR->succ->dest;\n-  basic_block bb = ENTRY_BLOCK_PTR->succ->dest->next_bb;\n+  basic_block end = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n+  basic_block bb = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->next_bb;\n \n   while (bb != EXIT_BLOCK_PTR)\n     {\n+      edge_iterator ei;\n       edge e, best = NULL;\n       while (end->rbi->next)\n \tend = end->rbi->next;\n \n-      for (e = end->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, end->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n-\t    && e->dest != ENTRY_BLOCK_PTR->succ->dest\n+\t    && e->dest != EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n \t    && !e->dest->rbi->visited\n \t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n \t  best = e;"}, {"sha": "db0d1b518cff56910d95af8122cee37e326f2874", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 148, "deletions": 136, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -441,7 +441,7 @@ make_edges (void)\n \n       /* Finally, if no edges were created above, this is a regular\n \t basic block that only needs a fallthru edge.  */\n-      if (bb->succ == NULL)\n+      if (EDGE_COUNT (bb->succs) == 0)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n@@ -483,7 +483,7 @@ make_ctrl_stmt_edges (basic_block bb)\n     case RESX_EXPR:\n       make_eh_edges (last);\n       /* Yet another NORETURN hack.  */\n-      if (bb->succ == NULL)\n+      if (EDGE_COUNT (bb->succs) == 0)\n \tmake_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n       break;\n \n@@ -698,7 +698,7 @@ make_goto_expr_edges (basic_block bb)\n     }\n \n   /* Degenerate case of computed goto with no labels.  */\n-  if (!for_call && !bb->succ)\n+  if (!for_call && EDGE_COUNT (bb->succs) == 0)\n     make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n@@ -1009,20 +1009,19 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n   tree stmt;\n   block_stmt_iterator bsi;\n \n-  if (!a->succ\n-      || a->succ->succ_next)\n+  if (EDGE_COUNT (a->succs) != 1)\n     return false;\n \n-  if (a->succ->flags & EDGE_ABNORMAL)\n+  if (EDGE_SUCC (a, 0)->flags & EDGE_ABNORMAL)\n     return false;\n \n-  if (a->succ->dest != b)\n+  if (EDGE_SUCC (a, 0)->dest != b)\n     return false;\n \n   if (b == EXIT_BLOCK_PTR)\n     return false;\n   \n-  if (b->pred->pred_next)\n+  if (EDGE_COUNT (b->preds) > 1)\n     return false;\n \n   /* If A ends by a statement causing exceptions or something similar, we\n@@ -1069,7 +1068,7 @@ tree_merge_blocks (basic_block a, basic_block b)\n   /* Ensure that B follows A.  */\n   move_block_after (b, a);\n \n-  gcc_assert (a->succ->flags & EDGE_FALLTHRU);\n+  gcc_assert (EDGE_SUCC (a, 0)->flags & EDGE_FALLTHRU);\n   gcc_assert (!last_stmt (a) || !stmt_ends_bb_p (last_stmt (a)));\n \n   /* Remove labels from B and set bb_for_stmt to A for other statements.  */\n@@ -1650,30 +1649,29 @@ cfg_remove_useless_stmts_bb (basic_block bb)\n \n   /* Check whether we come here from a condition, and if so, get the\n      condition.  */\n-  if (!bb->pred\n-      || bb->pred->pred_next\n-      || !(bb->pred->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+  if (EDGE_COUNT (bb->preds) != 1\n+      || !(EDGE_PRED (bb, 0)->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n     return;\n \n-  cond = COND_EXPR_COND (last_stmt (bb->pred->src));\n+  cond = COND_EXPR_COND (last_stmt (EDGE_PRED (bb, 0)->src));\n \n   if (TREE_CODE (cond) == VAR_DECL || TREE_CODE (cond) == PARM_DECL)\n     {\n       var = cond;\n-      val = (bb->pred->flags & EDGE_FALSE_VALUE\n+      val = (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE\n \t     ? boolean_false_node : boolean_true_node);\n     }\n   else if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n \t   && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n \t       || TREE_CODE (TREE_OPERAND (cond, 0)) == PARM_DECL))\n     {\n       var = TREE_OPERAND (cond, 0);\n-      val = (bb->pred->flags & EDGE_FALSE_VALUE\n+      val = (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE\n \t     ? boolean_true_node : boolean_false_node);\n     }\n   else\n     {\n-      if (bb->pred->flags & EDGE_FALSE_VALUE)\n+      if (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE)\n \tcond = invert_truthvalue (cond);\n       if (TREE_CODE (cond) == EQ_EXPR\n \t  && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n@@ -1776,8 +1774,8 @@ remove_phi_nodes_and_edges_for_unreachable_block (basic_block bb)\n     }\n \n   /* Remove edges to BB's successors.  */\n-  while (bb->succ != NULL)\n-    ssa_remove_edge (bb->succ);\n+  while (EDGE_COUNT (bb->succs) > 0)\n+    ssa_remove_edge (EDGE_SUCC (bb, 0));\n }\n \n \n@@ -1859,12 +1857,11 @@ tree_block_forwards_to (basic_block bb)\n      single successor has phi nodes.  */\n   if (bb == EXIT_BLOCK_PTR\n       || bb == ENTRY_BLOCK_PTR\n-      || !bb->succ\n-      || bb->succ->succ_next\n-      || bb->succ->dest == EXIT_BLOCK_PTR\n-      || (bb->succ->flags & EDGE_ABNORMAL) != 0\n+      || EDGE_COUNT (bb->succs) != 1\n+      || EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n+      || (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) != 0\n       || phi_nodes (bb)\n-      || phi_nodes (bb->succ->dest))\n+      || phi_nodes (EDGE_SUCC (bb, 0)->dest))\n     return NULL;\n \n   /* Walk past any labels at the start of this block.  */\n@@ -1882,11 +1879,11 @@ tree_block_forwards_to (basic_block bb)\n       edge dest;\n \n       /* Recursive call to pick up chains of forwarding blocks.  */\n-      dest = tree_block_forwards_to (bb->succ->dest);\n+      dest = tree_block_forwards_to (EDGE_SUCC (bb, 0)->dest);\n \n-      /* If none found, we forward to bb->succ at minimum.  */\n+      /* If none found, we forward to bb->succs[0] at minimum.  */\n       if (!dest)\n-\tdest = bb->succ;\n+\tdest = EDGE_SUCC (bb, 0);\n \n       ann->forwardable = 1;\n       return dest;\n@@ -1933,9 +1930,10 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n   bool retval = false;\n   tree expr = bsi_stmt (bsi), val;\n \n-  if (bb->succ->succ_next)\n+  if (EDGE_COUNT (bb->succs) > 1)\n     {\n-      edge e, next;\n+      edge e;\n+      edge_iterator ei;\n \n       switch (TREE_CODE (expr))\n \t{\n@@ -1958,22 +1956,23 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \treturn false;\n \n       /* Remove all the edges except the one that is always executed.  */\n-      for (e = bb->succ; e; e = next)\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n-\t  next = e->succ_next;\n \t  if (e != taken_edge)\n \t    {\n \t      taken_edge->probability += e->probability;\n \t      taken_edge->count += e->count;\n \t      ssa_remove_edge (e);\n \t      retval = true;\n \t    }\n+\t  else\n+\t    ei_next (&ei);\n \t}\n       if (taken_edge->probability > REG_BR_PROB_BASE)\n \ttaken_edge->probability = REG_BR_PROB_BASE;\n     }\n   else\n-    taken_edge = bb->succ;\n+    taken_edge = EDGE_SUCC (bb, 0);\n \n   bsi_remove (&bsi);\n   taken_edge->flags = EDGE_FALLTHRU;\n@@ -2016,7 +2015,7 @@ find_taken_edge (basic_block bb, tree val)\n   if (TREE_CODE (stmt) == SWITCH_EXPR)\n     return find_taken_edge_switch_expr (bb, val);\n \n-  return bb->succ;\n+  return EDGE_SUCC (bb, 0);\n }\n \n \n@@ -2248,11 +2247,7 @@ dump_cfg_stats (FILE *file)\n \n   n_edges = 0;\n   FOR_EACH_BB (bb)\n-    {\n-      edge e;\n-      for (e = bb->succ; e; e = e->succ_next)\n-\tn_edges++;\n-    }\n+    n_edges += EDGE_COUNT (bb->succs);\n   size = n_edges * sizeof (struct edge_def);\n   total += size;\n   fprintf (file, fmt_str_1, \"Edges\", n_edges, SCALE (size), LABEL (size));\n@@ -2294,6 +2289,7 @@ static void\n tree_cfg2vcg (FILE *file)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block bb;\n   const char *funcname\n     = lang_hooks.decl_printable_name (current_function_decl, 2);\n@@ -2304,7 +2300,7 @@ tree_cfg2vcg (FILE *file)\n   fprintf (file, \"node: { title: \\\"EXIT\\\" label: \\\"EXIT\\\" }\\n\");\n \n   /* Write blocks and edges.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       fprintf (file, \"edge: { sourcename: \\\"ENTRY\\\" targetname: \\\"%d\\\"\",\n \t       e->dest->index);\n@@ -2349,7 +2345,7 @@ tree_cfg2vcg (FILE *file)\n \t       bb->index, bb->index, head_name, head_line, end_name,\n \t       end_line);\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR)\n \t    fprintf (file, \"edge: { sourcename: \\\"%d\\\" targetname: \\\"EXIT\\\"\", bb->index);\n@@ -2497,6 +2493,7 @@ disband_implicit_edges (void)\n   basic_block bb;\n   block_stmt_iterator last;\n   edge e;\n+  edge_iterator ei;\n   tree stmt, label;\n \n   FOR_EACH_BB (bb)\n@@ -2510,7 +2507,7 @@ disband_implicit_edges (void)\n \t     from cfg_remove_useless_stmts here since it violates the\n \t     invariants for tree--cfg correspondence and thus fits better\n \t     here where we do it anyway.  */\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if (e->dest != bb->next_bb)\n \t\tcontinue;\n@@ -2531,15 +2528,14 @@ disband_implicit_edges (void)\n \t{\n \t  /* Remove the RETURN_EXPR if we may fall though to the exit\n \t     instead.  */\n-\t  gcc_assert (bb->succ);\n-\t  gcc_assert (!bb->succ->succ_next);\n-\t  gcc_assert (bb->succ->dest == EXIT_BLOCK_PTR);\n+\t  gcc_assert (EDGE_COUNT (bb->succs) == 1);\n+\t  gcc_assert (EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR);\n \n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n \t      && !TREE_OPERAND (stmt, 0))\n \t    {\n \t      bsi_remove (&last);\n-\t      bb->succ->flags |= EDGE_FALLTHRU;\n+\t      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n \t    }\n \t  continue;\n \t}\n@@ -2550,7 +2546,7 @@ disband_implicit_edges (void)\n \tcontinue;\n \n       /* Find a fallthru edge and emit the goto if necessary.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n \n@@ -2834,7 +2830,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n      would have to examine the PHIs to prove that none of them used\n      the value set by the statement we want to insert on E.   That\n      hardly seems worth the effort.  */\n-  if (dest->pred->pred_next == NULL\n+  if (EDGE_COUNT (dest->preds) == 1\n       && ! phi_nodes (dest)\n       && dest != EXIT_BLOCK_PTR)\n     {\n@@ -2866,7 +2862,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n      Except for the entry block.  */\n   src = e->src;\n   if ((e->flags & EDGE_ABNORMAL) == 0\n-      && src->succ->succ_next == NULL\n+      && EDGE_COUNT (src->succs) == 1\n       && src != ENTRY_BLOCK_PTR)\n     {\n       *bsi = bsi_last (src);\n@@ -2897,7 +2893,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n   dest = split_edge (e);\n   if (new_bb)\n     *new_bb = dest;\n-  e = dest->pred;\n+  e = EDGE_PRED (dest, 0);\n   goto restart;\n }\n \n@@ -2914,13 +2910,14 @@ bsi_commit_edge_inserts (int *new_blocks)\n   basic_block bb;\n   edge e;\n   int blocks;\n+  edge_iterator ei;\n \n   blocks = n_basic_blocks;\n \n-  bsi_commit_edge_inserts_1 (ENTRY_BLOCK_PTR->succ);\n+  bsi_commit_edge_inserts_1 (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n \n   FOR_EACH_BB (bb)\n-    for (e = bb->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n       bsi_commit_edge_inserts_1 (e);\n \n   if (new_blocks)\n@@ -2990,6 +2987,7 @@ tree_split_edge (edge edge_in)\n   edge new_edge, e;\n   tree phi;\n   int i, num_elem;\n+  edge_iterator ei;\n \n   /* Abnormal edges cannot be split.  */\n   gcc_assert (!(edge_in->flags & EDGE_ABNORMAL));\n@@ -3000,7 +2998,7 @@ tree_split_edge (edge edge_in)\n   /* Place the new block in the block list.  Try to keep the new block\n      near its \"logical\" location.  This is of most help to humans looking\n      at debugging dumps.  */\n-  for (e = dest->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, dest->preds)\n     if (e->src->next_bb == dest)\n       break;\n   if (!e)\n@@ -3424,6 +3422,7 @@ tree_verify_flow_info (void)\n   block_stmt_iterator bsi;\n   tree stmt;\n   edge e;\n+  edge_iterator ei;\n \n   if (ENTRY_BLOCK_PTR->stmt_list)\n     {\n@@ -3437,7 +3436,7 @@ tree_verify_flow_info (void)\n       err = 1;\n     }\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       {\n \terror (\"Fallthru to exit from bb %d\\n\", e->src->index);\n@@ -3503,7 +3502,7 @@ tree_verify_flow_info (void)\n \n       if (is_ctrl_stmt (stmt))\n \t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_FALLTHRU)\n \t      {\n \t\terror (\"Fallthru edge after a control statement in bb %d \\n\",\n@@ -3532,7 +3531,7 @@ tree_verify_flow_info (void)\n \t\t|| !(false_edge->flags & EDGE_FALSE_VALUE)\n \t\t|| (true_edge->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL))\n \t\t|| (false_edge->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL))\n-\t\t|| bb->succ->succ_next->succ_next)\n+\t\t|| EDGE_COUNT (bb->succs) >= 3)\n \t      {\n \t\terror (\"Wrong outgoing edge flags at end of bb %d\\n\",\n \t\t       bb->index);\n@@ -3567,7 +3566,7 @@ tree_verify_flow_info (void)\n \t    {\n \t      /* FIXME.  We should double check that the labels in the \n \t\t destination blocks have their address taken.  */\n-\t      for (e = bb->succ; e; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif ((e->flags & (EDGE_FALLTHRU | EDGE_TRUE_VALUE\n \t\t\t\t | EDGE_FALSE_VALUE))\n \t\t    || !(e->flags & EDGE_ABNORMAL))\n@@ -3580,14 +3579,14 @@ tree_verify_flow_info (void)\n \t  break;\n \n \tcase RETURN_EXPR:\n-\t  if (!bb->succ || bb->succ->succ_next\n-\t      || (bb->succ->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL\n+\t  if (EDGE_COUNT (bb->succs) != 1\n+\t      || (EDGE_SUCC (bb, 0)->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL\n \t\t  \t\t     | EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n \t    {\n \t      error (\"Wrong outgoing edge flags at end of bb %d\\n\", bb->index);\n \t      err = 1;\n \t    }\n-\t  if (bb->succ->dest != EXIT_BLOCK_PTR)\n+\t  if (EDGE_SUCC (bb, 0)->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      error (\"Return edge does not point to exit in bb %d\\n\",\n \t\t     bb->index);\n@@ -3643,7 +3642,7 @@ tree_verify_flow_info (void)\n \t\terr = 1;\n \t      }\n \n-\t    for (e = bb->succ; e; e = e->succ_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      {\n \t\tif (!e->dest->aux)\n \t\t  {\n@@ -3675,7 +3674,7 @@ tree_verify_flow_info (void)\n \t\t  }\n \t      }\n \n-\t    for (e = bb->succ; e; e = e->succ_next)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      e->dest->aux = (void *)0;\n \t  }\n \n@@ -3697,13 +3696,14 @@ static void\n tree_make_forwarder_block (edge fallthru)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block dummy, bb;\n   tree phi, new_phi, var, prev, next;\n \n   dummy = fallthru->src;\n   bb = fallthru->dest;\n \n-  if (!bb->pred->pred_next)\n+  if (EDGE_COUNT (bb->preds) == 1)\n     return;\n \n   /* If we redirected a branch we must create new phi nodes at the\n@@ -3728,7 +3728,7 @@ tree_make_forwarder_block (edge fallthru)\n   set_phi_nodes (bb, prev);\n \n   /* Add the arguments we have stored on edges.  */\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (e == fallthru)\n \tcontinue;\n@@ -3752,6 +3752,7 @@ tree_forwarder_block_p (basic_block bb)\n {\n   block_stmt_iterator bsi;\n   edge e;\n+  edge_iterator ei;\n \n   /* If we have already determined that this block is not forwardable,\n      then no further checks are necessary.  */\n@@ -3760,18 +3761,17 @@ tree_forwarder_block_p (basic_block bb)\n \n   /* BB must have a single outgoing normal edge.  Otherwise it can not be\n      a forwarder block.  */\n-  if (!bb->succ\n-      || bb->succ->succ_next\n-      || bb->succ->dest == EXIT_BLOCK_PTR\n-      || (bb->succ->flags & EDGE_ABNORMAL)\n+  if (EDGE_COUNT (bb->succs) != 1\n+      || EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n+      || (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL)\n       || bb == ENTRY_BLOCK_PTR)\n     {\n       bb_ann (bb)->forwardable = 0;\n       return false; \n     }\n \n   /* Successors of the entry block are not forwarders.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     if (e->dest == bb)\n       {\n \tbb_ann (bb)->forwardable = 0;\n@@ -3818,9 +3818,9 @@ tree_forwarder_block_p (basic_block bb)\n static bool\n thread_jumps (void)\n {\n-  edge e, next, last, old;\n+  edge e, last, old;\n   basic_block bb, dest, tmp, old_dest, curr, dom;\n-  tree phi;\n+    tree phi;\n   int arg;\n   bool retval = false;\n \n@@ -3829,8 +3829,10 @@ thread_jumps (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n+      edge_iterator ei;\n+\n       /* Don't waste time on unreachable blocks.  */\n-      if (!bb->pred)\n+      if (EDGE_COUNT (bb->preds) == 0)\n \tcontinue;\n \n       /* Nor on forwarders.  */\n@@ -3844,37 +3846,39 @@ thread_jumps (void)\n \n       /* Examine each of our block's successors to see if it is\n \t forwardable.  */\n-      for (e = bb->succ; e; e = next)\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n \t  int freq;\n \t  gcov_type count;\n-\t  next = e->succ_next;\n \n \t  /* If the edge is abnormal or its destination is not\n \t     forwardable, then there's nothing to do.  */\n \t  if ((e->flags & EDGE_ABNORMAL)\n \t      || !tree_forwarder_block_p (e->dest))\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \n \t  count = e->count;\n \t  freq = EDGE_FREQUENCY (e);\n \n \t  /* Now walk through as many forwarder block as possible to\n \t     find the ultimate destination we want to thread our jump\n \t     to.  */\n-\t  last = e->dest->succ;\n+\t  last = EDGE_SUCC (e->dest, 0);\n \t  bb_ann (e->dest)->forwardable = 0;\n-\t  for (dest = e->dest->succ->dest;\n+\t  for (dest = EDGE_SUCC (e->dest, 0)->dest;\n \t       tree_forwarder_block_p (dest);\n-\t       last = dest->succ,\n-\t       dest = dest->succ->dest)\n+\t       last = EDGE_SUCC (dest, 0),\n+\t       dest = EDGE_SUCC (dest, 0)->dest)\n \t    {\n \t      /* An infinite loop detected.  We redirect the edge anyway, so\n \t\t that the loop is shrunk into single basic block.  */\n \t      if (!bb_ann (dest)->forwardable)\n \t\tbreak;\n \n-\t      if (dest->succ->dest == EXIT_BLOCK_PTR)\n+\t      if (EDGE_SUCC (dest, 0)->dest == EXIT_BLOCK_PTR)\n \t\tbreak;\n \n \t      bb_ann (dest)->forwardable = 0;\n@@ -3883,11 +3887,14 @@ thread_jumps (void)\n \t  /* Reset the forwardable marks to 1.  */\n \t  for (tmp = e->dest;\n \t       tmp != dest;\n-\t       tmp = tmp->succ->dest)\n+\t       tmp = EDGE_SUCC (tmp, 0)->dest)\n \t    bb_ann (tmp)->forwardable = 1;\n \n \t  if (dest == e->dest)\n-\t    continue;\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t      \n \t  old = find_edge (bb, dest);\n \t  if (old)\n@@ -3903,7 +3910,10 @@ thread_jumps (void)\n \t  \n \t\t  /* That might mean that no forwarding at all is possible.  */\n \t\t  if (dest == e->dest)\n-\t\t    continue;\n+\t\t    {\n+\t\t      ei_next (&ei);\n+\t\t      continue;\n+\t\t    }\n \n \t\t  old = find_edge (bb, dest);\n \t\t}\n@@ -3916,17 +3926,17 @@ thread_jumps (void)\n \n \t  /* Update the profile.  */\n \t  if (profile_status != PROFILE_ABSENT)\n-\t    for (curr = old_dest; curr != dest; curr = curr->succ->dest)\n+\t    for (curr = old_dest; curr != dest; curr = EDGE_SUCC (curr, 0)->dest)\n \t      {\n \t\tcurr->frequency -= freq;\n \t\tif (curr->frequency < 0)\n \t\t  curr->frequency = 0;\n \t\tcurr->count -= count;\n \t\tif (curr->count < 0)\n \t\t  curr->count = 0;\n-\t\tcurr->succ->count -= count;\n-\t\tif (curr->succ->count < 0)\n-\t\t  curr->succ->count = 0;\n+\t\tEDGE_SUCC (curr, 0)->count -= count;\n+\t\tif (EDGE_SUCC (curr, 0)->count < 0)\n+\t\t  EDGE_SUCC (curr, 0)->count = 0;\n \t      }\n \n \t  if (!old)\n@@ -3951,9 +3961,9 @@ thread_jumps (void)\n \t\t become unreachable).  */\n \t      for (; old_dest != dest; old_dest = tmp)\n \t\t{\n-\t\t  tmp = old_dest->succ->dest;\n+\t\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n \n-\t\t  if (old_dest->pred)\n+\t\t  if (EDGE_COUNT (old_dest->preds) > 0)\n \t\t    break;\n \n \t\t  delete_basic_block (old_dest);\n@@ -3974,7 +3984,7 @@ thread_jumps (void)\n \n \t      for (; old_dest != dest; old_dest = tmp)\n \t\t{\n-\t\t  tmp = old_dest->succ->dest;\n+\t\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n \n \t\t  if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n \t\t      && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n@@ -4042,9 +4052,10 @@ tree_try_redirect_by_replacing_jump (edge e, basic_block target)\n   edge tmp;\n   block_stmt_iterator b;\n   tree stmt;\n+  edge_iterator ei;\n \n   /* Verify that all targets will be TARGET.  */\n-  for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n+  FOR_EACH_EDGE (tmp, ei, src->succs)\n     if (tmp->dest != target && tmp != e)\n       break;\n \n@@ -4166,13 +4177,14 @@ tree_split_block (basic_block bb, void *stmt)\n   tree act;\n   basic_block new_bb;\n   edge e;\n+  edge_iterator ei;\n \n   new_bb = create_empty_bb (bb);\n \n   /* Redirect the outgoing edges.  */\n-  new_bb->succ = bb->succ;\n-  bb->succ = NULL;\n-  for (e = new_bb->succ; e; e = e->succ_next)\n+  new_bb->succs = bb->succs;\n+  bb->succs = NULL;\n+  FOR_EACH_EDGE (e, ei, new_bb->succs)\n     e->src = new_bb;\n \n   if (stmt && TREE_CODE ((tree) stmt) == LABEL_EXPR)\n@@ -4289,11 +4301,12 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n {\n   basic_block bb, dest;\n   edge e, e_copy;\n+  edge_iterator ei;\n   tree phi, phi_copy, phi_next, def;\n       \n   bb = bb_copy->rbi->original;\n \n-  for (e_copy = bb_copy->succ; e_copy; e_copy = e_copy->succ_next)\n+  FOR_EACH_EDGE (e_copy, ei, bb_copy->succs)\n     {\n       if (!phi_nodes (e_copy->dest))\n \tcontinue;\n@@ -4309,7 +4322,7 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n \t  /* During loop unrolling the target of the latch edge is copied.\n \t     In this case we are not looking for edge to dest, but to\n \t     duplicated block whose original was dest.  */\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->dest->rbi->duplicated\n \t\t&& e->dest->rbi->original == dest)\n \t      break;\n@@ -4453,6 +4466,7 @@ rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n {\n   unsigned i;\n   edge e;\n+  edge_iterator ei;\n   tree phi, stmt;\n   block_stmt_iterator bsi;\n   use_optype uses;\n@@ -4462,7 +4476,7 @@ rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n   v_must_def_optype v_must_defs;\n   stmt_ann_t ann;\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e->flags & EDGE_ABNORMAL)\n       break;\n \n@@ -4506,7 +4520,7 @@ rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n \t\t(V_MUST_DEF_OP_PTR (v_must_defs, i), stmt, map);\n     }\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n       {\n \trewrite_to_new_ssa_names_use\n@@ -4771,43 +4785,33 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n \n /* Pretty print of the loops intermediate representation.  */\n static void print_loop (FILE *, struct loop *, int);\n-static void print_pred_bbs (FILE *, edge);\n-static void print_succ_bbs (FILE *, edge);\n+static void print_pred_bbs (FILE *, basic_block bb);\n+static void print_succ_bbs (FILE *, basic_block bb);\n \n \n /* Print the predecessors indexes of edge E on FILE.  */\n \n static void\n-print_pred_bbs (FILE *file, edge e)\n+print_pred_bbs (FILE *file, basic_block bb)\n {\n-  if (e == NULL)\n-    return;\n-  \n-  else if (e->pred_next == NULL)\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     fprintf (file, \"bb_%d\", e->src->index);\n-  \n-  else\n-    {\n-      fprintf (file, \"bb_%d, \", e->src->index);\n-      print_pred_bbs (file, e->pred_next);\n-    }\n }\n \n \n /* Print the successors indexes of edge E on FILE.  */\n \n static void\n-print_succ_bbs (FILE *file, edge e)\n+print_succ_bbs (FILE *file, basic_block bb)\n {\n-  if (e == NULL)\n-    return;\n-  else if (e->succ_next == NULL)\n-    fprintf (file, \"bb_%d\", e->dest->index);\n-  else\n-    {\n-      fprintf (file, \"bb_%d, \", e->dest->index);\n-      print_succ_bbs (file, e->succ_next);\n-    }\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    fprintf (file, \"bb_%d\", e->src->index);\n }\n \n \n@@ -4836,9 +4840,9 @@ print_loop (FILE *file, struct loop *loop, int indent)\n       {\n \t/* Print the basic_block's header.  */\n \tfprintf (file, \"%s  bb_%d (preds = {\", s_indent, bb->index);\n-\tprint_pred_bbs (file, bb->pred);\n+\tprint_pred_bbs (file, bb);\n \tfprintf (file, \"}, succs = {\");\n-\tprint_succ_bbs (file, bb->succ);\n+\tprint_succ_bbs (file, bb);\n \tfprintf (file, \"})\\n\");\n \t\n \t/* Print the basic_block's body.  */\n@@ -4966,6 +4970,7 @@ tree_flow_call_edges_add (sbitmap blocks)\n      Handle this by adding a dummy instruction in a new last basic block.  */\n   if (check_last_block)\n     {\n+      edge_iterator ei;\n       basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n       block_stmt_iterator bsi = bsi_last (bb);\n       tree t = NULL_TREE;\n@@ -4976,7 +4981,7 @@ tree_flow_call_edges_add (sbitmap blocks)\n \t{\n \t  edge e;\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->dest == EXIT_BLOCK_PTR)\n \t      {\n \t\tbsi_insert_on_edge (e, build_empty_stmt ());\n@@ -5018,8 +5023,11 @@ tree_flow_call_edges_add (sbitmap blocks)\n \t\t     mark that edge as fake and remove it later.  */\n #ifdef ENABLE_CHECKING\n \t\t  if (stmt == last_stmt)\n-\t\t    for (e = bb->succ; e; e = e->succ_next)\n-\t\t      gcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t    {\n+\t\t      edge_iterator ei;\n+\t\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t\tgcc_assert (e->dest != EXIT_BLOCK_PTR);\n+\t\t    }\n #endif\n \n \t\t  /* Note that the following may create a new basic block\n@@ -5048,20 +5056,22 @@ bool\n tree_purge_dead_eh_edges (basic_block bb)\n {\n   bool changed = false;\n-  edge e, next;\n+  edge e;\n+  edge_iterator ei;\n   tree stmt = last_stmt (bb);\n \n   if (stmt && tree_can_throw_internal (stmt))\n     return false;\n \n-  for (e = bb->succ; e ; e = next)\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      next = e->succ_next;\n       if (e->flags & EDGE_EH)\n \t{\n \t  ssa_remove_edge (e);\n \t  changed = true;\n \t}\n+      else\n+\tei_next (&ei);\n     }\n \n   return changed;\n@@ -5114,10 +5124,11 @@ split_critical_edges (void)\n {\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   FOR_ALL_BB (bb)\n     {\n-      for (e = bb->succ; e ; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (EDGE_CRITICAL_P (e) && !(e->flags & EDGE_ABNORMAL))\n \t  {\n \t    split_edge (e);\n@@ -5227,25 +5238,26 @@ execute_warn_function_return (void)\n #endif\n   tree last;\n   edge e;\n+  edge_iterator ei;\n \n   if (warn_missing_noreturn\n       && !TREE_THIS_VOLATILE (cfun->decl)\n-      && EXIT_BLOCK_PTR->pred == NULL\n+      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0\n       && !lang_hooks.function.missing_noreturn_ok_p (cfun->decl))\n     warning (\"%Jfunction might be possible candidate for \"\n \t     \"attribute %<noreturn%>\",\n \t     cfun->decl);\n \n   /* If we have a path to EXIT, then we do return.  */\n   if (TREE_THIS_VOLATILE (cfun->decl)\n-      && EXIT_BLOCK_PTR->pred != NULL)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0)\n     {\n #ifdef USE_MAPPED_LOCATION\n       location = UNKNOWN_LOCATION;\n #else\n       locus = NULL;\n #endif\n-      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n \t  last = last_stmt (e->src);\n \t  if (TREE_CODE (last) == RETURN_EXPR\n@@ -5270,10 +5282,10 @@ execute_warn_function_return (void)\n   /* If we see \"return;\" in some basic block, then we do reach the end\n      without returning a value.  */\n   else if (warn_return_type\n-\t   && EXIT_BLOCK_PTR->pred != NULL\n+\t   && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0\n \t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (cfun->decl))))\n     {\n-      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n \t  tree last = last_stmt (e->src);\n \t  if (TREE_CODE (last) == RETURN_EXPR\n@@ -5307,17 +5319,17 @@ extract_true_false_edges_from_block (basic_block b,\n \t\t\t\t     edge *true_edge,\n \t\t\t\t     edge *false_edge)\n {\n-  edge e = b->succ;\n+  edge e = EDGE_SUCC (b, 0);\n \n   if (e->flags & EDGE_TRUE_VALUE)\n     {\n       *true_edge = e;\n-      *false_edge = e->succ_next;\n+      *false_edge = EDGE_SUCC (b, 1);\n     }\n   else\n     {\n       *false_edge = e;\n-      *true_edge = e->succ_next;\n+      *true_edge = EDGE_SUCC (b, 1);\n     }\n }\n "}, {"sha": "88696465856f21e6d22cc6fbc471558c47c3940b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -187,9 +187,9 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \n       /* If current bb has only one successor, then consider it as an\n \t unconditional goto.  */\n-      if (bb->succ && !bb->succ->succ_next)\n+      if (EDGE_COUNT (bb->succs) == 1)\n \t{\n-\t  basic_block bb_n = bb->succ->dest;\n+\t  basic_block bb_n = EDGE_SUCC (bb, 0)->dest;\n \t  if (cond != NULL_TREE)\n \t    add_to_predicate_list (bb_n, cond);\n \t  cond = NULL_TREE;\n@@ -472,6 +472,7 @@ static bool\n if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n {\n   edge e;\n+  edge_iterator ei;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"----------[%d]-------------\\n\", bb->index);\n@@ -493,7 +494,7 @@ if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n     }\n \n   /* Be less adventurous and handle only normal edges.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->flags &\n \t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n       {\n@@ -524,6 +525,7 @@ if_convertable_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n   block_stmt_iterator itr;\n   unsigned int i;\n   edge e;\n+  edge_iterator ei;\n   bool exit_bb_seen = false;\n \n   /* Handle only inner most loop.  */\n@@ -556,7 +558,7 @@ if_convertable_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n \n   /* If one of the loop header's edge is exit edge then do not apply\n      if-conversion.  */\n-  for (e = loop->header->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, loop->header->succs)\n     if ( e->flags & EDGE_LOOP_EXIT)\n       return false;\n \n@@ -679,11 +681,12 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n   basic_block p2 = NULL;\n   basic_block true_bb = NULL; \n   tree tmp_cond;\n+  edge_iterator ei;\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (p1 == NULL)\n-\t  p1 = e->src;\n+\tp1 = e->src;\n       else \n \t{\n \t  gcc_assert (!p2);\n@@ -869,6 +872,7 @@ combine_blocks (struct loop *loop)\n       if (bb == exit_bb)\n \t{\n \t  edge new_e;\n+\t  edge_iterator ei;\n \n \t  /* Connect this node with loop header.  */\n \t  new_e = make_edge (ifc_bbs[0], bb, EDGE_FALLTHRU);\n@@ -877,7 +881,7 @@ combine_blocks (struct loop *loop)\n \t  if (exit_bb != loop->latch)\n \t    {\n \t      /* Redirect non-exit edge to loop->latch.  */\n-\t      for (e = bb->succ; e; e = e->succ_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (!(e->flags & EDGE_LOOP_EXIT))\n \t\t  {\n \t\t    redirect_edge_and_branch (e, loop->latch);\n@@ -888,10 +892,10 @@ combine_blocks (struct loop *loop)\n \t}\n \n       /* It is time to remove this basic block.\t First remove edges.  */\n-      while (bb->succ != NULL)\n-\tssa_remove_edge (bb->succ);\n-      while (bb->pred != NULL)\n-\tssa_remove_edge (bb->pred);\n+      while (EDGE_COUNT (bb->succs) > 0)\n+\tssa_remove_edge (EDGE_SUCC (bb, 0));\n+      while (EDGE_COUNT (bb->preds) > 0)\n+\tssa_remove_edge (EDGE_PRED (bb, 0));\n \n       /* Remove labels and make stmts member of loop->header.  */\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n@@ -970,7 +974,8 @@ static bool\n pred_blocks_visited_p (basic_block bb, bitmap *visited)\n {\n   edge e;\n-  for (e = bb->pred; e; e = e->pred_next)\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     if (!bitmap_bit_p (*visited, e->src->index))\n       return false;\n \n@@ -1041,11 +1046,15 @@ static bool\n bb_with_exit_edge_p (basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n   bool exit_edge_found = false;\n \n-  for (e = bb->succ; e && !exit_edge_found ; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->flags & EDGE_LOOP_EXIT)\n-      exit_edge_found = true;\n+      {\n+\texit_edge_found = true;\n+\tbreak;\n+      }\n \n   return exit_edge_found;\n }"}, {"sha": "ec51faaa3cbef78b800fe0494ba7f2bd8c7710ec", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -245,12 +245,13 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n   while (tos != worklist)\n     {\n       edge e;\n+      edge_iterator ei;\n \n       /* Pull a block off the worklist.  */\n       bb = *--tos;\n \n       /* For each predecessor block.  */\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  basic_block pred = e->src;\n \t  int pred_index = pred->index;\n@@ -320,8 +321,9 @@ ssa_mark_phi_uses (struct dom_walk_data *walk_data, basic_block bb)\n   edge e;\n   tree phi, use;\n   unsigned uid;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n@@ -730,14 +732,15 @@ ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n   sbitmap names_to_rename = walk_data->global_data;\n   edge e;\n   bool abnormal_phi;\n+  edge_iterator ei;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n   /* Mark the unwind point for this block.  */\n   VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e->flags & EDGE_ABNORMAL)\n       break;\n   abnormal_phi = (e != NULL);\n@@ -774,8 +777,9 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t   basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       tree phi;\n \n@@ -803,8 +807,9 @@ ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n   edge e;\n   sbitmap names_to_rename = walk_data->global_data;\n   use_operand_p op;\n+  edge_iterator ei;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       tree phi;\n \n@@ -1033,7 +1038,8 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n       /* If we are rewriting ssa names, add also the phi arguments.  */\n       if (TREE_CODE (var) == SSA_NAME)\n \t{\n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    add_phi_arg (&phi, var, e);\n \t}\n     }\n@@ -1445,13 +1451,7 @@ rewrite_into_ssa (bool all)\n   dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n   FOR_EACH_BB (bb)\n     {\n-      edge e;\n-      int count = 0;\n-\n-      for (e = bb->pred; e; e = e->pred_next)\n-\tcount++;\n-\n-      bb_ann (bb)->num_preds = count;\n+      bb_ann (bb)->num_preds = EDGE_COUNT (bb->preds);\n       dfs[bb->index] = BITMAP_XMALLOC ();\n     }\n \n@@ -1580,13 +1580,7 @@ rewrite_ssa_into_ssa (void)\n   dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n   FOR_EACH_BB (bb)\n     {\n-      edge e;\n-      int count = 0;\n-\n-      for (e = bb->pred; e; e = e->pred_next)\n-\tcount++;\n-\n-      bb_ann (bb)->num_preds = count;\n+      bb_ann (bb)->num_preds = EDGE_COUNT (bb->preds);\n       dfs[bb->index] = BITMAP_XMALLOC ();\n     }\n "}, {"sha": "a61a7ad935c32ad3bcb3145b5d83caf724c756cd", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -538,7 +538,7 @@ mf_build_check_statement_for (tree addr, tree size,\n \n   /* We expect that the conditional jump we will construct will not\n      be taken very often as it basically is an exception condition.  */\n-  predict_edge_def (then_bb->pred, PRED_MUDFLAP, NOT_TAKEN);\n+  predict_edge_def (EDGE_PRED (then_bb, 0), PRED_MUDFLAP, NOT_TAKEN);\n \n   /* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */\n   e = find_edge (cond_bb, join_bb);"}, {"sha": "4d9986d1953c48a181e8ac14baf6899c9362cf10", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -581,13 +581,14 @@ coalesce_abnormal_edges (var_map map, conflict_graph graph, root_var_p rv)\n   edge e;\n   tree phi, var, tmp;\n   int x, y;\n+  edge_iterator ei;\n \n   /* Code cannot be inserted on abnormal edges. Look for all abnormal \n      edges, and coalesce any PHI results with their arguments across \n      that edge.  */\n \n   FOR_EACH_BB (bb)\n-    for (e = bb->succ; e; e = e->succ_next)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n       if (e->dest != EXIT_BLOCK_PTR && e->flags & EDGE_ABNORMAL)\n \tfor (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n \t  {\n@@ -1930,7 +1931,8 @@ rewrite_trees (var_map map, tree *values)\n       phi = phi_nodes (bb);\n       if (phi)\n         {\n-\t  for (e = bb->pred; e; e = e->pred_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    eliminate_phi (e, phi_arg_from_edge (phi, e), g);\n \t}\n     }"}, {"sha": "17770cd35c82c4a8aca1100d208d9267fc61cf6a", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -2151,6 +2151,7 @@ dump_bb_header (pretty_printer *buffer, basic_block bb, int indent, int flags)\n {\n   edge e;\n   tree stmt;\n+  edge_iterator ei;\n \n   if (flags & TDF_BLOCKS)\n     {\n@@ -2174,8 +2175,8 @@ dump_bb_header (pretty_printer *buffer, basic_block bb, int indent, int flags)\n \n       pp_string (buffer, \"# PRED:\");\n       pp_write_text_to_stream (buffer);\n-      for (e = bb->pred; e; e = e->pred_next)\n-        if (flags & TDF_SLIM)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (flags & TDF_SLIM)\n \t  {\n \t    pp_string (buffer, \" \");\n \t    if (e->src == ENTRY_BLOCK_PTR)\n@@ -2210,11 +2211,12 @@ static void\n dump_bb_end (pretty_printer *buffer, basic_block bb, int indent, int flags)\n {\n   edge e;\n+  edge_iterator ei;\n \n   INDENT (indent);\n   pp_string (buffer, \"# SUCC:\");\n   pp_write_text_to_stream (buffer);\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (flags & TDF_SLIM)\n       {\n \tpp_string (buffer, \" \");\n@@ -2280,10 +2282,11 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \t\t     int flags)\n {\n   edge e;\n+  edge_iterator ei;\n \n   /* If there is a fallthru edge, we may need to add an artificial goto to the\n      dump.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->flags & EDGE_FALLTHRU)\n       break;\n   if (e && e->dest != bb->next_bb)"}, {"sha": "c6e1c4ed872db2c23f4e1361ec046b629f90c6c4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1639,10 +1639,11 @@ void\n insert_edge_copies (tree stmt, basic_block bb)\n {\n   edge e;\n+  edge_iterator ei;\n   bool first_copy;\n \n   first_copy = true;\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       /* We don't need to insert copies on abnormal edges.  The\n \t value of the scalar replacement is not guaranteed to"}, {"sha": "735feb18f728d3df2333146a15ba2b43f3a8da50", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -504,7 +504,8 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t and we currently do not have a means to recognize the finite ones.  */\n       FOR_EACH_BB (bb)\n \t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_DFS_BACK)\n \t      mark_control_dependent_edges_necessary (e->dest, el);\n \t}\n@@ -731,7 +732,6 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n   if (is_ctrl_stmt (t))\n     {\n       basic_block post_dom_bb;\n-      edge e;\n       /* The post dominance info has to be up-to-date.  */\n       gcc_assert (dom_computed[CDI_POST_DOMINATORS] == DOM_OK);\n       /* Get the immediate post dominator of bb.  */\n@@ -746,30 +746,26 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n \t}\n \n       /* Redirect the first edge out of BB to reach POST_DOM_BB.  */\n-      redirect_edge_and_branch (bb->succ, post_dom_bb);\n-      PENDING_STMT (bb->succ) = NULL;\n-      bb->succ->probability = REG_BR_PROB_BASE;\n-      bb->succ->count = bb->count;\n+      redirect_edge_and_branch (EDGE_SUCC (bb, 0), post_dom_bb);\n+      PENDING_STMT (EDGE_SUCC (bb, 0)) = NULL;\n+      EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+      EDGE_SUCC (bb, 0)->count = bb->count;\n \n       /* The edge is no longer associated with a conditional, so it does\n \t not have TRUE/FALSE flags.  */\n-      bb->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \n       /* If the edge reaches any block other than the exit, then it is a\n \t fallthru edge; if it reaches the exit, then it is not a fallthru\n \t edge.  */\n       if (post_dom_bb != EXIT_BLOCK_PTR)\n-\tbb->succ->flags |= EDGE_FALLTHRU;\n+\tEDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n       else\n-\tbb->succ->flags &= ~EDGE_FALLTHRU;\n+\tEDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n \n       /* Remove the remaining the outgoing edges.  */\n-      for (e = bb->succ->succ_next; e != NULL;)\n-\t{\n-\t  edge tmp = e;\n-\t  e = e->succ_next;\n-\t  remove_edge (tmp);\n-\t}\n+      while (EDGE_COUNT (bb->succs) != 1)\n+        remove_edge (EDGE_SUCC (bb, 1));\n     }\n \n   bsi_remove (i);"}, {"sha": "1e6830bb54b1adce5f8bb58cd5ade0de9625da49", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -591,6 +591,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n     {\n       tree cond, cached_lhs;\n       edge e1;\n+      edge_iterator ei;\n \n       /* Do not forward entry edges into the loop.  In the case loop\n \t has multiple entry edges we may end up in constructing irreducible\n@@ -599,7 +600,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t edges forward to the same destination block.  */\n       if (!e->flags & EDGE_DFS_BACK)\n \t{\n-\t  for (e1 = e->dest->pred; e; e = e->pred_next)\n+\t  FOR_EACH_EDGE (e1, ei, e->dest->preds)\n \t    if (e1->flags & EDGE_DFS_BACK)\n \t      break;\n \t  if (e1)\n@@ -879,24 +880,21 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n      the edge from BB through its successor.\n \n      Do this before we remove entries from our equivalence tables.  */\n-  if (bb->succ\n-      && ! bb->succ->succ_next\n-      && (bb->succ->flags & EDGE_ABNORMAL) == 0\n-      && (get_immediate_dominator (CDI_DOMINATORS, bb->succ->dest) != bb\n-\t  || phi_nodes (bb->succ->dest)))\n+  if (EDGE_COUNT (bb->succs) == 1\n+      && (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) == 0\n+      && (get_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (bb, 0)->dest) != bb\n+\t  || phi_nodes (EDGE_SUCC (bb, 0)->dest)))\n \t\n     {\n-      thread_across_edge (walk_data, bb->succ);\n+      thread_across_edge (walk_data, EDGE_SUCC (bb, 0));\n     }\n   else if ((last = last_stmt (bb))\n \t   && TREE_CODE (last) == COND_EXPR\n \t   && (COMPARISON_CLASS_P (COND_EXPR_COND (last))\n \t       || TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME)\n-\t   && bb->succ\n-\t   && (bb->succ->flags & EDGE_ABNORMAL) == 0\n-\t   && bb->succ->succ_next\n-\t   && (bb->succ->succ_next->flags & EDGE_ABNORMAL) == 0\n-\t   && ! bb->succ->succ_next->succ_next)\n+\t   && EDGE_COUNT (bb->succs) == 2\n+\t   && (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) == 0\n+\t   && (EDGE_SUCC (bb, 1)->flags & EDGE_ABNORMAL) == 0)\n     {\n       edge true_edge, false_edge;\n       tree cond, inverted = NULL;\n@@ -1111,8 +1109,9 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n {\n   edge retval = NULL;\n   edge e;\n+  edge_iterator ei;\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       /* A loop back edge can be identified by the destination of\n \t the edge dominating the source of the edge.  */\n@@ -1161,7 +1160,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data ATTRIBUT\n   /* If we have a single predecessor (ignoring loop backedges), then extract\n      EDGE_FLAGS from the single incoming edge.  Otherwise just return as\n      there is nothing to do.  */\n-  if (bb->pred\n+  if (EDGE_COUNT (bb->preds) >= 1\n       && parent_block_last_stmt)\n     {\n       edge e = single_incoming_edge_ignoring_loop_edges (bb);\n@@ -1192,7 +1191,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data ATTRIBUT\n   /* Similarly when the parent block ended in a SWITCH_EXPR.\n      We can only know the value of the switch's condition if the dominator\n      parent is also the only predecessor of this block.  */\n-  else if (bb->pred->src == parent\n+  else if (EDGE_PRED (bb, 0)->src == parent\n \t   && TREE_CODE (parent_block_last_stmt) == SWITCH_EXPR)\n     {\n       tree switch_cond = SWITCH_COND (parent_block_last_stmt);\n@@ -2185,10 +2184,11 @@ static void\n cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n {\n   edge e;\n+  edge_iterator ei;\n \n   /* This can get rather expensive if the implementation is naive in\n      how it finds the phi alternative associated with a particular edge.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       tree phi;\n       int phi_num_args;"}, {"sha": "d716a7e76aeb1406b2c4a895aa34fa780736e60c", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -488,6 +488,7 @@ live_worklist (tree_live_info_p live, varray_type stack, int i)\n   basic_block def_bb = NULL;\n   edge e;\n   var_map map = live->map;\n+  edge_iterator ei;\n   bitmap_iterator bi;\n \n   var = partition_to_var (map, i);\n@@ -504,15 +505,15 @@ live_worklist (tree_live_info_p live, varray_type stack, int i)\n       b = VARRAY_TOP_INT (stack);\n       VARRAY_POP (stack);\n \n-      for (e = BASIC_BLOCK (b)->pred; e; e = e->pred_next)\n-        if (e->src != ENTRY_BLOCK_PTR)\n+      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (b)->preds)\n+\tif (e->src != ENTRY_BLOCK_PTR)\n \t  {\n \t    /* Its not live on entry to the block its defined in.  */\n \t    if (e->src == def_bb)\n \t      continue;\n \t    if (!bitmap_bit_p (live->livein[i], e->src->index))\n \t      {\n-\t        bitmap_set_bit (live->livein[i], e->src->index);\n+\t\tbitmap_set_bit (live->livein[i], e->src->index);\n \t\tVARRAY_PUSH_INT (stack, e->src->index);\n \t      }\n \t  }\n@@ -570,7 +571,7 @@ calculate_live_on_entry (var_map map)\n #ifdef ENABLE_CHECKING\n   int num;\n #endif\n-\n+  edge_iterator ei;\n \n   saw_def = BITMAP_XMALLOC ();\n \n@@ -642,7 +643,7 @@ calculate_live_on_entry (var_map map)\n \n   bb = ENTRY_BLOCK_PTR;\n   num = 0;\n-  for (e = bb->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       int entry_block = e->dest->index;\n       if (e->dest == EXIT_BLOCK_PTR)\n@@ -765,7 +766,8 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n       on_entry = live_entry_blocks (liveinfo, i);\n       EXECUTE_IF_SET_IN_BITMAP (on_entry, 0, b, bi)\n         {\n-\t  for (e = BASIC_BLOCK(b)->pred; e; e = e->pred_next)\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (b)->preds)\n \t    if (e->src != ENTRY_BLOCK_PTR)\n \t      bitmap_set_bit (on_exit[e->src->index], i);\n \t}"}, {"sha": "ecdf6f2cc2c90ac62634928730e9b61e8ac3320f", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -59,19 +59,16 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n   if (header->aux)\n     return false;\n \n-  gcc_assert (header->succ);\n-  if (!header->succ->succ_next)\n+  gcc_assert (EDGE_COUNT (header->succs) > 0);\n+  if (EDGE_COUNT (header->succs) == 1)\n     return false;\n-  if (header->succ->succ_next->succ_next)\n-    return false;\n-  if (flow_bb_inside_loop_p (loop, header->succ->dest)\n-      && flow_bb_inside_loop_p (loop, header->succ->succ_next->dest))\n+  if (flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 0)->dest)\n+      && flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 1)->dest))\n     return false;\n \n   /* If this is not the original loop header, we want it to have just\n      one predecessor in order to match the && pattern.  */\n-  if (header != loop->header\n-      && header->pred->pred_next)\n+  if (header != loop->header && EDGE_COUNT (header->preds) >= 2)\n     return false;\n \n   last = last_stmt (header);\n@@ -176,10 +173,10 @@ copy_loop_headers (void)\n \t{\n \t  /* Find a successor of header that is inside a loop; i.e. the new\n \t     header after the condition is copied.  */\n-\t  if (flow_bb_inside_loop_p (loop, header->succ->dest))\n-\t    exit = header->succ;\n+\t  if (flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 0)->dest))\n+\t    exit = EDGE_SUCC (header, 0);\n \t  else\n-\t    exit = header->succ->succ_next;\n+\t    exit = EDGE_SUCC (header, 1);\n \t  bbs[n_bbs++] = header;\n \t  header = exit->dest;\n \t}\n@@ -194,8 +191,8 @@ copy_loop_headers (void)\n \n       /* Ensure that the header will have just the latch as a predecessor\n \t inside the loop.  */\n-      if (exit->dest->pred->pred_next)\n-\texit = loop_split_edge_with (exit, NULL)->succ;\n+      if (EDGE_COUNT (exit->dest->preds) > 1)\n+\texit = EDGE_SUCC (loop_split_edge_with (exit, NULL), 0);\n \n       if (!tree_duplicate_sese_region (loop_preheader_edge (loop), exit,\n \t\t\t\t       bbs, n_bbs, NULL))"}, {"sha": "c7a60768ee9a6c5f467a2bb0cd67b27ebcd2b14e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -603,8 +603,8 @@ loop_commit_inserts (void)\n     {\n       bb = BASIC_BLOCK (i);\n       add_bb_to_loop (bb,\n-\t\t      find_common_loop (bb->succ->dest->loop_father,\n-\t\t\t\t\tbb->pred->src->loop_father));\n+\t\t      find_common_loop (EDGE_SUCC (bb, 0)->dest->loop_father,\n+\t\t\t\t\tEDGE_PRED (bb, 0)->src->loop_father));\n     }\n }\n \n@@ -1316,6 +1316,7 @@ fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n \n       for (i = 0; i < loop->num_nodes; i++)\n \t{\n+\t  edge_iterator ei;\n \t  bb = bbs[i];\n \n \t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n@@ -1324,7 +1325,7 @@ fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n \t  if (TEST_BIT (contains_call, bb->index))\n \t    break;\n \n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (!flow_bb_inside_loop_p (loop, e->dest))\n \t      break;\n \t  if (e)"}, {"sha": "66fee03b1a19bde5895f0ef238c655b59edb8de0", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -74,9 +74,9 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n     }\n \n   cond = last_stmt (exit->src);\n-  in = exit->src->succ;\n+  in = EDGE_SUCC (exit->src, 0);\n   if (in == exit)\n-    in = in->succ_next;\n+    in = EDGE_SUCC (exit->src, 1);\n \n   /* Note that we do not need to worry about overflows, since\n      type of niter is always unsigned and all comparisons are"}, {"sha": "33c275fda3b54b371b486adfe4a059e3deff7097", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1510,9 +1510,10 @@ find_interesting_uses (struct ivopts_data *data)\n \n   for (i = 0; i < data->current_loop->num_nodes; i++)\n     {\n+      edge_iterator ei;\n       bb = body[i];\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n \t    && !flow_bb_inside_loop_p (data->current_loop, e->dest))\n \t  find_interesting_uses_outside (data, e);\n@@ -4128,7 +4129,7 @@ compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n   block_stmt_iterator bsi;\n   tree phi, stmt, def, next;\n \n-  if (exit->dest->pred->pred_next)\n+  if (EDGE_COUNT (exit->dest->preds) > 1)\n     split_loop_exit_edge (exit);\n \n   if (TREE_CODE (stmts) == STATEMENT_LIST)"}, {"sha": "25c366c1284120831f36547e5b8897b162984c7d", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -123,10 +123,11 @@ add_exit_phis_edge (basic_block exit, tree use)\n   basic_block def_bb = bb_for_stmt (def_stmt);\n   struct loop *def_loop;\n   edge e;\n+  edge_iterator ei;\n \n   /* Check that some of the edges entering the EXIT block exits a loop in\n      that USE is defined.  */\n-  for (e = exit->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, exit->preds)\n     {\n       def_loop = find_common_loop (def_bb->loop_father, e->src->loop_father);\n       if (!flow_bb_inside_loop_p (def_loop, e->dest))\n@@ -138,7 +139,7 @@ add_exit_phis_edge (basic_block exit, tree use)\n \n   phi = create_phi_node (use, exit);\n \n-  for (e = exit->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, exit->preds)\n     add_phi_arg (&phi, use, e);\n \n   SSA_NAME_DEF_STMT (use) = def_stmt;\n@@ -192,10 +193,11 @@ get_loops_exits (void)\n   bitmap exits = BITMAP_XMALLOC ();\n   basic_block bb;\n   edge e;\n+  edge_iterator ei;\n \n   FOR_EACH_BB (bb)\n     {\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->src != ENTRY_BLOCK_PTR\n \t    && !flow_bb_inside_loop_p (e->src->loop_father, bb))\n \t  {\n@@ -404,7 +406,7 @@ split_loop_exit_edge (edge exit)\n \n   for (phi = phi_nodes (dest); phi; phi = TREE_CHAIN (phi))\n     {\n-      op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, bb->succ);\n+      op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, EDGE_SUCC (bb, 0));\n \n       name = USE_FROM_PTR (op_p);\n \n@@ -468,17 +470,17 @@ ip_normal_pos (struct loop *loop)\n   basic_block bb;\n   edge exit;\n \n-  if (loop->latch->pred->pred_next)\n+  if (EDGE_COUNT (loop->latch->preds) > 1)\n     return NULL;\n \n-  bb = loop->latch->pred->src;\n+  bb = EDGE_PRED (loop->latch, 0)->src;\n   last = last_stmt (bb);\n   if (TREE_CODE (last) != COND_EXPR)\n     return NULL;\n \n-  exit = bb->succ;\n+  exit = EDGE_SUCC (bb, 0);\n   if (exit->dest == loop->latch)\n-    exit = exit->succ_next;\n+    exit = EDGE_SUCC (bb, 1);\n \n   if (flow_bb_inside_loop_p (loop, exit->dest))\n     return NULL;\n@@ -732,7 +734,7 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n \n   /* Adjust edges appropriately to connect new head with first head\n      as well as second head.  */\n-  e0 = new_head->succ;\n+  e0 = EDGE_SUCC (new_head, 0);\n   e0->flags &= ~EDGE_FALLTHRU;\n   e0->flags |= EDGE_FALSE_VALUE;\n   e1 = make_edge (new_head, first_head, EDGE_TRUE_VALUE);\n@@ -816,10 +818,10 @@ tree_ssa_loop_version (struct loops *loops, struct loop * loop,\n   *condition_bb = lv_adjust_loop_entry_edge (first_head, second_head, entry, \n \t\t\t\t\t    cond_expr); \n \n-  latch_edge = loop->latch->rbi->copy->succ;\n+  latch_edge = EDGE_SUCC (loop->latch->rbi->copy, 0);\n   nloop = loopify (loops, \n \t\t   latch_edge,\n-\t\t   loop->header->rbi->copy->pred,\n+\t\t   EDGE_PRED (loop->header->rbi->copy, 0),\n \t\t   *condition_bb,\n \t\t   false /* Do not redirect all edges.  */);\n \n@@ -839,7 +841,7 @@ tree_ssa_loop_version (struct loops *loops, struct loop * loop,\n       (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      (*condition_bb)->pred->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      EDGE_PRED ((*condition_bb), 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   /* At this point condition_bb is loop predheader with two successors, "}, {"sha": "381456cc8d83a0b32e54db61f55e3875e1974333", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -566,8 +566,8 @@ simplify_using_initial_conditions (struct loop *loop, tree expr,\n        bb != ENTRY_BLOCK_PTR;\n        bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n-      e = bb->pred;\n-      if (e->pred_next)\n+      e = EDGE_PRED (bb, 0);\n+      if (EDGE_COUNT (bb->preds) > 1)\n \tcontinue;\n \n       if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))"}, {"sha": "d4ab19263aec59a56a5c52fac7b15c347786ffe3", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -172,10 +172,10 @@ simplify_using_entry_checks (struct loop *loop, tree cond)\n \t\t? boolean_true_node\n \t\t: boolean_false_node);\n \n-      if (e->src->pred->pred_next)\n+      if (EDGE_COUNT (e->src->preds) > 1)\n \treturn cond;\n \n-      e = e->src->pred;\n+      e = EDGE_PRED (e->src, 0);\n       if (e->src == ENTRY_BLOCK_PTR)\n \treturn cond;\n     }\n@@ -283,9 +283,7 @@ tree_unswitch_loop (struct loops *loops, struct loop *loop,\n \n   /* Some sanity checking.  */\n   gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n-  gcc_assert (unswitch_on->succ != NULL);\n-  gcc_assert (unswitch_on->succ->succ_next != NULL);\n-  gcc_assert (unswitch_on->succ->succ_next->succ_next == NULL);\n+  gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n   gcc_assert (loop->inner == NULL);\n \n   return tree_ssa_loop_version (loops, loop, unshare_expr (cond), "}, {"sha": "7c38b8aae98157e9c71052f420af3eb92e5a72d5", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -185,39 +185,35 @@ candidate_bb_for_phi_optimization (basic_block bb,\n \n   /* One of the alternatives must come from a block ending with\n      a COND_EXPR.  */\n-  last0 = last_stmt (bb->pred->src);\n-  last1 = last_stmt (bb->pred->pred_next->src);\n+  last0 = last_stmt (EDGE_PRED (bb, 0)->src);\n+  last1 = last_stmt (EDGE_PRED (bb, 1)->src);\n   if (last0 && TREE_CODE (last0) == COND_EXPR)\n     {\n-      cond_block = bb->pred->src;\n-      other_block = bb->pred->pred_next->src;\n+      cond_block = EDGE_PRED (bb, 0)->src;\n+      other_block = EDGE_PRED (bb, 1)->src;\n     }\n   else if (last1 && TREE_CODE (last1) == COND_EXPR)\n     {\n-      other_block = bb->pred->src;\n-      cond_block = bb->pred->pred_next->src;\n+      other_block = EDGE_PRED (bb, 0)->src;\n+      cond_block = EDGE_PRED (bb, 1)->src;\n     }\n   else\n     return false;\n   \n   /* COND_BLOCK must have precisely two successors.  We indirectly\n      verify that those successors are BB and OTHER_BLOCK.  */\n-  if (!cond_block->succ\n-      || !cond_block->succ->succ_next\n-      || cond_block->succ->succ_next->succ_next\n-      || (cond_block->succ->flags & EDGE_ABNORMAL) != 0\n-      || (cond_block->succ->succ_next->flags & EDGE_ABNORMAL) != 0)\n+  if (EDGE_COUNT (cond_block->succs) != 2\n+      || (EDGE_SUCC (cond_block, 0)->flags & EDGE_ABNORMAL) != 0\n+      || (EDGE_SUCC (cond_block, 1)->flags & EDGE_ABNORMAL) != 0)\n     return false;\n   \n   /* OTHER_BLOCK must have a single predecessor which is COND_BLOCK,\n      OTHER_BLOCK must have a single successor which is BB and\n      OTHER_BLOCK must have no PHI nodes.  */\n-  if (!other_block->pred\n-      || other_block->pred->src != cond_block\n-      || other_block->pred->pred_next\n-      || !other_block->succ\n-      || other_block->succ->dest != bb\n-      || other_block->succ->succ_next\n+  if (EDGE_COUNT (other_block->preds) != 1\n+      || EDGE_PRED (other_block, 0)->src != cond_block\n+      || EDGE_COUNT (other_block->succs) != 1\n+      || EDGE_SUCC (other_block, 0)->dest != bb\n       || phi_nodes (other_block))\n     return false;\n   \n@@ -252,20 +248,20 @@ replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n   bb_ann (bb)->phi_nodes = NULL;\n   \n   /* Remove the empty basic block.  */\n-  if (cond_block->succ->dest == bb)\n+  if (EDGE_SUCC (cond_block, 0)->dest == bb)\n     {\n-      cond_block->succ->flags |= EDGE_FALLTHRU;\n-      cond_block->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      EDGE_SUCC (cond_block, 0)->flags |= EDGE_FALLTHRU;\n+      EDGE_SUCC (cond_block, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \n-      block_to_remove = cond_block->succ->succ_next->dest;\n+      block_to_remove = EDGE_SUCC (cond_block, 1)->dest;\n     }\n   else\n     {\n-      cond_block->succ->succ_next->flags |= EDGE_FALLTHRU;\n-      cond_block->succ->succ_next->flags\n+      EDGE_SUCC (cond_block, 1)->flags |= EDGE_FALLTHRU;\n+      EDGE_SUCC (cond_block, 1)->flags\n \t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \n-      block_to_remove = cond_block->succ->dest;\n+      block_to_remove = EDGE_SUCC (cond_block, 0)->dest;\n     }\n   delete_basic_block (block_to_remove);\n   \n@@ -477,7 +473,7 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \t edge from OTHER_BLOCK which reaches BB and represents the desired\n \t path from COND_BLOCK.  */\n       if (e->dest == other_block)\n-\te = e->dest->succ;\n+\te = EDGE_SUCC (e->dest, 0);\n \n       /* Now we know the incoming edge to BB that has the argument for the\n \t RHS of our new assignment statement.  */"}, {"sha": "b0809d14b73a97ae7fe6709717cd488a4c6a1f93", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1137,12 +1137,13 @@ compute_antic_aux (basic_block block)\n      setting the BB_VISITED flag.  */\n   if (! (block->flags & BB_VISITED))\n     {\n-      for (e = block->pred; e; e = e->pred_next)\n- \tif (e->flags & EDGE_ABNORMAL)\n- \t  {\n- \t    block->flags |= BB_VISITED;\n- \t    break;\n- \t  }\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, block->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    block->flags |= BB_VISITED;\n+\t    break;\n+\t  }\n     }\n   if (block->flags & BB_VISITED)\n     {\n@@ -1157,14 +1158,14 @@ compute_antic_aux (basic_block block)\n \n   /* If the block has no successors, ANTIC_OUT is empty, because it is\n      the exit block.  */\n-  if (block->succ == NULL);\n+  if (EDGE_COUNT (block->succs) == 0);\n \n   /* If we have one successor, we could have some phi nodes to\n      translate through.  */\n-  else if (block->succ->succ_next == NULL)\n+  else if (EDGE_COUNT (block->succs) == 1)\n     {\n-      phi_translate_set (ANTIC_OUT, ANTIC_IN(block->succ->dest),\n-\t\t\t block, block->succ->dest);\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN(EDGE_SUCC (block, 0)->dest),\n+\t\t\t block, EDGE_SUCC (block, 0)->dest);\n     }\n   /* If we have multiple successors, we take the intersection of all of\n      them.  */\n@@ -1174,14 +1175,11 @@ compute_antic_aux (basic_block block)\n       edge e;\n       size_t i;\n       basic_block bprime, first;\n+      edge_iterator ei;\n \n       worklist = VEC_alloc (basic_block, 2);\n-      e = block->succ;\n-      while (e)\n-\t{\n-\t  VEC_safe_push (basic_block, worklist, e->dest);\n-\t  e = e->succ_next;\n-\t}\n+      FOR_EACH_EDGE (e, ei, block->succs)\n+\tVEC_safe_push (basic_block, worklist, e->dest);\n       first = VEC_index (basic_block, worklist, 0);\n       set_copy (ANTIC_OUT, ANTIC_IN (first));\n \n@@ -1426,7 +1424,7 @@ insert_aux (basic_block block)\n \t      bitmap_insert_into_set (NEW_SETS (block), ssa_name (i));\n \t      bitmap_value_replace_in_set (AVAIL_OUT (block), ssa_name (i));\n \t    }\n-\t  if (block->pred->pred_next)\n+\t  if (EDGE_COUNT (block->preds) > 1)\n \t    {\n \t      value_set_node_t node;\n \t      for (node = ANTIC_IN (block)->head;\n@@ -1445,6 +1443,7 @@ insert_aux (basic_block block)\n \t\t      edge pred;\n \t\t      basic_block bprime;\n \t\t      tree eprime;\n+\t\t      edge_iterator ei;\n \n \t\t      val = get_value_handle (node->expr);\n \t\t      if (bitmap_set_contains_value (PHI_GEN (block), val))\n@@ -1455,11 +1454,9 @@ insert_aux (basic_block block)\n \t\t\t    fprintf (dump_file, \"Found fully redundant value\\n\");\n \t\t\t  continue;\n \t\t\t}\n-\t\t    \t\t    \n+\t\t\t\t\t      \n \t\t      avail = xcalloc (last_basic_block, sizeof (tree));\n-\t\t      for (pred = block->pred;\n-\t\t\t   pred;\n-\t\t\t   pred = pred->pred_next)\n+\t\t      FOR_EACH_EDGE (pred, ei, block->preds)\n \t\t\t{\n \t\t\t  tree vprime;\n \t\t\t  tree edoubleprime;\n@@ -1520,7 +1517,7 @@ insert_aux (basic_block block)\n \t\t\t partially redundant.  */\n \t\t      if (!cant_insert && !all_same && by_some)\n \t\t\t{\n-\t\t\t  tree type = TREE_TYPE (avail[block->pred->src->index]);\n+\t\t\t  tree type = TREE_TYPE (avail[EDGE_PRED (block, 0)->src->index]);\n \t\t\t  tree temp;\n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    {\n@@ -1530,9 +1527,7 @@ insert_aux (basic_block block)\n \t\t\t    }\n \n \t\t\t  /* Make the necessary insertions.  */\n-\t\t\t  for (pred = block->pred;\n-\t\t\t       pred;\n-\t\t\t       pred = pred->pred_next)\n+\t\t\t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t\t\t    {\n \t\t\t      tree stmts = alloc_stmt_list ();\n \t\t\t      tree builtexpr;\n@@ -1547,7 +1542,7 @@ insert_aux (basic_block block)\n \t\t\t\t  bsi_insert_on_edge (pred, stmts);\n \t\t\t\t  avail[bprime->index] = builtexpr;\n \t\t\t\t}\t\t\t      \n-\t\t\t    } \n+\t\t\t    }\n \t\t\t  /* Now build a phi for the new variable.  */\n \t\t\t  temp = create_tmp_var (type, \"prephitmp\");\n \t\t\t  add_referenced_tmp_var (temp);\n@@ -1562,9 +1557,7 @@ insert_aux (basic_block block)\n #endif\n \t\t\t    bitmap_value_replace_in_set (AVAIL_OUT (block), \n \t\t\t\t\t\t\t PHI_RESULT (temp));\n-\t\t\t  for (pred = block->pred;\n-\t\t\t       pred;\n-\t\t\t       pred = pred->pred_next)\n+\t\t\t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t\t\t    {\n \t\t\t      add_phi_arg (&temp, avail[pred->src->index],\n \t\t\t\t\t   pred);\n@@ -1926,9 +1919,9 @@ init_pre (void)\n      ENTRY_BLOCK_PTR (FIXME, if ENTRY_BLOCK_PTR had an index number\n      different than -1 we wouldn't have to hack this.  tree-ssa-dce.c\n      needs a similar change).  */\n-  if (ENTRY_BLOCK_PTR->succ->dest->pred->pred_next)\n-    if (!(ENTRY_BLOCK_PTR->succ->flags & EDGE_ABNORMAL))\n-      split_edge (ENTRY_BLOCK_PTR->succ);\n+  if (EDGE_COUNT (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->preds) > 1)\n+    if (!(EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->flags & EDGE_ABNORMAL))\n+      split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n \n   FOR_ALL_BB (bb)\n     bb->aux = xcalloc (1, sizeof (struct bb_value_sets));"}, {"sha": "e93b9c1ca1f222ce644b57300a17baadf6544a03", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -318,8 +318,9 @@ simulate_stmt (tree stmt)\n       if (stmt_ends_bb_p (stmt))\n \t{\n \t  edge e;\n+\t  edge_iterator ei;\n \t  basic_block bb = bb_for_stmt (stmt);\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    add_control_edge (e);\n \t}\n     }\n@@ -406,6 +407,7 @@ simulate_block (basic_block block)\n       block_stmt_iterator j;\n       unsigned int normal_edge_count;\n       edge e, normal_edge;\n+      edge_iterator ei;\n \n       /* Note that we have simulated this block.  */\n       SET_BIT (executable_blocks, block->index);\n@@ -434,7 +436,7 @@ simulate_block (basic_block block)\n \t worklist.  */\n       normal_edge_count = 0;\n       normal_edge = NULL;\n-      for (e = block->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n \t  if (e->flags & EDGE_ABNORMAL)\n \t    add_control_edge (e);\n@@ -457,6 +459,7 @@ static void\n ssa_prop_init (void)\n {\n   edge e;\n+  edge_iterator ei;\n   basic_block bb;\n \n   /* Worklists of SSA edges.  */\n@@ -482,13 +485,13 @@ ssa_prop_init (void)\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \tSTMT_IN_SSA_EDGE_WORKLIST (bsi_stmt (si)) = 0;\n \n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \te->flags &= ~EDGE_EXECUTABLE;\n     }\n \n   /* Seed the algorithm by adding the successors of the entry block to the\n      edge worklist.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       if (e->dest != EXIT_BLOCK_PTR)\n \t{"}, {"sha": "a1f6cda098cc243c86b9e397434e8a7244d59d03", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -141,7 +141,8 @@ static void\n remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n {\n   block_stmt_iterator bsi;\n-  edge e, next;\n+  edge e;\n+  edge_iterator ei;\n \n   bsi = bsi_last (bb);\n \n@@ -150,19 +151,18 @@ remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n \n   bsi_remove (&bsi);\n \n-  next = NULL;\n-  for (e = bb->succ; e; e = next)\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      next = e->succ_next;\n-\n       if (e->dest != dest_bb)\n \tssa_remove_edge (e);\n+      else\n+\tei_next (&ei);\n     }\n \n   /* BB now has a single outgoing edge. We need to update the flags for\n      that single outgoing edge.  */\n-  bb->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-  bb->succ->flags |= EDGE_FALLTHRU;\n+  EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+  EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n }\n \n /* Create a duplicate of BB which only reaches the destination of the edge\n@@ -173,6 +173,7 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n {\n   tree phi;\n   edge e;\n+  edge_iterator ei;\n \n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n@@ -188,18 +189,19 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n      specialized block copier.  */\n   remove_last_stmt_and_useless_edges (rd->dup_block, rd->outgoing_edge->dest);\n \n-  for (e = rd->dup_block->succ; e; e = e->succ_next)\n+  FOR_EACH_EDGE (e, ei, rd->dup_block->succs)\n     e->count = 0;\n \n   /* If there are any PHI nodes at the destination of the outgoing edge\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument\n      associated with the outgoing edge stored in RD.  */\n-  for (phi = phi_nodes (rd->dup_block->succ->dest); phi;\n+  for (phi = phi_nodes (EDGE_SUCC (rd->dup_block, 0)->dest); phi;\n        phi = PHI_CHAIN (phi))\n     {\n       int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n-      add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx), rd->dup_block->succ);\n+      add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx),\n+\t\t   EDGE_SUCC (rd->dup_block, 0));\n     }\n }\n \n@@ -238,10 +240,7 @@ thread_block (basic_block bb)\n   /* E is an incoming edge into BB that we may or may not want to\n      redirect to a duplicate of BB.  */\n   edge e;\n-\n-  /* The next edge in a predecessor list.  Used in loops where E->pred_next\n-     may change within the loop.  */\n-  edge next;\n+  edge_iterator ei;\n \n   /* ALL indicates whether or not all incoming edges into BB should\n      be threaded to a duplicate of BB.  */\n@@ -254,7 +253,7 @@ thread_block (basic_block bb)\n   /* Look at each incoming edge into BB.  Record each unique outgoing\n      edge that we want to thread an incoming edge to.  Also note if\n      all incoming edges are threaded or not.  */\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (!e->aux)\n \t{\n@@ -312,16 +311,16 @@ thread_block (basic_block bb)\n      If this turns out to be a performance problem, then we could create\n      a list of incoming edges associated with each entry in \n      REDIRECTION_DATA and walk over that list of edges instead.  */\n-  next = NULL;\n-  for (e = bb->pred; e; e = next)\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n     {\n       edge new_dest = e->aux;\n \n-      next = e->pred_next;\n-\n       /* E was not threaded, then there is nothing to do.  */\n       if (!new_dest)\n-\tcontinue;\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n \n       /* Go ahead and clear E->aux.  It's not needed anymore and failure\n          to clear it will cause all kinds of unpleasant problems later.  */\n@@ -373,7 +372,8 @@ thread_block (basic_block bb)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t bb->pred->src->index, bb->index, bb->succ->dest->index);\n+\t\t EDGE_PRED (bb, 0)->src->index, bb->index,\n+\t\t EDGE_SUCC (bb, 0)->dest->index);\n \n       remove_last_stmt_and_useless_edges (bb, rd->outgoing_edge->dest);\n     }"}, {"sha": "5b9b3ccd185253ce97a112a9857b2478c2b2084e", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -278,9 +278,10 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n   edge e;\n   bool err = false;\n   int i, phi_num_args = PHI_NUM_ARGS (phi);\n+  edge_iterator ei;\n \n   /* Mark all the incoming edges.  */\n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     e->aux = (void *) 1;\n \n   for (i = 0; i < phi_num_args; i++)\n@@ -326,7 +327,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n       e->aux = (void *) 2;\n     }\n \n-  for (e = bb->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (e->aux != (void *) 2)\n \t{\n@@ -580,10 +581,11 @@ verify_ssa (void)\n     {\n       edge e;\n       tree phi;\n+      edge_iterator ei;\n       block_stmt_iterator bsi;\n \n       /* Make sure that all edges have a clear 'aux' field.  */\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if (e->aux)\n \t    {\n@@ -631,7 +633,7 @@ verify_ssa (void)\n \n       /* Verify the uses in arguments of PHI nodes at the exits from the\n \t block.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n \t    {"}, {"sha": "a6c44933f79e634265721f772c6cdcfcbffbdf9b", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -190,6 +190,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n {\n   basic_block bb, call_bb, at_bb;\n   edge e;\n+  edge_iterator ei;\n \n   if (is_gimple_min_invariant (expr))\n     return expr;\n@@ -200,7 +201,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n   /* Mark the blocks in the chain leading to the end.  */\n   at_bb = bb_for_stmt (at);\n   call_bb = bb_for_stmt (bsi_stmt (bsi));\n-  for (bb = call_bb; bb != at_bb; bb = bb->succ->dest)\n+  for (bb = call_bb; bb != at_bb; bb = EDGE_SUCC (bb, 0)->dest)\n     bb->aux = &bb->aux;\n   bb->aux = &bb->aux;\n \n@@ -230,7 +231,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n \t  break;\n \t}\n \n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->src->aux)\n \t  break;\n       gcc_assert (e);\n@@ -244,7 +245,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n     }\n \n   /* Unmark the blocks.  */\n-  for (bb = call_bb; bb != at_bb; bb = bb->succ->dest)\n+  for (bb = call_bb; bb != at_bb; bb = EDGE_SUCC (bb, 0)->dest)\n     bb->aux = NULL;\n   bb->aux = NULL;\n \n@@ -371,7 +372,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   basic_block abb;\n   stmt_ann_t ann;\n \n-  if (bb->succ->succ_next)\n+  if (EDGE_COUNT (bb->succs) > 1)\n     return;\n \n   for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n@@ -412,8 +413,9 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n   if (bsi_end_p (bsi))\n     {\n+      edge_iterator ei;\n       /* Recurse to the predecessors.  */\n-      for (e = bb->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \tfind_tail_calls (e->src, ret);\n \n       return;\n@@ -458,8 +460,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       while (bsi_end_p (absi))\n \t{\n-\t  ass_var = propagate_through_phis (ass_var, abb->succ);\n-\t  abb = abb->succ->dest;\n+\t  ass_var = propagate_through_phis (ass_var, EDGE_SUCC (abb, 0));\n+\t  abb = EDGE_SUCC (abb, 0)->dest;\n \t  absi = bsi_start (abb);\n \t}\n \n@@ -677,7 +679,7 @@ eliminate_tail_call (struct tailcall *t)\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     stmt = TREE_OPERAND (stmt, 1);\n \n-  first = ENTRY_BLOCK_PTR->succ->dest;\n+  first = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n \n   /* Remove the code after call_bsi that will become unreachable.  The\n      possibly unreachable code in other blocks is removed later in\n@@ -697,7 +699,7 @@ eliminate_tail_call (struct tailcall *t)\n     }\n \n   /* Replace the call by a jump to the start of function.  */\n-  e = redirect_edge_and_branch (t->call_block->succ, first);\n+  e = redirect_edge_and_branch (EDGE_SUCC (t->call_block, 0), first);\n   gcc_assert (e);\n   PENDING_STMT (e) = NULL_TREE;\n \n@@ -752,12 +754,12 @@ eliminate_tail_call (struct tailcall *t)\n \t  var_ann (param)->default_def = new_name;\n \t  phi = create_phi_node (name, first);\n \t  SSA_NAME_DEF_STMT (name) = phi;\n-\t  add_phi_arg (&phi, new_name, ENTRY_BLOCK_PTR->succ);\n+\t  add_phi_arg (&phi, new_name, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n \n \t  /* For all calls the same set of variables should be clobbered.  This\n \t     means that there always should be the appropriate phi node except\n \t     for the first time we eliminate the call.  */\n-\t  gcc_assert (!first->pred->pred_next->pred_next);\n+\t  gcc_assert (EDGE_COUNT (first->preds) <= 2);\n \t}\n \n       add_phi_arg (&phi, V_MAY_DEF_OP (v_may_defs, i), e);\n@@ -819,15 +821,16 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   bool phis_constructed = false;\n   struct tailcall *tailcalls = NULL, *act, *next;\n   bool changed = false;\n-  basic_block first = ENTRY_BLOCK_PTR->succ->dest;\n+  basic_block first = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n   tree stmt, param, ret_type, tmp, phi;\n+  edge_iterator ei;\n \n   if (!suitable_for_tail_opt_p ())\n     return;\n   if (opt_tailcalls)\n     opt_tailcalls = suitable_for_tail_call_opt_p ();\n \n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     {\n       /* Only traverse the normal exits, i.e. those that end with return\n \t statement.  */\n@@ -848,8 +851,8 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n       if (!phis_constructed)\n \t{\n \t  /* Ensure that there is only one predecessor of the block.  */\n-\t  if (first->pred->pred_next)\n-\t    first = split_edge (ENTRY_BLOCK_PTR->succ);\n+\t  if (EDGE_COUNT (first->preds) > 1)\n+\t    first = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n \n \t  /* Copy the args if needed.  */\n \t  for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -868,7 +871,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t      var_ann (param)->default_def = new_name;\n \t      phi = create_phi_node (name, first);\n \t      SSA_NAME_DEF_STMT (name) = phi;\n-\t      add_phi_arg (&phi, new_name, first->pred);\n+\t      add_phi_arg (&phi, new_name, EDGE_PRED (first, 0));\n \t    }\n \t  phis_constructed = true;\n \t}\n@@ -881,7 +884,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t  add_referenced_tmp_var (tmp);\n \n \t  phi = create_phi_node (tmp, first);\n-\t  add_phi_arg (&phi, build_int_cst (ret_type, 0), first->pred);\n+\t  add_phi_arg (&phi, build_int_cst (ret_type, 0), EDGE_PRED (first, 0));\n \t  a_acc = PHI_RESULT (phi);\n \t}\n \n@@ -893,7 +896,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t  add_referenced_tmp_var (tmp);\n \n \t  phi = create_phi_node (tmp, first);\n-\t  add_phi_arg (&phi, build_int_cst (ret_type, 1), first->pred);\n+\t  add_phi_arg (&phi, build_int_cst (ret_type, 1), EDGE_PRED (first, 0));\n \t  m_acc = PHI_RESULT (phi);\n \t}\n     }\n@@ -908,7 +911,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   if (a_acc || m_acc)\n     {\n       /* Modify the remaining return statements.  */\n-      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n \t  stmt = last_stmt (e->src);\n "}, {"sha": "4493da19c52a73a238066f47a27b4355f903331e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -1876,8 +1876,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */\n \n-  gcc_assert (loop->header->pred->pred_next);\n-  gcc_assert (!loop->header->pred->pred_next->pred_next);\n+  gcc_assert (EDGE_COUNT (loop->header->preds) == 2);\n \n   loop_split_edge_with (loop_preheader_edge (loop), NULL);\n "}, {"sha": "72cb81d927e9cfa43fdf80e8f511b7959bc8b244", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f6a4e7c8e168256fe257a0dfc5f4fddda900a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "patch": "@@ -526,30 +526,30 @@ prologue_stack_adjust (void)\n static bool\n vt_stack_adjustments (void)\n {\n-  edge *stack;\n+  edge_iterator *stack;\n   int sp;\n \n   /* Initialize entry block.  */\n   VTI (ENTRY_BLOCK_PTR)->visited = true;\n   VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = frame_stack_adjust;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n \n   while (sp)\n     {\n-      edge e;\n+      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n       if (!VTI (dest)->visited)\n@@ -558,10 +558,10 @@ vt_stack_adjustments (void)\n \t  VTI (dest)->in.stack_adjust = VTI (src)->out.stack_adjust;\n \t  bb_stack_adjust_offset (dest);\n \n-\t  if (dest->succ)\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = dest->succ;\n+\t    stack[sp++] = ei_start (dest->succs);\n \t}\n       else\n \t{\n@@ -572,9 +572,9 @@ vt_stack_adjustments (void)\n \t      return false;\n \t    }\n \n-\t  if (e->succ_next)\n+\t  if (! ei_one_before_end_p (ei))\n \t    /* Go to the next edge.  */\n-\t    stack[sp - 1] = e->succ_next;\n+\t    ei_next (&stack[sp - 1]);\n \t  else\n \t    /* Return to previous level if there are no more edges.  */\n \t    sp--;\n@@ -1723,20 +1723,21 @@ vt_find_locations (void)\n \t  if (!TEST_BIT (visited, bb->index))\n \t    {\n \t      bool changed;\n+\t      edge_iterator ei;\n \n \t      SET_BIT (visited, bb->index);\n \n \t      /* Calculate the IN set as union of predecessor OUT sets.  */\n \t      dataflow_set_clear (&VTI (bb)->in);\n-\t      for (e = bb->pred; e; e = e->pred_next)\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t{\n \t\t  dataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n \t\t}\n \n \t      changed = compute_bb_dataflow (bb);\n \t      if (changed)\n \t\t{\n-\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    {\n \t\t      if (e->dest == EXIT_BLOCK_PTR)\n \t\t\tcontinue;"}]}