{"sha": "5a5086621e8751f9666cf0a3d5956149202e1487", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE1MDg2NjIxZTg3NTFmOTY2NmNmMGEzZDU5NTYxNDkyMDJlMTQ4Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-20T09:18:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-20T09:18:13Z"}, "message": "c-common.def (IF_STMT, [...]): Move to cp-tree.def.\n\n        * c-common.def (IF_STMT, CLEANUP_STMT): Move to cp-tree.def.\n        * c-common.h (IF_COND, THEN_CLAUSE, ELSE_CLAUSE, CLEANUP_BODY,\n        CLEANUP_EXPR, CLEANUP_DECL): Move to cp-tree.h.\n        (c_common_stmt_codes): Remove IF_STMT, CLEANUP_STMT.\n        * c-dump.c (c_dump_tree): Move IF_STMT, CLEANUP_STMT to cp_dump_tree.\n        * c-pretty-print.c (pp_c_statement): Similarly.\n        * c-gimplify.c (gimplify_cleanup_stmt, gimplify_cleanup_stmts,\n        gimplify_if_stmt): Move to cp-gimplify.c.\n        (c_genericize, c_gimplify_expr): Don't call them.\n        * c-semantics.c (push_cleanup): Move to cp/semantics.c.\n        * c-typeck.c (push_cleanup): New.\n        (c_begin_if_stmt, c_finish_if_cond, c_finish_then, c_finish_else,\n        c_finish_if_stmt): Use COND_EXPR.\n        * tree.h (CLEANUP_EH_ONLY): Update documentation.\ncp/\n        * cp-tree.def (CLEANUP_STMT, IF_STMT): Move from c-common.def.\n        * cp-gimplify.c (gimplify_if_stmt): Move from c-gimplify.c.\n        (cp_gimplify_expr): Call it.\n        (gimplify_cleanup_stmt): Move from c-gimplify.c.\n        (cp_genericize): New.\n        * decl.c (finish_function): Call it.\n        * cp-tree.h (cp_stmt_codes): Add CLEANUP_STMT, IF_STMT.\n        (CLEANUP_BODY, CLEANUP_EXPR, CLEANUP_DECL): Move from c-common.h.\n        (IF_COND, THEN_CLAUSE, ELSE_CLAUSE): Likewise.\n        (cp_genericize): Declare.\n        * cxx-pretty-print.c (pp_cxx_statement): Add CLEANUP_STMT, IF_STMT.\n        * dump.c (cp_dump_tree): Likewise.\n        * semantics.c (push_cleanup): Move from c-semantics.c.\n\nFrom-SVN: r83407", "tree": {"sha": "5f34633f30f7aaefd64e454886114b31df3b8155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f34633f30f7aaefd64e454886114b31df3b8155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a5086621e8751f9666cf0a3d5956149202e1487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5086621e8751f9666cf0a3d5956149202e1487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5086621e8751f9666cf0a3d5956149202e1487", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5086621e8751f9666cf0a3d5956149202e1487/comments", "author": null, "committer": null, "parents": [{"sha": "500e12641f0f7fb4fde1221f7f8052ef351de5f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500e12641f0f7fb4fde1221f7f8052ef351de5f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500e12641f0f7fb4fde1221f7f8052ef351de5f7"}], "stats": {"total": 410, "additions": 218, "deletions": 192}, "files": [{"sha": "fd9f0ac0ee1e823b3ad3b0a4e07da8e809cf4828", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -1,3 +1,20 @@\n+2004-06-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.def (IF_STMT, CLEANUP_STMT): Move to cp-tree.def.\n+\t* c-common.h (IF_COND, THEN_CLAUSE, ELSE_CLAUSE, CLEANUP_BODY,\n+\tCLEANUP_EXPR, CLEANUP_DECL): Move to cp-tree.h.\n+\t(c_common_stmt_codes): Remove IF_STMT, CLEANUP_STMT.\n+\t* c-dump.c (c_dump_tree): Move IF_STMT, CLEANUP_STMT to cp_dump_tree.\n+\t* c-pretty-print.c (pp_c_statement): Similarly.\n+\t* c-gimplify.c (gimplify_cleanup_stmt, gimplify_cleanup_stmts,\n+\tgimplify_if_stmt): Move to cp-gimplify.c.\n+\t(c_genericize, c_gimplify_expr): Don't call them.\n+\t* c-semantics.c (push_cleanup): Move to cp/semantics.c.\n+\t* c-typeck.c (push_cleanup): New.\n+\t(c_begin_if_stmt, c_finish_if_cond, c_finish_then, c_finish_else,\n+\tc_finish_if_stmt): Use COND_EXPR.\n+\t* tree.h (CLEANUP_EH_ONLY): Update documentation.\n+\n 2004-06-20  Zack Weinberg  <zack@codesourcery.com>\n \n \t* c-common.h (has_c_linkage): New interface."}, {"sha": "62dd05703cfdfcbc0ea49d6b839ad7d6100990cc", "filename": "gcc/c-common.def", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -37,10 +37,6 @@ DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n    DECL_STMT_DECL.  */\n DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n \n-/* Represents an 'if' statement. The operands are IF_COND,\n-   THEN_CLAUSE, and ELSE_CLAUSE, respectively.  */\n-DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n-\n /* Used to represent a `for' statement. The operands are\n    FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n@@ -78,11 +74,6 @@ DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n    the compound literal.  */\n DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)\n \n-/* A CLEANUP_STMT marks the point at which a declaration is fully\n-   constructed.  The CLEANUP_EXPR is run on behalf of CLEANUP_DECL\n-   when CLEANUP_BODY completes.  */\n-DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 3)\n-\n /*\n Local variables:\n mode:c"}, {"sha": "073ff70e4ec9e303614c6b91f88c45536501db2d", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -922,13 +922,6 @@ extern void finish_file\t(void);\n #define STATEMENT_LIST_STMT_EXPR(NODE) \\\n   TREE_LANG_FLAG_1 (STATEMENT_LIST_CHECK (NODE))\n \n-/* IF_STMT accessors. These give access to the condition of the if\n-   statement, the then block of the if statement, and the else block\n-   of the if statement if it exists.  */\n-#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n-#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n-#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n-\n /* WHILE_STMT accessors. These give access to the condition of the\n    while statement and the body of the while statement, respectively.  */\n #define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n@@ -975,16 +968,6 @@ extern void finish_file\t(void);\n #define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n   DECL_STMT_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n \n-/* The body of the CLEANUP_STMT.  */\n-#define CLEANUP_BODY(NODE) \\\n-  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n-/* The cleanup to run in a CLEANUP_STMT.  */\n-#define CLEANUP_EXPR(NODE) \\\n-  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n-/* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n-#define CLEANUP_DECL(NODE) \\\n-  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 2)\n-\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n \n enum c_tree_code {\n@@ -996,8 +979,7 @@ enum c_tree_code {\n #undef DEFTREECODE\n \n #define c_common_stmt_codes\t\t\t\t\\\n-   CLEANUP_STMT,\tEXPR_STMT,\t\t\t\\\n-   DECL_STMT,\t\tIF_STMT,\tFOR_STMT,\t\\\n+   EXPR_STMT,\t\tDECL_STMT,\tFOR_STMT,\t\\\n    WHILE_STMT,\t\tDO_STMT,\tRETURN_STMT,\t\\\n    BREAK_STMT,\t\tCONTINUE_STMT,\tSWITCH_STMT\n "}, {"sha": "18a8887295f208eee24ae65a6d9ed0feedd3a173", "filename": "gcc/c-dump.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -69,13 +69,6 @@ c_dump_tree (void *dump_info, tree t)\n       dump_next_stmt (di, t);\n       break;\n \n-    case CLEANUP_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"decl\", CLEANUP_DECL (t));\n-      dump_child (\"expr\", CLEANUP_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n     case DECL_STMT:\n       dump_stmt (di, t);\n       dump_child (\"decl\", DECL_STMT_DECL (t));\n@@ -104,14 +97,6 @@ c_dump_tree (void *dump_info, tree t)\n       dump_next_stmt (di, t);\n       break;\n \n-    case IF_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", IF_COND (t));\n-      dump_child (\"then\", THEN_CLAUSE (t));\n-      dump_child (\"else\", ELSE_CLAUSE (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n     case RETURN_STMT:\n       dump_stmt (di, t);\n       dump_child (\"expr\", RETURN_STMT_EXPR (t));"}, {"sha": "fa3ea299cc47c8fd2c4425e4ded115f864c55f7f", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -72,8 +72,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Local declarations.  */\n \n-static void gimplify_cleanup_stmts (tree);\n-\n enum bc_t { bc_break = 0, bc_continue = 1 };\n \n static struct c_gimplify_ctx\n@@ -137,7 +135,6 @@ c_genericize (tree fndecl)\n \n   /* Go ahead and gimplify for now.  */\n   push_context ();\n-  gimplify_cleanup_stmts (fndecl);\n   gimplify_function_tree (fndecl);\n   pop_context ();\n \n@@ -152,30 +149,6 @@ c_genericize (tree fndecl)\n     c_genericize (cgn->decl);\n }\n \n-/* Genericize a CLEANUP_STMT.  This just turns into a TRY_FINALLY or\n-   TRY_CATCH depending on whether it's EH-only.  */\n-\n-static tree\n-gimplify_cleanup_stmt (tree *stmt_p, int *walk_subtrees,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n-{\n-  tree stmt = *stmt_p;\n-\n-  if (DECL_P (stmt) || TYPE_P (stmt))\n-    *walk_subtrees = 0;\n-  else if (TREE_CODE (stmt) == CLEANUP_STMT)\n-    *stmt_p = build (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR,\n-\t\t     void_type_node, CLEANUP_BODY (stmt), CLEANUP_EXPR (stmt));\n-\n-  return NULL;\n-}\n-\n-static void\n-gimplify_cleanup_stmts (tree fndecl)\n-{\n-  walk_tree (&DECL_SAVED_TREE (fndecl), gimplify_cleanup_stmt, NULL, NULL);\n-}\n-\n static void\n add_block_to_enclosing (tree block)\n {\n@@ -479,28 +452,6 @@ gimplify_do_stmt (tree *stmt_p)\n   return GS_ALL_DONE;\n }\n \n-/* Genericize an IF_STMT by turning it into a COND_EXPR.  */\n-\n-static enum gimplify_status\n-gimplify_if_stmt (tree *stmt_p)\n-{\n-  tree stmt, then_, else_;\n-\n-  stmt = *stmt_p;\n-  then_ = THEN_CLAUSE (stmt);\n-  else_ = ELSE_CLAUSE (stmt);\n-\n-  if (!then_)\n-    then_ = build_empty_stmt ();\n-  if (!else_)\n-    else_ = build_empty_stmt ();\n-\n-  stmt = build (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n-  *stmt_p = stmt;\n-\n-  return GS_OK;\n-}\n-\n /* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n \n static enum gimplify_status\n@@ -670,9 +621,6 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n     case DO_STMT:\n       return gimplify_do_stmt (expr_p);\n \n-    case IF_STMT:\n-      return gimplify_if_stmt (expr_p);\n-\n     case SWITCH_STMT:\n       return gimplify_switch_stmt (expr_p);\n "}, {"sha": "7ecbe6b08dad46da07c0fb70f740e743fb1ac457", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 6, "deletions": 70, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -1889,75 +1889,22 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n \n   if (stmt == NULL)\n     return;\n+\n+  if (pp_needs_newline (pp))\n+    pp_newline_and_indent (pp, 0);\n   \n   code = TREE_CODE (stmt);\n   switch (code)\n     {\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator tsi;\n-\n-        if (pp_needs_newline (pp))\n-          pp_newline_and_indent (pp, 0);\n-        pp_c_left_brace (pp);\n-        pp_newline_and_indent (pp, 3);\n-\tfor (tsi = tsi_start (stmt); !tsi_end_p (tsi); tsi_next (&tsi))\n-          pp_statement (pp, tsi_stmt (tsi));\n-        pp_newline_and_indent (pp, -3);\n-        pp_c_right_brace (pp);\n-        pp_needs_newline (pp) = true;\n-      }\n-      break;\n-\n       /* expression-statement:\n             expression(opt) ;  */\n     case EXPR_STMT:\n-    case CLEANUP_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n-      {\n-        tree e = code == EXPR_STMT\n-          ? EXPR_STMT_EXPR (stmt)\n-          : CLEANUP_EXPR (stmt);\n-        if (e)\n-          pp_expression (pp, e);\n-      }\n+      pp_expression (pp, EXPR_STMT_EXPR (stmt));\n       pp_c_semicolon (pp);\n       pp_needs_newline (pp) = true;\n       break;\n \n-      /* selection-statement:\n-            if ( expression ) statement\n-            if ( expression ) statement else statement\n-            switch ( expression ) statement   */\n-    case IF_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n-      pp_c_identifier (pp, \"if\");\n-      pp_c_whitespace (pp);\n-      pp_c_left_paren (pp);\n-      pp_expression (pp, IF_COND (stmt));\n-      pp_c_right_paren (pp);\n-      pp_newline_and_indent (pp, 3);\n-      pp_statement (pp, THEN_CLAUSE (stmt));\n-      pp_newline_and_indent (pp, -3);\n-      if (ELSE_CLAUSE (stmt))\n-\t{\n-\t  tree else_clause = ELSE_CLAUSE (stmt);\n-\t  pp_c_identifier (pp, \"else\");\n-\t  if (TREE_CODE (else_clause) == IF_STMT)\n-\t    pp_c_whitespace (pp);\n-\t  else\n-\t    pp_newline_and_indent (pp, 3);\n-\t  pp_statement (pp, else_clause);\n-\t  if (TREE_CODE (else_clause) != IF_STMT)\n-\t    pp_newline_and_indent (pp, -3);\n-\t}\n-      break;\n-\n     case SWITCH_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_c_identifier (pp, \"switch\");\n       pp_space (pp);\n       pp_c_left_paren (pp);\n@@ -1975,8 +1922,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n             for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n             for ( declaration expression(opt) ; expression(opt) ) statement  */\n     case WHILE_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_c_identifier (pp, \"while\");\n       pp_space (pp);\n       pp_c_left_paren (pp);\n@@ -1989,8 +1934,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       break;\n \n     case DO_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_c_identifier (pp, \"do\");\n       pp_newline_and_indent (pp, 3);\n       pp_statement (pp, DO_BODY (stmt));\n@@ -2005,8 +1948,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       break;\n \n     case FOR_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_c_identifier (pp, \"for\");\n       pp_space (pp);\n       pp_c_left_paren (pp);\n@@ -2036,8 +1977,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n             return expression(opt) ;  */\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_identifier (pp, code == BREAK_STMT ? \"break\" : \"continue\");\n       pp_c_semicolon (pp);\n       pp_needs_newline (pp) = true;\n@@ -2046,8 +1985,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n     case RETURN_STMT:\n       {\n \ttree e = RETURN_STMT_EXPR (stmt);\n-        if (pp_needs_newline (pp))\n-          pp_newline_and_indent (pp, 0);\n \tpp_c_identifier (pp, \"return\");\n         pp_c_whitespace (pp);\n \tif (e)\n@@ -2063,14 +2000,13 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       break;\n \n     case DECL_STMT:\n-      if (pp_needs_newline (pp))\n-        pp_newline_and_indent (pp, 0);\n       pp_declaration (pp, DECL_STMT_DECL (stmt));\n       pp_needs_newline (pp) = true;\n       break;\n \n     default:\n-      pp_unsupported_tree (pp, stmt);\n+      dump_generic_node (pp_base (pp), stmt, pp_indentation (pp), 0, true);\n+      break;\n     }\n }\n "}, {"sha": "ba4e90b491169292bd4aa4831bc115372650cf79", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -158,19 +158,6 @@ add_decl_stmt (tree decl)\n   add_stmt (decl_stmt);\n }\n \n-/* Queue a cleanup.  CLEANUP is an expression/statement to be executed\n-   when the current scope is exited.  EH_ONLY is true when this is not\n-   meant to apply to normal control flow transfer.  */\n-\n-void\n-push_cleanup (tree decl, tree cleanup, bool eh_only)\n-{\n-  tree stmt = build_stmt (CLEANUP_STMT, NULL, cleanup, decl);\n-  CLEANUP_EH_ONLY (stmt) = eh_only;\n-  add_stmt (stmt);\n-  CLEANUP_BODY (stmt) = push_stmt_list ();\n-}\n-\n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n    EXPR_LOCUS to be the current source location.  */"}, {"sha": "201c5f1c1142ebfa429491e75046946e49ea144d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -6483,8 +6483,7 @@ static int if_stack_space = 0;\n /* Stack pointer.  */\n static int if_stack_pointer = 0;\n \n-/* Begin an if-statement.  Returns a newly created IF_STMT if\n-   appropriate.  */\n+/* Begin an if-statement.  */\n \n void\n c_begin_if_stmt (void)\n@@ -6504,7 +6503,7 @@ c_begin_if_stmt (void)\n       if_stack = xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n     }\n \n-  r = add_stmt (build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE));\n+  r = add_stmt (build_stmt (COND_EXPR, NULL_TREE, NULL_TREE, NULL_TREE));\n \n   /* Record this if statement.  */\n   elt = &if_stack[if_stack_pointer++];\n@@ -6527,7 +6526,7 @@ c_finish_if_cond (tree cond, int compstmt_count, int stmt_count)\n   if_elt *elt = &if_stack[if_stack_pointer - 1];\n   elt->compstmt_count = compstmt_count;\n   elt->stmt_count = stmt_count;\n-  IF_COND (elt->if_stmt) = lang_hooks.truthvalue_conversion (cond);\n+  COND_EXPR_COND (elt->if_stmt) = lang_hooks.truthvalue_conversion (cond);\n }\n \n /* Called after the then-clause for an if-statement is processed.  */\n@@ -6536,7 +6535,7 @@ void\n c_finish_then (tree then_stmt)\n {\n   if_elt *elt = &if_stack[if_stack_pointer - 1];\n-  THEN_CLAUSE (elt->if_stmt) = then_stmt;\n+  COND_EXPR_THEN (elt->if_stmt) = then_stmt;\n   elt->empty_locus = input_location;\n }\n \n@@ -6570,7 +6569,7 @@ void\n c_finish_else (tree else_stmt)\n {\n   if_elt *elt = &if_stack[if_stack_pointer - 1];\n-  ELSE_CLAUSE (elt->if_stmt) = else_stmt;\n+  COND_EXPR_ELSE (elt->if_stmt) = else_stmt;\n   elt->empty_locus = input_location;\n }\n \n@@ -6582,6 +6581,9 @@ c_finish_if_stmt (int stmt_count)\n {\n   if_elt *elt = &if_stack[--if_stack_pointer];\n \n+  if (COND_EXPR_ELSE (elt->if_stmt) == NULL)\n+    COND_EXPR_ELSE (elt->if_stmt) = build_empty_stmt ();\n+\n   if (elt->needs_warning)\n     warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n \t     EXPR_LOCUS (elt->if_stmt));\n@@ -6781,6 +6783,19 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n \n   return stmt;\n }\n+\n+/* Queue a cleanup.  CLEANUP is an expression/statement to be executed\n+   when the current scope is exited.  EH_ONLY is true when this is not\n+   meant to apply to normal control flow transfer.  */\n+\n+void\n+push_cleanup (tree decl ATTRIBUTE_UNUSED, tree cleanup, bool eh_only)\n+{\n+  enum tree_code code = eh_only ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR;\n+  tree stmt = build_stmt (code, NULL, cleanup);\n+  add_stmt (stmt);\n+  TREE_OPERAND (stmt, 0) = push_stmt_list ();\n+}\n \f\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build."}, {"sha": "b01e1f8b49def8bfa893bd17f901127eadb1e656", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -1,3 +1,19 @@\n+2004-06-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-tree.def (CLEANUP_STMT, IF_STMT): Move from c-common.def.\n+\t* cp-gimplify.c (gimplify_if_stmt): Move from c-gimplify.c.\n+\t(cp_gimplify_expr): Call it.\n+\t(gimplify_cleanup_stmt): Move from c-gimplify.c.\n+\t(cp_genericize): New.\n+\t* decl.c (finish_function): Call it.\n+\t* cp-tree.h (cp_stmt_codes): Add CLEANUP_STMT, IF_STMT.\n+\t(CLEANUP_BODY, CLEANUP_EXPR, CLEANUP_DECL): Move from c-common.h.\n+\t(IF_COND, THEN_CLAUSE, ELSE_CLAUSE): Likewise.\n+\t(cp_genericize): Declare.\n+\t* cxx-pretty-print.c (pp_cxx_statement): Add CLEANUP_STMT, IF_STMT.\n+\t* dump.c (cp_dump_tree): Likewise.\n+\t* semantics.c (push_cleanup): Move from c-semantics.c.\n+\n 2004-06-20  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cp-lang.c (has_c_linkage): Implement."}, {"sha": "8bdf5f4fcc5993013ab1ccb50248d2d47f6d262b", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -79,6 +79,26 @@ genericize_eh_spec_block (tree *stmt_p)\n   *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n }\n \n+/* Genericize an IF_STMT by turning it into a COND_EXPR.  */\n+\n+static void\n+gimplify_if_stmt (tree *stmt_p)\n+{\n+  tree stmt, then_, else_;\n+\n+  stmt = *stmt_p;\n+  then_ = THEN_CLAUSE (stmt);\n+  else_ = ELSE_CLAUSE (stmt);\n+\n+  if (!then_)\n+    then_ = build_empty_stmt ();\n+  if (!else_)\n+    else_ = build_empty_stmt ();\n+\n+  stmt = build (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n+  *stmt_p = stmt;\n+}\n+\n /* Gimplify initialization from an AGGR_INIT_EXPR.  */\n \n static void\n@@ -224,6 +244,11 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       ret = GS_ALL_DONE;\n       break;\n \n+    case IF_STMT:\n+      gimplify_if_stmt (expr_p);\n+      ret = GS_OK;\n+      break;\n+\n     default:\n       ret = c_gimplify_expr (expr_p, pre_p, post_p);\n       break;\n@@ -236,3 +261,33 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n   return ret;\n }\n+\n+/* Genericize a CLEANUP_STMT.  This just turns into a TRY_FINALLY or\n+   TRY_CATCH depending on whether it's EH-only.  */\n+\n+static tree\n+gimplify_cleanup_stmt (tree *stmt_p, int *walk_subtrees,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n+{\n+  tree stmt = *stmt_p;\n+\n+  if (DECL_P (stmt) || TYPE_P (stmt))\n+    *walk_subtrees = 0;\n+  else if (TREE_CODE (stmt) == CLEANUP_STMT)\n+    *stmt_p = build (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR,\n+\t\t     void_type_node, CLEANUP_BODY (stmt), CLEANUP_EXPR (stmt));\n+\n+  return NULL;\n+}\n+\n+void\n+cp_genericize (tree fndecl)\n+{\n+  /* Due to the way voidify_wrapper_expr is written, we don't get a chance\n+     to lower this construct before scanning it.  So we need to lower these\n+     before doing anything else.  */\n+  walk_tree (&DECL_SAVED_TREE (fndecl), gimplify_cleanup_stmt, NULL, NULL);\n+\n+  /* Do everything else.  */\n+  c_genericize (fndecl);\n+}"}, {"sha": "4f7961b7b8aeca556c81cd603de367132436d2b9", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -243,8 +243,11 @@ DEFTREECODE (NON_DEPENDENT_EXPR, \"non_dependent_expr\", 'e', 1)\n /* CTOR_INITIALIZER is a placeholder in template code for a call to\n    setup_vtbl_pointer (and appears in all functions, not just ctors).  */\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 1)\n+\n DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n+\n DEFTREECODE (EH_SPEC_BLOCK, \"eh_spec_block\", 'e', 2)\n+\n /* A HANDLER wraps a catch handler for the HANDLER_TYPE.  If this is\n    CATCH_ALL_TYPE, then the handler catches all types.  The declaration of\n    the catch variable is in HANDLER_PARMS, and the body block in\n@@ -255,6 +258,17 @@ DEFTREECODE (HANDLER, \"handler\", 'e', 2)\n    throw, and must call terminate if it does.  */\n DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n \n+/* A CLEANUP_STMT marks the point at which a declaration is fully\n+   constructed.  The CLEANUP_EXPR is run on behalf of CLEANUP_DECL\n+   when CLEANUP_BODY completes.  */\n+DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 3)\n+\n+/* Represents an 'if' statement. The operands are IF_COND,\n+   THEN_CLAUSE, and ELSE_CLAUSE, respectively.  */\n+/* ??? It is currently still necessary to distinguish between IF_STMT \n+   and COND_EXPR for the benefit of templates.  */\n+DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n+\n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n /* Template instantiation level node."}, {"sha": "ae62adc70dd3c538f7d0409d629ed23f6a323165", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -892,7 +892,8 @@ enum cplus_tree_code {\n \n #define cp_stmt_codes\t\t\t\t\t\\\n    CTOR_INITIALIZER,\tTRY_BLOCK,\tHANDLER,\t\\\n-   EH_SPEC_BLOCK,\tUSING_STMT,\tTAG_DEFN\n+   EH_SPEC_BLOCK,\tUSING_STMT,\tTAG_DEFN,\t\\\n+   IF_STMT,\t\tCLEANUP_STMT\n \n enum languages { lang_c, lang_cplusplus, lang_java };\n \n@@ -2939,6 +2940,19 @@ struct lang_decl GTY(())\n #define HANDLER_BODY(NODE)      TREE_OPERAND (HANDLER_CHECK (NODE), 1)\n #define HANDLER_TYPE(NODE)\tTREE_TYPE (HANDLER_CHECK (NODE))\n \n+/* CLEANUP_STMT accessors.  The statement(s) covered, the cleanup to run\n+   and the VAR_DECL for which this cleanup exists.  */\n+#define CLEANUP_BODY(NODE)\tTREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n+#define CLEANUP_EXPR(NODE)\tTREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n+#define CLEANUP_DECL(NODE)\tTREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 2)\n+\n+/* IF_STMT accessors. These give access to the condition of the if\n+   statement, the then block of the if statement, and the else block\n+   of the if statement if it exists.  */\n+#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n+#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n+#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+\n /* The parameters for a call-declarator.  */\n #define CALL_DECLARATOR_PARMS(NODE) \\\n   (TREE_PURPOSE (TREE_OPERAND (NODE, 1)))\n@@ -4304,6 +4318,7 @@ extern bool cp_dump_tree                         (void *, tree);\n \n /* in cp-simplify.c */\n extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n+extern void cp_genericize\t\t\t(tree);\n \n /* -- end of C++ */\n "}, {"sha": "cd08611763401da0371df5933b9a93a22fab7e3b", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -1517,6 +1517,43 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_needs_newline (pp) = true;\n       break;\n \n+      /* selection-statement:\n+            if ( expression ) statement\n+            if ( expression ) statement else statement  */\n+    case IF_STMT:\n+      pp_cxx_identifier (pp, \"if\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_expression (pp, IF_COND (t));\n+      pp_cxx_right_paren (pp);\n+      pp_newline_and_indent (pp, 2);\n+      pp_cxx_statement (pp, THEN_CLAUSE (t));\n+      pp_newline_and_indent (pp, -2);\n+      if (ELSE_CLAUSE (t))\n+\t{\n+\t  tree else_clause = ELSE_CLAUSE (t);\n+\t  pp_cxx_identifier (pp, \"else\");\n+\t  if (TREE_CODE (else_clause) == IF_STMT)\n+\t    pp_cxx_whitespace (pp);\n+\t  else\n+\t    pp_newline_and_indent (pp, 2);\n+\t  pp_cxx_statement (pp, else_clause);\n+\t  if (TREE_CODE (else_clause) != IF_STMT)\n+\t    pp_newline_and_indent (pp, -2);\n+\t}\n+      break;\n+\n+    case CLEANUP_STMT:\n+      pp_cxx_identifier (pp, \"try\");\n+      pp_newline_and_indent (pp, 2);\n+      pp_cxx_statement (pp, CLEANUP_BODY (t));\n+      pp_newline_and_indent (pp, -2);\n+      pp_cxx_identifier (pp, CLEANUP_EH_ONLY (t) ? \"catch\" : \"finally\");\n+      pp_newline_and_indent (pp, 2);\n+      pp_cxx_statement (pp, CLEANUP_EXPR (t));\n+      pp_newline_and_indent (pp, -2);\n+      break;\n+\n     default:\n       pp_c_statement (pp_c_base (pp), t);\n       break;"}, {"sha": "84f3b8459af5c7e85ab4e6e2c28b3f53d6ec9a0c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -10812,7 +10812,7 @@ finish_function (int flags)\n   /* Genericize before inlining.  */\n   if (!processing_template_decl)\n     {\n-      c_genericize (fndecl);\n+      cp_genericize (fndecl);\n \n       /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n       c_warn_unused_result (&DECL_SAVED_TREE (fndecl));"}, {"sha": "fd0a847a409eeac1c59a7d7d85f6b6083fd95718", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -411,7 +411,23 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"nmsp\", USING_STMT_NAMESPACE (t));\n       dump_next_stmt (di, t);\n       break;\n-      \n+\n+    case CLEANUP_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"decl\", CLEANUP_DECL (t));\n+      dump_child (\"expr\", CLEANUP_EXPR (t));\n+      dump_child (\"body\", CLEANUP_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case IF_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", IF_COND (t));\n+      dump_child (\"then\", THEN_CLAUSE (t));\n+      dump_child (\"else\", ELSE_CLAUSE (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "e53222f48b2b4723a213b264c9daac53e9a4fb69", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -346,6 +346,19 @@ do_pushlevel (scope_kind sk)\n   return ret;\n }\n \n+/* Queue a cleanup.  CLEANUP is an expression/statement to be executed\n+   when the current scope is exited.  EH_ONLY is true when this is not\n+   meant to apply to normal control flow transfer.  */\n+\n+void\n+push_cleanup (tree decl, tree cleanup, bool eh_only)\n+{\n+  tree stmt = build_stmt (CLEANUP_STMT, NULL, cleanup, decl);\n+  CLEANUP_EH_ONLY (stmt) = eh_only;\n+  add_stmt (stmt);\n+  CLEANUP_BODY (stmt) = push_stmt_list ();\n+}\n+\n /* Begin a conditional that might contain a declaration.  When generating\n    normal code, we want the declaration to appear before the statement\n    containing the conditional.  When generating template code, we want the"}, {"sha": "6babb197c59ccaf8e2d2994a4fdc99070c18a8d8", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5086621e8751f9666cf0a3d5956149202e1487/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5a5086621e8751f9666cf0a3d5956149202e1487", "patch": "@@ -209,8 +209,7 @@ struct tree_common GTY(())\n        TREE_SYMBOL_REFERENCED in\n            IDENTIFIER_NODE\n        CLEANUP_EH_ONLY in\n-           TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT,\n-\t   TREE_LIST elements of a block's cleanup list.\n+           TARGET_EXPR, WITH_CLEANUP_EXPR\n        ASM_INPUT_P in\n            ASM_EXPR\n        EH_FILTER_MUST_NOT_THROW in EH_FILTER_EXPR\n@@ -690,9 +689,9 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    should be cleaned up some day.  */\n #define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n \n-/* In a TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT, or element of a\n-   block's cleanup list, means that the pertinent cleanup should only be\n-   executed if an exception is thrown, not on normal exit of its scope.  */\n+/* In a TARGET_EXPR, WITH_CLEANUP_EXPR, means that the pertinent cleanup\n+   should only be executed if an exception is thrown, not on normal exit\n+   of its scope.  */\n #define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n \n /* In an expr node (usually a conversion) this means the node was made"}]}