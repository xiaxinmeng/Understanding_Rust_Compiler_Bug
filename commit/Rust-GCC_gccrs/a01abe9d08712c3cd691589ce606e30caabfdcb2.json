{"sha": "a01abe9d08712c3cd691589ce606e30caabfdcb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxYWJlOWQwODcxMmMzY2Q2OTE1ODljZTYwNmUzMGNhYWJmZGNiMg==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-10-12T13:50:15Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-10-12T13:50:15Z"}, "message": "md.texi (doloop_end): Document that the pattern code may need to check operand mode.\n\n\t* doc/md.texi (doloop_end): Document that the pattern code may\n\tneed to check operand mode.\n\nFrom-SVN: r265102", "tree": {"sha": "b88eb616f2ee4c38900867c58ae85093d4000121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b88eb616f2ee4c38900867c58ae85093d4000121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a01abe9d08712c3cd691589ce606e30caabfdcb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01abe9d08712c3cd691589ce606e30caabfdcb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01abe9d08712c3cd691589ce606e30caabfdcb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01abe9d08712c3cd691589ce606e30caabfdcb2/comments", "author": null, "committer": null, "parents": [{"sha": "e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444"}], "stats": {"total": 42, "additions": 38, "deletions": 4}, "files": [{"sha": "239336756187dafa957b03fb92f78aa192269171", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01abe9d08712c3cd691589ce606e30caabfdcb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01abe9d08712c3cd691589ce606e30caabfdcb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a01abe9d08712c3cd691589ce606e30caabfdcb2", "patch": "@@ -1,3 +1,8 @@\n+2018-10-12  Paul Koning  <ni1d@arrl.net>\n+\n+\t* doc/md.texi (doloop_end): Document that the pattern code may\n+\tneed to check operand mode.\n+\n 2018-10-12  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.md (zero_extendsidi2_aarch64): Add alternatives"}, {"sha": "360b36b862f7eb13964e60ff53b04e1274f89fe4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01abe9d08712c3cd691589ce606e30caabfdcb2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01abe9d08712c3cd691589ce606e30caabfdcb2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=a01abe9d08712c3cd691589ce606e30caabfdcb2", "patch": "@@ -7619,7 +7619,23 @@ simplified) from the PDP-11 target:\n \n @smallexample\n @group\n-(define_insn \"doloop_end\"\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc)\n+                   (if_then_else\n+                    (ne (match_operand:HI 0 \"nonimmediate_operand\" \"+r,!m\")\n+                        (const_int 1))\n+                    (label_ref (match_operand 1 \"\" \"\"))\n+                    (pc)))\n+              (set (match_dup 0)\n+                   (plus:HI (match_dup 0)\n+                         (const_int -1)))])]\n+  \"\"\n+  \"@{\n+    if (GET_MODE (operands[0]) != HImode)\n+      FAIL;\n+  @}\")\n+\n+(define_insn \"doloop_end_insn\"\n   [(set (pc)\n         (if_then_else\n          (ne (match_operand:HI 0 \"nonimmediate_operand\" \"+r,!m\")\n@@ -7662,9 +7678,22 @@ will be non-negative.\n Since the @code{doloop_end} insn is a jump insn that also has an output,\n the reload pass does not handle the output operand.  Therefore, the\n constraint must allow for that operand to be in memory rather than a\n-register.  In the example shown above, that is handled by using a loop\n-instruction sequence that can handle memory operands when the memory\n-alternative appears.\n+register.  In the example shown above, that is handled (in the\n+@code{doloop_end_insn} pattern) by using a loop instruction sequence\n+that can handle memory operands when the memory alternative appears.\n+\n+GCC does not check the mode of the loop register operand when generating\n+the @code{doloop_end} pattern.  If the pattern is only valid for some\n+modes but not others, the pattern should be a @code{define_expand}\n+pattern that checks the operand mode in the preparation code, and issues\n+@code{FAIL} if an unsupported mode is found.  The example above does\n+this, since the machine instruction to be used only exists for\n+@code{HImode}.\n+\n+If the @code{doloop_end} pattern is a @code{define_expand}, there must\n+also be a @code{define_insn} or @code{define_insn_and_split} matching\n+the generated pattern.  Otherwise, the compiler will fail during loop\n+optimization.\n \n @end ifset\n @ifset INTERNALS"}]}