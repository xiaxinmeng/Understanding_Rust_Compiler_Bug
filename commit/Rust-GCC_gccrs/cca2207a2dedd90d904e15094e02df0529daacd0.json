{"sha": "cca2207a2dedd90d904e15094e02df0529daacd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NhMjIwN2EyZGVkZDkwZDkwNGUxNTA5NGUwMmRmMDUyOWRhYWNkMA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-08-08T13:26:06Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-08-08T13:26:06Z"}, "message": "Fix Dwarf unwind library for UNITS_PER_WORD > sizeof (void *)\n\ngcc/\n\n2011-08-08  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR other/48007\n\t* config.gcc (libgcc_tm_file): Add i386/value-unwind.h for\n\tLinux/x86.\n\n\t* system.h (REG_VALUE_IN_UNWIND_CONTEXT): Poisoned.\n\t(ASSUME_EXTENDED_UNWIND_CONTEXT): Likewise.\n\n\t* unwind-dw2.c (ASSUME_EXTENDED_UNWIND_CONTEXT): New.\n\t(_Unwind_Context_Reg_Val): Likewise.\n\t(_Unwind_Get_Unwind_Word): Likewise.\n\t(_Unwind_Get_Unwind_Context_Reg_Val): Likewise.\n\t(_Unwind_Context): Use _Unwind_Context_Reg_Val on the reg field.\n\t(_Unwind_IsExtendedContext): Check ASSUME_EXTENDED_UNWIND_CONTEXT\n\tfor EXTENDED_CONTEXT_BIT.\n\t(__frame_state_for): Likewise.\n\t(uw_init_context_1): Likewise.\n\t(_Unwind_GetGR): Updated.\n\t(_Unwind_SetGR): Likewise.\n\t(_Unwind_GetGRPtr): Likewise.\n\t(_Unwind_SetGRPtr): Likewise.\n\t(_Unwind_SetGRValue): Likewise.\n\t(_Unwind_GRByValue): Likewise.\n\t(uw_install_context_1): Likewise.\n\n\t* doc/tm.texi.in: Document REG_VALUE_IN_UNWIND_CONTEXT and\n\tASSUME_EXTENDED_UNWIND_CONTEXT.\n\t* doc/tm.texi: Regenerated.\n\nlibgcc/\n\n2011-08-08  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR other/48007\n\t* config/i386/value-unwind.h: New.\n\nFrom-SVN: r177563", "tree": {"sha": "bede109f33fbea8f1ab9d058c05444a8addae8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bede109f33fbea8f1ab9d058c05444a8addae8ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cca2207a2dedd90d904e15094e02df0529daacd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca2207a2dedd90d904e15094e02df0529daacd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca2207a2dedd90d904e15094e02df0529daacd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca2207a2dedd90d904e15094e02df0529daacd0/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6ee5bef6e5105339c907c68e1885971a8c0c500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ee5bef6e5105339c907c68e1885971a8c0c500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ee5bef6e5105339c907c68e1885971a8c0c500"}], "stats": {"total": 176, "additions": 158, "deletions": 18}, "files": [{"sha": "d1371d2b25d95be27003299d9ec255515d825432", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -1,3 +1,33 @@\n+2011-08-08  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR other/48007\n+\t* config.gcc (libgcc_tm_file): Add i386/value-unwind.h for\n+\tLinux/x86.\n+\n+\t* system.h (REG_VALUE_IN_UNWIND_CONTEXT): Poisoned.\n+\t(ASSUME_EXTENDED_UNWIND_CONTEXT): Likewise.\n+\n+\t* unwind-dw2.c (ASSUME_EXTENDED_UNWIND_CONTEXT): New.\n+\t(_Unwind_Context_Reg_Val): Likewise.\n+\t(_Unwind_Get_Unwind_Word): Likewise.\n+\t(_Unwind_Get_Unwind_Context_Reg_Val): Likewise.\n+\t(_Unwind_Context): Use _Unwind_Context_Reg_Val on the reg field.\n+\t(_Unwind_IsExtendedContext): Check ASSUME_EXTENDED_UNWIND_CONTEXT\n+\tfor EXTENDED_CONTEXT_BIT.\n+\t(__frame_state_for): Likewise.\n+\t(uw_init_context_1): Likewise.\n+\t(_Unwind_GetGR): Updated.\n+\t(_Unwind_SetGR): Likewise.\n+\t(_Unwind_GetGRPtr): Likewise.\n+\t(_Unwind_SetGRPtr): Likewise.\n+\t(_Unwind_SetGRValue): Likewise.\n+\t(_Unwind_GRByValue): Likewise.\n+\t(uw_install_context_1): Likewise.\n+\n+\t* doc/tm.texi.in: Document REG_VALUE_IN_UNWIND_CONTEXT and\n+\tASSUME_EXTENDED_UNWIND_CONTEXT.\n+\t* doc/tm.texi: Regenerated.\n+\n 2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Makefile.in (gengtype$(exeext)): Add $(LDFLAGS)."}, {"sha": "ec13d93b3d5b8e84843264e24cfd8dce4dc91045", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -2663,6 +2663,7 @@ esac\n case ${target} in\n i[34567]86-*-linux* | x86_64-*-linux*)\n \ttmake_file=\"${tmake_file} i386/t-pmm_malloc i386/t-i386\"\n+\tlibgcc_tm_file=\"${libgcc_tm_file} i386/value-unwind.h\"\n \t;;\n i[34567]86-*-* | x86_64-*-*)\n \ttmake_file=\"${tmake_file} i386/t-gmm_malloc i386/t-i386\""}, {"sha": "74a232412d12df3453b2739f9fead9dbc8ac6da1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -3725,6 +3725,24 @@ return @code{@var{regno}}.\n \n @end defmac\n \n+@defmac REG_VALUE_IN_UNWIND_CONTEXT\n+\n+Define this macro if the target stores register values as\n+@code{_Unwind_Word} type in unwind context.  It should be defined if\n+target register size is larger than the size of @code{void *}.  The\n+default is to store register values as @code{void *} type.\n+\n+@end defmac\n+\n+@defmac ASSUME_EXTENDED_UNWIND_CONTEXT\n+\n+Define this macro to be 1 if the target always uses extended unwind\n+context with version, args_size and by_value fields.  If it is undefined,\n+it will be defined to 1 when @code{REG_VALUE_IN_UNWIND_CONTEXT} is\n+defined and 0 otherwise.\n+\n+@end defmac\n+\n @node Elimination\n @subsection Eliminating Frame Pointer and Arg Pointer\n "}, {"sha": "f63fe4a0c2b16946ee9b4bdc9b5463af9918af0b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -3711,6 +3711,24 @@ return @code{@var{regno}}.\n \n @end defmac\n \n+@defmac REG_VALUE_IN_UNWIND_CONTEXT\n+\n+Define this macro if the target stores register values as\n+@code{_Unwind_Word} type in unwind context.  It should be defined if\n+target register size is larger than the size of @code{void *}.  The\n+default is to store register values as @code{void *} type.\n+\n+@end defmac\n+\n+@defmac ASSUME_EXTENDED_UNWIND_CONTEXT\n+\n+Define this macro to be 1 if the target always uses extended unwind\n+context with version, args_size and by_value fields.  If it is undefined,\n+it will be defined to 1 when @code{REG_VALUE_IN_UNWIND_CONTEXT} is\n+defined and 0 otherwise.\n+\n+@end defmac\n+\n @node Elimination\n @subsection Eliminating Frame Pointer and Arg Pointer\n "}, {"sha": "9698c613f3506216b4f47c0808b7af5939a17cea", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -802,7 +802,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */\n  #pragma GCC poison DECLARE_LIBRARY_RENAMES LIBGCC2_GNU_PREFIX\t\t\\\n-\tMD_UNWIND_SUPPORT MD_FROB_UPDATE_CONTEXT ENABLE_EXECUTE_STACK\n+\tMD_UNWIND_SUPPORT MD_FROB_UPDATE_CONTEXT ENABLE_EXECUTE_STACK\t\\\n+\tREG_VALUE_IN_UNWIND_CONTEXT ASSUME_EXTENDED_UNWIND_CONTEXT\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "9148c9badc20e20560ce534ae362a5f5ff3a5e2e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -1,3 +1,8 @@\n+2011-08-08  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR other/48007\n+\t* config/i386/value-unwind.h: New.\n+\n 2011-08-06  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config.host (*-*-darwin*, *-*-freebsd*, *-*-linux*, frv-*-*linux*)"}, {"sha": "0dceb5c85c6f3a6e5a1276f4d58bc50436a69cf4", "filename": "libgcc/config/i386/value-unwind.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2Fconfig%2Fi386%2Fvalue-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2Fconfig%2Fi386%2Fvalue-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fvalue-unwind.h?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -0,0 +1,26 @@\n+/* Store register values as _Unwind_Word type in DWARF2 EH unwind context.\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Define this macro if the target stores register values as _Unwind_Word\n+   type in unwind context.  Only enable it for x32.  */\n+#if defined __x86_64 && !defined __LP64__\n+# define REG_VALUE_IN_UNWIND_CONTEXT\n+#endif"}, {"sha": "92aa233eb26538fbd86b7634469ac93d268217c6", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca2207a2dedd90d904e15094e02df0529daacd0/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=cca2207a2dedd90d904e15094e02df0529daacd0", "patch": "@@ -59,12 +59,50 @@\n #define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n #endif\n \n+#ifdef REG_VALUE_IN_UNWIND_CONTEXT\n+typedef _Unwind_Word _Unwind_Context_Reg_Val;\n+\n+#ifndef ASSUME_EXTENDED_UNWIND_CONTEXT\n+#define ASSUME_EXTENDED_UNWIND_CONTEXT 1\n+#endif\n+\n+static inline _Unwind_Word\n+_Unwind_Get_Unwind_Word (_Unwind_Context_Reg_Val val)\n+{\n+  return val;\n+}\n+\n+static inline _Unwind_Context_Reg_Val\n+_Unwind_Get_Unwind_Context_Reg_Val (_Unwind_Word val)\n+{\n+  return val;\n+}\n+#else\n+typedef void *_Unwind_Context_Reg_Val;\n+\n+static inline _Unwind_Word\n+_Unwind_Get_Unwind_Word (_Unwind_Context_Reg_Val val)\n+{\n+  return (_Unwind_Word) (_Unwind_Internal_Ptr) val;\n+}\n+\n+static inline _Unwind_Context_Reg_Val\n+_Unwind_Get_Unwind_Context_Reg_Val (_Unwind_Word val)\n+{\n+  return (_Unwind_Context_Reg_Val) (_Unwind_Internal_Ptr) val;\n+}\n+#endif\n+\n+#ifndef ASSUME_EXTENDED_UNWIND_CONTEXT\n+#define ASSUME_EXTENDED_UNWIND_CONTEXT 0\n+#endif\n+\n /* This is the register and unwind state for a particular frame.  This\n    provides the information necessary to unwind up past a frame and return\n    to its caller.  */\n struct _Unwind_Context\n {\n-  void *reg[DWARF_FRAME_REGISTERS+1];\n+  _Unwind_Context_Reg_Val reg[DWARF_FRAME_REGISTERS+1];\n   void *cfa;\n   void *ra;\n   void *lsda;\n@@ -147,7 +185,8 @@ _Unwind_SetSignalFrame (struct _Unwind_Context *context, int val)\n static inline _Unwind_Word\n _Unwind_IsExtendedContext (struct _Unwind_Context *context)\n {\n-  return context->flags & EXTENDED_CONTEXT_BIT;\n+  return (ASSUME_EXTENDED_UNWIND_CONTEXT\n+\t  || (context->flags & EXTENDED_CONTEXT_BIT));\n }\n \f\n /* Get the value of register INDEX as saved in CONTEXT.  */\n@@ -156,7 +195,7 @@ inline _Unwind_Word\n _Unwind_GetGR (struct _Unwind_Context *context, int index)\n {\n   int size;\n-  void *ptr;\n+  _Unwind_Context_Reg_Val val;\n \n #ifdef DWARF_ZERO_REG\n   if (index == DWARF_ZERO_REG)\n@@ -166,18 +205,18 @@ _Unwind_GetGR (struct _Unwind_Context *context, int index)\n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n   size = dwarf_reg_size_table[index];\n-  ptr = context->reg[index];\n+  val = context->reg[index];\n \n   if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n-    return (_Unwind_Word) (_Unwind_Internal_Ptr) ptr;\n+    return _Unwind_Get_Unwind_Word (val);\n \n   /* This will segfault if the register hasn't been saved.  */\n   if (size == sizeof(_Unwind_Ptr))\n-    return * (_Unwind_Ptr *) ptr;\n+    return * (_Unwind_Ptr *) (_Unwind_Internal_Ptr) val;\n   else\n     {\n       gcc_assert (size == sizeof(_Unwind_Word));\n-      return * (_Unwind_Word *) ptr;\n+      return * (_Unwind_Word *) (_Unwind_Internal_Ptr) val;\n     }\n }\n \n@@ -209,11 +248,11 @@ _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n \n   if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n     {\n-      context->reg[index] = (void *) (_Unwind_Internal_Ptr) val;\n+      context->reg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);\n       return;\n     }\n \n-  ptr = context->reg[index];\n+  ptr = (void *) (_Unwind_Internal_Ptr) context->reg[index];\n \n   if (size == sizeof(_Unwind_Ptr))\n     * (_Unwind_Ptr *) ptr = val;\n@@ -232,7 +271,7 @@ _Unwind_GetGRPtr (struct _Unwind_Context *context, int index)\n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n     return &context->reg[index];\n-  return context->reg[index];\n+  return (void *) (_Unwind_Internal_Ptr) context->reg[index];\n }\n \n /* Set the pointer to a register INDEX as saved in CONTEXT.  */\n@@ -243,7 +282,7 @@ _Unwind_SetGRPtr (struct _Unwind_Context *context, int index, void *p)\n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   if (_Unwind_IsExtendedContext (context))\n     context->by_value[index] = 0;\n-  context->reg[index] = p;\n+  context->reg[index] = (_Unwind_Context_Reg_Val) (_Unwind_Internal_Ptr) p;\n }\n \n /* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */\n@@ -254,10 +293,10 @@ _Unwind_SetGRValue (struct _Unwind_Context *context, int index,\n {\n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n-  gcc_assert (dwarf_reg_size_table[index] == sizeof (_Unwind_Ptr));\n+  gcc_assert (dwarf_reg_size_table[index] == sizeof (_Unwind_Context_Reg_Val));\n \n   context->by_value[index] = 1;\n-  context->reg[index] = (void *) (_Unwind_Internal_Ptr) val;\n+  context->reg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);\n }\n \n /* Return nonzero if register INDEX is stored by value rather than\n@@ -1215,7 +1254,8 @@ __frame_state_for (void *pc_target, struct frame_state *state_in)\n   int reg;\n \n   memset (&context, 0, sizeof (struct _Unwind_Context));\n-  context.flags = EXTENDED_CONTEXT_BIT;\n+  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n+    context.flags = EXTENDED_CONTEXT_BIT;\n   context.ra = pc_target + 1;\n \n   if (uw_frame_state_for (&context, &fs) != _URC_NO_REASON)\n@@ -1453,7 +1493,8 @@ uw_init_context_1 (struct _Unwind_Context *context,\n \n   memset (context, 0, sizeof (struct _Unwind_Context));\n   context->ra = ra;\n-  context->flags = EXTENDED_CONTEXT_BIT;\n+  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n+    context->flags = EXTENDED_CONTEXT_BIT;\n \n   code = uw_frame_state_for (context, &fs);\n   gcc_assert (code == _URC_NO_REASON);\n@@ -1532,8 +1573,8 @@ uw_install_context_1 (struct _Unwind_Context *current,\n \n   for (i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n     {\n-      void *c = current->reg[i];\n-      void *t = target->reg[i];\n+      void *c = (void *) (_Unwind_Internal_Ptr) current->reg[i];\n+      void *t = (void *) (_Unwind_Internal_Ptr)target->reg[i];\n \n       gcc_assert (current->by_value[i] == 0);\n       if (target->by_value[i] && c)"}]}