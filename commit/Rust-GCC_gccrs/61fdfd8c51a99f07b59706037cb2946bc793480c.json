{"sha": "61fdfd8c51a99f07b59706037cb2946bc793480c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmZGZkOGM1MWE5OWYwN2I1OTcwNjAzN2NiMjk0NmJjNzkzNDgwYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-03-08T08:50:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-03-08T08:50:01Z"}, "message": "re PR tree-optimization/79920 (Incorrect floating point results when compiling with -O3)\n\n2017-03-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/79920\n\t* tree-vect-slp.c (vect_create_mask_and_perm): Remove and inline\n\twith ncopies == 1 to ...\n\t(vect_transform_slp_perm_load): ... here.  Properly compute\n\tall element loads by iterating VF times over the group.  Do\n\tnot handle ncopies (computed in a broken way) in\n\tvect_create_mask_and_perm.\n\n\t* gcc.dg/vect/pr79920.c: New testcase.\n\nFrom-SVN: r245968", "tree": {"sha": "4a053adac88e0139104fc2de519527bc7be891bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a053adac88e0139104fc2de519527bc7be891bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61fdfd8c51a99f07b59706037cb2946bc793480c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fdfd8c51a99f07b59706037cb2946bc793480c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61fdfd8c51a99f07b59706037cb2946bc793480c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fdfd8c51a99f07b59706037cb2946bc793480c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b48e88382ab6c37aa981881adac0390a74eaeaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b48e88382ab6c37aa981881adac0390a74eaeaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b48e88382ab6c37aa981881adac0390a74eaeaa"}], "stats": {"total": 161, "additions": 91, "deletions": 70}, "files": [{"sha": "05f6017c9739a32a6bf5533ebd48ae685bc07b47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61fdfd8c51a99f07b59706037cb2946bc793480c", "patch": "@@ -1,3 +1,13 @@\n+2017-03-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/79920\n+\t* tree-vect-slp.c (vect_create_mask_and_perm): Remove and inline\n+\twith ncopies == 1 to ...\n+\t(vect_transform_slp_perm_load): ... here.  Properly compute\n+\tall element loads by iterating VF times over the group.  Do\n+\tnot handle ncopies (computed in a broken way) in\n+\tvect_create_mask_and_perm.\n+\n 2017-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/79904"}, {"sha": "eef88268eba3ff7b303f7f0861dc97ff29247f6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61fdfd8c51a99f07b59706037cb2946bc793480c", "patch": "@@ -1,3 +1,8 @@\n+2017-03-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/79920\n+\t* gcc.dg/vect/pr79920.c: New testcase.\n+\n 2017-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/79904"}, {"sha": "c066b91e73f2597a0bac8ddeeb55a22bd78fcaf9", "filename": "gcc/testsuite/gcc.dg/vect/pr79920.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c?ref=61fdfd8c51a99f07b59706037cb2946bc793480c", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include \"tree-vect.h\"\n+\n+double __attribute__((noinline,noclone))\n+compute_integral (double w_1[18])\n+{\n+  double A = 0;\n+  double t33[2][6] = {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n+\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};\n+  double t43[2] = {0.0, 0.0};\n+  double t31[2][2] = {{1.0, 1.0}, {1.0, 1.0}};\n+  double t32[2][3] = {{0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}};\n+\n+  for (int ip_1 = 0; ip_1 < 2; ++ip_1)\n+    {\n+      for (int i_0 = 0; i_0 < 6; ++i_0)\n+\tt33[ip_1][i_0] = ((w_1[i_0*3] * t32[ip_1][0])\n+\t\t\t  + (w_1[i_0*3+2] * t32[ip_1][2]));\n+      t43[ip_1] = 2.0;\n+    }\n+  for (int i_0 = 0; i_0 < 6; ++i_0)\n+    A += t43[1]*t33[1][i_0];\n+  return A;\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  double w_1[18] = {0., 1.0, 1.0,\n+      0., 1.0, 1.0,\n+      0., 1.0, 1.0,\n+      0., 1.0, 1.0,\n+      0., 1.0, 1.0,\n+      0., 1.0, 1.0};\n+  double A = compute_integral(w_1);\n+  if (A != 12.0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_double && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "1300c6a173d52c5f732c816bc80cca9353f6ff06", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 32, "deletions": 70, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61fdfd8c51a99f07b59706037cb2946bc793480c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=61fdfd8c51a99f07b59706037cb2946bc793480c", "patch": "@@ -3379,66 +3379,6 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n     }\n }\n \n-\n-/* Create NCOPIES permutation statements using the mask MASK_BYTES (by\n-   building a vector of type MASK_TYPE from it) and two input vectors placed in\n-   DR_CHAIN at FIRST_VEC_INDX and SECOND_VEC_INDX for the first copy and\n-   shifting by STRIDE elements of DR_CHAIN for every copy.\n-   (STRIDE is the number of vectorized stmts for NODE divided by the number of\n-   copies).\n-   VECT_STMTS_COUNTER specifies the index in the vectorized stmts of NODE, where\n-   the created stmts must be inserted.  */\n-\n-static inline void\n-vect_create_mask_and_perm (gimple *stmt,\n-                           tree mask, int first_vec_indx, int second_vec_indx,\n-                           gimple_stmt_iterator *gsi, slp_tree node,\n-                           tree vectype, vec<tree> dr_chain,\n-                           int ncopies, int vect_stmts_counter)\n-{\n-  tree perm_dest;\n-  gimple *perm_stmt = NULL;\n-  int i, stride_in, stride_out;\n-  tree first_vec, second_vec, data_ref;\n-\n-  stride_out = SLP_TREE_NUMBER_OF_VEC_STMTS (node) / ncopies;\n-  stride_in = dr_chain.length () / ncopies;\n-\n-  /* Initialize the vect stmts of NODE to properly insert the generated\n-     stmts later.  */\n-  for (i = SLP_TREE_VEC_STMTS (node).length ();\n-       i < (int) SLP_TREE_NUMBER_OF_VEC_STMTS (node); i++)\n-    SLP_TREE_VEC_STMTS (node).quick_push (NULL);\n-\n-  perm_dest = vect_create_destination_var (gimple_assign_lhs (stmt), vectype);\n-  for (i = 0; i < ncopies; i++)\n-    {\n-      first_vec = dr_chain[first_vec_indx];\n-      second_vec = dr_chain[second_vec_indx];\n-\n-      /* Generate the permute statement if necessary.  */\n-      if (mask)\n-\t{\n-\t  perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n-\t\t\t\t\t   first_vec, second_vec, mask);\n-\t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n-\t  gimple_set_lhs (perm_stmt, data_ref);\n-\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\t}\n-      else\n-\t/* If mask was NULL_TREE generate the requested identity transform.  */\n-\tperm_stmt = SSA_NAME_DEF_STMT (first_vec);\n-\n-      /* Store the vector statement in NODE.  */\n-      SLP_TREE_VEC_STMTS (node)[stride_out * i + vect_stmts_counter]\n-\t= perm_stmt;\n-\n-      first_vec_indx += stride_in;\n-      second_vec_indx += stride_in;\n-    }\n-}\n-\n-\n /* Generate vector permute statements from a list of loads in DR_CHAIN.\n    If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n    permute statements for the SLP node NODE of the SLP instance\n@@ -3456,7 +3396,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   int nunits, vec_index = 0;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n-  int unroll_factor, mask_element, ncopies;\n+  int mask_element;\n   unsigned char *mask;\n   machine_mode mode;\n \n@@ -3474,11 +3414,13 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   mask = XALLOCAVEC (unsigned char, nunits);\n-  unroll_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n \n-  /* Number of copies is determined by the final vectorization factor\n-     relatively to SLP_NODE_INSTANCE unrolling factor.  */\n-  ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n+  /* Initialize the vect stmts of NODE to properly insert the generated\n+     stmts later.  */\n+  if (! analyze_only)\n+    for (unsigned i = SLP_TREE_VEC_STMTS (node).length ();\n+\t i < SLP_TREE_NUMBER_OF_VEC_STMTS (node); i++)\n+      SLP_TREE_VEC_STMTS (node).quick_push (NULL);\n \n   /* Generate permutation masks for every NODE. Number of masks for each NODE\n      is equal to GROUP_SIZE.\n@@ -3505,7 +3447,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   bool noop_p = true;\n   *n_perms = 0;\n \n-  for (int j = 0; j < unroll_factor; j++)\n+  for (int j = 0; j < vf; j++)\n     {\n       for (int k = 0; k < group_size; k++)\n \t{\n@@ -3578,10 +3520,30 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \n \t\t  if (second_vec_index == -1)\n \t\t    second_vec_index = first_vec_index;\n-\t\t  vect_create_mask_and_perm (stmt, mask_vec, first_vec_index,\n-\t\t\t\t\t     second_vec_index,\n-\t\t\t\t\t     gsi, node, vectype, dr_chain,\n-\t\t\t\t\t     ncopies, vect_stmts_counter++);\n+\n+\t\t  /* Generate the permute statement if necessary.  */\n+\t\t  tree first_vec = dr_chain[first_vec_index];\n+\t\t  tree second_vec = dr_chain[second_vec_index];\n+\t\t  gimple *perm_stmt;\n+\t\t  if (! noop_p)\n+\t\t    {\n+\t\t      tree perm_dest\n+\t\t\t= vect_create_destination_var (gimple_assign_lhs (stmt),\n+\t\t\t\t\t\t       vectype);\n+\t\t      perm_dest = make_ssa_name (perm_dest);\n+\t\t      perm_stmt = gimple_build_assign (perm_dest,\n+\t\t\t\t\t\t       VEC_PERM_EXPR,\n+\t\t\t\t\t\t       first_vec, second_vec,\n+\t\t\t\t\t\t       mask_vec);\n+\t\t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t\t    }\n+\t\t  else\n+\t\t    /* If mask was NULL_TREE generate the requested\n+\t\t       identity transform.  */\n+\t\t    perm_stmt = SSA_NAME_DEF_STMT (first_vec);\n+\n+\t\t  /* Store the vector statement in NODE.  */\n+\t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++] = perm_stmt;\n \t\t}\n \n \t      index = 0;"}]}