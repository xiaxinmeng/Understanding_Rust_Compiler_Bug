{"sha": "41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFjNjRhYzAxMjcyYmQzZmNhMDQ4NmU2MThiZDFkMWVhMTRhNzZiZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-11T21:34:23Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-11T21:34:23Z"}, "message": "expmed.c (synth_mult): Add an additional MODE argument for the machine mode of the multiplication.\n\n\n\t* expmed.c (synth_mult): Add an additional MODE argument for the\n\tmachine mode of the multiplication.  Update recursive calls.  Use\n\tmode instead of word_mode for determining operation costs.\n\t(choose_mult_variant): Update calls to synth_mult with \"mode\".\n\nFrom-SVN: r83002", "tree": {"sha": "070bc0b8d2f8fd4ea4fb0cf75e77e2e5f4ca6a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/070bc0b8d2f8fd4ea4fb0cf75e77e2e5f4ca6a28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c64ac01272bd3fca0486e618bd1d1ea14a76bd/comments", "author": null, "committer": null, "parents": [{"sha": "9098a3ecee26d89fec8f055810988380a4d4580a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9098a3ecee26d89fec8f055810988380a4d4580a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9098a3ecee26d89fec8f055810988380a4d4580a"}], "stats": {"total": 47, "additions": 28, "deletions": 19}, "files": [{"sha": "6533e7d693425d5c962530776f6b26e2c154d936", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c64ac01272bd3fca0486e618bd1d1ea14a76bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c64ac01272bd3fca0486e618bd1d1ea14a76bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "patch": "@@ -1,3 +1,10 @@\n+2004-06-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (synth_mult): Add an additional MODE argument for the\n+\tmachine mode of the multiplication.  Update recursive calls.  Use\n+\tmode instead of word_mode for determining operation costs.\n+\t(choose_mult_variant): Update calls to synth_mult with \"mode\".\n+\n 2004-06-11  Richard Henderson  <rth@redhat.com>\n \n \t* tree-ssa-operands.c (get_stmt_operands): Clear makes_aliased_loads"}, {"sha": "00df7ce0c7be3c97a660ea1ab350a141e8b4ee30", "filename": "gcc/expmed.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c64ac01272bd3fca0486e618bd1d1ea14a76bd/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c64ac01272bd3fca0486e618bd1d1ea14a76bd/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "patch": "@@ -2153,7 +2153,8 @@ struct algorithm\n    multiplicand should be added to the result.  */\n enum mult_variant {basic_variant, negate_variant, add_variant};\n \n-static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT, int);\n+static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT,\n+\t\t\tint, enum machine_mode mode);\n static bool choose_mult_variant (enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t struct algorithm *, enum mult_variant *, int);\n static rtx expand_mult_const (enum machine_mode, rtx, HOST_WIDE_INT, rtx,\n@@ -2168,11 +2169,12 @@ static rtx expand_mult_highpart_optab (enum machine_mode, rtx, rtx, rtx,\n /* Compute and return the best algorithm for multiplying by T.\n    The algorithm must cost less than cost_limit\n    If retval.cost >= COST_LIMIT, no algorithm was found and all\n-   other field of the returned struct are undefined.  */\n+   other field of the returned struct are undefined.\n+   MODE is the machine mode of the multiplication.  */\n \n static void\n synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n-\t    int cost_limit)\n+\t    int cost_limit, enum machine_mode mode)\n {\n   int m;\n   struct algorithm *alg_in, *best_alg;\n@@ -2225,7 +2227,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  q = t >> m;\n \t  cost = shift_cost[m];\n-\t  synth_mult (alg_in, q, cost_limit - cost);\n+\t  synth_mult (alg_in, q, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2259,8 +2261,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n \n-\t  cost = add_cost[word_mode];\n-\t  synth_mult (alg_in, t + 1, cost_limit - cost);\n+\t  cost = add_cost[mode];\n+\t  synth_mult (alg_in, t + 1, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2276,8 +2278,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-\t  cost = add_cost[word_mode];\n-\t  synth_mult (alg_in, t - 1, cost_limit - cost);\n+\t  cost = add_cost[mode];\n+\t  synth_mult (alg_in, t - 1, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2308,10 +2310,10 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = add_cost[word_mode] + shift_cost[m];\n+\t  cost = add_cost[mode] + shift_cost[m];\n \t  if (shiftadd_cost[m] < cost)\n \t    cost = shiftadd_cost[m];\n-\t  synth_mult (alg_in, t / d, cost_limit - cost);\n+\t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2329,10 +2331,10 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = add_cost[word_mode] + shift_cost[m];\n+\t  cost = add_cost[mode] + shift_cost[m];\n \t  if (shiftsub_cost[m] < cost)\n \t    cost = shiftsub_cost[m];\n-\t  synth_mult (alg_in, t / d, cost_limit - cost);\n+\t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2357,7 +2359,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       if (m >= 0 && m < BITS_PER_WORD)\n \t{\n \t  cost = shiftadd_cost[m];\n-\t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost);\n+\t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2376,7 +2378,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       if (m >= 0 && m < BITS_PER_WORD)\n \t{\n \t  cost = shiftsub_cost[m];\n-\t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost);\n+\t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n \t  if (cost < cost_limit)\n@@ -2429,22 +2431,22 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n   struct algorithm alg2;\n \n   *variant = basic_variant;\n-  synth_mult (alg, val, mult_cost);\n+  synth_mult (alg, val, mult_cost, mode);\n \n   /* This works only if the inverted value actually fits in an\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n     {\n-      synth_mult (&alg2, -val, MIN (alg->cost, mult_cost)\n-\t\t\t       - neg_cost[mode]);\n+      synth_mult (&alg2, -val, MIN (alg->cost, mult_cost) - neg_cost[mode],\n+\t\t  mode);\n       alg2.cost += neg_cost[mode];\n       if (alg2.cost < alg->cost)\n \t*alg = alg2, *variant = negate_variant;\n     }\n \n   /* This proves very useful for division-by-constant.  */\n-  synth_mult (&alg2, val - 1, MIN (alg->cost, mult_cost)\n-\t\t\t      - add_cost[mode]);\n+  synth_mult (&alg2, val - 1, MIN (alg->cost, mult_cost) - add_cost[mode],\n+\t      mode);\n   alg2.cost += add_cost[mode];\n   if (alg2.cost < alg->cost)\n     *alg = alg2, *variant = add_variant;"}]}