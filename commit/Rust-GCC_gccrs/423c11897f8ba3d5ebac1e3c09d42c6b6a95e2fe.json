{"sha": "423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzYzExODk3ZjhiYTNkNWViYWMxZTNjMDlkNDJjNmI2YTk1ZTJmZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2004-04-20T02:13:19Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2004-04-20T02:13:19Z"}, "message": "rs6000.md (UNSPEC_MV_CR_GT): New constant.\n\n        * config/rs6000/rs6000.md (UNSPEC_MV_CR_GT): New constant.\n        (move_from_CR_gt_bit): New.\n        (cceq_ior_compare): Name previously unnamed pattern.  Disable for\n        E500.\n        (cceq_rev_compare): Name previously unnamed pattern.  Allow for\n        E500.\n\n        * config/rs6000/spe.md (cmpsfeq_gpr): Rewrite as unspec.\n        (tstsfeq_gpr): Same.\n        (cmpsfgt_gpr): Same.\n        (tstsfgt_gpr): Same.\n        (cmpsflt_gpr): Same.\n        (tstsflt_gpr): Same.\n        (e500_cceq_ior_compare): New.\n        (e500_flip_gt_bit): New.\n\n        * config/rs6000/rs6000.c (ccr_bit): Remove E500 specific code.\n        (print_operand): Add 'c' and 'D'.\n        (rs6000_generate_compare): Rewrite to generate correct rtl.\n        (rs6000_emit_sCOND): Handle E500.\n        (output_cbranch): Adjust for changes in rs6000_generate_compare.\n        (output_e500_flip_gt_bit): New.\n\n        * config/rs6000/rs6000-protos.h (output_e500_flip_gt_bit):\n        Protoize.\n\nFrom-SVN: r80876", "tree": {"sha": "06e1d8b1a6d2c2176c501a12322e0fa187b494b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e1d8b1a6d2c2176c501a12322e0fa187b494b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f531010820afc86bde3e7d4b98850ee51c735de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f531010820afc86bde3e7d4b98850ee51c735de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f531010820afc86bde3e7d4b98850ee51c735de5"}], "stats": {"total": 238, "additions": 168, "deletions": 70}, "files": [{"sha": "5aab80f3b1e74c072d0bccb7d964d5c466e4c140", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "patch": "@@ -1,3 +1,31 @@\n+2004-04-19  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/rs6000/rs6000.md (UNSPEC_MV_CR_GT): New constant.\n+        (move_from_CR_gt_bit): New.\n+        (cceq_ior_compare): Name previously unnamed pattern.  Disable for\n+        E500.\n+        (cceq_rev_compare): Name previously unnamed pattern.  Allow for\n+        E500.\n+\n+        * config/rs6000/spe.md (cmpsfeq_gpr): Rewrite as unspec.\n+        (tstsfeq_gpr): Same.\n+        (cmpsfgt_gpr): Same.\n+        (tstsfgt_gpr): Same.\n+        (cmpsflt_gpr): Same.\n+        (tstsflt_gpr): Same.\n+        (e500_cceq_ior_compare): New.\n+        (e500_flip_gt_bit): New.\n+\n+        * config/rs6000/rs6000.c (ccr_bit): Remove E500 specific code.\n+        (print_operand): Add 'c' and 'D'.\n+        (rs6000_generate_compare): Rewrite to generate correct rtl.\n+        (rs6000_emit_sCOND): Handle E500.\n+        (output_cbranch): Adjust for changes in rs6000_generate_compare.\n+        (output_e500_flip_gt_bit): New.\n+\n+        * config/rs6000/rs6000-protos.h (output_e500_flip_gt_bit):\n+        Protoize.\n+\n 2004-04-19  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.h (DWARF2_ADDR_SIZE): New."}, {"sha": "57e8886b391f5812e87498700ba2728ea4767c81", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "patch": "@@ -116,6 +116,7 @@ extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n extern void rs6000_emit_sCOND (enum rtx_code, rtx);\n extern void rs6000_emit_cbranch (enum rtx_code, rtx);\n extern char * output_cbranch (rtx, const char *, int, rtx);\n+extern char * output_e500_flip_gt_bit (rtx, rtx);\n extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);"}, {"sha": "5384c79c2d4c4ec1114a83193f2b515c7625c8ee", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 69, "deletions": 51, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "patch": "@@ -8798,14 +8798,8 @@ ccr_bit (rtx op, int scc_p)\n   switch (code)\n     {\n     case NE:\n-      if (TARGET_E500 && !TARGET_FPRS\n-\t  && TARGET_HARD_FLOAT && cc_mode == CCFPmode)\n-\treturn base_bit + 1;\n       return scc_p ? base_bit + 3 : base_bit + 2;\n     case EQ:\n-      if (TARGET_E500 && !TARGET_FPRS\n-\t  && TARGET_HARD_FLOAT && cc_mode == CCFPmode)\n-\treturn base_bit + 1;\n       return base_bit + 2;\n     case GT:  case GTU:  case UNLE:\n       return base_bit + 1;\n@@ -9025,6 +9019,26 @@ print_operand (FILE *file, rtx x, int code)\n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n \t output_operand.  */\n \n+    case 'c':\n+      /* X is a CR register.  Print the number of the GT bit of the CR.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%E value\");\n+      else\n+\tfprintf (file, \"%d\", 4 * (REGNO (x) - CR0_REGNO) + 1);\n+      return;\n+\n+    case 'D':\n+      /* Like 'J' but get to the GT bit.  */\n+      if (GET_CODE (x) != REG)\n+\tabort ();\n+\n+      /* Bit 1 is GT bit.  */\n+      i = 4 * (REGNO (x) - CR0_REGNO) + 1;\n+\n+      /* If we want bit 31, write a shift count of zero, not 32.  */\n+      fprintf (file, \"%d\", i == 31 ? 0 : i + 1);\n+      return;\n+\n     case 'E':\n       /* X is a CR register.  Print the number of the EQ bit of the CR */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n@@ -9812,36 +9826,26 @@ rs6000_generate_compare (enum rtx_code code)\n     {\n       rtx cmp, or1, or2, or_result, compare_result2;\n \n+      /* Note: The E500 comparison instructions set the GT bit (x +\n+\t 1), on success.  This explains the mess.  */\n+\n       switch (code)\n \t{\n-\tcase EQ:\n-\tcase UNEQ:\n-\tcase NE:\n-\tcase LTGT:\n+\tcase EQ: case UNEQ: case NE: case LTGT:\n \t  cmp = flag_finite_math_only\n \t    ? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1);\n \t  break;\n-\tcase GT:\n-\tcase GTU:\n-\tcase UNGT:\n-\tcase UNGE:\n-\tcase GE:\n-\tcase GEU:\n+\tcase GT: case GTU: case UNGT: case UNGE: case GE: case GEU:\n \t  cmp = flag_finite_math_only\n \t    ? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1);\n \t  break;\n-\tcase LT:\n-\tcase LTU:\n-\tcase UNLT:\n-\tcase UNLE:\n-\tcase LE:\n-\tcase LEU:\n+\tcase LT: case LTU: case UNLT: case UNLE: case LE: case LEU:\n \t  cmp = flag_finite_math_only\n \t    ? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n@@ -9855,8 +9859,6 @@ rs6000_generate_compare (enum rtx_code code)\n       /* Synthesize LE and GE from LT/GT || EQ.  */\n       if (code == LE || code == GE || code == LEU || code == GEU)\n \t{\n-\t  /* Synthesize GE/LE frome GT/LT || EQ.  */\n-\n \t  emit_insn (cmp);\n \n \t  switch (code)\n@@ -9881,23 +9883,8 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t\t       rs6000_compare_op1);\n \t  emit_insn (cmp);\n \n-\t  /* The MC8540 FP compare instructions set the CR bits\n-\t     differently than other PPC compare instructions.  For\n-\t     that matter, there is no generic test instruction, but a\n-\t     testgt, testlt, and testeq.  For a true condition, bit 2\n-\t     is set (x1xx) in the CR.  Following the traditional CR\n-\t     values:\n-\n-\t     LT    GT    EQ    OV\n-\t     bit3  bit2  bit1  bit0\n-\n-\t     ... bit 2 would be a GT CR alias, so later on we\n-\t     look in the GT bits for the branch instructions.\n-\t     However, we must be careful to emit correct RTL in\n-\t     the meantime, so optimizations don't get confused.  */\n-\n-\t  or1 = gen_rtx_NE (SImode, compare_result, const0_rtx);\n-\t  or2 = gen_rtx_NE (SImode, compare_result2, const0_rtx);\n+\t  or1 = gen_rtx_GT (SImode, compare_result, const0_rtx);\n+\t  or2 = gen_rtx_GT (SImode, compare_result2, const0_rtx);\n \n \t  /* OR them together.  */\n \t  cmp = gen_rtx_SET (VOIDmode, or_result,\n@@ -9909,16 +9896,10 @@ rs6000_generate_compare (enum rtx_code code)\n \t}\n       else\n \t{\n-\t  /* We only care about 1 bit (x1xx), so map everything to NE to\n-\t     maintain rtl sanity.  We'll get to the right bit (x1xx) at\n-\t     code output time.  */\n \t  if (code == NE || code == LTGT)\n-\t    /* Do the inverse here because we have no cmpne\n-\t       instruction.  We use the cmpeq instruction and expect\n-\t       to get a 0 instead.  */\n-\t    code = EQ;\n-\t  else\n \t    code = NE;\n+\t  else\n+\t    code = EQ;\n \t}\n \n       emit_insn (cmp);\n@@ -9983,6 +9964,24 @@ rs6000_emit_sCOND (enum rtx_code code, rtx result)\n   condition_rtx = rs6000_generate_compare (code);\n   cond_code = GET_CODE (condition_rtx);\n \n+  if (TARGET_E500 && rs6000_compare_fp_p\n+      && !TARGET_FPRS && TARGET_HARD_FLOAT)\n+    {\n+      rtx t;\n+\n+      PUT_MODE (condition_rtx, SImode);\n+      t = XEXP (condition_rtx, 0);\n+\n+      if (cond_code != NE && cond_code != EQ)\n+\tabort ();\n+\n+      if (cond_code == NE)\n+\temit_insn (gen_e500_flip_gt_bit (t, t));\n+\n+      emit_insn (gen_move_from_CR_gt_bit (result, t));\n+      return;\n+    }\n+\n   if (cond_code == NE\n       || cond_code == GE || cond_code == LE\n       || cond_code == GEU || cond_code == LEU\n@@ -10079,9 +10078,9 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n \t to the GT bit.  */\n       if (code == EQ)\n \t/* Opposite of GT.  */\n-\tcode = UNLE;\n-      else if (code == NE)\n \tcode = GT;\n+      else if (code == NE)\n+\tcode = UNLE;\n       else\n \tabort ();\n     }\n@@ -10160,6 +10159,25 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n   return string;\n }\n \n+/* Return the string to flip the GT bit on a CR.  */\n+char *\n+output_e500_flip_gt_bit (rtx dst, rtx src)\n+{\n+  static char string[64];\n+  int a, b;\n+\n+  if (GET_CODE (dst) != REG || ! CR_REGNO_P (REGNO (dst))\n+      || GET_CODE (src) != REG || ! CR_REGNO_P (REGNO (src)))\n+    abort ();\n+\n+  /* GT bit.  */\n+  a = 4 * (REGNO (dst) - CR0_REGNO) + 1;\n+  b = 4 * (REGNO (src) - CR0_REGNO) + 1;\n+\n+  sprintf (string, \"crnot %d,%d\", a, b);\n+  return string;\n+}\n+\n /* Emit a conditional move: move TRUE_COND to DEST if OP of the\n    operands of the last comparison is nonzero/true, FALSE_COND if it\n    is zero/false.  Return 0 if the hardware has no such operation.  */"}, {"sha": "c1dabf888b3991d2e8190c61f53172dc313f3681", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "patch": "@@ -50,6 +50,7 @@\n    (UNSPEC_TLSGOTTPREL\t\t28)\n    (UNSPEC_TLSTLS\t\t29)\n    (UNSPEC_FIX_TRUNC_TF\t\t30)\t; fadd, rounding towards zero\n+   (UNSPEC_MV_CR_GT\t\t31)\t; move_from_CR_gt_bit\n   ])\n \n ;;\n@@ -11290,6 +11291,15 @@\n \t(const_string \"mfcr\")))\n    (set_attr \"length\" \"12\")])\n \n+;; Same as above, but get the GT bit.\n+(define_insn \"move_from_CR_gt_bit\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"cc_reg_operand\" \"y\")] UNSPEC_MV_CR_GT))]\n+  \"TARGET_E500\"\n+  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%D1,1\"\n+  [(set_attr \"type\" \"mfcr\")\n+   (set_attr \"length\" \"12\")])\n+\n ;; Same as above, but get the OV/ORDERED bit.\n (define_insn \"move_from_CR_ov_bit\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -13620,7 +13630,7 @@\n ; which are generated by the branch logic.\n ; Prefer destructive operations where BT = BB (for crXX BT,BA,BB)\n \n-(define_insn \"\"\n+(define_insn \"*cceq_ior_compare\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y,?y\")\n         (compare:CCEQ (match_operator:SI 1 \"boolean_operator\"\n \t                [(match_operator:SI 2\n@@ -13634,7 +13644,7 @@\n \t\t\t\t\t\t      \"cc_reg_operand\" \"0,y\")\n \t\t\t\t       (const_int 0)])])\n \t\t      (const_int 1)))]\n-  \"\"\n+  \"!(TARGET_E500 && TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n   \"cr%q1 %E0,%j2,%j4\"\n   [(set_attr \"type\" \"cr_logical,delayed_cr\")])\n \n@@ -13658,17 +13668,15 @@\n   \"cr%q1 %E0,%j2,%j4\"\n   [(set_attr \"type\" \"cr_logical,delayed_cr\")])\n \n-(define_insn \"\"\n+(define_insn \"*cceq_rev_compare\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y,?y\")\n \t(compare:CCEQ (match_operator:SI 1\n \t\t\t\t      \"branch_positive_comparison_operator\"\n \t\t\t\t      [(match_operand 2\n \t\t\t\t\t\t      \"cc_reg_operand\" \"0,y\")\n \t\t\t\t       (const_int 0)])\n \t\t      (const_int 0)))]\n-  ;; This pattern is not available to SPE because the CR bits on an FP\n-  ;; compare are different than traditional PPC.\n-  \"!TARGET_SPE\"\n+  \"\"\n   \"{crnor %E0,%j1,%j1|crnot %E0,%j1}\"\n   [(set_attr \"type\" \"cr_logical,delayed_cr\")])\n "}, {"sha": "7e765753655a19a02ab185880e4bcf4850ce3309", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=423c11897f8ba3d5ebac1e3c09d42c6b6a95e2fe", "patch": "@@ -2455,55 +2455,98 @@\n   \"mfspefscr %0\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+;; FP comparison stuff.\n+\n+(define_insn \"e500_cceq_ior_compare\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y,?y\")\n+        (compare:CCEQ (match_operator:SI 1 \"boolean_operator\"\n+\t                [(match_operator:SI 2\n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 3\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"y,y\")\n+\t\t\t\t       (const_int 0)])\n+\t                 (match_operator:SI 4\n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 5\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"0,y\")\n+\t\t\t\t       (const_int 0)])])\n+\t\t      (const_int 1)))]\n+  \"TARGET_E500 && TARGET_HARD_FLOAT && !TARGET_FPRS\"\n+  \"cr%q1 %c0,%j2,%j4\"\n+  [(set_attr \"type\" \"cr_logical,delayed_cr\")])\n+\n+;; Flip the GT bit.\n+(define_insn \"e500_flip_gt_bit\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(match_operand:CCFP 1 \"cc_reg_operand\" \"y\")] 999))]\n+  \"!TARGET_FPRS && TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  return output_e500_flip_gt_bit (operands[0], operands[1]);\n+}\"\n+  [(set_attr \"type\" \"cr_logical\")])\n+\n ;; MPC8540 single-precision FP instructions on GPRs.\n ;; We have 2 variants for each.  One for IEEE compliant math and one\n ;; for non IEEE compliant math.\n \n (define_insn \"cmpsfeq_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(eq:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1000))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && !flag_unsafe_math_optimizations\"\n   \"efscmpeq %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"tstsfeq_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(eq:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1001))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && flag_unsafe_math_optimizations\"\n   \"efststeq %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpsimple\")])\n \n (define_insn \"cmpsfgt_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(gt:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1002))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && !flag_unsafe_math_optimizations\"\n   \"efscmpgt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"tstsfgt_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(gt:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1003))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && flag_unsafe_math_optimizations\"\n   \"efststgt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpsimple\")])\n \n (define_insn \"cmpsflt_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(lt:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1004))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && !flag_unsafe_math_optimizations\"\n   \"efscmplt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n (define_insn \"tstsflt_gpr\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(lt:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"r\")))]\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"r\"))]\n+\t 1004))]\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && flag_unsafe_math_optimizations\"\n   \"efststlt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpsimple\")])\n-"}]}