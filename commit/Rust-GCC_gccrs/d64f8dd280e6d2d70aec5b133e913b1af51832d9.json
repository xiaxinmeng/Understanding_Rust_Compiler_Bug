{"sha": "d64f8dd280e6d2d70aec5b133e913b1af51832d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0ZjhkZDI4MGU2ZDJkNzBhZWM1YjEzM2U5MTNiMWFmNTE4MzJkOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-30T20:28:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-30T20:28:14Z"}, "message": "[PATCH] Improve DOM's optimization of control statements\n\n\t* tree-ssa-dom.c (optimize_stmt): Collapse control flow statements\n\twith constant conditions.\n\t* tree-ssa-threadupdate.c (remove_jump_threads_starting_at): New.\n\t(remove_ctrl_stmt_and_useless_edges): No longer static.\n\t* tree-ssa-threadupdate.h (remove_jump_threads_starting_at): Prototype.\n\t(remove_ctrl_stmt_and_useless_edges): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-dom-branch-1.c: New test.\n\nFrom-SVN: r228306", "tree": {"sha": "8a5d0ddc85f0e869a286b391f3deb283fd6db817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a5d0ddc85f0e869a286b391f3deb283fd6db817"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d64f8dd280e6d2d70aec5b133e913b1af51832d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f8dd280e6d2d70aec5b133e913b1af51832d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64f8dd280e6d2d70aec5b133e913b1af51832d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f8dd280e6d2d70aec5b133e913b1af51832d9/comments", "author": null, "committer": null, "parents": [{"sha": "9702ee6a6f2086fffd543cdb785d0caac05e7fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9702ee6a6f2086fffd543cdb785d0caac05e7fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9702ee6a6f2086fffd543cdb785d0caac05e7fcc"}], "stats": {"total": 127, "additions": 99, "deletions": 28}, "files": [{"sha": "ba25406f2ba45cb51f40a3e5138dd408a09da21c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -1,3 +1,12 @@\n+2015-09-30  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (optimize_stmt): Collapse control flow statements\n+\twith constant conditions.\n+\t* tree-ssa-threadupdate.c (remove_jump_threads_starting_at): New.\n+\t(remove_ctrl_stmt_and_useless_edges): No longer static.\n+\t* tree-ssa-threadupdate.h (remove_jump_threads_starting_at): Prototype.\n+\t(remove_ctrl_stmt_and_useless_edges): Likewise.\n+\n 2015-09-30  Nathan Sidwell  <nathan@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "46f355aa993687bfc82977403e60c9c9a4b272f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -1,3 +1,7 @@\n+2015-09-30  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-dom-branch-1.c: New test.\n+\n 2015-09-30  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR rtl-optimization/67037"}, {"sha": "bf50e63494c368e41d9ab08e762088b086a7faa9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-branch-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -w -fdump-tree-dom1-details\" } */\n+\n+typedef struct rtx_def *rtx;\n+struct rtx_def\n+{\n+  int code;\n+  rtx rt_rtx;\n+};\n+rtx\n+try_combine (rtx i1, rtx newpat)\n+{\n+  rtx temp;\n+  if (i1 && (temp = ((((((newpat->rt_rtx, ((((temp)->code) == 42)))))))))\n+      && ((temp =\n+\t(((((((((((newpat)->rt_rtx),\n+\t\t ((((temp)->code) == 42) && arf ())))))))))))))\n+    ;\n+  else if (i1 && foo ());\n+}\n+\n+/* There should be three tests against i1.  Two from the hash table\n+   dumps, one in the code itself.  */\n+/* { dg-final { scan-tree-dump-times \"if .i1_\" 3 \"dom1\"} } */\n+\n+/* There should be no actual jump threads realized by DOM.  The\n+   legitimize jump threads are handled in VRP and those discovered\n+   by DOM are subsumed by collapsing a conditional.  */\n+/* { dg-final { scan-tree-dump-not \"Threaded\" \"dom1\"} } */"}, {"sha": "a8b7038d73bd00aba5d6bf18d252cee53f0c5818", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -1820,31 +1820,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n   if (is_gimple_assign (stmt))\n     record_equivalences_from_stmt (stmt, may_optimize_p, avail_exprs_stack);\n \n-  /* If STMT is a COND_EXPR and it was modified, then we may know\n-     where it goes.  If that is the case, then mark the CFG as altered.\n-\n-     This will cause us to later call remove_unreachable_blocks and\n-     cleanup_tree_cfg when it is safe to do so.  It is not safe to\n-     clean things up here since removal of edges and such can trigger\n-     the removal of PHI nodes, which in turn can release SSA_NAMEs to\n-     the manager.\n-\n-     That's all fine and good, except that once SSA_NAMEs are released\n-     to the manager, we must not call create_ssa_name until all references\n-     to released SSA_NAMEs have been eliminated.\n-\n-     All references to the deleted SSA_NAMEs can not be eliminated until\n-     we remove unreachable blocks.\n-\n-     We can not remove unreachable blocks until after we have completed\n-     any queued jump threading.\n-\n-     We can not complete any queued jump threads until we have taken\n-     appropriate variables out of SSA form.  Taking variables out of\n-     SSA form can call create_ssa_name and thus we lose.\n-\n-     Ultimately I suspect we're going to need to change the interface\n-     into the SSA_NAME manager.  */\n+  /* If STMT is a COND_EXPR or SWITCH_EXPR and it was modified, then we may\n+     know where it goes.  */\n   if (gimple_modified_p (stmt) || modified_p)\n     {\n       tree val = NULL;\n@@ -1858,8 +1835,27 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n       else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n \tval = gimple_switch_index (swtch_stmt);\n \n-      if (val && TREE_CODE (val) == INTEGER_CST && find_taken_edge (bb, val))\n-\tcfg_altered = true;\n+      if (val && TREE_CODE (val) == INTEGER_CST)\n+\t{\n+\t  edge taken_edge = find_taken_edge (bb, val);\n+\t  if (taken_edge)\n+\t    {\n+\t      /* Delete threads that start at BB.  */\n+\t      remove_jump_threads_starting_at (bb);\n+\n+\t      /* Now clean up the control statement at the end of\n+\t\t BB and remove unexecutable edges.  */\n+\t      remove_ctrl_stmt_and_useless_edges (bb, taken_edge->dest);\n+\n+\t      /* Fixup the flags on the single remaining edge.  */\n+\t      taken_edge->flags\n+\t\t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n+\t      taken_edge->flags |= EDGE_FALLTHRU;\n+\n+\t      /* Further simplifications may be possible.  */\n+\t      cfg_altered = true;\n+\t    }\n+\t}\n \n       /* If we simplified a statement in such a way as to be shown that it\n \t cannot trap, update the eh information and the cfg to match.  */"}, {"sha": "4a147bb46372b5a5fbf33a6e84b7f62d86c9e870", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -260,7 +260,7 @@ struct thread_stats_d thread_stats;\n    Also remove all outgoing edges except the edge which reaches DEST_BB.\n    If DEST_BB is NULL, then remove all outgoing edges.  */\n \n-static void\n+void\n remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -2539,6 +2539,37 @@ valid_jump_thread_path (vec<jump_thread_edge *> *path)\n   return true;\n }\n \n+/* Remove any queued jump threads that start at BB.  */\n+\n+void\n+remove_jump_threads_starting_at (basic_block bb)\n+{\n+  if (!paths.exists ())\n+    return;\n+\n+  for (unsigned i = 0; i < paths.length ();)\n+    {\n+      vec<jump_thread_edge *> *path = paths[i];\n+\n+      /* Sadly, FSM jump threads have a slightly different\n+\t representation than the rest of the jump threads.  */\n+      if ((*path)[0]->type == EDGE_FSM_THREAD\n+\t  && (*path)[0]->e->src == bb)\n+\t{\n+\t  delete_jump_thread_path (path);\n+\t  paths.unordered_remove (i);\n+\t}\n+      else if ((*path)[0]->type != EDGE_FSM_THREAD\n+\t       && (*path)[0]->e->dest == bb)\n+\t{\n+\t  delete_jump_thread_path (path);\n+\t  paths.unordered_remove (i);\n+\t}\n+      else\n+\ti++;\n+    }\n+}\n+\n /* Walk through all blocks and thread incoming edges to the appropriate\n    outgoing edge for each edge pair recorded in THREADED_EDGES.\n "}, {"sha": "30428e8bcbf953a38b45164d00dcc958ca0da440", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d64f8dd280e6d2d70aec5b133e913b1af51832d9/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=d64f8dd280e6d2d70aec5b133e913b1af51832d9", "patch": "@@ -43,5 +43,7 @@ class jump_thread_edge\n };\n \n extern void register_jump_thread (vec <class jump_thread_edge *> *);\n+extern void remove_jump_threads_starting_at (basic_block);\n extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);\n+extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);\n #endif"}]}