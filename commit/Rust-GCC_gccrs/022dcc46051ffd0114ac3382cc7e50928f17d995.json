{"sha": "022dcc46051ffd0114ac3382cc7e50928f17d995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyZGNjNDYwNTFmZmQwMTE0YWMzMzgyY2M3ZTUwOTI4ZjE3ZDk5NQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-02-28T11:40:29Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-02-28T11:40:29Z"}, "message": "expr.c (java_array_data_offset): Removed function.\n\n\t* expr.c (java_array_data_offset): Removed function.\n\t(JAVA_ARRAY_LENGTH_OFFSET): Removed macro.\n\t(build_java_array_length_access): Obtain \"length\" value using a\n\tCOMPONENT_REF, instead of INDIRECT_REF and arithmetic.\n\t(build_java_arrayaccess): Correct comment. Access \"data\" using a\n\tCOMPONENT_REF, and return an ARRAY_REF instead of an INDIRECT_REF.\n\t(build_java_arraystore_check): New function.\n\t(expand_java_arraystore): Use build_java_arraystore_check.\n\t* parse.y (patch_assignment): Simplify code to insert a store check\n\twhen lvalue is an ARRAY_REF. Use build_java_arraystore_check.\n\t* check-init.c (check_init): Update to reflect that an array length\n\taccess is now a COMPONENT_REF.\n\t* gcj.texi (Code Generation): Improve documentation of\n\t-fno-bounds-check. Add documentation for -fno-store-check.\n\t* java-tree.h (flag_store_check): Declare.\n\t(build_java_arraystore_check): Declare.\n\t* lang.c (flag_store_check): Initialize to 1.\n\t(lang_f_options): Add store-check option.\n\t* jvspec.c: Don't pass store-check option to jvgenmain.\n\t* lang-options.h: Add help string for -fno-store-check.\n\nFrom-SVN: r50129", "tree": {"sha": "6daf1252f43021f81274da35d2f5f16541eaedb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6daf1252f43021f81274da35d2f5f16541eaedb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/022dcc46051ffd0114ac3382cc7e50928f17d995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022dcc46051ffd0114ac3382cc7e50928f17d995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/022dcc46051ffd0114ac3382cc7e50928f17d995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022dcc46051ffd0114ac3382cc7e50928f17d995/comments", "author": null, "committer": null, "parents": [{"sha": "70da1d030dfa76bd605100e3969df62b6aaa2512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70da1d030dfa76bd605100e3969df62b6aaa2512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70da1d030dfa76bd605100e3969df62b6aaa2512"}], "stats": {"total": 293, "additions": 163, "deletions": 130}, "files": [{"sha": "2250b1d8ee7dd15725b064cab33525717aa5f6d2", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -1,3 +1,26 @@\n+2002-02-28  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* expr.c (java_array_data_offset): Removed function.\n+\t(JAVA_ARRAY_LENGTH_OFFSET): Removed macro.\n+\t(build_java_array_length_access): Obtain \"length\" value using a\n+\tCOMPONENT_REF, instead of INDIRECT_REF and arithmetic.\n+\t(build_java_arrayaccess): Correct comment. Access \"data\" using a\n+\tCOMPONENT_REF, and return an ARRAY_REF instead of an INDIRECT_REF.\n+\t(build_java_arraystore_check): New function.\n+\t(expand_java_arraystore): Use build_java_arraystore_check.\n+\t* parse.y (patch_assignment): Simplify code to insert a store check\n+\twhen lvalue is an ARRAY_REF. Use build_java_arraystore_check.\n+\t* check-init.c (check_init): Update to reflect that an array length\n+\taccess is now a COMPONENT_REF.\n+\t* gcj.texi (Code Generation): Improve documentation of\n+\t-fno-bounds-check. Add documentation for -fno-store-check.\n+\t* java-tree.h (flag_store_check): Declare.\n+\t(build_java_arraystore_check): Declare.\n+\t* lang.c (flag_store_check): Initialize to 1.\n+\t(lang_f_options): Add store-check option.\n+\t* jvspec.c: Don't pass store-check option to jvgenmain.\n+\t* lang-options.h: Add help string for -fno-store-check.\n+\n 2002-02-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* decl.c (copy_lang_decl): Rename java_dup_lang_specific_decl.\n@@ -20,7 +43,7 @@\n \n 2002-02-22  Per Bothner  <per@bothner.com>\n \n-\t*  class.c:  Change vtable to be more compatible with g++ v3 abi.\n+\t* class.c:  Change vtable to be more compatible with g++ v3 abi.\n \t(get_dispatch_table):  Prepend offset-to-top (always 0) and\n \ttype_info pointer (currently unimplemented hence NULL) to vtable.\n \tSpecifically, prepend offset-to-top and typeinfo ptr (currently null)."}, {"sha": "679353355c890d83d8b1c66ee7cadd10ed240683", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -558,7 +558,7 @@ check_init (exp, before)\n \t    final_assign_error (DECL_NAME (decl));\n \t  break;\n \t}\n-      else if (TREE_CODE (tmp) == INDIRECT_REF && IS_ARRAY_LENGTH_ACCESS (tmp))\n+      else if (TREE_CODE (tmp) == COMPONENT_REF && IS_ARRAY_LENGTH_ACCESS (tmp))\n \t{\n \t  /* We can't emit a more specific message here, because when\n \t     compiling to bytecodes we don't get here. */"}, {"sha": "80b2910872568a0ae45187f4ee3a61f612435437", "filename": "gcc/java/expr.c", "status": "modified", "additions": 89, "deletions": 51, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -79,7 +79,6 @@ static void java_push_constant_from_pool PARAMS ((struct JCF *, int));\n static void java_stack_pop PARAMS ((int)); \n static tree build_java_throw_out_of_bounds_exception PARAMS ((tree)); \n static tree build_java_check_indexed_type PARAMS ((tree, tree)); \n-static tree java_array_data_offset PARAMS ((tree)); \n static tree case_identity PARAMS ((tree, tree)); \n static unsigned char peek_opcode_at_pc PARAMS ((struct JCF *, int, int));\n static bool emit_init_test_initialization PARAMS ((struct hash_entry *,\n@@ -628,11 +627,6 @@ build_java_ret (location)\n  \n /* Implementation of operations on array: new, load, store, length */\n \n-/* Array core info access macros */\n-\n-#define JAVA_ARRAY_LENGTH_OFFSET(A) \\\n-  byte_position (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (TREE_TYPE (A)))))\n-\n tree\n decode_newarray_type (atype)\n   int atype;\n@@ -699,6 +693,7 @@ build_java_array_length_access (node)\n     tree node;\n {\n   tree type = TREE_TYPE (node);\n+  tree array_type = TREE_TYPE (type);\n   HOST_WIDE_INT length;\n \n   if (!is_array_type_p (type))\n@@ -707,13 +702,13 @@ build_java_array_length_access (node)\n   length = java_array_type_length (type);\n   if (length >= 0)\n     return build_int_2 (length, 0);\n-  node = build1 (INDIRECT_REF, int_type_node,\n-\t\t fold (build (PLUS_EXPR, ptr_type_node,\n-\t\t\t      java_check_reference (node, \n-\t\t\t\t\t\t    flag_check_references), \n-\t\t\t      JAVA_ARRAY_LENGTH_OFFSET(node))));\n+\n+  node = build (COMPONENT_REF, int_type_node,\n+\t\tbuild_java_indirect_ref (array_type, node,\n+\t\t\t\t\t flag_check_references),\n+\t\tlookup_field (&array_type, get_identifier (\"length\")));\n   IS_ARRAY_LENGTH_ACCESS (node) = 1;\n-  return fold (node);\n+  return node;\n }\n \n /* Optionally checks a reference against the NULL pointer.  ARG1: the\n@@ -752,19 +747,6 @@ build_java_indirect_ref (type, expr, check)\n   return build1 (INDIRECT_REF, type, java_check_reference (expr, check));\n }\n \n-static tree\n-java_array_data_offset (array)\n-     tree array;\n-{\n-  tree array_type = TREE_TYPE (TREE_TYPE (array));\n-  tree data_fld = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (array_type)));\n-\n-  if (data_fld == NULL_TREE)\n-    return size_in_bytes (array_type);\n-  else\n-    return byte_position (data_fld);\n-}\n-\n /* Implement array indexing (either as l-value or r-value).\n    Returns a tree for ARRAY[INDEX], assume TYPE is the element type.\n    Optionally performs bounds checking and/or test to NULL.\n@@ -774,12 +756,10 @@ tree\n build_java_arrayaccess (array, type, index)\n     tree array, type, index;\n {\n-  tree arith, node, throw = NULL_TREE;\n-\n-  arith = fold (build (PLUS_EXPR, int_type_node,\n-\t\t       java_array_data_offset (array),\n-\t\t       fold (build (MULT_EXPR, int_type_node,\n-\t\t\t\t    index, size_in_bytes(type)))));\n+  tree node, throw = NULL_TREE;\n+  tree data_field;\n+  tree ref;\n+  tree array_type = TREE_TYPE (TREE_TYPE (array));\n \n   if (flag_bounds_check)\n     {\n@@ -803,23 +783,86 @@ build_java_arrayaccess (array, type, index)\n \t}\n     }\n \n-  /* The SAVE_EXPR is for correct evaluation order.  It would be\n-     cleaner to use force_evaluation_order (see comment there), but\n-     that is difficult when we also have to deal with bounds\n-     checking. The SAVE_EXPR is not necessary to do that when we're\n-     not checking for array bounds. */\n-  if (TREE_SIDE_EFFECTS (index) && throw)\n-    throw = build (COMPOUND_EXPR, int_type_node, save_expr (array), throw);\n-\n-  node = build1 (INDIRECT_REF, type, \n-\t\t fold (build (PLUS_EXPR, ptr_type_node, \n-\t\t\t      java_check_reference (array,\n-\t\t\t\t\t\t    flag_check_references), \n-\t\t\t      (throw ? build (COMPOUND_EXPR, int_type_node, \n-\t\t\t\t\t      throw, arith ) : arith))));\n+  /* If checking bounds, wrap the index expr with a COMPOUND_EXPR in order\n+     to have the bounds check evaluated first. */\n+  if (throw != NULL_TREE)\n+    index = build (COMPOUND_EXPR, int_type_node, throw, index);\n+ \n+  data_field = lookup_field (&array_type, get_identifier (\"data\"));\n+\n+  ref = build (COMPONENT_REF, TREE_TYPE (data_field),    \n+\t       build_java_indirect_ref (array_type, array, \n+\t\t\t\t\tflag_check_references),\n+\t       data_field);\n+  \n+  node = build (ARRAY_REF, type, ref, index);\n   return node;\n }\n \n+/* Generate code to throw an ArrayStoreException if OBJECT is not assignable\n+   (at runtime) to an element of ARRAY.  A NOP_EXPR is returned if it can\n+   determine that no check is required. */\n+\n+tree\n+build_java_arraystore_check (array, object)\n+   tree array; \n+   tree object;\n+{\n+  tree check, element_type;\n+  tree array_type_p = TREE_TYPE (array);\n+  tree object_type = TYPE_NAME (TREE_TYPE (TREE_TYPE (object)));\n+\n+  if (! is_array_type_p (array_type_p))\n+    abort ();\n+\n+  /* Get the TYPE_DECL for ARRAY's element type. */\n+  element_type = TYPE_NAME (TREE_TYPE (TREE_TYPE (TREE_TYPE (array_type_p))));\n+\n+  if (TREE_CODE (element_type) != TYPE_DECL   \n+      || TREE_CODE (object_type) != TYPE_DECL)\n+    abort ();\n+\n+  if (!flag_store_check)\n+  return build1 (NOP_EXPR, array_type_p, array);\n+\n+  /* No check is needed if the element type is final or is itself an array.  \n+     Also check that element_type matches object_type, since in the bytecode \n+     compilation case element_type may be the actual element type of the arra\n+     rather than its declared type. */\n+  if (element_type == object_type\n+      && (TYPE_ARRAY_P (TREE_TYPE (element_type))\n+\t || CLASS_FINAL (element_type)))\n+    return build1 (NOP_EXPR, array_type_p, array);\n+  \n+  /* Avoid the check if OBJECT was just loaded from the same array. */\n+  if (TREE_CODE (object) == ARRAY_REF)\n+    {\n+      tree target;\n+      tree source = TREE_OPERAND (object, 0); /* COMPONENT_REF. */\n+      source = TREE_OPERAND (source, 0); /* INDIRECT_REF. */\n+      source = TREE_OPERAND (source, 0); /* Source array's DECL or SAVE_EXPR. */\n+      if (TREE_CODE (source) == SAVE_EXPR)\n+\tsource = TREE_OPERAND (source, 0);\n+      \n+      target = array;\n+      if (TREE_CODE (target) == SAVE_EXPR)\n+\ttarget = TREE_OPERAND (target, 0);\n+      \n+      if (source == target)\n+      return build1 (NOP_EXPR, array_type_p, array);\n+    }\n+\n+  /* Build an invocation of _Jv_CheckArrayStore */\n+  check = build (CALL_EXPR, void_type_node,\n+\t\t build_address_of (soft_checkarraystore_node),\n+\t\t tree_cons (NULL_TREE, array,\n+\t\t \t    build_tree_list (NULL_TREE, object)),\n+\t\t NULL_TREE);\n+  TREE_SIDE_EFFECTS (check) = 1;\n+\n+  return check;\n+}\n+\n /* Makes sure that INDEXED_TYPE is appropriate. If not, make it from\n    ARRAY_NODE. This function is used to retrieve something less vague than\n    a pointer type when indexing the first dimension of something like [[<t>.\n@@ -973,12 +1016,7 @@ expand_java_arraystore (rhs_type_node)\n \n   if (TREE_CODE (rhs_type_node) == POINTER_TYPE)\n     {\n-      tree check = build (CALL_EXPR, void_type_node,\n-\t\t\t  build_address_of (soft_checkarraystore_node),\n-\t\t\t  tree_cons (NULL_TREE, array,\n-\t\t\t\t     build_tree_list (NULL_TREE, rhs_node)),\n-\t\t\t  NULL_TREE);\n-      TREE_SIDE_EFFECTS (check) = 1;\n+      tree check = build_java_arraystore_check (array, rhs_node);\n       expand_expr_stmt (check);\n     }\n   "}, {"sha": "e88e8fb2cde0f0a74058bba562636a8f425b2060", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -392,9 +392,20 @@ directory.\n \n @item -fno-bounds-check\n By default, @code{gcj} generates code which checks the bounds of all\n-array indexing operations.  With this option, these checks are omitted.\n-Note that this can result in unpredictable behavior if the code in\n-question actually does violate array bounds constraints.\n+array indexing operations.  With this option, these checks are omitted, which\n+can improve performance for code that uses arrays extensively.  Note that this \n+can result in unpredictable behavior if the code in question actually does \n+violate array bounds constraints.  It is safe to use this option if you are \n+sure that your code will never throw an @code{ArrayIndexOutOfBoundsException}.\n+\n+@item -fno-store-check\n+Don't generate array store checks.  When storing objects into arrays, a runtime\n+check is normally generated in order to ensure that the object is assignment\n+compatible with the component type of the array (which may not be known\n+at compile-time).  With this option, these checks are omitted.  This can \n+improve performance for code which stores objects into arrays frequently.\n+It is safe to use this option if you are sure your code will never throw an \n+@code{ArrayStoreException}.\n \n @item -fjni\n With @code{gcj} there are two options for writing native methods: CNI"}, {"sha": "898c851cc9ec0a2f03571be06626d445e71eda4e", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -213,6 +213,9 @@ extern int flag_optimize_sci;\n    in order to improve binary compatibility. */\n extern int flag_indirect_dispatch;\n \n+/* When zero, don't generate runtime array store checks. */\n+extern int flag_store_check;\n+\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -1107,6 +1110,7 @@ extern tree build_java_binop PARAMS ((enum tree_code, tree, tree, tree));\n extern tree build_java_soft_divmod PARAMS ((enum tree_code, tree, tree, tree));\n extern tree binary_numeric_promotion PARAMS ((tree, tree, tree *, tree *));\n extern tree build_java_arrayaccess PARAMS ((tree, tree, tree));\n+extern tree build_java_arraystore_check PARAMS ((tree, tree));\n extern tree build_newarray PARAMS ((int, tree));\n extern tree build_anewarray PARAMS ((tree, tree));\n extern tree build_new_array PARAMS ((tree, tree));"}, {"sha": "202c7c8e0475ba0cc7361542dbf3e64e7ce7543a", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -66,6 +66,7 @@ static const char jvgenmain_spec[] =\n \t\t   %{<femit-class-file} %{<femit-class-files} %{<fencoding*}\\\n \t\t   %{<fuse-boehm-gc} %{<fhash-synchronization} %{<fjni}\\\n \t\t   %{<findirect-dispatch} \\\n+\t\t   %{<fno-store-check}\\\n \t\t   %{<fclasspath*} %{<fCLASSPATH*} %{<foutput-class-dir}\\\n \t\t   %{<fuse-divide-subroutine} %{<fno-use-divide-subroutine}\\\n \t\t   %{<fcheck-references} %{<fno-check-references}\\"}, {"sha": "3397fa8def85d13bd212210e3e36c2464ded0cd9", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -30,6 +30,8 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-fbounds-check\", \"\" },\n   { \"-fno-bounds-check\",\n     N_(\"Disable automatic array bounds checking\") },\n+  { \"-fno-store-check\",\n+    N_(\"Disable assignability checks for stores into object arrays\") },\n   { \"-fjni\",\n     N_(\"Assume native functions are implemented using JNI\") },\n   { \"--CLASSPATH\",\n@@ -54,3 +56,5 @@ DEFINE_LANG_NAME (\"Java\")\n     N_(\"Always check for non gcj generated classes archives\") },\n   { \"-fno-optimize-static-class-initialization\",\n     N_(\"Never optimize static class initialization code\") },\n+  { \"-findirect-dispatch\",\n+    N_(\"Use offset tables for virtual method calls\") },"}, {"sha": "9732f1a6eee56c37df57e1a289f4decce7ca31c5", "filename": "gcc/java/lang.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -157,6 +157,9 @@ int flag_optimize_sci = 1;\n    in order to improve binary compatibility. */\n int flag_indirect_dispatch = 0;\n \n+/* When zero, don't generate runtime array store checks. */\n+int flag_store_check = 1;\n+\n /* When non zero, print extra version information.  */\n static int version_flag = 0;\n \n@@ -179,7 +182,8 @@ lang_f_options[] =\n   {\"check-references\", &flag_check_references, 1},\n   {\"force-classes-archive-check\", &flag_force_classes_archive_check, 1},\n   {\"optimize-static-class-initialization\", &flag_optimize_sci, 1 },\n-  {\"indirect-dispatch\", &flag_indirect_dispatch, 1}\n+  {\"indirect-dispatch\", &flag_indirect_dispatch, 1},\n+  {\"store-check\", &flag_store_check, 1}\n };\n \n static const struct string_option"}, {"sha": "d005b4e8f9665ad519ca7657e32289d5dc5adfee", "filename": "gcc/java/parse.y", "status": "modified", "additions": 21, "deletions": 73, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022dcc46051ffd0114ac3382cc7e50928f17d995/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=022dcc46051ffd0114ac3382cc7e50928f17d995", "patch": "@@ -12585,9 +12585,8 @@ patch_assignment (node, wfl_op1)\n     {\n       lhs_type = TREE_TYPE (lvalue);\n     }\n-  /* Or Lhs can be a array access. Should that be lvalue ? FIXME +\n-     comment on reason why */\n-  else if (TREE_CODE (wfl_op1) == ARRAY_REF)\n+  /* Or Lhs can be an array access. */\n+  else if (TREE_CODE (lvalue) == ARRAY_REF)\n     {\n       lhs_type = TREE_TYPE (lvalue);\n       lvalue_from_array = 1;\n@@ -12689,80 +12688,29 @@ patch_assignment (node, wfl_op1)\n       && lvalue_from_array \n       && JREFERENCE_TYPE_P (TYPE_ARRAY_ELEMENT (lhs_type)))\n     {\n-      tree check;\n-      tree base = lvalue;\n+      tree array, store_check, base, index_expr;\n \n-      /* We need to retrieve the right argument for\n-         _Jv_CheckArrayStore.  This is somewhat complicated by bounds\n-         and null pointer checks, both of which wrap the operand in\n-         one layer of COMPOUND_EXPR.  */\n-      if (TREE_CODE (lvalue) == COMPOUND_EXPR)\n-\tbase = TREE_OPERAND (lvalue, 0);\n-      else\n+      /* Get the INDIRECT_REF. */\n+      array = TREE_OPERAND (TREE_OPERAND (lvalue, 0), 0);\n+      /* Get the array pointer expr. */\n+      array = TREE_OPERAND (array, 0);\n+      store_check = build_java_arraystore_check (array, new_rhs);\n+      \n+      index_expr = TREE_OPERAND (lvalue, 1);\n+      \n+      if (TREE_CODE (index_expr) == COMPOUND_EXPR)\n \t{\n-          tree op = TREE_OPERAND (base, 0);\n-\t  \n-          /* We can have a SAVE_EXPR here when doing String +=.  */\n-          if (TREE_CODE (op) == SAVE_EXPR)\n-            op = TREE_OPERAND (op, 0);\n-\t  /* We can have a COMPOUND_EXPR here when doing bounds check. */\n-\t  if (TREE_CODE (op) == COMPOUND_EXPR)\n-\t    op = TREE_OPERAND (op, 1);\n-\t  base = TREE_OPERAND (op, 0);\n-\t  /* Strip the last PLUS_EXPR to obtain the base. */\n-\t  if (TREE_CODE (base) == PLUS_EXPR)\n-\t    base = TREE_OPERAND (base, 0);\n-\t}\n-\n-      /* Build the invocation of _Jv_CheckArrayStore */\n-      new_rhs = save_expr (new_rhs);\n-      check = build (CALL_EXPR, void_type_node,\n-\t\t     build_address_of (soft_checkarraystore_node),\n-\t\t     tree_cons (NULL_TREE, base,\n-\t\t\t\tbuild_tree_list (NULL_TREE, new_rhs)),\n-\t\t     NULL_TREE);\n-      TREE_SIDE_EFFECTS (check) = 1;\n-\n-      /* We have to decide on an insertion point */\n-      if (TREE_CODE (lvalue) == COMPOUND_EXPR)\n-\t{\n-\t  tree t;\n-\t  if (flag_bounds_check)\n-\t    {\n-\t      t = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (lvalue, 1), 0), 0);\n-\t      TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (lvalue, 1), 0), 0) =\n-\t\tbuild (COMPOUND_EXPR, void_type_node, t, check);\n-\t    }\n-\t  else\n-\t    TREE_OPERAND (lvalue, 1) = build (COMPOUND_EXPR, lhs_type,\n-\t\t\t\t\t      check, TREE_OPERAND (lvalue, 1));\n+\t  /* A COMPOUND_EXPR here is a bounds check. The bounds check must \n+\t     happen before the store check, so prepare to insert the store\n+\t     check within the second operand of the existing COMPOUND_EXPR. */\n+\t  base = index_expr;\n \t}\n-      else if (flag_bounds_check)\n-\t{\n-          tree hook = lvalue;\n-          tree compound = TREE_OPERAND (lvalue, 0);\n-          tree bound_check, new_compound;\n-\n-          if (TREE_CODE (compound) == SAVE_EXPR)\n-            {\n-              compound = TREE_OPERAND (compound, 0);\n-              hook = TREE_OPERAND (hook, 0);\n-            }\n-\n-          /* Find the array bound check, hook the original array access. */\n-          bound_check = TREE_OPERAND (compound, 0);\n-          TREE_OPERAND (hook, 0) = TREE_OPERAND (compound, 1);\n-\n-\t  /* Make sure the bound check will happen before the store check */\n-          new_compound =\n-            build (COMPOUND_EXPR, void_type_node, bound_check, check);\n-\n-          /* Re-assemble the augmented array access. */\n-          lvalue = build (COMPOUND_EXPR, TREE_TYPE (lvalue),\n-\t\t\t  new_compound, lvalue);\n-        }\n       else\n-        lvalue = build (COMPOUND_EXPR, TREE_TYPE (lvalue), check, lvalue);\n+        base = lvalue;\n+      \n+      index_expr = TREE_OPERAND (base, 1);\n+      TREE_OPERAND (base, 1) = build (COMPOUND_EXPR, TREE_TYPE (index_expr), \n+\t  \t\t\t      store_check, index_expr);\n     }\n \n   /* Final locals can be used as case values in switch"}]}