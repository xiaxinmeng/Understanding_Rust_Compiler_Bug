{"sha": "915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1MTY3ZjVhNWE4ZjhmNWE0MTA3YjdmYTdkZjdmZTVhYWU2NjM2NQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2005-04-21T21:13:41Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-04-21T21:13:41Z"}, "message": "Index: ChangeLog\n2005-04-21  Geoffrey Keating  <geoffk@apple.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_sync): New.\n\t* config/rs6000/rs6000.c (rs6000_emit_vector_compare): Use\n\tgen_rtx_* not gen_rtx_fmt_*.\n\t(rs6000_emit_vector_select): Likewise.\n\t(rs6000_emit_sync): New.\n\t* config/rs6000/rs6000.md (GPR, INT, INT1): New mode macros.\n\t(larx, stcx, cmp): New mode substitutions.\n\t(UNSPEC_SYNC, UNSPEC_SYNC_OP, UNSPEC_SYNC_SWAP, UNSPEC_LWSYNC,\n\tUNSPEC_ISYNC): New constants.\n\t(rlwinm): Give name.\n\t(memory_barrier, isync, lwsync): New insns.\n\t(sync_compare_and_swap<mode>, sync_lock_test_and_set<mode>): New insn.\n\t(sync_lock_release<mode>): New expander.\n\t(sync_add<mode>, sync_sub<mode>, sync_ior<mode>, sync_and<mode>,\n\tsync_xor<mode>, sync_nand<mode>, sync_old_add<mode>,\n\tsync_old_sub<mode>, sync_old_ior<mode>, sync_old_and<mode>,\n\tsync_old_xor<mode>, sync_old_nand<mode>, sync_new_add<mode>,\n\tsync_new_sub<mode>, sync_new_ior<mode>, sync_new_and<mode>,\n\tsync_new_xor<mode>, sync_new_nand<mode>): New expanders.\n\t(sync_add<mode>_internal, sync_addshort_internal,\n\tsync_sub<mode>_internal, sync_andsi_internal, sync_anddi_internal,\n\tsync_boolsi_internal, sync_booldi_internal, sync_boolc<mode>_internal,\n\tsync_boolc<mode>_internal2, sync_boolcc<mode>_internal): New insns.\n\n\t* doc/md.texi (Standard Names): sync_compare_and_swap's operand 0\n\tis the memory before, not after, the operation.  Clarify\n\tbarrier requirements.\n\nIndex: testsuite/ChangeLog\n2005-04-21  Geoffrey Keating  <geoffk@apple.com>\n\n\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n\tAdd powerpc*.\n\nFrom-SVN: r98527", "tree": {"sha": "20cf5cd81b103fbc656ec31e2f13eca0fb390e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20cf5cd81b103fbc656ec31e2f13eca0fb390e86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fd5bcbe958308c326c07c1b4329500af2b650f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd5bcbe958308c326c07c1b4329500af2b650f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd5bcbe958308c326c07c1b4329500af2b650f8"}], "stats": {"total": 723, "additions": 698, "deletions": 25}, "files": [{"sha": "b182ad3e0930f9825ddd9fbf280878e91db2238f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -1,3 +1,33 @@\n+2005-04-21  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_sync): New.\n+\t* config/rs6000/rs6000.c (rs6000_emit_vector_compare): Use\n+\tgen_rtx_* not gen_rtx_fmt_*.\n+\t(rs6000_emit_vector_select): Likewise.\n+\t(rs6000_emit_sync): New.\n+\t* config/rs6000/rs6000.md (GPR, INT, INT1): New mode macros.\n+\t(larx, stcx, cmp): New mode substitutions.\n+\t(UNSPEC_SYNC, UNSPEC_SYNC_OP, UNSPEC_SYNC_SWAP, UNSPEC_LWSYNC,\n+\tUNSPEC_ISYNC): New constants.\n+\t(rlwinm): Give name.\n+\t(memory_barrier, isync, lwsync): New insns.\n+\t(sync_compare_and_swap<mode>, sync_lock_test_and_set<mode>): New insn.\n+\t(sync_lock_release<mode>): New expander.\n+\t(sync_add<mode>, sync_sub<mode>, sync_ior<mode>, sync_and<mode>,\n+\tsync_xor<mode>, sync_nand<mode>, sync_old_add<mode>,\n+\tsync_old_sub<mode>, sync_old_ior<mode>, sync_old_and<mode>,\n+\tsync_old_xor<mode>, sync_old_nand<mode>, sync_new_add<mode>,\n+\tsync_new_sub<mode>, sync_new_ior<mode>, sync_new_and<mode>,\n+\tsync_new_xor<mode>, sync_new_nand<mode>): New expanders.\n+\t(sync_add<mode>_internal, sync_addshort_internal,\n+\tsync_sub<mode>_internal, sync_andsi_internal, sync_anddi_internal,\n+\tsync_boolsi_internal, sync_booldi_internal, sync_boolc<mode>_internal,\n+\tsync_boolc<mode>_internal2, sync_boolcc<mode>_internal): New insns.\n+\n+\t* doc/md.texi (Standard Names): sync_compare_and_swap's operand 0\n+\tis the memory before, not after, the operation.  Clarify\n+\tbarrier requirements.\n+\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cfghooks.h (struct cfg_hooks): Reword comments to avoid 'abort'."}, {"sha": "63ffe4fb9fc10d2f5f570f1c50b9299ff12b685c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -80,6 +80,8 @@ extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n+extern void rs6000_emit_sync (enum rtx_code, enum machine_mode,\n+\t\t\t      rtx, rtx, rtx, rtx, bool);\n extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern void rs6000_initialize_trampoline (rtx, rtx, rtx);\n extern rtx rs6000_longcall_ref (rtx);"}, {"sha": "fc4683d388b1f6e738470352a1c217a85361dd60", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 185, "deletions": 10, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -10620,12 +10620,10 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t}\n     }\n \n-  emit_insn (gen_rtx_fmt_ee (SET,\n-\t\t\t     VOIDmode,\n-\t\t\t     mask,\n-\t\t\t     gen_rtx_fmt_Ei (UNSPEC, dest_mode,\n-\t\t\t\t\t     gen_rtvec (2, op0, op1),\n-\t\t\t\t\t     vec_cmp_insn)));\n+  emit_insn (gen_rtx_SET (VOIDmode, mask,\n+\t\t\t  gen_rtx_UNSPEC (dest_mode,\n+\t\t\t\t\t  gen_rtvec (2, op0, op1),\n+\t\t\t\t\t  vec_cmp_insn)));\n   if (dmode != dest_mode)\n     {\n       rtx temp = gen_reg_rtx (dest_mode);\n@@ -10676,10 +10674,10 @@ rs6000_emit_vector_select (rtx dest, rtx op1, rtx op2, rtx mask)\n \n   /* For each vector element, select op1 when mask is 1 otherwise \n      select op2.  */\n-  t = gen_rtx_fmt_ee (SET, VOIDmode, temp,\n-\t\t      gen_rtx_fmt_Ei (UNSPEC, dest_mode,\n-\t\t\t\t      gen_rtvec (3, op2, op1, mask),\n-\t\t\t\t      vsel_insn_index));\n+  t = gen_rtx_SET (VOIDmode, temp,\n+\t\t   gen_rtx_UNSPEC (dest_mode,\n+\t\t\t\t   gen_rtvec (3, op2, op1, mask),\n+\t\t\t\t   vsel_insn_index));\n   emit_insn (t);\n   emit_move_insn (dest, temp);\n   return;\n@@ -10960,6 +10958,183 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     emit_move_insn (dest, target);\n }\n \n+/* Emit instructions to perform a load-reserved/store-conditional operation.\n+   The operation performed is an atomic\n+   (set M (CODE:MODE M OP))\n+   If not NULL, BEFORE is atomically set to M before the operation, and\n+   AFTER is set to M after the operation (that is, (CODE:MODE M OP)).\n+   If SYNC_P then a memory barrier is emitted before the operation.  \n+   Either OP or M may be wrapped in a NOT operation.  */\n+\n+void\n+rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n+\t\t  rtx m, rtx op, rtx before_param, rtx after_param,\n+\t\t  bool sync_p)\n+{\n+  enum machine_mode used_mode;\n+  rtx the_op, set_before, set_after, set_atomic, cc_scratch, before, after;\n+  rtx used_m;\n+  rtvec vec;\n+  HOST_WIDE_INT imask = GET_MODE_MASK (mode);\n+  rtx shift = NULL_RTX;\n+  \n+  if (sync_p)\n+    emit_insn (gen_memory_barrier ());\n+  \n+  if (GET_CODE (m) == NOT)\n+    used_m = XEXP (m, 0);\n+  else\n+    used_m = m;\n+\n+  /* If this is smaller than SImode, we'll have to use SImode with\n+     adjustments.  */\n+  if (mode == QImode || mode == HImode)\n+    {\n+      rtx newop, oldop;\n+\n+      if (MEM_ALIGN (used_m) >= 32)\n+\t{\n+\t  int ishift = 0;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    ishift = GET_MODE_BITSIZE (SImode) - GET_MODE_BITSIZE (mode);\n+\t  \n+\t  shift = GEN_INT (ishift);\n+\t}\n+      else\n+\t{\n+\t  rtx addrSI, aligned_addr;\n+\t  \n+\t  addrSI = force_reg (SImode, gen_lowpart_common (SImode,\n+\t\t\t\t\t\t\t  XEXP (used_m, 0)));\n+\t  shift = gen_reg_rtx (SImode);\n+\n+\t  emit_insn (gen_rlwinm (shift, addrSI, GEN_INT (3),\n+\t\t\t\t GEN_INT (0x18)));\n+\n+\t  aligned_addr = expand_binop (Pmode, and_optab,\n+\t\t\t\t       XEXP (used_m, 0),\n+\t\t\t\t       GEN_INT (-4), NULL_RTX,\n+\t\t\t\t       1, OPTAB_LIB_WIDEN);\n+\t  used_m = change_address (used_m, SImode, aligned_addr);\n+\t  set_mem_align (used_m, 32);\n+\t  /* It's safe to keep the old alias set of USED_M, because\n+\t     the operation is atomic and only affects the original\n+\t     USED_M.  */\n+\t  if (GET_CODE (m) == NOT)\n+\t    m = gen_rtx_NOT (SImode, used_m);\n+\t  else\n+\t    m = used_m;\n+\t}\n+\n+      if (GET_CODE (op) == NOT)\n+\t{\n+\t  oldop = lowpart_subreg (SImode, XEXP (op, 0), mode);\n+\t  oldop = gen_rtx_NOT (SImode, oldop);\n+\t}\n+      else\n+\toldop = lowpart_subreg (SImode, op, mode);\n+      switch (code)\n+\t{\n+\tcase IOR:\n+\tcase XOR:\n+\t  newop = expand_binop (SImode, and_optab,\n+\t\t\t\toldop, GEN_INT (imask), NULL_RTX,\n+\t\t\t\t1, OPTAB_LIB_WIDEN);\n+\t  emit_insn (gen_ashlsi3 (newop, newop, shift));\n+\t  break;\n+\n+\tcase AND:\n+\t  newop = expand_binop (SImode, ior_optab,\n+\t\t\t\toldop, GEN_INT (~imask), NULL_RTX,\n+\t\t\t\t1, OPTAB_LIB_WIDEN);\n+\t  emit_insn (gen_ashlsi3 (newop, newop, shift));\n+\t  break;\n+\n+\tcase PLUS:\n+\t  {\n+\t    rtx mask;\n+\t    \n+\t    newop = expand_binop (SImode, and_optab,\n+\t\t\t\t  oldop, GEN_INT (imask), NULL_RTX,\n+\t\t\t\t  1, OPTAB_LIB_WIDEN);\n+\t    emit_insn (gen_ashlsi3 (newop, newop, shift));\n+\n+\t    mask = gen_reg_rtx (SImode);\n+\t    emit_move_insn (mask, GEN_INT (imask));\n+\t    emit_insn (gen_ashlsi3 (mask, mask, shift));\n+\n+\t    newop = gen_rtx_AND (SImode, gen_rtx_PLUS (SImode, m, newop),\n+\t\t\t\t mask);\n+\t    newop = gen_rtx_IOR (SImode, newop,\n+\t\t\t\t gen_rtx_AND (SImode,\n+\t\t\t\t\t      gen_rtx_NOT (SImode, mask),\n+\t\t\t\t\t      m));\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      op = newop;\n+      used_mode = SImode;\n+      before = gen_reg_rtx (used_mode);\n+      after = gen_reg_rtx (used_mode);\n+    }\n+  else\n+    {\n+      used_mode = mode;\n+      before = before_param;\n+      after = after_param;\n+\n+      if (before == NULL_RTX)\n+\tbefore = gen_reg_rtx (used_mode);\n+      if (after == NULL_RTX)\n+\tafter = gen_reg_rtx (used_mode);\n+    }\n+  \n+  if (code == PLUS && used_mode != mode)\n+    the_op = op;  /* Computed above.  */\n+  else if (GET_CODE (op) == NOT && GET_CODE (m) != NOT)\n+    the_op = gen_rtx_fmt_ee (code, used_mode, op, m);\n+  else\n+    the_op = gen_rtx_fmt_ee (code, used_mode, m, op);\n+\n+  set_after = gen_rtx_SET (VOIDmode, after, the_op);\n+  set_before = gen_rtx_SET (VOIDmode, before, used_m);\n+  set_atomic = gen_rtx_SET (VOIDmode, used_m,\n+\t\t\t    gen_rtx_UNSPEC (used_mode, gen_rtvec (1, the_op),\n+\t\t\t\t\t    UNSPEC_SYNC_OP));\n+  cc_scratch = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (CCmode));\n+\n+  if (code == PLUS && used_mode != mode)\n+    vec = gen_rtvec (5, set_after, set_before, set_atomic, cc_scratch,\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (SImode)));\n+  else\n+    vec = gen_rtvec (4, set_after, set_before, set_atomic, cc_scratch);\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+\n+  /* Shift and mask the return values properly.  */\n+  if (used_mode != mode && before_param)\n+    {\n+      emit_insn (gen_lshrsi3 (before, before, shift));\n+      convert_move (before_param, before, 1);\n+    }\n+\n+  if (used_mode != mode && after_param)\n+    {\n+      emit_insn (gen_lshrsi3 (after, after, shift));\n+      convert_move (after_param, after, 1);\n+    }\n+\n+  /* The previous sequence will end with a branch that's dependent on\n+     the conditional store, so placing an isync will ensure that no\n+     other instructions (especially, no load or store instructions)\n+     can start before the atomic operation completes.  */\n+  if (sync_p)\n+    emit_insn (gen_isync ());\n+}\n+\n /* Emit instructions to move SRC to DST.  Called by splitters for\n    multi-register moves.  It will emit at most one instruction for\n    each register that is accessed; that is, it won't emit li/lis pairs"}, {"sha": "aabe7cb6e1ddedfa7439f134861000a52cc4ca11", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 453, "deletions": 3, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -52,6 +52,11 @@\n    (UNSPEC_FIX_TRUNC_TF\t\t30)\t; fadd, rounding towards zero\n    (UNSPEC_MV_CR_GT\t\t31)\t; move_from_CR_eq_bit\n    (UNSPEC_STFIWX\t\t32)\n+   (UNSPEC_SYNC\t\t\t33)\n+   (UNSPEC_SYNC_OP\t\t34)\n+   (UNSPEC_SYNC_SWAP\t\t35)\n+   (UNSPEC_LWSYNC\t\t36)\n+   (UNSPEC_ISYNC\t\t37)\n   ])\n \n ;;\n@@ -108,10 +113,28 @@\n (include \"darwin.md\")\n \n \f\n-;; This mode macro allows :P to be used for patterns that operate on\n-;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n+;; Mode macros\n+\n+; This mode macro allows :GPR to be used to indicate the allowable size\n+; of whole values in GPRs.\n+(define_mode_macro GPR [SI (DI \"TARGET_POWERPC64\")])\n+\n+; Any supported integer mode\n+(define_mode_macro INT [QI HI SI DI TI])\n+\n+; Any supported integer mode that fits in one register\n+(define_mode_macro INT1 [QI HI SI (DI \"TARGET_POWERPC64\")])\n+\n+; This mode macro allows :P to be used for patterns that operate on\n+; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n \n+; Various instructions that come in SI and DI forms.\n+(define_mode_attr larx [(SI \"lwarx\") (DI \"ldarx\")])\n+(define_mode_attr stcx [(SI \"stwcx.\") (DI \"stdcx.\")])\n+(define_mode_attr cmp [(SI \"cmpw\") (DI \"cmpd\")])\n+\n+\f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n \n@@ -3742,7 +3765,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"rlwinm\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:SI (ashift:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n@@ -14733,6 +14756,433 @@\n   return INTVAL (operands[1]) ? \\\"dcbtst %a0\\\" : \\\"dcbt %a0\\\";\n }\"\n   [(set_attr \"type\" \"load\")])\n+\f\n+; Atomic instructions\n+\n+(define_insn \"memory_barrier\"\n+  [(set (mem:BLK (match_scratch 0 \"X\"))\n+\t(unspec:BLK [(mem:BLK (match_scratch 1 \"X\"))] UNSPEC_SYNC))]\n+  \"\"\n+  \"{ics|sync}\")\n+\n+(define_insn \"sync_compare_and_swap<mode>\"\n+  [(set (match_operand:GPR 1 \"memory_operand\" \"+Z\")\n+\t(unspec:GPR [(match_dup 1)\n+\t\t     (match_operand:GPR 2 \"reg_or_short_operand\" \"rI\")\n+\t\t     (match_operand:GPR 3 \"gpc_reg_operand\" \"r\")]\n+\t\t    UNSPEC_SYNC_SWAP))\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=&r\") (match_dup 1))\n+   (set (mem:BLK (match_scratch 5 \"X\"))\n+\t(unspec:BLK [(mem:BLK (match_scratch 6 \"X\"))] UNSPEC_SYNC))\n+   (clobber (match_scratch:CC 4 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"sync\\n0:\\t<larx> %0,%y1\\n\\t<cmp>%I2 %0,%2\\n\\tbne- 1f\\n\\t<stcx> %3,%y1\\n\\tbne- 0b\\n\\t1:\\tisync\"\n+  [(set_attr \"length\" \"28\")])\n+\n+(define_expand \"sync_add<mode>\"\n+  [(use (match_operand:INT1 0 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"add_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (PLUS, <MODE>mode, operands[0], operands[1], \n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_sub<mode>\"\n+  [(use (match_operand:GPR 0 \"memory_operand\" \"\"))\n+   (use (match_operand:GPR 1 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (MINUS, <MODE>mode, operands[0], operands[1], \n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_ior<mode>\"\n+  [(use (match_operand:INT1 0 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (IOR, <MODE>mode, operands[0], operands[1], \n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_and<mode>\"\n+  [(use (match_operand:INT1 0 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"and_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, operands[0], operands[1], \n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_xor<mode>\"\n+  [(use (match_operand:INT1 0 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (XOR, <MODE>mode, operands[0], operands[1], \n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_nand<mode>\"\n+  [(use (match_operand:INT1 0 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, \n+\t\t    gen_rtx_NOT (<MODE>mode, operands[0]),\n+\t\t    operands[1],\n+\t\t    NULL_RTX, NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_add<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"add_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (PLUS, <MODE>mode, operands[1], operands[2], \n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_sub<mode>\"\n+  [(use (match_operand:GPR 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:GPR 1 \"memory_operand\" \"\"))\n+   (use (match_operand:GPR 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (MINUS, <MODE>mode, operands[1], operands[2], \n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_ior<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (IOR, <MODE>mode, operands[1], operands[2], \n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_and<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"and_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, operands[1], operands[2], \n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_xor<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (XOR, <MODE>mode, operands[1], operands[2], \n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_old_nand<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, \n+\t\t    gen_rtx_NOT (<MODE>mode, operands[1]),\n+\t\t    operands[2],\n+\t\t    operands[0], NULL_RTX, true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_add<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"add_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (PLUS, <MODE>mode, operands[1], operands[2], \n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_sub<mode>\"\n+  [(use (match_operand:GPR 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:GPR 1 \"memory_operand\" \"\"))\n+   (use (match_operand:GPR 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (MINUS, <MODE>mode, operands[1], operands[2], \n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_ior<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (IOR, <MODE>mode, operands[1], operands[2], \n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_and<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"and_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, operands[1], operands[2], \n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_xor<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"logical_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (XOR, <MODE>mode, operands[1], operands[2], \n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+(define_expand \"sync_new_nand<mode>\"\n+  [(use (match_operand:INT1 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:INT1 1 \"memory_operand\" \"\"))\n+   (use (match_operand:INT1 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  rs6000_emit_sync (AND, <MODE>mode, \n+\t\t    gen_rtx_NOT (<MODE>mode, operands[1]),\n+\t\t    operands[2],\n+\t\t    NULL_RTX, operands[0], true);\n+  DONE;\n+}\")\n+\n+; the sync_*_internal patterns all have these operands:\n+; 0 - memory location\n+; 1 - operand\n+; 2 - value in memory after operation\n+; 3 - value in memory immediately before operation\n+\n+(define_insn \"*sync_add<mode>_internal\"\n+  [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r,&r\")\n+\t(plus:GPR (match_operand:GPR 0 \"memory_operand\" \"+Z,Z\")\n+\t\t (match_operand:GPR 1 \"add_operand\" \"rI,L\")))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"=&b,&b\") (match_dup 0))\n+   (set (match_dup 0) \n+\t(unspec:GPR [(plus:GPR (match_dup 0) (match_dup 1))]\n+\t\t   UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 4 \"=&x,&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"@\n+   0:\\t<larx> %3,%y0\\n\\tadd%I1 %2,%3,%1\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\n+   0:\\t<larx> %3,%y0\\n\\taddis %2,%3,%v1\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16,16\")])\n+\n+(define_insn \"*sync_addshort_internal\"\n+  [(set (match_operand:SI 2 \"gpc_reg_operand\" \"=&r\")\n+\t(ior:SI (and:SI (plus:SI (match_operand:SI 0 \"memory_operand\" \"+Z\")\n+\t\t\t\t (match_operand:SI 1 \"add_operand\" \"rI\"))\n+\t\t\t(match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n+\t\t(and:SI (not:SI (match_dup 4)) (match_dup 0))))\n+   (set (match_operand:SI 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) \n+\t(unspec:SI [(ior:SI (and:SI (plus:SI (match_dup 0) (match_dup 1))\n+\t\t\t\t    (match_dup 4))\n+\t\t\t    (and:SI (not:SI (match_dup 4)) (match_dup 0)))]\n+\t\t   UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x\"))\n+   (clobber (match_scratch:SI 6 \"=&r\"))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\tlwarx %3,%y0\\n\\tadd%I1 %2,%3,%1\\n\\tandc %6,%3,%4\\n\\tand %2,%2,%4\\n\\tor %2,%2,%6\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"28\")])\n+\n+(define_insn \"*sync_sub<mode>_internal\"\n+  [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r\")\n+\t(minus:GPR (match_operand:GPR 0 \"memory_operand\" \"+Z\")\n+\t\t  (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) \n+\t(unspec:GPR [(minus:GPR (match_dup 0) (match_dup 1))]\n+\t\t   UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 4 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\t<larx> %3,%y0\\n\\tsubf %2,%1,%3\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"*sync_andsi_internal\"\n+  [(set (match_operand:SI 2 \"gpc_reg_operand\" \"=&r,&r,&r,&r\")\n+\t(and:SI (match_operand:SI 0 \"memory_operand\" \"+Z,Z,Z,Z\")\n+\t\t(match_operand:SI 1 \"and_operand\" \"r,T,K,L\")))\n+   (set (match_operand:SI 3 \"gpc_reg_operand\" \"=&b,&b,&b,&b\") (match_dup 0))\n+   (set (match_dup 0) \n+\t(unspec:SI [(and:SI (match_dup 0) (match_dup 1))]\n+\t\t   UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 4 \"=&x,&x,&x,&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"@\n+   0:\\tlwarx %3,%y0\\n\\tand %2,%3,%1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tlwarx %3,%y0\\n\\trlwinm %2,%3,0,%m1,%M1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tlwarx %3,%y0\\n\\tandi. %2,%3,%b1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tlwarx %3,%y0\\n\\tandis. %2,%3,%u1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16,16,16,16\")])\n+\n+(define_insn \"*sync_anddi_internal\"\n+  [(set (match_operand:DI 2 \"gpc_reg_operand\" \"=&r,&r,&r,&r,&r\")\n+\t(and:DI (match_operand:DI 0 \"memory_operand\" \"+Z,Z,Z,Z,Z\")\n+\t\t(match_operand:DI 1 \"and_operand\" \"r,S,T,K,J\")))\n+   (set (match_operand:DI 3 \"gpc_reg_operand\" \"=&b,&b,&b,&b,&b\") (match_dup 0))\n+   (set (match_dup 0) \n+\t(unspec:DI [(and:DI (match_dup 0) (match_dup 1))]\n+\t\t   UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 4 \"=&x,&x,&x,&x,&x\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   0:\\tldarx %3,%y0\\n\\tand %2,%3,%1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\trldic%B1 %2,%3,0,%S1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\trlwinm %2,%3,0,%m1,%M1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\tandi. %2,%3,%b1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\tandis. %2,%3,%b1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16,16,16,16,16\")])\n+\n+(define_insn \"*sync_boolsi_internal\"\n+  [(set (match_operand:SI 2 \"gpc_reg_operand\" \"=&r,&r,&r\")\n+\t(match_operator:SI 4 \"boolean_or_operator\"\n+\t [(match_operand:SI 0 \"memory_operand\" \"+Z,Z,Z\")\n+\t  (match_operand:SI 1 \"logical_operand\" \"r,K,L\")]))\n+   (set (match_operand:SI 3 \"gpc_reg_operand\" \"=&b,&b,&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:SI [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x,&x,&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"@\n+   0:\\tlwarx %3,%y0\\n\\t%q4 %2,%3,%1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tlwarx %3,%y0\\n\\t%q4i %2,%3,%b1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tlwarx %3,%y0\\n\\t%q4is %2,%3,%u1\\n\\tstwcx. %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16,16,16\")])\n+\n+(define_insn \"*sync_booldi_internal\"\n+  [(set (match_operand:DI 2 \"gpc_reg_operand\" \"=&r,&r,&r\")\n+\t(match_operator:DI 4 \"boolean_or_operator\"\n+\t [(match_operand:DI 0 \"memory_operand\" \"+Z,Z,Z\")\n+\t  (match_operand:DI 1 \"logical_operand\" \"r,K,JF\")]))\n+   (set (match_operand:DI 3 \"gpc_reg_operand\" \"=&b,&b,&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:DI [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x,&x,&x\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   0:\\tldarx %3,%y0\\n\\t%q4 %2,%3,%1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\t%q4i %2,%3,%b1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\n+   0:\\tldarx %3,%y0\\n\\t%q4is %2,%3,%u1\\n\\tstdcx. %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16,16,16\")])\n+\n+(define_insn \"*sync_boolc<mode>_internal\"\n+  [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r\")\n+\t(match_operator:GPR 4 \"boolean_operator\"\n+\t [(not:GPR (match_operand:GPR 0 \"memory_operand\" \"+Z\"))\n+\t  (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")]))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:GPR [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\t<larx> %3,%y0\\n\\t%q4 %2,%1,%3\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"*sync_boolc<mode>_internal2\"\n+  [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r\")\n+\t(match_operator:GPR 4 \"boolean_operator\"\n+\t [(not:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\"))\n+\t  (match_operand:GPR 0 \"memory_operand\" \"+Z\")]))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:GPR [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\t<larx> %3,%y0\\n\\t%q4 %2,%3,%1\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"*sync_boolcc<mode>_internal\"\n+  [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r\")\n+\t(match_operator:GPR 4 \"boolean_operator\"\n+\t [(not:GPR (match_operand:GPR 0 \"memory_operand\" \"+Z\"))\n+\t  (not:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\"))]))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:GPR [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 5 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\t<larx> %3,%y0\\n\\t%q4 %2,%1,%3\\n\\t<stcx> %2,%y0\\n\\tbne- 0b\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"isync\"\n+  [(set (mem:BLK (match_scratch 0 \"X\"))\n+        (unspec:BLK [(mem:BLK (match_scratch 1 \"X\"))] UNSPEC_ISYNC))]\n+  \"TARGET_POWERPC\"\n+  \"isync\")\n+\n+(define_insn \"sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+Z\"))\n+   (set (match_dup 1) (unspec:GPR [(match_operand:GPR 2 \"gpc_reg_operand\" \"r\")] \n+\t\t\t\t UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 3 \"=&x\"))\n+   (set (mem:BLK (match_scratch 4 \"X\"))\n+        (unspec:BLK [(mem:BLK (match_scratch 5 \"X\"))] UNSPEC_ISYNC))]\n+  \"TARGET_POWERPC\"\n+  \"0:\\t<larx> %0,%y1\\n\\t<stcx> %2,%y1\\n\\tbne- 0b\\n\\tisync\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_expand \"sync_lock_release<mode>\"\n+  [(use (match_operand:INT 0 \"memory_operand\"))]\n+  \"\"\n+  \"\n+{\n+  emit_insn (gen_lwsync ());\n+  emit_move_insn (operands[0], CONST0_RTX (<MODE>mode));\n+  DONE;\n+}\")\n+\n+(define_insn \"lwsync\"\n+  [(set (mem:BLK (match_scratch 0 \"X\"))\n+        (unspec:BLK [(mem:BLK (match_scratch 1 \"X\"))] UNSPEC_LWSYNC))]\n+  \"\"\n+  \"lwsync\")\n+\n+\f\n \n (include \"altivec.md\")\n (include \"spe.md\")"}, {"sha": "b29d7e02f987feba9d9a322bab3f2d853f9e93fb", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -3952,14 +3952,16 @@ operation.  Operand 1 is the memory on which the atomic operation is\n performed.  Operand 2 is the ``old'' value to be compared against the\n current contents of the memory location.  Operand 3 is the ``new'' value\n to store in the memory if the compare succeeds.  Operand 0 is the result\n-of the operation; it should contain the current contents of the memory\n-after the operation.  If the compare succeeds, this should obviously be\n-a copy of operand 3.\n+of the operation; it should contain the contents of the memory\n+before the operation.  If the compare succeeds, this should obviously be\n+a copy of operand 2.\n \n This pattern must show that both operand 0 and operand 1 are modified.\n \n-This pattern must issue any memory barrier instructions such that the\n-pattern as a whole acts as a full barrier.\n+This pattern must issue any memory barrier instructions such that all\n+memory operations before the atomic operation occur before the atomic\n+operation and all memory operations after the atomic operation occur\n+after the atomic operation.\n \n @cindex @code{sync_compare_and_swap_cc@var{mode}} instruction pattern\n @item @samp{sync_compare_and_swap_cc@var{mode}}\n@@ -3991,8 +3993,10 @@ Operand 1 is the second operand to the binary operator.\n \n The ``nand'' operation is @code{op0 & ~op1}.\n \n-This pattern must issue any memory barrier instructions such that the\n-pattern as a whole acts as a full barrier.\n+This pattern must issue any memory barrier instructions such that all\n+memory operations before the atomic operation occur before the atomic\n+operation and all memory operations after the atomic operation occur\n+after the atomic operation.\n \n If these patterns are not defined, the operation will be constructed\n from a compare-and-swap operation, if defined.\n@@ -4013,8 +4017,10 @@ Operand 0 is the result value, operand 1 is the memory on which the\n atomic operation is performed, and operand 2 is the second operand\n to the binary operator.\n \n-This pattern must issue any memory barrier instructions such that the\n-pattern as a whole acts as a full barrier.\n+This pattern must issue any memory barrier instructions such that all\n+memory operations before the atomic operation occur before the atomic\n+operation and all memory operations after the atomic operation occur\n+after the atomic operation.\n \n If these patterns are not defined, the operation will be constructed\n from a compare-and-swap operation, if defined.\n@@ -4052,7 +4058,8 @@ an atomic test-and-set bit operation.  The result operand should contain\n The true contents of the memory operand are implementation defined.\n \n This pattern must issue any memory barrier instructions such that the\n-pattern as a whole acts as an acquire barrier.\n+pattern as a whole acts as an acquire barrier, that is all memory\n+operations after the pattern do not occur until the lock is acquired.\n \n If this pattern is not defined, the operation will be constructed from\n a compare-and-swap operation, if defined.\n@@ -4065,7 +4072,8 @@ This pattern, if defined, releases a lock set by\n that contains the lock.\n \n This pattern must issue any memory barrier instructions such that the\n-pattern as a whole acts as a release barrier.\n+pattern as a whole acts as a release barrier, that is the lock is\n+released only after all previous memory operations have completed.\n \n If this pattern is not defined, then a @code{memory_barrier} pattern\n will be emitted, followed by a store of zero to the memory operand."}, {"sha": "61c9bf8c8bd679a12230be2b866a38e4bb2e03e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -1,3 +1,8 @@\n+2005-04-21  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n+\tAdd powerpc*.\n+\n 2005-04-21  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.target/mips/branch-1.c: New test."}, {"sha": "4356aba3cbc0fb712b1ec08b3e38afe53d6c2e5d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915167f5a5a8f8f5a4107b7fa7df7fe5aae66365/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=915167f5a5a8f8f5a4107b7fa7df7fe5aae66365", "patch": "@@ -883,10 +883,13 @@ proc check_effective_target_sync_int_long { } {\n         verbose \"check_effective_target_sync_int_long: using cached result\" 2\n     } else {\n         set et_sync_int_long_saved 0\n+# This is intentionally powerpc but not rs6000, rs6000 doesn't have the\n+# load-reserved/store-conditional instructions.\n         if { [istarget ia64-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*]\n-\t     || [istarget alpha*-*-*] } {\n+\t     || [istarget alpha*-*-*] \n+\t     || [istarget powerpc*-*-*] } {\n            set et_sync_int_long_saved 1\n         }\n     }"}]}