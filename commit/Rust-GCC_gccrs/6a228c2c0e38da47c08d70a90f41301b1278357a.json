{"sha": "6a228c2c0e38da47c08d70a90f41301b1278357a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyMjhjMmMwZTM4ZGE0N2MwOGQ3MGE5MGY0MTMwMWIxMjc4MzU3YQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2011-08-19T14:56:24Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2011-08-19T14:56:24Z"}, "message": "tree-ssa-math-opts.c (convert_mult_to_widen): Better handle unsigned inputs of different modes.\n\n2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Better handle\n\tunsigned inputs of different modes.\n\t(convert_plusminus_to_widen): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/wmul-9.c: New file.\n\t* gcc.target/arm/wmul-bitfield-2.c: New file.\n\nFrom-SVN: r177908", "tree": {"sha": "399ca1eadf9b56228d57ed6b32ae01a3e077b742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/399ca1eadf9b56228d57ed6b32ae01a3e077b742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a228c2c0e38da47c08d70a90f41301b1278357a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a228c2c0e38da47c08d70a90f41301b1278357a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a228c2c0e38da47c08d70a90f41301b1278357a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a228c2c0e38da47c08d70a90f41301b1278357a/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26a855d7e05810f8032ebb8e46a9bf6d18fef50d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a855d7e05810f8032ebb8e46a9bf6d18fef50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a855d7e05810f8032ebb8e46a9bf6d18fef50d"}], "stats": {"total": 73, "additions": 64, "deletions": 9}, "files": [{"sha": "648c3b1803257fadbeb4aa7988dd31abe53e159c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a228c2c0e38da47c08d70a90f41301b1278357a", "patch": "@@ -1,3 +1,9 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Better handle\n+\tunsigned inputs of different modes.\n+\t(convert_plusminus_to_widen): Likewise.\n+\n 2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* tree-ssa-math-opts.c (is_widening_mult_rhs_p): Add new argument"}, {"sha": "2f65d2ec57bf583c569becf277b7f13cba49b734", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a228c2c0e38da47c08d70a90f41301b1278357a", "patch": "@@ -1,3 +1,8 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc.target/arm/wmul-9.c: New file.\n+\t* gcc.target/arm/wmul-bitfield-2.c: New file.\n+\n 2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gcc.target/arm/wmul-8.c: New file."}, {"sha": "40ed0219a8de29951cc5a7ebf7b03bcdc06f2daf", "filename": "gcc/testsuite/gcc.target/arm/wmul-9.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-9.c?ref=6a228c2c0e38da47c08d70a90f41301b1278357a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target arm_dsp } */\n+\n+long long\n+foo (long long a, short *b, char *c)\n+{\n+  return a + *b * *c;\n+}\n+\n+/* { dg-final { scan-assembler \"smlalbb\" } } */"}, {"sha": "07ba9a84d113903d89fc3b12618d1bed7f0fc40e", "filename": "gcc/testsuite/gcc.target/arm/wmul-bitfield-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-2.c?ref=6a228c2c0e38da47c08d70a90f41301b1278357a", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target arm_dsp } */\n+\n+struct bf\n+{\n+  int a : 3;\n+  unsigned int b : 15;\n+  int c : 3;\n+};\n+\n+long long\n+foo (long long a, struct bf b, struct bf c)\n+{\n+  return a + b.b * c.c;\n+}\n+\n+/* { dg-final { scan-assembler \"smlalbb\" } } */"}, {"sha": "5ba31b560b55af503ec4fb142ffbe024e9c86f94", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a228c2c0e38da47c08d70a90f41301b1278357a/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=6a228c2c0e38da47c08d70a90f41301b1278357a", "patch": "@@ -2115,9 +2115,18 @@ convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n     {\n       if (op != smul_widen_optab)\n \t{\n-\t  from_mode = GET_MODE_WIDER_MODE (from_mode);\n-\t  if (GET_MODE_SIZE (to_mode) <= GET_MODE_SIZE (from_mode))\n-\t    return false;\n+\t  /* We can use a signed multiply with unsigned types as long as\n+\t     there is a wider mode to use, or it is the smaller of the two\n+\t     types that is unsigned.  Note that type1 >= type2, always.  */\n+\t  if ((TYPE_UNSIGNED (type1)\n+\t       && TYPE_PRECISION (type1) == GET_MODE_PRECISION (from_mode))\n+\t      || (TYPE_UNSIGNED (type2)\n+\t\t  && TYPE_PRECISION (type2) == GET_MODE_PRECISION (from_mode)))\n+\t    {\n+\t      from_mode = GET_MODE_WIDER_MODE (from_mode);\n+\t      if (GET_MODE_SIZE (to_mode) <= GET_MODE_SIZE (from_mode))\n+\t\treturn false;\n+\t    }\n \n \t  op = smul_widen_optab;\n \t  handler = find_widening_optab_handler_and_mode (op, to_mode,\n@@ -2284,14 +2293,20 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   /* There's no such thing as a mixed sign madd yet, so use a wider mode.  */\n   if (from_unsigned1 != from_unsigned2)\n     {\n-      enum machine_mode mode = GET_MODE_WIDER_MODE (from_mode);\n-      if (GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (to_mode))\n+      /* We can use a signed multiply with unsigned types as long as\n+\t there is a wider mode to use, or it is the smaller of the two\n+\t types that is unsigned.  Note that type1 >= type2, always.  */\n+      if ((from_unsigned1\n+\t   && TYPE_PRECISION (type1) == GET_MODE_PRECISION (from_mode))\n+\t  || (from_unsigned2\n+\t      && TYPE_PRECISION (type2) == GET_MODE_PRECISION (from_mode)))\n \t{\n-\t  from_mode = mode;\n-\t  from_unsigned1 = from_unsigned2 = false;\n+\t  from_mode = GET_MODE_WIDER_MODE (from_mode);\n+\t  if (GET_MODE_SIZE (from_mode) >= GET_MODE_SIZE (to_mode))\n+\t    return false;\n \t}\n-      else\n-\treturn false;\n+\n+      from_unsigned1 = from_unsigned2 = false;\n     }\n \n   /* If there was a conversion between the multiply and addition"}]}