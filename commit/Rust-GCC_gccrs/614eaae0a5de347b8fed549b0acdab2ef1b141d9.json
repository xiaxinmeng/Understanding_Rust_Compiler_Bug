{"sha": "614eaae0a5de347b8fed549b0acdab2ef1b141d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE0ZWFhZTBhNWRlMzQ3YjhmZWQ1NDliMGFjZGFiMmVmMWIxNDFkOQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-07T06:25:14Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-07T06:25:14Z"}, "message": "[multiple changes]\n\n2000-03-06  Bryce McKinlay <bryce@albatross.co.nz>\n\n\t* typeck.c (lookup_do): Search superinterfaces first\n\twhen looking up an interface method. From Godmar Back\n\t<gback@cs.utah.edu>\n\n2000-03-02  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* java-tree.h (lookup_argument_method2): Declared.\n\t(safe_layout_class): Prototype moved from parse.h.\n\t* parse.h (safe_layout_class): Prototype moved to java-tree.h.\n\t* parse.y (java_check_regular_methods): Local `super_class' gone.\n\tCall lookup_argument_method2 instead of lookup_argument_method.\n\tPerform modifier match for methods found declared in implemented\n\tinterfaces. Fixed indentation problem. Overriding/hiding error\n\treport to take place only for methods found in classes.\n\t* typeck.c (lookup_argument_method): Changed leading\n\tcomment. Re-written by calling lookup_do.\n\t(lookup_argument_method2): New function.\n\t(lookup_java_method): Re-written by calling lookup_do.\n\t(lookup_do): New function.\n\nFrom-SVN: r32376", "tree": {"sha": "21007f6e90dfbf502b8219c186d62fdeefad01e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21007f6e90dfbf502b8219c186d62fdeefad01e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/614eaae0a5de347b8fed549b0acdab2ef1b141d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/614eaae0a5de347b8fed549b0acdab2ef1b141d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/614eaae0a5de347b8fed549b0acdab2ef1b141d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/614eaae0a5de347b8fed549b0acdab2ef1b141d9/comments", "author": null, "committer": null, "parents": [{"sha": "141b58108437ef9f1984b78f194933f5b68bab22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141b58108437ef9f1984b78f194933f5b68bab22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/141b58108437ef9f1984b78f194933f5b68bab22"}], "stats": {"total": 202, "additions": 132, "deletions": 70}, "files": [{"sha": "ce13683245f9b13d56abfa8940afe8b42ab76c7b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=614eaae0a5de347b8fed549b0acdab2ef1b141d9", "patch": "@@ -1,3 +1,25 @@\n+2000-03-06  Bryce McKinlay <bryce@albatross.co.nz>\n+\n+\t* typeck.c (lookup_do): Search superinterfaces first\n+\twhen looking up an interface method. From Godmar Back\n+\t<gback@cs.utah.edu>\n+\n+2000-03-02  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (lookup_argument_method2): Declared.\n+\t(safe_layout_class): Prototype moved from parse.h.\n+\t* parse.h (safe_layout_class): Prototype moved to java-tree.h.\n+\t* parse.y (java_check_regular_methods): Local `super_class' gone.\n+\tCall lookup_argument_method2 instead of lookup_argument_method.\n+\tPerform modifier match for methods found declared in implemented\n+\tinterfaces. Fixed indentation problem. Overriding/hiding error\n+\treport to take place only for methods found in classes.\n+\t* typeck.c (lookup_argument_method): Changed leading\n+\tcomment. Re-written by calling lookup_do.\n+\t(lookup_argument_method2): New function.\n+\t(lookup_java_method): Re-written by calling lookup_do.\n+\t(lookup_do): New function.\n+\n 2000-03-06  Tom Tromey  <tromey@cygnus.com>\n \n \t* Make-lang.in (JAVA_SRCS): Added boehm.c, lex.c."}, {"sha": "629061f0e1de5940cdc159b4fa2a3c1448c78321", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=614eaae0a5de347b8fed549b0acdab2ef1b141d9", "patch": "@@ -510,6 +510,7 @@ extern tree lookup_class PARAMS ((tree));\n extern tree lookup_java_constructor PARAMS ((tree, tree));\n extern tree lookup_java_method PARAMS ((tree, tree, tree));\n extern tree lookup_argument_method PARAMS ((tree, tree, tree));\n+extern tree lookup_argument_method2 PARAMS ((tree, tree, tree));\n extern tree promote_type PARAMS ((tree));\n extern tree get_constant PARAMS ((struct JCF*, int));\n extern tree get_name_constant PARAMS ((struct JCF*, int));\n@@ -665,6 +666,7 @@ extern char* open_class PARAMS ((char *, struct JCF *, int, const char *));\n # endif /* JCF_USE_STDIO */\n #endif\n void java_debug_context PARAMS ((void));\n+void safe_layout_class PARAMS ((tree));\n \n extern tree get_boehm_type_descriptor PARAMS ((tree));\n "}, {"sha": "04d86855aaf1c1f5456973d885515c8816f0e94e", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=614eaae0a5de347b8fed549b0acdab2ef1b141d9", "patch": "@@ -678,7 +678,6 @@ struct parser_ctxt {\n };\n \n #ifndef JC1_LITE\n-void safe_layout_class PARAMS ((tree));\n void java_complete_class PARAMS ((void));\n void java_check_circular_reference PARAMS ((void));\n void java_fix_constructors PARAMS ((void));"}, {"sha": "5406a3b432c5906ed0dbe38c1d513b5b0b1f5145", "filename": "gcc/java/parse.y", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=614eaae0a5de347b8fed549b0acdab2ef1b141d9", "patch": "@@ -4762,7 +4762,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n     }\n }\n \n-/* Check that CLASS_DECL somehoow implements all inherited abstract\n+/* Check that CLASS_DECL somehow implements all inherited abstract\n    methods.  */\n \n static void\n@@ -4807,7 +4807,6 @@ java_check_regular_methods (class_decl)\n   int saw_constructor = 0;\n   tree method;\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n-  tree super_class = CLASSTYPE_SUPER (class);\n   tree saved_found_wfl = NULL_TREE, found = NULL_TREE;\n   tree mthrows;\n \n@@ -4859,7 +4858,7 @@ java_check_regular_methods (class_decl)\n \t}\n \n       sig = build_java_argument_signature (TREE_TYPE (method));\n-      found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n+      found = lookup_argument_method2 (class, DECL_NAME (method), sig);\n \n       /* Nothing overrides or it's a private method. */\n       if (!found)\n@@ -4875,12 +4874,25 @@ java_check_regular_methods (class_decl)\n       saved_found_wfl = DECL_NAME (found);\n       reset_method_name (found);\n \n+      /* If `found' is declared in an interface, make sure the\n+\t modifier matches. */\n+      if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (found))) \n+\t  && clinit_identifier_node != DECL_NAME (found)\n+\t  && !METHOD_PUBLIC (method))\n+\t{\n+\t  tree found_decl = TYPE_NAME (DECL_CONTEXT (found));\n+\t  parse_error_context (method_wfl, \"Class `%s' must override `%s' with a public method in order to implement interface `%s'\",\n+\t\t\t       IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n+\t\t\t       lang_printable_name (method, 0),\n+\t\t\t       IDENTIFIER_POINTER (DECL_NAME (found_decl)));\n+\t}\n+\n       /* Can't override a method with the same name and different return\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n \t{\n-\t  char *t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n-\t\t\t\t\t\t 0));\n+\t  char *t = xstrdup \n+\t    (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\", \n@@ -4943,12 +4955,15 @@ java_check_regular_methods (class_decl)\n \t - Overriding/hiding protected must be protected or public\n          - If the overriden or hidden method has default (package)\n            access, then the overriding or hiding method must not be\n-           private; otherwise, a compile-time error occurs */\n-      if ((METHOD_PUBLIC (found) && !METHOD_PUBLIC (method)) \n-\t  || (METHOD_PROTECTED (found) \n-\t      && !(METHOD_PUBLIC (method) || METHOD_PROTECTED (method)))\n-\t  || (!(aflags & (ACC_PUBLIC | ACC_PRIVATE | ACC_STATIC))\n-\t      && METHOD_PRIVATE (method)))\n+           private; otherwise, a compile-time error occurs.  If\n+           `found' belongs to an interface, things have been already\n+           taken care of.  */\n+      if (!CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (found)))\n+\t  && ((METHOD_PUBLIC (found) && !METHOD_PUBLIC (method))\n+\t      || (METHOD_PROTECTED (found) \n+\t\t  && !(METHOD_PUBLIC (method) || METHOD_PROTECTED (method)))\n+\t      || (!(aflags & (ACC_PUBLIC | ACC_PRIVATE | ACC_STATIC))\n+\t\t  && METHOD_PRIVATE (method))))\n \t{\n \t  parse_error_context \n \t    (method_wfl,"}, {"sha": "4a46d42c636b4834de3db0e497a7db3c8d8cd3b4", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 82, "deletions": 58, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/614eaae0a5de347b8fed549b0acdab2ef1b141d9/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=614eaae0a5de347b8fed549b0acdab2ef1b141d9", "patch": "@@ -37,6 +37,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n static tree convert_ieee_real_to_integer PARAMS ((tree, tree));\n static tree parse_signature_type PARAMS ((const unsigned char **,\n \t\t\t\t\t const unsigned char *));\n+static tree lookup_do PARAMS ((tree, tree, tree, tree, tree (*)(tree)));\n \n tree * type_map;\n extern struct obstack permanent_obstack;\n@@ -713,106 +714,129 @@ set_java_signature (type, sig)\n #endif\n }\n \n-/* Search in class CLAS (and its superclasses) for a method\n-   matching METHOD_NAME and argument signature METHOD_SIGNATURE.\n-   Return a FUNCTION_DECL on success, or NULL_TREE if none found.\n-   (Contrast lookup_java_method, which takes into account return type.) */\n+/* Search in class SEARCHED_CLASS (and its superclasses) for a method\n+   matching METHOD_NAME and signature SIGNATURE.  If SEARCHED_INTERFACE is\n+   not NULL_TREE then first search its superinterfaces for a similar match.\n+   Return the matched method DECL or NULL_TREE.  SIGNATURE_BUILDER is\n+   used on method candidates to build their (sometimes partial)\n+   signature.  */\n \n tree\n-lookup_argument_method (clas, method_name, method_signature)\n-     tree clas, method_name, method_signature;\n+lookup_argument_method (searched_class, method_name, method_signature)\n+     tree searched_class, method_name, method_signature;\n {\n-  tree method;\n-  while (clas != NULL_TREE)\n-    {\n-      for (method = TYPE_METHODS (clas);\n-\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n-\t{\n-\t  tree method_sig = build_java_argument_signature (TREE_TYPE (method));\n-\t  tree name = DECL_NAME (method);\n-\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (name) : name) == method_name \n-\t      && method_sig == method_signature)\n-\t    return method;\n-\t}\n-      clas = CLASSTYPE_SUPER (clas);\n-    }\n-  return NULL_TREE;\n+  return lookup_do (searched_class, NULL_TREE, method_name, method_signature, \n+\t\t    build_java_argument_signature);\n }\n \n-/* Search in class CLAS (and its superclasses) for a method\n-   matching METHOD_NAME and signature METHOD_SIGNATURE.\n-   Return a FUNCTION_DECL on success, or NULL_TREE if none found.\n-   (Contrast lookup_argument_method, which ignores return type.) */\n+/* Search in class SEARCHED_CLASS (and its superclasses and\n+   implemented interfaces) for a method matching METHOD_NAME and\n+   argument signature METHOD_SIGNATURE.  Return a FUNCTION_DECL on\n+   success, or NULL_TREE if none found.  (Contrast lookup_java_method,\n+   which takes into account return type.) */\n \n tree\n-lookup_java_method (searched_class, method_name, method_signature)\n+lookup_argument_method2 (searched_class, method_name, method_signature)\n      tree searched_class, method_name, method_signature;\n {\n-  tree method;\n-  tree currently_searched = searched_class;\n+  return lookup_do (CLASSTYPE_SUPER (searched_class), searched_class,\n+\t\t    method_name, method_signature, \n+\t\t    build_java_argument_signature);\n+}\n \n-  while (currently_searched != NULL_TREE)\n-    {\n-      for (method = TYPE_METHODS (currently_searched);\n-\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n-\t{\n-\t  tree method_sig = build_java_signature (TREE_TYPE (method));\n-\t  tree name = DECL_NAME (method);\n+/* Search in class SEARCHED_CLASS (and its superclasses) for a method\n+   matching METHOD_NAME and signature METHOD_SIGNATURE.  Return a\n+   FUNCTION_DECL on success, or NULL_TREE if none found.  (Contrast\n+   lookup_argument_method, which ignores return type.) If\n+   SEARCHED_CLASS is an interface, search it too. */\n \n-\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (name) : name) == method_name\n-\t      && method_sig == method_signature)\n-\t    return method;\n-\t}\n-      currently_searched = CLASSTYPE_SUPER (currently_searched);\n-    }\n+tree\n+lookup_java_method (searched_class, method_name, method_signature)\n+     tree searched_class, method_name, method_signature;\n+{\n+  tree searched_interface;\n+  \n+  /* If this class is an interface class, search its superinterfaces\n+   * first. A superinterface is not an interface's superclass: a super\n+   * interface is implemented by the interface.  */\n+\n+  searched_interface = (CLASS_INTERFACE (TYPE_NAME (searched_class)) ?\n+\t\t\tsearched_class : NULL_TREE);\n+  return lookup_do (searched_class, searched_interface, method_name, \n+\t\t    method_signature, build_java_signature);\n+}\n \n-  /* If this class is an interface class, search its superinterfaces as\n-   * well.  A superinterface is not an interface's superclass: a\n-   * super interface is implemented by the interface.\n-   */\n+/* Search in class SEARCHED_CLASS (an its superclasses) for a method\n+   matching METHOD_NAME and signature SIGNATURE.  Also search in\n+   SEARCHED_INTERFACE (an its superinterfaces) for a similar match.\n+   Return the matched method DECL or NULL_TREE.  SIGNATURE_BUILDER is\n+   used on method candidates to build their (sometimes partial)\n+   signature.  */\n \n-  currently_searched = searched_class;\n-  if (CLASS_INTERFACE (TYPE_NAME (currently_searched)))\n+static tree\n+lookup_do (searched_class, searched_interface, method_name, signature, signature_builder)\n+     tree searched_class, searched_interface, method_name, signature;\n+     tree (*signature_builder) PARAMS ((tree));\n+{\n+  tree method;\n+  \n+  if (searched_interface)\n     {\n       int i;\n       int interface_len = \n-\tTREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (currently_searched)) - 1;\n+\tTREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (searched_interface)) - 1;\n \n       for (i = interface_len; i > 0; i--)\n        {\n          tree child = \n-\t   TREE_VEC_ELT (TYPE_BINFO_BASETYPES (currently_searched), i);\n+\t   TREE_VEC_ELT (TYPE_BINFO_BASETYPES (searched_interface), i);\n          tree iclass = BINFO_TYPE (child);\n \n          /* If the superinterface hasn't been loaded yet, do so now.  */\n-         if (! CLASS_LOADED_P (iclass))\n-           load_class (iclass, 1);\n+\t if (CLASS_FROM_SOURCE_P (iclass))\n+\t   safe_layout_class (iclass);\n+\t else if (!CLASS_LOADED_P (iclass))\n+\t   load_class (iclass, 1);\n \n          for (method = TYPE_METHODS (iclass);\n               method != NULL_TREE;  method = TREE_CHAIN (method))\n            {\n-             tree method_sig = build_java_signature (TREE_TYPE (method));\n+             tree method_sig = (*signature_builder) (TREE_TYPE (method));\n \t     tree name = DECL_NAME (method);\n \n \t     if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n \t\t  EXPR_WFL_NODE (name) : name) == method_name\n-\t\t && method_sig == method_signature)\n+\t\t && method_sig == signature)\n                return method;\n            }\n \n          /* it could be defined in a supersuperinterface */\n          if (CLASS_INTERFACE (TYPE_NAME (iclass)))\n            {\n-             method = lookup_java_method (iclass, \n-\t\t\t\t\t  method_name, \n-\t\t\t\t\t  method_signature);\n+             method = lookup_do (iclass, iclass, method_name, \n+\t\t\t\t signature, signature_builder);\n              if (method != NULL_TREE) \n \t       return method;\n            }\n        }\n     }\n+\n+  while (searched_class != NULL_TREE)\n+    {\n+      for (method = TYPE_METHODS (searched_class);\n+\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n+\t{\n+\t  tree method_sig = (*signature_builder) (TREE_TYPE (method));\n+\t  tree name = DECL_NAME (method);\n+\n+\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n+\t       EXPR_WFL_NODE (name) : name) == method_name\n+\t      && method_sig == signature)\n+\t    return method;\n+\t}\n+      searched_class = CLASSTYPE_SUPER (searched_class);\n+    }\n+\n   return NULL_TREE;\n }\n "}]}