{"sha": "1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY4NWVjZjNiZjk2Y2JhNDg0MGVhNGVmN2IwZjg3YjRmOTJiNDg5OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-10T06:30:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-10T06:30:50Z"}, "message": "ipa-reference.c (is_proper_for_analysis): Exclude addressable and public vars.\n\n\n\t* ipa-reference.c (is_proper_for_analysis): Exclude addressable and public\n\tvars.\n\t(intersect_static_var_sets): Remove.\n\t(propagate): Do not prune local statics.\n\nFrom-SVN: r211398", "tree": {"sha": "6fa23abb955cbefb76854c5586d48f63d2dba07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fa23abb955cbefb76854c5586d48f63d2dba07e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898/comments", "author": null, "committer": null, "parents": [{"sha": "92d28cbb59cc5a611af41342c5b224fbf779a44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d28cbb59cc5a611af41342c5b224fbf779a44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d28cbb59cc5a611af41342c5b224fbf779a44d"}], "stats": {"total": 58, "additions": 18, "deletions": 40}, "files": [{"sha": "4841582fb5e6374fc56f49117c844bd4dd9f3fb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "patch": "@@ -1,3 +1,10 @@\n+2014-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-reference.c (is_proper_for_analysis): Exclude addressable and public\n+\tvars.\n+\t(intersect_static_var_sets): Remove.\n+\t(propagate): Do not prune local statics.\n+\n 2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/60928"}, {"sha": "e815454162bac80cf3e14815631a0065c8a7b0ec", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=1685ecf3bf96cba4840ea4ef7b0f87b4f92b4898", "patch": "@@ -243,6 +243,17 @@ is_proper_for_analysis (tree t)\n   if (TREE_READONLY (t))\n     return false;\n \n+  /* We can not track variables with address taken.  */\n+  if (TREE_ADDRESSABLE (t))\n+    return false;\n+\n+  /* TODO: We could track public variables that are not addressable, but currently\n+     frontends don't give us those.  */\n+  if (TREE_PUBLIC (t))\n+    return false;\n+\n+  /* TODO: Check aliases.  */\n+\n   /* This is a variable we care about.  Check if we have seen it\n      before, and if not add it the set of variables we care about.  */\n   if (all_module_statics\n@@ -312,26 +323,6 @@ union_static_var_sets (bitmap &x, bitmap y)\n   return x == all_module_statics;\n }\n \n-/* Compute X &= Y, taking into account the possibility that\n-   X may become the maximum set.  */\n-\n-static bool\n-intersect_static_var_sets (bitmap &x, bitmap y)\n-{\n-  if (x != all_module_statics)\n-    {\n-      bitmap_and_into (x, y);\n-      /* As with union_static_var_sets, reducing to the maximum\n-\t set as early as possible is an overall win.  */\n-      if (bitmap_equal_p (x, all_module_statics))\n-\t{\n-\t  BITMAP_FREE (x);\n-\t  x = all_module_statics;\n-\t}\n-    }\n-  return x == all_module_statics;\n-}\n-\n /* Return a copy of SET on the bitmap obstack containing SET.\n    But if SET is NULL or the maximum set, return that instead.  */\n \n@@ -669,7 +660,6 @@ static unsigned int\n propagate (void)\n {\n   struct cgraph_node *node;\n-  varpool_node *vnode;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int order_pos;\n@@ -681,25 +671,6 @@ propagate (void)\n   ipa_discover_readonly_nonaddressable_vars ();\n   generate_summary ();\n \n-  /* Now we know what vars are really statics; prune out those that aren't.  */\n-  FOR_EACH_VARIABLE (vnode)\n-    if (vnode->externally_visible\n-\t|| TREE_ADDRESSABLE (vnode->decl)\n-\t|| TREE_READONLY (vnode->decl)\n-\t|| !is_proper_for_analysis (vnode->decl)\n-\t|| !vnode->definition)\n-      bitmap_clear_bit (all_module_statics, DECL_UID (vnode->decl));\n-\n-  /* Forget info we collected \"just for fun\" on variables that turned out to be\n-     non-local.  */\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      ipa_reference_local_vars_info_t node_l;\n-      node_l = &get_reference_vars_info (node)->local;\n-      intersect_static_var_sets (node_l->statics_read, all_module_statics);\n-      intersect_static_var_sets (node_l->statics_written, all_module_statics);\n-    }\n-\n   /* Propagate the local information through the call graph to produce\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the"}]}