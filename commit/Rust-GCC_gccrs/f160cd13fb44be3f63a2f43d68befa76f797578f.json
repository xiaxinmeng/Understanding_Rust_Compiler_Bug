{"sha": "f160cd13fb44be3f63a2f43d68befa76f797578f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2MGNkMTNmYjQ0YmUzZjYzYTJmNDNkNjhiZWZhNzZmNzk3NTc4Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-28T07:31:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-28T07:31:26Z"}, "message": "Handle correctly global0 and global counters in profile_count::to_sreal_scale\n\nThis patch fixes problem in profile_count::to_sreal_scale.  We our porfile\ncounters can be function local, global (ipa) or function local but globally 0.\nThe last is used to hold static estimates for functions executed 0 times in\nprofile.  Now only one 64bit value is stored and if we compute frequency\nof global0 counter in global counter we mix them up and return non-zero value\nincorrectly.\n\nI also implemented unit test, but will commit sanity checking separately from\nfixes: there are multiple bugs in this area I tracked down.\n\n\t* profile-count.c (profile_count::to_sreal_scale): Handle correctly\n\tcombination of globa0 and global counters..\n\nFrom-SVN: r278801", "tree": {"sha": "bdce7cac8176db8648be979e0c1243c12b793c09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdce7cac8176db8648be979e0c1243c12b793c09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f160cd13fb44be3f63a2f43d68befa76f797578f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f160cd13fb44be3f63a2f43d68befa76f797578f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f160cd13fb44be3f63a2f43d68befa76f797578f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f160cd13fb44be3f63a2f43d68befa76f797578f/comments", "author": null, "committer": null, "parents": [{"sha": "34b7ae1dd5f0c01036b2a9308baf15329280733e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b7ae1dd5f0c01036b2a9308baf15329280733e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34b7ae1dd5f0c01036b2a9308baf15329280733e"}], "stats": {"total": 19, "additions": 19, "deletions": 0}, "files": [{"sha": "4ee1806b5abaea7106a7dee23cbd65f9a60af1cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f160cd13fb44be3f63a2f43d68befa76f797578f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f160cd13fb44be3f63a2f43d68befa76f797578f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f160cd13fb44be3f63a2f43d68befa76f797578f", "patch": "@@ -1,3 +1,8 @@\n+2019-11-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* profile-count.c (profile_count::to_sreal_scale): Handle correctly\n+\tcombination of globa0 and global counters..\n+\n 2019-11-28  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR target/92566"}, {"sha": "e8602a025f026e8925860d414c67590bb0dca9a8", "filename": "gcc/profile-count.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f160cd13fb44be3f63a2f43d68befa76f797578f/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f160cd13fb44be3f63a2f43d68befa76f797578f/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=f160cd13fb44be3f63a2f43d68befa76f797578f", "patch": "@@ -310,6 +310,20 @@ profile_count::to_sreal_scale (profile_count in, bool *known) const\n     }\n   if (known)\n     *known = true;\n+  /* Watch for cases where one count is IPA and other is not.  */\n+  if (in.ipa ().initialized_p ())\n+    {\n+      gcc_checking_assert (ipa ().initialized_p ());\n+      /* If current count is inter-procedurally 0 and IN is inter-procedurally\n+\t non-zero, return 0.  */\n+      if (in.ipa ().nonzero_p ()\n+\t  && !ipa().nonzero_p ())\n+\treturn 0;\n+    }\n+  else \n+    /* We can handle correctly 0 IPA count within locally estimated\n+       profile, but otherwise we are lost and this should not happen.   */\n+    gcc_checking_assert (!ipa ().initialized_p () || !ipa ().nonzero_p ());\n   if (*this == zero ())\n     return 0;\n   if (m_val == in.m_val)"}]}