{"sha": "55994078b6bc51ae62bd4117c6c335b94336137b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU5OTQwNzhiNmJjNTFhZTYyYmQ0MTE3YzZjMzM1Yjk0MzM2MTM3Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-11-02T09:56:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-11-02T09:56:12Z"}, "message": "bitmap.h (bitmap_equal_p): Return bool.\n\n\t* bitmap.h (bitmap_equal_p): Return bool.\n\t(bitmap_intersect_p, bitmap_intersect_compl_p): Declare.\n\t* bitmap.c (bitmap_equal_p): Return bool. Compare directly.\n\t(bitmap_intersect_p, bitmap_intersect_compl_p): New.\n\t* flow.c (calculate_global_regs_live): Use bitmap_intersect_p and\n\tbitmap_intersect_compl_p.\n\t* ifcvt (dead_or_predicable): Likewise.\n\nFrom-SVN: r89981", "tree": {"sha": "01db73d0a68c2e2de0213a73d4f7c8d2b5d8ce66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01db73d0a68c2e2de0213a73d4f7c8d2b5d8ce66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55994078b6bc51ae62bd4117c6c335b94336137b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55994078b6bc51ae62bd4117c6c335b94336137b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55994078b6bc51ae62bd4117c6c335b94336137b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55994078b6bc51ae62bd4117c6c335b94336137b/comments", "author": null, "committer": null, "parents": [{"sha": "f6219a5e9ca08b637e8e397eb33d7a515c9cfe7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6219a5e9ca08b637e8e397eb33d7a515c9cfe7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6219a5e9ca08b637e8e397eb33d7a515c9cfe7c"}], "stats": {"total": 159, "additions": 116, "deletions": 43}, "files": [{"sha": "87d7e073f11795d664d575f3af099677c723d2d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55994078b6bc51ae62bd4117c6c335b94336137b", "patch": "@@ -1,3 +1,13 @@\n+2004-11-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* bitmap.h (bitmap_equal_p): Return bool.\n+\t(bitmap_intersect_p, bitmap_intersect_compl_p): Declare.\n+\t* bitmap.c (bitmap_equal_p): Return bool. Compare directly.\n+\t(bitmap_intersect_p, bitmap_intersect_compl_p): New.\n+\t* flow.c (calculate_global_regs_live): Use bitmap_intersect_p and\n+\tbitmap_intersect_compl_p.\n+\t* ifcvt (dead_or_predicable): Likewise.\n+\n 2004-11-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR rtl-optimization/17104"}, {"sha": "c78912b28ff76a9fa663db6f03b6a0cfdab4771d", "filename": "gcc/bitmap.c", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=55994078b6bc51ae62bd4117c6c335b94336137b", "patch": "@@ -663,20 +663,85 @@ bitmap_operation (bitmap to, bitmap from1, bitmap from2,\n   return changed;\n }\n \n-/* Return true if two bitmaps are identical.  */\n+/* Return true if two bitmaps are identical.\n+   We do not bother with a check for pointer equality, as that never\n+   occurs in practice.  */\n \n-int\n+bool\n bitmap_equal_p (bitmap a, bitmap b)\n {\n-  bitmap_head c;\n-  int ret;\n+  bitmap_element *a_elt;\n+  bitmap_element *b_elt;\n+  unsigned ix;\n+  \n+  for (a_elt = a->first, b_elt = b->first;\n+       a_elt && b_elt;\n+       a_elt = a_elt->next, b_elt = b_elt->next)\n+    {\n+      if (a_elt->indx != b_elt->indx)\n+\treturn false;\n+      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\tif (a_elt->bits[ix] != b_elt->bits[ix])\n+\t  return false;\n+    }\n+  return !a_elt && !b_elt;\n+}\n+\n+/* Return true if A AND B is not empty.  */\n+\n+bool\n+bitmap_intersect_p (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt;\n+  bitmap_element *b_elt;\n+  unsigned ix;\n+  \n+  for (a_elt = a->first, b_elt = b->first;\n+       a_elt && b_elt;)\n+    {\n+      if (a_elt->indx < b_elt->indx)\n+\ta_elt = a_elt->next;\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n+      else\n+\t{\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    if (a_elt->bits[ix] & b_elt->bits[ix])\n+\t      return true;\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n+\t}\n+    }\n+  return false;\n+}\n \n-  memset (&c, 0, sizeof (c));\n-  ret = ! bitmap_xor (&c, a, b);\n-  bitmap_clear (&c);\n+/* Return true if A AND NOT B is not empty.  */\n \n-  return ret;\n+bool\n+bitmap_intersect_compl_p (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt;\n+  bitmap_element *b_elt;\n+  unsigned ix;\n+  for (a_elt = a->first, b_elt = b->first;\n+       a_elt && b_elt;)\n+    {\n+      if (a_elt->indx < b_elt->indx)\n+\treturn true;\n+      else if (b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n+      else\n+\t{\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    if (a_elt->bits[ix] & ~b_elt->bits[ix])\n+\t      return true;\n+\t  a_elt = a_elt->next;\n+\t  b_elt = b_elt->next;\n+\t}\n+    }\n+  return a_elt != NULL;\n }\n+\n \f\n /* Or into bitmap TO bitmap FROM1 and'ed with the complement of\n    bitmap FROM2.  */"}, {"sha": "767fafa3b9842a0b1964be4c305eddf701b89223", "filename": "gcc/bitmap.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=55994078b6bc51ae62bd4117c6c335b94336137b", "patch": "@@ -85,8 +85,16 @@ extern void bitmap_clear (bitmap);\n extern void bitmap_copy (bitmap, bitmap);\n \n /* True if two bitmaps are identical.  */\n-extern int bitmap_equal_p (bitmap, bitmap);\n+extern bool bitmap_equal_p (bitmap, bitmap);\n \n+/* True if the bitmaps intersect (their AND is non-empty).  */\n+extern bool bitmap_intersect_p (bitmap, bitmap);\n+\n+/* True if the complement of the second intersects the first (their\n+   AND_COMPL is non-empty).  */\n+extern bool bitmap_intersect_compl_p (bitmap, bitmap);\n+\n+/* True if MAP is an empty bitmap.  */\n #define bitmap_empty_p(MAP) (!(MAP)->first)\n \n /* Perform an operation on two bitmaps, yielding a third.  */"}, {"sha": "163e5c9a4804beff1de7530065f1b968ab7ac53f", "filename": "gcc/flow.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=55994078b6bc51ae62bd4117c6c335b94336137b", "patch": "@@ -1185,38 +1185,32 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t     rescan the block.  This wouldn't be necessary if we had\n \t     precalculated local_live, however with PROP_SCAN_DEAD_CODE\n \t     local_live is really dependent on live_at_end.  */\n-\t  CLEAR_REG_SET (tmp);\n-\t  rescan = bitmap_and_compl (tmp, bb->global_live_at_end,\n-\t\t\t\t     new_live_at_end);\n-\n-\t  if (! rescan)\n-\t    {\n-\t      /* If any of the registers in the new live_at_end set are\n-\t\t conditionally set in this basic block, we must rescan.\n-\t         This is because conditional lifetimes at the end of the\n-\t\t block do not just take the live_at_end set into account,\n-\t\t but also the liveness at the start of each successor\n-\t\t block.  We can miss changes in those sets if we only\n-\t\t compare the new live_at_end against the previous one.  */\n-\t      CLEAR_REG_SET (tmp);\n-\t      rescan = bitmap_and (tmp, new_live_at_end,\n-\t\t\t\t   bb->cond_local_set);\n-\t    }\n-\n-\t  if (! rescan)\n+\t  rescan = bitmap_intersect_compl_p (bb->global_live_at_end,\n+\t\t\t\t\t     new_live_at_end);\n+\n+\t  if (!rescan)\n+\t    /* If any of the registers in the new live_at_end set are\n+\t       conditionally set in this basic block, we must rescan.\n+\t       This is because conditional lifetimes at the end of the\n+\t       block do not just take the live_at_end set into\n+\t       account, but also the liveness at the start of each\n+\t       successor block.  We can miss changes in those sets if\n+\t       we only compare the new live_at_end against the\n+\t       previous one.  */\n+\t    rescan = bitmap_intersect_p (new_live_at_end,\n+\t\t\t\t\t bb->cond_local_set);\n+\n+\t  if (!rescan)\n \t    {\n \t      /* Find the set of changed bits.  Take this opportunity\n \t\t to notice that this set is empty and early out.  */\n-\t      CLEAR_REG_SET (tmp);\n-\t      changed = bitmap_xor (tmp, bb->global_live_at_end,\n-\t\t\t\t\t  new_live_at_end);\n-\t      if (! changed)\n+\t      bitmap_xor (tmp, bb->global_live_at_end, new_live_at_end);\n+\t      if (bitmap_empty_p (tmp))\n \t\tcontinue;\n-\n+  \n \t      /* If any of the changed bits overlap with local_set,\n-\t\t we'll have to rescan the block.  Detect overlap by\n-\t\t the AND with ~local_set turning off bits.  */\n-\t      rescan = bitmap_and_compl_into (tmp, bb->local_set);\n+ \t\t we'll have to rescan the block.  */\n+\t      rescan = bitmap_intersect_p (tmp, bb->local_set);\n \t    }\n \t}\n "}, {"sha": "a033f356aa24856ea52eb27917500f00b4cc0786", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55994078b6bc51ae62bd4117c6c335b94336137b/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=55994078b6bc51ae62bd4117c6c335b94336137b", "patch": "@@ -3217,13 +3217,9 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t   TEST_SET & merge_bb->global_live_at_start\n \t are empty.  */\n \n-      bitmap_ior (tmp, test_set, test_live);\n-      bitmap_and_into (tmp, merge_set);\n-      if (!bitmap_empty_p (tmp))\n-\tfail = 1;\n-\n-      bitmap_and (tmp, test_set, merge_bb->global_live_at_start);\n-      if (!bitmap_empty_p (tmp))\n+      if (bitmap_intersect_p (test_set, merge_set)\n+\t  || bitmap_intersect_p (test_live, merge_set)\n+\t  || bitmap_intersect_p (test_set, merge_bb->global_live_at_start))\n \tfail = 1;\n \n       FREE_REG_SET (tmp);"}]}