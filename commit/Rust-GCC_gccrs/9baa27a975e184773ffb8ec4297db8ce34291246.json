{"sha": "9baa27a975e184773ffb8ec4297db8ce34291246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhYTI3YTk3NWUxODQ3NzNmZmI4ZWM0Mjk3ZGI4Y2UzNDI5MTI0Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-02-04T18:35:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-02-04T18:35:18Z"}, "message": "re PR c++/13969 (static const value rejected as template parameter)\n\n\tPR c++/13969\n\t* g++.dg/template/static6.C: New test.\n\n\tPR c++/13969\n\t* cp-tree.h (fold_non_dependent_expr): New function.\n\t* parser.c (cp_parser_fold_non_dependent_expr): Remove.\n\t(cp_parser_template_argument): Use fold_non_dependent_expr.\n\t(cp_parser_direct_declarator): Likewise.\n\t* pt.c (fold_non_dependent_expr): New function.\n\t(convert_nontype_argument): Use it.\n\t(tsubst_qualified_id): Simplify.\n\t(tsubst_copy_and_build): Likewise.\n\nFrom-SVN: r77260", "tree": {"sha": "4cb6604e4f32e48c7a452d221aa65ba75a1c7912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cb6604e4f32e48c7a452d221aa65ba75a1c7912"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9baa27a975e184773ffb8ec4297db8ce34291246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baa27a975e184773ffb8ec4297db8ce34291246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9baa27a975e184773ffb8ec4297db8ce34291246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baa27a975e184773ffb8ec4297db8ce34291246/comments", "author": null, "committer": null, "parents": [{"sha": "772fec9a0e7d39b1713715db88977ca07b4333b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772fec9a0e7d39b1713715db88977ca07b4333b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772fec9a0e7d39b1713715db88977ca07b4333b4"}], "stats": {"total": 155, "additions": 102, "deletions": 53}, "files": [{"sha": "ec034bc2194c218c1c35cbd0958bbe739aef8d7a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -1,3 +1,15 @@\n+2004-02-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13969\n+\t* cp-tree.h (fold_non_dependent_expr): New function.\n+\t* parser.c (cp_parser_fold_non_dependent_expr): Remove.\n+\t(cp_parser_template_argument): Use fold_non_dependent_expr.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t* pt.c (fold_non_dependent_expr): New function.\n+\t(convert_nontype_argument): Use it.\n+\t(tsubst_qualified_id): Simplify.\n+\t(tsubst_copy_and_build): Likewise.\n+\n 2004-02-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (cxx_push_function_context): Do not set"}, {"sha": "64b9549b876b86ff8f72b9b870d1edeb63a2d384", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -3927,6 +3927,7 @@ extern tree template_for_substitution           (tree);\n extern tree build_non_dependent_expr            (tree);\n extern tree build_non_dependent_args            (tree);\n extern bool reregister_specialization           (tree, tree, tree);\n+extern tree fold_non_dependent_expr             (tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);"}, {"sha": "4ee1aa6cbd86a047f686ca18b3d6755ffa8c7e0c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -1669,8 +1669,6 @@ static tree cp_parser_sizeof_operand\n   (cp_parser *, enum rid);\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n-static tree cp_parser_fold_non_dependent_expr\n-  (tree);\n static bool cp_parser_friend_p\n   (tree);\n static cp_token *cp_parser_require\n@@ -8411,7 +8409,7 @@ cp_parser_template_argument (cp_parser* parser)\n   argument = cp_parser_constant_expression (parser, \n \t\t\t\t\t    /*allow_non_constant_p=*/false,\n \t\t\t\t\t    /*non_constant_p=*/NULL);\n-  argument = cp_parser_fold_non_dependent_expr (argument);\n+  argument = fold_non_dependent_expr (argument);\n   if (!maybe_type_id)\n     return argument;\n   if (!cp_parser_next_token_ends_template_argument_p (parser))\n@@ -10417,7 +10415,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t /*allow_non_constant=*/true,\n \t\t\t\t\t\t &non_constant_p);\n \t      if (!non_constant_p)\n-\t\tbounds = cp_parser_fold_non_dependent_expr (bounds);\n+\t\tbounds = fold_non_dependent_expr (bounds);\n \t    }\n \t  else\n \t    bounds = NULL_TREE;\n@@ -14734,37 +14732,6 @@ cp_parser_declares_only_class_p (cp_parser *parser)\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_COMMA));\n }\n \n-/* Simplify EXPR if it is a non-dependent expression.  Returns the\n-   (possibly simplified) expression.  */\n-\n-static tree\n-cp_parser_fold_non_dependent_expr (tree expr)\n-{\n-  /* If we're in a template, but EXPR isn't value dependent, simplify\n-     it.  We're supposed to treat:\n-     \n-       template <typename T> void f(T[1 + 1]);\n-       template <typename T> void f(T[2]);\n-\t\t   \n-     as two declarations of the same function, for example.  */\n-  if (processing_template_decl\n-      && !type_dependent_expression_p (expr)\n-      && !value_dependent_expression_p (expr))\n-    {\n-      HOST_WIDE_INT saved_processing_template_decl;\n-\n-      saved_processing_template_decl = processing_template_decl;\n-      processing_template_decl = 0;\n-      expr = tsubst_copy_and_build (expr,\n-\t\t\t\t    /*args=*/NULL_TREE,\n-\t\t\t\t    tf_error,\n-\t\t\t\t    /*in_decl=*/NULL_TREE,\n-\t\t\t\t    /*function_p=*/false);\n-      processing_template_decl = saved_processing_template_decl;\n-    }\n-  return expr;\n-}\n-\n /* DECL_SPECIFIERS is the representation of a decl-specifier-seq.\n    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n "}, {"sha": "b7d794e23405d4d57462f8041ade8b569a36c963", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -3099,20 +3099,60 @@ redeclare_class_template (tree type, tree parms)\n     }\n }\n \n+/* Simplify EXPR if it is a non-dependent expression.  Returns the\n+   (possibly simplified) expression.  */\n+\n+tree\n+fold_non_dependent_expr (tree expr)\n+{\n+  /* If we're in a template, but EXPR isn't value dependent, simplify\n+     it.  We're supposed to treat:\n+     \n+       template <typename T> void f(T[1 + 1]);\n+       template <typename T> void f(T[2]);\n+\t\t   \n+     as two declarations of the same function, for example.  */\n+  if (processing_template_decl\n+      && !type_dependent_expression_p (expr)\n+      && !value_dependent_expression_p (expr))\n+    {\n+      HOST_WIDE_INT saved_processing_template_decl;\n+\n+      saved_processing_template_decl = processing_template_decl;\n+      processing_template_decl = 0;\n+      expr = tsubst_copy_and_build (expr,\n+\t\t\t\t    /*args=*/NULL_TREE,\n+\t\t\t\t    tf_error,\n+\t\t\t\t    /*in_decl=*/NULL_TREE,\n+\t\t\t\t    /*function_p=*/false);\n+      processing_template_decl = saved_processing_template_decl;\n+    }\n+  return expr;\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return\n    NULL_TREE if we issued an error message, or error_mark_node if we\n    did not.  We issue error messages for out-and-out bad template\n    parameters, but not simply because the conversion failed, since we\n-   might be just trying to do argument deduction.  By the time this\n-   function is called, neither TYPE nor EXPR may make use of template\n-   parameters.  */\n+   might be just trying to do argument deduction.  Both TYPE and EXPR\n+   must be non-dependent.  */\n \n static tree\n convert_nontype_argument (tree type, tree expr)\n {\n-  tree expr_type = TREE_TYPE (expr);\n+  tree expr_type;\n+\n+  /* If we are in a template, EXPR may be non-dependent, but still\n+     have a syntactic, rather than semantic, form.  For example, EXPR\n+     might be a SCOPE_REF, rather than the VAR_DECL to which the\n+     SCOPE_REF refers.  Preserving the qualifying scope is necessary\n+     so that access checking can be performed when the template is\n+     instantiated -- but here we need the resolved form so that we can\n+     convert the argument.  */\n+  expr = fold_non_dependent_expr (expr);\n+  expr_type = TREE_TYPE (expr);\n \n   /* A template-argument for a non-type, non-template\n      template-parameter shall be one of:\n@@ -3136,12 +3176,31 @@ convert_nontype_argument (tree type, tree expr)\n      --a pointer to member expressed as described in _expr.unary.op_.  */\n \n   /* An integral constant-expression can include const variables or\n-     enumerators.  Simplify things by folding them to their values,\n+.     enumerators.  Simplify things by folding them to their values,\n      unless we're about to bind the declaration to a reference\n      parameter.  */\n-  if (INTEGRAL_TYPE_P (expr_type)\n-      && TREE_CODE (type) != REFERENCE_TYPE)\n-    expr = decl_constant_value (expr);\n+  if (INTEGRAL_TYPE_P (expr_type) && TREE_CODE (type) != REFERENCE_TYPE)\n+    while (true) \n+      {\n+\ttree const_expr = decl_constant_value (expr);\n+\t/* In a template, the initializer for a VAR_DECL may not be\n+\t   marked as TREE_CONSTANT, in which case decl_constant_value\n+\t   will not return the initializer.  Handle that special case\n+\t   here.  */\n+\tif (expr == const_expr\n+\t    && TREE_CODE (expr) == VAR_DECL\n+\t    && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (expr)\n+\t    && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (expr))\n+\t    /* DECL_INITIAL can be NULL if we are processing a\n+\t       variable initialized to an expression involving itself.\n+\t       We know it is initialized to a constant -- but not what\n+\t       constant, yet.  */\n+\t    && DECL_INITIAL (expr))\n+\t  const_expr = DECL_INITIAL (expr);\n+\tif (expr == const_expr)\n+\t  break;\n+\texpr = fold_non_dependent_expr (const_expr);\n+      }\n \n   if (is_overloaded_fn (expr))\n     /* OK for now.  We'll check that it has external linkage later.\n@@ -7279,11 +7338,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   \n   /* Remember that there was a reference to this entity.  */\n   if (DECL_P (expr))\n-    {\n-      mark_used (expr);\n-      if (!args && TREE_CODE (expr) == VAR_DECL)\n-\texpr = DECL_INITIAL (expr);\n-    }\n+    mark_used (expr);\n \n   if (is_template)\n     expr = lookup_template_function (expr, template_args);\n@@ -8485,11 +8540,6 @@ tsubst_copy_and_build (tree t,\n     case VAR_DECL:\n       if (args)\n \tt = tsubst_copy (t, args, complain, in_decl);\n-      else\n-\t/* If there are no ARGS, then we are evaluating a\n-\t   non-dependent expression.  If the expression is\n-\t   non-dependent, the variable must be a constant.  */\n-\tt = DECL_INITIAL (t);\n       return convert_from_reference (t);\n \n     case VA_ARG_EXPR:"}, {"sha": "def7ad68954accc9571b8877e053994edec8570c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -1,3 +1,8 @@\n+2004-02-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13969\n+\t* g++.dg/template/static6.C: New test.\n+\n 2004-02-04  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* gcc.dg/arm-mmx-1.c: Don't look for ldmfd if -mthumb."}, {"sha": "30ecae94067cead7911ff4384f8308dfda7ceaaf", "filename": "gcc/testsuite/g++.dg/template/static6.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baa27a975e184773ffb8ec4297db8ce34291246/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic6.C?ref=9baa27a975e184773ffb8ec4297db8ce34291246", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/13969\n+\n+struct B { \n+  static const int N=10; \n+}; \n+ \n+template <int> struct X {}; \n+ \n+template <typename> struct S { \n+  static const int N = B::N; \n+  X<N> x; \n+}; \n+ \n+template class S<float>; "}]}