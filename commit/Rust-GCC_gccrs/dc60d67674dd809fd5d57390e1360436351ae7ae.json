{"sha": "dc60d67674dd809fd5d57390e1360436351ae7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2MGQ2NzY3NGRkODA5ZmQ1ZDU3MzkwZTEzNjA0MzYzNTFhZTdhZQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-16T12:02:24Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-30T16:00:35Z"}, "message": "d: Move private functions out of ExprVisitor into local statics\n\nNone of these functions need access to the context pointer of the\nvisitor class, so have been made free standing.\n\ngcc/d/ChangeLog:\n\n\t* expr.cc (needs_postblit): Move out of ExprVisitor as a static\n\tfunction.  Update all callers.\n\t(needs_dtor): Likewise.\n\t(lvalue_p): Likewise.\n\t(binary_op): Likewise.\n\t(binop_assignment): Likewise.", "tree": {"sha": "8f2f595e9b7fdc51a5ecf8efa6a7f9791adfb5cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f2f595e9b7fdc51a5ecf8efa6a7f9791adfb5cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc60d67674dd809fd5d57390e1360436351ae7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc60d67674dd809fd5d57390e1360436351ae7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc60d67674dd809fd5d57390e1360436351ae7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc60d67674dd809fd5d57390e1360436351ae7ae/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "561a19c3011f7bde3a41f2a27ea979118e3a2dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561a19c3011f7bde3a41f2a27ea979118e3a2dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561a19c3011f7bde3a41f2a27ea979118e3a2dff"}], "stats": {"total": 313, "additions": 159, "deletions": 154}, "files": [{"sha": "ac9a2820112af19b9b489bca829841c0fc585be1", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 159, "deletions": 154, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc60d67674dd809fd5d57390e1360436351ae7ae/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc60d67674dd809fd5d57390e1360436351ae7ae/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=dc60d67674dd809fd5d57390e1360436351ae7ae", "patch": "@@ -43,181 +43,186 @@ along with GCC; see the file COPYING3.  If not see\n #include \"d-tree.h\"\n \n \n-/* Implements the visitor interface to build the GCC trees of all Expression\n-   AST classes emitted from the D Front-end.\n-   All visit methods accept one parameter E, which holds the frontend AST\n-   of the expression to compile.  They also don't return any value, instead\n-   generated code is cached in RESULT_ and returned from the caller.  */\n+/* Determine if type T is a struct that has a postblit.  */\n \n-class ExprVisitor : public Visitor\n+static bool\n+needs_postblit (Type *t)\n {\n-  using Visitor::visit;\n-\n-  tree result_;\n-  bool constp_;\n+  t = t->baseElemOf ();\n \n-  /* Determine if type is a struct that has a postblit.  */\n-\n-  bool needs_postblit (Type *t)\n-  {\n-    t = t->baseElemOf ();\n-\n-    if (TypeStruct *ts = t->isTypeStruct ())\n-      {\n-\tif (ts->sym->postblit)\n-\t  return true;\n-      }\n+  if (TypeStruct *ts = t->isTypeStruct ())\n+    {\n+      if (ts->sym->postblit)\n+\treturn true;\n+    }\n \n-    return false;\n-  }\n+  return false;\n+}\n \n-  /* Determine if type is a struct that has a destructor.  */\n+/* Determine if type T is a struct that has a destructor.  */\n \n-  bool needs_dtor (Type *t)\n-  {\n-    t = t->baseElemOf ();\n+static bool\n+needs_dtor (Type *t)\n+{\n+  t = t->baseElemOf ();\n \n-    if (TypeStruct *ts = t->isTypeStruct ())\n-      {\n-\tif (ts->sym->dtor)\n-\t  return true;\n-      }\n+  if (TypeStruct *ts = t->isTypeStruct ())\n+    {\n+      if (ts->sym->dtor)\n+\treturn true;\n+    }\n \n-    return false;\n-  }\n+  return false;\n+}\n \n-  /* Determine if expression is suitable lvalue.  */\n+/* Determine if expression E is a suitable lvalue.  */\n \n-  bool lvalue_p (Expression *e)\n-  {\n-    SliceExp *se = e->isSliceExp ();\n-    if (se != NULL && se->e1->isLvalue ())\n-      return true;\n+static bool\n+lvalue_p (Expression *e)\n+{\n+  SliceExp *se = e->isSliceExp ();\n+  if (se != NULL && se->e1->isLvalue ())\n+    return true;\n \n-    CastExp *ce = e->isCastExp ();\n-    if (ce != NULL && ce->e1->isLvalue ())\n-      return true;\n+  CastExp *ce = e->isCastExp ();\n+  if (ce != NULL && ce->e1->isLvalue ())\n+    return true;\n \n-    return (e->op != TOKslice && e->isLvalue ());\n-  }\n-\n-  /* Build an expression of code CODE, data type TYPE, and operands ARG0 and\n-     ARG1.  Perform relevant conversions needed for correct code operations.  */\n+  return (e->op != TOKslice && e->isLvalue ());\n+}\n \n-  tree binary_op (tree_code code, tree type, tree arg0, tree arg1)\n-  {\n-    tree t0 = TREE_TYPE (arg0);\n-    tree t1 = TREE_TYPE (arg1);\n-    tree ret = NULL_TREE;\n+/* Build an expression of code CODE, data type TYPE, and operands ARG0 and\n+   ARG1.  Perform relevant conversions needed for correct code operations.  */\n \n-    bool unsignedp = TYPE_UNSIGNED (t0) || TYPE_UNSIGNED (t1);\n+static tree\n+binary_op (tree_code code, tree type, tree arg0, tree arg1)\n+{\n+  tree t0 = TREE_TYPE (arg0);\n+  tree t1 = TREE_TYPE (arg1);\n+  tree ret = NULL_TREE;\n \n-    /* Deal with float mod expressions immediately.  */\n-    if (code == FLOAT_MOD_EXPR)\n-      return build_float_modulus (type, arg0, arg1);\n+  bool unsignedp = TYPE_UNSIGNED (t0) || TYPE_UNSIGNED (t1);\n \n-    if (POINTER_TYPE_P (t0) && INTEGRAL_TYPE_P (t1))\n-      return build_nop (type, build_offset_op (code, arg0, arg1));\n+  /* Deal with float mod expressions immediately.  */\n+  if (code == FLOAT_MOD_EXPR)\n+    return build_float_modulus (type, arg0, arg1);\n \n-    if (INTEGRAL_TYPE_P (t0) && POINTER_TYPE_P (t1))\n-      return build_nop (type, build_offset_op (code, arg1, arg0));\n+  if (POINTER_TYPE_P (t0) && INTEGRAL_TYPE_P (t1))\n+    return build_nop (type, build_offset_op (code, arg0, arg1));\n \n-    if (POINTER_TYPE_P (t0) && POINTER_TYPE_P (t1))\n-      {\n-\tgcc_assert (code == MINUS_EXPR);\n-\ttree ptrtype = lang_hooks.types.type_for_mode (ptr_mode, 0);\n+  if (INTEGRAL_TYPE_P (t0) && POINTER_TYPE_P (t1))\n+    return build_nop (type, build_offset_op (code, arg1, arg0));\n \n-\t/* POINTER_DIFF_EXPR requires a signed integer type of the same size as\n-\t   pointers.  If some platform cannot provide that, or has a larger\n-\t   ptrdiff_type to support differences larger than half the address\n-\t   space, cast the pointers to some larger integer type and do the\n-\t   computations in that type.  */\n-\tif (TYPE_PRECISION (ptrtype) > TYPE_PRECISION (t0))\n-\t  ret = fold_build2 (MINUS_EXPR, ptrtype,\n-\t\t\t     d_convert (ptrtype, arg0),\n-\t\t\t     d_convert (ptrtype, arg1));\n-\telse\n-\t  ret = fold_build2 (POINTER_DIFF_EXPR, ptrtype, arg0, arg1);\n-      }\n-    else if (INTEGRAL_TYPE_P (type) && (TYPE_UNSIGNED (type) != unsignedp))\n-      {\n-\ttree inttype = (unsignedp)\n-\t  ? d_unsigned_type (type) : d_signed_type (type);\n-\tret = fold_build2 (code, inttype, arg0, arg1);\n-      }\n-    else\n-      {\n-\t/* If the operation needs excess precision.  */\n-\ttree eptype = excess_precision_type (type);\n-\tif (eptype != NULL_TREE)\n-\t  {\n-\t    arg0 = d_convert (eptype, arg0);\n-\t    arg1 = d_convert (eptype, arg1);\n-\t  }\n-\telse\n-\t  {\n-\t    /* Front-end does not do this conversion and GCC does not\n-\t       always do it right.  */\n-\t    if (COMPLEX_FLOAT_TYPE_P (t0) && !COMPLEX_FLOAT_TYPE_P (t1))\n-\t      arg1 = d_convert (t0, arg1);\n-\t    else if (COMPLEX_FLOAT_TYPE_P (t1) && !COMPLEX_FLOAT_TYPE_P (t0))\n-\t      arg0 = d_convert (t1, arg0);\n+  if (POINTER_TYPE_P (t0) && POINTER_TYPE_P (t1))\n+    {\n+      gcc_assert (code == MINUS_EXPR);\n+      tree ptrtype = lang_hooks.types.type_for_mode (ptr_mode, 0);\n+\n+      /* POINTER_DIFF_EXPR requires a signed integer type of the same size as\n+\t pointers.  If some platform cannot provide that, or has a larger\n+\t ptrdiff_type to support differences larger than half the address\n+\t space, cast the pointers to some larger integer type and do the\n+\t computations in that type.  */\n+      if (TYPE_PRECISION (ptrtype) > TYPE_PRECISION (t0))\n+\tret = fold_build2 (MINUS_EXPR, ptrtype,\n+\t\t\t   d_convert (ptrtype, arg0),\n+\t\t\t   d_convert (ptrtype, arg1));\n+      else\n+\tret = fold_build2 (POINTER_DIFF_EXPR, ptrtype, arg0, arg1);\n+    }\n+  else if (INTEGRAL_TYPE_P (type) && (TYPE_UNSIGNED (type) != unsignedp))\n+    {\n+      tree inttype = (unsignedp)\n+\t? d_unsigned_type (type) : d_signed_type (type);\n+      ret = fold_build2 (code, inttype, arg0, arg1);\n+    }\n+  else\n+    {\n+      /* If the operation needs excess precision.  */\n+      tree eptype = excess_precision_type (type);\n+      if (eptype != NULL_TREE)\n+\t{\n+\t  arg0 = d_convert (eptype, arg0);\n+\t  arg1 = d_convert (eptype, arg1);\n+\t}\n+      else\n+\t{\n+\t  /* Front-end does not do this conversion and GCC does not\n+\t     always do it right.  */\n+\t  if (COMPLEX_FLOAT_TYPE_P (t0) && !COMPLEX_FLOAT_TYPE_P (t1))\n+\t    arg1 = d_convert (t0, arg1);\n+\t  else if (COMPLEX_FLOAT_TYPE_P (t1) && !COMPLEX_FLOAT_TYPE_P (t0))\n+\t    arg0 = d_convert (t1, arg0);\n+\n+\t  eptype = type;\n+\t}\n+\n+      ret = fold_build2 (code, eptype, arg0, arg1);\n+    }\n \n-\t    eptype = type;\n-\t  }\n+  return d_convert (type, ret);\n+}\n \n-\tret = fold_build2 (code, eptype, arg0, arg1);\n-      }\n+/* Build a binary expression of code CODE, assigning the result into E1.  */\n \n-    return d_convert (type, ret);\n-  }\n+static tree\n+binop_assignment (tree_code code, Expression *e1, Expression *e2)\n+{\n+  /* Skip casts for lhs assignment.  */\n+  Expression *e1b = e1;\n+  while (e1b->op == TOKcast)\n+    {\n+      CastExp *ce = e1b->isCastExp ();\n+      gcc_assert (same_type_p (ce->type, ce->to));\n+      e1b = ce->e1;\n+    }\n \n-  /* Build a binary expression of code CODE, assigning the result into E1.  */\n+  /* Stabilize LHS for assignment.  */\n+  tree lhs = build_expr (e1b);\n+  tree lexpr = stabilize_expr (&lhs);\n \n-  tree binop_assignment (tree_code code, Expression *e1, Expression *e2)\n-  {\n-    /* Skip casts for lhs assignment.  */\n-    Expression *e1b = e1;\n-    while (e1b->op == TOKcast)\n-      {\n-\tCastExp *ce = e1b->isCastExp ();\n-\tgcc_assert (same_type_p (ce->type, ce->to));\n-\te1b = ce->e1;\n-      }\n+  /* The LHS expression could be an assignment, to which its operation gets\n+     lost during gimplification.  */\n+  if (TREE_CODE (lhs) == MODIFY_EXPR)\n+    {\n+      /* If LHS has side effects, call stabilize_reference on it, so it can\n+\t be evaluated multiple times.  */\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n+\tlhs = build_assign (MODIFY_EXPR,\n+\t\t\t    stabilize_reference (TREE_OPERAND (lhs, 0)),\n+\t\t\t    TREE_OPERAND (lhs, 1));\n+\n+      lexpr = compound_expr (lexpr, lhs);\n+      lhs = TREE_OPERAND (lhs, 0);\n+    }\n \n-    /* Stabilize LHS for assignment.  */\n-    tree lhs = build_expr (e1b);\n-    tree lexpr = stabilize_expr (&lhs);\n+  lhs = stabilize_reference (lhs);\n \n-    /* The LHS expression could be an assignment, to which its operation gets\n-       lost during gimplification.  */\n-    if (TREE_CODE (lhs) == MODIFY_EXPR)\n-      {\n-\t/* If LHS has side effects, call stabilize_reference on it, so it can\n-\t   be evaluated multiple times.  */\n-\tif (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n-\t  lhs = build_assign (MODIFY_EXPR,\n-\t\t\t      stabilize_reference (TREE_OPERAND (lhs, 0)),\n-\t\t\t      TREE_OPERAND (lhs, 1));\n+  /* Save RHS, to ensure that the expression is evaluated before LHS.  */\n+  tree rhs = build_expr (e2);\n+  tree rexpr = d_save_expr (rhs);\n \n-\tlexpr = compound_expr (lexpr, lhs);\n-\tlhs = TREE_OPERAND (lhs, 0);\n-      }\n+  rhs = binary_op (code, build_ctype (e1->type),\n+\t\t   convert_expr (lhs, e1b->type, e1->type), rexpr);\n+  if (TREE_SIDE_EFFECTS (rhs))\n+    rhs = compound_expr (rexpr, rhs);\n \n-    lhs = stabilize_reference (lhs);\n+  tree expr = modify_expr (lhs, convert_expr (rhs, e1->type, e1b->type));\n+  return compound_expr (lexpr, expr);\n+}\n \n-    /* Save RHS, to ensure that the expression is evaluated before LHS.  */\n-    tree rhs = build_expr (e2);\n-    tree rexpr = d_save_expr (rhs);\n+/* Implements the visitor interface to build the GCC trees of all Expression\n+   AST classes emitted from the D Front-end.\n+   All visit methods accept one parameter E, which holds the frontend AST\n+   of the expression to compile.  They also don't return any value, instead\n+   generated code is cached in RESULT_ and returned from the caller.  */\n \n-    rhs = this->binary_op (code, build_ctype (e1->type),\n-\t\t\t   convert_expr (lhs, e1b->type, e1->type), rexpr);\n-    if (TREE_SIDE_EFFECTS (rhs))\n-      rhs = compound_expr (rexpr, rhs);\n+class ExprVisitor : public Visitor\n+{\n+  using Visitor::visit;\n \n-    tree expr = modify_expr (lhs, convert_expr (rhs, e1->type, e1b->type));\n-    return compound_expr (lexpr, expr);\n-  }\n+  tree result_;\n+  bool constp_;\n \n public:\n   ExprVisitor (bool constp)\n@@ -653,8 +658,8 @@ class ExprVisitor : public Visitor\n \tgcc_unreachable ();\n       }\n \n-    this->result_ = this->binary_op (code, build_ctype (e->type),\n-\t\t\t\t     build_expr (e->e1), build_expr (e->e2));\n+    this->result_ = binary_op (code, build_ctype (e->type),\n+\t\t\t       build_expr (e->e1), build_expr (e->e2));\n   }\n \n \n@@ -807,7 +812,7 @@ class ExprVisitor : public Visitor\n \tgcc_unreachable ();\n       }\n \n-    tree exp = this->binop_assignment (code, e1b, e->e2);\n+    tree exp = binop_assignment (code, e1b, e->e2);\n     this->result_ = convert_expr (exp, e1b->type, e->type);\n   }\n \n@@ -915,8 +920,8 @@ class ExprVisitor : public Visitor\n \tType *etype = stype->nextOf ()->toBasetype ();\n \n \t/* Determine if we need to run postblit or dtor.  */\n-\tbool postblit = this->needs_postblit (etype) && this->lvalue_p (e->e2);\n-\tbool destructor = this->needs_dtor (etype);\n+\tbool postblit = needs_postblit (etype) && lvalue_p (e->e2);\n+\tbool destructor = needs_dtor (etype);\n \n \tif (e->memset & blockAssign)\n \t  {\n@@ -1098,15 +1103,15 @@ class ExprVisitor : public Visitor\n \tgcc_assert (e->e2->type->toBasetype ()->ty == Tsarray);\n \n \t/* Determine if we need to run postblit.  */\n-\tbool postblit = this->needs_postblit (etype);\n-\tbool destructor = this->needs_dtor (etype);\n-\tbool lvalue_p = this->lvalue_p (e->e2);\n+\tbool postblit = needs_postblit (etype);\n+\tbool destructor = needs_dtor (etype);\n+\tbool lvalue = lvalue_p (e->e2);\n \n \t/* Even if the elements in rhs are all rvalues and don't have\n \t   to call postblits, this assignment should call dtors on old\n \t   assigned elements.  */\n \tif ((!postblit && !destructor)\n-\t    || (e->op == TOKconstruct && !lvalue_p && postblit)\n+\t    || (e->op == TOKconstruct && !lvalue && postblit)\n \t    || (e->op == TOKblit || e->e1->type->size () == 0))\n \t  {\n \t    tree t1 = build_expr (e->e1);\n@@ -1132,7 +1137,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    /* Generate: _d_arrayassign_l()\n \t\t     or: _d_arrayassign_r()  */\n-\t    libcall_fn libcall = (lvalue_p)\n+\t    libcall_fn libcall = (lvalue)\n \t      ? LIBCALL_ARRAYASSIGN_L : LIBCALL_ARRAYASSIGN_R;\n \t    tree elembuf = build_local_temp (build_ctype (etype));\n "}]}