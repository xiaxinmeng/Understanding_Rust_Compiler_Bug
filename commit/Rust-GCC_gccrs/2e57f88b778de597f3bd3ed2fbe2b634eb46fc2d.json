{"sha": "2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU1N2Y4OGI3NzhkZTU5N2YzYmQzZWQyZmJlMmI2MzRlYjQ2ZmMyZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-11T10:52:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-11T10:52:35Z"}, "message": "[multiple changes]\n\n2014-06-11  Geert Bosch  <bosch@adacore.com>\n\n\t* s-exctab.adb: avoid race conditions in exception registration.\n\n2014-06-11  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.adb (Warn_Insertion): New function.\n\t(Error_Msg): Use Warn_Insertion and Prescan_Message.\n\t(Error_Msg_Internal): Set Info field of error object.\n\t(Error_Msg_NEL): Use Prescan_Message.\n\t(Set_Msg_Text): Don't store info: at start of message.\n\t(Skip_Msg_Insertion_Warning): New name for Set_Msg_Insertion_Warning.\n\t(Skip_Msg_Insertion_Warning): Now just skips warning insertion.\n\t* errout.ads: Document new ?$? and >$> insertion sequences\n\tDocument use of \"(style)\" and \"info: \"\n\t* erroutc.adb (dmsg): Print several missing fields\n\t(Get_Warning_Tag): Handle -gnatel case (?$?)  (Output_Msg_Text):\n\tDeal with new tagging of info messages\n\t* erroutc.ads: Is_Info_Msg: New global (Error_Msg_Object):\n\tAdd field Info (Prescan_Message): New procedure, this procedure\n\treplaces the old Test_Style_Warning_Serious_Unconditional_Msg\n\t* errutil.adb, exp_util.adb, par-ch7.adb, sem_ch13.adb, sem_ch7.adb,\n\tsem_elab.adb: Follow new rules for info message (info belongs\n\tonly at the start of a message, and only in the first message,\n\tnot in any of the continuations).\n\t* gnat_ugn.texi: Document full set of warning tags.\n\nFrom-SVN: r211447", "tree": {"sha": "8164bb2479d90ef5d1bb21f44ae01230e59b55a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8164bb2479d90ef5d1bb21f44ae01230e59b55a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/comments", "author": null, "committer": null, "parents": [{"sha": "c230ed0b7e7cfec4bc9c437f833aa703ac9b3f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c230ed0b7e7cfec4bc9c437f833aa703ac9b3f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c230ed0b7e7cfec4bc9c437f833aa703ac9b3f95"}], "stats": {"total": 890, "additions": 590, "deletions": 300}, "files": [{"sha": "a2ce54e9b0f0dfdccf9e391c103dec8ad580c95c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -1,3 +1,30 @@\n+2014-06-11  Geert Bosch  <bosch@adacore.com>\n+\n+\t* s-exctab.adb: avoid race conditions in exception registration.\n+\n+2014-06-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.adb (Warn_Insertion): New function.\n+\t(Error_Msg): Use Warn_Insertion and Prescan_Message.\n+\t(Error_Msg_Internal): Set Info field of error object.\n+\t(Error_Msg_NEL): Use Prescan_Message.\n+\t(Set_Msg_Text): Don't store info: at start of message.\n+\t(Skip_Msg_Insertion_Warning): New name for Set_Msg_Insertion_Warning.\n+\t(Skip_Msg_Insertion_Warning): Now just skips warning insertion.\n+\t* errout.ads: Document new ?$? and >$> insertion sequences\n+\tDocument use of \"(style)\" and \"info: \"\n+\t* erroutc.adb (dmsg): Print several missing fields\n+\t(Get_Warning_Tag): Handle -gnatel case (?$?)  (Output_Msg_Text):\n+\tDeal with new tagging of info messages\n+\t* erroutc.ads: Is_Info_Msg: New global (Error_Msg_Object):\n+\tAdd field Info (Prescan_Message): New procedure, this procedure\n+\treplaces the old Test_Style_Warning_Serious_Unconditional_Msg\n+\t* errutil.adb, exp_util.adb, par-ch7.adb, sem_ch13.adb, sem_ch7.adb,\n+\tsem_elab.adb: Follow new rules for info message (info belongs\n+\tonly at the start of a message, and only in the first message,\n+\tnot in any of the continuations).\n+\t* gnat_ugn.texi: Document full set of warning tags.\n+\n 2014-06-11  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_util.adb: Minor typo fix."}, {"sha": "7f02fe2257164907202df6ea5b5105698782f783", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -197,6 +197,17 @@ package body Errout is\n    --  spec for precise definition of the conversion that is performed by this\n    --  routine in OpenVMS mode.\n \n+   function Warn_Insertion return String;\n+   --  This is called for warning messages only (so Warning_Msg_Char is set)\n+   --  and returns a corresponding string to use at the beginning of generated\n+   --  auxiliary messages, such as \"in instantiation at ...\".\n+   --    'a' .. 'z'   returns \"?x?\"\n+   --    'A' .. 'Z'   returns \"?X?\"\n+   --    '*'          returns \"?*?\"\n+   --    '$'          returns \"?$?info: \"\n+   --    ' '          returns \" \"\n+   --  No other settings are valid\n+\n    -----------------------\n    -- Change_Error_Text --\n    -----------------------\n@@ -282,7 +293,7 @@ package body Errout is\n       --  Start of processing for new message\n \n       Sindex := Get_Source_File_Index (Flag_Location);\n-      Test_Style_Warning_Serious_Unconditional_Msg (Msg);\n+      Prescan_Message (Msg);\n       Orig_Loc := Original_Location (Flag_Location);\n \n       --  If the current location is in an instantiation, the issue arises of\n@@ -332,8 +343,7 @@ package body Errout is\n       --  that style checks are not considered warning messages for this\n       --  purpose.\n \n-      if Is_Warning_Msg\n-        and then Warnings_Suppressed (Orig_Loc) /= No_String\n+      if Is_Warning_Msg and then Warnings_Suppressed (Orig_Loc) /= No_String\n       then\n          return;\n \n@@ -438,9 +448,9 @@ package body Errout is\n                --  Case of inlined body\n \n                if Inlined_Body (X) then\n-                  if Is_Warning_Msg or else Is_Style_Msg then\n+                  if Is_Warning_Msg or Is_Style_Msg then\n                      Error_Msg_Internal\n-                       (\"?in inlined body #\",\n+                       (Warn_Insertion & \"in inlined body #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n                   else\n                      Error_Msg_Internal\n@@ -453,7 +463,7 @@ package body Errout is\n                else\n                   if Is_Warning_Msg or else Is_Style_Msg then\n                      Error_Msg_Internal\n-                       (\"?in instantiation #\",\n+                       (Warn_Insertion & \"in instantiation #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n                   else\n                      Error_Msg_Internal\n@@ -732,7 +742,6 @@ package body Errout is\n       Continuation_New_Line := False;\n       Suppress_Message := False;\n       Kill_Message := False;\n-      Warning_Msg_Char := ' ';\n       Set_Msg_Text (Msg, Sptr);\n \n       --  Kill continuation if parent message killed\n@@ -944,6 +953,7 @@ package body Errout is\n           Line     => Get_Physical_Line_Number (Sptr),\n           Col      => Get_Column_Number (Sptr),\n           Warn     => Is_Warning_Msg,\n+          Info     => Is_Info_Msg,\n           Warn_Err => False, -- reset below\n           Warn_Chr => Warning_Msg_Char,\n           Style    => Is_Style_Msg,\n@@ -1159,7 +1169,7 @@ package body Errout is\n          return;\n       end if;\n \n-      Test_Style_Warning_Serious_Unconditional_Msg (Msg);\n+      Prescan_Message (Msg);\n \n       --  Special handling for warning messages\n \n@@ -2745,35 +2755,36 @@ package body Errout is\n       C : Character;   -- Current character\n       P : Natural;     -- Current index;\n \n-      procedure Set_Msg_Insertion_Warning (C : Character);\n-      --  Deal with ? ?? ?x? ?X? insertion sequences (also < << <x< <X<). The\n-      --  caller has already bumped the pointer past the initial ? or < and C\n-      --  is set to this initial character (? or <).\n+      procedure Skip_Msg_Insertion_Warning (C : Character);\n+      --  Deal with ? ?? ?x? ?X? ?*? ?$? insertion sequences (and the same\n+      --  sequences using < instead of ?). The caller has already bumped\n+      --  the pointer past the initial ? or < and C is set to this initial\n+      --  character (? or <). This procedure skips past the rest of the\n+      --  sequence. We do not need to set Msg_Insertion_Char, since this\n+      --  was already done during the message prescan.\n \n-      -------------------------------\n-      -- Set_Msg_Insertion_Warning --\n-      -------------------------------\n+      --------------------------------\n+      -- Skip_Msg_Insertion_Warning --\n+      --------------------------------\n \n-      procedure Set_Msg_Insertion_Warning (C : Character) is\n+      procedure Skip_Msg_Insertion_Warning (C : Character) is\n       begin\n          if P <= Text'Last and then Text (P) = C then\n-            Warning_Msg_Char := '?';\n             P := P + 1;\n \n          elsif P + 1 <= Text'Last\n            and then (Text (P) in 'a' .. 'z'\n                        or else\n                      Text (P) in 'A' .. 'Z'\n                        or else\n-                     Text (P) = '*')\n+                     Text (P) = '*'\n+                       or else\n+                     Text (P) = '$')\n            and then Text (P + 1) = C\n          then\n-            Warning_Msg_Char := Text (P);\n             P := P + 2;\n-         else\n-            Warning_Msg_Char := ' ';\n          end if;\n-      end Set_Msg_Insertion_Warning;\n+      end Skip_Msg_Insertion_Warning;\n \n    --  Start of processing for Set_Msg_Text\n \n@@ -2782,7 +2793,21 @@ package body Errout is\n       Msglen := 0;\n       Flag_Source := Get_Source_File_Index (Flag);\n \n-      P := Text'First;\n+      --  Skip info: at start, we have recorded this in Is_Info_Msg, and this\n+      --  will be used (Info field in error message object) to put back the\n+      --  string when it is printed. We need to do this, or we get confused\n+      --  with instantiation continuations.\n+\n+      if Text'Length > 6\n+        and then Text (Text'First .. Text'First + 5) = \"info: \"\n+      then\n+         P := Text'First + 6;\n+      else\n+         P := Text'First;\n+      end if;\n+\n+      --  Loop through characters of message\n+\n       while P <= Text'Last loop\n          C := Text (P);\n          P := P + 1;\n@@ -2846,16 +2871,10 @@ package body Errout is\n                null; -- already dealt with\n \n             when '?' =>\n-               Set_Msg_Insertion_Warning ('?');\n+               Skip_Msg_Insertion_Warning ('?');\n \n             when '<' =>\n-\n-               --  Note: the prescan already set Is_Warning_Msg True if and\n-               --  only if Error_Msg_Warn is set to True. If Error_Msg_Warn\n-               --  is False, the call to Set_Msg_Insertion_Warning here does\n-               --  no harm, since Warning_Msg_Char is ignored in that case.\n-\n-               Set_Msg_Insertion_Warning ('<');\n+               Skip_Msg_Insertion_Warning ('<');\n \n             when '|' =>\n                null; -- already dealt with\n@@ -3233,4 +3252,22 @@ package body Errout is\n       end loop;\n    end VMS_Convert;\n \n+   --------------------\n+   -- Warn_Insertion --\n+   --------------------\n+\n+   function Warn_Insertion return String is\n+   begin\n+      case Warning_Msg_Char is\n+         when '?' =>\n+            return \"??\";\n+         when 'a' .. 'z' | 'A' .. 'Z' | '*' | '$' =>\n+            return '?' & Warning_Msg_Char & '?';\n+         when ' ' =>\n+            return \"?\";\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Warn_Insertion;\n+\n end Errout;"}, {"sha": "45234a4dc9b106823533fa4c64feb668252d2058", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -60,12 +60,13 @@ package Errout is\n    --  Exception raised if Raise_Exception_On_Error is true\n \n    Warning_Doc_Switch : Boolean renames Err_Vars.Warning_Doc_Switch;\n-   --  If this is set True, then the ??/?*?/?x?/?X? sequences in error messages\n-   --  generate appropriate tags for the output error messages. If this switch\n-   --  is False, then these sequences are still recognized (for the purposes\n-   --  of implementing pragmas Warnings (Off,..) and Warning_As_Pragma(...) but\n-   --  do not result in adding the error message tag. The -gnatw.d switch sets\n-   --  this flag True, -gnatw.D sets this flag False.\n+   --  If this is set True, then the ??/?*?/?$?/?x?/?X? insertion sequences in\n+   --  error messages generate appropriate tags for the output error messages.\n+   --  If this switch is False, then these sequences are still recognized (for\n+   --  the purposes of implementing the pattern matching in pragmas Warnings\n+   --  (Off,..) and Warning_As_Pragma(...) but do not result in adding the\n+   --  error message tag. The -gnatw.d switch sets this flag True, -gnatw.D\n+   --  sets this flag False.\n \n    -----------------------------------\n    -- Suppression of Error Messages --\n@@ -283,7 +284,7 @@ package Errout is\n    --      messages, and the usual style is to include it, since it makes it\n    --      clear that the continuation is part of a warning message.\n    --\n-   --      Note: this usage is obsolete, use ?? ?*? ?x? ?X? instead to specify\n+   --      Note: this usage is obsolete, use ?? ?*? ?$? ?x? ?X? to specify\n    --      the string to be added when Warn_Doc_Switch is set to True. If this\n    --      switch is True, then for simple ? messages it has no effect. This\n    --      simple form is to ease transition and will be removed later.\n@@ -309,11 +310,17 @@ package Errout is\n    --      \"[restriction warning]\" at the end of the warning message. For\n    --      continuations, use this on each continuation message.\n \n+   --    Insertion character ?$? (elaboration information messages)\n+   --      Like ?, but if the flag Warn_Doc_Switch is True, adds the string\n+   --      \"[-gnatel]\" at the end of the info message. This is used for the\n+   --      messages generated by the switch -gnatel. For continuations, use\n+   --      this on each continuation message.\n+\n    --    Insertion character < (Less Than: conditional warning message)\n    --      The character < appearing anywhere in a message is used for a\n    --      conditional error message. If Error_Msg_Warn is True, then the\n-   --      effect is the same as ? described above, and in particular <<\n-   --      <X< and <*< have the effect of ?? ?X? and ?*? respectively. If\n+   --      effect is the same as ? described above, and in particular << <X<\n+   --      <x< <$< <*< have the effect of ?? ?X? ?x? ?$? ?*? respectively. If\n    --      Error_Msg_Warn is False, then the < << or <X< sequence is ignored\n    --      and the message is treated as a error rather than a warning.\n \n@@ -392,6 +399,19 @@ package Errout is\n    --      This is like [ except that the insertion messages say may/might,\n    --      instead of will/would.\n \n+   --    Insertion sequence \"(style)\" (style message)\n+   --      This appears only at the start of the message (and not any of its\n+   --      continuations, if any), and indicates that the message is a style\n+   --      message. Style messages are also considered to be warnings, but\n+   --      they do not get a tag.\n+\n+   --    Insertion sequence \"info: \" (information message)\n+   --      This appears only at the start of the message (and not any of its\n+   --      continuations, if any), and indicates that the message is an info\n+   --      message. The message will be output with this prefix, and if there\n+   --      are continuations that are not printed using the -gnatj switch they\n+   --      will also have this prefix.\n+\n    ----------------------------------------\n    -- Specialization of Messages for VMS --\n    ----------------------------------------"}, {"sha": "c27b76e642fba4b26ebbffda8d230bd635db66b2", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 108, "deletions": 64, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -257,6 +257,7 @@ package body Erroutc is\n       w (\"Dumping error message, Id = \", Int (Id));\n       w (\"  Text     = \", E.Text.all);\n       w (\"  Next     = \", Int (E.Next));\n+      w (\"  Prev     = \", Int (E.Prev));\n       w (\"  Sfile    = \", Int (E.Sfile));\n \n       Write_Str\n@@ -272,6 +273,8 @@ package body Erroutc is\n       w (\"  Line     = \", Int (E.Line));\n       w (\"  Col      = \", Int (E.Col));\n       w (\"  Warn     = \", E.Warn);\n+      w (\"  Warn_Err = \", E.Warn_Err);\n+      w (\"  Warn_Chr = '\" & E.Warn_Chr & ''');\n       w (\"  Style    = \", E.Style);\n       w (\"  Serious  = \", E.Serious);\n       w (\"  Uncond   = \", E.Uncond);\n@@ -312,6 +315,8 @@ package body Erroutc is\n             return \"[enabled by default]\";\n          elsif Warn_Chr = '*' then\n             return \"[restriction warning]\";\n+         elsif Warn_Chr = '$' then\n+            return \"[-gnatel]\";\n          elsif Warn_Chr in 'a' .. 'z' then\n             return \"[-gnatw\" & Warn_Chr & ']';\n          else pragma Assert (Warn_Chr in 'A' .. 'Z');\n@@ -574,24 +579,22 @@ package body Erroutc is\n \n          if Errors.Table (E).Warn then\n \n-            --  Nothing to do with info messages, \"info \" already set\n+            --  For info messages, prefix message with \"info: \"\n \n-            if Txt'Length >= 6\n-              and then Txt (Txt'First .. Txt'First + 5) = \"info: \"\n-            then\n-               null;\n+            if Errors.Table (E).Info then\n+               Txt := new String'(\"info: \" & Txt.all);\n \n             --  Warning treated as error\n \n             elsif Errors.Table (E).Warn_Err then\n \n-               --  We prefix the tag error: rather than warning: and postfix\n+               --  We prefix with \"error:\" rather than warning: and postfix\n                --  [warning-as-error] at the end.\n \n                Warnings_Treated_As_Errors := Warnings_Treated_As_Errors + 1;\n                Txt := new String'(\"error: \" & Txt.all & \" [warning-as-error]\");\n \n-            --  Normal case, prefix\n+            --  Normal case, prefix with \"warning: \"\n \n             else\n                Txt := new String'(\"warning: \" & Txt.all);\n@@ -683,6 +686,103 @@ package body Erroutc is\n       end;\n    end Output_Msg_Text;\n \n+   ---------------------\n+   -- Prescan_Message --\n+   ---------------------\n+\n+   procedure Prescan_Message (Msg : String) is\n+      J : Natural;\n+\n+   begin\n+      --  Nothing to do for continuation line\n+\n+      if Msg (Msg'First) = '\\' then\n+         return;\n+      end if;\n+\n+      --  Set initial values of globals (may be changed during scan)\n+\n+      Is_Serious_Error     := True;\n+      Is_Unconditional_Msg := False;\n+      Is_Warning_Msg       := False;\n+      Has_Double_Exclam    := False;\n+\n+      --  Check style message\n+\n+      Is_Style_Msg :=\n+        Msg'Length > 7 and then Msg (Msg'First .. Msg'First + 6) = \"(style)\";\n+\n+      --  Check info message\n+\n+      Is_Info_Msg :=\n+        Msg'Length > 6 and then Msg (Msg'First .. Msg'First + 5) = \"info: \";\n+\n+      --  Loop through message looking for relevant insertion sequences\n+\n+      J := Msg'First;\n+      while J <= Msg'Last loop\n+\n+         --  If we have a quote, don't look at following character\n+\n+         if Msg (J) = ''' then\n+            J := J + 2;\n+\n+         --  Warning message (? or < insertion sequence)\n+\n+         elsif Msg (J) = '?' or else Msg (J) = '<' then\n+            Is_Warning_Msg := Msg (J) = '?' or else Error_Msg_Warn;\n+            Warning_Msg_Char := ' ';\n+            J := J + 1;\n+\n+            if Is_Warning_Msg then\n+               declare\n+                  C : constant Character := Msg (J - 1);\n+               begin\n+                  if J <= Msg'Last then\n+                     if Msg (J) = C then\n+                        Warning_Msg_Char := '?';\n+                        J := J + 1;\n+\n+                     elsif J < Msg'Last and then Msg (J + 1) = C\n+                       and then (Msg (J) in 'a' .. 'z' or else\n+                                 Msg (J) in 'A' .. 'Z' or else\n+                                 Msg (J) = '*'         or else\n+                                 Msg (J) = '$')\n+                     then\n+                        Warning_Msg_Char := Msg (J);\n+                        J := J + 2;\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+\n+         --  Unconditional message (! insertion)\n+\n+         elsif Msg (J) = '!' then\n+            Is_Unconditional_Msg := True;\n+            J := J + 1;\n+\n+            if J <= Msg'Last and then Msg (J) = '!' then\n+               Has_Double_Exclam := True;\n+               J := J + 1;\n+            end if;\n+\n+         --  Non-serious error (| insertion)\n+\n+         elsif Msg (J) = '|' then\n+            Is_Serious_Error := False;\n+            J := J + 1;\n+\n+         else\n+            J := J + 1;\n+         end if;\n+      end loop;\n+\n+      if Is_Warning_Msg or Is_Style_Msg then\n+         Is_Serious_Error := False;\n+      end if;\n+   end Prescan_Message;\n+\n    --------------------\n    -- Purge_Messages --\n    --------------------\n@@ -1251,6 +1351,7 @@ package body Erroutc is\n       for J in 1 .. Specific_Warnings.Last loop\n          declare\n             SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n+\n          begin\n             if Msg = SWE.Msg.all\n               and then Loc > SWE.Start\n@@ -1352,63 +1453,6 @@ package body Erroutc is\n       end if;\n    end Set_Warnings_Mode_On;\n \n-   ------------------------------------\n-   -- Test_Style_Warning_Serious_Msg --\n-   ------------------------------------\n-\n-   procedure Test_Style_Warning_Serious_Unconditional_Msg (Msg : String) is\n-   begin\n-      --  Nothing to do for continuation line\n-\n-      if Msg (Msg'First) = '\\' then\n-         return;\n-      end if;\n-\n-      --  Set initial values of globals (may be changed during scan)\n-\n-      Is_Serious_Error     := True;\n-      Is_Unconditional_Msg := False;\n-      Is_Warning_Msg       := False;\n-      Has_Double_Exclam    := False;\n-\n-      Is_Style_Msg :=\n-        (Msg'Length > 7 and then Msg (Msg'First .. Msg'First + 6) = \"(style)\");\n-\n-      for J in Msg'Range loop\n-         if Msg (J) = '?'\n-           and then (J = Msg'First or else Msg (J - 1) /= ''')\n-         then\n-            Is_Warning_Msg := True;\n-            Warning_Msg_Char := ' ';\n-\n-         elsif Msg (J) = '!'\n-           and then (J = Msg'First or else Msg (J - 1) /= ''')\n-         then\n-            Is_Unconditional_Msg := True;\n-            Warning_Msg_Char := ' ';\n-\n-            if J < Msg'Last and then Msg (J + 1) = '!' then\n-               Has_Double_Exclam := True;\n-            end if;\n-\n-         elsif Msg (J) = '<'\n-           and then (J = Msg'First or else Msg (J - 1) /= ''')\n-         then\n-            Is_Warning_Msg := Error_Msg_Warn;\n-            Warning_Msg_Char := ' ';\n-\n-         elsif Msg (J) = '|'\n-           and then (J = Msg'First or else Msg (J - 1) /= ''')\n-         then\n-            Is_Serious_Error := False;\n-         end if;\n-      end loop;\n-\n-      if Is_Warning_Msg or Is_Style_Msg then\n-         Is_Serious_Error := False;\n-      end if;\n-   end Test_Style_Warning_Serious_Unconditional_Msg;\n-\n    --------------------------------\n    -- Validate_Specific_Warnings --\n    --------------------------------"}, {"sha": "f23f4df588f9c78d773ae71defe302bcd5befbd6", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -60,15 +60,24 @@ package Erroutc is\n    --  character ! and is thus to be treated as an unconditional message.\n \n    Is_Warning_Msg : Boolean := False;\n-   --  Set True to indicate if current message is warning message (contains ?)\n+   --  Set True to indicate if current message is warning message (contains ?\n+   --  or contains < and Error_Msg_Warn is True.\n+\n+   Is_Info_Msg : Boolean := False;\n+   --  Set True to indicate that the current message starts with the characters\n+   --  \"info: \" and is to be treated as an information message. This string\n+   --  will be prepended to the message and all its continuations.\n \n    Warning_Msg_Char : Character;\n    --  Warning character, valid only if Is_Warning_Msg is True\n-   --    ' '      -- ?   appeared on its own in message\n-   --    '?'      -- ??  appeared in message\n-   --    'x'      -- ?x? appeared in message (x = a .. z)\n-   --    'X'      -- ?X? appeared in message (X = A .. Z)\n-   --    '*'      -- ?*? appeared in message\n+   --    ' '      -- ?   or <   appeared on its own in message\n+   --    '?'      -- ??  or <<  appeared in message\n+   --    'x'      -- ?x? or <x< appeared in message (x = a .. z)\n+   --    'X'      -- ?X? or <X< appeared in message (X = A .. Z)\n+   --    '*'      -- ?*? or <*< appeared in message\n+   --    '$'      -- ?$? or <$< appeared in message\n+   --  In the case of the < sequences, this is set only if the message is\n+   --  actually a warning, i.e. if Error_Msg_Warn is True\n \n    Is_Style_Msg : Boolean := False;\n    --  Set True to indicate if the current message is a style message\n@@ -194,19 +203,25 @@ package Erroutc is\n       --  Column number for error message\n \n       Warn : Boolean;\n-      --  True if warning message (i.e. insertion character ? appeared)\n+      --  True if warning message\n+\n+      Info : Boolean;\n+      --  True if info message\n \n       Warn_Err : Boolean;\n       --  True if this is a warning message which is to be treated as an error\n       --  as a result of a match with a Warning_As_Error pragma.\n \n       Warn_Chr : Character;\n       --  Warning character (note: set even if Warning_Doc_Switch is False)\n-      --    ' '      -- ?   appeared on its own in message\n-      --    '?'      -- ??  appeared in message\n-      --    'x'      -- ?x? appeared in message (x = a .. z)\n-      --    'X'      -- ?X? appeared in message (X = A .. Z)\n-      --    '*'      -- ?*? appeared in message\n+      --    ' '      -- ?   or <   appeared on its own in message\n+      --    '?'      -- ??  or <<  appeared in message\n+      --    'x'      -- ?x? or <x< appeared in message (x = a .. z)\n+      --    'X'      -- ?X? or <X< appeared in message (X = A .. Z)\n+      --    '*'      -- ?*? or <*< appeared in message\n+      --    '$'      -- ?$? or <$< appeared in message\n+      --  In the case of the < sequences, this is set only if the message is\n+      --  actually a warning, i.e. if Error_Msg_Warn is True\n \n       Style : Boolean;\n       --  True if style message (starts with \"(style)\")\n@@ -404,6 +419,34 @@ package Erroutc is\n    --  splits the line generating multiple lines of output, and in this case\n    --  the last line has no terminating end of line character.\n \n+   procedure Prescan_Message (Msg : String);\n+   --  Scans message text and sets the following variables:\n+   --\n+   --    Is_Warning_Msg is set True if Msg is a warning message (contains a\n+   --    question mark character), and False otherwise.\n+   --\n+   --    Is_Style_Msg is set True if Msg is a style message (starts with\n+   --    \"(style)\") and False otherwise.\n+   --\n+   --    Is_Info_Msg is set True if Msg is an information message (starts\n+   --    with \"info: \". Such messages must contain a ? sequence since they\n+   --    are also considered to be warning messages, and get a tag.\n+   --\n+   --    Is_Serious_Error is set to True unless the message is a warning or\n+   --    style message or contains the character | (non-serious error).\n+   --\n+   --    Is_Unconditional_Msg is set True if the message contains the character\n+   --    ! and is otherwise set False.\n+   --\n+   --    Has_Double_Exclam is set True if the message contains the sequence !!\n+   --    and is otherwise set False.\n+   --\n+   --  We need to know right away these aspects of a message, since we will\n+   --  test these values before doing the full error scan.\n+   --\n+   --  Note that the call has no effect for continuation messages (those whose\n+   --  first character is '\\'), and all variables are left unchanged.\n+\n    procedure Purge_Messages (From : Source_Ptr; To : Source_Ptr);\n    --  All error messages whose location is in the range From .. To (not\n    --  including the end points) will be deleted from the error listing.\n@@ -523,27 +566,6 @@ package Erroutc is\n    --  Called in response to a pragma Warnings (On) to record the source\n    --  location from which warnings are to be turned back on.\n \n-   procedure Test_Style_Warning_Serious_Unconditional_Msg (Msg : String);\n-   --  Scans message text and sets the following variables:\n-   --\n-   --    Is_Warning_Msg is set True if Msg is a warning message (contains a\n-   --    question mark character), and False otherwise.\n-   --\n-   --    Is_Style_Msg is set True if Msg is a style message (starts with\n-   --    \"(style)\") and False otherwise.\n-   --\n-   --    Is_Serious_Error is set to True unless the message is a warning or\n-   --    style message or contains the character | (non-serious error).\n-   --\n-   --    Is_Unconditional_Msg is set True if the message contains the character\n-   --    ! and is otherwise set False.\n-   --\n-   --    Has_Double_Exclam is set True if the message contains the sequence !!\n-   --    and is otherwise set False.\n-   --\n-   --  Note that the call has no effect for continuation messages (those whose\n-   --  first character is '\\'), and all variables are left unchanged.\n-\n    function Warnings_Suppressed (Loc : Source_Ptr) return String_Id;\n    --  Determines if given location is covered by a warnings off suppression\n    --  range in the warnings table (or is suppressed by compilation option,"}, {"sha": "f15eec9a7b17f4533eada444f81bbda32b232535", "filename": "gcc/ada/errutil.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Ferrutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrutil.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1991-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1991-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -177,7 +177,7 @@ package body Errutil is\n          raise Error_Msg_Exception;\n       end if;\n \n-      Test_Style_Warning_Serious_Unconditional_Msg (Msg);\n+      Prescan_Message (Msg);\n       Set_Msg_Text (Msg, Sptr);\n \n       --  Kill continuation if parent message killed\n@@ -212,6 +212,7 @@ package body Errutil is\n       Errors.Table (Cur_Msg).Col      := Get_Column_Number (Sptr);\n       Errors.Table (Cur_Msg).Style    := Is_Style_Msg;\n       Errors.Table (Cur_Msg).Warn     := Is_Warning_Msg;\n+      Errors.Table (Cur_Msg).Info     := Is_Info_Msg;\n       Errors.Table (Cur_Msg).Warn_Chr := Warning_Msg_Char;\n       Errors.Table (Cur_Msg).Serious  := Is_Serious_Error;\n       Errors.Table (Cur_Msg).Uncond   := Is_Unconditional_Msg;"}, {"sha": "3e72bac9063aa7e843fce58c9dcb367b2b6c6c52", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -228,10 +228,10 @@ package body Exp_Util is\n \n          if Present (Msg_Node) then\n             Error_Msg_N\n-              (\"?N?info: atomic synchronization set for &\", Msg_Node);\n+              (\"info: atomic synchronization set for &?N?\", Msg_Node);\n          else\n             Error_Msg_N\n-              (\"?N?info: atomic synchronization set\", N);\n+              (\"info: atomic synchronization set?N?\", N);\n          end if;\n       end if;\n    end Activate_Atomic_Synchronization;"}, {"sha": "0edd66ce165846746f7d48e8052acfe997d511c3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -5096,19 +5096,46 @@ This switch suppresses warnings for implicit dereferences in\n indexed components, slices, and selected components.\n \n @item -gnatw.d\n-@emph{Activate tagging of warning messages.}\n+@emph{Activate tagging of warning and info messages.}\n @cindex @option{-gnatw.d} (@command{gcc})\n-If this switch is set, then warning messages are tagged, either with\n-the string ``@option{-gnatw?}'' showing which switch controls the warning,\n-or with ``[enabled by default]'' if the warning is not under control of a\n-specific @option{-gnatw?} switch. This mode is off by default, and is not\n-affected by the use of @code{-gnatwa}.\n+If this switch is set, then warning messages are tagged, with one of the\n+following strings:\n+\n+@table @option\n+\n+@item [-gnatw?]\n+Used to tag warnings controlled by the switch @option{-gnatwx} where x\n+is a letter a-z.\n+\n+@item [-gnatw.?]\n+Used to tag warnings controlled by the switch @option{-gnatw.x} where x\n+is a letter a-z.\n+\n+@item [-gnatel]\n+Used to tag elaboration information (info) messages generated when the\n+static model of elaboration is used and the @option{-gnatel} switch is set.\n+\n+@item [restriction warning]\n+Used to tag warning messages for restriction violations, activated by use\n+of the pragma @option{Restriction_Warnings}.\n+\n+@item [warning-as-error]\n+Used to tag warning messages that have been converted to error messages by\n+use of the pragma Warning_As_Error. Note that such warnings are prefixed by\n+the string \"error: \" rather than \"warning: \".\n+\n+@item [enabled by default]\n+Used to tag all other warnings that are always given by default, unless\n+warnings are completely suppressed using pragma @option{Warnings(Off)} or\n+the switch @option{-gnatws}.\n+\n+@end table\n \n @item -gnatw.D\n-@emph{Deactivate tagging of warning messages.}\n+@emph{Deactivate tagging of warning and info messages messages.}\n @cindex @option{-gnatw.d} (@command{gcc})\n If this switch is set, then warning messages return to the default\n-mode in which warnings are not tagged as described above for\n+mode in which warnings and info messages are not tagged as described above for\n @code{-gnatw.d}.\n \n @item -gnatwe"}, {"sha": "dd4bdb4b329325445d3e920e2c772dc3f0e43ce9", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -270,7 +270,7 @@ package body Ch7 is\n                if Aspect_Sloc /= No_Location\n                  and then not Aspect_Specifications_Present\n                then\n-                  Error_Msg_SC (\"\\info: aspect specifications belong here\");\n+                  Error_Msg_SC (\"info: aspect specifications belong here??\");\n                   Move_Aspects (From => Dummy_Node, To => Package_Node);\n                end if;\n "}, {"sha": "23a48158092e577c57e00b8c2ed9cd342f300c7e", "filename": "gcc/ada/s-exctab.adb", "status": "modified", "additions": 216, "deletions": 120, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fs-exctab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fs-exctab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-exctab.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,71 +31,167 @@\n \n pragma Compiler_Unit_Warning;\n \n-with System.HTable;\n-with System.Soft_Links;   use System.Soft_Links;\n+with System.Soft_Links; use System.Soft_Links;\n \n package body System.Exception_Table is\n \n    use System.Standard_Library;\n \n-   type HTable_Headers is range 1 .. 37;\n-\n-   procedure Set_HT_Link (T : Exception_Data_Ptr; Next : Exception_Data_Ptr);\n-   function  Get_HT_Link (T : Exception_Data_Ptr) return Exception_Data_Ptr;\n-\n-   function Hash (F : System.Address) return HTable_Headers;\n-   function Equal (A, B : System.Address) return Boolean;\n-   function Get_Key (T : Exception_Data_Ptr) return System.Address;\n-\n-   package Exception_HTable is new System.HTable.Static_HTable (\n-     Header_Num => HTable_Headers,\n-     Element    => Exception_Data,\n-     Elmt_Ptr   => Exception_Data_Ptr,\n-     Null_Ptr   => null,\n-     Set_Next   => Set_HT_Link,\n-     Next       => Get_HT_Link,\n-     Key        => System.Address,\n-     Get_Key    => Get_Key,\n-     Hash       => Hash,\n-     Equal      => Equal);\n-\n-   -----------\n-   -- Equal --\n-   -----------\n-\n-   function Equal (A, B : System.Address) return Boolean is\n-      S1 : constant Big_String_Ptr := To_Ptr (A);\n-      S2 : constant Big_String_Ptr := To_Ptr (B);\n-      J : Integer := 1;\n+   type Hash_Val is mod 2 ** 8;\n+   subtype Hash_Idx is Hash_Val range 1 .. 37;\n+\n+   HTable : array (Hash_Idx) of aliased Exception_Data_Ptr;\n+   --  Actual hash table containing all registered exceptions\n+   --\n+   --  The table is very small and the hash function weak, as looking up\n+   --  registered exceptions is rare and minimizing space and time overhead\n+   --  of registration is more important. In addition, it is expected that the\n+   --  exceptions that need to be looked up are registered dynamically, and\n+   --  therefore will be at the begin of the hash chains.\n+   --\n+   --  The table differs from System.HTable.Static_HTable in that the final\n+   --  element of each chain is not marked by null, but by a pointer to self.\n+   --  This way it is possible to defend against the same entry being inserted\n+   --  twice, without having to do a lookup which is relatively expensive for\n+   --  programs with large number\n+   --\n+   --  All non-local subprograms use the global Task_Lock to protect against\n+   --  concurrent use of the exception table. This is needed as local\n+   --  exceptions may be declared concurrently with those declared at the\n+   --  library level.\n+\n+   --  Local Subprograms\n+\n+   generic\n+      with procedure Process (T : Exception_Data_Ptr; More : out Boolean);\n+   procedure Iterate;\n+   --  Iterate over all\n+\n+   function Lookup  (Name : String) return Exception_Data_Ptr;\n+   --  Find and return the Exception_Data of the exception with the given Name\n+   --  (which must be in all uppercase), or null if none was registered.\n+\n+   procedure Register (Item : Exception_Data_Ptr);\n+   --  Register an exception with the given Exception_Data in the table.\n+\n+   function Has_Name (Item : Exception_Data_Ptr; Name : String) return Boolean;\n+   --  Return True iff Item.Full_Name and Name are equal. Both names are\n+   --  assumed to be in all uppercase and end with ASCII.NUL.\n+\n+   function Hash (S : String) return Hash_Idx;\n+   --  Return the index in the hash table for S, which is assumed to be all\n+   --  uppercase and end with ASCII.NUL.\n+\n+   --------------\n+   -- Has_Name --\n+   --------------\n+\n+   function Has_Name (Item : Exception_Data_Ptr; Name : String) return Boolean\n+   is\n+      S : constant Big_String_Ptr := To_Ptr (Item.Full_Name);\n+      J : Integer := S'First;\n+\n    begin\n-      loop\n-         if S1 (J) /= S2 (J) then\n+      for K in Name'Range loop\n+\n+         --  Note that as both items are terminated with ASCII.NUL, the\n+         --  comparison below must fail for strings of different lengths.\n+\n+         if S (J) /= Name (K) then\n             return False;\n-         elsif S1 (J) = ASCII.NUL then\n-            return True;\n-         else\n-            J := J + 1;\n          end if;\n+\n+         J := J + 1;\n       end loop;\n-   end Equal;\n \n-   -----------------\n-   -- Get_HT_Link --\n-   -----------------\n+      return True;\n+   end Has_Name;\n+\n+   ------------\n+   -- Lookup --\n+   ------------\n+\n+   function Lookup (Name : String) return Exception_Data_Ptr is\n+      Prev   : Exception_Data_Ptr;\n+      Curr   : Exception_Data_Ptr;\n+\n+   begin\n+      Curr := HTable (Hash (Name));\n+      Prev := null;\n+      while Curr /= Prev loop\n+         if Has_Name (Curr, Name) then\n+            return Curr;\n+         end if;\n+\n+         Prev := Curr;\n+         Curr := Curr.HTable_Ptr;\n+      end loop;\n+\n+      return null;\n+   end Lookup;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (S : String) return Hash_Idx is\n+      Hash : Hash_Val := 0;\n \n-   function  Get_HT_Link (T : Exception_Data_Ptr) return Exception_Data_Ptr is\n    begin\n-      return T.HTable_Ptr;\n-   end Get_HT_Link;\n+      for J in S'Range loop\n+         exit when S (J) = ASCII.NUL;\n+         Hash := Hash xor Character'Pos (S (J));\n+      end loop;\n+\n+      return Hash_Idx'First + Hash mod (Hash_Idx'Last - Hash_Idx'First + 1);\n+   end Hash;\n \n    -------------\n-   -- Get_Key --\n+   -- Iterate --\n    -------------\n \n-   function Get_Key (T : Exception_Data_Ptr) return System.Address is\n+   procedure Iterate is\n+      More : Boolean;\n+      Prev, Curr : Exception_Data_Ptr;\n+\n    begin\n-      return T.Full_Name;\n-   end Get_Key;\n+      Outer : for Idx in HTable'Range loop\n+         Prev   := null;\n+         Curr   := HTable (Idx);\n+\n+         while Curr /= Prev loop\n+               Process (Curr, More);\n+\n+               exit Outer when not More;\n+\n+               Prev := Curr;\n+               Curr := Curr.HTable_Ptr;\n+         end loop;\n+      end loop Outer;\n+   end Iterate;\n+\n+   --------------\n+   -- Register --\n+   --------------\n+\n+   procedure Register (Item : Exception_Data_Ptr) is\n+   begin\n+      if Item.HTable_Ptr = null then\n+         Prepend_To_Chain : declare\n+            Chain : Exception_Data_Ptr\n+                      renames HTable (Hash (To_Ptr (Item.Full_Name).all));\n+\n+         begin\n+            if Chain = null then\n+               Item.HTable_Ptr := Item;\n+            else\n+               Item.HTable_Ptr := Chain;\n+            end if;\n+\n+            Chain := Item;\n+         end Prepend_To_Chain;\n+      end if;\n+   end Register;\n \n    -------------------------------\n    -- Get_Registered_Exceptions --\n@@ -105,44 +201,40 @@ package body System.Exception_Table is\n      (List : out Exception_Data_Array;\n       Last : out Integer)\n    is\n-      Data : Exception_Data_Ptr := Exception_HTable.Get_First;\n+      procedure Get_One (Item : Exception_Data_Ptr; More : out Boolean);\n+      --  Add Item to List (List'First .. Last) by first incrementing Last\n+      --  and storing Item in List (Last). Last should be in List'First - 1\n+      --  and List'Last.\n \n-   begin\n-      Lock_Task.all;\n-      Last := List'First - 1;\n+      procedure Get_All is new Iterate (Get_One);\n+      --  Store all registered exceptions in List, updating Last\n \n-      while Last < List'Last and then Data /= null loop\n-         Last := Last + 1;\n-         List (Last) := Data;\n-         Data := Exception_HTable.Get_Next;\n-      end loop;\n+      -------------\n+      -- Get_One --\n+      -------------\n \n-      Unlock_Task.all;\n-   end Get_Registered_Exceptions;\n+      procedure Get_One (Item : Exception_Data_Ptr; More : out Boolean) is\n+      begin\n+         if Last < List'Last then\n+            Last := Last + 1;\n+            List (Last) := Item;\n+            More := True;\n \n-   ----------\n-   -- Hash --\n-   ----------\n+         else\n+            More := False;\n+         end if;\n+      end Get_One;\n \n-   function Hash (F : System.Address) return HTable_Headers is\n-      type S is mod 2**8;\n+   begin\n+      --  In this routine the invariant is that List (List'First .. Last)\n+      --  contains the registered exceptions retrieved so far.\n \n-      Str  : constant Big_String_Ptr := To_Ptr (F);\n-      Size : constant S := S (HTable_Headers'Last - HTable_Headers'First + 1);\n-      Tmp  : S := 0;\n-      J    : Positive;\n+      Last := List'First - 1;\n \n-   begin\n-      J := 1;\n-      loop\n-         if Str (J) = ASCII.NUL then\n-            return HTable_Headers'First + HTable_Headers'Base (Tmp mod Size);\n-         else\n-            Tmp := Tmp xor S (Character'Pos (Str (J)));\n-         end if;\n-         J := J + 1;\n-      end loop;\n-   end Hash;\n+      Lock_Task.all;\n+      Get_All;\n+      Unlock_Task.all;\n+   end Get_Registered_Exceptions;\n \n    ------------------------\n    -- Internal_Exception --\n@@ -152,25 +244,30 @@ package body System.Exception_Table is\n      (X                   : String;\n       Create_If_Not_Exist : Boolean := True) return Exception_Data_Ptr\n    is\n+      --  If X was not yet registered and Create_if_Not_Exist is True,\n+      --  dynamically allocate and register a new exception.\n+\n       type String_Ptr is access all String;\n \n-      Copy     : aliased String (X'First .. X'Last + 1);\n-      Res      : Exception_Data_Ptr;\n       Dyn_Copy : String_Ptr;\n+      Copy     : aliased String (X'First .. X'Last + 1);\n+      Result   : Exception_Data_Ptr;\n \n    begin\n+      Lock_Task.all;\n+\n       Copy (X'Range) := X;\n       Copy (Copy'Last) := ASCII.NUL;\n-      Res := Exception_HTable.Get (Copy'Address);\n+      Result := Lookup (Copy);\n \n       --  If unknown exception, create it on the heap. This is a legitimate\n-      --  situation in the distributed case when an exception is defined only\n-      --  in a partition\n+      --  situation in the distributed case when an exception is defined\n+      --  only in a partition\n \n-      if Res = null and then Create_If_Not_Exist then\n+      if Result = null and then Create_If_Not_Exist then\n          Dyn_Copy := new String'(Copy);\n \n-         Res :=\n+         Result :=\n            new Exception_Data'\n              (Not_Handled_By_Others => False,\n               Lang                  => 'A',\n@@ -180,10 +277,12 @@ package body System.Exception_Table is\n               Foreign_Data          => Null_Address,\n               Raise_Hook            => null);\n \n-         Register_Exception (Res);\n+         Register (Result);\n       end if;\n \n-      return Res;\n+      Unlock_Task.all;\n+\n+      return Result;\n    end Internal_Exception;\n \n    ------------------------\n@@ -192,7 +291,9 @@ package body System.Exception_Table is\n \n    procedure Register_Exception (X : Exception_Data_Ptr) is\n    begin\n-      Exception_HTable.Set (X);\n+      Lock_Task.all;\n+      Register (X);\n+      Unlock_Task.all;\n    end Register_Exception;\n \n    ---------------------------------\n@@ -201,43 +302,38 @@ package body System.Exception_Table is\n \n    function Registered_Exceptions_Count return Natural is\n       Count : Natural := 0;\n-      Data  : Exception_Data_Ptr := Exception_HTable.Get_First;\n \n-   begin\n-      --  We need to lock the runtime in the meantime, to avoid concurrent\n-      --  access since we have only one iterator.\n-\n-      Lock_Task.all;\n+      procedure Count_Item (Item : Exception_Data_Ptr; More : out Boolean);\n+      --  Update Count for given Item\n \n-      while Data /= null loop\n+      procedure Count_Item (Item : Exception_Data_Ptr; More : out Boolean) is\n+         pragma Unreferenced (Item);\n+      begin\n          Count := Count + 1;\n-         Data := Exception_HTable.Get_Next;\n-      end loop;\n+         More := Count < Natural'Last;\n+      end Count_Item;\n \n-      Unlock_Task.all;\n-      return Count;\n-   end Registered_Exceptions_Count;\n-\n-   -----------------\n-   -- Set_HT_Link --\n-   -----------------\n+      procedure Count_All is new Iterate (Count_Item);\n \n-   procedure Set_HT_Link\n-     (T    : Exception_Data_Ptr;\n-      Next : Exception_Data_Ptr)\n-   is\n    begin\n-      T.HTable_Ptr := Next;\n-   end Set_HT_Link;\n+      Lock_Task.all;\n+      Count_All;\n+      Unlock_Task.all;\n \n---  Register the standard exceptions at elaboration time\n+      return Count;\n+   end Registered_Exceptions_Count;\n \n begin\n-   Register_Exception (Abort_Signal_Def'Access);\n-   Register_Exception (Tasking_Error_Def'Access);\n-   Register_Exception (Storage_Error_Def'Access);\n-   Register_Exception (Program_Error_Def'Access);\n-   Register_Exception (Numeric_Error_Def'Access);\n-   Register_Exception (Constraint_Error_Def'Access);\n-\n+   --  Register the standard exceptions at elaboration time\n+\n+   --  We don't need to use the locking version here as the elaboration\n+   --  will not be concurrent and no tasks can call any subprograms of this\n+   --  unit before it has been elaborated.\n+\n+   Register (Abort_Signal_Def'Access);\n+   Register (Tasking_Error_Def'Access);\n+   Register (Storage_Error_Def'Access);\n+   Register (Program_Error_Def'Access);\n+   Register (Numeric_Error_Def'Access);\n+   Register (Constraint_Error_Def'Access);\n end System.Exception_Table;"}, {"sha": "6417523335a048f9ea5cfd0c3585bad2ec0a7890", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -661,12 +661,12 @@ package body Sem_Ch13 is\n \n                            if Bytes_Big_Endian then\n                               Error_Msg_NE\n-                                (\"\\info: big-endian range for \"\n+                                (\"\\big-endian range for \"\n                                  & \"component & is ^ .. ^?V?\",\n                                  First_Bit (CC), Comp);\n                            else\n                               Error_Msg_NE\n-                                (\"\\info: little-endian range \"\n+                                (\"\\little-endian range \"\n                                  & \"for component & is ^ .. ^?V?\",\n                                  First_Bit (CC), Comp);\n                            end if;\n@@ -6324,7 +6324,7 @@ package body Sem_Ch13 is\n                if Inherit and Opt.List_Inherited_Aspects then\n                   Error_Msg_Sloc := Sloc (Ritem);\n                   Error_Msg_N\n-                    (\"?L?info: & inherits `Invariant''Class` aspect from #\",\n+                    (\"info: & inherits `Invariant''Class` aspect from #?L?\",\n                      Typ);\n                end if;\n             end if;"}, {"sha": "d9a9dab88ec2f78e5a713324d038e423ddb9fe7c", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -2885,13 +2885,12 @@ package body Sem_Ch7 is\n       --  Body required if library package with pragma Elaborate_Body\n \n       elsif Has_Pragma_Elaborate_Body (P) then\n-         Error_Msg_N\n-           (\"?Y?info: & requires body (Elaborate_Body)\", P);\n+         Error_Msg_N (\"info: & requires body (Elaborate_Body)?Y?\", P);\n \n       --  Body required if subprogram\n \n       elsif Is_Subprogram (P) or else Is_Generic_Subprogram (P) then\n-         Error_Msg_N (\"?Y?info: & requires body (subprogram case)\", P);\n+         Error_Msg_N (\"info: & requires body (subprogram case)?Y?\", P);\n \n       --  Body required if generic parent has Elaborate_Body\n \n@@ -2904,7 +2903,7 @@ package body Sem_Ch7 is\n          begin\n             if Has_Pragma_Elaborate_Body (G_P) then\n                Error_Msg_N\n-                 (\"?Y?info: & requires body (generic parent Elaborate_Body)\",\n+                 (\"info: & requires body (generic parent Elaborate_Body)?Y?\",\n                   P);\n             end if;\n          end;\n@@ -2922,7 +2921,7 @@ package body Sem_Ch7 is\n           not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n       then\n          Error_Msg_N\n-           (\"?Y?info: & requires body (non-null abstract state aspect)\", P);\n+           (\"info: & requires body (non-null abstract state aspect)?Y?\", P);\n       end if;\n \n       --  Otherwise search entity chain for entity requiring completion\n@@ -2985,7 +2984,7 @@ package body Sem_Ch7 is\n          then\n             Error_Msg_Node_2 := E;\n             Error_Msg_NE\n-              (\"?Y?info: & requires body (& requires completion)\",\n+              (\"info: & requires body (& requires completion)?Y?\",\n                E, P);\n \n          --  Entity that does not require completion"}, {"sha": "da327315730e372aaeed01007ba4e30038f55359", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=2e57f88b778de597f3bd3ed2fbe2b634eb46fc2d", "patch": "@@ -942,15 +942,15 @@ package body Sem_Elab is\n                if Inst_Case then\n                   Elab_Warning\n                     (\"instantiation of& may raise Program_Error?l?\",\n-                     \"info: instantiation of& during elaboration?\", Ent);\n+                     \"info: instantiation of& during elaboration?$?\", Ent);\n \n                --  Indirect call case, info message only in static elaboration\n                --  case, because the attribute reference itself cannot raise\n                --  an exception.\n \n                elsif Access_Case then\n                   Elab_Warning\n-                    (\"\", \"info: access to& during elaboration?\", Ent);\n+                    (\"\", \"info: access to& during elaboration?$?\", Ent);\n \n                --  Subprogram call case\n \n@@ -961,13 +961,13 @@ package body Sem_Elab is\n                   then\n                      Elab_Warning\n                        (\"implicit call to & may raise Program_Error?l?\",\n-                        \"info: implicit call to & during elaboration?\",\n+                        \"info: implicit call to & during elaboration?$?\",\n                         Ent);\n \n                   else\n                      Elab_Warning\n                        (\"call to & may raise Program_Error?l?\",\n-                        \"info: call to & during elaboration?\",\n+                        \"info: call to & during elaboration?$?\",\n                         Ent);\n                   end if;\n                end if;\n@@ -977,13 +977,13 @@ package body Sem_Elab is\n                if Nkind (N) in N_Subprogram_Instantiation then\n                   Elab_Warning\n                     (\"\\missing pragma Elaborate for&?l?\",\n-                     \"\\info: implicit pragma Elaborate for& generated?\",\n+                     \"\\implicit pragma Elaborate for& generated?$?\",\n                      W_Scope);\n \n                else\n                   Elab_Warning\n                     (\"\\missing pragma Elaborate_All for&?l?\",\n-                     \"\\info: implicit pragma Elaborate_All for & generated?\",\n+                     \"\\implicit pragma Elaborate_All for & generated?$?\",\n                      W_Scope);\n                end if;\n             end Generate_Elab_Warnings;\n@@ -1063,7 +1063,7 @@ package body Sem_Elab is\n                   Error_Msg_Node_2 := W_Scope;\n                   Error_Msg_NE\n                     (\"info: call to& in elaboration code \" &\n-                     \"requires pragma Elaborate_All on&?\", N, E);\n+                     \"requires pragma Elaborate_All on&?$?\", N, E);\n                end if;\n \n                --  Set indication for binder to generate Elaborate_All\n@@ -2320,15 +2320,14 @@ package body Sem_Elab is\n \n             if Inst_Case then\n                Error_Msg_NE\n-                 (\"instantiation of& may occur before body is seen<<\",\n+                 (\"instantiation of& may occur before body is seen<l<\",\n                   N, Orig_Ent);\n             else\n                Error_Msg_NE\n-                 (\"call to& may occur before body is seen<<\", N, Orig_Ent);\n+                 (\"call to& may occur before body is seen<l<\", N, Orig_Ent);\n             end if;\n \n-            Error_Msg_N\n-              (\"\\Program_Error ]<<\", N);\n+            Error_Msg_N (\"\\Program_Error ]<l<\", N);\n \n             Output_Calls (N);\n          end if;\n@@ -2570,7 +2569,7 @@ package body Sem_Elab is\n                Error_Msg_Node_2 := Task_Scope;\n                Error_Msg_NE\n                  (\"info: activation of an instance of task type&\" &\n-                  \" requires pragma Elaborate_All on &?\", N, Ent);\n+                  \" requires pragma Elaborate_All on &?$?\", N, Ent);\n             end if;\n \n             Activate_Elaborate_All_Desirable (N, Task_Scope);\n@@ -3056,6 +3055,10 @@ package body Sem_Elab is\n       --  by the error message circuits (i.e. it has a single upper\n       --  case letter at the end).\n \n+      -----------------------------\n+      -- Is_Printable_Error_Name --\n+      -----------------------------\n+\n       function Is_Printable_Error_Name (Nm : Name_Id) return Boolean is\n       begin\n          if not Is_Internal_Name (Nm) then\n@@ -3078,17 +3081,31 @@ package body Sem_Elab is\n \n          Ent := Elab_Call.Table (J).Ent;\n \n-         if Is_Generic_Unit (Ent) then\n-            Error_Msg_NE (\"\\??& instantiated #\", N, Ent);\n+         --  Dynamic elaboration model, warnings controlled by -gnatwl\n \n-         elsif Is_Init_Proc (Ent) then\n-            Error_Msg_N (\"\\??initialization procedure called #\", N);\n+         if Dynamic_Elaboration_Checks then\n+            if Is_Generic_Unit (Ent) then\n+               Error_Msg_NE (\"\\\\?l?& instantiated #\", N, Ent);\n+            elsif Is_Init_Proc (Ent) then\n+               Error_Msg_N (\"\\\\?l?initialization procedure called #\", N);\n+            elsif Is_Printable_Error_Name (Chars (Ent)) then\n+               Error_Msg_NE (\"\\\\?l?& called #\", N, Ent);\n+            else\n+               Error_Msg_N (\"\\\\?l?called #\", N);\n+            end if;\n \n-         elsif Is_Printable_Error_Name (Chars (Ent)) then\n-            Error_Msg_NE (\"\\??& called #\", N, Ent);\n+         --  Static elaboration model, info messages controlled by -gnatel\n \n          else\n-            Error_Msg_N (\"\\?? called #\", N);\n+            if Is_Generic_Unit (Ent) then\n+               Error_Msg_NE (\"\\\\?$?& instantiated #\", N, Ent);\n+            elsif Is_Init_Proc (Ent) then\n+               Error_Msg_N (\"\\\\?$?initialization procedure called #\", N);\n+            elsif Is_Printable_Error_Name (Chars (Ent)) then\n+               Error_Msg_NE (\"\\\\?$?& called #\", N, Ent);\n+            else\n+               Error_Msg_N (\"\\\\?$?called #\", N);\n+            end if;\n          end if;\n       end loop;\n    end Output_Calls;"}]}