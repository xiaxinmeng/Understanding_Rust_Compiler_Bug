{"sha": "f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBhMDM5MGU2OTFlY2UwZDg1OWI3ZDg3YzZlNjYxN2QyMjdjYjhkZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-09-28T20:44:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-09-28T20:44:58Z"}, "message": "Hookize TARGET_UNWIND_INFO et al.\n\nFrom-SVN: r164701", "tree": {"sha": "abc0f2fe4784df2eb251f4c04a0493fec3eac91d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc0f2fe4784df2eb251f4c04a0493fec3eac91d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/comments", "author": null, "committer": null, "parents": [{"sha": "c165dca7efdb3f4bdae82c01b409a6b9cf4dbd65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c165dca7efdb3f4bdae82c01b409a6b9cf4dbd65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c165dca7efdb3f4bdae82c01b409a6b9cf4dbd65"}], "stats": {"total": 736, "additions": 482, "deletions": 254}, "files": [{"sha": "c4304e618766906c7b71c5711ba55b150983a472", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,68 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* defaults.h (DWARF2_UNWIND_INFO): Don't depend on TARGET_UNWIND_INFO.\n+\t(MUST_USE_SJLJ_EXCEPTIONS): Remove.\n+\t(CONFIG_SJLJ_EXCEPTIONS): Remove.\n+\t(STACK_OLD_CHECK_PROTECT): Use targetm.except_unwind_info.\n+\t(STACK_CHECK_PROTECT): Likewise.\n+\t* dwarf2out.c (DWARF2_UNWIND_INFO, DWARF2_FRAME_INFO): Poison.\n+\t(dwarf2out_do_frame): Use debug_unwind_info and except_unwind_info.\n+\t(dwarf2out_do_cfi_asm, dwarf2out_begin_prologue): Likewise.\n+\t(dwarf2out_frame_init, dwarf2out_frame_finish): Likewise.\n+\t(dwarf2out_assembly_start): Likewise.\n+\t* except.c (init_eh): Use targetm.except_unwind_info.\n+\t(finish_eh_generation, gate_convert_to_eh_region_ranges): Likewise.\n+\t(output_one_function_exception_table): Likewise.\n+\t* final.c: Unconditionally include dwarf2out.h.\n+\t(final_start_function): Unconditionally call dwarf2out routines.\n+\t(final_end_function, final_scan_insn): Likewise.\n+\t* function.c (expand_function_end): Use targetm.except_unwind_info.\n+\t* opts.c (decode_options): Use targetm.except_unwind_info.\n+\t* system.h (USING_SJLJ_EXCEPTIONS, TARGET_UNWIND_INFO): Poison.\n+\t* target.def (debug_unwind_info, except_unwind_info): New.\n+\t* target.h (enum unwind_info_type): New.\n+\t* targhooks.c (default_debug_unwind_info): New.\n+\t(default_except_unwind_info): New.\n+\t(dwarf2_except_unwind_info, sjlj_except_unwind_info): New.\n+\t* targhooks.h: Declare them.\n+\t* tree-tailcall.c: Include \"target.h\"\n+\t(suitable_for_tail_call_opt_p): Use targetm.except_unwind_info.\n+\t* Makefile.in (tree-tailcall.o): Update.\n+\t* tree.c (build_common_builtin_nodes): Use targetm.except_unwind_info.\n+\t(lhd_gcc_personality): Likewise.\n+\n+\t* doc/tm.texi.in (TARGET_UNWIND_INFO): Remove.\n+\t(TARGET_EXCEPT_UNWIND_INFO): New.\n+\t(DWARF2_UNWIND_INFO): Update.\n+\t(TARGET_DEBUG_UNWIND_INFO): New.\n+\t* doc/tm.texi: Rebuild.\n+\n+\t* c-family/c-cppbuiltin.c (c_cpp_builtins): Use\n+\ttargetm.except_unwind_info.\n+\n+\t* config/arm/arm.c (TARGET_EXCEPT_UNWIND_INFO): New.\n+\t(arm_except_unwind_info): New.\n+\t(arm_compute_func_type): Use it.\n+\t(arm_expand_prologue, thumb_pushpop): Likewise.\n+\t(thumb1_expand_prologue, thumb1_output_function_prologue): Likewise.\n+\t(arm_unwind_emit, arm_output_fn_unwind): Likewise.\n+\t* config/arm/bpabi.h (ARM_UNWIND_INFO): Rename from TARGET_UNWIND_INFO.\n+\t* config/arm/arm.h (ARM_UNWIND_INFO): Likewise.\n+\t(DWARF2_UNWIND_INFO): Remove.\n+\t(MUST_USE_SJLJ_EXCEPTIONS): Remove.\n+\t(ARM_EABI_UNWIND_TABLES): Remove.\n+\n+\t* config/ia64/ia64.c (ia64_debug_unwind_info): New.\n+\t(TARGET_DEBUG_UNWIND_INFO, TARGET_EXCEPT_UNWIND_INFO): New.\n+\t(ia64_except_unwind_info): New.\n+\t(ia64_output_function_prologue): Use it.\n+\t(ia64_add_bundle_selector_before): Likewise.\n+\t(ia64_reorg, ia64_asm_unwind_emit): Likewise.\n+\t* config/ia64/ia64.h (DWARF2_FRAME_INFO): Remove.\n+\t(TARGET_UNWIND_INFO): Remove.\n+\n+\t* config/pa/pa.c (pa_option_override): Use targetm.except_unwind_info.\n+\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* c-parser.c (c_parser_objc_class_definition): Adjust prototype."}, {"sha": "dc10c58a124d61ec5b0575a21f92367893b1913b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -2501,7 +2501,7 @@ tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(EXCEPT_H) $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n-   $(BASIC_BLOCK_H) $(DBGCNT_H) gimple-pretty-print.h\n+   $(BASIC_BLOCK_H) $(DBGCNT_H) gimple-pretty-print.h $(TARGET_H)\n tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) alloc-pool.h \\"}, {"sha": "44a127a98e9b39fa1d939ab2c3a5435386e988b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,8 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc-interface/misc.c (gnat_eh_personality): Use\n+\ttargetm.except_unwind_info.\n+\n 2010-09-28  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc-interface/utils.c (handle_leaf_attribute): New function."}, {"sha": "1819977a7adf2bcff6e71d7cf048226551f71e4b", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -766,7 +766,7 @@ gnat_eh_personality (void)\n {\n   if (!gnat_eh_personality_decl)\n     gnat_eh_personality_decl\n-      = build_personality_function (USING_SJLJ_EXCEPTIONS\n+      = build_personality_function (targetm.except_unwind_info () == UI_SJLJ\n \t\t\t\t    ? \"__gnat_eh_personality_sj\"\n \t\t\t\t    : \"__gnat_eh_personality\");\n "}, {"sha": "86e45209b479a4dd8f962aeeec857bac66f3b201", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -601,7 +601,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t\t\t\t   1000 + flag_abi_version);\n \n   /* libgcc needs to know this.  */\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     cpp_define (pfile, \"__USING_SJLJ_EXCEPTIONS__\");\n \n   /* limits.h and stdint.h need to know these.  */"}, {"sha": "2ff010bc702bc79a85707f8da6a8ccc798e36034", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -193,12 +193,13 @@ static bool arm_align_anon_bitfield (void);\n static bool arm_return_in_msb (const_tree);\n static bool arm_must_pass_in_stack (enum machine_mode, const_tree);\n static bool arm_return_in_memory (const_tree, const_tree);\n-#ifdef TARGET_UNWIND_INFO\n+#if ARM_UNWIND_INFO\n static void arm_unwind_emit (FILE *, rtx);\n static bool arm_output_ttype (rtx);\n static void arm_asm_emit_except_personality (rtx);\n static void arm_asm_init_sections (void);\n #endif\n+static enum unwind_info_type arm_except_unwind_info (void);\n static void arm_dwarf_handle_frame_unspec (const char *, rtx, int);\n static rtx arm_dwarf_register_span (rtx);\n \n@@ -461,7 +462,7 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK arm_must_pass_in_stack\n \n-#ifdef TARGET_UNWIND_INFO\n+#if ARM_UNWIND_INFO\n #undef TARGET_ASM_UNWIND_EMIT\n #define TARGET_ASM_UNWIND_EMIT arm_unwind_emit\n \n@@ -477,7 +478,10 @@ static const struct attribute_spec arm_attribute_table[] =\n \n #undef TARGET_ASM_INIT_SECTIONS\n #define TARGET_ASM_INIT_SECTIONS arm_asm_init_sections\n-#endif /* TARGET_UNWIND_INFO */\n+#endif /* ARM_UNWIND_INFO */\n+\n+#undef TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO  arm_except_unwind_info\n \n #undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n #define TARGET_DWARF_HANDLE_FRAME_UNSPEC arm_dwarf_handle_frame_unspec\n@@ -2032,7 +2036,7 @@ arm_compute_func_type (void)\n   if (optimize > 0\n       && (TREE_NOTHROW (current_function_decl)\n           || !(flag_unwind_tables\n-               || (flag_exceptions && !USING_SJLJ_EXCEPTIONS)))\n+               || (flag_exceptions && arm_except_unwind_info () != UI_SJLJ)))\n       && TREE_THIS_VOLATILE (current_function_decl))\n     type |= ARM_FT_VOLATILE;\n \n@@ -15719,7 +15723,8 @@ arm_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (ARM_EABI_UNWIND_TABLES && cfun->can_throw_non_call_exceptions))\n+      || (arm_except_unwind_info () == UI_TARGET\n+\t  && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n   /* If the link register is being kept alive, with the return address in it,\n@@ -19575,7 +19580,7 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n       return;\n     }\n \n-  if (ARM_EABI_UNWIND_TABLES && push)\n+  if (push && arm_except_unwind_info () == UI_TARGET)\n     {\n       fprintf (f, \"\\t.save\\t{\");\n       for (regno = 0; regno < 15; regno++)\n@@ -20515,7 +20520,8 @@ thumb1_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (ARM_EABI_UNWIND_TABLES && cfun->can_throw_non_call_exceptions))\n+      || (arm_except_unwind_info () == UI_TARGET\n+\t  && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n   cfun->machine->lr_save_eliminated = !thumb_force_lr_save ();\n@@ -20628,7 +20634,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   if (crtl->args.pretend_args_size)\n     {\n       /* Output unwind directive for the stack adjustment.  */\n-      if (ARM_EABI_UNWIND_TABLES)\n+      if (arm_except_unwind_info () == UI_TARGET)\n \tfprintf (f, \"\\t.pad #%d\\n\",\n \t\t crtl->args.pretend_args_size);\n \n@@ -20698,7 +20704,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       work_register = thumb_find_work_register (live_regs_mask);\n \n-      if (ARM_EABI_UNWIND_TABLES)\n+      if (arm_except_unwind_info () == UI_TARGET)\n \tasm_fprintf (f, \"\\t.pad #16\\n\");\n \n       asm_fprintf\n@@ -22061,7 +22067,7 @@ arm_dwarf_register_span (rtx rtl)\n   return p;\n }\n \n-#ifdef TARGET_UNWIND_INFO\n+#if ARM_UNWIND_INFO\n /* Emit unwind directives for a store-multiple instruction or stack pointer\n    push during alignment.\n    These should only ever be generated by the function prologue code, so\n@@ -22275,7 +22281,7 @@ arm_unwind_emit (FILE * asm_out_file, rtx insn)\n {\n   rtx pat;\n \n-  if (!ARM_EABI_UNWIND_TABLES)\n+  if (arm_except_unwind_info () != UI_TARGET)\n     return;\n \n   if (!(flag_unwind_tables || crtl->uses_eh_lsda)\n@@ -22344,7 +22350,33 @@ arm_asm_init_sections (void)\n   exception_section = get_unnamed_section (0, output_section_asm_op,\n \t\t\t\t\t   \"\\t.handlerdata\");\n }\n-#endif /* TARGET_UNWIND_INFO */\n+#endif /* ARM_UNWIND_INFO */\n+\n+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n+\n+static enum unwind_info_type\n+arm_except_unwind_info (void)\n+{\n+  /* Honor the --enable-sjlj-exceptions configure switch.  */\n+#ifdef CONFIG_SJLJ_EXCEPTIONS\n+  if (CONFIG_SJLJ_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  /* If not using ARM EABI unwind tables... */\n+  if (ARM_UNWIND_INFO)\n+    {\n+      /* For simplicity elsewhere in this file, indicate that all unwind\n+\t info is disabled if we're not emitting unwind tables.  */\n+      if (!flag_exceptions && !flag_unwind_tables)\n+\treturn UI_NONE;\n+      else\n+\treturn UI_TARGET;\n+    }\n+\n+  /* ... we use sjlj exceptions for backwards compatibility.  */\n+  return UI_SJLJ;\n+}\n \n \n /* Handle UNSPEC DWARF call frame instructions.  These are needed for dynamic\n@@ -22376,7 +22408,7 @@ arm_dwarf_handle_frame_unspec (const char *label, rtx pattern, int index)\n void\n arm_output_fn_unwind (FILE * f, bool prologue)\n {\n-  if (!ARM_EABI_UNWIND_TABLES)\n+  if (arm_except_unwind_info () != UI_TARGET)\n     return;\n \n   if (prologue)"}, {"sha": "9bbe346d44c6f6b12057db12d0507877522b249f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -948,14 +948,11 @@ extern int arm_structure_size_boundary;\n #define FIRST_HI_REGNUM\t\t8\n #define LAST_HI_REGNUM\t\t11\n \n-#ifndef TARGET_UNWIND_INFO\n-/* We use sjlj exceptions for backwards compatibility.  */\n-#define MUST_USE_SJLJ_EXCEPTIONS 1\n+/* Overridden by config/arm/bpabi.h.  */\n+#ifndef ARM_UNWIND_INFO\n+#define ARM_UNWIND_INFO  0\n #endif\n \n-/* We can generate DWARF2 Unwind info, even though we don't use it.  */\n-#define DWARF2_UNWIND_INFO 1\n-\n /* Use r0 and r1 to pass exception handling information.  */\n #define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? N : INVALID_REGNUM)\n \n@@ -2033,13 +2030,6 @@ typedef struct\n \n #define ARM_OUTPUT_FN_UNWIND(F, PROLOGUE) arm_output_fn_unwind (F, PROLOGUE)\n \n-#ifdef TARGET_UNWIND_INFO\n-#define ARM_EABI_UNWIND_TABLES \\\n-  ((!USING_SJLJ_EXCEPTIONS && flag_exceptions) || flag_unwind_tables)\n-#else\n-#define ARM_EABI_UNWIND_TABLES 0\n-#endif\n-\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them."}, {"sha": "9a59b47de072cab4dea374996a93b49b89d035c6", "filename": "gcc/config/arm/bpabi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Fbpabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Farm%2Fbpabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fbpabi.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -26,7 +26,8 @@\n #define TARGET_BPABI (TARGET_AAPCS_BASED)\n \n /* BPABI targets use EABI frame unwinding tables.  */\n-#define TARGET_UNWIND_INFO 1\n+#undef ARM_UNWIND_INFO\n+#define ARM_UNWIND_INFO 1\n \n /* Section 4.1 of the AAPCS requires the use of VFP format.  */\n #undef  FPUTYPE_DEFAULT"}, {"sha": "f75e42b89794dcc185b7fd829653d56ac0f215c3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -251,6 +251,9 @@ static void ia64_asm_unwind_emit (FILE *, rtx);\n static void ia64_asm_emit_except_personality (rtx);\n static void ia64_asm_init_sections (void);\n \n+static enum unwind_info_type ia64_debug_unwind_info (void);\n+static enum unwind_info_type ia64_except_unwind_info (void);\n+\n static struct bundle_state *get_free_bundle_state (void);\n static void free_bundle_state (struct bundle_state *);\n static void initiate_bundle_states (void);\n@@ -537,6 +540,11 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_ASM_INIT_SECTIONS\n #define TARGET_ASM_INIT_SECTIONS  ia64_asm_init_sections\n \n+#undef TARGET_DEBUG_UNWIND_INFO\n+#define TARGET_DEBUG_UNWIND_INFO  ia64_debug_unwind_info\n+#undef TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO  ia64_except_unwind_info\n+\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P ia64_scalar_mode_supported_p\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n@@ -3903,7 +3911,7 @@ ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t     current_frame_info.n_output_regs,\n \t     current_frame_info.n_rotate_regs);\n \n-  if (!flag_unwind_tables && (!flag_exceptions || USING_SJLJ_EXCEPTIONS))\n+  if (ia64_except_unwind_info () != UI_TARGET)\n     return;\n \n   /* Emit the .prologue directive.  */\n@@ -3961,7 +3969,7 @@ ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n static void\n ia64_output_function_end_prologue (FILE *file)\n {\n-  if (!flag_unwind_tables && (!flag_exceptions || USING_SJLJ_EXCEPTIONS))\n+  if (ia64_except_unwind_info () != UI_TARGET)\n     return;\n \n   fputs (\"\\t.body\\n\", file);\n@@ -8558,7 +8566,7 @@ ia64_add_bundle_selector_before (int template0, rtx insn)\n   ia64_emit_insn_before (b, insn);\n #if NR_BUNDLES == 10\n   if ((template0 == 4 || template0 == 5)\n-      && (flag_unwind_tables || (flag_exceptions && !USING_SJLJ_EXCEPTIONS)))\n+      && ia64_except_unwind_info () == UI_TARGET)\n     {\n       int i;\n       rtx note = NULL_RTX;\n@@ -9399,7 +9407,7 @@ ia64_reorg (void)\n   /* A call must not be the last instruction in a function, so that the\n      return address is still within the function, so that unwinding works\n      properly.  Note that IA-64 differs from dwarf2 on this point.  */\n-  if (flag_unwind_tables || (flag_exceptions && !USING_SJLJ_EXCEPTIONS))\n+  if (ia64_except_unwind_info () == UI_TARGET)\n     {\n       rtx insn;\n       int saw_stop = 0;\n@@ -9865,8 +9873,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n static void\n ia64_asm_unwind_emit (FILE *asm_out_file, rtx insn)\n {\n-  bool unwind = (flag_unwind_tables\n-\t\t || (flag_exceptions && !USING_SJLJ_EXCEPTIONS));\n+  bool unwind = ia64_except_unwind_info () == UI_TARGET;\n   bool frame = dwarf2out_do_frame ();\n   rtx note, pat;\n   bool handled_one;\n@@ -9991,6 +9998,33 @@ ia64_asm_init_sections (void)\n   exception_section = get_unnamed_section (0, output_section_asm_op,\n \t\t\t\t\t   \"\\t.handlerdata\");\n }\n+\n+/* Implement TARGET_DEBUG_UNWIND_INFO.  */\n+\n+static enum unwind_info_type\n+ia64_debug_unwind_info (void)\n+{\n+  return UI_TARGET;\n+}\n+\n+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n+\n+static enum unwind_info_type\n+ia64_except_unwind_info (void)\n+{\n+  /* Honor the --enable-sjlj-exceptions configure switch.  */\n+#ifdef CONFIG_UNWIND_EXCEPTIONS\n+  if (CONFIG_UNWIND_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  /* For simplicity elsewhere in this file, indicate that all unwind\n+     info is disabled if we're not emitting unwind tables.  */\n+  if (!flag_exceptions && !flag_unwind_tables)\n+    return UI_NONE;\n+\n+  return UI_TARGET;\n+}\n \f\n enum ia64_builtins\n {"}, {"sha": "98e9b64d05aad751d4c3ba5a9e1ea6a0cf7f1a07", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1731,12 +1731,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define DWARF2_DEBUGGING_INFO 1\n \n-/* We do not want call-frame info to be output, since debuggers are\n-   supposed to use the target unwind info.  Leave this undefined it\n-   TARGET_UNWIND_INFO might ever be false.  */\n-\n-#define DWARF2_FRAME_INFO 0\n-\n #define DWARF2_ASM_LINE_DEBUG_INFO (TARGET_DWARF2_ASM)\n \n /* Use tags for debug info labels, so that they don't break instruction\n@@ -1849,8 +1843,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n extern int ia64_final_schedule;\n \n-#define TARGET_UNWIND_INFO\t1\n-\n #define TARGET_UNWIND_TABLES_DEFAULT true\n \n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 15 : INVALID_REGNUM)"}, {"sha": "43da0192c17eb51232d5d762d2738346c0fe3076", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -520,7 +520,7 @@ pa_option_override (void)\n      call frame information.  There is no benefit in using this optimization\n      on PA8000 and later processors.  */\n   if (pa_cpu >= PROCESSOR_8000\n-      || (! USING_SJLJ_EXCEPTIONS && flag_exceptions)\n+      || (targetm.except_unwind_info () == UI_DWARF2 && flag_exceptions)\n       || flag_unwind_tables)\n     target_flags &= ~MASK_JUMP_IN_DELAY;\n "}, {"sha": "095ac2efa895b53a652dacd410daeee798aad71b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,9 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-lang.c: Include \"target.h\".\n+\t(cp_eh_personality): Use targetm.except_unwind_info.\n+\t* Make-lang.in (cp-lang.o): Update deps.\n+\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* parser.c (cp_parser_objc_valid_prefix_attributes): New."}, {"sha": "35736ca13f398d6d670c71dee403b024e5f46a5a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -250,7 +250,7 @@ cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   $(C_PRAGMA_H) toplev.h output.h input.h cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-cp.h gt-cp-cp-lang.h \\\n-  cp/cp-objcp-common.h $(EXPR_H)\n+  cp/cp-objcp-common.h $(EXPR_H) $(TARGET_H)\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   output.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(C_PRAGMA_H) \\"}, {"sha": "0b70444808a9413bce44e6b44c89a00280f02a6f", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"cp-objcp-common.h\"\n #include \"hashtab.h\"\n+#include \"target.h\"\n \n enum c_language_kind c_language = clk_cxx;\n static void cp_init_ts (void);\n@@ -165,16 +166,17 @@ cp_eh_personality (void)\n {\n   if (!cp_eh_personality_decl)\n     {\n-      if (!pragma_java_exceptions)\n-\tcp_eh_personality_decl\n-\t  = build_personality_function (USING_SJLJ_EXCEPTIONS\n-\t\t\t\t\t? \"__gxx_personality_sj0\"\n-\t\t\t\t\t: \"__gxx_personality_v0\");\n-      else\n-\tcp_eh_personality_decl\n-\t  = build_personality_function (USING_SJLJ_EXCEPTIONS\n-\t\t\t\t\t? \"__gcj_personality_sj0\"\n-\t\t\t\t\t: \"__gcj_personality_v0\");\n+      const char *name;\n+\n+      name = (targetm.except_unwind_info () == UI_SJLJ\n+\t      ? (pragma_java_exceptions\n+\t\t ? \"__gcj_personality_sj0\"\n+\t\t : \"__gxx_personality_sj0\")\n+\t      : (pragma_java_exceptions\n+\t\t ? \"__gcj_personality_v0\"\n+\t\t : \"__gxx_personality_v0\"));\n+\n+      cp_eh_personality_decl = build_personality_function (name);\n     }\n \n   return cp_eh_personality_decl;"}, {"sha": "6ecebb69f426ddf76054af0603f4e11b9287ddc9", "filename": "gcc/defaults.h", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -376,8 +376,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n    the rest of the DWARF 2 frame unwind support is also provided.  */\n-#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX) \\\n-    && !defined (TARGET_UNWIND_INFO)\n+#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)\n #define DWARF2_UNWIND_INFO 1\n #endif\n \n@@ -1238,49 +1237,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    functions.\n */\n \n-/* Just because the user configured --with-sjlj-exceptions=no doesn't\n-   mean that we can use call frame exceptions.  Detect that the target\n-   has appropriate support.  */\n-\n-#ifndef MUST_USE_SJLJ_EXCEPTIONS\n-# if defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n-       && (defined (TARGET_UNWIND_INFO)\t\t\t\\\n-\t   || (DWARF2_UNWIND_INFO\t\t\t\\\n-\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n-\t\t   || defined (HAVE_eh_return))))\n-#  define MUST_USE_SJLJ_EXCEPTIONS\t0\n-# else\n-#  define MUST_USE_SJLJ_EXCEPTIONS\t1\n-# endif\n-#endif\n-\n-#ifdef CONFIG_SJLJ_EXCEPTIONS\n-# if CONFIG_SJLJ_EXCEPTIONS == 1\n-#  define USING_SJLJ_EXCEPTIONS\t\t1\n-# endif\n-# if CONFIG_SJLJ_EXCEPTIONS == 0\n-#  define USING_SJLJ_EXCEPTIONS\t\t0\n-#  if !defined(EH_RETURN_DATA_REGNO)\n-    #error \"EH_RETURN_DATA_REGNO required\"\n-#  endif\n-#  if ! (defined(TARGET_UNWIND_INFO) || DWARF2_UNWIND_INFO)\n-    #error \"{DWARF2,TARGET}_UNWIND_INFO required\"\n-#  endif\n-#  if !defined(TARGET_UNWIND_INFO) \\\n-\t&& !(defined(EH_RETURN_HANDLER_RTX) || defined(HAVE_eh_return))\n-    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n-#  endif\n-/* Usually the above error checks will have already triggered an\n-   error, but backends may set MUST_USE_SJLJ_EXCEPTIONS for their own\n-   reasons.  */\n-#  if MUST_USE_SJLJ_EXCEPTIONS\n-    #error \"Must use SJLJ exceptions but configured not to\"\n-#  endif\n-# endif\n-#else\n-# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n-#endif\n-\n /* The default branch cost is 1.  */\n #ifndef BRANCH_COST\n #define BRANCH_COST(speed_p, predictable_p) 1\n@@ -1388,15 +1344,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT\n #else\n #define STACK_OLD_CHECK_PROTECT \\\n- (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)\n+ (targetm.except_unwind_info () == UI_SJLJ ? 75 * UNITS_PER_WORD : 8 * 1024)\n #endif\n \n /* Minimum amount of stack required to recover from an anticipated stack\n    overflow detection.  The default value conveys an estimate of the amount\n    of stack required to propagate an exception.  */\n #ifndef STACK_CHECK_PROTECT\n #define STACK_CHECK_PROTECT \\\n- (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)\n+ (targetm.except_unwind_info () == UI_SJLJ ? 75 * UNITS_PER_WORD : 12 * 1024)\n #endif\n \n /* Make the maximum frame size be the largest we can and still only need"}, {"sha": "bbda85a43a7707239d936c2ea9df5dbf01cafc7d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -8747,7 +8747,8 @@ If the target implements @code{TARGET_ASM_UNWIND_EMIT}, this hook may be used to\n \n @deftypefn {Target Hook} void TARGET_ASM_UNWIND_EMIT (FILE *@var{stream}, rtx @var{insn})\n This target hook emits assembly directives required to unwind the\n-given instruction.  This is only used when TARGET_UNWIND_INFO is set.\n+given instruction.  This is only used when @code{TARGET_EXCEPT_UNWIND_INFO}\n+returns @code{UI_TARGET}.\n @end deftypefn\n \n @deftypevr {Target Hook} bool TARGET_ASM_UNWIND_EMIT_BEFORE_INSN\n@@ -8798,23 +8799,32 @@ that it does not contain any extraneous set bits in it.\n Define this macro to 0 if your target supports DWARF 2 frame unwind\n information, but it does not yet work with exception handling.\n Otherwise, if your target supports this information (if it defines\n-@samp{INCOMING_RETURN_ADDR_RTX} and either @samp{UNALIGNED_INT_ASM_OP}\n-or @samp{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n+@code{INCOMING_RETURN_ADDR_RTX} and either @code{UNALIGNED_INT_ASM_OP}\n+or @code{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n+@end defmac\n \n-If @code{TARGET_UNWIND_INFO} is defined, the target specific unwinder\n-will be used in all cases.  Defining this macro will enable the generation\n-of DWARF 2 frame debugging information.\n+@deftypefn {Target Hook} {enum unwind_info_type} TARGET_EXCEPT_UNWIND_INFO (void)\n+This hook defines the mechanism that will be used for exception handling\n+by the target.  If the target has ABI specified unwind tables, the hook\n+should return @code{UI_TARGET}.  If the target is to use the\n+@code{setjmp}/@code{longjmp}-based exception handling scheme, the hook\n+should return @code{UI_SJLJ}.  If the target supports DWARF 2 frame unwind\n+information, the hook should return @code{UI_DWARF2}.\n \n-If @code{TARGET_UNWIND_INFO} is not defined, and this macro is defined to 1,\n-the DWARF 2 unwinder will be the default exception handling mechanism;\n-otherwise, the @code{setjmp}/@code{longjmp}-based scheme will be used by\n-default.\n-@end defmac\n+A target may, if exceptions are disabled, choose to return @code{UI_NONE}.\n+This may end up simplifying other parts of target-specific code.  The\n+default implementation of this hook never returns @code{UI_NONE}.\n \n-@defmac TARGET_UNWIND_INFO\n-Define this macro if your target has ABI specified unwind tables.  Usually\n-these will be output by @code{TARGET_ASM_UNWIND_EMIT}.\n-@end defmac\n+Note that the value returned by this hook should be constant.  It should\n+not depend on anything except command-line switches.  In particular, the\n+setting @code{UI_SJLJ} must be fixed at compiler start-up as C pre-processor\n+macros and builtin functions related to exception handling are set up\n+depending on this setting.\n+\n+The default implementation of the hook first honors the\n+@option{--enable-sjlj-exceptions} configure option, then\n+@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.\n+@end deftypefn\n \n @deftypevr {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT\n This variable should be set to @code{true} if the target ABI requires unwinding\n@@ -9323,11 +9333,25 @@ as appropriate from @code{TARGET_ASM_FUNCTION_PROLOGUE} if you don't.\n \n @defmac DWARF2_FRAME_INFO\n Define this macro to a nonzero value if GCC should always output\n-Dwarf 2 frame information.  If @code{DWARF2_UNWIND_INFO}\n-(@pxref{Exception Region Output} is nonzero, GCC will output this\n-information not matter how you define @code{DWARF2_FRAME_INFO}.\n+Dwarf 2 frame information.  If @code{TARGET_EXCEPT_UNWIND_INFO}\n+(@pxref{Exception Region Output}) returns @code{UI_DWARF2}, and\n+exceptions are enabled, GCC will output this information not matter\n+how you define @code{DWARF2_FRAME_INFO}.\n @end defmac\n \n+@deftypefn {Target Hook} {enum unwind_info_type} TARGET_DEBUG_UNWIND_INFO (void)\n+This hook defines the mechanism that will be used for describing frame\n+unwind information to the debugger.  Normally the hook will return\n+@code{UI_DWARF2} if DWARF 2 debug information is enabled, and\n+return @code{UI_NONE} otherwise.\n+\n+A target may return @code{UI_DWARF2} even when DWARF 2 debug information\n+is disabled in order to always output DWARF 2 frame information.\n+\n+A target may return @code{UI_TARGET} if it has ABI specified unwind tables.\n+This will suppress generation of the normal debug frame unwind information.\n+@end deftypefn\n+\n @defmac DWARF2_ASM_LINE_DEBUG_INFO\n Define this macro to be a nonzero value if the assembler can generate Dwarf 2\n line debug info sections.  This will result in much more compact line number"}, {"sha": "7f0b460927b6cc8c10c4e53b1d3f0887ae97b622", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -8733,7 +8733,8 @@ The default is that no label is emitted.\n \n @hook TARGET_ASM_UNWIND_EMIT\n This target hook emits assembly directives required to unwind the\n-given instruction.  This is only used when TARGET_UNWIND_INFO is set.\n+given instruction.  This is only used when @code{TARGET_EXCEPT_UNWIND_INFO}\n+returns @code{UI_TARGET}.\n @end deftypefn\n \n @hook TARGET_ASM_UNWIND_EMIT_BEFORE_INSN\n@@ -8782,23 +8783,32 @@ that it does not contain any extraneous set bits in it.\n Define this macro to 0 if your target supports DWARF 2 frame unwind\n information, but it does not yet work with exception handling.\n Otherwise, if your target supports this information (if it defines\n-@samp{INCOMING_RETURN_ADDR_RTX} and either @samp{UNALIGNED_INT_ASM_OP}\n-or @samp{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n+@code{INCOMING_RETURN_ADDR_RTX} and either @code{UNALIGNED_INT_ASM_OP}\n+or @code{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n+@end defmac\n \n-If @code{TARGET_UNWIND_INFO} is defined, the target specific unwinder\n-will be used in all cases.  Defining this macro will enable the generation\n-of DWARF 2 frame debugging information.\n+@hook TARGET_EXCEPT_UNWIND_INFO\n+This hook defines the mechanism that will be used for exception handling\n+by the target.  If the target has ABI specified unwind tables, the hook\n+should return @code{UI_TARGET}.  If the target is to use the\n+@code{setjmp}/@code{longjmp}-based exception handling scheme, the hook\n+should return @code{UI_SJLJ}.  If the target supports DWARF 2 frame unwind\n+information, the hook should return @code{UI_DWARF2}.\n \n-If @code{TARGET_UNWIND_INFO} is not defined, and this macro is defined to 1,\n-the DWARF 2 unwinder will be the default exception handling mechanism;\n-otherwise, the @code{setjmp}/@code{longjmp}-based scheme will be used by\n-default.\n-@end defmac\n+A target may, if exceptions are disabled, choose to return @code{UI_NONE}.\n+This may end up simplifying other parts of target-specific code.  The\n+default implementation of this hook never returns @code{UI_NONE}.\n \n-@defmac TARGET_UNWIND_INFO\n-Define this macro if your target has ABI specified unwind tables.  Usually\n-these will be output by @code{TARGET_ASM_UNWIND_EMIT}.\n-@end defmac\n+Note that the value returned by this hook should be constant.  It should\n+not depend on anything except command-line switches.  In particular, the\n+setting @code{UI_SJLJ} must be fixed at compiler start-up as C pre-processor\n+macros and builtin functions related to exception handling are set up\n+depending on this setting.\n+\n+The default implementation of the hook first honors the\n+@option{--enable-sjlj-exceptions} configure option, then\n+@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.\n+@end deftypefn\n \n @hook TARGET_UNWIND_TABLES_DEFAULT\n This variable should be set to @code{true} if the target ABI requires unwinding\n@@ -9307,11 +9317,25 @@ as appropriate from @code{TARGET_ASM_FUNCTION_PROLOGUE} if you don't.\n \n @defmac DWARF2_FRAME_INFO\n Define this macro to a nonzero value if GCC should always output\n-Dwarf 2 frame information.  If @code{DWARF2_UNWIND_INFO}\n-(@pxref{Exception Region Output} is nonzero, GCC will output this\n-information not matter how you define @code{DWARF2_FRAME_INFO}.\n+Dwarf 2 frame information.  If @code{TARGET_EXCEPT_UNWIND_INFO}\n+(@pxref{Exception Region Output}) returns @code{UI_DWARF2}, and\n+exceptions are enabled, GCC will output this information not matter\n+how you define @code{DWARF2_FRAME_INFO}.\n @end defmac\n \n+@hook TARGET_DEBUG_UNWIND_INFO\n+This hook defines the mechanism that will be used for describing frame\n+unwind information to the debugger.  Normally the hook will return\n+@code{UI_DWARF2} if DWARF 2 debug information is enabled, and\n+return @code{UI_NONE} otherwise.\n+\n+A target may return @code{UI_DWARF2} even when DWARF 2 debug information\n+is disabled in order to always output DWARF 2 frame information.\n+\n+A target may return @code{UI_TARGET} if it has ABI specified unwind tables.\n+This will suppress generation of the normal debug frame unwind information.\n+@end deftypefn\n+\n @defmac DWARF2_ASM_LINE_DEBUG_INFO\n Define this macro to be a nonzero value if the assembler can generate Dwarf 2\n line debug info sections.  This will result in much more compact line number"}, {"sha": "12d057d88554399242ceb9b4488408301e970551", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -112,23 +112,18 @@ int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n #define DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET 0\n #endif\n \n-#ifndef DWARF2_UNWIND_INFO\n-#define DWARF2_UNWIND_INFO 0\n+/* ??? Poison these here until it can be done generically.  They've been\n+   totally replaced in this file; make sure it stays that way.  */\n+#undef DWARF2_UNWIND_INFO\n+#undef DWARF2_FRAME_INFO\n+#if (GCC_VERSION >= 3000)\n+ #pragma GCC poison DWARF2_UNWIND_INFO DWARF2_FRAME_INFO\n #endif\n \n #ifndef INCOMING_RETURN_ADDR_RTX\n #define INCOMING_RETURN_ADDR_RTX  (gcc_unreachable (), NULL_RTX)\n #endif\n \n-#ifndef DWARF2_FRAME_INFO\n-# ifdef DWARF2_DEBUGGING_INFO\n-#  define DWARF2_FRAME_INFO \\\n-  (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n-# else\n-#  define DWARF2_FRAME_INFO 0\n-# endif\n-#endif\n-\n /* Map register numbers held in the call frame info that gcc has\n    collected using DWARF_FRAME_REGNUM to those that should be output in\n    .debug_frame and .eh_frame.  */\n@@ -148,13 +143,20 @@ dwarf2out_do_frame (void)\n   /* We want to emit correct CFA location expressions or lists, so we\n      have to return true if we're going to output debug info, even if\n      we're not going to output frame or unwind info.  */\n-  return (write_symbols == DWARF2_DEBUG\n-\t  || write_symbols == VMS_AND_DWARF2_DEBUG\n-\t  || DWARF2_FRAME_INFO || saved_do_cfi_asm\n-\t  || (DWARF2_UNWIND_INFO\n-\t      && (flag_unwind_tables\n-\t\t  || (flag_exceptions && ! USING_SJLJ_EXCEPTIONS)))\n-\t  );\n+  if (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+    return true;\n+\n+  if (saved_do_cfi_asm)\n+    return true;\n+\n+  if (targetm.debug_unwind_info () == UI_DWARF2)\n+    return true;\n+\n+  if ((flag_unwind_tables || flag_exceptions)\n+      && targetm.except_unwind_info () == UI_DWARF2)\n+    return true;\n+\n+  return false;\n }\n \n /* Decide whether to emit frame unwind via assembler directives.  */\n@@ -167,10 +169,10 @@ dwarf2out_do_cfi_asm (void)\n #ifdef MIPS_DEBUGGING_INFO\n   return false;\n #endif\n-  if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())\n-    return false;\n   if (saved_do_cfi_asm)\n     return true;\n+  if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())\n+    return false;\n   if (!HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)\n     return false;\n \n@@ -183,15 +185,12 @@ dwarf2out_do_cfi_asm (void)\n   if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel)\n     return false;\n \n-  if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE)\n-    {\n-#ifdef TARGET_UNWIND_INFO\n-      return false;\n-#else\n-      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))\n-\treturn false;\n-#endif\n-    }\n+  /* If we can't get the assembler to emit only .debug_frame, and we don't need\n+     dwarf2 unwind info for exceptions, then emit .debug_frame by hand.  */\n+  if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n+      && !flag_unwind_tables && !flag_exceptions\n+      && targetm.except_unwind_info () != UI_DWARF2)\n+    return false;\n \n   saved_do_cfi_asm = true;\n   return true;\n@@ -3976,20 +3975,18 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   char * dup_label;\n   dw_fde_ref fde;\n   section *fnsec;\n+  bool do_frame;\n \n   current_function_func_begin_label = NULL;\n \n-#ifdef TARGET_UNWIND_INFO\n-  /* ??? current_function_func_begin_label is also used by except.c\n-     for call-site information.  We must emit this label if it might\n-     be used.  */\n-  if ((! flag_exceptions || USING_SJLJ_EXCEPTIONS)\n-      && ! dwarf2out_do_frame ())\n-    return;\n-#else\n-  if (! dwarf2out_do_frame ())\n+  do_frame = dwarf2out_do_frame ();\n+\n+  /* ??? current_function_func_begin_label is also used by except.c for\n+     call-site information.  We must emit this label if it might be used.  */\n+  if (!do_frame\n+      && (!flag_exceptions\n+\t  || targetm.except_unwind_info () != UI_TARGET))\n     return;\n-#endif\n \n   fnsec = function_section (current_function_decl);\n   switch_to_section (fnsec);\n@@ -4000,11 +3997,9 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   dup_label = xstrdup (label);\n   current_function_func_begin_label = dup_label;\n \n-#ifdef TARGET_UNWIND_INFO\n   /* We can elide the fde allocation if we're not emitting debug info.  */\n-  if (! dwarf2out_do_frame ())\n+  if (!do_frame)\n     return;\n-#endif\n \n   /* Expand the fde table if necessary.  */\n   if (fde_table_in_use == fde_table_allocated)\n@@ -4173,22 +4168,22 @@ dwarf2out_frame_init (void)\n   /* On entry, the Canonical Frame Address is at SP.  */\n   dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n \n-  if (DWARF2_UNWIND_INFO || DWARF2_FRAME_INFO)\n+  if (targetm.debug_unwind_info () == UI_DWARF2\n+      || targetm.except_unwind_info () == UI_DWARF2)\n     initial_return_save (INCOMING_RETURN_ADDR_RTX);\n }\n \n void\n dwarf2out_frame_finish (void)\n {\n   /* Output call frame information.  */\n-  if (DWARF2_FRAME_INFO)\n+  if (targetm.debug_unwind_info () == UI_DWARF2)\n     output_call_frame_info (0);\n \n-#ifndef TARGET_UNWIND_INFO\n   /* Output another copy for the unwinder.  */\n-  if (! USING_SJLJ_EXCEPTIONS && (flag_unwind_tables || flag_exceptions))\n+  if ((flag_unwind_tables || flag_exceptions)\n+      && targetm.except_unwind_info () == UI_DWARF2)\n     output_call_frame_info (1);\n-#endif\n }\n \n /* Note that the current function section is being used for code.  */\n@@ -21806,13 +21801,11 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n static void\n dwarf2out_assembly_start (void)\n {\n-  if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE && dwarf2out_do_cfi_asm ())\n-    {\n-#ifndef TARGET_UNWIND_INFO\n-      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))\n-#endif\n-\tfprintf (asm_out_file, \"\\t.cfi_sections\\t.debug_frame\\n\");\n-    }\n+  if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n+      && dwarf2out_do_cfi_asm ()\n+      && (!(flag_unwind_tables || flag_exceptions)\n+\t  || targetm.except_unwind_info () != UI_DWARF2))\n+    fprintf (asm_out_file, \"\\t.cfi_sections\\t.debug_frame\\n\");\n }\n \n /* A helper function for dwarf2out_finish called through"}, {"sha": "5ee9ba3ca488eddac8359c2f4853f9c3980133a6", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -209,7 +209,7 @@ init_eh (void)\n \n   /* Create the SjLj_Function_Context structure.  This should match\n      the definition in unwind-sjlj.c.  */\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     {\n       tree f_jbuf, f_per, f_lsda, f_prev, f_cs, f_data, tmp;\n \n@@ -1375,13 +1375,13 @@ finish_eh_generation (void)\n   basic_block bb;\n \n   /* Construct the landing pads.  */\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     sjlj_build_landing_pads ();\n   else\n     dw2_build_landing_pads ();\n   break_superblocks ();\n \n-  if (USING_SJLJ_EXCEPTIONS\n+  if (targetm.except_unwind_info () == UI_SJLJ\n       /* Kludge for Alpha/Tru64 (see alpha_gp_save_rtx).  */\n       || single_succ_edge (ENTRY_BLOCK_PTR)->insns.r)\n     commit_edge_insertions ();\n@@ -2620,7 +2620,11 @@ static bool\n gate_convert_to_eh_region_ranges (void)\n {\n   /* Nothing to do for SJLJ exceptions or if no regions created.  */\n-  return !(USING_SJLJ_EXCEPTIONS || cfun->eh->region_tree == NULL);\n+  if (cfun->eh->region_tree == NULL)\n+    return false;\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n+    return false;\n+  return true;\n }\n \n struct rtl_opt_pass pass_convert_to_eh_region_ranges =\n@@ -2957,7 +2961,7 @@ output_one_function_exception_table (int section)\n \t\t       eh_data_format_name (tt_format));\n \n #ifndef HAVE_AS_LEB128\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     call_site_len = sjlj_size_of_call_site_table ();\n   else\n     call_site_len = dw2_size_of_call_site_table (section);\n@@ -3024,14 +3028,14 @@ output_one_function_exception_table (int section)\n   dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,\n \t\t\t\t\"Call-site table length\");\n   ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     sjlj_output_call_site_table ();\n   else\n     dw2_output_call_site_table (cs_format, section);\n   ASM_OUTPUT_LABEL (asm_out_file, cs_end_label);\n #else\n   dw2_asm_output_data_uleb128 (call_site_len, \"Call-site table length\");\n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     sjlj_output_call_site_table ();\n   else\n     dw2_output_call_site_table (cs_format, section);"}, {"sha": "26bb9ccc87616c093d03613410bcf7f9fc89ce61", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -87,9 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n-#if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n-#endif\n \n #ifdef DBX_DEBUGGING_INFO\n #include \"dbxout.h\"\n@@ -1534,10 +1532,8 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   if (!DECL_IGNORED_P (current_function_decl))\n     debug_hooks->begin_prologue (last_linenum, last_filename);\n \n-#if defined (DWARF2_UNWIND_INFO) || defined (TARGET_UNWIND_INFO)\n   if (!dwarf2_debug_info_emitted_p (current_function_decl))\n     dwarf2out_begin_prologue (0, NULL);\n-#endif\n \n #ifdef LEAF_REG_REMAP\n   if (current_function_uses_only_leaf_regs)\n@@ -1549,7 +1545,7 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   if (targetm.profile_before_prologue () && crtl->profile)\n     profile_function (file);\n \n-#if defined (DWARF2_UNWIND_INFO) && defined (HAVE_prologue)\n+#if defined (HAVE_prologue)\n   if (dwarf2out_do_frame ())\n     dwarf2out_frame_debug (NULL_RTX, false);\n #endif\n@@ -1657,11 +1653,9 @@ final_end_function (void)\n   if (!DECL_IGNORED_P (current_function_decl))\n     debug_hooks->end_epilogue (last_linenum, last_filename);\n \n-#if defined (DWARF2_UNWIND_INFO)\n   if (!dwarf2_debug_info_emitted_p (current_function_decl)\n       && dwarf2out_do_frame ())\n     dwarf2out_end_epilogue (last_linenum, last_filename);\n-#endif\n }\n \f\n /* Output assembler code for some insns: all or part of a function.\n@@ -1834,12 +1828,10 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t  in_cold_section_p = !in_cold_section_p;\n-#ifdef DWARF2_UNWIND_INFO\n+\n \t  if (dwarf2out_do_frame ())\n \t    dwarf2out_switch_text_section ();\n-\t  else\n-#endif\n-\t  if (!DECL_IGNORED_P (current_function_decl))\n+\t  else if (!DECL_IGNORED_P (current_function_decl))\n \t    debug_hooks->switch_text_section ();\n \n \t  switch_to_section (current_function_section ());\n@@ -1890,7 +1882,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_EPILOGUE_BEG:\n-#if defined (DWARF2_UNWIND_INFO) && defined (HAVE_epilogue)\n+#if defined (HAVE_epilogue)\n \t  if (dwarf2out_do_frame ())\n \t    dwarf2out_cfi_begin_epilogue (insn);\n #endif\n@@ -1899,9 +1891,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_CFA_RESTORE_STATE:\n-#if defined (DWARF2_UNWIND_INFO)\n \t  dwarf2out_frame_debug_restore_state ();\n-#endif\n \t  break;\n \n \tcase NOTE_INSN_FUNCTION_BEG:\n@@ -2010,10 +2000,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       break;\n \n     case BARRIER:\n-#if defined (DWARF2_UNWIND_INFO)\n       if (dwarf2out_do_frame ())\n \tdwarf2out_frame_debug (insn, false);\n-#endif\n       break;\n \n     case CODE_LABEL:\n@@ -2281,11 +2269,9 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \t    /* Record the delay slots' frame information before the branch.\n \t       This is needed for delayed calls: see execute_cfa_program().  */\n-#if defined (DWARF2_UNWIND_INFO)\n \t    if (dwarf2out_do_frame ())\n \t      for (i = 1; i < XVECLEN (body, 0); i++)\n \t\tdwarf2out_frame_debug (XVECEXP (body, 0, i), false);\n-#endif\n \n \t    /* The first insn in this SEQUENCE might be a JUMP_INSN that will\n \t       force the restoration of a comparison that was previously\n@@ -2600,10 +2586,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \tcurrent_output_insn = debug_insn = insn;\n \n-#if defined (DWARF2_UNWIND_INFO)\n \tif (CALL_P (insn) && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn, false);\n-#endif\n \n \t/* Find the proper template for this insn.  */\n \ttempl = get_insn_template (insn_code_number, insn);\n@@ -2705,14 +2689,12 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t/* If necessary, report the effect that the instruction has on\n \t   the unwind info.   We've already done this for delay slots\n \t   and call instructions.  */\n-#if defined (DWARF2_UNWIND_INFO)\n \tif (final_sequence == 0\n #if !defined (HAVE_prologue)\n \t    && !ACCUMULATE_OUTGOING_ARGS\n #endif\n \t    && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn, true);\n-#endif\n \n \tif (!targetm.asm_out.unwind_emit_before_insn\n \t    && targetm.asm_out.unwind_emit)"}, {"sha": "535c053860f78733e9c9e315f867ab18c49e946c", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -4897,7 +4897,7 @@ expand_function_end (void)\n   /* Output the label for the actual return from the function.  */\n   emit_label (return_label);\n \n-  if (USING_SJLJ_EXCEPTIONS)\n+  if (targetm.except_unwind_info () == UI_SJLJ)\n     {\n       /* Let except.c know where it should emit the call to unregister\n \t the function context for sjlj exceptions.  */\n@@ -5055,7 +5055,8 @@ expand_function_end (void)\n   /* @@@ This is a kludge.  We want to ensure that instructions that\n      may trap are not moved into the epilogue by scheduling, because\n      we don't always emit unwind information for the epilogue.  */\n-  if (!USING_SJLJ_EXCEPTIONS && cfun->can_throw_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions\n+      && targetm.except_unwind_info () != UI_SJLJ)\n     emit_insn (gen_blockage ());\n \n   /* If stack protection is enabled for this function, check the guard.  */"}, {"sha": "97192a252cc6eb7411f9e100f7b4eb71c03c0958", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,9 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* lang.c: Include \"target.h\".\n+\t(java_eh_personality): Use targetm.except_unwind_info.\n+\t* Make-lang.in (lang.o): Update deps.\n+\n 2010-09-27  Andrew Haley  <aph@redhat.com>\n \n \tPR java/45773"}, {"sha": "0c91c3758815632593649c9ad74ddb3d4c311ee8", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -302,7 +302,8 @@ java/jvgenmain.o: java/jvgenmain.c $(CONFIG_H) $(JAVA_TREE_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) intl.h\n java/lang.o: java/lang.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h input.h \\\n   toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(DIAGNOSTIC_H) \\\n-  langhooks.h $(LANGHOOKS_DEF_H) gt-java-lang.h opts.h options.h\n+  langhooks.h $(LANGHOOKS_DEF_H) gt-java-lang.h opts.h options.h \\\n+  $(TARGET_H)\n java/mangle.o: java/mangle.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) toplev.h $(GGC_H) gt-java-mangle.h $(LANGHOOKS_DEF_H)\n java/mangle_name.o: java/mangle_name.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) \\"}, {"sha": "78f9715bb826c09aeb8cc6f38be603a3507892c4", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -43,6 +43,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"tree-dump.h\"\n #include \"opts.h\"\n #include \"options.h\"\n+#include \"target.h\"\n \n static bool java_init (void);\n static void java_finish (void);\n@@ -902,7 +903,7 @@ java_eh_personality (void)\n {\n   if (!java_eh_personality_decl)\n     java_eh_personality_decl\n-      = build_personality_function (USING_SJLJ_EXCEPTIONS\n+      = build_personality_function (targetm.except_unwind_info () == UI_SJLJ\n \t\t\t\t    ? \"__gcj_personality_sj0\"\n \t\t\t\t    : \"__gcj_personality_v0\");\n "}, {"sha": "7aa91dc395d8019f57f926c176ed0dc10426955a", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,7 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* objc-act.c (objc_eh_personality): Use targetm.except_unwind_info.\n+\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* objc-act.c (objc_start_class_interface): Handle and ignore attributes."}, {"sha": "67e9b516d437ffe8ffb8c4f646cbf32816268c80", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -3638,7 +3638,7 @@ objc_eh_personality (void)\n   if (!flag_objc_sjlj_exceptions\n       && !objc_eh_personality_decl)\n     objc_eh_personality_decl\n-      = build_personality_function (USING_SJLJ_EXCEPTIONS\n+      = build_personality_function (targetm.except_unwind_info () == UI_SJLJ\n \t\t\t\t    ? \"__gnu_objc_personality_sj0\"\n \t\t\t\t    : \"__gnu_objc_personality_v0\");\n "}, {"sha": "c1012ecfd7d05aa34c9751be697d046699fbbd20", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1,3 +1,9 @@\n+2010-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* objcp-lang.c: Include \"target.h\".\n+\t(objcxx_eh_personality): Use targetm.except_unwind_info.\n+\t* Make-lang.in (objcp-lang.o): Update deps.\n+\n 2010-09-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/25965\t"}, {"sha": "0849a89a6dd43a2818c57f8200c6df9a7e8c32ef", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -73,7 +73,7 @@ cc1objplus$(exeext): $(OBJCXX_OBJS) cc1objplus-checksum.o $(BACKEND) $(LIBDEPS)\n objcp/objcp-lang.o : objcp/objcp-lang.c \\\n   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\\n   $(C_COMMON_H) $(LANGHOOKS_DEF_H) objc/objc-act.h cp/cp-objcp-common.h \\\n-  gtype-objcp.h\n+  $(TARGET_H) gtype-objcp.h\n \n objcp/objcp-decl.o : objcp/objcp-decl.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\"}, {"sha": "fdb297676152660e554ea03fbf47bce9aff7d184", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"objc-act.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"target.h\"\n #include \"cp-objcp-common.h\"\n \n enum c_language_kind c_language = clk_objcxx;\n@@ -147,7 +148,7 @@ objcxx_eh_personality (void)\n {\n   if (!objcp_eh_personality_decl)\n     objcp_eh_personality_decl\n-\t= build_personality_function (USING_SJLJ_EXCEPTIONS\n+\t= build_personality_function (targetm.except_unwind_info () == UI_SJLJ\n \t\t\t\t      ? \"__gxx_personality_sj0\"\n \t\t\t\t      : \"__gxx_personality_v0\");\n "}, {"sha": "ef379428027cb102ffe7d720fffad3a977f02414", "filename": "gcc/opts.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -664,6 +664,7 @@ decode_options (unsigned int argc, const char **argv,\n   int opt3;\n   int opt1_max;\n   int ofast = 0;\n+  enum unwind_info_type ui_except;\n \n   if (first_time_p)\n     {\n@@ -992,32 +993,30 @@ decode_options (unsigned int argc, const char **argv,\n      generating unwind info.  If flag_exceptions is turned on we need to\n      turn off the partitioning optimization.  */\n \n-  if (flag_exceptions && flag_reorder_blocks_and_partition\n-      && (USING_SJLJ_EXCEPTIONS\n-#ifdef TARGET_UNWIND_INFO\n-\t  || 1\n-#endif\n-\t ))\n+  ui_except = targetm.except_unwind_info ();\n+\n+  if (flag_exceptions\n+      && flag_reorder_blocks_and_partition\n+      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))\n     {\n       inform (input_location,\n-\t      \"-freorder-blocks-and-partition does not work with exceptions on this architecture\");\n+\t      \"-freorder-blocks-and-partition does not work \"\n+\t      \"with exceptions on this architecture\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n \n   /* If user requested unwind info, then turn off the partitioning\n      optimization.  */\n \n-  if (flag_unwind_tables && ! targetm.unwind_tables_default\n+  if (flag_unwind_tables\n+      && !targetm.unwind_tables_default\n       && flag_reorder_blocks_and_partition\n-      && (USING_SJLJ_EXCEPTIONS\n-#ifdef TARGET_UNWIND_INFO\n-\t  || 1\n-#endif\n-\t ))\n+      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))\n     {\n       inform (input_location,\n-\t      \"-freorder-blocks-and-partition does not support unwind info on this architecture\");\n+\t      \"-freorder-blocks-and-partition does not support \"\n+\t      \"unwind info on this architecture\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n@@ -1028,15 +1027,13 @@ decode_options (unsigned int argc, const char **argv,\n \n   if (flag_reorder_blocks_and_partition\n       && (!targetm.have_named_sections\n-\t  || (flag_unwind_tables && targetm.unwind_tables_default\n-\t      && (USING_SJLJ_EXCEPTIONS\n-#ifdef TARGET_UNWIND_INFO\n-\t\t  || 1\n-#endif\n-\t\t ))))\n+\t  || (flag_unwind_tables\n+\t      && targetm.unwind_tables_default\n+\t      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))))\n     {\n       inform (input_location,\n-\t      \"-freorder-blocks-and-partition does not work on this architecture\");\n+\t      \"-freorder-blocks-and-partition does not work \"\n+\t      \"on this architecture\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }"}, {"sha": "f7ce1ef5998e2db8332398b7b26c193a9e8f1841", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -716,7 +716,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tCAN_ELIMINATE TRAMPOLINE_TEMPLATE INITIALIZE_TRAMPOLINE\t\t\\\n \tTRAMPOLINE_ADJUST_ADDRESS STATIC_CHAIN STATIC_CHAIN_INCOMING\t\\\n \tRETURN_POPS_ARGS UNITS_PER_SIMD_WORD OVERRIDE_OPTIONS\t\t\\\n-\tOPTIMIZATION_OPTIONS\n+\tOPTIMIZATION_OPTIONS\t\t\t\t\t\t\\\n+\tUSING_SJLJ_EXCEPTIONS TARGET_UNWIND_INFO\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "7a07f097b3f612ed89a3afe63c2b077d752d727a", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -2350,6 +2350,20 @@ DEFHOOK\n  void, (bitmap regs),\n  hook_void_bitmap)\n \n+/* Determine the type of unwind info to emit for debugging.  */\n+DEFHOOK\n+(debug_unwind_info,\n+ \"\",\n+ enum unwind_info_type, (void),\n+ default_debug_unwind_info)\n+\n+/* Determine the type of unwind info to emit for exceptions.  */\n+DEFHOOK\n+(except_unwind_info,\n+ \"\",\n+ enum unwind_info_type, (void),\n+ default_except_unwind_info)\n+\n /* Leave the boolean fields at the end.  */\n \n /* True if unwinding tables should be generated by default.  */"}, {"sha": "f160e979415e127f797f52f56b4045f50f5356e6", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -128,6 +128,16 @@ enum vect_cost_for_stmt\n   vec_perm\n };\n \n+/* Types of unwind/exception handling info that can be generated.  */\n+\n+enum unwind_info_type\n+{\n+  UI_NONE,\n+  UI_SJLJ,\n+  UI_DWARF2,\n+  UI_TARGET\n+};\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "82e59a8f34e35b824cbcd64b679095d421c08cf8", "filename": "gcc/targhooks.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -1233,4 +1233,73 @@ default_class_likely_spilled_p (reg_class_t rclass)\n #endif\n }\n \n+/* Determine the debugging unwind mechanism for the target.  */\n+\n+enum unwind_info_type\n+default_debug_unwind_info (void)\n+{\n+  /* If the target wants to force the use of dwarf2 unwind info, let it.  */\n+  /* ??? Change all users to the hook, then poison this.  */\n+#ifdef DWARF2_FRAME_INFO\n+  if (DWARF2_FRAME_INFO)\n+    return UI_DWARF2;\n+#endif\n+\n+  /* Otherwise, only turn it on if dwarf2 debugging is enabled.  */\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+    return UI_DWARF2;\n+#endif\n+\n+  return UI_NONE;\n+}\n+\n+/* Determine the exception handling mechanism for the target.  */\n+\n+enum unwind_info_type\n+default_except_unwind_info (void)\n+{\n+  /* ??? Change the one user to the hook, then poison this.  */\n+#ifdef MUST_USE_SJLJ_EXCEPTIONS\n+  if (MUST_USE_SJLJ_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  /* Obey the configure switch to turn on sjlj exceptions.  */\n+#ifdef CONFIG_SJLJ_EXCEPTIONS\n+  if (CONFIG_SJLJ_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  /* ??? Change all users to the hook, then poison this.  */\n+#ifdef DWARF2_UNWIND_INFO\n+  if (DWARF2_UNWIND_INFO)\n+    return UI_DWARF2;\n+#endif\n+\n+  return UI_SJLJ;\n+}\n+\n+/* To be used by targets that force dwarf2 unwind enabled.  */\n+\n+enum unwind_info_type\n+dwarf2_except_unwind_info (void)\n+{\n+  /* Obey the configure switch to turn on sjlj exceptions.  */\n+#ifdef CONFIG_SJLJ_EXCEPTIONS\n+  if (CONFIG_SJLJ_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  return UI_DWARF2;\n+}\n+\n+/* To be used by targets that force sjlj unwind enabled.  */\n+\n+enum unwind_info_type\n+sjlj_except_unwind_info (void)\n+{\n+  return UI_SJLJ;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "da575f3e7e0d0af9e72adfd0c6830642fda1f8a1", "filename": "gcc/targhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -154,3 +154,8 @@ extern int default_register_move_cost (enum machine_mode, reg_class_t,\n \n extern bool default_profile_before_prologue (void);\n extern bool default_class_likely_spilled_p (reg_class_t);\n+\n+extern enum unwind_info_type default_debug_unwind_info (void);\n+extern enum unwind_info_type default_except_unwind_info (void);\n+extern enum unwind_info_type dwarf2_except_unwind_info (void);\n+extern enum unwind_info_type sjlj_except_unwind_info (void);"}, {"sha": "38daed9a786b1ac6aeee82326283e0efff3462e5", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"langhooks.h\"\n #include \"dbgcnt.h\"\n+#include \"target.h\"\n \n /* The file implements the tail recursion elimination.  It is also used to\n    analyze the tail calls in general, passing the results to the rtl level\n@@ -151,7 +152,8 @@ suitable_for_tail_call_opt_p (void)\n   /* If we are using sjlj exceptions, we may need to add a call to\n      _Unwind_SjLj_Unregister at exit of the function.  Which means\n      that we cannot do any sibcall transformations.  */\n-  if (USING_SJLJ_EXCEPTIONS && current_function_has_exception_handlers ())\n+  if (targetm.except_unwind_info () == UI_SJLJ\n+      && current_function_has_exception_handlers ())\n     return false;\n \n   /* Any function that calls setjmp might have longjmp called from"}, {"sha": "16c26db0518f29d225dcc7a544800e6ce501503b", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a0390e691ece0d859b7d87c6e6617d227cb8dd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "patch": "@@ -9351,7 +9351,7 @@ build_common_builtin_nodes (void)\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_unwind_resume\", ftype,\n \t\t\tBUILT_IN_UNWIND_RESUME,\n-\t\t\t(USING_SJLJ_EXCEPTIONS\n+\t\t\t(targetm.except_unwind_info () == UI_SJLJ\n \t\t\t ? \"_Unwind_SjLj_Resume\" : \"_Unwind_Resume\"),\n \t\t\tECF_NORETURN);\n \n@@ -10935,7 +10935,7 @@ lhd_gcc_personality (void)\n {\n   if (!gcc_eh_personality_decl)\n     gcc_eh_personality_decl\n-      = build_personality_function (USING_SJLJ_EXCEPTIONS\n+      = build_personality_function (targetm.except_unwind_info () == UI_SJLJ\n \t\t\t\t    ? \"__gcc_personality_sj0\"\n \t\t\t\t    : \"__gcc_personality_v0\");\n "}]}