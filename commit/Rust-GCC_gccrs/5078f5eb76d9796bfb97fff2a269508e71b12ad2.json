{"sha": "5078f5eb76d9796bfb97fff2a269508e71b12ad2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3OGY1ZWI3NmQ5Nzk2YmZiOTdmZmYyYTI2OTUwOGU3MWIxMmFkMg==", "commit": {"author": {"name": "Herman A.J. ten Brugge", "email": "Haj.Ten.Brugge@net.HCC.nl", "date": "2001-01-22T10:29:14Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-22T10:29:14Z"}, "message": "c4x.c (c4x_check_legit_addr): Only check CONST.\n\n\t* c4x.c (c4x_check_legit_addr): Only check CONST.  Not if CONST\n\tcontains SYMBOL_REF, LABEL_REF and CONST_INT.\n\t(c4x_U_constraint, symbolic_address_operand): Likewise.\n\t(c4x_immed_float_constant): Do not check if CONST_DOUBLE is in\n\tmemory.\n\t(c4x_r11_set_p, c4x_check_laj_p): New functions.\n\t* c4x-protos.h (c4x_check_laj_p): Add prototype.\n\t* c4x.md (in_annul_slot_3): Do not allow auto-increment in last\n\tanulling slot because of silicon bug.\n\t(laj, lajv): Call c4x_check_laj_p to check for silicon bug.\n\nFrom-SVN: r39180", "tree": {"sha": "7a7bfb70cceb48673b66bf32e58f9ae275929e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a7bfb70cceb48673b66bf32e58f9ae275929e39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5078f5eb76d9796bfb97fff2a269508e71b12ad2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5078f5eb76d9796bfb97fff2a269508e71b12ad2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5078f5eb76d9796bfb97fff2a269508e71b12ad2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5078f5eb76d9796bfb97fff2a269508e71b12ad2/comments", "author": null, "committer": null, "parents": [{"sha": "1a938e38a0860429ac79db5edd5a0df9fb184b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a938e38a0860429ac79db5edd5a0df9fb184b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a938e38a0860429ac79db5edd5a0df9fb184b82"}], "stats": {"total": 131, "additions": 102, "deletions": 29}, "files": [{"sha": "d68d6127e541cf86d8edca59f66429bbc88ffd94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5078f5eb76d9796bfb97fff2a269508e71b12ad2", "patch": "@@ -1,3 +1,16 @@\n+2001-01-22 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n+\n+\t* c4x.c (c4x_check_legit_addr): Only check CONST.  Not if CONST\n+\tcontains SYMBOL_REF, LABEL_REF and CONST_INT.\n+\t(c4x_U_constraint, symbolic_address_operand): Likewise.\n+\t(c4x_immed_float_constant): Do not check if CONST_DOUBLE is in\n+\tmemory.\n+\t(c4x_r11_set_p, c4x_check_laj_p): New functions.\n+\t* c4x-protos.h (c4x_check_laj_p): Add prototype.\n+\t* c4x.md (in_annul_slot_3): Do not allow auto-increment in last \n+\tanulling slot because of silicon bug.\n+\t(laj, lajv): Call c4x_check_laj_p to check for silicon bug.\n+\n 2001-01-22  Alan Modra <alan@linuxcare.com.au>\n \n         * cppexp.c (parse_charconst):  Change `mask' type to agree"}, {"sha": "4814e97cd8c0e948205133b6eda9968441e676e0", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=5078f5eb76d9796bfb97fff2a269508e71b12ad2", "patch": "@@ -121,6 +121,8 @@ extern int c4x_rptb_nop_p PARAMS ((rtx));\n \n extern int c4x_rptb_rpts_p PARAMS ((rtx, rtx));\n \n+extern int c4x_check_laj_p PARAMS ((rtx));\n+\n extern int c4x_autoinc_operand PARAMS ((rtx, enum machine_mode));\n \n extern int any_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "a23b3c8e536d4660c06fd657cc5c706cdfca1b65", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=5078f5eb76d9796bfb97fff2a269508e71b12ad2", "patch": "@@ -186,6 +186,7 @@ static int c4x_arn_reg_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static int c4x_arn_mem_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static void c4x_check_attribute PARAMS ((const char *, tree, tree, tree *));\n static int c4x_parse_pragma PARAMS ((const char *, tree *, tree *));\n+static int c4x_r11_set_p PARAMS ((rtx));\n \n /* Called to register all of our global variables with the garbage\n    collector.  */\n@@ -1558,15 +1559,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \t  return 1;\n \n \tif (GET_CODE (op1) == CONST)\n-\t  {\n-\t    addr = XEXP (op1, 0);\n-\t    \n-\t    if (GET_CODE (addr) == PLUS\n-\t\t&& (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n-\t\t    || GET_CODE (XEXP (addr, 0)) == LABEL_REF)\n-\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\t      return 1;\n-\t  }\n+\t  return 1;\n \treturn 0;\n       }\n       break;\n@@ -2432,8 +2425,9 @@ c4x_immed_float_constant (op)\n   if (GET_CODE (op) != CONST_DOUBLE)\n     return 0;\n \n-  if (GET_CODE (XEXP (op, 0)) == MEM)\n-    return 0;\n+  /* Do not check if the CONST_DOUBLE is in memory. If there is a MEM\n+     present this only means that a MEM rtx has been generated. It does\n+     not mean the rtx is really in memory.  */\n \n   return GET_MODE (op) == QFmode || GET_MODE (op) == HFmode;\n }\n@@ -2835,14 +2829,9 @@ c4x_U_constraint (op)\n      rtx op;\n {\n   /* Don't allow direct addressing to an arbitrary constant.  */\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && (GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF)\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n-    return 1;\n-\n-  return GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF;\n+  return GET_CODE (op) == CONST\n+\t || GET_CODE (op) == SYMBOL_REF\n+\t || GET_CODE (op) == LABEL_REF;\n }\n \n \n@@ -3228,14 +3217,10 @@ symbolic_address_operand (op, mode)\n {\n   switch (GET_CODE (op))\n     {\n+    case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return 1;\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n     default:\n       return 0;\n     }\n@@ -4720,6 +4705,75 @@ c4x_rptb_rpts_p (insn, op)\n }\n \n \n+/* Check if register r11 is used as the destination of an insn.  */\n+\n+static int\n+c4x_r11_set_p(x)\n+    rtx x;\n+{\n+  RTX_CODE code;\n+  rtx set;\n+  int i, j;\n+  const char *fmt;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  if (code == INSN && GET_CODE (PATTERN (x)) == SEQUENCE)\n+    x = XVECEXP (PATTERN (x), 0, XVECLEN (PATTERN (x), 0) - 1);\n+\n+  if (code == INSN && (set = single_set (x)))\n+    return c4x_r11_set_p (SET_DEST (set));\n+\n+  if (code == REG && REGNO (x) == R11_REGNO)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+          if (c4x_r11_set_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+        for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+          if (c4x_r11_set_p (XVECEXP (x, i, j)))\n+\t    return 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* The c4x sometimes has a problem when the insn before the laj insn\n+   sets the r11 register.  Check for this situation.  */\n+\n+int\n+c4x_check_laj_p (insn)\n+     rtx insn;\n+{\n+  insn = prev_nonnote_insn (insn);\n+\n+  /* If this is the start of the function no nop is needed.  */\n+  if (insn == 0)\n+    return 0;\n+\n+  /* If the previous insn is a code label we have to insert a nop. This\n+     could be a jump or table jump. We can find the normal jumps by\n+     scanning the function but this will not find table jumps.  */\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    return 1;\n+\n+  /* If the previous insn sets register r11 we have to insert a nop.  */\n+  if (c4x_r11_set_p (insn))\n+    return 1;\n+\n+  /* No nop needed.  */\n+  return 0;\n+}\n+\n+\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost. \n    A set of an address register followed by a use occurs a 2 cycle"}, {"sha": "3a81ef65d24f5176cc911e85cebe960b103a1f1a", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5078f5eb76d9796bfb97fff2a269508e71b12ad2/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=5078f5eb76d9796bfb97fff2a269508e71b12ad2", "patch": "@@ -377,10 +377,12 @@\n \t\t(const_string \"false\")))\n \n /* Disable ldp because the c4x contains a bug. The ldp insn modifies\n-   the dp register when the insn is anulled or not.  */\n+   the dp register when the insn is anulled or not.\n+   Also disable autoincrement insns because of a silicon bug.  */\n (define_attr \"in_annul_slot_3\" \"false,true\"\n-  (if_then_else (and (eq_attr \"cpu\" \"c4x\")\n-\t\t     (eq_attr \"type\" \"!jump,call,rets,jmpc,db,dbc,repeat,repeat_top,laj,push,pop,ldp,multi\"))\n+  (if_then_else (and (and (eq_attr \"cpu\" \"c4x\")\n+\t\t          (eq_attr \"type\" \"!jump,call,rets,jmpc,db,dbc,repeat,repeat_top,laj,push,pop,ldp,multi\"))\n+\t\t     (eq_attr \"onlyreg_nomod\" \"true\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n@@ -5133,7 +5135,8 @@\n   \"! TARGET_C3X\"\n   \"*\n    if (final_sequence)\n-     return \\\"laj%U0\\\\t%C0\\\";\n+     return c4x_check_laj_p (insn)\n+\t ? \\\"nop\\\\n\\\\tlaj%U0\\\\t%C0\\\" : \\\"laj%U0\\\\t%C0\\\";\n    else\n      return \\\"call%U0\\\\t%C0\\\";\"\n   [(set_attr \"type\" \"laj\")])\n@@ -5181,7 +5184,8 @@\n   \"! TARGET_C3X\"\n   \"*\n    if (final_sequence)\n-     return \\\"laj%U1\\\\t%C1\\\";\n+     return c4x_check_laj_p (insn)\n+\t ? \\\"nop\\\\n\\\\tlaj%U1\\\\t%C1\\\" : \\\"laj%U1\\\\t%C1\\\";\n    else\n      return \\\"call%U1\\\\t%C1\\\";\"\n   [(set_attr \"type\" \"laj\")])"}]}