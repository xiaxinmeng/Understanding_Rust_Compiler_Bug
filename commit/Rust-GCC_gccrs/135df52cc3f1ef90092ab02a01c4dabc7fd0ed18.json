{"sha": "135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM1ZGY1MmNjM2YxZWY5MDA5MmFiMDJhMDFjNGRhYmM3ZmQwZWQxOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-24T22:29:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-24T22:29:09Z"}, "message": "gimplify.h (omp_construct_selector_matches): Declare.\n\n\t* gimplify.h (omp_construct_selector_matches): Declare.\n\t* gimplify.c (struct gimplify_omp_ctx): Add code member.\n\t(gimplify_call_expr): Call omp_resolve_declare_variant and remap\n\tcalled function if needed for flag_openmp.\n\t(gimplify_scan_omp_clauses): Set ctx->code.\n\t(omp_construct_selector_matches): New function.\n\t* omp-general.h (omp_constructor_traits_to_codes,\n\tomp_context_selector_matches, omp_resolve_declare_variant): Declare.\n\t* omp-general.c (omp_constructor_traits_to_codes,\n\tomp_context_selector_matches, omp_resolve_declare_variant): New\n\tfunctions.\nc-family/\n\t* c-common.h (c_omp_context_selector_matches): Remove.\n\t* c-omp.c (c_omp_context_selector_matches): Remove.\n\t* c-attribs.c (c_common_attribute_table): Add\n\t\"omp declare target {host,nohost,block}\" attributes.\nc/\n\t* c-parser.c (c_finish_omp_declare_variant): Use\n\tomp_context_selector_matches instead of\n\tc_omp_context_selector_matches.\n\t* c-decl.c (c_decl_attributes): Add \"omp declare target block\"\n\tattribute in between declare target and end declare target\n\tpragmas.\ncp/\n\t* decl2.c (cplus_decl_attributes): Add \"omp declare target block\"\n\tattribute in between declare target and end declare target\n\tpragmas.\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-8.c: New test.\n\nFrom-SVN: r277427", "tree": {"sha": "788a3c845a393f73563f1c4dba757939c85265ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/788a3c845a393f73563f1c4dba757939c85265ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8cb8bcde13df2f2b1a996567c849ec512eec210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8cb8bcde13df2f2b1a996567c849ec512eec210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8cb8bcde13df2f2b1a996567c849ec512eec210"}], "stats": {"total": 779, "additions": 585, "deletions": 194}, "files": [{"sha": "4d9e4709da2e8ff0efbfa81a59c83ca3564ddd55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1,5 +1,17 @@\n 2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gimplify.h (omp_construct_selector_matches): Declare.\n+\t* gimplify.c (struct gimplify_omp_ctx): Add code member.\n+\t(gimplify_call_expr): Call omp_resolve_declare_variant and remap\n+\tcalled function if needed for flag_openmp.\n+\t(gimplify_scan_omp_clauses): Set ctx->code.\n+\t(omp_construct_selector_matches): New function.\n+\t* omp-general.h (omp_constructor_traits_to_codes,\n+\tomp_context_selector_matches, omp_resolve_declare_variant): Declare.\n+\t* omp-general.c (omp_constructor_traits_to_codes,\n+\tomp_context_selector_matches, omp_resolve_declare_variant): New\n+\tfunctions.\n+\n \t* config/arc/arc.c (hwloop_optimize): Add missing space in string\n \tliteral.\n \t* config/rx/rx.c (rx_print_operand): Likewise."}, {"sha": "3b3d5744bac70cfc1e3c74183468c3698b6aa105", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1,3 +1,10 @@\n+2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_omp_context_selector_matches): Remove.\n+\t* c-omp.c (c_omp_context_selector_matches): Remove.\n+\t* c-attribs.c (c_common_attribute_table): Add\n+\t\"omp declare target {host,nohost,block}\" attributes.\n+\n 2019-10-17  JeanHeyd Meneide  <phdofthehouse@gmail.com>\n \n \t* c-lex.c (c_common_has_attribute): Update nodiscard value."}, {"sha": "1c9f28587fbb2348cc30e302e889a5a22906901a", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -456,6 +456,12 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_omp_declare_target_attribute, NULL },\n   { \"omp declare target implicit\", 0, 0, true, false, false, false,\n \t\t\t      handle_omp_declare_target_attribute, NULL },\n+  { \"omp declare target host\", 0, 0, true, false, false, false,\n+\t\t\t      handle_omp_declare_target_attribute, NULL },\n+  { \"omp declare target nohost\", 0, 0, true, false, false, false,\n+\t\t\t      handle_omp_declare_target_attribute, NULL },\n+  { \"omp declare target block\", 0, 0, true, false, false, false,\n+\t\t\t      handle_omp_declare_target_attribute, NULL },\n   { \"alloc_align\",\t      1, 1, false, true, true, false,\n \t\t\t      handle_alloc_align_attribute,\n \t                      attr_alloc_exclusions },"}, {"sha": "70771834502f9e72a8abb5b8ce57b7d5d43220a8", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1193,7 +1193,6 @@ extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n extern tree c_omp_check_context_selector (location_t, tree);\n extern tree c_omp_get_context_selector (tree, const char *, const char *);\n extern void c_omp_mark_declare_variant (location_t, tree, tree);\n-extern int c_omp_context_selector_matches (tree);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree"}, {"sha": "4f5a6ed175adefe8694a9514a1ab76d4105e0fbe", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -34,9 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"attribs.h\"\n #include \"gimplify.h\"\n-#include \"cgraph.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -2388,188 +2385,3 @@ c_omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n     error_at (loc, \"%qD used as a variant with incompatible %<constructor%> \"\n \t\t   \"selector sets\", variant);\n }\n-\n-/* Return 1 if context selector matches the current OpenMP context, 0\n-   if it does not and -1 if it is unknown and need to be determined later.\n-   Some properties can be checked right away during parsing (this routine),\n-   others need to wait until the whole TU is parsed, others need to wait until\n-   IPA, others until vectorization.  */\n-\n-int\n-c_omp_context_selector_matches (tree ctx)\n-{\n-  int ret = 1;\n-  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n-    {\n-      char set = IDENTIFIER_POINTER (TREE_PURPOSE (t1))[0];\n-      if (set == 'c')\n-\t{\n-\t  /* For now, ignore the construct set.  While something can be\n-\t     determined already during parsing, we don't know until end of TU\n-\t     whether additional constructs aren't added through declare variant\n-\t     unless \"omp declare variant variant\" attribute exists already\n-\t     (so in most of the cases), and we'd need to maintain set of\n-\t     surrounding OpenMP constructs, which is better handled during\n-\t     gimplification.  */\n-\t  ret = -1;\n-\t  continue;\n-\t}\n-      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n-\t{\n-\t  const char *sel = IDENTIFIER_POINTER (TREE_PURPOSE (t2));\n-\t  switch (*sel)\n-\t    {\n-\t    case 'v':\n-\t      if (set == 'i' && !strcmp (sel, \"vendor\"))\n-\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n-\t\t  {\n-\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n-\t\t    if (!strcmp (prop, \" score\") || !strcmp (prop, \"gnu\"))\n-\t\t      continue;\n-\t\t    return 0;\n-\t\t  }\n-\t      break;\n-\t    case 'e':\n-\t      if (set == 'i' && !strcmp (sel, \"extension\"))\n-\t\t/* We don't support any extensions right now.  */\n-\t\treturn 0;\n-\t      break;\n-\t    case 'a':\n-\t      if (set == 'i' && !strcmp (sel, \"atomic_default_mem_order\"))\n-\t\t{\n-\t\t  enum omp_memory_order omo\n-\t\t    = ((enum omp_memory_order)\n-\t\t       (omp_requires_mask\n-\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER));\n-\t\t  if (omo == OMP_MEMORY_ORDER_UNSPECIFIED)\n-\t\t    {\n-\t\t      /* We don't know yet, until end of TU.  */\n-\t\t      ret = -1;\n-\t\t      break;\n-\t\t    }\n-\t\t  tree t3 = TREE_VALUE (t2);\n-\t\t  const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n-\t\t  if (!strcmp (prop, \" score\"))\n-\t\t    {\n-\t\t      t3 = TREE_CHAIN (t3);\n-\t\t      prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n-\t\t    }\n-\t\t  if (!strcmp (prop, \"relaxed\")\n-\t\t      && omo != OMP_MEMORY_ORDER_RELAXED)\n-\t\t    return 0;\n-\t\t  else if (!strcmp (prop, \"seq_cst\")\n-\t\t\t   && omo != OMP_MEMORY_ORDER_SEQ_CST)\n-\t\t    return 0;\n-\t\t  else if (!strcmp (prop, \"acq_rel\")\n-\t\t\t   && omo != OMP_MEMORY_ORDER_ACQ_REL)\n-\t\t    return 0;\n-\t\t}\n-\t      if (set == 'd' && !strcmp (sel, \"arch\"))\n-\t\t/* For now, need a target hook.  */\n-\t\tret = -1;\n-\t      break;\n-\t    case 'u':\n-\t      if (set == 'i' && !strcmp (sel, \"unified_address\"))\n-\t\t{\n-\t\t  if ((omp_requires_mask & OMP_REQUIRES_UNIFIED_ADDRESS) == 0)\n-\t\t    ret = -1;\n-\t\t  break;\n-\t\t}\n-\t      if (set == 'i' && !strcmp (sel, \"unified_shared_memory\"))\n-\t\t{\n-\t\t  if ((omp_requires_mask\n-\t\t       & OMP_REQUIRES_UNIFIED_SHARED_MEMORY) == 0)\n-\t\t    ret = -1;\n-\t\t  break;\n-\t\t}\n-\t      break;\n-\t    case 'd':\n-\t      if (set == 'i' && !strcmp (sel, \"dynamic_allocators\"))\n-\t\t{\n-\t\t  if ((omp_requires_mask\n-\t\t       & OMP_REQUIRES_DYNAMIC_ALLOCATORS) == 0)\n-\t\t    ret = -1;\n-\t\t  break;\n-\t\t}\n-\t      break;\n-\t    case 'r':\n-\t      if (set == 'i' && !strcmp (sel, \"reverse_offload\"))\n-\t\t{\n-\t\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n-\t\t    ret = -1;\n-\t\t  break;\n-\t\t}\n-\t      break;\n-\t    case 'k':\n-\t      if (set == 'd' && !strcmp (sel, \"kind\"))\n-\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n-\t\t  {\n-\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n-\t\t    if (!strcmp (prop, \"any\"))\n-\t\t      continue;\n-\t\t    if (!strcmp (prop, \"fpga\"))\n-\t\t      return 0;\t/* Right now GCC doesn't support any fpgas.  */\n-\t\t    if (!strcmp (prop, \"host\"))\n-\t\t      {\n-\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n-\t\t\t  ret = -1;\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t    if (!strcmp (prop, \"nohost\"))\n-\t\t      {\n-\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n-\t\t\t  ret = -1;\n-\t\t\telse\n-\t\t\t  return 0;\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t    if (!strcmp (prop, \"cpu\") || !strcmp (prop, \"gpu\"))\n-\t\t      {\n-\t\t\tbool maybe_gpu = false;\n-\t\t\tif (hsa_gen_requested_p ())\n-\t\t\t  maybe_gpu = true;\n-\t\t\telse if (ENABLE_OFFLOADING)\n-\t\t\t  for (const char *c = getenv (\"OFFLOAD_TARGET_NAMES\");\n-\t\t\t       c; )\n-\t\t\t    {\n-\t\t\t      if (!strncmp (c, \"nvptx\", strlen (\"nvptx\"))\n-\t\t\t\t  || !strncmp (c, \"amdgcn\", strlen (\"amdgcn\")))\n-\t\t\t\t{\n-\t\t\t\t  maybe_gpu = true;\n-\t\t\t\t  break;\n-\t\t\t\t}\n-\t\t\t      else if ((c = strchr (c, ',')))\n-\t\t\t\tc++;\n-\t\t\t    }\n-\t\t\tif (!maybe_gpu)\n-\t\t\t  {\n-\t\t\t    if (prop[0] == 'g')\n-\t\t\t      return 0;\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  ret = -1;\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t    /* Any other kind doesn't match.  */\n-\t\t    return 0;\n-\t\t  }\n-\t      break;\n-\t    case 'i':\n-\t      if (set == 'd' && !strcmp (sel, \"isa\"))\n-\t\t/* For now, need a target hook.  */\n-\t\tret = -1;\n-\t      break;\n-\t    case 'c':\n-\t      if (set == 'u' && !strcmp (sel, \"condition\"))\n-\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n-\t\t  if (TREE_PURPOSE (t3) == NULL_TREE\n-\t\t      && integer_zerop (TREE_VALUE (t3)))\n-\t\t    return 0;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return ret;\n-}"}, {"sha": "e8518f27494a65994ebae307b380a50c42c1fb55", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1,3 +1,12 @@\n+2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (c_finish_omp_declare_variant): Use\n+\tomp_context_selector_matches instead of\n+\tc_omp_context_selector_matches.\n+\t* c-decl.c (c_decl_attributes): Add \"omp declare target block\"\n+\tattribute in between declare target and end declare target\n+\tpragmas.\n+\n 2019-10-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c (c_parser_attribute_any_word): Rename to"}, {"sha": "c6c4a4d7aebc5c57f30d6a8d747ffe4c21b7ea3d", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -4832,8 +4832,12 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \tattributes = tree_cons (get_identifier (\"omp declare target implicit\"),\n \t\t\t\tNULL_TREE, attributes);\n       else\n-\tattributes = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t\t\tNULL_TREE, attributes);\n+\t{\n+\t  attributes = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t\t\t  NULL_TREE, attributes);\n+\t  attributes = tree_cons (get_identifier (\"omp declare target block\"),\n+\t\t\t\t  NULL_TREE, attributes);\n+\t}\n     }\n \n   /* Look up the current declaration with all the attributes merged"}, {"sha": "9589cc68c25b5b15bb364fdae56e24dedbe91601", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -19489,7 +19489,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \t  C_DECL_USED (variant) = 1;\n \t  tree construct = c_omp_get_context_selector (ctx, \"construct\", NULL);\n \t  c_omp_mark_declare_variant (match_loc, variant, construct);\n-\t  if (c_omp_context_selector_matches (ctx))\n+\t  if (omp_context_selector_matches (ctx))\n \t    {\n \t      tree attr\n \t\t= tree_cons (get_identifier (\"omp declare variant base\"),"}, {"sha": "78bbfb5b9372550b827526ccccf946da537917eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1,5 +1,9 @@\n 2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* decl2.c (cplus_decl_attributes): Add \"omp declare target block\"\n+\tattribute in between declare target and end declare target\n+\tpragmas.\n+\n \t* call.c (convert_arg_to_ellipsis): Add missing space in string\n \tliteral.\n "}, {"sha": "cff11baef4690b8552666861b5659f32951794a2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1555,8 +1555,12 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \tattributes = tree_cons (get_identifier (\"omp declare target implicit\"),\n \t\t\t\tNULL_TREE, attributes);\n       else\n-\tattributes = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t\t\tNULL_TREE, attributes);\n+\t{\n+\t  attributes = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t\t\t  NULL_TREE, attributes);\n+\t  attributes = tree_cons (get_identifier (\"omp declare target block\"),\n+\t\t\t\t  NULL_TREE, attributes);\n+\t}\n     }\n \n   if (processing_template_decl)"}, {"sha": "05ae2f1552bd5dffb503e17b45e85bfe5eb5cad6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -219,6 +219,7 @@ struct gimplify_omp_ctx\n   location_t location;\n   enum omp_clause_default_kind default_kind;\n   enum omp_region_type region_type;\n+  enum tree_code code;\n   bool combined_loop;\n   bool distribute;\n   bool target_firstprivatize_array_bases;\n@@ -3385,6 +3386,13 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   /* Remember the original function pointer type.  */\n   fnptrtype = TREE_TYPE (CALL_EXPR_FN (*expr_p));\n \n+  if (flag_openmp && fndecl)\n+    {\n+      tree variant = omp_resolve_declare_variant (fndecl);\n+      if (variant != fndecl)\n+\tCALL_EXPR_FN (*expr_p) = build1 (ADDR_EXPR, fnptrtype, variant);\n+    }\n+\n   /* There is a sequence point before the call, so any side effects in\n      the calling expression must occur before the actual call.  Force\n      gimplify_expr to use an internal post queue.  */\n@@ -8137,6 +8145,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   int nowait = -1;\n \n   ctx = new_omp_context (region_type);\n+  ctx->code = code;\n   outer_ctx = ctx->outer_context;\n   if (code == OMP_TARGET)\n     {\n@@ -10324,6 +10333,99 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n   delete_omp_context (ctx);\n }\n \n+/* Return 0 if CONSTRUCTS selectors don't match the OpenMP context,\n+   -1 if unknown yet (simd is involved, won't be known until vectorization)\n+   and positive number if they do, the number is then the number of constructs\n+   in the OpenMP context.  */\n+\n+HOST_WIDE_INT\n+omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n+{\n+  int matched = 0, cnt = 0;\n+  bool simd_seen = false;\n+  for (struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp; ctx;)\n+    {\n+      if (((ctx->region_type & ORT_PARALLEL) && ctx->code == OMP_PARALLEL)\n+\t  || ((ctx->region_type & (ORT_TARGET | ORT_IMPLICIT_TARGET | ORT_ACC))\n+\t      == ORT_TARGET && ctx->code == OMP_TARGET)\n+\t  || ((ctx->region_type & ORT_TEAMS) && ctx->code == OMP_TEAMS)\n+\t  || (ctx->region_type == ORT_WORKSHARE && ctx->code == OMP_FOR)\n+\t  || (ctx->region_type == ORT_SIMD\n+\t      && ctx->code == OMP_SIMD\n+\t      && !omp_find_clause (ctx->clauses, OMP_CLAUSE_BIND)))\n+\t{\n+\t  ++cnt;\n+\t  if (matched < nconstructs && ctx->code == constructs[matched])\n+\t    {\n+\t      if (ctx->code == OMP_SIMD)\n+\t\t{\n+\t\t  if (matched)\n+\t\t    return 0;\n+\t\t  simd_seen = true;\n+\t\t}\n+\t      ++matched;\n+\t    }\n+\t  if (ctx->code == OMP_TARGET)\n+\t    return matched < nconstructs ? 0 : simd_seen ? -1 : cnt;\n+\t}\n+      else if (ctx->region_type == ORT_WORKSHARE\n+\t       && ctx->code == OMP_LOOP\n+\t       && ctx->outer_context\n+\t       && ctx->outer_context->region_type == ORT_COMBINED_PARALLEL\n+\t       && ctx->outer_context->outer_context\n+\t       && ctx->outer_context->outer_context->code == OMP_LOOP\n+\t       && ctx->outer_context->outer_context->distribute)\n+\tctx = ctx->outer_context->outer_context;\n+      ctx = ctx->outer_context;\n+    }\n+  if (cnt == 0\n+      && constructs[0] == OMP_SIMD\n+      && lookup_attribute (\"omp declare simd\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n+    {\n+      /* Declare simd is a maybe case, it is supposed to be added only to the\n+\t omp-simd-clone.c added clones and not to the base function.  */\n+      gcc_assert (matched == 0);\n+      ++cnt;\n+      simd_seen = true;\n+      if (++matched == nconstructs)\n+\treturn -1;\n+    }\n+  if (tree attr = lookup_attribute (\"omp declare variant variant\",\n+\t\t\t\t    DECL_ATTRIBUTES (current_function_decl)))\n+    {\n+      enum tree_code variant_constructs[5];\n+      int variant_nconstructs\n+\t= omp_constructor_traits_to_codes (TREE_VALUE (attr),\n+\t\t\t\t\t   variant_constructs);\n+      for (int i = 0; i < variant_nconstructs; i++)\n+\t{\n+\t  ++cnt;\n+\t  if (matched < nconstructs\n+\t      && variant_constructs[i] == constructs[matched])\n+\t    {\n+\t      if (variant_constructs[i] == OMP_SIMD)\n+\t\t{\n+\t\t  if (matched)\n+\t\t    return 0;\n+\t\t  simd_seen = true;\n+\t\t}\n+\t      ++matched;\n+\t    }\n+\t}\n+    }\n+  if (lookup_attribute (\"omp declare target block\",\n+\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n+    {\n+      ++cnt;\n+      if (matched < nconstructs && constructs[matched] == OMP_TARGET)\n+\t++matched;\n+    }\n+  if (matched == nconstructs)\n+    return simd_seen ? -1 : cnt;\n+  return 0;\n+}\n+\n /* Gimplify OACC_CACHE.  */\n \n static void"}, {"sha": "601b82b12bd1e373dfa36816d8972dda6a55113f", "filename": "gcc/gimplify.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -75,6 +75,8 @@ extern void omp_firstprivatize_variable (struct gimplify_omp_ctx *, tree);\n extern enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n \n+HOST_WIDE_INT omp_construct_selector_matches (enum tree_code *, int);\n+\n extern void gimplify_type_sizes (tree, gimple_seq *);\n extern void gimplify_one_sizepos (tree *, gimple_seq *);\n extern gbind *gimplify_body (tree, bool);"}, {"sha": "9397b1951f8088470b28d1fee0a6ebcd4f57b117", "filename": "gcc/omp-general.c", "status": "modified", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -35,6 +35,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"gimplify.h\"\n+#include \"cgraph.h\"\n+#include \"symbol-summary.h\"\n+#include \"hsa-common.h\"\n+#include \"tree-pass.h\"\n \n enum omp_requires omp_requires_mask;\n \n@@ -538,6 +543,299 @@ omp_max_simt_vf (void)\n   return 0;\n }\n \n+/* Store the construct selectors as tree codes from last to first,\n+   return their number.  */\n+\n+int\n+omp_constructor_traits_to_codes (tree ctx, enum tree_code *constructs)\n+{\n+  int nconstructs = list_length (ctx);\n+  int i = nconstructs - 1;\n+  for (tree t2 = ctx; t2; t2 = TREE_CHAIN (t2), i--)\n+    {\n+      const char *sel = IDENTIFIER_POINTER (TREE_PURPOSE (t2));\n+      if (!strcmp (sel, \"target\"))\n+\tconstructs[i] = OMP_TARGET;\n+      else if (!strcmp (sel, \"teams\"))\n+\tconstructs[i] = OMP_TEAMS;\n+      else if (!strcmp (sel, \"parallel\"))\n+\tconstructs[i] = OMP_PARALLEL;\n+      else if (!strcmp (sel, \"for\") || !strcmp (sel, \"do\"))\n+\tconstructs[i] = OMP_FOR;\n+      else if (!strcmp (sel, \"simd\"))\n+\tconstructs[i] = OMP_SIMD;\n+      else\n+\tgcc_unreachable ();\n+    }\n+  gcc_assert (i == -1);\n+  return nconstructs;\n+}\n+\n+/* Return 1 if context selector matches the current OpenMP context, 0\n+   if it does not and -1 if it is unknown and need to be determined later.\n+   Some properties can be checked right away during parsing (this routine),\n+   others need to wait until the whole TU is parsed, others need to wait until\n+   IPA, others until vectorization.  */\n+\n+int\n+omp_context_selector_matches (tree ctx)\n+{\n+  int ret = 1;\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    {\n+      char set = IDENTIFIER_POINTER (TREE_PURPOSE (t1))[0];\n+      if (set == 'c')\n+\t{\n+\t  /* For now, ignore the construct set.  While something can be\n+\t     determined already during parsing, we don't know until end of TU\n+\t     whether additional constructs aren't added through declare variant\n+\t     unless \"omp declare variant variant\" attribute exists already\n+\t     (so in most of the cases), and we'd need to maintain set of\n+\t     surrounding OpenMP constructs, which is better handled during\n+\t     gimplification.  */\n+\t  if (symtab->state == PARSING\n+\t      || (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t    {\n+\t      ret = -1;\n+\t      continue;\n+\t    }\n+\n+\t  enum tree_code constructs[5];\n+\t  int nconstructs\n+\t    = omp_constructor_traits_to_codes (TREE_VALUE (t1), constructs);\n+\t  HOST_WIDE_INT r\n+\t    = omp_construct_selector_matches (constructs, nconstructs);\n+\t  if (r == 0)\n+\t    return 0;\n+\t  if (r == -1)\n+\t    ret = -1;\n+\t  continue;\n+\t}\n+      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t{\n+\t  const char *sel = IDENTIFIER_POINTER (TREE_PURPOSE (t2));\n+\t  switch (*sel)\n+\t    {\n+\t    case 'v':\n+\t      if (set == 'i' && !strcmp (sel, \"vendor\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    if (!strcmp (prop, \" score\") || !strcmp (prop, \"gnu\"))\n+\t\t      continue;\n+\t\t    return 0;\n+\t\t  }\n+\t      break;\n+\t    case 'e':\n+\t      if (set == 'i' && !strcmp (sel, \"extension\"))\n+\t\t/* We don't support any extensions right now.  */\n+\t\treturn 0;\n+\t      break;\n+\t    case 'a':\n+\t      if (set == 'i' && !strcmp (sel, \"atomic_default_mem_order\"))\n+\t\t{\n+\t\t  enum omp_memory_order omo\n+\t\t    = ((enum omp_memory_order)\n+\t\t       (omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER));\n+\t\t  if (omo == OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    {\n+\t\t      /* We don't know yet, until end of TU.  */\n+\t\t      if (symtab->state == PARSING)\n+\t\t\t{\n+\t\t\t  ret = -1;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\tomo = OMP_MEMORY_ORDER_RELAXED;\n+\t\t    }\n+\t\t  tree t3 = TREE_VALUE (t2);\n+\t\t  const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t  if (!strcmp (prop, \" score\"))\n+\t\t    {\n+\t\t      t3 = TREE_CHAIN (t3);\n+\t\t      prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    }\n+\t\t  if (!strcmp (prop, \"relaxed\")\n+\t\t      && omo != OMP_MEMORY_ORDER_RELAXED)\n+\t\t    return 0;\n+\t\t  else if (!strcmp (prop, \"seq_cst\")\n+\t\t\t   && omo != OMP_MEMORY_ORDER_SEQ_CST)\n+\t\t    return 0;\n+\t\t  else if (!strcmp (prop, \"acq_rel\")\n+\t\t\t   && omo != OMP_MEMORY_ORDER_ACQ_REL)\n+\t\t    return 0;\n+\t\t}\n+\t      if (set == 'd' && !strcmp (sel, \"arch\"))\n+\t\t/* For now, need a target hook.  */\n+\t\tret = -1;\n+\t      break;\n+\t    case 'u':\n+\t      if (set == 'i' && !strcmp (sel, \"unified_address\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask & OMP_REQUIRES_UNIFIED_ADDRESS) == 0)\n+\t\t    {\n+\t\t      if (symtab->state == PARSING)\n+\t\t\tret = -1;\n+\t\t      else\n+\t\t\treturn 0;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      if (set == 'i' && !strcmp (sel, \"unified_shared_memory\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask\n+\t\t       & OMP_REQUIRES_UNIFIED_SHARED_MEMORY) == 0)\n+\t\t    {\n+\t\t      if (symtab->state == PARSING)\n+\t\t\tret = -1;\n+\t\t      else\n+\t\t\treturn 0;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'd':\n+\t      if (set == 'i' && !strcmp (sel, \"dynamic_allocators\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask\n+\t\t       & OMP_REQUIRES_DYNAMIC_ALLOCATORS) == 0)\n+\t\t    {\n+\t\t      if (symtab->state == PARSING)\n+\t\t\tret = -1;\n+\t\t      else\n+\t\t\treturn 0;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'r':\n+\t      if (set == 'i' && !strcmp (sel, \"reverse_offload\"))\n+\t\t{\n+\t\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n+\t\t    {\n+\t\t      if (symtab->state == PARSING)\n+\t\t\tret = -1;\n+\t\t      else\n+\t\t\treturn 0;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case 'k':\n+\t      if (set == 'd' && !strcmp (sel, \"kind\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    if (!strcmp (prop, \"any\"))\n+\t\t      continue;\n+\t\t    if (!strcmp (prop, \"fpga\"))\n+\t\t      return 0;\t/* Right now GCC doesn't support any fpgas.  */\n+\t\t    if (!strcmp (prop, \"host\"))\n+\t\t      {\n+\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\t  ret = -1;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    if (!strcmp (prop, \"nohost\"))\n+\t\t      {\n+\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\t  ret = -1;\n+\t\t\telse\n+\t\t\t  return 0;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    if (!strcmp (prop, \"cpu\") || !strcmp (prop, \"gpu\"))\n+\t\t      {\n+\t\t\tbool maybe_gpu = false;\n+\t\t\tif (hsa_gen_requested_p ())\n+\t\t\t  maybe_gpu = true;\n+\t\t\telse if (ENABLE_OFFLOADING)\n+\t\t\t  for (const char *c = getenv (\"OFFLOAD_TARGET_NAMES\");\n+\t\t\t       c; )\n+\t\t\t    {\n+\t\t\t      if (!strncmp (c, \"nvptx\", strlen (\"nvptx\"))\n+\t\t\t\t  || !strncmp (c, \"amdgcn\", strlen (\"amdgcn\")))\n+\t\t\t\t{\n+\t\t\t\t  maybe_gpu = true;\n+\t\t\t\t  break;\n+\t\t\t\t}\n+\t\t\t      else if ((c = strchr (c, ',')))\n+\t\t\t\tc++;\n+\t\t\t    }\n+\t\t\tif (!maybe_gpu)\n+\t\t\t  {\n+\t\t\t    if (prop[0] == 'g')\n+\t\t\t      return 0;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  ret = -1;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    /* Any other kind doesn't match.  */\n+\t\t    return 0;\n+\t\t  }\n+\t      break;\n+\t    case 'i':\n+\t      if (set == 'd' && !strcmp (sel, \"isa\"))\n+\t\t/* For now, need a target hook.  */\n+\t\tret = -1;\n+\t      break;\n+\t    case 'c':\n+\t      if (set == 'u' && !strcmp (sel, \"condition\"))\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  if (TREE_PURPOSE (t3) == NULL_TREE)\n+\t\t    {\n+\t\t      if (integer_zerop (TREE_VALUE (t3)))\n+\t\t\treturn 0;\n+\t\t      if (integer_nonzerop (TREE_VALUE (t3)))\n+\t\t\tbreak;\n+\t\t      ret = -1;\n+\t\t    }\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Try to resolve declare variant, return the variant decl if it should\n+   be used instead of base, or base otherwise.  */\n+\n+tree\n+omp_resolve_declare_variant (tree base)\n+{\n+  tree variant = NULL_TREE;\n+  for (tree attr = DECL_ATTRIBUTES (base); attr; attr = TREE_CHAIN (attr))\n+    {\n+      attr = lookup_attribute (\"omp declare variant base\", attr);\n+      if (attr == NULL_TREE)\n+\tbreak;\n+      switch (omp_context_selector_matches (TREE_VALUE (TREE_VALUE (attr))))\n+\t{\n+\tcase 0:\n+\t  /* No match, ignore.  */\n+\t  break;\n+\tcase -1:\n+\t  /* Needs to be deferred.  */\n+\t  return base;\n+\tdefault:\n+\t  /* FIXME: Scoring not implemented yet, so just resolve it\n+\t     if there is a single variant only.  */\n+\t  if (variant)\n+\t    return base;\n+\t  if (TREE_CODE (TREE_PURPOSE (TREE_VALUE (attr))) == FUNCTION_DECL)\n+\t    variant = TREE_PURPOSE (TREE_VALUE (attr));\n+\t  else\n+\t    return base;\n+\t}\n+    }\n+  return variant ? variant : base;\n+}\n+\n+\n /* Encode an oacc launch argument.  This matches the GOMP_LAUNCH_PACK\n    macro on gomp-constants.h.  We do not check for overflow.  */\n "}, {"sha": "c0c294d29f483f7a7e2f979698b318e7a053c00e", "filename": "gcc/omp-general.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -84,6 +84,9 @@ extern void omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n extern gimple *omp_build_barrier (tree lhs);\n extern poly_uint64 omp_max_vf (void);\n extern int omp_max_simt_vf (void);\n+extern int omp_constructor_traits_to_codes (tree, enum tree_code *);\n+extern int omp_context_selector_matches (tree);\n+extern tree omp_resolve_declare_variant (tree);\n extern tree oacc_launch_pack (unsigned code, tree device, unsigned op);\n extern tree oacc_replace_fn_attrib_attr (tree attribs, tree dims);\n extern void oacc_replace_fn_attrib (tree fn, tree dims);"}, {"sha": "8e652ab3cbf3a463ffd092e8d6357fcaf953d49c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -1,3 +1,7 @@\n+2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-8.c: New test.\n+\n 2019-10-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* gcc.dg/ipa/ipa-sra-19.c: Remove dg-skip-if. Add argument type to"}, {"sha": "792e56ccd97c773ec8511e023c33d422a7cce2c0", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-8.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135df52cc3f1ef90092ab02a01c4dabc7fd0ed18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-8.c?ref=135df52cc3f1ef90092ab02a01c4dabc7fd0ed18", "patch": "@@ -0,0 +1,125 @@\n+/* { dg-do compile { target c } } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+void f01 (void);\n+#pragma omp declare variant (f01) match (user={condition(6 == 7)},implementation={vendor(gnu)})\n+void f02 (void);\n+void f03 (void);\n+#pragma omp declare variant (f03) match (user={condition(6 == 6)},implementation={atomic_default_mem_order(seq_cst)})\n+void f04 (void);\n+void f05 (void);\n+#pragma omp declare variant (f05) match (user={condition(1)},implementation={atomic_default_mem_order(relaxed)})\n+void f06 (void);\n+#pragma omp requires atomic_default_mem_order(seq_cst)\n+void f07 (void);\n+#pragma omp declare variant (f07) match (construct={parallel,for},device={kind(any)})\n+void f08 (void);\n+void f09 (void);\n+#pragma omp declare variant (f09) match (construct={parallel,for},implementation={vendor(gnu)})\n+void f10 (void);\n+void f11 (void);\n+#pragma omp declare variant (f11) match (construct={parallel,for})\n+void f12 (void);\n+void f13 (void);\n+#pragma omp declare variant (f13) match (construct={parallel,for})\n+void f14 (void);\n+#pragma omp declare target to (f13, f14)\n+void f15 (void);\n+#pragma omp declare variant (f15) match (implementation={vendor(llvm)})\n+void f16 (void);\n+void f17 (void);\n+#pragma omp declare variant (f17) match (construct={target,parallel})\n+void f18 (void);\n+void f19 (void);\n+#pragma omp declare variant (f19) match (construct={target,parallel})\n+void f20 (void);\n+void f21 (void);\n+#pragma omp declare variant (f21) match (construct={teams,parallel})\n+void f22 (void);\n+void f23 (void);\n+#pragma omp declare variant (f23) match (construct={teams,parallel,for})\n+void f24 (void);\n+void f25 (void);\n+#pragma omp declare variant (f25) match (construct={teams,parallel})\n+void f26 (void);\n+void f27 (void);\n+#pragma omp declare variant (f27) match (construct={teams,parallel,for})\n+void f28 (void);\n+void f29 (void);\n+#pragma omp declare variant (f29) match (implementation={vendor(gnu)})\n+void f30 (void);\n+void f31 (void);\n+#pragma omp declare variant (f31) match (construct={teams,parallel,for})\n+void f32 (void);\n+\n+void\n+test1 (void)\n+{\n+  int i;\n+  f02 ();\t/* { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f04 ();\t/* { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f06 ();\t/* { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp parallel\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    f08 ();\t/* { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp parallel for\n+  for (i = 0; i < 1; i++)\n+    f10 ();\t/* { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    #pragma omp parallel\n+    f12 ();\t/* { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp parallel\n+  #pragma omp target\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    f14 ();\t/* { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f16 ();\t/* { dg-final { scan-tree-dump-times \"f16 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+\n+#pragma omp declare target\n+void\n+test2 (void)\n+{\n+  #pragma omp parallel\n+  f18 ();\t/* { dg-final { scan-tree-dump-times \"f17 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+#pragma omp end declare target\n+\n+void test3 (void);\n+#pragma omp declare target to (test3)\n+\n+void\n+test3 (void)\n+{\n+  #pragma omp parallel\n+  f20 ();\t/* { dg-final { scan-tree-dump-times \"f20 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+\n+void\n+f21 (void)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    f24 ();\t/* { dg-final { scan-tree-dump-times \"f23 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+\n+void\n+f26 (void)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    f28 ();\t/* { dg-final { scan-tree-dump-times \"f28 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+\n+void\n+f29 (void)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    f32 ();\t/* { dg-final { scan-tree-dump-times \"f32 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}"}]}