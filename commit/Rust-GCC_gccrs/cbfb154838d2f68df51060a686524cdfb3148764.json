{"sha": "cbfb154838d2f68df51060a686524cdfb3148764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmYjE1NDgzOGQyZjY4ZGY1MTA2MGE2ODY1MjRjZGZiMzE0ODc2NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-10-29T10:00:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-10-29T10:00:18Z"}, "message": "PR rtl-optimization/63340 (part 1)\n\ngcc/\n\tPR rtl-optimization/63340 (part 1)\n\t* ira-costs.c (all_cost_classes): New variable.\n\t(complete_cost_classes): New function, split out from...\n\t(setup_cost_classes): ...here.\n\t(initiate_regno_cost_classes): Set up all_cost_classes.\n\t(restrict_cost_classes): New function.\n\t(setup_regno_cost_classes_by_aclass): Restrict the cost classes to\n\tregisters that are valid for the register's mode.\n\t(setup_regno_cost_classes_by_mode): Model the mode cache as a\n\trestriction of all_cost_classes to a particular mode.\n\t(print_allocno_costs): Remove contains_reg_of_mode check.\n\t(print_pseudo_costs, find_costs_and_classes): Likewise.\n\nFrom-SVN: r216828", "tree": {"sha": "b6794ab36a4bffd07c40e1276f4aaeff13cbd2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6794ab36a4bffd07c40e1276f4aaeff13cbd2ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbfb154838d2f68df51060a686524cdfb3148764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfb154838d2f68df51060a686524cdfb3148764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbfb154838d2f68df51060a686524cdfb3148764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfb154838d2f68df51060a686524cdfb3148764/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f5f9f3613643e828b676318c81b7229dcaf9016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5f9f3613643e828b676318c81b7229dcaf9016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5f9f3613643e828b676318c81b7229dcaf9016"}], "stats": {"total": 204, "additions": 152, "deletions": 52}, "files": [{"sha": "8be1f259da1d713869700dcf21efbbef9362d6e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfb154838d2f68df51060a686524cdfb3148764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfb154838d2f68df51060a686524cdfb3148764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbfb154838d2f68df51060a686524cdfb3148764", "patch": "@@ -1,3 +1,18 @@\n+2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/63340 (part 1)\n+\t* ira-costs.c (all_cost_classes): New variable.\n+\t(complete_cost_classes): New function, split out from...\n+\t(setup_cost_classes): ...here.\n+\t(initiate_regno_cost_classes): Set up all_cost_classes.\n+\t(restrict_cost_classes): New function.\n+\t(setup_regno_cost_classes_by_aclass): Restrict the cost classes to\n+\tregisters that are valid for the register's mode.\n+\t(setup_regno_cost_classes_by_mode): Model the mode cache as a\n+\trestriction of all_cost_classes to a particular mode.\n+\t(print_allocno_costs): Remove contains_reg_of_mode check.\n+\t(print_pseudo_costs, find_costs_and_classes): Likewise.\n+\n 2014-10-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/63666"}, {"sha": "dbefaced65773749e439f2b160ce8339ebcc1380", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 137, "deletions": 52, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfb154838d2f68df51060a686524cdfb3148764/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfb154838d2f68df51060a686524cdfb3148764/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=cbfb154838d2f68df51060a686524cdfb3148764", "patch": "@@ -185,6 +185,31 @@ static cost_classes_t cost_classes_aclass_cache[N_REG_CLASSES];\n /* Map mode -> cost classes for pseudo of give mode.  */\n static cost_classes_t cost_classes_mode_cache[MAX_MACHINE_MODE];\n \n+/* Cost classes that include all classes in ira_important_classes.  */\n+static cost_classes all_cost_classes;\n+\n+/* Use the array of classes in CLASSES_PTR to fill out the rest of\n+   the structure.  */\n+static void\n+complete_cost_classes (cost_classes_t classes_ptr)\n+{\n+  for (int i = 0; i < N_REG_CLASSES; i++)\n+    classes_ptr->index[i] = -1;\n+  for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    classes_ptr->hard_regno_index[i] = -1;\n+  for (int i = 0; i < classes_ptr->num; i++)\n+    {\n+      enum reg_class cl = classes_ptr->classes[i];\n+      classes_ptr->index[cl] = i;\n+      for (int j = ira_class_hard_regs_num[cl] - 1; j >= 0; j--)\n+\t{\n+\t  unsigned int hard_regno = ira_class_hard_regs[cl][j];\n+\t  if (classes_ptr->hard_regno_index[hard_regno] < 0)\n+\t    classes_ptr->hard_regno_index[hard_regno] = i;\n+\t}\n+    }\n+}\n+\n /* Initialize info about the cost classes for each pseudo.  */\n static void\n initiate_regno_cost_classes (void)\n@@ -198,6 +223,10 @@ initiate_regno_cost_classes (void)\n   memset (cost_classes_mode_cache, 0,\n \t  sizeof (cost_classes_t) * MAX_MACHINE_MODE);\n   cost_classes_htab = new hash_table<cost_classes_hasher> (200);\n+  all_cost_classes.num = ira_important_classes_num;\n+  for (int i = 0; i < ira_important_classes_num; i++)\n+    all_cost_classes.classes[i] = ira_important_classes[i];\n+  complete_cost_classes (&all_cost_classes);\n }\n \n /* Create new cost classes from cost classes FROM and set up members\n@@ -209,27 +238,105 @@ static cost_classes_t\n setup_cost_classes (cost_classes_t from)\n {\n   cost_classes_t classes_ptr;\n-  enum reg_class cl;\n-  int i, j, hard_regno;\n \n   classes_ptr = (cost_classes_t) ira_allocate (sizeof (struct cost_classes));\n   classes_ptr->num = from->num;\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    classes_ptr->index[i] = -1;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    classes_ptr->hard_regno_index[i] = -1;\n-  for (i = 0; i < from->num; i++)\n+  for (int i = 0; i < from->num; i++)\n+    classes_ptr->classes[i] = from->classes[i];\n+  complete_cost_classes (classes_ptr);\n+  return classes_ptr;\n+}\n+\n+/* Return a version of FULL that only considers registers in REGS that are\n+   valid for mode MODE.  Both FULL and the returned class are globally\n+   allocated.  */\n+static cost_classes_t\n+restrict_cost_classes (cost_classes_t full, enum machine_mode mode,\n+\t\t       const HARD_REG_SET &regs)\n+{\n+  static struct cost_classes narrow;\n+  int map[N_REG_CLASSES];\n+  narrow.num = 0;\n+  for (int i = 0; i < full->num; i++)\n     {\n-      cl = classes_ptr->classes[i] = from->classes[i];\n-      classes_ptr->index[cl] = i;\n-      for (j = ira_class_hard_regs_num[cl] - 1; j >= 0; j--)\n+      /* Assume that we'll drop the class.  */\n+      map[i] = -1;\n+\n+      /* Ignore classes that are too small for the mode.  */\n+      enum reg_class cl = full->classes[i];\n+      if (!contains_reg_of_mode[cl][mode])\n+\tcontinue;\n+\n+      /* Calculate the set of registers in CL that belong to REGS and\n+\t are valid for MODE.  */\n+      HARD_REG_SET valid_for_cl;\n+      COPY_HARD_REG_SET (valid_for_cl, reg_class_contents[cl]);\n+      AND_HARD_REG_SET (valid_for_cl, regs);\n+      AND_COMPL_HARD_REG_SET (valid_for_cl,\n+\t\t\t      ira_prohibited_class_mode_regs[cl][mode]);\n+      AND_COMPL_HARD_REG_SET (valid_for_cl, ira_no_alloc_regs);\n+      if (hard_reg_set_empty_p (valid_for_cl))\n+\tcontinue;\n+\n+      /* Don't use this class if the set of valid registers is a subset\n+\t of an existing class.  For example, suppose we have two classes\n+\t GR_REGS and FR_REGS and a union class GR_AND_FR_REGS.  Suppose\n+\t that the mode changes allowed by FR_REGS are not as general as\n+\t the mode changes allowed by GR_REGS.\n+\n+\t In this situation, the mode changes for GR_AND_FR_REGS could\n+\t either be seen as the union or the intersection of the mode\n+\t changes allowed by the two subclasses.  The justification for\n+\t the union-based definition would be that, if you want a mode\n+\t change that's only allowed by GR_REGS, you can pick a register\n+\t from the GR_REGS subclass.  The justification for the\n+\t intersection-based definition would be that every register\n+\t from the class would allow the mode change.\n+\n+\t However, if we have a register that needs to be in GR_REGS,\n+\t using GR_AND_FR_REGS with the intersection-based definition\n+\t would be too pessimistic, since it would bring in restrictions\n+\t that only apply to FR_REGS.  Conversely, if we have a register\n+\t that needs to be in FR_REGS, using GR_AND_FR_REGS with the\n+\t union-based definition would lose the extra restrictions\n+\t placed on FR_REGS.  GR_AND_FR_REGS is therefore only useful\n+\t for cases where GR_REGS and FP_REGS are both valid.  */\n+      int pos;\n+      for (pos = 0; pos < narrow.num; ++pos)\n \t{\n-\t  hard_regno = ira_class_hard_regs[cl][j];\n-\t  if (classes_ptr->hard_regno_index[hard_regno] < 0)\n-\t    classes_ptr->hard_regno_index[hard_regno] = i;\n+\t  enum reg_class cl2 = narrow.classes[pos];\n+\t  if (hard_reg_set_subset_p (valid_for_cl, reg_class_contents[cl2]))\n+\t    break;\n+\t}\n+      map[i] = pos;\n+      if (pos == narrow.num)\n+\t{\n+\t  /* If several classes are equivalent, prefer to use the one\n+\t     that was chosen as the allocno class.  */\n+\t  enum reg_class cl2 = ira_allocno_class_translate[cl];\n+\t  if (ira_class_hard_regs_num[cl] == ira_class_hard_regs_num[cl2])\n+\t    cl = cl2;\n+\t  narrow.classes[narrow.num++] = cl;\n \t}\n     }\n-  return classes_ptr;\n+  if (narrow.num == full->num)\n+    return full;\n+\n+  cost_classes **slot = cost_classes_htab->find_slot (&narrow, INSERT);\n+  if (*slot == NULL)\n+    {\n+      cost_classes_t classes = setup_cost_classes (&narrow);\n+      /* Map equivalent classes to the representative that we chose above.  */\n+      for (int i = 0; i < ira_important_classes_num; i++)\n+\t{\n+\t  enum reg_class cl = ira_important_classes[i];\n+\t  int index = full->index[cl];\n+\t  if (index >= 0)\n+\t    classes->index[cl] = map[index];\n+\t}\n+      *slot = classes;\n+    }\n+  return *slot;\n }\n \n /* Setup cost classes for pseudo REGNO whose allocno class is ACLASS.\n@@ -279,6 +386,13 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \t}\n       classes_ptr = cost_classes_aclass_cache[aclass] = (cost_classes_t) *slot;\n     }\n+  if (regno_reg_rtx[regno] != NULL_RTX)\n+    /* Restrict the classes to those that are valid for REGNO's mode\n+       (which might for example exclude singleton classes if the mode requires\n+       two registers).  */\n+    classes_ptr = restrict_cost_classes (classes_ptr,\n+\t\t\t\t\t PSEUDO_REGNO_MODE (regno),\n+\t\t\t\t\t reg_class_contents[ALL_REGS]);\n   regno_cost_classes[regno] = classes_ptr;\n }\n \n@@ -291,36 +405,11 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n static void\n setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n {\n-  static struct cost_classes classes;\n-  cost_classes_t classes_ptr;\n-  enum reg_class cl;\n-  int i;\n-  cost_classes **slot;\n-  HARD_REG_SET temp;\n-\n-  if ((classes_ptr = cost_classes_mode_cache[mode]) == NULL)\n-    {\n-      classes.num = 0;\n-      for (i = 0; i < ira_important_classes_num; i++)\n-\t{\n-\t  cl = ira_important_classes[i];\n-\t  COPY_HARD_REG_SET (temp, ira_prohibited_class_mode_regs[cl][mode]);\n-\t  IOR_HARD_REG_SET (temp, ira_no_alloc_regs);\n-\t  if (hard_reg_set_subset_p (reg_class_contents[cl], temp))\n-\t    continue;\n-\t  classes.classes[classes.num++] = cl;\n-\t}\n-      slot = cost_classes_htab->find_slot (&classes, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  classes_ptr = setup_cost_classes (&classes);\n-\t  *slot = classes_ptr;\n-\t}\n-      else\n-\tclasses_ptr = (cost_classes_t) *slot;\n-      cost_classes_mode_cache[mode] = (cost_classes_t) *slot;\n-    }\n-  regno_cost_classes[regno] = classes_ptr;\n+  if (cost_classes_mode_cache[mode] == NULL)\n+    cost_classes_mode_cache[mode]\n+      = restrict_cost_classes (&all_cost_classes, mode,\n+\t\t\t       reg_class_contents[ALL_REGS]);\n+  regno_cost_classes[regno] = cost_classes_mode_cache[mode];\n }\n \n /* Finalize info about the cost classes for each pseudo.  */\n@@ -1447,8 +1536,7 @@ print_allocno_costs (FILE *f)\n       for (k = 0; k < cost_classes_ptr->num; k++)\n \t{\n \t  rclass = cost_classes[k];\n-\t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n-\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass))\n+\t  if (! invalid_mode_change_p (regno, (enum reg_class) rclass))\n \t    {\n \t      fprintf (f, \" %s:%d\", reg_class_names[rclass],\n \t\t       COSTS (costs, i)->cost[k]);\n@@ -1486,8 +1574,7 @@ print_pseudo_costs (FILE *f)\n       for (k = 0; k < cost_classes_ptr->num; k++)\n \t{\n \t  rclass = cost_classes[k];\n-\t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n-\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass))\n+\t  if (! invalid_mode_change_p (regno, (enum reg_class) rclass))\n \t    fprintf (f, \" %s:%d\", reg_class_names[rclass],\n \t\t     COSTS (costs, regno)->cost[k]);\n \t}\n@@ -1728,8 +1815,7 @@ find_costs_and_classes (FILE *dump_file)\n \t      rclass = cost_classes[k];\n \t      /* Ignore classes that are too small or invalid for this\n \t\t operand.  */\n-\t      if (! contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (i)]\n-\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass))\n+\t      if (invalid_mode_change_p (i, (enum reg_class) rclass))\n \t\tcontinue;\n \t      if (i_costs[k] < best_cost)\n \t\t{\n@@ -1822,8 +1908,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t\tcontinue;\n \t\t      /* Ignore classes that are too small or invalid\n \t\t\t for this operand.  */\n-\t\t      if (! contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (i)]\n-\t\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass))\n+\t\t      if (invalid_mode_change_p (i, (enum reg_class) rclass))\n \t\t\t;\n \t\t      else if (total_a_costs[k] < best_cost)\n \t\t\t{"}]}