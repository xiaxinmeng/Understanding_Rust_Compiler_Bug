{"sha": "8aada4ade08634055b789ad4de86a2589ef7fdf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhZGE0YWRlMDg2MzQwNTViNzg5YWQ0ZGU4NmEyNTg5ZWY3ZmRmNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-13T11:47:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-13T11:47:32Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r735", "tree": {"sha": "95cbc9b15d536d868b2ae71dbb732d7fb94a09f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95cbc9b15d536d868b2ae71dbb732d7fb94a09f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aada4ade08634055b789ad4de86a2589ef7fdf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aada4ade08634055b789ad4de86a2589ef7fdf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aada4ade08634055b789ad4de86a2589ef7fdf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aada4ade08634055b789ad4de86a2589ef7fdf7/comments", "author": null, "committer": null, "parents": [{"sha": "2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2db2bea5cbb72b8a69759af8302bbe0876b0a56d"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "00945c838a83dae2d669cd93b82214cb10485c15", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aada4ade08634055b789ad4de86a2589ef7fdf7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aada4ade08634055b789ad4de86a2589ef7fdf7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8aada4ade08634055b789ad4de86a2589ef7fdf7", "patch": "@@ -560,6 +560,55 @@ gen_lowpart_common (mode, x)\n \t}\n     }\n \n+  /* If X is an integral constant but we want it in floating-point, it\n+     must be the case that we have a union of an integer and a floating-point\n+     value.  If the machine-parameters allow it, simulate that union here\n+     and return the result.  */\n+\n+  else if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t   && HOST_BITS_PER_INT == BITS_PER_WORD\n+\t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t   && GET_MODE (x) == VOIDmode\n+\t   && sizeof (double) * HOST_BITS_PER_CHAR == 2 * HOST_BITS_PER_INT)\n+    {\n+      union {int i[2]; double d; } u;\n+      int low, high;\n+\n+      if (GET_CODE (x) == CONST_INT)\n+\tlow = INTVAL (x), high = low >> (HOST_BITS_PER_INT -1);\n+      else\n+\tlow = CONST_DOUBLE_LOW (x), high = CONST_DOUBLE_HIGH (x);\n+\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+      u.i[0] = high, u.i[1] = low;\n+#else\n+      u.i[0] = low, u.i[1] = high;\n+#endif\n+\n+      return immed_real_const_1 (u.d, mode);\n+    }\n+\n+  /* Similarly, if this is converting a floating-point value into a\n+     two-word integer, we can do this one word at a time and make an\n+     integer.  Only do this is the host and target parameters are\n+     compatible.  */\n+\n+  else if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t   && HOST_BITS_PER_INT == BITS_PER_WORD\n+\t   && GET_MODE_CLASS (mode) == MODE_INT\n+\t   && GET_CODE (x) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n+\t   && GET_MODE_BITSIZE (mode) == 2 * BITS_PER_WORD)\n+    {\n+      rtx lowpart = operand_subword (x, WORDS_BIG_ENDIAN, 0, GET_MODE (x));\n+      rtx highpart = operand_subword (x, ! WORDS_BIG_ENDIAN, 0, GET_MODE (x));\n+\n+      if (lowpart && GET_CODE (lowpart) == CONST_INT\n+\t  && highpart && GET_CODE (highpart) == CONST_INT)\n+\treturn immed_double_const (INTVAL (lowpart), INTVAL (highpart), mode);\n+    }\n+\n   /* Otherwise, we can't do this.  */\n   return 0;\n }"}]}