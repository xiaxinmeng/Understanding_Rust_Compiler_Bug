{"sha": "fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3ZGU2NGNlZTA0ZmQwOGM5YTg0OWEyMGU5Y2YwZmQ4ZDY5MDZlMQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-06-18T15:58:48Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-06-18T15:58:48Z"}, "message": "double-int.h (double_int_to_shwi, [...]): Implement as static inline.\n\n\t* double-int.h (double_int_to_shwi, double_int_to_uhwi,\n\tdouble_int_fits_in_uhwi_p): Implement as static inline.\n\t(double_int_xor): New inline function.\n\t(double_int_lrotate, double_int_rrotate, double_int_max,\n\tdouble_int_umax, double_int_smax, double_int_min, double_int_umin,\n\tdouble_int_smin): Declare.\n\t(lrotate_double, rrotate_double): Remove declaration.\n\t* double-int.c (double_int_fits_in_uhwi_p, double_int_to_shwi,\n\tdouble_int_to_uhwi, lrotate_double, rrotate_double): Remove function.\n\t(double_int_lrotate, double_int_rrotate, double_int_max,\n\tdouble_int_umax, double_int_smax, double_int_min, double_int_umin,\n\tdouble_int_smin): New function.\n\t* fold-const.c (int_const_binop): Clean up, use double_int_*\n\tfunctions.\n\t* simplify-rtx.c (simplify_const_binary_operation): Clean up, use\n\tdouble_int_* and immed_double_int_const functions.\n\nFrom-SVN: r161002", "tree": {"sha": "43dbfc5a3de6b7b8c559675266ac518bbcabd39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43dbfc5a3de6b7b8c559675266ac518bbcabd39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/comments", "author": null, "committer": null, "parents": [{"sha": "bc87224e9341b186905d8ac849aeb59463ae4f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc87224e9341b186905d8ac849aeb59463ae4f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc87224e9341b186905d8ac849aeb59463ae4f6b"}], "stats": {"total": 481, "additions": 264, "deletions": 217}, "files": [{"sha": "14bdc453e9812cd3c7b2dfa4652f116af9caa903", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "patch": "@@ -1,3 +1,22 @@\n+2010-06-18  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* double-int.h (double_int_to_shwi, double_int_to_uhwi,\n+\tdouble_int_fits_in_uhwi_p): Implement as static inline.\n+\t(double_int_xor): New inline function.\n+\t(double_int_lrotate, double_int_rrotate, double_int_max,\n+\tdouble_int_umax, double_int_smax, double_int_min, double_int_umin,\n+\tdouble_int_smin): Declare.\n+\t(lrotate_double, rrotate_double): Remove declaration.\n+\t* double-int.c (double_int_fits_in_uhwi_p, double_int_to_shwi,\n+\tdouble_int_to_uhwi, lrotate_double, rrotate_double): Remove function.\n+\t(double_int_lrotate, double_int_rrotate, double_int_max,\n+\tdouble_int_umax, double_int_smax, double_int_min, double_int_umin,\n+\tdouble_int_smin): New function.\n+\t* fold-const.c (int_const_binop): Clean up, use double_int_*\n+\tfunctions.\n+\t* simplify-rtx.c (simplify_const_binary_operation): Clean up, use\n+\tdouble_int_* and immed_double_int_const functions.\n+\n 2010-06-18  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* function.h (types_used_by_cur_var_decl): Change type to a VEC."}, {"sha": "7bdda7da212ad0eff4eb82502fcb6d49d6afc792", "filename": "gcc/double-int.c", "status": "modified", "additions": 81, "deletions": 71, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "patch": "@@ -432,51 +432,6 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n     }\n }\n \n-/* Rotate the doubleword integer in L1, H1 left by COUNT places\n-   keeping only PREC bits of result.\n-   Rotate right if COUNT is negative.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\tHOST_WIDE_INT count, unsigned int prec,\n-\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n-{\n-  unsigned HOST_WIDE_INT s1l, s2l;\n-  HOST_WIDE_INT s1h, s2h;\n-\n-  count %= prec;\n-  if (count < 0)\n-    count += prec;\n-\n-  lshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n-  rshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n-  *lv = s1l | s2l;\n-  *hv = s1h | s2h;\n-}\n-\n-/* Rotate the doubleword integer in L1, H1 left by COUNT places\n-   keeping only PREC bits of result.  COUNT must be positive.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\tHOST_WIDE_INT count, unsigned int prec,\n-\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n-{\n-  unsigned HOST_WIDE_INT s1l, s2l;\n-  HOST_WIDE_INT s1h, s2h;\n-\n-  count %= prec;\n-  if (count < 0)\n-    count += prec;\n-\n-  rshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n-  lshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n-  *lv = s1l | s2l;\n-  *hv = s1h | s2h;\n-}\n-\n /* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN\n    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).\n    CODE is a tree code for a kind of division, one of\n@@ -842,14 +797,6 @@ double_int_sext (double_int cst, unsigned prec)\n   return r;\n }\n \n-/* Returns true if CST fits in unsigned HOST_WIDE_INT.  */\n-\n-bool\n-double_int_fits_in_uhwi_p (double_int cst)\n-{\n-  return cst.high == 0;\n-}\n-\n /* Returns true if CST fits in signed HOST_WIDE_INT.  */\n \n bool\n@@ -875,24 +822,6 @@ double_int_fits_in_hwi_p (double_int cst, bool uns)\n     return double_int_fits_in_shwi_p (cst);\n }\n \n-/* Returns value of CST as a signed number.  CST must satisfy\n-   double_int_fits_in_shwi_p.  */\n-\n-HOST_WIDE_INT\n-double_int_to_shwi (double_int cst)\n-{\n-  return (HOST_WIDE_INT) cst.low;\n-}\n-\n-/* Returns value of CST as an unsigned number.  CST must satisfy\n-   double_int_fits_in_uhwi_p.  */\n-\n-unsigned HOST_WIDE_INT\n-double_int_to_uhwi (double_int cst)\n-{\n-  return cst.low;\n-}\n-\n /* Returns A * B.  */\n \n double_int\n@@ -1049,6 +978,42 @@ double_int_rshift (double_int a, HOST_WIDE_INT count, unsigned int prec, bool ar\n   return ret;\n }\n \n+/* Rotate  A left by COUNT places keeping only PREC bits of result.\n+   Rotate right if COUNT is negative.  */\n+\n+double_int\n+double_int_lrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+{\n+  double_int t1, t2;\n+\n+  count %= prec;\n+  if (count < 0)\n+    count += prec;\n+\n+  t1 = double_int_lshift (a, count, prec, false);\n+  t2 = double_int_rshift (a, prec - count, prec, false);\n+\n+  return double_int_ior (t1, t2);\n+}\n+\n+/* Rotate A rigth by COUNT places keeping only PREC bits of result.\n+   Rotate right if COUNT is negative.  */\n+\n+double_int\n+double_int_rrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+{\n+  double_int t1, t2;\n+\n+  count %= prec;\n+  if (count < 0)\n+    count += prec;\n+\n+  t1 = double_int_rshift (a, count, prec, false);\n+  t2 = double_int_lshift (a, prec - count, prec, false);\n+\n+  return double_int_ior (t1, t2);\n+}\n+\n /* Returns -1 if A < B, 0 if A == B and 1 if A > B.  Signedness of the\n    comparison is given by UNS.  */\n \n@@ -1097,6 +1062,51 @@ double_int_scmp (double_int a, double_int b)\n   return 0;\n }\n \n+/* Compares two values A and B.  Returns max value.  Signedness of the\n+   comparison is given by UNS.  */\n+\n+double_int\n+double_int_max (double_int a, double_int b, bool uns)\n+{\n+  return (double_int_cmp (a, b, uns) == 1) ? a : b;\n+}\n+\n+/* Compares two signed values A and B.  Returns max value.  */\n+\n+double_int double_int_smax (double_int a, double_int b)\n+{\n+  return (double_int_scmp (a, b) == 1) ? a : b;\n+}\n+\n+/* Compares two unsigned values A and B.  Returns max value.  */\n+\n+double_int double_int_umax (double_int a, double_int b)\n+{\n+  return (double_int_ucmp (a, b) == 1) ? a : b;\n+}\n+\n+/* Compares two values A and B.  Returns mix value.  Signedness of the\n+   comparison is given by UNS.  */\n+\n+double_int double_int_min (double_int a, double_int b, bool uns)\n+{\n+  return (double_int_cmp (a, b, uns) == -1) ? a : b;\n+}\n+\n+/* Compares two signed values A and B.  Returns min value.  */\n+\n+double_int double_int_smin (double_int a, double_int b)\n+{\n+  return (double_int_scmp (a, b) == -1) ? a : b;\n+}\n+\n+/* Compares two unsigned values A and B.  Returns min value.  */\n+\n+double_int double_int_umin (double_int a, double_int b)\n+{\n+  return (double_int_ucmp (a, b) == -1) ? a : b;\n+}\n+\n /* Splits last digit of *CST (taken as unsigned) in BASE and returns it.  */\n \n static unsigned"}, {"sha": "250951d57f946d906a4710cb86010d5058cdc156", "filename": "gcc/double-int.h", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "patch": "@@ -97,6 +97,35 @@ uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n   return r;\n }\n \n+/* Returns value of CST as a signed number.  CST must satisfy\n+   double_int_fits_in_shwi_p.  */\n+\n+static inline HOST_WIDE_INT\n+double_int_to_shwi (double_int cst)\n+{\n+  return (HOST_WIDE_INT) cst.low;\n+}\n+\n+/* Returns value of CST as an unsigned number.  CST must satisfy\n+   double_int_fits_in_uhwi_p.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+double_int_to_uhwi (double_int cst)\n+{\n+  return cst.low;\n+}\n+\n+bool double_int_fits_in_hwi_p (double_int, bool);\n+bool double_int_fits_in_shwi_p (double_int);\n+\n+/* Returns true if CST fits in unsigned HOST_WIDE_INT.  */\n+\n+static inline bool\n+double_int_fits_in_uhwi_p (double_int cst)\n+{\n+  return cst.high == 0;\n+}\n+\n /* The following operations perform arithmetics modulo 2^precision,\n    so you do not need to call double_int_ext between them, even if\n    you are representing numbers with precision less than\n@@ -109,11 +138,6 @@ double_int double_int_neg (double_int);\n /* You must ensure that double_int_ext is called on the operands\n    of the following operations, if the precision of the numbers\n    is less than 2 * HOST_BITS_PER_WIDE_INT bits.  */\n-bool double_int_fits_in_hwi_p (double_int, bool);\n-bool double_int_fits_in_shwi_p (double_int);\n-bool double_int_fits_in_uhwi_p (double_int);\n-HOST_WIDE_INT double_int_to_shwi (double_int);\n-unsigned HOST_WIDE_INT double_int_to_uhwi (double_int);\n double_int double_int_div (double_int, double_int, bool, unsigned);\n double_int double_int_sdiv (double_int, double_int, unsigned);\n double_int double_int_udiv (double_int, double_int, unsigned);\n@@ -157,9 +181,22 @@ double_int_and (double_int a, double_int b)\n   return a;\n }\n \n+/* Returns A ^ B.  */\n+\n+static inline double_int\n+double_int_xor (double_int a, double_int b)\n+{\n+  a.low ^= b.low;\n+  a.high ^= b.high;\n+  return a;\n+}\n+\n+\n /* Shift operations.  */\n double_int double_int_lshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n double_int double_int_rshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n+double_int double_int_lrotate (double_int, HOST_WIDE_INT, unsigned int);\n+double_int double_int_rrotate (double_int, HOST_WIDE_INT, unsigned int);\n \n /* Returns true if CST is negative.  Of course, CST is considered to\n    be signed.  */\n@@ -173,6 +210,15 @@ double_int_negative_p (double_int cst)\n int double_int_cmp (double_int, double_int, bool);\n int double_int_scmp (double_int, double_int);\n int double_int_ucmp (double_int, double_int);\n+\n+double_int double_int_max (double_int, double_int, bool);\n+double_int double_int_smax (double_int, double_int);\n+double_int double_int_umax (double_int, double_int);\n+\n+double_int double_int_min (double_int, double_int, bool);\n+double_int double_int_smin (double_int, double_int);\n+double_int double_int_umin (double_int, double_int);\n+\n void dump_double_int (FILE *, double_int, bool);\n \n /* Zero and sign extension of numbers in smaller precisions.  */\n@@ -248,12 +294,6 @@ extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n extern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t   HOST_WIDE_INT, unsigned int,\n \t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n-extern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    HOST_WIDE_INT, unsigned int,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-extern void rrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    HOST_WIDE_INT, unsigned int,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n extern int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,"}, {"sha": "a1cd552014cdf555936af96ff60f4badeb0820c3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "patch": "@@ -924,145 +924,140 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n tree\n int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notrunc)\n {\n-  unsigned HOST_WIDE_INT int1l, int2l;\n-  HOST_WIDE_INT int1h, int2h;\n-  unsigned HOST_WIDE_INT low;\n-  HOST_WIDE_INT hi;\n-  unsigned HOST_WIDE_INT garbagel;\n-  HOST_WIDE_INT garbageh;\n+  double_int op1, op2, res, tmp;\n   tree t;\n   tree type = TREE_TYPE (arg1);\n-  int uns = TYPE_UNSIGNED (type);\n-  int is_sizetype\n+  bool uns = TYPE_UNSIGNED (type);\n+  bool is_sizetype\n     = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type));\n-  int overflow = 0;\n+  bool overflow = false;\n \n-  int1l = TREE_INT_CST_LOW (arg1);\n-  int1h = TREE_INT_CST_HIGH (arg1);\n-  int2l = TREE_INT_CST_LOW (arg2);\n-  int2h = TREE_INT_CST_HIGH (arg2);\n+  op1 = tree_to_double_int (arg1);\n+  op2 = tree_to_double_int (arg2);\n \n   switch (code)\n     {\n     case BIT_IOR_EXPR:\n-      low = int1l | int2l, hi = int1h | int2h;\n+      res = double_int_ior (op1, op2);\n       break;\n \n     case BIT_XOR_EXPR:\n-      low = int1l ^ int2l, hi = int1h ^ int2h;\n+      res = double_int_xor (op1, op2);\n       break;\n \n     case BIT_AND_EXPR:\n-      low = int1l & int2l, hi = int1h & int2h;\n+      res = double_int_and (op1, op2);\n       break;\n \n     case RSHIFT_EXPR:\n-      int2l = -int2l;\n+      res = double_int_rshift (op1, double_int_to_shwi (op2),\n+\t\t\t       TYPE_PRECISION (type), !uns);\n+      break;\n+\n     case LSHIFT_EXPR:\n       /* It's unclear from the C standard whether shifts can overflow.\n \t The following code ignores overflow; perhaps a C standard\n \t interpretation ruling is needed.  */\n-      lshift_double (int1l, int1h, int2l, TYPE_PRECISION (type),\n-\t\t     &low, &hi, !uns);\n+      res = double_int_lshift (op1, double_int_to_shwi (op2),\n+\t\t\t       TYPE_PRECISION (type), !uns);\n       break;\n \n     case RROTATE_EXPR:\n-      int2l = - int2l;\n+      res = double_int_rrotate (op1, double_int_to_shwi (op2),\n+\t\t\t\tTYPE_PRECISION (type));\n+      break;\n+\n     case LROTATE_EXPR:\n-      lrotate_double (int1l, int1h, int2l, TYPE_PRECISION (type),\n-\t\t      &low, &hi);\n+      res = double_int_lrotate (op1, double_int_to_shwi (op2),\n+\t\t\t\tTYPE_PRECISION (type));\n       break;\n \n     case PLUS_EXPR:\n-      overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n+      overflow = add_double (op1.low, op1.high, op2.low, op2.high,\n+\t\t\t     &res.low, &res.high);\n       break;\n \n     case MINUS_EXPR:\n-      neg_double (int2l, int2h, &low, &hi);\n-      add_double (int1l, int1h, low, hi, &low, &hi);\n-      overflow = OVERFLOW_SUM_SIGN (hi, int2h, int1h);\n+      neg_double (op2.low, op2.high, &res.low, &res.high);\n+      add_double (op1.low, op1.high, res.low, res.high,\n+\t\t  &res.low, &res.high);\n+      overflow = OVERFLOW_SUM_SIGN (res.high, op2.high, op1.high);\n       break;\n \n     case MULT_EXPR:\n-      overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n+      overflow = mul_double (op1.low, op1.high, op2.low, op2.high,\n+\t\t\t     &res.low, &res.high);\n       break;\n \n     case TRUNC_DIV_EXPR:\n     case FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n+      if (op2.high == 0 && (HOST_WIDE_INT) op2.low > 0\n \t  && !TREE_OVERFLOW (arg1)\n \t  && !TREE_OVERFLOW (arg2)\n-\t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n+\t  && op1.high == 0 && (HOST_WIDE_INT) op1.low >= 0)\n \t{\n \t  if (code == CEIL_DIV_EXPR)\n-\t    int1l += int2l - 1;\n+\t    op1.low += op2.low - 1;\n \n-\t  low = int1l / int2l, hi = 0;\n+\t  res.low = op1.low / op2.low, res.high = 0;\n \t  break;\n \t}\n \n       /* ... fall through ...  */\n \n     case ROUND_DIV_EXPR:\n-      if (int2h == 0 && int2l == 0)\n+      if (double_int_zero_p (op2))\n \treturn NULL_TREE;\n-      if (int2h == 0 && int2l == 1)\n+      if (double_int_one_p (op2))\n \t{\n-\t  low = int1l, hi = int1h;\n+\t  res = op1;\n \t  break;\n \t}\n-      if (int1l == int2l && int1h == int2h\n-\t  && ! (int1l == 0 && int1h == 0))\n+      if (double_int_equal_p (op1, op2)\n+\t  && ! double_int_zero_p (op1))\n \t{\n-\t  low = 1, hi = 0;\n+\t  res = double_int_one;\n \t  break;\n \t}\n-      overflow = div_and_round_double (code, uns, int1l, int1h, int2l, int2h,\n-\t\t\t\t       &low, &hi, &garbagel, &garbageh);\n+      overflow = div_and_round_double (code, uns,\n+\t\t\t\t       op1.low, op1.high, op2.low, op2.high,\n+\t\t\t\t       &res.low, &res.high,\n+\t\t\t\t       &tmp.low, &tmp.high);\n       break;\n \n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n       /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n+      if (op2.high == 0 && (HOST_WIDE_INT) op2.low > 0\n \t  && !TREE_OVERFLOW (arg1)\n \t  && !TREE_OVERFLOW (arg2)\n-\t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n+\t  && op1.high == 0 && (HOST_WIDE_INT) op1.low >= 0)\n \t{\n \t  if (code == CEIL_MOD_EXPR)\n-\t    int1l += int2l - 1;\n-\t  low = int1l % int2l, hi = 0;\n+\t    op1.low += op2.low - 1;\n+\t  res.low = op1.low % op2.low, res.high = 0;\n \t  break;\n \t}\n \n       /* ... fall through ...  */\n \n     case ROUND_MOD_EXPR:\n-      if (int2h == 0 && int2l == 0)\n+      if (double_int_zero_p (op2))\n \treturn NULL_TREE;\n       overflow = div_and_round_double (code, uns,\n-\t\t\t\t       int1l, int1h, int2l, int2h,\n-\t\t\t\t       &garbagel, &garbageh, &low, &hi);\n+\t\t\t\t       op1.low, op1.high, op2.low, op2.high,\n+\t\t\t\t       &tmp.low, &tmp.high,\n+\t\t\t\t       &res.low, &res.high);\n       break;\n \n     case MIN_EXPR:\n-    case MAX_EXPR:\n-      if (uns)\n-\tlow = (((unsigned HOST_WIDE_INT) int1h\n-\t\t< (unsigned HOST_WIDE_INT) int2h)\n-\t       || (((unsigned HOST_WIDE_INT) int1h\n-\t\t    == (unsigned HOST_WIDE_INT) int2h)\n-\t\t   && int1l < int2l));\n-      else\n-\tlow = (int1h < int2h\n-\t       || (int1h == int2h && int1l < int2l));\n+      res = double_int_min (op1, op2, uns);\n+      break;\n \n-      if (low == (code == MIN_EXPR))\n-\tlow = int1l, hi = int1h;\n-      else\n-\tlow = int2l, hi = int2h;\n+    case MAX_EXPR:\n+      res = double_int_max (op1, op2, uns);\n       break;\n \n     default:\n@@ -1071,7 +1066,7 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notr\n \n   if (notrunc)\n     {\n-      t = build_int_cst_wide (TREE_TYPE (arg1), low, hi);\n+      t = build_int_cst_wide (TREE_TYPE (arg1), res.low, res.high);\n \n       /* Propagate overflow flags ourselves.  */\n       if (((!uns || is_sizetype) && overflow)\n@@ -1082,7 +1077,7 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notr\n \t}\n     }\n   else\n-    t = force_fit_type_double (TREE_TYPE (arg1), low, hi, 1,\n+    t = force_fit_type_double (TREE_TYPE (arg1), res.low, res.high, 1,\n \t\t\t       ((!uns || is_sizetype) && overflow)\n \t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n "}, {"sha": "be63198e442c91dbd21d6e941f62d32b12e7af21", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 56, "deletions": 73, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=fd7de64cee04fd08c9a849a20e9cf0fd8d6906e1", "patch": "@@ -3268,141 +3268,124 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n   /* We can fold some multi-word operations.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n-      && width == HOST_BITS_PER_WIDE_INT * 2\n-      && (GET_CODE (op0) == CONST_DOUBLE || CONST_INT_P (op0))\n-      && (GET_CODE (op1) == CONST_DOUBLE || CONST_INT_P (op1)))\n+      && width == HOST_BITS_PER_DOUBLE_INT\n+      && (CONST_DOUBLE_P (op0) || CONST_INT_P (op0))\n+      && (CONST_DOUBLE_P (op1) || CONST_INT_P (op1)))\n     {\n-      unsigned HOST_WIDE_INT l1, l2, lv, lt;\n-      HOST_WIDE_INT h1, h2, hv, ht;\n+      double_int o0, o1, res, tmp;\n \n-      if (GET_CODE (op0) == CONST_DOUBLE)\n-\tl1 = CONST_DOUBLE_LOW (op0), h1 = CONST_DOUBLE_HIGH (op0);\n-      else\n-\tl1 = INTVAL (op0), h1 = HWI_SIGN_EXTEND (l1);\n-\n-      if (GET_CODE (op1) == CONST_DOUBLE)\n-\tl2 = CONST_DOUBLE_LOW (op1), h2 = CONST_DOUBLE_HIGH (op1);\n-      else\n-\tl2 = INTVAL (op1), h2 = HWI_SIGN_EXTEND (l2);\n+      o0 = rtx_to_double_int (op0);\n+      o1 = rtx_to_double_int (op1);\n \n       switch (code)\n \t{\n \tcase MINUS:\n \t  /* A - B == A + (-B).  */\n-\t  neg_double (l2, h2, &lv, &hv);\n-\t  l2 = lv, h2 = hv;\n+\t  o1 = double_int_neg (o1);\n \n \t  /* Fall through....  */\n \n \tcase PLUS:\n-\t  add_double (l1, h1, l2, h2, &lv, &hv);\n+\t  res = double_int_add (o0, o1);\n \t  break;\n \n \tcase MULT:\n-\t  mul_double (l1, h1, l2, h2, &lv, &hv);\n+\t  res = double_int_mul (o0, o1);\n \t  break;\n \n \tcase DIV:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0, l1, h1, l2, h2,\n-\t\t\t\t    &lv, &hv, &lt, &ht))\n+\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0,\n+\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n+\t\t\t\t    &res.low, &res.high,\n+\t\t\t\t    &tmp.low, &tmp.high))\n \t    return 0;\n \t  break;\n \n \tcase MOD:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0, l1, h1, l2, h2,\n-\t\t\t\t    &lt, &ht, &lv, &hv))\n+\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0,\n+\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n+\t\t\t\t    &tmp.low, &tmp.high,\n+\t\t\t\t    &res.low, &res.high))\n \t    return 0;\n \t  break;\n \n \tcase UDIV:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1, l1, h1, l2, h2,\n-\t\t\t\t    &lv, &hv, &lt, &ht))\n+\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1,\n+\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n+\t\t\t\t    &res.low, &res.high,\n+\t\t\t\t    &tmp.low, &tmp.high))\n \t    return 0;\n \t  break;\n \n \tcase UMOD:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1, l1, h1, l2, h2,\n-\t\t\t\t    &lt, &ht, &lv, &hv))\n+\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1,\n+\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n+\t\t\t\t    &tmp.low, &tmp.high,\n+\t\t\t\t    &res.low, &res.high))\n \t    return 0;\n \t  break;\n \n \tcase AND:\n-\t  lv = l1 & l2, hv = h1 & h2;\n+\t  res = double_int_and (o0, o1);\n \t  break;\n \n \tcase IOR:\n-\t  lv = l1 | l2, hv = h1 | h2;\n+\t  res = double_int_ior (o0, o1);\n \t  break;\n \n \tcase XOR:\n-\t  lv = l1 ^ l2, hv = h1 ^ h2;\n+\t  res = double_int_xor (o0, o1);\n \t  break;\n \n \tcase SMIN:\n-\t  if (h1 < h2\n-\t      || (h1 == h2\n-\t\t  && ((unsigned HOST_WIDE_INT) l1\n-\t\t      < (unsigned HOST_WIDE_INT) l2)))\n-\t    lv = l1, hv = h1;\n-\t  else\n-\t    lv = l2, hv = h2;\n+\t  res = double_int_smin (o0, o1);\n \t  break;\n \n \tcase SMAX:\n-\t  if (h1 > h2\n-\t      || (h1 == h2\n-\t\t  && ((unsigned HOST_WIDE_INT) l1\n-\t\t      > (unsigned HOST_WIDE_INT) l2)))\n-\t    lv = l1, hv = h1;\n-\t  else\n-\t    lv = l2, hv = h2;\n+\t  res = double_int_smax (o0, o1);\n \t  break;\n \n \tcase UMIN:\n-\t  if ((unsigned HOST_WIDE_INT) h1 < (unsigned HOST_WIDE_INT) h2\n-\t      || (h1 == h2\n-\t\t  && ((unsigned HOST_WIDE_INT) l1\n-\t\t      < (unsigned HOST_WIDE_INT) l2)))\n-\t    lv = l1, hv = h1;\n-\t  else\n-\t    lv = l2, hv = h2;\n+\t  res = double_int_umin (o0, o1);\n \t  break;\n \n \tcase UMAX:\n-\t  if ((unsigned HOST_WIDE_INT) h1 > (unsigned HOST_WIDE_INT) h2\n-\t      || (h1 == h2\n-\t\t  && ((unsigned HOST_WIDE_INT) l1\n-\t\t      > (unsigned HOST_WIDE_INT) l2)))\n-\t    lv = l1, hv = h1;\n-\t  else\n-\t    lv = l2, hv = h2;\n+\t  res = double_int_umax (o0, o1);\n \t  break;\n \n \tcase LSHIFTRT:   case ASHIFTRT:\n \tcase ASHIFT:\n \tcase ROTATE:     case ROTATERT:\n-\t  if (SHIFT_COUNT_TRUNCATED)\n-\t    l2 &= (GET_MODE_BITSIZE (mode) - 1), h2 = 0;\n-\n-\t  if (h2 != 0 || l2 >= GET_MODE_BITSIZE (mode))\n-\t    return 0;\n-\n-\t  if (code == LSHIFTRT || code == ASHIFTRT)\n-\t    rshift_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv,\n-\t\t\t   code == ASHIFTRT);\n-\t  else if (code == ASHIFT)\n-\t    lshift_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv, 1);\n-\t  else if (code == ROTATE)\n-\t    lrotate_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv);\n-\t  else /* code == ROTATERT */\n-\t    rrotate_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv);\n+\t  {\n+\t    unsigned HOST_WIDE_INT cnt;\n+\n+\t    if (SHIFT_COUNT_TRUNCATED)\n+\t      o1 = double_int_zext (o1, GET_MODE_BITSIZE (mode));\n+\n+\t    if (!double_int_fits_in_uhwi_p (o1)\n+\t        || double_int_to_uhwi (o1) >= GET_MODE_BITSIZE (mode))\n+\t      return 0;\n+\n+\t    cnt = double_int_to_uhwi (o1);\n+\n+\t    if (code == LSHIFTRT || code == ASHIFTRT)\n+\t      res = double_int_rshift (o0, cnt, GET_MODE_BITSIZE (mode),\n+\t\t\t\t       code == ASHIFTRT);\n+\t    else if (code == ASHIFT)\n+\t      res = double_int_lshift (o0, cnt, GET_MODE_BITSIZE (mode),\n+\t\t\t\t       true);\n+\t    else if (code == ROTATE)\n+\t      res = double_int_lrotate (o0, cnt, GET_MODE_BITSIZE (mode));\n+\t    else /* code == ROTATERT */\n+\t      res = double_int_rrotate (o0, cnt, GET_MODE_BITSIZE (mode));\n+\t  }\n \t  break;\n \n \tdefault:\n \t  return 0;\n \t}\n \n-      return immed_double_const (lv, hv, mode);\n+      return immed_double_int_const (res, mode);\n     }\n \n   if (CONST_INT_P (op0) && CONST_INT_P (op1)"}]}