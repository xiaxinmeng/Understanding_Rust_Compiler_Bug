{"sha": "1a6306420090409cb397e2e042256eb1905f415f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2MzA2NDIwMDkwNDA5Y2IzOTdlMmUwNDIyNTZlYjE5MDVmNDE1Zg==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-10-15T17:13:59Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-01-15T12:39:19Z"}, "message": "arm: Implement vceqq_p64, vceqz_p64 and vceqzq_p64 intrinsics\n\nThis patch adds implementations for vceqq_p64, vceqz_p64 and\nvceqzq_p64 intrinsics.\n\nvceqq_p64 uses the existing vceq_p64 after splitting the input vectors\ninto their high and low halves.\n\nvceqz[q] simply call the vceq and vceqq with a second argument equal\nto zero.\n\nThe added (executable) testcases make sure that the poly64x2_t\nvariants have results with one element of all zeroes (false) and the\nother element with all bits set to one (true).\n\n2021-01-15  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\tPR target/71233\n\t* config/arm/arm_neon.h (vceqz_p64, vceqq_p64, vceqzq_p64): New.\n\n\tgcc/testsuite/\n\tPR target/71233\n\t* gcc.target/aarch64/advsimd-intrinsics/p64_p128.c: Add tests for\n\tvceqz_p64, vceqq_p64 and vceqzq_p64.", "tree": {"sha": "045d890fa28e03497b04e23d61d9fb1a130ba783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/045d890fa28e03497b04e23d61d9fb1a130ba783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a6306420090409cb397e2e042256eb1905f415f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6306420090409cb397e2e042256eb1905f415f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6306420090409cb397e2e042256eb1905f415f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6306420090409cb397e2e042256eb1905f415f/comments", "author": null, "committer": null, "parents": [{"sha": "cb60334b7162ec5ae560be482cd7a33402470bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb60334b7162ec5ae560be482cd7a33402470bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb60334b7162ec5ae560be482cd7a33402470bb4"}], "stats": {"total": 77, "additions": 76, "deletions": 1}, "files": [{"sha": "dc28b92b5afeaa545571d65cd6d7dc56d4dcf7bc", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6306420090409cb397e2e042256eb1905f415f/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6306420090409cb397e2e042256eb1905f415f/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=1a6306420090409cb397e2e042256eb1905f415f", "patch": "@@ -16912,6 +16912,37 @@ vceq_p64 (poly64x1_t __a, poly64x1_t __b)\n   return vreinterpret_u64_u32 (__m);\n }\n \n+__extension__ extern __inline uint64x1_t\n+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))\n+vceqz_p64 (poly64x1_t __a)\n+{\n+  poly64x1_t __b = vreinterpret_p64_u32 (vdup_n_u32 (0));\n+  return vceq_p64 (__a, __b);\n+}\n+\n+/* For vceqq_p64, we rely on vceq_p64 for each of the two elements.  */\n+__extension__ extern __inline uint64x2_t\n+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))\n+vceqq_p64 (poly64x2_t __a, poly64x2_t __b)\n+{\n+  poly64_t __high_a = vget_high_p64 (__a);\n+  poly64_t __high_b = vget_high_p64 (__b);\n+  uint64x1_t __high = vceq_p64 (__high_a, __high_b);\n+\n+  poly64_t __low_a = vget_low_p64 (__a);\n+  poly64_t __low_b = vget_low_p64 (__b);\n+  uint64x1_t __low = vceq_p64 (__low_a, __low_b);\n+  return vcombine_u64 (__low, __high);\n+}\n+\n+__extension__ extern __inline uint64x2_t\n+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))\n+vceqzq_p64 (poly64x2_t __a)\n+{\n+  poly64x2_t __b = vreinterpretq_p64_u32 (vdupq_n_u32 (0));\n+  return vceqq_p64 (__a, __b);\n+}\n+\n /* The vtst_p64 intrinsic does not map to a single instruction.\n    We emulate it in way similar to vceq_p64 above but here we do\n    a reduction with max since if any two corresponding bits"}, {"sha": "6aed096fc6f3985d5ab15ed6378d75a7e8a89d7a", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/p64_p128.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6306420090409cb397e2e042256eb1905f415f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fp64_p128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6306420090409cb397e2e042256eb1905f415f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fp64_p128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fp64_p128.c?ref=1a6306420090409cb397e2e042256eb1905f415f", "patch": "@@ -16,6 +16,11 @@ VECT_VAR_DECL(vbsl_expected,poly,64,2) [] = { 0xfffffff1,\n \n /* Expected results: vceq.  */\n VECT_VAR_DECL(vceq_expected,uint,64,1) [] = { 0x0 };\n+VECT_VAR_DECL(vceq_expected,uint,64,2) [] = { 0x0, 0xffffffffffffffff };\n+\n+/* Expected results: vceqz.  */\n+VECT_VAR_DECL(vceqz_expected,uint,64,1) [] = { 0x0 };\n+VECT_VAR_DECL(vceqz_expected,uint,64,2) [] = { 0x0, 0xffffffffffffffff };\n \n /* Expected results: vcombine.  */\n VECT_VAR_DECL(vcombine_expected,poly,64,2) [] = { 0xfffffffffffffff0, 0x88 };\n@@ -213,7 +218,7 @@ int main (void)\n \n   /* vceq_p64 tests. */\n #undef TEST_MSG\n-#define TEST_MSG \"VCEQ\"\n+#define TEST_MSG \"VCEQ/VCEQQ\"\n \n #define TEST_VCOMP1(INSN, Q, T1, T2, T3, W, N)\t\t\t\t\\\n   VECT_VAR(vceq_vector_res, T3, W, N) =\t\t\t\t\t\\\n@@ -227,16 +232,55 @@ int main (void)\n   DECL_VARIABLE(vceq_vector, poly, 64, 1);\n   DECL_VARIABLE(vceq_vector2, poly, 64, 1);\n   DECL_VARIABLE(vceq_vector_res, uint, 64, 1);\n+  DECL_VARIABLE(vceq_vector, poly, 64, 2);\n+  DECL_VARIABLE(vceq_vector2, poly, 64, 2);\n+  DECL_VARIABLE(vceq_vector_res, uint, 64, 2);\n \n   CLEAN(result, uint, 64, 1);\n+  CLEAN(result, uint, 64, 2);\n \n   VLOAD(vceq_vector, buffer, , poly, p, 64, 1);\n+  VLOAD(vceq_vector, buffer, q, poly, p, 64, 2);\n \n   VDUP(vceq_vector2, , poly, p, 64, 1, 0x88);\n+  VSET_LANE(vceq_vector2, q, poly, p, 64, 2, 0, 0x88);\n+  VSET_LANE(vceq_vector2, q, poly, p, 64, 2, 1, 0xFFFFFFFFFFFFFFF1);\n \n   TEST_VCOMP(vceq, , poly, p, uint, 64, 1);\n+  TEST_VCOMP(vceq, q, poly, p, uint, 64, 2);\n \n   CHECK(TEST_MSG, uint, 64, 1, PRIx64, vceq_expected, \"\");\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, vceq_expected, \"\");\n+\n+  /* vceqz_p64 tests. */\n+#undef TEST_MSG\n+#define TEST_MSG \"VCEQZ/VCEQZQ\"\n+\n+#define TEST_VCOMPZ1(INSN, Q, T1, T2, T3, W, N)\t\t\t\t\\\n+  VECT_VAR(vceqz_vector_res, T3, W, N) =\t\t\t\t\\\n+    INSN##Q##_##T2##W(VECT_VAR(vceqz_vector, T1, W, N));\t\t\\\n+  vst1##Q##_u##W(VECT_VAR(result, T3, W, N), VECT_VAR(vceqz_vector_res, T3, W, N))\n+\n+#define TEST_VCOMPZ(INSN, Q, T1, T2, T3, W, N)\t\t\t\t\\\n+  TEST_VCOMPZ1(INSN, Q, T1, T2, T3, W, N)\n+\n+  DECL_VARIABLE(vceqz_vector, poly, 64, 1);\n+  DECL_VARIABLE(vceqz_vector_res, uint, 64, 1);\n+  DECL_VARIABLE(vceqz_vector, poly, 64, 2);\n+  DECL_VARIABLE(vceqz_vector_res, uint, 64, 2);\n+\n+  CLEAN(result, uint, 64, 1);\n+  CLEAN(result, uint, 64, 2);\n+\n+  VLOAD(vceqz_vector, buffer, , poly, p, 64, 1);\n+  VLOAD(vceqz_vector, buffer, q, poly, p, 64, 2);\n+  VSET_LANE(vceqz_vector, q, poly, p, 64, 2, 1, 0);\n+\n+  TEST_VCOMPZ(vceqz, , poly, p, uint, 64, 1);\n+  TEST_VCOMPZ(vceqz, q, poly, p, uint, 64, 2);\n+\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, vceqz_expected, \"\");\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, vceqz_expected, \"\");\n \n   /* vcombine_p64 tests.  */\n #undef TEST_MSG"}]}