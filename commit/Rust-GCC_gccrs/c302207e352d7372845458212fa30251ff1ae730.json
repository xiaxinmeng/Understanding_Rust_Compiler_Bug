{"sha": "c302207e352d7372845458212fa30251ff1ae730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMwMjIwN2UzNTJkNzM3Mjg0NTQ1ODIxMmZhMzAyNTFmZjFhZTczMA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-13T21:02:19Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-13T21:02:19Z"}, "message": "tree-ssa-pre.c (do_regular_insertion): Add FIXME markers at points of potentially huge memset overhead.\n\n\t* tree-ssa-pre.c (do_regular_insertion): Add FIXME markers at points\n\tof potentially huge memset overhead.\n\t(do_partial_partial_insertion): Likewise.\n\t* cfgexpand.c (gimple_expand_cfg): Use XCNEWVEC instead of xcalloc.\n\t* tree-vrp.c (find_assert_locations): Use XNEWVEC instead of XCNEWVEC\n\tfor arrays to be filled by pre_and_rev_post_order_compute.  Allocate\n\tthe right number of slots, not that number plus NUM_FIXED_BLOCKS.\n\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n\t* cfganal.c (dfs_enumerate_from): Use XNEWVEC instead of XCNEWVEC for\n\tarray used as stack.\n\t* tree-ssa-sccvn.c (init_scc_vn): Use XNEWVEC instead of XCNEWVEC for\n\tarrays to be filled by pre_and_rev_post_order_compute.\n\t* cfgloopmanip.c (find_path): Use XNEWVEC instead of XCNEWVEC for\n\tarray to be filled by dfs_enumerate_from.\n\t(remove_path): Likewise.\n\t(duplicate_loop_to_header_edge): Use XNEWVEC instead of XCNEWVEC for\n\tarray of loops that is filled on the next lines.\n\t* cfgloop.c (get_loop_body): Use XNEWVEC instead of XCNEWVEC for\n\tarray of basic blocks to be returned.\n\t(get_loop_body_in_dom_order): Likewise.\n\t(get_loop_body_in_bfs_order): Likewise.\n\t* tree-ssa-loop-manip.c (loop_renamer_obstack): New static obstack\n\tfor all bitmaps used for rewriting into loop-closed SSA form.\n\t(add_exit_phis_var): Allocate the def bitmap on it.  Clear the livein\n\tbitmap at the end to release a lot of memory.\n\t(add_exit_phis): Allocate the exits bitmap on the new obstack.\n\t(get_loops_exits): Allocate the exits bitmap on the new obstack.\n\t(find_uses_to_rename_use): Allocate a use_blocks bitmap if ver is\n\tseen for the first time.\n\t(find_uses_to_rename): Add \"???\" for why the whole function must\n\tbe re-scanned if changed_bbs is empty.\n\t(rewrite_into_loop_closed_ssa): Allocate bitmaps on the new obstack.\n\tUse XNEWVEC to allocate the use_blocks array.  Initialize the new\n\tobstack, and free it at the end.  Remove loop over all SSA names.\n\t(check_loop_closed_ssa_stmt): Look only at SSA_OP_USE operands.\n\t* tree-cfg.c (move_sese_region_to_fn): Use XNEWVEC instead of\n\txcalloc to allocate edge_pred and edge_flag arrays.\n\nFrom-SVN: r190359", "tree": {"sha": "1c95fd4683bc594cb2132acdc6e4392391693368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c95fd4683bc594cb2132acdc6e4392391693368"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c302207e352d7372845458212fa30251ff1ae730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c302207e352d7372845458212fa30251ff1ae730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c302207e352d7372845458212fa30251ff1ae730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c302207e352d7372845458212fa30251ff1ae730/comments", "author": null, "committer": null, "parents": [{"sha": "2942db6337e4982a520f596554c9ae409afc69af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2942db6337e4982a520f596554c9ae409afc69af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2942db6337e4982a520f596554c9ae409afc69af"}], "stats": {"total": 134, "additions": 94, "deletions": 40}, "files": [{"sha": "dde7c78fd36fdcc94105603063d811f71274dd86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -1,3 +1,43 @@\n+2012-08-13  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree-ssa-pre.c (do_regular_insertion): Add FIXME markers at points\n+\tof potentially huge memset overhead.\n+\t(do_partial_partial_insertion): Likewise.\n+\t* cfgexpand.c (gimple_expand_cfg): Use XCNEWVEC instead of xcalloc.\n+\t* tree-vrp.c (find_assert_locations): Use XNEWVEC instead of XCNEWVEC\n+\tfor arrays to be filled by pre_and_rev_post_order_compute.  Allocate\n+\tthe right number of slots, not that number plus NUM_FIXED_BLOCKS.\n+\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n+\t* cfganal.c (dfs_enumerate_from): Use XNEWVEC instead of XCNEWVEC for\n+\tarray used as stack.\n+\t* tree-ssa-sccvn.c (init_scc_vn): Use XNEWVEC instead of XCNEWVEC for\n+\tarrays to be filled by pre_and_rev_post_order_compute.\n+\t* cfgloopmanip.c (find_path): Use XNEWVEC instead of XCNEWVEC for\n+\tarray to be filled by dfs_enumerate_from.\n+\t(remove_path): Likewise.\n+\t(duplicate_loop_to_header_edge): Use XNEWVEC instead of XCNEWVEC for\n+\tarray of loops that is filled on the next lines.\n+\t* cfgloop.c (get_loop_body): Use XNEWVEC instead of XCNEWVEC for\n+\tarray of basic blocks to be returned.\n+\t(get_loop_body_in_dom_order): Likewise.\n+\t(get_loop_body_in_bfs_order): Likewise.\n+\t* tree-ssa-loop-manip.c (loop_renamer_obstack): New static obstack\n+\tfor all bitmaps used for rewriting into loop-closed SSA form.\n+\t(add_exit_phis_var): Allocate the def bitmap on it.  Clear the livein\n+\tbitmap at the end to release a lot of memory.\n+\t(add_exit_phis): Allocate the exits bitmap on the new obstack.\n+\t(get_loops_exits): Allocate the exits bitmap on the new obstack.\n+\t(find_uses_to_rename_use): Allocate a use_blocks bitmap if ver is\n+\tseen for the first time.\n+\t(find_uses_to_rename): Add \"???\" for why the whole function must\n+\tbe re-scanned if changed_bbs is empty.\n+\t(rewrite_into_loop_closed_ssa): Allocate bitmaps on the new obstack.\n+\tUse XNEWVEC to allocate the use_blocks array.  Initialize the new\n+\tobstack, and free it at the end.  Remove loop over all SSA names.\n+\t(check_loop_closed_ssa_stmt): Look only at SSA_OP_USE operands.\n+\t* tree-cfg.c (move_sese_region_to_fn): Use XNEWVEC instead of\n+\txcalloc to allocate edge_pred and edge_flag arrays.\n+\n 2012-08-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (FIXED_REGISTERS): Do not mark REX registers here."}, {"sha": "7cf9ca856065f2c79aaead53483bb79ac0883c97", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -1019,7 +1019,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n       v_size = size;\n     }\n \n-  st = XCNEWVEC (basic_block, rslt_max);\n+  st = XNEWVEC (basic_block, rslt_max);\n   rslt[tv++] = st[sp++] = bb;\n   MARK_VISITED (bb);\n   while (sp)"}, {"sha": "6793ba68daf0e086843f79242caef89fd6661e75", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -4334,8 +4334,7 @@ gimple_expand_cfg (void)\n   timevar_push (TV_OUT_OF_SSA);\n   rewrite_out_of_ssa (&SA);\n   timevar_pop (TV_OUT_OF_SSA);\n-  SA.partition_to_pseudo = (rtx *)xcalloc (SA.map->num_partitions,\n-\t\t\t\t\t   sizeof (rtx));\n+  SA.partition_to_pseudo = XCNEWVEC (rtx, SA.map->num_partitions);\n \n   /* Make sure all values used by the optimization passes have sane\n      defaults.  */"}, {"sha": "dd75be668e3ad3f5560e4e3fd62103178c79ee99", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -805,7 +805,7 @@ get_loop_body (const struct loop *loop)\n \n   gcc_assert (loop->num_nodes);\n \n-  body = XCNEWVEC (basic_block, loop->num_nodes);\n+  body = XNEWVEC (basic_block, loop->num_nodes);\n \n   if (loop->latch == EXIT_BLOCK_PTR)\n     {\n@@ -865,7 +865,7 @@ get_loop_body_in_dom_order (const struct loop *loop)\n \n   gcc_assert (loop->num_nodes);\n \n-  tovisit = XCNEWVEC (basic_block, loop->num_nodes);\n+  tovisit = XNEWVEC (basic_block, loop->num_nodes);\n \n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n@@ -904,7 +904,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   gcc_assert (loop->num_nodes);\n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n-  blocks = XCNEWVEC (basic_block, loop->num_nodes);\n+  blocks = XNEWVEC (basic_block, loop->num_nodes);\n   visited = BITMAP_ALLOC (NULL);\n \n   bb = loop->header;"}, {"sha": "98a306fd68c8fe3867ae1f0e88af7e0a67b1dfa3", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -71,7 +71,7 @@ find_path (edge e, basic_block **bbs)\n   gcc_assert (EDGE_COUNT (e->dest->preds) <= 1);\n \n   /* Find bbs in the path.  */\n-  *bbs = XCNEWVEC (basic_block, n_basic_blocks);\n+  *bbs = XNEWVEC (basic_block, n_basic_blocks);\n   return dfs_enumerate_from (e->dest, 0, rpe_enum_p, *bbs,\n \t\t\t     n_basic_blocks, e->dest);\n }\n@@ -322,7 +322,7 @@ remove_path (edge e)\n   nrem = find_path (e, &rem_bbs);\n \n   n_bord_bbs = 0;\n-  bord_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n+  bord_bbs = XNEWVEC (basic_block, n_basic_blocks);\n   seen = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (seen);\n \n@@ -1135,7 +1135,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   n_orig_loops = 0;\n   for (aloop = loop->inner; aloop; aloop = aloop->next)\n     n_orig_loops++;\n-  orig_loops = XCNEWVEC (struct loop *, n_orig_loops);\n+  orig_loops = XNEWVEC (struct loop *, n_orig_loops);\n   for (aloop = loop->inner, i = 0; aloop; aloop = aloop->next, i++)\n     orig_loops[i] = aloop;\n "}, {"sha": "f1e9ddf52b2f2376db83c00cdb991bc520ce67f5", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -6467,8 +6467,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n      EXIT_BB so that we can re-attach them to the new basic block that\n      will replace the region.  */\n   num_entry_edges = EDGE_COUNT (entry_bb->preds);\n-  entry_pred = (basic_block *) xcalloc (num_entry_edges, sizeof (basic_block));\n-  entry_flag = (int *) xcalloc (num_entry_edges, sizeof (int));\n+  entry_pred = XNEWVEC (basic_block, num_entry_edges);\n+  entry_flag = XNEWVEC (int, num_entry_edges);\n   entry_prob = XNEWVEC (unsigned, num_entry_edges);\n   i = 0;\n   for (ei = ei_start (entry_bb->preds); (e = ei_safe_edge (ei)) != NULL;)\n@@ -6482,9 +6482,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   if (exit_bb)\n     {\n       num_exit_edges = EDGE_COUNT (exit_bb->succs);\n-      exit_succ = (basic_block *) xcalloc (num_exit_edges,\n-\t\t\t\t\t   sizeof (basic_block));\n-      exit_flag = (int *) xcalloc (num_exit_edges, sizeof (int));\n+      exit_succ = XNEWVEC (basic_block, num_exit_edges);\n+      exit_flag = XNEWVEC (int, num_exit_edges);\n       exit_prob = XNEWVEC (unsigned, num_exit_edges);\n       i = 0;\n       for (ei = ei_start (exit_bb->succs); (e = ei_safe_edge (ei)) != NULL;)"}, {"sha": "98846138e7c90ffca4a8696a617ea7a9aadbe9ed", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -34,6 +34,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"langhooks.h\"\n \n+/* All bitmaps for rewriting into loop-closed SSA go on this obstack,\n+   so that we can free them all at once.  */\n+static bitmap_obstack loop_renamer_obstack;\n+\n /* Creates an induction variable with value BASE + STEP * iteration in LOOP.\n    It is expected that neither BASE nor STEP are shared with other expressions\n    (unless the sharing rules allow this).  Use VAR as a base var_decl for it\n@@ -168,7 +172,7 @@ add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n   gcc_checking_assert (is_gimple_reg (var));\n   bitmap_clear_bit (livein, def_bb->index);\n \n-  def = BITMAP_ALLOC (NULL);\n+  def = BITMAP_ALLOC (&loop_renamer_obstack);\n   bitmap_set_bit (def, def_bb->index);\n   compute_global_livein (livein, def);\n   BITMAP_FREE (def);\n@@ -177,6 +181,10 @@ add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n     {\n       add_exit_phis_edge (BASIC_BLOCK (index), var);\n     }\n+\n+  /* Free the livein bitmap.  We'll not be needing it anymore, and\n+     it may have grown quite large.  No reason to hold on to it.  */\n+  bitmap_clear (livein);\n }\n \n /* Add exit phis for the names marked in NAMES_TO_RENAME.\n@@ -200,7 +208,7 @@ add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap loop_exits)\n static bitmap\n get_loops_exits (void)\n {\n-  bitmap exits = BITMAP_ALLOC (NULL);\n+  bitmap exits = BITMAP_ALLOC (&loop_renamer_obstack);\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n@@ -253,11 +261,11 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,\n   if (flow_bb_inside_loop_p (def_loop, bb))\n     return;\n \n-  if (!use_blocks[ver])\n-    use_blocks[ver] = BITMAP_ALLOC (NULL);\n+  /* If we're seeing VER for the first time, we still have to allocate\n+     a bitmap for its uses.  */\n+  if (bitmap_set_bit (need_phis, ver))\n+    use_blocks[ver] = BITMAP_ALLOC (&loop_renamer_obstack);\n   bitmap_set_bit (use_blocks[ver], bb->index);\n-\n-  bitmap_set_bit (need_phis, ver);\n }\n \n /* For uses in STMT, mark names that are used outside of the loop they are\n@@ -312,6 +320,7 @@ find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)\n   unsigned index;\n   bitmap_iterator bi;\n \n+  /* ??? If CHANGED_BBS is empty we rewrite the whole function -- why?  */\n   if (changed_bbs && !bitmap_empty_p (changed_bbs))\n     {\n       EXECUTE_IF_SET_IN_BITMAP (changed_bbs, 0, index, bi)\n@@ -365,22 +374,25 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n {\n   bitmap loop_exits;\n   bitmap *use_blocks;\n-  unsigned i, old_num_ssa_names;\n   bitmap names_to_rename;\n \n   loops_state_set (LOOP_CLOSED_SSA);\n   if (number_of_loops () <= 1)\n     return;\n \n+  bitmap_obstack_initialize (&loop_renamer_obstack);\n+\n   loop_exits = get_loops_exits ();\n-  names_to_rename = BITMAP_ALLOC (NULL);\n+  names_to_rename = BITMAP_ALLOC (&loop_renamer_obstack);\n \n   /* If the pass has caused the SSA form to be out-of-date, update it\n      now.  */\n   update_ssa (update_flag);\n \n-  old_num_ssa_names = num_ssa_names;\n-  use_blocks = XCNEWVEC (bitmap, old_num_ssa_names);\n+  /* Uses of names to rename.  We don't have to initialize this array,\n+     because we know that we will only have entries for the SSA names\n+     in NAMES_TO_RENAME.  */\n+  use_blocks = XCNEWVEC (bitmap, num_ssa_names);\n \n   /* Find the uses outside loops.  */\n   find_uses_to_rename (changed_bbs, use_blocks, names_to_rename);\n@@ -389,11 +401,8 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n      rewrite.  */\n   add_exit_phis (names_to_rename, use_blocks, loop_exits);\n \n-  for (i = 0; i < old_num_ssa_names; i++)\n-    BITMAP_FREE (use_blocks[i]);\n+  bitmap_obstack_release (&loop_renamer_obstack);\n   free (use_blocks);\n-  BITMAP_FREE (loop_exits);\n-  BITMAP_FREE (names_to_rename);\n \n   /* Fix up all the names found to be used outside their original\n      loops.  */\n@@ -428,7 +437,7 @@ check_loop_closed_ssa_stmt (basic_block bb, gimple stmt)\n   if (is_gimple_debug (stmt))\n     return;\n \n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n     check_loop_closed_ssa_use (bb, var);\n }\n "}, {"sha": "b4775404fdb9f6772461edfbf257ddc6a7af4afe", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -3442,6 +3442,9 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t      continue;\n \t    }\n \n+\t  /* FIXME: This costs N_EXPR*N_BASIC_BLOCKS.  Should use\n+\t     a less costly data structure for avail (e.g. a VEC\n+\t     indexed by edge index).  */\n \t  avail = XCNEWVEC (pre_expr, last_basic_block);\n \t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t    {\n@@ -3602,6 +3605,9 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t  if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n \t    continue;\n \n+\t  /* FIXME: This costs N_EXPR*N_BASIC_BLOCKS.  Should use\n+\t     a less costly data structure for avail (e.g. a VEC\n+\t     indexed by edge index).  */\n \t  avail = XCNEWVEC (pre_expr, last_basic_block);\n \t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t    {"}, {"sha": "ebe2dc3fc92279d335705ac41b2b81673045174d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -3613,7 +3613,7 @@ init_reassoc (void)\n {\n   int i;\n   long rank = 2;\n-  int *bbs = XNEWVEC (int, last_basic_block + 1);\n+  int *bbs = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n \n   /* Find the loops, so that we can prevent moving calculations in\n      them.  */\n@@ -3628,7 +3628,7 @@ init_reassoc (void)\n   /* Reverse RPO (Reverse Post Order) will give us something where\n      deeper loops come later.  */\n   pre_and_rev_post_order_compute (NULL, bbs, false);\n-  bb_rank = XCNEWVEC (long, last_basic_block + 1);\n+  bb_rank = XCNEWVEC (long, last_basic_block);\n   operand_rank = pointer_map_create ();\n \n   /* Give each default definition a distinct rank.  This includes"}, {"sha": "b7e343be7c3dddb0105c87ae034225db9d931390", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -3835,13 +3835,14 @@ init_scc_vn (void)\n   vn_ssa_aux_table = VEC_alloc (vn_ssa_aux_t, heap, num_ssa_names + 1);\n   /* VEC_alloc doesn't actually grow it to the right size, it just\n      preallocates the space to do so.  */\n-  VEC_safe_grow_cleared (vn_ssa_aux_t, heap, vn_ssa_aux_table, num_ssa_names + 1);\n+  VEC_safe_grow_cleared (vn_ssa_aux_t, heap, vn_ssa_aux_table,\n+\t\t\t num_ssa_names + 1);\n   gcc_obstack_init (&vn_ssa_aux_obstack);\n \n   shared_lookup_phiargs = NULL;\n   shared_lookup_references = NULL;\n-  rpo_numbers = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n-  rpo_numbers_temp = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  rpo_numbers = XNEWVEC (int, last_basic_block);\n+  rpo_numbers_temp = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n   pre_and_rev_post_order_compute (NULL, rpo_numbers_temp, false);\n \n   /* RPO numbers is an array of rpo ordering, rpo[i] = bb means that"}, {"sha": "65aa6c1169b36d1f8e733554b08d817f0b5b5848", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c302207e352d7372845458212fa30251ff1ae730/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c302207e352d7372845458212fa30251ff1ae730", "patch": "@@ -5574,19 +5574,19 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n static bool\n find_assert_locations (void)\n {\n-  int *rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n-  int *bb_rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n-  int *last_rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  int *rpo = XNEWVEC (int, last_basic_block);\n+  int *bb_rpo = XNEWVEC (int, last_basic_block);\n+  int *last_rpo = XCNEWVEC (int, last_basic_block);\n   int rpo_cnt, i;\n   bool need_asserts;\n \n-  live = XCNEWVEC (sbitmap, last_basic_block + NUM_FIXED_BLOCKS);\n+  live = XCNEWVEC (sbitmap, last_basic_block);\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n   for (i = 0; i < rpo_cnt; ++i)\n     bb_rpo[rpo[i]] = i;\n \n   need_asserts = false;\n-  for (i = rpo_cnt-1; i >= 0; --i)\n+  for (i = rpo_cnt - 1; i >= 0; --i)\n     {\n       basic_block bb = BASIC_BLOCK (rpo[i]);\n       edge e;\n@@ -5647,7 +5647,7 @@ find_assert_locations (void)\n   XDELETEVEC (rpo);\n   XDELETEVEC (bb_rpo);\n   XDELETEVEC (last_rpo);\n-  for (i = 0; i < last_basic_block + NUM_FIXED_BLOCKS; ++i)\n+  for (i = 0; i < last_basic_block; ++i)\n     if (live[i])\n       sbitmap_free (live[i]);\n   XDELETEVEC (live);"}]}