{"sha": "478e571a3eedfab198e48e8d2c8f02e491ba2c28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4ZTU3MWEzZWVkZmFiMTk4ZTQ4ZThkMmM4ZjAyZTQ5MWJhMmMyOA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:59:12Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:59:12Z"}, "message": "slp: support complex FMS and complex FMS conjugate\n\nThis adds support for FMS and FMS conjugated to the slp pattern matcher.\n\nExample of matches:\n\n#include <stdio.h>\n#include <complex.h>\n\n#define N 200\n#define ROT\n#define TYPE float\n#define TYPE2 float\n\nvoid g (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] -=  a[i] * (b[i] ROT);\n    }\n}\n\nvoid g_f1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] -=  conjf (a[i]) * (b[i]);\n    }\n}\n\nvoid g_s1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] -=  a[i] * conjf (b[i] ROT);\n    }\n}\n\nvoid caxpy_sub(double complex * restrict y, double complex * restrict x, size_t N, double complex f) {\n  for (size_t i = 0; i < N; ++i)\n    y[i] -= x[i]* f;\n}\n\ngcc/ChangeLog:\n\n\t* internal-fn.def (COMPLEX_FMS, COMPLEX_FMS_CONJ): New.\n\t* optabs.def (cmls_optab, cmls_conj_optab): New.\n\t* doc/md.texi: Document them.\n\t* tree-vect-slp-patterns.c (class complex_fms_pattern,\n\tcomplex_fms_pattern::matches, complex_fms_pattern::recognize,\n\tcomplex_fms_pattern::build): New.", "tree": {"sha": "6cfdd5a785e765e2ca1be2351b424757b73930ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cfdd5a785e765e2ca1be2351b424757b73930ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478e571a3eedfab198e48e8d2c8f02e491ba2c28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478e571a3eedfab198e48e8d2c8f02e491ba2c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478e571a3eedfab198e48e8d2c8f02e491ba2c28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478e571a3eedfab198e48e8d2c8f02e491ba2c28/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31fac31800b5671d17c46108013d6fc709370ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fac31800b5671d17c46108013d6fc709370ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31fac31800b5671d17c46108013d6fc709370ef3"}], "stats": {"total": 231, "additions": 230, "deletions": 1}, "files": [{"sha": "e3686dbfe6175505906bca11c3c57b85ad474fa9", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=478e571a3eedfab198e48e8d2c8f02e491ba2c28", "patch": "@@ -6247,6 +6247,51 @@ The operation is only supported for vector modes @var{m}.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{cmls@var{m}4} instruction pattern\n+@item @samp{cmls@var{m}4}\n+Perform a vector multiply and subtract that is semantically the same as\n+a multiply and subtract of complex numbers.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] -= a[i] * b[i];\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{cmls_conj@var{m}4} instruction pattern\n+@item @samp{cmls_conj@var{m}4}\n+Perform a vector multiply by conjugate and subtract that is semantically\n+the same as a multiply and subtract of complex numbers where the second\n+multiply arguments is conjugated.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] -= a[i] * conj (b[i]);\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{cmul@var{m}4} instruction pattern\n @item @samp{cmul@var{m}4}\n Perform a vector multiply that is semantically the same as multiply of"}, {"sha": "daeace7a34ee950fdf724f87601478f3ec5378f7", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=478e571a3eedfab198e48e8d2c8f02e491ba2c28", "patch": "@@ -290,6 +290,8 @@ DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)\n DEF_INTERNAL_FLT_FLOATN_FN (FMA, ECF_CONST, fma, ternary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_FMA, ECF_CONST, cmla, ternary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_FMA_CONJ, ECF_CONST, cmla_conj, ternary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_FMS, ECF_CONST, cmls, ternary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_FMS_CONJ, ECF_CONST, cmls_conj, ternary)\n \n /* Unary integer ops.  */\n DEF_INTERNAL_INT_FN (CLRSB, ECF_CONST | ECF_NOTHROW, clrsb, unary)"}, {"sha": "b192a9d070b8aa72e5676b2eaa020b5bdd7ffcc8", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=478e571a3eedfab198e48e8d2c8f02e491ba2c28", "patch": "@@ -296,6 +296,8 @@ OPTAB_D (cmul_optab, \"cmul$a3\")\n OPTAB_D (cmul_conj_optab, \"cmul_conj$a3\")\n OPTAB_D (cmla_optab, \"cmla$a4\")\n OPTAB_D (cmla_conj_optab, \"cmla_conj$a4\")\n+OPTAB_D (cmls_optab, \"cmls$a4\")\n+OPTAB_D (cmls_conj_optab, \"cmls_conj$a4\")\n OPTAB_D (cos_optab, \"cos$a2\")\n OPTAB_D (cosh_optab, \"cosh$a2\")\n OPTAB_D (exp10_optab, \"exp10$a2\")"}, {"sha": "8065a58065f742a6fe3a76f5fb6b6965b716dbf0", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 181, "deletions": 1, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478e571a3eedfab198e48e8d2c8f02e491ba2c28/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=478e571a3eedfab198e48e8d2c8f02e491ba2c28", "patch": "@@ -830,7 +830,7 @@ vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n \t variants to be sure.  This needs to be fixed in the mid-end so\n \t this part can be simpler.  */\n       kind = linear_loads_p (perm_cache, right_op[0]).first;\n-      if (!((kind == PERM_ODDODD\n+      if (!((is_eq_or_top (linear_loads_p (perm_cache, right_op[0]), PERM_ODDODD)\n \t   && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n \t\t\t     PERM_ODDEVEN))\n \t  || (kind == PERM_ODDEVEN\n@@ -863,6 +863,7 @@ vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n     {\n       if ((kind = linear_loads_p (perm_cache, left_op[index2]).first) == PERM_EVENODD)\n \treturn false;\n+      return true;\n     }\n   else if (!neg_first)\n     *conj_first_operand = true;\n@@ -1265,6 +1266,185 @@ complex_fma_pattern::build (vec_info *vinfo)\n   complex_pattern::build (vinfo);\n }\n \n+/*******************************************************************************\n+ * complex_fms_pattern class\n+ ******************************************************************************/\n+\n+class complex_fms_pattern : public complex_pattern\n+{\n+  protected:\n+    complex_fms_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+      : complex_pattern (node, m_ops, ifn)\n+    {\n+      this->m_num_args = 3;\n+    }\n+\n+  public:\n+    void build (vec_info *);\n+    static internal_fn\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n+\t     vec<slp_tree> *);\n+\n+    static vect_pattern*\n+    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+\n+    static vect_pattern*\n+    mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+    {\n+      return new complex_fms_pattern (node, m_ops, ifn);\n+    }\n+};\n+\n+\n+/* Pattern matcher for trying to match complex multiply and accumulate\n+   and multiply and subtract patterns in SLP tree.\n+   If the operation matches then IFN is set to the operation it matched and\n+   the arguments to the two replacement statements are put in m_ops.\n+\n+   If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n+\n+   This function matches the patterns shaped as:\n+\n+   double ax = (b[i+1] * a[i]) + (b[i] * a[i]);\n+   double bx = (a[i+1] * b[i]) - (a[i+1] * b[i+1]);\n+\n+   c[i] = c[i] - ax;\n+   c[i+1] = c[i+1] + bx;\n+\n+   If a match occurred then TRUE is returned, else FALSE.  The initial match is\n+   expected to be in OP1 and the initial match operands in args0.  */\n+\n+internal_fn\n+complex_fms_pattern::matches (complex_operation_t op,\n+\t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      slp_tree * ref_node, vec<slp_tree> *ops)\n+{\n+  internal_fn ifn = IFN_LAST;\n+\n+  /* Find the two components.  We match Complex MUL first which reduces the\n+     amount of work this pattern has to do.  After that we just match the\n+     head node and we're done.:\n+\n+     * FMS: - +.  */\n+  slp_tree child = NULL;\n+\n+  /* We need to ignore the two_operands nodes that may also match,\n+     for that we can check if they have any scalar statements and also\n+     check that it's not a permute node as we're looking for a normal\n+     PLUS_EXPR operation.  */\n+  if (op != PLUS_MINUS)\n+    return IFN_LAST;\n+\n+  child = SLP_TREE_CHILDREN ((*ops)[1])[1];\n+  if (vect_detect_pair_op (child) != MINUS_PLUS)\n+    return IFN_LAST;\n+\n+  /* First two nodes must be a multiply.  */\n+  auto_vec<slp_tree> muls;\n+  if (vect_match_call_complex_mla (child, 0) != MULT_MULT\n+      || vect_match_call_complex_mla (child, 1, &muls) != MULT_MULT)\n+    return IFN_LAST;\n+\n+  /* Now operand2+4 may lead to another expression.  */\n+  auto_vec<slp_tree> left_op, right_op;\n+  left_op.safe_splice (SLP_TREE_CHILDREN (muls[0]));\n+  right_op.safe_splice (SLP_TREE_CHILDREN (muls[1]));\n+\n+  bool is_neg = vect_normalize_conj_loc (left_op);\n+\n+  child = SLP_TREE_CHILDREN ((*ops)[1])[0];\n+  bool conj_first_operand = false;\n+  if (!vect_validate_multiplication (perm_cache, right_op, left_op, false,\n+\t\t\t\t     &conj_first_operand, true))\n+    return IFN_LAST;\n+\n+  if (!is_neg)\n+    ifn = IFN_COMPLEX_FMS;\n+  else if (is_neg)\n+    ifn = IFN_COMPLEX_FMS_CONJ;\n+\n+  if (!vect_pattern_validate_optab (ifn, *ref_node))\n+    return IFN_LAST;\n+\n+  ops->truncate (0);\n+  ops->create (4);\n+\n+  complex_perm_kinds_t kind = linear_loads_p (perm_cache, right_op[0]).first;\n+  if (kind == PERM_EVENODD)\n+    {\n+      ops->quick_push (child);\n+      ops->quick_push (right_op[0]);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (left_op[1]);\n+    }\n+  else if (kind == PERM_TOP)\n+    {\n+      ops->quick_push (child);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (right_op[0]);\n+      ops->quick_push (left_op[0]);\n+    }\n+  else if (kind == PERM_EVENEVEN && !is_neg)\n+    {\n+      ops->quick_push (child);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (right_op[0]);\n+      ops->quick_push (left_op[0]);\n+    }\n+  else\n+    {\n+      ops->quick_push (child);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (right_op[0]);\n+      ops->quick_push (left_op[1]);\n+    }\n+\n+  return ifn;\n+}\n+\n+/* Attempt to recognize a complex mul pattern.  */\n+\n+vect_pattern*\n+complex_fms_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_tree *node)\n+{\n+  auto_vec<slp_tree> ops;\n+  complex_operation_t op\n+    = vect_detect_pair_op (*node, true, &ops);\n+  internal_fn ifn\n+    = complex_fms_pattern::matches (op, perm_cache, node, &ops);\n+  if (ifn == IFN_LAST)\n+    return NULL;\n+\n+  return new complex_fms_pattern (node, &ops, ifn);\n+}\n+\n+/* Perform a replacement of the detected complex mul pattern with the new\n+   instruction sequences.  */\n+\n+void\n+complex_fms_pattern::build (vec_info *vinfo)\n+{\n+  slp_tree node;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n+    vect_free_slp_tree (node);\n+\n+  SLP_TREE_CHILDREN (*this->m_node).release ();\n+  SLP_TREE_CHILDREN (*this->m_node).create (3);\n+\n+  /* First re-arrange the children.  */\n+  SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[0]);\n+  SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[1]);\n+  SLP_TREE_CHILDREN (*this->m_node).quick_push (\n+    vect_build_combine_node (this->m_ops[2], this->m_ops[3], *this->m_node));\n+  SLP_TREE_REF_COUNT (this->m_ops[0])++;\n+  SLP_TREE_REF_COUNT (this->m_ops[1])++;\n+\n+  /* And then rewrite the node itself.  */\n+  complex_pattern::build (vinfo);\n+}\n+\n /*******************************************************************************\n  * Pattern matching definitions\n  ******************************************************************************/"}]}