{"sha": "d6c5a763516081cca8b9ed4f10a17a90f7176b69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZjNWE3NjM1MTYwODFjY2E4YjllZDRmMTBhMTdhOTBmNzE3NmI2OQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2001-01-14T19:37:18Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2001-01-14T19:37:18Z"}, "message": "arm.md (ldmsi_postinc, [...]): Delete.\n\n* arm.md (ldmsi_postinc, ldmsi, stmsi_postinc, smsi): Delete.  Replace\nwith ...\n(ldmsi_postinc[432], ldmsi[432], stmsi_postinc[432], stmsi[432]): New.\n\nFrom-SVN: r39015", "tree": {"sha": "71e56dff9f3521974337192b2eef5cac358c7f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71e56dff9f3521974337192b2eef5cac358c7f3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6c5a763516081cca8b9ed4f10a17a90f7176b69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c5a763516081cca8b9ed4f10a17a90f7176b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c5a763516081cca8b9ed4f10a17a90f7176b69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c5a763516081cca8b9ed4f10a17a90f7176b69/comments", "author": null, "committer": null, "parents": [{"sha": "3e29b81bdad50e9250474df60d87a8c3924a1778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e29b81bdad50e9250474df60d87a8c3924a1778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e29b81bdad50e9250474df60d87a8c3924a1778"}], "stats": {"total": 232, "additions": 160, "deletions": 72}, "files": [{"sha": "70fe869fdd94c519914dfd43a485a96a7406e9d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c5a763516081cca8b9ed4f10a17a90f7176b69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c5a763516081cca8b9ed4f10a17a90f7176b69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6c5a763516081cca8b9ed4f10a17a90f7176b69", "patch": "@@ -1,3 +1,9 @@\n+2001-01-14  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.md (ldmsi_postinc, ldmsi, stmsi_postinc, smsi): Delete.  Replace\n+\twith ...\n+\t(ldmsi_postinc[432], ldmsi[432], stmsi_postinc[432], stmsi[432]): New.\n+\n 2001-01-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cppmain.c (do_preprocessing): New function; most of the old"}, {"sha": "f7d4e6d5c2ddb3f9314e4c31f50f60a55b799037", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 154, "deletions": 72, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6c5a763516081cca8b9ed4f10a17a90f7176b69/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6c5a763516081cca8b9ed4f10a17a90f7176b69/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d6c5a763516081cca8b9ed4f10a17a90f7176b69", "patch": "@@ -5229,51 +5229,97 @@\n \n ;; Load multiple with write-back\n \n-(define_insn \"*ldmsi_postinc\"\n+(define_insn \"*ldmsi_postinc4\"\n   [(match_parallel 0 \"load_multiple_operation\"\n     [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n \t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\")))\n+\t\t   (const_int 16)))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_dup 2)))\n      (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_dup 2)))])]\n-  \"TARGET_ARM && (INTVAL (operands[3])  == 4 * (XVECLEN (operands[0], 0) - 1))\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    int count = XVECLEN (operands[0], 0);\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n+     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))\n+     (set (match_operand:SI 6 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 12))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%?ia\\\\t%1!, {%3, %4, %5, %6}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n \n-    ops[0] = XEXP (SET_SRC (XVECEXP (operands[0], 0, 0)), 0);\n-    ops[1] = SET_DEST (XVECEXP (operands[0], 0, 1));\n-    ops[2] = SET_DEST (XVECEXP (operands[0], 0, count - 1));\n+(define_insn \"*ldmsi_postinc3\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 12)))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_dup 2)))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n+     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%?ia\\\\t%1!, {%3, %4, %5}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n \n-    output_asm_insn (\\\"ldm%?ia\\\\t%0!, {%1-%2}\\\\t%@ load multiple\\\", ops);\n-    return \\\"\\\";\n-  }\n-  \"\n+(define_insn \"*ldmsi_postinc2\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 8)))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_dup 2)))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%?ia\\\\t%1!, {%3, %4}\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n ;; Ordinary load multiple\n \n-(define_insn \"*ldmsi\"\n+(define_insn \"*ldmsi4\"\n   [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_operand:SI 2 \"s_register_operand\" \"r\")))])]\n-  \"TARGET_ARM\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    int count = XVECLEN (operands[0], 0);\n+    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 12))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%?ia\\\\t%1, {%2, %3, %4, %5}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n \n-    ops[0] = XEXP (SET_SRC (XVECEXP (operands[0], 0, 0)), 0);\n-    ops[1] = SET_DEST (XVECEXP (operands[0], 0, 0));\n-    ops[2] = SET_DEST (XVECEXP (operands[0], 0, count - 1));\n+(define_insn \"*ldmsi3\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 8))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%?ia\\\\t%1, {%2, %3, %4}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n \n-    output_asm_insn (\\\"ldm%?ia\\\\t%0, {%1-%2}\\\\t%@ load multiple\\\", ops);\n-    return \\\"\\\";\n-  }\n-  \"\n+(define_insn \"*ldmsi2\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%?ia\\\\t%1, {%2, %3}\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -5305,63 +5351,99 @@\n \n ;; Store multiple with write-back\n \n-(define_insn \"*stmsi_postinc\"\n+(define_insn \"*stmsi_postinc4\"\n   [(match_parallel 0 \"store_multiple_operation\"\n     [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n \t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\")))\n+\t\t   (const_int 16)))\n      (set (mem:SI (match_dup 2))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_ARM && (INTVAL (operands[3]) == 4 * (XVECLEN (operands[0], 0) - 1))\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    int count = XVECLEN (operands[0], 0);\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n+\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 12)))\n+\t  (match_operand:SI 6 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%?ia\\\\t%1!, {%3, %4, %5, %6}\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"store4\")]\n+)\n \n-    ops[0] = XEXP (SET_SRC (XVECEXP (operands[0], 0, 0)), 0);\n-    ops[1] = SET_SRC (XVECEXP (operands[0], 0, 1));\n-    ops[2] = SET_SRC (XVECEXP (operands[0], 0, count - 1));\n+(define_insn \"*stmsi_postinc3\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 12)))\n+     (set (mem:SI (match_dup 2))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n+\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%?ia\\\\t%1!, {%3, %4, %5}\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"store3\")]\n+)\n \n-    output_asm_insn (\\\"stm%?ia\\\\t%0!, {%1-%2}\\\\t%@ str multiple\\\", ops);\n-    return \\\"\\\";\n-  }\n-  \"\n+(define_insn \"*stmsi_postinc2\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 8)))\n+     (set (mem:SI (match_dup 2))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%?ia\\\\t%1!, {%3, %4}\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set (attr \"type\")\n-        (cond [(eq (symbol_ref \"XVECLEN (operands[0],0)\") (const_int 3))\n-\t  \t   (const_string \"store2\")\n-\t       (eq (symbol_ref \"XVECLEN (operands[0],0)\") (const_int 4))\n-\t\t   (const_string \"store3\")]\n-\t       (const_string \"store4\")))]\n+   (set_attr \"type\" \"store2\")]\n )\n \n ;; Ordinary store multiple\n \n-(define_insn \"*stmsi\"\n+(define_insn \"*stmsi4\"\n   [(match_parallel 0 \"store_multiple_operation\"\n     [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n-\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_ARM\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    int count = XVECLEN (operands[0], 0);\n+\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n+\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%?ia\\\\t%1, {%2, %3, %4, %5}\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"store4\")]\n+)\n \n-    ops[0] = XEXP (SET_DEST (XVECEXP (operands[0], 0, 0)), 0);\n-    ops[1] = SET_SRC (XVECEXP (operands[0], 0, 0));\n-    ops[2] = SET_SRC (XVECEXP (operands[0], 0, count - 1));\n+(define_insn \"*stmsi3\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%?ia\\\\t%1, {%2, %3, %4}\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"store3\")]\n+)\n \n-    output_asm_insn (\\\"stm%?ia\\\\t%0, {%1-%2}\\\\t%@ str multiple\\\", ops);\n-    return \\\"\\\";\n-  }\n-  \"\n+(define_insn \"*stmsi2\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"stm%?ia\\\\t%1, {%2, %3}\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set (attr \"type\")\n-        (cond [(eq (symbol_ref \"XVECLEN (operands[0],0)\") (const_int 3))\n-\t\t   (const_string \"store2\")\n-\t       (eq (symbol_ref \"XVECLEN (operands[0],0)\") (const_int 4))\n-\t\t   (const_string \"store3\")]\n-\t       (const_string \"store4\")))]\n+   (set_attr \"type\" \"store2\")]\n )\n \n ;; Move a block of memory if it is word aligned and MORE than 2 words long.\n@@ -5393,7 +5475,7 @@\n   \"\n )\n \n-;; Block-move insns\n+;; Thumb block-move insns\n \n (define_insn \"movmem12b\"\n   [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))"}]}