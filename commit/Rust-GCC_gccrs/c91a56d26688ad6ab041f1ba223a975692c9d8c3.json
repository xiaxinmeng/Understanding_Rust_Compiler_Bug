{"sha": "c91a56d26688ad6ab041f1ba223a975692c9d8c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkxYTU2ZDI2Njg4YWQ2YWIwNDFmMWJhMjIzYTk3NTY5MmM5ZDhjMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-02T21:44:27Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-02T21:44:27Z"}, "message": "86th Cygnus<->FSF merge\n\nFrom-SVN: r11654", "tree": {"sha": "70d788069e68470c0b9d32e3194eef5d5a8bbbd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d788069e68470c0b9d32e3194eef5d5a8bbbd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c91a56d26688ad6ab041f1ba223a975692c9d8c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91a56d26688ad6ab041f1ba223a975692c9d8c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c91a56d26688ad6ab041f1ba223a975692c9d8c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91a56d26688ad6ab041f1ba223a975692c9d8c3/comments", "author": null, "committer": null, "parents": [{"sha": "dd07092ebe8a89f603b764519b4b8b43cf3abc2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd07092ebe8a89f603b764519b4b8b43cf3abc2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd07092ebe8a89f603b764519b4b8b43cf3abc2e"}], "stats": {"total": 516, "additions": 427, "deletions": 89}, "files": [{"sha": "1548a58b469221381c453df5863d9ad4cda27d74", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -1,10 +1,134 @@\n-Fri Mar 29 09:41:02 1996  Jeffrey A. Law  <law@cygnus.com\n+Mon Apr  1 09:03:13 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Propagate the TYPE_PACKED\n+\tflag for the type to the type's fields.\n+\n+Sat Mar 30 12:14:33 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (complex_parmlist, ELLIPSES): Take out ARM-based warning.\n+\n+Fri Mar 29 15:51:36 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* class.c (base_info, finish_base_struct): Replace \n+\tneeds_virtual_dtor with base_has_virtual.\n+\n+\t(finish_struct_1): Remove the old code that tried to make default\n+ \tdestructors virtual. Use base_has_virtual when checking if we need\n+ \tto add a vtable entry for the rtti code.\n+\n+Fri Mar 29 14:02:36 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (push_template_decl): Complain about template decl with\n+ \tinappropriate declaration.\n+\n+Fri Mar 29 12:15:35 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (build_x_unary_op): Remove bogus check for taking\n+\tthe address of a member function.\n+\n+Fri Mar 29 11:56:02 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (constructor_declarator): Only push the class if\n+\twe are not already in the class.\n+\n+Fri Mar 29 09:41:02 1996  Jeffrey A. Law  <law@cygnus.com>\n \n \t* method.c (emit_thunk): Remove current_call_is_indirect nonsense.\n \tAdd additional argument to INIT_CUMULATIVE_ARGS.\n \n+Thu Mar 28 16:41:39 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (shadow_tag): Fix error about anon union with methods.\n+\n+\t* parse.y (self_reference): Only generate a self-reference if this\n+ \tis a non-template class.\n+\t(opt.component_decl_list): Only use it if it was generated.\n+\n+\t* parse.y (component_decl_1): Use constructor_declarator.\n+\t(fn.def2): Ditto.\n+\t(notype_component_declarator0): Ditto.\n+\n+Thu Mar 28 15:11:35 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (build_x_unary_op): Add checks for taking the address\n+\tof a TARGET_EXPR or of a member function, and give appropriate\n+\twarnings.\n+\n+Thu Mar 28 14:49:26 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (process_template_parm): Allow template type parms to be\n+ \tused as types for template const parms.\n+\n+Wed Mar 27 15:51:19 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (expand_vec_init): Ensure the eh cleanups are on the\n+\tfunction_obstack.\n+\n+Wed Mar 27 10:14:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Be even more picky about the\n+ \tambiguous lookup warning.\n+\t(grokdeclarator): Tweak SCOPE_REF constructor declarators here.\n+\t* parse.y (constructor_declarator): Rather than here.\n+\n+\t* parse.y (constructor_declarator): New nonterminal.\n+\t(fn.def1): Use it.\n+\t(explicit_instantiation): Ditto.\n+\n+Tue Mar 26 13:41:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tAdd implicit declaration of class name at class scope.\n+\t* decl.c (lookup_name_real): Restrict pedwarn about ambiguous lookup.\n+\t* parse.y (self_reference): New nonterminal.\n+\t(opt.component_decl_list): Use it.\n+\t(fn.def1): Add nested_name_specifier type_name cases.\n+\t* class.c (build_self_reference): New function.\n+\t(finish_struct): Handle access_default later, move self-reference\n+\tdecl to the end.\n+\t* pt.c (lookup_template_class): Handle getting a TYPE_DECL.\n+\t* cp-tree.h: Adjust.\n+\n+\t* pt.c (do_function_instantiation): Separate handling of member\n+ \tfunctions and non-member functions properly.\n+\n+Mon Mar 25 14:23:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (process_template_parm): Improve error for 'volatile class K'.\n+\n+\t* class.c (finish_struct_1): Check the right slot for destructors.\n+\n+\t* decl.c (start_enum): Complain about enum templates.\n+\n+Mon Mar 25 13:25:31 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Offset pointers to member data by one.\n+\t* typeck.c (unary_complex_lvalue): Ditto.\n+\n+Mon Mar 25 13:30:42 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Check for a returned local\n+\tarray name, similar to the check for an ADDR_EXPR.\n+\n+Mon Mar 25 13:07:19 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (cp_finish_decl): Don't build cleanups for static\n+ \tvariables here.\n+\n+Fri Mar 22 17:57:55 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Fix error messages to be more\n+\taccurate.\n+\t* cp-tree.h (assop_as_string): Parallel to op_as_string, but for\n+\tassignment operators.\n+\t* error.c (assop_as_string): Ditto.  Add support for `%Q' for\n+\tassignment operators.\n+\n Fri Mar 22 13:48:29 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl.c (grokdeclarator): Call bad_specifiers for typedefs.  Also\n+ \tgive an error if initialized.  Pedwarn about nested type with the\n+ \tsame name as its enclosing class.\n+\n \t* pt.c (tsubst, case TYPE_DECL): Set DECL_CONTEXT.\n \n \t* typeck.c (require_complete_type): Be sure to instantiate the"}, {"sha": "76377e14b2e11b04272d5a9fc8c646f1f3bde810", "filename": "gcc/cp/class.c", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -1384,7 +1384,7 @@ struct base_info\n   char cant_synth_copy_ctor;\n   char cant_synth_asn_ref;\n   char no_const_asn_ref;\n-  char needs_virtual_dtor;\n+  char base_has_virtual;\n };\n \n /* Record information about type T derived from its base classes.\n@@ -1520,9 +1520,8 @@ finish_base_struct (t, b, t_binfo)\n \n       if (TYPE_VIRTUAL_P (basetype))\n \t{\n-\t  /* If there's going to be a destructor needed, make\n-\t     sure it will be virtual.  */\n-\t  b->needs_virtual_dtor = 1;\n+\t  /* Remember that the baseclass has virtual members. */\n+\t  b->base_has_virtual = 1;\n \n \t  /* Don't borrow virtuals from virtual baseclasses.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n@@ -2973,7 +2972,7 @@ finish_struct_1 (t, attributes, warn_anon)\n   tree fields = TYPE_FIELDS (t);\n   tree fn_fields = TYPE_METHODS (t);\n   tree x, last_x, method_vec;\n-  int needs_virtual_dtor;\n+  int base_has_virtual;\n   int all_virtual;\n   int has_virtual;\n   int max_has_virtual;\n@@ -3083,7 +3082,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       cant_synth_copy_ctor = base_info.cant_synth_copy_ctor;\n       cant_synth_asn_ref = base_info.cant_synth_asn_ref;\n       no_const_asn_ref = base_info.no_const_asn_ref;\n-      needs_virtual_dtor = base_info.needs_virtual_dtor;\n+      base_has_virtual = base_info.base_has_virtual;\n       n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n       aggregate = 0;\n     }\n@@ -3100,7 +3099,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       cant_synth_copy_ctor = 0;\n       cant_synth_asn_ref = 0;\n       no_const_asn_ref = 0;\n-      needs_virtual_dtor = 0;\n+      base_has_virtual = 0;\n     }\n \n #if 0\n@@ -3172,6 +3171,9 @@ finish_struct_1 (t, attributes, warn_anon)\n     {\n       GNU_xref_member (current_class_name, x);\n \n+      if (TREE_CODE (x) == FIELD_DECL)\n+\tDECL_PACKED (x) |= TYPE_PACKED (t);\n+\n       /* Handle access declarations.  */\n       if (TREE_CODE (x) == USING_DECL)\n \t{\n@@ -3537,7 +3539,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       && !IS_SIGNATURE (t))\n     {\n       /* Here we must cons up a destructor on the fly.  */\n-      tree dtor = cons_up_default_function (t, name, needs_virtual_dtor != 0);\n+      tree dtor = cons_up_default_function (t, name, 0);\n       check_for_override (dtor, t);\n \n       /* If we couldn't make it work, then pretend we didn't need it.  */\n@@ -3550,11 +3552,6 @@ finish_struct_1 (t, attributes, warn_anon)\n \t  TREE_CHAIN (dtor) = fn_fields;\n \t  fn_fields = dtor;\n \n-\t  if (DECL_VINDEX (dtor) == NULL_TREE\n-\t      && (needs_virtual_dtor\n-\t\t  || pending_virtuals != NULL_TREE\n-\t\t  || pending_hard_virtuals != NULL_TREE))\n-\t    DECL_VINDEX (dtor) = error_mark_node;\n \t  if (DECL_VINDEX (dtor))\n \t    pending_virtuals = add_virtual_function (pending_virtuals,\n \t\t\t\t\t\t     &has_virtual, dtor, t);\n@@ -3563,7 +3560,7 @@ finish_struct_1 (t, attributes, warn_anon)\n     }\n \n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n-  if (flag_rtti && (max_has_virtual > 0 || needs_virtual_dtor) && \n+  if (flag_rtti && (max_has_virtual > 0 || base_has_virtual) && \n \thas_virtual == 0)\n     has_virtual = 1;\n \n@@ -4132,7 +4129,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       TYPE_NONCOPIED_PARTS (t) = build_tree_list (default_conversion (TYPE_BINFO_VTABLE (t)), vfield);\n \n       if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n-\t  && DECL_VINDEX (TREE_VEC_ELT (method_vec, 0)) == NULL_TREE)\n+\t  && DECL_VINDEX (TREE_VEC_ELT (method_vec, 1)) == NULL_TREE)\n \tcp_warning (\"`%#T' has virtual functions but non-virtual destructor\",\n \t\t    t);\n     }\n@@ -4212,6 +4209,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   tree name = TYPE_NAME (t);\n   tree x, last_x = NULL_TREE;\n   tree access;\n+  tree dummy = NULL_TREE;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n@@ -4233,25 +4231,33 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   if (IS_SIGNATURE (t))\n     append_signature_fields (list_of_fieldlists);\n \n-  if (last_x && list_of_fieldlists)\n-    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n-\n-  /* For signatures, we made all methods `public' in the parser and\n-     reported an error if a access specifier was used.  */\n-  if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n+  /* Move our self-reference declaration to the end of the field list so\n+     any real field with the same name takes precedence.  */\n+  if (list_of_fieldlists\n+      && TREE_VALUE (list_of_fieldlists)\n+      && DECL_ARTIFICIAL (TREE_VALUE (list_of_fieldlists)))\n     {\n-      if (list_of_fieldlists\n-\t  && TREE_PURPOSE (list_of_fieldlists) == access_default_node)\n-\tTREE_PURPOSE (list_of_fieldlists) = access_public_node;\n+      dummy = TREE_VALUE (list_of_fieldlists);\n+      list_of_fieldlists = TREE_CHAIN (list_of_fieldlists);\n     }\n-  else if (list_of_fieldlists\n-\t   && TREE_PURPOSE (list_of_fieldlists) == access_default_node)\n-    TREE_PURPOSE (list_of_fieldlists) = access_private_node;\n+\n+  if (last_x && list_of_fieldlists)\n+    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n \n   while (list_of_fieldlists)\n     {\n       access = TREE_PURPOSE (list_of_fieldlists);\n \n+      /* For signatures, we made all methods `public' in the parser and\n+\t reported an error if a access specifier was used.  */\n+      if (access == access_default_node)\n+\t{\n+\t  if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n+\t    access = access_public_node;\n+\t  else\n+\t    access = access_private_node;\n+\t}\n+\n       for (x = TREE_VALUE (list_of_fieldlists); x; x = TREE_CHAIN (x))\n \t{\n \t  TREE_PRIVATE (x) = access == access_private_node;\n@@ -4298,16 +4304,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t      continue;\n \t    }\n \n-#if 0\n-\t  /* Handle access declarations.  */\n-\t  if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n-\t    {\n-\t      tree n = DECL_NAME (x);\n-\t      x = build_decl\n-\t\t(USING_DECL, DECL_NAME (TREE_OPERAND (n, 1)), TREE_TYPE (x));\n-\t      DECL_RESULT (x) = n;\n-\t    }\n-#endif\n \t  if (TREE_CODE (x) != TYPE_DECL)\n \t    DECL_FIELD_CONTEXT (x) = t;\n \n@@ -4330,7 +4326,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n   /* Now add the tags, if any, to the list of TYPE_DECLs\n      defined for this type.  */\n-  if (CLASSTYPE_TAGS (t))\n+  if (CLASSTYPE_TAGS (t) || dummy)\n     {\n       x = CLASSTYPE_TAGS (t);\n       while (x)\n@@ -4350,6 +4346,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t  x = TREE_CHAIN (x);\n \t  last_x = chainon (last_x, tag);\n \t}\n+      if (dummy)\n+\tlast_x = chainon (last_x, dummy);\n       if (fields == NULL_TREE)\n \tfields = last_x;\n       CLASSTYPE_LOCAL_TYPEDECLS (t) = 1;\n@@ -5298,10 +5296,32 @@ print_class_statistics ()\n    decls that may be cached in the previous_class_values list.  For now, let's\n    use the permanent obstack, later we may create a dedicated obstack just\n    for this purpose.  The effect is undone by pop_obstacks.  */\n+\n void\n maybe_push_cache_obstack ()\n {\n   push_obstacks_nochange ();\n   if (current_class_depth == 1)\n     current_obstack = &permanent_obstack;\n }\n+\n+/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,\n+   according to [class]:\n+                                          The class-name is also inserted\n+   into  the scope of the class itself.  For purposes of access checking,\n+   the inserted class name is treated as if it were a public member name.  */\n+\n+tree\n+build_self_reference ()\n+{\n+  tree name = constructor_name (current_class_type);\n+  tree value = build_lang_decl (TYPE_DECL, name, current_class_type);\n+  DECL_NONLOCAL (value) = 1;\n+  DECL_CONTEXT (value) = current_class_type;\n+  DECL_CLASS_CONTEXT (value) = current_class_type;\n+  CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n+  DECL_ARTIFICIAL (value) = 1;\n+\n+  pushdecl_class_level (value);\n+  return value;\n+}"}, {"sha": "4f3212c39b84448cc54ea681c655e5ae0473ea1f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -1967,6 +1967,7 @@ extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n extern unsigned HOST_WIDE_INT skip_rtti_stuff\tPROTO((tree *));\n+extern tree build_self_reference\t\tPROTO((void));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -2254,6 +2255,7 @@ extern char *code_as_string\t\t\tPROTO((enum tree_code, int));\n extern char *language_as_string\t\t\tPROTO((enum languages, int));\n extern char *parm_as_string\t\t\tPROTO((int, int));\n extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *assop_as_string\t\t\tPROTO((enum tree_code, int));\n extern char *cv_as_string\t\t\tPROTO((tree, int));\n \n /* in method.c */\n@@ -2290,7 +2292,6 @@ extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree *));\n-extern void overload_template_name\t\tPROTO((tree));\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));"}, {"sha": "93585de3db2d6a2b78feb12c0fa0e1766b5df6b6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -4501,12 +4501,18 @@ lookup_name_real (name, prefer_type, nonclass)\n  done:\n   if (val)\n     {\n+      /* This should only warn about types used in qualified-ids.  */\n       if (from_obj && from_obj != val)\n \t{\n-\t  cp_pedwarn (\"lookup of `%D' in the scope of `%#T' (`%D')\",\n-\t\t      name, got_object, from_obj);\n-\t  cp_pedwarn (\"  does not match lookup in the current scope (`%D')\",\n-\t\t      val);\n+\t  if (looking_for_typename && TREE_CODE (from_obj) == TYPE_DECL\n+\t      && TREE_CODE (val) == TYPE_DECL\n+\t      && TREE_TYPE (from_obj) != TREE_TYPE (val))\n+\t    {\n+\t      cp_pedwarn (\"lookup of `%D' in the scope of `%#T' (`%#T')\",\n+\t\t\t  name, got_object, TREE_TYPE (from_obj));\n+\t      cp_pedwarn (\"  does not match lookup in the current scope (`%#T')\",\n+\t\t\t  TREE_TYPE (val));\n+\t    }\n \t}\n \n       if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n@@ -5700,14 +5706,15 @@ shadow_tag (declspecs)\n     {\n       /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n \t function members.  */\n+      if (TYPE_METHODS (t))\n+\terror (\"an anonymous union cannot have function members\");\n+\n       if (TYPE_FIELDS (t))\n \t{\n \t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n \t\t\t\t      NULL_TREE, NULL_TREE);\n \t  finish_anon_union (decl);\n \t}\n-      else\n-\terror (\"anonymous union cannot have a function member\");\n     }\n   else\n     {\n@@ -6525,7 +6532,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t    cp_error (\"storage size of `%D' isn't constant\", decl);\n \t}\n \n-      if (!DECL_EXTERNAL (decl) && TYPE_NEEDS_DESTRUCTOR (type))\n+      if (! DECL_EXTERNAL (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n+\t  /* Cleanups for static variables are handled by `finish_file'.  */\n+\t  && ! TREE_STATIC (decl))\n \t{\n \t  int yes = suspend_momentary ();\n \t  cleanup = maybe_build_cleanup (decl);\n@@ -7676,8 +7685,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t    ctype = cname;\n \t\t}\n \n-\t      if (ctype\n-\t\t  && TREE_OPERAND (decl, 1) == constructor_name_full (ctype))\n+\t      if (ctype && TREE_CODE (TREE_OPERAND (decl, 1)) == TYPE_DECL\n+\t\t  && ((DECL_NAME (TREE_OPERAND (decl, 1))\n+\t\t       == constructor_name_full (ctype))\n+\t\t      || (DECL_NAME (TREE_OPERAND (decl, 1))\n+\t\t\t  == constructor_name (ctype))))\n \t\tTREE_OPERAND (decl, 1) = constructor_name (ctype);\n \t      next = &TREE_OPERAND (decl, 1);\n \t      decl = *next;\n@@ -9030,6 +9042,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \n       if (decl_context == FIELD)\n \t{\n+\t  if (declarator == current_class_name)\n+\t    cp_pedwarn (\"ANSI C++ forbids nested type `%D' with same name as enclosing class\",\n+\t\t\tdeclarator);\n \t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n \t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n@@ -9064,6 +9079,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  error (\"non-object member `%s' cannot be declared mutable\", name);\n \t}\n \n+      bad_specifiers (decl, \"type\", virtualp, quals != NULL_TREE,\n+\t\t      inlinep, friendp, raises != NULL_TREE);\n+\n+      if (initialized)\n+\terror (\"typedef declaration includes an initializer\");\n+\n       return decl;\n     }\n \n@@ -10597,15 +10618,19 @@ start_enum (name)\n     enumtype = lookup_tag (ENUMERAL_TYPE, name, b, 1);\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n-    cp_error (\"multiple definition of enum `%T'\", enumtype);\n+    cp_error (\"multiple definition of `%#T'\", enumtype);\n   else\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n       pushtag (name, enumtype, 0);\n     }\n \n+  if (b->pseudo_global)\n+    cp_error (\"template declaration of `%#T'\", enumtype);\n+\n   if (current_class_type)\n     TREE_ADDRESSABLE (b->tags) = 1;\n+\n   current_local_enum = NULL_TREE;\n \n   /* We copy this value because enumerated type constants"}, {"sha": "652ed3ff0abb6a6563aea1984fdd8eb073eab346", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -34,6 +34,7 @@ typedef char* cp_printer ();\n #define L language_as_string\n #define O op_as_string\n #define P parm_as_string\n+#define Q assop_as_string\n #define T type_as_string\n #define V cv_as_string\n \n@@ -46,7 +47,7 @@ cp_printer * cp_printers[256] =\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x20 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x30 */\n   _, A, _, C, D, E, _, _, _, _, _, _, L, _, _, O, /* 0x40 */\n-  P, _, _, _, T, _, V, _, _, _, _, _, _, _, _, _, /* 0x50 */\n+  P, Q, _, _, T, _, V, _, _, _, _, _, _, _, _, _, /* 0x50 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x60 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x70 */\n };\n@@ -56,6 +57,7 @@ cp_printer * cp_printers[256] =\n #undef L\n #undef O\n #undef P\n+#undef Q\n #undef T\n #undef V\n #undef _\n@@ -1503,6 +1505,20 @@ op_as_string (p, v)\n   return buf;\n }\n \n+char *\n+assop_as_string (p, v)\n+     enum tree_code p;\n+     int v;\n+{\n+  static char buf[] = \"operator                \";\n+\n+  if (p == 0)\n+    return \"{unknown}\";\n+  \n+  strcpy (buf + 9, assignop_tab [p]);\n+  return buf;\n+}\n+\n char *\n args_as_string (p, v)\n      tree p;"}, {"sha": "b8d0dadde7a1817447c92a8539f0cbcff0213eac", "filename": "gcc/cp/init.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -2071,6 +2071,14 @@ resolve_offset_ref (exp)\n       addr = convert_pointer_to (basetype, addr);\n       member = convert (ptrdiff_type_node,\n \t\t\tbuild_unary_op (ADDR_EXPR, member, 0));\n+      \n+      /* Pointer to data mebers are offset by one, so that a null\n+\t pointer with a real value of 0 is distinguishable from an\n+\t offset of the first member of a structure.  */\n+      member = build_binary_op (MINUS_EXPR, member,\n+\t\t\t\tconvert (ptrdiff_type_node, integer_one_node),\n+\t\t\t\t0);\n+\n       return build1 (INDIRECT_REF, type,\n \t\t     build (PLUS_EXPR, build_pointer_type (type),\n \t\t\t    addr, member));\n@@ -3399,13 +3407,31 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    use_variable (DECL_RTL (base2));\n \t}\n       expand_end_loop ();\n-      if (TYPE_NEEDS_DESTRUCTOR (type))\n-\tend_protect (build_array_eh_cleanup (rval,\n-\t\t\t\t\t     build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t\t      maxindex,\n-\t\t\t\t\t\t\t      iterator,\n-\t\t\t\t\t\t\t      1),\n-\t\t\t\t\t     type));\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && flag_handle_exceptions)\n+\t{\n+\t  /* We have to ensure that this can live to the cleanup\n+\t     expansion time, since we know it is only ever needed\n+\t     once, generate code now.  */\n+\t  push_obstacks_nochange ();\n+\t  resume_temporary_allocation ();\n+\t  {\n+\t    tree e1, e2 = make_node (RTL_EXPR);\n+\t    TREE_TYPE (e2) = void_type_node;\n+\t    RTL_EXPR_RTL (e2) = const0_rtx;\n+\t    TREE_SIDE_EFFECTS (e2) = 1;\n+\t    start_sequence_for_rtl_expr (e2);\n+\n+\t    e1 = build_array_eh_cleanup\n+\t      (rval,\n+\t       build_binary_op (MINUS_EXPR, maxindex, iterator, 1),\n+\t       type);\n+\t    expand_expr (e1, const0_rtx, VOIDmode, 0);\n+\t    RTL_EXPR_SEQUENCE (e2) = get_insns ();\n+\t    end_sequence ();\n+\t    end_protect (e2);\n+\t  }\n+\t  pop_obstacks ();\n+\t}\n       expand_end_cond ();\n       if (obey_regdecls)\n \tuse_variable (DECL_RTL (iterator));"}, {"sha": "fa521a370f121cd839886296c7db697e3ed5ce9a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 94, "deletions": 18, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -210,7 +210,7 @@ empty_parms ()\n \n %type <ttype> structsp opt.component_decl_list component_decl_list\n %type <ttype> component_decl component_decl_1 components notype_components\n-%type <ttype> component_declarator component_declarator0\n+%type <ttype> component_declarator component_declarator0 self_reference\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n %type <ttype> enumlist enumerator\n@@ -231,7 +231,7 @@ empty_parms ()\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL\n %type <ttype> fn.def1 /* Not really! */\n-%type <ttype> fn.def2 return_id fn.defpen\n+%type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n %type <itype> ctor_initializer_opt\n %type <ttype> named_class_head named_class_head_sans_basetype\n %type <ttype> named_complex_class_head_sans_basetype\n@@ -551,6 +551,51 @@ fndef:\n \t\t{}\n \t;\n \n+constructor_declarator:\n+\t  nested_name_specifier type_name '(' \n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n+\t\t  if ($1 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($1, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n+\t  parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>4, $5, $7); }\n+\t| nested_name_specifier type_name LEFT_RIGHT type_quals\n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n+\t\t  if ($1 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($1, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $4);\n+\t\t}\n+\t| global_scope nested_name_specifier type_name '(' \n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n+\t\t  if ($2 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($2, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n+\t parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>5, $6, $8); }\n+\t| global_scope nested_name_specifier type_name LEFT_RIGHT type_quals\n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n+\t\t  if ($2 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($2, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $5);\n+\t\t}\n+\t;\n+\n fn.def1:\n \t  typed_declspecs declarator exception_specification_opt\n \t\t{ tree specs, attrs;\n@@ -571,20 +616,25 @@ fn.def1:\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n+\t| declmods constructor_declarator exception_specification_opt\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n+\t\t    YYERROR1;\n+\t\t  reinit_parse_for_function ();\n+\t\t  $$ = NULL_TREE; }\n+\t| constructor_declarator exception_specification_opt\n+\t\t{ if (! start_function (NULL_TREE, $$, $2, NULL_TREE, 0))\n+\t\t    YYERROR1;\n+\t\t  reinit_parse_for_function ();\n+\t\t  $$ = NULL_TREE; }\n \t;\n \n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n \t  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  if (TREE_VALUE (specs) == current_class_type)\n-\t\t    {\n-\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n-\t\t        specs = get_decl_list (current_class_name);\n-\t\t      else\n-\t\t        TREE_VALUE (specs) = current_class_name;\n-\t\t    } \n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs), $3, $5);\n \t\t  $$ = start_method (TREE_CHAIN (specs), $$, $6);\n \t\t rest_of_mdef:\n@@ -608,6 +658,11 @@ fn.def2:\n \t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n \t| notype_declarator exception_specification_opt\n \t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n+\t| declmods constructor_declarator exception_specification_opt\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n+\t| constructor_declarator exception_specification_opt\n+\t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n \t;\n \n return_id: RETURN IDENTIFIER\n@@ -726,13 +781,17 @@ explicit_instantiation:\n \t\t  do_function_instantiation (specs, $3, NULL_TREE); }\n \t| TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n+\t| TEMPLATE constructor_declarator\n+\t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n \t| SCSPEC TEMPLATE aggr template_type\n \t\t{ do_type_instantiation ($4, $1); }\n \t| SCSPEC TEMPLATE typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($3);\n \t\t  do_function_instantiation (specs, $4, $1); }\n \t| SCSPEC TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n+\t| SCSPEC TEMPLATE constructor_declarator\n+\t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n \t;\n \n /* The TYPENAME expansions are to deal with use of a template class name as\n@@ -2408,15 +2467,26 @@ left_curly: '{'\n \t\t}\n \t;\n \n+self_reference:\n+\t  /* empty */\n+\t\t{\n+\t\t  if (CLASSTYPE_TEMPLATE_INFO (current_class_type))\n+\t\t    $$ = NULL_TREE;\n+\t\t  else\n+\t\t    $$ = build_self_reference ();\n+\t\t}\n+\t;\n+\n opt.component_decl_list:\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| component_decl_list\n+\t  self_reference\n+\t\t{ if ($$) $$ = build_tree_list (access_public_node, $$); }\n+\t| self_reference component_decl_list\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n-\t\t    $$ = build_tree_list (access_public_node, $$);\n+\t\t    $$ = build_tree_list (access_public_node, $2);\n \t\t  else\n-\t\t    $$ = build_tree_list (access_default_node, $$);\n+\t\t    $$ = build_tree_list (access_default_node, $2);\n+\t\t  if ($1) $$ = tree_cons (access_public_node, $1, $$);\n \t\t}\n \t| opt.component_decl_list VISSPEC ':' component_decl_list\n \t\t{\n@@ -2488,6 +2558,9 @@ component_decl_1:\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,\n \t\t\t\t  build_tree_list ($4, NULL_TREE)); }\n+\t| constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, NULL_TREE)); }\n \t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n \t| error\n@@ -2597,6 +2670,12 @@ notype_component_declarator0:\n \t\t  $<ttype>0 = current_declspecs;\n \t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n \t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n+\t| constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n@@ -2781,7 +2860,7 @@ direct_after_type_declarator:\n \t| '(' after_type_declarator ')'\n \t\t{ $$ = $2; }\n \t| nested_name_specifier type_name %prec EMPTY\n-\t\t{ push_nested_class (TREE_TYPE ($$), 3);\n+\t\t{ push_nested_class ($1, 3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2);\n \t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n \t| type_name %prec EMPTY\n@@ -3694,9 +3773,6 @@ complex_parmlist:\n \t\t}\n \t| ELLIPSIS\n \t\t{\n-\t\t  /* ARM $8.2.5 has this as a boxed-off comment.  */\n-\t\t  if (pedantic)\n-\t\t    warning (\"use of `...' without a first argument is non-portable\");\n \t\t  $$ = NULL_TREE;\n \t\t}\n \t| TYPENAME_ELLIPSIS"}, {"sha": "c4b58a4789a77b5caae04e2444542e2dad95dc4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -114,9 +114,13 @@ process_template_parm (list, next)\n \t\t\t     PARM, 0, NULL_TREE, NULL_TREE);\n       /* A template parameter is not modifiable.  */\n       TREE_READONLY (parm) = 1;\n-      if (IS_AGGR_TYPE (TREE_TYPE (parm)))\n+      if (IS_AGGR_TYPE (TREE_TYPE (parm))\n+\t  && TREE_CODE (TREE_TYPE (parm)) != TEMPLATE_TYPE_PARM)\n \t{\n-\t  sorry (\"aggregate template parameter types\");\n+\t  cp_error (\"`%#T' is not a valid type for a template constant parameter\",\n+\t\t    TREE_TYPE (parm));\n+\t  if (DECL_NAME (parm) == NULL_TREE)\n+\t    error (\"  a template type parameter must begin with `class' or `typename'\");\n \t  TREE_TYPE (parm) = void_type_node;\n \t}\n       tinfo = make_node (TEMPLATE_CONST_PARM);\n@@ -235,8 +239,10 @@ push_template_decl (decl)\n       if (TREE_CODE (decl) == TYPE_DECL)\n \ttmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n       else if (! DECL_TEMPLATE_INFO (decl))\n-\t/* A member definition that doesn't match anything in the class.  */\n-\treturn;\n+\t{\n+\t  cp_error (\"template definition of non-template `%#D'\", decl);\n+\t  return;\n+\t}\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n     }\n@@ -609,6 +615,11 @@ lookup_template_class (d1, arglist, in_decl)\n       if (! template)\n \ttemplate = IDENTIFIER_CLASS_VALUE (d1);\n     }\n+  else if (TREE_CODE (d1) == TYPE_DECL && IS_AGGR_TYPE (TREE_TYPE (d1)))\n+    {\n+      template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d1));\n+      d1 = DECL_NAME (template);\n+    }\n   else if (TREE_CODE_CLASS (TREE_CODE (d1)) == 't' && IS_AGGR_TYPE (d1))\n     {\n       template = CLASSTYPE_TI_TEMPLATE (d1);\n@@ -2728,12 +2739,15 @@ do_function_instantiation (declspecs, declarator, storage)\n     }\n \n   /* If we've already seen this template instance, use it.  */\n-  if (name = DECL_ASSEMBLER_NAME (decl),\n-      fn = IDENTIFIER_GLOBAL_VALUE (name),\n-      fn && DECL_TEMPLATE_INSTANTIATION (fn))\n-    result = fn;\n-  else if (fn && DECL_CONTEXT (fn))\n-    ;\n+  if (DECL_FUNCTION_MEMBER_P (decl))\n+    {\n+      if (DECL_TEMPLATE_INSTANTIATION (decl))\n+\tresult = decl;\n+      else if (name = DECL_ASSEMBLER_NAME (decl),\n+\t       fn = IDENTIFIER_GLOBAL_VALUE (name),\n+\t       fn && DECL_TEMPLATE_INSTANTIATION (fn))\n+\tresult = fn;\n+    }\n   else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n     {\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n@@ -2779,10 +2793,10 @@ do_function_instantiation (declspecs, declarator, storage)\n     cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n \n-  if (! extern_p)\n-    instantiate_decl (result);\n   mark_decl_instantiated (result, extern_p);\n   repo_template_instantiated (result, extern_p);\n+  if (! extern_p)\n+    instantiate_decl (result);\n }\n \n void"}, {"sha": "05e757f50ee23f3d602be54271b153cd79426a3b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91a56d26688ad6ab041f1ba223a975692c9d8c3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c91a56d26688ad6ab041f1ba223a975692c9d8c3", "patch": "@@ -3999,6 +3999,13 @@ build_x_unary_op (code, xarg)\n \treturn build_opfncall (code, LOOKUP_NORMAL, xarg,\n \t\t\t       NULL_TREE, NULL_TREE);\n     }\n+\n+  if (code == ADDR_EXPR)\n+    {\n+      if (TREE_CODE (xarg) == TARGET_EXPR)\n+\twarning (\"taking address of temporary\");\n+    }\n+\n   return build_unary_op (code, xarg, 0);\n }\n \n@@ -4499,17 +4506,30 @@ unary_complex_lvalue (code, arg)\n \t\treturn error_mark_node;\n \t      }\n \n+\t  /* Add in the offset to the right subobject.  */\n \t  offset = get_delta_difference (DECL_FIELD_CONTEXT (t), \n \t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg, 0)),\n \t\t\t\t\t 0);\n+\n+\t  /* Add in the offset to the field.  */\n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       size_binop (EASY_DIV_EXPR,\n \t\t\t\t\t   DECL_FIELD_BITPOS (t),\n \t\t\t\t\t   size_int (BITS_PER_UNIT)));\n+\n+\t  /* We offset all pointer to data memebers by 1 so that we can\n+\t     distinguish between a null pointer to data member and the first\n+\t     data member of a structure.  */\n+\t  offset = size_binop (PLUS_EXPR, offset, size_int (1));\n+\n \t  return convert (build_pointer_type (TREE_TYPE (arg)), offset);\n \t}\n     }\n \n+  \n+#if 0\n+  /* This seems to be obsolete now (and posssibly wrong, compare with\n+     resolve_offset_ref).  */\n   if (TREE_CODE (arg) == OFFSET_REF)\n     {\n       tree left = TREE_OPERAND (arg, 0), left_addr;\n@@ -4530,6 +4550,7 @@ unary_complex_lvalue (code, arg)\n \t\t    build1 (NOP_EXPR, integer_type_node, left_addr),\n \t\t    build1 (NOP_EXPR, integer_type_node, right_addr));\n     }\n+#endif\n \n   /* We permit compiler to make function calls returning\n      objects of aggregate type look like lvalues.  */\n@@ -5558,7 +5579,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t}\n       else\n \t{\n-\t  cp_error (\"no match for `%O(%#T, %#T)'\", modifycode,\n+\t  cp_error (\"no match for `%Q(%#T, %#T)'\", modifycode,\n \t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t  return error_mark_node;\n \t}\n@@ -5567,6 +5588,12 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       lhs = stabilize_reference (lhs);\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n+      if (newrhs == error_mark_node)\n+\t{\n+\t  cp_error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n+\t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n+\t  return error_mark_node;\n+\t}\n     }\n \n   /* Handle a cast used as an \"lvalue\".\n@@ -6977,6 +7004,15 @@ c_expand_return (retval)\n \t  && !TREE_PUBLIC (whats_returned))\n \tcp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n     }\n+  else if (TREE_CODE (retval) == VAR_DECL)\n+    {\n+      if (TREE_CODE (TREE_TYPE (retval)) == ARRAY_TYPE\n+\t  && DECL_NAME (retval)\n+\t  && IDENTIFIER_LOCAL_VALUE (DECL_NAME (retval))\n+\t  && !TREE_STATIC (retval)\n+\t  && !TREE_PUBLIC (retval))\n+\tcp_warning_at (\"address of local array `%D' returned\", retval);\n+    }\n   \n   /* Now deal with possible C++ hair:\n      (1) Compute the return value."}]}