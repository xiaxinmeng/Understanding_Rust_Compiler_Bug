{"sha": "208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4Mzg0ZmRkMjdmYzFkMTVjN2JjMGJlOGMxZjRkOGNmOGNhNjYzNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-01-05T22:29:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-01-05T22:29:18Z"}, "message": "re PR target/42564 (unrecognizable insn with -O -fPIC)\n\n\tPR target/42564\n\t* config/sparc/sparc.h (SPARC_SYMBOL_REF_TLS_P): Delete.\n\t* config/sparc/sparc-protos.h (legitimize_pic_address): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t(sparc_tls_referenced_p): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_move): Use legitimize_tls_address\n\tand adjust calls to legitimize_pic_address.\n\t(legitimate_constant_p) Use sparc_tls_referenced_p.\n\t(legitimate_pic_operand_p): Likewise.\n\t(sparc_legitimate_address_p): Do not use SPARC_SYMBOL_REF_TLS_P.\n\t(sparc_tls_symbol_ref_1): Delete.\n\t(sparc_tls_referenced_p): Make static, recognize specific patterns.\n\t(legitimize_tls_address): Make static, handle CONST patterns.\n\t(legitimize_pic_address): Make static, remove unused parameter and\n\tadjust recursive calls.\n\t(sparc_legitimize_address): Make static, use sparc_tls_referenced_p\n\tand adjust call to legitimize_pic_address.\n\t(sparc_output_mi_thunk): Likewise.\n\nFrom-SVN: r155662", "tree": {"sha": "74ae2545069058553587b414ac1964dc1e6fce54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74ae2545069058553587b414ac1964dc1e6fce54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/comments", "author": null, "committer": null, "parents": [{"sha": "4396e06315f0fdd09acf6eedfa4ea913b7106e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4396e06315f0fdd09acf6eedfa4ea913b7106e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4396e06315f0fdd09acf6eedfa4ea913b7106e96"}], "stats": {"total": 177, "additions": 102, "deletions": 75}, "files": [{"sha": "40a277b119d949cbf17d0bb78b5b656e0ec359ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -1,3 +1,24 @@\n+2010-01-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/42564\n+\t* config/sparc/sparc.h (SPARC_SYMBOL_REF_TLS_P): Delete.\n+\t* config/sparc/sparc-protos.h (legitimize_pic_address): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t(sparc_tls_referenced_p): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_move): Use legitimize_tls_address\n+\tand adjust calls to legitimize_pic_address.\n+\t(legitimate_constant_p) Use sparc_tls_referenced_p.\n+\t(legitimate_pic_operand_p): Likewise.\n+\t(sparc_legitimate_address_p): Do not use SPARC_SYMBOL_REF_TLS_P.\n+\t(sparc_tls_symbol_ref_1): Delete.\n+\t(sparc_tls_referenced_p): Make static, recognize specific patterns.\n+\t(legitimize_tls_address): Make static, handle CONST patterns.\n+\t(legitimize_pic_address): Make static, remove unused parameter and\n+\tadjust recursive calls.\n+\t(sparc_legitimize_address): Make static, use sparc_tls_referenced_p\n+\tand adjust call to legitimize_pic_address.\n+\t(sparc_output_mi_thunk): Likewise.\n+\n 2010-01-05  Paolo Bonzini  <bonzinI@gnu.rg>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "b76e45b433a3107c9c45289b7756c60c6d6c3725", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -64,8 +64,6 @@ extern void emit_tfmode_cvt (enum rtx_code, rtx *);\n extern bool legitimate_constant_p (rtx);\n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n-extern rtx legitimize_tls_address (rtx);\n extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (enum machine_mode, rtx *);\n@@ -97,7 +95,6 @@ extern int emit_move_sequence (rtx, enum machine_mode);\n extern int fp_sethi_p (rtx);\n extern int fp_mov_p (rtx);\n extern int fp_high_losum_p (rtx);\n-extern bool sparc_tls_referenced_p (rtx);\n extern int mem_min_alignment (rtx, int);\n extern int pic_address_needs_scratch (rtx);\n extern int reg_unused_after (rtx, rtx);"}, {"sha": "4b904b4535236332a3bdd54bfb8c3a7360470d6e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -411,6 +411,9 @@ static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n static void sparc_va_start (tree, rtx);\n static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n+static bool sparc_tls_referenced_p (rtx);\n+static rtx legitimize_tls_address (rtx);\n+static rtx legitimize_pic_address (rtx, rtx);\n static rtx sparc_legitimize_address (rtx, rtx, enum machine_mode);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, const_tree, bool);\n@@ -992,34 +995,17 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n   /* Fixup TLS cases.  */\n   if (TARGET_HAVE_TLS\n       && CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != HIGH\n       && sparc_tls_referenced_p (operands [1]))\n     {\n-      rtx sym = operands[1];\n-      rtx addend = NULL;\n-\n-      if (GET_CODE (sym) == CONST && GET_CODE (XEXP (sym, 0)) == PLUS)\n-\t{\n-\t  addend = XEXP (XEXP (sym, 0), 1);\n-\t  sym = XEXP (XEXP (sym, 0), 0);\n-\t}\n-\n-      gcc_assert (SPARC_SYMBOL_REF_TLS_P (sym));\n-\n-      sym = legitimize_tls_address (sym);\n-      if (addend)\n-\t{\n-\t  sym = gen_rtx_PLUS (mode, sym, addend);\n-\t  sym = force_operand (sym, operands[0]);\n-\t}\n-      operands[1] = sym;\n+      operands[1] = legitimize_tls_address (operands[1]);\n+      return false;\n     }\n \n   /* Fixup PIC cases.  */\n   if (flag_pic && CONSTANT_P (operands[1]))\n     {\n       if (pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], mode, 0);\n+\toperands[1] = legitimize_pic_address (operands[1], NULL_RTX);\n \n       /* VxWorks does not impose a fixed gap between segments; the run-time\n \t gap can be different from the object-file gap.  We therefore can't\n@@ -1047,10 +1033,8 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       if (symbolic_operand (operands[1], mode))\n \t{\n \t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tmode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n+\t\t\t\t\t\treload_in_progress\n+\t\t\t\t\t\t? operands[0] : NULL_RTX);\n \t  return false;\n \t}\n     }\n@@ -2979,23 +2963,11 @@ pic_address_needs_scratch (rtx x)\n bool\n legitimate_constant_p (rtx x)\n {\n-  rtx inner;\n-\n   switch (GET_CODE (x))\n     {\n-    case SYMBOL_REF:\n-      /* TLS symbols are not constant.  */\n-      if (SYMBOL_REF_TLS_MODEL (x))\n-\treturn false;\n-      break;\n-\n     case CONST:\n-      inner = XEXP (x, 0);\n-\n-      /* Offsets of TLS symbols are never valid.\n-\t Discourage CSE from creating them.  */\n-      if (GET_CODE (inner) == PLUS\n-\t  && SPARC_SYMBOL_REF_TLS_P (XEXP (inner, 0)))\n+    case SYMBOL_REF:\n+      if (sparc_tls_referenced_p (x))\n \treturn false;\n       break;\n \n@@ -3062,10 +3034,7 @@ legitimate_pic_operand_p (rtx x)\n {\n   if (pic_address_needs_scratch (x))\n     return false;\n-  if (SPARC_SYMBOL_REF_TLS_P (x)\n-      || (GET_CODE (x) == CONST\n-\t  && GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && SPARC_SYMBOL_REF_TLS_P (XEXP (XEXP (x, 0), 0))))\n+  if (sparc_tls_referenced_p (x))\n     return false;\n   return true;\n }\n@@ -3103,7 +3072,7 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n \t   && GET_CODE (rs2) != SUBREG\n \t   && GET_CODE (rs2) != LO_SUM\n \t   && GET_CODE (rs2) != MEM\n-\t   && ! SPARC_SYMBOL_REF_TLS_P (rs2)\n+\t   && !(GET_CODE (rs2) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs2))\n \t   && (! symbolic_operand (rs2, VOIDmode) || mode == Pmode)\n \t   && (GET_CODE (rs2) != CONST_INT || SMALL_INT (rs2)))\n \t  || ((REG_P (rs1)\n@@ -3143,7 +3112,8 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n \t  rs2 = NULL;\n \t  imm1 = XEXP (rs1, 1);\n \t  rs1 = XEXP (rs1, 0);\n-\t  if (! CONSTANT_P (imm1) || SPARC_SYMBOL_REF_TLS_P (rs1))\n+\t  if (!CONSTANT_P (imm1)\n+\t      || (GET_CODE (rs1) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs1)))\n \t    return 0;\n \t}\n     }\n@@ -3152,7 +3122,8 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n       rs1 = XEXP (addr, 0);\n       imm1 = XEXP (addr, 1);\n \n-      if (! CONSTANT_P (imm1) || SPARC_SYMBOL_REF_TLS_P (rs1))\n+      if (!CONSTANT_P (imm1)\n+\t  || (GET_CODE (rs1) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs1)))\n \treturn 0;\n \n       /* We can't allow TFmode in 32-bit mode, because an offset greater\n@@ -3228,29 +3199,28 @@ sparc_tls_got (void)\n   return temp;\n }\n \n-/* Return 1 if *X is a thread-local symbol.  */\n-\n-static int\n-sparc_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n-{\n-  return SPARC_SYMBOL_REF_TLS_P (*x);\n-}\n-\n-/* Return 1 if X contains a thread-local symbol.  */\n+/* Return true if X contains a thread-local symbol.  */\n \n-bool\n+static bool\n sparc_tls_referenced_p (rtx x)\n {\n   if (!TARGET_HAVE_TLS)\n     return false;\n \n-  return for_each_rtx (&x, &sparc_tls_symbol_ref_1, 0);\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)\n+    x = XEXP (XEXP (x, 0), 0);\n+\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x))\n+    return true;\n+\n+  /* That's all we handle in legitimize_tls_address for now.  */\n+  return false;\n }\n \n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n    this (thread-local) address.  */\n \n-rtx\n+static rtx\n legitimize_tls_address (rtx addr)\n {\n   rtx temp1, temp2, temp3, ret, o0, got, insn;\n@@ -3374,21 +3344,34 @@ legitimize_tls_address (rtx addr)\n \tgcc_unreachable ();\n       }\n \n+  else if (GET_CODE (addr) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      gcc_assert (GET_CODE (XEXP (addr, 0)) == PLUS);\n+\n+      base = legitimize_tls_address (XEXP (XEXP (addr, 0), 0));\n+      offset = XEXP (XEXP (addr, 0), 1);\n+\n+      base = force_operand (base, NULL_RTX);\n+      if (!(GET_CODE (offset) == CONST_INT && SMALL_INT (offset)))\n+\toffset = force_reg (Pmode, offset);\n+      ret = gen_rtx_PLUS (Pmode, base, offset);\n+    }\n+\n   else\n     gcc_unreachable ();  /* for now ... */\n \n   return ret;\n }\n \n-\n /* Legitimize PIC addresses.  If the address is already position-independent,\n    we return ORIG.  Newly generated position-independent addresses go into a\n    reg.  This is REG if nonzero, otherwise we allocate register(s) as\n    necessary.  */\n \n-rtx\n-legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\trtx reg)\n+static rtx\n+legitimize_pic_address (rtx orig, rtx reg)\n {\n   if (GET_CODE (orig) == SYMBOL_REF\n       /* See the comment in sparc_expand_move.  */\n@@ -3455,9 +3438,9 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t}\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n-      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t \t       base == reg ? 0 : reg);\n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), reg);\n+      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n+\t\t\t \t       base == reg ? NULL_RTX : reg);\n \n       if (GET_CODE (offset) == CONST_INT)\n \t{\n@@ -3490,7 +3473,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n    On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n \n-rtx\n+static rtx\n sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode mode)\n {\n@@ -3512,10 +3495,10 @@ sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   if (x != orig_x && sparc_legitimate_address_p (mode, x, FALSE))\n     return x;\n \n-  if (SPARC_SYMBOL_REF_TLS_P (x))\n+  if (sparc_tls_referenced_p (x))\n     x = legitimize_tls_address (x);\n   else if (flag_pic)\n-    x = legitimize_pic_address (x, mode, 0);\n+    x = legitimize_pic_address (x, NULL_RTX);\n   else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 1)))\n     x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t      copy_to_mode_reg (Pmode, XEXP (x, 1)));\n@@ -3524,8 +3507,9 @@ sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t      copy_to_mode_reg (Pmode, XEXP (x, 0)));\n   else if (GET_CODE (x) == SYMBOL_REF\n \t   || GET_CODE (x) == CONST\n-           || GET_CODE (x) == LABEL_REF)\n+\t   || GET_CODE (x) == LABEL_REF)\n     x = copy_to_suggested_reg (x, NULL_RTX, Pmode);\n+\n   return x;\n }\n \n@@ -8899,7 +8883,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  /* Delay emitting the PIC helper function because it needs to\n \t     change the section and we are emitting assembly code.  */\n \t  load_pic_register (true);  /* clobbers %o7 */\n-\t  scratch = legitimize_pic_address (funexp, Pmode, scratch);\n+\t  scratch = legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n \t  end_sequence ();\n \t  emit_and_preserve (seq, spill_reg, spill_reg2);"}, {"sha": "344441e1bcb69316e76c10d8dc28cef491f2ab65", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -2213,9 +2213,6 @@ extern int sparc_indent_opcode;\n       }\t\t\t\t\t\\\n   } while (0)\n \n-#define SPARC_SYMBOL_REF_TLS_P(RTX) \\\n-  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n-\n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n   ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '('\t\t\\\n    || (CHAR) == ')' || (CHAR) == '_' || (CHAR) == '&')"}, {"sha": "4f6aa65250da22bee65a5654bd6f5d289a394b5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -1,3 +1,7 @@\n+2010-01-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/tls/opt-15.c: New test.\n+\n 2010-01-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/pr42542-1.c (res): Make it 8 elements."}, {"sha": "bebee8a499f571ceefc1e9445c1153004c4ac520", "filename": "gcc/testsuite/gcc.dg/tls/opt-15.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c?ref=208384fdd27fc1d15c7bc0be8c1f4d8cf8ca6637", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/42564 */\n+/* This used to ICE on the SPARC because of an unrecognized TLS pattern.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fPIC\" } */\n+/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target fpic } */\n+\n+extern void *memset(void *s, int c, __SIZE_TYPE__ n);\n+\n+struct S1 { int i; };\n+\n+struct S2\n+{\n+  int ver;\n+  struct S1 s;\n+};\n+\n+static __thread struct S2 m;\n+\n+void init(void)\n+{\n+  memset(&m.s, 0, sizeof(m.s));\n+}"}]}