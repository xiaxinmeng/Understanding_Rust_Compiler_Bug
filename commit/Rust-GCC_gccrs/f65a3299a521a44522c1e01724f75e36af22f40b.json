{"sha": "f65a3299a521a44522c1e01724f75e36af22f40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1YTMyOTlhNTIxYTQ0NTIyYzFlMDE3MjRmNzVlMzZhZjIyZjQwYg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-21T13:03:43Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-21T13:03:43Z"}, "message": "c++: template instantiation during fold_for_warn [PR94038]\n\nUnfortunately, the previous fix to PR94038 is fragile.  When the\nargument to fold_for_warn is a bare CALL_EXPR, then all is well: the\nresult of maybe_constant_value from fold_for_warn (with\nuid_sensitive=true) is reused via the cv_cache in the subsequent call to\nmaybe_constant_value from cp_fold (with uid_sensitive=false), so we\navoid instantiating bar<int>.\n\nBut when the argument to fold_for_warn is more complex, e.g. an\nINDIRECT_REF of a CALL_EXPR, as in the testcase below (due to bar<int>()\nreturning const int& which we need to decay to int) then from\nfold_for_warn we call maybe_constant_value on the INDIRECT_REF, and from\ncp_fold we call it on the CALL_EXPR, so there is no reuse via the\ncv_cache and we therefore end up instantiating bar<int>.\n\nSo for a more robust solution to this general issue of warning flags\naffecting code generation, it seems that we need a way to globally avoid\ntemplate instantiation during constexpr evaluation whenever we're\nperforming warning-dependent folding.\n\nTo that end, this patch replaces the flag constexpr_ctx::uid_sensitive\nwith a global flag uid_sensitive_constexpr_evaluation_p, and enables it\nduring fold_for_warn using an RAII helper.\n\nThe patch also adds a counter that keeps track of the number of times\nuid_sensitive_constexpr_evaluation_p is called and returned true, and we\nuse this to determine whether the result of constexpr evaluation\nwas restricted by the flag.  This lets us safely update the cv_cache and\nfold_cache from fold_for_warn in the most common case where the flag\ndid not restrict constexpr evaluation.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94038\n\t* constexpr.c (constexpr_ctx::uid_sensitive): Remove field.\n\t(uid_sensitive_constexpr_evaluation_value): Define.\n\t(uid_sensitive_constexpr_evaluation_true_counter): Define.\n\t(uid_sensitive_constexpr_evaluation_p): Define.\n\t(uid_sensitive_constexpr_evaluation_sentinel): Define its\n\tconstructor.\n\t(uid_sensitive_constexpr_evaluation_checker): Define its\n\tconstructor and its evaluation_restricted_p method.\n\t(get_fundef_copy): Remove 'ctx' parameter.  Use u_s_c_e_p\n\tinstead of constexpr_ctx::uid_sensitive.\n\t(cxx_eval_call_expression): Use u_s_c_e_p instead, and test it\n\tlast.  Adjust call to get_fundef_copy.\n\t(instantiate_cx_fn_r): Test u_s_c_e_p so that we increment the\n\tcounter if necessary.\n\t(cxx_eval_outermost_constant_expr): Remove 'uid_sensitive'\n\tparameter.  Adjust function body accordingly.\n\t(maybe_constant_value): Remove 'uid_sensitive' parameter and\n\tadjust function body accordingly.  Set up a\n\tuid_sensitive_constexpr_evaluation_checker, and use it to\n\tconditionally update the cv_cache.\n\t* cp-gimplify.c (cp_fold): Set up a\n\tuid_sensitive_constexpr_evaluation_checker, and use it to\n\tconditionally update the fold_cache.\n\t* cp-tree.h (maybe_constant_value): Update declaration.\n\t(struct uid_sensitive_constexpr_evaluation_sentinel): Define.\n\t(struct sensitive_constexpr_evaluation_checker): Define.\n\t* expr.c (fold_for_warn): Set up a\n\tuid_sensitive_constexpr_evaluation_sentinel before calling\n\tthe folding subroutines.  Drop all but the first argument to\n\tmaybe_constant_value.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94038\n\t* g++.dg/warn/pr94038-2.C: New test.", "tree": {"sha": "5b3d9e479413cd1aef174c8929ed8cf8f5936c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b3d9e479413cd1aef174c8929ed8cf8f5936c28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65a3299a521a44522c1e01724f75e36af22f40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65a3299a521a44522c1e01724f75e36af22f40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65a3299a521a44522c1e01724f75e36af22f40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65a3299a521a44522c1e01724f75e36af22f40b/comments", "author": null, "committer": null, "parents": [{"sha": "5855bdfa06fb25c0880af89cb2bfdcdf342beac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5855bdfa06fb25c0880af89cb2bfdcdf342beac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5855bdfa06fb25c0880af89cb2bfdcdf342beac2"}], "stats": {"total": 210, "additions": 180, "deletions": 30}, "files": [{"sha": "385bfcd72db4103aaaa47f3673a041befb5dde33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -1,3 +1,37 @@\n+2020-05-21  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94038\n+\t* constexpr.c (constexpr_ctx::uid_sensitive): Remove field.\n+\t(uid_sensitive_constexpr_evaluation_value): Define.\n+\t(uid_sensitive_constexpr_evaluation_true_counter): Define.\n+\t(uid_sensitive_constexpr_evaluation_p): Define.\n+\t(uid_sensitive_constexpr_evaluation_sentinel): Define its\n+\tconstructor.\n+\t(uid_sensitive_constexpr_evaluation_checker): Define its\n+\tconstructor and its evaluation_restricted_p method.\n+\t(get_fundef_copy): Remove 'ctx' parameter.  Use u_s_c_e_p\n+\tinstead of constexpr_ctx::uid_sensitive.\n+\t(cxx_eval_call_expression): Use u_s_c_e_p instead, and test it\n+\tlast.  Adjust call to get_fundef_copy.\n+\t(instantiate_cx_fn_r): Test u_s_c_e_p so that we increment the\n+\tcounter if necessary.\n+\t(cxx_eval_outermost_constant_expr): Remove 'uid_sensitive'\n+\tparameter.  Adjust function body accordingly.\n+\t(maybe_constant_value): Remove 'uid_sensitive' parameter and\n+\tadjust function body accordingly.  Set up a\n+\tuid_sensitive_constexpr_evaluation_checker, and use it to\n+\tconditionally update the cv_cache.\n+\t* cp-gimplify.c (cp_fold): Set up a\n+\tuid_sensitive_constexpr_evaluation_checker, and use it to\n+\tconditionally update the fold_cache.\n+\t* cp-tree.h (maybe_constant_value): Update declaration.\n+\t(struct uid_sensitive_constexpr_evaluation_sentinel): Define.\n+\t(struct sensitive_constexpr_evaluation_checker): Define.\n+\t* expr.c (fold_for_warn): Set up a\n+\tuid_sensitive_constexpr_evaluation_sentinel before calling\n+\tthe folding subroutines.  Drop all but the first argument to\n+\tmaybe_constant_value.\n+\n 2020-05-20  Marek Polacek  <polacek@redhat.com>\n \n \tDR 2237"}, {"sha": "c1ab9288f72eeb55d15df2dfde9b40007a377cf9", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 76, "deletions": 24, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -1089,11 +1089,67 @@ struct constexpr_ctx {\n   bool strict;\n   /* Whether __builtin_is_constant_evaluated () should be true.  */\n   bool manifestly_const_eval;\n-  /* Whether we want to avoid doing anything that will cause extra DECL_UID\n-     generation.  */\n-  bool uid_sensitive;\n };\n \n+/* This internal flag controls whether we should avoid doing anything during\n+   constexpr evaluation that would cause extra DECL_UID generation, such as\n+   template instantiation and function body copying.  */\n+\n+static bool uid_sensitive_constexpr_evaluation_value;\n+\n+/* An internal counter that keeps track of the number of times\n+   uid_sensitive_constexpr_evaluation_p returned true.  */\n+\n+static unsigned uid_sensitive_constexpr_evaluation_true_counter;\n+\n+/* The accessor for uid_sensitive_constexpr_evaluation_value which also\n+   increments the corresponding counter.  */\n+\n+static bool\n+uid_sensitive_constexpr_evaluation_p ()\n+{\n+  if (uid_sensitive_constexpr_evaluation_value)\n+    {\n+      ++uid_sensitive_constexpr_evaluation_true_counter;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* The default constructor for uid_sensitive_constexpr_evaluation_sentinel\n+   enables the internal flag for uid_sensitive_constexpr_evaluation_p\n+   during the lifetime of the sentinel object.  Upon its destruction, the\n+   previous value of uid_sensitive_constexpr_evaluation_p is restored.  */\n+\n+uid_sensitive_constexpr_evaluation_sentinel\n+::uid_sensitive_constexpr_evaluation_sentinel ()\n+  : ovr (uid_sensitive_constexpr_evaluation_value, true)\n+{\n+}\n+\n+/* The default constructor for uid_sensitive_constexpr_evaluation_checker\n+   records the current number of times that uid_sensitive_constexpr_evaluation_p\n+   has been called and returned true.  */\n+\n+uid_sensitive_constexpr_evaluation_checker\n+::uid_sensitive_constexpr_evaluation_checker ()\n+  : saved_counter (uid_sensitive_constexpr_evaluation_true_counter)\n+{\n+}\n+\n+/* Returns true iff uid_sensitive_constexpr_evaluation_p is true, and\n+   some constexpr evaluation was restricted due to u_s_c_e_p being called\n+   and returning true during the lifetime of this checker object.  */\n+\n+bool\n+uid_sensitive_constexpr_evaluation_checker::evaluation_restricted_p () const\n+{\n+  return (uid_sensitive_constexpr_evaluation_value\n+\t  && saved_counter != uid_sensitive_constexpr_evaluation_true_counter);\n+}\n+\n+\n /* A table of all constexpr calls that have been evaluated by the\n    compiler in this translation unit.  */\n \n@@ -1156,7 +1212,7 @@ static GTY(()) hash_map<tree, tree> *fundef_copies_table;\n    is parms, TYPE is result.  */\n \n static tree\n-get_fundef_copy (const constexpr_ctx *ctx, constexpr_fundef *fundef)\n+get_fundef_copy (constexpr_fundef *fundef)\n {\n   tree copy;\n   bool existed;\n@@ -1173,7 +1229,7 @@ get_fundef_copy (const constexpr_ctx *ctx, constexpr_fundef *fundef)\n     }\n   else if (*slot == NULL_TREE)\n     {\n-      if (ctx->uid_sensitive)\n+      if (uid_sensitive_constexpr_evaluation_p ())\n \treturn NULL_TREE;\n \n       /* We've already used the function itself, so make a copy.  */\n@@ -2292,8 +2348,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \n   /* We can't defer instantiating the function any longer.  */\n   if (!DECL_INITIAL (fun)\n-      && !ctx->uid_sensitive\n-      && DECL_TEMPLOID_INSTANTIATION (fun))\n+      && DECL_TEMPLOID_INSTANTIATION (fun)\n+      && !uid_sensitive_constexpr_evaluation_p ())\n     {\n       location_t save_loc = input_location;\n       input_location = loc;\n@@ -2454,7 +2510,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (at_eof >= 2 && ctx->quiet);\n \t  *non_constant_p = true;\n \t}\n-      else if (tree copy = get_fundef_copy (ctx, new_call.fundef))\n+      else if (tree copy = get_fundef_copy (new_call.fundef))\n \t{\n \t  tree body, parms, res;\n \t  releasing_vec ctors;\n@@ -6485,7 +6541,8 @@ instantiate_cx_fn_r (tree *tp, int *walk_subtrees, void */*data*/)\n       && DECL_DECLARED_CONSTEXPR_P (*tp)\n       && !DECL_INITIAL (*tp)\n       && !trivial_fn_p (*tp)\n-      && DECL_TEMPLOID_INSTANTIATION (*tp))\n+      && DECL_TEMPLOID_INSTANTIATION (*tp)\n+      && !uid_sensitive_constexpr_evaluation_p ())\n     {\n       ++function_depth;\n       instantiate_decl (*tp, /*defer_ok*/false, /*expl_inst*/false);\n@@ -6552,8 +6609,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n \t\t\t\t  bool manifestly_const_eval = false,\n \t\t\t\t  bool constexpr_dtor = false,\n-\t\t\t\t  tree object = NULL_TREE,\n-\t\t\t\t  bool uid_sensitive = false)\n+\t\t\t\t  tree object = NULL_TREE)\n {\n   auto_timevar time (TV_CONSTEXPR);\n \n@@ -6569,8 +6625,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   constexpr_global_ctx global_ctx;\n   constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n-\t\t\tmanifestly_const_eval || !allow_non_constant,\n-\t\t\tuid_sensitive };\n+\t\t\tmanifestly_const_eval || !allow_non_constant };\n \n   tree type = initialized_type (t);\n   tree r = t;\n@@ -6660,8 +6715,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   auto_vec<tree, 16> cleanups;\n   global_ctx.cleanups = &cleanups;\n \n-  if (!uid_sensitive)\n-    instantiate_constexpr_fns (r);\n+  instantiate_constexpr_fns (r);\n   r = cxx_eval_constant_expression (&ctx, r,\n \t\t\t\t    false, &non_constant_p, &overflow_p);\n \n@@ -6909,14 +6963,12 @@ fold_simple (tree t)\n    Otherwise, if T does not have TREE_CONSTANT set, returns T.\n    Otherwise, returns a version of T without TREE_CONSTANT.\n    MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated\n-   as per P0595.  UID_SENSITIVE is true if we can't do anything that\n-   would affect DECL_UID ordering.  */\n+   as per P0595.  */\n \n static GTY((deletable)) hash_map<tree, tree> *cv_cache;\n \n tree\n-maybe_constant_value (tree t, tree decl, bool manifestly_const_eval,\n-\t\t      bool uid_sensitive)\n+maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n {\n   tree r;\n \n@@ -6934,8 +6986,7 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval,\n     return t;\n \n   if (manifestly_const_eval)\n-    return cxx_eval_outermost_constant_expr (t, true, true, true, false,\n-\t\t\t\t\t     decl, uid_sensitive);\n+    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n \n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n@@ -6950,14 +7001,15 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval,\n       return r;\n     }\n \n-  r = cxx_eval_outermost_constant_expr (t, true, true, false, false,\n-\t\t\t\t\tdecl, uid_sensitive);\n+  uid_sensitive_constexpr_evaluation_checker c;\n+  r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);\n   gcc_checking_assert (r == t\n \t\t       || CONVERT_EXPR_P (t)\n \t\t       || TREE_CODE (t) == VIEW_CONVERT_EXPR\n \t\t       || (TREE_CONSTANT (t) && !TREE_CONSTANT (r))\n \t\t       || !cp_tree_equal (r, t));\n-  cv_cache->put (t, r);\n+  if (!c.evaluation_restricted_p ())\n+    cv_cache->put (t, r);\n   return r;\n }\n "}, {"sha": "2804958c2464667f288a044bd24ea38c41c36a1c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -2447,6 +2447,8 @@ cp_fold (tree x)\n   if (tree *cached = fold_cache->get (x))\n     return *cached;\n \n+  uid_sensitive_constexpr_evaluation_checker c;\n+\n   code = TREE_CODE (x);\n   switch (code)\n     {\n@@ -2929,10 +2931,13 @@ cp_fold (tree x)\n       return org_x;\n     }\n \n-  fold_cache->put (org_x, x);\n-  /* Prevent that we try to fold an already folded result again.  */\n-  if (x != org_x)\n-    fold_cache->put (x, x);\n+  if (!c.evaluation_restricted_p ())\n+    {\n+      fold_cache->put (org_x, x);\n+      /* Prevent that we try to fold an already folded result again.  */\n+      if (x != org_x)\n+\tfold_cache->put (x, x);\n+    }\n \n   return x;\n }"}, {"sha": "07c16144c988470468031aa21f63849267543890", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -7950,7 +7950,7 @@ extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false, bool = false);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,\n@@ -7969,6 +7969,27 @@ extern tree fold_sizeof_expr\t\t\t(tree);\n extern void clear_cv_and_fold_caches\t\t(bool = true);\n extern tree unshare_constructor\t\t\t(tree CXX_MEM_STAT_INFO);\n \n+/* An RAII sentinel used to restrict constexpr evaluation so that it\n+   doesn't do anything that causes extra DECL_UID generation.  */\n+\n+struct uid_sensitive_constexpr_evaluation_sentinel\n+{\n+  temp_override<bool> ovr;\n+  uid_sensitive_constexpr_evaluation_sentinel ();\n+};\n+\n+/* Used to determine whether uid_sensitive_constexpr_evaluation_p was\n+   called and returned true, indicating that we've restricted constexpr\n+   evaluation in order to avoid UID generation.  We use this to control\n+   updates to the fold_cache and cv_cache.  */\n+\n+struct uid_sensitive_constexpr_evaluation_checker\n+{\n+  const unsigned saved_counter;\n+  uid_sensitive_constexpr_evaluation_checker ();\n+  bool evaluation_restricted_p () const;\n+};\n+\n /* In cp-ubsan.c */\n extern void cp_ubsan_maybe_instrument_member_call (tree);\n extern void cp_ubsan_instrument_member_accesses (tree *);"}, {"sha": "a6ab96af614edd6ecc0f12ef8ed92626520d1e54", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -399,6 +399,11 @@ fold_for_warn (tree x)\n {\n   /* C++ implementation.  */\n \n+  /* Prevent warning-dependent constexpr evaluation from changing\n+     DECL_UID (which breaks -fcompare-debug) and from instantiating\n+     templates.  */\n+  uid_sensitive_constexpr_evaluation_sentinel s;\n+\n   /* It's not generally safe to fully fold inside of a template, so\n      call fold_non_dependent_expr instead.  */\n   if (processing_template_decl)\n@@ -410,7 +415,7 @@ fold_for_warn (tree x)\n \treturn f;\n     }\n   else if (cxx_dialect >= cxx11)\n-    x = maybe_constant_value (x, NULL_TREE, false, true);\n+    x = maybe_constant_value (x);\n \n   return c_fully_fold (x, /*for_init*/false, /*maybe_constp*/NULL);\n }"}, {"sha": "6de0c5e89235f54dbdfb9d0b939766b2a1132411", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -1,3 +1,8 @@\n+2020-05-21  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94038\n+\t* g++.dg/warn/pr94038-2.C: New test.\n+\n 2020-05-21  Martin Liska  <mliska@suse.cz>\n \n \tPR target/95229"}, {"sha": "a468cc055ebf6343a713f450a1eb81e7c8356c7e", "filename": "gcc/testsuite/g++.dg/warn/pr94038-2.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr94038-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65a3299a521a44522c1e01724f75e36af22f40b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr94038-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr94038-2.C?ref=f65a3299a521a44522c1e01724f75e36af22f40b", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/94038\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-O -Wall\" }\n+\n+static constexpr int x = 0;\n+\n+template<typename T>\n+constexpr const int&\n+foo()\n+{\n+  static_assert(T(1) == 0, \"\");\n+  return x;\n+}\n+\n+template<typename T>\n+constexpr const int&\n+bar()\n+{\n+  return foo<T>();\n+}\n+\n+constexpr int\n+baz(int a)\n+{\n+  return a;\n+}\n+\n+static_assert(decltype(baz(bar<int>())){} == 0, \"\");"}]}