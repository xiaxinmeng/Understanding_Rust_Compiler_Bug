{"sha": "61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4OTBmZjI1YTI0YjJkZGIyODljNjFjMWU1ZmJjYWU2ZjlmNjEzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-05-22T09:35:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-22T09:35:21Z"}, "message": "ipa-inline-analysis.c (account_size_time): Rename to ...\n\n\t* ipa-inline-analysis.c (account_size_time): Rename to ...\n\t(inline_summary::account_size_time): ... this one.\n\t(reset_ipa_call_summary): Turn to ...\n\t(ipa_call_summary::reset): ... this one.\n\t(reset_inline_summary): Turn to ...\n\t(inline_summary::reset): ... this one.\n\t(inline_summary_t::remove): Update.\n\t(inline_summary_t::duplicate): Update.\n\t(ipa_call_summary_t::remove): Update.\n\t(dump_inline_summary): Update.\n\t(estimate_function_body_sizes): Update.\n\t(compute_inline_parameters): Update.\n\t(estimate_node_size_and_time): Update.\n\t(inline_merge_summary): Update.\n\t(inline_update_overall_summary): Update.\n\t(inline_read_section): Update.\n\t(inline_write_summary): Update.\n\t* ipa-inline.h (inline_summary): Rename entry to size_time_table;\n\tadd account_size_time and reset member functions.\n\t(ipa_call_summary): Add reset function.\n\t* ipa-predicate.h (predicate::operator &): Constify.\n\nFrom-SVN: r248322", "tree": {"sha": "525488f8dbeb5ee3c5f2b06e394978eebce3b4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/525488f8dbeb5ee3c5f2b06e394978eebce3b4a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/comments", "author": null, "committer": null, "parents": [{"sha": "d327113612c1b089eee87f04cd517b7f7103c1ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d327113612c1b089eee87f04cd517b7f7103c1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d327113612c1b089eee87f04cd517b7f7103c1ea"}], "stats": {"total": 213, "additions": 121, "deletions": 92}, "files": [{"sha": "8d57bcf020a169d010617fb6280fe72bccdea5cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "patch": "@@ -1,3 +1,27 @@\n+2017-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (account_size_time): Rename to ...\n+\t(inline_summary::account_size_time): ... this one.\n+\t(reset_ipa_call_summary): Turn to ...\n+\t(ipa_call_summary::reset): ... this one.\n+\t(reset_inline_summary): Turn to ...\n+\t(inline_summary::reset): ... this one.\n+\t(inline_summary_t::remove): Update.\n+\t(inline_summary_t::duplicate): Update.\n+\t(ipa_call_summary_t::remove): Update.\n+\t(dump_inline_summary): Update.\n+\t(estimate_function_body_sizes): Update.\n+\t(compute_inline_parameters): Update.\n+\t(estimate_node_size_and_time): Update.\n+\t(inline_merge_summary): Update.\n+\t(inline_update_overall_summary): Update.\n+\t(inline_read_section): Update.\n+\t(inline_write_summary): Update.\n+\t* ipa-inline.h (inline_summary): Rename entry to size_time_table;\n+\tadd account_size_time and reset member functions.\n+\t(ipa_call_summary): Add reset function.\n+\t* ipa-predicate.h (predicate::operator &): Constify.\n+\n 2017-05-22  Richard Biener  <rguenther@suse.de>\n \n \t* df-scan.c (df_insn_refs_verify): Speedup when not verifying."}, {"sha": "13f775d62bfc3d35b685a59acc755c9dca03a56f", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 85, "deletions": 89, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "patch": "@@ -158,33 +158,33 @@ dump_inline_hints (FILE *f, inline_hints hints)\n    When NONCONST_PRED is false the code will evaulate to constant and\n    will get optimized out in specialized clones of the function.   */\n \n-static void\n-account_size_time (struct inline_summary *summary, int size, sreal time,\n-\t\t   predicate *exec_pred,\n-\t\t   predicate *nonconst_pred_ptr)\n+void\n+inline_summary::account_size_time (int size, sreal time,\n+\t\t\t\t   const predicate &exec_pred,\n+\t\t\t\t   const predicate &nonconst_pred_in)\n {\n   size_time_entry *e;\n   bool found = false;\n   int i;\n   predicate nonconst_pred;\n \n-  if (*exec_pred == false)\n+  if (exec_pred == false)\n     return;\n \n-  nonconst_pred = *nonconst_pred_ptr & *exec_pred;\n+  nonconst_pred = nonconst_pred_in & exec_pred;\n \n   if (nonconst_pred == false)\n     return;\n \n   /* We need to create initial empty unconitional clause, but otherwie\n      we don't need to account empty times and sizes.  */\n-  if (!size && time == 0 && summary->entry)\n+  if (!size && time == 0 && size_time_table)\n     return;\n \n   gcc_assert (time >= 0);\n \n-  for (i = 0; vec_safe_iterate (summary->entry, i, &e); i++)\n-    if (e->exec_predicate == *exec_pred\n+  for (i = 0; vec_safe_iterate (size_time_table, i, &e); i++)\n+    if (e->exec_predicate == exec_pred\n \t&& e->nonconst_predicate == nonconst_pred)\n       {\n \tfound = true;\n@@ -194,7 +194,7 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n     {\n       i = 0;\n       found = true;\n-      e = &(*summary->entry)[0];\n+      e = &(*size_time_table)[0];\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"\\t\\tReached limit on number of entries, \"\n@@ -206,11 +206,11 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n \t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate exec:\",\n \t       ((double) size) / INLINE_SIZE_SCALE,\n \t       (time.to_double ()), found ? \"\" : \"new \");\n-      exec_pred->dump (dump_file, summary->conds, 0);\n-      if (*exec_pred != nonconst_pred)\n+      exec_pred.dump (dump_file, conds, 0);\n+      if (exec_pred != nonconst_pred)\n \t{\n           fprintf (dump_file, \" nonconst:\");\n-          nonconst_pred.dump (dump_file, summary->conds);\n+          nonconst_pred.dump (dump_file, conds);\n \t}\n       else\n         fprintf (dump_file, \"\\n\");\n@@ -220,9 +220,9 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n       struct size_time_entry new_entry;\n       new_entry.size = size;\n       new_entry.time = time;\n-      new_entry.exec_predicate = *exec_pred;\n+      new_entry.exec_predicate = exec_pred;\n       new_entry.nonconst_predicate = nonconst_pred;\n-      vec_safe_push (summary->entry, new_entry);\n+      vec_safe_push (size_time_table, new_entry);\n     }\n   else\n     {\n@@ -541,66 +541,63 @@ inline_summary_alloc (void)\n /* We are called multiple time for given function; clear\n    data from previous run so they are not cumulated.  */\n \n-static void\n-reset_ipa_call_summary (struct cgraph_edge *e)\n+void\n+ipa_call_summary::reset ()\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n-\n-  es->call_stmt_size = es->call_stmt_time = 0;\n-  if (es->predicate)\n-    edge_predicate_pool.remove (es->predicate);\n-  es->predicate = NULL;\n-  es->param.release ();\n+  call_stmt_size = call_stmt_time = 0;\n+  if (predicate)\n+    edge_predicate_pool.remove (predicate);\n+  predicate = NULL;\n+  param.release ();\n }\n \n /* We are called multiple time for given function; clear\n    data from previous run so they are not cumulated.  */\n \n-static void\n-reset_inline_summary (struct cgraph_node *node,\n-\t\t      inline_summary *info)\n+void\n+inline_summary::reset (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n \n-  info->self_size = 0;\n-  info->self_time = 0;\n-  info->estimated_stack_size = 0;\n-  info->estimated_self_stack_size = 0;\n-  info->stack_frame_offset = 0;\n-  info->size = 0;\n-  info->time = 0;\n-  info->growth = 0;\n-  info->scc_no = 0;\n-  if (info->loop_iterations)\n+  self_size = 0;\n+  self_time = 0;\n+  estimated_stack_size = 0;\n+  estimated_self_stack_size = 0;\n+  stack_frame_offset = 0;\n+  size = 0;\n+  time = 0;\n+  growth = 0;\n+  scc_no = 0;\n+  if (loop_iterations)\n     {\n-      edge_predicate_pool.remove (info->loop_iterations);\n-      info->loop_iterations = NULL;\n+      edge_predicate_pool.remove (loop_iterations);\n+      loop_iterations = NULL;\n     }\n-  if (info->loop_stride)\n+  if (loop_stride)\n     {\n-      edge_predicate_pool.remove (info->loop_stride);\n-      info->loop_stride = NULL;\n+      edge_predicate_pool.remove (loop_stride);\n+      loop_stride = NULL;\n     }\n-  if (info->array_index)\n+  if (array_index)\n     {\n-      edge_predicate_pool.remove (info->array_index);\n-      info->array_index = NULL;\n+      edge_predicate_pool.remove (array_index);\n+      array_index = NULL;\n     }\n-  vec_free (info->conds);\n-  vec_free (info->entry);\n+  vec_free (conds);\n+  vec_free (size_time_table);\n   for (e = node->callees; e; e = e->next_callee)\n-    reset_ipa_call_summary (e);\n+    ipa_call_summaries->get (e)->reset ();\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    reset_ipa_call_summary (e);\n-  info->fp_expressions = false;\n+    ipa_call_summaries->get (e)->reset ();\n+  fp_expressions = false;\n }\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n \n void\n inline_summary_t::remove (cgraph_node *node, inline_summary *info)\n {\n-  reset_inline_summary (node, info);\n+  info->reset (node);\n }\n \n /* Same as remap_predicate_after_duplication but handle hint predicate *P.\n@@ -641,7 +638,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n      out that something was optimized out.  */\n   if (ipa_node_params_sum && dst->clone.tree_map)\n     {\n-      vec<size_time_entry, va_gc> *entry = info->entry;\n+      vec<size_time_entry, va_gc> *entry = info->size_time_table;\n       /* Use SRC parm info since it may not be copied yet.  */\n       struct ipa_node_params *parms_info = IPA_NODE_REF (src);\n       vec<tree> known_vals = vNULL;\n@@ -654,7 +651,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n       bool inlined_to_p = false;\n       struct cgraph_edge *edge, *next;\n \n-      info->entry = 0;\n+      info->size_time_table = 0;\n       known_vals.safe_grow_cleared (count);\n       for (i = 0; i < count; i++)\n \t{\n@@ -680,7 +677,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t\t\t\t\t  NULL);\n       known_vals.release ();\n \n-      account_size_time (info, 0, 0, &true_pred, &true_pred);\n+      info->account_size_time (0, 0, true_pred, true_pred);\n \n       /* Remap size_time vectors.\n          Simplify the predicate by prunning out alternatives that are known\n@@ -698,8 +695,8 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t  if (new_exec_pred == false || new_nonconst_pred == false)\n \t    optimized_out_size += e->size;\n \t  else\n-\t    account_size_time (info, e->size, e->time, &new_exec_pred,\n-\t\t\t       &new_nonconst_pred);\n+\t    info->account_size_time (e->size, e->time, new_exec_pred,\n+\t\t\t             new_nonconst_pred);\n \t}\n \n       /* Remap edge predicates with the same simplification as above.\n@@ -753,7 +750,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n     }\n   else\n     {\n-      info->entry = vec_safe_copy (info->entry);\n+      info->size_time_table = vec_safe_copy (info->size_time_table);\n       if (info->loop_iterations)\n \t{\n \t  predicate p = *info->loop_iterations;\n@@ -804,11 +801,11 @@ ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n \n void\n ipa_call_summary_t::remove (struct cgraph_edge *edge,\n-\t\t\t    struct ipa_call_summary *)\n+\t\t\t    struct ipa_call_summary *sum)\n {\n   if (edge_growth_cache.exists ())\n     reset_edge_growth_cache (edge);\n-  reset_ipa_call_summary (edge);\n+  sum->reset ();\n }\n \n \n@@ -935,7 +932,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n       if (s->scc_no)\n \tfprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n-      for (i = 0; vec_safe_iterate (s->entry, i, &e); i++)\n+      for (i = 0; vec_safe_iterate (s->size_time_table, i, &e); i++)\n \t{\n \t  fprintf (f, \"    size:%f, time:%f\",\n \t\t   (double) e->size / INLINE_SIZE_SCALE,\n@@ -2057,7 +2054,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n   memset(&fbi, 0, sizeof(fbi));\n   info->conds = NULL;\n-  info->entry = NULL;\n+  info->size_time_table = NULL;\n \n   /* When optimizing and analyzing for IPA inliner, initialize loop optimizer\n      so we can produce proper inline hints.\n@@ -2095,11 +2092,11 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   /* When we run into maximal number of entries, we assign everything to the\n      constant truth case.  Be sure to have it in list. */\n   bb_predicate = true;\n-  account_size_time (info, 0, 0, &bb_predicate, &bb_predicate);\n+  info->account_size_time (0, 0, bb_predicate, bb_predicate);\n \n   bb_predicate = predicate::not_inlined ();\n-  account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate,\n-\t\t     &bb_predicate);\n+  info->account_size_time (2 * INLINE_SIZE_SCALE, 0, bb_predicate,\n+\t\t           bb_predicate);\n \n   if (fbi.info)\n     compute_bb_predicates (&fbi, node, info);\n@@ -2286,17 +2283,17 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  if (prob)\n \t\t    {\n \t\t      predicate ip = bb_predicate & predicate::not_inlined ();\n-\t\t      account_size_time (info, this_size * prob,\n-\t\t\t\t\t (sreal)(this_time * prob)\n-\t\t\t\t\t / (CGRAPH_FREQ_BASE * 2), &ip,\n-\t\t\t\t\t &p);\n+\t\t      info->account_size_time (this_size * prob,\n+\t\t\t\t\t       (sreal)(this_time * prob)\n+\t\t\t\t\t       / (CGRAPH_FREQ_BASE * 2), ip,\n+\t\t\t\t\t       p);\n \t\t    }\n \t\t  if (prob != 2)\n-\t\t    account_size_time (info, this_size * (2 - prob),\n-\t\t\t\t       (sreal)(this_time * (2 - prob))\n-\t\t\t\t\t/ (CGRAPH_FREQ_BASE * 2),\n-\t\t\t\t       &bb_predicate,\n-\t\t\t\t       &p);\n+\t\t    info->account_size_time (this_size * (2 - prob),\n+\t\t\t\t\t     (sreal)(this_time * (2 - prob))\n+\t\t\t\t\t      / (CGRAPH_FREQ_BASE * 2),\n+\t\t\t\t\t     bb_predicate,\n+\t\t\t\t\t     p);\n \t\t}\n \n \t      if (!info->fp_expressions && fp_expression_p (stmt))\n@@ -2453,7 +2450,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   inline_summary_alloc ();\n \n   info = inline_summaries->get (node);\n-  reset_inline_summary (node, info);\n+  info->reset (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize && !node->thunk.thunk_p\n@@ -2470,10 +2467,9 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       node->local.can_change_signature = false;\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n-      account_size_time (info, INLINE_SIZE_SCALE * 2,\n-\t\t\t 2, &t, &t);\n+      info->account_size_time (INLINE_SIZE_SCALE * 2, 2, t, t);\n       t = predicate::not_inlined ();\n-      account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &t, &t);\n+      info->account_size_time (2 * INLINE_SIZE_SCALE, 0, t, t);\n       inline_update_overall_summary (node);\n       info->self_size = info->size;\n       info->self_time = info->time;\n@@ -2799,7 +2795,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\tknown_vals, known_contexts, known_aggs);\n   sreal nonspecialized_time = time;\n \n-  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n+  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n     {\n       bool nonconst = e->nonconst_predicate.evaluate (possible_truths);\n       bool exec = e->exec_predicate.evaluate (nonspec_possible_truths);\n@@ -2837,9 +2833,9 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t  gcc_checking_assert (time >= 0);\n         }\n      }\n-  gcc_checking_assert ((*info->entry)[0].exec_predicate == true);\n-  gcc_checking_assert ((*info->entry)[0].nonconst_predicate == true);\n-  min_size = (*info->entry)[0].size;\n+  gcc_checking_assert ((*info->size_time_table)[0].exec_predicate == true);\n+  gcc_checking_assert ((*info->size_time_table)[0].nonconst_predicate == true);\n+  min_size = (*info->size_time_table)[0].size;\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n   /* nonspecialized_time should be always bigger than specialized time.\n@@ -3141,7 +3137,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t  gcc_assert (map < ipa_get_param_count (IPA_NODE_REF (to)));\n \t}\n     }\n-  for (i = 0; vec_safe_iterate (callee_info->entry, i, &e); i++)\n+  for (i = 0; vec_safe_iterate (callee_info->size_time_table, i, &e); i++)\n     {\n       predicate p;\n       p = e->exec_predicate.remap_after_inlining\n@@ -3165,7 +3161,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t      fprintf (dump_file, \"\\t\\tScaling time by probability:%f\\n\",\n \t\t       (double) prob / REG_BR_PROB_BASE);\n \t    }\n-\t  account_size_time (info, e->size, add_time, &p, &nonconstp);\n+\t  info->account_size_time (e->size, add_time, p, nonconstp);\n \t}\n     }\n   remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n@@ -3203,7 +3199,7 @@ inline_update_overall_summary (struct cgraph_node *node)\n \n   info->size = 0;\n   info->time = 0;\n-  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n+  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n     {\n       info->size += e->size;\n       info->time += e->time;\n@@ -3723,7 +3719,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  vec_safe_push (info->conds, c);\n \t}\n       count2 = streamer_read_uhwi (&ib);\n-      gcc_assert (!info->entry);\n+      gcc_assert (!info->size_time_table);\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct size_time_entry e;\n@@ -3733,7 +3729,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  e.exec_predicate.stream_in (&ib);\n \t  e.nonconst_predicate.stream_in (&ib);\n \n-\t  vec_safe_push (info->entry, e);\n+\t  vec_safe_push (info->size_time_table, e);\n \t}\n \n       p.stream_in (&ib);\n@@ -3872,8 +3868,8 @@ inline_write_summary (void)\n \t      if (c->agg_contents)\n \t\tstreamer_write_uhwi (ob, c->offset);\n \t    }\n-\t  streamer_write_uhwi (ob, vec_safe_length (info->entry));\n-\t  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n+\t  streamer_write_uhwi (ob, vec_safe_length (info->size_time_table));\n+\t  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n \t    {\n \t      streamer_write_uhwi (ob, e->size);\n \t      e->time.stream_out (ob);\n@@ -3917,7 +3913,7 @@ inline_free_summary (void)\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n-      reset_inline_summary (node, inline_summaries->get (node));\n+      inline_summaries->get (node)->reset (node);\n   inline_summaries->release ();\n   inline_summaries = NULL;\n   ipa_call_summaries->release ();"}, {"sha": "eb23533c3bc77450a7197d3884bec6c0ca6a8c18", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "patch": "@@ -127,7 +127,7 @@ struct GTY(()) inline_summary\n   /* Conditional size/time information.  The summaries are being\n      merged during inlining.  */\n   conditions conds;\n-  vec<size_time_entry, va_gc> *entry;\n+  vec<size_time_entry, va_gc> *size_time_table;\n \n   /* Predicate on when some loop in the function becomes to have known\n      bounds.   */\n@@ -153,10 +153,16 @@ struct GTY(()) inline_summary\n       inlinable (false), contains_cilk_spawn (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n       stack_frame_offset (false), time (0), size (0), conds (NULL),\n-      entry (NULL), loop_iterations (NULL), loop_stride (NULL),\n+      size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n       array_index (NULL), growth (0), scc_no (0)\n     {\n     }\n+\n+  /* Record time and size under given predicates.  */\n+  void account_size_time (int, sreal, const predicate &, const predicate &);\n+\n+  /* Reset inline summary to empty state.  */\n+  void reset (struct cgraph_node *node);\n };\n \n class GTY((user)) inline_summary_t: public function_summary <inline_summary *>\n@@ -201,6 +207,9 @@ struct ipa_call_summary\n       loop_depth (0)\n     {\n     }\n+\n+  /* Reset inline summary to empty state.  */\n+  void reset ();\n };\n \n class ipa_call_summary_t: public call_summary <ipa_call_summary *>"}, {"sha": "40f26c86e2c125edb7796b17ca1a1ebdd81e1423", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61890ff25a24b2ddb289c61c1e5fbcae6f9f613d/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=61890ff25a24b2ddb289c61c1e5fbcae6f9f613d", "patch": "@@ -137,7 +137,7 @@ class predicate\n \n   /* Compute logical and of predicates.  */\n   predicate & operator &= (const predicate &);\n-  inline predicate operator &(const predicate &p)\n+  inline predicate operator &(const predicate &p) const\n     {\n       predicate ret = *this;\n       ret &= p;"}]}