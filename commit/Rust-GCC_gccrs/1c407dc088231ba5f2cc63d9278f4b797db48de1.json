{"sha": "1c407dc088231ba5f2cc63d9278f4b797db48de1", "node_id": "C_kwDOANBUbNoAKDFjNDA3ZGMwODgyMzFiYTVmMmNjNjNkOTI3OGY0Yjc5N2RiNDhkZTE", "commit": {"author": {"name": "Takayuki 'January June' Suwa", "email": "jjsuwa_sys3175@yahoo.co.jp", "date": "2023-01-20T03:33:37Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2023-01-24T21:23:03Z"}, "message": "xtensa: Revise complex hard register clobber elimination\n\nIn the previously posted patch\n\"xtensa: Make complex hard register clobber elimination more robust and accurate\",\nthe check code for insns that refer to the [DS]Cmode hard register before\nit is overwritten after it is clobbered is incomplete.  Fortunately such\ninsns are seldom emitted, so it didn't matter.\n\nThis patch fixes that for the sake of completeness.\n\ngcc/ChangeLog:\n\n\t* config/xtensa/xtensa.md:\n\tFix exit from loops detecting references before overwriting in the\n\tsplit pattern.", "tree": {"sha": "5c360e20836e0e4f81874c79c7df22cfab87914e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c360e20836e0e4f81874c79c7df22cfab87914e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c407dc088231ba5f2cc63d9278f4b797db48de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c407dc088231ba5f2cc63d9278f4b797db48de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c407dc088231ba5f2cc63d9278f4b797db48de1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c407dc088231ba5f2cc63d9278f4b797db48de1/comments", "author": {"login": "jjsuwa-sys3175", "id": 73290592, "node_id": "MDQ6VXNlcjczMjkwNTky", "avatar_url": "https://avatars.githubusercontent.com/u/73290592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjsuwa-sys3175", "html_url": "https://github.com/jjsuwa-sys3175", "followers_url": "https://api.github.com/users/jjsuwa-sys3175/followers", "following_url": "https://api.github.com/users/jjsuwa-sys3175/following{/other_user}", "gists_url": "https://api.github.com/users/jjsuwa-sys3175/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjsuwa-sys3175/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjsuwa-sys3175/subscriptions", "organizations_url": "https://api.github.com/users/jjsuwa-sys3175/orgs", "repos_url": "https://api.github.com/users/jjsuwa-sys3175/repos", "events_url": "https://api.github.com/users/jjsuwa-sys3175/events{/privacy}", "received_events_url": "https://api.github.com/users/jjsuwa-sys3175/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265a749f290f7c6adc9a3aaa9c585b498a8a38ea"}], "stats": {"total": 72, "additions": 37, "deletions": 35}, "files": [{"sha": "d3996b26cb5c1d1e6b6bba8e3a24ab6b8bc3b246", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c407dc088231ba5f2cc63d9278f4b797db48de1/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c407dc088231ba5f2cc63d9278f4b797db48de1/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=1c407dc088231ba5f2cc63d9278f4b797db48de1", "patch": "@@ -2973,45 +2973,47 @@\n {\n   auto_sbitmap bmp (FIRST_PSEUDO_REGISTER);\n   rtx_insn *insn;\n-  rtx reg = gen_rtx_REG (SImode, 0);\n+  rtx reg = gen_rtx_REG (SImode, 0), dest;\n+  unsigned int regno;\n+  sbitmap_iterator iter;\n   bitmap_set_range (bmp, REGNO (operands[0]), REG_NREGS (operands[0]));\n   for (insn = next_nonnote_nondebug_insn_bb (curr_insn);\n        insn; insn = next_nonnote_nondebug_insn_bb (insn))\n-    {\n-      sbitmap_iterator iter;\n-      unsigned int regno;\n-      if (NONJUMP_INSN_P (insn))\n-\t{\n-\t  EXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n-\t    {\n-\t      set_regno_raw (reg, regno, REG_NREGS (reg));\n-\t      if (reg_overlap_mentioned_p (reg, PATTERN (insn)))\n-\t\tbreak;\n-\t    }\n-\t  if (GET_CODE (PATTERN (insn)) == SET)\n-\t    {\n-\t      rtx x = SET_DEST (PATTERN (insn));\n-\t      if (REG_P (x) && HARD_REGISTER_P (x))\n-\t\tbitmap_clear_range (bmp, REGNO (x), REG_NREGS (x));\n-\t      else if (SUBREG_P (x) && HARD_REGISTER_P (SUBREG_REG (x)))\n-\t\t{\n-\t\t  struct subreg_info info;\n-\t\t  subreg_get_info (regno = REGNO (SUBREG_REG (x)),\n-\t\t\t\t   GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t   SUBREG_BYTE (x), GET_MODE (x), &info);\n-\t\t  if (!info.representable_p)\n-\t\t    break;\n-\t\t  bitmap_clear_range (bmp, regno + info.offset, info.nregs);\n-\t\t}\n-\t    }\n-\t  if (bitmap_empty_p (bmp))\n-\t    goto FALLTHRU;\n-\t}\n-      else if (CALL_P (insn))\n+    if (NONJUMP_INSN_P (insn))\n+      {\n \tEXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n-\t if (call_used_or_fixed_reg_p (regno))\n-\t   break;\n-    }\n+\t  {\n+\t    set_regno_raw (reg, regno, REG_NREGS (reg));\n+\t    if (reg_referenced_p (reg, PATTERN (insn)))\n+\t      goto ABORT;\n+\t  }\n+\tif (GET_CODE (PATTERN (insn)) == SET\n+\t    || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t  {\n+\t    dest = SET_DEST (PATTERN (insn));\n+\t    if (REG_P (dest) && HARD_REGISTER_P (dest))\n+\t      bitmap_clear_range (bmp, REGNO (dest), REG_NREGS (dest));\n+\t    else if (SUBREG_P (dest)\n+\t\t     && HARD_REGISTER_P (SUBREG_REG (dest)))\n+\t      {\n+\t\tstruct subreg_info info;\n+\t\tsubreg_get_info (regno = REGNO (SUBREG_REG (dest)),\n+\t\t\t\t GET_MODE (SUBREG_REG (dest)),\n+\t\t\t\t SUBREG_BYTE (dest), GET_MODE (dest),\n+\t\t\t\t &info);\n+\t\tif (!info.representable_p)\n+\t\t  break;\n+\t\tbitmap_clear_range (bmp, regno + info.offset, info.nregs);\n+\t      }\n+\t  }\n+\tif (bitmap_empty_p (bmp))\n+\t  goto FALLTHRU;\n+      }\n+    else if (CALL_P (insn))\n+      EXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n+\tif (call_used_or_fixed_reg_p (regno))\n+\t  goto ABORT;\n+ABORT:\n   FAIL;\n FALLTHRU:;\n })"}]}