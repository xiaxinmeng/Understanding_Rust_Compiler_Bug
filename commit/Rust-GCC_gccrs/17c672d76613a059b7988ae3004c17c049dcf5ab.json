{"sha": "17c672d76613a059b7988ae3004c17c049dcf5ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdjNjcyZDc2NjEzYTA1OWI3OTg4YWUzMDA0YzE3YzA0OWRjZjVhYg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-04-21T12:16:01Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-04-21T12:16:01Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r810", "tree": {"sha": "748a8ef400c01c79abbc57b5193e1ed72c766a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/748a8ef400c01c79abbc57b5193e1ed72c766a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17c672d76613a059b7988ae3004c17c049dcf5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c672d76613a059b7988ae3004c17c049dcf5ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17c672d76613a059b7988ae3004c17c049dcf5ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c672d76613a059b7988ae3004c17c049dcf5ab/comments", "author": null, "committer": null, "parents": [{"sha": "d7ea4cf6803aa3e19541372380c093d442dde0d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ea4cf6803aa3e19541372380c093d442dde0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ea4cf6803aa3e19541372380c093d442dde0d4"}], "stats": {"total": 115, "additions": 108, "deletions": 7}, "files": [{"sha": "4aca80d5981cc79768db4e07c93bbeb863147416", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=17c672d76613a059b7988ae3004c17c049dcf5ab", "patch": "@@ -46,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.1.3.1 07 Apr 1992 17:23:59\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.1.4.6 20 Apr 1992 14:30:40\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -718,19 +718,23 @@ output_call (operands, addr)\n   if (final_sequence)\n     {\n       rtx jump;\n+      rtx seq_insn;\n \n       /* This can be generalized, but there is currently no need.  */\n       if (XVECLEN (final_sequence, 0) != 2)\n \tabort ();\n \n+      /* The address of interior insns is not computed, so use the sequence.  */\n+      seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n       jump = XVECEXP (final_sequence, 0, 1);\n       if (GET_CODE (jump) == JUMP_INSN)\n \t{\n \t  rtx low, high;\n \t  char *last;\n \t  rtx dest = XEXP (SET_SRC (PATTERN (jump)), 0);\n \t  int delta = 4 * (insn_addresses[INSN_UID (dest)]\n-\t\t\t   - insn_addresses[INSN_UID (jump)]);\n+\t\t\t   - insn_addresses[INSN_UID (seq_insn)]\n+\t\t\t   - 2);\n #if (MONITOR_GCC & 0x2) /* How often do long branches happen?  */\n \t  if ((unsigned) (delta + 0x8000) >= 0x10000)\n \t    warning (\"Internal gcc monitor: short-branch(%x)\", delta);\n@@ -818,6 +822,92 @@ output_short_branch_defs (stream)\n     abort ();\n }\n \f\n+/* Return truth value of the statement that this conditional branch is likely\n+   to fall through.  CONDITION, is the condition that JUMP_INSN is testing.  */\n+\n+int\n+mostly_false_jump (jump_insn, condition)\n+     rtx jump_insn, condition;\n+{\n+  rtx target_label = JUMP_LABEL (jump_insn);\n+  rtx insnt, insnj;\n+\n+  /* Much of this isn't computed unless we're optimizing.  */\n+  if (optimize == 0)\n+    return 0;\n+\n+  /* Determine if one path or the other leads to a return.  */\n+  for (insnt = NEXT_INSN (target_label);\n+       insnt;\n+       insnt = NEXT_INSN (insnt))\n+    if (GET_CODE (insnt) == JUMP_INSN\n+\t|| (GET_CODE (insnt) == SEQUENCE\n+\t    && GET_CODE (XVECEXP (insnt, 0, 0)) == JUMP_INSN))\n+      break;\n+  if (insnt && GET_CODE (PATTERN (insnt)) == RETURN)\n+    insnt = 0;\n+\n+  for (insnj = NEXT_INSN (jump_insn);\n+       insnj;\n+       insnj = NEXT_INSN (insnj))\n+    if (GET_CODE (insnj) == JUMP_INSN\n+\t|| (GET_CODE (insnj) == SEQUENCE\n+\t    && GET_CODE (XVECEXP (insnj, 0, 0)) == JUMP_INSN))\n+      break;\n+  if (insnj && GET_CODE (PATTERN (insnj)) == RETURN)\n+    insnj = 0;\n+\n+  /* Predict to not return.  */\n+  if (insnt != insnj)\n+    return (insnt == 0);\n+\n+  /* Predict loops to loop.  */\n+  for (insnt = PREV_INSN (target_label);\n+       insnt && GET_CODE (insnt) == NOTE;\n+       insnt = PREV_INSN (insnt))\n+    if (NOTE_LINE_NUMBER (insnt) == NOTE_INSN_LOOP_END)\n+      return 1;\n+    else if (NOTE_LINE_NUMBER (insnt) == NOTE_INSN_LOOP_BEG)\n+      return 0;\n+    else if (NOTE_LINE_NUMBER (insnt) == NOTE_INSN_LOOP_CONT)\n+      return 0;\n+\n+  /* Predict backward branches usually take.  */\n+  if (final_sequence)\n+    insnj = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+  else\n+    insnj = jump_insn;\n+  if (insn_addresses[INSN_UID (insnj)]\n+      > insn_addresses[INSN_UID (target_label)])\n+    return 0;\n+\n+  /* EQ tests are usually false and NE tests are usually true.  Also,\n+     most quantities are positive, so we can make the appropriate guesses\n+     about signed comparisons against zero.  */\n+  switch (GET_CODE (condition))\n+    {\n+    case CONST_INT:\n+      /* Unconditional branch.  */\n+      return 0;\n+    case EQ:\n+      return 1;\n+    case NE:\n+      return 0;\n+    case LE:\n+    case LT:\n+      if (XEXP (condition, 1) == const0_rtx)\n+        return 1;\n+      break;\n+    case GE:\n+    case GT:\n+      if (XEXP (condition, 1) == const0_rtx)\n+\treturn 0;\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\f\n /* Report errors on floating point, if we are given NaN's, or such.  Leave\n    the number as is, though, since we output the number in hex, and the\n    assembler won't choke on it.  */"}, {"sha": "532350b15d7de037a4fbab854e8aab38fc107474", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=17c672d76613a059b7988ae3004c17c049dcf5ab", "patch": "@@ -204,9 +204,9 @@ extern char * reg_names[];\n /* Print subsidiary information on the compiler version in use.\n    Redefined in m88kv4.h, and m88kluna.h.  */\n #define VERSION_INFO1\t\"88open OCS/BCS, \"\n-#define VERSION_INFO2\t\"07 Apr 1992\"\n+#define VERSION_INFO2\t\"21 Apr 1992\"\n #define VERSION_STRING\tversion_string\n-#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.3.1 07 Apr 1992 17:24:45\"\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.4.5 21 Apr 1992 08:02:51\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -1469,6 +1469,11 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    so give the MEM rtx word mode.  */\n #define FUNCTION_MODE SImode\n \n+/* A barrier will be aligned so account for the possible expansion.  */\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\\n+  if (GET_CODE (INSN) == BARRIER)\t\t\\\n+    LENGTH += 1;\n+\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,\n@@ -1551,7 +1556,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n /* Allow pseudo-ops to be overridden.  Override these in svr[34].h.  */\n #undef\tINT_ASM_OP\n #undef\tASCII_DATA_ASM_OP\n-#undef\tINIT_SECTION_ASM_OP\n #undef\tCONST_SECTION_ASM_OP\n #undef\tCTORS_SECTION_ASM_OP\n #undef\tDTORS_SECTION_ASM_OP\n@@ -2261,6 +2265,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \n #else /* m88kluna or other not based on svr[34].h.  */\n \n+#undef INIT_SECTION_ASM_OP\n #define EXTRA_SECTIONS in_const, in_tdesc, in_sdata\n #define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\"}, {"sha": "15f1b74333f8538004342072a0e4e85b400e7e1b", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c672d76613a059b7988ae3004c17c049dcf5ab/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=17c672d76613a059b7988ae3004c17c049dcf5ab", "patch": "@@ -28,7 +28,7 @@\n (define_expand \"m88k_sccs_id\"\n   [(match_operand:SI 0 \"\" \"\")]\n   \"\"\n-  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.4.2 15 Apr 1992 15:39:48\\\";\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.4.3 20 Apr 1992 10:42:47\\\";\n      FAIL; }\")\n \f\n ;; Attribute specifications\n@@ -995,7 +995,13 @@\n \t      (match_operand 2 \"pc_or_label_ref\" \"\")\n \t      (match_operand 3 \"pc_or_label_ref\" \"\")))]\n   \"\"\n-  \"bb1%. %R3%C0,%1,%P2%P3\"\n+  \"*\n+{\n+  if (mostly_false_jump (insn, operands[0]))\n+    return \\\"bb0%. %R2%C0,%1,%P2%P3\\\";\n+  else\n+    return \\\"bb1%. %R3%C0,%1,%P2%P3\\\";\n+}\"\n   [(set_attr \"type\" \"branch\")])\n \f\n ;; SImode move instructions"}]}