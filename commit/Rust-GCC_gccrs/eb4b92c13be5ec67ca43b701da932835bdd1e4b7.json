{"sha": "eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0YjkyYzEzYmU1ZWM2N2NhNDNiNzAxZGE5MzI4MzViZGQxZTRiNw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-11-12T15:03:28Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-11-12T15:03:28Z"}, "message": "predict.c (drop_profile): New function.\n\n2013-11-12  Teresa Johnson  <tejohnson@google.com>\n\t    Jan Hubicka  <jh@suse.cz>\n\n\t* predict.c (drop_profile): New function.\n\t(handle_missing_profiles): Ditto.\n\t(counts_to_freqs): Don't overwrite estimated frequencies\n\twhen function has no profile counts.\n\t* predict.h (handle_missing_profiles): Declare.\n\t* tree-inline.c (freqs_to_counts): New function.\n\t(copy_cfg_body): Invoke freqs_to_counts as needed.\n\t* tree-profile.c (tree_profiling): Invoke handle_missing_profiles.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r204704", "tree": {"sha": "dd1e6b187157352f6f08341a70daaedf473980fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd1e6b187157352f6f08341a70daaedf473980fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a720b48e18470367633194fff2107ba0b131d3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a720b48e18470367633194fff2107ba0b131d3bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a720b48e18470367633194fff2107ba0b131d3bb"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "32bd0ece09998ae6608887eb9c59c16ba43ffd67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "patch": "@@ -1,3 +1,15 @@\n+2013-11-12  Teresa Johnson  <tejohnson@google.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (drop_profile): New function.\n+\t(handle_missing_profiles): Ditto.\n+\t(counts_to_freqs): Don't overwrite estimated frequencies\n+\twhen function has no profile counts.\n+\t* predict.h (handle_missing_profiles): Declare.\n+\t* tree-inline.c (freqs_to_counts): New function.\n+\t(copy_cfg_body): Invoke freqs_to_counts as needed.\n+\t* tree-profile.c (tree_profiling): Invoke handle_missing_profiles.\n+\n 2013-11-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/59088"}, {"sha": "2a500eaa78d2b1a93b538d2c947b7f864d379004", "filename": "gcc/predict.c", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "patch": "@@ -2765,6 +2765,116 @@ estimate_loops (void)\n   BITMAP_FREE (tovisit);\n }\n \n+/* Drop the profile for NODE to guessed, and update its frequency based on\n+   whether it is expected to be HOT.  */\n+\n+static void\n+drop_profile (struct cgraph_node *node, bool hot)\n+{\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+             \"Dropping 0 profile for %s/%i. %s based on calls.\\n\",\n+             cgraph_node_name (node), node->order,\n+             hot ? \"Function is hot\" : \"Function is normal\");\n+  /* We only expect to miss profiles for functions that are reached\n+     via non-zero call edges in cases where the function may have\n+     been linked from another module or library (COMDATs and extern\n+     templates). See the comments below for handle_missing_profiles.  */\n+  if (!DECL_COMDAT (node->decl) && !DECL_EXTERNAL (node->decl))\n+    {\n+      if (flag_profile_correction)\n+        {\n+          if (dump_file)\n+            fprintf (dump_file,\n+                     \"Missing counts for called function %s/%i\\n\",\n+                     cgraph_node_name (node), node->order);\n+        }\n+      else\n+        error (\"Missing counts for called function %s/%i\",\n+               cgraph_node_name (node), node->order);\n+    }\n+\n+  profile_status_for_function (fn)\n+      = (flag_guess_branch_prob ? PROFILE_GUESSED : PROFILE_ABSENT);\n+  node->frequency\n+      = hot ? NODE_FREQUENCY_HOT : NODE_FREQUENCY_NORMAL;\n+}\n+\n+/* In the case of COMDAT routines, multiple object files will contain the same\n+   function and the linker will select one for the binary. In that case\n+   all the other copies from the profile instrument binary will be missing\n+   profile counts. Look for cases where this happened, due to non-zero\n+   call counts going to 0-count functions, and drop the profile to guessed\n+   so that we can use the estimated probabilities and avoid optimizing only\n+   for size.\n+   \n+   The other case where the profile may be missing is when the routine\n+   is not going to be emitted to the object file, e.g. for \"extern template\"\n+   class methods. Those will be marked DECL_EXTERNAL. Emit a warning in\n+   all other cases of non-zero calls to 0-count functions.  */\n+\n+void\n+handle_missing_profiles (void)\n+{\n+  struct cgraph_node *node;\n+  int unlikely_count_fraction = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n+  vec<struct cgraph_node *> worklist;\n+  worklist.create (64);\n+\n+  /* See if 0 count function has non-0 count callers.  In this case we\n+     lost some profile.  Drop its function profile to PROFILE_GUESSED.  */\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      struct cgraph_edge *e;\n+      gcov_type call_count = 0;\n+      struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+\n+      if (node->count)\n+        continue;\n+      for (e = node->callers; e; e = e->next_caller)\n+        call_count += e->count;\n+      if (call_count\n+          && fn && fn->cfg\n+          && (call_count * unlikely_count_fraction >= profile_info->runs))\n+        {\n+          bool maybe_hot = maybe_hot_count_p (NULL, call_count);\n+\n+          drop_profile (node, maybe_hot);\n+          worklist.safe_push (node);\n+        }\n+    }\n+\n+  /* Propagate the profile dropping to other 0-count COMDATs that are\n+     potentially called by COMDATs we already dropped the profile on.  */\n+  while (worklist.length () > 0)\n+    {\n+      struct cgraph_edge *e;\n+\n+      node = worklist.pop ();\n+      for (e = node->callees; e; e = e->next_caller)\n+        {\n+          struct cgraph_node *callee = e->callee;\n+          struct function *fn = DECL_STRUCT_FUNCTION (callee->decl);\n+\n+          if (callee->count > 0)\n+            continue;\n+          if (DECL_COMDAT (callee->decl) && fn && fn->cfg\n+              && profile_status_for_function (fn) == PROFILE_READ)\n+            {\n+              /* Since there are no non-0 call counts to this function,\n+                 we don't know for sure whether it is hot. Indicate to\n+                 the drop_profile routine that function should be marked\n+                 normal, rather than hot.  */\n+              drop_profile (node, false);\n+              worklist.safe_push (callee);\n+            }\n+        }\n+    }\n+  worklist.release ();\n+}\n+\n /* Convert counts measured by profile driven feedback to frequencies.\n    Return nonzero iff there was any nonzero execution count.  */\n \n@@ -2774,6 +2884,12 @@ counts_to_freqs (void)\n   gcov_type count_max, true_count_max = 0;\n   basic_block bb;\n \n+  /* Don't overwrite the estimated frequencies when the profile for\n+     the function is missing.  We may drop this function PROFILE_GUESSED\n+     later in drop_profile ().  */\n+  if (!ENTRY_BLOCK_PTR->count)\n+    return 0;\n+\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     true_count_max = MAX (bb->count, true_count_max);\n "}, {"sha": "83b1695c65eaebb3ed975e5d57b43fbb6c302494", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "patch": "@@ -37,6 +37,7 @@ enum prediction\n \n extern void predict_insn_def (rtx, enum br_predictor, enum prediction);\n extern int counts_to_freqs (void);\n+extern void handle_missing_profiles (void);\n extern void estimate_bb_frequencies (bool);\n extern const char *predictor_name (enum br_predictor);\n extern tree build_predict_expr (enum br_predictor, enum prediction);"}, {"sha": "0d1f1c7621b61fcf555b0b064c9029cda3fc1bbe", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "patch": "@@ -2353,6 +2353,29 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n     }\n }\n \n+/* Convert estimated frequencies into counts for NODE, scaling COUNT\n+   with each bb's frequency. Used when NODE has a 0-weight entry\n+   but we are about to inline it into a non-zero count call bb.\n+   See the comments for handle_missing_profiles() in predict.c for\n+   when this can happen for COMDATs.  */\n+\n+void\n+freqs_to_counts (struct cgraph_node *node, gcov_type count)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+\n+  FOR_ALL_BB_FN(bb, fn)\n+    {\n+      bb->count = apply_scale (count,\n+                               GCOV_COMPUTE_SCALE (bb->frequency, BB_FREQ_MAX));\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        e->count = apply_probability (e->src->count, e->probability);\n+    }\n+}\n+\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n@@ -2373,6 +2396,24 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   int incoming_frequency = 0;\n   gcov_type incoming_count = 0;\n \n+  /* This can happen for COMDAT routines that end up with 0 counts\n+     despite being called (see the comments for handle_missing_profiles()\n+     in predict.c as to why). Apply counts to the blocks in the callee\n+     before inlining, using the guessed edge frequencies, so that we don't\n+     end up with a 0-count inline body which can confuse downstream\n+     optimizations such as function splitting.  */\n+  if (!ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count && count)\n+    {\n+      /* Apply the larger of the call bb count and the total incoming\n+         call edge count to the callee.  */\n+      gcov_type in_count = 0;\n+      struct cgraph_edge *in_edge;\n+      for (in_edge = id->src_node->callers; in_edge;\n+           in_edge = in_edge->next_caller)\n+        in_count += in_edge->count;\n+      freqs_to_counts (id->src_node, count > in_count ? count : in_count);\n+    }\n+\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale\n         = GCOV_COMPUTE_SCALE (count,"}, {"sha": "9f9dba854fdd027737b0aa8c00bd32a4a8c4a2d2", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4b92c13be5ec67ca43b701da932835bdd1e4b7/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "patch": "@@ -645,6 +645,8 @@ tree_profiling (void)\n       pop_cfun ();\n     }\n \n+  handle_missing_profiles ();\n+\n   del_node_map ();\n   return 0;\n }"}]}