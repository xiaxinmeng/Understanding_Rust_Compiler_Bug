{"sha": "a844a60b40efe94d6437bb5b3410fbc0a74f2000", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg0NGE2MGI0MGVmZTk0ZDY0MzdiYjViMzQxMGZiYzBhNzRmMjAwMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-12-02T12:24:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-12-02T12:24:46Z"}, "message": "re PR c++/44871 (Invalid type mismatches while merging C and C++ sources)\n\n2010-12-02  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/44871\n\t* gimple.c (canonical_type_hash_cache): New hashtable.\n\t(gimple_type_hash): Make a wrapper around ...\n\t(gimple_type_hash_1): ... this.  Take gtc_mode argument.\n\t(gimple_canonical_type_hash): Likewise.\n\t(gtc_visit): Take a gtc_mode argument.\n\t(gimple_types_compatible_p_1): Likewise. Do not compare struct\n\ttag names or field names when computing canonical types.\n\t(gimple_types_compatible_p): Adjust.\n\t(visit): Take a gtc_mode argument.\n\t(iterative_hash_gimple_type): Likewise.  Do not hash struct tag\n\tnames or field names when computing hashes of canonical types.\n\t(gimple_register_canonical_type): Use gimple_canonical_type_hash\n\tfor the hash.\n\t(print_gimple_types_stats): Dump stats of canonical_type_hash_cache.\n\t(free_gimple_type_tables): Free canonical_type_hash_cache.\n\n\t* g++.dg/lto/20101126-1_0.C: New testcase.\n\t* g++.dg/lto/20101126-1_1.c: Likewise.\n\nFrom-SVN: r167367", "tree": {"sha": "41c04417c105cf620efada0e39df75d95915f041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41c04417c105cf620efada0e39df75d95915f041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a844a60b40efe94d6437bb5b3410fbc0a74f2000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a844a60b40efe94d6437bb5b3410fbc0a74f2000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a844a60b40efe94d6437bb5b3410fbc0a74f2000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a844a60b40efe94d6437bb5b3410fbc0a74f2000/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52bd463c629b5c0c30b6c95c90aa8dc8199fc84e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bd463c629b5c0c30b6c95c90aa8dc8199fc84e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52bd463c629b5c0c30b6c95c90aa8dc8199fc84e"}], "stats": {"total": 156, "additions": 119, "deletions": 37}, "files": [{"sha": "1c3b6e120556cac58153afd4cc9bf313e83a4ebe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a844a60b40efe94d6437bb5b3410fbc0a74f2000", "patch": "@@ -1,3 +1,22 @@\n+2010-12-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44871\n+\t* gimple.c (canonical_type_hash_cache): New hashtable.\n+\t(gimple_type_hash): Make a wrapper around ...\n+\t(gimple_type_hash_1): ... this.  Take gtc_mode argument.\n+\t(gimple_canonical_type_hash): Likewise.\n+\t(gtc_visit): Take a gtc_mode argument.\n+\t(gimple_types_compatible_p_1): Likewise. Do not compare struct\n+\ttag names or field names when computing canonical types.\n+\t(gimple_types_compatible_p): Adjust.\n+\t(visit): Take a gtc_mode argument.\n+\t(iterative_hash_gimple_type): Likewise.  Do not hash struct tag\n+\tnames or field names when computing hashes of canonical types.\n+\t(gimple_register_canonical_type): Use gimple_canonical_type_hash\n+\tfor the hash.\n+\t(print_gimple_types_stats): Dump stats of canonical_type_hash_cache.\n+\t(free_gimple_type_tables): Free canonical_type_hash_cache.\n+\n 2010-12-02  Richard Guenther  <rguenther@suse.de>\n \t    Ira Rosen  <irar@il.ibm.com>\n "}, {"sha": "e686e63c32ae259df4c8b972004b6642857a1853", "filename": "gcc/gimple.c", "status": "modified", "additions": 85, "deletions": 37, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=a844a60b40efe94d6437bb5b3410fbc0a74f2000", "patch": "@@ -47,6 +47,8 @@ static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n   htab_t gimple_canonical_types;\n static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n   htab_t type_hash_cache;\n+static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n+  htab_t canonical_type_hash_cache;\n \n /* Global type comparison cache.  This is by TYPE_UID for space efficiency\n    and thus cannot use and does not need GC.  */\n@@ -3131,7 +3133,7 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n }\n \n \n-static hashval_t gimple_type_hash (const void *);\n+static hashval_t gimple_type_hash_1 (const void *, enum gtc_mode);\n \n /* Structure used to maintain a cache of some type pairs compared by\n    gimple_types_compatible_p when comparing aggregate types.  There are\n@@ -3474,7 +3476,7 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+  if (gimple_type_hash_1 (t1, mode) != gimple_type_hash_1 (t2, mode))\n     return false;\n \n   /* Allocate a new cache entry for this comparison.  */\n@@ -3757,8 +3759,9 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \ttree f1, f2;\n \n \t/* The struct tags shall compare equal.  */\n-\tif (!compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n-\t\t\t\t   TYPE_MAIN_VARIANT (t2), false))\n+\tif (mode == GTC_MERGE\n+\t    && !compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n+\t\t\t\t      TYPE_MAIN_VARIANT (t2), false))\n \t  goto different_types;\n \n \t/* For aggregate types, all the fields must be the same.  */\n@@ -3767,7 +3770,8 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n \t  {\n \t    /* The fields must have the same name, offset and type.  */\n-\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n+\t    if ((mode == GTC_MERGE\n+\t\t && DECL_NAME (f1) != DECL_NAME (f2))\n \t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !gimple_compare_field_offset (f1, f2)\n \t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2), mode,\n@@ -3910,7 +3914,7 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+  if (gimple_type_hash_1 (t1, mode) != gimple_type_hash_1 (t2, mode))\n     return false;\n \n   /* If we've visited this type pair before (in the case of aggregates\n@@ -3939,7 +3943,8 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n \n static hashval_t\n iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n-\t\t\t    struct pointer_map_t *, struct obstack *);\n+\t\t\t    struct pointer_map_t *, struct obstack *,\n+\t\t\t    enum gtc_mode);\n \n /* DFS visit the edge from the callers type with state *STATE to T.\n    Update the callers type hash V with the hash for T if it is not part\n@@ -3950,7 +3955,7 @@ static hashval_t\n visit (tree t, struct sccs *state, hashval_t v,\n        VEC (tree, heap) **sccstack,\n        struct pointer_map_t *sccstate,\n-       struct obstack *sccstate_obstack)\n+       struct obstack *sccstate_obstack, enum gtc_mode mode)\n {\n   struct sccs *cstate = NULL;\n   struct tree_int_map m;\n@@ -3959,7 +3964,9 @@ visit (tree t, struct sccs *state, hashval_t v,\n   /* If there is a hash value recorded for this type then it can't\n      possibly be part of our parent SCC.  Simply mix in its hash.  */\n   m.base.from = t;\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+  if ((slot = htab_find_slot (mode == GTC_MERGE\n+\t\t\t      ? type_hash_cache : canonical_type_hash_cache,\n+\t\t\t      &m, NO_INSERT))\n       && *slot)\n     return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n \n@@ -3970,7 +3977,8 @@ visit (tree t, struct sccs *state, hashval_t v,\n       hashval_t tem;\n       /* Not yet visited.  DFS recurse.  */\n       tem = iterative_hash_gimple_type (t, v,\n-\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n+\t\t\t\t\tsccstack, sccstate, sccstate_obstack,\n+\t\t\t\t\tmode);\n       if (!cstate)\n \tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n       state->low = MIN (state->low, cstate->low);\n@@ -4021,7 +4029,8 @@ static hashval_t\n iterative_hash_gimple_type (tree type, hashval_t val,\n \t\t\t    VEC(tree, heap) **sccstack,\n \t\t\t    struct pointer_map_t *sccstate,\n-\t\t\t    struct obstack *sccstate_obstack)\n+\t\t\t    struct obstack *sccstate_obstack,\n+\t\t\t    enum gtc_mode mode)\n {\n   hashval_t v;\n   void **slot;\n@@ -4067,11 +4076,11 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t{\n \t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n \t  v = iterative_hash_name\n-\t      (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n+\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n \t}\n       else\n \tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n+\t\t   sccstack, sccstate, sccstate_obstack, mode);\n     }\n \n   /* For integer types hash the types min/max values and the string flag.  */\n@@ -4092,15 +4101,15 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n     {\n       v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n       v = visit (TYPE_DOMAIN (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n+\t\t sccstack, sccstate, sccstate_obstack, mode);\n     }\n \n   /* Recurse for aggregates with a single element type.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       || TREE_CODE (type) == COMPLEX_TYPE\n       || TREE_CODE (type) == VECTOR_TYPE)\n     v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n+\t       sccstack, sccstate, sccstate_obstack, mode);\n \n   /* Incorporate function return and argument types.  */\n   if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n@@ -4111,18 +4120,18 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n       /* For method types also incorporate their parent class.  */\n       if (TREE_CODE (type) == METHOD_TYPE)\n \tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n+\t\t   sccstack, sccstate, sccstate_obstack, mode);\n \n       /* For result types allow mismatch in completeness.  */\n       if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n \t{\n \t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n \t  v = iterative_hash_name\n-\t      (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n+\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n \t}\n       else\n \tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n+\t\t   sccstack, sccstate, sccstate_obstack, mode);\n \n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n@@ -4131,11 +4140,11 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t    {\n \t      v = iterative_hash_hashval_t (TREE_CODE (TREE_VALUE (p)), v);\n \t      v = iterative_hash_name\n-\t\t  (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n+\t\t    (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n \t    }\n \t  else\n \t    v = visit (TREE_VALUE (p), state, v,\n-\t\t       sccstack, sccstate, sccstate_obstack);\n+\t\t       sccstack, sccstate, sccstate_obstack, mode);\n \t  na++;\n \t}\n \n@@ -4149,13 +4158,15 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n       unsigned nf;\n       tree f;\n \n-      v = iterative_hash_name (TYPE_NAME (TYPE_MAIN_VARIANT (type)), v);\n+      if (mode == GTC_MERGE)\n+\tv = iterative_hash_name (TYPE_NAME (TYPE_MAIN_VARIANT (type)), v);\n \n       for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n \t{\n-\t  v = iterative_hash_name (DECL_NAME (f), v);\n+\t  if (mode == GTC_MERGE)\n+\t    v = iterative_hash_name (DECL_NAME (f), v);\n \t  v = visit (TREE_TYPE (f), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n+\t\t     sccstack, sccstate, sccstate_obstack, mode);\n \t  nf++;\n \t}\n \n@@ -4180,7 +4191,9 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t  cstate->on_sccstack = false;\n \t  m->base.from = x;\n \t  m->to = cstate->u.hash;\n-\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n+\t  slot = htab_find_slot (mode == GTC_MERGE\n+\t\t\t\t ? type_hash_cache : canonical_type_hash_cache,\n+\t\t\t\t m, INSERT);\n \t  gcc_assert (!*slot);\n \t  *slot = (void *) m;\n \t}\n@@ -4200,7 +4213,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n    types according to gimple_types_compatible_p.  */\n \n static hashval_t\n-gimple_type_hash (const void *p)\n+gimple_type_hash_1 (const void *p, enum gtc_mode mode)\n {\n   const_tree t = (const_tree) p;\n   VEC(tree, heap) *sccstack = NULL;\n@@ -4210,12 +4223,19 @@ gimple_type_hash (const void *p)\n   void **slot;\n   struct tree_int_map m;\n \n-  if (type_hash_cache == NULL)\n+  if (mode == GTC_MERGE\n+      && type_hash_cache == NULL)\n     type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n \t\t\t\t       tree_int_map_eq, NULL);\n+  else if (mode == GTC_DIAG\n+\t   && canonical_type_hash_cache == NULL)\n+    canonical_type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t\t\t tree_int_map_eq, NULL);\n \n   m.base.from = CONST_CAST_TREE (t);\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+  if ((slot = htab_find_slot (mode == GTC_MERGE\n+\t\t\t      ? type_hash_cache : canonical_type_hash_cache,\n+\t\t\t      &m, NO_INSERT))\n       && *slot)\n     return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n \n@@ -4224,14 +4244,27 @@ gimple_type_hash (const void *p)\n   sccstate = pointer_map_create ();\n   gcc_obstack_init (&sccstate_obstack);\n   val = iterative_hash_gimple_type (CONST_CAST_TREE (t), 0,\n-\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n+\t\t\t\t    &sccstack, sccstate, &sccstate_obstack,\n+\t\t\t\t    mode);\n   VEC_free (tree, heap, sccstack);\n   pointer_map_destroy (sccstate);\n   obstack_free (&sccstate_obstack, NULL);\n \n   return val;\n }\n \n+static hashval_t\n+gimple_type_hash (const void *p)\n+{\n+  return gimple_type_hash_1 (p, GTC_MERGE);\n+}\n+\n+static hashval_t\n+gimple_canonical_type_hash (const void *p)\n+{\n+  return gimple_type_hash_1 (p, GTC_DIAG);\n+}\n+\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n@@ -4399,7 +4432,7 @@ gimple_register_canonical_type (tree t)\n     gimple_register_canonical_type (TYPE_MAIN_VARIANT (t));\n \n   if (gimple_canonical_types == NULL)\n-    gimple_canonical_types = htab_create_ggc (16381, gimple_type_hash,\n+    gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n \t\t\t\t\t      gimple_canonical_type_eq, 0);\n \n   slot = htab_find_slot (gimple_canonical_types, t, INSERT);\n@@ -4439,6 +4472,16 @@ print_gimple_types_stats (void)\n \t     htab_collisions (gimple_types));\n   else\n     fprintf (stderr, \"GIMPLE type table is empty\\n\");\n+  if (type_hash_cache)\n+    fprintf (stderr, \"GIMPLE type hash table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (type_hash_cache),\n+\t     (long) htab_elements (type_hash_cache),\n+\t     (long) type_hash_cache->searches,\n+\t     (long) type_hash_cache->collisions,\n+\t     htab_collisions (type_hash_cache));\n+  else\n+    fprintf (stderr, \"GIMPLE type hash table is empty\\n\");\n   if (gimple_canonical_types)\n     fprintf (stderr, \"GIMPLE canonical type table: size %ld, %ld elements, \"\n \t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n@@ -4449,16 +4492,16 @@ print_gimple_types_stats (void)\n \t     htab_collisions (gimple_canonical_types));\n   else\n     fprintf (stderr, \"GIMPLE canonical type table is empty\\n\");\n-  if (type_hash_cache)\n-    fprintf (stderr, \"GIMPLE type hash table: size %ld, %ld elements, \"\n+  if (canonical_type_hash_cache)\n+    fprintf (stderr, \"GIMPLE canonical type hash table: size %ld, %ld elements, \"\n \t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n-\t     (long) htab_size (type_hash_cache),\n-\t     (long) htab_elements (type_hash_cache),\n-\t     (long) type_hash_cache->searches,\n-\t     (long) type_hash_cache->collisions,\n-\t     htab_collisions (type_hash_cache));\n+\t     (long) htab_size (canonical_type_hash_cache),\n+\t     (long) htab_elements (canonical_type_hash_cache),\n+\t     (long) canonical_type_hash_cache->searches,\n+\t     (long) canonical_type_hash_cache->collisions,\n+\t     htab_collisions (canonical_type_hash_cache));\n   else\n-    fprintf (stderr, \"GIMPLE type hash table is empty\\n\");\n+    fprintf (stderr, \"GIMPLE canonical type hash table is empty\\n\");\n   if (gtc_visited)\n     fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n \t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n@@ -4495,6 +4538,11 @@ free_gimple_type_tables (void)\n       htab_delete (type_hash_cache);\n       type_hash_cache = NULL;\n     }\n+  if (canonical_type_hash_cache)\n+    {\n+      htab_delete (canonical_type_hash_cache);\n+      canonical_type_hash_cache = NULL;\n+    }\n   if (gtc_visited)\n     {\n       htab_delete (gtc_visited);"}, {"sha": "b0e2553f12f9c7446ff9d186d930b472d55d4c22", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a844a60b40efe94d6437bb5b3410fbc0a74f2000", "patch": "@@ -1,3 +1,9 @@\n+2010-12-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44871\n+\t* g++.dg/lto/20101126-1_0.C: New testcase.\n+\t* g++.dg/lto/20101126-1_1.c: Likewise.\n+\n 2010-12-02  Richard Guenther  <rguenther@suse.de>\n             Ira Rosen  <irar@il.ibm.com>\n "}, {"sha": "93a1cf3afba4b08653336e2f4cb948267cf00c40", "filename": "gcc/testsuite/g++.dg/lto/20101126-1_0.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_0.C?ref=a844a60b40efe94d6437bb5b3410fbc0a74f2000", "patch": "@@ -0,0 +1,5 @@\n+typedef struct { int i; } T1;\n+typedef T1 T2;\n+extern T1 a;\n+extern T2 b;\n+int main() { return a.i + b.i; }"}, {"sha": "628e89b6cffb2bc3d668a0de9a9b68cd7c1b4803", "filename": "gcc/testsuite/g++.dg/lto/20101126-1_1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844a60b40efe94d6437bb5b3410fbc0a74f2000/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20101126-1_1.c?ref=a844a60b40efe94d6437bb5b3410fbc0a74f2000", "patch": "@@ -0,0 +1,4 @@\n+typedef struct { int i; } T1;\n+typedef T1 T2;\n+T1 a;\n+T2 b;"}]}