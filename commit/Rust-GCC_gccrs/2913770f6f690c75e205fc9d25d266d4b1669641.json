{"sha": "2913770f6f690c75e205fc9d25d266d4b1669641", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkxMzc3MGY2ZjY5MGM3NWUyMDVmYzlkMjVkMjY2ZDRiMTY2OTY0MQ==", "commit": {"author": {"name": "Stefan Olsson", "email": "stefan@snon.net", "date": "2004-01-15T19:18:35Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-15T19:18:35Z"}, "message": "mt_allocator.h: Reuse thread id's as soon as possible by changing the behaviour of...\n\n\n2004-01-15  Stefan Olsson  <stefan@snon.net>\n\n\t* include/ext/mt_allocator.h: Reuse thread id's as soon as\n\tpossible by changing the behaviour of thread_freelist to do\n\tpush_front when threads die instead of push_back.\n\nFrom-SVN: r75939", "tree": {"sha": "7b86fb407c38d5f1fa1be30b21cdeded74b715eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b86fb407c38d5f1fa1be30b21cdeded74b715eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2913770f6f690c75e205fc9d25d266d4b1669641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2913770f6f690c75e205fc9d25d266d4b1669641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2913770f6f690c75e205fc9d25d266d4b1669641", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2913770f6f690c75e205fc9d25d266d4b1669641/comments", "author": null, "committer": null, "parents": [{"sha": "ecc748322be8da4053b1d66904200b67b1d732a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc748322be8da4053b1d66904200b67b1d732a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecc748322be8da4053b1d66904200b67b1d732a2"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "4ea985bd8aeead18377c971747b7bcc63f5ed7a1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2913770f6f690c75e205fc9d25d266d4b1669641/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2913770f6f690c75e205fc9d25d266d4b1669641/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2913770f6f690c75e205fc9d25d266d4b1669641", "patch": "@@ -1,3 +1,9 @@\n+2004-01-15  Stefan Olsson  <stefan@snon.net>\n+\n+\t* include/ext/mt_allocator.h: Reuse thread id's as soon as\n+\tpossible by changing the behaviour of thread_freelist to do\n+\tpush_front when threads die instead of push_back.\n+\n 2004-01-14  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.h (struct __numpunct_cache):"}, {"sha": "b4498feddf3c9de30ab0908bd58ede09e7267374", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2913770f6f690c75e205fc9d25d266d4b1669641/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2913770f6f690c75e205fc9d25d266d4b1669641/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=2913770f6f690c75e205fc9d25d266d4b1669641", "patch": "@@ -122,7 +122,7 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n       static __gthread_once_t _S_once_mt;\n #endif\n-      static bool _S_initialized;\n+      static bool volatile _S_initialized;\n \n       /*\n        * Using short int as type for the binmap implies we are never caching\n@@ -151,24 +151,23 @@ namespace __gnu_cxx\n        * memory we remove the first record in this list and stores the address\n        * in a __gthread_key. When initializing the __gthread_key\n        * we specify a destructor. When this destructor (i.e. the thread dies)\n-       * is called, we return the thread id to the back of this list.\n+       * is called, we return the thread id to the front of this list.\n        */\n #ifdef __GTHREADS\n       struct thread_record\n       {\n         /*\n          * Points to next free thread id record. NULL if last record in list.\n          */\n-        thread_record* next;\n+        thread_record* volatile next;\n \n         /*\n          * Thread id ranging from 1 to _S_max_threads.\n          */\n         size_t id;\n       };\n \n-      static thread_record* _S_thread_freelist_first;\n-      static thread_record* _S_thread_freelist_last;\n+      static thread_record* volatile _S_thread_freelist_first;\n       static __gthread_mutex_t _S_thread_freelist_mutex;\n       static void _S_thread_key_destr(void* freelist_pos);\n       static __gthread_key_t _S_thread_key;\n@@ -412,7 +411,7 @@ namespace __gnu_cxx\n           {\n             free(__p);\n             return;\n-           }\n+          }\n \n         /*\n          * Round up to power of 2 and figure out which bin to use\n@@ -599,11 +598,10 @@ namespace __gnu_cxx\n             }\n \n           /*\n-           * Set last record and pointer to this\n+           * Set last record\n            */\n           _S_thread_freelist_first[i - 1].next = NULL;\n           _S_thread_freelist_first[i - 1].id = i;\n-          _S_thread_freelist_last = &_S_thread_freelist_first[i - 1];\n \n           /*\n            * Initialize per thread key to hold pointer to\n@@ -708,12 +706,11 @@ namespace __gnu_cxx\n         }\n \n       /*\n-       * Return this thread id record to thread_freelist\n+       * Return this thread id record to front of thread_freelist\n        */\n       __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-      _S_thread_freelist_last->next = (thread_record*)freelist_pos;\n-      _S_thread_freelist_last = (thread_record*)freelist_pos;\n-      _S_thread_freelist_last->next = NULL;\n+      ((thread_record*)freelist_pos)->next = _S_thread_freelist_first;\n+      _S_thread_freelist_first = (thread_record*)freelist_pos;\n       __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n     }\n \n@@ -730,7 +727,7 @@ namespace __gnu_cxx\n        */\n       if (__gthread_active_p())\n         {\n-          thread_record* freelist_pos;\n+          thread_record* volatile freelist_pos;\n \n           if ((freelist_pos =\n               (thread_record*)__gthread_getspecific(_S_thread_key)) == NULL)\n@@ -778,7 +775,7 @@ namespace __gnu_cxx\n #endif\n \n   template<typename _Tp> bool\n-  __mt_alloc<_Tp>::_S_initialized = false;\n+  volatile __mt_alloc<_Tp>::_S_initialized = false;\n \n   template<typename _Tp> typename __mt_alloc<_Tp>::binmap_type*\n   __mt_alloc<_Tp>::_S_binmap = NULL;\n@@ -829,10 +826,7 @@ namespace __gnu_cxx\n    */\n #ifdef __GTHREADS\n   template<typename _Tp> typename __mt_alloc<_Tp>::thread_record*\n-  __mt_alloc<_Tp>::_S_thread_freelist_first = NULL;\n-\n-  template<typename _Tp> typename __mt_alloc<_Tp>::thread_record*\n-  __mt_alloc<_Tp>::_S_thread_freelist_last = NULL;\n+  volatile __mt_alloc<_Tp>::_S_thread_freelist_first = NULL;\n \n   template<typename _Tp> __gthread_mutex_t\n   __mt_alloc<_Tp>::_S_thread_freelist_mutex = __GTHREAD_MUTEX_INIT;"}]}