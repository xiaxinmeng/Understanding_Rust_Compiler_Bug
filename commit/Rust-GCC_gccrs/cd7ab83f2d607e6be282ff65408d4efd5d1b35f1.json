{"sha": "cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q3YWI4M2YyZDYwN2U2YmUyODJmZjY1NDA4ZDRlZmQ1ZDFiMzVmMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-29T17:15:42Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-29T17:15:42Z"}, "message": "cppexp.c (cpp_num): Move to cpplib.h.\n\n2002-05-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n\t    Zack Weinberg <zack@codesourcery.com>\n\n\t* cppexp.c (cpp_num): Move to cpplib.h.\n\t(CPP_ERROR): Remove.\n\t(interpret_float_suffix, interpret_int_suffix): New.\n\t(struct suffix, vsuf_1, vsuf_2, vsuf_3): Remove.\n\t(cpp_classify_number, cpp_interpret_integer): New.\n\t(interpret_number): Remove.\n\t(eval_token): Update to use new routines.\n\t* cpphash.h (cpp_num_part): Move to cpplib.h.\n\t* cppinit.c (cpp_post_options): Set warn_long_long.\n\t* cpplib.h (struct cpp_options): Add warn_long_long.\n\t(cpp_num, cpp_num_part, CPP_N_CATEGORY, CPP_N_INVALID,\n\tCPP_N_INTEGER, CPP_N_FLOATING, CPP_N_WIDTH, CPP_N_SMALL,\n\tCPP_N_MEDIUM, CPP_N_LARGE, CPP_N_RADIX, CPP_N_DEC, CPP_N_HEX,\n\tCPP_N_OCTAL, CPP_N_UNSIGNED, CPP_N_IMAGINARY, cpp_classify_number,\n\tcpp_interpret_integer): New.\ntestsuite:\n\t* gcc.dg/cpp/c++98-pedantic.c, gcc.dg/cpp/c89-pedantic.c,\n\tgcc.dg/cpp/c94-pedantic.c, gcc.dg/cpp/gnuc89-pedantic.c,\n\tgcc.dg/cpp/if-1.c: Update for modified diagnostics.\n\nCo-Authored-By: Zack Weinberg <zack@codesourcery.com>\n\nFrom-SVN: r54007", "tree": {"sha": "cb54dc5c6bb9ba60a0d20a46d9816c704bcb8afa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb54dc5c6bb9ba60a0d20a46d9816c704bcb8afa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/comments", "author": null, "committer": null, "parents": [{"sha": "61a8515c94ea4a9524e708d7a6e2a172d7cbd48e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a8515c94ea4a9524e708d7a6e2a172d7cbd48e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a8515c94ea4a9524e708d7a6e2a172d7cbd48e"}], "stats": {"total": 602, "additions": 414, "deletions": 188}, "files": [{"sha": "75ebd81002c8468e1d8e0200e08dc0d0595f116a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -1,3 +1,22 @@\n+2002-05-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\t    Zack Weinberg <zack@codesourcery.com>\n+\n+\t* cppexp.c (cpp_num): Move to cpplib.h.\n+\t(CPP_ERROR): Remove.\n+\t(interpret_float_suffix, interpret_int_suffix): New.\n+\t(struct suffix, vsuf_1, vsuf_2, vsuf_3): Remove.\n+\t(cpp_classify_number, cpp_interpret_integer): New.\n+\t(interpret_number): Remove.\n+\t(eval_token): Update to use new routines.\n+\t* cpphash.h (cpp_num_part): Move to cpplib.h.\n+\t* cppinit.c (cpp_post_options): Set warn_long_long.\n+\t* cpplib.h (struct cpp_options): Add warn_long_long.\n+\t(cpp_num, cpp_num_part, CPP_N_CATEGORY, CPP_N_INVALID,\n+\tCPP_N_INTEGER, CPP_N_FLOATING, CPP_N_WIDTH, CPP_N_SMALL,\n+\tCPP_N_MEDIUM, CPP_N_LARGE, CPP_N_RADIX, CPP_N_DEC, CPP_N_HEX,\n+\tCPP_N_OCTAL, CPP_N_UNSIGNED, CPP_N_IMAGINARY, cpp_classify_number,\n+\tcpp_interpret_integer): New.\n+\n 2002-05-29  Joel Sherrill <joel@OARcorp.com>\n \n \t* config/rs6000/rs6000.h (ASM_CPU_SPEC): Use -m403 and -m405."}, {"sha": "73a892ff79bf6627f9ebd419d38c1314ae31cdc4", "filename": "gcc/cppexp.c", "status": "modified", "additions": 332, "deletions": 181, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -23,23 +23,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-typedef struct cpp_num cpp_num;\n-\n #define PART_PRECISION (sizeof (cpp_num_part) * CHAR_BIT)\n #define HALF_MASK (~(cpp_num_part) 0 >> (PART_PRECISION / 2))\n #define LOW_PART(num_part) (num_part & HALF_MASK)\n #define HIGH_PART(num_part) (num_part >> (PART_PRECISION / 2))\n \n-/* A preprocessing number.  Code assumes that any unused high bits of\n-   the double integer are set to zero.  */\n-struct cpp_num\n-{\n-  cpp_num_part high;\n-  cpp_num_part low;\n-  bool unsignedp;  /* True if value should be treated as unsigned.  */\n-  bool overflow;   /* True if the most recent calculation overflowed.  */\n-};\n-\n struct op\n {\n   cpp_num value;\t\t     /* The value logically \"right\" of op.  */\n@@ -72,15 +60,13 @@ static cpp_num num_lshift PARAMS ((cpp_num, size_t, size_t));\n static cpp_num num_rshift PARAMS ((cpp_num, size_t, size_t));\n \n static cpp_num append_digit PARAMS ((cpp_num, int, int, size_t));\n-static cpp_num interpret_number PARAMS ((cpp_reader *, const cpp_token *));\n static cpp_num parse_defined PARAMS ((cpp_reader *));\n static cpp_num eval_token PARAMS ((cpp_reader *, const cpp_token *));\n static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n+static unsigned int interpret_float_suffix PARAMS ((const uchar *, size_t));\n+static unsigned int interpret_int_suffix PARAMS ((const uchar *, size_t));\n \n-/* Token type abuse.  There is no \"error\" token, but we can't get\n-   comments in #if, so we can abuse that token type.  Similarly,\n-   create unary plus and minus operators.  */\n-#define CPP_ERROR CPP_COMMENT\n+/* Token type abuse to create unary plus and minus operators.  */\n #define CPP_UPLUS (CPP_LAST_CPP_OP + 1)\n #define CPP_UMINUS (CPP_LAST_CPP_OP + 2)\n \n@@ -91,28 +77,317 @@ static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n #define SYNTAX_ERROR2(msgid, arg) \\\n   do { cpp_error (pfile, DL_ERROR, msgid, arg); goto syntax_error; } while(0)\n \n-struct suffix\n+/* Subroutine of cpp_classify_number.  S points to a float suffix of\n+   length LEN, possibly zero.  Returns 0 for an invalid suffix, or a\n+   flag vector describing the suffix.  */\n+static unsigned int\n+interpret_float_suffix (s, len)\n+     const uchar *s;\n+     size_t len;\n {\n-  const unsigned char s[4];\n-  const unsigned char u;\n-  const unsigned char l;\n-};\n+  size_t f = 0, l = 0, i = 0;\n \n-static const struct suffix vsuf_1[] = {\n-  { \"u\", 1, 0 }, { \"U\", 1, 0 },\n-  { \"l\", 0, 1 }, { \"L\", 0, 1 }\n-};\n+  while (len--)\n+    switch (s[len])\n+      {\n+      case 'f': case 'F': f++; break;\n+      case 'l': case 'L': l++; break;\n+      case 'i': case 'I':\n+      case 'j': case 'J': i++; break;\n+      default:\n+\treturn 0;\n+      }\n \n-static const struct suffix vsuf_2[] = {\n-  { \"ul\", 1, 1 }, { \"UL\", 1, 1 }, { \"uL\", 1, 1 }, { \"Ul\", 1, 1 },\n-  { \"lu\", 1, 1 }, { \"LU\", 1, 1 }, { \"Lu\", 1, 1 }, { \"lU\", 1, 1 },\n-  { \"ll\", 0, 2 }, { \"LL\", 0, 2 }\n-};\n+  if (f + l > 1 || i > 1)\n+    return 0;\n \n-static const struct suffix vsuf_3[] = {\n-  { \"ull\", 1, 2 }, { \"ULL\", 1, 2 }, { \"uLL\", 1, 2 }, { \"Ull\", 1, 2 },\n-  { \"llu\", 1, 2 }, { \"LLU\", 1, 2 }, { \"LLu\", 1, 2 }, { \"llU\", 1, 2 }\n-};\n+  return ((i ? CPP_N_IMAGINARY : 0)\n+\t  | (f ? CPP_N_SMALL :\n+\t     l ? CPP_N_LARGE : CPP_N_MEDIUM));\n+}\n+\n+/* Subroutine of cpp_classify_number.  S points to an integer suffix\n+   of length LEN, possibly zero. Returns 0 for an invalid suffix, or a\n+   flag vector describing the suffix.  */\n+static unsigned int\n+interpret_int_suffix (s, len)\n+     const uchar *s;\n+     size_t len;\n+{\n+  size_t u, l, i;\n+\n+  u = l = i = 0;\n+\n+  while (len--)\n+    switch (s[len])\n+      {\n+      case 'u': case 'U':\tu++; break;\n+      case 'i': case 'I':\n+      case 'j': case 'J':\ti++; break;\n+      case 'l': case 'L':\tl++;\n+\t/* If there are two Ls, they must be adjacent and the same case.  */\n+\tif (l == 2 && s[len] != s[len + 1])\n+\t  return 0;\n+\tbreak;\n+      default:\n+\treturn 0;\n+      }\n+\n+  if (l > 2 || u > 1 || i > 1)\n+    return 0;\n+\n+  return ((i ? CPP_N_IMAGINARY : 0)\n+\t  | (u ? CPP_N_UNSIGNED : 0)\n+\t  | ((l == 0) ? CPP_N_SMALL\n+\t     : (l == 1) ? CPP_N_MEDIUM : CPP_N_LARGE));\n+}\n+\n+/* Categorize numeric constants according to their field (integer,\n+   floating point, or invalid), radix (decimal, octal, hexadecimal),\n+   and type suffixes.  */\n+unsigned int\n+cpp_classify_number (pfile, token)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+{\n+  const uchar *str = token->val.str.text;\n+  const uchar *limit;\n+  unsigned int max_digit, result, radix;\n+  enum {NOT_FLOAT = 0, AFTER_POINT, AFTER_EXPON} float_flag;\n+\n+  /* If the lexer has done its job, length one can only be a single\n+     digit.  Fast-path this very common case.  */\n+  if (token->val.str.len == 1)\n+    return CPP_N_INTEGER | CPP_N_SMALL | CPP_N_DECIMAL;\n+\n+  limit = str + token->val.str.len;\n+  float_flag = NOT_FLOAT;\n+  max_digit = 0;\n+  radix = 10;\n+\n+  /* First, interpret the radix.  */\n+  if (*str == '0')\n+    {\n+      radix = 8;\n+      str++;\n+\n+      /* Require at least one hex digit to classify it as hex.  */\n+      if ((*str == 'x' || *str == 'X') && ISXDIGIT (str[1]))\n+\t{\n+\t  radix = 16;\n+\t  str++;\n+\t}\n+    }\n+\n+  /* Now scan for a well-formed integer or float.  */\n+  for (;;)\n+    {\n+      unsigned int c = *str++;\n+\n+      if (ISDIGIT (c) || (ISXDIGIT (c) && radix == 16))\n+\t{\n+\t  c = hex_value (c);\n+\t  if (c > max_digit)\n+\t    max_digit = c;\n+\t}\n+      else if (c == '.')\n+\t{\n+\t  if (float_flag == NOT_FLOAT)\n+\t    float_flag = AFTER_POINT;\n+\t  else\n+\t    SYNTAX_ERROR (\"too many decimal points in number\");\n+\t}\n+      else if ((radix <= 10 && (c == 'e' || c == 'E'))\n+\t       || (radix == 16 && (c == 'p' || c == 'P')))\n+\t{\n+\t  float_flag = AFTER_EXPON;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  /* Start of suffix.  */\n+\t  str--;\n+\t  break;\n+\t}\n+    }\n+\n+  if (float_flag != NOT_FLOAT && radix == 8)\n+    radix = 10;\n+\n+  if (max_digit >= radix)\n+    SYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in octal constant\", '0' + max_digit);\n+\n+  if (float_flag != NOT_FLOAT)\n+    {\n+      if (radix == 16 && CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, c99))\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"use of C99 hexadecimal floating constant\");\n+\n+      if (float_flag == AFTER_EXPON)\n+\t{\n+\t  if (*str == '+' || *str == '-')\n+\t    str++;\n+\n+\t  /* Exponent is decimal, even if string is a hex float.  */\n+\t  if (!ISDIGIT (*str))\n+\t    SYNTAX_ERROR (\"exponent has no digits\");\n+\n+\t  do\n+\t    str++;\n+\t  while (ISDIGIT (*str));\n+\t}\n+      else if (radix == 16)\n+\tSYNTAX_ERROR (\"hexadecimal floating constants require an exponent\");\n+\n+      result = interpret_float_suffix (str, limit - str);\n+      if (result == 0)\n+\t{\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"invalid suffix \\\"%.*s\\\" on floating constant\",\n+\t\t     limit - str, str);\n+\t  return CPP_N_INVALID;\n+\t}\n+\n+      /* Traditional C didn't accept any floating suffixes.  */\n+      if (limit != str\n+\t  && CPP_WTRADITIONAL (pfile)\n+\t  && ! cpp_sys_macro_p (pfile))\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"traditional C rejects the \\\"%.*s\\\" suffix\",\n+\t\t   limit - str, str);\n+\n+      result |= CPP_N_FLOATING;\n+    }\n+  else\n+    {\n+      result = interpret_int_suffix (str, limit - str);\n+      if (result == 0)\n+\t{\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"invalid suffix \\\"%.*s\\\" on integer constant\",\n+\t\t     limit - str, str);\n+\t  return CPP_N_INVALID;\n+\t}\n+\n+      /* Traditional C only accepted the 'L' suffix.  */\n+      if (result != CPP_N_SMALL && result != CPP_N_MEDIUM\n+\t  && CPP_WTRADITIONAL (pfile)\n+\t  && ! cpp_sys_macro_p (pfile))\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"traditional C rejects the \\\"%.*s\\\" suffix\",\n+\t\t   limit - str, str);\n+\n+      if ((result & CPP_N_WIDTH) == CPP_N_LARGE\n+\t  && ! CPP_OPTION (pfile, c99)\n+\t  && CPP_OPTION (pfile, warn_long_long))\n+\tcpp_error (pfile, DL_PEDWARN, \"use of C99 long long integer constant\");\n+\n+      result |= CPP_N_INTEGER;\n+    }\n+\n+  if ((result & CPP_N_IMAGINARY) && CPP_PEDANTIC (pfile))\n+    cpp_error (pfile, DL_PEDWARN, \"imaginary constants are a GCC extension\");\n+\n+  if (radix == 10)\n+    result |= CPP_N_DECIMAL;\n+  else if (radix == 16)\n+    result |= CPP_N_HEX;\n+  else\n+    result |= CPP_N_OCTAL;\n+\n+  return result;\n+\n+ syntax_error:\n+  return CPP_N_INVALID;\n+}\n+\n+/* cpp_interpret_integer converts an integer constant into a cpp_num,\n+   of precision options->precision.\n+\n+   We do not provide any interface for decimal->float conversion,\n+   because the preprocessor doesn't need it and the floating point\n+   handling in GCC proper is too ugly to speak of.  */\n+cpp_num\n+cpp_interpret_integer (pfile, token, type)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+     unsigned int type;\n+{\n+  const uchar *p, *end;\n+  cpp_num result;\n+\n+  result.low = 0;\n+  result.high = 0;\n+  result.unsignedp = type & CPP_N_UNSIGNED;\n+  result.overflow = 0;\n+\n+  p = token->val.str.text;\n+  end = p + token->val.str.len;\n+\n+  /* Common case of a single digit.  */\n+  if (token->val.str.len == 1)\n+    result.low = p[0] - '0';\n+  else\n+    {\n+      cpp_num_part max;\n+      size_t precision = CPP_OPTION (pfile, precision);\n+      unsigned int base = 10, c = 0;\n+      bool overflow = false;\n+\n+      if ((type & CPP_N_RADIX) == CPP_N_OCTAL)\n+\t{\n+\t  base = 8;\n+\t  p++;\n+\t}\n+      else if ((type & CPP_N_RADIX) == CPP_N_HEX)\n+\t{\n+\t  base = 16;\n+\t  p += 2;\n+\t}\n+\n+      /* We can add a digit to numbers strictly less than this without\n+\t needing the precision and slowness of double integers.  */\n+      max = ~(cpp_num_part) 0;\n+      if (precision < PART_PRECISION)\n+\tmax >>= PART_PRECISION - precision;\n+      max = (max - base + 1) / base + 1;\n+\n+      for (; p < end; p++)\n+\t{\n+\t  c = *p;\n+\n+\t  if (ISDIGIT (c) || (base == 16 && ISXDIGIT (c)))\n+\t    c = hex_value (c);\n+\t  else\n+\t    break;\n+\n+\t  /* Strict inequality for when max is set to zero.  */\n+\t  if (result.low < max)\n+\t    result.low = result.low * base + c;\n+\t  else\n+\t    {\n+\t      result = append_digit (result, c, base, precision);\n+\t      overflow |= result.overflow;\n+\t      max = 0;\n+\t    }\n+\t}\n+\n+      if (overflow)\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"integer constant is too large for its type\");\n+      else if (!result.unsignedp && !num_positive (result, precision))\n+\t{\n+\t  /* If too big to be signed, consider it unsigned.  Only warn\n+\t     for decimal numbers.  */\n+\t  if (base == 10)\n+\t    cpp_error (pfile, DL_WARNING,\n+\t\t       \"integer constant is so large that it is unsigned\");\n+\t  result.unsignedp = 1;\n+\t}\n+    }\n+\n+  return result;\n+}\n \n /* Append DIGIT to NUM, a number of PRECISION bits being read in base\n    BASE.  */\n@@ -167,149 +442,6 @@ append_digit (num, digit, base, precision)\n   return result;\n }\n \n-/* Parse and convert what is presumably an integer in TOK.  Accepts\n-   decimal, hex, or octal with or without size suffixes.  Returned op\n-   is CPP_ERROR on error, otherwise it is a CPP_NUMBER.  */\n-static cpp_num\n-interpret_number (pfile, tok)\n-     cpp_reader *pfile;\n-     const cpp_token *tok;\n-{\n-  cpp_num result;\n-  cpp_num_part max;\n-  const uchar *p = tok->val.str.text;\n-  const uchar *end;\n-  const struct suffix *sufftab;\n-  size_t precision;\n-  unsigned int i, nsuff, base, c;\n-  bool overflow, big_digit;\n-\n-  result.low = 0;\n-  result.high = 0;\n-  result.unsignedp = 0;\n-  result.overflow = 0;\n-\n-  /* Common case of a single digit.  */\n-  end = p + tok->val.str.len;\n-  if (tok->val.str.len == 1 && (unsigned int) (p[0] - '0') <= 9)\n-    {\n-      result.low = p[0] - '0';\n-      return result;\n-    }\n-\n-  base = 10;\n-  if (p[0] == '0')\n-    {\n-      if (end - p >= 3 && (p[1] == 'x' || p[1] == 'X'))\n-\t{\n-\t  p += 2;\n-\t  base = 16;\n-\t}\n-      else\n-\t{\n-\t  p += 1;\n-\t  base = 8;\n-\t}\n-    }\n-\n-  c = 0;\n-  overflow = big_digit = false;\n-  precision = CPP_OPTION (pfile, precision);\n-\n-  /* We can add a digit to numbers less than this without needing\n-     double integers.  9 is the maximum digit for octal and decimal;\n-     for hex it is annihilated by the division anyway.  */\n-  max = ~(cpp_num_part) 0;\n-  if (precision < PART_PRECISION)\n-    max >>= PART_PRECISION - precision;\n-  max = (max - 9) / base + 1;\n-\n-  for(; p < end; p++)\n-    {\n-      c = *p;\n-\n-      if (ISDIGIT (c) || (base == 16 && ISXDIGIT (c)))\n-\tc = hex_value (c);\n-      else\n-\tbreak;\n-\n-      if (c >= base)\n-\tbig_digit = true;\n-\n-      /* Strict inequality for when max is set to zero.  */\n-      if (result.low < max)\n-\tresult.low = result.low * base + c;\n-      else\n-\t{\n-\t  result = append_digit (result, c, base, precision);\n-\t  overflow |= result.overflow;\n-\t  max = 0;\n-\t}\n-    }\n-\n-  if (p < end)\n-    {\n-      /* Check for a floating point constant.  Note that float constants\n-\t with an exponent or suffix but no decimal point are technically\n-\t invalid (C99 6.4.4.2) but accepted elsewhere.  */\n-      if ((c == '.' || c == 'F' || c == 'f')\n-\t  || (base == 10 && (c == 'E' || c == 'e')\n-\t      && p+1 < end && (p[1] == '+' || p[1] == '-'))\n-\t  || (base == 16 && (c == 'P' || c == 'p')\n-\t      && p+1 < end && (p[1] == '+' || p[1] == '-')))\n-\tSYNTAX_ERROR (\"floating point numbers are not valid in #if\");\n-\n-      /* Determine the suffix. l means long, and u means unsigned.\n-\t See the suffix tables, above.  */\n-      switch (end - p)\n-\t{\n-\tcase 1: sufftab = vsuf_1; nsuff = ARRAY_SIZE (vsuf_1); break;\n-\tcase 2: sufftab = vsuf_2; nsuff = ARRAY_SIZE (vsuf_2); break;\n-\tcase 3: sufftab = vsuf_3; nsuff = ARRAY_SIZE (vsuf_3); break;\n-\tdefault: goto invalid_suffix;\n-\t}\n-\n-      for (i = 0; i < nsuff; i++)\n-\tif (memcmp (p, sufftab[i].s, end - p) == 0)\n-\t  break;\n-      if (i == nsuff)\n-\tgoto invalid_suffix;\n-      result.unsignedp = sufftab[i].u;\n-\n-      if (CPP_WTRADITIONAL (pfile)\n-\t  && sufftab[i].u\n-\t  && ! cpp_sys_macro_p (pfile))\n-\tcpp_error (pfile, DL_WARNING, \"traditional C rejects the `U' suffix\");\n-      if (sufftab[i].l == 2 && CPP_OPTION (pfile, pedantic)\n-\t  && ! CPP_OPTION (pfile, c99))\n-\tcpp_error (pfile, DL_PEDWARN,\n-\t\t   \"too many 'l' suffixes in integer constant\");\n-    }\n-\n-  if (big_digit)\n-    cpp_error (pfile, DL_PEDWARN,\n-\t       \"integer constant contains digits beyond the radix\");\n-\n-  if (overflow)\n-    cpp_error (pfile, DL_PEDWARN, \"integer constant too large for its type\");\n-  /* If too big to be signed, consider it unsigned.  */\n-  else if (!result.unsignedp && !num_positive (result, precision))\n-    {\n-      if (base == 10)\n-\tcpp_error (pfile, DL_WARNING,\n-\t\t   \"integer constant is so large that it is unsigned\");\n-      result.unsignedp = 1;\n-    }\n-\n-  return result;\n-\n- invalid_suffix:\n-  cpp_error (pfile, DL_ERROR, \"invalid suffix '%.*s' on integer constant\",\n-\t     (int) (end - p), p);\n- syntax_error:\n-  return result;\n-}\n-\n /* Handle meeting \"defined\" in a preprocessor expression.  */\n static cpp_num\n parse_defined (pfile)\n@@ -379,7 +511,7 @@ parse_defined (pfile)\n \n /* Convert a token into a CPP_NUMBER (an interpreted preprocessing\n    number or character constant, or the result of the \"defined\" or \"#\"\n-   operators), or CPP_ERROR on error.  */\n+   operators).  */\n static cpp_num\n eval_token (pfile, token)\n      cpp_reader *pfile;\n@@ -392,7 +524,26 @@ eval_token (pfile, token)\n   switch (token->type)\n     {\n     case CPP_NUMBER:\n-      return interpret_number (pfile, token);\n+      temp = cpp_classify_number (pfile, token);\n+      switch (temp & CPP_N_CATEGORY)\n+\t{\n+\tcase CPP_N_FLOATING:\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"floating constant in preprocessor expression\");\n+\t  break;\n+\tcase CPP_N_INTEGER:\n+\t  if (!(temp & CPP_N_IMAGINARY))\n+\t    return cpp_interpret_integer (pfile, token, temp);\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"imaginary number in preprocessor expression\");\n+\t  break;\n+\n+\tcase CPP_N_INVALID:\n+\t  /* Error already issued.  */\n+\t  break;\n+\t}\n+      result.high = result.low = 0;\n+      break;\n \n     case CPP_WCHAR:\n     case CPP_CHAR:\n@@ -604,7 +755,7 @@ _cpp_parse_expr (pfile)\n \n \tdefault:\n \t  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)\n-\t    SYNTAX_ERROR2 (\"token \\\"%s\\\" is not valid in #if expressions\",\n+\t    SYNTAX_ERROR2 (\"token \\\"%s\\\" is not valid in preprocessor expressions\",\n \t\t\t   cpp_token_as_text (pfile, token));\n \t  break;\n \t}"}, {"sha": "a059e2b0aac26b4e08912e195a42d5f8c3c97eb8", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -29,7 +29,6 @@ struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n \n-typedef unsigned HOST_WIDE_INT cpp_num_part;\n typedef unsigned char uchar;\n #define U (const uchar *)  /* Intended use: U\"string\" */\n "}, {"sha": "41842cb38329fc69fe16c7a6b1f33e409c5931aa", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -1774,6 +1774,9 @@ cpp_post_options (pfile)\n   if (CPP_OPTION (pfile, cplusplus))\n     CPP_OPTION (pfile, warn_traditional) = 0;\n \n+  CPP_OPTION (pfile, warn_long_long) = (CPP_OPTION (pfile, pedantic)\n+\t\t\t\t\t&& !CPP_OPTION (pfile, c99));\n+\n   /* Permanently disable macro expansion if we are rescanning\n      preprocessed text.  Read preprocesed source in ISO mode.  */\n   if (CPP_OPTION (pfile, preprocessed))"}, {"sha": "79fff2bdf5c0e98d0456c69234a9bfadc68d4e83", "filename": "gcc/cpplib.h", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -327,6 +327,9 @@ struct cpp_options\n      traditional C.  */\n   unsigned char warn_traditional;\n \n+  /* Nonzero means warn about long long numeric constants.  */\n+  unsigned char warn_long_long;\n+\n   /* Nonzero means warn about text after an #endif (or #else).  */\n   unsigned char warn_endif_labels;\n \n@@ -577,6 +580,51 @@ extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    int, int));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n+/* A preprocessing number.  Code assumes that any unused high bits of\n+   the double integer are set to zero.  */\n+typedef unsigned HOST_WIDE_INT cpp_num_part;\n+typedef struct cpp_num cpp_num;\n+struct cpp_num\n+{\n+  cpp_num_part high;\n+  cpp_num_part low;\n+  bool unsignedp;  /* True if value should be treated as unsigned.  */\n+  bool overflow;   /* True if the most recent calculation overflowed.  */\n+};\n+\n+/* cpplib provides two interfaces for interpretation of preprocessing\n+   numbers.\n+\n+   cpp_classify_number categorizes numeric constants according to\n+   their field (integer, floating point, or invalid), radix (decimal,\n+   octal, hexadecimal), and type suffixes.  */\n+\n+#define CPP_N_CATEGORY  0x000F\n+#define CPP_N_INVALID\t0x0000\n+#define CPP_N_INTEGER\t0x0001\n+#define CPP_N_FLOATING\t0x0002\n+\n+#define CPP_N_WIDTH\t0x00F0\n+#define CPP_N_SMALL\t0x0010\t/* int, float.  */\n+#define CPP_N_MEDIUM\t0x0020\t/* long, double.  */\n+#define CPP_N_LARGE\t0x0040\t/* long long, long double.  */\n+\n+#define CPP_N_RADIX\t0x0F00\n+#define CPP_N_DECIMAL\t0x0100\n+#define CPP_N_HEX\t0x0200\n+#define CPP_N_OCTAL\t0x0400\n+\n+#define CPP_N_UNSIGNED\t0x1000\t/* Properties.  */\n+#define CPP_N_IMAGINARY\t0x2000\n+\n+/* Classify a CPP_NUMBER token.  The return value is a combination of\n+   the flags from the above sets.  */\n+extern unsigned cpp_classify_number PARAMS ((cpp_reader *, const cpp_token *));\n+\n+/* Evaluate a token classified as category CPP_N_INTEGER.  */\n+extern cpp_num cpp_interpret_integer PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t\t      unsigned int type));\n+\n /* Diagnostic levels.  To get a dianostic without associating a\n    position in the translation unit with it, use cpp_error_with_line\n    with a line number of zero.  */"}, {"sha": "b3e2fde4adc7babc561f512b6d18400a3fe43ef6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -1,3 +1,9 @@\n+2002-05-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/c++98-pedantic.c, gcc.dg/cpp/c89-pedantic.c, \n+\tgcc.dg/cpp/c94-pedantic.c, gcc.dg/cpp/gnuc89-pedantic.c,\n+\tgcc.dg/cpp/if-1.c: Update for modified diagnostics.\n+\n 2002-05-29  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gcc.c-torture/execute/20020529-1.c: New test."}, {"sha": "61e13c5d145a51117636edaff56a938812c78a02", "filename": "gcc/testsuite/gcc.dg/cpp/c++98-pedantic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc%2B%2B98-pedantic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc%2B%2B98-pedantic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc%2B%2B98-pedantic.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -6,5 +6,5 @@\n /* This file is for testing the preprocessor in -std=c++98 -pedantic mode.\n    Neil Booth, 2 Dec 2000.  */\n \n-#if 1LL\t\t\t\t/* { dg-warning \"too many\" } */\n+#if 1LL\t\t\t\t/* { dg-warning \"long long\" } */\n #endif"}, {"sha": "3b7f6dd020d99aeec5f3b0d9e7fc532c51920cac", "filename": "gcc/testsuite/gcc.dg/cpp/c89-pedantic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc89-pedantic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc89-pedantic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc89-pedantic.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -6,5 +6,5 @@\n /* This file is for testing the preprocessor in -std=c89 -pedantic mode.\n    Neil Booth, 2 Dec 2000.  */\n \n-#if 1LL\t\t\t\t/* { dg-warning \"too many\" } */\n+#if 1LL\t\t\t\t/* { dg-warning \"long long\" } */\n #endif"}, {"sha": "1c1216449d2c8d3705a9e6df2b5c0c2a3475b241", "filename": "gcc/testsuite/gcc.dg/cpp/c94-pedantic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc94-pedantic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc94-pedantic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc94-pedantic.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -6,5 +6,5 @@\n /* This file is for testing the preprocessor in -std=iso9899:199409\n    -pedantic mode.  Neil Booth, 2 Dec 2000.  */\n \n-#if 1LL\t\t\t\t/* { dg-warning \"too many\" } */\n+#if 1LL\t\t\t\t/* { dg-warning \"long long\" } */\n #endif"}, {"sha": "2749ad739cc9be24a30b208a0cd00862b14568b6", "filename": "gcc/testsuite/gcc.dg/cpp/gnuc89-pedantic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnuc89-pedantic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnuc89-pedantic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnuc89-pedantic.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -6,5 +6,5 @@\n /* This file is for testing the preprocessor in -std=gnu89 -pedantic mode.\n    Neil Booth, 2 Dec 2000.  */\n \n-#if 1LL\t\t\t\t/* { dg-warning \"too many\" } */\n+#if 1LL\t\t\t\t/* { dg-warning \"long long\" } */\n #endif"}, {"sha": "c30f21561db53565f2c479359c32687360308f96", "filename": "gcc/testsuite/gcc.dg/cpp/if-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ab83f2d607e6be282ff65408d4efd5d1b35f1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c?ref=cd7ab83f2d607e6be282ff65408d4efd5d1b35f1", "patch": "@@ -22,7 +22,7 @@\n #error 0xabc\t/* { dg-bogus \"#error\" \"normal conversion\" } */\n #endif\n \n-#if 1.2 /* { dg-error \"loating point numbers\" \"floating point in #if\" } */\n+#if 1.2 /* { dg-error \"loating constant\" \"floating point in #if\" } */\n #endif\n \n #if 4uu /* { dg-error \"invalid suffix\" \"too many suffixes\" } */\n@@ -34,7 +34,7 @@\n #if 1234lul\t/* { dg-error \"invalid suffix\" \"u between ls\" } */\n #endif\n \n-#if 099 /* { dg-error \"digits beyond the radix\" \"decimal in octal constant\" } */\n+#if 099 /* { dg-error \"invalid digit\" \"decimal in octal constant\" } */\n #endif\n \n #if 0xfffffffffffffffff /* { dg-error \"integer constant\" \"range error\" } */"}]}