{"sha": "ee77eda571f5a82d2836c83c5a62914669397b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3N2VkYTU3MWY1YTgyZDI4MzZjODNjNWE2MjkxNDY2OTM5N2I3Mw==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "2000-01-07T00:42:12Z"}, "committer": {"name": "Mumit Khan", "email": "khan@gcc.gnu.org", "date": "2000-01-07T00:42:12Z"}, "message": "protoize.c: Conditionally include unistd.h.\n\n2000-01-06  Mumit Khan  <khan@xraylith.wisc.edu>\n\n\t* protoize.c: Conditionally include unistd.h.\n\t(IS_SAME_PATH_CHAR): New macro.\n\t(IS_SAME_PATH): New macro.\n\t(CPLUS_FILE_SUFFIX): New macro.\n\t(cplus_suffix): New static variable.\n\t(is_abspath): New static function.\n\t(in_system_include_dir): Handle DOS style pathnames.\n\t(file_could_be_converted): Likewise.\n\t(file_normally_convertible): Likewise.\n\t(directory_specified_p): Likewise.\n\t(file_excluded_p): Likewise.\n\t(abspath): Likewise.\n\t(shortpath): Likewise.\n\t(referenced_file_is_newer): Likewise.\n\t(save_def_or_dec): Likewise.\n\t(do_processing): Likewise.\n\t(main): Likewise.\n\t(edit_file): Likewise. Use rename instead of link.\n\t(rename_c_file): Likewise. Don't rename syscalls file.\n\t(munge_compile_params): Define null device for DOS based systems.\n\t(process_aux_info_file): Use binary mode if appliable.\n\t(edit_file): Likewise.\n\t* invoke.texi (Running Protoize): Document C++ suffixes used.\n\nFrom-SVN: r31265", "tree": {"sha": "f5462c54de7c35870a4529f9d01b393ac00924b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5462c54de7c35870a4529f9d01b393ac00924b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee77eda571f5a82d2836c83c5a62914669397b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee77eda571f5a82d2836c83c5a62914669397b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee77eda571f5a82d2836c83c5a62914669397b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee77eda571f5a82d2836c83c5a62914669397b73/comments", "author": null, "committer": null, "parents": [{"sha": "d5b6516da59be3d5c0481f7982a2f7deb0e398bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b6516da59be3d5c0481f7982a2f7deb0e398bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b6516da59be3d5c0481f7982a2f7deb0e398bb"}], "stats": {"total": 305, "additions": 228, "deletions": 77}, "files": [{"sha": "2e75b1d3b09824031d7f0a94aea0a8d83ec3c911", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee77eda571f5a82d2836c83c5a62914669397b73", "patch": "@@ -1,5 +1,29 @@\n 2000-01-06  Mumit Khan  <khan@xraylith.wisc.edu>\n \n+\t* protoize.c: Conditionally include unistd.h.\n+\t(IS_SAME_PATH_CHAR): New macro.\n+\t(IS_SAME_PATH): New macro.\n+\t(CPLUS_FILE_SUFFIX): New macro.\n+\t(cplus_suffix): New static variable.\n+\t(is_abspath): New static function.\n+\t(in_system_include_dir): Handle DOS style pathnames.\n+\t(file_could_be_converted): Likewise.\n+\t(file_normally_convertible): Likewise.\n+\t(directory_specified_p): Likewise.\n+\t(file_excluded_p): Likewise.\n+\t(abspath): Likewise.\n+\t(shortpath): Likewise.\n+\t(referenced_file_is_newer): Likewise.\n+\t(save_def_or_dec): Likewise.\n+\t(do_processing): Likewise.\n+\t(main): Likewise.\n+\t(edit_file): Likewise. Use rename instead of link.\n+\t(rename_c_file): Likewise. Don't rename syscalls file.\n+\t(munge_compile_params): Define null device for DOS based systems.\n+\t(process_aux_info_file): Use binary mode if appliable.\n+\t(edit_file): Likewise.\n+\t* invoke.texi (Running Protoize): Document C++ suffixes used. \n+  \n \t* cccp.c: Delete PATH_SEPARATOR, DIR_SEPARATOR and\n \tIS_DIR_SEPARATOR macros.\n \t* collect2.c: Likewise."}, {"sha": "549ece17e24e8ddf5d1f639818ac837e7ab4b7c5", "filename": "gcc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=ee77eda571f5a82d2836c83c5a62914669397b73", "patch": "@@ -7429,9 +7429,9 @@ would produce the wrong kind of output.  These include @samp{-g},\n the @var{compilation-options}, they are ignored.\n \n @item -C\n-Rename files to end in @samp{.C} instead of @samp{.c}.\n-This is convenient if you are converting a C program to C++.\n-This option applies only to @code{protoize}.\n+Rename files to end in @samp{.C}, or @samp{.cc} for DOS-based file\n+systems, instead of @samp{.c}.  This is convenient if you are converting \n+a C program to C++.  This option applies only to @code{protoize}.\n \n @item -g\n Add explicit global declarations.  This means inserting explicit"}, {"sha": "a12e0a753982ed6bf0e74294b2c16f3a36cf4205", "filename": "gcc/protoize.c", "status": "modified", "additions": 201, "deletions": 74, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee77eda571f5a82d2836c83c5a62914669397b73/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=ee77eda571f5a82d2836c83c5a62914669397b73", "patch": "@@ -24,11 +24,35 @@ Boston, MA 02111-1307, USA.  */\n \n #include <setjmp.h>\n #include <signal.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n #undef abort\n \n /* Include getopt.h for the sake of getopt_long. */\n #include \"getopt.h\"\n \n+/* Macro to see if the path elements match.  */\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+#define IS_SAME_PATH_CHAR(a,b) (toupper (a) == toupper (b))\n+#else\n+#define IS_SAME_PATH_CHAR(a,b) ((a) == (b))\n+#endif\n+\n+/* Macro to see if the paths match.  */\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+#define IS_SAME_PATH(a,b) (strcasecmp (a, b) == 0)\n+#else\n+#define IS_SAME_PATH(a,b) (strcmp (a, b) == 0)\n+#endif\n+\n+/* Suffix for renamed C++ files.  */\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+#define CPLUS_FILE_SUFFIX \"cc\"\n+#else\n+#define CPLUS_FILE_SUFFIX \"C\"\n+#endif\n+\n extern char *version_string;\n \n static void usage PARAMS ((void)) ATTRIBUTE_NORETURN;\n@@ -50,6 +74,7 @@ static int directory_specified_p PARAMS ((const char *));\n static int file_excluded_p PARAMS ((const char *));\n static char *unexpand_if_needed PARAMS ((const char *));\n static char *abspath PARAMS ((const char *, const char *));\n+static int is_abspath PVPROTO ((const char *));\n static void check_aux_info PARAMS ((int));\n static const char *find_corresponding_lparen PARAMS ((const char *));\n static int referenced_file_is_newer PARAMS ((const char *, time_t));\n@@ -99,6 +124,10 @@ static const char * const aux_info_suffix = \".X\";\n \n static const char * const save_suffix = \".save\";\n \n+/* String to attach to C filenames renamed to C++.  */\n+\n+static const char * const cplus_suffix = CPLUS_FILE_SUFFIX;\n+\n #ifndef UNPROTOIZE\n \n /* File name of the file which contains descriptions of standard system\n@@ -707,12 +736,12 @@ in_system_include_dir (path)\n {\n   struct default_include *p;\n \n-  if (path[0] != '/')\n+  if (! is_abspath (path))\n     abort ();\t\t/* Must be an absolutized filename.  */\n \n   for (p = include_defaults; p->fname; p++)\n     if (!strncmp (path, p->fname, strlen (p->fname))\n-\t&& path[strlen (p->fname)] == '/')\n+\t&& IS_DIR_SEPARATOR (path[strlen (p->fname)]))\n       return 1;\n   return 0;\n }\n@@ -734,7 +763,17 @@ file_could_be_converted (const char *path)\n     char *dir_last_slash;\n \n     strcpy (dir_name, path);\n-    dir_last_slash = strrchr (dir_name, '/');\n+    dir_last_slash = strrchr (dir_name, DIR_SEPARATOR);\n+#ifdef DIR_SEPARATOR_2\n+    {\n+      char *slash;\n+\n+      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, \n+                       DIR_SEPARATOR_2);\n+      if (slash)\n+\tdir_last_slash = slash;\n+    }\n+#endif\n     if (dir_last_slash)\n       *dir_last_slash = '\\0';\n     else\n@@ -768,7 +807,17 @@ file_normally_convertible (const char *path)\n     char *dir_last_slash;\n \n     strcpy (dir_name, path);\n-    dir_last_slash = strrchr (dir_name, '/');\n+    dir_last_slash = strrchr (dir_name, DIR_SEPARATOR);\n+#ifdef DIR_SEPARATOR_2\n+    {\n+      char *slash;\n+\n+      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, \n+                       DIR_SEPARATOR_2);\n+      if (slash)\n+\tdir_last_slash = slash;\n+    }\n+#endif\n     if (dir_last_slash)\n       *dir_last_slash = '\\0';\n     else\n@@ -875,14 +924,14 @@ directory_specified_p (name)\n \n   for (p = directory_list; p; p = p->next)\n     if (!strncmp (name, p->name, strlen (p->name))\n-\t&& name[strlen (p->name)] == '/')\n+\t&& IS_DIR_SEPARATOR (name[strlen (p->name)]))\n       {\n \tconst char *q = name + strlen (p->name) + 1;\n \n \t/* If there are more slashes, it's in a subdir, so\n \t   this match doesn't count.  */\n-\twhile (*q)\n-\t  if (*q++ == '/')\n+\twhile (*q++)\n+\t  if (IS_DIR_SEPARATOR (*(q-1)))\n \t    goto lose;\n \treturn 1;\n \n@@ -903,7 +952,7 @@ file_excluded_p (name)\n \n   for (p = exclude_list; p; p = p->next)\n     if (!strcmp (name + len - strlen (p->name), p->name)\n-\t&& name[len - strlen (p->name) - 1] == '/')\n+\t&& IS_DIR_SEPARATOR (name[len - strlen (p->name) - 1]))\n       return 1;\n \n   return 0;\n@@ -1107,6 +1156,20 @@ continue_outer: ;\n   return (got_unexpanded ? savestring (line_buf, copy_p - line_buf) : 0);\n }\n \f\n+/* Return 1 if pathname is absolute. */\n+\n+static int\n+is_abspath (path)\n+     const char *path;\n+{\n+  return (IS_DIR_SEPARATOR (path[0])\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+          /* Check for disk name on MS-DOS-based systems.  */\n+          || (path[0] && path[1] == ':' && IS_DIR_SEPARATOR (path[2]))\n+#endif\n+          );\n+}\n+\f\n /* Return the absolutized filename for the given relative\n    filename.  Note that if that filename is already absolute, it may\n    still be returned in a modified form because this routine also\n@@ -1135,13 +1198,24 @@ abspath (cwd, rel_filename)\n   {\n     const char *src_p;\n \n-    if (rel_filename[0] != '/')\n+    if (! is_abspath (rel_filename))\n       {\n         src_p = cwd2;\n         while ((*endp++ = *src_p++))\n           continue;\n-        *(endp-1) = '/';        \t\t/* overwrite null */\n+        *(endp-1) = DIR_SEPARATOR;     \t\t/* overwrite null */\n       }\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+    else if (IS_DIR_SEPARATOR (rel_filename[0]))\n+      {\n+\t/* A path starting with a directory separator is considered absolute \n+\t   for dos based filesystems, but it's really not -- it's just the \n+\t   convention used throughout GCC and it works. However, in this\n+\t   case, we still need to prepend the drive spec from cwd_buffer.  */\n+\t*endp++ = cwd2[0];\n+\t*endp++ = cwd2[1];\n+      }\n+#endif\n     src_p = rel_filename;\n     while ((*endp++ = *src_p++))\n       continue;\n@@ -1153,32 +1227,33 @@ abspath (cwd, rel_filename)\n   outp = inp = abs_buffer;\n   *outp++ = *inp++;        \t/* copy first slash */\n #if defined (apollo) || defined (_WIN32) || defined (__INTERIX)\n-  if (inp[0] == '/')\n+  if (IS_DIR_SEPARATOR (inp[0]))\n     *outp++ = *inp++;        \t/* copy second slash */\n #endif\n   for (;;)\n     {\n       if (!inp[0])\n         break;\n-      else if (inp[0] == '/' && outp[-1] == '/')\n+      else if (IS_DIR_SEPARATOR (inp[0]) && IS_DIR_SEPARATOR (outp[-1]))\n         {\n           inp++;\n           continue;\n         }\n-      else if (inp[0] == '.' && outp[-1] == '/')\n+      else if (inp[0] == '.' && IS_DIR_SEPARATOR (outp[-1]))\n         {\n           if (!inp[1])\n                   break;\n-          else if (inp[1] == '/')\n+          else if (IS_DIR_SEPARATOR (inp[1]))\n             {\n                     inp += 2;\n                     continue;\n             }\n-          else if ((inp[1] == '.') && (inp[2] == 0 || inp[2] == '/'))\n+          else if ((inp[1] == '.') && (inp[2] == 0 \n+\t                               || IS_DIR_SEPARATOR (inp[2])))\n             {\n-                    inp += (inp[2] == '/') ? 3 : 2;\n+                    inp += (IS_DIR_SEPARATOR (inp[2])) ? 3 : 2;\n                     outp -= 2;\n-                    while (outp >= abs_buffer && *outp != '/')\n+                    while (outp >= abs_buffer && ! IS_DIR_SEPARATOR (*outp))\n               \toutp--;\n                     if (outp < abs_buffer)\n \t\t      {\n@@ -1201,7 +1276,7 @@ abspath (cwd, rel_filename)\n      the last character of the returned string is *not* a slash.  */\n \n   *outp = '\\0';\n-  if (outp[-1] == '/')\n+  if (IS_DIR_SEPARATOR (outp[-1]))\n     *--outp  = '\\0';\n \n   /* Make a copy (in the heap) of the stuff left in the absolutization\n@@ -1239,13 +1314,14 @@ shortpath (cwd, filename)\n   path_p = abspath (cwd, filename);\n   rel_buf_p = rel_buffer = (char *) xmalloc (filename_len);\n \n-  while (*cwd_p && (*cwd_p == *path_p))\n+  while (*cwd_p && IS_SAME_PATH_CHAR (*cwd_p, *path_p))\n     {\n       cwd_p++;\n       path_p++;\n     }\n-  if (!*cwd_p && (!*path_p || *path_p == '/'))\t/* whole pwd matched */\n+  if (!*cwd_p && (!*path_p || IS_DIR_SEPARATOR (*path_p)))\n     {\n+      /* whole pwd matched */\n       if (!*path_p)        \t/* input *is* the current path! */\n         return \".\";\n       else\n@@ -1257,7 +1333,7 @@ shortpath (cwd, filename)\n         {\n           --cwd_p;\n           --path_p;\n-          while (*cwd_p != '/')        \t/* backup to last slash */\n+          while (! IS_DIR_SEPARATOR (*cwd_p))     /* backup to last slash */\n             {\n               --cwd_p;\n               --path_p;\n@@ -1268,8 +1344,8 @@ shortpath (cwd, filename)\n         }\n \n       /* Find out how many directory levels in cwd were *not* matched.  */\n-      while (*cwd_p)\n-        if (*cwd_p++ == '/')\n+      while (*cwd_p++)\n+        if (IS_DIR_SEPARATOR (*(cwd_p-1)))\n \t  unmatched_slash_count++;\n \n       /* Now we know how long the \"short name\" will be.\n@@ -1286,7 +1362,7 @@ shortpath (cwd, filename)\n \t    return filename;\n           *rel_buf_p++ = '.';\n           *rel_buf_p++ = '.';\n-          *rel_buf_p++ = '/';\n+          *rel_buf_p++ = DIR_SEPARATOR;\n         }\n \n       /* Then tack on the unmatched part of the desired file's name.  */\n@@ -1298,7 +1374,7 @@ shortpath (cwd, filename)\n       while ((*rel_buf_p++ = *path_p++));\n \n       --rel_buf_p;\n-      if (*(rel_buf_p-1) == '/')\n+      if (IS_DIR_SEPARATOR (*(rel_buf_p-1)))\n         *--rel_buf_p = '\\0';\n       return rel_buffer;\n     }\n@@ -1421,7 +1497,11 @@ referenced_file_is_newer (l, aux_info_mtime)\n   {\n     const char *filename_start = p = l + 3;\n \n-    while (*p != ':')\n+    while (*p != ':'\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+#endif\n+           )\n       p++;\n     filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n@@ -1479,7 +1559,11 @@ save_def_or_dec (l, is_syscalls)\n     const char *filename_start = p = l + 3;\n     char *filename;\n \n-    while (*p != ':')\n+    while (*p != ':'\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+#endif\n+           )\n       p++;\n     filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n@@ -1506,7 +1590,11 @@ save_def_or_dec (l, is_syscalls)\n     const char *line_number_start = ++p;\n     char line_number[10];\n \n-    while (*p != ':')\n+    while (*p != ':'\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+#endif\n+           )\n       p++;\n     strncpy (line_number, line_number_start, (size_t) (p - line_number_start));\n     line_number[p-line_number_start] = '\\0';\n@@ -1896,7 +1984,11 @@ munge_compile_params (params_list)\n \n   temp_params[param_count++] = \"-S\";\n   temp_params[param_count++] = \"-o\";\n+#if defined (__MSDOS__) || (defined (_WIN32) && ! defined (__CYGWIN__) && ! defined (_UWIN))\n+  temp_params[param_count++] = \"NUL:\";\n+#else\n   temp_params[param_count++] = \"/dev/null\";\n+#endif\n \n   /* Leave room for the input file name argument.  */\n   input_file_name_index = param_count;\n@@ -2116,10 +2208,16 @@ start_over: ;\n \n   {\n     int aux_info_file;\n+    int fd_flags;\n \n     /* Open the aux_info file.  */\n   \n-    if ((aux_info_file = open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n+    fd_flags = O_RDONLY;\n+#ifdef O_BINARY\n+    /* Use binary mode to avoid having to deal with different EOL characters. */\n+    fd_flags |= O_BINARY;\n+#endif\n+    if ((aux_info_file = open (aux_info_filename, fd_flags, 0444 )) == -1)\n       {\n \tint errno_val = errno;\n         notice (\"%s: can't open aux info file `%s' for reading: %s\\n\",\n@@ -2184,28 +2282,42 @@ start_over: ;\n   {\n     char *p = aux_info_base;\n \n-    while (*p != ':')\n+    while (*p != ':'\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+#endif\n+           )\n       p++;\n     p++;\n     while (*p == ' ')\n       p++;\n     invocation_filename = p;\t/* Save a pointer to first byte of path.  */\n     while (*p != ' ')\n       p++;\n-    *p++ = '/';\n+    *p++ = DIR_SEPARATOR;\n     *p++ = '\\0';\n     while (*p++ != '\\n')\n       continue;\n     aux_info_second_line = p;\n     aux_info_relocated_name = 0;\n-    if (invocation_filename[0] != '/')\n+    if (! is_abspath (invocation_filename))\n       {\n \t/* INVOCATION_FILENAME is relative;\n \t   append it to BASE_SOURCE_FILENAME's dir.  */\n \tchar *dir_end;\n \taux_info_relocated_name = xmalloc (base_len + (p-invocation_filename));\n \tstrcpy (aux_info_relocated_name, base_source_filename);\n-\tdir_end = strrchr (aux_info_relocated_name, '/');\n+\tdir_end = strrchr (aux_info_relocated_name, DIR_SEPARATOR);\n+#ifdef DIR_SEPARATOR_2\n+\t{\n+\t  char *slash;\n+\n+\t  slash = strrchr (dir_end ? dir_end : aux_info_relocated_name, \n+\t                   DIR_SEPARATOR_2);\n+\t  if (slash)\n+\t    dir_end = slash;\n+\t}\n+#endif\n \tif (dir_end)\n \t  dir_end++;\n \telse\n@@ -2297,38 +2409,31 @@ rename_c_file (hp)\n {\n   const char *filename = hp->symbol;\n   int last_char_index = strlen (filename) - 1;\n-  char *const new_filename = (char *) alloca (strlen (filename) + 1);\n+  char *const new_filename = (char *) alloca (strlen (filename) \n+                                              + strlen (cplus_suffix) + 1);\n \n   /* Note that we don't care here if the given file was converted or not.  It\n      is possible that the given file was *not* converted, simply because there\n      was nothing in it which actually required conversion.  Even in this case,\n      we want to do the renaming.  Note that we only rename files with the .c\n-     suffix.  */\n+     suffix (except for the syscalls file, which is left alone).  */\n \n-  if (filename[last_char_index] != 'c' || filename[last_char_index-1] != '.')\n+  if (filename[last_char_index] != 'c' || filename[last_char_index-1] != '.'\n+      || IS_SAME_PATH (syscalls_absolute_filename, filename))\n     return;\n \n   strcpy (new_filename, filename);\n-  new_filename[last_char_index] = 'C';\n+  strcpy (&new_filename[last_char_index], cplus_suffix);\n \n-  if (link (filename, new_filename) == -1)\n+  if (rename (filename, new_filename) == -1)\n     {\n       int errno_val = errno;\n-      notice (\"%s: warning: can't link file `%s' to `%s': %s\\n\",\n+      notice (\"%s: warning: can't rename file `%s' to `%s': %s\\n\",\n \t      pname, shortpath (NULL, filename),\n \t      shortpath (NULL, new_filename), xstrerror (errno_val));\n       errors++;\n       return;\n     }\n-\n-  if (unlink (filename) == -1)\n-    {\n-      int errno_val = errno;\n-      notice (\"%s: warning: can't delete file `%s': %s\\n\",\n-\t      pname, shortpath (NULL, filename), xstrerror (errno_val));\n-      errors++;\n-      return;\n-    }\n }\n \n #endif /* !defined (UNPROTOIZE) */\n@@ -4057,10 +4162,16 @@ edit_file (hp)\n \n   {\n     int input_file;\n+    int fd_flags;\n \n     /* Open the file to be converted in READ ONLY mode.  */\n \n-    if ((input_file = open (convert_filename, O_RDONLY, 0444)) == -1)\n+    fd_flags = O_RDONLY;\n+#ifdef O_BINARY\n+    /* Use binary mode to avoid having to deal with different EOL characters. */\n+    fd_flags |= O_BINARY;\n+#endif\n+    if ((input_file = open (convert_filename, fd_flags, 0444)) == -1)\n       {\n \tint errno_val = errno;\n         notice (\"%s: can't open file `%s' for reading: %s\\n\",\n@@ -4207,36 +4318,39 @@ edit_file (hp)\n   \n       strcpy (new_filename, convert_filename);\n       strcat (new_filename, save_suffix);\n-      if (link (convert_filename, new_filename) == -1)\n+\n+      /* Don't overwrite existing file.  */\n+      if (access (new_filename, F_OK) == 0)\n+\t{\n+\t  if (!quiet_flag)\n+\t    notice (\"%s: warning: file `%s' already saved in `%s'\\n\",\n+\t\t    pname,\n+\t\t    shortpath (NULL, convert_filename),\n+\t\t    shortpath (NULL, new_filename));\n+\t}\n+      else if (rename (convert_filename, new_filename) == -1)\n         {\n \t  int errno_val = errno;\n-\t  if (errno_val == EEXIST)\n-            {\n-              if (!quiet_flag)\n-                notice (\"%s: warning: file `%s' already saved in `%s'\\n\",\n-\t\t\tpname,\n-\t\t\tshortpath (NULL, convert_filename),\n-\t\t\tshortpath (NULL, new_filename));\n-            }\n-          else\n-            {\n-              notice (\"%s: can't link file `%s' to `%s': %s\\n\",\n-\t\t      pname,\n-\t\t      shortpath (NULL, convert_filename),\n-\t\t      shortpath (NULL, new_filename),\n-\t\t      xstrerror (errno_val));\n-              return;\n-            }\n+\t  notice (\"%s: can't link file `%s' to `%s': %s\\n\",\n+\t\t  pname,\n+\t\t  shortpath (NULL, convert_filename),\n+\t\t  shortpath (NULL, new_filename),\n+\t\t  xstrerror (errno_val));\n+\t  return;\n         }\n     }\n \n   if (unlink (convert_filename) == -1)\n     {\n       int errno_val = errno;\n-      notice (\"%s: can't delete file `%s': %s\\n\",\n-\t      pname, shortpath (NULL, convert_filename),\n-\t      xstrerror (errno_val));\n-      return;\n+      /* The file may have already been renamed.  */\n+      if (errno_val != ENOENT)\n+        {\n+\t  notice (\"%s: can't delete file `%s': %s\\n\",\n+\t\t  pname, shortpath (NULL, convert_filename),\n+\t\t  xstrerror (errno_val));\n+\t  return;\n+\t}\n     }\n \n   {\n@@ -4252,6 +4366,10 @@ edit_file (hp)\n \t\txstrerror (errno_val));\n         return;\n       }\n+#ifdef O_BINARY\n+    /* Use binary mode to avoid changing the existing EOL character.  */\n+    setmode (output_file, O_BINARY);\n+#endif\n   \n     /* Write the output file.  */\n   \n@@ -4342,9 +4460,9 @@ do_processing ()\n     }\n \n   syscalls_len = strlen (syscalls_absolute_filename);\n-  if (*(syscalls_absolute_filename + syscalls_len - 1) != '/')\n+  if (! IS_DIR_SEPARATOR (*(syscalls_absolute_filename + syscalls_len - 1)))\n     {\n-      *(syscalls_absolute_filename + syscalls_len++) = '/';\n+      *(syscalls_absolute_filename + syscalls_len++) = DIR_SEPARATOR;\n       *(syscalls_absolute_filename + syscalls_len) = '\\0';\n     }\n   strcat (syscalls_absolute_filename, syscalls_filename);\n@@ -4428,7 +4546,16 @@ main (argc, argv)\n   int c;\n   const char *params = \"\";\n \n-  pname = strrchr (argv[0], '/');\n+  pname = strrchr (argv[0], DIR_SEPARATOR);\n+#ifdef DIR_SEPARATOR_2\n+  {\n+    char *slash;\n+\n+    slash = strrchr (pname ? pname : argv[0], DIR_SEPARATOR_2);\n+    if (slash)\n+      pname = slash;\n+  }\n+#endif\n   pname = pname ? pname+1 : argv[0];\n \n #ifdef HAVE_LC_MESSAGES"}]}