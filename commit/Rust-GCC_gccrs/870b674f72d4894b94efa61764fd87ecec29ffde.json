{"sha": "870b674f72d4894b94efa61764fd87ecec29ffde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwYjY3NGY3MmQ0ODk0Yjk0ZWZhNjE3NjRmZDg3ZWNlYzI5ZmZkZQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-18T16:33:18Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-18T21:43:28Z"}, "message": "Remove poor value computations.\n\nRemove the old \"poor value\" approach which made callbacks into ranger\nfrom the cache.  Use only the best available value for all propagation.\n\n\tPR tree-optimization/101014\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Remove poor\n\tvalue list.\n\t(ranger_cache::~ranger_cache): Ditto.\n\t(ranger_cache::enable_new_values): Delete.\n\t(ranger_cache::push_poor_value): Delete.\n\t(ranger_cache::range_of_def): Remove poor value processing.\n\t(ranger_cache::entry_range): Ditto.\n\t(ranger_cache::fill_block_cache): Ditto.\n\t* gimple-range-cache.h (class ranger_cache): Remove poor value members.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Remove call.\n\t* gimple-range.h (class gimple_ranger): Adjust.", "tree": {"sha": "e03de3865dc9442cb0aff6a29adaf67eab24fab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e03de3865dc9442cb0aff6a29adaf67eab24fab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/870b674f72d4894b94efa61764fd87ecec29ffde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870b674f72d4894b94efa61764fd87ecec29ffde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870b674f72d4894b94efa61764fd87ecec29ffde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870b674f72d4894b94efa61764fd87ecec29ffde/comments", "author": null, "committer": null, "parents": [{"sha": "93022946df2463ad49e3eaa2f6d43c47c16f31c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93022946df2463ad49e3eaa2f6d43c47c16f31c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93022946df2463ad49e3eaa2f6d43c47c16f31c0"}], "stats": {"total": 141, "additions": 7, "deletions": 134}, "files": [{"sha": "c85b299d13ec21d73a69a55633949257ae09bd6b", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 6, "deletions": 119, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=870b674f72d4894b94efa61764fd87ecec29ffde", "patch": "@@ -706,16 +706,13 @@ temporal_cache::set_always_current (tree name)\n \n // --------------------------------------------------------------------------\n \n-ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n+ranger_cache::ranger_cache ()\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   m_update_list.create (0);\n   m_update_list.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   m_update_list.truncate (0);\n-  m_poor_value_list.create (0);\n-  m_poor_value_list.safe_grow_cleared (20);\n-  m_poor_value_list.truncate (0);\n   m_temporal = new temporal_cache;\n   unsigned x, lim = last_basic_block_for_fn (cfun);\n   // Calculate outgoing range info upfront.  This will fully populate the\n@@ -727,13 +724,11 @@ ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n       if (bb)\n \tm_gori.exports (bb);\n     }\n-  m_new_value_p = true;\n }\n \n ranger_cache::~ranger_cache ()\n {\n   delete m_temporal;\n-  m_poor_value_list.release ();\n   m_workback.release ();\n   m_update_list.release ();\n }\n@@ -748,17 +743,6 @@ ranger_cache::dump (FILE *f)\n   fprintf (f, \"\\n\");\n }\n \n-// Allow or disallow the cache to flag and query new values when propagation\n-// is forced to use an unknown value.  The previous state is returned.\n-\n-bool\n-ranger_cache::enable_new_values (bool state)\n-{\n-  bool ret = m_new_value_p;\n-  m_new_value_p = state;\n-  return ret;\n-}\n-\n // Dump the caches for basic block BB to file F.\n \n void\n@@ -836,30 +820,6 @@ ranger_cache::set_global_range (tree name, const irange &r)\n   m_temporal->set_timestamp (name);\n }\n \n-// Push a request for a new lookup in block BB of name.  Return true if\n-// the request is actually made (ie, isn't a duplicate).\n-\n-bool\n-ranger_cache::push_poor_value (basic_block bb, tree name)\n-{\n-  if (!m_new_value_p)\n-    return false;\n-  if (m_poor_value_list.length ())\n-    {\n-      // Don't push anything else to the same block.  If there are multiple \n-      // things required, another request will come during a later evaluation\n-      // and this prevents oscillation building uneccessary depth.\n-      if ((m_poor_value_list.last ()).bb == bb)\n-\treturn false;\n-    }\n-\n-  struct update_record rec;\n-  rec.bb = bb;\n-  rec.calc = name;\n-  m_poor_value_list.safe_push (rec);\n-  return true;\n-}\n-\n //  Provide lookup for the gori-computes class to access the best known range\n //  of an ssa_name in any given basic block.  Note, this does no additonal\n //  lookups, just accesses the data that is already known.\n@@ -872,31 +832,16 @@ ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n   gcc_checking_assert (gimple_range_ssa_p (name));\n   gcc_checking_assert (bb == gimple_bb (SSA_NAME_DEF_STMT (name)));\n \n+  // Pick up the best global range available.\n   if (!m_globals.get_global_range (r, name))\n-    {\n-      // If it doesn't have a value calculated, it means it's a\n-      // \"poor\" value being used in some calculation.  Queue it up\n-      // as a poor value to be improved later.\n-      r = gimple_range_global (name);\n-      if (push_poor_value (bb, name))\n-\t{\n-\t  if (DEBUG_RANGE_CACHE)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"*CACHE* no global def in bb %d for \", bb->index);\n-\t      print_generic_expr (dump_file, name, TDF_SLIM);\n-\t      fprintf (dump_file, \" depth : %d\\n\",\n-\t\t       m_poor_value_list.length ());\n-\t    }\n-\t}\n-    }\n+    r = gimple_range_global (name);\n+\n   if (r.varying_p () && m_non_null.non_null_deref_p (name, bb, false) &&\n       !cfun->can_throw_non_call_exceptions)\n     r = range_nonzero (TREE_TYPE (name));\n }\n \n-// Get the range of NAME as it occurs on entry to block BB.  If it is not set,\n-// mark it as a poor value for possible later improvement.\n+// Get the range of NAME as it occurs on entry to block BB.\n \n void\n ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n@@ -910,20 +855,7 @@ ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n   // Look for the on-entry value of name in BB from the cache.\n   if (!m_on_entry.get_bb_range (r, name, bb))\n     {\n-      // If it has no entry but should, then mark this as a poor value.\n-      // Its not a poor value if it does not have *any* edge ranges,\n-      // Then global range is as good as it gets.\n-      if (m_gori.has_edge_range_p (name) && push_poor_value (bb, name))\n-\t{\n-\t  if (DEBUG_RANGE_CACHE)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"*CACHE* no on entry range in bb %d for \", bb->index);\n-\t      print_generic_expr (dump_file, name, TDF_SLIM);\n-\t      fprintf (dump_file, \" depth : %d\\n\", m_poor_value_list.length ());\n-\t    }\n-\t}\n-      // Try to pick up any known global value as a best guess for now.\n+      // Try to pick up any known global value.\n       if (!m_globals.get_global_range (r, name))\n \tr = gimple_range_global (name);\n     }\n@@ -1195,7 +1127,6 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n   edge e;\n   int_range_max block_result;\n   int_range_max undefined;\n-  unsigned poor_list_start = m_poor_value_list.length ();  \n \n   // At this point we shouldn't be looking at the def, entry or exit block.\n   gcc_checking_assert (bb != def_bb && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) &&\n@@ -1301,49 +1232,5 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n   propagate_cache (name);\n   if (DEBUG_RANGE_CACHE)\n     fprintf (dump_file, \"  Propagation update done.\\n\");\n-\n-  // Now that the cache has been updated, check to see if there were any \n-  // SSA_NAMES used in filling the cache which were \"poor values\".\n-  // Evaluate them, and inject any new values into the propagation\n-  // list, and see if it improves any on-entry values.\n-  if (poor_list_start !=  m_poor_value_list.length ())\n-    {\n-      gcc_checking_assert (poor_list_start < m_poor_value_list.length ());\n-      while (poor_list_start < m_poor_value_list.length ())\n-\t{\n-\t  // Find a range for this unresolved value.   \n-\t  // Note, this may spawn new cache filling cycles, but by the time it\n-\t  // is finished, the work vectors will all be back to the same state\n-\t  // as before the call.  The update record vector will always be\n-\t  // returned to the current state upon return.\n-\t  struct update_record rec = m_poor_value_list.pop ();\n-\t  basic_block calc_bb = rec.bb;\n-\t  int_range_max tmp;\n-\n-\t  if (DEBUG_RANGE_CACHE)\n-\t    {\n-\t      fprintf (dump_file, \"(%d:%d)Calculating \",\n-\t\t       m_poor_value_list.length () + 1, poor_list_start);\n-\t      print_generic_expr (dump_file, name, TDF_SLIM);\n-\t      fprintf (dump_file, \" used POOR VALUE for \");\n-\t      print_generic_expr (dump_file, rec.calc, TDF_SLIM);\n-\t      fprintf (dump_file, \" in bb%d, trying to improve:\\n\",\n-\t\t       calc_bb->index);\n-\t    }\n-\n-\t  // Calculate a range at the exit from the block so the caches feeding\n-\t  // this block will be filled, and we'll get a \"better\" value.\n-\t  // Disallow additonal \"poor values\" during this phase to avoid\n-\t  // iterations that are unlikely to be profitable for this name.\n-\t  // See PR 101014.\n-\t  bool state = enable_new_values (false);\n-\t  query.range_on_exit (tmp, calc_bb, rec.calc);\n-\t  enable_new_values (state);\n-\t  \n-\t  // Then ask for NAME to be re-evaluated on outgoing edges and \n-\t  // use any new values.\n-\t  propagate_updated_value (name, calc_bb);\n-\t}\n-    }\n }\n "}, {"sha": "e67af68f30bbf021487886d8911afae91ff5d695", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=870b674f72d4894b94efa61764fd87ecec29ffde", "patch": "@@ -90,7 +90,7 @@ class ssa_global_cache\n class ranger_cache : public range_query\n {\n public:\n-  ranger_cache (class gimple_ranger &q);\n+  ranger_cache ();\n   ~ranger_cache ();\n \n   virtual bool range_of_expr (irange &r, tree name, gimple *stmt);\n@@ -123,17 +123,6 @@ class ranger_cache : public range_query\n \n   vec<basic_block> m_workback;\n   vec<basic_block> m_update_list;\n-\n-  // Iterative \"poor value\" calculations.\n-  struct update_record\n-  {\n-    basic_block bb;\t// Block which value needs to be calculated in.\n-    tree calc;\t\t// SSA_NAME which needs its value calculated.\n-  };\n-  bool push_poor_value (basic_block bb, tree name);\n-  vec<update_record> m_poor_value_list;\n-  class gimple_ranger &query;\n-  bool m_new_value_p;\n };\n \n #endif // GCC_SSA_RANGE_CACHE_H"}, {"sha": "0a2c72b29aaff5f1a07e0a6edcca00e54b29efbf", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=870b674f72d4894b94efa61764fd87ecec29ffde", "patch": "@@ -1167,9 +1167,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   // trigger new value calculations.  PR 100781.\n   if (is_gimple_debug (stmt))\n     {\n-      bool state = m_cache.enable_new_values (false);\n       m_cache.range_of_expr (r, expr, stmt);\n-      m_cache.enable_new_values (state);\n       return true;\n     }\n   basic_block bb = gimple_bb (stmt);"}, {"sha": "fc28123f9ecb4140d58ce23c3ef5475f5de0d9c6", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870b674f72d4894b94efa61764fd87ecec29ffde/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=870b674f72d4894b94efa61764fd87ecec29ffde", "patch": "@@ -58,7 +58,6 @@ along with GCC; see the file COPYING3.  If not see\n class gimple_ranger : public range_query\n {\n public:\n-  gimple_ranger () : m_cache (*this) { }\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) OVERRIDE;\n   virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) OVERRIDE;\n   virtual bool range_on_edge (irange &r, edge e, tree name) OVERRIDE;"}]}