{"sha": "40a49b3cf69348fbe1c8a2412849afe1163e614a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBhNDliM2NmNjkzNDhmYmUxYzhhMjQxMjg0OWFmZTExNjNlNjE0YQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-10-29T18:21:44Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-10-29T18:21:44Z"}, "message": "rs6000.c (rs6000_init_libfuncs): Split libfunc setup into 3 functions...\n\n[gcc]\n2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_init_libfuncs): Split libfunc\n\tsetup into 3 functions: init_float128_ibm, init_float128_ieee, and\n\trs6000_init_libfuncs. If -mfloat128, add IFmode functions for all\n\tof the traditional names that TFmode uses for handling IEEE\n\textended double. If -mfloat128, add KFmode functions for all of\n\tthe emulation functions. If -mabi=ieeelongdouble and -mfloat128,\n\tmake TFmode use the same emulation functions as KFmode.\n\t(init_float128_ibm): Likewise.\n\t(init_float128_ieee): Likewise.\n\t(rs6000_generate_compare): For IEEE 128-bit floating point\n\tcomparisons, call the unordered comparison function instead of the\n\tordered comparison function.\n\t(rs6000_expand_float128_convert): Deal with operands that are\n\tmemory operands. Restructure the code to use a switch statement on\n\tthe mode. Add support for TFmode defaulting to either IBM extended\n\tdouble or IEEE 128-bit floating point. If the underlying types are\n\tthe same, use a move instead of a conversion function.\n\t(TARGET_C_MODE_FOR_SUFFIX): Define 'q' and 'Q' as the suffix to\n\tuse for IEEE 128-bit floating point constants with -mfloat128.\n\t(rs6000_c_mode_for_suffix): Likewise.\n\t(TARGET_INVALID_BINARY_OP): Do not allow inter-mixing of IEEE\n\t128-bit floating point with IBM extended double floating point.\n\t(rs6000_invalid_binary_op): Likewise.\n\t(rs6000_gen_le_vsx_permute): On little endian systems generate a\n\tROTATE insn instead of VEC_SELECT for IEEE 128-bit floating point\n\ttypes that can go in vector registers.\n\t(chain_contains_only_swaps): Properly swap IEEE 128-bit floating\n\tpoint types that can go in vector registers on little endian\n\tPowerPC systems.\n\t(mark_swaps_for_removal): Likewise.\n\t(rs6000_analyze_swaps): Likewise.\n\t(rs6000_mangle_type): Use U10__float128 for IEEE 128-bit floating point.\n\n\t* config/rs6000/rs6000.md (FLOAT128_SFDFTF): Delete iterator,\n\trework IEEE 128-bit floating point insns to deal with TFmode being\n\teither IBM extended double or IEEE 128-bit floating point.\n\t(IFKF): Likewise.\n\t(IBM128): Update iterator to add condition that the mode is IBM\n\textended double.\n\t(IEEE128): New iterator for IEEE 128-bit floating point.\n\t(TFIFKF): Rename TFIFKF iterator to FLOAT128.\n\t(FLOAT128): Likewise.\n\t(signbit<mode>2): FLOAT128_IBM_P condition test moved into IBM128\n\titerator.\n\t(neg<mode>2): Replace TFIFKF iterator with FLOAT128. Add support\n\tfor TFmode being IEEE 128-bit floating point. Use IEEE128 iterator\n\tinstead of hard coding TFmode or KFmode.\n\t(negtf2_internal): Likewise.\n\t(neg<mode>2_internal): Likewise.\n\t(abs<mode>2): Likewise.\n\t(abstf2_internal): Likewise.\n\t(abs<mode>2_internal): Likewise.\n\t(ieee_128bit_neg<mode>2): Likewise.\n\t(ieee_128bit_neg<mode>2_internal): Likewise.\n\t(ieee_128bit_abs<mode>2): Likewise.\n\t(ieee_128bit_abs<mode>2_internal): Likewise.\n\t(ieee_128bit_nabs<mode>2): Likewise.\n\t(ieee_128bit_nabs<mode>2_internal): Likewise.\n\t(extendiftf2): Add explicit conversions between 128-bit floating\n\tpoint types. Drop the old conversions that had become unwieldy.\n\t(extend<FLOAT128_SFDFTF:mode><IFKF:mode>2): Likewise.\n\t(extendifkf2): Likewise.\n\t(trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2): Likewise.\n\t(extendtfkf2): Likewise.\n\t(fix_trunc<IFKF:mode><SDI:mode>2): Likewise.\n\t(trunciftf2): Likewise.\n\t(fixuns_trunc<IFKF:mode><SDI:mode>2): Likewise.\n\t(truncifkf2): Likewise.\n\t(float<SDI:mode><IFKF:mode>2): Likewise.\n\t(trunckftf2): Likewise.\n\t(floatuns<SDI:mode><IFKF:mode>2): Likewise.\n\t(trunctfif2): Likewise.\n\t(FP iterator): Allow TFmode to be IEEE 128-bit floating point.\n\t(extenddftf2): Rework 128-bit floating point conversions to\n\tproperly handle -mabi=ieeelongdouble. Merge IFmode, TFmode, and\n\tKFmode expanders into one function.\n\t(extenddf<mode>2): Likewise.\n\t(extenddftf2_fprs): Likewise.\n\t(extenddf<mode>2_fprs): Likewise.\n\t(extenddftf2_vsx): Likewise.\n\t(extenddf<mode>2_vsx): Likewise.\n\t(extendsftf2): Likewise.\n\t(extendsf<mode>2): Likewise.\n\t(trunctfdf2): Likewise.\n\t(trunc<mode>df2): Likewise.\n\t(trunctfdf2_internal1): Likewise.\n\t(trunc<mode>df2_internal1): Likewise.\n\t(trunctfdf2_internal2): Likewise.\n\t(trunc<mode>df2_internal2): Likewise.\n\t(trunctfsf2): Likewise.\n\t(trunc<mode>sf2): Likewise.\n\t(trunctfsf2_fprs): Likewise.\n\t(trunc<mode>sf2_fprs): Likewise.\n\t(floatsit2f): Likewise.\n\t(floatsi<mode>2): Likewise.\n\t(fix_trunc_helper): Likewise.\n\t(fix_trunc_helper<mode>): Likewise.\n\t(fix_trunctfsi2): Likewise.\n\t(fix_trunc<mode>si2): Likewise.\n\t(fix_trunctfsi2_fprs): Likewise.\n\t(fix_trunc<mode>si2_fprs): Likewise.\n\t(fix_trunctfsi2_internal): Likewise.\n\t(fix_trunc<mode>si2_internal): Likewise.\n\t(fix_trunctfdi2): Likewise.\n\t(fix_trunc<mode>di2): Likewise.\n\t(fixuns_trunctf<mode>2): Likewise.\n\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n\t(floatditf2): Likewise.\n\t(floatdi<mode>2): Likewise.\n\t(floatuns<mode>tf2): Likewise.\n\t(floatuns<SDI:mode><IEEE128:mode>): Likewise.\n\t(cmptf_internal1): Use a mode iterator to add support for both\n\ttypes (IFmode, TFmode) that support IBM extended double.\n\t(cmp<mode>_internal1): Likewise.\n\t(cmptf_internal2): Likewise.\n\t(cmp<mode>_internal2): Likewise.\n\n\t* doc/extend.texi (Floating Types): Document __ibm128 and\n\t__float128 on PowerPC.\n\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n\t-mfloat128 and -mno-float128.\n\n[gcc/testsuite]\n2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-call.c: New test for -mfloat128 on\n\tPowerPC.\n\t* gcc.target/powerpc/float128-mix.c: Likewise.\n\nFrom-SVN: r229547", "tree": {"sha": "7542f5353cd61b918592cb2a9938ba9d8c56f317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7542f5353cd61b918592cb2a9938ba9d8c56f317"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40a49b3cf69348fbe1c8a2412849afe1163e614a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a49b3cf69348fbe1c8a2412849afe1163e614a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40a49b3cf69348fbe1c8a2412849afe1163e614a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a49b3cf69348fbe1c8a2412849afe1163e614a/comments", "author": null, "committer": null, "parents": [{"sha": "f4a513a98e6341b2d4796752644a27c722612847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a513a98e6341b2d4796752644a27c722612847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a513a98e6341b2d4796752644a27c722612847"}], "stats": {"total": 1088, "additions": 805, "deletions": 283}, "files": [{"sha": "1f32c9dfa5904f5f95e18d5ceebb18baca32ba81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -1,3 +1,128 @@\n+2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_init_libfuncs): Split libfunc\n+\tsetup into 3 functions: init_float128_ibm, init_float128_ieee, and\n+\trs6000_init_libfuncs. If -mfloat128, add IFmode functions for all\n+\tof the traditional names that TFmode uses for handling IEEE\n+\textended double. If -mfloat128, add KFmode functions for all of\n+\tthe emulation functions. If -mabi=ieeelongdouble and -mfloat128,\n+\tmake TFmode use the same emulation functions as KFmode.\n+\t(init_float128_ibm): Likewise.\n+\t(init_float128_ieee): Likewise.\n+\t(rs6000_generate_compare): For IEEE 128-bit floating point\n+\tcomparisons, call the unordered comparison function instead of the\n+\tordered comparison function.\n+\t(rs6000_expand_float128_convert): Deal with operands that are\n+\tmemory operands. Restructure the code to use a switch statement on\n+\tthe mode. Add support for TFmode defaulting to either IBM extended\n+\tdouble or IEEE 128-bit floating point. If the underlying types are\n+\tthe same, use a move instead of a conversion function.\n+\t(TARGET_C_MODE_FOR_SUFFIX): Define 'q' and 'Q' as the suffix to\n+\tuse for IEEE 128-bit floating point constants with -mfloat128.\n+\t(rs6000_c_mode_for_suffix): Likewise.\n+\t(TARGET_INVALID_BINARY_OP): Do not allow inter-mixing of IEEE\n+\t128-bit floating point with IBM extended double floating point.\n+\t(rs6000_invalid_binary_op): Likewise.\n+\t(rs6000_gen_le_vsx_permute): On little endian systems generate a\n+\tROTATE insn instead of VEC_SELECT for IEEE 128-bit floating point\n+\ttypes that can go in vector registers.\n+\t(chain_contains_only_swaps): Properly swap IEEE 128-bit floating\n+\tpoint types that can go in vector registers on little endian\n+\tPowerPC systems.\n+\t(mark_swaps_for_removal): Likewise.\n+\t(rs6000_analyze_swaps): Likewise.\n+\t(rs6000_mangle_type): Use U10__float128 for IEEE 128-bit floating point.\n+\n+\t* config/rs6000/rs6000.md (FLOAT128_SFDFTF): Delete iterator,\n+\trework IEEE 128-bit floating point insns to deal with TFmode being\n+\teither IBM extended double or IEEE 128-bit floating point.\n+\t(IFKF): Likewise.\n+\t(IBM128): Update iterator to add condition that the mode is IBM\n+\textended double.\n+\t(IEEE128): New iterator for IEEE 128-bit floating point.\n+\t(TFIFKF): Rename TFIFKF iterator to FLOAT128.\n+\t(FLOAT128): Likewise.\n+\t(signbit<mode>2): FLOAT128_IBM_P condition test moved into IBM128\n+\titerator.\n+\t(neg<mode>2): Replace TFIFKF iterator with FLOAT128. Add support\n+\tfor TFmode being IEEE 128-bit floating point. Use IEEE128 iterator\n+\tinstead of hard coding TFmode or KFmode.\n+\t(negtf2_internal): Likewise.\n+\t(neg<mode>2_internal): Likewise.\n+\t(abs<mode>2): Likewise.\n+\t(abstf2_internal): Likewise.\n+\t(abs<mode>2_internal): Likewise.\n+\t(ieee_128bit_neg<mode>2): Likewise.\n+\t(ieee_128bit_neg<mode>2_internal): Likewise.\n+\t(ieee_128bit_abs<mode>2): Likewise.\n+\t(ieee_128bit_abs<mode>2_internal): Likewise.\n+\t(ieee_128bit_nabs<mode>2): Likewise.\n+\t(ieee_128bit_nabs<mode>2_internal): Likewise.\n+\t(extendiftf2): Add explicit conversions between 128-bit floating\n+\tpoint types. Drop the old conversions that had become unwieldy.\n+\t(extend<FLOAT128_SFDFTF:mode><IFKF:mode>2): Likewise.\n+\t(extendifkf2): Likewise.\n+\t(trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2): Likewise.\n+\t(extendtfkf2): Likewise.\n+\t(fix_trunc<IFKF:mode><SDI:mode>2): Likewise.\n+\t(trunciftf2): Likewise.\n+\t(fixuns_trunc<IFKF:mode><SDI:mode>2): Likewise.\n+\t(truncifkf2): Likewise.\n+\t(float<SDI:mode><IFKF:mode>2): Likewise.\n+\t(trunckftf2): Likewise.\n+\t(floatuns<SDI:mode><IFKF:mode>2): Likewise.\n+\t(trunctfif2): Likewise.\n+\t(FP iterator): Allow TFmode to be IEEE 128-bit floating point.\n+\t(extenddftf2): Rework 128-bit floating point conversions to\n+\tproperly handle -mabi=ieeelongdouble. Merge IFmode, TFmode, and\n+\tKFmode expanders into one function.\n+\t(extenddf<mode>2): Likewise.\n+\t(extenddftf2_fprs): Likewise.\n+\t(extenddf<mode>2_fprs): Likewise.\n+\t(extenddftf2_vsx): Likewise.\n+\t(extenddf<mode>2_vsx): Likewise.\n+\t(extendsftf2): Likewise.\n+\t(extendsf<mode>2): Likewise.\n+\t(trunctfdf2): Likewise.\n+\t(trunc<mode>df2): Likewise.\n+\t(trunctfdf2_internal1): Likewise.\n+\t(trunc<mode>df2_internal1): Likewise.\n+\t(trunctfdf2_internal2): Likewise.\n+\t(trunc<mode>df2_internal2): Likewise.\n+\t(trunctfsf2): Likewise.\n+\t(trunc<mode>sf2): Likewise.\n+\t(trunctfsf2_fprs): Likewise.\n+\t(trunc<mode>sf2_fprs): Likewise.\n+\t(floatsit2f): Likewise.\n+\t(floatsi<mode>2): Likewise.\n+\t(fix_trunc_helper): Likewise.\n+\t(fix_trunc_helper<mode>): Likewise.\n+\t(fix_trunctfsi2): Likewise.\n+\t(fix_trunc<mode>si2): Likewise.\n+\t(fix_trunctfsi2_fprs): Likewise.\n+\t(fix_trunc<mode>si2_fprs): Likewise.\n+\t(fix_trunctfsi2_internal): Likewise.\n+\t(fix_trunc<mode>si2_internal): Likewise.\n+\t(fix_trunctfdi2): Likewise.\n+\t(fix_trunc<mode>di2): Likewise.\n+\t(fixuns_trunctf<mode>2): Likewise.\n+\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n+\t(floatditf2): Likewise.\n+\t(floatdi<mode>2): Likewise.\n+\t(floatuns<mode>tf2): Likewise.\n+\t(floatuns<SDI:mode><IEEE128:mode>): Likewise.\n+\t(cmptf_internal1): Use a mode iterator to add support for both\n+\ttypes (IFmode, TFmode) that support IBM extended double.\n+\t(cmp<mode>_internal1): Likewise.\n+\t(cmptf_internal2): Likewise.\n+\t(cmp<mode>_internal2): Likewise.\n+\n+\t* doc/extend.texi (Floating Types): Document __ibm128 and\n+\t__float128 on PowerPC.\n+\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n+\t-mfloat128 and -mno-float128.\n+\n 2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.h (ALTIVEC_VECTOR_MODE): Add IEEE 128-bit"}, {"sha": "21b43476181ec11a3b1336584ed8876201363095", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 361, "deletions": 99, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -1674,6 +1674,12 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_OFFLOAD_OPTIONS\n #define TARGET_OFFLOAD_OPTIONS rs6000_offload_options\n+\n+#undef TARGET_C_MODE_FOR_SUFFIX\n+#define TARGET_C_MODE_FOR_SUFFIX rs6000_c_mode_for_suffix\n+\n+#undef TARGET_INVALID_BINARY_OP\n+#define TARGET_INVALID_BINARY_OP rs6000_invalid_binary_op\n \f\n \n /* Processor table.  */\n@@ -8461,8 +8467,14 @@ rs6000_const_vec (machine_mode mode)\n rtx\n rs6000_gen_le_vsx_permute (rtx source, machine_mode mode)\n {\n-  rtx par = gen_rtx_PARALLEL (VOIDmode, rs6000_const_vec (mode));\n-  return gen_rtx_VEC_SELECT (mode, source, par);\n+  /* Use ROTATE instead of VEC_SELECT on IEEE 128-bit floating point.  */\n+  if (FLOAT128_VECTOR_P (mode))\n+    return gen_rtx_ROTATE (mode, source, GEN_INT (64));\n+  else\n+    {\n+      rtx par = gen_rtx_PARALLEL (VOIDmode, rs6000_const_vec (mode));\n+      return gen_rtx_VEC_SELECT (mode, source, par);\n+    }\n }\n \n /* Emit a little-endian load from vector memory location SOURCE to VSX\n@@ -16036,75 +16048,184 @@ rs6000_common_init_builtins (void)\n     }\n }\n \n+/* Set up AIX/Darwin/64-bit Linux quad floating point routines.  */\n static void\n-rs6000_init_libfuncs (void)\n+init_float128_ibm (machine_mode mode)\n {\n-  if (!TARGET_IEEEQUAD)\n-      /* AIX/Darwin/64-bit Linux quad floating point routines.  */\n-    if (!TARGET_XL_COMPAT)\n-      {\n-\tset_optab_libfunc (add_optab, TFmode, \"__gcc_qadd\");\n-\tset_optab_libfunc (sub_optab, TFmode, \"__gcc_qsub\");\n-\tset_optab_libfunc (smul_optab, TFmode, \"__gcc_qmul\");\n-\tset_optab_libfunc (sdiv_optab, TFmode, \"__gcc_qdiv\");\n+  if (!TARGET_XL_COMPAT)\n+    {\n+      set_optab_libfunc (add_optab, mode, \"__gcc_qadd\");\n+      set_optab_libfunc (sub_optab, mode, \"__gcc_qsub\");\n+      set_optab_libfunc (smul_optab, mode, \"__gcc_qmul\");\n+      set_optab_libfunc (sdiv_optab, mode, \"__gcc_qdiv\");\n \n-\tif (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n-\t  {\n-\t    set_optab_libfunc (neg_optab, TFmode, \"__gcc_qneg\");\n-\t    set_optab_libfunc (eq_optab, TFmode, \"__gcc_qeq\");\n-\t    set_optab_libfunc (ne_optab, TFmode, \"__gcc_qne\");\n-\t    set_optab_libfunc (gt_optab, TFmode, \"__gcc_qgt\");\n-\t    set_optab_libfunc (ge_optab, TFmode, \"__gcc_qge\");\n-\t    set_optab_libfunc (lt_optab, TFmode, \"__gcc_qlt\");\n-\t    set_optab_libfunc (le_optab, TFmode, \"__gcc_qle\");\n-\n-\t    set_conv_libfunc (sext_optab, TFmode, SFmode, \"__gcc_stoq\");\n-\t    set_conv_libfunc (sext_optab, TFmode, DFmode, \"__gcc_dtoq\");\n-\t    set_conv_libfunc (trunc_optab, SFmode, TFmode, \"__gcc_qtos\");\n-\t    set_conv_libfunc (trunc_optab, DFmode, TFmode, \"__gcc_qtod\");\n-\t    set_conv_libfunc (sfix_optab, SImode, TFmode, \"__gcc_qtoi\");\n-\t    set_conv_libfunc (ufix_optab, SImode, TFmode, \"__gcc_qtou\");\n-\t    set_conv_libfunc (sfloat_optab, TFmode, SImode, \"__gcc_itoq\");\n-\t    set_conv_libfunc (ufloat_optab, TFmode, SImode, \"__gcc_utoq\");\n-\t  }\n+      if (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n+\t{\n+\t  set_optab_libfunc (neg_optab, mode, \"__gcc_qneg\");\n+\t  set_optab_libfunc (eq_optab, mode, \"__gcc_qeq\");\n+\t  set_optab_libfunc (ne_optab, mode, \"__gcc_qne\");\n+\t  set_optab_libfunc (gt_optab, mode, \"__gcc_qgt\");\n+\t  set_optab_libfunc (ge_optab, mode, \"__gcc_qge\");\n+\t  set_optab_libfunc (lt_optab, mode, \"__gcc_qlt\");\n+\t  set_optab_libfunc (le_optab, mode, \"__gcc_qle\");\n \n-\tif (!(TARGET_HARD_FLOAT && TARGET_FPRS))\n-\t  set_optab_libfunc (unord_optab, TFmode, \"__gcc_qunord\");\n-      }\n-    else\n-      {\n-\tset_optab_libfunc (add_optab, TFmode, \"_xlqadd\");\n-\tset_optab_libfunc (sub_optab, TFmode, \"_xlqsub\");\n-\tset_optab_libfunc (smul_optab, TFmode, \"_xlqmul\");\n-\tset_optab_libfunc (sdiv_optab, TFmode, \"_xlqdiv\");\n-      }\n+\t  set_conv_libfunc (sext_optab, mode, SFmode, \"__gcc_stoq\");\n+\t  set_conv_libfunc (sext_optab, mode, DFmode, \"__gcc_dtoq\");\n+\t  set_conv_libfunc (trunc_optab, SFmode, mode, \"__gcc_qtos\");\n+\t  set_conv_libfunc (trunc_optab, DFmode, mode, \"__gcc_qtod\");\n+\t  set_conv_libfunc (sfix_optab, SImode, mode, \"__gcc_qtoi\");\n+\t  set_conv_libfunc (ufix_optab, SImode, mode, \"__gcc_qtou\");\n+\t  set_conv_libfunc (sfloat_optab, mode, SImode, \"__gcc_itoq\");\n+\t  set_conv_libfunc (ufloat_optab, mode, SImode, \"__gcc_utoq\");\n+\t}\n+\n+      if (!(TARGET_HARD_FLOAT && TARGET_FPRS))\n+\tset_optab_libfunc (unord_optab, mode, \"__gcc_qunord\");\n+    }\n   else\n     {\n-      /* 32-bit SVR4 quad floating point routines.  */\n+      set_optab_libfunc (add_optab, mode, \"_xlqadd\");\n+      set_optab_libfunc (sub_optab, mode, \"_xlqsub\");\n+      set_optab_libfunc (smul_optab, mode, \"_xlqmul\");\n+      set_optab_libfunc (sdiv_optab, mode, \"_xlqdiv\");\n+    }\n+\n+  /* Add various conversions for IFmode to use the traditional TFmode\n+     names.  */\n+  if (mode == IFmode)\n+    {\n+      set_conv_libfunc (sext_optab, mode, SDmode, \"__dpd_extendsdtf2\");\n+      set_conv_libfunc (sext_optab, mode, DDmode, \"__dpd_extendddtf2\");\n+      set_conv_libfunc (trunc_optab, mode, TDmode, \"__dpd_trunctftd2\");\n+      set_conv_libfunc (trunc_optab, SDmode, mode, \"__dpd_trunctfsd2\");\n+      set_conv_libfunc (trunc_optab, DDmode, mode, \"__dpd_trunctfdd2\");\n+      set_conv_libfunc (sext_optab, TDmode, mode, \"__dpd_extendtdtf2\");\n \n-      set_optab_libfunc (add_optab, TFmode, \"_q_add\");\n-      set_optab_libfunc (sub_optab, TFmode, \"_q_sub\");\n-      set_optab_libfunc (neg_optab, TFmode, \"_q_neg\");\n-      set_optab_libfunc (smul_optab, TFmode, \"_q_mul\");\n-      set_optab_libfunc (sdiv_optab, TFmode, \"_q_div\");\n+      if (TARGET_POWERPC64)\n+\t{\n+\t  set_conv_libfunc (sfix_optab, TImode, mode, \"__fixtfti\");\n+\t  set_conv_libfunc (ufix_optab, TImode, mode, \"__fixunstfti\");\n+\t  set_conv_libfunc (sfloat_optab, mode, TImode, \"__floattitf\");\n+\t  set_conv_libfunc (ufloat_optab, mode, TImode, \"__floatuntitf\");\n+\t}\n+    }\n+}\n+\n+/* Set up IEEE 128-bit floating point routines.  Use different names if the\n+   arguments can be passed in a vector register.  The historical PowerPC\n+   implementation of IEEE 128-bit floating point used _q_<op> for the names, so\n+   continue to use that if we aren't using vector registers to pass IEEE\n+   128-bit floating point.  */\n+\n+static void\n+init_float128_ieee (machine_mode mode)\n+{\n+  if (FLOAT128_VECTOR_P (mode))\n+    {\n+      set_optab_libfunc (add_optab, mode, \"__addkf3\");\n+      set_optab_libfunc (sub_optab, mode, \"__subkf3\");\n+      set_optab_libfunc (neg_optab, mode, \"__negkf2\");\n+      set_optab_libfunc (smul_optab, mode, \"__mulkf3\");\n+      set_optab_libfunc (sdiv_optab, mode, \"__divkf3\");\n+      set_optab_libfunc (sqrt_optab, mode, \"__sqrtkf2\");\n+      set_optab_libfunc (abs_optab, mode, \"__abstkf2\");\n+\n+      set_optab_libfunc (eq_optab, mode, \"__eqkf2\");\n+      set_optab_libfunc (ne_optab, mode, \"__nekf2\");\n+      set_optab_libfunc (gt_optab, mode, \"__gtkf2\");\n+      set_optab_libfunc (ge_optab, mode, \"__gekf2\");\n+      set_optab_libfunc (lt_optab, mode, \"__ltkf2\");\n+      set_optab_libfunc (le_optab, mode, \"__lekf2\");\n+      set_optab_libfunc (unord_optab, mode, \"__unordkf2\");\n+      set_optab_libfunc (cmp_optab, mode, \"__cmpokf2\");\t\t/* fcmpo */\n+      set_optab_libfunc (ucmp_optab, mode, \"__cmpukf2\");\t/* fcmpu */\n+\n+      set_conv_libfunc (sext_optab, mode, SFmode, \"__extendsfkf2\");\n+      set_conv_libfunc (sext_optab, mode, DFmode, \"__extenddfkf2\");\n+      set_conv_libfunc (trunc_optab, SFmode, mode, \"__trunckfsf2\");\n+      set_conv_libfunc (trunc_optab, DFmode, mode, \"__trunckfdf2\");\n+\n+      set_conv_libfunc (sext_optab, mode, IFmode, \"__extendtfkf2\");\n+      if (mode != TFmode && FLOAT128_IBM_P (TFmode))\n+\tset_conv_libfunc (sext_optab, mode, TFmode, \"__extendtfkf2\");\n+\n+      set_conv_libfunc (trunc_optab, IFmode, mode, \"__trunckftf2\");\n+      if (mode != TFmode && FLOAT128_IBM_P (TFmode))\n+\tset_conv_libfunc (trunc_optab, TFmode, mode, \"__trunckftf2\");\n+\n+      set_conv_libfunc (sext_optab, mode, SDmode, \"__dpd_extendsdkf2\");\n+      set_conv_libfunc (sext_optab, mode, DDmode, \"__dpd_extendddkf2\");\n+      set_conv_libfunc (trunc_optab, mode, TDmode, \"__dpd_trunckftd2\");\n+      set_conv_libfunc (trunc_optab, SDmode, mode, \"__dpd_trunckfsd2\");\n+      set_conv_libfunc (trunc_optab, DDmode, mode, \"__dpd_trunckfdd2\");\n+      set_conv_libfunc (sext_optab, TDmode, mode, \"__dpd_extendtdkf2\");\n+\n+      set_conv_libfunc (sfix_optab, SImode, mode, \"__fixkfsi\");\n+      set_conv_libfunc (ufix_optab, SImode, mode, \"__fixunskfsi\");\n+      set_conv_libfunc (sfix_optab, DImode, mode, \"__fixkfdi\");\n+      set_conv_libfunc (ufix_optab, DImode, mode, \"__fixunskfdi\");\n+\n+      set_conv_libfunc (sfloat_optab, mode, SImode, \"__floatsikf\");\n+      set_conv_libfunc (ufloat_optab, mode, SImode, \"__floatunsikf\");\n+      set_conv_libfunc (sfloat_optab, mode, DImode, \"__floatdikf\");\n+      set_conv_libfunc (ufloat_optab, mode, DImode, \"__floatundikf\");\n+\n+      if (TARGET_POWERPC64)\n+\t{\n+\t  set_conv_libfunc (sfix_optab, TImode, mode, \"__fixkfti\");\n+\t  set_conv_libfunc (ufix_optab, TImode, mode, \"__fixunskfti\");\n+\t  set_conv_libfunc (sfloat_optab, mode, TImode, \"__floattikf\");\n+\t  set_conv_libfunc (ufloat_optab, mode, TImode, \"__floatuntikf\");\n+\t}\n+    }\n+\n+  else\n+    {\n+      set_optab_libfunc (add_optab, mode, \"_q_add\");\n+      set_optab_libfunc (sub_optab, mode, \"_q_sub\");\n+      set_optab_libfunc (neg_optab, mode, \"_q_neg\");\n+      set_optab_libfunc (smul_optab, mode, \"_q_mul\");\n+      set_optab_libfunc (sdiv_optab, mode, \"_q_div\");\n       if (TARGET_PPC_GPOPT)\n-\tset_optab_libfunc (sqrt_optab, TFmode, \"_q_sqrt\");\n+\tset_optab_libfunc (sqrt_optab, mode, \"_q_sqrt\");\n \n-      set_optab_libfunc (eq_optab, TFmode, \"_q_feq\");\n-      set_optab_libfunc (ne_optab, TFmode, \"_q_fne\");\n-      set_optab_libfunc (gt_optab, TFmode, \"_q_fgt\");\n-      set_optab_libfunc (ge_optab, TFmode, \"_q_fge\");\n-      set_optab_libfunc (lt_optab, TFmode, \"_q_flt\");\n-      set_optab_libfunc (le_optab, TFmode, \"_q_fle\");\n+      set_optab_libfunc (eq_optab, mode, \"_q_feq\");\n+      set_optab_libfunc (ne_optab, mode, \"_q_fne\");\n+      set_optab_libfunc (gt_optab, mode, \"_q_fgt\");\n+      set_optab_libfunc (ge_optab, mode, \"_q_fge\");\n+      set_optab_libfunc (lt_optab, mode, \"_q_flt\");\n+      set_optab_libfunc (le_optab, mode, \"_q_fle\");\n \n-      set_conv_libfunc (sext_optab, TFmode, SFmode, \"_q_stoq\");\n-      set_conv_libfunc (sext_optab, TFmode, DFmode, \"_q_dtoq\");\n-      set_conv_libfunc (trunc_optab, SFmode, TFmode, \"_q_qtos\");\n-      set_conv_libfunc (trunc_optab, DFmode, TFmode, \"_q_qtod\");\n-      set_conv_libfunc (sfix_optab, SImode, TFmode, \"_q_qtoi\");\n-      set_conv_libfunc (ufix_optab, SImode, TFmode, \"_q_qtou\");\n-      set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_q_itoq\");\n-      set_conv_libfunc (ufloat_optab, TFmode, SImode, \"_q_utoq\");\n+      set_conv_libfunc (sext_optab, mode, SFmode, \"_q_stoq\");\n+      set_conv_libfunc (sext_optab, mode, DFmode, \"_q_dtoq\");\n+      set_conv_libfunc (trunc_optab, SFmode, mode, \"_q_qtos\");\n+      set_conv_libfunc (trunc_optab, DFmode, mode, \"_q_qtod\");\n+      set_conv_libfunc (sfix_optab, SImode, mode, \"_q_qtoi\");\n+      set_conv_libfunc (ufix_optab, SImode, mode, \"_q_qtou\");\n+      set_conv_libfunc (sfloat_optab, mode, SImode, \"_q_itoq\");\n+      set_conv_libfunc (ufloat_optab, mode, SImode, \"_q_utoq\");\n+    }\n+}\n+\n+static void\n+rs6000_init_libfuncs (void)\n+{\n+  /* __float128 support.  */\n+  if (TARGET_FLOAT128)\n+    {\n+      init_float128_ibm (IFmode);\n+      init_float128_ieee (KFmode);\n+    }\n+\n+  /* AIX/Darwin/64-bit Linux quad floating point routines.  */\n+  if (TARGET_LONG_DOUBLE_128)\n+    {\n+      if (!TARGET_IEEEQUAD)\n+\tinit_float128_ibm (TFmode);\n+\n+      /* IEEE 128-bit including 32-bit SVR4 quad floating point routines.  */\n+      else\n+\tinit_float128_ieee (TFmode);\n     }\n }\n \n@@ -19989,17 +20110,18 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n       emit_insn (cmp);\n     }\n \n-  /* IEEE 128-bit support in VSX registers.  The comparison function (__cmpkf2)\n-     returns 0..15 that is laid out the same way as the PowerPC CR register\n-     would for a normal floating point comparison.  */\n+  /* IEEE 128-bit support in VSX registers.  The comparison functions\n+     (__cmpokf2 and __cmpukf2) returns 0..15 that is laid out the same way as\n+     the PowerPC CR register would for a normal floating point comparison from\n+     the fcmpo and fcmpu instructions.  */\n   else if (FLOAT128_IEEE_P (mode))\n     {\n       rtx and_reg = gen_reg_rtx (SImode);\n       rtx dest = gen_reg_rtx (SImode);\n-      rtx libfunc = optab_libfunc (cmp_optab, mode);\n+      rtx libfunc = optab_libfunc (ucmp_optab, mode);\n       HOST_WIDE_INT mask_value = 0;\n \n-      /* Values that __cmpkf2 returns.  */\n+      /* Values that __cmpokf2/__cmpukf2 returns.  */\n #define PPC_CMP_UNORDERED\t0x1\t\t/* isnan (a) || isnan (b).  */\n #define PPC_CMP_EQUAL\t\t0x2\t\t/* a == b.  */\n #define PPC_CMP_GREATER_THEN\t0x4\t\t/* a > b.  */\n@@ -20170,7 +20292,49 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   return gen_rtx_fmt_ee (code, VOIDmode, compare_result, const0_rtx);\n }\n \n+\f\n+/* Return the diagnostic message string if the binary operation OP is\n+   not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n+\n+static const char*\n+rs6000_invalid_binary_op (int op ATTRIBUTE_UNUSED,\n+\t\t\t  const_tree type1,\n+\t\t\t  const_tree type2)\n+{\n+  enum machine_mode mode1 = TYPE_MODE (type1);\n+  enum machine_mode mode2 = TYPE_MODE (type2);\n+\n+  /* For complex modes, use the inner type.  */\n+  if (COMPLEX_MODE_P (mode1))\n+    mode1 = GET_MODE_INNER (mode1);\n+\n+  if (COMPLEX_MODE_P (mode2))\n+    mode2 = GET_MODE_INNER (mode2);\n+\n+  /* Don't allow IEEE 754R 128-bit binary floating point and IBM extended\n+     double to intermix.  */\n+  if (mode1 == mode2)\n+    return NULL;\n+\n+  if ((mode1 == KFmode && mode2 == IFmode)\n+      || (mode1 == IFmode && mode2 == KFmode))\n+    return N_(\"__float128 and __ibm128 cannot be used in the same expression\");\n+\n+  if (TARGET_IEEEQUAD\n+      && ((mode1 == IFmode && mode2 == TFmode)\n+\t  || (mode1 == TFmode && mode2 == IFmode)))\n+    return N_(\"__ibm128 and long double cannot be used in the same expression\");\n+\n+  if (!TARGET_IEEEQUAD\n+      && ((mode1 == KFmode && mode2 == TFmode)\n+\t  || (mode1 == TFmode && mode2 == KFmode)))\n+    return N_(\"__float128 and long double cannot be used in the same \"\n+\t      \"expression\");\n+\n+  return NULL;\n+}\n \n+\f\n /* Expand floating point conversion to/from __float128 and __ibm128.  */\n \n void\n@@ -20179,60 +20343,121 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   machine_mode dest_mode = GET_MODE (dest);\n   machine_mode src_mode = GET_MODE (src);\n   convert_optab cvt = unknown_optab;\n+  bool do_move = false;\n   rtx libfunc = NULL_RTX;\n   rtx dest2;\n \n   if (dest_mode == src_mode)\n     gcc_unreachable ();\n \n+  /* Eliminate memory operations.  */\n+  if (MEM_P (src))\n+    src = force_reg (src_mode, src);\n+\n+  if (MEM_P (dest))\n+    {\n+      rtx tmp = gen_reg_rtx (dest_mode);\n+      rs6000_expand_float128_convert (tmp, src, unsigned_p);\n+      rs6000_emit_move (dest, tmp, dest_mode);\n+      return;\n+    }\n+\n+  /* Convert to IEEE 128-bit floating point.  */\n   if (FLOAT128_IEEE_P (dest_mode))\n     {\n-      if (src_mode == SFmode\n-\t  || src_mode == DFmode\n-\t  || FLOAT128_IBM_P (src_mode))\n-\tcvt = sext_optab;\n+      switch (src_mode)\n+\t{\n+\tcase DFmode:\n+\t  cvt = sext_optab;\n+\t  break;\n \n-      else if (GET_MODE_CLASS (src_mode) == MODE_INT)\n-\tcvt = (unsigned_p) ? ufloat_optab : sfloat_optab;\n+\tcase SFmode:\n+\t  cvt = sext_optab;\n+\t  break;\n \n-      else if (FLOAT128_IEEE_P (src_mode))\n-\temit_move_insn (dest, gen_lowpart (dest_mode, src));\n+\tcase KFmode:\n+\tcase IFmode:\n+\tcase TFmode:\n+\t  if (FLOAT128_IBM_P (src_mode))\n+\t    cvt = sext_optab;\n+\t  else\n+\t    do_move = true;\n+\t  break;\n \n-      else\n-\tgcc_unreachable ();\n+\tcase SImode:\n+\tcase DImode:\n+\t  cvt = (unsigned_p) ? ufloat_optab : sfloat_optab;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n+  /* Convert from IEEE 128-bit floating point.  */\n   else if (FLOAT128_IEEE_P (src_mode))\n     {\n-      if (dest_mode == SFmode\n-\t  || dest_mode == DFmode\n-\t  || FLOAT128_IBM_P (dest_mode))\n-\tcvt = trunc_optab;\n+      switch (dest_mode)\n+\t{\n+\tcase DFmode:\n+\t  cvt = trunc_optab;\n+\t  break;\n \n-      else if (GET_MODE_CLASS (dest_mode) == MODE_INT)\n-\tcvt = (unsigned_p) ? ufix_optab : sfix_optab;\n+\tcase SFmode:\n+\t  cvt = trunc_optab;\n+\t  break;\n \n-      else\n-\tgcc_unreachable ();\n+\tcase KFmode:\n+\tcase IFmode:\n+\tcase TFmode:\n+\t  if (FLOAT128_IBM_P (dest_mode))\n+\t    cvt = trunc_optab;\n+\t  else\n+\t    do_move = true;\n+\t  break;\n+\n+\tcase SImode:\n+\tcase DImode:\n+\t  cvt = (unsigned_p) ? ufix_optab : sfix_optab;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n+  /* Both IBM format.  */\n+  else if (FLOAT128_IBM_P (dest_mode) && FLOAT128_IBM_P (src_mode))\n+    do_move = true;\n+\n   else\n     gcc_unreachable ();\n \n-  gcc_assert (cvt != unknown_optab);\n-  libfunc = convert_optab_libfunc (cvt, dest_mode, src_mode);\n-  gcc_assert (libfunc != NULL_RTX);\n+  /* Handle conversion between TFmode/KFmode.  */\n+  if (do_move)\n+    emit_move_insn (dest, gen_lowpart (dest_mode, src));\n \n-  dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode, 1, src,\n-\t\t\t\t   src_mode);\n+  /* Call an external function to do the conversion.  */\n+  else if (cvt != unknown_optab)\n+    {\n+      libfunc = convert_optab_libfunc (cvt, dest_mode, src_mode);\n+      gcc_assert (libfunc != NULL_RTX);\n \n-  gcc_assert (dest != NULL_RTX);\n-  if (!rtx_equal_p (dest, dest2))\n-    emit_move_insn (dest, dest2);\n+      dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode, 1, src,\n+\t\t\t\t       src_mode);\n+\n+      gcc_assert (dest2 != NULL_RTX);\n+      if (!rtx_equal_p (dest, dest2))\n+\temit_move_insn (dest, dest2);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n \n   return;\n }\n \n+\f\n /* Emit the RTL for an sISEL pattern.  */\n \n void\n@@ -29827,6 +30052,21 @@ rs6000_mangle_type (const_tree type)\n   if (type == bool_int_type_node) return \"U6__booli\";\n   if (type == bool_long_type_node) return \"U6__booll\";\n \n+  /* Use a unique name for __float128 rather than trying to use \"e\" or \"g\". Use\n+     \"g\" for IBM extended double, no matter whether it is long double (using\n+     -mabi=ibmlongdouble) or the distinct __ibm128 type.  */\n+  if (TARGET_FLOAT128)\n+    {\n+      if (type == ieee128_float_type_node)\n+\treturn \"U10__float128\";\n+\n+      if (type == ibm128_float_type_node)\n+\treturn \"g\";\n+\n+      if (type == long_double_type_node && TARGET_LONG_DOUBLE_128)\n+\treturn (TARGET_IEEEQUAD) ? \"U10__float128\" : \"g\";\n+    }\n+\n   /* Mangle IBM extended float long double as `g' (__float128) on\n      powerpc*-linux where long-double-64 previously was the default.  */\n   if (TYPE_MAIN_VARIANT (type) == long_double_type_node\n@@ -33136,6 +33376,26 @@ rs6000_vector_mode_supported_p (machine_mode mode)\n     return false;\n }\n \n+/* Target hook for c_mode_for_suffix.  */\n+static machine_mode\n+rs6000_c_mode_for_suffix (char suffix)\n+{\n+  if (TARGET_FLOAT128)\n+    {\n+      if (suffix == 'q' || suffix == 'Q')\n+\treturn (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n+\n+      /* At the moment, we are not defining a suffix for IBM extended double.\n+\t If/when the default for -mabi=ieeelongdouble is changed, and we want\n+\t to support __ibm128 constants in legacy library code, we may need to\n+\t re-evalaute this decision.  Currently, c-lex.c only supports 'w' and\n+\t 'q' as machine dependent suffixes.  The x86_64 port uses 'w' for\n+\t __float80 constants.  */\n+    }\n+\n+  return VOIDmode;\n+}\n+\n /* Target hook for invalid_arg_for_unprototyped_fn. */\n static const char *\n invalid_arg_for_unprototyped_fn (const_tree typelist, const_tree funcdecl, const_tree val)\n@@ -35605,7 +35865,7 @@ chain_contains_only_swaps (swap_web_entry *insn_entry, struct df_link *link,\n \n   for (; link; link = link->next)\n     {\n-      if (!VECTOR_MODE_P (GET_MODE (DF_REF_REG (link->ref))))\n+      if (!ALTIVEC_OR_VSX_VECTOR_MODE (GET_MODE (DF_REF_REG (link->ref))))\n \tcontinue;\n \n       if (DF_REF_IS_ARTIFICIAL (link->ref))\n@@ -35704,7 +35964,7 @@ mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)\n \t{\n \t  /* Ignore uses for addressability.  */\n \t  machine_mode mode = GET_MODE (DF_REF_REG (use));\n-\t  if (!VECTOR_MODE_P (mode))\n+\t  if (!ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n \t    continue;\n \n \t  struct df_link *link = DF_REF_CHAIN (use);\n@@ -36218,10 +36478,11 @@ rs6000_analyze_swaps (function *fun)\n \t\t    mode = V4SImode;\n \t\t}\n \n-\t      if (VECTOR_MODE_P (mode) || mode == TImode)\n+\t      if (ALTIVEC_OR_VSX_VECTOR_MODE (mode) || mode == TImode)\n \t\t{\n \t\t  insn_entry[uid].is_relevant = 1;\n-\t\t  if (mode == TImode || mode == V1TImode)\n+\t\t  if (mode == TImode || mode == V1TImode\n+\t\t      || FLOAT128_VECTOR_P (mode))\n \t\t    insn_entry[uid].is_128_int = 1;\n \t\t  if (DF_REF_INSN_INFO (mention))\n \t\t    insn_entry[uid].contains_subreg\n@@ -36242,13 +36503,14 @@ rs6000_analyze_swaps (function *fun)\n \t\t isn't sufficient to ensure we union the call into the\n \t\t web with the parameter setup code.  */\n \t      if (mode == DImode && GET_CODE (insn) == SET\n-\t\t  && VECTOR_MODE_P (GET_MODE (SET_DEST (insn))))\n+\t\t  && ALTIVEC_OR_VSX_VECTOR_MODE (GET_MODE (SET_DEST (insn))))\n \t\tmode = GET_MODE (SET_DEST (insn));\n \n-\t      if (VECTOR_MODE_P (mode) || mode == TImode)\n+\t      if (ALTIVEC_OR_VSX_VECTOR_MODE (mode) || mode == TImode)\n \t\t{\n \t\t  insn_entry[uid].is_relevant = 1;\n-\t\t  if (mode == TImode || mode == V1TImode)\n+\t\t  if (mode == TImode || mode == V1TImode\n+\t\t      || FLOAT128_VECTOR_P (mode))\n \t\t    insn_entry[uid].is_128_int = 1;\n \t\t  if (DF_REF_INSN_INFO (mention))\n \t\t    insn_entry[uid].contains_subreg"}, {"sha": "eeeef3422283a520c9542b83aee51156ba5fba19", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 230, "deletions": 178, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -347,8 +347,7 @@\n    && ((TARGET_FPRS && TARGET_SINGLE_FLOAT) || TARGET_E500_SINGLE)\")\n   (DF \"TARGET_HARD_FLOAT \n    && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\")\n-  (TF \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n+  (TF \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\")\n   (IF \"TARGET_FLOAT128\")\n@@ -448,24 +447,18 @@\n ; Iterator for just SF/DF\n (define_mode_iterator SFDF [SF DF])\n \n-; Iterator for float128 floating conversions\n-(define_mode_iterator FLOAT128_SFDFTF [\n-    (SF \"TARGET_FLOAT128\")\n-    (DF \"TARGET_FLOAT128\")\n-    (TF \"FLOAT128_IBM_P (TFmode)\")\n-    (IF \"TARGET_FLOAT128\")])\n-\n-; Iterator for special 128-bit floating point.  This is for non-default\n-; conversions, so TFmode is not used here.\n-(define_mode_iterator IFKF [IF KF])\n-\n ; Iterator for 128-bit floating point that uses the IBM double-double format\n-(define_mode_iterator IBM128 [IF TF])\n+(define_mode_iterator IBM128 [(IF \"FLOAT128_IBM_P (IFmode)\")\n+\t\t\t      (TF \"FLOAT128_IBM_P (TFmode)\")])\n+\n+; Iterator for 128-bit floating point that uses IEEE 128-bit float\n+(define_mode_iterator IEEE128 [(KF \"FLOAT128_IEEE_P (KFmode)\")\n+\t\t\t       (TF \"FLOAT128_IEEE_P (TFmode)\")])\n \n ; Iterator for 128-bit floating point\n-(define_mode_iterator TFIFKF [(KF \"TARGET_FLOAT128\")\n-\t\t\t      (IF \"TARGET_FLOAT128\")\n-\t\t\t      (TF \"TARGET_LONG_DOUBLE_128\")])\n+(define_mode_iterator FLOAT128 [(KF \"TARGET_FLOAT128\")\n+\t\t\t\t(IF \"TARGET_FLOAT128\")\n+\t\t\t\t(TF \"TARGET_LONG_DOUBLE_128\")])\n \n ; SF/DF suffix for traditional floating instructions\n (define_mode_attr Ftrad\t\t[(SF \"s\") (DF \"\")])\n@@ -4248,8 +4241,7 @@\n    \t(match_dup 5))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n   \t(match_dup 6))]\n-  \"FLOAT128_IBM_P (<MODE>mode)\n-   && TARGET_HARD_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n {\n   operands[2] = gen_reg_rtx (DFmode);\n@@ -6470,34 +6462,51 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"20,20,16\")])\n \n-(define_expand \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(float_extend:TF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"extenddf<mode>2\"\n+  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:FLOAT128 (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_IEEEQUAD)\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n   else if (TARGET_E500_DOUBLE)\n-    emit_insn (gen_spe_extenddftf2 (operands[0], operands[1]));\n+    {\n+      gcc_assert (<MODE>mode == TFmode);\n+      emit_insn (gen_spe_extenddftf2 (operands[0], operands[1]));\n+    }\n   else if (TARGET_VSX)\n-    emit_insn (gen_extenddftf2_vsx (operands[0], operands[1]));\n-  else\n+    {\n+      if (<MODE>mode == TFmode)\n+\temit_insn (gen_extenddftf2_vsx (operands[0], operands[1]));\n+      else if (<MODE>mode == IFmode)\n+\temit_insn (gen_extenddfif2_vsx (operands[0], operands[1]));\n+      else\n+\tgcc_unreachable ();\n+    }\n+   else\n     {\n       rtx zero = gen_reg_rtx (DFmode);\n       rs6000_emit_move (zero, CONST0_RTX (DFmode), DFmode);\n-      emit_insn (gen_extenddftf2_fprs (operands[0], operands[1], zero));\n+\n+      if (<MODE>mode == TFmode)\n+\temit_insn (gen_extenddftf2_fprs (operands[0], operands[1], zero));\n+      else if (<MODE>mode == IFmode)\n+\temit_insn (gen_extenddfif2_fprs (operands[0], operands[1], zero));\n+      else\n+\tgcc_unreachable ();\n     }\n   DONE;\n })\n \n ;; Allow memory operands for the source to be created by the combiner.\n-(define_insn_and_split \"extenddftf2_fprs\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=d,d,&d\")\n-\t(float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"d,m,d\")))\n+(define_insn_and_split \"extenddf<mode>2_fprs\"\n+  [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"=d,d,&d\")\n+\t(float_extend:IBM128\n+\t (match_operand:DF 1 \"nonimmediate_operand\" \"d,m,d\")))\n    (use (match_operand:DF 2 \"nonimmediate_operand\" \"m,m,d\"))]\n   \"!TARGET_VSX && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && TARGET_LONG_DOUBLE_128 && !TARGET_IEEEQUAD\"\n+   && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3) (match_dup 1))\n@@ -6506,14 +6515,15 @@\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n \n-  operands[3] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n-  operands[4] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n+  operands[3] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, hi_word);\n+  operands[4] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, lo_word);\n })\n \n-(define_insn_and_split \"extenddftf2_vsx\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=d,d\")\n-\t(float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"ws,m\")))]\n-  \"TARGET_LONG_DOUBLE_128 && TARGET_VSX && !TARGET_IEEEQUAD\"\n+(define_insn_and_split \"extenddf<mode>2_vsx\"\n+  [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"=d,d\")\n+\t(float_extend:IBM128\n+\t (match_operand:DF 1 \"nonimmediate_operand\" \"ws,m\")))]\n+  \"TARGET_LONG_DOUBLE_128 && TARGET_VSX && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -6522,47 +6532,48 @@\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n \n-  operands[2] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n-  operands[3] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n+  operands[2] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, hi_word);\n+  operands[3] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, lo_word);\n   operands[4] = CONST0_RTX (DFmode);\n })\n \n-(define_expand \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(float_extend:TF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"extendsf<mode>2\"\n+  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:FLOAT128 (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_IEEEQUAD)\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n   else\n     {\n       rtx tmp = gen_reg_rtx (DFmode);\n       emit_insn (gen_extendsfdf2 (tmp, operands[1]));\n-      emit_insn (gen_extenddftf2 (operands[0], tmp));\n+      emit_insn (gen_extenddf<mode>2 (operands[0], tmp));\n     }\n   DONE;\n })\n \n-(define_expand \"trunctfdf2\"\n+(define_expand \"trunc<mode>df2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+\t(float_truncate:DF (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_IEEEQUAD)\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n       rs6000_expand_float128_convert (operands[0], operands[1], false);\n       DONE;\n     }\n })\n \n-(define_insn_and_split \"trunctfdf2_internal1\"\n+(define_insn_and_split \"trunc<mode>df2_internal1\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d\")\n-\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"0,d\")))]\n-  \"!TARGET_IEEEQUAD && !TARGET_XL_COMPAT\n+\t(float_truncate:DF\n+\t (match_operand:IBM128 1 \"gpc_reg_operand\" \"0,d\")))]\n+  \"FLOAT128_IBM_P (<MODE>mode) && !TARGET_XL_COMPAT\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n   \"@\n    #\n@@ -6575,39 +6586,44 @@\n }\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"trunctfdf2_internal2\"\n+(define_insn \"trunc<mode>df2_internal2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"!TARGET_IEEEQUAD && TARGET_XL_COMPAT\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && TARGET_LONG_DOUBLE_128\"\n+\t(float_truncate:DF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n+  \"FLOAT128_IBM_P (<MODE>mode) && TARGET_XL_COMPAT && TARGET_HARD_FLOAT\n+   && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"fadd %0,%1,%L1\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_addsub_d\")])\n \n-(define_expand \"trunctfsf2\"\n+(define_expand \"trunc<mode>sf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+\t(float_truncate:SF (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_IEEEQUAD)\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n   else if (TARGET_E500_DOUBLE)\n-    emit_insn (gen_spe_trunctfsf2 (operands[0], operands[1]));\n-  else\n+    {\n+      gcc_assert (<MODE>mode == TFmode);\n+      emit_insn (gen_spe_trunctfsf2 (operands[0], operands[1]));\n+    }\n+  else if (<MODE>mode == TFmode)\n     emit_insn (gen_trunctfsf2_fprs (operands[0], operands[1]));\n+  else if (<MODE>mode == IFmode)\n+    emit_insn (gen_truncifsf2_fprs (operands[0], operands[1]));\n+  else\n+    gcc_unreachable ();\n   DONE;\n })\n \n-(define_insn_and_split \"trunctfsf2_fprs\"\n+(define_insn_and_split \"trunc<mode>sf2_fprs\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"d\")))\n+\t(float_truncate:SF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \n-   && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \n+   && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -6616,78 +6632,91 @@\n \t(float_truncate:SF (match_dup 2)))]\n   \"\")\n \n-(define_expand \"floatsitf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-        (float:TF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n+(define_expand \"floatsi<mode>2\"\n+  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n+        (float:FLOAT128 (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  rtx tmp = gen_reg_rtx (DFmode);\n-  expand_float (tmp, operands[1], false);\n-  emit_insn (gen_extenddftf2 (operands[0], tmp));\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n+    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  else\n+    {\n+      rtx tmp = gen_reg_rtx (DFmode);\n+      expand_float (tmp, operands[1], false);\n+      if (<MODE>mode == TFmode)\n+\temit_insn (gen_extenddftf2 (operands[0], tmp));\n+      else if (<MODE>mode == IFmode)\n+\temit_insn (gen_extenddfif2 (operands[0], tmp));\n+      else\n+\tgcc_unreachable ();\n+    }\n   DONE;\n })\n \n ; fadd, but rounding towards zero.\n ; This is probably not the optimal code sequence.\n-(define_insn \"fix_trunc_helper\"\n+(define_insn \"fix_trunc_helper<mode>\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:TF 1 \"gpc_reg_operand\" \"d\")]\n+\t(unspec:DF [(match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")]\n \t\t   UNSPEC_FIX_TRUNC_TF))\n    (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=&d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && FLOAT128_IBM_P (<MODE>mode)\"\n   \"mffs %2\\n\\tmtfsb1 31\\n\\tmtfsb0 30\\n\\tfadd %0,%1,%L1\\n\\tmtfsf 1,%2\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"20\")])\n \n-(define_expand \"fix_trunctfsi2\"\n+(define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+\t(fix:SI (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE) && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_IEEEQUAD)\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  else if (TARGET_E500_DOUBLE)\n+  else if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n     emit_insn (gen_spe_fix_trunctfsi2 (operands[0], operands[1]));\n-  else\n+  else if (<MODE>mode == TFmode)\n     emit_insn (gen_fix_trunctfsi2_fprs (operands[0], operands[1]));\n+  else if (<MODE>mode == IFmode)\n+    emit_insn (gen_fix_truncifsi2_fprs (operands[0], operands[1]));\n+  else\n+    gcc_unreachable ();\n   DONE;\n })\n \n-(define_expand \"fix_trunctfsi2_fprs\"\n+(define_expand \"fix_trunc<mode>si2_fprs\"\n   [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n+\t\t   (fix:SI (match_operand:IBM128 1 \"gpc_reg_operand\" \"\")))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n {\n   operands[2] = gen_reg_rtx (DFmode);\n   operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = gen_reg_rtx (DImode);\n   operands[5] = assign_stack_temp (DImode, GET_MODE_SIZE (DImode));\n })\n \n-(define_insn_and_split \"*fix_trunctfsi2_internal\"\n+(define_insn_and_split \"*fix_trunc<mode>si2_internal\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"d\")))\n+        (fix:SI (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=d\"))\n    (clobber (match_operand:DF 3 \"gpc_reg_operand\" \"=&d\"))\n    (clobber (match_operand:DI 4 \"gpc_reg_operand\" \"=d\"))\n    (clobber (match_operand:DI 5 \"offsettable_mem_operand\" \"=o\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"\"\n   [(pc)]\n {\n   rtx lowword;\n-  emit_insn (gen_fix_trunc_helper (operands[2], operands[1], operands[3]));\n+  emit_insn (gen_fix_trunc_helper<mode> (operands[2], operands[1],\n+\t\t\t\t\t operands[3]));\n \n   gcc_assert (MEM_P (operands[5]));\n   lowword = adjust_address (operands[5], SImode, WORDS_BIG_ENDIAN ? 4 : 0);\n@@ -6698,45 +6727,45 @@\n   DONE;\n })\n \n-(define_expand \"fix_trunctfdi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(fix:DI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"fix_trunc<mode>di2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:DI (match_operand:IEEE128 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"fixuns_trunctf<mode>2\"\n-  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n-\t(unsigned_fix:SDI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"fixuns_trunc<IEEE128:mode><SDI:mode>2\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_fix:SDI (match_operand:IEEE128 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], true);\n   DONE;\n })\n \n-(define_expand \"floatditf2\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-\t(float:TF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"floatdi<mode>2\"\n+  [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n+\t(float:IEEE128 (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"floatuns<mode>tf2\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-\t(unsigned_float:TF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"floatuns<SDI:mode><IEEE128:mode>2\"\n+  [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_float:IEEE128 (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], true);\n   DONE;\n })\n \n (define_expand \"neg<mode>2\"\n-  [(set (match_operand:TFIFKF 0 \"gpc_reg_operand\" \"\")\n-\t(neg:TFIFKF (match_operand:TFIFKF 1 \"gpc_reg_operand\" \"\")))]\n+  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n+\t(neg:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n    || (FLOAT128_IBM_P (<MODE>mode)\n        && TARGET_HARD_FLOAT\n@@ -6746,7 +6775,14 @@\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n       if (TARGET_FLOAT128)\n-\temit_insn (gen_ieee_128bit_vsx_neg<mode>2 (operands[0], operands[1]));\n+\t{\n+\t  if (<MODE>mode == TFmode)\n+\t    emit_insn (gen_ieee_128bit_vsx_negtf2 (operands[0], operands[1]));\n+\t  else if (<MODE>mode == KFmode)\n+\t    emit_insn (gen_ieee_128bit_vsx_negkf2 (operands[0], operands[1]));\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n       else\n \t{\n \t  rtx libfunc = optab_libfunc (neg_optab, <MODE>mode);\n@@ -6761,9 +6797,9 @@\n     }\n }\")\n \n-(define_insn \"negtf2_internal\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=d\")\n-\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"d\")))]\n+(define_insn \"neg<mode>2_internal\"\n+  [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"=d\")\n+\t(neg:IBM128 (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && FLOAT128_IBM_P (TFmode)\"\n   \"*\n {\n@@ -6776,8 +6812,8 @@\n    (set_attr \"length\" \"8\")])\n \n (define_expand \"abs<mode>2\"\n-  [(set (match_operand:TFIFKF 0 \"gpc_reg_operand\" \"\")\n-\t(abs:TFIFKF (match_operand:TFIFKF 1 \"gpc_reg_operand\" \"\")))]\n+  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n+\t(abs:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n    || (FLOAT128_IBM_P (<MODE>mode)\n        && TARGET_HARD_FLOAT\n@@ -6790,48 +6826,56 @@\n     {\n       if (TARGET_FLOAT128)\n \t{\n-\t  emit_insn (gen_ieee_128bit_vsx_abs<mode>2 (operands[0], operands[1]));\n+\t  if (<MODE>mode == TFmode)\n+\t    emit_insn (gen_ieee_128bit_vsx_abstf2 (operands[0], operands[1]));\n+\t  else if (<MODE>mode == KFmode)\n+\t    emit_insn (gen_ieee_128bit_vsx_abskf2 (operands[0], operands[1]));\n+\t  else\n+\t    FAIL;\n \t  DONE;\n \t}\n       else\n \tFAIL;\n     }\n \n   label = gen_label_rtx ();\n-  if (TARGET_E500_DOUBLE)\n+  if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n     {\n       if (flag_finite_math_only && !flag_trapping_math)\n \temit_insn (gen_spe_abstf2_tst (operands[0], operands[1], label));\n       else\n \temit_insn (gen_spe_abstf2_cmp (operands[0], operands[1], label));\n     }\n-  else\n+  else if (<MODE>mode == TFmode)\n     emit_insn (gen_abstf2_internal (operands[0], operands[1], label));\n+  else if (<MODE>mode == TFmode)\n+    emit_insn (gen_absif2_internal (operands[0], operands[1], label));\n+  else\n+    FAIL;\n   emit_label (label);\n   DONE;\n }\")\n \n-(define_expand \"abstf2_internal\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:TF 1 \"gpc_reg_operand\" \"\"))\n+(define_expand \"abs<mode>2_internal\"\n+  [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:IBM128 1 \"gpc_reg_operand\" \"\"))\n    (set (match_dup 3) (match_dup 5))\n    (set (match_dup 5) (abs:DF (match_dup 5)))\n    (set (match_dup 4) (compare:CCFP (match_dup 3) (match_dup 5)))\n    (set (pc) (if_then_else (eq (match_dup 4) (const_int 0))\n \t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 6) (neg:DF (match_dup 6)))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && TARGET_LONG_DOUBLE_128\"\n   \"\n {\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n   operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = gen_reg_rtx (CCFPmode);\n-  operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n-  operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n+  operands[5] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, hi_word);\n+  operands[6] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, lo_word);\n }\")\n \n \f\n@@ -6864,14 +6908,14 @@\n ;; neg/abs to create the constant just once.\n \n (define_insn_and_split \"ieee_128bit_vsx_neg<mode>2\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(neg:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"TARGET_FLOAT128\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (neg:TFIFKF (match_dup 1)))\n+\t\t   (neg:IEEE128 (match_dup 1)))\n \t      (use (match_dup 2))])]\n {\n   if (GET_CODE (operands[2]) == SCRATCH)\n@@ -6884,23 +6928,23 @@\n    (set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*ieee_128bit_vsx_neg<mode>2_internal\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(neg:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n   \"TARGET_FLOAT128\"\n   \"xxlxor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n ;; IEEE 128-bit absolute value\n (define_insn_and_split \"ieee_128bit_vsx_abs<mode>2\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(abs:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n   \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (abs:TFIFKF (match_dup 1)))\n+\t\t   (abs:IEEE128 (match_dup 1)))\n \t      (use (match_dup 2))])]\n {\n   if (GET_CODE (operands[2]) == SCRATCH)\n@@ -6913,25 +6957,25 @@\n    (set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*ieee_128bit_vsx_abs<mode>2_internal\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(abs:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n   \"TARGET_FLOAT128\"\n   \"xxlandc %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n ;; IEEE 128-bit negative absolute value\n (define_insn_and_split \"*ieee_128bit_vsx_nabs<mode>2\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(neg:TFIFKF\n-\t (abs:TFIFKF\n-\t  (match_operand:TFIFKF 1 \"register_operand\" \"wa\"))))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(neg:IEEE128\n+\t (abs:IEEE128\n+\t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n   \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (abs:TFIFKF (match_dup 1)))\n+\t\t   (abs:IEEE128 (match_dup 1)))\n \t      (use (match_dup 2))])]\n {\n   if (GET_CODE (operands[2]) == SCRATCH)\n@@ -6944,70 +6988,78 @@\n    (set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*ieee_128bit_vsx_nabs<mode>2_internal\"\n-  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n-\t(neg:TFIFKF\n-\t (abs:TFIFKF\n-\t  (match_operand:TFIFKF 1 \"register_operand\" \"wa\"))))\n+  [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n+\t(neg:IEEE128\n+\t (abs:IEEE128\n+\t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n   \"TARGET_FLOAT128\"\n   \"xxlor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n ;; Float128 conversion functions.  These expand to library function calls.\n+;; We use expand to convert from IBM double double to IEEE 128-bit\n+;; and trunc for the opposite.\n+(define_expand \"extendiftf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:TF (match_operand:IF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n \n-(define_expand \"extend<FLOAT128_SFDFTF:mode><IFKF:mode>2\"\n-  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n-\t(float_extend:IFKF\n-\t (match_operand:FLOAT128_SFDFTF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"extendifkf2\"\n+  [(set (match_operand:KF 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:KF (match_operand:IF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2\"\n-  [(set (match_operand:FLOAT128_SFDFTF 0 \"nonimmediate_operand\" \"\")\n-\t(float_truncate:FLOAT128_SFDFTF\n-\t (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"extendtfkf2\"\n+  [(set (match_operand:KF 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:KF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"fix_trunc<IFKF:mode><SDI:mode>2\"\n-  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n-\t(fix:SDI (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"trunciftf2\"\n+  [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n+\t(float_truncate:IF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"fixuns_trunc<IFKF:mode><SDI:mode>2\"\n-  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n-\t(unsigned_fix:SDI (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"truncifkf2\"\n+  [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n+\t(float_truncate:IF (match_operand:KF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n-  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"float<SDI:mode><IFKF:mode>2\"\n-  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n-\t(float:KF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"trunckftf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(float_truncate:TF (match_operand:KF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n-(define_expand \"floatuns<SDI:mode><IFKF:mode>2\"\n-  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n-\t(unsigned_float:IFKF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"trunctfif2\"\n+  [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n+\t(float_truncate:IF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128\"\n {\n-  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n@@ -10524,20 +10576,20 @@\n    (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 4)))])\n \n ;; Only need to compare second words if first words equal\n-(define_insn \"*cmptf_internal1\"\n+(define_insn \"*cmp<mode>_internal1\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"d\")\n-\t\t      (match_operand:TF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"!TARGET_IEEEQUAD && !TARGET_XL_COMPAT\n+\t(compare:CCFP (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")\n+\t\t      (match_operand:IBM128 2 \"gpc_reg_operand\" \"d\")))]\n+  \"!TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"fcmpu %0,%1,%2\\;bne %0,$+8\\;fcmpu %0,%L1,%L2\"\n   [(set_attr \"type\" \"fpcompare\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn_and_split \"*cmptf_internal2\"\n+(define_insn_and_split \"*cmp<mode>_internal2\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"d\")\n-\t\t      (match_operand:TF 2 \"gpc_reg_operand\" \"d\")))\n+\t(compare:CCFP (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")\n+\t\t      (match_operand:IBM128 2 \"gpc_reg_operand\" \"d\")))\n     (clobber (match_scratch:DF 3 \"=d\"))\n     (clobber (match_scratch:DF 4 \"=d\"))\n     (clobber (match_scratch:DF 5 \"=d\"))\n@@ -10547,7 +10599,7 @@\n     (clobber (match_scratch:DF 9 \"=d\"))\n     (clobber (match_scratch:DF 10 \"=d\"))\n     (clobber (match_scratch:GPR 11 \"=b\"))]\n-  \"!TARGET_IEEEQUAD && TARGET_XL_COMPAT\n+  \"TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -10571,10 +10623,10 @@\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n \n-  operands[5] = simplify_gen_subreg (DFmode, operands[1], TFmode, hi_word);\n-  operands[6] = simplify_gen_subreg (DFmode, operands[1], TFmode, lo_word);\n-  operands[7] = simplify_gen_subreg (DFmode, operands[2], TFmode, hi_word);\n-  operands[8] = simplify_gen_subreg (DFmode, operands[2], TFmode, lo_word);\n+  operands[5] = simplify_gen_subreg (DFmode, operands[1], <MODE>mode, hi_word);\n+  operands[6] = simplify_gen_subreg (DFmode, operands[1], <MODE>mode, lo_word);\n+  operands[7] = simplify_gen_subreg (DFmode, operands[2], <MODE>mode, hi_word);\n+  operands[8] = simplify_gen_subreg (DFmode, operands[2], <MODE>mode, lo_word);\n   operands[12] = gen_label_rtx ();\n   operands[13] = gen_label_rtx ();\n   real_inf (&rv);"}, {"sha": "9f8785eb145aa0b5a1b170d452910d90fef7d709", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -929,6 +929,7 @@ examine and set these two fictitious variables with your debugger.\n @cindex additional floating types\n @cindex @code{__float80} data type\n @cindex @code{__float128} data type\n+@cindex @code{__ibm128} data type\n @cindex @code{w} floating point suffix\n @cindex @code{q} floating point suffix\n @cindex @code{W} floating point suffix\n@@ -941,19 +942,39 @@ Support for additional types includes the arithmetic operators:\n add, subtract, multiply, divide; unary arithmetic operators;\n relational operators; equality operators; and conversions to and from\n integer and other floating types.  Use a suffix @samp{w} or @samp{W}\n-in a literal constant of type @code{__float80} and @samp{q} or @samp{Q}\n-for @code{_float128}.  You can declare complex types using the\n-corresponding internal complex type, @code{XCmode} for @code{__float80}\n-type and @code{TCmode} for @code{__float128} type:\n+in a literal constant of type @code{__float80} or type\n+@code{__ibm128}.  Use a suffix @samp{q} or @samp{Q} for @code{_float128}.\n+\n+On the i386, x86_64, IA-64, and HP-UX targets, you can declare complex\n+types using the corresponding internal complex type, @code{XCmode} for\n+@code{__float80} type and @code{TCmode} for @code{__float128} type:\n \n @smallexample\n typedef _Complex float __attribute__((mode(TC))) _Complex128;\n typedef _Complex float __attribute__((mode(XC))) _Complex80;\n @end smallexample\n \n+On PowerPC Linux, Freebsd and Darwin systems, the default for\n+@code{long double} is to use the IBM extended floating point format\n+that uses a pair of @code{double} values to extend the precision.\n+This means that the mode @code{TCmode} was already used by the\n+traditional IBM long double format, and you would need to use the mode\n+@code{KCmode}:\n+\n+@smallexample\n+typedef _Complex float __attribute__((mode(KC))) _Complex128;\n+@end smallexample\n+\n Not all targets support additional floating-point types.  @code{__float80}\n and @code{__float128} types are supported on x86 and IA-64 targets.\n-The @code{__float128} type is supported on hppa HP-UX targets.\n+The @code{__float128} type is supported on hppa HP-UX.\n+The @code{__float128} type is supported on PowerPC systems by default\n+if the vector scalar instruction set (VSX) is enabled.\n+\n+On the PowerPC, @code{__ibm128} provides access to the IBM extended\n+double format, and it is intended to be used by the library functions\n+that handle conversions if/when long double is changed to be IEEE\n+128-bit floating point.\n \n @node Half-Precision\n @section Half-Precision Floating Point"}, {"sha": "70dc5d0b197419ec52ca75a2234ae11abfa13eed", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -946,7 +946,8 @@ See RS/6000 and PowerPC Options.\n -mquad-memory-atomic -mno-quad-memory-atomic @gol\n -mcompat-align-parm -mno-compat-align-parm @gol\n -mupper-regs-df -mno-upper-regs-df -mupper-regs-sf -mno-upper-regs-sf @gol\n--mupper-regs -mno-upper-regs}\n+-mupper-regs -mno-upper-regs @gol\n+-mfloat128 -mno-float128}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -19525,6 +19526,17 @@ floating point register set, depending on the model of the machine.\n If the @option{-mno-upper-regs} option is used, it turns off both\n @option{-mupper-regs-sf} and @option{-mupper-regs-df} options.\n \n+@item -mfloat128\n+@itemx -mno-float128\n+@opindex mfloat128\n+@opindex mno-float128\n+Enable/disable the @var{__float128} keyword for IEEE 128-bit floating point\n+and use software emulation for IEEE 128-bit floating point.\n+\n+The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7}, or\n+@option{-mcpu=power8}) must be enabled to use the @option{-mfloat128}\n+option.\n+\n @item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs\n @opindex mfloat-gprs"}, {"sha": "eea5a20f3351cb0c38ddfb4f607cae85f0ae76bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -1,3 +1,9 @@\n+2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-call.c: New test for -mfloat128 on\n+\tPowerPC.\n+\t* gcc.target/powerpc/float128-mix.c: Likewise.\n+\n 2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68054"}, {"sha": "382b2926e908b794dcabe2f0612e858aeb119ce0", "filename": "gcc/testsuite/gcc.target/powerpc/float128-call.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-O2 -mcpu=power7 -mfloat128 -mno-regnames\" } */\n+\n+#ifndef __FLOAT128__\n+#error \"-mfloat128 is not supported.\"\n+#endif\n+\n+#ifdef __LONG_DOUBLE_IEEE128__\n+#define TYPE long double\n+#define ONE  1.0L\n+\n+#else\n+#define TYPE __float128\n+#define ONE  1.0Q\n+#endif\n+\n+/* Test to make sure vector registers are used for passing IEEE 128-bit\n+   floating point values and returning them. Also make sure the 'q' suffix is\n+   handled.  */\n+TYPE one (void) { return ONE; }\n+void store (TYPE a, TYPE *p) { *p = a; }\n+\n+/* { dg-final { scan-assembler \"lxvd2x 34\"  } } */\n+/* { dg-final { scan-assembler \"stxvd2x 34\" } } */"}, {"sha": "466be9075247f6a385cbee3527c2cd443f9f37de", "filename": "gcc/testsuite/gcc.target/powerpc/float128-mix.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a49b3cf69348fbe1c8a2412849afe1163e614a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c?ref=40a49b3cf69348fbe1c8a2412849afe1163e614a", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n+\n+\n+/* Test to make sure that __float128 and __ibm128 cannot be combined together.  */\n+__float128 add (__float128 a, __ibm128 b)\n+{\n+  return a+b;\t/* { dg-error \"__float128 and __ibm128 cannot be used in the same expression\" \"\" } */\n+}\n+\n+__ibm128 sub (__ibm128 a, __float128 b)\n+{\n+  return a-b;\t/* { dg-error \"__float128 and __ibm128 cannot be used in the same expression\" \"\" } */\n+}"}]}