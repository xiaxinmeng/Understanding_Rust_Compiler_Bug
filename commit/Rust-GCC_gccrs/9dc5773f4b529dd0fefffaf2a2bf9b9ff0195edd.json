{"sha": "9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjNTc3M2Y0YjUyOWRkMGZlZmZmYWYyYTJiZjliOWZmMDE5NWVkZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-09-02T18:38:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-09-02T18:38:07Z"}, "message": "re PR c/65467 ([libgomp] sorry, unimplemented: '_Atomic' with OpenMP)\n\n\tPR c/65467\n\t* gimplify.c (gimplify_adjust_omp_clauses_1): Diagnose implicit\n\tmap and firstprivate clauses on target construct for _Atomic\n\tqualified decls.\n\t(gimplify_adjust_omp_clauses): Diagnose explicit firstprivate clauses\n\ton target construct for _Atomic qualified decls.\n\t* omp-low.c (use_pointer_for_field): Return true for _Atomic qualified\n\tdecls.\n\t* omp-simd-clone.c (simd_clone_clauses_extract): Warn and give up for\n\t_Atomic qualified arguments not mentioned in uniform clause.\nc/\n\t* c-parser.c (c_parser_declspecs): Don't sorry about _Atomic if\n\tflag_openmp.\n\t(c_parser_omp_variable_list): Use convert_lvalue_to_rvalue\n\tinstead of mark_exp_read on low_bound/length expression.\n\t(c_parser_omp_clause_num_gangs, c_parser_omp_clause_num_threads,\n\tc_parser_omp_clause_num_tasks, c_parser_omp_clause_grainsize,\n\tc_parser_omp_clause_priority, c_parser_omp_clause_hint,\n\tc_parser_omp_clause_num_workers, c_parser_oacc_shape_clause,\n\tc_parser_oacc_clause_tile, c_parser_omp_clause_schedule,\n\tc_parser_omp_clause_vector_length, c_parser_omp_clause_num_teams,\n\tc_parser_omp_clause_thread_limit, c_parser_omp_clause_aligned,\n\tc_parser_omp_clause_linear, c_parser_omp_clause_safelen,\n\tc_parser_omp_clause_simdlen, c_parser_omp_clause_device,\n\tc_parser_omp_clause_dist_schedule): Use convert_lvalue_to_rvalue\n\tinstead of mark_expr_read.\n\t(c_parser_omp_declare_reduction): Reject _Atomic qualified types.\n\t* c-objc-common.h (LANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP): Redefine.\n\t* c-tree.h (c_omp_clause_copy_ctor): New prototype.\n\t* c-typeck.c (handle_omp_array_sections_1): Diagnose _Atomic qualified\n\tarray section bases outside of depend clause, for depend clause\n\tuse convert_lvalue_to_rvalue on the base.\n\t(c_finish_omp_clauses): Reject _Atomic qualified vars in reduction,\n\tlinear, aligned, map, to and from clauses.\n\t(c_omp_clause_copy_ctor): New function.\nc-family/\n\t* c-omp.c (c_finish_omp_atomic): Reject _Atomic qualified expressions.\n\t(c_finish_omp_for): Reject _Atomic qualified iterators.\ntestsuite/\n\t* gcc.dg/gomp/_Atomic-1.c: New test.\n\t* gcc.dg/gomp/_Atomic-2.c: New test.\n\t* gcc.dg/gomp/_Atomic-3.c: New test.\n\t* gcc.dg/gomp/_Atomic-4.c: New test.\n\t* gcc.dg/gomp/_Atomic-5.c: New test.\n\nFrom-SVN: r239964", "tree": {"sha": "4e53b18a2fda99a485292dfd9bf30c8fbd9145b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e53b18a2fda99a485292dfd9bf30c8fbd9145b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/comments", "author": null, "committer": null, "parents": [{"sha": "c65236d682789b6a33510aaebfd7e83fe0f30d1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65236d682789b6a33510aaebfd7e83fe0f30d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65236d682789b6a33510aaebfd7e83fe0f30d1a"}], "stats": {"total": 729, "additions": 670, "deletions": 59}, "files": [{"sha": "b4710f9274f10d2852d93ab06f866be39ddd5cd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -1,3 +1,16 @@\n+2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/65467\n+\t* gimplify.c (gimplify_adjust_omp_clauses_1): Diagnose implicit\n+\tmap and firstprivate clauses on target construct for _Atomic\n+\tqualified decls.\n+\t(gimplify_adjust_omp_clauses): Diagnose explicit firstprivate clauses\n+\ton target construct for _Atomic qualified decls.\n+\t* omp-low.c (use_pointer_for_field): Return true for _Atomic qualified\n+\tdecls.\n+\t* omp-simd-clone.c (simd_clone_clauses_extract): Warn and give up for\n+\t_Atomic qualified arguments not mentioned in uniform clause.\n+\n 2016-09-02  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (OBJS-libcommon): Add edit-context.o."}, {"sha": "9dc1fdb55440d4cafa9376d3224393d1e358aaac", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -1,4 +1,10 @@\n-2016-09-01 Martin Sebor  <msebor@redhat.com>\n+2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/65467\n+\t* c-omp.c (c_finish_omp_atomic): Reject _Atomic qualified expressions.\n+\t(c_finish_omp_for): Reject _Atomic qualified iterators.\n+\n+2016-09-01  Martin Sebor  <msebor@redhat.com>\n \n \t* c-ada-spec.c (dump_ada_function_declaration): Increase buffer\n \tsize to guarantee it fits the output of the formatted function\n@@ -290,7 +296,7 @@\n \tPR c++/65970\n \t* c.opt (fconstexpr-loop-limit): New.\n \n-2016-07-22 Martin Sebor  <msebor@redhat.com>\n+2016-07-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/71675\n \t* c-common.c (resolve_overloaded_builtin): Avoid converting"}, {"sha": "3b131ed1843109a18d72e58432ae6bfa57df0ae2", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -199,6 +199,11 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       error_at (loc, \"invalid expression type for %<#pragma omp atomic%>\");\n       return error_mark_node;\n     }\n+  if (TYPE_ATOMIC (type))\n+    {\n+      error_at (loc, \"%<_Atomic%> expression in %<#pragma omp atomic%>\");\n+      return error_mark_node;\n+    }\n \n   if (opcode == RDIV_EXPR)\n     opcode = TRUNC_DIV_EXPR;\n@@ -480,6 +485,14 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t  error_at (elocus, \"invalid type for iteration variable %qE\", decl);\n \t  fail = true;\n \t}\n+      else if (TYPE_ATOMIC (TREE_TYPE (decl)))\n+\t{\n+\t  error_at (elocus, \"%<_Atomic%> iteration variable %qE\", decl);\n+\t  fail = true;\n+\t  /* _Atomic iterator confuses stuff too much, so we risk ICE\n+\t     trying to diagnose it further.  */\n+\t  continue;\n+\t}\n \n       /* In the case of \"for (int i = 0...)\", init will be a decl.  It should\n \t have a DECL_INITIAL that we can turn into an assignment.  */"}, {"sha": "d10dd6d0689b610d7ee0b36ad91d62472fed2f06", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -1,3 +1,32 @@\n+2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/65467\n+\t* c-parser.c (c_parser_declspecs): Don't sorry about _Atomic if\n+\tflag_openmp.\n+\t(c_parser_omp_variable_list): Use convert_lvalue_to_rvalue\n+\tinstead of mark_exp_read on low_bound/length expression.\n+\t(c_parser_omp_clause_num_gangs, c_parser_omp_clause_num_threads,\n+\tc_parser_omp_clause_num_tasks, c_parser_omp_clause_grainsize,\n+\tc_parser_omp_clause_priority, c_parser_omp_clause_hint,\n+\tc_parser_omp_clause_num_workers, c_parser_oacc_shape_clause,\n+\tc_parser_oacc_clause_tile, c_parser_omp_clause_schedule,\n+\tc_parser_omp_clause_vector_length, c_parser_omp_clause_num_teams,\n+\tc_parser_omp_clause_thread_limit, c_parser_omp_clause_aligned,\n+\tc_parser_omp_clause_linear, c_parser_omp_clause_safelen,\n+\tc_parser_omp_clause_simdlen, c_parser_omp_clause_device,\n+\tc_parser_omp_clause_dist_schedule): Use convert_lvalue_to_rvalue\n+\tinstead of mark_expr_read.\n+\t(c_parser_omp_declare_reduction): Reject _Atomic qualified types.\n+\t* c-objc-common.h (LANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n+\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP): Redefine.\n+\t* c-tree.h (c_omp_clause_copy_ctor): New prototype.\n+\t* c-typeck.c (handle_omp_array_sections_1): Diagnose _Atomic qualified\n+\tarray section bases outside of depend clause, for depend clause\n+\tuse convert_lvalue_to_rvalue on the base.\n+\t(c_finish_omp_clauses): Reject _Atomic qualified vars in reduction,\n+\tlinear, aligned, map, to and from clauses.\n+\t(c_omp_clause_copy_ctor): New function.\n+\n 2016-09-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/7652"}, {"sha": "14554ace114a916c66f5fadfd7a04df770d2ad98", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -100,6 +100,12 @@ along with GCC; see the file COPYING3.  If not see\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING c_omp_predetermined_sharing\n \n+#undef LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\n+#define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR c_omp_clause_copy_ctor\n+\n+#undef LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\n+#define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP c_omp_clause_copy_ctor\n+\n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_vla_unspec_p\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "0aba51c9cde994d72baa0908b6385476fc4ee07f", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 79, "deletions": 46, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -2600,10 +2600,6 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t     and objc_types_are_equivalent may also need updates.  */\n \t  if (c_dialect_objc ())\n \t    sorry (\"%<_Atomic%> in Objective-C\");\n-\t  /* C parser handling of OpenMP constructs needs checking for\n-\t     correct lvalue-to-rvalue conversions.  */\n-\t  if (flag_openmp)\n-\t    sorry (\"%<_Atomic%> with OpenMP\");\n \t  if (flag_isoc99)\n \t    pedwarn_c99 (loc, OPT_Wpedantic,\n \t\t\t \"ISO C99 does not support the %<_Atomic%> qualifier\");\n@@ -10718,8 +10714,12 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t  c_parser_consume_token (parser);\n \t\t  if (!c_parser_next_token_is (parser, CPP_COLON))\n \t\t    {\n-\t\t      low_bound = c_parser_expression (parser).value;\n-\t\t      mark_exp_read (low_bound);\n+\t\t      location_t expr_loc\n+\t\t\t= c_parser_peek_token (parser)->location;\n+\t\t      c_expr expr = c_parser_expression (parser);\n+\t\t      expr = convert_lvalue_to_rvalue (expr_loc, expr,\n+\t\t\t\t\t\t       false, true);\n+\t\t      low_bound = expr.value;\n \t\t    }\n \t\t  if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t    length = integer_one_node;\n@@ -10734,8 +10734,12 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t\t}\n \t\t      if (!c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t\t{\n-\t\t\t  length = c_parser_expression (parser).value;\n-\t\t\t  mark_exp_read (length);\n+\t\t\t  location_t expr_loc\n+\t\t\t    = c_parser_peek_token (parser)->location;\n+\t\t\t  c_expr expr = c_parser_expression (parser);\n+\t\t\t  expr = convert_lvalue_to_rvalue (expr_loc, expr,\n+\t\t\t\t\t\t\t   false, true);\n+\t\t\t  length = expr.value;\n \t\t\t}\n \t\t    }\n \t\t  /* Look for the closing `]'.  */\n@@ -11257,8 +11261,9 @@ c_parser_omp_clause_num_gangs (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11301,8 +11306,9 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11345,8 +11351,9 @@ c_parser_omp_clause_num_tasks (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11389,8 +11396,9 @@ c_parser_omp_clause_grainsize (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11433,8 +11441,9 @@ c_parser_omp_clause_priority (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11477,8 +11486,10 @@ c_parser_omp_clause_hint (c_parser *parser, tree list)\n   location_t hint_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11581,8 +11592,9 @@ c_parser_omp_clause_num_workers (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -11703,11 +11715,12 @@ c_parser_oacc_shape_clause (c_parser *parser, omp_clause_code kind,\n \t    }\n \n \t  location_t expr_loc = c_parser_peek_token (parser)->location;\n-\t  tree expr = c_parser_expr_no_commas (parser, NULL).value;\n+\t  c_expr cexpr = c_parser_expr_no_commas (parser, NULL);\n+\t  cexpr = convert_lvalue_to_rvalue (expr_loc, cexpr, false, true);\n+\t  tree expr = cexpr.value;\n \t  if (expr == error_mark_node)\n \t    goto cleanup_error;\n \n-\t  mark_exp_read (expr);\n \t  expr = c_fully_fold (expr, false, NULL);\n \n \t  /* Attempt to statically determine when the number isn't a\n@@ -11842,7 +11855,9 @@ c_parser_oacc_clause_tile (c_parser *parser, tree list)\n       else\n \t{\n \t  expr_loc = c_parser_peek_token (parser)->location;\n-\t  expr = c_parser_expr_no_commas (parser, NULL).value;\n+\t  c_expr cexpr = c_parser_expr_no_commas (parser, NULL);\n+\t  cexpr = convert_lvalue_to_rvalue (expr_loc, cexpr, false, true);\n+\t  expr = cexpr.value;\n \n \t  if (expr == error_mark_node)\n \t    {\n@@ -11857,7 +11872,6 @@ c_parser_oacc_clause_tile (c_parser *parser, tree list)\n \t      return list;\n \t    }\n \n-\t  mark_exp_read (expr);\n \t  expr = c_fully_fold (expr, false, NULL);\n \n \t  /* Attempt to statically determine when expr isn't positive.  */\n@@ -12180,8 +12194,9 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n       c_parser_consume_token (parser);\n \n       here = c_parser_peek_token (parser)->location;\n-      t = c_parser_expr_no_commas (parser, NULL).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (here, expr, false, true);\n+      t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n@@ -12266,8 +12281,9 @@ c_parser_omp_clause_vector_length (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -12369,8 +12385,9 @@ c_parser_omp_clause_num_teams (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -12412,8 +12429,9 @@ c_parser_omp_clause_thread_limit (c_parser *parser, tree list)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      tree c, t = c_parser_expression (parser).value;\n-      mark_exp_read (t);\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -12465,8 +12483,10 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n       c_parser_consume_token (parser);\n-      tree alignment = c_parser_expr_no_commas (parser, NULL).value;\n-      mark_exp_read (alignment);\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree alignment = expr.value;\n       alignment = c_fully_fold (alignment, false, NULL);\n       if (TREE_CODE (alignment) != INTEGER_CST\n \t  || !INTEGRAL_TYPE_P (TREE_TYPE (alignment))\n@@ -12528,8 +12548,10 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n       c_parser_consume_token (parser);\n-      step = c_parser_expression (parser).value;\n-      mark_exp_read (step);\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expression (parser);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      step = expr.value;\n       step = c_fully_fold (step, false, NULL);\n       if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n \t{\n@@ -12569,8 +12591,10 @@ c_parser_omp_clause_safelen (c_parser *parser, tree list)\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n-  t = c_parser_expr_no_commas (parser, NULL).value;\n-  mark_exp_read (t);\n+  location_t expr_loc = c_parser_peek_token (parser)->location;\n+  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+  t = expr.value;\n   t = c_fully_fold (t, false, NULL);\n   if (TREE_CODE (t) != INTEGER_CST\n       || !INTEGRAL_TYPE_P (TREE_TYPE (t))\n@@ -12605,8 +12629,10 @@ c_parser_omp_clause_simdlen (c_parser *parser, tree list)\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n-  t = c_parser_expr_no_commas (parser, NULL).value;\n-  mark_exp_read (t);\n+  location_t expr_loc = c_parser_peek_token (parser)->location;\n+  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+  t = expr.value;\n   t = c_fully_fold (t, false, NULL);\n   if (TREE_CODE (t) != INTEGER_CST\n       || !INTEGRAL_TYPE_P (TREE_TYPE (t))\n@@ -12921,8 +12947,10 @@ c_parser_omp_clause_device (c_parser *parser, tree list)\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      tree c, t = c_parser_expr_no_commas (parser, NULL).value;\n-      mark_exp_read (t);\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -12970,8 +12998,10 @@ c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)\n     {\n       c_parser_consume_token (parser);\n \n-      t = c_parser_expr_no_commas (parser, NULL).value;\n-      mark_exp_read (t);\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n@@ -16876,6 +16906,9 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n \t\t   || TREE_CODE (type) == ARRAY_TYPE)\n \t    error_at (loc, \"function or array type in \"\n \t\t      \"%<#pragma omp declare reduction%>\");\n+\t  else if (TYPE_ATOMIC (type))\n+\t    error_at (loc, \"%<_Atomic%> qualified type in \"\n+\t\t\t   \"%<#pragma omp declare reduction%>\");\n \t  else if (TYPE_QUALS_NO_ADDR_SPACE (type))\n \t    error_at (loc, \"const, volatile or restrict qualified type in \"\n \t\t\t   \"%<#pragma omp declare reduction%>\");"}, {"sha": "e8060f8b1977afde270cb90bf829d814af59139a", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -682,6 +682,7 @@ extern tree c_finish_transaction (location_t, tree, int);\n extern bool c_tree_equal (tree, tree);\n extern tree c_build_function_call_vec (location_t, vec<location_t>, tree,\n \t\t\t\t       vec<tree, va_gc> *, vec<tree, va_gc> *);\n+extern tree c_omp_clause_copy_ctor (tree, tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "d56c3d6b2643f3a2a755210357a2c6ffbeb7c179", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -12072,6 +12072,13 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       if (error_operand_p (t))\n \treturn error_mark_node;\n       ret = t;\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  && TYPE_ATOMIC (strip_array_types (TREE_TYPE (t))))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c), \"%<_Atomic%> %qE in %qs clause\",\n+\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n       if (TREE_CODE (t) == COMPONENT_REF\n \t  && ort == C_ORT_OMP\n \t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n@@ -12109,13 +12116,35 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  return error_mark_node;\n \t}\n       else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t       && VAR_P (t) && DECL_THREAD_LOCAL_P (t))\n+\t       && TYPE_ATOMIC (TREE_TYPE (t)))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c), \"%<_Atomic%> %qD in %qs clause\",\n+\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t       && VAR_P (t)\n+\t       && DECL_THREAD_LOCAL_P (t))\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t    \"%qD is threadprivate variable in %qs clause\", t,\n \t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t  && TYPE_ATOMIC (TREE_TYPE (t))\n+\t  && POINTER_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  /* If the array section is pointer based and the pointer\n+\t     itself is _Atomic qualified, we need to atomically load\n+\t     the pointer.  */\n+\t  c_expr expr;\n+\t  memset (&expr, 0, sizeof (expr));\n+\t  expr.value = ret;\n+\t  expr = convert_lvalue_to_rvalue (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t   expr, false, false);\n+\t  ret = expr.value;\n+\t}\n       return ret;\n     }\n \n@@ -12675,7 +12704,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  oacc_async = true;\n \t  break;\n \t}\n-\t  \n+\n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n       bool remove = false;\n@@ -12750,6 +12779,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      t = build2 (MEM_REF, atype, t, build_int_cst (ptype, 0));\n \t      OMP_CLAUSE_DECL (c) = t;\n \t    }\n+\t  if (TYPE_ATOMIC (type))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<_Atomic%> %qE in %<reduction%> clause\", t);\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE\n \t      && (FLOAT_TYPE_P (type)\n \t\t  || TREE_CODE (type) == COMPLEX_TYPE))\n@@ -12964,6 +13000,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t  break;\n \t\t}\n+\t      if (TYPE_ATOMIC (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<_Atomic%> %qD in %<linear%> clause\", t);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  if (ort == C_ORT_OMP_DECLARE_SIMD)\n \t    {\n@@ -13112,6 +13155,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"an array\", t);\n \t      remove = true;\n \t    }\n+\t  else if (TYPE_ATOMIC (TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<_Atomic%> %qD in %<aligned%> clause\", t);\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n@@ -13197,6 +13247,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t      remove = true;\n \t\t    }\n+\t\t  else if (TYPE_ATOMIC (TREE_TYPE (t)))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%<_Atomic%> %qE in %qs clause\", t,\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      remove = true;\n+\t\t    }\n \t\t  while (TREE_CODE (t) == ARRAY_REF)\n \t\t    t = TREE_OPERAND (t, 0);\n \t\t  if (TREE_CODE (t) == COMPONENT_REF\n@@ -13251,6 +13308,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t  remove = true;\n \t\t}\n+\t      else if (TYPE_ATOMIC (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<_Atomic%> %qE in %qs clause\", t,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t}\n \t      while (TREE_CODE (t) == COMPONENT_REF)\n \t\t{\n \t\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n@@ -13304,6 +13368,15 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n+\t  else if (TREE_TYPE (t) == error_mark_node)\n+\t    remove = true;\n+\t  else if (TYPE_ATOMIC (strip_array_types (TREE_TYPE (t))))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<_Atomic%> %qE in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t    {\n@@ -13644,6 +13717,50 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   return clauses;\n }\n \n+/* Return code to initialize DST with a copy constructor from SRC.\n+   C doesn't have copy constructors nor assignment operators, only for\n+   _Atomic vars we need to perform __atomic_load from src into a temporary\n+   followed by __atomic_store of the temporary to dst.  */\n+\n+tree\n+c_omp_clause_copy_ctor (tree clause, tree dst, tree src)\n+{\n+  if (!really_atomic_lvalue (dst) && !really_atomic_lvalue (src))\n+    return build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n+\n+  location_t loc = OMP_CLAUSE_LOCATION (clause);\n+  tree type = TREE_TYPE (dst);\n+  tree nonatomic_type = build_qualified_type (type, TYPE_UNQUALIFIED);\n+  tree tmp = create_tmp_var (nonatomic_type);\n+  tree tmp_addr = build_fold_addr_expr (tmp);\n+  TREE_ADDRESSABLE (tmp) = 1;\n+  TREE_NO_WARNING (tmp) = 1;\n+  tree src_addr = build_fold_addr_expr (src);\n+  tree dst_addr = build_fold_addr_expr (dst);\n+  tree seq_cst = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+  vec<tree, va_gc> *params;\n+  /* Expansion of a generic atomic load may require an addition\n+     element, so allocate enough to prevent a resize.  */\n+  vec_alloc (params, 4);\n+\n+  /* Build __atomic_load (&src, &tmp, SEQ_CST);  */\n+  tree fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_LOAD);\n+  params->quick_push (src_addr);\n+  params->quick_push (tmp_addr);\n+  params->quick_push (seq_cst);\n+  tree load = c_build_function_call_vec (loc, vNULL, fndecl, params, NULL);\n+\n+  vec_alloc (params, 4);\n+\n+  /* Build __atomic_store (&dst, &tmp, SEQ_CST);  */\n+  fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_STORE);\n+  params->quick_push (dst_addr);\n+  params->quick_push (tmp_addr);\n+  params->quick_push (seq_cst);\n+  tree store = c_build_function_call_vec (loc, vNULL, fndecl, params, NULL);\n+  return build2 (COMPOUND_EXPR, void_type_node, load, store);\n+}\n+\n /* Create a transaction node.  */\n \n tree"}, {"sha": "2f0dd88ebd67848f2859376c3f94707f034a92bc", "filename": "gcc/gimplify.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -7911,7 +7911,15 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n   if (private_debug)\n     code = OMP_CLAUSE_PRIVATE;\n   else if (flags & GOVD_MAP)\n-    code = OMP_CLAUSE_MAP;\n+    {\n+      code = OMP_CLAUSE_MAP;\n+      if ((gimplify_omp_ctxp->region_type & ORT_ACC) == 0\n+\t  && TYPE_ATOMIC (strip_array_types (TREE_TYPE (decl))))\n+\t{\n+\t  error (\"%<_Atomic%> %qD in implicit %<map%> clause\", decl);\n+\t  return 0;\n+\t}\n+    }\n   else if (flags & GOVD_SHARED)\n     {\n       if (is_global_var (decl))\n@@ -7935,7 +7943,17 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n   else if (flags & GOVD_PRIVATE)\n     code = OMP_CLAUSE_PRIVATE;\n   else if (flags & GOVD_FIRSTPRIVATE)\n-    code = OMP_CLAUSE_FIRSTPRIVATE;\n+    {\n+      code = OMP_CLAUSE_FIRSTPRIVATE;\n+      if ((gimplify_omp_ctxp->region_type & ORT_TARGET)\n+\t  && (gimplify_omp_ctxp->region_type & ORT_ACC) == 0\n+\t  && TYPE_ATOMIC (strip_array_types (TREE_TYPE (decl))))\n+\t{\n+\t  error (\"%<_Atomic%> %qD in implicit %<firstprivate%> clause on \"\n+\t\t \"%<target%> construct\", decl);\n+\t  return 0;\n+\t}\n+    }\n   else if (flags & GOVD_LASTPRIVATE)\n     code = OMP_CLAUSE_LASTPRIVATE;\n   else if (flags & GOVD_ALIGNED)\n@@ -8090,9 +8108,21 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \n       switch (OMP_CLAUSE_CODE (c))\n \t{\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  if ((ctx->region_type & ORT_TARGET)\n+\t      && (ctx->region_type & ORT_ACC) == 0\n+\t      && TYPE_ATOMIC (strip_array_types\n+\t\t\t\t\t(TREE_TYPE (OMP_CLAUSE_DECL (c)))))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<_Atomic%> %qD in %<firstprivate%> clause on \"\n+\t\t\t\"%<target%> construct\", OMP_CLAUSE_DECL (c));\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n-\tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);"}, {"sha": "7c11b5043519b325df7cc3afcf7c2f4cad6f6711", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -1120,7 +1120,8 @@ maybe_lookup_field (tree var, omp_context *ctx)\n static bool\n use_pointer_for_field (tree decl, omp_context *shared_ctx)\n {\n-  if (AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (decl))\n+      || TYPE_ATOMIC (TREE_TYPE (decl)))\n     return true;\n \n   /* We can only use copy-in/copy-out semantics for shared variables"}, {"sha": "c418440c55079f1352afbc03cb6a2abe46b3ef7d", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -126,13 +126,11 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n   clone_info->cilk_elemental = cilk_clone;\n \n   if (!clauses)\n-    {\n-      args.release ();\n-      return clone_info;\n-    }\n+    goto out;\n+\n   clauses = TREE_VALUE (clauses);\n   if (!clauses || TREE_CODE (clauses) != OMP_CLAUSE)\n-    return clone_info;\n+    goto out;\n \n   for (t = clauses; t; t = OMP_CLAUSE_CHAIN (t))\n     {\n@@ -252,6 +250,28 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n \t  break;\n \t}\n     }\n+\n+ out:\n+  if (TYPE_ATOMIC (TREE_TYPE (TREE_TYPE (node->decl))))\n+    {\n+      warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t  \"ignoring %<#pragma omp declare simd%> on function \"\n+\t\t  \"with %<_Atomic%> qualified return type\");\n+      args.release ();\n+      return NULL;\n+    }\n+\n+  for (unsigned int argno = 0; argno < clone_info->nargs; argno++)\n+    if (TYPE_ATOMIC (args[argno])\n+\t&& clone_info->args[argno].arg_type != SIMD_CLONE_ARG_TYPE_UNIFORM)\n+      {\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"ignoring %<#pragma omp declare simd%> on function \"\n+\t\t    \"with %<_Atomic%> qualified non-%<uniform%> argument\");\n+\targs.release ();\n+\treturn NULL;\n+      }\n+\n   args.release ();\n   return clone_info;\n }"}, {"sha": "434b3db5ac33c97696d4f2f485fa76fb50e0e490", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -1,5 +1,12 @@\n 2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c/65467\n+\t* gcc.dg/gomp/_Atomic-1.c: New test.\n+\t* gcc.dg/gomp/_Atomic-2.c: New test.\n+\t* gcc.dg/gomp/_Atomic-3.c: New test.\n+\t* gcc.dg/gomp/_Atomic-4.c: New test.\n+\t* gcc.dg/gomp/_Atomic-5.c: New test.\n+\n \tPR sanitizer/77396\n \t* g++.dg/asan/pr77396.C: New test.\n "}, {"sha": "1f784524f67f2c58314f5a2ce9422d503de86459", "filename": "gcc/testsuite/gcc.dg/gomp/_Atomic-1.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-1.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -0,0 +1,103 @@\n+/* PR c/65467 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c11\" } */\n+\n+_Atomic int t;\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (void)\n+{\n+  _Atomic int a = 4, b = 0, c, d = 3, e;\n+  a++;\n+  #pragma omp parallel sections num_threads (a) shared (b) private (c) firstprivate (d) lastprivate (e)\n+  {\n+  #pragma omp section\n+    {\n+      a++;\n+      b++;\n+      c = 5;\n+      c++;\n+      d++;\n+      e = 9;\n+      e++;\n+    }\n+  #pragma omp section\n+    {\n+      a++;\n+      b++;\n+      c = 5;\n+      c++;\n+      d++;\n+      e = 3;\n+      e++;\n+    }\n+  }\n+  e++;\n+  t++;\n+  #pragma omp parallel copyin (t) private (e)\n+  {\n+    t++;\n+    e = t;\n+    #pragma omp single copyprivate (e)\n+    {\n+      e++;\n+    }\n+    e++;\n+  }\n+}\n+\n+void\n+bar (void)\n+{\n+  int a[4];\n+  _Atomic int b = 1, c = 2, f = 8, g = 8, h = 0;\n+  _Atomic int d, e[3];\n+  int *_Atomic p;\n+  _Atomic int *_Atomic q;\n+  int i, j;\n+  p = a;\n+  q = e;\n+  #pragma omp target teams map (tofrom: a[b:c]) num_teams (b) thread_limit (c)\n+  a[1]++;\n+  #pragma omp target device(h)\n+  ;\n+  #pragma omp task depend (inout: a[b:c])\n+  ;\n+  #pragma omp task depend (out: d, e[b:c]) priority (b)\n+  ;\n+  #pragma omp task depend (out: p[b:c])\n+  ;\n+  #pragma omp task depend (out: q[b:c])\n+  ;\n+  #pragma omp taskloop num_tasks (c)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop grainsize (c)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp parallel for schedule (dynamic, b)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  j = 0;\n+  #pragma omp simd linear(j:b)\n+  for (i = 0; i < 16; i++)\n+    j += b;\n+  j = 4;\n+  #pragma omp atomic read\n+  b = j;\n+  #pragma omp atomic write\n+  j = c;\n+  #pragma omp atomic\n+  j += c;\n+  #pragma omp atomic capture\n+  b = j += c;\n+  #pragma omp atomic capture\n+  b = ++j;\n+  #pragma omp atomic capture\n+  { b = j; j = c; }\n+  #pragma omp atomic capture\n+  { b = j; j++; }\n+  #pragma omp atomic capture\n+  { j *= c; b = j; }\n+}"}, {"sha": "159a5b3ee7d4a83a815f7ec6359b5cbb2a2ba4c0", "filename": "gcc/testsuite/gcc.dg/gomp/_Atomic-2.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-2.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -0,0 +1,76 @@\n+/* PR c/65467 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c11\" } */\n+\n+void\n+f1 (void)\n+{\n+  _Atomic int i;\n+  #pragma omp for\t\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp parallel for\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp simd\t\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp parallel for simd\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for simd\t\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for\t\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp parallel for\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp simd\t\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp parallel for simd\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp for simd\t\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+}\n+\n+void\n+f2 (void)\n+{\n+  _Atomic int i;\n+  #pragma omp distribute\t\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute parallel for\t/* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute parallel for simd /* { dg-error \"'_Atomic' iteration variable 'i'\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute\t\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp distribute parallel for\t/* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp distribute parallel for simd /* { dg-error \"'_Atomic' iteration variable 'j'\" } */\n+  for (_Atomic int j = 0; j < 64; j++)\n+    ;\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i;\n+  _Atomic int j = 0;\n+  #pragma omp simd linear(j:2)\t\t/* { dg-error \"'_Atomic' 'j' in 'linear' clause\" } */\n+  for (i = 0; i < 64; i++)\n+    j += 2;\n+  #pragma omp parallel for linear(j:1)\t/* { dg-error \"'_Atomic' 'j' in 'linear' clause\" } */\n+  for (i = 0; i < 64; i++)\n+    j++;\n+}"}, {"sha": "31dd1cb1122cadabd8bc825f5444e7567b7a5a5e", "filename": "gcc/testsuite/gcc.dg/gomp/_Atomic-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-3.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -0,0 +1,65 @@\n+/* PR c/65467 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c11\" } */\n+\n+void\n+f1 (void)\n+{\n+  _Atomic int i = 0, k[4];\n+  int j = 0;\n+  k[0] = 0;\n+  k[1] = 0;\n+  k[2] = 0;\n+  k[3] = 0;\n+  #pragma omp parallel reduction (+:i)\t\t/* { dg-error \"'_Atomic' 'i' in 'reduction' clause\" } */\n+    i++;\n+  #pragma omp declare reduction (foo: _Atomic int: omp_out += omp_in) initializer (omp_priv = omp_orig * 0)\t/* { dg-error \"'_Atomic' qualified type in '#pragma omp declare reduction'\" } */\n+  #pragma omp declare reduction (bar: int: omp_out += omp_in) initializer (omp_priv = omp_orig * 0)\n+  #pragma omp parallel reduction (bar:j)\n+    j++;\n+  #pragma omp parallel reduction (bar:i)\t/* { dg-error \"'_Atomic' 'i' in 'reduction' clause\" } */\n+    i++;\n+  #pragma omp parallel reduction (+:k)\t\t/* { dg-error \"'_Atomic' 'k' in 'reduction' clause\" } */\n+    k[1]++;\n+  #pragma omp parallel reduction (+:k[1:2])\t/* { dg-error \"'_Atomic' \\[^\\n\\r]* in 'reduction' clause\" } */\n+    k[1]++;\n+}\n+\n+void\n+f2 (int *_Atomic p)\n+{\n+  #pragma omp simd aligned (p : 16)\t\t/* { dg-error \"'_Atomic' 'p' in 'aligned' clause\" } */\n+  for (int i = 0; i < 16; i++)\n+    p[i]++;\n+}\n+\n+_Atomic int x;\n+\n+void\n+f3 (_Atomic int *p)\n+{\n+  int i;\n+  #pragma omp atomic write\n+  x = 6;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic read\n+  i = x;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic update\n+  x += 6;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic capture\n+  i = x *= 2;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic write\n+  p[2] = 6;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic read\n+  i = p[2];\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic update\n+  p[2] += 6;\t\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+  #pragma omp atomic capture\n+  i = p[2] *= 2;\t\t\t\t/* { dg-error \"'_Atomic' expression in '#pragma omp atomic'\" } */\n+}\n+\n+#pragma omp declare simd linear(x:1)\t\t/* { dg-error \"'_Atomic' 'x' in 'linear' clause\" } */\n+int\n+f4 (_Atomic int x, int y)\n+{\n+  return x + y;\n+}"}, {"sha": "c5be3c3ea9b164d7c93db0e7b7ee393b1c154987", "filename": "gcc/testsuite/gcc.dg/gomp/_Atomic-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-4.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -0,0 +1,17 @@\n+/* PR c/65467 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c11\" } */\n+\n+#pragma omp declare simd\n+int\n+f1 (_Atomic int x, int y)\t/* { dg-warning \"ignoring '#pragma omp declare simd' on function with '_Atomic' qualified non-'uniform' argument\" } */\n+{\n+  return x + y;\n+}\n+\n+#pragma omp declare simd uniform(x)\n+int\n+f2 (_Atomic int x, int y)\n+{\n+  return x + y;\n+}"}, {"sha": "9b7f58f032928d83fb5515f32dc34683e970cdcf", "filename": "gcc/testsuite/gcc.dg/gomp/_Atomic-5.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2F_Atomic-5.c?ref=9dc5773f4b529dd0fefffaf2a2bf9b9ff0195edd", "patch": "@@ -0,0 +1,74 @@\n+/* PR c/65467 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c11\" } */\n+\n+void\n+f1 (void)\n+{\n+  struct S { int a; int b[2]; _Atomic int *c; };\n+  _Atomic int a = 0, b[2];\n+  _Atomic int d[3];\n+  _Atomic struct S c = (struct S) { 3, { 4, 5 }, d };\n+  int *_Atomic p;\n+  _Atomic int *q;\n+  int e[3] = { 1, 2, 3 };\n+  b[0] = 1;\n+  b[1] = 2;\n+  d[0] = 6;\n+  d[1] = 7;\n+  d[2] = 8;\n+  p = e;\n+  #pragma omp target map(tofrom: a)\t\t/* { dg-error \"'_Atomic' 'a' in 'map' clause\" } */\n+  ;\n+  #pragma omp target map(to: b)\t\t\t/* { dg-error \"'_Atomic' 'b' in 'map' clause\" } */\n+  ;\n+  #pragma omp target map(from: b[1:1])\t\t/* { dg-error \"'_Atomic' 'b' in 'map' clause\" } */\n+  ;\n+  #pragma omp target map(to: c.a)\t\t/* { dg-error \"'_Atomic' 'c.a' in 'map' clause\" } */\n+  /* { dg-warning \"accessing a member 'a' of an atomic structure 'c'\" \"\" { target *-*-* } 27 } */\n+  ;\n+  #pragma omp target map(to: c.b[1])\t\t/* { dg-error \"'_Atomic' 'c.b' in 'map' clause\" } */\n+  /* { dg-warning \"accessing a member 'b' of an atomic structure 'c'\" \"\" { target *-*-* } 30 } */\n+  ;\n+  #pragma omp target data map(c)\t\t/* { dg-error \"'_Atomic' 'c' in 'map' clause\" } */\n+  /* { dg-error \"must contain at least one\" \"\" { target *-*-* } 33 } */\n+  {\n+    #pragma omp target update to (c.a)\t\t/* { dg-error \"'_Atomic' 'c.a' in 'to' clause\" } */\n+    /* { dg-error \"must contain at least one\" \"\" { target *-*-* } 36 } */\n+    /* { dg-warning \"accessing a member 'a' of an atomic structure 'c'\" \"\" { target *-*-* } 36 } */\n+    #pragma omp target update from (c.b[1])\t/* { dg-error \"'_Atomic' 'c.b' in 'from' clause\" } */\n+    /* { dg-error \"must contain at least one\" \"\" { target *-*-* } 39 } */\n+    /* { dg-warning \"accessing a member 'b' of an atomic structure 'c'\" \"\" { target *-*-* } 39 } */\n+    #pragma omp target update to (c)\t\t/* { dg-error \"'_Atomic' 'c' in 'to' clause\" } */\n+    /* { dg-error \"must contain at least one\" \"\" { target *-*-* } 42 } */\n+  }\n+  #pragma omp target map(to: c.c[0:])\t\t/* { dg-error \"'_Atomic' 'c.c' in 'map' clause\" } */\n+  /* { dg-warning \"accessing a member 'c' of an atomic structure 'c'\" \"\" { target *-*-* } 45 } */\n+  ;\n+  #pragma omp target map(to: p[1:2])\t\t/* { dg-error \"'_Atomic' 'p' in 'map' clause\" } */\n+  ;\n+  #pragma omp target map(to: q[1:2])\t\t/* { dg-error \"'_Atomic' '\\[^\\n\\r]*' in 'map' clause\" } */\n+  ;\n+}\n+\n+void\n+f2 (void)\n+{\n+  _Atomic int a = 0, b[2] = { 1, 2 };\n+  #pragma omp target defaultmap(tofrom:scalar)\t/* { dg-error \"'_Atomic' 'a' in implicit 'map' clause\" } */\n+  a++;\n+  #pragma omp target\t\t\t\t/* { dg-error \"'_Atomic' 'b' in implicit 'map' clause\" } */\n+  b[0]++;\n+}\n+\n+void\n+f3 (void)\n+{\n+  _Atomic int a = 0, b[2] = { 1, 2 };\n+  #pragma omp target\t\t\t\t/* { dg-error \"'_Atomic' 'a' in implicit 'firstprivate' clause on 'target' construct\" } */\n+  a++;\n+  #pragma omp target firstprivate (a)\t\t/* { dg-error \"'_Atomic' 'a' in 'firstprivate' clause on 'target' construct\" } */\n+  a++;\n+  #pragma omp target firstprivate (b)\t\t/* { dg-error \"'_Atomic' 'b' in 'firstprivate' clause on 'target' construct\" } */\n+  b[0]++;\n+}"}]}