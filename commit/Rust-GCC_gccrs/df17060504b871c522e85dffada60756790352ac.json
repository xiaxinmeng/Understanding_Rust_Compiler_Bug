{"sha": "df17060504b871c522e85dffada60756790352ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxNzA2MDUwNGI4NzFjNTIyZTg1ZGZmYWRhNjA3NTY3OTAzNTJhYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T08:59:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T08:59:28Z"}, "message": "[multiple changes]\n\n2011-08-29  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Allocator): Analyze the subpool specification.\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): If the entity is tagged\n\tand a separate tag assignment is generated, ensure that the tag\n\tassignment is analyzed.\n\nFrom-SVN: r178170", "tree": {"sha": "6166ba6a7882b070e55a92b01f34368ac7b487d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6166ba6a7882b070e55a92b01f34368ac7b487d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df17060504b871c522e85dffada60756790352ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df17060504b871c522e85dffada60756790352ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df17060504b871c522e85dffada60756790352ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df17060504b871c522e85dffada60756790352ac/comments", "author": null, "committer": null, "parents": [{"sha": "864a4236aa8d090625b2a5442f1b41fa06ddb106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/864a4236aa8d090625b2a5442f1b41fa06ddb106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/864a4236aa8d090625b2a5442f1b41fa06ddb106"}], "stats": {"total": 99, "additions": 63, "deletions": 36}, "files": [{"sha": "a2b1d7d56919aeabe8cbde0b19ef2a56fb4e4ea2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=df17060504b871c522e85dffada60756790352ac", "patch": "@@ -1,11 +1,22 @@\n+2011-08-29  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Allocator): Analyze the subpool specification.\n+\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): If the entity is tagged\n+\tand a separate tag assignment is generated, ensure that the tag\n+\tassignment is analyzed.\n+\n 2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* atree.ads, atree.adb (Copy_Separate_List): New function that applies\n \tCopy_Separate_Tree to a list of nodes. Used to create disjoint copies\n \tof statement lists that may contain local declarations.\n-\t(Expand_N_Timed_Entry_Call): Use Copy_Separate_List to duplicate the\n-\ttriggering statements needed for the expansion of this construct, when\n-\tthe trigger is a dispatching call to a synchronized primitive.\n+\t* exp_ch9.adb (Expand_N_Timed_Entry_Call): Use Copy_Separate_List to\n+\tduplicate the triggering statements needed for the expansion of this\n+\tconstruct, when the trigger is a dispatching call to a synchronized\n+\tprimitive.\n \n 2011-08-29  Arnaud Charlet  <charlet@adacore.com>\n "}, {"sha": "dfff997b133415e94b8e55fd692b68d254afb04e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=df17060504b871c522e85dffada60756790352ac", "patch": "@@ -5108,25 +5108,24 @@ package body Exp_Ch3 is\n \n                begin\n                   --  The re-assignment of the tag has to be done even if the\n-                  --  object is a constant.\n+                  --  object is a constant. The assignment must be analyzed\n+                  --  after the declaration.\n \n                   New_Ref :=\n                     Make_Selected_Component (Loc,\n-                       Prefix => New_Reference_To (Def_Id, Loc),\n+                       Prefix => New_Occurrence_Of (Def_Id, Loc),\n                        Selector_Name =>\n                          New_Reference_To (First_Tag_Component (Full_Typ),\n                                            Loc));\n                   Set_Assignment_OK (New_Ref);\n \n-                  Insert_After (Init_After,\n+                  Insert_Action_After (Init_After,\n                     Make_Assignment_Statement (Loc,\n-                      Name => New_Ref,\n+                      Name       => New_Ref,\n                       Expression =>\n                         Unchecked_Convert_To (RTE (RE_Tag),\n                           New_Reference_To\n-                            (Node\n-                              (First_Elmt\n-                                (Access_Disp_Table (Full_Typ))),\n+                            (Node (First_Elmt (Access_Disp_Table (Full_Typ))),\n                              Loc))));\n                end;\n \n@@ -5196,10 +5195,6 @@ package body Exp_Ch3 is\n          if (Is_Possibly_Unaligned_Slice (Expr)\n                or else (Is_Possibly_Unaligned_Object (Expr)\n                           and then not Represented_As_Scalar (Etype (Expr))))\n-\n-            --  The exclusion of the unconstrained case is wrong, but for now\n-            --  it is too much trouble ???\n-\n            and then not (Is_Array_Type (Etype (Expr))\n                            and then not Is_Constrained (Etype (Expr)))\n          then\n@@ -5302,7 +5297,7 @@ package body Exp_Ch3 is\n \n    --  If the last variant does not contain the Others choice, replace it with\n    --  an N_Others_Choice node since Gigi always wants an Others. Note that we\n-   --  do not bother to call Analyze on the modified variant part, since it's\n+   --  do not bother to call Analyze on the modified variant part, since its\n    --  only effect would be to compute the Others_Discrete_Choices node\n    --  laboriously, and of course we already know the list of choices that\n    --  corresponds to the others choice (it's the list we are replacing!)\n@@ -6838,7 +6833,7 @@ package body Exp_Ch3 is\n                (Get_Rep_Item_For_Entity\n                  (First_Subtype (T), Name_Default_Value)));\n \n-      --  Othersie, for scalars, we must have normalize/initialize scalars\n+      --  Otherwise, for scalars, we must have normalize/initialize scalars\n       --  case, or if the node N is an 'Invalid_Value attribute node.\n \n       elsif Is_Scalar_Type (T) then\n@@ -6854,8 +6849,8 @@ package body Exp_Ch3 is\n             Size_To_Use := Size;\n          end if;\n \n-         --  Maximum size to use is 64 bits, since we will create values\n-         --  of type Unsigned_64 and the range must fit this type.\n+         --  Maximum size to use is 64 bits, since we will create values of\n+         --  type Unsigned_64 and the range must fit this type.\n \n          if Size_To_Use /= No_Uint and then Size_To_Use > Uint_64 then\n             Size_To_Use := Uint_64;\n@@ -6883,7 +6878,7 @@ package body Exp_Ch3 is\n \n             --  For signed integer types that have no negative values, either\n             --  there is room for negative values, or there is not. If there\n-            --  is, then all 1 bits may be interpreted as minus one, which is\n+            --  is, then all 1-bits may be interpreted as minus one, which is\n             --  certainly invalid. Alternatively it is treated as the largest\n             --  positive value, in which case the observation for modular types\n             --  still applies.\n@@ -6897,8 +6892,8 @@ package body Exp_Ch3 is\n             then\n                Val := Make_Integer_Literal (Loc, 2 ** Size_To_Use - 1);\n \n-               --  Resolve as Unsigned_64, because the largest number we\n-               --  can generate is out of range of universal integer.\n+               --  Resolve as Unsigned_64, because the largest number we can\n+               --  generate is out of range of universal integer.\n \n                Analyze_And_Resolve (Val, RTE (RE_Unsigned_64));\n \n@@ -6910,10 +6905,10 @@ package body Exp_Ch3 is\n                                   UI_Min (Uint_63, Size_To_Use - 1);\n \n                begin\n-                  --  Normally we like to use the most negative number. The\n-                  --  one exception is when this number is in the known\n-                  --  subtype range and the largest positive number is not in\n-                  --  the known subtype range.\n+                  --  Normally we like to use the most negative number. The one\n+                  --  exception is when this number is in the known subtype\n+                  --  range and the largest positive number is not in the known\n+                  --  subtype range.\n \n                   --  For this exceptional case, use largest positive value\n \n@@ -6923,7 +6918,7 @@ package body Exp_Ch3 is\n                   then\n                      Val := Make_Integer_Literal (Loc, 2 ** Signed_Size - 1);\n \n-                     --  Normal case of largest negative value\n+                  --  Normal case of largest negative value\n \n                   else\n                      Val := Make_Integer_Literal (Loc, -(2 ** Signed_Size));\n@@ -6992,14 +6987,14 @@ package body Exp_Ch3 is\n \n          --  The final expression is obtained by doing an unchecked conversion\n          --  of this result to the base type of the required subtype. We use\n-         --  the base type to avoid the unchecked conversion from chopping\n+         --  the base type to prevent the unchecked conversion from chopping\n          --  bits, and then we set Kill_Range_Check to preserve the \"bad\"\n          --  value.\n \n          Result := Unchecked_Convert_To (Base_Type (T), Val);\n \n-         --  Ensure result is not truncated, since we want the \"bad\" bits\n-         --  and also kill range check on result.\n+         --  Ensure result is not truncated, since we want the \"bad\" bits, and\n+         --  also kill range check on result.\n \n          if Nkind (Result) = N_Unchecked_Type_Conversion then\n             Set_No_Truncation (Result);\n@@ -7031,12 +7026,11 @@ package body Exp_Ch3 is\n       --  Access type is initialized to null\n \n       elsif Is_Access_Type (T) then\n-         return\n-           Make_Null (Loc);\n+         return Make_Null (Loc);\n \n-      --  No other possibilities should arise, since we should only be\n-      --  calling Get_Simple_Init_Val if Needs_Simple_Initialization\n-      --  returned True, indicating one of the above cases held.\n+      --  No other possibilities should arise, since we should only be calling\n+      --  Get_Simple_Init_Val if Needs_Simple_Initialization returned True,\n+      --  indicating one of the above cases held.\n \n       else\n          raise Program_Error;\n@@ -7085,7 +7079,7 @@ package body Exp_Ch3 is\n          S1 := Scope (S1);\n       end loop;\n \n-      return Chars (S1) = Name_System or else Chars (S1) = Name_Ada;\n+      return Is_RTU (S1, RU_System) or else Is_RTU (S1, RU_Ada);\n    end In_Runtime;\n \n    ----------------------------"}, {"sha": "a6ec3a74b0db1be0a0f8d930ac316b6682ddbf7e", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df17060504b871c522e85dffada60756790352ac/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=df17060504b871c522e85dffada60756790352ac", "patch": "@@ -443,7 +443,29 @@ package body Sem_Ch4 is\n          end loop;\n       end if;\n \n-      --  Analyze the allocator\n+      --  Ada 2012 (AI05-0111-3): Analyze the subpool_specification, if\n+      --  any. The expected type for the name is any type. A non-overloading\n+      --  rule then requires it to be of a type descended from\n+      --  System.Storage_Pools.Subpools.Subpool_Handle. This isn't exactly what\n+      --  the AI says, but I think it's the right rule. The AI should be fixed.\n+\n+      declare\n+         Subpool : constant Node_Id := Subpool_Handle_Name (N);\n+      begin\n+         if Present (Subpool) then\n+            Analyze (Subpool);\n+            if Is_Overloaded (Subpool) then\n+               Error_Msg_N (\"ambiguous subpool handle\", Subpool);\n+            end if;\n+\n+            --  ???We need to check that Etype (Subpool) is descended from\n+            --  Subpool_Handle\n+\n+            Resolve (Subpool);\n+         end if;\n+      end;\n+\n+      --  Analyze the qualified expression or subtype indication\n \n       if Nkind (E) = N_Qualified_Expression then\n          Acc_Type := Create_Itype (E_Allocator_Type, N);"}]}