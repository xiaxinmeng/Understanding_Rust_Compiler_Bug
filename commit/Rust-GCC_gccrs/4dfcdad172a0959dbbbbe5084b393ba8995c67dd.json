{"sha": "4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmY2RhZDE3MmEwOTU5ZGJiYmJlNTA4NGIzOTNiYTg5OTVjNjdkZA==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-06-17T23:43:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-06-17T23:43:16Z"}, "message": "[multiple changes]\n\n2004-06-17  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JToolBar.java\n\t(name): Removed.\n\t(JToolBar): Use Component.setName(String) instead of doing it all\n\talone.\n\t* javax/swing/Timer.java\n\t(queueEvent): Added missing modifier.\n\n2004-06-17  Olga Rodimina  <rodimina@redhat.coom>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Re-generate.\n\t* javax/swing/JMenu.java:\n\t(insertSeparator): Implemented.\n\t* javax/swing/JPopupMenu.java:\n\t(JPopupMenu.Separator): Implemented.\n\t* javax/swing/MenuSelectionManager.java:\n\t(processMouseEvent): Use java.awt.Component\n\tfor event source instead of javax.swing.JComponent.\n\t* javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.java:\n\tNew File. Implemented.\n\n2004-06-16  David Jee  <djee@redhat.com>\n\n\t* java/awt/GridBagLayout.java\n\t(GetLayoutInfo): Adjust cell sizes iff parent size is not zero.\n\tMake sure pos_x and pos_y are never negative.\n\n2004-04-16  Andrew Overholt  <overholt@redhat.com>\n\n\t* Makefile.am: Add new file.\n\t* Makefile.in: Re-generate.\n\t* javax/swing/JToolBar.java\n\tPartially implemented.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java\n\tNew file. Partially implemented.\n\n2004-06-16  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(setComposite): Accept AlphaComposite arguments.\n\t* gnu/java/awt/peer/gtk/GdkPixbufDecoder.java\n\t(createBufferedImage): Add new overloads.\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n\t(createImage): Use GdkPixbufDecoder.createBufferedImage\n\twhen useGraphics2D() is true.\n\t(getImage): Delegate to createImage.\n\t* javax/swing/JList.java\n\t(isSelectionEmpty):\n\t(getFirstVisibleIndex):\n\t(getLastVisibleIndex):\n\t(setSelectedValue):\n\t(ensureIndexIsVisible): New methods.\n\t* javax/swing/Timer.java: Reimplement.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java\n\t(AbstracElement): Made public, implements java.io.Serializable.\n\t(AttributeContext): Made public.\n\t(BranchElement): Likewise.\n\t(Content): Likewise.\n\t(DefaultDocumentEvent): Made public, extends\n\tjavax.swing.undo.CompoundEdit.\n\t(ElementEdit): Made public, extends\n\tjavax.swing.undo.AbstractUndoableEdit.\n\t(LeafElement): Made public.\n\t(LeafElement.LeafElement): Made public.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/JTextComponent.java: Totally reworked. Removed many\n\tmethods (that were obviously never be intended to get included hi this\n\tclass. Added some methods too.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/PlainDocument.java\n\t(serialVersionUID): New constant.\n\t(lineLimitAttribute): Likewise.\n\t(tabSizeAttribute): Likewise.\n\t(tabSize): New field.\n\t(PlainDocument): Made public.\n\t(PlainDocument): New constructor.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java\n\t(insertString): Throws BadLocationException.\n\t* javax/swing/text/Document.java\n\t(insertString): Likewise.\n\t* javax/swing/text/JTextComponent.java:\n\tJavadocs and comments cleaned up.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/event/UndoableEditListener.java: Reformatted.\n\t* javax/swing/text/AbstractDocument.java\n\t(AbstractDocument): Implements java.io.Serializable.\n\t(doc_list): Removed.\n\t(undo_list): Removed.\n\t(AbstractElement.serialVerionUID): New field.\n\t(BranchElement.serialVerionUID): Likewise.\n\t(DefaultDocumentEvent.serialVerionUID): Likewise.\n\t(ElementEdit.serialVerionUID): Likewise.\n\t(LeafElement.serialVerionUID): Likewise.\n\t(serialVerionUID): Likewise.\n\t(BAD_LOCATION): New constant.\n\t(BidiElementName): Likewise.\n\t(ContentElementName): Likewise.\n\t(ParagraphElementName): Likewise.\n\t(SectionElementName): Likewise.\n\t(ElementNameAttribute): Likewise.\n\t(AbstractDocument): Made protected.\n\t(AbstractDocument): New construtor.\n\t(listenerList): New field.\n\t(fireChangedUpdate): Implemented.\n\t(fireInsertUpdate): Likewise.\n\t(fireRemoveUpdate): Likewise.\n\t(fireUndoableEditUpdate): Likewise.\n\t(getListeners): Likewise.\n\t(addDocumentListener): Likewise.\n\t(removeDocumentListener): Likewise.\n\t(addUndoableEditListener): Likewise.\n\t(removeUndoableEditListener): Likewise.\n\t(getDocumentListeners): New method.\n\t(getUndoableEditListeners): Likewise.\n\t(getAsynchronousLoadPriority): Made public.\n\t(getBidiRootElement): Likewise.\n\t(setAsynchronousLoadPriority): Likewise.\n\t(setDocumentProperties): Likewise.\n\t* javax/swing/text/BadLocationException.java\n\t(serialVerionUID): New field.\n\t* javax/swing/text/DefaultCaret.java\n\t(changeEvent): New field.\n\t(listenerList): Likewise.\n\t(changes): Removed.\n\t(addChangeListener): Reimplemented.\n\t(removeChangeListener): Likewise.\n\t(getListeners): New method.\n\t(getChangeListeners): Likwise.\n\t(getComponent): Likewise.\n\t* javax/swing/text/GapContent.java\n\t(GapContent): Implements java.io.Serializable.\n\t(serialVerionUID): New field.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTree.java\n\t(treeModel): New field.\n\t(JTree): New constructors, one existing one made public.\n\t(createTreeModel): New method.\n\t(addTreeExpansionListener): Likewise.\n\t(removeTreeExpansionListener): Likewise.\n\t(getTreeExpansionListeners): Likewise.\n\t(fireTreeCollapsed): Likewise.\n\t(fireTreeExpanded): Likewise.\n\t(addTreeSelectionListener): Likewise.\n\t(removeTreeSelectionListener): Likewise.\n\t(getTreeSelectionListeners): Likewise.\n\t(fireValueChanged): Likewise.\n\t(addTreeWillExpandListener): Likewise.\n\t(removeTreeWillExpandListener): Likewise.\n\t(getTreeWillExpandListeners): Likewise.\n\t(fireTreeWillCollapse): Likewise.\n\t(fireTreeWillExpand): Likewise.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTree.java: Reformatted.\n\n2004-06-16  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTextArea.java: New file.\n\t* javax/swing/JTextField.java\n\t(actions): Removed.\n\t(notifyAction): New constant.\n\t(columns): New field.\n\t(JTextField): New constructors.\n\t(createDefaultModel): New method.\n\t(addActionListener): Reimplmemented.\n\t(removeActionListener): Reimplemented.\n\t(getActionListeners): New method.\n\t(fireActionPerformed): New method.\n\t(getColumns): New method.\n\t(setColumne): New method.\n\t* javax/swing/text/JTextComponent.java\n\t(AccessibleJTextComponent.serialVersionUID): New field.\n\t(serialVersionUID): Likewise.\n\t(DEFAULT_KEYMAP): Likewise.\n\t(FOCUS_ACCELERATOR_KEY): Likewise.\n\t(doc): Made private.\n\t(icon_gap): Likewise.\n\t(icon): Likewise.\n\t(align): Likewise.\n\t(JTextComponent): Some constructors removed.\n\t(getScrollableTracksViewportHeight): New method.\n\t(getScrollableTracksViewportWidth): Likewise.\n\t* Makefile.am: Added javax/swing/JTextArea.java.\n\t* Makefile.in: Regenerated.\n\n2004-06-15  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/ImageIcon.java (ImageIcon): New constructor.\n\t* javax/swing/JFrame.java (defaultLookAndFeelDecorated): New property.\n\t* javax/swing/JViewport.java\n\t(getExtentSize): Return size rather than preferred size.\n\t(toViewCoordinates): New methods.\n\t(getViewSize): Return size rather than preferred size.\n\t(setViewSize): Note view size as set.\n\t* javax/swing/ViewportLayout.java (layoutContainer): Reimplement.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n\t(getPreferredSize): Don't redo layout.\n\t* javax/swing/plaf/basic/BasicViewportUI.java\n\t(paint): Translate image properly and eat exceptions.\n\n2004-06-15  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JTabbedPane.java\n\t(setComponent): Remove old component and\n\tadd new component.\n\t(setSelectedIndex): Don't operate on the\n\tcomponents if they're null. Don't set index\n\ton the model if the index is the same.\n\t(insertTab): Don't add or hide the component\n\tif it's null. Repaint the container.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n\tChange colors for TabbedPane.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n\t(mousePressed): Re-layout and paint the component.\n\t(layoutContainer): Don't set location on the view.\n\t(ScrollingViewport::paint): Remove.\n\n2004-06-14  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(gtkWidgetDispatchKeyEvent): Change warning message to comment.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n\tWrap baseline y value in PANGO_PIXELS macro, rather than simply\n\tdividing by PANGO_SCALE.  Call gdk_flush before leaving GDK\n\tcritical region.\n\t(drawLine): Call gdk_flush before leaving GDK critical region.\n\t(fillRect): Likewise.\n\t(drawRect): Likewise.\n\t(copyArea): Likewise.\n\t(copyPixmap): Likewise.\n\t(clearRect): Likewise.\n\t(drawArc): Likewise.\n\t(drawPolyline): Likewise.\n\t(drawPolygon): Likewise.\n\t(fillPolygon): Likewise.\n\t(fillArc): Likewise.\n\t(drawOval): Likewise.\n\t(fillOval): Likewise.\n\n\t* gnu/java/awt/peer/gtk/GdkFontMetrics.java (initState): Add\n\tstyle parameter.\n\t(GdkFontMetrics): Add style argument to initState call.\n\t(stringWidth(String,int,int,String)): Add style parameter.\n\t(stringWidth(String)): Add style argument to stringWidth call.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c\n\t(initState): Set pango font style and weight based on AWT style\n\tparameter.  Pass default GTK language to\n\tpango_context_get_metrics.  Use PANGO_PIXELS macro rather than\n\tsimply dividing by PANGO_SCALE.\n\t(stringWidth): Set pango font style and weight based on AWT style\n\tparameter.\n\n\t* java/awt/Button.java (next_button_number): New field.\n\t(paramString): Change output.\n\t(generateName): New method.\n\t(getUniqueLong): New method.\n\n2004-06-14  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JTabbedPane.java:\n\t(setComponentAt): Set the component, not\n\tthe enabled status.\n\t* javax/swing/plaf/basic/BasicDesktopIconUI.java\n\t(actionPerformed): Let deiconize catch exception.\n\n2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JPopupMenu.java:\n\t(setVisible): Corrected location of a\n\theavyweight popup menu.\n\n2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/MenuSelectionManager.java:\n\tRan through jalopy to fix formatting style.\n\n2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JLayeredPane.java:\n\t(remove): Revalidate and repaint layered pane after\n\tthe component was removed.\n\tjavax/swing/JMenu.java:\n\t(setVisible): Display popup menu at the user location,\n\tif one was set by the user.\n\t(setMenuLocation): Reimplemented. Fixed javadoc.\n\t* javax/swing/JMenuBar.java: Added javadoc.\n\t(BORDER_PAINTED_CHANGED_PROPERTY): New Property.\n\t(MODEL_CHANGED_PROPERTY): New Property.\n\t(isSelected): Implemented.\n\t(setBorderPainted): Fire PropertyChangeEvent\n\tif paintBorder property changes.\n\t(setSelected): Implemented.\n\t(setSelectionModel): Implemented.\n\t* javax/swing/JPopupMenu.java: Added Javadoc\n\t(pack): Implemented.\n\t(setVisible): Reimplemented.\n\t(show): Fixed location.\n\t(JPopupMenu.LigthWeightPopup): Reimplemented to use\n\tContainer instead of JPanel.\n\t* javax/swing/MenuSelectionManager.java: Added Javadocs.\n\t(clearSelectedPath): Reimplemented to clear selectedPath\n\tin reverse order.\n\t(processMouseEvent): Reimplemented.\n\t(setSelectedPath): Fire stateChange event indicating that\n\tselected menu path has changed.\n\t(getPath): Change to use ArrayList instead of Vector.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n\t(installUI): call installKeyboardActions().\n\t(uninstallUI): call uninstallKeyboardActions().\n\n2004-06-13  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/DefaultCaret.java,\n\tjavax/swing/text/BadLocationException.java:\n\tReformatted.\n\n2004-06-12  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java (DEFAULT_ROWS,\n\tDEFAULT_COLS): New variables.\n\t(create): Don't allow 0 rows or 0 columns.  Instead, set the\n\tvalues to DEFAULT_ROWS or DEFAULT_COLS.\n\t(getMinimumSize): Likewise.\n\t(getPreferredSize): Likewise.\n\t(minimumSize): Likewise.\n\t(preferredSize): Likewise.\n\t(create): Set peer's editable state.\n\t* java/awt/TextArea.java (TextArea()): Set rows and columns to\n\tzero.  Update javadocs.\n\t(TextArea(String)): Likewise.\n\t(TextArea(int,int)): Fix javadocs.\n\t(TextArea(String,int,int,int)): Only throw exception if one of\n\trows or columns is zero.  Fix javadocs.\n\n2004-06-11  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/AWTEvent.java (toString): Handle MenuComponents in\n\taddition to Components.\n\n\t* java/awt/MenuItem.java (dispatchEventImpl): If the event\n\twasn't consumed by normal processing, send it to the parent\n\tmenu.\n\n\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n\t(setPixels(int,int,int,int,ColorModel,int[],int,int)): Remove\n\ttranslation.\n\n2004-06-11  David Jee  <djee@redhat.com>\n\n\t* java/awt/MediaTracker.java\n\t(addImage(Image,int)): Call imageUpdate() to udpate image status.\n\t(addImage(Image,int,int,int)): Likewise.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java,\n\tjavax/swing/text/Document.java,\n\tjavax/swing/text/GapContent.java,\n\tjavax/swing/text/JTextComponent.java,\n\tjavax/swing/text/PlainDocument.java:\n\tReformatted.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JRootPane.java\n\t(AccessibleJRootPane.serialVersionUID): New field.\n\t(AccessibleJRootPane.AccessibleJRootPane): New constructor.\n\t(AccessibleJRootPane.getAccessibleRole): New method.\n\t(RootLayout): Implements Serializable.\n\t(RootLayout.serialVersionUID): New field.\n\t(RootLayout.RootLayout): New constructor.\n\t(setJMenuBar): Made public.\n\t(getJMenuBar): Likewise.\n\t(JRootPane): Likewise.\n\t(createContentPane): Likewise.\n\t(createGlassPane): Likewise.\n\t(createLayeredPane): Likewise.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/SwingUtilities.java\n\t(isLeftMouseButton): Fixed javadoc.\n\t(isMiddleMouseButton): Likewise.\n\t(isRightMouseButton): Likewise.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JScrollPane.java\n\t(serialVersionUID): New field.\n\t(columnHeader): Made protected.\n\t(rowHeader): Likewise.\n\t(lowerLeft): Likewise.\n\t(lowerRight): Likewise.\n\t(upperLeft): Likewise.\n\t(upperRight): Likewise.\n\t(horizontalScrollBar): Likewise.\n\t(horizontalScrollBarPolicy): Likewise.\n\t(verticalScrollBar): Likewise.\n\t(verticalScrollBarPolicy): Likewise.\n\t(viewport): Likewise.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/LookAndFeel.java: Fixed javadocs.\n\n2004-06-11  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JEditorPane.java: Fixed javadocs.\n\t(JEditorPane): Removed redundant call to to this().\n\t(fireHyperlinkUpdate): Implemented.\n\n2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JMenu.java: Fixed file name\n\tin the file comment.\n\n2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JMenu.java: Added javadoc.\n\t(JMenu): Added MenuChangeListener to listen to\n\tChangeEvents occuring in menu's model.\n\t(insert): Throw IllegalArgumentException if\n\tindex is less than 0\n\t(setSelected): Reimplement.\n\t(setPopupMenuVisible): Call menu's model isEnabled()\n\t(setDelay): Throw IllegalArgumentException if\n\tgiven amount of delay is less than 0.\n\t(createActionComponent): Implemented.\n\t(createActionChangeListener): Implemented.\n\t(addSeparator): Implemented.\n\t(getItem): Throw IllegalArgumentException if index is\n\tless than 0.\n\t(getItemCount): Implemented.\n\t(fireMenuSelected): Changed to use menuEvent.\n\t(fireMenuDeselected): Likewise.\n\t(fireMenuCanceled): Likewise.\n\t(setAccelerator): Changed to throw an error if this\n\tmethod is used.\n\t(doClick): Implemented.\n\t(JMenu.ActionChangedListener): New inner class to handle\n\tPropertyChangeEvents occuring in the actions associated with menu.\n\t* javax/swing/plaf/basic/BasicMenuUI.java: Added javadoc.\n\t(BasicMenuUI): Added PropertyChangeListener to the menu.\n\t(createChangeListener): Implemented.\n\t(createMenuDragMouseListener): Likewise.\n\t(createMenuKeyListener): Likewise.\n\t(createPropertyChangeListener): Likewise.\n\t(uninstallListeners): Likewise.\n\t(BasicMenuUI.MouseInputHandler): Reimplemented.\n\t(BasicMenuUI.PropertyChangeHandler): New class. Not implemented yet.\n\t(BasicMenuUI.ChangeHandler): Likewise.\n\t(BasicMenuUI.MenuDragMouseHandler): Likewise.\n\t(BasicMenuUI.MenuKeyHandler): Likewise.\n\n2004-06-10  David Jee  <djee@redhat.com>\n\n\t* java/awt/MediaTracker.java\n\t(imageUpdate): Only do notifyAll() if the image is complete.\n\n2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JApplet.java:\n\t(getJMenuBar): Made public.\n\t(setJMenuBar): Likewise.\n\t* javax/swing/JFrame.java:\n\t(getJMenuBar): Made public.\n\t(setJMenuBar): Likewise.\n\t* javax/swing/JWindow.java:\n\t(getJMenuBar): Removed.\n\t(setJMenuBar): Removed.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JEditorPane.java\n\t(createEditorKitForContentType): Fixed visibility.\n\t(fireHyperlinkUpdate): Likewise.\n\t(getContentType): Likewise.\n\t(getEditorKit): Likewise.\n\t(getEditorKitForContentType): Likewise.\n\t(getPage): Likewise.\n\t(read): Likewise.\n\t(registerEditorKitForContentTyoe): Likewise.\n\t(replaceSelection): Likewise.\n\t(setContentType): Likewise.\n\t(setEditorKit): Likewise.\n\t(setPage): Likewise.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/Timer.java\n\t(Timer): New constructor.\n\t* javax/swing/plaf/basic/BasicProgressBarUI.java\n\t(animationTimer): Don't initialize at construction.\n\t(startAnimationTimer): Added since tag.\n\t(stopAnimationTimer): Likewise.\n\t(installUI): Use new Timer constructor.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n\t(installUI): Likewise.\n\t* javax/swing/plaf/basic/BasicSliderUI.java\n\t(installUI): Likewise.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ButtonGroup.java\n\t(serialVersionUID): Made private.\n\t(buttons): Renamed from v, added javadoc.\n\t(sel): Added javadoc.\n\t(ButtonGroup): Likewise.\n\t(add): Likewise.\n\t(remove): Likewise.\n\t(getElements): Likewise.\n\t(getSelection): Likewise.\n\t(setSelected): Likewise.\n\t(isSelected): Likewise.\n\t(getButtonCount): Likewise.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ButtonGroup.java,\n\tjavax/swing/ImageIcon.java,\n\tjavax/swing/JEditorPane.java,\n\tjavax/swing/JRootPane.java,\n\tjavax/swing/JTextField.java,\n\tjavax/swing/LookAndFeel.java,\n\tjavax/swing/plaf/basic/BasicTextUI.java:\n\tReindented.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/Style.java: Added javadocs.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JComponent.java\n\t(fireVetoableChange): Removed redundant cast.\n\t* javax/swing/JLabel.java\n\t(getDisabledIcon): Save icon for next call.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/KeyStroke.java\n\t(getKeyStroke(char,boolean)): Marked deprecated.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/DefaultCellEditor.java,\n\tjavax/swing/GrayFilter.java,\n\tjavax/swing/event/DocumentEvent.java,\n\tjavax/swing/text/JTextComponent.java,\n\tjavax/swing/text/MutableAttributeSet.java:\n\tReindented.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/BorderUIResource.java:\n\tAdded serialVersionUID all over.\n\n2004-06-10  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/UndoManager.java: Re-written from scratch.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/table/DefaultTableCellRenderer.java\n\t(noFocusBorder): Initialize directly.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicArrowButton.java\n\t(setDirection): Use method argument.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/BorderUIResource.java,\n\tjavax/swing/plaf/ComponentUI.java,\n\tjavax/swing/undo/CompoundEdit.java,\n\tjavax/swing/undo/StateEdit.java:\n\tFixed javadocs all over.\n\n2004-06-10  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/DefaultButtonModel.java\n\t(ARMED): Made public final, fixed value.\n\t(ENABLED): Likewise.\n\t(PRESSED): Likewise.\n\t(ROLLOVER): Likewise.\n\t(SELECTED): Likewise.\n\t(stateMask): Initialize directly.\n\t(listenerList): Likewise.\n\t(mnemonic): Likewise.\n\t(fireStateChanged): Removed argument, use changeEvent as event.\n\tAll places where this method is called are fixed too.\n\t(getActionCommant): Fixed javadoc.\n\t(setGroup): Fixed javadoc.\n\t(getGroup): New method.\n\n2004-06-09  Olga Rodimina <rodimina@redhat.com>\n\n\t* javax/swing/AbstractButton.java\n\t(AbstractButton): Use init() to initialize the button.\n\t(init): New Method. Initializes AbstractButton.\n\t* javax/swing/JMenuItem.java: Documented.\n\t(JMenuItem): Reimplemented.\n\t(init): Implemented.\n\t(setEnabled): Changed to call super.setEnabled()\n\t(processMouseEvent): Reimplemented.\n\t(fireMenuKeyPressed): Implemented.\n\t(fireMenuKeyReleased): Implemented.\n\t(fireMenuKeyTyped): Implemented.\n\t(menuSelectionChanged): disarm the model if the menu item was\n\tdeselected.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:Documented.\n\t(getPath): Change to use ArrayList instead of Vector.\n\t(getPreferredSize): Renamed variable.\n\t(paintMenuItem): Paint margin area of menu item.\n\t(MouseInputHandler.mouseEntered): Set selection in MenuSelectionManager.\n\t(MouseInputHandler.mouseReleased): Check if mouse was pressed inside\n\tmenu item's bounds before clearing the selection.\n\n2004-06-09  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkTextComponentPeer.java\n\t(GtkTextComponentPeer): Set caret position to 0.\n\t* java/awt/TextComponent.java\n\t(setText): Set caret position to 0.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter):\n\tHandle GtkScrolledWindow separately. Fix signal handler blocking.\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter):\n\tLikewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkTextAreaPeer_create): Make cursor\n\tvisible.\n\n2004-06-09  Kim Ho  <kho@redhat.com>\n\n\t* Makefile.am: New files\n\t* Makefile.in: Regenerated\n\t* java/awt/Container.java\n\t(getComponentAt): Removed.\n\t* javax/swing/AbstractAction.java\n\t(ENABLED_PROPERTY): New property.\n\t(putValue): Fire PropertyChangeEvents.\n\t(setEnabled): ditto.\n\t(firePropertyChange): Javadoc and implement\n\tconvenience method.\n\t* javax/swing/AbstractButton.java\n\t(setAction): Don't create PropertyChangeListener\n\tif new Action is null.\n\t(setIcon): Don't set icon till after comparing\n\tit.\n\t(configurePropertiesFromAction): Check mnemonic\n\tkey before calling intValue().\n\t(createActionPropertyChangeListener): Check\n\tproperties rather than bulk change.\n\t* javax/swing/DefaultDesktopManager.java:\n\tImplement.\n\t* javax/swing/DesktopManager.java:\n\tJalopy and javadoc.\n\t* javax/swing/JComponent.java\n\t(fireVetoableChange): Implement.\n\t(paintImmediately): Use root component.\n\t* javax/swing/JDesktopPane.java: Implement\n\t* javax/swing/JInternalFrame.java: Implement\n\t* javax/swing/JLabel.java\n\t(getDisabledIcon): Return grayscaled icon if\n\tno disabled icon specified.\n\t* javax/swing/JMenuBar.java\n\t(getComponentAtIndex): Use getComponent\n\t* javax/swing/JOptionPane.java\n\t(getDesktopPaneForComponent): Use SwingUtilities'\n\tgetAncestorOfClass\n\t(getFrameForComponent): ditto.\n\t* javax/swing/JSplitPane.java\n\t(remove): Use getComponent.\n\t* javax/swing/SwingUtilities.java\n\t(convertPoint): Implement.\n\t* javax/swing/plaf/basic/BasicButtonUI.java\n\t(paintButtonNormal): Check opaqueness before\n\tfilling background.\n\t* javax/swing/plaf/basic/BasicDesktopIconUI.java:\n\tImplement\n\t* javax/swing/plaf/basic/BasicDesktopPaneUI.java:\n\tImplement.\n\t* javax/swing/plaf/basic/BasicInternalFrameTitlePane.java:\n\tImplement.\n\t* javax/swing/plaf/basic/BasicInternalFrameUI.java:\n\tImplement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tChange InternalFrame and Desktop colors.\n\n2004-06-09  David Jee  <djee@redhat.com>\n\n\t* java/awt/Container.java\n\t(remove): Do not set component to invisible.\n\n2004-06-09  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/tree/DefaultMutableTreeNode.java\n\t(getLeafCount): Renamed enum to e.\n\n2004-06-09  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java\n\t(positionForMouseEvent): Removed redundant semicolon.\n\t(continueDrag): Use method arguments.\n\n2004-06-09  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/border/TitledBorder.java,\n\tjavax/swing/filechooser/FileSystemView.java,\n\tjavax/swing/plaf/basic/BasicButtonListener.java,\n\tjavax/swing/plaf/basic/BasicGraphicsUtils.java,\n\tjavax/swing/plaf/basic/BasicLabelUI.java,\n\tjavax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java,\n\tjavax/swing/plaf/basic/BasicScrollBarUI.java,\n\tjavax/swing/plaf/basic/BasicScrollPaneUI.java,\n\tjavax/swing/plaf/basic/BasicSliderUI.java,\n\tjavax/swing/plaf/basic/BasicTabbedPaneUI.java,\n\tjavax/swing/plaf/basic/BasicToggleButtonUI.java,\n\tjavax/swing/table/JTableHeader.java,\n\tjavax/swing/text/AbstractDocument.java,\n\tjavax/swing/text/DefaultCaret.java,\n\tjavax/swing/text/StyledEditorKit.java,\n\tjavax/swing/tree/DefaultTreeCellEditor.java:\n\tReworked import statements.\n\n2004-06-08  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/Box.java: Temporarily comment out code\n\tbroken due to visibility bug.\n\n2004-06-09  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ImageIcon.java\n\t(ImageIcon): Added missing constructor.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JToggleButton.java\n\t(JToggleButton): New constructor.\n\t(getAccessibleContext): Moved documentation into javadoc.\n\t(getUIClassID): Likewise.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/AbstractButton.java\n\t(getDisabledIcon): Create disabled icon if none exists yet.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n\t(initClassDefaults): Added FormattedTextFieldUI.\n\t(loadResourceBundle): Renamed enum to e.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicButtonUI.java\n\t(paintIcon): Simplified.\n\t(paintText): Paint disabled button correctly.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JComponent.java\n\t(createToolTip): Use official JToolTip API.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JToolTip.java\n\t(JToolTip): No arguments in API.\n\t(setTipText): New method.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/SwingUtilities.java\n\t(isLeftMouseButton): New method.\n\t(isMiddleMouseButton): New method.\n\t(isRightMouseButton): New method.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/AbstractButton.java,\n\tjavax/swing/CellRendererPane.java,\n\tjavax/swing/JCheckBoxMenuItem.java,\n\tjavax/swing/JColorChooser.java,\n\tjavax/swing/JComboBox.java,\n\tjavax/swing/JComponent.java,\n\tjavax/swing/JDesktopPane.java,\n\tjavax/swing/JFileChooser.java,\n\tjavax/swing/JMenu.java,\n\tjavax/swing/JMenuItem.java,\n\tjavax/swing/JOptionPane.java,\n\tjavax/swing/JPasswordField.java,\n\tjavax/swing/JPopupMenu.java,\n\tjavax/swing/JProgressBar.java,\n\tjavax/swing/JRadioButtonMenuItem.java,\n\tjavax/swing/JScrollBar.java,\n\tjavax/swing/JSeparator.java,\n\tjavax/swing/JSlider.java,\n\tjavax/swing/JSplitPane.java,\n\tjavax/swing/JTabbedPane.java,\n\tjavax/swing/JTextField.java,\n\tjavax/swing/JToolBar.java,\n\tjavax/swing/text/JTextComponent.java:\n\tFixed all constructors of accessibility classes.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ScrollPaneLayout.java: Renamed all memeber variables all\n\tover.\n\n2004-06-08  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/Box.java\n\t(AccessibleBoxFiller): Extends AccessibleAWTComponent.\n\t(AccessibleBoxFiller.serialVersionUID): New member variable.\n\t* javax/swing/DefaultButtonModel.java\n\t(stateMask): Made protected.\n\t(listenerList): Likewise.\n\t(changeEvent): Likewise.\n\t(group): Likewise.\n\t(mnemonic): Likewise.\n\t(actionCommand): Likewise.\n\t(getListeners): New method.\n\t(getActionListeners): New method.\n\t(getItemListeners): New method.\n\t(getChangeListeners): New method.\n\t(fireItemStateChanged): Simplified.\n\t(fireActionPerformed): Simplified.\n\t(fireStateChanged): Simplified.\n\t* javax/swing/JFrame.java\n\t(JFrame): Implements WindowContants.\n\t(HIDE_ON_CLOSE): Removed.\n\t(EXIT_ON_CLOSE): Removed.\n\t(DISPOSE_ON_CLOSE): Removed.\n\t(DO_NOTHING_ON_CLOSE): Removed.\n\t(processWindowEvent): Exit with code 0.\n\t(setDefaultCloseOperation): Do security check before setting value.\n\t* javax/swing/JOptionPane.java\n\t(message): Initialize only in constructor.\n\t* javax/swing/JToolTip.java: Removed unused imports.\n\t* javax/swing/JViewport.java\n\t(serialVersionUID): New member variable.\n\t(SIMPLE_SCROLL_MODE): Made final, fixed value.\n\t(BLIT_SCROLL_MODE): Likewise.\n\t(BACKINGSTORE_SCROLL_MODE): Likewise.\n\t(scrollUnderway): Made protected.\n\t(isViewSizeSet): Likewise.\n\t* javax/swing/ListModel.java: Fixed javadoc.\n\t* javax/swing/Popup.java: Likewise.\n\t* javax/swing/RepaintManager.java\n\t(paintDirtyRegions): Don't use internal classes of\n\tjava.util.AbstractMap.\n\t* javax/swing/ScrollPaneConstants.java: Reindented.\n\t* javax/swing/ScrollPaneLayout.java\n\t(viewport): Made protected.\n\t(verticalScrollBar): Made protected, renamed to vsb.\n\t(horizontalScrollBar): Made protected, renamed to hsb.\n\t(rowHeader): Made protected, renamed to rowHead.\n\t(columnHeader): Made protected, renamed to colHead.\n\t(lowerLeft): Made protected.\n\t(lowerRight): Made protected.\n\t(upperLeft): Made protected.\n\t(upperRight): Made protected.\n\t(verticalScrollBarPolicy): Made protected, renamed to vsbPolicy.\n\t(horizontalScrollBarPolicy): Made protected, renamed to hsbPolicy.\n\n2004-06-07  Bernd Schmidt  <bernds@btinternet.com>\n\n\t* java/awt/MediaTracker.java (imageUpdate): Only set status to\n\tLOADING if flags has SOMEBITS set.\n\n2004-06-07  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/AbstractButton.java: Reorganized imports.\n\t* javax/swing/ActionMap.java: Likewise.\n\t* javax/swing/DefaultButtonModel.java: Likewise.\n\t* javax/swing/DefaultListModel.java: Likewise.\n\t* javax/swing/ImageIcon.java: Likewise.\n\t(serialVersionUID): New member variable.\n\t* javax/swing/JComboBox.java: Reorganized imports.\n\t* javax/swing/JComponent.java: Likewise.\n\t(ui): Made protected.\n\t(listenerList): Made protected.\n\t(TOOL_TIP_TEXT_KEY): New constant.\n\t(scrollRectToVisible): Removed redundant null check.\n\t* javax/swing/JFrame.java: Reorganized imports.\n\t* javax/swing/JInternalFrame.java: Reorganized imports.\n\t* javax/swing/JProgressBar.java: Likewise.\n\t* javax/swing/JRootPane.java: Likewise.\n\t* javax/swing/JScrollBar.java: Likewise.\n\t* javax/swing/JSeparator.java: Likewise.\n\t* javax/swing/JSlider.java: Likewise.\n\t* javax/swing/JTabbedPane.java: Likewise.\n\t* javax/swing/JTextField.java: Likewise.\n\t* javax/swing/JToolBar.java: Likewise.\n\t* javax/swing/JTree.java: Likewise.\n\t* javax/swing/JViewport.java: Likewise.\n\t* javax/swing/JWindow.java: Likewise.\n\t* javax/swing/KeyStroke.java: Likewise.\n\t* javax/swing/LookAndFeel.java: Likewise.\n\t* javax/swing/MenuSelectionManager.java: Likewise.\n\t* javax/swing/SwingUtilities.java: Likewise.\n\t* javax/swing/Timer.java: Likewise.\n\t* javax/swing/DefaultBoundedRangeModel.java: Fixed javadoc.\n\t* javax/swing/JList.java\n\t(HORIZONTAL_WRAP): Made final, fixed value.\n\t(VERTICAL): Likewise.\n\t(VERTICAL_WRAP): Likewise.\n\n2004-06-07  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/AbstractButton.java\n\t(serialVersionUID): New member variable.\n\t(AccessibleAbstractButton.serialVersionUID): Likewise.\n\t(AbstractButton): Made public.\n\t* javax/swing/Box.java\n\t(AccessibleBox.serialVersionUID): New member variable.\n\t(Filler.serialVersionUID): Likewise.\n\t* javax/swing/DefaultListSelectionModel.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JApplet.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JCheckBox.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JCheckBoxMenuItem.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJCheckBoxMenuItem.serialVersionUID): Likewise.\n\t* javax/swing/JColorChooser.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJColorChooser.serialVersionUID): Likewise.\n\t* javax/swing/JComponent.java\n\t(serialVersionUID): Made private.\n\t(AccessibleJComponent.serialVersionUID): New member variable.\n\t* javax/swing/JDesktopPane.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JDialog.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JFormattedTextField.java\n\t(serialVersionUID): Fixed value.\n\t* javax/swing/JFrame.java\n\t(serialVersionUID): New member variable.\n\t(getDefaultCloseOpertation): Made public.\n\t* javax/swing/JLayeredPane.java\n\t(serialVersionUID): Likewise.\n\t(LAYER_PROPERTY): Made final, fixed value.\n\t(JLayeredPane): Made public.\n\t* javax/swing/JMenu.java\n\t(AccessibleJMenu.serialVersionUID): New member variable.\n\t(WinListener.serialVersionUID): Likewise.\n\t* javax/swing/JMenuBar.java\n\t(serialVersionUID): Likewise.\n\t(getComponentAtIndex): Added @deprecated tag.\n\t* javax/swing/JMenuItem.java\n\t(serialVersionUID): New member variable.\n\t(AccessibleJMenuItem.serialVersionUID): Likewise.\n\t* javax/swing/JOptionPane.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJOptionPane.serialVersionUID): Likewise.\n\t* javax/swing/JPopupMenu.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJPopupMenu.serialVersionUID): Likewise.\n\t(getPopupMenuListeners): New method.\n\t(getComponentAtIndex): Added @deprecated tag.\n\t* javax/swing/JProgressBar.java\n\t(serialVersionUID): New member variable.\n\t(AccessibleJProgressBar.serialVersionUID): Likewise.\n\t* javax/swing/JRadioButton.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JRadioButtonMenuItem.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJRadioButtonMenuItem.serialVersionUID): Likewise.\n\t* javax/swing/JScrollBar.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJScrollBar.serialVersionUID): Likewise.\n\t* javax/swing/JSeparator.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJSeparator.serialVersionUID): Likewise.\n\t* javax/swing/JSlider.java: Fixed javadocs.\n\t(AccessibleJSlider.serialVersionUID): New member variable.\n\t* javax/swing/JSplitPane.java: Added copyright statement.\n\t(serialVersionUID): New member variable.\n\t(AccessibleJSplitPane.serialVersionUID): Likewise.\n\t* javax/swing/JTabbedPane.java\n\t(serialVersionUID): Likewise.\n\t(AccessibleJTabbedPane.serialVersionUID): Likewise.\n\t(ModelListener.serialVersionUID): Likewise.\n\t(ModelListener.ModelListener): New constructor.\n\t(SCROLL_TAB_LAYOUT): Made public final, fixed value.\n\t(WRAP_TAB_LAYOUT): Likewise.\n\t* javax/swing/JTable.java\n\t(serialVersionUID): New member variable.\n\t* javax/swing/JToggleButton.java\n\t(serialVersionUID): Likewise.\n\t(ToggleButtonModel): Made static.\n\t(ToggleButtonModel.serialVersionUID): New member variable.\n\t* javax/swing/JToolTip.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JTree.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/JWindow.java\n\t(serialVersionUID): Likewise.\n\t* javax/swing/Timer.java\n\t(serialVersionUID): Likewise.\n\n2004-06-06  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/SwingConstants.java\n\t(NEXT): New constant.\n\t(PREVIOUS): Likewise.\n\t* javax/swing/UIManager.java\n\t(LookAndFeel): Made public.\n\t(LookAndFeel.getClassName): Likewise.\n\t(LookAndFeel.getName): Likewise.\n\n2004-06-02  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JCheckBoxMenuItem.java:\n\tRemoved CVS tags.\n\t* javax/swing/JMenu.java: Likewise.\n\t* javax/swing/JMenuBar.java: Likewise.\n\t* javax/swing/JMenuItem.java: Likewise.\n\t* javax/swing/JPopupMenu.java: Likewise.\n\t* javax/swing/JRadioButtonMenuItem.java: Likewise.\n\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java:Likewise.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicMenuUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java: Likewise.\n\n2004-05-31  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\t(MouseEntered): Do not call getPath() from MenuSelectionManager.\n\tCall getPath() from super class instead.\n\n2004-05-31  David Jee  <djee@redhat.com>\n\n\t* java/awt/Container.java\n\t(remove): Set component visibility to false after removing it.\n\n2004-05-27  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/Component.java (getForeground): Return SystemColor if\n\tparent is null.\n\t(getBackground): Likewise.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c\n\t(item_highlighted): New function.\n\t(connectSignals): Set item_highlighted as list's select\n\tfunction.\n\n\t* java/applet/Applet.java: Revert changes from 2004-04-29,\n\t2004-03-15 and 2004-03-14.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n\tDivide baseline y coordinate by PANGO_SCALE, not DPI conversion\n\tfactor.\n\n\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java (create): Set\n\t\"Dialog\" as the default font.\n\t* gnu/java/awt/peer/gtk/GtkTextFieldPeer.java (create):\n\tLikewise.\n\t* java/awt/Component.java (getFont): Return \"Dialog\" font by\n\tdefault.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c:\n\tMultiply size argument to pango_font_description_set_size by the\n\tDPI conversion factor rather than by PANGO_SCALE.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextFieldPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n\tDivide baseline y coordinate by DPI conversion factor rather\n\tthan by PANGO_SCALE.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c\n\t(area_prepared): Fix typo.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c\n\t(gtkSetFont): Move gtk_bin_get_child inside GDK critical region.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c\n\t(dpi_conversion_factor): New global variable.\n\t(init_dpi_conversion_factor): New function to calculate and\n\ttrack DPI conversion factor.\n\t(dpi_changed_cb): New callback.\n\t* jni/gtk-peer/gtkpeer.h (dpi_conversion_factor): Declare.\n\n2004-05-27  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(getGraphics): Return a new GdkGraphics instance.\n\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n\t(getGraphics): Call super.getGraphics().\n\n2004-05-26  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(setNativeBounds): Clamp width and height values to >= 0.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(find_fg_color_widget): Handle GtkOptionMenu specially.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(pre_event_handler): Only post configure events to visible\n\ttop-level windows.\n\n2004-05-26  David Jee  <djee@redhat.com>\n\n\t* java/awt/BorderLayout.java\n\t(layoutContainer): Fix size calculations.\n\n2004-05-26  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(window_wm_protocols_filter): Remove function.\n\t(create): Remove filter that removes WM_TAKE_FOCUS client\n\tmessages.\n\nFrom-SVN: r83324", "tree": {"sha": "0b7a36fdca2f61d07e5d16b523a65334e7f98cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b7a36fdca2f61d07e5d16b523a65334e7f98cc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/comments", "author": null, "committer": null, "parents": [{"sha": "398ce3dd7c85766ec8645d7815fac8248c568b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/398ce3dd7c85766ec8645d7815fac8248c568b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/398ce3dd7c85766ec8645d7815fac8248c568b54"}], "stats": {"total": 18800, "additions": 14181, "deletions": 4619}, "files": [{"sha": "9bf29a25affddbc73710ed569cfedbb5f4f38881", "filename": "libjava/ChangeLog", "status": "modified", "additions": 1141, "deletions": 0, "changes": 1141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,3 +1,1144 @@\n+2004-06-17  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JToolBar.java\n+\t(name): Removed.\n+\t(JToolBar): Use Component.setName(String) instead of doing it all\n+\talone.\n+\t* javax/swing/Timer.java\n+\t(queueEvent): Added missing modifier.\n+\n+2004-06-17  Olga Rodimina  <rodimina@redhat.coom>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Re-generate.\n+\t* javax/swing/JMenu.java:\n+\t(insertSeparator): Implemented.\n+\t* javax/swing/JPopupMenu.java:\n+\t(JPopupMenu.Separator): Implemented.\n+\t* javax/swing/MenuSelectionManager.java:\n+\t(processMouseEvent): Use java.awt.Component \n+\tfor event source instead of javax.swing.JComponent. \n+\t* javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.java:\n+\tNew File. Implemented.\n+\t\n+2004-06-16  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/GridBagLayout.java\n+\t(GetLayoutInfo): Adjust cell sizes iff parent size is not zero.\n+\tMake sure pos_x and pos_y are never negative.\n+\n+2004-04-16  Andrew Overholt  <overholt@redhat.com>\n+\n+\t* Makefile.am: Add new file.\n+\t* Makefile.in: Re-generate.     \n+\t* javax/swing/JToolBar.java\n+\tPartially implemented.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java\n+\tNew file. Partially implemented.\n+\n+2004-06-16  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java \n+\t(setComposite): Accept AlphaComposite arguments.\n+\t* gnu/java/awt/peer/gtk/GdkPixbufDecoder.java\n+\t(createBufferedImage): Add new overloads.\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n+\t(createImage): Use GdkPixbufDecoder.createBufferedImage\n+\twhen useGraphics2D() is true.\n+\t(getImage): Delegate to createImage.\n+\t* javax/swing/JList.java\n+\t(isSelectionEmpty):\n+\t(getFirstVisibleIndex):\n+\t(getLastVisibleIndex):\n+\t(setSelectedValue):\n+\t(ensureIndexIsVisible): New methods.\n+\t* javax/swing/Timer.java: Reimplement.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java\n+\t(AbstracElement): Made public, implements java.io.Serializable.\n+\t(AttributeContext): Made public.\n+\t(BranchElement): Likewise.\n+\t(Content): Likewise.\n+\t(DefaultDocumentEvent): Made public, extends\n+\tjavax.swing.undo.CompoundEdit.\n+\t(ElementEdit): Made public, extends\n+\tjavax.swing.undo.AbstractUndoableEdit.\n+\t(LeafElement): Made public.\n+\t(LeafElement.LeafElement): Made public.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/JTextComponent.java: Totally reworked. Removed many\n+\tmethods (that were obviously never be intended to get included hi this\n+\tclass. Added some methods too.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/PlainDocument.java\n+\t(serialVersionUID): New constant.\n+\t(lineLimitAttribute): Likewise.\n+\t(tabSizeAttribute): Likewise.\n+\t(tabSize): New field.\n+\t(PlainDocument): Made public.\n+\t(PlainDocument): New constructor.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java\n+\t(insertString): Throws BadLocationException.\n+\t* javax/swing/text/Document.java\n+\t(insertString): Likewise.\n+\t* javax/swing/text/JTextComponent.java:\n+\tJavadocs and comments cleaned up.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/event/UndoableEditListener.java: Reformatted.\n+\t* javax/swing/text/AbstractDocument.java\n+\t(AbstractDocument): Implements java.io.Serializable.\n+\t(doc_list): Removed.\n+\t(undo_list): Removed.\n+\t(AbstractElement.serialVerionUID): New field.\n+\t(BranchElement.serialVerionUID): Likewise.\n+\t(DefaultDocumentEvent.serialVerionUID): Likewise.\n+\t(ElementEdit.serialVerionUID): Likewise.\n+\t(LeafElement.serialVerionUID): Likewise.\n+\t(serialVerionUID): Likewise.\n+\t(BAD_LOCATION): New constant.\n+\t(BidiElementName): Likewise.\n+\t(ContentElementName): Likewise.\n+\t(ParagraphElementName): Likewise.\n+\t(SectionElementName): Likewise.\n+\t(ElementNameAttribute): Likewise.\n+\t(AbstractDocument): Made protected.\n+\t(AbstractDocument): New construtor.\n+\t(listenerList): New field.\n+\t(fireChangedUpdate): Implemented.\n+\t(fireInsertUpdate): Likewise.\n+\t(fireRemoveUpdate): Likewise.\n+\t(fireUndoableEditUpdate): Likewise.\n+\t(getListeners): Likewise.\n+\t(addDocumentListener): Likewise.\n+\t(removeDocumentListener): Likewise.\n+\t(addUndoableEditListener): Likewise.\n+\t(removeUndoableEditListener): Likewise.\n+\t(getDocumentListeners): New method.\n+\t(getUndoableEditListeners): Likewise.\n+\t(getAsynchronousLoadPriority): Made public.\n+\t(getBidiRootElement): Likewise.\n+\t(setAsynchronousLoadPriority): Likewise.\n+\t(setDocumentProperties): Likewise.\n+\t* javax/swing/text/BadLocationException.java\n+\t(serialVerionUID): New field.\n+\t* javax/swing/text/DefaultCaret.java\n+\t(changeEvent): New field.\n+\t(listenerList): Likewise.\n+\t(changes): Removed.\n+\t(addChangeListener): Reimplemented.\n+\t(removeChangeListener): Likewise.\n+\t(getListeners): New method.\n+\t(getChangeListeners): Likwise.\n+\t(getComponent): Likewise.\n+\t* javax/swing/text/GapContent.java\n+\t(GapContent): Implements java.io.Serializable.\n+\t(serialVerionUID): New field.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTree.java\n+\t(treeModel): New field.\n+\t(JTree): New constructors, one existing one made public.\n+\t(createTreeModel): New method.\n+\t(addTreeExpansionListener): Likewise.\n+\t(removeTreeExpansionListener): Likewise.\n+\t(getTreeExpansionListeners): Likewise.\n+\t(fireTreeCollapsed): Likewise.\n+\t(fireTreeExpanded): Likewise.\n+\t(addTreeSelectionListener): Likewise.\n+\t(removeTreeSelectionListener): Likewise.\n+\t(getTreeSelectionListeners): Likewise.\n+\t(fireValueChanged): Likewise.\n+\t(addTreeWillExpandListener): Likewise.\n+\t(removeTreeWillExpandListener): Likewise.\n+\t(getTreeWillExpandListeners): Likewise.\n+\t(fireTreeWillCollapse): Likewise.\n+\t(fireTreeWillExpand): Likewise.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTree.java: Reformatted.\n+\n+2004-06-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTextArea.java: New file.\n+\t* javax/swing/JTextField.java\n+\t(actions): Removed.\n+\t(notifyAction): New constant.\n+\t(columns): New field.\n+\t(JTextField): New constructors.\n+\t(createDefaultModel): New method.\n+\t(addActionListener): Reimplmemented.\n+\t(removeActionListener): Reimplemented.\n+\t(getActionListeners): New method.\n+\t(fireActionPerformed): New method.\n+\t(getColumns): New method.\n+\t(setColumne): New method.\n+\t* javax/swing/text/JTextComponent.java\n+\t(AccessibleJTextComponent.serialVersionUID): New field.\n+\t(serialVersionUID): Likewise.\n+\t(DEFAULT_KEYMAP): Likewise.\n+\t(FOCUS_ACCELERATOR_KEY): Likewise.\n+\t(doc): Made private.\n+\t(icon_gap): Likewise.\n+\t(icon): Likewise.\n+\t(align): Likewise.\n+\t(JTextComponent): Some constructors removed.\n+\t(getScrollableTracksViewportHeight): New method.\n+\t(getScrollableTracksViewportWidth): Likewise.\n+\t* Makefile.am: Added javax/swing/JTextArea.java.\n+\t* Makefile.in: Regenerated.\n+\n+2004-06-15  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/ImageIcon.java (ImageIcon): New constructor.\n+\t* javax/swing/JFrame.java (defaultLookAndFeelDecorated): New property.\n+\t* javax/swing/JViewport.java \n+\t(getExtentSize): Return size rather than preferred size.\n+\t(toViewCoordinates): New methods.\n+\t(getViewSize): Return size rather than preferred size.\n+\t(setViewSize): Note view size as set.\n+\t* javax/swing/ViewportLayout.java (layoutContainer): Reimplement.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java \n+\t(getPreferredSize): Don't redo layout.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java \n+\t(paint): Translate image properly and eat exceptions.\n+\n+2004-06-15  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JTabbedPane.java\n+\t(setComponent): Remove old component and\n+\tadd new component.\n+\t(setSelectedIndex): Don't operate on the \n+\tcomponents if they're null. Don't set index\n+\ton the model if the index is the same.\n+\t(insertTab): Don't add or hide the component\n+\tif it's null. Repaint the container.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n+\tChange colors for TabbedPane.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n+\t(mousePressed): Re-layout and paint the component.\n+\t(layoutContainer): Don't set location on the view.\n+\t(ScrollingViewport::paint): Remove.\n+\n+2004-06-14  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(gtkWidgetDispatchKeyEvent): Change warning message to comment.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n+\tWrap baseline y value in PANGO_PIXELS macro, rather than simply\n+\tdividing by PANGO_SCALE.  Call gdk_flush before leaving GDK\n+\tcritical region.\n+\t(drawLine): Call gdk_flush before leaving GDK critical region.\n+\t(fillRect): Likewise.\n+\t(drawRect): Likewise.\n+\t(copyArea): Likewise.\n+\t(copyPixmap): Likewise.\n+\t(clearRect): Likewise.\n+\t(drawArc): Likewise.\n+\t(drawPolyline): Likewise.\n+\t(drawPolygon): Likewise.\n+\t(fillPolygon): Likewise.\n+\t(fillArc): Likewise.\n+\t(drawOval): Likewise.\n+\t(fillOval): Likewise.\n+\n+\t* gnu/java/awt/peer/gtk/GdkFontMetrics.java (initState): Add\n+\tstyle parameter.\n+\t(GdkFontMetrics): Add style argument to initState call.\n+\t(stringWidth(String,int,int,String)): Add style parameter.\n+\t(stringWidth(String)): Add style argument to stringWidth call.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c\n+\t(initState): Set pango font style and weight based on AWT style\n+\tparameter.  Pass default GTK language to\n+\tpango_context_get_metrics.  Use PANGO_PIXELS macro rather than\n+\tsimply dividing by PANGO_SCALE.\n+\t(stringWidth): Set pango font style and weight based on AWT style\n+\tparameter.\n+\n+\t* java/awt/Button.java (next_button_number): New field.\n+\t(paramString): Change output.\n+\t(generateName): New method.\n+\t(getUniqueLong): New method.\n+\n+2004-06-14  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JTabbedPane.java:\n+\t(setComponentAt): Set the component, not\n+\tthe enabled status.\n+\t* javax/swing/plaf/basic/BasicDesktopIconUI.java\n+\t(actionPerformed): Let deiconize catch exception.\n+\n+2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JPopupMenu.java:\n+\t(setVisible): Corrected location of a \n+\theavyweight popup menu.\n+\n+2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/MenuSelectionManager.java: \n+\tRan through jalopy to fix formatting style.\n+\n+2004-06-14  Olga Rodimina  <rodimina@redhat.com>\n+\t\n+\t* javax/swing/JLayeredPane.java: \n+\t(remove): Revalidate and repaint layered pane after\n+\tthe component was removed.\n+\tjavax/swing/JMenu.java:\n+\t(setVisible): Display popup menu at the user location,\n+\tif one was set by the user.\n+\t(setMenuLocation): Reimplemented. Fixed javadoc.\n+\t* javax/swing/JMenuBar.java: Added javadoc.\n+\t(BORDER_PAINTED_CHANGED_PROPERTY): New Property.\n+\t(MODEL_CHANGED_PROPERTY): New Property.\n+\t(isSelected): Implemented.\n+\t(setBorderPainted): Fire PropertyChangeEvent\n+\tif paintBorder property changes.\n+\t(setSelected): Implemented.\n+\t(setSelectionModel): Implemented.\n+\t* javax/swing/JPopupMenu.java: Added Javadoc\n+\t(pack): Implemented.\n+\t(setVisible): Reimplemented.\n+\t(show): Fixed location.\n+\t(JPopupMenu.LigthWeightPopup): Reimplemented to use\n+\tContainer instead of JPanel.\n+\t* javax/swing/MenuSelectionManager.java: Added Javadocs.\n+\t(clearSelectedPath): Reimplemented to clear selectedPath\n+\tin reverse order.\n+\t(processMouseEvent): Reimplemented.\n+\t(setSelectedPath): Fire stateChange event indicating that\n+\tselected menu path has changed.\n+\t(getPath): Change to use ArrayList instead of Vector.\n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n+\t(installUI): call installKeyboardActions().\n+\t(uninstallUI): call uninstallKeyboardActions().\n+\n+2004-06-13  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/DefaultCaret.java,\n+\tjavax/swing/text/BadLocationException.java:\n+\tReformatted.\n+\n+2004-06-12  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java (DEFAULT_ROWS,\n+\tDEFAULT_COLS): New variables.\n+\t(create): Don't allow 0 rows or 0 columns.  Instead, set the\n+\tvalues to DEFAULT_ROWS or DEFAULT_COLS.\n+\t(getMinimumSize): Likewise.\n+\t(getPreferredSize): Likewise.\n+\t(minimumSize): Likewise.\n+\t(preferredSize): Likewise.\n+\t(create): Set peer's editable state.\n+\t* java/awt/TextArea.java (TextArea()): Set rows and columns to\n+\tzero.  Update javadocs.\n+\t(TextArea(String)): Likewise.\n+\t(TextArea(int,int)): Fix javadocs.\n+\t(TextArea(String,int,int,int)): Only throw exception if one of\n+\trows or columns is zero.  Fix javadocs.\n+\n+2004-06-11  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/AWTEvent.java (toString): Handle MenuComponents in\n+\taddition to Components.\n+\n+\t* java/awt/MenuItem.java (dispatchEventImpl): If the event\n+\twasn't consumed by normal processing, send it to the parent\n+\tmenu.\n+\n+\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n+\t(setPixels(int,int,int,int,ColorModel,int[],int,int)): Remove\n+\ttranslation.\n+\n+2004-06-11  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/MediaTracker.java\n+\t(addImage(Image,int)): Call imageUpdate() to udpate image status.\n+\t(addImage(Image,int,int,int)): Likewise.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java,\n+\tjavax/swing/text/Document.java,\n+\tjavax/swing/text/GapContent.java,\n+\tjavax/swing/text/JTextComponent.java,\n+\tjavax/swing/text/PlainDocument.java:\n+\tReformatted.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JRootPane.java\n+\t(AccessibleJRootPane.serialVersionUID): New field.\n+\t(AccessibleJRootPane.AccessibleJRootPane): New constructor.\n+\t(AccessibleJRootPane.getAccessibleRole): New method.\n+\t(RootLayout): Implements Serializable.\n+\t(RootLayout.serialVersionUID): New field.\n+\t(RootLayout.RootLayout): New constructor.\n+\t(setJMenuBar): Made public.\n+\t(getJMenuBar): Likewise.\n+\t(JRootPane): Likewise.\n+\t(createContentPane): Likewise.\n+\t(createGlassPane): Likewise.\n+\t(createLayeredPane): Likewise.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/SwingUtilities.java\n+\t(isLeftMouseButton): Fixed javadoc.\n+\t(isMiddleMouseButton): Likewise.\n+\t(isRightMouseButton): Likewise.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JScrollPane.java\n+\t(serialVersionUID): New field.\n+\t(columnHeader): Made protected.\n+\t(rowHeader): Likewise.\n+\t(lowerLeft): Likewise.\n+\t(lowerRight): Likewise.\n+\t(upperLeft): Likewise.\n+\t(upperRight): Likewise.\n+\t(horizontalScrollBar): Likewise.\n+\t(horizontalScrollBarPolicy): Likewise.\n+\t(verticalScrollBar): Likewise.\n+\t(verticalScrollBarPolicy): Likewise.\n+\t(viewport): Likewise.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/LookAndFeel.java: Fixed javadocs.\n+\n+2004-06-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JEditorPane.java: Fixed javadocs.\n+\t(JEditorPane): Removed redundant call to to this().\n+\t(fireHyperlinkUpdate): Implemented.\n+\n+2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JMenu.java: Fixed file name \n+\tin the file comment.\n+\n+2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JMenu.java: Added javadoc.\n+\t(JMenu): Added MenuChangeListener to listen to \n+\tChangeEvents occuring in menu's model. \n+\t(insert): Throw IllegalArgumentException if \n+\tindex is less than 0\n+\t(setSelected): Reimplement.\n+\t(setPopupMenuVisible): Call menu's model isEnabled()\n+\t(setDelay): Throw IllegalArgumentException if \n+\tgiven amount of delay is less than 0.\n+\t(createActionComponent): Implemented.\n+\t(createActionChangeListener): Implemented.\n+\t(addSeparator): Implemented.\n+\t(getItem): Throw IllegalArgumentException if index is \n+\tless than 0.\n+\t(getItemCount): Implemented.\n+\t(fireMenuSelected): Changed to use menuEvent.\n+\t(fireMenuDeselected): Likewise.\n+\t(fireMenuCanceled): Likewise.\n+\t(setAccelerator): Changed to throw an error if this \n+\tmethod is used. \n+\t(doClick): Implemented.\n+\t(JMenu.ActionChangedListener): New inner class to handle\n+\tPropertyChangeEvents occuring in the actions associated with menu.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java: Added javadoc.\n+\t(BasicMenuUI): Added PropertyChangeListener to the menu.\n+\t(createChangeListener): Implemented.\n+\t(createMenuDragMouseListener): Likewise.\n+\t(createMenuKeyListener): Likewise.\n+\t(createPropertyChangeListener): Likewise.\n+\t(uninstallListeners): Likewise.\n+\t(BasicMenuUI.MouseInputHandler): Reimplemented.\n+\t(BasicMenuUI.PropertyChangeHandler): New class. Not implemented yet.\n+\t(BasicMenuUI.ChangeHandler): Likewise.\n+\t(BasicMenuUI.MenuDragMouseHandler): Likewise.\n+\t(BasicMenuUI.MenuKeyHandler): Likewise.\n+\n+2004-06-10  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/MediaTracker.java\n+\t(imageUpdate): Only do notifyAll() if the image is complete.\n+\n+2004-06-10  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JApplet.java:\n+\t(getJMenuBar): Made public.\n+\t(setJMenuBar): Likewise.\n+\t* javax/swing/JFrame.java:\n+\t(getJMenuBar): Made public.\n+\t(setJMenuBar): Likewise.\n+\t* javax/swing/JWindow.java:\n+\t(getJMenuBar): Removed.\n+\t(setJMenuBar): Removed.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JEditorPane.java\n+\t(createEditorKitForContentType): Fixed visibility.\n+\t(fireHyperlinkUpdate): Likewise.\n+\t(getContentType): Likewise.\n+\t(getEditorKit): Likewise.\n+\t(getEditorKitForContentType): Likewise.\n+\t(getPage): Likewise.\n+\t(read): Likewise.\n+\t(registerEditorKitForContentTyoe): Likewise.\n+\t(replaceSelection): Likewise.\n+\t(setContentType): Likewise.\n+\t(setEditorKit): Likewise.\n+\t(setPage): Likewise.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/Timer.java\n+\t(Timer): New constructor.\n+\t* javax/swing/plaf/basic/BasicProgressBarUI.java\n+\t(animationTimer): Don't initialize at construction.\n+\t(startAnimationTimer): Added since tag.\n+\t(stopAnimationTimer): Likewise.\n+\t(installUI): Use new Timer constructor.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n+\t(installUI): Likewise.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java\n+\t(installUI): Likewise.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ButtonGroup.java\n+\t(serialVersionUID): Made private.\n+\t(buttons): Renamed from v, added javadoc.\n+\t(sel): Added javadoc.\n+\t(ButtonGroup): Likewise.\n+\t(add): Likewise.\n+\t(remove): Likewise.\n+\t(getElements): Likewise.\n+\t(getSelection): Likewise.\n+\t(setSelected): Likewise.\n+\t(isSelected): Likewise.\n+\t(getButtonCount): Likewise.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ButtonGroup.java,\n+\tjavax/swing/ImageIcon.java,\n+\tjavax/swing/JEditorPane.java,\n+\tjavax/swing/JRootPane.java,\n+\tjavax/swing/JTextField.java,\n+\tjavax/swing/LookAndFeel.java,\n+\tjavax/swing/plaf/basic/BasicTextUI.java:\n+\tReindented.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/Style.java: Added javadocs.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JComponent.java\n+\t(fireVetoableChange): Removed redundant cast.\n+\t* javax/swing/JLabel.java\n+\t(getDisabledIcon): Save icon for next call.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/KeyStroke.java\n+\t(getKeyStroke(char,boolean)): Marked deprecated.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/DefaultCellEditor.java,\n+\tjavax/swing/GrayFilter.java,\n+\tjavax/swing/event/DocumentEvent.java,\n+\tjavax/swing/text/JTextComponent.java,\n+\tjavax/swing/text/MutableAttributeSet.java:\n+\tReindented.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/BorderUIResource.java:\n+\tAdded serialVersionUID all over.\n+\n+2004-06-10  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/UndoManager.java: Re-written from scratch.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/table/DefaultTableCellRenderer.java\n+\t(noFocusBorder): Initialize directly.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicArrowButton.java\n+\t(setDirection): Use method argument.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/BorderUIResource.java,\n+\tjavax/swing/plaf/ComponentUI.java,\n+\tjavax/swing/undo/CompoundEdit.java,\n+\tjavax/swing/undo/StateEdit.java:\n+\tFixed javadocs all over.\n+\n+2004-06-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/DefaultButtonModel.java\n+\t(ARMED): Made public final, fixed value.\n+\t(ENABLED): Likewise.\n+\t(PRESSED): Likewise.\n+\t(ROLLOVER): Likewise.\n+\t(SELECTED): Likewise.\n+\t(stateMask): Initialize directly.\n+\t(listenerList): Likewise.\n+\t(mnemonic): Likewise.\n+\t(fireStateChanged): Removed argument, use changeEvent as event.\n+\tAll places where this method is called are fixed too.\n+\t(getActionCommant): Fixed javadoc.\n+\t(setGroup): Fixed javadoc.\n+\t(getGroup): New method.\n+\n+2004-06-09  Olga Rodimina <rodimina@redhat.com>\n+\n+\t* javax/swing/AbstractButton.java\n+\t(AbstractButton): Use init() to initialize the button.\n+\t(init): New Method. Initializes AbstractButton.\n+\t* javax/swing/JMenuItem.java: Documented.\n+\t(JMenuItem): Reimplemented.\n+\t(init): Implemented.\n+\t(setEnabled): Changed to call super.setEnabled()\n+\t(processMouseEvent): Reimplemented.\n+\t(fireMenuKeyPressed): Implemented.\n+\t(fireMenuKeyReleased): Implemented.\n+\t(fireMenuKeyTyped): Implemented.\n+\t(menuSelectionChanged): disarm the model if the menu item was\n+\tdeselected.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:Documented.\n+\t(getPath): Change to use ArrayList instead of Vector.\n+\t(getPreferredSize): Renamed variable.\n+\t(paintMenuItem): Paint margin area of menu item.\n+\t(MouseInputHandler.mouseEntered): Set selection in MenuSelectionManager.\n+\t(MouseInputHandler.mouseReleased): Check if mouse was pressed inside\n+\tmenu item's bounds before clearing the selection. \t\n+\n+2004-06-09  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkTextComponentPeer.java\n+\t(GtkTextComponentPeer): Set caret position to 0.\n+\t* java/awt/TextComponent.java\n+\t(setText): Set caret position to 0.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter):\n+\tHandle GtkScrolledWindow separately. Fix signal handler blocking.\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter):\n+\tLikewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkTextAreaPeer_create): Make cursor\n+\tvisible.\n+\n+2004-06-09  Kim Ho  <kho@redhat.com>\n+\n+\t* Makefile.am: New files\n+\t* Makefile.in: Regenerated\n+\t* java/awt/Container.java\n+\t(getComponentAt): Removed.\n+\t* javax/swing/AbstractAction.java\n+\t(ENABLED_PROPERTY): New property.\n+\t(putValue): Fire PropertyChangeEvents.\n+\t(setEnabled): ditto.\n+\t(firePropertyChange): Javadoc and implement\n+\tconvenience method.\n+\t* javax/swing/AbstractButton.java\n+\t(setAction): Don't create PropertyChangeListener\n+\tif new Action is null.\n+\t(setIcon): Don't set icon till after comparing\n+\tit.\n+\t(configurePropertiesFromAction): Check mnemonic\n+\tkey before calling intValue().\n+\t(createActionPropertyChangeListener): Check\n+\tproperties rather than bulk change.\n+\t* javax/swing/DefaultDesktopManager.java:\n+\tImplement.\n+\t* javax/swing/DesktopManager.java:\n+\tJalopy and javadoc.\n+\t* javax/swing/JComponent.java\n+\t(fireVetoableChange): Implement.\n+\t(paintImmediately): Use root component.\n+\t* javax/swing/JDesktopPane.java: Implement\n+\t* javax/swing/JInternalFrame.java: Implement\n+\t* javax/swing/JLabel.java\n+\t(getDisabledIcon): Return grayscaled icon if\n+\tno disabled icon specified.\n+\t* javax/swing/JMenuBar.java\n+\t(getComponentAtIndex): Use getComponent\n+\t* javax/swing/JOptionPane.java\n+\t(getDesktopPaneForComponent): Use SwingUtilities'\n+\tgetAncestorOfClass\n+\t(getFrameForComponent): ditto.\n+\t* javax/swing/JSplitPane.java\n+\t(remove): Use getComponent.\n+\t* javax/swing/SwingUtilities.java\n+\t(convertPoint): Implement.\n+\t* javax/swing/plaf/basic/BasicButtonUI.java\n+\t(paintButtonNormal): Check opaqueness before\n+\tfilling background.\n+\t* javax/swing/plaf/basic/BasicDesktopIconUI.java:\n+\tImplement\n+\t* javax/swing/plaf/basic/BasicDesktopPaneUI.java:\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicInternalFrameTitlePane.java:\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicInternalFrameUI.java:\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tChange InternalFrame and Desktop colors.\n+\n+2004-06-09  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Container.java\n+\t(remove): Do not set component to invisible.\n+\n+2004-06-09  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/tree/DefaultMutableTreeNode.java\n+\t(getLeafCount): Renamed enum to e.\n+\n+2004-06-09  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java\n+\t(positionForMouseEvent): Removed redundant semicolon.\n+\t(continueDrag): Use method arguments.\n+\n+2004-06-09  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/border/TitledBorder.java,\n+\tjavax/swing/filechooser/FileSystemView.java,\n+\tjavax/swing/plaf/basic/BasicButtonListener.java,\n+\tjavax/swing/plaf/basic/BasicGraphicsUtils.java,\n+\tjavax/swing/plaf/basic/BasicLabelUI.java,\n+\tjavax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java,\n+\tjavax/swing/plaf/basic/BasicScrollBarUI.java,\n+\tjavax/swing/plaf/basic/BasicScrollPaneUI.java,\n+\tjavax/swing/plaf/basic/BasicSliderUI.java,\n+\tjavax/swing/plaf/basic/BasicTabbedPaneUI.java,\n+\tjavax/swing/plaf/basic/BasicToggleButtonUI.java,\n+\tjavax/swing/table/JTableHeader.java,\n+\tjavax/swing/text/AbstractDocument.java,\n+\tjavax/swing/text/DefaultCaret.java,\n+\tjavax/swing/text/StyledEditorKit.java,\n+\tjavax/swing/tree/DefaultTreeCellEditor.java:\n+\tReworked import statements.\n+\n+2004-06-08  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/Box.java: Temporarily comment out code\n+\tbroken due to visibility bug.\n+\n+2004-06-09  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ImageIcon.java\n+\t(ImageIcon): Added missing constructor.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JToggleButton.java\n+\t(JToggleButton): New constructor.\n+\t(getAccessibleContext): Moved documentation into javadoc.\n+\t(getUIClassID): Likewise.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/AbstractButton.java\n+\t(getDisabledIcon): Create disabled icon if none exists yet.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n+\t(initClassDefaults): Added FormattedTextFieldUI.\n+\t(loadResourceBundle): Renamed enum to e.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicButtonUI.java\n+\t(paintIcon): Simplified.\n+\t(paintText): Paint disabled button correctly.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JComponent.java\n+\t(createToolTip): Use official JToolTip API.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JToolTip.java\n+\t(JToolTip): No arguments in API.\n+\t(setTipText): New method.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/SwingUtilities.java\n+\t(isLeftMouseButton): New method.\n+\t(isMiddleMouseButton): New method.\n+\t(isRightMouseButton): New method.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/AbstractButton.java,\n+\tjavax/swing/CellRendererPane.java,\n+\tjavax/swing/JCheckBoxMenuItem.java,\n+\tjavax/swing/JColorChooser.java,\n+\tjavax/swing/JComboBox.java,\n+\tjavax/swing/JComponent.java,\n+\tjavax/swing/JDesktopPane.java,\n+\tjavax/swing/JFileChooser.java,\n+\tjavax/swing/JMenu.java,\n+\tjavax/swing/JMenuItem.java,\n+\tjavax/swing/JOptionPane.java,\n+\tjavax/swing/JPasswordField.java,\n+\tjavax/swing/JPopupMenu.java,\n+\tjavax/swing/JProgressBar.java,\n+\tjavax/swing/JRadioButtonMenuItem.java,\n+\tjavax/swing/JScrollBar.java,\n+\tjavax/swing/JSeparator.java,\n+\tjavax/swing/JSlider.java,\n+\tjavax/swing/JSplitPane.java,\n+\tjavax/swing/JTabbedPane.java,\n+\tjavax/swing/JTextField.java,\n+\tjavax/swing/JToolBar.java,\n+\tjavax/swing/text/JTextComponent.java:\n+\tFixed all constructors of accessibility classes.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ScrollPaneLayout.java: Renamed all memeber variables all\n+\tover.\n+\n+2004-06-08  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/Box.java\n+\t(AccessibleBoxFiller): Extends AccessibleAWTComponent.\n+\t(AccessibleBoxFiller.serialVersionUID): New member variable.\n+\t* javax/swing/DefaultButtonModel.java\n+\t(stateMask): Made protected.\n+\t(listenerList): Likewise.\n+\t(changeEvent): Likewise.\n+\t(group): Likewise.\n+\t(mnemonic): Likewise.\n+\t(actionCommand): Likewise.\n+\t(getListeners): New method.\n+\t(getActionListeners): New method.\n+\t(getItemListeners): New method.\n+\t(getChangeListeners): New method.\n+\t(fireItemStateChanged): Simplified.\n+\t(fireActionPerformed): Simplified.\n+\t(fireStateChanged): Simplified.\n+\t* javax/swing/JFrame.java\n+\t(JFrame): Implements WindowContants.\n+\t(HIDE_ON_CLOSE): Removed.\n+\t(EXIT_ON_CLOSE): Removed.\n+\t(DISPOSE_ON_CLOSE): Removed.\n+\t(DO_NOTHING_ON_CLOSE): Removed.\n+\t(processWindowEvent): Exit with code 0.\n+\t(setDefaultCloseOperation): Do security check before setting value.\n+\t* javax/swing/JOptionPane.java\n+\t(message): Initialize only in constructor.\n+\t* javax/swing/JToolTip.java: Removed unused imports.\n+\t* javax/swing/JViewport.java\n+\t(serialVersionUID): New member variable.\n+\t(SIMPLE_SCROLL_MODE): Made final, fixed value.\n+\t(BLIT_SCROLL_MODE): Likewise.\n+\t(BACKINGSTORE_SCROLL_MODE): Likewise.\n+\t(scrollUnderway): Made protected.\n+\t(isViewSizeSet): Likewise.\n+\t* javax/swing/ListModel.java: Fixed javadoc.\n+\t* javax/swing/Popup.java: Likewise.\n+\t* javax/swing/RepaintManager.java\n+\t(paintDirtyRegions): Don't use internal classes of\n+\tjava.util.AbstractMap.\n+\t* javax/swing/ScrollPaneConstants.java: Reindented.\n+\t* javax/swing/ScrollPaneLayout.java\n+\t(viewport): Made protected.\n+\t(verticalScrollBar): Made protected, renamed to vsb.\n+\t(horizontalScrollBar): Made protected, renamed to hsb.\n+\t(rowHeader): Made protected, renamed to rowHead.\n+\t(columnHeader): Made protected, renamed to colHead.\n+\t(lowerLeft): Made protected.\n+\t(lowerRight): Made protected.\n+\t(upperLeft): Made protected.\n+\t(upperRight): Made protected.\n+\t(verticalScrollBarPolicy): Made protected, renamed to vsbPolicy.\n+\t(horizontalScrollBarPolicy): Made protected, renamed to hsbPolicy.\n+\n+2004-06-07  Bernd Schmidt  <bernds@btinternet.com>\n+\n+\t* java/awt/MediaTracker.java (imageUpdate): Only set status to\n+\tLOADING if flags has SOMEBITS set.\n+\n+2004-06-07  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/AbstractButton.java: Reorganized imports.\n+\t* javax/swing/ActionMap.java: Likewise.\n+\t* javax/swing/DefaultButtonModel.java: Likewise.\n+\t* javax/swing/DefaultListModel.java: Likewise.\n+\t* javax/swing/ImageIcon.java: Likewise.\n+\t(serialVersionUID): New member variable.\n+\t* javax/swing/JComboBox.java: Reorganized imports.\n+\t* javax/swing/JComponent.java: Likewise.\n+\t(ui): Made protected.\n+\t(listenerList): Made protected.\n+\t(TOOL_TIP_TEXT_KEY): New constant.\n+\t(scrollRectToVisible): Removed redundant null check.\n+\t* javax/swing/JFrame.java: Reorganized imports.\n+\t* javax/swing/JInternalFrame.java: Reorganized imports.\n+\t* javax/swing/JProgressBar.java: Likewise.\n+\t* javax/swing/JRootPane.java: Likewise.\n+\t* javax/swing/JScrollBar.java: Likewise.\n+\t* javax/swing/JSeparator.java: Likewise.\n+\t* javax/swing/JSlider.java: Likewise.\n+\t* javax/swing/JTabbedPane.java: Likewise.\n+\t* javax/swing/JTextField.java: Likewise.\n+\t* javax/swing/JToolBar.java: Likewise.\n+\t* javax/swing/JTree.java: Likewise.\n+\t* javax/swing/JViewport.java: Likewise.\n+\t* javax/swing/JWindow.java: Likewise.\n+\t* javax/swing/KeyStroke.java: Likewise.\n+\t* javax/swing/LookAndFeel.java: Likewise.\n+\t* javax/swing/MenuSelectionManager.java: Likewise.\n+\t* javax/swing/SwingUtilities.java: Likewise.\n+\t* javax/swing/Timer.java: Likewise.\n+\t* javax/swing/DefaultBoundedRangeModel.java: Fixed javadoc.\n+\t* javax/swing/JList.java\n+\t(HORIZONTAL_WRAP): Made final, fixed value.\n+\t(VERTICAL): Likewise.\n+\t(VERTICAL_WRAP): Likewise.\n+\n+2004-06-07  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/AbstractButton.java\n+\t(serialVersionUID): New member variable.\n+\t(AccessibleAbstractButton.serialVersionUID): Likewise.\n+\t(AbstractButton): Made public.\n+\t* javax/swing/Box.java\n+\t(AccessibleBox.serialVersionUID): New member variable.\n+\t(Filler.serialVersionUID): Likewise.\n+\t* javax/swing/DefaultListSelectionModel.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JApplet.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JCheckBox.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JCheckBoxMenuItem.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJCheckBoxMenuItem.serialVersionUID): Likewise.\n+\t* javax/swing/JColorChooser.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJColorChooser.serialVersionUID): Likewise.\n+\t* javax/swing/JComponent.java\n+\t(serialVersionUID): Made private.\n+\t(AccessibleJComponent.serialVersionUID): New member variable.\n+\t* javax/swing/JDesktopPane.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JDialog.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JFormattedTextField.java\n+\t(serialVersionUID): Fixed value.\n+\t* javax/swing/JFrame.java\n+\t(serialVersionUID): New member variable.\n+\t(getDefaultCloseOpertation): Made public.\n+\t* javax/swing/JLayeredPane.java\n+\t(serialVersionUID): Likewise.\n+\t(LAYER_PROPERTY): Made final, fixed value.\n+\t(JLayeredPane): Made public.\n+\t* javax/swing/JMenu.java\n+\t(AccessibleJMenu.serialVersionUID): New member variable.\n+\t(WinListener.serialVersionUID): Likewise.\n+\t* javax/swing/JMenuBar.java\n+\t(serialVersionUID): Likewise.\n+\t(getComponentAtIndex): Added @deprecated tag.\n+\t* javax/swing/JMenuItem.java\n+\t(serialVersionUID): New member variable.\n+\t(AccessibleJMenuItem.serialVersionUID): Likewise.\n+\t* javax/swing/JOptionPane.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJOptionPane.serialVersionUID): Likewise.\n+\t* javax/swing/JPopupMenu.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJPopupMenu.serialVersionUID): Likewise.\n+\t(getPopupMenuListeners): New method.\n+\t(getComponentAtIndex): Added @deprecated tag.\n+\t* javax/swing/JProgressBar.java\n+\t(serialVersionUID): New member variable.\n+\t(AccessibleJProgressBar.serialVersionUID): Likewise.\n+\t* javax/swing/JRadioButton.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JRadioButtonMenuItem.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJRadioButtonMenuItem.serialVersionUID): Likewise.\n+\t* javax/swing/JScrollBar.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJScrollBar.serialVersionUID): Likewise.\n+\t* javax/swing/JSeparator.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJSeparator.serialVersionUID): Likewise.\n+\t* javax/swing/JSlider.java: Fixed javadocs.\n+\t(AccessibleJSlider.serialVersionUID): New member variable.\n+\t* javax/swing/JSplitPane.java: Added copyright statement.\n+\t(serialVersionUID): New member variable.\n+\t(AccessibleJSplitPane.serialVersionUID): Likewise.\n+\t* javax/swing/JTabbedPane.java\n+\t(serialVersionUID): Likewise.\n+\t(AccessibleJTabbedPane.serialVersionUID): Likewise.\n+\t(ModelListener.serialVersionUID): Likewise.\n+\t(ModelListener.ModelListener): New constructor.\n+\t(SCROLL_TAB_LAYOUT): Made public final, fixed value.\n+\t(WRAP_TAB_LAYOUT): Likewise.\n+\t* javax/swing/JTable.java\n+\t(serialVersionUID): New member variable.\n+\t* javax/swing/JToggleButton.java\n+\t(serialVersionUID): Likewise.\n+\t(ToggleButtonModel): Made static.\n+\t(ToggleButtonModel.serialVersionUID): New member variable.\n+\t* javax/swing/JToolTip.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JTree.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/JWindow.java\n+\t(serialVersionUID): Likewise.\n+\t* javax/swing/Timer.java\n+\t(serialVersionUID): Likewise.\n+\n+2004-06-06  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/SwingConstants.java\n+\t(NEXT): New constant.\n+\t(PREVIOUS): Likewise.\n+\t* javax/swing/UIManager.java\n+\t(LookAndFeel): Made public.\n+\t(LookAndFeel.getClassName): Likewise.\n+\t(LookAndFeel.getName): Likewise.\n+\n+2004-06-02  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JCheckBoxMenuItem.java:\n+\tRemoved CVS tags.\n+\t* javax/swing/JMenu.java: Likewise.\n+\t* javax/swing/JMenuBar.java: Likewise.\n+\t* javax/swing/JMenuItem.java: Likewise.\n+\t* javax/swing/JPopupMenu.java: Likewise.\n+\t* javax/swing/JRadioButtonMenuItem.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java:Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java: Likewise.\n+\n+2004-05-31  Olga Rodimina  <rodimina@redhat.com>\n+\t\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\t(MouseEntered): Do not call getPath() from MenuSelectionManager.\n+\tCall getPath() from super class instead.\n+\n+2004-05-31  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Container.java\n+\t(remove): Set component visibility to false after removing it.\n+\n+2004-05-27  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/Component.java (getForeground): Return SystemColor if\n+\tparent is null.\n+\t(getBackground): Likewise.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c\n+\t(item_highlighted): New function.\n+\t(connectSignals): Set item_highlighted as list's select\n+\tfunction.\n+\n+\t* java/applet/Applet.java: Revert changes from 2004-04-29,\n+\t2004-03-15 and 2004-03-14.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n+\tDivide baseline y coordinate by PANGO_SCALE, not DPI conversion\n+\tfactor.\n+\n+\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java (create): Set\n+\t\"Dialog\" as the default font.\n+\t* gnu/java/awt/peer/gtk/GtkTextFieldPeer.java (create):\n+\tLikewise.\n+\t* java/awt/Component.java (getFont): Return \"Dialog\" font by\n+\tdefault.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c:\n+\tMultiply size argument to pango_font_description_set_size by the\n+\tDPI conversion factor rather than by PANGO_SCALE.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextFieldPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c (drawString):\n+\tDivide baseline y coordinate by DPI conversion factor rather\n+\tthan by PANGO_SCALE.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c\n+\t(area_prepared): Fix typo.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c\n+\t(gtkSetFont): Move gtk_bin_get_child inside GDK critical region.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c\n+\t(dpi_conversion_factor): New global variable.\n+\t(init_dpi_conversion_factor): New function to calculate and\n+\ttrack DPI conversion factor.\n+\t(dpi_changed_cb): New callback.\n+\t* jni/gtk-peer/gtkpeer.h (dpi_conversion_factor): Declare.\n+\n+2004-05-27  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(getGraphics): Return a new GdkGraphics instance.\n+\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n+\t(getGraphics): Call super.getGraphics().\n+\n+2004-05-26  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(setNativeBounds): Clamp width and height values to >= 0.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(find_fg_color_widget): Handle GtkOptionMenu specially.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(pre_event_handler): Only post configure events to visible\n+\ttop-level windows.\n+\n+2004-05-26  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/BorderLayout.java\n+\t(layoutContainer): Fix size calculations.\n+\n+2004-05-26  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(window_wm_protocols_filter): Remove function.\n+\t(create): Remove filter that removes WM_TAKE_FOCUS client\n+\tmessages.\n+\n 2004-06-17  Anthony Green  <green@redhat.com>\n \n \t* java/util/zip/ZipFile.java (getInputStream): Return null if"}, {"sha": "cac32b47777488dcafef8a55f1d8ba071af4aeb9", "filename": "libjava/Makefile.am", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1322,7 +1322,11 @@ javax/swing/plaf/basic/BasicArrowButton.java \\\n javax/swing/plaf/basic/BasicButtonListener.java \\\n javax/swing/plaf/basic/BasicButtonUI.java \\\n javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n+javax/swing/plaf/basic/BasicDesktopIconUI.java \\\n+javax/swing/plaf/basic/BasicDesktopPaneUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n+javax/swing/plaf/basic/BasicInternalFrameTitlePane.java \\\n+javax/swing/plaf/basic/BasicInternalFrameUI.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n javax/swing/plaf/basic/BasicMenuUI.java \\\n@@ -1331,6 +1335,7 @@ javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n javax/swing/plaf/basic/BasicPopupMenuUI.java \\\n+javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n@@ -1345,6 +1350,7 @@ javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\\n javax/swing/plaf/basic/BasicTextUI.java \\\n javax/swing/plaf/basic/BasicToggleButtonUI.java \\\n+javax/swing/plaf/basic/BasicToolBarUI.java \\\n javax/swing/plaf/basic/BasicTreeUI.java \\\n javax/swing/plaf/basic/BasicViewportUI.java \\\n javax/swing/plaf/basic/BasicLookAndFeel.java \\\n@@ -1444,6 +1450,7 @@ javax/swing/JRootPane.java \\\n javax/swing/JScrollBar.java \\\n javax/swing/JScrollPane.java \\\n javax/swing/JTabbedPane.java \\\n+javax/swing/JTextArea.java \\\n javax/swing/JTextField.java \\\n javax/swing/JToggleButton.java \\\n javax/swing/JToolTip.java \\"}, {"sha": "4177fd8ca03fca9ee119932dd1feac2392039223", "filename": "libjava/Makefile.in", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1001,7 +1001,11 @@ javax/swing/plaf/basic/BasicArrowButton.java \\\n javax/swing/plaf/basic/BasicButtonListener.java \\\n javax/swing/plaf/basic/BasicButtonUI.java \\\n javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n+javax/swing/plaf/basic/BasicDesktopIconUI.java \\\n+javax/swing/plaf/basic/BasicDesktopPaneUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n+javax/swing/plaf/basic/BasicInternalFrameTitlePane.java \\\n+javax/swing/plaf/basic/BasicInternalFrameUI.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n javax/swing/plaf/basic/BasicMenuUI.java \\\n@@ -1010,6 +1014,7 @@ javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n javax/swing/plaf/basic/BasicPopupMenuUI.java \\\n+javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n@@ -1024,6 +1029,7 @@ javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\\n javax/swing/plaf/basic/BasicTextUI.java \\\n javax/swing/plaf/basic/BasicToggleButtonUI.java \\\n+javax/swing/plaf/basic/BasicToolBarUI.java \\\n javax/swing/plaf/basic/BasicTreeUI.java \\\n javax/swing/plaf/basic/BasicViewportUI.java \\\n javax/swing/plaf/basic/BasicLookAndFeel.java \\\n@@ -1123,6 +1129,7 @@ javax/swing/JRootPane.java \\\n javax/swing/JScrollBar.java \\\n javax/swing/JScrollPane.java \\\n javax/swing/JTabbedPane.java \\\n+javax/swing/JTextArea.java \\\n javax/swing/JTextField.java \\\n javax/swing/JToggleButton.java \\\n javax/swing/JToolTip.java \\\n@@ -4545,14 +4552,14 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/JScrollBar.P .deps/javax/swing/JScrollPane.P \\\n .deps/javax/swing/JSeparator.P .deps/javax/swing/JSlider.P \\\n .deps/javax/swing/JSplitPane.P .deps/javax/swing/JTabbedPane.P \\\n-.deps/javax/swing/JTable.P .deps/javax/swing/JTextField.P \\\n-.deps/javax/swing/JTextPane.P .deps/javax/swing/JToggleButton.P \\\n-.deps/javax/swing/JToolBar.P .deps/javax/swing/JToolTip.P \\\n-.deps/javax/swing/JTree.P .deps/javax/swing/JViewport.P \\\n-.deps/javax/swing/JWindow.P .deps/javax/swing/KeyStroke.P \\\n-.deps/javax/swing/ListCellRenderer.P .deps/javax/swing/ListModel.P \\\n-.deps/javax/swing/ListSelectionModel.P .deps/javax/swing/LookAndFeel.P \\\n-.deps/javax/swing/MenuElement.P \\\n+.deps/javax/swing/JTable.P .deps/javax/swing/JTextArea.P \\\n+.deps/javax/swing/JTextField.P .deps/javax/swing/JTextPane.P \\\n+.deps/javax/swing/JToggleButton.P .deps/javax/swing/JToolBar.P \\\n+.deps/javax/swing/JToolTip.P .deps/javax/swing/JTree.P \\\n+.deps/javax/swing/JViewport.P .deps/javax/swing/JWindow.P \\\n+.deps/javax/swing/KeyStroke.P .deps/javax/swing/ListCellRenderer.P \\\n+.deps/javax/swing/ListModel.P .deps/javax/swing/ListSelectionModel.P \\\n+.deps/javax/swing/LookAndFeel.P .deps/javax/swing/MenuElement.P \\\n .deps/javax/swing/MenuSelectionManager.P \\\n .deps/javax/swing/MutableComboBoxModel.P \\\n .deps/javax/swing/OverlayLayout.P .deps/javax/swing/Popup.P \\\n@@ -4667,8 +4674,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicButtonUI.P \\\n .deps/javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.P \\\n .deps/javax/swing/plaf/basic/BasicCheckBoxUI.P \\\n+.deps/javax/swing/plaf/basic/BasicDesktopIconUI.P \\\n+.deps/javax/swing/plaf/basic/BasicDesktopPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicGraphicsUtils.P \\\n .deps/javax/swing/plaf/basic/BasicIconFactory.P \\\n+.deps/javax/swing/plaf/basic/BasicInternalFrameTitlePane.P \\\n+.deps/javax/swing/plaf/basic/BasicInternalFrameUI.P \\\n .deps/javax/swing/plaf/basic/BasicLabelUI.P \\\n .deps/javax/swing/plaf/basic/BasicListUI.P \\\n .deps/javax/swing/plaf/basic/BasicLookAndFeel.P \\\n@@ -4677,6 +4688,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicMenuUI.P \\\n .deps/javax/swing/plaf/basic/BasicOptionPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicPanelUI.P \\\n+.deps/javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.P \\\n .deps/javax/swing/plaf/basic/BasicPopupMenuUI.P \\\n .deps/javax/swing/plaf/basic/BasicProgressBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.P \\\n@@ -4691,6 +4703,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicTabbedPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicTextUI.P \\\n .deps/javax/swing/plaf/basic/BasicToggleButtonUI.P \\\n+.deps/javax/swing/plaf/basic/BasicToolBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicTreeUI.P \\\n .deps/javax/swing/plaf/basic/BasicViewportUI.P \\\n .deps/javax/swing/plaf/metal/MetalLookAndFeel.P \\"}, {"sha": "c7a73a3f362a6ed724ed09ea1c1b8885bdfcfb48", "filename": "libjava/gnu/java/awt/peer/gtk/GdkFontMetrics.java", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontMetrics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontMetrics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontMetrics.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -50,19 +50,21 @@ public class GdkFontMetrics extends FontMetrics\n                        MAX_ADVANCE = 4;\n \n   private int[] metrics;\n-  private native int[] initState (String fname, int size);\n+  private native int[] initState (String fname, int style, int size);\n \n   public GdkFontMetrics (Font font)\n   {\n     super (font);\n-    metrics = initState (font.getName (), font.getSize ());\n+    metrics = initState (font.getName (), font.getStyle (), font.getSize ());\n   }\n \n-  native public int stringWidth (String fname, int size, String str);\n+  native public int stringWidth (String fname, int style, int size,\n+                                 String str);\n \n   public int stringWidth (String str)\n   {\n-    return stringWidth (font.getName (), font.getSize (), str);\n+    return stringWidth (font.getName (), font.getStyle (), font.getSize (),\n+                        str);\n   }\n \n   public int charWidth (char ch)"}, {"sha": "ebff68ef987c1b3d60a3a882c3993f59f86c518d", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1260,7 +1260,18 @@ public GraphicsConfiguration getDeviceConfiguration()\n \n   public void setComposite(Composite comp)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    if (comp instanceof AlphaComposite)\n+      {\n+        AlphaComposite a = (AlphaComposite) comp;\n+        cairoSetOperator(a.getRule());\n+        Color c = getColor();\n+        setColor(new Color(c.getRed(),\n+                           c.getGreen(),\n+                           c.getBlue(),\n+                           (int) (a.getAlpha() * ((float) c.getAlpha()))));\n+      }\n+    else\n+      throw new java.lang.UnsupportedOperationException ();\n   }\n \n   public void setRenderingHint(RenderingHints.Key hintKey,"}, {"sha": "32c69871711fc3499ee59981c759f51176038123", "filename": "libjava/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -220,4 +220,31 @@ public static BufferedImage createBufferedImage (String filename)\n     dec.startProduction (bb);\n     return bb.getBufferedImage ();\n   }\n+\n+  public static BufferedImage createBufferedImage (URL u)\n+  {\n+    BufferedImageBuilder bb = new BufferedImageBuilder ();\n+    GdkPixbufDecoder dec = new GdkPixbufDecoder (u);\n+    dec.startProduction (bb);\n+    return bb.getBufferedImage ();\n+  }\n+\n+  public static BufferedImage createBufferedImage (byte[] imagedata, int imageoffset,\n+                                                   int imagelength)\n+  {\n+    BufferedImageBuilder bb = new BufferedImageBuilder ();\n+    GdkPixbufDecoder dec = new GdkPixbufDecoder (imagedata, imageoffset, imagelength);\n+    dec.startProduction (bb);\n+    return bb.getBufferedImage ();\n+  }\n+  \n+  public static BufferedImage createBufferedImage (ImageProducer producer)\n+  {\n+    BufferedImageBuilder bb = new BufferedImageBuilder ();\n+    producer.startProduction(bb);\n+    return bb.getBufferedImage ();\n+  }\n+  \n+\n+\n }"}, {"sha": "48e63f3d19a4bf274a71bd15cd5c9626deed3a23", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -199,7 +199,10 @@ public FontMetrics getFontMetrics (Font font)\n \n   public Graphics getGraphics ()\n   {\n-    return null;\n+    if (GtkToolkit.useGraphics2D ())\n+        return new GdkGraphics2D (this);\n+    else\n+        return new GdkGraphics (this);\n   }\n \n   public Point getLocationOnScreen () "}, {"sha": "8ac927cbae60efbc864eb1d98d1ee3e97df8ade8", "filename": "libjava/gnu/java/awt/peer/gtk/GtkContainerPeer.java", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -107,10 +107,7 @@ public void setFont(Font f)\n \n   public Graphics getGraphics ()\n   {\n-    if (GtkToolkit.useGraphics2D ())\n-        return new GdkGraphics2D (this);\n-    else\n-    return new GdkGraphics (this);\n+    return super.getGraphics();\n   }\n \n   public void beginLayout () { }"}, {"sha": "16f36d303f34a16ab54bc8e425dac2e2a7f4cb9b", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImagePainter.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -104,7 +104,7 @@ public class GtkImagePainter implements Runnable, ImageConsumer\n     s_width = Math.abs (sx2 - sx1);\n     s_height = Math.abs (sy2 - sy1);\n     clip = new Rectangle (sx1, sy1, s_width, s_height);\n-    \n+\n     new Thread (this).start ();\n   }\n \n@@ -170,8 +170,6 @@ public class GtkImagePainter implements Runnable, ImageConsumer\n \n \toffset += r.y * scansize + r.x;\n \n-\tr.translate (-Math.abs (clip.x - startX), -Math.abs (clip.y - startY));\n-\n \twidth = r.width;\n \theight = r.height;\n \tx = r.x;"}, {"sha": "b08728b2bff18bdb47b8b5be3ad3b63ce835a474", "filename": "libjava/gnu/java/awt/peer/gtk/GtkTextAreaPeer.java", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -47,6 +47,9 @@\n public class GtkTextAreaPeer extends GtkTextComponentPeer\n   implements TextAreaPeer\n {\n+  private static transient int DEFAULT_ROWS = 10;\n+  private static transient int DEFAULT_COLS = 80;\n+\n   native void create (int width, int height, int scrollbarVisibility);\n \n   native void gtkSetFont (String name, int style, int size);\n@@ -61,7 +64,7 @@ void create ()\n     // GtkComponent.create.\n     if (f == null)\n       {\n-\tf = new Font (\"Fixed\", Font.PLAIN, 12);\n+\tf = new Font (\"Dialog\", Font.PLAIN, 12);\n \tawtComponent.setFont (f);\n       }\n \n@@ -72,13 +75,17 @@ void create ()\n       fm = new GdkFontMetrics (f);\n \n     TextArea ta = ((TextArea) awtComponent);\n-    int rows = ta.getRows ();\n-    int cols = ta.getColumns ();\n+    int sizeRows = ta.getRows ();\n+    int sizeCols = ta.getColumns ();\n+\n+    sizeRows = sizeRows == 0 ? DEFAULT_ROWS : sizeRows;\n+    sizeCols = sizeCols == 0 ? DEFAULT_COLS : sizeCols;\n \n-    int width = cols * fm.getMaxAdvance ();\n-    int height = rows * (fm.getMaxDescent () + fm.getMaxAscent ());\n+    int width = sizeCols * fm.getMaxAdvance ();\n+    int height = sizeRows * (fm.getMaxDescent () + fm.getMaxAscent ());\n \n     create (width, height, ta.getScrollbarVisibility ());\n+    setEditable (ta.isEditable ());\n   }\n \n   public GtkTextAreaPeer (TextArea ta)\n@@ -91,12 +98,14 @@ public GtkTextAreaPeer (TextArea ta)\n \n   public Dimension getMinimumSize (int rows, int cols)\n   {\n-    return minimumSize (rows, cols);\n+    return minimumSize (rows == 0 ? DEFAULT_ROWS : rows,\n+                        cols == 0 ? DEFAULT_COLS : cols);\n   }\n \n   public Dimension getPreferredSize (int rows, int cols)\n   {\n-    return preferredSize (rows, cols);\n+    return preferredSize (rows == 0 ? DEFAULT_ROWS : rows,\n+                          cols == 0 ? DEFAULT_COLS : cols);\n   }\n \n   native int getHScrollbarHeight ();\n@@ -127,8 +136,11 @@ public Dimension minimumSize (int rows, int cols)\n     else\n       fm = new GdkFontMetrics (f);\n \n-    width += cols * fm.getMaxAdvance ();\n-    height += rows * (fm.getMaxDescent () + fm.getMaxAscent ());\n+    int sizeRows = rows == 0 ? DEFAULT_ROWS : rows;\n+    int sizeCols = cols == 0 ? DEFAULT_COLS : cols;\n+\n+    width += sizeCols * fm.getMaxAdvance ();\n+    height += sizeRows * (fm.getMaxDescent () + fm.getMaxAscent ());\n \n     return new Dimension (width, height);\n   }\n@@ -157,8 +169,11 @@ public Dimension preferredSize (int rows, int cols)\n     else\n       fm = new GdkFontMetrics (f);\n \n-    width += cols * fm.getMaxAdvance ();\n-    height += rows * (fm.getMaxDescent () + fm.getMaxAscent ());\n+    int sizeRows = rows == 0 ? DEFAULT_ROWS : rows;\n+    int sizeCols = cols == 0 ? DEFAULT_COLS : cols;\n+\n+    width += sizeCols * fm.getMaxAdvance ();\n+    height += sizeRows * (fm.getMaxDescent () + fm.getMaxAscent ());\n \n     return new Dimension (width, height);\n   }"}, {"sha": "8893e36e8382f357e3e4aaf3b63e4185e92b54e9", "filename": "libjava/gnu/java/awt/peer/gtk/GtkTextComponentPeer.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextComponentPeer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -54,6 +54,7 @@ public class GtkTextComponentPeer extends GtkComponentPeer\n     super (tc);\n \n     setText (tc.getText ());\n+    setCaretPosition(0);\n   }\n \n   public native void connectSignals ();"}, {"sha": "111c1f96979e7cf24ec7c540cfa3898ebf16f946", "filename": "libjava/gnu/java/awt/peer/gtk/GtkTextFieldPeer.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -60,7 +60,7 @@ void create ()\n     // GtkComponent.create.\n     if (f == null)\n       {\n-\tf = new Font (\"Fixed\", Font.PLAIN, 12);\n+\tf = new Font (\"Dialog\", Font.PLAIN, 12);\n \tawtComponent.setFont (f);\n       }\n "}, {"sha": "c55001591c4af546096b888732ff70dc26fdf906", "filename": "libjava/gnu/java/awt/peer/gtk/GtkToolkit.java", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -129,26 +129,58 @@ public int checkImage (Image image, int width, int height,\n \n   public Image createImage (String filename)\n   {\n-    return new GtkImage (new GdkPixbufDecoder (filename), null);\n+    if (useGraphics2D())\n+      return GdkPixbufDecoder.createBufferedImage (filename);\n+    else\n+      {\n+        GdkPixbufDecoder d = new GdkPixbufDecoder (filename);\n+        GtkImage image = new GtkImage (d, null);\n+        d.startProduction (image);\n+        return image;        \n+      }\n   }\n \n   public Image createImage (URL url)\n   {\n-    return new GtkImage (new GdkPixbufDecoder (url), null);\n+    if (useGraphics2D())\n+      return GdkPixbufDecoder.createBufferedImage (url);\n+    else\n+      {\n+        GdkPixbufDecoder d = new GdkPixbufDecoder (url);\n+        GtkImage image = new GtkImage (d, null);\n+        d.startProduction (image);\n+        return image;        \n+      }\n   }\n \n   public Image createImage (ImageProducer producer) \n   {\n-    return new GtkImage (producer, null);\n+    if (useGraphics2D())\n+      return GdkPixbufDecoder.createBufferedImage (producer);\n+    else\n+      {\n+        GtkImage image = new GtkImage (producer, null);\n+        producer.startProduction (image);\n+        return image;        \n+      }\n   }\n \n   public Image createImage (byte[] imagedata, int imageoffset,\n \t\t\t    int imagelength)\n   {\n-    return new GtkImage (new GdkPixbufDecoder (imagedata,\n-\t\t\t\t\t       imageoffset,\n-\t\t\t\t\t       imagelength),\n-\t\t\t null);\n+    if (useGraphics2D())\n+      return GdkPixbufDecoder.createBufferedImage (imagedata,\n+                                                   imageoffset, \n+                                                   imagelength);\n+    else\n+      {\n+        GdkPixbufDecoder d = new GdkPixbufDecoder (imagedata,\n+                                                   imageoffset, \n+                                                   imagelength);\n+        GtkImage image = new GtkImage (d, null);\n+        d.startProduction (image);\n+        return image;        \n+      }\n   }\n \n   public ColorModel getColorModel () \n@@ -175,18 +207,12 @@ public FontMetrics getFontMetrics (Font font)\n \n   public Image getImage (String filename) \n   {\n-    GdkPixbufDecoder d = new GdkPixbufDecoder (filename);\n-    GtkImage image = new GtkImage (d, null);\n-    d.startProduction (image);\n-    return image;\n+    return createImage (filename);\n   }\n \n   public Image getImage (URL url) \n   {\n-    GdkPixbufDecoder d = new GdkPixbufDecoder (url);\n-    GtkImage image = new GtkImage (d, null);\n-    d.startProduction (image);\n-    return image;\n+    return createImage (url);\n   }\n \n   public PrintJob getPrintJob (Frame frame, String jobtitle, Properties props) "}, {"sha": "5990c6392dad18f9ce26b5631b93e77e1a081527", "filename": "libjava/java/applet/Applet.java", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fapplet%2FApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fapplet%2FApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fapplet%2FApplet.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -77,11 +77,6 @@ public class Applet extends Panel\n   /** The applet stub for this applet. */\n   private transient AppletStub stub;\n \n-  /**\n-   * The dimensions passed to this applet through its HTML tag.\n-   */\n-  private transient Dimension dimensions;\n-\n   /**\n    * The accessibility context for this applet.\n    *\n@@ -462,41 +457,6 @@ private void readObject(ObjectInputStream s)\n     s.defaultReadObject();\n   }\n \n-  private Dimension getDimensions ()\n-  {\n-    if (dimensions == null)\n-      {\n-\tint width = Integer.parseInt(stub.getParameter(\"width\"));\n-\tint height = Integer.parseInt(stub.getParameter(\"height\"));\n-\n-\tdimensions = new Dimension(width, height);\n-      }\n-\n-    return dimensions;\n-  }\n-\n-  /**\n-   * Returns an instance of {@link Dimension} representing the\n-   * applet's width and height parameters.\n-   *\n-   * @return the applet's preferred size\n-   */\n-  public Dimension preferredSize()\n-  {\n-    return stub == null ? super.preferredSize () : getDimensions ();\n-  }\n-\n-  /**\n-   * Returns an instance of {@link Dimension} representing the\n-   * applet's width and height parameters.\n-   *\n-   * @return the applet's minimum size\n-   */\n-  public Dimension minimumSize()\n-  {\n-    return stub == null ? super.minimumSize () : getDimensions ();\n-  }\n-\n   /**\n    * This class provides accessibility support for Applets, and is the\n    * runtime type returned by {@link #getAccessibleContext()}."}, {"sha": "675c27f9511adcc5aae99f3bfad43d9b9101ab70", "filename": "libjava/java/awt/AWTEvent.java", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FAWTEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FAWTEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FAWTEvent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -238,8 +238,16 @@ public int getID()\n    */\n   public String toString ()\n   {\n-    return getClass ().getName () + \"[\" + paramString () + \"] on \"\n-      + ((Component) source).getName ();\n+    String string = null;\n+\n+    if (source instanceof Component)\n+      string = getClass ().getName () + \"[\" + paramString () + \"] on \"\n+        + ((Component) source).getName ();\n+    else if (source instanceof MenuComponent)\n+      string = getClass ().getName () + \"[\" + paramString () + \"] on \"\n+        + ((MenuComponent) source).getName ();\n+\n+    return string;\n   }\n \n   /**"}, {"sha": "a023cbb059b9398441016d3956686e8dc09afec7", "filename": "libjava/java/awt/BorderLayout.java", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FBorderLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FBorderLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FBorderLayout.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -592,13 +592,21 @@ else if (str.equals(AFTER_LINE_ENDS))\n \n       int x1 = i.left;\n       int x2 = x1 + w.width + hgap;\n-      int x3 = Math.max(x2 + w.width + hgap, t.width - i.right - e.width);\n+      int x3;\n+      if (t.width <= i.right + e.width)\n+        x3 = x2 + w.width + hgap;\n+      else\n+        x3 = t.width - i.right - e.width;\n       int ww = t.width - i.right - i.left;\n \n       int y1 = i.top;\n       int y2 = y1 + n.height + vgap;\n       int midh = Math.max(e.height, Math.max(w.height, c.height));\n-      int y3 = Math.max(y2 + midh + vgap, t.height - i.bottom - s.height);\n+      int y3;\n+      if (t.height <= i.bottom + s.height)\n+        y3 = y2 + midh + vgap;\n+      else\n+        y3 = t.height - i.bottom - s.height;\n       int hh = y3-y2-vgap;\n \n       setBounds(center, x2, y2, x3-x2-hgap, hh);"}, {"sha": "54b201ed1c44a6c5f67d2f302bed9c0e8aa7a713", "filename": "libjava/java/awt/Button.java", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FButton.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -81,6 +81,11 @@ public class Button extends Component implements java.io.Serializable\n // List of ActionListeners for this class.\n private transient ActionListener action_listeners;\n \n+  /*\n+   * The number used to generate the name returned by getName.\n+   */\n+  private static transient long next_button_number = 0;\n+\n /*************************************************************************/\n \n /*\n@@ -305,9 +310,24 @@ public EventListener[] getListeners(Class listenerType)\n protected String\n paramString()\n {\n-  return (\"label=\" + getLabel() + \",actionCommand=\" + getActionCommand()\n-\t  + \",\" + super.paramString());\n+  return getName () + \",\" + getX () + \",\" + getY () + \",\"\n+    + getWidth () + \"x\" + getHeight () + \",label=\" + getLabel ();\n }\n \n+  /**\n+   * Generate a unique name for this button.\n+   *\n+   * @return A unique name for this button.\n+   */\n+  String generateName ()\n+  {\n+    return \"button\" + getUniqueLong ();\n+  }\n+\n+  private static synchronized long getUniqueLong ()\n+  {\n+    return next_button_number++;\n+  }\n+\n } // class Button \n "}, {"sha": "f3153da59116efc0140780060757858fce2eda12", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -941,7 +941,7 @@ public Color getForeground()\n   {\n     if (foreground != null)\n       return foreground;\n-    return parent == null ? null : parent.getForeground();\n+    return parent == null ? SystemColor.windowText : parent.getForeground();\n   }\n \n   /**\n@@ -982,7 +982,7 @@ public Color getBackground()\n   {\n     if (background != null)\n       return background;\n-    return parent == null ? null : parent.getBackground();\n+    return parent == null ? SystemColor.window : parent.getBackground();\n   }\n \n   /**\n@@ -1031,7 +1031,7 @@ public Font getFont()\n     if (parent != null)\n       return parent.getFont ();\n     else\n-      return new Font (\"Fixed\", Font.PLAIN, 12);\n+      return new Font (\"Dialog\", Font.PLAIN, 12);\n   }\n \n   /**"}, {"sha": "ffd81b468029e06d0b9e56b4116c894cf0499685", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -876,11 +876,6 @@ public Component getComponentAt(int x, int y)\n   {\n     return locate (x, y);\n   }\n-  \n-  public Component getComponentAt(int index)\n-  {\n-    return component[index];\n-  }\n \n   /**\n    * Returns the component located at the specified point.  This is done"}, {"sha": "b98359c1bdb1d00761230f43d1ae5b29c2c12d07", "filename": "libjava/java/awt/GridBagLayout.java", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayout.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -790,13 +790,26 @@ else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n                                   info.rowWeights);\n         } // end of STEP 4\n \n-      calcCellSizes (info.colWidths, info.colWeights, parentDim.width);\n-      calcCellSizes (info.rowHeights, info.rowWeights, parentDim.height);\n+      // Adjust cell sizes iff parent size not zero.\n+      if (parentDim.width > 0 && parentDim.height > 0)\n+        {\n+          calcCellSizes (info.colWidths, info.colWeights, parentDim.width);\n+          calcCellSizes (info.rowHeights, info.rowWeights, parentDim.height);\n+        }\n \n       int totalWidth = sumIntArray(info.colWidths);\n       int totalHeight = sumIntArray(info.rowHeights);\n-      info.pos_x = parentInsets.left + (parentDim.width - totalWidth) / 2;\n-      info.pos_y = parentInsets.top + (parentDim.height - totalHeight) / 2;\n+\n+      // Make sure pos_x and pos_y are never negative.\n+      if (totalWidth >= parentDim.width)\n+        info.pos_x = parentInsets.left;\n+      else\n+        info.pos_x = parentInsets.left + (parentDim.width - totalWidth) / 2;\n+\n+      if (totalHeight >= parentDim.height)\n+        info.pos_y = parentInsets.top;\n+      else\n+        info.pos_y = parentInsets.top + (parentDim.height - totalHeight) / 2;\n \n       // DEBUG\n       //dumpLayoutInfo (info);"}, {"sha": "d1df8b38360748fd9e51732decd5bb2cfcb4bc6a", "filename": "libjava/java/awt/MediaTracker.java", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FMediaTracker.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FMediaTracker.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMediaTracker.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -81,12 +81,17 @@ else if ((flags & ERROR) != 0)\n         status = ERRORED | COMPLETE;\n       else if ((flags & ALLBITS) != 0)\n         status = COMPLETE;\n-      else\n+      else if ((flags & SOMEBITS) != 0)\n         status = LOADING;\n-      \n-      synchronized (MediaTracker.this)\n+      else\n+        status = 0;\n+\n+      if ((status & COMPLETE) == COMPLETE)\n       {\n-\tMediaTracker.this.notifyAll();\n+        synchronized (MediaTracker.this)\n+        {\n+          MediaTracker.this.notifyAll();\n+        }\n       }\n       // If status is not COMPLETE then we need more updates.\n       return (status & COMPLETE) == 0;\n@@ -106,7 +111,8 @@ public void addImage(Image image, int id)\n     e.next = head;\n     head = e;\n     // Start tracking image status.\n-    target.checkImage(image, e);\n+    int flags = target.checkImage(image, e);\n+    e.imageUpdate(image, flags, -1, -1, -1, -1);\n   }\n \n   public void addImage(Image image, int id, int width, int height)\n@@ -119,7 +125,8 @@ public void addImage(Image image, int id, int width, int height)\n     e.height = height;\n     head = e;\n     // Start tracking image status.\n-    target.checkImage(image, width, height, e);\n+    int flags = target.checkImage(image, width, height, e);\n+    e.imageUpdate(image, flags, -1, -1, width, height);\n   }\n \n   public boolean checkAll()"}, {"sha": "8511f698fad92ff0d076b16a9d71619b104c0731", "filename": "libjava/java/awt/MenuItem.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenuItem.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -424,6 +424,11 @@ public EventListener[] getListeners(Class listenerType)\n       && (action_listeners != null\n \t  || (eventMask & AWTEvent.ACTION_EVENT_MASK) != 0))\n     processEvent(e);\n+\n+  // Send the event to the parent menu if it has not yet been\n+  // consumed.\n+  if (!e.isConsumed ())\n+    ((Menu) getParent ()).processEvent (e);\n }\n \n /**"}, {"sha": "6355376df5248bafe890ed8a891a851959057471", "filename": "libjava/java/awt/TextArea.java", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextArea.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -103,29 +103,33 @@ public class TextArea extends TextComponent implements java.io.Serializable\n   private static transient long next_text_number = 0;\n \n   /**\n-   * Initialize a new instance of <code>TextArea</code> that is empty\n-   * and is one row by one column.  Both horizontal and vertical\n+   * Initialize a new instance of <code>TextArea</code> that is empty.\n+   * Conceptually the <code>TextArea</code> has 0 rows and 0 columns\n+   * but its initial bounds are defined by its peer or by the\n+   * container in which it is packed.  Both horizontal and vertical\n    * scrollbars will be displayed.\n    *\n-   * @exception HeadlessException If GraphicsEnvironment.isHeadless () is true,\n+   * @exception HeadlessException if GraphicsEnvironment.isHeadless () is true\n    */\n   public TextArea ()\n   {\n-    this (\"\", 1, 1, SCROLLBARS_BOTH);\n+    this (\"\", 0, 0, SCROLLBARS_BOTH);\n   }\n \n   /**\n-   * Initialize a new instance of <code>TextArea</code> that initially\n-   * contains the specified text.  Both horizontal and veritcal\n-   * scrollbars will be displayed.\n+   * Initialize a new instance of <code>TextArea</code> that contains\n+   * the specified text.  Conceptually the <code>TextArea</code> has 0\n+   * rows and 0 columns but its initial bounds are defined by its peer\n+   * or by the container in which it is packed.  Both horizontal and\n+   * veritcal scrollbars will be displayed.\n    *\n    * @param text The text to display in this text area.\n    *\n-   * @exception HeadlessException If GraphicsEnvironment.isHeadless () is true,\n+   * @exception HeadlessException if GraphicsEnvironment.isHeadless () is true\n    */\n   public TextArea (String text)\n   {\n-    this (text, 1, text.length (), SCROLLBARS_BOTH);\n+    this (text, 0, 0, SCROLLBARS_BOTH);\n   }\n \n   /**\n@@ -137,7 +141,7 @@ public TextArea (String text)\n    * @param rows The number of rows in this text area.\n    * @param columns The number of columns in this text area.\n    *\n-   * @exception HeadlessException If GraphicsEnvironment.isHeadless () is true,\n+   * @exception HeadlessException if GraphicsEnvironment.isHeadless () is true\n    */\n   public TextArea (int rows, int columns)\n   {\n@@ -154,7 +158,7 @@ public TextArea (int rows, int columns)\n    * @param rows The number of rows in this text area.\n    * @param columns The number of columns in this text area.\n    *\n-   * @exception HeadlessException If GraphicsEnvironment.isHeadless () is true,\n+   * @exception HeadlessException if GraphicsEnvironment.isHeadless () is true\n    */\n   public TextArea (String text, int rows, int columns)\n   {\n@@ -175,7 +179,7 @@ public TextArea (String text, int rows, int columns)\n    * SCROLLBARS_BOTH, SCROLLBARS_VERTICAL_ONLY,\n    * SCROLLBARS_HORIZONTAL_ONLY, SCROLLBARS_NONE.\n    *\n-   * @exception HeadlessException If GraphicsEnvironment.isHeadless () is true,\n+   * @exception HeadlessException if GraphicsEnvironment.isHeadless () is true\n    */\n   public TextArea (String text, int rows, int columns, int scrollbarVisibility)\n   {\n@@ -184,7 +188,7 @@ public TextArea (String text, int rows, int columns, int scrollbarVisibility)\n     if (GraphicsEnvironment.isHeadless ())\n       throw new HeadlessException ();\n \n-    if (rows < 1 || columns < 0)\n+    if (rows < 0 || columns < 0)\n       throw new IllegalArgumentException (\"Bad row or column value\");\n \n     if (scrollbarVisibility != SCROLLBARS_BOTH"}, {"sha": "9cdb507f30ae9123b1b33b63a512af9668b25d7c", "filename": "libjava/java/awt/TextComponent.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FTextComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjava%2Fawt%2FTextComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextComponent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -141,6 +141,7 @@ public class TextComponent extends Component\n   TextComponentPeer tcp = (TextComponentPeer)getPeer();\n   if (tcp != null)\n     tcp.setText(text);\n+  setCaretPosition(0);\n }\n \n /*************************************************************************/"}, {"sha": "d7518998273d97f63837d5d9bd7bf85e04e8cfba", "filename": "libjava/javax/swing/AbstractAction.java", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FAbstractAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FAbstractAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractAction.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -60,6 +60,8 @@\n    * enabled\n    */\n   protected boolean enabled = true;\n+  \n+  public static final String ENABLED_PROPERTY = \"enabled\";\n \n   /**\n    * changeSupport\n@@ -162,7 +164,12 @@ public Object getValue(String key)\n    */\n   public void putValue(String key, Object value)\n   {\n-    store.put(key, value);\n+    Object old = getValue(key);\n+    if (old != value)\n+    {\n+      store.put(key, value);\n+      firePropertyChange(key, old, value);\n+    }\n   }\n \n   /**\n@@ -182,7 +189,11 @@ public boolean isEnabled()\n    */\n   public void setEnabled(boolean enabled)\n   {\n-    this.enabled = enabled;\n+    if (enabled != this.enabled)\n+    {\n+      this.enabled = enabled;\n+      firePropertyChange(ENABLED_PROPERTY, !this.enabled, this.enabled);\n+    }\n   }\n \n   /**\n@@ -195,17 +206,31 @@ public Object[] getKeys()\n   }\n \n   /**\n-   * firePropertyChange\n+   * This method fires a PropertyChangeEvent given the propertyName \n+   * and the old and new values.\n    *\n-   * @param propertyName TODO\n-   * @param oldValue TODO\n-   * @param newValue TODO\n+   * @param propertyName The property that changed.\n+   * @param oldValue The old value of the property.\n+   * @param newValue The new value of the property.\n    */\n   protected void firePropertyChange(String propertyName, Object oldValue,\n                                     Object newValue)\n   {\n     changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n   }\n+  \n+  /**\n+   * This convenience method fires a PropertyChangeEvent given \n+   * the propertyName and the old and new values.\n+   *\n+   * @param propertyName The property that changed.\n+   * @param oldValue The old value of the property.\n+   * @param newValue The new value of the property.\n+   */\n+  private void firePropertyChange(String propertyName, boolean oldValue, boolean newValue)\n+  {\n+    changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n+  }\n \n   /**\n    * addPropertyChangeListener"}, {"sha": "745afc92467989e8efd35d732f23810a1913a5a4", "filename": "libjava/javax/swing/AbstractButton.java", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractButton.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -154,6 +154,8 @@\n public abstract class AbstractButton extends JComponent\n   implements ItemSelectable, SwingConstants\n {\n+  private static final long serialVersionUID = -937921345538462020L;\n+  \n   /** The icon displayed by default. */\n   Icon default_icon;\n \n@@ -292,9 +294,10 @@ public abstract class AbstractButton extends JComponent\n     extends AccessibleJComponent implements AccessibleAction, AccessibleValue,\n                                             AccessibleText\n   {\n-    protected AccessibleAbstractButton(JComponent c)\n+    private static final long serialVersionUID = -5673062525319836790L;\n+    \n+    protected AccessibleAbstractButton()\n     {\n-      super(c);\n     }\n \n     public AccessibleStateSet getAccessibleStateSet()\n@@ -459,7 +462,7 @@ public void focusGained(FocusEvent event)\n   /**\n    * Creates a new AbstractButton object.\n    */\n-  AbstractButton()\n+  public AbstractButton()\n   {\n     this(\"\",null);\n   }\n@@ -472,28 +475,7 @@ public void focusGained(FocusEvent event)\n    */\n   AbstractButton(String txt, Icon icon)\n   {\n-    text = txt;\n-    default_icon = icon;\n-    model = new DefaultButtonModel();\n-    actionListener = createActionListener();\n-    changeListener = createChangeListener();\n-    itemListener = createItemListener();\n-\n-    model.addActionListener(actionListener);\n-    model.addChangeListener(changeListener);\n-    model.addItemListener(itemListener);\n-\n-    hori_align = CENTER;\n-    hori_text_pos = TRAILING;\n-    vert_align = CENTER;\n-    vert_text_pos = CENTER;\n-    paint_border = true;\n-    content_area_filled = true;\n-\n-    setAlignmentX(LEFT_ALIGNMENT);\n-    setAlignmentY(CENTER_ALIGNMENT);\n-\n-    addFocusListener(new ButtonFocusListener());\n+    init (txt, icon);\n     updateUI();\n   }\n \n@@ -538,6 +520,32 @@ public void setModel(ButtonModel newModel)\n     repaint();\n   }\n \n+ protected void init(String text, Icon icon) \n+ {\n+    this.text = text;\n+    default_icon = icon;\n+    model = new DefaultButtonModel();\n+    actionListener = createActionListener();\n+    changeListener = createChangeListener();\n+    itemListener = createItemListener();\n+\n+    model.addActionListener(actionListener);\n+    model.addChangeListener(changeListener);\n+    model.addItemListener(itemListener);\n+\n+    hori_align = CENTER;\n+    hori_text_pos = TRAILING;\n+    vert_align = CENTER;\n+    vert_text_pos = CENTER;\n+    paint_border = true;\n+    content_area_filled = true;\n+\n+    setAlignmentX(LEFT_ALIGNMENT);\n+    setAlignmentY(CENTER_ALIGNMENT);\n+\n+    addFocusListener(new ButtonFocusListener());\n+ }\n+ \n   /**\n    * Get the action command string for this button's model.\n    *\n@@ -1036,15 +1044,17 @@ public void setAction(Action a)\n             action.removePropertyChangeListener(actionPropertyChangeListener);\n             actionPropertyChangeListener = null;\n           }\n-        actionPropertyChangeListener = createActionPropertyChangeListener(a);\n+\n+\n   }\n+  \n \n     Action old = action;\n     action = a;\n     configurePropertiesFromAction(action);\n-\n     if (action != null)\n       {\n+        actionPropertyChangeListener = createActionPropertyChangeListener(a);      \n         action.addPropertyChangeListener(actionPropertyChangeListener);\n         addActionListener(action);\n       }\n@@ -1067,15 +1077,15 @@ public Icon getIcon()\n    * @param i The new default icon\n    */\n   public void setIcon(Icon i)\n+  {\n+    if (default_icon != i)\n       {\n-    Icon old = default_icon;\n-    default_icon = i;\n-    if (old != i)\n-      {\n-        firePropertyChange(ICON_CHANGED_PROPERTY, old, i);\n+    Icon old = default_icon;      \n+    default_icon = i;      \n+    firePropertyChange(ICON_CHANGED_PROPERTY, old, i);\n     revalidate();\n     repaint();\n-  }\n+      }\n   }\n \n   /**\n@@ -1204,6 +1214,10 @@ public void setPressedIcon(Icon pressedIcon)\n    */\n   public Icon getDisabledIcon()\n   {\n+    if (disabled_icon == null\n+\t&& default_icon instanceof ImageIcon)\n+      disabled_icon = new ImageIcon(GrayFilter.createDisabledImage(((ImageIcon) default_icon).getImage()));\n+      \n     return disabled_icon;\n   }\n \n@@ -1375,7 +1389,8 @@ protected  void configurePropertiesFromAction(Action a)\n         setIcon((Icon)(a.getValue(Action.SMALL_ICON)));\n         setEnabled(a.isEnabled());\n         setToolTipText((String)(a.getValue(Action.SHORT_DESCRIPTION)));\n-        setMnemonic(((Integer)(a.getValue(Action.MNEMONIC_KEY))).intValue());\n+\tif (a.getValue(Action.MNEMONIC_KEY) != null)\n+          setMnemonic(((Integer)(a.getValue(Action.MNEMONIC_KEY))).intValue());\n         setActionCommand((String)(a.getValue(Action.ACTION_COMMAND_KEY)));\n       }\n   }\n@@ -1433,9 +1448,21 @@ protected  PropertyChangeListener createActionPropertyChangeListener(Action a)\n       {\n         public void propertyChange(PropertyChangeEvent e)\n         {\n-          Action act = (Action)(e.getSource());\n-          AbstractButton.this.configurePropertiesFromAction(act);\n-        }\n+          Action act = (Action) (e.getSource());\t\n+\t  if (e.getPropertyName().equals(AbstractAction.ENABLED_PROPERTY))\n+\t    setEnabled(act.isEnabled());\n+\t  else if (e.getPropertyName().equals(Action.NAME))\n+            setText((String)(act.getValue(Action.NAME)));\n+\t  else if (e.getPropertyName().equals(Action.SMALL_ICON))\n+\t    setIcon((Icon)(act.getValue(Action.SMALL_ICON)));\n+\t  else if (e.getPropertyName().equals(Action.SHORT_DESCRIPTION))\n+            setToolTipText((String)(act.getValue(Action.SHORT_DESCRIPTION)));\n+\t  else if (e.getPropertyName().equals(Action.MNEMONIC_KEY))\n+            if (act.getValue(Action.MNEMONIC_KEY) != null)\n+              setMnemonic(((Integer)(act.getValue(Action.MNEMONIC_KEY))).intValue());\n+\t  else if (e.getPropertyName().equals(Action.ACTION_COMMAND_KEY))\n+            setActionCommand((String)(act.getValue(Action.ACTION_COMMAND_KEY)));\n+\t}\n       };\n   }\n "}, {"sha": "f5d090e0b9d01121942a134ceb862c921ba6ec41", "filename": "libjava/javax/swing/Box.java", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FBox.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* Box.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -55,8 +55,12 @@ public class Box extends JComponent implements Accessible\n {\n   private static final long serialVersionUID = 1525417495883046342L;\n   \n-  protected class AccessibleBox extends AccessibleAWTContainer\n+  protected class AccessibleBox \n+  // FIXME: disable to make libjava compile; visibility rules are broken\n+  // extends Container.AccessibleAWTContainer\n   {\n+    private static final long serialVersionUID = -7775079816389931944L;\n+  \n     protected AccessibleBox()\n     {\n     }\n@@ -69,8 +73,14 @@ public AccessibleRole getAccessibleRole()\n   \n   public static class Filler extends JComponent implements Accessible\n   {\n-    protected class AccessibleBoxFiller// extends AccessibleAWTComponent\n+    private static final long serialVersionUID = -1204263191910183998L;\n+  \n+    protected class AccessibleBoxFiller \n+    // FIXME: disable to make libjava compile; visibility rules are broken\n+    // extends Component.AccessibleAWTComponent\n     {\n+      private static final long serialVersionUID = 164963348357479321L;\n+      \n       protected AccessibleBoxFiller()\n       {\n       }\n@@ -99,8 +109,9 @@ public void changeShape(Dimension min, Dimension pref, Dimension max)\n     \n     public AccessibleContext getAccessibleContext()\n     {\n-//      if (accessibleContext == null)\n-//        accessibleContext = new AccessibleBoxFiller();\n+      // FIXME: disable to make libjava compile; visibility rules are broken      \n+      //      if (accessibleContext == null)\n+      //        accessibleContext = new AccessibleBoxFiller();\n       return accessibleContext;\n     }\n     \n@@ -172,8 +183,8 @@ public void setLayout(LayoutManager l)\n   \n   public AccessibleContext getAccessibleContext()\n   {\n-    if (accessibleContext == null)\n-      accessibleContext = new AccessibleBox();\n+    //     if (accessibleContext == null)\n+    //       accessibleContext = new AccessibleBox();\n     return accessibleContext;\n   }\n   "}, {"sha": "8202fa6cb8279bcacfd6829469858b808b900420", "filename": "libjava/javax/swing/ButtonGroup.java", "status": "modified", "additions": 135, "deletions": 87, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FButtonGroup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FButtonGroup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FButtonGroup.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* ButtonGroup.java -- \n+/* ButtonGroup.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,97 +35,145 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.io.Serializable;\n import java.util.Enumeration;\n import java.util.Vector;\n \n-public class ButtonGroup implements Serializable \n-{\n-  static final long serialVersionUID = 4259076101881721375L;\n-\n-    Vector v = new Vector();\n-    ButtonModel sel;\n-    \n-    public ButtonGroup() {}\n-    \n-    public void add(AbstractButton b) \n-    {\n-\tb.getModel().setGroup(this);\n-\tv.addElement(b);\n-    }\n-    \n-    public void remove(AbstractButton b)\n-    {\n-\tb.getModel().setGroup(null);\n-\tv.removeElement(b);\n-    }\n-\n-\n-    public Enumeration getElements() {\n-        return v.elements();\n-    }\n-\n-    public ButtonModel getSelection() {\n-        return sel;\n-    }\n-\n-    AbstractButton FindButton(ButtonModel m)\n-    {\n-\tfor (int i=0;i<v.size();i++)\n-\t    {\n-\t    AbstractButton a = (AbstractButton) v.get(i);\n-\t    if (a.getModel()== m)\n-\t    {\n-\t\treturn a;\n-\t    }\n-\t}\n-\treturn null;\n-    }\n-\n-    public void setSelected(ButtonModel m, boolean b)\n-    {\n-\tif ((m == sel) &&\n-\t    (b == true))\n-\t    {\n-\t\t// clicked on sam item twice.\n-\t\tSystem.out.println(\"PRESSED TWICE:\" + m + \", sel=\"+sel);\n-\t\treturn;\n-\t    }\t\n-\t\n-\tif (sel != null)\n-\t    {\n-\n-\t\tSystem.out.println(\"DESELECTING: \" + sel);\n-\t\tsel.setSelected(!b);\n-\n-\t\tAbstractButton but = FindButton(sel);\n-\t\tif (but != null)\n-\t\t    {\n-\t\t\tSystem.out.println(\"REPAINT-REQUIST: \" + but.text);\n-\t\t\t//but.revalidate();\n-\t\t\tbut.repaint();\n-\t\t    }\n-\t    }\n-\telse\n-\t    {\n-\t\tSystem.out.println(\"NO SELECTION YET\");\n-\t    }\n-\t\n-\tsel = m;\n-    }\n-    \n-    public boolean isSelected(ButtonModel m) \n-    {\n-        return (m == sel);\n-    }\n-\n-    public int getButtonCount() \n-    {\n-\treturn v.size();\n-    }\n \n+public class ButtonGroup\n+  implements Serializable\n+{\n+  private static final long serialVersionUID = 4259076101881721375L;\n+\n+  /**\n+   * The buttons added to this button group.\n+   */\n+  protected Vector buttons = new Vector();\n+\n+  /**\n+   * The currently selected button model.\n+   */\n+  ButtonModel sel;\n+\n+  /**\n+   * Creates a new button group.\n+   */\n+  public ButtonGroup()\n+  {\n+  }\n+\n+  /**\n+   * Adds a button to this group.\n+   *\n+   * @param b the button to add\n+   */\n+  public void add(AbstractButton b)\n+  {\n+    b.getModel().setGroup(this);\n+    buttons.addElement(b);\n+  }\n+\n+  /**\n+   * Removed a given button from this group.\n+   *\n+   * @param b the button to remove\n+   */\n+  public void remove(AbstractButton b)\n+  {\n+    b.getModel().setGroup(null);\n+    buttons.removeElement(b);\n+  }\n+\n+  /**\n+   * Returns the currently added buttons.\n+   *\n+   * @return <code>Enumeration</code> over all added buttons\n+   */\n+  public Enumeration getElements()\n+  {\n+    return buttons.elements();\n+  }\n+\n+  /**\n+   * Returns the currently selected button model.\n+   *\n+   * @return the currently selected button model,\n+   * null if none was selected yet\n+   */\n+  public ButtonModel getSelection()\n+  {\n+    return sel;\n+  }\n+\n+  AbstractButton FindButton(ButtonModel m)\n+  {\n+    for (int i = 0;i < buttons.size(); i++)\n+      {\n+\tAbstractButton a = (AbstractButton) buttons.get(i);\n+\tif (a.getModel() == m)\n+\t  return a;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Sets the currently selected button model. Only one button of a group\n+   * can be selected at a time.\n+   *\n+   * @param m the model to select\n+   * @param b true if this button is to be selected, false otherwise\n+   */\n+  public void setSelected(ButtonModel m, boolean b)\n+  {\n+    if ((m == sel) && (b == true))\n+      {\n+\t// clicked on same item twice.\n+\tSystem.out.println(\"PRESSED TWICE:\" + m + \", sel=\" + sel);\n+\treturn;\n+      }\n+\n+    if (sel != null)\n+      {\n+\tSystem.out.println(\"DESELECTING: \" + sel);\n+\tsel.setSelected(! b);\n+\n+\tAbstractButton but = FindButton(sel);\n+\tif (but != null)\n+\t  {\n+\t    System.out.println(\"REPAINT-REQUEST: \" + but.text);\n+\t    //but.revalidate();\n+\t    but.repaint();\n+\t  }\n+      }\n+    else\n+      System.out.println(\"NO SELECTION YET\");\n+\n+    sel = m;\n+  }\n+\n+  /**\n+   * Checks if the given <code>ButtonModel</code> is selected\n+   * in this button group.\n+   *\n+   * @return true of given <code>ButtonModel</code> is selected,\n+   * false otherwise\n+   */\n+  public boolean isSelected(ButtonModel m)\n+  {\n+    return m == sel;\n+  }\n+\n+  /**\n+   * Return the number of buttons in this button group.\n+   *\n+   * @return the number of buttons\n+   *\n+   * @since 1.3\n+   */\n+  public int getButtonCount()\n+  {\n+    return buttons.size();\n+  }\n }\n-"}, {"sha": "246916d01d922650b602a2bd60e410bb31f923cc", "filename": "libjava/javax/swing/CellRendererPane.java", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FCellRendererPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FCellRendererPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FCellRendererPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -56,50 +56,30 @@ public class CellRendererPane extends Container implements Accessible\n {\n   private static final long serialVersionUID = -7642183829532984273L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleCellRendererPane\n-\t */\n-\tprotected class AccessibleCellRendererPane extends AccessibleAWTContainer {\n-\n-          private static final long serialVersionUID = 7300340301783504481L;\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleCellRendererPane\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleCellRendererPane(CellRendererPane component) {\n-\t\t\tsuper();\n-\t\t\t// TODO\n-\t\t} // AccessibleCellRendererPane()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.PANEL;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleCellRendererPane\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+  /**\n+   * AccessibleCellRendererPane\n+   */\n+  protected class AccessibleCellRendererPane extends AccessibleAWTContainer\n+  {\n+    private static final long serialVersionUID = -8981090083147391074L;\n+\n+    /**\n+     * Constructor AccessibleCellRendererPane\n+     * @param component TODO\n+     */\n+    protected AccessibleCellRendererPane()\n+    {\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     * @returns AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.PANEL;\n+    }\n+  }\n \n \t/**\n \t * accessibleContext\n@@ -209,16 +189,15 @@ public void paintComponent(Graphics graphics, Component c,\n \t\t// TODO\n \t} // paintComponent()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleCellRendererPane(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // CellRendererPane\n+  /**\n+   * getAccessibleContext\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleCellRendererPane();\n+\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "e9a1356e8a634aa9445f4c88320067cd3d2905bc", "filename": "libjava/javax/swing/DefaultButtonModel.java", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -41,6 +41,7 @@\n import java.awt.event.ActionListener;\n import java.awt.event.ItemEvent;\n import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n import java.io.Serializable;\n import java.util.EventListener;\n \n@@ -80,56 +81,52 @@ public class DefaultButtonModel implements ButtonModel, Serializable\n   /** Indicates that the button is <em>partially</em> committed to being\n    pressed, but not entirely. This usually happens when a user has pressed\n    but not yet released the mouse button. */\n-  static int ARMED = 1;\n+  public static final int ARMED = 1;\n \n   /** State constant indicating that the button is enabled. Buttons cannot\n    be pressed or selected unless they are enabled. */\n-  static int ENABLED = 2;\n+  public static final int ENABLED = 8;\n \n   /** State constant indicating that the user is holding down the button.\n    When this transitions from true to false, an ActionEvent may be fired,\n    depending on the value of the \"armed\" property.*/\n-  static int PRESSED = 4;\n+  public static final int PRESSED = 4;\n \n   /** State constant indicating that the mouse is currently positioned over\n       the button. */\n-  static int ROLLOVER = 8;\n+  public static final int ROLLOVER = 16;\n \n   /** State constant indicating that the button is selected. This constant\n       is only meaningful for toggle-type buttons (radio buttons,\n       checkboxes). */\n-  static int SELECTED = 16;\n+  public static final int SELECTED = 2;\n \n   /** Represents the \"state properties\" (armed, enabled, pressed, rollover\n       and selected) by a bitwise combination of integer constants. */\n-  int stateMask;\n+  protected int stateMask = ENABLED;\n \n   /** List of ItemListeners, ChangeListeners, and ActionListeners\n       registered on this model. */\n-  EventListenerList listenerList;\n+  protected EventListenerList listenerList = new EventListenerList();;\n \n   /** The single ChangeEvent this model (re)uses to call its\n       ChangeListeners. */\n-  ChangeEvent changeEvent;\n+  protected ChangeEvent changeEvent = new ChangeEvent(this);\n \n   /** The group this model belongs to. Only one button in a group may be\n       selected at any given time. */\n-  ButtonGroup group;\n+  protected ButtonGroup group;\n   \n   /** The key code (one of {@link java.awt.event.KeyEvent} VK_*) used to\n       press this button via a keyboard interface. */\n-  int mnemonic;\n+  protected int mnemonic = KeyEvent.VK_UNDEFINED;\n \n   /** The string used as the \"command\" property of any ActionEvent this\n       model sends. */\n-  String actionCommand;\n+  protected String actionCommand;\n \n   public DefaultButtonModel()\n   {\n-    stateMask = ENABLED;\n-    mnemonic = java.awt.event.KeyEvent.VK_UNDEFINED;\n-    listenerList = new EventListenerList();    \n-    changeEvent = new ChangeEvent(this);\n   }\n \n   /**\n@@ -143,6 +140,18 @@ public Object[] getSelectedObjects()\n \treturn null;\n     }\n \n+  /**\n+   * Returns a specified class of listeners.\n+   *\n+   * @param listenerType the type of listener to return\n+   *\n+   * @return array of listeners\n+   */\n+  public EventListener[] getListeners(Class listenerType)\n+  {\n+    return listenerList.getListeners(listenerType);\n+  }\n+  \n   /**\n    * Add an ActionListener to the model. Usually only called to subscribe\n    * an AbstractButton's listener to the model.\n@@ -165,6 +174,16 @@ public void removeActionListener(ActionListener l)\n     listenerList.remove(ActionListener.class, l);\n   }\n \n+  /**\n+   * Returns all registered <code>ActionListener</code> objects.\n+   *\n+   * @return array of <code>ActionListener</code> objects\n+   */\n+  public ActionListener[] getActionListeners()\n+  {\n+    return (ActionListener[]) listenerList.getListeners(ActionListener.class);\n+  }\n+\n   /**\n    * Add an ItemListener to the model. Usually only called to subscribe\n    * an AbstractButton's listener to the model.\n@@ -187,6 +206,16 @@ public void removeItemListener(ItemListener l)\n     listenerList.remove(ItemListener.class, l);\n   }\n \n+  /**\n+   * Returns all registered <code>ItemListener</code> objects.\n+   *\n+   * @return array of <code>ItemListener</code> objects\n+   */\n+  public ItemListener[] getItemListeners()\n+  {\n+    return (ItemListener[]) listenerList.getListeners(ItemListener.class);\n+  }\n+\n   /**\n    * Add a ChangeListener to the model. Usually only called to subscribe\n    * an AbstractButton's listener to the model.\n@@ -209,6 +238,16 @@ public void removeChangeListener(ChangeListener l)\n     listenerList.remove(ChangeListener.class, l);\n   }\n \n+  /**\n+   * Returns all registered <code>ChangeListener</code> objects.\n+   *\n+   * @return array of <code>ChangeListener</code> objects\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n+  }\n+\n   /**\n    * Inform each ItemListener in the {@link listenerList} that an ItemEvent\n    * has occurred. This happens in response to any change to the {@link\n@@ -218,9 +257,10 @@ public void removeChangeListener(ChangeListener l)\n    */\n   public void fireItemStateChanged(ItemEvent e)\n   {\n-    EventListener[] ll = listenerList.getListeners(ItemListener.class);\n+    ItemListener[] ll = getItemListeners();\n+    \n     for (int i = 0; i < ll.length; i++)\n-      ((ItemListener)ll[i]).itemStateChanged(e);\n+      ll[i].itemStateChanged(e);\n   }\n \n   /**\n@@ -233,9 +273,10 @@ public void fireItemStateChanged(ItemEvent e)\n    */\n   public void fireActionPerformed(ActionEvent e)\n   {\n-    EventListener[] ll = listenerList.getListeners(ActionListener.class);\n+    ActionListener[] ll = getActionListeners();\n+    \n     for (int i = 0; i < ll.length; i++)\n-      ((ActionListener)ll[i]).actionPerformed(e);\n+      ll[i].actionPerformed(e);\n   }\n \n   /**\n@@ -245,11 +286,12 @@ public void fireActionPerformed(ActionEvent e)\n    *\n    * @param event The ChangeEvent to fire\n    */\n-  public void fireStateChanged(ChangeEvent e)\n+  public void fireStateChanged()\n   {\n-    EventListener[] ll = listenerList.getListeners(ChangeListener.class);\n+    ChangeListener[] ll = getChangeListeners();\n+    \n     for (int i = 0; i < ll.length; i++)\n-      ((ChangeListener)ll[i]).stateChanged(e);\n+      ll[i].stateChanged(changeEvent);\n   }\n \n   /**\n@@ -276,7 +318,7 @@ protected void changeState(int stateflag, boolean b)\n \n     stateMask = newstate;\n \n-    fireStateChanged(changeEvent);\n+    fireStateChanged();\n \n     if ((oldstate & SELECTED) == 0\n         && (newstate & SELECTED) == SELECTED)\n@@ -418,7 +460,7 @@ public void setMnemonic(int key)\n     if (mnemonic != key)\n       {\n         mnemonic = key;\n-        fireStateChanged(changeEvent);\n+        fireStateChanged();\n       }\n   }\n   \n@@ -434,14 +476,12 @@ public void setActionCommand(String s)\n     if (actionCommand != s)\n       {\n         actionCommand = s;\n-        fireStateChanged(changeEvent);\n+        fireStateChanged();\n       }\n   } \n   \n   /**\n-   * Set the value of the model's \"actionCommand\" property. This property\n-   * is used as the \"command\" property of the {@link ActionEvent} fired\n-   * from the model.\n+   * Returns the current value of the model's \"actionCommand\" property.\n    *\n    * @return The current \"actionCommand\" property\n    */\n@@ -453,7 +493,7 @@ public String getActionCommand()\n   /**\n    * Set the value of the model's \"group\" property. The model is said to be\n    * a member of the {@link ButtonGroup} held in its \"group\" property, and\n-   * only one models in a given group can have their \"selected\" property be\n+   * only one model in a given group can have their \"selected\" property be\n    * <code>true</code> at a time.\n    *\n    * @param g The new \"group\" property\n@@ -463,7 +503,17 @@ public void setGroup(ButtonGroup g)\n     if (group != g)\n       {\n         group = g;\n-        fireStateChanged(changeEvent);\n+        fireStateChanged();\n       }\n   }\n+\n+  /**\n+   * Returns the current value of the model's \"group\" property.\n+   *\n+   * @return The value of the \"group\" property\n+   */\n+  public ButtonGroup getGroup()\n+  {\n+    return group;\n+  }\n }"}, {"sha": "39da1fb9f8e8179685feb6aea81a75841fdf2d84", "filename": "libjava/javax/swing/DefaultCellEditor.java", "status": "modified", "additions": 29, "deletions": 62, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultCellEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultCellEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultCellEditor.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -58,50 +58,34 @@\n {\n   static final long serialVersionUID = 3564035141373880027L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * EditorDelegate\n-\t */\n-\tprotected class EditorDelegate implements ActionListener, \n-\t\t\tItemListener, Serializable {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * value\n-\t\t */\n-\t\tprotected Object value;\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor EditorDelegate\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tprotected EditorDelegate(DefaultCellEditor editor) {\n-\t\t\t// TODO\n-\t\t} // EditorDelegate()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * setValue\n-\t\t * @param event TODO\n-\t\t */\n-\t\tpublic void setValue(Object event) {\n-\t\t\t// TODO\n-\t\t} // setValue()\n+  /**\n+   * EditorDelegate\n+   */\n+  protected class EditorDelegate\n+    implements ActionListener, ItemListener, Serializable\n+  {\n+    private static final long serialVersionUID = -1420007406015481933L;\n+\n+    /**\n+     * value\n+     */\n+    protected Object value;\n+\n+    /**\n+     * Constructor EditorDelegate\n+     * @param value0 TODO\n+     */\n+    protected EditorDelegate()\n+    {\n+    }\n+\n+    /**\n+     * setValue\n+     * @param event TODO\n+     */\n+    public void setValue(Object event)\n+    {\n+    }\n \n \t\t/**\n \t\t * getCellEditorValue\n@@ -172,11 +156,6 @@ public void itemStateChanged(ItemEvent event) {\n \n \t} // EditorDelegate\n \n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * editorComponent\n \t */\n@@ -192,11 +171,6 @@ public void itemStateChanged(ItemEvent event) {\n \t */\n \tprotected int clickCountToStart;\n \n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * Constructor DefaultCellEditor\n \t * @param textfield TODO\n@@ -221,11 +195,6 @@ public DefaultCellEditor(JComboBox combobox) {\n \t\t// TODO\n \t} // DefaultCellEditor()\n \n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * getComponent\n \t * @returns Component\n@@ -320,6 +289,4 @@ public Component getTableCellEditorComponent(JTable tree,\n \t\t\tObject value, boolean isSelected, int row, int column) {\n \t\treturn null; // TODO\n \t} // getTableCellEditorComponent()\n-\n-\n-} // DefaultCellEditor\n+}"}, {"sha": "40b78b8773197edfae61262a9feba9381c654f4e", "filename": "libjava/javax/swing/DefaultDesktopManager.java", "status": "modified", "additions": 605, "deletions": 236, "changes": 841, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -37,249 +37,618 @@\n \n package javax.swing;\n \n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n import java.awt.Rectangle;\n+import java.beans.PropertyVetoException;\n import java.io.Serializable;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JInternalFrame.JDesktopIcon;\n+\n \n /**\n- * DefaultDesktopManager\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * DefaultDesktopManager is the default implementation of DesktopManager for\n+ * swing. It implements the basic beaviours for JInternalFrames in arbitrary\n+ * parents. The methods provided by the class are not meant to be called by\n+ * the user, instead, the JInternalFrame methods will call these methods.\n  */\n public class DefaultDesktopManager implements DesktopManager, Serializable\n {\n+  /** DOCUMENT ME! */\n   static final long serialVersionUID = 4657624909838017887L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * HAS_BEEN_ICONIFIED_PROPERTY\n-\t */\n-\tstatic final String HAS_BEEN_ICONIFIED_PROPERTY = \"\"; // TODO\n-\n-\t/**\n-\t * DEFAULT_DRAG_MODE\n-\t */\n-\tstatic final int DEFAULT_DRAG_MODE = 0; // TODO\n-\n-\t/**\n-\t * OUTLINE_DRAG_MODE\n-\t */\n-\tstatic final int OUTLINE_DRAG_MODE = 0; // TODO\n-\n-\t/**\n-\t * FASTER_DRAG_MODE\n-\t */\n-\tstatic final int FASTER_DRAG_MODE = 0; // TODO\n-\n-\t/**\n-\t * dragMode\n-\t */\n-\tint dragMode;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor DefaultDesktopManager\n-\t */\n-\tpublic DefaultDesktopManager() {\n-\t\t// TODO\n-\t} // DefaultDesktopManager()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * openFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void openFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // openFrame()\n-\n-\t/**\n-\t * closeFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void closeFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // closeFrame()\n-\n-\t/**\n-\t * maximizeFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void maximizeFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // maximizeFrame()\n-\n-\t/**\n-\t * minimizeFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void minimizeFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // minimizeFrame()\n-\n-\t/**\n-\t * iconifyFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void iconifyFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // iconifyFrame()\n-\n-\t/**\n-\t * deiconifyFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void deiconifyFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // deiconifyFrame()\n-\n-\t/**\n-\t * activateFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void activateFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // activateFrame()\n-\n-\t/**\n-\t * deactivateFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void deactivateFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // deactivateFrame()\n-\n-\t/**\n-\t * beginDraggingFrame\n-\t * @param component TODO\n-\t */\n-\tpublic void beginDraggingFrame(JComponent component) {\n-\t\t// TODO\n-\t} // beginDraggingFrame()\n-\n-\t/**\n-\t * dragFrame\n-\t * @param component TODO\n-\t * @param newX TODO\n-\t * @param newY TODO\n-\t */\n-\tpublic void dragFrame(JComponent component, int newX, int newY) {\n-\t\t// TODO\n-\t} // dragFrame()\n-\n-\t/**\n-\t * endDraggingFrame\n-\t * @param component TODO\n-\t */\n-\tpublic void endDraggingFrame(JComponent component) {\n-\t\t// TODO\n-\t} // endDraggingFrame()\n-\n-\t/**\n-\t * beginResizingFrame\n-\t * @param component TODO\n-\t * @param direction TODO\n-\t */\n-\tpublic void beginResizingFrame(JComponent component, int direction) {\n-\t\t// TODO\n-\t} // beginResizingFrame()\n-\n-\t/**\n-\t * resizeFrame\n-\t * @param component TODO\n-\t * @param newX TODO\n-\t * @param newY TODO\n-\t * @param newWidth TODO\n-\t * @param newHeight TODO\n-\t */\n-\tpublic void resizeFrame(JComponent component, int newX, int newY,\n-\t\t\tint newWidth, int newHeight) {\n-\t\t// TODO\n-\t} // resizeFrame()\n-\n-\t/**\n-\t * endResizingFrame\n-\t * @param component TODO\n-\t */\n-\tpublic void endResizingFrame(JComponent component) {\n-\t\t// TODO\n-\t} // endResizingFrame()\n-\n-\t/**\n-\t * setBoundsForFrame\n-\t * @param component TODO\n-\t * @param newX TODO\n-\t * @param newY TODO\n-\t * @param newWidth TODO\n-\t * @param newHeight TODO\n-\t */\n-\tpublic void setBoundsForFrame(JComponent component, int newX,\n-\t\t\tint newY, int newWidth, int newHeight) {\n-\t\t// TODO\n-\t} // setBoundsForFrame()\n-\n-\t/**\n-\t * removeIconFor\n-\t * @param frame TODO\n-\t */\n-\tprotected void removeIconFor(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // removeIconFor()\n-\n-\t/**\n-\t * getBoundsForIconOf\n-\t * @param frame TODO\n-\t * @returns Rectangle\n-\t */\n-\tprotected Rectangle getBoundsForIconOf(JInternalFrame frame) {\n-\t\treturn null; // TODO\n-\t} // getBoundsForIconOf()\n-\n-\t/**\n-\t * setPreviousBounds\n-\t * @param frame TODO\n-\t * @param rect TODO\n-\t */\n-\tprotected void setPreviousBounds(JInternalFrame frame, Rectangle rect) {\n-\t\t// TODO\n-\t} // setPreviousBounds()\n-\n-\t/**\n-\t * getPreviousBounds\n-\t * @param frame TODO\n-\t * @returns Rectangle\n-\t */\n-\tprotected Rectangle getPreviousBounds(JInternalFrame frame) {\n-\t\treturn null; // TODO\n-\t} // getPreviousBounds()\n-\n-\t/**\n-\t * setWasIcon\n-\t * @param frame TODO\n-\t * @param value TODO\n-\t */\n-\tprotected void setWasIcon(JInternalFrame frame, Boolean value) {\n-\t\t// TODO\n-\t} // setWasIcon()\n-\n-\t/**\n-\t * wasIcon\n-\t * @param frame TODO\n-\t * @returns boolean\n-\t */\n-\tprotected boolean wasIcon(JInternalFrame frame) {\n-\t\treturn false; // TODO\n-\t} // wasIcon()\n-\n-\n+  /** The property change event fired when the wasIcon property changes. */\n+  static final String WAS_ICON_ONCE_PROPERTY = \"wasIconOnce\";\n+\n+  /**\n+   * The method of dragging used by the JDesktopPane that parents the\n+   * JInternalFrame that is being dragged.\n+   */\n+  private int currentDragMode = 0;\n+\n+  /**\n+   * The cache of the bounds used to draw the outline rectangle when\n+   * OUTLINE_DRAG_MODE is used.\n+   */\n+  private transient Rectangle dragCache = new Rectangle();\n+\n+  /**\n+   * A cached JDesktopPane that is stored when the JInternalFrame is initially\n+   * dragged.\n+   */\n+  private transient Container pane;\n+\n+  /**\n+   * An array of Rectangles that holds the bounds of the JDesktopIcons in the \n+   * JDesktopPane when looking for where to place a new icon.\n+   */\n+  private transient Rectangle[] iconRects;\n+\n+  /**\n+   * This creates a new DefaultDesktopManager object.\n+   */\n+  public DefaultDesktopManager()\n+  {\n+  } // DefaultDesktopManager()\n+\n+  /**\n+   * This method is not normally called since the user will typically add the\n+   * JInternalFrame to a Container. If this is called, it will try to\n+   * determine the parent of the JInternalFrame and remove any icon that\n+   * represents this JInternalFrame and add this JInternalFrame.\n+   *\n+   * @param frame The JInternalFrame to open.\n+   */\n+  public void openFrame(JInternalFrame frame)\n+  {\n+    Container c = frame.getParent();\n+    if (c == null)\n+      c = frame.getDesktopIcon().getParent();\n+    if (c == null)\n+      return;\n+\n+    c.remove(frame.getDesktopIcon());\n+    c.add(frame);\n+    frame.setVisible(true);\n+  } // openFrame()\n+\n+  /**\n+   * This method removes the JInternalFrame and JDesktopIcon (if one is\n+   * present) from their parents.\n+   *\n+   * @param frame The JInternalFrame to close.\n+   */\n+  public void closeFrame(JInternalFrame frame)\n+  {\n+    Container c = frame.getParent();\n+    frame.doDefaultCloseAction();\n+\n+    if (c != null)\n+      {\n+\tif (frame.isIcon())\n+\t  c.remove(frame.getDesktopIcon());\n+\telse\n+\t  c.remove(frame);\n+\tc.repaint();\n+      }\n+  } // closeFrame()\n+\n+  /**\n+   * This method resizes the JInternalFrame to match its parent's bounds.\n+   *\n+   * @param frame The JInternalFrame to maximize.\n+   */\n+  public void maximizeFrame(JInternalFrame frame)\n+  {\n+    // Can't maximize from iconified state.\n+    // It can only return to maximized state, but that would fall under\n+    // deiconify.\n+    if (frame.isIcon())\n+      return;\n+    frame.setNormalBounds(frame.getBounds());\n+\n+    Container p = frame.getParent();\n+    if (p != null)\n+      {\n+\tRectangle pBounds = p.getBounds();\n+\tInsets insets = p.getInsets();\n+\tpBounds.width -= insets.left + insets.right;\n+\tpBounds.height -= insets.top + insets.bottom;\n+\n+\tsetBoundsForFrame(frame, 0, 0, pBounds.width, pBounds.height);\n+      }\n+    if (p instanceof JDesktopPane)\n+      ((JDesktopPane) p).setSelectedFrame(frame);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    frame.setSelected(true);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t    // Do nothing.\n+\t  }\n+      }\n+  } // maximizeFrame()\n+\n+  /**\n+   * This method restores the JInternalFrame's bounds to what they were\n+   * previous to the setMaximize call.\n+   *\n+   * @param frame The JInternalFrame to minimize.\n+   */\n+  public void minimizeFrame(JInternalFrame frame)\n+  {\n+    Rectangle normalBounds = frame.getNormalBounds();\n+\n+    JDesktopPane p = frame.getDesktopPane();\n+    if (p != null)\n+      p.setSelectedFrame(frame);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    frame.setSelected(true);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t    // Do nothing.\n+\t  }\n+      }\n+\n+    setBoundsForFrame(frame, normalBounds.x, normalBounds.y,\n+                      normalBounds.width, normalBounds.height);\n+  } // minimizeFrame()\n+\n+  /**\n+   * This method removes the JInternalFrame from its parent and adds its\n+   * JDesktopIcon representation.\n+   *\n+   * @param frame The JInternalFrame to iconify.\n+   */\n+  public void iconifyFrame(JInternalFrame frame)\n+  {\n+    JDesktopPane p = frame.getDesktopPane();\n+    JDesktopIcon icon = frame.getDesktopIcon();\n+    if (p != null && p.getSelectedFrame() == frame)\n+      p.setSelectedFrame(null);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    frame.setSelected(false);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t  }\n+      }\n+\n+    Container c = frame.getParent();\n+\n+    if (! wasIcon(frame))\n+      {\n+\tRectangle r = getBoundsForIconOf(frame);\n+\ticon.setBounds(r);\n+\tsetWasIcon(frame, true);\n+      }\n+\n+    if (c != null)\n+      {\n+\tif (icon != null)\n+\t  {\n+\t    c.add(icon);\n+\t    icon.setVisible(true);\n+\t  }\n+\tc.remove(frame);\n+      }\n+  } // iconifyFrame()\n+\n+  /**\n+   * This method removes the JInternalFrame's JDesktopIcon representation and\n+   * adds the JInternalFrame back to its parent.\n+   *\n+   * @param frame The JInternalFrame to deiconify.\n+   */\n+  public void deiconifyFrame(JInternalFrame frame)\n+  {\n+    JDesktopIcon icon = frame.getDesktopIcon();\n+    Container c = icon.getParent();\n+\n+    removeIconFor(frame);\n+    c.add(frame);\n+    frame.setVisible(true);\n+\n+    if (! frame.isSelected())\n+      {\n+\tJDesktopPane p = frame.getDesktopPane();\n+\tif (p != null)\n+\t  p.setSelectedFrame(frame);\n+\telse\n+\t  {\n+\t    try\n+\t      {\n+\t\tframe.setSelected(true);\n+\t      }\n+\t    catch (PropertyVetoException e)\n+\t      {\n+\t\t// Do nothing.\n+\t      }\n+\t  }\n+      }\n+\n+    c.invalidate();\n+  } // deiconifyFrame()\n+\n+  /**\n+   * This method activates the JInternalFrame by moving it to the front and\n+   * selecting it.\n+   *\n+   * @param frame The JInternalFrame to activate.\n+   */\n+  public void activateFrame(JInternalFrame frame)\n+  {\n+    JDesktopPane p = frame.getDesktopPane();\n+\n+    if (p != null)\n+      p.setSelectedFrame(frame);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    frame.setSelected(true);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t  }\n+      }\n+\n+    frame.toFront();\n+  } // activateFrame()\n+\n+  /**\n+   * This method is called when the JInternalFrame loses focus.\n+   *\n+   * @param frame The JInternalFram to deactivate.\n+   */\n+  public void deactivateFrame(JInternalFrame frame)\n+  {\n+    JDesktopPane p = frame.getDesktopPane();\n+    if (p != null)\n+      {\n+\tif (p.getSelectedFrame() == frame)\n+\t  p.setSelectedFrame(null);\n+      }\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    frame.setSelected(false);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t  }\n+      }\n+  } // deactivateFrame()\n+\n+  /**\n+   * This method is called to indicate that the DesktopManager should prepare\n+   * to drag the JInternalFrame. Any state information needed to drag the\n+   * frame will be prepared now.\n+   *\n+   * @param component The JComponent to drag, usually a JInternalFrame.\n+   */\n+  public void beginDraggingFrame(JComponent component)\n+  {\n+    if (component instanceof JDesktopIcon)\n+      pane = ((JDesktopIcon) component).getInternalFrame().getDesktopPane();\n+    else\n+      pane = ((JInternalFrame) component).getDesktopPane();\n+    if (pane == null)\n+      return;\n+\n+    dragCache = component.getBounds();\n+\n+    if (! (pane instanceof JDesktopPane))\n+      currentDragMode = JDesktopPane.LIVE_DRAG_MODE;\n+    else\n+      currentDragMode = ((JDesktopPane) pane).getDragMode();\n+  } // beginDraggingFrame()\n+\n+  /**\n+   * This method is called to drag the JInternalFrame to a new location.\n+   *\n+   * @param component The JComponent to drag, usually a JInternalFrame.\n+   * @param newX The new x coordinate.\n+   * @param newY The new y coordinate.\n+   */\n+  public void dragFrame(JComponent component, int newX, int newY)\n+  {\n+    if (currentDragMode == JDesktopPane.OUTLINE_DRAG_MODE)\n+      {\n+\t// FIXME: Do outline drag mode painting.\n+      }\n+    else\n+      {\n+\tRectangle b = component.getBounds();\n+\tif (component instanceof JDesktopIcon)\n+\t  component.setBounds(newX, newY, b.width, b.height);\n+\telse\n+\t  setBoundsForFrame((JInternalFrame) component, newX, newY, b.width,\n+\t                    b.height);\n+      }\n+  } // dragFrame()\n+\n+  /**\n+   * This method indicates that the dragging is done. Any state information\n+   * stored by the DesktopManager can be cleared.\n+   *\n+   * @param component The JComponent that has finished dragging.\n+   */\n+  public void endDraggingFrame(JComponent component)\n+  {\n+    if (currentDragMode == JDesktopPane.OUTLINE_DRAG_MODE)\n+      {\n+\tsetBoundsForFrame((JInternalFrame) component, dragCache.x,\n+\t                  dragCache.y, dragCache.width, dragCache.height);\n+\tpane = null;\n+\tdragCache = null;\n+      }\n+    component.repaint();\n+  } // endDraggingFrame()\n+\n+  /**\n+   * This method is called to indicate that the given JComponent will be\n+   * resized. Any state information necessary to resize the JComponent will\n+   * be prepared now.\n+   *\n+   * @param component The JComponent to resize, usually a JInternalFrame.\n+   * @param direction The direction to drag in (a SwingConstant).\n+   */\n+  public void beginResizingFrame(JComponent component, int direction)\n+  {\n+    pane = ((JInternalFrame) component).getDesktopPane();\n+    if (pane == null)\n+      return;\n+\n+    dragCache = component.getBounds();\n+    if (! (pane instanceof JDesktopPane))\n+      currentDragMode = JDesktopPane.LIVE_DRAG_MODE;\n+    else\n+      currentDragMode = ((JDesktopPane) pane).getDragMode();\n+  } // beginResizingFrame()\n+\n+  /**\n+   * This method resizes the give JComponent.\n+   *\n+   * @param component The JComponent to resize.\n+   * @param newX The new x coordinate.\n+   * @param newY The new y coordinate.\n+   * @param newWidth The new width.\n+   * @param newHeight The new height.\n+   */\n+  public void resizeFrame(JComponent component, int newX, int newY,\n+                          int newWidth, int newHeight)\n+  {\n+    dragCache.setBounds(newX, newY, newWidth, newHeight);\n+    dragCache = findMinimum(dragCache, component);\n+\n+    if (currentDragMode == JDesktopPane.OUTLINE_DRAG_MODE)\n+      {\n+\t// FIXME: Do outline drag painting.\n+      }\n+    else\n+      setBoundsForFrame(component, dragCache.x, dragCache.y, dragCache.width,\n+                        dragCache.height);\n+  } // resizeFrame()\n+\n+  /**\n+   * This method is called to indicate that the given JComponent has finished\n+   * dragging. Any state information stored by the DesktopManager can be\n+   * cleared.\n+   *\n+   * @param component The JComponent that finished resizing.\n+   */\n+  public void endResizingFrame(JComponent component)\n+  {\n+    if (currentDragMode == JDesktopPane.OUTLINE_DRAG_MODE)\n+      {\n+\tsetBoundsForFrame((JInternalFrame) component, dragCache.x,\n+\t                  dragCache.y, dragCache.width, dragCache.height);\n+\tpane = null;\n+\tdragCache = null;\n+      }\n+    component.repaint();\n+  } // endResizingFrame()\n+\n+  /**\n+   * This method calls setBounds with the given parameters and repaints the\n+   * JComponent.\n+   *\n+   * @param component The JComponent to set bounds for.\n+   * @param newX The new x coordinate.\n+   * @param newY The new y coordinate.\n+   * @param newWidth The new width.\n+   * @param newHeight The new height.\n+   */\n+  public void setBoundsForFrame(JComponent component, int newX, int newY,\n+                                int newWidth, int newHeight)\n+  {\n+    component.setBounds(newX, newY, newWidth, newHeight);\n+    component.revalidate();\n+\n+    // If not null, I'd rather repaint the parent\n+    if (component.getParent() != null)\n+      component.getParent().repaint();\n+    else\n+      component.repaint();\n+  } // setBoundsForFrame()\n+\n+  /**\n+   * This is a helper method that removes the JDesktopIcon of the given\n+   * JInternalFrame from the parent.\n+   *\n+   * @param frame The JInternalFrame to remove an icon for.\n+   */\n+  protected void removeIconFor(JInternalFrame frame)\n+  {\n+    JDesktopIcon icon = frame.getDesktopIcon();\n+    Container c = icon.getParent();\n+    if (c != null && icon != null)\n+      c.remove(icon);\n+  } // removeIconFor()\n+\n+  /**\n+   * This method is called by iconifyFrame to determine the bounds of the\n+   * JDesktopIcon for the given JInternalFrame.\n+   *\n+   * @param frame The JInternalFrame to find the bounds of its JDesktopIcon\n+   *        for.\n+   *\n+   * @return The bounds of the JDesktopIcon.\n+   */\n+  protected Rectangle getBoundsForIconOf(JInternalFrame frame)\n+  {\n+    // IconRects has no order to it.\n+    // The icon _must_ be placed in the first free slot (working from \n+    // the bottom left corner)\n+    // The icon also must not be placed where another icon is placed \n+    // (regardless whether that frame is an icon currently or not)\n+    JDesktopPane desktopPane = frame.getDesktopPane();\n+    Rectangle paneBounds = desktopPane.getBounds();\n+    Insets insets = desktopPane.getInsets();\n+    Dimension pref = frame.getDesktopIcon().getPreferredSize();\n+\n+    if (desktopPane == null)\n+      return frame.getDesktopIcon().getBounds();\n+\n+    Component[] frames = desktopPane.getComponents();\n+\n+    int count = 0;\n+    for (int i = 0, j = 0; i < frames.length; i++)\n+      if (frames[i] instanceof JDesktopIcon\n+          || frames[i] instanceof JInternalFrame\n+          && ((JInternalFrame) frames[i]).getWasIcon() && frames[i] != frame)\n+\tcount++;\n+    iconRects = new Rectangle[count];\n+    for (int i = 0, j = 0; i < frames.length; i++)\n+      if (frames[i] instanceof JDesktopIcon)\n+\ticonRects[--count] = frames[i].getBounds();\n+      else if (frames[i] instanceof JInternalFrame\n+               && ((JInternalFrame) frames[i]).getWasIcon()\n+               && frames[i] != frame)\n+\ticonRects[--count] = ((JInternalFrame) frames[i]).getDesktopIcon()\n+\t                      .getBounds();\n+\n+    int startingX = insets.left;\n+    int startingY = paneBounds.height - insets.bottom - pref.height;\n+    Rectangle ideal = new Rectangle(startingX, startingY, pref.width,\n+                                    pref.height);\n+    boolean clear = true;\n+\n+    while (iconRects.length > 0)\n+      {\n+\tclear = true;\n+\tfor (int i = 0; i < iconRects.length; i++)\n+\t  {\n+\t    if (iconRects[i] != null && iconRects[i].intersects(ideal))\n+\t      {\n+\t\tclear = false;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif (clear)\n+\t  return ideal;\n+\n+\tstartingX += pref.width;\n+\tif (startingX + pref.width > paneBounds.width - insets.right)\n+\t  {\n+\t    startingX = insets.left;\n+\t    startingY -= pref.height;\n+\t  }\n+\tideal.setBounds(startingX, startingY, pref.width, pref.height);\n+      }\n+\n+    return ideal;\n+  } // getBoundsForIconOf()\n+\n+  /**\n+   * This method sets the bounds of the JInternalFrame right before the\n+   * maximizeFrame call.\n+   *\n+   * @param frame The JInternalFrame being maximized.\n+   * @param rect The normal bounds.\n+   */\n+  protected void setPreviousBounds(JInternalFrame frame, Rectangle rect)\n+  {\n+    frame.setNormalBounds(rect);\n+  } // setPreviousBounds()\n+\n+  /**\n+   * This method returns the normal bounds of the JInternalFrame from before\n+   * the maximize call.\n+   *\n+   * @param frame The JInternalFrame that is being restored.\n+   *\n+   * @return The previous bounds of the JInternalFrame.\n+   */\n+  protected Rectangle getPreviousBounds(JInternalFrame frame)\n+  {\n+    return frame.getNormalBounds();\n+  } // getPreviousBounds()\n+\n+  /**\n+   * This method sets the value to true if the given JInternalFrame has been\n+   * iconized and the bounds of its DesktopIcon are valid.\n+   *\n+   * @param frame The JInternalFrame for the JDesktopIcon.\n+   * @param value True if the JInternalFrame has been iconized and the bounds\n+   *        of the JDesktopIcon are valid.\n+   */\n+  protected void setWasIcon(JInternalFrame frame, boolean value)\n+  {\n+    frame.setWasIcon(value, WAS_ICON_ONCE_PROPERTY);\n+  } // setWasIcon()\n+\n+  /**\n+   * This method returns true if the given JInternalFrame has been iconized\n+   * and the bounds of its DesktopIcon are valid.\n+   *\n+   * @param frame The JInternalFrame for the JDesktopIcon.\n+   *\n+   * @return True if the given JInternalFrame has been iconized and the bounds\n+   *         of its DesktopIcon are valid.\n+   */\n+  protected boolean wasIcon(JInternalFrame frame)\n+  {\n+    return frame.getWasIcon();\n+  } // wasIcon()\n+\n+  /**\n+   * This is a helper method that determines the minimum size a \n+   * JInternalFrame can be resized to.\n+   *\n+   * @param r The desired size.\n+   * @param c The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size a JInternalFrame can be resized to.\n+   */\n+  private Rectangle findMinimum(Rectangle r, JComponent c)\n+  {\n+    if (r != null && c != null)\n+      {\n+\tDimension d = c.getPreferredSize();\n+\tif (d != null)\n+\t  {\n+\t    r.width = Math.max(d.width, r.width);\n+\t    r.height = Math.max(d.height, r.height);\n+\t  }\n+      }\n+    return r;\n+  }\n } // DefaultDesktopManager"}, {"sha": "67ad1df4173e002638e1d0f971b5bc3c8b2eb6dd", "filename": "libjava/javax/swing/DefaultListSelectionModel.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -62,6 +62,7 @@ public class DefaultListSelectionModel implements Cloneable,\n                                                   ListSelectionModel,\n                                                   Serializable\n {\n+  private static final long serialVersionUID = -5718799865110415860L;\n \n   /** The list of ListSelectionListeners subscribed to this selection model. */\n   protected EventListenerList listenerList = new EventListenerList();"}, {"sha": "7fbc972c367158bd23b351586558475d441a29d9", "filename": "libjava/javax/swing/DesktopManager.java", "status": "modified", "additions": 136, "deletions": 114, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDesktopManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FDesktopManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDesktopManager.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* DesktopManager.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,118 +38,140 @@\n package javax.swing;\n \n /**\n- * DesktopManager\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * DesktopManagers are responsible for implementing the behaviours for the\n+ * JInternalFrames that belong to JDesktopPanes. Actions such as maximizing,\n+ * minimizing, iconifying, etc will be delegated to the DesktopManager.\n  */\n-public interface DesktopManager {\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * openFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid openFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * closeFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid closeFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * maximizeFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid maximizeFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * minimizeFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid minimizeFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * iconifyFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid iconifyFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * deiconifyFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid deiconifyFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * activateFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid activateFrame(JInternalFrame vframe);\n-\n-\t/**\n-\t * deactivateFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid deactivateFrame(JInternalFrame frame);\n-\n-\t/**\n-\t * beginDraggingFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid beginDraggingFrame(JComponent frame);\n-\n-\t/**\n-\t * dragFrame\n-\t * @param frame TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t */\n-\tvoid dragFrame(JComponent frame, int x, int y);\n-\n-\t/**\n-\t * endDraggingFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid endDraggingFrame(JComponent frame);\n-\n-\t/**\n-\t * beginResizingFrame\n-\t * @param frame TODO\n-\t * @param direction TODO\n-\t */\n-\tvoid beginResizingFrame(JComponent frame, int direction);\n-\n-\t/**\n-\t * resizeFrame\n-\t * @param frame TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t * @param width TODO\n-\t * @param height TODO\n-\t */\n-\tvoid resizeFrame(JComponent frame, int x, int y, \n-\t\t\t\t\tint width, int height);\n-\n-\t/**\n-\t * endResizingFrame\n-\t * @param frame TODO\n-\t */\n-\tvoid endResizingFrame(JComponent frame);\n-\n-\t/**\n-\t * setBoundsForFrame\n-\t * @param frame TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t * @param width TODO\n-\t * @param height TODO\n-\t */\n-\tvoid setBoundsForFrame(JComponent frame, int x, int y, \n-\t\t\t\t\tint width, int height);\n-\n-\n+public interface DesktopManager\n+{\n+  /**\n+   * This method will cause the JInternalFrame to be displayed in the set\n+   * location. This usually is not needed since the user will add the\n+   * JInternalFrame to a Container separately.\n+   *\n+   * @param frame The JInternalFrame to open.\n+   */\n+  void openFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should remove the JInternalFrame from its parent.\n+   *\n+   * @param frame The JInternalFrame to close.\n+   */\n+  void closeFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should maximize the JInternalFrame to match its parent's\n+   * bounds.\n+   *\n+   * @param frame The JInternalFrame to maximize.\n+   */\n+  void maximizeFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should restore the JInternalFrame to its normal bounds.\n+   *\n+   * @param frame The JInternalFrame to minimize.\n+   */\n+  void minimizeFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should remove the JInternalFrame from its parent and replace\n+   * it with a JDesktopIcon.\n+   *\n+   * @param frame The JInternalFrame to iconify.\n+   */\n+  void iconifyFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should remove the JDesktopIcon from its parent and replace it\n+   * with the JInternalFrame that the JDesktopIcon represents.\n+   *\n+   * @param frame The JInternalFrame to deiconify.\n+   */\n+  void deiconifyFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should give focus to the JInternalFrame and its default focus\n+   * owner.\n+   *\n+   * @param frame The JInternalFrame to activate.\n+   */\n+  void activateFrame(JInternalFrame vframe);\n+\n+  /**\n+   * This method should be called when the JInternalFrame gets deselected and\n+   * subsequently loses focus.\n+   *\n+   * @param frame The JInternalFrame to deactivate.\n+   */\n+  void deactivateFrame(JInternalFrame frame);\n+\n+  /**\n+   * This method should be called in preparation for dragging. This needs to\n+   * be called prior to dragFrame calls so that the DesktopManager can\n+   * prepare any state information.\n+   *\n+   * @param frame The JInternalFrame to prepare for dragging.\n+   */\n+  void beginDraggingFrame(JComponent frame);\n+\n+  /**\n+   * This method drags the given JInternalFrame to the given x and y\n+   * coordinates.\n+   *\n+   * @param frame The JInternalFrame to drag.\n+   * @param x The new x coordinate.\n+   * @param y The new y coordinate.\n+   */\n+  void dragFrame(JComponent frame, int x, int y);\n+\n+  /**\n+   * This method should be called after dragFrame calls. Any information used\n+   * by the DesktopManager for dragging the JInternalFrame can be cleared.\n+   *\n+   * @param frame The JInternalFrame that finished dragging.\n+   */\n+  void endDraggingFrame(JComponent frame);\n+\n+  /**\n+   * This method should be called prior to any resizeFrame calls. Any state\n+   * information needed by the DesktopManager to resize the JInternalFrame\n+   * will be prepared here.\n+   *\n+   * @param frame The JInternalFrame to resize.\n+   * @param direction One of eight directions specified by SwingConstants.\n+   */\n+  void beginResizingFrame(JComponent frame, int direction);\n+\n+  /**\n+   * This method is called to resize the given JInternalFrame to the given\n+   * bounds.\n+   *\n+   * @param frame The JInternalFrame to resize.\n+   * @param x The new x coordinate.\n+   * @param y The new y coordinate.\n+   * @param width The new width.\n+   * @param height The new height.\n+   */\n+  void resizeFrame(JComponent frame, int x, int y, int width, int height);\n+\n+  /**\n+   * This method is called to signify that the resize is finished. Any\n+   * information used to resize the JInternalFrame can now be cleared.\n+   *\n+   * @param frame The JInternalFrame that just finished dragging.\n+   */\n+  void endResizingFrame(JComponent frame);\n+\n+  /**\n+   * This method does the actual work for reshaping the JInternalFrame.\n+   *\n+   * @param frame The JInternalFrame to resize.\n+   * @param x The new x coordinate.\n+   * @param y The new y coordinate.\n+   * @param width The new width.\n+   * @param height The new height.\n+   */\n+  void setBoundsForFrame(JComponent frame, int x, int y, int width, int height);\n } // DesktopManager"}, {"sha": "39ad4d3563039e779ccb4e5b5640f1d6f9a9da42", "filename": "libjava/javax/swing/GrayFilter.java", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FGrayFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FGrayFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FGrayFilter.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -45,41 +45,41 @@\n \n public class GrayFilter extends RGBImageFilter\n {\n-    private boolean b;\n-    private int p;\n+  private boolean b;\n+  private int p;\n \n-    /**\n-       Create a GrayFilter. If b is true then brighten. Also, indicate how much gray.\n-       \n-       @param b if brighten\n-       @param p percent of gray, 0 - 100\n-    */\n-    public GrayFilter(boolean b, int p)\n-    {\n-\tthis.b = b; //FIXME - HANDLE THIS\n-\tthis.p = p;\n-    }\n+  /**\n+   * Create a GrayFilter. If b is true then brighten. Also, indicate how much gray.\n+   *    \n+   * @param b if brighten\n+   * @param p percent of gray, 0 - 100\n+   */\n+  public GrayFilter(boolean b, int p)\n+  {\n+    this.b = b; //FIXME - HANDLE THIS\n+    this.p = p;\n+  }\n \n-    /**\n-       Create grayed image\n-\n-       @param i image to gray\n-\n-       @return a grayed image\n-     */\n-    public static Image createDisabledImage(Image src)\n-    {\n-\treturn Toolkit.getDefaultToolkit().createImage( new FilteredImageSource(src.getSource(),\n-\t\t\t\t\t\t\t\t\t\tnew GrayFilter(false, 100)));\n-    }\n-\n-    /**\n-       Filter RGB to gray\n-     */\n-    public int filterRGB(int x,\n-\t\t\t int y,\n-\t\t\t int rgb)\n-    {\n-\treturn (int) ( ( p * ( 0.299 * ( (0xff0000 & rgb) >> 16) + 0.587 * ( (0xff00 & rgb) >> 8 ) + 0.114 * (0xff & rgb ) ) ));\n-    }\n+  /**\n+   * Create grayed image\n+   *\n+   * @param src image to gray\n+   *\n+   * @return a grayed image\n+   */\n+  public static Image createDisabledImage(Image src)\n+  {\n+    return (Toolkit.getDefaultToolkit().\n+\t    createImage(new FilteredImageSource(src.getSource(),\n+\t\t\t\t\t\tnew GrayFilter(false, 100))));\n+  }\n+  \n+  /**\n+   * Filter RGB to gray\n+   */\n+  public int filterRGB(int x, int y, int rgb)\n+  {\n+    return (int) (p * (0.299 * ((0xff0000 & rgb) >> 16)\n+\t\t       + 0.587 * ((0xff00 & rgb) >> 8) + 0.114 * (0xff & rgb)));\n+  }\n }"}, {"sha": "f94d58a5f80bd12dadf496c290a6194b1c72beb0", "filename": "libjava/javax/swing/ImageIcon.java", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FImageIcon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FImageIcon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FImageIcon.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -35,65 +35,86 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Component;\n import java.awt.Graphics;\n import java.awt.Image;\n import java.awt.Toolkit;\n+import java.io.Serializable;\n+import java.net.URL;\n+\n \n-public class ImageIcon implements Icon\n+public class ImageIcon\n+  implements Icon, Serializable\n {\n-    Image image;\n-    String file, descr;\n-    Component observer;\n+  private static final long serialVersionUID = 532615968316031794L;\n+  Image image;\n+  String file;\n+  String descr;\n+  Component observer;\n \n   public ImageIcon(String s)\n-    {\n-    \t// if description is not specified, then file name becomes\n-\t// desciption for this icon\n-\t\n-\tthis(s, s);\n-    }\n-\n-  public ImageIcon(String file,\n-\t      String descr)\n-    {\n-        this.file = file;\n-        this.descr = descr;\n-\n-        image = Toolkit.getDefaultToolkit().getImage(file);\n-        if (image == null) {\n-            return;\n-        }\n-        //loadImage(image);\n-    }\n-\n-    // not in SUN's spec !!!\n-    public void setParent(Component p)\n-    {\n-\tobserver = p;\n-    }\n-\n-    public Image getImage() \n-    {  return image;    }\n-\n-    public String getDescription() \n-    {  return descr;    }\n-    public void setDescription(String description) \n-    {  this.descr = description;    }\n-\n-    public int getIconHeight()\n-    {\treturn image.getHeight(observer);    }\n-    public int getIconWidth()\n-    {\treturn image.getWidth(observer);    }\n-\n-    public void paintIcon(Component c, \n-\t\t\t  Graphics g,\n-\t\t\t  int x, \n-\t\t\t  int y)\n-    {\n-\tg.drawImage(image, x, y, observer);\n-    }\n+  {\n+    // if description is not specified, then file name becomes\n+    // desciption for this icon\n+    this(s, s);\n+  }\n+\n+  public ImageIcon(Image image)\n+  {\n+  }\n+\n+  public ImageIcon(URL url)\n+  {\n+    image = Toolkit.getDefaultToolkit().getImage(url);\n+  }\n+\n+  public ImageIcon(String file, String descr)\n+  {\n+    this.file = file;\n+    this.descr = descr;\n+\n+    image = Toolkit.getDefaultToolkit().getImage(file);\n+    if (image == null)\n+      return;\n+\n+    //loadImage(image);\n+  }\n+\n+  // not in SUN's spec !!!\n+  public void setParent(Component p)\n+  {\n+    observer = p;\n+  }\n+\n+  public Image getImage()\n+  {\n+    return image;\n+  }\n+\n+  public String getDescription()\n+  {\n+    return descr;\n+  }\n+\n+  public void setDescription(String description)\n+  {\n+    this.descr = description;\n+  }\n+\n+  public int getIconHeight()\n+  {\n+    return image.getHeight(observer);\n+  }\n+\n+  public int getIconWidth()\n+  {\n+    return image.getWidth(observer);\n+  }\n+\n+  public void paintIcon(Component c, Graphics g, int x, int y)\n+  {\n+    g.drawImage(image, x, y, observer);\n+  }\n }"}, {"sha": "f1c3e354ff812a180c94aab5808a250b26184cab", "filename": "libjava/javax/swing/JApplet.java", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJApplet.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JApplet.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -51,6 +51,7 @@\n \n public class JApplet extends Applet implements RootPaneContainer\n {\n+  private static final long serialVersionUID = 7269359214497372587L;\n \n     public final static int HIDE_ON_CLOSE        = 0;\n     public final static int EXIT_ON_CLOSE        = 1;\n@@ -136,10 +137,10 @@ int getDefaultCloseOperation()\n     {    return close_action;   }\n \n     \n-    JMenuBar getJMenuBar()\n+    public JMenuBar getJMenuBar()\n     {    return getRootPane().getJMenuBar();   }\n     \n-    void setJMenuBar(JMenuBar menubar)\n+    public void setJMenuBar(JMenuBar menubar)\n     {    getRootPane().setJMenuBar(menubar); }\n     \n     "}, {"sha": "0eb5e4482015b90b31af9879b4c3d00dd3c0f906", "filename": "libjava/javax/swing/JButton.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJButton.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -87,6 +87,7 @@ public Object[] getSelectedObjects()\n     protected  void configurePropertiesFromAction(Action a)\n     {\n \t//Factory method which sets the AbstractButton's properties according to values from the Action instance. \n+\tsuper.configurePropertiesFromAction(a);\n     }\n     \n     public AccessibleContext getAccessibleContext()"}, {"sha": "94aba4a4733c1f5fe24d83e73f76c2e2add849f0", "filename": "libjava/javax/swing/JCheckBox.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJCheckBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJCheckBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBox.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JCheckBox.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -47,6 +47,8 @@\n  */\n public class JCheckBox extends JToggleButton\n {\n+  private static final long serialVersionUID = -5246739313864538930L;\n+  \n     public JCheckBox()\n     {\n \tthis(null, null);"}, {"sha": "fcc7721008f3bedd35188a3632d1d2744820ed59", "filename": "libjava/javax/swing/JCheckBoxMenuItem.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -50,6 +50,8 @@\n public class JCheckBoxMenuItem extends JMenuItem implements SwingConstants,\n                                                             Accessible\n {\n+  private static final long serialVersionUID = -6676402307973384715L;\n+\n   private static final String uiClassID = \"CheckBoxMenuItemUI\";\n   private boolean state;\n   private Object[] selectedObjects;\n@@ -207,7 +209,7 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJCheckBoxMenuItem(this);\n+      accessibleContext = new AccessibleJCheckBoxMenuItem();\n \n     return accessibleContext;\n   }\n@@ -217,16 +219,13 @@ public AccessibleContext getAccessibleContext()\n    */\n   protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem\n   {\n+    private static final long serialVersionUID = 1079958073579370777L;\n+\n     /**\n      * Creates a new AccessibleJCheckBoxMenuItem object.\n-     *\n-     * @param component DOCUMENT ME!\n      */\n-    protected AccessibleJCheckBoxMenuItem(JCheckBoxMenuItem component)\n+    protected AccessibleJCheckBoxMenuItem()\n     {\n-      super(component);\n-\n-      // TODO\n     }\n \n     /**"}, {"sha": "70dde6a19b30c4a9d787282c4835b3f09d74be6a", "filename": "libjava/javax/swing/JColorChooser.java", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJColorChooser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJColorChooser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJColorChooser.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JColorChooser.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -57,6 +57,8 @@\n  */\n public class JColorChooser extends JComponent implements Accessible {\n \n+  private static final long serialVersionUID = 9168066781620640889L;\n+  \n \t//-------------------------------------------------------------\n \t// Classes ----------------------------------------------------\n \t//-------------------------------------------------------------\n@@ -66,6 +68,8 @@ public class JColorChooser extends JComponent implements Accessible {\n \t */\n \tprotected class AccessibleJColorChooser extends JComponent.AccessibleJComponent {\n \n+\t  private static final long serialVersionUID = -2038297864782299082L;\n+  \n \t\t//-------------------------------------------------------------\n \t\t// Variables --------------------------------------------------\n \t\t//-------------------------------------------------------------\n@@ -79,15 +83,9 @@ protected class AccessibleJColorChooser extends JComponent.AccessibleJComponent\n \t\t * Constructor AccessibleJColorChooser\n \t\t * @param component TODO\n \t\t */\n-\t\tprotected AccessibleJColorChooser(JColorChooser component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJColorChooser()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+\t  protected AccessibleJColorChooser()\n+\t  {\n+\t  }\n \n \t\t/**\n \t\t * getAccessibleRole\n@@ -355,16 +353,15 @@ protected String paramString() {\n \t\treturn null; // TODO\n \t} // paramString()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJColorChooser(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JColorChooser\n+  /**\n+   * getAccessibleContext\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJColorChooser();\n+\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "b66dcb3a9a8b9a91e5c5f089c0dad77e20d80e6f", "filename": "libjava/javax/swing/JComboBox.java", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJComboBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJComboBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComboBox.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -69,39 +69,21 @@ public class JComboBox extends JComponent\n {\n   private static final long serialVersionUID = 5654585963292734470L;\n \n+  /**\n+   * AccessibleJComboBox\n+   */\n+  protected class AccessibleJComboBox extends AccessibleJComponent \n+    implements AccessibleAction, AccessibleSelection\n+  {\n+    private static final long serialVersionUID = 8217828307256675666L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJComboBox\n-\t */\n-\tprotected class AccessibleJComboBox extends AccessibleJComponent \n-\t\t\timplements AccessibleAction, AccessibleSelection {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJComboBox\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJComboBox(JComboBox component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJComboBox()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    /**\n+     * Constructor AccessibleJComboBox\n+     * @param component TODO\n+     */\n+    protected AccessibleJComboBox()\n+    {\n+    }\n \n \t\t/**\n \t\t * getAccessibleChildrenCount\n@@ -804,16 +786,18 @@ protected String paramString() {\n \t\treturn null; // TODO\n \t} // paramString()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJComboBox(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n+  /**\n+   * getAccessibleContext\n+   * @returns AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJComboBox();\n+\n+    return accessibleContext;\n+  }\n+  \n   /**\n    * addActionListener\n    * @param listener TODO"}, {"sha": "de8bd76f27c13c7677a71814eb0d5bd1a52dbd82", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -57,6 +57,7 @@\n import java.awt.geom.Rectangle2D;\n import java.awt.image.ImageObserver;\n import java.awt.peer.LightweightPeer;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.beans.PropertyVetoException;\n import java.beans.VetoableChangeListener;\n@@ -87,7 +88,7 @@\n  */\n public abstract class JComponent extends Container implements Serializable\n {\n-  static final long serialVersionUID = -5242478962609715464L;\n+  private static final long serialVersionUID = -7908749299918704233L;\n \n   /** \n    * Accessibility support is currently missing.\n@@ -101,23 +102,25 @@ public abstract class AccessibleJComponent\n     protected class AccessibleFocusHandler \n       implements FocusListener\n     {\n-      protected AccessibleFocusHandler(AccessibleJComponent component){}\n+      protected AccessibleFocusHandler(){}\n       public void focusGained(FocusEvent event){}\n       public void focusLost(FocusEvent valevent){}\n     }\n \n     protected class AccessibleContainerHandler \n       implements ContainerListener\n     {\n-      protected AccessibleContainerHandler(AccessibleJComponent component) {}\n+      protected AccessibleContainerHandler() {}\n       public void componentAdded(ContainerEvent event) {}\n       public void componentRemoved(ContainerEvent valevent) {}\n     }\n \n+    private static final long serialVersionUID = -7047089700479897799L;\n+  \n     protected ContainerListener accessibleContainerHandler;\n     protected FocusListener accessibleFocusHandler;\n \n-    protected AccessibleJComponent(JComponent component) {}\n+    protected AccessibleJComponent() {}\n     public void addPropertyChangeListener(PropertyChangeListener listener) {}\n     public void removePropertyChangeListener(PropertyChangeListener listener) {}\n     public int getAccessibleChildrenCount() { return 0; }\n@@ -273,7 +276,7 @@ public void removePropertyChangeListener(PropertyChangeListener listener) {}\n    * @see #getUI\n    * @see #updateUI\n    */\n-  ComponentUI ui;\n+  protected ComponentUI ui;\n \n   /**\n    * A hint to the focus system that this component should or should not\n@@ -343,6 +346,7 @@ public void removePropertyChangeListener(PropertyChangeListener listener) {}\n    */\n   private static Locale defaultLocale;\n   \n+  public static final String TOOL_TIP_TEXT_KEY = \"ToolTipText\";\n \n   /**\n    * Constant used to indicate that no condition has been assigned to a\n@@ -735,7 +739,12 @@ protected void fireVetoableChange(String propertyName, Object oldValue,\n                                     Object newValue)\n     throws PropertyVetoException\n   {\n-    //       Support for reporting constrained property changes.\n+    VetoableChangeListener[] listeners = getVetoableChangeListeners();\n+    \n+    PropertyChangeEvent evt = new PropertyChangeEvent(this, propertyName, oldValue, newValue);\n+    \n+    for (int i = 0; i < listeners.length; i++)\n+      listeners[i].vetoableChange(evt);\n   }\n \n   /**\n@@ -1105,7 +1114,11 @@ public Dimension getSize(Dimension rv)\n   public JToolTip createToolTip()\n   {\n     if (toolTip == null)\n-      toolTip = new JToolTip(toolTipText);\n+      {\n+\ttoolTip = new JToolTip();\n+\ttoolTip.setTipText(toolTipText);\n+      }\n+    \n     return toolTip;\n   }\n \n@@ -1378,7 +1391,7 @@ public void paint(Graphics g)\n             g2 = doubleBuffer.getGraphics();\n             g2.setClip(g.getClipBounds());\n           }\n-\n+\t  \n         g2 = getComponentGraphics(g2);\n         paintComponent(g2);\n         paintBorder(g2);\n@@ -1470,7 +1483,7 @@ public void paintImmediately(int x, int y, int w, int h)\n    */\n   public void paintImmediately(Rectangle r)\n   {\n-    Component root = this.getRootPane();\n+    Component root = SwingUtilities.getRoot(this);\n     if (root == null || ! root.isShowing())\n       return;\n     Graphics g = root.getGraphics();\n@@ -1624,7 +1637,7 @@ public void revalidate()\n   public void scrollRectToVisible(Rectangle r)\n   {\n     Component p = getParent();\n-    if (p != null && p instanceof JComponent)\n+    if (p instanceof JComponent)\n       ((JComponent) p).scrollRectToVisible(r);\n   }\n "}, {"sha": "ce8085a99f076c581adf1c58b1d34dd536ae5d8e", "filename": "libjava/javax/swing/JDesktopPane.java", "status": "modified", "additions": 276, "deletions": 237, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJDesktopPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJDesktopPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJDesktopPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -37,251 +37,290 @@\n \n package javax.swing;\n \n+import java.awt.Component;\n+import java.beans.PropertyVetoException;\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.swing.plaf.DesktopPaneUI;\n \n+\n /**\n- * JDesktopPane\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * JDesktopPane is a container (usually for JInternalFrames) that simulates a\n+ * desktop. Typically, the user will create JInternalFrames and place thme in\n+ * a JDesktopPane. The user can then interact with JInternalFrames like they\n+ * usually would with JFrames. The actions (minimize, maximize, close, etc)\n+ * are done by using a DesktopManager that is associated with the\n+ * JDesktopPane.\n  */\n public class JDesktopPane extends JLayeredPane implements Accessible\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJDesktopPane\n-\t */\n-\tprotected class AccessibleJDesktopPane extends AccessibleJComponent {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJDesktopPane\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJDesktopPane(JDesktopPane component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJDesktopPane()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.DESKTOP_PANE;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJDesktopPane\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Constants --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\t\n-\t/**\n-\t * LIVE_DRAG_MODE\n-\t */\n-\tpublic static int LIVE_DRAG_MODE = 0;\n-\n-\t/**\n-\t * OUTLINE_DRAG_MODE\n-\t */\n-\tpublic static int OUTLINE_DRAG_MODE = 1;\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"DesktopPaneUI\";\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * selectedFrame\n-\t */\n-\tprivate transient JInternalFrame selectedFrame;\n-\n-        /**\n-         * desktopManager\n-         */\n-\tprivate transient DesktopManager desktopManager;\n-\n-\n-\t/**\n-\t * dragMode\n-\t */\n-\tprivate int dragMode;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JDesktopPane\n-\t */\n-\tpublic JDesktopPane() {\n-\t\t// TODO\n-\t} // JDesktopPane()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getUI\n-\t * @returns DesktopPaneUI\n-\t */\n-\tpublic DesktopPaneUI getUI() {\n-\t\treturn (DesktopPaneUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(DesktopPaneUI ui) {\n-\t\tsuper.setUI(ui);\n-\t} // setUI()\n-\n-\t/**\n-\t * setDragMode\n-\t * @param mode TODO\n-\t */\n-\tpublic void setDragMode(int mode) {\n-\t\tthis.dragMode = mode;\n-\t\t// TODO\n-\t} // setDragMode()\n-\n-\t/**\n-\t * getDragMode\n-\t * @returns int\n-\t */\n-\tpublic int getDragMode() {\n-\t\treturn dragMode;\n-\t} // getDragMode()\n-\n-\t/**\n-\t * getDesktopManager\n-\t * @returns DesktopManager\n-\t */\n-\tpublic DesktopManager getDesktopManager() {\n-\t\treturn desktopManager;\n-\t} // getDesktopManager()\n-\n-\t/**\n-\t * setDesktopManager\n-\t * @param manager TODO\n-\t */\n-\tpublic void setDesktopManager(DesktopManager manager) {\n-\t\tthis.desktopManager = manager;\n-\t\t// TODO\n-\t} // setDesktopManager()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((DesktopPaneUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * getAllFrames\n-\t * @returns JInternalFrame[]\n-\t */\n-\tpublic JInternalFrame[] getAllFrames() {\n-\t\treturn null; // TODO\n-\t} // getAllFrames()\n-\n-\t/**\n-\t * getSelectedFrame\n-\t * @returns JInternalFrame\n-\t */\n-\tpublic JInternalFrame getSelectedFrame() {\n-\t\treturn null; // TODO\n-\t} // getSelectedFrame()\n-\n-\t/**\n-\t * setSelectedFrame\n-\t * @param frame TODO\n-\t */\n-\tpublic void setSelectedFrame(JInternalFrame frame) {\n-\t\t// TODO\n-\t} // setSelectedFrame()\n-\n-\t/**\n-\t * getAllFramesInLayer\n-\t * @param layer TODO\n-\t * @returns JInternalFrame[]\n-\t */\n-\tpublic JInternalFrame[] getAllFramesInLayer(int layer) {\n-\t\treturn null; // TODO\n-\t} // getAllFramesInLayer()\n-\n-\t/**\n-\t * isOpaque\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isOpaque() {\n-\t\treturn true;\n-\t} // isOpaque()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJDesktopPane(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JDesktopPane\n+  /** DOCUMENT ME! */\n+  private static final long serialVersionUID = 766333777224038726L;\n+\n+  /**\n+   * This specifies that when dragged, a JInternalFrame should be completely\n+   * visible.\n+   */\n+  public static int LIVE_DRAG_MODE = 0;\n+\n+  /**\n+   * This specifies that when dragged, a JInternalFrame should only be visible\n+   * as an outline.\n+   */\n+  public static int OUTLINE_DRAG_MODE = 1;\n+\n+  /** The selected frame in the JDesktopPane. */\n+  private transient JInternalFrame selectedFrame;\n+\n+  /** The JDesktopManager to use for acting on JInternalFrames. */\n+  transient DesktopManager desktopManager;\n+\n+  /** The drag mode used by the JDesktopPane. */\n+  private transient int dragMode = LIVE_DRAG_MODE;\n+\n+  /**\n+   * AccessibleJDesktopPane\n+   */\n+  protected class AccessibleJDesktopPane extends AccessibleJComponent\n+  {\n+    /** DOCUMENT ME! */\n+    private static final long serialVersionUID = 6079388927946077570L;\n+\n+    /**\n+     * Constructor AccessibleJDesktopPane\n+     */\n+    protected AccessibleJDesktopPane()\n+    {\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     *\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.DESKTOP_PANE;\n+    }\n+  }\n+\n+  /**\n+   * Creates a new JDesktopPane object.\n+   */\n+  public JDesktopPane()\n+  {\n+    setLayout(null);\n+    updateUI();\n+  }\n+\n+  /**\n+   * This method returns the UI used with the JDesktopPane.\n+   *\n+   * @return The UI used with the JDesktopPane.\n+   */\n+  public DesktopPaneUI getUI()\n+  {\n+    return (DesktopPaneUI) ui;\n+  }\n+\n+  /**\n+   * This method sets the UI used with the JDesktopPane.\n+   *\n+   * @param ui The UI to use with the JDesktopPane.\n+   */\n+  public void setUI(DesktopPaneUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method sets the drag mode to use with the JDesktopPane.\n+   *\n+   * @param mode The drag mode to use.\n+   *\n+   * @throws IllegalArgumentException If the drag mode given is not\n+   *         LIVE_DRAG_MODE or OUTLINE_DRAG_MODE.\n+   */\n+  public void setDragMode(int mode)\n+  {\n+    if ((mode != LIVE_DRAG_MODE) && (mode != OUTLINE_DRAG_MODE))\n+      throw new IllegalArgumentException(\"Drag mode not valid.\");\n+\n+    // FIXME: Unsupported mode.\n+    if (mode == OUTLINE_DRAG_MODE)\n+      throw new IllegalArgumentException(\"Outline drag modes are unsupported.\");\n+\n+    dragMode = mode;\n+  }\n+\n+  /**\n+   * This method returns the drag mode used with the JDesktopPane.\n+   *\n+   * @return The drag mode used with the JDesktopPane.\n+   */\n+  public int getDragMode()\n+  {\n+    return dragMode;\n+  }\n+\n+  /**\n+   * This method returns the DesktopManager used with the JDesktopPane.\n+   *\n+   * @return The DesktopManager to use with the JDesktopPane.\n+   */\n+  public DesktopManager getDesktopManager()\n+  {\n+    return desktopManager;\n+  }\n+\n+  /**\n+   * This method sets the DesktopManager to use with the JDesktopPane.\n+   *\n+   * @param manager The DesktopManager to use with the JDesktopPane.\n+   */\n+  public void setDesktopManager(DesktopManager manager)\n+  {\n+    desktopManager = manager;\n+  }\n+\n+  /**\n+   * This method restores the UI used with the JDesktopPane to the default.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((DesktopPaneUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * This method returns a String identifier that allows the UIManager to know\n+   * which class will act as JDesktopPane's UI.\n+   *\n+   * @return A String identifier for the UI class to use.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"DesktopPaneUI\";\n+  }\n+\n+  /**\n+   * This method returns all JInternalFrames that are in the JDesktopPane.\n+   *\n+   * @return All JInternalFrames that are in the JDesktopPane.\n+   */\n+  public JInternalFrame[] getAllFrames()\n+  {\n+    return getFramesFromComponents(getComponents());\n+  }\n+\n+  /**\n+   * This method returns the currently selected frame in the JDesktopPane.\n+   *\n+   * @return The currently selected frame in the JDesktopPane.\n+   */\n+  public JInternalFrame getSelectedFrame()\n+  {\n+    return selectedFrame;\n+  }\n+\n+  /**\n+   * This method sets the selected frame in the JDesktopPane.\n+   *\n+   * @param frame The selected frame in the JDesktopPane.\n+   */\n+  public void setSelectedFrame(JInternalFrame frame)\n+  {\n+    if (selectedFrame != null)\n+      {\n+\ttry\n+\t  {\n+\t    selectedFrame.setSelected(false);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t  }\n+      }\n+    selectedFrame = null;\n+\n+    try\n+      {\n+\tif (frame != null)\n+\t  frame.setSelected(true);\n+\n+\tselectedFrame = frame;\n+      }\n+    catch (PropertyVetoException e)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * This method returns all the JInternalFrames in the given layer.\n+   *\n+   * @param layer The layer to grab frames in.\n+   *\n+   * @return All JInternalFrames in the given layer.\n+   */\n+  public JInternalFrame[] getAllFramesInLayer(int layer)\n+  {\n+    return getFramesFromComponents(getComponentsInLayer(layer));\n+  }\n+\n+  /**\n+   * This method always returns true to indicate that it is not transparent.\n+   *\n+   * @return true.\n+   */\n+  public boolean isOpaque()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * This method returns a String that describes the JDesktopPane.\n+   *\n+   * @return A String that describes the JDesktopPane.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JDesktopPane\";\n+  }\n+\n+  /**\n+   * This method returns all the JInternalFrames in the given Component array.\n+   *\n+   * @param components An array to search for JInternalFrames in.\n+   *\n+   * @return An array of JInternalFrames found in the Component array.\n+   */\n+  private static JInternalFrame[] getFramesFromComponents(Component[] components)\n+  {\n+    int count = 0;\n+\n+    for (int i = 0; i < components.length; i++)\n+\tif (components[i] instanceof JInternalFrame)\n+\t  count++;\n+\t  \n+    JInternalFrame[] value = new JInternalFrame[count];\n+    for (int i = 0, j = 0; i < components.length && j != count; i++)\n+      if (components[i] instanceof JInternalFrame)\n+\tvalue[j++] = (JInternalFrame) components[i];\n+    return value;\n+  }\n+\n+  /**\n+   * getAccessibleContext\n+   *\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJDesktopPane();\n+\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "598f4931cd350954073842f3528bff5d483dcd9c", "filename": "libjava/javax/swing/JDialog.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJDialog.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJDialog.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJDialog.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -62,6 +62,7 @@\n public class JDialog extends Dialog implements Accessible, WindowConstants,\n                                                RootPaneContainer\n {\n+  private static final long serialVersionUID = -864070866424508218L;\n \n   /** DOCUMENT ME! */\n   protected AccessibleContext accessibleContext;"}, {"sha": "b944a3d129d39cedea088396950398c602d074e9", "filename": "libjava/javax/swing/JEditorPane.java", "status": "modified", "additions": 240, "deletions": 167, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJEditorPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJEditorPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJEditorPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* JEditorPane.java -- \n+/* JEditorPane.java --\n    Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,207 +35,280 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Dimension;\n import java.awt.event.KeyEvent;\n-import java.io.InputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.net.URL;\n import javax.accessibility.AccessibleContext;\n+import javax.swing.event.HyperlinkEvent;\n+import javax.swing.event.HyperlinkListener;\n import javax.swing.text.EditorKit;\n import javax.swing.text.JTextComponent;\n import javax.swing.text.PlainEditorKit;\n-import javax.swing.event.HyperlinkEvent;\n-import javax.swing.event.HyperlinkListener;\n+\n \n public class JEditorPane extends JTextComponent\n {\n   private static final long serialVersionUID = 3140472492599046285L;\n+  \n+  URL page_url;\n+  EditorKit kit;\n+  String ctype = \"text/plain\";\n+  boolean focus_root;\n+  boolean manages_focus;\n+\n+  public JEditorPane()\n+  {\n+  }\n+\n+  public JEditorPane(String url) throws IOException\n+  {\n+    setPage(url);\n+  }\n+\n+  public JEditorPane(String type, String text)\n+  {\n+    ctype = text;\n+    setText(text);\n+  }\n \n-    URL page_url;\n-    EditorKit kit;\n-    String ctype = \"text/plain\";\n-    boolean focus_root;\n-    boolean manages_focus;\n-\n-\n-    public JEditorPane()\n-    {\n-    }\n-\n-    public JEditorPane(String url)\n-      throws IOException\n-    {\n-\tthis();\n-\tsetPage(url);\n-    }\n-    \n-    public JEditorPane(String type, String text)\n-    {\n-\tctype = text;\n-\tsetText(text);\n-    }\n-    \n-    public JEditorPane(URL url)\n-      throws IOException\n-    {\n-\tsetPage(url);\n-    }\n-\n-    protected  EditorKit createDefaultEditorKit()\n-    {\treturn new PlainEditorKit();    }\n-    \n-    static EditorKit createEditorKitForContentType(String type)\n-    {\treturn new PlainEditorKit();     }\n-    \n-  void fireHyperlinkUpdate(HyperlinkEvent e)\n+  public JEditorPane(URL url) throws IOException\n   {\n+    setPage(url);\n+  }\n+\n+  protected EditorKit createDefaultEditorKit()\n+  {\n+    return new PlainEditorKit();\n+  }\n+\n+  protected static EditorKit createEditorKitForContentType(String type)\n+  {\n+    return new PlainEditorKit();\n+  }\n+\n+  /**\n+   * Sends a given <code>HyperlinkEvent</code> to all registered listeners.\n+   *\n+   * @param event the event to send\n+   */\n+  public void fireHyperlinkUpdate(HyperlinkEvent event)\n+  {\n+    HyperlinkListener[] listeners = getHyperlinkListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+       listeners[index].hyperlinkUpdate(event);\n   }\n \n   public AccessibleContext getAccessibleContext()\n-  {      return null;  }\n+  {\n+    return null;\n+  }\n \n-  String getContentType()\n-    {  return ctype;   }\n+  public String getContentType()\n+  {\n+    return ctype;\n+  }\n \n-  EditorKit getEditorKit()\n-    {  return kit;    }\n-    \n-  static String getEditorKitClassNameForContentType(String type)\n-    { return \"text/plain\";  }\n-  \n-  EditorKit getEditorKitForContentType(String type)\n-    { return kit;  }\n-    \n-    public Dimension getPreferredSize()\n-    {\n-\t//Returns the preferred size for the JEditorPane.  \n-\treturn super.getPreferredSize();\n-    }\n+  public EditorKit getEditorKit()\n+  {\n+    return kit;\n+  }\n+\n+  public static String getEditorKitClassNameForContentType(String type)\n+  {\n+    return \"text/plain\";\n+  }\n+\n+  public EditorKit getEditorKitForContentType(String type)\n+  {\n+    return kit;\n+  }\n+\n+  /**\n+   * Returns the preferred size for the JEditorPane.  \n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    return super.getPreferredSize();\n+  }\n \n   public boolean getScrollableTracksViewportHeight()\n-    {  return false;  }\n+  {\n+    return false;\n+  }\n+\n   public boolean getScrollableTracksViewportWidth()\n-    {  return false;  }\n-\n-  URL getPage()\n-    { return page_url;  }\n-\n-  protected  InputStream getStream(URL page)\n-    {\t\n-\ttry {\n-\t    return page.openStream();    \n-\t} catch (Exception e) {\n-\t    System.out.println(\"Hhmmm, failed to open stream: \" + e);\n-\t}\t\n-\treturn null;\n-    }\n-\n-    public String getText()\n-    { return super.getText();    }\n-    \n-    public String getUIClassID()\n-    {    return \"EditorPaneUI\";  }\n-\n-    public boolean isFocusCycleRoot()\n-    { return focus_root;    }\n-\n-    public boolean isManagingFocus()\n-    { return manages_focus;  }\n-\n-  protected  String paramString()\n-    { return \"JEditorPane\";  }\n-    \n-  protected  void processComponentKeyEvent(KeyEvent e)\n-    {\n-\t//Overridden to handle processing of tab/shift tab. \n-    }\n-    \n+  {\n+    return false;\n+  }\n+\n+  public URL getPage()\n+  {\n+    return page_url;\n+  }\n+\n+  protected InputStream getStream(URL page)\n+  {\n+    try\n+      {\n+\treturn page.openStream();\n+      }\n+    catch (Exception e)\n+      {\n+\tSystem.out.println(\"Hhmmm, failed to open stream: \" + e);\n+      }\n+    return null;\n+  }\n+\n+  public String getText()\n+  {\n+    return super.getText();\n+  }\n+\n+  public String getUIClassID()\n+  {\n+    return \"EditorPaneUI\";\n+  }\n+\n+  public boolean isFocusCycleRoot()\n+  {\n+    return focus_root;\n+  }\n+\n+  public boolean isManagingFocus()\n+  {\n+    return manages_focus;\n+  }\n+\n+  protected String paramString()\n+  {\n+    return \"JEditorPane\";\n+  }\n+\n+  /**\n+   * Overridden to handle processing of tab/shift tab. \n+   */\n+  protected void processComponentKeyEvent(KeyEvent e)\n+  {\n+  }\n+\n+  /**\n+   * Make sure that TAB and Shift-TAB events get consumed, so that awt doesn't attempt focus traversal.  \n+   */\n   protected void processKeyEvent(KeyEvent e)\n-    {\n-\t//Make sure that TAB and Shift-TAB events get consumed, so that awt doesn't attempt focus traversal.  \n-    }\n-    \n-    void read(InputStream in, Object desc)\n-    {\n-\t//This method initializes from a stream. \n-    }\n-    \n-    static void registerEditorKitForContentType(String type, String classname)\n-    {\n-\t//Establishes the default bindings of type to classname. \n-    }\n-    \n-    static void registerEditorKitForContentType(String type, String classname, ClassLoader loader)\n-    {\n-\t//Establishes the default bindings of type to classname.  \n-    }\n-    \n-    void replaceSelection(String content)\n-    {\n-\t//Replaces the currently selected content with new content represented by the given string. \n-    }\n-    \n-    protected  void scrollToReference(String reference)\n-    {\n-\t//Scrolls the view to the given reference location (that is, the value returned by the UL.getRef method for the URL being displayed).  \n-    }\n-    \n-    void setContentType(String type)\n-    {\n-\tctype = type;\n-\tinvalidate();\n-\trepaint();\n-    }\n-    \n-    void setEditorKit(EditorKit kit)\n-    {\n-\tthis.kit = kit;\n-\tinvalidate();\n-\trepaint();\n-    }\n-    \n-    void setEditorKitForContentType(String type, EditorKit k)\n-    {\n-\tctype = type;\n-\tsetEditorKit(k);\n-    }\n-  \n-  void setPage(String url)\n-    throws IOException\n-    {\n-\t//  Sets the current URL being displayed.  \n-    }\n-    \n-    void setPage(URL page)\n-    throws IOException\n-    {\n-\t//    Sets the current URL being displayed.  \n-    }\n-    \n-    public void setText(String t)\n-    {\t\n-\tsuper.setText(t);\n-    }\n+  {\n+  }\n+\n+  /**\n+   * This method initializes from a stream. \n+   */\n+  public void read(InputStream in, Object desc)\n+  {\n+  }\n+\n+  /**\n+   * Establishes the default bindings of type to classname. \n+   */\n+  public static void registerEditorKitForContentType(String type,\n+                                                     String classname)\n+  {\n+  }\n+\n+  /**\n+   * Establishes the default bindings of type to classname.  \n+   */\n+  public static void registerEditorKitForContentType(String type,\n+                                                     String classname,\n+                                                     ClassLoader loader)\n+  {\n+  }\n+\n+  /**\n+   * Replaces the currently selected content with new content represented by the given string. \n+   */\n+  public void replaceSelection(String content)\n+  {\n+  }\n+\n+  /**\n+   * Scrolls the view to the given reference location (that is, the value returned by the UL.getRef method for the URL being displayed).  \n+   */\n+  protected void scrollToReference(String reference)\n+  {\n+  }\n+\n+  public void setContentType(String type)\n+  {\n+    ctype = type;\n+    invalidate();\n+    repaint();\n+  }\n+\n+  public void setEditorKit(EditorKit kit)\n+  {\n+    this.kit = kit;\n+    invalidate();\n+    repaint();\n+  }\n+\n+  public void setEditorKitForContentType(String type, EditorKit k)\n+  {\n+    ctype = type;\n+    setEditorKit(k);\n+  }\n+\n+  /**\n+   * Sets the current URL being displayed.  \n+   */\n+  public void setPage(String url) throws IOException\n+  {\n+  }\n+\n+  /**\n+   * Sets the current URL being displayed.  \n+   */\n+  public void setPage(URL page) throws IOException\n+  {\n+  }\n \n+  public void setText(String t)\n+  {\n+    super.setText(t);\n+  }\n+\n+  /**\n+   * Add a <code>HyperlinkListener</code> object to this editor pane.\n+   *\n+   * @param listener the listener to add\n+   */\n   public void addHyperlinkListener(HyperlinkListener listener)\n   {\n-    listenerList.add (HyperlinkListener.class, listener);\n+    listenerList.add(HyperlinkListener.class, listener);\n   }\n-    \n-  public void removeHyperlinkListener (HyperlinkListener listener)\n+\n+  /**\n+   * Removes a <code>HyperlinkListener</code> object to this editor pane.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeHyperlinkListener(HyperlinkListener listener)\n   {\n-    listenerList.remove (HyperlinkListener.class, listener);\n+    listenerList.remove(HyperlinkListener.class, listener);\n   }\n \n   /**\n+   * Returns all added <code>HyperlinkListener</code> objects.\n+   *\n+   * @return array of listeners\n+   *\n    * @since 1.4\n    */\n   public HyperlinkListener[] getHyperlinkListeners()\n   {\n-    return (HyperlinkListener[]) getListeners (HyperlinkListener.class);\n+    return (HyperlinkListener[]) getListeners(HyperlinkListener.class);\n   }\n-    \n-} // class JEditorPane\n+}"}, {"sha": "2a23eff25564cdc853bb7100f6889729c8900e67", "filename": "libjava/javax/swing/JFileChooser.java", "status": "modified", "additions": 36, "deletions": 62, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFileChooser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFileChooser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJFileChooser.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -61,55 +61,30 @@ public class JFileChooser extends JComponent implements Accessible {\n \n   private static final long serialVersionUID = 3162921138695327837L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJFileChooser\n-\t */\n-\tprotected class AccessibleJFileChooser extends AccessibleJComponent {\n-\n-          private static final long serialVersionUID = 3318922050345221200L;\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJFileChooser\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJFileChooser(JFileChooser component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJFileChooser()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.FILE_CHOOSER;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJFileChooser\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+  /**\n+   * AccessibleJFileChooser\n+   */\n+  protected class AccessibleJFileChooser extends AccessibleJComponent\n+  {\n+    private static final long serialVersionUID = 8205148454060169244L;\n+\n+    /**\n+     * Constructor AccessibleJFileChooser\n+     * @param component TODO\n+     */\n+    protected AccessibleJFileChooser()\n+    {\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.FILE_CHOOSER;\n+    }\n+  }\n \n \t/**\n \t * uiClassID\n@@ -969,16 +944,15 @@ protected String paramString() {\n \t\treturn null; // TODO\n \t} // paramString()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJFileChooser(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JFileChooser\n+  /**\n+   * getAccessibleContext\n+   * @returns AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJFileChooser();\n+\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "8e10a7fc9a65dba5c15a2faf731a7a61af499e75", "filename": "libjava/javax/swing/JFormattedTextField.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JFormattedTextField.java --\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -52,7 +52,7 @@\n  */\n public class JFormattedTextField extends JTextField\n {\n-  private static final long serialVersionUID = 2889768923115424035L;\n+  private static final long serialVersionUID = 5464657870110180632L;\n \n   public abstract static class AbstractFormatter implements Serializable\n   {"}, {"sha": "3c254ab04482ce2c5f4c06a468d96ff436f6ba8e", "filename": "libjava/javax/swing/JFrame.java", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJFrame.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -59,10 +59,23 @@\n  */\n public class JFrame extends Frame implements WindowConstants, RootPaneContainer\n {\n-    protected  AccessibleContext accessibleContext;\n+  private static final long serialVersionUID = -3362141868504252139L;\n+  \n+  protected  AccessibleContext accessibleContext;\n+  \n+  private int close_action = HIDE_ON_CLOSE;    \n+  \n+  private static boolean defaultLookAndFeelDecorated = false;    \n \n-    private int close_action = HIDE_ON_CLOSE;    \n-    \n+  public static void setDefaultLookAndFeelDecorated(boolean d)\n+  {\n+    defaultLookAndFeelDecorated = d;\n+  }\n+\n+  public static boolean isDefaultLookAndFeelDecorated()\n+  {\n+    return defaultLookAndFeelDecorated;\n+  }\n \n     /***************************************************\n      *\n@@ -111,10 +124,10 @@ public Dimension getPreferredSize()\n     return d;\n   }\n \n-    JMenuBar getJMenuBar()\n+  public JMenuBar getJMenuBar()\n     {    return getRootPane().getJMenuBar();   }\n     \n-    void setJMenuBar(JMenuBar menubar)\n+  public void setJMenuBar(JMenuBar menubar)\n     {    getRootPane().setJMenuBar(menubar); }\n     \n "}, {"sha": "12c9d139db2538d5439ae3a228572994eb36c9fc", "filename": "libjava/javax/swing/JInternalFrame.java", "status": "modified", "additions": 1663, "deletions": 14, "changes": 1677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJInternalFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJInternalFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJInternalFrame.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -35,24 +35,1673 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Graphics;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.LayoutManager;\n+import java.awt.Rectangle;\n+import java.beans.PropertyVetoException;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import javax.accessibility.AccessibleValue;\n+import javax.swing.event.InternalFrameEvent;\n+import javax.swing.event.InternalFrameListener;\n+import javax.swing.plaf.DesktopIconUI;\n+import javax.swing.plaf.InternalFrameUI;\n+\n \n-public class JInternalFrame extends JComponent\n-/*implements Accessible, WindowConstants, RootPaneContainer*/\n+/**\n+ * This class implements a Swing widget that looks and acts like a native\n+ * frame. The frame can be dragged, resized, closed, etc. Typically,\n+ * JInternalFrames are placed in JDesktopPanes. The actions that the\n+ * JInternalFrame performs (maximizing, minimizing, etc.) are performed by a\n+ * DesktopManager. As with regular frames, components are added by calling\n+ * frame.getContentPane().add.\n+ */\n+public class JInternalFrame extends JComponent implements Accessible,\n+                                                          WindowConstants,\n+                                                          RootPaneContainer\n {\n+  /** DOCUMENT ME! */\n   private static final long serialVersionUID = -5425177187760785402L;\n \n-  public static final String CONTENT_PANE_PROPERTY = \"contentPane\";\n-  public static final String MENU_BAR_PROPERTY = \"JMenuBar\";\n-  public static final String TITLE_PROPERTY = \"title\";\n-  public static final String LAYERED_PANE_PROPERTY = \"layeredPane\";\n-  public static final String ROOT_PANE_PROPERTY = \"rootPane\";\n-  public static final String GLASS_PANE_PROPERTY = \"glassPane\";\n-  public static final String FRAME_ICON_PROPERTY = \"frameIcon\";\n-  public static final String IS_SELECTED_PROPERTY = \"selected\";\n-  public static final String IS_CLOSED_PROPERTY = \"closed\";\n-  public static final String IS_MAXIMUM_PROPERTY = \"maximum\";\n-  public static final String IS_ICON_PROPERTY = \"icon\";\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJInternalFrame extends AccessibleJComponent\n+    implements AccessibleValue\n+  {\n+    /**\n+     * Creates a new AccessibleJInternalFrame object.\n+     */\n+    protected AccessibleJInternalFrame()\n+    {\n+      super();\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public String getAccessibleName()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleValue getAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getCurrentAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getMaximumAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getMinimumAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param n DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public boolean setCurrentAccessibleValue(Number n)\n+    {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * This class represents the JInternalFrame while it is iconified.\n+   */\n+  public static class JDesktopIcon extends JComponent implements Accessible\n+  {\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    protected class AccessibleJDesktopIcon extends AccessibleJComponent\n+      implements AccessibleValue\n+    {\n+      /**\n+       * Creates a new AccessibleJDesktopIcon object.\n+       */\n+      protected AccessibleJDesktopIcon()\n+      {\n+\tsuper();\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public AccessibleRole getAccessibleRole()\n+      {\n+\treturn null;\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public AccessibleValue getAccessibleValue()\n+      {\n+\treturn null;\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public Number getCurrentAccessibleValue()\n+      {\n+\treturn null;\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public Number getMaximumAccessibleValue()\n+      {\n+\treturn null;\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public Number getMinimumAccessibleValue()\n+      {\n+\treturn null;\n+      }\n+\n+      /**\n+       * DOCUMENT ME!\n+       *\n+       * @param n DOCUMENT ME!\n+       *\n+       * @return DOCUMENT ME!\n+       */\n+      public boolean setCurrentAccessibleValue(Number n)\n+      {\n+\treturn false;\n+      }\n+    }\n+\n+    /** The JInternalFrame this DesktopIcon represents. */\n+    JInternalFrame frame;\n+\n+    /**\n+     * Creates a new JDesktopIcon object for representing the given frame.\n+     *\n+     * @param f The JInternalFrame to represent.\n+     */\n+    public JDesktopIcon(JInternalFrame f)\n+    {\n+      frame = f;\n+      updateUI();\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleContext getAccessibleContext()\n+    {\n+      if (accessibleContext == null)\n+\taccessibleContext = new AccessibleJDesktopIcon();\n+      return accessibleContext;\n+    }\n+\n+    /**\n+     * This method returns the JDesktopPane this JDesktopIcon is in.\n+     *\n+     * @return The JDesktopPane this JDesktopIcon is in.\n+     */\n+    public JDesktopPane getDesktopPane()\n+    {\n+      JDesktopPane p = (JDesktopPane) SwingUtilities.getAncestorOfClass(JDesktopPane.class,\n+                                                                        this);\n+      return p;\n+    }\n+\n+    /**\n+     * This method returns the JInternalFrame this JDesktopIcon represents.\n+     *\n+     * @return The JInternalFrame this JDesktopIcon represents.\n+     */\n+    public JInternalFrame getInternalFrame()\n+    {\n+      return frame;\n+    }\n+\n+    /**\n+     * This method returns the UI that is responsible for the JDesktopIcon.\n+     *\n+     * @return The UI that is responsible for the JDesktopIcon.\n+     */\n+    public DesktopIconUI getUI()\n+    {\n+      return (DesktopIconUI) ui;\n+    }\n+\n+    /**\n+     * This method returns the String identifier that is used to determine\n+     * which class is used for JDesktopIcon's UI.\n+     *\n+     * @return A String identifier for the UI class.\n+     */\n+    public String getUIClassID()\n+    {\n+      return \"DesktopIconUI\";\n+    }\n+\n+    /**\n+     * This method sets the JInternalFrame that this JDesktopIcon represents.\n+     *\n+     * @param f The JInternalFrame that this JDesktopIcon represents.\n+     */\n+    public void setInternalFrame(JInternalFrame f)\n+    {\n+      frame = f;\n+    }\n+\n+    /**\n+     * This method sets the UI used for this JDesktopIcon.\n+     *\n+     * @param ui The UI to use.\n+     */\n+    public void setUI(DesktopIconUI ui)\n+    {\n+      super.setUI(ui);\n+    }\n+\n+    /**\n+     * This method restores the UI property to the defaults.\n+     */\n+    public void updateUI()\n+    {\n+      setUI((DesktopIconUI) UIManager.getUI(this));\n+    }\n+  }\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the contentPane property\n+   * changes.\n+   */\n+  public static String CONTENT_PANE_PROPERTY = \"contentPane\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the frameIcon property\n+   * changes.\n+   */\n+  public static String FRAME_ICON_PROPERTY = \"frameIcon\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the glassPane property\n+   * changes.\n+   */\n+  public static String GLASS_PANE_PROPERTY = \"glassPane\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the closed property\n+   * changes.\n+   */\n+  public static String IS_CLOSED_PROPERTY = \"closed\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the icon property\n+   * changes.\n+   */\n+  public static String IS_ICON_PROPERTY = \"icon\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the maximum property\n+   * changes.\n+   */\n+  public static String IS_MAXIMUM_PROPERTY = \"maximum\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the selected property\n+   * changes.\n+   */\n+  public static String IS_SELECTED_PROPERTY = \"selected\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the layeredPane property\n+   * changes.\n+   */\n+  public static String LAYERED_PANE_PROPERTY = \"layeredPane\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the jMenuBar property\n+   * changes.\n+   */\n+  public static String MENU_BAR_PROPERTY = \"jMenuBar\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the rootPane property\n+   * changes.\n+   */\n+  public static String ROOT_PANE_PROPERTY = \"rootPane\";\n+\n+  /**\n+   * The property fired in a PropertyChangeEvent when the title property\n+   * changes.\n+   */\n+  public static String TITLE_PROPERTY = \"title\";\n+\n+  /** Whether the JInternalFrame is closable. */\n+  protected boolean closable;\n+\n+  /** Whether the JInternalFrame can be iconified. */\n+  protected boolean iconable;\n+\n+  /** Whether the JInternalFrame is closed. */\n+  protected boolean isClosed;\n+\n+  /** Whether the JInternalFrame has been iconified. */\n+  protected boolean isIcon;\n+\n+  /** Whether the JInternalFrame has been maximized. */\n+  protected boolean isMaximum;\n+\n+  /** Whether the JInternalFrame is the active frame. */\n+  protected boolean isSelected;\n+\n+  /** Whether the JInternalFrame can be maximized. */\n+  protected boolean maximizable;\n+\n+  /** Whether the JInternalFrame has rootPaneChecking enabled. */\n+  protected boolean rootPaneCheckingEnabled = true;\n+\n+  /** Whether the JInternalFrame is resizable. */\n+  protected boolean resizable;\n+\n+  /**\n+   * The JDesktopIcon that represents the JInternalFrame while it is\n+   * iconified.\n+   */\n+  protected JDesktopIcon desktopIcon;\n+\n+  /** The icon used in the JMenuBar in the TitlePane. */\n+  protected Icon frameIcon;\n+\n+  /** The rootPane of the JInternalFrame. */\n+  protected JRootPane rootPane;\n+\n+  /** The title on the TitlePane of the JInternalFrame. */\n+  protected String title;\n+\n+  /** The bounds of the JInternalFrame before it was maximized. */\n+  private transient Rectangle storedBounds;\n+\n+  /** The Component that receives focus by default. */\n+  private transient Component defaultFocus;\n+\n+  /** The default close action taken, */\n+  private transient int defaultCloseOperation = DISPOSE_ON_CLOSE;\n+\n+  /** Whether the JInternalFrame has become visible for the very first time. */\n+  private transient boolean isFirstTimeVisible = true;\n+\n+  /**\n+   * Whether the JInternalFrame is in the transition from being a maximized\n+   * frame back to a regular sized frame.\n+   */\n+  private transient boolean maxTransition = false;\n+\n+  /** DOCUMENT ME! */\n+  private transient boolean wasIcon = false;\n+\n+  /**\n+   * Creates a new JInternalFrame object that has no title, and is\n+   * non-resizable, non-maximizable, non-iconifiable, and non-closable.\n+   */\n+  public JInternalFrame()\n+  {\n+    this(null, false, false, false, false);\n+  }\n+\n+  /**\n+   * Creates a new JInternalFrame object with the given title and is\n+   * non-resizable, non-maximizable, non-iconifiable, and non-closable.\n+   *\n+   * @param title The title displayed in the JInternalFrame.\n+   */\n+  public JInternalFrame(String title)\n+  {\n+    this(title, false, false, false, false);\n+  }\n+\n+  /**\n+   * Creates a new JInternalFrame object with the given title and resizable\n+   * properties. The JInternalFrame is non-maximizable, non-iconifiable, and\n+   * non-closable.\n+   *\n+   * @param title The title displayed in the JInternalFrame.\n+   * @param resizable Whether the JInternalFrame is resizable.\n+   */\n+  public JInternalFrame(String title, boolean resizable)\n+  {\n+    this(title, resizable, false, false, false);\n+  }\n+\n+  /**\n+   * Creates a new JInternalFrame object with the given title, resizable, and\n+   * closable properties. The JInternalFrame is non-maximizable and\n+   * non-iconifiable.\n+   *\n+   * @param title The title displayed in the JInternalFrame.\n+   * @param resizable Whether the JInternalFrame is resizable.\n+   * @param closable Whether the JInternalFrame is closable.\n+   */\n+  public JInternalFrame(String title, boolean resizable, boolean closable)\n+  {\n+    this(title, resizable, closable, false, false);\n+  }\n+\n+  /**\n+   * Creates a new JInternalFrame object with the given title, resizable,\n+   * closable and maximizable properties. The JInternalFrame is\n+   * non-iconifiable.\n+   *\n+   * @param title The title displayed in the JInternalFrame.\n+   * @param resizable Whether the JInternalFrame is resizable.\n+   * @param closable Whether the JInternalFrame is closable.\n+   * @param maximizable Whether the JInternalFrame is maximizable.\n+   */\n+  public JInternalFrame(String title, boolean resizable, boolean closable,\n+                        boolean maximizable)\n+  {\n+    this(title, resizable, closable, maximizable, false);\n+  }\n+\n+  /**\n+   * Creates a new JInternalFrame object with the given title, resizable,\n+   * closable, maximizable and iconifiable properties.\n+   *\n+   * @param title The title displayed in the JInternalFrame.\n+   * @param resizable Whether the JInternalFrame is resizable.\n+   * @param closable Whether the JInternalFrame is closable.\n+   * @param maximizable Whether the JInternalFrame is maximizable.\n+   * @param iconifiable Whether the JInternalFrame is iconifiable.\n+   */\n+  public JInternalFrame(String title, boolean resizable, boolean closable,\n+                        boolean maximizable, boolean iconifiable)\n+  {\n+    this.title = title;\n+    this.resizable = resizable;\n+    this.closable = closable;\n+    this.maximizable = maximizable;\n+    this.iconable = iconifiable;\n+    storedBounds = new Rectangle();\n+\n+    setRootPaneCheckingEnabled(false);\n+    setRootPane(createRootPane());\n+\n+    updateUI();\n+    setRootPaneCheckingEnabled(true);\n+  }\n+\n+  /**\n+   * This method adds Components to this Container. For JInternalFrames,\n+   * instead of calling add directly on the JInternalFrame, it should be\n+   * called with JInternalFrame.getContentPane().add. If root pane checking\n+   * is enabled, calling this method will cause an exception to be thrown.\n+   *\n+   * @param comp The Component to add.\n+   * @param constraints The constraints on the Component added.\n+   * @param index The position to place the Component.\n+   *\n+   * @throws Error DOCUMENT ME!\n+   */\n+  protected void addImpl(Component comp, Object constraints, int index)\n+  {\n+    if (isRootPaneCheckingEnabled())\n+      throw new Error(\"Do not use add() on JInternalPane directly. Use getContentPane().add() instead\");\n+\n+    super.addImpl(comp, constraints, index);\n+  }\n+\n+  /**\n+   * This method adds an InternalFrameListener to this JInternalFrame.\n+   *\n+   * @param l The listener to add.\n+   */\n+  public void addInternalFrameListener(InternalFrameListener l)\n+  {\n+    listenerList.add(InternalFrameListener.class, l);\n+  }\n+\n+  /**\n+   * This method is used to create a root pane for the JInternalFrame. This\n+   * method is called by the constructors.\n+   *\n+   * @return A root pane for the JInternalFrame to use.\n+   */\n+  protected JRootPane createRootPane()\n+  {\n+    return new JRootPane();\n+  }\n+\n+  /**\n+   * This method makes this JInternalFrame invisible, unselected and closed.\n+   * If this JInternalFrame is not closed already, it will fire an\n+   * INTERNAL_FRAME_CLoSED event. This method is similar to setClosed but it\n+   * doesn't give vetoable listeners a chance to veto and it will not fire an\n+   * INTERNAL_FRAME_CLOSING event.\n+   */\n+  public void dispose()\n+  {\n+    hide();\n+    JDesktopPane pane = getDesktopPane();\n+    if (pane != null)\n+      pane.setSelectedFrame(null);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    setSelected(false);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t    // Do nothing if they don't want to be unselected.\n+\t  }\n+      }\n+    isClosed = true;\n+    fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_CLOSED);\n+    removeNotify();\n+  }\n+\n+  /**\n+   * This method is used for closing this JInternalFrame. It fires an\n+   * INTERNAL_FRAME_CLOSING event and then performs the action specified by\n+   * the default close operation.\n+   */\n+  public void doDefaultCloseAction()\n+  {\n+    fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_CLOSING);\n+    switch (getDefaultCloseOperation())\n+      {\n+      case HIDE_ON_CLOSE:\n+\thide();\n+\tbreak;\n+      case DISPOSE_ON_CLOSE:\n+\tdispose();\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * This method fires an InternalFrameEvent to the listeners.\n+   *\n+   * @param id The type of event being fired. See InternalFrameEvent.\n+   */\n+  protected void fireInternalFrameEvent(int id)\n+  {\n+    Object[] ifListeners = listenerList.getListenerList();\n+    InternalFrameEvent evt = new InternalFrameEvent(this, id);\n+    switch (id)\n+      {\n+      case InternalFrameEvent.INTERNAL_FRAME_CLOSING:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1])\n+\t      .internalFrameClosing(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_ACTIVATED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1])\n+\t      .internalFrameActivated(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_CLOSED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1]).internalFrameClosed(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_DEACTIVATED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1])\n+\t      .internalFrameDeactivated(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_DEICONIFIED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1])\n+\t      .internalFrameDeiconified(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_ICONIFIED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1])\n+\t      .internalFrameIconified(evt);\n+\t  }\n+\tbreak;\n+      case InternalFrameEvent.INTERNAL_FRAME_OPENED:\n+\tfor (int i = ifListeners.length - 2; i >= 0; i -= 2)\n+\t  {\n+\t    if (ifListeners[i] == InternalFrameListener.class)\n+\t      ((InternalFrameListener) ifListeners[i + 1]).internalFrameOpened(evt);\n+\t  }\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJInternalFrame();\n+    return accessibleContext;\n+  }\n+\n+  /**\n+   * This method returns the Content Pane for this JInternalFrame.\n+   *\n+   * @return The Content Pane for this JInternalFrame.\n+   */\n+  public Container getContentPane()\n+  {\n+    return getRootPane().getContentPane();\n+  }\n+\n+  /**\n+   * This method returns the default action taken when this JInternalFrame is\n+   * closed.\n+   *\n+   * @return The default action taken when this JInternalFrame is closed.\n+   */\n+  public int getDefaultCloseOperation()\n+  {\n+    return defaultCloseOperation;\n+  }\n+\n+  /**\n+   * This method returns the JDesktopIcon that represents this JInternalFrame\n+   * while it is iconified.\n+   *\n+   * @return The JDesktopIcon that represents this JInternalFrame while it is\n+   *         iconified.\n+   */\n+  public JDesktopIcon getDesktopIcon()\n+  {\n+    if (desktopIcon == null)\n+      desktopIcon = new JDesktopIcon(this);\n+    return desktopIcon;\n+  }\n+\n+  /**\n+   * This method searches this JInternalFrame ancestors for an instance of\n+   * JDesktopPane. If one is found, it is returned. If none is found, then it\n+   * will search the JDesktopIcon for a JDesktopPane.\n+   *\n+   * @return The JDesktopPane that this JInternalFrame belongs to.\n+   */\n+  public JDesktopPane getDesktopPane()\n+  {\n+    JDesktopPane value = (JDesktopPane) SwingUtilities.getAncestorOfClass(JDesktopPane.class,\n+                                                                          this);\n+    if (value == null && desktopIcon != null)\n+      value = desktopIcon.getDesktopPane();\n+    return value;\n+  }\n+\n+  /**\n+   * This method returns null because this must always be the root of a focus\n+   * traversal.\n+   *\n+   * @return null.\n+   */\n+  public Container getFocusCycleRootAncestor()\n+  {\n+    // as defined.\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the child Component that will receive focus if this\n+   * JInternalFrame is selected.\n+   *\n+   * @return The child Component that will receive focus.\n+   */\n+  public Component getFocusOwner()\n+  {\n+    if (isSelected())\n+      {\n+\tComponent focus = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();\n+\tif (SwingUtilities.isDescendingFrom(focus, this))\n+\t  {\n+\t    defaultFocus = focus;\n+\t    return focus;\n+\t  }\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the Frame Icon (the icon used in the JInternalFrame\n+   * TitlePane and iconified frame).\n+   *\n+   * @return The Frame Icon.\n+   */\n+  public Icon getFrameIcon()\n+  {\n+    return frameIcon;\n+  }\n+\n+  /**\n+   * This method returns the Glass Pane used with this JInternalFrame.\n+   *\n+   * @return The Glass Pane used with this JInternalFrame.\n+   */\n+  public Component getGlassPane()\n+  {\n+    return getRootPane().getGlassPane();\n+  }\n+\n+  /**\n+   * This method returns an array of InternalFrameListeners that are listening\n+   * to this JInternalFrame.\n+   *\n+   * @return An array of InternalFrameListeners that are listening to this\n+   *         JInternalFrame.\n+   */\n+  public InternalFrameListener[] getInternalFrameListeners()\n+  {\n+    return (InternalFrameListener[]) listenerList.getListeners(InternalFrameListener.class);\n+  }\n+\n+  /**\n+   * This method returns the JMenuBar for this JInternalFrame.\n+   *\n+   * @return The JMenuBar for this JInternalFrame.\n+   */\n+  public JMenuBar getJMenuBar()\n+  {\n+    return getRootPane().getJMenuBar();\n+  }\n+\n+  /**\n+   * This method returns the layer that this JInternalFrame resides in.\n+   *\n+   * @return The layer that this JInternalFrame resides in.\n+   */\n+  public int getLayer()\n+  {\n+    JDesktopPane pane = getDesktopPane();\n+    if (pane != null)\n+      return pane.getLayer(this).intValue();\n+    return -1;\n+  }\n+\n+  /**\n+   * This method returns the LayeredPane for this JInternalFrame.\n+   *\n+   * @return The LayeredPane for this JInternalFrame.\n+   */\n+  public JLayeredPane getLayeredPane()\n+  {\n+    return getRootPane().getLayeredPane();\n+  }\n+\n+  /**\n+   * This method is deprecated. This method returns the JMenuBar for this\n+   * JInternalFrame.\n+   *\n+   * @return The JMenuBar for this JInternalFrame.\n+   */\n+  public JMenuBar getMenuBar()\n+  {\n+    return getJMenuBar();\n+  }\n+\n+  /**\n+   * This method returns the child Component that will receive focus when the\n+   * JInternalFrame is selected. If the JInternalFrame is selected, this\n+   * method returns getFocusOwner(). Otherwise, it will return the child\n+   * Component that most recently requested focus. If that is null, then the\n+   * initial focus Component is returned. If that is null, then the default\n+   * focus component is returned.\n+   *\n+   * @return The most recent focus owner.\n+   */\n+  public Component getMostRecentFocusOwner()\n+  {\n+    if (isSelected())\n+      return getFocusOwner();\n+    else\n+      return defaultFocus;\n+  }\n+\n+  /**\n+   * This method returns the bounds of the JInternalFrame if it is not\n+   * maximized. If it is maximized, it returns the bounds of the\n+   * JInternalFrame before it was maximized (the bounds that it will be\n+   * restored to).\n+   *\n+   * @return A Rectangle that contains this JInternalFrame's normal bounds (or\n+   *         just its bounds if it is not maximized).\n+   */\n+  public Rectangle getNormalBounds()\n+  {\n+    if (! isMaximum() && ! maxTransition)\n+      return getBounds();\n+    else\n+      return storedBounds;\n+  }\n+\n+  /**\n+   * This method returns the Root Pane for this JInternalFrame.\n+   *\n+   * @return The Root Pane for this JInternalFrame.\n+   */\n+  public JRootPane getRootPane()\n+  {\n+    return rootPane;\n+  }\n+\n+  /**\n+   * This method sets the title of the JInternalFrame.\n+   *\n+   * @return The String displayed in the TitlePane of this JInternalFrame.\n+   */\n+  public String getTitle()\n+  {\n+    return title;\n+  }\n+\n+  /**\n+   * This method returns the UI used to represent the JInternalFrame.\n+   *\n+   * @return The UI used to represent the JInternalFrame.\n+   */\n+  public InternalFrameUI getUI()\n+  {\n+    return (InternalFrameUI) ui;\n+  }\n+\n+  /**\n+   * This method returns a String identifier that is used to determine which\n+   * class acts as the JInternalFrame's UI.\n+   *\n+   * @return A String identifier to determine a UI class.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"InternalFrameUI\";\n+  }\n+\n+  /**\n+   * This method returns null.\n+   *\n+   * @return null.\n+   */\n+  public String getWarningString()\n+  {\n+    // as defined.\n+    return null;\n+  }\n+\n+  /**\n+   * This method deselects this JInternalFrame and hides it.\n+   */\n+  public void hide()\n+  {\n+    JDesktopPane pane = getDesktopPane();\n+    if (pane != null)\n+      pane.setSelectedFrame(null);\n+    else\n+      {\n+\ttry\n+\t  {\n+\t    setSelected(false);\n+\t  }\n+\tcatch (PropertyVetoException e)\n+\t  {\n+\t    // Do nothing.\n+\t  }\n+      }\n+    super.hide();\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame is closable.\n+   *\n+   * @return Whether this JInternalFrame is closable.\n+   */\n+  public boolean isClosable()\n+  {\n+    return closable;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame has been closed.\n+   *\n+   * @return Whether this JInternalFrame is closed.\n+   */\n+  public boolean isClosed()\n+  {\n+    return isClosed;\n+  }\n+\n+  /**\n+   * This must always return true.\n+   *\n+   * @return True\n+   */\n+  public boolean isFocusCycleRoot()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame is currently iconified.\n+   *\n+   * @return Whether this JInternalFrame is currently iconified.\n+   */\n+  public boolean isIcon()\n+  {\n+    return isIcon;\n+  }\n+\n+  /**\n+   * This method returns whether the JInternalFrame can be iconified.\n+   *\n+   * @return Whether the JInternalFrame can be iconified.\n+   */\n+  public boolean isIconifiable()\n+  {\n+    return iconable;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame can be maximized.\n+   *\n+   * @return Whether this JInternalFrame can be maximized.\n+   */\n+  public boolean isMaximizable()\n+  {\n+    return maximizable;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame is currently maximized.\n+   *\n+   * @return Whether this JInternalFrame is maximized.\n+   */\n+  public boolean isMaximum()\n+  {\n+    return isMaximum;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame is resizable.\n+   *\n+   * @return Whether this JInternalFrame is resizable.\n+   */\n+  public boolean isResizable()\n+  {\n+    return resizable;\n+  }\n+\n+  /**\n+   * This method returns whether root pane checking is enabled. If root pane\n+   * checking is enabled, then calls to addImpl and setLayout will throw\n+   * exceptions.\n+   *\n+   * @return Whether root pane checking is enabled.\n+   */\n+  protected boolean isRootPaneCheckingEnabled()\n+  {\n+    return rootPaneCheckingEnabled;\n+  }\n+\n+  /**\n+   * This method returns whether this JInternalFrame is selected.\n+   *\n+   * @return Whether this JInternalFrame is selected.\n+   */\n+  public boolean isSelected()\n+  {\n+    return isSelected;\n+  }\n+\n+  /**\n+   * A helper method that moves this JInternalFrame to the back if the parent\n+   * is a JLayeredPane.\n+   */\n+  public void moveToBack()\n+  {\n+    if (getParent() instanceof JLayeredPane)\n+      ((JLayeredPane) getParent()).moveToBack(this);\n+  }\n+\n+  /**\n+   * A helper method that moves this JInternalFrame to the front if the parent\n+   * is a JLayeredPane.\n+   */\n+  public void moveToFront()\n+  {\n+    if (getParent() instanceof JLayeredPane)\n+      ((JLayeredPane) getParent()).moveToFront(this);\n+  }\n+\n+  /**\n+   * This method causes the children of this JInternalFrame to be laid out.\n+   * Before it begins, if this JInternalFrame is an icon, then it will be\n+   * deiconified. If it is maximized, then it will be restored. If either\n+   * operation fails, then this method will return.\n+   */\n+  public void pack()\n+  {\n+    try\n+      {\n+\tif (isIcon())\n+\t  setIcon(false);\n+\telse if (isMaximum())\n+\t  setMaximum(false);\n+      }\n+    catch (PropertyVetoException e)\n+      {\n+\t// Do nothing if they don't want to be restored first.\n+      }\n+    doLayout();\n+  }\n+\n+  /**\n+   * This method is overridden to allow for speedier painting while this\n+   * JInternalFramme is being dragged.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  protected void paintComponent(Graphics g)\n+  {\n+    super.paintComponent(g);\n+  }\n+\n+  /**\n+   * This method returns a String describing this JInternalFrame.\n+   *\n+   * @return A String describing this JInternalFrame.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JInternalFrame\";\n+  }\n+\n+  /**\n+   * This method removes the given Component from the Container.\n+   *\n+   * @param comp The Component to remove.\n+   */\n+  public void remove(Component comp)\n+  {\n+    super.remove(comp);\n+  }\n+\n+  /**\n+   * This method removes an InternalFrameListener from this JInternalFrame.\n+   *\n+   * @param l The listener to remove.\n+   */\n+  public void removeInternalFrameListener(InternalFrameListener l)\n+  {\n+    listenerList.remove(InternalFrameListener.class, l);\n+  }\n+\n+  /**\n+   * This method resizes and positions this JInternalFrame. It also forces a\n+   * relayout of the Container.\n+   *\n+   * @param x The x position of this JInternalFrame.\n+   * @param y The y position of this JInternalFrame.\n+   * @param width The width of this JInternalFrame.\n+   * @param height The height of this JInternalFrame.\n+   */\n+  public void reshape(int x, int y, int width, int height)\n+  {\n+    super.reshape(x, y, width, height);\n+    invalidate();\n+    doLayout();\n+  }\n+\n+  /**\n+   * This method gives focus to the last child Component that had focus. This\n+   * is used by the UI when this JInternalFrame is activated.\n+   */\n+  public void restoreSubcomponentFocus()\n+  {\n+    Component c = getMostRecentFocusOwner();\n+    if (c != null)\n+      c.requestFocus();\n+  }\n+\n+  /**\n+   * This method sets whether this JInternalFrame can be closed.\n+   *\n+   * @param b Whether this JInternalFrame can be closed.\n+   */\n+  public void setClosable(boolean b)\n+  {\n+    closable = b;\n+  }\n+\n+  /**\n+   * This method closes the JInternalFrame if the given boolean is true. If it\n+   * is false, then the result of this method is unspecified. If the\n+   * JInternalFrame is closed, this method does nothing. This method will\n+   * first fire an INTERNAL_FRAME_CLOSING event and give a chance for veto\n+   * listeners to cancel the close. If no listener vetoes the change, the\n+   * closed property is set to true and the JInternalFrame is hidden and\n+   * unselected. The method will finish by firing an INTERNAL_FRAME_CLOSED\n+   * event.\n+   *\n+   * @param b Whether the JInternalFrame will be closed.\n+   *\n+   * @throws PropertyVetoException If a VetoableChangeListener vetoes the change.\n+   */\n+  public void setClosed(boolean b) throws PropertyVetoException\n+  {\n+    if (b && ! isClosed())\n+      {\n+\tfireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_CLOSING);\n+\tfireVetoableChange(IS_CLOSED_PROPERTY, false, true);\n+\n+\tisClosed = b;\n+\n+\tfirePropertyChange(IS_CLOSED_PROPERTY, false, true);\n+\tfireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_CLOSED);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the Container to be used as a Content Pane for this\n+   * JInternalFrame.\n+   *\n+   * @param c The Container to use as a Content Pane.\n+   */\n+  public void setContentPane(Container c)\n+  {\n+    if (c != getContentPane())\n+      {\n+\tContainer old = getContentPane();\n+\tgetRootPane().setContentPane(c);\n+\tfirePropertyChange(CONTENT_PANE_PROPERTY, old, c);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the action taken when this JInternalFrame is closed.\n+   *\n+   * @param operation One of DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE or\n+   *        DISPOSE_ON_CLOSE.\n+   *\n+   * @throws Error If the given operation is not one of the allowed modes.\n+   */\n+  public void setDefaultCloseOperation(int operation)\n+  {\n+    if (operation != DO_NOTHING_ON_CLOSE || operation != HIDE_ON_CLOSE\n+        || operation != DISPOSE_ON_CLOSE)\n+      throw new Error(\"Close operation must be one of DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, or DISPOSE_ON_CLOSE\");\n+    defaultCloseOperation = operation;\n+  }\n+\n+  /**\n+   * This method sets the JDesktopIcon that represents this JInternalFrame\n+   * while it is iconified.\n+   *\n+   * @param d The JDesktopIcon that represents this JInternalFrame while it is\n+   *        iconified.\n+   */\n+  public void setDesktopIcon(JDesktopIcon d)\n+  {\n+    d.setInternalFrame(this);\n+    desktopIcon = d;\n+  }\n+\n+  /**\n+   * This method does nothing because this must be the root of a focus\n+   * traversal cycle.\n+   *\n+   * @param focusCycleRoot Not used.\n+   */\n+  public final void setFocusCycleRoot(boolean focusCycleRoot)\n+  {\n+    // Do nothing\n+  }\n+\n+  /**\n+   * This method sets the Icon to be used in two places. The first is icon\n+   * that is painted at the top left corner of the JInternalFrame when it is\n+   * not iconified (clicking on that icon will activate the TitlePane\n+   * JMenuBar). When the JInternalFrame is iconified, it will be the icon\n+   * displayed in the JDesktopIcon. If no icon is set, the JInternalFrame\n+   * will use a Look and Feel default.\n+   *\n+   * @param icon The Icon used in the TitlePane JMenuBar and iconified frames.\n+   */\n+  public void setFrameIcon(Icon icon)\n+  {\n+    if (icon != frameIcon)\n+      {\n+\tIcon old = frameIcon;\n+\tframeIcon = icon;\n+\tfirePropertyChange(FRAME_ICON_PROPERTY, old, frameIcon);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the Glass Pane used with this JInternalFrame.\n+   *\n+   * @param glass The Glass Pane to use with this JInternalFrame.\n+   */\n+  public void setGlassPane(Component glass)\n+  {\n+    if (glass != getGlassPane())\n+      {\n+\tComponent old = getGlassPane();\n+\tgetRootPane().setGlassPane(glass);\n+\tfirePropertyChange(GLASS_PANE_PROPERTY, old, glass);\n+      }\n+  }\n+\n+  /**\n+   * This method iconifies or deiconifies this JInternalFrame given the\n+   * boolean argument. If the JInternalFrame becomes iconified, it will fire\n+   * an INTERNAL_FRAME_ICONIFIED event. If the JInternalFrame becomes\n+   * deiconified, it will fire anINTERNAL_FRAME_DEICONIFIED event.\n+   *\n+   * @param b Whether this JInternalFrame is to be iconified or deiconified.\n+   *\n+   * @throws PropertyVetoException DOCUMENT ME!\n+   */\n+  public void setIcon(boolean b) throws PropertyVetoException\n+  {\n+    if (b != isIcon())\n+      {\n+\tfireVetoableChange(IS_ICON_PROPERTY, b, isIcon);\n+\n+\tisIcon = b;\n+\n+\tfirePropertyChange(IS_ICON_PROPERTY, ! isIcon, isIcon);\n+\tif (b)\n+\t  fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_ICONIFIED);\n+\telse\n+\t  fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_DEICONIFIED);\n+      }\n+  }\n+\n+  /**\n+   * This method sets whether the JInternalFrame can be iconified. (This means\n+   * that the JInternalFrame can be turned into an icon if minimized).\n+   *\n+   * @param b Whether the JInternalFrame can be iconified.\n+   */\n+  public void setIconifiable(boolean b)\n+  {\n+    iconable = b;\n+  }\n+\n+  /**\n+   * This method sets the JMenuBar to be used with this JInternalFrame.\n+   *\n+   * @param b The JMenuBar to be used with this JInternalFrame.\n+   */\n+  public void setJMenuBar(JMenuBar b)\n+  {\n+    getRootPane().setJMenuBar(b);\n+  }\n+\n+  /**\n+   * A helper method that set the layer that this JInternalFrame resides in.\n+   * Using this version of the method means that the user should not set it\n+   * to values that are already defined in JLayeredPane. If predefined values\n+   * are to be used, the user should use the setLayer(Integer) version.\n+   *\n+   * @param layer The layer to place this JInternalFrame in.\n+   */\n+  public void setLayer(int layer)\n+  {\n+    setLayer(new Integer(layer));\n+  }\n+\n+  /**\n+   * A helper method that sets the layer that this JInternalFrame resides in.\n+   * Calling this version of the method should use layer values that are\n+   * already defined in JLayeredPane.\n+   *\n+   * @param layer The layer to place this JInternalFrame in.\n+   */\n+  public void setLayer(Integer layer)\n+  {\n+    JDesktopPane p = getDesktopPane();\n+    if (p != null)\n+      {\n+\tint pos = p.getPosition(this);\n+\tp.setLayer(this, layer.intValue(), pos);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the JLayeredPane to use with this JInternalFrame.\n+   *\n+   * @param layered The JLayeredPane to use as a layeredPane.\n+   */\n+  public void setLayeredPane(JLayeredPane layered)\n+  {\n+    if (layered != getLayeredPane())\n+      {\n+\tJLayeredPane old = getLayeredPane();\n+\tgetRootPane().setLayeredPane(layered);\n+\tfirePropertyChange(LAYERED_PANE_PROPERTY, old, layered);\n+      }\n+  }\n+\n+  /**\n+   * This method sets whether the JInternalFrame can be maximized.\n+   *\n+   * @param b Whether this JInternalFrame can be maximized.\n+   */\n+  public void setMaximizable(boolean b)\n+  {\n+    maximizable = b;\n+  }\n+\n+  /**\n+   * This method sets the Layout Manager used in the JInternalFrame. SetLayout\n+   * should not be called on the JInternalFrame directly. Instead, it should\n+   * be called with JInternalFrame.getContentPane().setLayout. Calls to this\n+   * method with root pane checking enabled will cause exceptions to be\n+   * thrown.\n+   *\n+   * @param manager The Layout Manager to be used with the JInternalFrame.\n+   *\n+   * @throws Error If rootPaneChecking is enabled.\n+   */\n+  public void setLayout(LayoutManager manager)\n+  {\n+    if (isRootPaneCheckingEnabled())\n+      throw new Error(\"Cannot set layout. Use getContentPane().setLayout() instead.\");\n+    super.setLayout(manager);\n+  }\n+\n+  /**\n+   * This method sets the JInternalFrame to maximized (if the given argument\n+   * is true) or restores the JInternalFrame to its normal bounds otherwise.\n+   *\n+   * @param b Whether this JInteralFrame will be maximized or restored.\n+   *\n+   * @throws PropertyVetoException If a VetoableChangeListener vetoes the change.\n+   */\n+  public void setMaximum(boolean b) throws PropertyVetoException\n+  {\n+    if (b != isMaximum())\n+      {\n+\tfireVetoableChange(IS_MAXIMUM_PROPERTY, b, isMaximum);\n+\tisMaximum = b;\n+\tif (b)\n+\t  setNormalBounds(getBounds());\n+\tmaxTransition = ! b;\n+\tfirePropertyChange(IS_MAXIMUM_PROPERTY, ! isMaximum, isMaximum);\n+\tmaxTransition = false;\n+      }\n+  }\n+\n+  /**\n+   * This method is deprecated. This method sets the JMenuBar used with this\n+   * JInternalFrame.\n+   *\n+   * @param m The JMenuBar to use with this JInternalFrame.\n+   */\n+  public void setMenuBar(JMenuBar m)\n+  {\n+    setJMenuBar(m);\n+  }\n+\n+  /**\n+   * This method sets the bounds that this JInternalFrame will be restored to.\n+   *\n+   * @param r The bounds that this JInternalFrame will be restored to.\n+   */\n+  public void setNormalBounds(Rectangle r)\n+  {\n+    storedBounds.setBounds(r.x, r.y, r.width, r.height);\n+  }\n+\n+  /**\n+   * This method sets whether the JInternalFrame can be resized by a user\n+   * action (like dragging at the frame borders).\n+   *\n+   * @param b Whether this JInternalFramer can be resized.\n+   */\n+  public void setResizable(boolean b)\n+  {\n+    resizable = b;\n+  }\n+\n+  /**\n+   * This method sets the Root Pane for this JInternalFrame.\n+   *\n+   * @param root The Root Pane for this JInternalFrame.\n+   */\n+  protected void setRootPane(JRootPane root)\n+  {\n+    if (rootPane != null)\n+      remove(rootPane);\n+\n+    rootPane = root;\n+    add(root);\n+  }\n+\n+  /**\n+   * This method sets whether root pane checking is enabled. If root pane\n+   * checking is enabled, then calls to addImpl and setLayout will throw\n+   * exceptions.\n+   *\n+   * @param enabled Whether root pane checking is enabled.\n+   */\n+  protected void setRootPaneCheckingEnabled(boolean enabled)\n+  {\n+    rootPaneCheckingEnabled = enabled;\n+  }\n+\n+  /**\n+   * This method sets whether this JInternalFrame is the selected frame in the\n+   * JDesktopPane (or other container). When selected, a JInternalFrame will\n+   * have focus and paint its TitlePane differently (usually a different\n+   * colour). If this method selects the frame, this JInternalFrame will fire\n+   * an INTERNAL_FRAME_ACTIVATED event. If it deselects this frame, it will\n+   * fire an INTERNAL_FRAME_DEACTIVATED event.\n+   *\n+   * @param selected Whether this JInternalFrame will become selected or\n+   *        deselected.\n+   *\n+   * @throws PropertyVetoException If a VetoableChangeListener vetoes the change.\n+   */\n+  public void setSelected(boolean selected) throws PropertyVetoException\n+  {\n+    if (selected != isSelected())\n+      {\n+\tfireVetoableChange(IS_SELECTED_PROPERTY, selected, isSelected);\n+\n+\tif (! selected)\n+\t  defaultFocus = getMostRecentFocusOwner();\n+\n+\tisSelected = selected;\n+\n+\tif (selected)\n+\t  restoreSubcomponentFocus();\n+\n+\tfirePropertyChange(IS_SELECTED_PROPERTY, ! isSelected, isSelected);\n+\n+\tif (isSelected)\n+\t  fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_ACTIVATED);\n+\telse\n+\t  fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_DEACTIVATED);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the title displayed in the TitlePane of this\n+   * JInternalFrame.\n+   *\n+   * @param title The title displayed.\n+   */\n+  public void setTitle(String title)\n+  {\n+    if (title == null && this.title == null)\n+      return;\n+    if (title == null || this.title == null || ! this.title.equals(title))\n+      {\n+\tString old = title;\n+\tthis.title = title;\n+\tfirePropertyChange(TITLE_PROPERTY, old, this.title);\n+      }\n+  }\n+\n+  /**\n+   * This method displays the JInternalFrame. If it is not visible, this\n+   * method will bring this JInternalFrame to the front, make it visible and\n+   * select it. If this is the first time this JInternalFrame is made\n+   * visible, an INTERNAL_FRAME_OPENED event will be fired.\n+   */\n+  public void show()\n+  {\n+    if (! isVisible())\n+      {\n+\tmoveToFront();\n+\tsuper.show();\n+\n+\tJDesktopPane pane = getDesktopPane();\n+\tif (pane != null)\n+\t  pane.setSelectedFrame(this);\n+\telse\n+\t  {\n+\t    try\n+\t      {\n+\t\tsetSelected(true);\n+\t      }\n+\t    catch (PropertyVetoException e)\n+\t      {\n+\t\t// Do nothing. if they don't want to be selected.\n+\t      }\n+\t  }\n+\tif (isFirstTimeVisible)\n+\t  {\n+\t    isFirstTimeVisible = false;\n+\t    fireInternalFrameEvent(InternalFrameEvent.INTERNAL_FRAME_OPENED);\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * This method is used to set the UI responsible for the JInternalFrame.\n+   *\n+   * @param ui The UI responsible for the JInternalFrame.\n+   */\n+  public void setUI(InternalFrameUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method causes the JInternalFrame to be brough to back in the\n+   * z-order.\n+   */\n+  public void toBack()\n+  {\n+    moveToBack();\n+  }\n+\n+  /**\n+   * This method causes the JInternalFrame to be brought to front in the\n+   * z-order.\n+   */\n+  public void toFront()\n+  {\n+    moveToFront();\n+  }\n+\n+  /**\n+   * This method resets the UI to the Look and Feel defaults.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((InternalFrameUI) UIManager.getUI(this));\n+  }\n+\n+  /**\n+   * This helper method allows JInternalFrames to signal that they were\n+   * iconned for the first time.\n+   *\n+   * @param b Whether the JInternalFrame was iconned.\n+   * @param ID The identifier of the property change event to fire if the\n+   *        JInternalFrame is iconned for the first time.\n+   */\n+  void setWasIcon(boolean b, String ID)\n+  {\n+    if (b && ! wasIcon)\n+      {\n+\twasIcon = b;\n+\tfirePropertyChange(ID, ! b, b);\n+      }\n+  }\n+\n+  /**\n+   * This helper method returns whether the JInternalFrame has been iconned\n+   * once already.\n+   *\n+   * @return Whether the JInternalFrame has been iconned once already.\n+   */\n+  boolean getWasIcon()\n+  {\n+    return wasIcon;\n+  }\n+\n+  /**\n+   * This method is a convenience method to fire vetoable property changes.\n+   *\n+   * @param name The identifier of the property change.\n+   * @param oldValue The old value.\n+   * @param newValue The new value.\n+   *\n+   * @throws PropertyVetoException Fired if a vetoable change listener vetoes\n+   *         the change.\n+   */\n+  private void fireVetoableChange(String name, boolean oldValue,\n+                                  boolean newValue)\n+                           throws PropertyVetoException\n+  {\n+    super.fireVetoableChange(name, new Boolean(oldValue), new Boolean(newValue));\n+  }\n } // class JInternalFrame"}, {"sha": "0a15cfc9c5ff14ad4a792c38286eae4de47bc7a7", "filename": "libjava/javax/swing/JLabel.java", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJLabel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJLabel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLabel.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -331,9 +331,8 @@ public void setIcon(Icon icon)\n    */\n   public Icon getDisabledIcon()\n   {\n-    //FIXME: We should be gray-scaling the active icon and then returning it\n     if (disabledIcon == null && activeIcon instanceof ImageIcon)\n-      setDisabledIcon(activeIcon);\n+      disabledIcon = new ImageIcon(GrayFilter.createDisabledImage(((ImageIcon) activeIcon).getImage()));\n     return disabledIcon;\n   }\n "}, {"sha": "78ff95e0b7666dd4b5faaf8203d45ecbe67e04e3", "filename": "libjava/javax/swing/JLayeredPane.java", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLayeredPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -91,7 +91,9 @@\n  */\n public class JLayeredPane extends JComponent implements Accessible\n {\n-  public static String LAYER_PROPERTY = \"LAYER_PROPERTY\";\n+  private static final long serialVersionUID = 5534920399324590459L;\n+  \n+  public static final String LAYER_PROPERTY = \"layeredContainerLayer\";\n \n   public static Integer FRAME_CONTENT_LAYER = new Integer (-30000);\n \n@@ -104,7 +106,7 @@ public class JLayeredPane extends JComponent implements Accessible\n   TreeMap layers;               // Layer Number (Integer) -> Layer Size (Integer)\n   Hashtable componentToLayer;   // Component -> Layer Number (Integer)\n \n-  JLayeredPane()\n+  public JLayeredPane()\n   {\n     layers = new TreeMap ();\n     componentToLayer = new Hashtable ();\n@@ -492,6 +494,8 @@ public void remove (int index)\n     decrLayer (layer);\n     componentToLayer.remove (c);\n     super.remove (index);\n+    revalidate();\n+    repaint();\n   }\n \n   /**"}, {"sha": "732a0c077a0e112c44c481d5094107292af6bf6f", "filename": "libjava/javax/swing/JList.java", "status": "modified", "additions": 94, "deletions": 9, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJList.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -39,6 +39,7 @@\n \n import java.awt.Color;\n import java.awt.Component;\n+import java.awt.ComponentOrientation;\n import java.awt.Dimension;\n import java.awt.Point;\n import java.awt.Rectangle;\n@@ -107,26 +108,26 @@ public class JList extends JComponent implements Accessible, Scrollable\n {\n   private static final long serialVersionUID = 4406629526391098046L;\n \n-  /** \n-   * Constant value used in \"layoutOrientation\" property. This value means\n-   * that cells are laid out in multiple columns \"newspaper style\",\n-   * filling horizontally first, then vertically. \n-   */\n-  public static int HORIZONTAL_WRAP = 1;\n-\n   /** \n    * Constant value used in \"layoutOrientation\" property. This value means\n    * that cells are laid out in a single vertical column. This is the default. \n    */\n-  public static int VERTICAL = 2;\n+  public static final int VERTICAL = 0;\n \n   /** \n    * Constant value used in \"layoutOrientation\" property. This value means\n    * that cells are laid out in multiple columns \"newspaper style\", filling\n    * vertically first, then horizontally. \n    */\n-  public static int VERTICAL_WRAP = 3;\n+  public static final int VERTICAL_WRAP = 1;\n   \n+  /** \n+   * Constant value used in \"layoutOrientation\" property. This value means\n+   * that cells are laid out in multiple columns \"newspaper style\",\n+   * filling horizontally first, then vertically. \n+   */\n+  public static final int HORIZONTAL_WRAP = 2;\n+\n   /** Fired in a PropertyChangeEvent when the \"cellRenderer\" property changes. */\n   public static final String CELL_RENDERER_PROPERTY_CHANGED = \"cellRenderer\";\n \n@@ -559,6 +560,52 @@ public int getSelectedIndex()\n     return selectionModel.getMinSelectionIndex();\n   }\n \n+  /**\n+   * Returns <code>true</code> if the model's selection is empty, otherwise\n+   * <code>false</code>. \n+   *\n+   * @return The return value of {@link ListSelectionModel#isSelectionEmpty}\n+   */\n+  public boolean isSelectionEmpty()\n+  {\n+    return selectionModel.isSelectionEmpty();\n+  }\n+\n+  /**\n+   * Returns the list index of the upper left or upper right corner of the\n+   * {@link #visibleRect} property, depending on the {@link\n+   * #componentOrientation} property.\n+   *\n+   * @return The index of the first visible list cell, or <code>-1</code>\n+   * if none is visible.\n+   */\n+  public int getFirstVisibleIndex()\n+  {\n+    ComponentOrientation or = getComponentOrientation();\n+    Rectangle r = getVisibleRect();\n+    if (or == ComponentOrientation.RIGHT_TO_LEFT)\n+      r.translate((int) r.getWidth(), 0);\n+    return getUI().locationToIndex(this, r.getLocation());      \n+  }\n+\n+  /**\n+   * Returns the list index of the lower right or lower left corner of the\n+   * {@link #visibleRect} property, depending on the {@link\n+   * #componentOrientation} property.\n+   *\n+   * @return The index of the first visible list cell, or <code>-1</code>\n+   * if none is visible.\n+   */\n+  public int getLastVisibleIndex()\n+  {\n+    ComponentOrientation or = getComponentOrientation();\n+    Rectangle r = getVisibleRect();\n+    r.translate(0, (int) r.getHeight());\n+    if (or == ComponentOrientation.LEFT_TO_RIGHT)\n+      r.translate((int) r.getWidth(), 0);\n+    return getUI().locationToIndex(this, r.getLocation());      \n+  }\n+\n   /**\n    * Returns the indices of values in the {@link #model} property which are\n    * selected.\n@@ -681,6 +728,44 @@ public void setSelectionForeground(Color c)\n     firePropertyChange(SELECTION_FOREGROUND_PROPERTY_CHANGED, old, c);\n   }\n \n+  /**\n+   * Sets the selection to cover only the specified value, if it\n+   * exists in the model. \n+   *\n+   * @param obj The object to select\n+   * @param scroll Whether to scroll the list to make the newly selected\n+   * value visible\n+   *\n+   * @see #ensureIndexIsVisible\n+   */\n+\n+  public void setSelectedValue(Object obj, boolean scroll)\n+  {\n+    for (int i = 0; i < model.getSize(); ++i)\n+      {\n+        if (model.getElementAt(i).equals(obj))\n+          {\n+            setSelectedIndex(i);\n+            if (scroll)\n+              ensureIndexIsVisible(i);\n+            break;\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Scrolls this list to make the specified cell visible. This\n+   * only works if the list is contained within a viewport.\n+   *\n+   * @param i The list index to make visible\n+   *\n+   * @see JComponent#scrollRectToVisible\n+   */\n+  public void ensureIndexIsVisible(int i)\n+  {\n+    scrollRectToVisible(getUI().getCellBounds(this, i, i));\n+  }\n+\n   /**\n    * Sets the {@link #model} property of the list to a new anonymous\n    * {@link AbstractListModel} subclass which accesses the provided Object"}, {"sha": "430d5781eb17909e250e73e6993a52bdedbf8a2e", "filename": "libjava/javax/swing/JMenu.java", "status": "modified", "additions": 305, "deletions": 239, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenu.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JMenu.java --\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,9 +39,11 @@\n \n import java.awt.Component;\n import java.awt.Point;\n+import java.awt.Window;\n import java.awt.event.KeyEvent;\n import java.awt.event.WindowAdapter;\n import java.awt.event.WindowEvent;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n@@ -52,160 +54,181 @@\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleSelection;\n+import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.MenuEvent;\n import javax.swing.event.MenuListener;\n import javax.swing.plaf.MenuItemUI;\n \n \n /**\n- * DOCUMENT ME!\n+ * This class represents a menu that can be added to a menu bar or\n+ * to some other menu. When JMenu is selected it displays JPopupMenu\n+ * containing its menu items.\n  */\n public class JMenu extends JMenuItem implements Accessible, MenuElement\n {\n   static final long serialVersionUID = 4227225638931828014L;\n+\n+  /** name for the UI delegate for this menu. */\n   private static final String uiClassID = \"MenuUI\";\n-  private static Hashtable listenerRegistry = null;\n+\n+  /** A Popup menu associated with this menu, which pops up when menu is selected */\n   private JPopupMenu popupMenu = new JPopupMenu();\n+\n+  /** MenuChangeListener that listens to change events occuring in menu's model */\n   private ChangeListener menuChangeListener;\n-  private MenuEvent menuEvent;\n+\n+  /** MenuEvent */\n+  private MenuEvent menuEvent = new MenuEvent(this);\n+\n+  /*Amount of time, in milliseconds, that should pass before popupMenu\n+    associated with this menu appears or disappers */\n   private int delay;\n-  protected JMenu.WinListener popupListener;\n+\n+  /* PopupListener */\n+  protected WinListener popupListener;\n+\n+  /** Location at which popup menu associated with this menu will be displayed*/\n+  private Point menuLocation;\n \n   /**\n    * Creates a new JMenu object.\n    */\n   public JMenu()\n   {\n     super();\n+    menuChangeListener = createMenuChangeListener();\n+    getModel().addChangeListener(menuChangeListener);\n   }\n \n   /**\n-   * Creates a new JMenu object.\n+   * Creates a new JMenu with the spicified label\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text label for this menu\n    */\n   public JMenu(String text)\n   {\n     super(text);\n+    menuChangeListener = createMenuChangeListener();\n+    getModel().addChangeListener(menuChangeListener);\n   }\n \n   /**\n-   * Creates a new JMenu object.\n+   * Creates a new JMenu object\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action that  is used to create menu item tha will be\n+   * added to the menu.\n    */\n   public JMenu(Action action)\n   {\n     super(action);\n+    menuChangeListener = createMenuChangeListener();\n+    getModel().addChangeListener(menuChangeListener);\n   }\n \n   /**\n-   * Creates a new JMenu object.\n+   * Creates a new JMenu with specified label and an option\n+   * for this menu to be tear-off menu\n    *\n-   * @param text DOCUMENT ME!\n-   * @param tearoff DOCUMENT ME!\n+   * @param text label for this menu\n+   * @param tearoff true if this menu should be tear-off and false otherwise\n    */\n   public JMenu(String text, boolean tearoff)\n   {\n+    throw new Error(\"not implemented\");\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds specified menu item to this menu\n    *\n-   * @param item DOCUMENT ME!\n+   * @param item Menu item to add to this menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return Menu item that was added\n    */\n   public JMenuItem add(JMenuItem item)\n   {\n     return popupMenu.add(item);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds specified component to this menu.\n    *\n-   * @param component DOCUMENT ME!\n+   * @param component Component to add to this menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return Component that was added\n    */\n   public Component add(Component component)\n   {\n     return popupMenu.add(component);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds specified component to this menu at the given index\n    *\n-   * @param component DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * @param component Component to add\n+   * @param index Position of this menu item in the menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return Component that was added\n    */\n   public Component add(Component component, int index)\n   {\n     return popupMenu.add(component, index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds JMenuItem constructed with the specified label to this menu\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text label for the menu item that will be added\n    *\n-   * @return DOCUMENT ME!\n+   * @return Menu Item that was added to this menu\n    */\n   public JMenuItem add(String text)\n   {\n     return popupMenu.add(text);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds JMenuItem constructed using properties from specified action.\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action action to construct the menu item with\n    *\n-   * @return DOCUMENT ME!\n+   * @return Menu Item that was added to this menu\n    */\n   public JMenuItem add(Action action)\n   {\n     return popupMenu.add(action);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes given menu item from this menu. Nothing happens if\n+   * this menu doesn't contain specified menu item.\n    *\n-   * @param item DOCUMENT ME!\n+   * @param item Menu Item which needs to be removed\n    */\n   public void remove(JMenuItem item)\n   {\n     popupMenu.remove(item);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes component at the specified index from this menu\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index Position of the component that needs to be removed in the menu\n    */\n   public void remove(int index)\n   {\n     popupMenu.remove(index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes given component from this menu.\n    *\n-   * @param component DOCUMENT ME!\n+   * @param component Component to remove\n    */\n   public void remove(Component component)\n   {\n@@ -214,57 +237,64 @@ public void remove(Component component)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes all menu items from the menu\n    */\n   public void removeAll()\n   {\n     popupMenu.removeAll();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates JMenuItem with the specified text and inserts it in the\n+   * at the specified index\n    *\n-   * @param text DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * @param text label for the new menu item\n+   * @param index index at which to insert newly created menu item.\n    */\n   public void insert(String text, int index)\n   {\n-    popupMenu.insert(new JMenuItem(text), index);\n+    this.insert(new JMenuItem(text), index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @param item DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * Creates JMenuItem with the specified text and inserts it in the\n+   * at the specified index. IllegalArgumentException is thrown\n+   * if index is less than 0\n    *\n-   * @return DOCUMENT ME!\n+   * @param item menu item to insert\n+   * @param index index at which to insert menu item.\n+   * @return Menu item that was added to the menu\n    */\n   public JMenuItem insert(JMenuItem item, int index)\n   {\n+    if (index < 0)\n+      throw new IllegalArgumentException(\"index less than zero\");\n+\n     popupMenu.insert(item, index);\n \n     return item;\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @param action DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * Creates JMenuItem with the associated action and inserts it to the menu\n+   * at the specified index. IllegalArgumentException is thrown\n+   * if index is less than 0\n    *\n-   * @return DOCUMENT ME!\n+   * @param action Action for the new menu item\n+   * @param index index at which to insert newly created menu item.\n+   * @return Menu item that was added to the menu\n    */\n   public JMenuItem insert(Action action, int index)\n   {\n     JMenuItem item = new JMenuItem(action);\n-    popupMenu.insert(item, index);\n+    this.insert(item, index);\n \n     return item;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method sets this menuItem's UI to the UIManager's default for the\n+   * current look and feel.\n    */\n   public void updateUI()\n   {\n@@ -273,70 +303,74 @@ public void updateUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The Look and Feel classID. \"MenuUI\"\n    */\n   public String getUIClassID()\n   {\n     return uiClassID;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets model for this menu.\n    *\n-   * @param model DOCUMENT ME!\n+   * @param model model to set\n    */\n   public void setModel(ButtonModel model)\n   {\n     super.setModel(model);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if the menu is selected and false otherwise\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if the menu is selected and false otherwise\n    */\n   public boolean isSelected()\n   {\n-    return super.isSelected();\n+    return super.isArmed();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Changes this menu selected state if selected is true and false otherwise\n+   * This method fires menuEvents to model's registered listeners.\n    *\n-   * @param selected DOCUMENT ME!\n+   * @param selected true if the menu should be selected and false otherwise\n    */\n   public void setSelected(boolean selected)\n   {\n-    super.setSelected(selected);\n+    super.setArmed(true);\n+    fireMenuSelected();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if PopupMenu associated with this menu is visible\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if the popup associated with this menu is currently visible on the screen and\n+   * false otherwise.\n    */\n   public boolean isPopupMenuVisible()\n   {\n     return popupMenu.isVisible();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets popup menu visibility\n    *\n-   * @param popup DOCUMENT ME!\n+   * @param popup true if popup should be visible and false otherwise\n    */\n   public void setPopupMenuVisible(boolean popup)\n   {\n-    if (isEnabled())\n+    if (getModel().isEnabled())\n       popupMenu.setVisible(popup);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns origin point of the popup menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return Point containing\n    */\n   protected Point getPopupMenuOrigin()\n   {\n@@ -349,85 +383,102 @@ protected Point getPopupMenuOrigin()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns delay property.\n    *\n-   * @return DOCUMENT ME!\n+   * @return delay property, indicating number of milliseconds before\n+   * popup menu associated with the menu appears or disappears after\n+   * menu was selected or deselected respectively\n    */\n   public int getDelay()\n   {\n     return delay;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets delay property for this menu. If given time for the delay\n+   * property is negative, then IllegalArgumentException is thrown\n    *\n-   * @param delay DOCUMENT ME!\n+   * @param delay number of milliseconds before\n+   * popup menu associated with the menu appears or disappears after\n+   * menu was selected or deselected respectively\n    */\n   public void setDelay(int delay)\n   {\n+    if (delay < 0)\n+      throw new IllegalArgumentException(\"delay less than 0\");\n     this.delay = delay;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets location at which popup menu should be displayed\n+   * The location given is relative to this menu item\n    *\n-   * @param x DOCUMENT ME!\n-   * @param y DOCUMENT ME!\n+   * @param x x-coordinate of the menu location\n+   * @param y y-coordinate of the menu location\n    */\n   public void setMenuLocation(int x, int y)\n   {\n-    popupMenu.setLocation(x, y);\n+    menuLocation = new Point(x, y);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates and returns JMenuItem associated with the given action\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action to use for creation of JMenuItem\n    *\n-   * @return DOCUMENT ME!\n+   * @return JMenuItem that was creted with given action\n    */\n   protected JMenuItem createActionComponent(Action action)\n   {\n-    return null;\n+    return new JMenuItem(action);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates ActionChangeListener to listen for PropertyChangeEvents occuring\n+   * in the action that is associated with this menu\n    *\n-   * @param item DOCUMENT ME!\n+   * @param item menu that contains action to listen to\n    *\n-   * @return DOCUMENT ME!\n+   * @return The PropertyChangeListener\n    */\n   protected PropertyChangeListener createActionChangeListener(JMenuItem item)\n   {\n-    return null;\n+    return new ActionChangedListener(item);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds separator to the end of the menu items in the menu.\n    */\n   public void addSeparator()\n   {\n+    getPopupMenu().addSeparator();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Inserts separator in the menu at the specified index.\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index Index at which separator should be inserted\n    */\n   public void insertSeparator(int index)\n   {\n+    if (index < 0)\n+      throw new IllegalArgumentException(\"index less than 0\");\n+\n+    getPopupMenu().insert(new JPopupMenu.Separator(), index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns menu item located at the specified index in the menu\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index Index at which to look for the menu item\n    *\n-   * @return DOCUMENT ME!\n+   * @return menu item located at the specified index in the menu\n    */\n   public JMenuItem getItem(int index)\n   {\n+    if (index < 0)\n+      throw new IllegalArgumentException(\"index less than 0\");\n+\n     Component c = popupMenu.getComponentAtIndex(index);\n \n     if (c instanceof JMenuItem)\n@@ -437,61 +488,67 @@ public JMenuItem getItem(int index)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns number of items in the menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return number of items in the menu\n    */\n   public int getItemCount()\n   {\n-    return 0;\n+    // returns the number of items on \n+    // the menu, including separators.\n+    return getComponents().length;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if this menu is a tear-off menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if this menu is a tear-off menu and false otherwise\n    */\n   public boolean isTearOff()\n   {\n+    // NOT YET IMPLEMENTED \n     return false;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns number of menu components in this menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return number of menu components in this menu\n    */\n   public int getMenuComponentCount()\n   {\n     return popupMenu.getComponentCount();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns menu component located at the givent index\n+   * in the menu\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index index at which to get the menu component in the menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return Menu Component located in the menu at the specified index\n    */\n   public Component getMenuComponent(int index)\n   {\n     return (Component) popupMenu.getComponentAtIndex(index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return components belonging to this menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return components belonging to this menu\n    */\n   public Component[] getMenuComponents()\n   {\n     return popupMenu.getComponents();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if this menu is a top level menu. The menu is top\n+   * level menu if it is inside the menu bar. While if the menu\n+   * inside some other menu, it is considered to be a pull-right menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if this menu is top level menu, and false otherwise\n    */\n   public boolean isTopLevelMenu()\n   {\n@@ -502,331 +559,340 @@ public boolean isTopLevelMenu()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if given component exists in this menu. The submenus of\n+   * this menu are checked as well\n    *\n-   * @param component DOCUMENT ME!\n+   * @param component Component to look for\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if the given component exists in this menu, and false otherwise\n    */\n   public boolean isMenuComponent(Component component)\n   {\n     return false;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns popup menu associated with the menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return popup menu associated with the menu.\n    */\n   public JPopupMenu getPopupMenu()\n   {\n     return popupMenu;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds MenuListener to the menu\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener MenuListener to add\n    */\n   public void addMenuListener(MenuListener listener)\n   {\n     listenerList.add(MenuListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes MenuListener from the menu\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener MenuListener to remove\n    */\n   public void removeMenuListener(MenuListener listener)\n   {\n     listenerList.remove(MenuListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires MenuEvents to all menu's MenuListeners. In this case\n+   * menuSelected() method of MenuListeners is called to indicated that the menu\n+   * was selected.\n    */\n   protected void fireMenuSelected()\n   {\n     EventListener[] ll = listenerList.getListeners(MenuListener.class);\n \n     for (int i = 0; i < ll.length; i++)\n-      ((MenuListener) ll[i]).menuSelected(new MenuEvent(this));\n+      ((MenuListener) ll[i]).menuSelected(menuEvent);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires MenuEvents to all menu's MenuListeners. In this case\n+   * menuDeselected() method of MenuListeners is called to indicated that the menu\n+   * was deselected.\n    */\n   protected void fireMenuDeselected()\n   {\n     EventListener[] ll = listenerList.getListeners(MenuListener.class);\n \n     for (int i = 0; i < ll.length; i++)\n-      ((MenuListener) ll[i]).menuDeselected(new MenuEvent(this));\n+      ((MenuListener) ll[i]).menuDeselected(menuEvent);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires MenuEvents to all menu's MenuListeners. In this case\n+   * menuSelected() method of MenuListeners is called to indicated that the menu\n+   * was cancelled. The menu is cancelled when it's popup menu is close without selection.\n    */\n   protected void fireMenuCanceled()\n   {\n     EventListener[] ll = listenerList.getListeners(MenuListener.class);\n \n     for (int i = 0; i < ll.length; i++)\n-      ((MenuListener) ll[i]).menuCanceled(new MenuEvent(this));\n+      ((MenuListener) ll[i]).menuCanceled(menuEvent);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates MenuChangeListener to listen to change events occuring\n+   * in the model\n    *\n-   * @return DOCUMENT ME!\n+   * @return ChangeListener\n    */\n   private ChangeListener createMenuChangeListener()\n   {\n-    return null;\n+    return new MenuChangeListener();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates WinListener that listens to the menu;s popup menu.\n    *\n-   * @param popup DOCUMENT ME!\n+   * @param popup JPopupMenu to listen to\n    *\n-   * @return DOCUMENT ME!\n+   * @return The WinListener\n    */\n-  protected JMenu.WinListener createWinListener(JPopupMenu popup)\n+  protected WinListener createWinListener(JPopupMenu popup)\n   {\n-    return null;\n+    return new WinListener(popup);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of the MenuElementInterface. It reacts to the selection\n+   * changes in the menu. If this menu was selected, then it\n+   * displayes popup menu associated with it and if this menu was\n+   * deselected it hides the popup menu.\n    *\n-   * @param changed DOCUMENT ME!\n+   * @param changed true if the menu was selected and false otherwise\n    */\n   public void menuSelectionChanged(boolean changed)\n   {\n+    // if this menu selection is true, then activate this menu and \n+    // display popup associated with this menu\n+    if (changed)\n+      {\n+\tsetArmed(true);\n+\tfireMenuSelected();\n+\n+\tint x = 0;\n+\tint y = 0;\n+\tif (menuLocation == null)\n+\t  {\n+\t    // Calculate correct position of the popup. Note that location of the popup \n+\t    // passed to show() should be relative to the popup's invoker\n+\t    if (isTopLevelMenu())\n+\t      y = this.getHeight();\n+\t    else\n+\t      x = this.getWidth();\n+\n+\t    getPopupMenu().show(this, x, y);\n+\t  }\n+\telse\n+\t  getPopupMenu().show(this, menuLocation.x, menuLocation.y);\n+      }\n+\n+    else\n+      {\n+\tfireMenuDeselected();\n+\tpopupMenu.setVisible(false);\n+\tsetArmed(false);\n+      }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of MenuElement interface. Returns sub components of\n+   * this menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return array containing popupMenu that is associated with this menu\n    */\n   public MenuElement[] getSubElements()\n   {\n     return new MenuElement[] { popupMenu };\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n+   * @return Returns reference to itself\n    */\n   public Component getComponent()\n   {\n     return this;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method is overriden with empty implementation, s.t the\n+   * accelerator couldn't be set for the menu. The mnemonic should\n+   * be used for the menu instead.\n    *\n-   * @param keystroke DOCUMENT ME!\n+   * @param keystroke accelerator for this menu\n    */\n   public void setAccelerator(KeyStroke keystroke)\n   {\n-    super.setAccelerator(keystroke);\n+    throw new Error(\"setAccelerator() is not defined for JMenu.  Use setMnemonic() instead.\");\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method process KeyEvent occuring when the menu is visible\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The KeyEvent\n    */\n   protected void processKeyEvent(KeyEvent event)\n   {\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Programatically performs click\n    *\n-   * @param time DOCUMENT ME!\n+   * @param time Number of milliseconds for which this menu stays pressed\n    */\n   public void doClick(int time)\n   {\n+    getModel().setArmed(true);\n+    getModel().setPressed(true);\n+    try\n+      {\n+\tjava.lang.Thread.sleep(time);\n+      }\n+    catch (java.lang.InterruptedException e)\n+      {\n+\t// probably harmless\n+      }\n+\n+    getModel().setPressed(false);\n+    getModel().setArmed(false);\n+    popupMenu.show(this, this.getWidth(), 0);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JMenu. Normally only used\n+   * for debugging.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A string describing this JMenu\n    */\n   protected String paramString()\n   {\n     return \"JMenu\";\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJMenu(this);\n+      accessibleContext = new AccessibleJMenu();\n \n     return accessibleContext;\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class AccessibleJMenu extends AccessibleJMenuItem\n     implements AccessibleSelection\n   {\n-    /**\n-     * Creates a new AccessibleJMenu object.\n-     *\n-     * @param component DOCUMENT ME!\n-     */\n-    protected AccessibleJMenu(JMenu component)\n+    protected AccessibleJMenu()\n     {\n-      super(component);\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public int getAccessibleChildrenCount()\n     {\n       return 0;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public Accessible getAccessibleChild(int value0)\n     {\n       return null;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public AccessibleSelection getAccessibleSelection()\n     {\n       return null;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public Accessible getAccessibleSelection(int value0)\n     {\n       return null;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public boolean isAccessibleChildSelected(int value0)\n     {\n       return false;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.MENU;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public int getAccessibleSelectionCount()\n     {\n       return 0;\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     */\n     public void addAccessibleSelection(int value0)\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     */\n     public void removeAccessibleSelection(int value0)\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     */\n     public void clearAccessibleSelection()\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     */\n     public void selectAllAccessibleSelection()\n     {\n     }\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class WinListener extends WindowAdapter implements Serializable\n   {\n     JPopupMenu popupMenu;\n+    private static final long serialVersionUID = -6415815570638474823L;\n+\n+    public WinListener(JPopupMenu popup)\n+    {\n+    }\n+\n+    public void windowClosing(WindowEvent event)\n+    {\n+    }\n+  }\n+\n+  /** This class listens to ChangeEvent fired by menu's model*/\n+  protected class MenuChangeListener implements ChangeListener\n+  {\n+    /** This method is invoked when there is change in menu's model property */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      revalidate();\n+      repaint();\n+    }\n+  }\n+\n+  /**\n+   * This class listens to PropertyChangeEvents occuring in menu's action\n+   */\n+  protected class ActionChangedListener implements PropertyChangeListener\n+  {\n+    /** menu item associated with the action */\n+    private JMenuItem menuItem;\n \n-    /**\n-     * Creates a new WinListener object.\n-     *\n-     * @param value0 DOCUMENT ME!\n-     * @param value1 DOCUMENT ME!\n-     */\n-    public WinListener(JMenu value0, JPopupMenu value1)\n+    /** Creates new ActionChangedListener and adds it to menuItem's action */\n+    public ActionChangedListener(JMenuItem menuItem)\n     {\n+      this.menuItem = menuItem;\n+\n+      Action a = menuItem.getAction();\n+      if (a != null)\n+\ta.addPropertyChangeListener(this);\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param value0 DOCUMENT ME!\n-     */\n-    public void windowClosing(WindowEvent value0)\n+    /**This method is invoked when some change occures in menuItem's action*/\n+    public void propertyChange(PropertyChangeEvent evt)\n     {\n+      // FIXME: Need to implement\n     }\n   }\n }"}, {"sha": "c4edcd1f897e918f09877182c7c3d7112350a701", "filename": "libjava/javax/swing/JMenuBar.java", "status": "modified", "additions": 96, "deletions": 64, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuBar.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -66,12 +66,25 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * JMenuBar\n  */\n public class JMenuBar extends JComponent implements Accessible, MenuElement\n {\n+  /** Fired in a PropertyChangeEvent when the \"borderPainted\" property changes. */\n+  public static final String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"model\" changes. */\n+  public static final String MODEL_CHANGED_PROPERTY = \"model\";\n+  \n+  private static final long serialVersionUID = -8191026883931977036L;\n+\n+  /** JMenuBar's model. It keeps track of selected menu's index */\n   private transient SingleSelectionModel selectionModel;\n-  private boolean paintBorder;\n+\n+  /* borderPainted property indicating if the menuBar's border will be painted*/\n+  private boolean borderPainted;\n+\n+  /* margin between menu bar's border and its menues*/\n   private Insets margin;\n \n   /**\n@@ -80,16 +93,16 @@ public class JMenuBar extends JComponent implements Accessible, MenuElement\n   public JMenuBar()\n   {\n     selectionModel = new DefaultSingleSelectionModel();\n-    paintBorder = true;\n+    borderPainted = true;\n     updateUI();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds menu to the menu bar\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c menu to add\n    *\n-   * @return DOCUMENT ME!\n+   * @return reference to the added menu\n    */\n   public JMenu add(JMenu c)\n   {\n@@ -107,44 +120,42 @@ public void addNotify()\n     super.addNotify();\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   */\n   public AccessibleContext getAccessibleContext()\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns reference to this menu bar\n    *\n-   * @return DOCUMENT ME!\n+   * @return reference to this menu bar\n    */\n   public Component getComponent()\n   {\n     return this;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns component at the specified index.\n    *\n-   * @param i DOCUMENT ME!\n+   * @param i index of the component to get\n    *\n-   * @return DOCUMENT ME!\n+   * @return component at the specified index. Null is returned if\n+   * component at the specified index doesn't exist.\n+   * @deprecated Replaced by getComponent(int)\n    */\n   public Component getComponentAtIndex(int i)\n   {\n-    return getComponentAt(i);\n+    return getComponent(i);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns index of the specified component\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c Component to search for\n    *\n-   * @return DOCUMENT ME!\n+   * @return index of the specified component. -1 is returned if\n+   * specified component doesnt' exist in the menu bar.\n    */\n   public int getComponentIndex(Component c)\n   {\n@@ -175,9 +186,9 @@ public JMenu getHelpMenu()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns margin betweeen menu bar's border and its menues\n    *\n-   * @return DOCUMENT ME!\n+   * @return margin between menu bar's border and its menues\n    */\n   public Insets getMargin()\n   {\n@@ -188,11 +199,13 @@ public Insets getMargin()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return menu at the specified index. If component at the\n+   * specified index is not a menu, then null is returned.\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index index to look for the menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return menu at specified index, or null if menu doesn't exist\n+   * at the specified index.\n    */\n   public JMenu getMenu(int index)\n   {\n@@ -213,19 +226,20 @@ public int getMenuCount()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns selection model for this menu bar.\n    *\n-   * @return DOCUMENT ME!\n+   * @return selection mdoel for this menu bar.\n    */\n   public SingleSelectionModel getSelectionModel()\n   {\n     return selectionModel;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of MenuElement interface. It returns subcomponents\n+   * of the menu bar, which are all the menues that it contains.\n    *\n-   * @return DOCUMENT ME!\n+   * @return MenuElement[] array containing menues in this menu bar\n    */\n   public MenuElement[] getSubElements()\n   {\n@@ -238,73 +252,68 @@ public MenuElement[] getSubElements()\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   */\n+    * Set the \"UI\" property of the menu bar, which is a look and feel class\n+    * responsible for handling the menuBar's input events and painting it.\n+    *\n+    * @return The current \"UI\" property\n+    */\n   public MenuBarUI getUI()\n   {\n     return (MenuBarUI) ui;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menu bar.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The Look and Feel classID. \"MenuItemUI\"\n    */\n   public String getUIClassID()\n   {\n     return \"MenuBarUI\";\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if menu bar paints its border and false otherwise\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if menu bar paints its border and false otherwise\n    */\n   public boolean isBorderPainted()\n   {\n-    return paintBorder;\n+    return borderPainted;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if some menu in menu bar is selected.\n    *\n-   * @return DOCUMENT ME!\n-   */\n-  public boolean isManagingFocus()\n-  {\n-    return true;\n-  }\n-\n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n+   * @return true if some menu in menu bar is selected and false otherwise\n    */\n   public boolean isSelected()\n   {\n-    return false;\n+    return selectionModel.isSelected();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method does nothing by default. This method is need for the\n+   * MenuElement interface to be implemented.\n    *\n-   * @param isIncluded DOCUMENT ME!\n+   * @param isIncluded true if menuBar is included in the selection \n+   * and false otherwise\n    */\n   public void menuSelectionChanged(boolean isIncluded)\n   {\n     // Do nothing - needed for implementation of MenuElement interface\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints border of the menu bar, if its borderPainted property is set to \n+   * true.\n    *\n-   * @param g DOCUMENT ME!\n+   * @param g The graphics context with which to paint the border\n    */\n   protected void paintBorder(Graphics g)\n   {\n-    if (paintBorder)\n+    if (borderPainted)\n       getBorder().paintBorder(this, g, 0, 0, getSize(null).width,\n                               getSize(null).height);\n   }\n@@ -361,7 +370,14 @@ public void removeNotify()\n    */\n   public void setBorderPainted(boolean b)\n   {\n-    paintBorder = b;\n+    boolean old = borderPainted;\n+    borderPainted = b;\n+    if (b != old)\n+      {\n+\tfirePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, old, b);\n+\trevalidate();\n+\trepaint();\n+      }\n   }\n \n   /**\n@@ -384,35 +400,51 @@ public void setMargin(Insets m)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Changes menu bar's selection to the specifies menu.\n+   * This method updates selected index of menu bar's model,\n+   * which results in a model firing change event.\n    *\n-   * @param sel DOCUMENT ME!\n+   * @param sel menu to select\n    */\n   public void setSelected(Component sel)\n   {\n+    int index = getComponentIndex(sel);\n+    selectionModel.setSelectedIndex(index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets menuBar's selection model to the one specified\n    *\n-   * @param model DOCUMENT ME!\n+   * @param model SingleSelectionModel that needs to be set for this menu bar\n    */\n   public void setSelectionModel(SingleSelectionModel model)\n   {\n+    selectionModel = model;\n+    if (selectionModel != model)\n+      {\n+\tSingleSelectionModel oldModel = selectionModel;\n+\n+\tselectionModel = model;\n+\n+\tfirePropertyChange(MODEL_CHANGED_PROPERTY, oldModel,\n+\t                   this.selectionModel);\n+      }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Set the \"UI\" property of the menu bar, which is a look and feel class\n+   * responsible for handling menuBar's input events and painting it.\n    *\n-   * @param ui DOCUMENT ME!\n+   * @param ui The new \"UI\" property\n    */\n   public void setUI(MenuBarUI ui)\n   {\n     super.setUI(ui);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Set the \"UI\" property to a class constructed, via the {@link\n+   * UIManager}, from the current look and feel.\n    */\n   public void updateUI()\n   {"}, {"sha": "65dfc3361fe48eeb713bc8eaa5b32ba50b99c4d7", "filename": "libjava/javax/swing/JMenuItem.java", "status": "modified", "additions": 160, "deletions": 127, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuItem.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -61,57 +61,75 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * <p>\n+ * JMenuItem represents element in the menu. It inherits most of\n+ * its functionality from AbstractButton, however its behavior somewhat\n+ * varies from it. JMenuItem fire different kinds of events.\n+ * PropertyChangeEvents are fired when menuItems properties are modified;\n+ * ChangeEvents are fired when menuItem's state changes and actionEvents are\n+ * fired when menu item is selected. In addition to this events menuItem also\n+ * fire MenuDragMouseEvent and MenuKeyEvents when mouse is dragged over\n+ * the menu item or associated key with menu item is invoked respectively.\n+ * </p>\n  */\n public class JMenuItem extends AbstractButton implements Accessible,\n                                                          MenuElement\n {\n+  private static final long serialVersionUID = -1681004643499461044L;\n+\n+  /** name for the UI delegate for this menuItem. */\n   private static final String uiClassID = \"MenuItemUI\";\n+\n+  /** Combination of keyboard keys that can be used to activate this menu item */\n   private KeyStroke accelerator;\n \n   /**\n    * Creates a new JMenuItem object.\n    */\n   public JMenuItem()\n   {\n-    this(null, null);\n+    super(null, null);\n   }\n \n   /**\n-   * Creates a new JMenuItem object.\n+   * Creates a new JMenuItem with the given icon.\n    *\n-   * @param icon DOCUMENT ME!\n+   * @param icon Icon that will be displayed on the menu item\n    */\n   public JMenuItem(Icon icon)\n   {\n-    this(null, icon);\n+    // FIXME: The requestedFocusEnabled property should\n+    // be set to false, when only icon is set for menu item.\n+    super(null, icon);\n   }\n \n   /**\n-   * Creates a new JMenuItem object.\n+   * Creates a new JMenuItem with the given label.\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text label for the menu item\n    */\n   public JMenuItem(String text)\n   {\n-    this(text, null);\n+    super(text, null);\n   }\n \n   /**\n-   * Creates a new JMenuItem object.\n+   * Creates a new JMenuItem associated with the specified action.\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action action for this menu item\n    */\n   public JMenuItem(Action action)\n   {\n-    // TODO\t\t\n+    super(null, null);\n+    super.setAction(action);\n   }\n \n   /**\n-   * Creates a new JMenuItem object.\n+   * Creates a new JMenuItem with specified text and icon.\n+   * Text is displayed to the left of icon by default.\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param text label for this menu item\n+   * @param icon icon that will be displayed on this menu item\n    */\n   public JMenuItem(String text, Icon icon)\n   {\n@@ -121,22 +139,28 @@ public JMenuItem(String text, Icon icon)\n   /**\n    * Creates a new JMenuItem object.\n    *\n-   * @param text DOCUMENT ME!\n-   * @param mnemonic DOCUMENT ME!\n+   * @param text label for this menu item\n+   * @param mnemonic - Single key that can be used with a\n+   * look-and-feel meta key to activate this menu item. However\n+   * menu item should be visible on the screen when mnemonic is used.\n    */\n   public JMenuItem(String text, int mnemonic)\n   {\n     super(text, null);\n     setMnemonic(mnemonic);\n   }\n \n-  //-------------------------------------------------------------\n-  // Methods ----------------------------------------------------\n-  //-------------------------------------------------------------\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   * @throws ClassNotFoundException DOCUMENT ME!\n+   */\n   private void readObject(ObjectInputStream stream)\n                    throws IOException, ClassNotFoundException\n   {\n-    // TODO\n   }\n \n   /**\n@@ -148,32 +172,40 @@ private void readObject(ObjectInputStream stream)\n    */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n-    // TODO\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Initializes this menu item\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param text label for this menu item\n+   * @param icon icon to be displayed for this menu item\n    */\n   protected void init(String text, Icon icon)\n   {\n-    // TODO\n+    super.init(text, icon);\n+\n+    // Initializes properties for this menu item, that are different\n+    // from Abstract button properties. \n+    paint_border = false;\n+    paint_focus = false;\n+    hori_align = JButton.LEFT;\n+    hori_text_pos = JButton.LEFT;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Set the \"UI\" property of the menu item, which is a look and feel class\n+   * responsible for handling menuItem's input events and painting it.\n    *\n-   * @param ui DOCUMENT ME!\n+   * @param ui The new \"UI\" property\n    */\n   public void setUI(MenuItemUI ui)\n   {\n     super.setUI(ui);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method sets this menuItem's UI to the UIManager's default for the\n+   * current look and feel.\n    */\n   public void updateUI()\n   {\n@@ -183,27 +215,29 @@ public void updateUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menuItem.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return The Look and Feel classID. \"MenuItemUI\"\n    */\n   public String getUIClassID()\n   {\n     return uiClassID;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if button's model is armed and false otherwise. The\n+   * button model is armed if menu item has focus or it is selected.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $boolean$ true if button's model is armed and false otherwise\n    */\n   public boolean isArmed()\n   {\n     return getModel().isArmed();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets menuItem's \"ARMED\" property\n    *\n    * @param armed DOCUMENT ME!\n    */\n@@ -213,39 +247,42 @@ public void setArmed(boolean armed)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Enable or disable menu item. When menu item is disabled,\n+   * its text and icon are grayed out if they exist.\n    *\n-   * @param enabled DOCUMENT ME!\n+   * @param enabled if true enable menu item, and disable otherwise.\n    */\n   public void setEnabled(boolean enabled)\n   {\n-    setEnabled(enabled);\n+    super.setEnabled(enabled);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return accelerator for this menu item.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $KeyStroke$ accelerator for this menu item.\n    */\n   public KeyStroke getAccelerator()\n   {\n     return accelerator;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets accelerator for this menu item.\n    *\n-   * @param keystroke DOCUMENT ME!\n+   * @param keystroke accelerator for this menu item.\n    */\n   public void setAccelerator(KeyStroke keystroke)\n   {\n     this.accelerator = keystroke;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Configures menu items' properties from properties of the specified action.\n+   * This method overrides configurePropertiesFromAction from AbstractButton\n+   * to also set accelerator property.\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action action to configure properties from\n    */\n   protected void configurePropertiesFromAction(Action action)\n   {\n@@ -258,11 +295,13 @@ protected void configurePropertiesFromAction(Action action)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates PropertyChangeListener to listen for the changes in action\n+   * properties.\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action action to listen to for property changes\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $PropertyChangeListener$ Listener that listens to changes in\n+   * action properties.\n    */\n   protected PropertyChangeListener createActionPropertyChangeListener(Action action)\n   {\n@@ -277,34 +316,27 @@ public void propertyChange(PropertyChangeEvent e)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Process mouse events forwarded from MenuSelectionManager.\n    *\n-   * @param event DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n+   * @param event event forwarded from MenuSelectionManager\n+   * @param path path to the menu element from which event was generated\n+   * @param manager MenuSelectionManager for the current menu hierarchy\n    */\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n   {\n     switch (event.getID())\n       {\n       case MouseEvent.MOUSE_CLICKED:\n-\tdoClick();\n \tbreak;\n       case MouseEvent.MOUSE_ENTERED:\n \tif (event.getSource() instanceof JMenuItem)\n \t  {\n \t    JMenuItem item = (JMenuItem) event.getSource();\n-\t    ButtonModel model = item.getModel();\n \n+\t    ButtonModel model = item.getModel();\n \t    if (item.isRolloverEnabled())\n \t      model.setRollover(true);\n-\n-\t    if (model.isPressed()\n-\t        && (event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n-\t      model.setArmed(true);\n-\t    else\n-\t      model.setArmed(false);\n \t  }\n \tbreak;\n       case MouseEvent.MOUSE_EXITED:\n@@ -314,7 +346,6 @@ public void processMouseEvent(MouseEvent event, MenuElement[] path,\n \t    ButtonModel model = item.getModel();\n \t    if (item.isRolloverEnabled())\n \t      model.setRollover(false);\n-\t    model.setArmed(false);\n \t  }\n \tbreak;\n       case MouseEvent.MOUSE_PRESSED:\n@@ -328,17 +359,6 @@ public void processMouseEvent(MouseEvent event, MenuElement[] path,\n \t  }\n \tbreak;\n       case MouseEvent.MOUSE_RELEASED:\n-\tif (event.getSource() instanceof JMenuItem)\n-\t  {\n-\t    JMenuItem item = (JMenuItem) event.getSource();\n-\t    ButtonModel model = item.getModel();\n-\t    if ((event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n-\t      {\n-\t\tmodel.setPressed(false);\n-\t\tmodel.setArmed(false);\n-\t\tmanager.clearSelectedPath();\n-\t      }\n-\t  }\n \tbreak;\n       case MouseEvent.MOUSE_MOVED:\n \tbreak;\n@@ -372,9 +392,11 @@ public void processKeyEvent(KeyEvent event, MenuElement[] path,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires MenuDragMouseEvents to registered listeners.\n+   * Different types of MenuDragMouseEvents are fired depending\n+   * on the observed mouse event.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event Mouse\n    */\n   public void processMenuDragMouseEvent(MenuDragMouseEvent event)\n   {\n@@ -396,7 +418,9 @@ public void processMenuDragMouseEvent(MenuDragMouseEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires MenuKeyEvent to registered listeners.\n+   * Different types of MenuKeyEvents are fired depending\n+   * on the observed key event.\n    *\n    * @param event DOCUMENT ME!\n    */\n@@ -406,9 +430,9 @@ public void processMenuKeyEvent(MenuKeyEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Fires MenuDragMouseEvent to all of the menuItem's MouseInputListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that mouse entered menuItem while it was dragged\n    */\n   protected void fireMenuDragMouseEntered(MenuDragMouseEvent event)\n   {\n@@ -419,9 +443,9 @@ protected void fireMenuDragMouseEntered(MenuDragMouseEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Fires MenuDragMouseEvent to all of the menuItem's MouseInputListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that mouse has exited menu item, while it was dragged\n    */\n   protected void fireMenuDragMouseExited(MenuDragMouseEvent event)\n   {\n@@ -432,9 +456,9 @@ protected void fireMenuDragMouseExited(MenuDragMouseEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Fires MenuDragMouseEvent to all of the menuItem's MouseInputListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that mouse is being dragged over the menuItem\n    */\n   protected void fireMenuDragMouseDragged(MenuDragMouseEvent event)\n   {\n@@ -445,9 +469,9 @@ protected void fireMenuDragMouseDragged(MenuDragMouseEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires a MenuDragMouseEvent to all the MenuItem's MouseInputListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that mouse was released while it was dragged over the menuItem\n    */\n   protected void fireMenuDragMouseReleased(MenuDragMouseEvent event)\n   {\n@@ -458,110 +482,135 @@ protected void fireMenuDragMouseReleased(MenuDragMouseEvent event)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires a MenuKeyEvent to all the MenuItem's MenuKeyListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that key associated with this menu was pressed\n    */\n   protected void fireMenuKeyPressed(MenuKeyEvent event)\n   {\n-    // TODO\n+    EventListener[] ll = listenerList.getListeners(MenuKeyListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuKeyListener) ll[i]).menuKeyPressed(event);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires a MenuKeyEvent to all the MenuItem's MenuKeyListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that key associated with this menu was released\n    */\n   protected void fireMenuKeyReleased(MenuKeyEvent event)\n   {\n-    // TODO\n+    EventListener[] ll = listenerList.getListeners(MenuKeyListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuKeyListener) ll[i]).menuKeyTyped(event);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method fires a MenuKeyEvent to all the MenuItem's MenuKeyListeners.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event The event signifying that key associated with this menu was typed.\n+   *        The key is typed when it was pressed and then released\n    */\n   protected void fireMenuKeyTyped(MenuKeyEvent event)\n   {\n-    // TODO\n+    EventListener[] ll = listenerList.getListeners(MenuKeyListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuKeyListener) ll[i]).menuKeyTyped(event);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of the MenuElement interface.\n+   * This method is invoked by MenuSelectionManager when selection of\n+   * this menu item has changed. If this menu item was selected then\n+   * arm it's model, and disarm the model otherwise. The menu item\n+   * is considered to be selected, and thus highlighted when its model\n+   * is armed.\n    *\n-   * @param changed DOCUMENT ME!\n+   * @param changed indicates selection status of this menu item. If changed is\n+   * true then menu item is selected and deselected otherwise.\n    */\n   public void menuSelectionChanged(boolean changed)\n   {\n     if (changed)\n       model.setArmed(true);\n+    else\n+      model.setArmed(false);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of the MenuElement interface.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $MenuElement[]$ Returns array of sub-components for this menu\n+   *         item. By default menuItem doesn't have any subcomponents and so\n+   *             empty array is returned instead.\n    */\n   public MenuElement[] getSubElements()\n   {\n     return new MenuElement[0];\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns reference to the component that will paint this menu item.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $Component$ Component that will paint this menu item.\n+   *         Simply returns reference to this menu item.\n    */\n   public Component getComponent()\n   {\n     return this;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds a MenuDragMouseListener to this menu item. When mouse\n+   * is dragged over the menu item the MenuDragMouseEvents will be\n+   * fired, and these listeners will be called.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener The new listener to add\n    */\n   public void addMenuDragMouseListener(MenuDragMouseListener listener)\n   {\n     listenerList.add(MenuDragMouseListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes a MenuDragMouseListener from the menuItem's listener list.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener The listener to remove\n    */\n   public void removeMenuDragMouseListener(MenuDragMouseListener listener)\n   {\n     listenerList.remove(MenuDragMouseListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds an MenuKeyListener to this menu item.  This listener will be\n+   * invoked when MenuKeyEvents will be fired by this menu item.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener The new listener to add\n    */\n   public void addMenuKeyListener(MenuKeyListener listener)\n   {\n     listenerList.add(MenuKeyListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes an MenuKeyListener from the menuItem's listener list.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener The listener to remove\n    */\n   public void removeMenuKeyListener(MenuKeyListener listener)\n   {\n     listenerList.remove(MenuKeyListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JMenuItem. Normally only used\n+   * for debugging.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return A string describing this JMenuItem\n    */\n   protected String paramString()\n   {\n@@ -571,49 +620,33 @@ protected String paramString()\n   /**\n    * DOCUMENT ME!\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return DOCUMENT ME!\n    */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJMenuItem(this);\n+      accessibleContext = new AccessibleJMenuItem();\n \n     return accessibleContext;\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class AccessibleJMenuItem extends AccessibleAbstractButton\n     implements ChangeListener\n   {\n+    private static final long serialVersionUID = 6748924232082076534L;\n+\n     /**\n      * Creates a new AccessibleJMenuItem object.\n-     *\n-     * @param component DOCUMENT ME!\n      */\n-    AccessibleJMenuItem(JMenuItem component)\n+    AccessibleJMenuItem()\n     {\n-      super(component);\n-\n-      // TODO\n+      //super(component);\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param event DOCUMENT ME!\n-     */\n     public void stateChanged(ChangeEvent event)\n     {\n-      // TODO\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return $returnType$ DOCUMENT ME!\n-     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.MENU_ITEM;"}, {"sha": "df45a1a4882c13876b3e3cdcb3a17564cc70a567", "filename": "libjava/javax/swing/JOptionPane.java", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJOptionPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -60,12 +60,13 @@ public class JOptionPane extends JComponent implements Accessible\n    */\n   protected class AccessibleJOptionPane extends JComponent.AccessibleJComponent\n   {\n+    private static final long serialVersionUID = 686071432213084821L;\n+  \n     /**\n      * Creates a new AccessibleJOptionPane object.\n      */\n     protected AccessibleJOptionPane()\n     {\n-      super(JOptionPane.this);\n     }\n \n     /**\n@@ -79,6 +80,8 @@ public AccessibleRole getAccessibleRole()\n     }\n   }\n \n+  private static final long serialVersionUID = 5231143276678566796L;\n+  \n   /** The value returned when cancel option is selected. */\n   public static final int CANCEL_OPTION = 2;\n \n@@ -418,21 +421,7 @@ public AccessibleContext getAccessibleContext()\n    */\n   public static JDesktopPane getDesktopPaneForComponent(Component parentComponent)\n   {\n-    if (parentComponent == null)\n-      return null;\n-    if (parentComponent instanceof JDesktopPane)\n-      return (JDesktopPane) parentComponent;\n-    JDesktopPane parent = null;\n-    while (parentComponent.getParent() != null)\n-      {\n-\tparentComponent = parentComponent.getParent();\n-\tif (parentComponent instanceof JDesktopPane)\n-\t  {\n-\t    parent = (JDesktopPane) parentComponent;\n-\t    break;\n-\t  }\n-      }\n-    return parent;\n+    return (JDesktopPane) SwingUtilities.getAncestorOfClass(JDesktopPane.class, parentComponent);\n   }\n \n   /**\n@@ -445,21 +434,7 @@ public static JDesktopPane getDesktopPaneForComponent(Component parentComponent)\n    */\n   public static Frame getFrameForComponent(Component parentComponent)\n   {\n-    if (parentComponent == null)\n-      return null;\n-    if (parentComponent instanceof Frame)\n-      return (Frame) parentComponent;\n-    Frame parent = null;\n-    while (parentComponent.getParent() != null)\n-      {\n-\tparentComponent = parentComponent.getParent();\n-\tif (parentComponent instanceof Frame)\n-\t  {\n-\t    parent = (Frame) parentComponent;\n-\t    break;\n-\t  }\n-      }\n-    return parent;\n+    return (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parentComponent);\n   }\n \n   /**"}, {"sha": "b8c88055fc40cc24f03e0e2b0a25af9b7d85c5f6", "filename": "libjava/javax/swing/JPasswordField.java", "status": "modified", "additions": 37, "deletions": 62, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJPasswordField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJPasswordField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJPasswordField.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -49,55 +49,31 @@\n  * @author\tAndrew Selkirk\n  * @version\t1.0\n  */\n-public class JPasswordField extends JTextField {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJPasswordField\n-\t */\n-\tprotected class AccessibleJPasswordField extends AccessibleJTextField {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJPasswordField\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJPasswordField(JPasswordField component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJPasswordField()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.PASSWORD_TEXT;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJPasswordField\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+public class JPasswordField extends JTextField\n+{\n+  /**\n+   * AccessibleJPasswordField\n+   */\n+  protected class AccessibleJPasswordField extends AccessibleJTextField\n+  {\n+    private static final long serialVersionUID = -8477039424200681086L;\n+\n+    /**\n+     * Constructor AccessibleJPasswordField\n+     */\n+    protected AccessibleJPasswordField()\n+    {\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.PASSWORD_TEXT;\n+    }\n+  }\n \n \t/**\n \t * uiClassID\n@@ -254,16 +230,15 @@ protected String paramString() {\n \t\treturn null; // TODO\n \t} // paramString()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJPasswordField(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JPasswordField\n+  /**\n+   * getAccessibleContext\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJPasswordField();\n+\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "54a820c33ad7a40d56407236eab58cb26bae85e9", "filename": "libjava/javax/swing/JPopupMenu.java", "status": "modified", "additions": 328, "deletions": 262, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJPopupMenu.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -52,6 +52,7 @@\n import java.awt.Window;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectInputStream;\n@@ -71,35 +72,72 @@\n  */\n public class JPopupMenu extends JComponent implements Accessible, MenuElement\n {\n+  private static final long serialVersionUID = -8336996630009646009L;\n+\n+  /** name for the UI delegate for this menuItem. */\n   private static final String uiClassID = \"PopupMenuUI\";\n-  private static final Object defaultLWPopupEnabledKey = null;\n-  private static boolean defaultLWPopupEnabled = true;\n+\n+  /* indicates if popup's menu border should be painted*/\n+  private boolean borderPainted = true;\n+\n+  /** Flag indicating whether lightweight, mediumweight or heavyweight popup\n+     is used to display menu items.\n+\n+     These are the possible cases:\n+\n+     1. if DefaultLightWeightPopupEnabled true\n+         (i)  use lightweight container if popup feets inside top-level window\n+         (ii) only use heavyweight container (JWindow) if popup doesn't fit.\n+\n+     2. if DefaultLightWeightPopupEnabled false\n+         (i) if popup fits, use awt.Panel (mediumWeight)\n+         (ii) if popup doesn't fit, use JWindow (heavyWeight)\n+  */\n+  private static boolean DefaultLightWeightPopupEnabled = true;\n+\n+  /* Component that invokes popup menu. */\n   transient Component invoker;\n-  private int locationX;\n-  private int locationY;\n+\n+  /* Label for this popup menu */\n   private String label;\n-  private boolean paintBorder;\n+\n+  /*Amount of space between menuItem's in JPopupMenu and JPopupMenu's border */\n   private Insets margin;\n+\n+  /** Indicates whether ligthWeight container can be used to display popup\n+     menu. This flag is the same as DefaultLightWeightPopupEnabled, but setting\n+     this flag can change popup menu after creation of the object */\n   private boolean lightWeightPopupEnabled;\n+\n+  /** SelectionModel that keeps track of menu selection. */\n   private SingleSelectionModel selectionModel;\n+\n+  /* Popup that is used to display JPopupMenu */\n   private transient Popup popup;\n-  private Point location;\n+\n+  /* Location of the popup */\n+  private Point popupLocation;\n+\n+  /* Bound Property indicating visibility of the popup menu*/\n+  public static final String VISIBLE_CHANGED_PROPERTY = \"visible\";\n \n   /**\n    * Creates a new JPopupMenu object.\n    */\n   public JPopupMenu()\n   {\n     updateUI();\n-    \n-    lightWeightPopupEnabled = defaultLWPopupEnabled;\n+\n+    lightWeightPopupEnabled = DefaultLightWeightPopupEnabled;\n     selectionModel = new DefaultSingleSelectionModel();\n+\n+    super.setVisible(false);\n   }\n \n   /**\n-   * Creates a new JPopupMenu object.\n+   * Creates a new JPopupMenu with specified label\n    *\n-   * @param label DOCUMENT ME!\n+   * @param label Label for popup menu.\n    */\n   public JPopupMenu(String label)\n   {\n@@ -131,11 +169,11 @@ private void writeObject(ObjectOutputStream stream) throws IOException\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds given menu item to the popup menu\n    *\n-   * @param item DOCUMENT ME!\n+   * @param item menu item to add to the popup menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return menu item that was added to the popup menu\n    */\n   public JMenuItem add(JMenuItem item)\n   {\n@@ -144,11 +182,12 @@ public JMenuItem add(JMenuItem item)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Constructs menu item with a specified label and adds it to\n+   * popup menu\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text label for the menu item to be added\n    *\n-   * @return DOCUMENT ME!\n+   * @return constructed menu item that was added to the popup menu\n    */\n   public JMenuItem add(String text)\n   {\n@@ -157,22 +196,27 @@ public JMenuItem add(String text)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Constructs menu item associated with the specified action\n+   * and adds it to the popup menu\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action for the new menu item\n    *\n-   * @return DOCUMENT ME!\n+   * @return menu item that was added to the menu\n    */\n   public JMenuItem add(Action action)\n   {\n     JMenuItem item = new JMenuItem(action);\n+\n+    if (action != null)\n+      action.addPropertyChangeListener(createActionChangeListener(item));\n+\n     return add(item);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Revomes component at the given index from the menu.\n    *\n-   * @param index DOCUMENT ME!\n+   * @param index index of the component that will be removed in the menu\n    */\n   public void remove(int index)\n   {\n@@ -192,10 +236,11 @@ public void remove(int index)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Create menu item associated with the given action\n+   * and inserts it into the popup menu at the specified index\n    *\n-   * @param action DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * @param action Action for the new menu item\n+   * @param index index in the popup menu at which to insert new menu item.\n    */\n   public void insert(Action action, int index)\n   {\n@@ -204,21 +249,22 @@ public void insert(Action action, int index)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Insert given component to the popup menu at the\n+   * specified index\n    *\n-   * @param component DOCUMENT ME!\n-   * @param index DOCUMENT ME!\n+   * @param component Component to insert\n+   * @param index Index at which to insert given component\n    */\n   public void insert(Component component, int index)\n   {\n     GridBagConstraints constraints = new GridBagConstraints();\n     constraints.fill = GridBagConstraints.HORIZONTAL;\n     constraints.weightx = 100.0;\n     constraints.weighty = 100.0;\n-    \n+\n     if (index == -1)\n-       index = getComponents().length;\n-       \n+      index = getComponents().length;\n+\n     constraints.gridy = index;\n     super.add(component, constraints, index);\n \n@@ -237,59 +283,65 @@ public void insert(Component component, int index)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints popup menu's border if borderPainted is true\n    *\n-   * @param graphics DOCUMENT ME!\n+   * @param graphics graphics context used to paint this popup's menu border.\n    */\n-  protected void paintBorder(Graphics graphics)\n+  protected void borderPainted(Graphics graphics)\n   {\n-    if (paintBorder)\n+    if (borderPainted)\n       getBorder().paintBorder(this, graphics, 0, 0, getSize(null).width,\n                               getSize(null).height);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns flag indicating if newly created JPopupMenu will use\n+   * heavyweight or lightweight container to display its menu items\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if JPopupMenu will use lightweight container to display\n+   * menu items by default, and false otherwise.\n    */\n   public static boolean getDefaultLightWeightPopupEnabled()\n   {\n-    return defaultLWPopupEnabled;\n+    return DefaultLightWeightPopupEnabled;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets whether JPopupMenu should use ligthWeight container to\n+   * display it menu items by default\n    *\n-   * @param enabled DOCUMENT ME!\n+   * @param enabled true if JPopupMenu should use lightweight container\n+   * for displaying its menu items, and false otherwise.\n    */\n   public static void setDefaultLightWeightPopupEnabled(boolean enabled)\n   {\n-    defaultLWPopupEnabled = enabled;\n+    DefaultLightWeightPopupEnabled = enabled;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns the UI used to display the JPopupMenu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The UI used to display the JPopupMenu.\n    */\n   public PopupMenuUI getUI()\n   {\n     return (PopupMenuUI) ui;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Set the \"UI\" property of the menu item, which is a look and feel class\n+   * responsible for handling popupMenu's input events and painting it.\n    *\n-   * @param ui DOCUMENT ME!\n+   * @param ui The new \"UI\" property\n    */\n   public void setUI(PopupMenuUI ui)\n   {\n     super.setUI(ui);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method sets this menuItem's UI to the UIManager's default for the\n+   * current look and feel.\n    */\n   public void updateUI()\n   {\n@@ -298,29 +350,31 @@ public void updateUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menuItem.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The Look and Feel classID. \"PopupMenuUI\"\n    */\n   public String getUIClassID()\n   {\n     return \"PopupMenuUI\";\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns selectionModel used by this popup menu to keep\n+   * track of the selection.\n    *\n-   * @return DOCUMENT ME!\n+   * @return popup menu's selection model\n    */\n   public SingleSelectionModel getSelectionModel()\n   {\n     return selectionModel;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets selection model for this popup menu\n    *\n-   * @param model DOCUMENT ME!\n+   * @param model new selection model of this popup menu\n    */\n   public void setSelectionModel(SingleSelectionModel model)\n   {\n@@ -355,9 +409,11 @@ protected PropertyChangeListener createActionChangeListener(JMenuItem item)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if this popup menu will display its menu item in\n+   * a lightweight container and false otherwise.\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if this popup menu will display its menu items\n+   * in a lightweight container and false otherwise.\n    */\n   public boolean isLightWeightPopupEnabled()\n   {\n@@ -375,54 +431,69 @@ public void setLightWeightPopupEnabled(boolean enabled)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns label for this popup menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return label for this popup menu\n    */\n   public String getLabel()\n   {\n     return label;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets label for this popup menu\n    *\n-   * @param label DOCUMENT ME!\n+   * @param label label for this popup menu\n    */\n   public void setLabel(String label)\n   {\n     this.label = label;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds separator to this popup menu\n    */\n   public void addSeparator()\n   {\n+    // insert separator at the end of the list of menu items    \n+    this.insert(new Separator(), -1);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Adds popupMenuListener to listen for PopupMenuEvents fired\n+   * by the JPopupMenu\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener PopupMenuListener to add to JPopupMenu\n    */\n   public void addPopupMenuListener(PopupMenuListener listener)\n   {\n     listenerList.add(PopupMenuListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Removes PopupMenuListener from JPopupMenu's list of listeners\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param listener PopupMenuListener which needs to be removed\n    */\n   public void removePopupMenuListener(PopupMenuListener listener)\n   {\n     listenerList.remove(PopupMenuListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns array of PopupMenuListeners that are listening to JPopupMenu\n+   *\n+   * @return Array of PopupMenuListeners that are listening to JPopupMenu\n+   */\n+  public PopupMenuListener[] getPopupMenuListeners()\n+  {\n+    return ((PopupMenuListener[]) listenerList.getListeners(PopupMenuListener.class));\n+  }\n+\n+  /**\n+   * This method calls popupMenuWillBecomeVisible() of popup menu's\n+   * PopupMenuListeners. This method is invoked just before popup menu\n+   * will appear on the screen.\n    */\n   protected void firePopupMenuWillBecomeVisible()\n   {\n@@ -433,7 +504,9 @@ protected void firePopupMenuWillBecomeVisible()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method calls popupMenuWillBecomeInvisible() of popup\n+   * menu's PopupMenuListeners. This method is invoked just before popup\n+   * menu will disappear from the screen\n    */\n   protected void firePopupMenuWillBecomeInvisible()\n   {\n@@ -444,7 +517,10 @@ protected void firePopupMenuWillBecomeInvisible()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method calls popupMenuCanceled() of popup menu's PopupMenuListeners.\n+   * This method is invoked just before popup menu is cancelled. This happens\n+   * when popup menu is closed without selecting any of its menu items. This\n+   * usually happens when the top-level window is resized or moved.\n    */\n   protected void firePopupMenuCanceled()\n   {\n@@ -455,173 +531,176 @@ protected void firePopupMenuCanceled()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This methods sets popup menu's size to its' preferred size. If the\n+   * popup menu's size is previously set it will be ignored.\n    */\n   public void pack()\n   {\n+    super.setSize(null);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return visibility of the popup menu\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if popup menu is visible on the screen and false otherwise.\n    */\n   public boolean isVisible()\n   {\n     return super.isVisible();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets visibility property of this popup menu. If the property is\n+   * set to true then popup menu will be dispayed and popup menu will\n+   * hide itself if visible property is set to false.\n    *\n-   * @param visible DOCUMENT ME!\n+   * @param visible true if popup menu will become visible and false otherwise.\n    */\n   public void setVisible(boolean visible)\n   {\n+    boolean old = isVisible();\n     super.setVisible(visible);\n-\n-    firePopupMenuWillBecomeVisible();\n-\n-    if (visible)\n+    if (old != isVisible())\n       {\n-\tContainer rootContainer = (Container) SwingUtilities.getRoot(invoker);\n+\tfirePropertyChange(VISIBLE_CHANGED_PROPERTY, old, (boolean) isVisible());\n+\tif (visible)\n+\t  {\n+\t    firePopupMenuWillBecomeVisible();\n+\t    Container rootContainer = (Container) SwingUtilities.getRoot(invoker);\n \n-\tboolean fit = true;\n-\tDimension size;\n+\t    boolean fit = true;\n+\t    Dimension size;\n \n-\t// Determine the size of the popup menu\n-\tif (this.getSize().width == 0 && this.getSize().width == 0)\n-\t  size = this.getPreferredSize();\n+\t    // Determine the size of the popup menu\n+\t    if (this.getSize().width == 0 && this.getSize().width == 0)\n+\t      size = this.getPreferredSize();\n+\t    else\n+\t      size = this.getSize();\n+\t    if ((size.width > (rootContainer.getWidth() - popupLocation.x))\n+\t        || (size.height > (rootContainer.getHeight() - popupLocation.y)))\n+\t      fit = false;\n+\t    if (lightWeightPopupEnabled && fit)\n+\t      popup = new LightWeightPopup(this);\n+\t    else\n+\t      {\n+\t\tif (fit)\n+\t\t  popup = new MediumWeightPopup(this);\n+\t\telse\n+\t\t  popup = new HeavyWeightPopup(this);\n+\t      }\n+\t    if (popup instanceof LightWeightPopup\n+\t        || popup instanceof MediumWeightPopup)\n+\t      {\n+\t\tJLayeredPane layeredPane;\n+\t\tlayeredPane = SwingUtilities.getRootPane(invoker)\n+\t\t                            .getLayeredPane();\n+\t\tPoint p = new Point(popupLocation.x, popupLocation.y);\n+\t\tSwingUtilities.convertPointFromScreen(p, layeredPane);\n+\t\tpopup.show(p.x, p.y, size.width, size.height);\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Subtract insets of the top-level container if popup menu's\n+\t\t// top-left corner is inside it.\n+\t\tif (rootContainer.contains(popupLocation))\n+\t\t  {\n+\t\t    Insets insets = rootContainer.getInsets();\n+\t\t    popup.show(popupLocation.x - insets.left,\n+\t\t               popupLocation.y - insets.top, size.width,\n+\t\t               size.height);\n+\t\t  }\n+\n+\t\telse\n+\t\t  popup.show(popupLocation.x, popupLocation.y, size.width,\n+\t\t             size.height);\n+\t      }\n+\t  }\n \telse\n-\t  size = this.getSize();\n+\t  {\n+\t    // popup menu was cancelled without selection\n+\t    if (! getSelectionModel().isSelected())\n+\t      firePopupMenuCanceled();\n \n-\tif ((size.width > (rootContainer.getWidth() - locationX))\n-\t    || (size.height > (rootContainer.getHeight() - locationY)))\n-\t  fit = false;\n+\t    firePopupMenuWillBecomeInvisible();\n \n-\tif (lightWeightPopupEnabled && fit)\n-\t  popup = new LightWeightPopup(this);\n-\telse\n-\t  {\n-\t    if (fit)\n-\t      popup = new MediumWeightPopup(this);\n-\t    else\n-\t      popup = new HeavyWeightPopup(this);\n+\t    popup.hide();\n \t  }\n-\t\n-        if (popup instanceof LightWeightPopup \n-            || popup instanceof MediumWeightPopup)\n-          {\n-            JLayeredPane layeredPane;\n-            layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n-            Point lp = layeredPane.getLocationOnScreen();\n-            Point r = SwingUtilities.getRoot(invoker).getLocationOnScreen();\n-            int px = locationX - (lp.x - r.x);\n-            int py = locationY - (lp.y - r.y);\t  \n-            popup.show(px, py, size.width, size.height);\t  \t\t\n-          } \n-        else\n-          popup.show(locationX, locationY, size.width, size.height);\n-      }\n-    else\n-      {\n-\tfirePopupMenuWillBecomeInvisible();\n-\tpopup.hide();\n       }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets location of the popup menu.\n    *\n-   * @param x DOCUMENT ME!\n-   * @param y DOCUMENT ME!\n+   * @param x X coordinate of the popup menu's location\n+   * @param y Y coordinate of the popup menu's location\n    */\n   public void setLocation(int x, int y)\n   {\n-    locationX = x;\n-    locationY = y;\n-  }\n+    if (popupLocation == null)\n+      popupLocation = new Point();\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   */\n-  private boolean isPopupMenu()\n-  {\n-    return true;\n+    popupLocation.x = x;\n+    popupLocation.y = y;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns popup menu's invoker.\n    *\n-   * @return DOCUMENT ME!\n+   * @return popup menu's invoker\n    */\n   public Component getInvoker()\n   {\n     return invoker;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets popup menu's invoker.\n    *\n-   * @param component DOCUMENT ME!\n+   * @param component The new invoker of this popup menu\n    */\n   public void setInvoker(Component component)\n   {\n     invoker = component;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method displays JPopupMenu on the screen at the specified\n+   * location. Note that x and y coordinates given to this method\n+   * should be expressed in terms of the popup menus' invoker.\n    *\n-   * @param component DOCUMENT ME!\n-   * @param x DOCUMENT ME!\n-   * @param y DOCUMENT ME!\n+   * @param component Invoker for this popup menu\n+   * @param x x-coordinate of the popup menu relative to the specified invoker\n+   * @param y y-coordiate of the popup menu relative to the specified invoker\n    */\n   public void show(Component component, int x, int y)\n   {\n     setInvoker(component);\n-\n-    Point rootOnScreen;\n-    rootOnScreen = SwingUtilities.getRoot(invoker).getLocationOnScreen();\n-    Point invokerOnScreen = invoker.getLocationOnScreen();\n-    \n-    int popupX = (invokerOnScreen.x - rootOnScreen.x) + x;\n-    int popupY = (invokerOnScreen.y - rootOnScreen.y) + y;\n-    \n-    setLocation(popupX , popupY);\n+    Point p = new Point(x, y);\n+    SwingUtilities.convertPointToScreen(p, component);\n+    setLocation(p.x, p.y);\n     setVisible(true);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns component located at the specified index in the popup menu\n    *\n-   * @return DOCUMENT ME!\n-   */\n-  JPopupMenu getRootPopupMenu()\n-  {\n-    return null;\n-  }\n-\n-  /**\n-   * DOCUMENT ME!\n+   * @param index index of the component to return\n    *\n-   * @param index DOCUMENT ME!\n+   * @return component located at the specified index in the popup menu\n    *\n-   * @return DOCUMENT ME!\n+   * @deprecated Replaced by getComponent(int)\n    */\n   public Component getComponentAtIndex(int index)\n   {\n     return getComponent(index);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns index of the specified component in the popup menu\n    *\n-   * @param component DOCUMENT ME!\n+   * @param component Component to look for\n    *\n-   * @return DOCUMENT ME!\n+   * @return index of the specified component in the popup menu\n    */\n   public int getComponentIndex(Component component)\n   {\n@@ -637,30 +716,30 @@ public int getComponentIndex(Component component)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets size of the popup\n    *\n-   * @param size DOCUMENT ME!\n+   * @param size Dimensions representing new size of the popup menu\n    */\n   public void setPopupSize(Dimension size)\n   {\n     super.setSize(size);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets size of the popup menu\n    *\n-   * @param x DOCUMENT ME!\n-   * @param y DOCUMENT ME!\n+   * @param width width for the new size\n+   * @param height height for the new size\n    */\n-  public void setPopupSize(int x, int y)\n+  public void setPopupSize(int width, int height)\n   {\n-    super.setSize(x, y);\n+    super.setSize(width, height);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Selects specified component in this popup menu.\n    *\n-   * @param selected DOCUMENT ME!\n+   * @param selected component to select\n    */\n   public void setSelected(Component selected)\n   {\n@@ -669,52 +748,54 @@ public void setSelected(Component selected)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if this popup menu paints its border.\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if this popup menu paints its border and false otherwise.\n    */\n   public boolean isBorderPainted()\n   {\n-    return paintBorder;\n+    return borderPainted;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets if the border of the popup menu should be\n+   * painter or not.\n    *\n-   * @param painted DOCUMENT ME!\n+   * @param painted true if the border should be painted and false otherwise\n    */\n   public void setBorderPainted(boolean painted)\n   {\n-    paintBorder = painted;\n+    borderPainted = painted;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns margin for this popup menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return margin for this popup menu.\n    */\n   public Insets getMargin()\n   {\n     return margin;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JPopupMenu. Normally only used\n+   * for debugging.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A string describing this JMenuItem\n    */\n   protected String paramString()\n   {\n     return \"JPopupMenu\";\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @param event DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n-   */\n+  * Process mouse events forwarded from MenuSelectionManager.\n+  *\n+  * @param event event forwarded from MenuSelectionManager\n+  * @param path path to the menu element from which event was generated\n+  * @param manager MenuSelectionManager for the current menu hierarchy\n+  */\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n   {\n@@ -733,18 +814,20 @@ public void processKeyEvent(KeyEvent event, MenuElement[] path,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of MenuElement Interface. It is invoked when\n+   * popupMenu's selection has changed\n    *\n-   * @param changed DOCUMENT ME!\n+   * @param changed true if this popupMenu is part of current menu\n+   * hierarchy and false otherwise.\n    */\n   public void menuSelectionChanged(boolean changed)\n   {\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return subcomonents of this popup menu.\n    *\n-   * @return DOCUMENT ME!\n+   * @return Array containing menuItem's of belonging to this popup menu.\n    */\n   public MenuElement[] getSubElements()\n   {\n@@ -758,26 +841,26 @@ public MenuElement[] getSubElements()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Method of the MenuElement interface. Returns reference to itself.\n    *\n-   * @return DOCUMENT ME!\n+   * @return Returns reference to itself\n    */\n   public Component getComponent()\n   {\n     return this;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if observing mouse event should trigger popup\n+   * menu to show on the screen.\n    *\n-   * @param event DOCUMENT ME!\n+   * @param event MouseEvent to check\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if the observing mouse event is popup trigger and false otherwise\n    */\n   public boolean isPopupTrigger(MouseEvent event)\n   {\n-    return ((PopupMenuUI)getUI()).isPopupTrigger(event);\n-    \n+    return ((PopupMenuUI) getUI()).isPopupTrigger(event);\n   }\n \n   /**\n@@ -788,98 +871,103 @@ public boolean isPopupTrigger(MouseEvent event)\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJPopupMenu(this);\n+      accessibleContext = new AccessibleJPopupMenu();\n \n     return accessibleContext;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This interface is used to display menu items of the JPopupMenu\n    */\n   private interface Popup\n   {\n     /**\n-     * DOCUMENT ME!\n+     * Displays container on the screen\n      *\n-     * @param x DOCUMENT ME!\n-     * @param y DOCUMENT ME!\n-     * @param width DOCUMENT ME!\n-     * @param height DOCUMENT ME!\n+     * @param x x-coordinate of popup menu's location on the screen\n+     * @param y y-coordinate of popup menu's location on the screen\n+     * @param width width of the container that is used to display menu\n+     * item's for popup menu\n+     * @param height height of the container that is used to display menu\n+     * item's for popup menu\n      */\n     void show(int x, int y, int width, int height);\n \n     /**\n-     * DOCUMENT ME!\n+     * Hides container used to display popup menu item's from the screen\n      */\n     void hide();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This class represents Popup menu that uses light weight container\n+   * to display its contents.\n    */\n-  private class LightWeightPopup extends JPanel implements Popup\n+  private class LightWeightPopup extends Container implements Popup\n   {\n     /**\n-     * Creates a new LightWeightPopup object.\n+     * Creates a new LightWeightPopup menu\n      *\n-     * @param c DOCUMENT ME!\n+     * @param c Container containing menu items\n      */\n+    private Component c;\n+\n     public LightWeightPopup(Container c)\n     {\n-      this.add(c);\n+      this.c = c;\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Displayes lightweight container with menu items to the screen\n      *\n-     * @param x DOCUMENT ME!\n-     * @param y DOCUMENT ME!\n-     * @param width DOCUMENT ME!\n-     * @param height DOCUMENT ME!\n+     * @param x x-coordinate of lightweight container on the screen\n+     * @param y y-coordinate of lightweight container on the screen\n+     * @param width width of the lightweight container\n+     * @param height height of the lightweight container\n      */\n     public void show(int x, int y, int width, int height)\n     {\n       JLayeredPane layeredPane;\n       layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n-      this.setBounds(x, y, width, height);\n-      layeredPane.add(this, JLayeredPane.POPUP_LAYER, 0);\n+      c.setBounds(x, y, width, height);\n+      layeredPane.add(c, JLayeredPane.POPUP_LAYER, 0);\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Hides lightweight container from the screen\n      */\n     public void hide()\n     {\n       JLayeredPane layeredPane;\n       layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n-      int index = layeredPane.getIndexOf(this);\n+      int index = layeredPane.getIndexOf(c);\n       layeredPane.remove(index);\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * MediumWeightPopup is an AWT Panel with JPopupMenu's menu items.\n+   * It is used to display JPopupMenu's menu items on the screen\n    */\n   private class MediumWeightPopup extends Panel implements Popup\n   {\n-\n     /**\n      * Creates a new MediumWeightPopup object.\n      *\n-     * @param c DOCUMENT ME!\n+     * @param c Container with JPopupMenu's menu items\n      */\n     public MediumWeightPopup(Container c)\n     {\n-      this.add(c);      \n+      this.add(c);\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Displays AWT Panel with its components on the screen\n      *\n-     * @param x DOCUMENT ME!\n-     * @param y DOCUMENT ME!\n-     * @param width DOCUMENT ME!\n-     * @param heigth DOCUMENT ME!\n+     * @param x x-coordinate of the upper-left corner of the panel's\n+     * @param y y-coordinate of the upper-left corner of the panel's\n+     * @param width width of the panel\n+     * @param height height of the panel\n      */\n     public void show(int x, int y, int width, int height)\n     {\n@@ -890,39 +978,40 @@ public void show(int x, int y, int width, int height)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Hides This panel from the screen\n      */\n     public void hide()\n     {\n       JLayeredPane layeredPane;\n-      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane(); \n+      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n       int index = layeredPane.getIndexOf(this);\n       layeredPane.remove(index);\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * HeavyWeightPopup is JWindow that is used to display JPopupMenu menu item's\n+   * on the screen\n    */\n   private class HeavyWeightPopup extends JWindow implements Popup\n   {\n     /**\n      * Creates a new HeavyWeightPopup object.\n      *\n-     * @param c DOCUMENT ME!\n+     * @param c Container containing menu items\n      */\n     public HeavyWeightPopup(Container c)\n     {\n       this.setContentPane(c);\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Displays JWindow container JPopupMenu's menu items to the screen\n      *\n-     * @param x DOCUMENT ME!\n-     * @param y DOCUMENT ME!\n-     * @param width DOCUMENT ME!\n-     * @param height DOCUMENT ME!\n+     * @param x x-coordinate of JWindow containing menu items\n+     * @param y y-coordinate of JWindow containing menu items\n+     * @param width width of the JWindow\n+     * @param height height of the JWindow\n      */\n     public void show(int x, int y, int width, int height)\n     {\n@@ -931,57 +1020,34 @@ public void show(int x, int y, int width, int height)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Hides JWindow with menu item's from the screen.\n      */\n     public void hide()\n     {\n-      this.hide();\n+      super.hide();\n     }\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   public static class Separator extends JSeparator\n   {\n-    /**\n-     * Creates a new Separator object.\n-     */\n     public Separator()\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public String getUIClassID()\n     {\n-      return null;\n+      return \"PopupMenuSeparatorUI\";\n     }\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class AccessibleJPopupMenu extends AccessibleJComponent\n   {\n-    /**\n-     * Creates a new AccessibleJPopupMenu object.\n-     *\n-     * @param component DOCUMENT ME!\n-     */\n-    protected AccessibleJPopupMenu(JPopupMenu component)\n+    private static final long serialVersionUID = 7423261328879849768L;\n+\n+    protected AccessibleJPopupMenu()\n     {\n-      super(component);\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return DOCUMENT ME!\n-     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.POPUP_MENU;"}, {"sha": "3c4084724f2aa3e10f0e984a1660bfb4461754f4", "filename": "libjava/javax/swing/JProgressBar.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJProgressBar.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -85,14 +85,15 @@ public class JProgressBar extends JComponent implements SwingConstants,\n   protected class AccessibleJProgressBar extends AccessibleJComponent\n     implements AccessibleValue\n   {\n+    private static final long serialVersionUID = -2938130009392721813L;\n+  \n     /**\n      * Constructor AccessibleJProgressBar\n      *\n      * @param component TODO\n      */\n-    protected AccessibleJProgressBar(JProgressBar component)\n+    protected AccessibleJProgressBar()\n     {\n-      super(component);\n     } \n \n     /**\n@@ -168,6 +169,8 @@ public Number getMaximumAccessibleValue()\n     } \n   } \n \n+  private static final long serialVersionUID = 1980046021813598781L;\n+  \n   /** Fired in a PropertyChangeEvent when the \"borderPainted\" property changes. */\n   public static final String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n   \n@@ -661,7 +664,8 @@ public boolean isIndeterminate()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJProgressBar(this);\n+      accessibleContext = new AccessibleJProgressBar();\n+    \n     return accessibleContext;\n   } \n }"}, {"sha": "0802ac09ba455e97fd9fc1b0597dfb11a0c4ed8e", "filename": "libjava/javax/swing/JRadioButton.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRadioButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRadioButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButton.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* JRadioButton.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,6 +42,8 @@\n \n public class JRadioButton extends JToggleButton\n {\n+  private static final long serialVersionUID = 7751949583255506856L;\n+\n     public JRadioButton()\n     {\n \tthis(null, null);"}, {"sha": "a1611879933a8ceb72714eaebbaea896803dac07", "filename": "libjava/javax/swing/JRadioButtonMenuItem.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -49,6 +49,8 @@\n  */\n public class JRadioButtonMenuItem extends JMenuItem implements Accessible\n {\n+  private static final long serialVersionUID = 8482658191548521743L;\n+\n   private static final String uiClassID = \"RadioButtonMenuItemUI\";\n \n   /**\n@@ -185,7 +187,7 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJRadioButtonMenuItem(this);\n+      accessibleContext = new AccessibleJRadioButtonMenuItem();\n \n     return accessibleContext;\n   }\n@@ -195,16 +197,13 @@ public AccessibleContext getAccessibleContext()\n    */\n   protected class AccessibleJRadioButtonMenuItem extends AccessibleJMenuItem\n   {\n+    private static final long serialVersionUID = 4381471510145292179L;\n+\n     /**\n      * Creates a new AccessibleJRadioButtonMenuItem object.\n-     *\n-     * @param component DOCUMENT ME!\n      */\n-    protected AccessibleJRadioButtonMenuItem(JRadioButtonMenuItem component)\n+    protected AccessibleJRadioButtonMenuItem()\n     {\n-      super(component);\n-\n-      // TODO\n     }\n \n     /**"}, {"sha": "b1c24a207d9db15a14246077819f5269be6c78f2", "filename": "libjava/javax/swing/JRootPane.java", "status": "modified", "additions": 237, "deletions": 224, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRootPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJRootPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRootPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.BorderLayout;\n@@ -44,282 +43,296 @@\n import java.awt.Dimension;\n import java.awt.LayoutManager;\n import java.awt.LayoutManager2;\n+import java.io.Serializable;\n+import javax.accessibility.AccessibleRole;\n import javax.swing.plaf.RootPaneUI;\n \n /**\n  * This class is where JComponents are added to.\n  * Unlike awt where you could just say frame.add(),\n- * with swing you need to say frame.getRootPane() \n+ * with swing you need to say frame.getRootPane()\n  * (which delivers an instance of this class)\n  * and add your components to that.\n  *\n- * It is implemented by several 'layers' (pane() should be read as plane()) \n+ * It is implemented by several 'layers' (pane() should be read as plane())\n  * each on top of the others\n- * where you can add components to. \n+ * where you can add components to.\n  * (getContentPane(), getGlassPane(), getLayeredPane())\n  *\n  * @author Ronald Veldema (rveldema@cs.vu.nl)\n  */\n public class JRootPane extends JComponent\n {\n-    //  The class used to obtain the accessible role for this object.\n-    static protected class AccessibleJRootPane\n+  //  The class used to obtain the accessible role for this object.\n+  protected static class AccessibleJRootPane\n+  {\n+    private static final long serialVersionUID = 1082432482784468088L;\n+\n+    protected AccessibleJRootPane()\n     {\n     }\n \n-    // Custom Layout Manager for JRootPane. It positions contentPane and \n-    // menuBar withing its layeredPane.\n-    protected class RootLayout extends Object implements LayoutManager2\n+    public AccessibleRole getAccessibleRole()\n     {\n-      public void addLayoutComponent(Component comp, Object constraints)\n-      {\n-      }\n-\n-      public void addLayoutComponent(String name, Component comp)\n-      {\n-      }\n-\n-      public float getLayoutAlignmentX(Container target)\n-      {\n-        return target.getAlignmentX();\n-      }\n-\n-      public float getLayoutAlignmentY(Container target)\n-      {\n-        return target.getAlignmentY();\n-      }\n-\n-      public void invalidateLayout(Container target)\n-      {\n-      }\n-\n-      public void layoutContainer(Container c)\n-      {\n-        Dimension menuBarSize;\n-        Dimension containerSize = c.getSize(null);\n-        Dimension contentPaneSize = contentPane.getPreferredSize();\n-\n-        /*\n-         if size of top-level window wasn't set then just set\n-         contentPane and menuBar to its preferred sizes.\n-         Otherwise, if the size of top-level window was specified then\n-         set menuBar to its preferred size and make content pane\n-         to fit into the remaining space\n-\n-\n-         +-------------------------------+\n-         |  JLayeredPane                 |  \n-         |  +--------------------------+ |\n-         |  | menuBar                  | |\n-         |  +--------------------------+ |\n-         |  +--------------------------+ |\n-         |  |contentPane               | |\n-         |  |                          | |\n-         |  |                          | |\n-         |  |                          | |\n-         |  +--------------------------+ |\n-         +-------------------------------+\n-\n-        */\n-        if (containerSize.width == 0 && containerSize.height == 0)\n-          {\n-\t      if (menuBar != null)\n-\t      {\n-\t        int maxWidth;\n-\t        menuBarSize = menuBar.getPreferredSize();\n-\t        maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n-\t        menuBar.setBounds(0, 0, maxWidth, menuBarSize.height);\n-\t        contentPane.setBounds(0, menuBarSize.height, maxWidth,\n-\t                              contentPaneSize.height);\n-\t        layeredPane.setSize(maxWidth,\n-\t                            menuBarSize.height + contentPaneSize.height);\n-\t      }\n-\t    else\n-\t      {\n-\t        contentPane.setBounds(0, 0, contentPaneSize.width,\n-\t                              contentPaneSize.height);\n-\t        layeredPane.setSize(contentPaneSize.width, contentPaneSize.height);\n-\t      }\n-          }\n-        else\n-          {\n-\t    if (menuBar != null)\n-\t      {\n-\t        menuBarSize = menuBar.getPreferredSize();\n-\t        if (menuBarSize.height > containerSize.height)\n-\t\t   menuBarSize.height = containerSize.height;\n-\t        menuBar.setBounds(0, 0, containerSize.width, menuBarSize.height);\n-\t        int remainingHeight = containerSize.height - menuBarSize.height;\n-\t        contentPane.setBounds(0, menuBarSize.height,\n-\t                              containerSize.width,\n-\t                              (containerSize.height - menuBarSize.height));\n-\t      }\n-\t    else\n-\t      contentPane.setBounds(0, 0, containerSize.width,\n-\t                            containerSize.height);\n-\n-\t    layeredPane.setSize(containerSize.width, containerSize.height);\n-          }\n-      }\n-      \n-      public Dimension maximumLayoutSize(Container target)\n-      {\n-        return preferredLayoutSize(target);\n-      }\n-\n-      public Dimension minimumLayoutSize(Container target)\n-      {\n-        return preferredLayoutSize(target);\n-      }\n-\n-      public Dimension preferredLayoutSize(Container c)\n-      {\n-        Dimension menuBarSize;\n-        Dimension prefSize;\n-\n-        Dimension containerSize = c.getSize();\n-        Dimension contentPaneSize = contentPane.getPreferredSize();\n-\n-        if (containerSize.width == 0 && containerSize.height == 0)\n-          {\n-\t    if (menuBar != null)\n-\t      {\n-\t        int maxWidth;\n-\t        menuBarSize = menuBar.getPreferredSize();\n-\t        maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n-\t        prefSize = new Dimension(maxWidth,\n-\t                               contentPaneSize.height\n-\t                               + menuBarSize.height);\n-\t      }\n-\t    else\n-\t      prefSize = contentPaneSize;\n-          }\n-        else\n-          prefSize = c.getSize();\n-\n-        return prefSize;\n-      }\n-\n-      public void removeLayoutComponent(Component comp)\n-      {\n-      }\n+      return AccessibleRole.ROOT_PANE;\n     }\n-  \n-    protected  Component glassPane;\n-    protected  JLayeredPane layeredPane;  \n-    protected  JMenuBar menuBar;  \n-    protected Container contentPane;\n-  \n-    \n-    void setJMenuBar(JMenuBar m)\n-    {  \n-      menuBar = m; \n-      getLayeredPane().add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);\n-    }\n-\n-    JMenuBar getJMenuBar()\n-    {  return menuBar; }\n+  }\n \n-  public boolean isValidateRoot()\n+  // Custom Layout Manager for JRootPane. It positions contentPane and \n+  // menuBar withing its layeredPane.\n+  protected class RootLayout implements LayoutManager2, Serializable\n   {\n-    return true;\n-  }\n-    \n+    private static final long serialVersionUID = -4100116998559815027L;\n \n-    public Container getContentPane()\n+    protected RootLayout()\n+    {\n+    }\n+    \n+    public void addLayoutComponent(Component comp, Object constraints)\n     {\n-\tif (contentPane == null)\n-\t    {\n-\t\tsetContentPane(createContentPane());\n-\t    }\n-\treturn contentPane;\n     }\n \n-    public void setContentPane(Container p)\n+    public void addLayoutComponent(String name, Component comp)\n     {\n-\tcontentPane = p;    \n-\tgetLayeredPane().add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);\n     }\n \n-    protected void addImpl(Component comp,\n-\t\t\t  Object constraints,\n-\t\t\t  int index)\n+    public float getLayoutAlignmentX(Container target)\n     {\n-\tsuper.addImpl(comp, constraints, index);\n-    } \n+      return target.getAlignmentX();\n+    }\n \n-    public Component getGlassPane() \n+    public float getLayoutAlignmentY(Container target)\n     {\n-\tif (glassPane == null)\n-\t    setGlassPane(createGlassPane());\n-\treturn glassPane;    \n+      return target.getAlignmentY();\n     }\n \n-    public void setGlassPane(Component f)\n+    public void invalidateLayout(Container target)\n     {\n-\tif (glassPane != null)\n-\t    remove(glassPane);\n+    }\n \n-\tglassPane = f; \n+    public void layoutContainer(Container c)\n+    {\n+      Dimension menuBarSize;\n+      Dimension containerSize = c.getSize(null);\n+      Dimension contentPaneSize = contentPane.getPreferredSize();\n+\n+      /*\n+       if size of top-level window wasn't set then just set\n+       contentPane and menuBar to its preferred sizes.\n+       Otherwise, if the size of top-level window was specified then\n+       set menuBar to its preferred size and make content pane\n+       to fit into the remaining space\n+\n+\n+       +-------------------------------+\n+       |  JLayeredPane                 |\n+       |  +--------------------------+ |\n+       |  | menuBar                  | |\n+       |  +--------------------------+ |\n+       |  +--------------------------+ |\n+       |  |contentPane               | |\n+       |  |                          | |\n+       |  |                          | |\n+       |  |                          | |\n+       |  +--------------------------+ |\n+       +-------------------------------+\n+\n+      */\n+      if (containerSize.width == 0 && containerSize.height == 0)\n+        {\n+\t  if (menuBar != null)\n+\t    {\n+\t      int maxWidth;\n+\t      menuBarSize = menuBar.getPreferredSize();\n+\t      maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n+\t      menuBar.setBounds(0, 0, maxWidth, menuBarSize.height);\n+\t      contentPane.setBounds(0, menuBarSize.height, maxWidth,\n+\t                            contentPaneSize.height);\n+\t      layeredPane.setSize(maxWidth,\n+\t                          menuBarSize.height + contentPaneSize.height);\n+\t    }\n+\t  else\n+\t    {\n+\t      contentPane.setBounds(0, 0, contentPaneSize.width,\n+\t                            contentPaneSize.height);\n+\t      layeredPane.setSize(contentPaneSize.width, contentPaneSize.height);\n+\t    }\n+        }\n+      else\n+        {\n+\t  if (menuBar != null)\n+\t    {\n+\t      menuBarSize = menuBar.getPreferredSize();\n+\t      if (menuBarSize.height > containerSize.height)\n+\t\tmenuBarSize.height = containerSize.height;\n+\t      menuBar.setBounds(0, 0, containerSize.width, menuBarSize.height);\n+\t      int remainingHeight = containerSize.height - menuBarSize.height;\n+\t      contentPane.setBounds(0, menuBarSize.height,\n+\t                            containerSize.width,\n+\t                            (containerSize.height - menuBarSize.height));\n+\t    }\n+\t  else\n+\t    contentPane.setBounds(0, 0, containerSize.width,\n+\t                          containerSize.height);\n \n-\tglassPane.setVisible(false);\n-\tadd(glassPane, 0);\n+\t  layeredPane.setSize(containerSize.width, containerSize.height);\n+        }\n     }\n \n-    public JLayeredPane getLayeredPane() \n+    public Dimension maximumLayoutSize(Container target)\n     {\n-\tif (layeredPane == null)\n-\t    setLayeredPane(createLayeredPane());\n-\treturn layeredPane;    \n+      return preferredLayoutSize(target);\n     }\n-    public void setLayeredPane(JLayeredPane f)\n+\n+    public Dimension minimumLayoutSize(Container target)\n     {\n-\tif (layeredPane != null)\n-\t    remove(layeredPane);\n-\t\n-\tlayeredPane = f; \n-\tadd(f, -1);\n+      return preferredLayoutSize(target);\n     }\n-    \n \n-    JRootPane()\n+    public Dimension preferredLayoutSize(Container c)\n     {\n-\tsetLayout(createRootLayout());\n-\tgetGlassPane();\n-\tgetLayeredPane();\n-\tgetContentPane();\n-\tsetDoubleBuffered(true);\n-\tupdateUI();\n-    }\n+      Dimension menuBarSize;\n+      Dimension prefSize;\n \n-    protected LayoutManager createRootLayout() {\n-        return new RootLayout();\n-    } \n+      Dimension containerSize = c.getSize();\n+      Dimension contentPaneSize = contentPane.getPreferredSize();\n \n-    JComponent createContentPane()\n-    {\n-\tJPanel p = new JPanel();\n-\tp.setName(this.getName()+\".contentPane\");\n-\tp.setLayout(new BorderLayout());\n-\treturn p;\n+      if (containerSize.width == 0 && containerSize.height == 0)\n+        {\n+\t  if (menuBar != null)\n+\t    {\n+\t      int maxWidth;\n+\t      menuBarSize = menuBar.getPreferredSize();\n+\t      maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n+\t      prefSize =\n+\t\tnew Dimension(maxWidth,\n+\t\t              contentPaneSize.height + menuBarSize.height);\n+\t    }\n+\t  else\n+\t    prefSize = contentPaneSize;\n+        }\n+      else\n+\tprefSize = c.getSize();\n+\n+      return prefSize;\n     }\n \n-    Component createGlassPane()\n+    public void removeLayoutComponent(Component comp)\n     {\n-\tJPanel p = new JPanel();\n-\tp.setName(this.getName()+\".glassPane\");\n-\tp.setLayout(new BorderLayout());\n-\tp.setVisible(false);\n-\treturn p;\n     }\n+  }\n \n-    JLayeredPane createLayeredPane()\n-    {\n-\tJLayeredPane l = new JLayeredPane();\n-\tl.setLayout(null);\n-\treturn l;\n-    }    \n+  protected Component glassPane;\n+  protected JLayeredPane layeredPane;\n+  protected JMenuBar menuBar;\n+  protected Container contentPane;\n+\n+  public void setJMenuBar(JMenuBar m)\n+  {\n+    menuBar = m;\n+    getLayeredPane().add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);\n+  }\n \n+  public JMenuBar getJMenuBar()\n+  {\n+    return menuBar;\n+  }\n+\n+  public boolean isValidateRoot()\n+  {\n+    return true;\n+  }\n+\n+  public Container getContentPane()\n+  {\n+    if (contentPane == null)\n+      setContentPane(createContentPane());\n+    return contentPane;\n+  }\n+\n+  public void setContentPane(Container p)\n+  {\n+    contentPane = p;\n+    getLayeredPane().add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);\n+  }\n+\n+  protected void addImpl(Component comp, Object constraints, int index)\n+  {\n+    super.addImpl(comp, constraints, index);\n+  }\n+\n+  public Component getGlassPane()\n+  {\n+    if (glassPane == null)\n+      setGlassPane(createGlassPane());\n+    return glassPane;\n+  }\n+\n+  public void setGlassPane(Component f)\n+  {\n+    if (glassPane != null)\n+      remove(glassPane);\n+\n+    glassPane = f;\n+\n+    glassPane.setVisible(false);\n+    add(glassPane, 0);\n+  }\n+\n+  public JLayeredPane getLayeredPane()\n+  {\n+    if (layeredPane == null)\n+      setLayeredPane(createLayeredPane());\n+    return layeredPane;\n+  }\n+\n+  public void setLayeredPane(JLayeredPane f)\n+  {\n+    if (layeredPane != null)\n+      remove(layeredPane);\n+\n+    layeredPane = f;\n+    add(f, -1);\n+  }\n+\n+  public JRootPane()\n+  {\n+    setLayout(createRootLayout());\n+    getGlassPane();\n+    getLayeredPane();\n+    getContentPane();\n+    setDoubleBuffered(true);\n+    updateUI();\n+  }\n+\n+  protected LayoutManager createRootLayout()\n+  {\n+    return new RootLayout();\n+  }\n+\n+  protected JComponent createContentPane()\n+  {\n+    JPanel p = new JPanel();\n+    p.setName(this.getName() + \".contentPane\");\n+    p.setLayout(new BorderLayout());\n+    return p;\n+  }\n+\n+  protected Component createGlassPane()\n+  {\n+    JPanel p = new JPanel();\n+    p.setName(this.getName() + \".glassPane\");\n+    p.setLayout(new BorderLayout());\n+    p.setVisible(false);\n+    return p;\n+  }\n+\n+  protected JLayeredPane createLayeredPane()\n+  {\n+    JLayeredPane l = new JLayeredPane();\n+    l.setLayout(null);\n+    return l;\n+  }\n \n   public RootPaneUI getUI()\n   {"}, {"sha": "07fe5cc85013401d6558451d92b2a60938ba0609", "filename": "libjava/javax/swing/JScrollBar.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollBar.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -67,14 +67,16 @@ public class JScrollBar extends JComponent implements Adjustable, Accessible\n   protected class AccessibleJScrollBar extends JComponent.AccessibleJComponent\n     implements AccessibleValue\n   {\n+    private static final long serialVersionUID = -7758162392045586663L;\n+    \n     /**\n      * Creates a new AccessibleJSlider object.\n      *\n      * @param value0 DOCUMENT ME!\n      */\n-    protected AccessibleJScrollBar(JScrollBar value0)\n+    protected AccessibleJScrollBar()\n     {\n-      super(value0);\n+      super();\n     }\n \n     /**\n@@ -150,6 +152,8 @@ public Number getMaximumAccessibleValue()\n     }\n   }\n \n+  private static final long serialVersionUID = -8195169869225066566L;\n+  \n   /** Fired in a PropertyChangeEvent when the \"blockIncrement\" changes. */\n   public static final String BLOCK_INCREMENT_CHANGED_PROPERTY = \"blockIncrement\";\n \n@@ -725,7 +729,7 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJScrollBar(this);\n+      accessibleContext = new AccessibleJScrollBar();\n     return accessibleContext;\n   }\n }"}, {"sha": "7e8bdce1897d8bf9e4edc37d4a15ef82b7faa33a", "filename": "libjava/javax/swing/JScrollPane.java", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -79,20 +79,23 @@ public class JScrollPane\n   extends JComponent \n   implements Accessible, ScrollPaneConstants\n {\n-  JViewport columnHeader;\n-  JViewport rowHeader;\n+  private static final long serialVersionUID = 5203525440012340014L;\n+  \n+  protected JViewport columnHeader;\n+  protected JViewport rowHeader;\n \n-  Component lowerLeft;\n-  Component lowerRight;\n-  Component upperLeft;\n-  Component upperRight;\n+  protected Component lowerLeft;\n+  protected Component lowerRight;\n+  protected Component upperLeft;\n+  protected Component upperRight;\n \n-  JScrollBar horizontalScrollBar;\n-  int horizontalScrollBarPolicy;\n-  JScrollBar verticalScrollBar;\n-  int verticalScrollBarPolicy;\n+  protected JScrollBar horizontalScrollBar;\n+  protected int horizontalScrollBarPolicy;\n+  protected JScrollBar verticalScrollBar;\n+  protected int verticalScrollBarPolicy;\n \n-  JViewport viewport;\n+  protected JViewport viewport;\n+  \n   Border viewportBorder;\n   boolean wheelScrollingEnabled;\n   ChangeListener scrollListener;  "}, {"sha": "5b99795a5ccec45a811ebaf495d174597225b048", "filename": "libjava/javax/swing/JSeparator.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSeparator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSeparator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSeparator.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -55,14 +55,15 @@ public class JSeparator extends JComponent implements SwingConstants,\n    */\n   protected class AccessibleJSeparator extends AccessibleJComponent\n   {\n+    private static final long serialVersionUID = 916332890553201095L;\n+  \n     /**\n      * Constructor AccessibleJSeparator\n      *\n      * @param component TODO\n      */\n-    protected AccessibleJSeparator(JSeparator component)\n+    protected AccessibleJSeparator()\n     {\n-      super(component);\n     }\n \n     /**\n@@ -76,6 +77,8 @@ public AccessibleRole getAccessibleRole()\n     }\n   }\n \n+  private static final long serialVersionUID = 125301223445282357L;\n+  \n   /** The orientation of the JSeparator. */\n   private transient int orientation = HORIZONTAL;\n \n@@ -198,7 +201,8 @@ public boolean isFocusTraversable()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJSeparator(this);\n+      accessibleContext = new AccessibleJSeparator();\n+    \n     return accessibleContext;\n   }\n }"}, {"sha": "0bc013cb128a79c88d98b8ba7e8b6bf3722ef001", "filename": "libjava/javax/swing/JSlider.java", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSlider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSlider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSlider.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -122,14 +122,15 @@ public class JSlider extends JComponent implements SwingConstants, Accessible,\n   protected class AccessibleJSlider extends JComponent.AccessibleJComponent\n     implements AccessibleValue\n   {\n+    private static final long serialVersionUID = -6301740148041106789L;\n+  \n     /**\n      * Creates a new AccessibleJSlider object.\n      *\n      * @param value0 DOCUMENT ME!\n      */\n-    protected AccessibleJSlider(JSlider value0)\n+    protected AccessibleJSlider()\n     {\n-      super(value0);\n     }\n \n     /**\n@@ -933,7 +934,8 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJSlider(this);\n+      accessibleContext = new AccessibleJSlider();\n+    \n     return accessibleContext;\n   }\n }"}, {"sha": "32b85e1da953876c2e7fcaadafd4ac9d0ac5cd41", "filename": "libjava/javax/swing/JSplitPane.java", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSplitPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJSplitPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSplitPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,3 +1,40 @@\n+/* JSplitPane.java -- \n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n \n package javax.swing;\n \n@@ -26,14 +63,15 @@ public class JSplitPane extends JComponent implements Accessible\n   protected class AccessibleJSplitPane extends JComponent.AccessibleJComponent\n     implements AccessibleValue\n   {\n+  private static final long serialVersionUID = -1788116871416305366L;\n+  \n     /**\n      * Creates a new AccessibleJSplitPane object.\n      *\n      * @param value0 DOCUMENT ME!\n      */\n-    protected AccessibleJSplitPane(JSplitPane value0)\n+    protected AccessibleJSplitPane()\n     {\n-      super(value0);\n     }\n \n     /**\n@@ -109,6 +147,8 @@ public Number getMaximumAccessibleValue()\n     }\n   }\n \n+  private static final long serialVersionUID = -5634142046175988380L;\n+  \n   /** The constraints string used to add components to the bottom. */\n   public static final String BOTTOM = \"bottom\";\n \n@@ -311,7 +351,8 @@ else if (placement.equals(DIVIDER))\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJSplitPane(this);\n+      accessibleContext = new AccessibleJSplitPane();\n+    \n     return accessibleContext;\n   }\n \n@@ -522,7 +563,7 @@ else if (component == rightComponent)\n    */\n   public void remove(int index)\n   {\n-    Component component = getComponentAt(index);\n+    Component component = getComponent(index);\n     if (component == leftComponent)\n       leftComponent = null;\n     else if (component == rightComponent)"}, {"sha": "7cf91c30445f59ebe31238bd166695b838ebf886", "filename": "libjava/javax/swing/JTabbedPane.java", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTabbedPane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -79,14 +79,16 @@ public class JTabbedPane extends JComponent implements Serializable,\n   protected class AccessibleJTabbedPane extends JComponent.AccessibleJComponent\n     implements AccessibleSelection, ChangeListener\n   {\n+    private static final long serialVersionUID = 7610530885966830483L;\n+    \n     /**\n      * Creates a new AccessibleJTabbedPane object.\n      *\n      * @param c DOCUMENT ME!\n      */\n-    public AccessibleJTabbedPane(JTabbedPane c)\n+    public AccessibleJTabbedPane()\n     {\n-      super(c);\n+      super();\n     }\n \n     /**\n@@ -224,6 +226,12 @@ public void selectAllAccessibleSelection()\n    */\n   protected class ModelListener implements ChangeListener, Serializable\n   {\n+    private static final long serialVersionUID = 497359819958114132L;\n+\n+    protected ModelListener()\n+    {\n+    }\n+    \n     /**\n      * This method is called whenever the model  is changed.\n      *\n@@ -304,7 +312,9 @@ public Component getComponent()\n      */\n     public void setComponent(Component c)\n     {\n+      JTabbedPane.this.remove(component);\n       this.component = c;\n+      JTabbedPane.this.add(c);\n     }\n \n     /**\n@@ -542,10 +552,10 @@ public void setDisplayedMnemonicIndex(int index)\n   protected SingleSelectionModel model;\n \n   /** Indicates that the TabbedPane is in scrolling mode. */\n-  public static int SCROLL_TAB_LAYOUT = 1;\n+  public static final int SCROLL_TAB_LAYOUT = 1;\n \n   /** Indicates that the TabbedPane is in wrap mode. */\n-  public static int WRAP_TAB_LAYOUT = 0;\n+  public static final int WRAP_TAB_LAYOUT = 0;\n \n   /** The current tabPlacement of the TabbedPane. */\n   protected int tabPlacement = SwingConstants.TOP;\n@@ -825,12 +835,12 @@ public void setSelectedIndex(int index)\n     checkIndex(index, -1, tabs.size());\n     if (index != getSelectedIndex())\n       {\n-\tif (getSelectedIndex() != -1)\n+\tif (getSelectedIndex() != -1 && getSelectedComponent() != null)\n \t  getSelectedComponent().hide();\n-\tif (index != -1)\n+\tif (index != -1 && getComponentAt(index) != null)\n \t  getComponentAt(index).show();\n+        model.setSelectedIndex(index);\t  \n       }\n-    model.setSelectedIndex(index);\n   }\n \n   /**\n@@ -874,13 +884,17 @@ public void insertTab(String title, Icon icon, Component component,\n \n     // Hide the component so we don't see it. Do it before we parent it\n     // so we don't trigger a repaint.\n-    component.hide();\n-    super.add(component);\n-  \n+    if (component != null)\n+    {\n+      component.hide();\n+      super.add(component);\n+    }\n+    \n     if (getSelectedIndex() == -1)\n       setSelectedIndex(0);\n \n     layout();\n+    repaint();\n   }\n \n   /**\n@@ -1474,7 +1488,7 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJTabbedPane(this);\n+      accessibleContext = new AccessibleJTabbedPane();\n     return accessibleContext;\n   }\n }"}, {"sha": "73dac5e8bdd39305921ca46fa7a361452fd26be6", "filename": "libjava/javax/swing/JTable.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTable.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -58,6 +58,8 @@ public class JTable extends JComponent\n   implements TableModelListener, Scrollable, TableColumnModelListener,\n              ListSelectionListener, CellEditorListener, Accessible\n {\n+  private static final long serialVersionUID = 3876025080382781659L;\n+  \n   public static final int AUTO_RESIZE_ALL_COLUMNS = 4;\n   public static final int AUTO_RESIZE_LAST_COLUMN = 3;\n   public static final int AUTO_RESIZE_NEXT_COLUMN = 1;"}, {"sha": "7a44e91c5ca3cc13c74103d4e0c222d79e28ba27", "filename": "libjava/javax/swing/JTextArea.java", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTextArea.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -0,0 +1,231 @@\n+/* JTextArea.java -- \n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+import java.awt.Dimension;\n+import javax.swing.text.Document;\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.PlainDocument;\n+\n+public class JTextArea extends JTextComponent\n+{\n+  private static final long serialVersionUID = -6141680179310439825L;\n+  \n+  private int rows;\n+  private int columns;\n+  private boolean wrapping;\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   */\n+  public JTextArea()\n+  {\n+    this(null, null, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   *\n+   * @param text the initial text\n+   */\n+  public JTextArea(String text)\n+  {\n+    this(null, text, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   *\n+   * @param rows the number of rows\n+   * @param columns the number of cols\n+   *\n+   * @exception IllegalArgumentException if rows or columns are negative\n+   */\n+  public JTextArea(int rows, int columns)\n+  {\n+    this(null, null, rows, columns);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   *\n+   * @param text the initial text\n+   * @param rows the number of rows\n+   * @param columns the number of cols\n+   *\n+   * @exception IllegalArgumentException if rows or columns are negative\n+   */\n+  public JTextArea(String text, int rows, int columns)\n+  {\n+    this(null, text, rows, columns);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   *\n+   * @param the document model to use\n+   */\n+  public JTextArea(Document doc)\n+  {\n+    this(doc, null, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTextArea</code> object.\n+   *\n+   * @param the document model to use\n+   * @param text the initial text\n+   * @param rows the number of rows\n+   * @param columns the number of cols\n+   *\n+   * @exception IllegalArgumentException if rows or columns are negative\n+   */\n+  public JTextArea(Document doc, String text, int rows, int columns)\n+  {\n+    setDocument(doc == null ? createDefaultModel() : doc);\n+    setText(text);\n+    setRows(rows);\n+    setColumns(columns);\n+  }\n+\n+  /**\n+   * Appends some text.\n+   *\n+   * @param toAppend the text to append\n+   */\n+  public void append(String toAppend)\n+  {\n+    setText(getText() + toAppend);\n+  }\n+\n+  /**\n+   * Creates the default document model.\n+   *\n+   * @return a new default model\n+   */\n+  protected Document createDefaultModel()\n+  {\n+    return new PlainDocument();\n+  }\n+\n+\n+  public boolean getScrollableTracksViewportWidth()\n+  {\n+    return wrapping ? true : super.getScrollableTracksViewportWidth();\n+  }\n+\n+  /**\n+   * Returns the UI class ID string.\n+   *\n+   * @return the string \"TextAreaUI\"\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"TextAreaUI\";\n+  }\n+\n+  /**\n+   * Returns the current number of columns.\n+   *\n+   * @return number of columns\n+   */\n+  public int getColumns()\n+  {\n+    return columns;\n+  }\n+  \n+  /**\n+   * Sets the number of rows.\n+   *\n+   * @param columns number of columns\n+   *\n+   * @exception IllegalArgumentException if columns is negative\n+   */\n+  public void setColumns(int columns)\n+  {\n+    if (columns < 0)\n+      throw new IllegalArgumentException();\n+\n+    this.columns = columns;\n+  }\n+\n+  /**\n+   * Returns the current number of rows.\n+   *\n+   * @return number of rows\n+   */\n+  public int getRows()\n+  {\n+    return rows;\n+  }\n+\n+  /**\n+   * Sets the number of rows.\n+   *\n+   * @param columns number of columns\n+   *\n+   * @exception IllegalArgumentException if rows is negative\n+   */\n+  public void setRows(int rows)\n+  {\n+    if (rows < 0)\n+      throw new IllegalArgumentException();\n+\n+    this.rows = rows;\n+  }\n+\n+  /**\n+   * Checks whethet line wrapping is enabled.\n+   *\n+   * @return true if line wrapping is enabled, false otherwise\n+   */\n+  public boolean getLineWrap()\n+  {\n+    return wrapping;\n+  }\n+\n+  /**\n+   * Enables/disables line wrapping.\n+   *\n+   * @param wrapping true to enable line wrapping, false otherwise\n+   */\n+  public void setLineWrap(boolean wrapping)\n+  {\n+    this.wrapping = wrapping;\n+  }\n+}"}, {"sha": "46d35929a28f221a04c7b2ff6cfc1d69b5ed2c66", "filename": "libjava/javax/swing/JTextField.java", "status": "modified", "additions": 159, "deletions": 47, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTextField.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* JTextField.java -- \n+/* JTextField.java --\n    Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,73 +35,185 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n-import java.util.Vector;\n-\n import javax.accessibility.AccessibleStateSet;\n+import javax.swing.text.Document;\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.PlainDocument;\n+\n \n-public class JTextField extends JEditorPane\n+public class JTextField extends JTextComponent\n+  implements SwingConstants\n {\n+  /**\n+   * AccessibleJTextField\n+   */\n+  protected class AccessibleJTextField extends AccessibleJTextComponent\n+  {\n+    private static final long serialVersionUID = 8255147276740453036L;\n \n-\t/**\n-\t * AccessibleJTextField\n-\t */\n-\tprotected class AccessibleJTextField extends AccessibleJTextComponent {\n+    /**\n+     * Constructor AccessibleJTextField\n+     */\n+    protected AccessibleJTextField()\n+    {\n+    }\n \n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    /**\n+     * getAccessibleStateSet\n+     * @return AccessibleStateSet\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null;\n+    }\n+  }\n \n-\t\t/**\n-\t\t * Constructor AccessibleJTextField\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJTextField(JTextField component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJTextField()\n+  private static final long serialVersionUID = 353853209832607592L;\n \n+  public static final String notifyAction = \"notify-field-accept\";\n+  \n+  private int columns;\n \n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+  /**\n+   * Creates a new instance of <code>JTextField</code>.\n+   */\n+  public JTextField()\n+  {\n+    this(null, null, 0);\n+  }\n \n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n+  /**\n+   * Creates a new instance of <code>JTextField</code>.\n+   *\n+   * @param text the initial text\n+   */\n+  public JTextField(String text)\n+  {\n+    this(null, text, 0);\n+  }\n+  \n+  /**\n+   * Creates a new instance of <code>JTextField</code>.\n+   *\n+   * @param columns the number of columns\n+   *\n+   * @exception IllegalArgumentException if columns %lt; 0\n+   */\n+  public JTextField(int columns)\n+  {\n+    this(null, null, columns);\n+  }\n \n+  /**\n+   * Creates a new instance of <code>JTextField</code>.\n+   *\n+   * @param text the initial text\n+   * @param columns the number of columns\n+   *\n+   * @exception IllegalArgumentException if columns %lt; 0\n+   */\n+  public JTextField(String text, int columns)\n+  {\n+    this(null, text, columns);\n+  }\n \n-\t} // AccessibleJTextField\n+  /**\n+   * Creates a new instance of <code>JTextField</code>.\n+   *\n+   * @param doc the document to use\n+   * @param text the initial text\n+   * @param columns the number of columns\n+   *\n+   * @exception IllegalArgumentException if columns %lt; 0\n+   */\n+  public JTextField(Document doc, String text, int columns)\n+  {\n+    if (doc == null)\n+      doc = createDefaultModel();\n \n+    setDocument(doc);\n+    setText(text);\n+    setColumns(columns);\n+  }\n \n-    Vector actions = new Vector();\n+  /**\n+   * Creates the default model for this text field.\n+   * This implementation returns an instance of <code>PlainDocument</code>.\n+   *\n+   * @return a new instance of the default model\n+   */\n+  protected Document createDefaultModel()\n+  {\n+    return new PlainDocument();\n+  }\n \n-  public JTextField()\n+  /**\n+   * Adds a new listener object to this text field.\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addActionListener(ActionListener listener)\n   {\n+    listenerList.add(ActionListener.class, listener);\n   }\n \n-    public JTextField(int a)\n-    {\n-    }\n+  /**\n+   * Removes a listener object from this text field.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeActionListener(ActionListener listener)\n+  {\n+    listenerList.remove(ActionListener.class, listener);\n+  }\n \n-    public void addActionListener(ActionListener l)\n-    {\n-\tactions.addElement(l);\n-    }\n+  /**\n+   * Returns all registered <code>ActionListener</code> objects.\n+   *\n+   * @return an array of listeners\n+   */\n+  public ActionListener[] getActionListeners()\n+  {\n+    return (ActionListener[]) getListeners(ActionListener.class);\n+  }\n \n-    public void removeActionListener(ActionListener l)\n-    {\n-\tactions.removeElement(l);\n-    }\n+  /**\n+   * Sends an action event to all registered\n+   * <code>ActionListener</code> objects.\n+   */\n+  protected void fireActionPerformed()\n+  {\n+    ActionEvent event = new ActionEvent(this, 0, notifyAction);\n+    ActionListener[] listeners = getActionListeners();\n \n-    public void selectAll()\n-    {\n-    }\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].actionPerformed(event);\n+  }\n+\n+  /**\n+   * Returns the number of columns of this text field.\n+   *\n+   * @return the number of columns\n+   */\n+  public int getColumns()\n+  {\n+    return columns;\n+  }\n+\n+  public void setColumns(int columns)\n+  {\n+    if (columns < 0)\n+      throw new IllegalArgumentException();\n+\n+    this.columns = columns;\n+    // FIXME: Invalidate layout.\n+  }\n+\n+  public void selectAll()\n+  {\n+  }\n }"}, {"sha": "9f3395aa22791a6eecd485094d17806679194684", "filename": "libjava/javax/swing/JToggleButton.java", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToggleButton.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -47,6 +47,8 @@ public class JToggleButton extends AbstractButton implements Accessible\n \n   public static class ToggleButtonModel extends DefaultButtonModel\n   {\n+    private static final long serialVersionUID = -1589950750899943974L;\n+  \n     public void setPressed(boolean b)  \n     {\n       if (! isEnabled())\n@@ -62,6 +64,8 @@ public void setPressed(boolean b)\n   }\n \n \n+  private static final long serialVersionUID = -3128248873429850443L;\n+    \n   public JToggleButton()\n   {\n     this(null, null);\n@@ -82,6 +86,12 @@ public JToggleButton(String text)\n     this(text, null);\n   }\n       \n+  public JToggleButton(String text, boolean selected)\n+  {\n+    this(text, null);\n+    setSelected(selected);\n+  }\n+\n   public JToggleButton(String text, Icon icon)\n   {\n     this(text, icon, false);\n@@ -96,17 +106,20 @@ public JToggleButton (String text, Icon icon, boolean selected)\n     model.setSelected(selected);\n   }\n \n-\n-    \n+  /**\n+   * Gets the AccessibleContext associated with this JToggleButton.\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n-    //Gets the AccessibleContext associated with this JToggleButton. \n     return null;\n   }\n   \n+  /**\n+   * Returns a string that specifies the name of the L&amp;F class that renders\n+   * this component.\n+   */\n   public String getUIClassID()\n   {\n-    //Returns a string that specifies the name of the L&F class that renders this component.  \n     return \"ToggleButtonUI\";\n   }\n   "}, {"sha": "e6db8720c2c06ef731e0c879e537fd992d7e8172", "filename": "libjava/javax/swing/JToolBar.java", "status": "modified", "additions": 111, "deletions": 75, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToolBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToolBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToolBar.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -40,7 +40,9 @@\n import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Graphics;\n+import java.awt.GridLayout;\n import java.awt.Insets;\n+import java.awt.LayoutManager;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n@@ -59,58 +61,46 @@\n public class JToolBar extends JComponent \n   implements SwingConstants, Accessible\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJToolBar\n-\t */\n-\tprotected class AccessibleJToolBar extends AccessibleJComponent {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJToolBar\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJToolBar(JToolBar component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJToolBar()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.TOOL_BAR;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJToolBar\n+  /**\n+   * AccessibleJToolBar\n+   */\n+  protected class AccessibleJToolBar extends AccessibleJComponent\n+  {\n+    private static final long serialVersionUID = -5516888265903814215L;\n+\n+    /**\n+     * Constructor AccessibleJToolBar\n+     */\n+    protected AccessibleJToolBar()\n+    {\n+    }\n+\n+    /**\n+     * getAccessibleStateSet\n+     * @return AccessibleStateSet\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null; // TODO\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.TOOL_BAR;\n+    }\n+  }\n \n \t/**\n \t * Separator\n \t */\n \tpublic static class Separator extends JSeparator {\n \n+\t  private static final long serialVersionUID = -1656745644823105219L;\n+    \n \t\t//-------------------------------------------------------------\n \t\t// Variables --------------------------------------------------\n \t\t//-------------------------------------------------------------\n@@ -196,7 +186,27 @@ public void setSeparatorSize(Dimension size) {\n \n \t} // Separator\n \n-\n+//        /**\n+//         * DefaultJToolBarLayout\n+//         */\n+//        private class DefaultJToolBarLayout {\n+//\n+//            private void DefaultJToolBarLayout() {\n+//            }\n+//\n+//            private LayoutManager getLayout() {\n+//                switch (JToolBar.this.getOrientation()) {\n+//                    case HORIZONTAL: setLayout(new GridLayout(1, 0, 4, 4));\n+//                                     break;\n+//                    case VERTICAL: setLayout(new GridLayout(0, 1, 4, 4));\n+//                                   break;\n+//                }\n+//            }\n+//        } // DefaultJToolBarLayout\n+\n+\n+    private static final long serialVersionUID = -1269915519555129643L;\n+    \n \t//-------------------------------------------------------------\n \t// Variables --------------------------------------------------\n \t//-------------------------------------------------------------\n@@ -224,8 +234,13 @@ public void setSeparatorSize(Dimension size) {\n \t/**\n \t * orientation\n \t */\n-\tprivate int orientation;\n+\tprivate int orientation = HORIZONTAL;\n+\n+//        protected transient DefaultJToolBarLayout toolbarLayout;\n \n+\t/** Fired in a PropertyChangeEvent when the \"orientation\" property changes.\n+\t*/\n+\tpublic static final String ORIENTATION_CHANGED_PROPERTY = \"orientation\";\n \n \t//-------------------------------------------------------------\n \t// Initialization ---------------------------------------------\n@@ -235,32 +250,37 @@ public void setSeparatorSize(Dimension size) {\n \t * Constructor JToolBar\n \t */\n \tpublic JToolBar() {\n-\t\t// TODO\n+          this(null);\n \t} // JToolBar()\n \n \t/**\n \t * Constructor JToolBar\n-\t * @param orientation TODO\n+\t * @param orientation JToolBar orientation (HORIZONTAL or VERTICAL)\n \t */\n \tpublic JToolBar(int orientation) {\n-\t\t// TODO\n+          this(null, orientation);\n \t} // JToolBar()\n \n \t/**\n \t * Constructor JToolBar\n-\t * @param name TODO\n+\t * @param name Name assigned to undocked tool bar.\n \t */\n \tpublic JToolBar(String name) {\n-\t\t// TODO\n+          this(name, HORIZONTAL);\n \t} // JToolBar()\n \n \t/**\n \t * Constructor JToolBar\n-\t * @param name TODO\n-\t * @param orientation TODO\n+\t * @param name Name assigned to undocked tool bar.\n+\t * @param orientation JToolBar orientation (HORIZONTAL or VERTICAL)\n \t */\n \tpublic JToolBar(String name, int orientation) {\n-\t\t// TODO\n+\t        setName(name);\n+\t\tif (orientation != HORIZONTAL && orientation != VERTICAL)\n+\t\t\tthrow new IllegalArgumentException(orientation + \" is not a legal orientation\");\n+\t\tthis.orientation = orientation;\n+//                toolbarLayout = new DefaultJToolBarLayout();\n+                updateUI();\t\n \t} // JToolBar()\n \n \n@@ -299,6 +319,7 @@ protected void paintBorder(Graphics graphics) {\n \t * @returns ToolBarUI\n \t */\n \tpublic ToolBarUI getUI() {\n+\t    System.out.println(\"ui = \" + ui);\n \t\treturn (ToolBarUI) ui;\n \t} // getUI()\n \n@@ -314,8 +335,7 @@ public void setUI(ToolBarUI ui) {\n \t * updateUI\n \t */\n \tpublic void updateUI() {\n-\t\tsetUI((ToolBarUI) UIManager.get(this));\n-\t\tinvalidate();\n+          setUI((ToolBarUI)UIManager.getUI(this));\n \t} // updateUI()\n \n \t/**\n@@ -397,15 +417,31 @@ public void setFloatable(boolean floatable) {\n \t * @returns int\n \t */\n \tpublic int getOrientation() {\n-\t\treturn 0; // TODO\n+\t\treturn this.orientation;\n \t} // getOrientation()\n \n+\t/**\n+\t * setLayout\n+\t * @param mgr\n+\t */\n+\tpublic void setLayout(LayoutManager mgr) {\n+\t    super.setLayout(mgr);\n+\t} // setLayout()\n+\n \t/**\n \t * setOrientation\n-\t * @param orientation TODO\n+\t * @param orientation\n \t */\n \tpublic void setOrientation(int orientation) {\n-\t\t// TODO\n+\t\tif (orientation != HORIZONTAL && orientation != VERTICAL)\n+\t\t\tthrow new IllegalArgumentException(orientation + \" is not a legal orientation\");\n+\t    if (orientation != this.orientation)\n+\t    {\n+\t\tint oldOrientation = this.orientation;\n+\t\tthis.orientation = orientation;\n+\t\tfirePropertyChange(ORIENTATION_CHANGED_PROPERTY, oldOrientation,\n+\t\t\tthis.orientation);\n+\t    }\n \t} // setOrientation()\n \n \t/**\n@@ -447,10 +483,11 @@ protected PropertyChangeListener createActionChangeListener(JButton button) {\n \t * @param constraints TODO\n \t * @param index TODO\n \t */\n+  /*\n \tprotected void addImpl(Component component, Object constraints, int index) {\n \t\t// TODO\n \t} // addImpl()\n-\n+  */\n \t/**\n \t * paramString\n \t * @returns String\n@@ -459,16 +496,15 @@ protected String paramString() {\n \t\treturn null; // TODO\n \t} // paramString()\n \n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJToolBar(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JToolBar\n+  /**\n+   * getAccessibleContext\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJToolBar();\n+    \n+    return accessibleContext;\n+  }\n+}"}, {"sha": "87e4610db40ca733945d693693d9be041b5fce56", "filename": "libjava/javax/swing/JToolTip.java", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToolTip.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJToolTip.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToolTip.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -42,12 +42,18 @@\n \n public class JToolTip extends JComponent implements Accessible\n {\n-    String text;\n-\n-    JToolTip(String text)\n-    {\n-\tthis.text = text;\n-    }\n+  private static final long serialVersionUID = -1138929898906751643L;\n+  \n+  String text;\n+\n+  public JToolTip()\n+  {\n+  }\n+\n+  public void setTipText(String newText)\n+  {\n+    this.text = newText;\n+  }\n }\n \n "}, {"sha": "765a0d996e604d6f9d654b4902694ef09eafe8de", "filename": "libjava/javax/swing/JTree.java", "status": "modified", "additions": 309, "deletions": 65, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTree.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJTree.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTree.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* JTree.java -- \n+/* JTree.java --\n    Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,79 +35,323 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Dimension;\n import java.awt.Rectangle;\n-\n+import java.util.Hashtable;\n+import java.util.Vector;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n+import javax.swing.event.TreeExpansionEvent;\n+import javax.swing.event.TreeExpansionListener;\n+import javax.swing.event.TreeSelectionEvent;\n+import javax.swing.event.TreeSelectionListener;\n+import javax.swing.event.TreeWillExpandListener;\n import javax.swing.plaf.TreeUI;\n+import javax.swing.tree.ExpandVetoException;\n+import javax.swing.tree.TreeModel;\n+import javax.swing.tree.TreeNode;\n+import javax.swing.tree.TreePath;\n+\n \n-public class JTree extends JComponent implements Scrollable, Accessible\n+public class JTree extends JComponent\n+  implements Scrollable, Accessible\n {\n-    JTree()\n-    {\n-\tupdateUI();\n-    }\n-    \n-    public TreeUI getUI()\n-    {\n-        return (TreeUI) ui;\n-    }\n-\n-    public void setUI(TreeUI ui)\n-    {\n-        super.setUI(ui);\n-    }\n-\n-    public void updateUI()\n-    {\n-        setUI((TreeUI)UIManager.getUI(this));\n-    }\n-\n-    \n-    public String getUIClassID()\n-    {\n-\treturn \"TreeUI\";\n-    }\n-\n-\n-    public AccessibleContext getAccessibleContext()\n-    {\n-      return null;\n-    }\n-\n-    public Dimension getPreferredScrollableViewportSize()\n-    {\n-\treturn null;\n-    }\n-\n-    public int getScrollableUnitIncrement(Rectangle visibleRect,\n-\t\t\t\t\t  int orientation,\n-\t\t\t\t\t  int direction)\n-    {\n-\treturn 1;\n-    }\n-\n-    public int getScrollableBlockIncrement(Rectangle visibleRect,\n-\t\t\t\t\t   int orientation,\n-\t\t\t\t\t   int direction)\n-    {\n-\treturn 1;\n-    }\n-\n-    public boolean getScrollableTracksViewportWidth()\n-    {\n-\treturn false;\n-    }\n-\n-    public boolean getScrollableTracksViewportHeight()\n-    {\n-\treturn false;\n-    }\n-}\n+  private static final long serialVersionUID = 7559816092864483649L;\n+\n+  protected TreeModel treeModel;\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   */\n+  public JTree()\n+  {\n+    treeModel = createTreeModel(null);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param value the initial nodes in the tree\n+   */\n+  public JTree(Hashtable value)\n+  {\n+    treeModel = createTreeModel(value);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param value the initial nodes in the tree\n+   */\n+  public JTree(Object[] value)\n+  {\n+    treeModel = createTreeModel(value);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param model the model to use\n+   */\n+  public JTree(TreeModel model)\n+  {\n+    treeModel = model;\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param root the root node\n+   */\n+  public JTree(TreeNode root)\n+  {\n+    this(root, false);\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param root the root node\n+   * @param asksAllowChildren if false, all nodes without children are leaf nodes.\n+   * If true, only nodes that do not allow children are leaf nodes.\n+   */\n+  public JTree(TreeNode root, boolean asksAllowChildren)\n+  {\n+  }\n+\n+  /**\n+   * Creates a new <code>JTree</code> object.\n+   *\n+   * @param value the initial nodes in the tree\n+   */\n+  public JTree(Vector value)\n+  {\n+    treeModel = createTreeModel(value);\n+  }\n+\n+  /**\n+   * Creates a new <code>TreeModel</code> object.\n+   *\n+   * @param value the values stored in the model\n+   */\n+  protected static TreeModel createTreeModel(Object value)\n+  {\n+    // FIXME: Implement this.\n+    return null;\n+  }\n+\n+  public TreeUI getUI()\n+  {\n+    return (TreeUI) ui;\n+  }\n+\n+  public void setUI(TreeUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  public void updateUI()\n+  {\n+    setUI((TreeUI) UIManager.getUI(this));\n+  }\n+\n+  public String getUIClassID()\n+  {\n+    return \"TreeUI\";\n+  }\n+\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n+\n+  public Dimension getPreferredScrollableViewportSize()\n+  {\n+    return null;\n+  }\n+\n+  public int getScrollableUnitIncrement(Rectangle visibleRect,\n+                                        int orientation, int direction)\n+  {\n+    return 1;\n+  }\n \n+  public int getScrollableBlockIncrement(Rectangle visibleRect,\n+                                         int orientation, int direction)\n+  {\n+    return 1;\n+  }\n \n+  public boolean getScrollableTracksViewportWidth()\n+  {\n+    return false;\n+  }\n \n+  public boolean getScrollableTracksViewportHeight()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Adds a <code>TreeExpansionListener</code> object to the tree.\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addTreeExpansionListener(TreeExpansionListener listener)\n+  {\n+    listenerList.add(TreeExpansionListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a <code>TreeExpansionListener</code> object from the tree.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeTreeExpansionListener(TreeExpansionListener listener)\n+  {\n+    listenerList.remove(TreeExpansionListener.class, listener);\n+  }\n+\n+  /**\n+   * Returns all added <code>TreeExpansionListener</code> objects.\n+   *\n+   * @return an array of listeners\n+   */\n+  public TreeExpansionListener[] getTreeExpansionListeners()\n+  {\n+    return (TreeExpansionListener[]) getListeners(TreeExpansionListener.class);\n+  }\n+\n+  /**\n+   * Notifies all listeners that the tree was collapsed.\n+   *\n+   * @param path the path to the node that was collapsed\n+   */\n+  public void fireTreeCollapsed(TreePath path)\n+  {\n+    TreeExpansionEvent event = new TreeExpansionEvent(this, path);\n+    TreeExpansionListener[] listeners = getTreeExpansionListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].treeCollapsed(event);\n+  }\n+  \n+  /**\n+   * Notifies all listeners that the tree was expanded.\n+   *\n+   * @param path the path to the node that was expanded\n+   */\n+  public void fireTreeExpanded(TreePath path)\n+  {\n+    TreeExpansionEvent event = new TreeExpansionEvent(this, path);\n+    TreeExpansionListener[] listeners = getTreeExpansionListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].treeExpanded(event);\n+  }\n+\n+  /**\n+   * Adds a <code>TreeSelctionListener</code> object to the tree.\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addTreeSelectionListener(TreeSelectionListener listener)\n+  {\n+    listenerList.add(TreeSelectionListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a <code>TreeSelectionListener</code> object from the tree.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeTreeSelectionListener(TreeSelectionListener listener)\n+  {\n+    listenerList.remove(TreeSelectionListener.class, listener);\n+  }\n+\n+  /**\n+   * Returns all added <code>TreeSelectionListener</code> objects.\n+   *\n+   * @return an array of listeners\n+   */\n+  public TreeSelectionListener[] getTreeSelectionListeners()\n+  {\n+    return (TreeSelectionListener[]) getListeners(TreeSelectionListener.class);\n+  }\n+\n+  /**\n+   * Notifies all listeners when the selection of the tree changed.\n+   *\n+   * @param event the event to send\n+   */\n+  protected void fireValueChanged(TreeSelectionEvent event)\n+  {\n+    TreeSelectionListener[] listeners = getTreeSelectionListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].valueChanged(event);\n+  }\n+\n+  /**\n+   * Adds a <code>TreeWillExpandListener</code> object to the tree.\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addTreeWillExpandListener(TreeWillExpandListener listener)\n+  {\n+    listenerList.add(TreeWillExpandListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a <code>TreeWillExpandListener</code> object from the tree.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeTreeWillExpandListener(TreeWillExpandListener listener)\n+  {\n+    listenerList.remove(TreeWillExpandListener.class, listener);\n+  }\n+\n+  /**\n+   * Returns all added <code>TreeWillExpandListener</code> objects.\n+   *\n+   * @return an array of listeners\n+   */\n+  public TreeWillExpandListener[] getTreeWillExpandListeners()\n+  {\n+    return (TreeWillExpandListener[]) getListeners(TreeWillExpandListener.class);\n+  }\n+\n+  /**\n+   * Notifies all listeners that the tree will collapse.\n+   *\n+   * @param path the path to the node that will collapse\n+   */\n+  public void fireTreeWillCollapse(TreePath path)\n+    throws ExpandVetoException\n+  {\n+    TreeExpansionEvent event = new TreeExpansionEvent(this, path);\n+    TreeWillExpandListener[] listeners = getTreeWillExpandListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].treeWillCollapse(event);\n+  }\n+\n+  /**\n+   * Notifies all listeners that the tree will expand.\n+   *\n+   * @param path the path to the node that will expand\n+   */\n+  public void fireTreeWillExpand(TreePath path)\n+    throws ExpandVetoException\n+  {\n+    TreeExpansionEvent event = new TreeExpansionEvent(this, path);\n+    TreeWillExpandListener[] listeners = getTreeWillExpandListeners();\n+\n+    for (int index = 0; index < listeners.length; ++index)\n+      listeners[index].treeWillExpand(event);\n+  }\n+}"}, {"sha": "bbb4d5cb683287f2f7059275eb5f8fb5e8d6aa28", "filename": "libjava/javax/swing/JViewport.java", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJViewport.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -45,6 +45,7 @@\n import java.awt.Point;\n import java.awt.Rectangle;\n \n+import javax.accessibility.Accessible;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ViewportUI;\n@@ -91,19 +92,20 @@\n  * the underlying child at position <code>(-VX,-VY)</code></p>\n  *\n  */\n-\n public class JViewport extends JComponent\n {\n-  public static int BACKINGSTORE_SCROLL_MODE = 1;\n-  public static int BLIT_SCROLL_MODE = 2;\n-  public static int SIMPLE_SCROLL_MODE = 3;\n+  private static final long serialVersionUID = -6925142919680527970L;\n+  \n+  public static final int SIMPLE_SCROLL_MODE = 0;\n+  public static final int BLIT_SCROLL_MODE = 1;\n+  public static final int BACKINGSTORE_SCROLL_MODE = 2;\n \n   ChangeEvent changeEvent = new ChangeEvent(this);\n \n   int scrollMode;\n \n-  boolean scrollUnderway;\n-  boolean isViewSizeSet;\n+  protected boolean scrollUnderway;\n+  protected boolean isViewSizeSet;\n \n   /** \n    * The width and height of the Viewport's area in terms of view\n@@ -133,11 +135,23 @@ public JViewport()\n   public Dimension getExtentSize()\n   {\n     if (extentSize == null)\n-      return getPreferredSize();\n+      return toViewCoordinates(getSize());\n     else\n       return extentSize;\n   }\n \n+  public Dimension toViewCoordinates(Dimension size)\n+  {\n+    return size;\n+  }\n+\n+  public Point toViewCoordinates(Point p)\n+  {\n+    Point pos = getViewPosition();\n+    return new Point(p.x + pos.x,\n+                     p.y + pos.y);\n+  }\n+\n   public void setExtentSize(Dimension newSize)\n   {\n     extentSize = newSize;\n@@ -146,10 +160,10 @@ public void setExtentSize(Dimension newSize)\n \n   public Dimension getViewSize()\n   {\n-    if (viewSize == null)\n-      return getView().getPreferredSize();\n-    else\n+    if (isViewSizeSet)\n       return viewSize;\n+    else\n+      return getView().getSize();\n   }\n \n \n@@ -158,10 +172,17 @@ public void setViewSize(Dimension newSize)\n     viewSize = newSize;\n     Component view = getView();\n     if (view != null)\n-      view.setSize(newSize);\n+      view.setSize(viewSize);\n+    isViewSizeSet = true;\n     fireStateChanged();\n   }\n \n+  /**\n+   * Get the viewport's position in view space. Despite confusing name,\n+   * this really does return the viewport's (0,0) position in view space,\n+   * not the view's position.\n+   */\n+\n   public Point getViewPosition()\n   {\n     Component view = getView();"}, {"sha": "81acd1138a7a7e4f6915774d25a5263c8fd13377", "filename": "libjava/javax/swing/JWindow.java", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FJWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJWindow.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -60,6 +60,8 @@\n  */\n public class JWindow extends Window implements Accessible, RootPaneContainer\n {\n+  private static final long serialVersionUID = 5420698392125238833L;\n+  \n     public final static int HIDE_ON_CLOSE        = 0;\n     public final static int EXIT_ON_CLOSE        = 1;\n     public final static int DISPOSE_ON_CLOSE     = 2;\n@@ -114,13 +116,6 @@ public Dimension getPreferredSize()\n     return d;\n   }\n \n-    JMenuBar getJMenuBar()\n-    {    return getRootPane().getJMenuBar();   }\n-    \n-    void setJMenuBar(JMenuBar menubar)\n-    {    getRootPane().setJMenuBar(menubar); }\n-    \n-\n   public  void setLayout(LayoutManager manager)\n   {    super.setLayout(manager);  }\n "}, {"sha": "b78be0c7392c60ed04cb6298921fc70a55f612c6", "filename": "libjava/javax/swing/KeyStroke.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FKeyStroke.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FKeyStroke.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FKeyStroke.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -149,6 +149,7 @@ public static KeyStroke getKeyStroke(char keyChar) {\n \t * @param keyChar TODO\n \t * @param onKeyRelease TODO\n \t * @returns KeyStroke\n+\t * @deprecated Use getKeyStroke(char)\n \t */\n \tpublic static KeyStroke getKeyStroke(char keyChar, boolean onKeyRelease) {\n \t\tKeyStroke key = getKeyStroke(keyChar);"}, {"sha": "aa6b8a2ec6fc180cad8f6dbddc94ef8c7fd45e34", "filename": "libjava/javax/swing/LookAndFeel.java", "status": "modified", "additions": 125, "deletions": 83, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FLookAndFeel.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* LookAndFeel.java -- \n+/* LookAndFeel.java --\n    Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,92 +35,134 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import javax.swing.text.JTextComponent;\n \n+\n public abstract class LookAndFeel\n {\n-    public UIDefaults getDefaults()\n-    {\n-\t//This method is called once by UIManager.setLookAndFeel to create the look and feel specific defaults table.\n-\treturn null;\n-    }\n-\n-    public abstract  String getDescription();  \n-    public abstract  String getID();\n-    public abstract  String getName();\n-\n-    public void initialize()\n-    {\n-\t//UIManager.setLookAndFeel calls this method before the first call (and typically the only call) to getDefaults(). \n-    }\n-\n-    static void installBorder(JComponent c, String defaultBorderName)\n-    {\n-\t//Convenience method for installing a component's default Border object on the specified component if either the border is currently null or already an instance of UIResource. \n-    }\n-\n-    public static void installColors(JComponent c, String defaultBgName, String defaultFgName)\n-    {\n-\t//Convenience method for initializing a component's foreground and background color properties with values from the current defaults table. \n-    }\n-\n-    public static void installColorsAndFont(JComponent c, String defaultBgName, String defaultFgName, String defaultFontName)\n-    {\n-\t//Convenience method for initializing a components foreground background and font properties with values from the current defaults table. \n-    }\n-  \n-    public abstract  boolean isNativeLookAndFeel();\n-    public abstract  boolean isSupportedLookAndFeel();\n-\n-    public static void loadKeyBindings(InputMap retMap, Object[] keys)\n-    {\n-\t//Loads the bindings in keys into retMap. \n-    }\n-\n-    public static ComponentInputMap makeComponentInputMap(JComponent c, Object[] keys)\n-    {\n-\t//    Creates a ComponentInputMap from keys. \n-\treturn null;\n-    }  \n-\n-    public static Object makeIcon(Class baseClass, String gifFile)\n-    {\n-\t//Utility method that creates a UIDefaults.LazyValue that creates an ImageIcon UIResource for the specified gifFile filename. \n-\treturn null;\n-    }\n-  \n-    public static InputMap makeInputMap(Object[] keys)\n-    {\n-\t//Creates a InputMap from keys. \n-\treturn null;\n-    }\n-\n-    public static JTextComponent.KeyBinding[] makeKeyBindings(Object[] keyBindingList)\n-    {\n-\t//        Convenience method for building lists of KeyBindings.  \n-\treturn null;\n-    }\n-\n-  \n-    public String toString()\n-    {\n-\t//Returns a string that displays and identifies this object's properties. \n-\treturn \"LookAndFeel\";\n-    }\n-  \n-    public void uninitialize()\n-    {\n-\t//UIManager.setLookAndFeel calls this method just before we're replaced by a new default look and feel. \n-    }\n-\n-  \n-    public static void uninstallBorder(JComponent c)\n-    {\n-\t//Convenience method for un-installing a component's default border on the specified component if the border is currently an instance of UIResource.\n-    }\n-\n+  /**\n+   * This method is called once by UIManager.setLookAndFeel to create\n+   * the look and feel specific defaults table.\n+   *\n+   * @return the UI defaults\n+   */\n+  public UIDefaults getDefaults()\n+  {\n+    return null;\n+  }\n+\n+  public abstract String getDescription();\n+\n+  public abstract String getID();\n+\n+  public abstract String getName();\n+\n+  /**\n+   * UIManager.setLookAndFeel calls this method before the first call\n+   * (and typically the only call) to getDefaults(). \n+   */\n+  public void initialize()\n+  {\n+  }\n+\n+  /**\n+   * Convenience method for installing a component's default Border object\n+   * on the specified component if either the border is currently null\n+   * or already an instance of UIResource. \n+   */\n+  public static void installBorder(JComponent c, String defaultBorderName)\n+  {\n+  }\n+\n+  /**\n+   * Convenience method for initializing a component's foreground and\n+   * background color properties with values from the current defaults table.\n+   */\n+  public static void installColors(JComponent c, String defaultBgName, String defaultFgName)\n+  {\n+  }\n+\n+  /**\n+   * Convenience method for initializing a components foreground background\n+   * and font properties with values from the current defaults table. \n+   */\n+  public static void installColorsAndFont(JComponent component,\n+\t\t\t\t\t  String defaultBgName,\n+\t\t\t\t\t  String defaultFgName,\n+\t\t\t\t\t  String defaultFontName)\n+  {\n+  }\n+\n+  public abstract boolean isNativeLookAndFeel();\n+\n+  public abstract boolean isSupportedLookAndFeel();\n+\n+  /**\n+   * Loads the bindings in keys into retMap. \n+   */\n+  public static void loadKeyBindings(InputMap retMap, Object[] keys)\n+  {\n+  }\n+\n+  /**\n+   * Creates a ComponentInputMap from keys. \n+   */\n+  public static ComponentInputMap makeComponentInputMap(JComponent c,\n+\t\t\t\t\t\t\tObject[] keys)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Utility method that creates a UIDefaults.LazyValue that creates an\n+   * ImageIcon UIResource for the specified gifFile filename. \n+   */\n+  public static Object makeIcon(Class baseClass, String gifFile)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Creates a InputMap from keys. \n+   */\n+  public static InputMap makeInputMap(Object[] keys)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Convenience method for building lists of KeyBindings.  \n+   */\n+  public static JTextComponent.KeyBinding[] makeKeyBindings(Object[] keyBindingList)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Returns a string that displays and identifies this object's properties.\n+   *\n+   * @return the string \"LookAndFeel\"\n+   */\n+  public String toString()\n+  {\n+    return \"LookAndFeel\";\n+  }\n+\n+  /**\n+   * UIManager.setLookAndFeel calls this method just before we're replaced by\n+   * a new default look and feel. \n+   */\n+  public void uninitialize()\n+  {\n+  }\n+\n+  /**\n+   * Convenience method for un-installing a component's default border on the\n+   * specified component if the border is currently an instance of UIResource.\n+   */\n+  public static void uninstallBorder(JComponent c)\n+  {\n+  }\n }\n-"}, {"sha": "33988003b47a4ea73980faf48c1cb9ed02da5c95", "filename": "libjava/javax/swing/MenuSelectionManager.java", "status": "modified", "additions": 140, "deletions": 122, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,4 +1,4 @@\n-/* MenuSelectionManager.java -- \n+/* MenuSelectionManager.java --\n    Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,70 +35,111 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Component;\n import java.awt.Point;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n-\n+import java.util.ArrayList;\n import java.util.Vector;\n-\n import javax.swing.JMenu;\n import javax.swing.JMenuItem;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.EventListenerList;\n \n+\n+/**\n+ * This class manages current menu selectection. It provides\n+ * methods to clear and set current selected menu path.\n+ * It also fires StateChange event to its registered\n+ * listeners whenever selected path of the current menu hierarchy\n+ * changes.\n+ *\n+ */\n public class MenuSelectionManager\n {\n-  protected ChangeEvent changeEvent;\n-  \n-  protected EventListenerList listenerList = new EventListenerList ();\n+  /** ChangeEvent fired when selected path changes*/\n+  protected ChangeEvent changeEvent = new ChangeEvent(this);\n+\n+  /** List of listeners for this MenuSelectionManager */\n+  protected EventListenerList listenerList = new EventListenerList();\n \n+  /** Default manager for the current menu hierarchy*/\n   private static final MenuSelectionManager manager = new MenuSelectionManager();\n-  \n-  private Vector selection = new Vector();\n-  \n-  protected void fireStateChanged ()\n+\n+  /** Path to the currently selected menu */\n+  private Vector selectedPath = new Vector();\n+\n+  /**\n+   * Fires StateChange event to registered listeners\n+   */\n+  protected void fireStateChanged()\n   {\n-    ChangeListener[] listeners = getChangeListeners ();\n+    ChangeListener[] listeners = getChangeListeners();\n \n     for (int i = 0; i < listeners.length; i++)\n-      {\n-        listeners [i].stateChanged (new ChangeEvent (this));\n-      }\n+      listeners[i].stateChanged(changeEvent);\n   }\n \n-  public void addChangeListener (ChangeListener listener)\n+  /**\n+   * Adds ChangeListener to this MenuSelectionManager\n+   *\n+   * @param listener ChangeListener to add\n+   */\n+  public void addChangeListener(ChangeListener listener)\n   {\n-    listenerList.add (ChangeListener.class, listener);\n+    listenerList.add(ChangeListener.class, listener);\n   }\n \n-  public void removeChangeListener (ChangeListener listener)\n+  /**\n+   * Removes ChangeListener from the list of registered listeners\n+   * for this MenuSelectionManager.\n+   *\n+   * @param listener ChangeListner to remove\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n   {\n-    listenerList.remove (ChangeListener.class, listener);\n+    listenerList.remove(ChangeListener.class, listener);\n   }\n \n-  /** @since 1.4 */\n-  public ChangeListener[] getChangeListeners ()\n+  /**\n+   * Returns list of registered listeners with MenuSelectionManager\n+   *\n+   * @since 1.4\n+   */\n+  public ChangeListener[] getChangeListeners()\n   {\n-    return (ChangeListener[]) listenerList.getListeners (ChangeListener.class);\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n   }\n-  \n+\n   /**\n-   * Unselects all the menu elements on the selection path \n+   * Unselects all the menu elements on the selection path\n    */\n-  public void clearSelectedPath ()\n+  public void clearSelectedPath()\n   {\n-    for (int i = 0; i < selection.size (); i++)\n-      ((MenuElement) selection.get (i)).menuSelectionChanged (false);\n+    // Send events from the bottom most item in the menu - hierarchy to the\n+    // top most\n+    for (int i = selectedPath.size() - 1; i >= 0; i--)\n+      ((MenuElement) selectedPath.get(i)).menuSelectionChanged(false);\n+\n+    // notify all listeners that the selected path was changed    \n+    fireStateChanged();\n \n-    selection.clear ();\n+    // clear selected path\n+    selectedPath.clear();\n   }\n-  \n-  public Component componentForPoint (Component source, Point sourcePoint)\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param source DOCUMENT ME!\n+   * @param sourcePoint DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component componentForPoint(Component source, Point sourcePoint)\n   {\n     throw new UnsupportedOperationException(\"not implemented\");\n   }\n@@ -108,7 +149,7 @@ public Component componentForPoint (Component source, Point sourcePoint)\n    *\n    * @return default Manager\n    */\n-  public static MenuSelectionManager defaultManager ()\n+  public static MenuSelectionManager defaultManager()\n   {\n     return manager;\n   }\n@@ -118,12 +159,12 @@ public static MenuSelectionManager defaultManager ()\n    *\n    * @return Current selection path\n    */\n-  public MenuElement[] getSelectedPath ()\n+  public MenuElement[] getSelectedPath()\n   {\n-    MenuElement[] path = new MenuElement[selection.size ()];\n+    MenuElement[] path = new MenuElement[selectedPath.size()];\n \n     for (int i = 0; i < path.length; i++)\n-      path[i] = (MenuElement) selection.get (i);\n+      path[i] = (MenuElement) selectedPath.get(i);\n \n     return path;\n   }\n@@ -135,17 +176,17 @@ public MenuElement[] getSelectedPath ()\n    * @param c Component for which to check\n    * @return True if specified component is part of current menu\n    */\n-  boolean isComponentPartOfCurrentMenu (Component c)\n+  boolean isComponentPartOfCurrentMenu(Component c)\n   {\n     MenuElement[] subElements;\n-    for (int i = 0; i < selection.size (); i++)\n+    for (int i = 0; i < selectedPath.size(); i++)\n       {\n-        subElements = ((MenuElement) selection.get (i)).getSubElements ();\n-        for (int j = 0; j < subElements.length; j++)\n-          {\n-            if ((subElements[j].getComponent ()).equals (c))\n-              return true;\n-          }\n+\tsubElements = ((MenuElement) selectedPath.get(i)).getSubElements();\n+\tfor (int j = 0; j < subElements.length; j++)\n+\t  {\n+\t    if ((subElements[j].getComponent()).equals(c))\n+\t      return true;\n+\t  }\n       }\n \n     return false;\n@@ -156,7 +197,7 @@ boolean isComponentPartOfCurrentMenu (Component c)\n    *\n    * @param e DOCUMENT ME!\n    */\n-  public void processKeyEvent (KeyEvent e)\n+  public void processKeyEvent(KeyEvent e)\n   {\n     throw new UnsupportedOperationException(\"not implemented\");\n   }\n@@ -166,35 +207,20 @@ public void processKeyEvent (KeyEvent e)\n    *\n    * @param event Mouse event\n    */\n-  public void processMouseEvent (MouseEvent event)\n+  public void processMouseEvent(MouseEvent event)\n   {\n-    \n-    Component c = ((MenuElement) event.getSource ()).getComponent ();\n-    if (selection.size () == 0)\n-      {\n-        ((MenuElement) event.getSource ()).processMouseEvent (event,\n-                                                              getPath (c),\n-                                                              manager);\n-        return;\n-      }\n+    Component c = ((Component) event.getSource());\n \n-    // find the index of the source component in the current menu hierarchy\n-    int i = 0;\n-    for (i = 0; i < selection.size (); i++)\n-      {\n-        MenuElement me = (MenuElement) selection.get (i);\n-        if (me.getComponent ().equals (c))\n-          break;\n-      }\n+    MenuElement[] path = getPath(c);\n+    ((MenuElement) c).processMouseEvent(event, path, manager);\n+\n+    // forward events to subcomponents \n+    MenuElement[] subComponents = ((MenuElement) c).getSubElements();\n \n-    // Forward event to all subcomponents of the source \n-    Component subComp;\n-    for (int j = i; j < selection.size (); j++)\n+    for (int i = 0; i < subComponents.length; i++)\n       {\n-         subComp = ((MenuElement)selection.get (j)).getComponent ();\n-        ((MenuElement) selection.get (j)).processMouseEvent (event,\n-                                                             getPath (subComp),\n-                                                             manager);\n+\tif (subComponents[i] instanceof JMenuItem)\n+\t  subComponents[i].processMouseEvent(event, path, manager);\n       }\n   }\n \n@@ -203,96 +229,88 @@ public void processMouseEvent (MouseEvent event)\n    *\n    * @param path new selection path\n    */\n-  public void setSelectedPath (MenuElement[] path)\n+  public void setSelectedPath(MenuElement[] path)\n   {\n     if (path == null)\n       {\n-        clearSelectedPath ();\n-        return;\n+\tclearSelectedPath();\n+\treturn;\n       }\n \n+    fireStateChanged();\n+\n     int i;\n     int minSize = path.length; // size of the smaller path. \n \n-    if (path.length > selection.size ())\n+    if (path.length > selectedPath.size())\n       {\n-        // if new selected path contains more elements then current\n-        // selection then first add all elements at \n-        // the indexes > selection.size \n-\t\n-        for (i = selection.size (); i < path.length; i++)\n-          {\n-            selection.add (path[i]);\n-            path[i].menuSelectionChanged (true);\n-          }\n-\n-        minSize = selection.size ();\n+\t// if new selected path contains more elements then current\n+\t// selection then first add all elements at \n+\t// the indexes > selectedPath.size \n+\tfor (i = selectedPath.size(); i < path.length; i++)\n+\t  {\n+\t    selectedPath.add(path[i]);\n+\t    path[i].menuSelectionChanged(true);\n+\t  }\n+\n+\tminSize = selectedPath.size();\n       }\n \n-    else if (path.length < selection.size ())\n+    else if (path.length < selectedPath.size())\n       {\n-        // if new selected path contains less elements then current \n-        // selection then first remove all elements from the selection\n-        // at the indexes > path.length\n-\t\n-        for (i = selection.size () - 1; i >= path.length; i--)\n-          {\n-            ((MenuElement) selection.get (i)).menuSelectionChanged (false);\n-            selection.remove (i);\n-          }\n-\n-        minSize = path.length;\n+\t// if new selected path contains less elements then current \n+\t// selection then first remove all elements from the selection\n+\t// at the indexes > path.length\n+\tfor (i = selectedPath.size() - 1; i >= path.length; i--)\n+\t  {\n+\t    ((MenuElement) selectedPath.get(i)).menuSelectionChanged(false);\n+\t    selectedPath.remove(i);\n+\t  }\n+\n+\tminSize = path.length;\n       }\n \n     // Now compare elements in new and current selection path at the \n     // same location and adjust selection until \n     // same menu elements will be encountered at the\n     // same index in both current and new selection path.\n-    \n-    MenuElement oldSelection;\n+    MenuElement oldSelectedPath;\n \n     for (i = minSize - 1; i >= 0; i--)\n       {\n-        oldSelection = (MenuElement) selection.get (i);\n+\toldSelectedPath = (MenuElement) selectedPath.get(i);\n \n-        if (path[i].equals (oldSelection))\n-          break;\n+\tif (path[i].equals(oldSelectedPath))\n+\t  break;\n \n-        oldSelection.menuSelectionChanged (false);\n-        path[i].menuSelectionChanged (true);\n-        selection.setElementAt (path[i], i);\n+\toldSelectedPath.menuSelectionChanged(false);\n+\tpath[i].menuSelectionChanged(true);\n+\tselectedPath.setElementAt(path[i], i);\n       }\n   }\n \n-\n   /**\n    * Returns path to the specified component\n    *\n    * @param c component for which to find path for\n    *\n    * @return path to the specified component\n    */\n-  private MenuElement[] getPath (Component c)\n+  private MenuElement[] getPath(Component c)\n   {\n-    Vector path = new Vector();\n-    path.add (c);\n-\n-    Component parent = c.getParent ();\n-\n-    while (parent instanceof JMenu \n-           || parent instanceof JPopupMenu \n-           || parent instanceof JMenuItem \n-           || parent instanceof JMenuBar)\n+    ArrayList path = new ArrayList();\n+    while (c instanceof MenuElement)\n       {\n-        path.add (parent);\n-        parent = parent.getParent ();\n-      }\n+\tpath.add(0, (MenuElement) c);\n \n-    MenuElement[] pathArray = new MenuElement[path.size ()];\n+\tif (c instanceof JPopupMenu)\n+\t  c = ((JPopupMenu) c).getInvoker();\n+\telse\n+\t  c = c.getParent();\n+      }\n \n-    for (int i = 0; i < path.size (); i++)\n-      pathArray[i] = (MenuElement) path.get (path.size () - i - 1);\n+    MenuElement[] pathArray = new MenuElement[path.size()];\n+    path.toArray(pathArray);\n     return pathArray;\n   }\n-  \n-} // class MenuSelectionManager\n+}"}, {"sha": "b4e24be013629fb6824ee4fbe6436c95fe5339c3", "filename": "libjava/javax/swing/ScrollPaneConstants.java", "status": "modified", "additions": 108, "deletions": 114, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FScrollPaneConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FScrollPaneConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FScrollPaneConstants.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* ScrollPaneConstants.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,116 +42,110 @@\n  * @author\tAndrew Selkirk\n  * @version\t1.0\n  */\n-public interface ScrollPaneConstants {\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * VIEWPORT\n-\t */\n-\tString VIEWPORT = \"VIEWPORT\";\n-\n-\t/**\n-\t * VERTICAL_SCROLLBAR\n-\t */\n-\tString VERTICAL_SCROLLBAR = \"VERTICAL_SCROLLBAR\";\n-\n-\t/**\n-\t * HORIZONTAL_SCROLLBAR\n-\t */\n-\tString HORIZONTAL_SCROLLBAR = \"HORIZONTAL_SCROLLBAR\";\n-\n-\t/**\n-\t * ROW_HEADER\n-\t */\n-\tString ROW_HEADER = \"ROW_HEADER\";\n-\n-\t/**\n-\t * COLUMN_HEADER\n-\t */\n-\tString COLUMN_HEADER = \"COLUMN_HEADER\";\n-\n-\t/**\n-\t * LOWER_LEFT_CORNER\n-\t */\n-\tString LOWER_LEFT_CORNER = \"LOWER_LEFT_CORNER\";\n-\n-\t/**\n-\t * LOWER_RIGHT_CORNER\n-\t */\n-\tString LOWER_RIGHT_CORNER = \"LOWER_RIGHT_CORNER\";\n-\n-\t/**\n-\t * UPPER_LEFT_CORNER\n-\t */\n-\tString UPPER_LEFT_CORNER = \"UPPER_LEFT_CORNER\";\n-\n-\t/**\n-\t * UPPER_RIGHT_CORNER\n-\t */\n-\tString UPPER_RIGHT_CORNER = \"UPPER_RIGHT_CORNER\";\n-\n-\t/**\n-\t * LOWER_LEADING_CORNER\n-\t */\n-\tString LOWER_LEADING_CORNER = \"LOWER_LEADING_CORNER\";\n-\n-\t/**\n-\t * LOWER_TRAILING_CORNER\n-\t */\n-\tString LOWER_TRAILING_CORNER = \"LOWER_TRAILING_CORNER\";\n-\n-\t/**\n-\t * UPPER_LEADING_CORNER\n-\t */\n-\tString UPPER_LEADING_CORNER = \"UPPER_LEADING_CORNER\";\n-\n-\t/**\n-\t * UPPER_TRAILING_CORNER\n-\t */\n-\tString UPPER_TRAILING_CORNER = \"UPPER_TRAILING_CORNER\";\n-\n-\t/**\n-\t * VERTICAL_SCROLLBAR_POLICY\n-\t */\n-\tString VERTICAL_SCROLLBAR_POLICY = \"VERTICAL_SCROLLBAR_POLICY\";\n-\n-\t/**\n-\t * HORIZONTAL_SCROLLBAR_POLICY\n-\t */\n-\tString HORIZONTAL_SCROLLBAR_POLICY = \"HORIZONTAL_SCROLLBAR_POLICY\";\n-\n-\t/**\n-\t * VERTICAL_SCROLLBAR_AS_NEEDED\n-\t */\n-\tint VERTICAL_SCROLLBAR_AS_NEEDED = 20;\n-\n-\t/**\n-\t * VERTICAL_SCROLLBAR_NEVER\n-\t */\n-\tint VERTICAL_SCROLLBAR_NEVER = 21;\n-\n-\t/**\n-\t * VERTICAL_SCROLLBAR_ALWAYS\n-\t */\n-\tint VERTICAL_SCROLLBAR_ALWAYS = 22;\n-\n-\t/**\n-\t * HORIZONTAL_SCROLLBAR_AS_NEEDED\n-\t */\n-\tint HORIZONTAL_SCROLLBAR_AS_NEEDED = 30;\n-\n-\t/**\n-\t * HORIZONTAL_SCROLLBAR_NEVER\n-\t */\n-\tint HORIZONTAL_SCROLLBAR_NEVER = 31;\n-\n-\t/**\n-\t * HORIZONTAL_SCROLLBAR_ALWAYS\n-\t */\n-\tint HORIZONTAL_SCROLLBAR_ALWAYS = 32;\n-\n-\n-} // ScrollPaneConstants\n+public interface ScrollPaneConstants\n+{\n+  /**\n+   * VIEWPORT\n+   */\n+  String VIEWPORT = \"VIEWPORT\";\n+\n+  /**\n+   * VERTICAL_SCROLLBAR\n+   */\n+  String VERTICAL_SCROLLBAR = \"VERTICAL_SCROLLBAR\";\n+\n+  /**\n+   * HORIZONTAL_SCROLLBAR\n+   */\n+  String HORIZONTAL_SCROLLBAR = \"HORIZONTAL_SCROLLBAR\";\n+\n+  /**\n+   * ROW_HEADER\n+   */\n+  String ROW_HEADER = \"ROW_HEADER\";\n+\n+  /**\n+   * COLUMN_HEADER\n+   */\n+  String COLUMN_HEADER = \"COLUMN_HEADER\";\n+\n+  /**\n+   * LOWER_LEFT_CORNER\n+   */\n+  String LOWER_LEFT_CORNER = \"LOWER_LEFT_CORNER\";\n+\n+  /**\n+   * LOWER_RIGHT_CORNER\n+   */\n+  String LOWER_RIGHT_CORNER = \"LOWER_RIGHT_CORNER\";\n+\n+  /**\n+   * UPPER_LEFT_CORNER\n+   */\n+  String UPPER_LEFT_CORNER = \"UPPER_LEFT_CORNER\";\n+\n+  /**\n+   * UPPER_RIGHT_CORNER\n+   */\n+  String UPPER_RIGHT_CORNER = \"UPPER_RIGHT_CORNER\";\n+\n+  /**\n+   * LOWER_LEADING_CORNER\n+   */\n+  String LOWER_LEADING_CORNER = \"LOWER_LEADING_CORNER\";\n+\n+  /**\n+   * LOWER_TRAILING_CORNER\n+   */\n+  String LOWER_TRAILING_CORNER = \"LOWER_TRAILING_CORNER\";\n+\n+  /**\n+   * UPPER_LEADING_CORNER\n+   */\n+  String UPPER_LEADING_CORNER = \"UPPER_LEADING_CORNER\";\n+\n+  /**\n+   * UPPER_TRAILING_CORNER\n+   */\n+  String UPPER_TRAILING_CORNER = \"UPPER_TRAILING_CORNER\";\n+\n+  /**\n+   * VERTICAL_SCROLLBAR_POLICY\n+   */\n+  String VERTICAL_SCROLLBAR_POLICY = \"VERTICAL_SCROLLBAR_POLICY\";\n+\n+  /**\n+   * HORIZONTAL_SCROLLBAR_POLICY\n+   */\n+  String HORIZONTAL_SCROLLBAR_POLICY = \"HORIZONTAL_SCROLLBAR_POLICY\";\n+\n+  /**\n+   * VERTICAL_SCROLLBAR_AS_NEEDED\n+   */\n+  int VERTICAL_SCROLLBAR_AS_NEEDED = 20;\n+\n+  /**\n+   * VERTICAL_SCROLLBAR_NEVER\n+   */\n+  int VERTICAL_SCROLLBAR_NEVER = 21;\n+\n+  /**\n+   * VERTICAL_SCROLLBAR_ALWAYS\n+   */\n+  int VERTICAL_SCROLLBAR_ALWAYS = 22;\n+\n+  /**\n+   * HORIZONTAL_SCROLLBAR_AS_NEEDED\n+   */\n+  int HORIZONTAL_SCROLLBAR_AS_NEEDED = 30;\n+\n+  /**\n+   * HORIZONTAL_SCROLLBAR_NEVER\n+   */\n+  int HORIZONTAL_SCROLLBAR_NEVER = 31;\n+\n+  /**\n+   * HORIZONTAL_SCROLLBAR_ALWAYS\n+   */\n+  int HORIZONTAL_SCROLLBAR_ALWAYS = 32;\n+}"}, {"sha": "a249c2773404946a4338de9bcebc68069ed99787", "filename": "libjava/javax/swing/ScrollPaneLayout.java", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* ScrollPaneLayout.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -63,28 +63,28 @@ public UIResource() {\n     }\n   }\n \n-  JViewport viewport;\n-  JScrollBar verticalScrollBar;\n-  JScrollBar horizontalScrollBar;\n-  JViewport rowHeader;\n-  JViewport columnHeader;\n-  Component lowerLeft;\n-  Component lowerRight;\n-  Component upperLeft;\n-  Component upperRight;\n-  int verticalScrollBarPolicy;\n-  int horizontalScrollBarPolicy;\n+  protected JViewport viewport;\n+  protected JScrollBar vsb;\n+  protected JScrollBar hsb;\n+  protected JViewport rowHead;\n+  protected JViewport colHead;\n+  protected Component lowerLeft;\n+  protected Component lowerRight;\n+  protected Component upperLeft;\n+  protected Component upperRight;\n+  protected int vsbPolicy;\n+  protected int hsbPolicy;\n \n   public ScrollPaneLayout() {\n \t\t\n   }\n \n   public void syncWithScrollPane(JScrollPane scrollPane) {\n     viewport = scrollPane.getViewport();\n-    verticalScrollBar = scrollPane.getVerticalScrollBar();\n-    horizontalScrollBar = scrollPane.getHorizontalScrollBar();\n-    verticalScrollBarPolicy = scrollPane.getVerticalScrollBarPolicy();\n-    horizontalScrollBarPolicy = scrollPane.getHorizontalScrollBarPolicy();\n+    vsb = scrollPane.getVerticalScrollBar();\n+    hsb = scrollPane.getHorizontalScrollBar();\n+    vsbPolicy = scrollPane.getVerticalScrollBarPolicy();\n+    hsbPolicy = scrollPane.getHorizontalScrollBarPolicy();\n     lowerLeft = scrollPane.getCorner(LOWER_LEFT_CORNER);\n     lowerRight = scrollPane.getCorner(LOWER_RIGHT_CORNER);\n     upperLeft = scrollPane.getCorner(UPPER_LEFT_CORNER);\n@@ -101,13 +101,13 @@ public void addLayoutComponent(String key, Component component)\n     if (key == VIEWPORT)\n       viewport = (JViewport) component;\n     else if (key == VERTICAL_SCROLLBAR)\n-      verticalScrollBar = (JScrollBar) component;\n+      vsb = (JScrollBar) component;\n     else if (key == HORIZONTAL_SCROLLBAR)\n-      horizontalScrollBar = (JScrollBar) component;\n+      hsb = (JScrollBar) component;\n     else if (key == ROW_HEADER)\n-      rowHeader = (JViewport) component;\n+      rowHead = (JViewport) component;\n     else if (key == COLUMN_HEADER)\n-      columnHeader = (JViewport) component;\n+      colHead = (JViewport) component;\n     else if (key == LOWER_RIGHT_CORNER)\n       lowerRight = component;\n     else if (key == UPPER_RIGHT_CORNER)\n@@ -121,14 +121,14 @@ else if (key == UPPER_LEFT_CORNER)\n   public void removeLayoutComponent(Component component) {\n     if (component == viewport)\n       viewport = null;\n-    else if (component == verticalScrollBar)\n-      verticalScrollBar = null;\n-    else if (component == horizontalScrollBar)\n-      horizontalScrollBar = null;\n-    else if (component == rowHeader)\n-      rowHeader = null;\n-    else if (component == columnHeader)\n-      columnHeader = null;\n+    else if (component == vsb)\n+      vsb = null;\n+    else if (component == hsb)\n+      hsb = null;\n+    else if (component == rowHead)\n+      rowHead = null;\n+    else if (component == colHead)\n+      colHead = null;\n     else if (component == lowerRight)\n       lowerRight = null;\n     else if (component == upperRight)\n@@ -139,43 +139,53 @@ else if (component == upperLeft)\n       upperLeft = null;\n   }\n \n-  public int getVerticalScrollBarPolicy() {\n-    return verticalScrollBarPolicy;\n+  public int getVerticalScrollBarPolicy()\n+  {\n+    return vsbPolicy;\n   }\n \n-  public void setVerticalScrollBarPolicy(int policy) {\n-    verticalScrollBarPolicy = policy;\n+  public void setVerticalScrollBarPolicy(int policy)\n+  {\n+    vsbPolicy = policy;\n   }\n \n-  public int getHorizontalScrollBarPolicy() {\n-    return horizontalScrollBarPolicy;\n+  public int getHorizontalScrollBarPolicy()\n+  {\n+    return hsbPolicy;\n   }\n \n-  public void setHorizontalScrollBarPolicy(int policy) {\n-    horizontalScrollBarPolicy = policy;\n+  public void setHorizontalScrollBarPolicy(int policy)\n+  {\n+    hsbPolicy = policy;\n   }\n \n-  public JViewport getViewport() {\n+  public JViewport getViewport()\n+  {\n     return viewport;\n   }\n \n-  public JScrollBar getHorizontalScrollBar() {\n-    return horizontalScrollBar;\n+  public JScrollBar getHorizontalScrollBar()\n+  {\n+    return hsb;\n   }\n \n-  public JScrollBar getVerticalScrollBar() {\n-    return verticalScrollBar;\n+  public JScrollBar getVerticalScrollBar()\n+  {\n+    return vsb;\n   }\n \n-  public JViewport getRowHeader() {\n-    return rowHeader;\n+  public JViewport getRowHeader()\n+  {\n+    return rowHead;\n   }\n \n-  public JViewport getColumnHeader() {\n-    return columnHeader;\n+  public JViewport getColumnHeader()\n+  {\n+    return colHead;\n   }\n \n-  public Component getCorner(String key) {\n+  public Component getCorner(String key)\n+  {\n     if (key == LOWER_RIGHT_CORNER)\n       return lowerRight;\n     else if (key == UPPER_RIGHT_CORNER)\n@@ -216,17 +226,17 @@ public Dimension preferredLayoutSize(Container parent)\n             if (viewport != null)\n               viewportSize.setSize(viewport.getPreferredSize());\n \n-            if (columnHeader != null)\n-              columnHeaderSize.setSize(columnHeader.getPreferredSize());\n+            if (colHead != null)\n+              columnHeaderSize.setSize(colHead.getPreferredSize());\n             \n-            if (rowHeader != null)\n-              rowHeaderSize.setSize(rowHeader.getPreferredSize());\n+            if (rowHead != null)\n+              rowHeaderSize.setSize(rowHead.getPreferredSize());\n \n-            if (verticalScrollBar != null)\n-              verticalScrollBarSize.setSize(verticalScrollBar.getPreferredSize());\n+            if (vsb != null)\n+              verticalScrollBarSize.setSize(vsb.getPreferredSize());\n \n-            if (horizontalScrollBar != null)\n-              horizontalScrollBarSize.setSize(horizontalScrollBar.getPreferredSize());\n+            if (hsb != null)\n+              horizontalScrollBarSize.setSize(hsb.getPreferredSize());\n \n             /*\n             System.err.println(\"widths: [vp=\" + viewportSize.width +\n@@ -285,19 +295,19 @@ public Dimension minimumLayoutSize(Container parent)\n             if (viewport != null)\n               viewportSize.setSize(viewport.getMinimumSize());\n \n-            if (columnHeader != null)\n-              columnHeaderSize.setSize(columnHeader.getMinimumSize());\n+            if (colHead != null)\n+              columnHeaderSize.setSize(colHead.getMinimumSize());\n             \n-            if (rowHeader != null)\n-              rowHeaderSize.setSize(rowHeader.getMinimumSize());\n+            if (rowHead != null)\n+              rowHeaderSize.setSize(rowHead.getMinimumSize());\n \n-            if (verticalScrollBar != null\n-                && verticalScrollBarPolicy != VERTICAL_SCROLLBAR_NEVER)\n-              verticalScrollBarSize.setSize(verticalScrollBar.getMinimumSize());\n+            if (vsb != null\n+                && vsbPolicy != VERTICAL_SCROLLBAR_NEVER)\n+              verticalScrollBarSize.setSize(vsb.getMinimumSize());\n \n-            if (horizontalScrollBar != null \n-                && horizontalScrollBarPolicy != HORIZONTAL_SCROLLBAR_NEVER)\n-              horizontalScrollBarSize.setSize(horizontalScrollBar.getMinimumSize());\n+            if (hsb != null \n+                && hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)\n+              horizontalScrollBarSize.setSize(hsb.getMinimumSize());\n             \n             return new Dimension(insetsSize.width \n                                  + viewportSize.width\n@@ -338,8 +348,8 @@ public Dimension minimumLayoutSize(Container parent)\n    *    x1   x2                   x3   x4\n    *   \n    */\n-\n-  public void layoutContainer(Container parent) {\n+  public void layoutContainer(Container parent)\n+  {\n     if (parent instanceof JScrollPane)\n       {\n         JScrollPane sc = (JScrollPane) parent;\n@@ -358,38 +368,38 @@ public void layoutContainer(Container parent) {\n             x4 = scrollPaneBounds.x + scrollPaneBounds.width;\n             y4 = scrollPaneBounds.y + scrollPaneBounds.height;\n             \n-            if (columnHeader != null)\n-              y2 = columnHeader.getPreferredSize().height;\n+            if (colHead != null)\n+              y2 = colHead.getPreferredSize().height;\n             else\n               y2 = y1;\n \n-            if (rowHeader != null)\n-              x2 = rowHeader.getPreferredSize().width;\n+            if (rowHead != null)\n+              x2 = rowHead.getPreferredSize().width;\n             else\n               x2 = x1;\n \n             int vsbPolicy = sc.getVerticalScrollBarPolicy();\n             int hsbPolicy = sc.getHorizontalScrollBarPolicy();\n \n             boolean showVsb = \n-              (verticalScrollBar != null)\n+              (vsb != null)\n               && ((vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS)\n                   || (vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED \n                       && viewSize.height > viewportSize.height));\n \n             boolean showHsb = \n-              (horizontalScrollBar != null)\n+              (hsb != null)\n               && ((hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS)\n                   || (hsbPolicy == HORIZONTAL_SCROLLBAR_AS_NEEDED \n                       && viewSize.width > viewportSize.width));\n             \n             if (showVsb)\n-              x3 = x4 - verticalScrollBar.getPreferredSize().width;\n+              x3 = x4 - vsb.getPreferredSize().width;\n             else\n               x3 = x4;\n \n             if (showHsb)\n-              y3 = y4 - horizontalScrollBar.getPreferredSize().height;\n+              y3 = y4 - hsb.getPreferredSize().height;\n             else\n               y3 = y4;\n \n@@ -398,17 +408,17 @@ public void layoutContainer(Container parent) {\n             if (viewport != null)\n               viewport.setBounds(new Rectangle(x2, y2, x3-x2, y3-y2));\n \n-            if (columnHeader != null)\n-              columnHeader.setBounds(new Rectangle(x2, y1, x3-x2, y2-y1));\n+            if (colHead != null)\n+              colHead.setBounds(new Rectangle(x2, y1, x3-x2, y2-y1));\n \n-            if (rowHeader != null)\n-              rowHeader.setBounds(new Rectangle(x1, y2, x2-x1, y3-y2));\n+            if (rowHead != null)\n+              rowHead.setBounds(new Rectangle(x1, y2, x2-x1, y3-y2));\n \n             if (showVsb)\n-                verticalScrollBar.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n+\t      vsb.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n \n             if (showHsb)\n-              horizontalScrollBar.setBounds(new Rectangle(x2, y3, x3-x2, y4-y3));\n+              hsb.setBounds(new Rectangle(x2, y3, x3-x2, y4-y3));\n \n             if (upperLeft != null)\n               upperLeft.setBounds(new Rectangle(x1, y1, x2-x1, y2-y1));"}, {"sha": "7162edbd75f1e78df6e30cf7ecb77a5dbfe963d9", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -51,6 +51,7 @@\n import java.awt.Shape;\n import java.awt.Toolkit;\n import java.awt.Window;\n+import java.awt.event.InputEvent;\n import java.awt.event.MouseEvent;\n import java.lang.reflect.InvocationTargetException;\n \n@@ -375,8 +376,12 @@ public static Point convertPoint(Component source, int x, int y,\n \n     return pt;\n   }\n-\n   \n+  public static Point convertPoint(Component source, Point aPoint, Component destination)\n+  {\n+    return convertPoint(source, aPoint.x, aPoint.y, destination);\n+  }\n+\n   /**\n    * Converts a rectangle from the coordinate space of one component to\n    * another. This is equivalent to converting the rectangle from\n@@ -718,7 +723,6 @@ public static String layoutCompoundLabel(FontMetrics fm,\n         iconR.y = centerLine - iconR.height/2;\n         break;\n       }\n-\n     // The two rectangles are laid out correctly now, but only assuming\n     // that their upper left corner is at (0,0). If we have any alignment other\n     // than TOP and LEFT, we need to adjust them.\n@@ -845,6 +849,43 @@ static Frame getOwnerFrame()\n       ownerFrame = new Frame();\n     return ownerFrame;\n   }\n-  \n \n+  /**\n+   * Checks if left mouse button was clicked.\n+   *\n+   * @param event the event to check\n+   *\n+   * @return true if left mouse was clicked, false otherwise.\n+   */\n+  public static boolean isLeftMouseButton(MouseEvent event)\n+  {\n+    return ((event.getModifiers() & InputEvent.BUTTON1_DOWN_MASK)\n+\t     == InputEvent.BUTTON1_DOWN_MASK);\n+  }\n+\n+  /**\n+   * Checks if middle mouse button was clicked.\n+   *\n+   * @param event the event to check\n+   *\n+   * @return true if middle mouse was clicked, false otherwise.\n+   */\n+  public static boolean isMiddleMouseButton(MouseEvent event)\n+  {\n+    return ((event.getModifiers() & InputEvent.BUTTON2_DOWN_MASK)\n+\t     == InputEvent.BUTTON2_DOWN_MASK);\n+  }\n+\n+  /**\n+   * Checks if right mouse button was clicked.\n+   *\n+   * @param event the event to check\n+   *\n+   * @return true if right mouse was clicked, false otherwise.\n+   */\n+  public static boolean isRightMouseButton(MouseEvent event)\n+  {\n+    return ((event.getModifiers() & InputEvent.BUTTON3_DOWN_MASK)\n+\t     == InputEvent.BUTTON3_DOWN_MASK);\n+  }\n }"}, {"sha": "57a412a1910ad776d1b973902264b75afef2dd7c", "filename": "libjava/javax/swing/Timer.java", "status": "modified", "additions": 120, "deletions": 38, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FTimer.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -47,44 +47,107 @@\n \n public class Timer implements Serializable\n {\n+  private static final long serialVersionUID = -1116180831621385484L;\n+  \n   protected EventListenerList listenerList = new EventListenerList();\n   \n-  int ticks;\n-  static boolean verbose;\n+  // This object manages a \"queue\" of virtual actionEvents, maintained as a\n+  // simple long counter. When the timer expires, a new event is queued,\n+  // and a dispatcher object is pushed into the system event queue. When\n+  // the system thread runs the dispatcher, it will fire as many\n+  // ActionEvents as have been queued, unless the timer is set to\n+  // coalescing mode, in which case it will fire only one ActionEvent.\n+\n+  private long queue;\n+  private Object queueLock = new Object();\n+  private void queueEvent()\n+  {\n+    synchronized (queueLock)\n+      {\n+        queue++;\n+        if (queue == 1)\n+          SwingUtilities.invokeLater(new Runnable() { public void run() { drainEvents(); } });\n+      }\n+  }\n+\n+  private void drainEvents()\n+  {\n+    synchronized (queueLock)\n+      {\n+        if (isCoalesce())\n+          {\n+            if (queue > 0)\n+              fireActionPerformed();\n+          }\n+        else\n+          {\n+            while(queue > 0)\n+              {                  \n+                fireActionPerformed();\n+                queue--;\n+              }          \n+          }\n+        queue = 0;\n+      }\n+  }\n+  \n+\n+  static boolean logTimers;\n+  boolean coalesce = true;\n+  boolean repeats = true;\n   boolean running;\n-  boolean repeat_ticks = true;\n-  long interval, init_delay;\n+  int ticks;\n+  int delay;\n+  int initialDelay;\n     \n-  class Waker extends Thread\n+  private class Waker \n+    extends Thread\n   {\n     public void run()\n     {\n       running = true;\n-      try {\n-\tsleep(init_delay);\n-\t\t\n-\twhile (running)\n-\t  {\n-\t    sleep(interval);\n-\n-\t    if (verbose)\n-\t      {\n-\t\tSystem.out.println(\"javax.swing.Timer -> clocktick\");\n-\t      }\n-\n-\t    ticks++;\n-\t    fireActionPerformed();\n-  \n-\t    if (! repeat_ticks)\n-\t      break;\n-\t  }\n-\trunning = false;\n-      } catch (Exception e) {\n-\tSystem.out.println(\"swing.Timer::\" + e);\n-      }\n+      try \n+        {\n+\n+          sleep(initialDelay);\n+          \n+          while (running)\n+            {\n+              sleep(delay);\n+              \n+              if (logTimers)\n+                System.out.println(\"javax.swing.Timer -> clocktick\");\n+              \n+              if (! repeats)\n+                break;\n+            }\n+          running = false;\n+      } \n+      catch (Exception e) \n+        {\n+          System.out.println(\"swing.Timer::\" + e);\n+        }\n     }\n   }\n \n+  public Timer(int d, ActionListener listener)\n+  {\n+    delay = d;\n+\n+    if (listener != null)\n+      addActionListener(listener);\n+  }\n+\n+  public void setCoalesce(boolean c)\n+  {\n+    coalesce = c;\n+  }\n+\n+  public boolean isCoalesce()\n+  {\n+    return coalesce;\n+  }\n+\n   public void addActionListener(ActionListener listener)\n   {\n     listenerList.add (ActionListener.class, listener);\n@@ -123,37 +186,47 @@ protected void fireActionPerformed (ActionEvent event)\n \n   void fireActionPerformed ()\n   {\n-    fireActionPerformed (new ActionEvent (this, ticks, \"Timer\"));\n+    fireActionPerformed (new ActionEvent (this, ticks++, \"Timer\"));\n   }\n \n-  public static void setLogTimers(boolean flag)\n+  public static void setLogTimers(boolean lt)\n   {\n-    verbose = flag;\n+    logTimers = lt;\n   }\n \n   public static boolean getLogTimers()\n   {\n-    return verbose;\n+    return logTimers;\n   }\n     \n-  public void setDelay(int delay)\n+  public void setDelay(int d)\n   {\n-    interval = delay;\n+    delay = d;\n   }\n \n   public int getDelay()\n   {\n-    return (int)interval;\n+    return delay;\n   }\n \n-  public void setInitialDelay(int initialDelay)\n+  public void setInitialDelay(int i)\n   {\n-    init_delay = initialDelay;\n+    initialDelay = i;\n   }\n \n-  public void setRepeats(boolean flag)\n+  public int getInitialDelay()\n   {\n-    repeat_ticks = flag;\n+    return initialDelay;\n+  }\n+\n+  public void setRepeats(boolean r)\n+  {\n+    repeats = r;\n+  }\n+\n+  public boolean isRepeats()\n+  {\n+    return repeats;\n   }\n \n   public boolean isRunning()\n@@ -171,6 +244,15 @@ public void start()\n     new Waker().start();\n   }\n \n+  public void restart()\n+  {\n+    synchronized (queueLock)\n+      {\n+        queue = 0;\n+      }\n+    start();\n+  }\n+\n   public void stop()\n   {\n     running = false;"}, {"sha": "d419c497956cda46f81729bd1013c909fc7e564f", "filename": "libjava/javax/swing/ViewportLayout.java", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FViewportLayout.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -71,7 +71,6 @@ public Dimension preferredLayoutSize(Container parent)\n       {\n         Scrollable sc = (Scrollable) view;\n         Dimension d = sc.getPreferredScrollableViewportSize();\n-        // System.err.println(this + \".preferredLayoutSize() : scrollable -> \" + d);\n         return d;\n       }\n     else\n@@ -83,20 +82,84 @@ public Dimension minimumLayoutSize(Container parent)\n     Component view = vp.getView();\n     return view.getMinimumSize();\n   }\n+\n+  /**\n+   * Layout the view and viewport to respect the following rules. These are\n+   * not precisely the rules described in sun's javadocs, but they are the\n+   * rules which sun's swing implementation follows, if you watch its\n+   * behavior:\n+   *\n+   * <ol> \n+   * \n+   * <li>If the port is larger than the view's minimum size, put the port\n+   * at view position <code>(0,0)</code> and make the view's size equal to\n+   * the port's.</li>\n+   *\n+   * <li>If the port is smaller than the view, leave the view at its\n+   * minimum size. also, do not move the port, <em>unless</em> the port\n+   * extends into space <em>past</em> the edge of the view. If so, move the\n+   * port up or to the left, in view space, by the amount of empty space\n+   * (keep the lower and right edges lined up)</li>\n+   *\n+   * </ol>\n+   *\n+   * @see JViewport#getViewSize\n+   * @see JViewport#setViewSize\n+   * @see JViewport#getViewPosition\n+   * @see JViewport#setViewPosition\n+   */\n+\n   public void layoutContainer(Container parent) \n   {\n-    JViewport vp = (JViewport)parent;\n-    Component view = vp.getView();\n-    Rectangle portBounds = vp.getBounds();\n+    // The way to interpret this function is basically to ignore the names\n+    // of methods it calls, and focus on the variable names here. getViewRect\n+    // doesn't, for example, return the view; it returns the port bounds in\n+    // view space. Likwise setViewPosition doesn't reposition the view; it \n+    // positions the port, in view coordinates.\n+\n+    JViewport port = (JViewport) parent;    \n+    Component view = port.getView();\n+\n+    // These dimensions and positions are in *view space*.  Do not mix\n+    // variables in here from port space (eg. parent.getBounds()). This\n+    // function should be entirely in view space, because the methods on\n+    // the viewport require inputs in view space.\n+\n+    Rectangle portBounds = port.getViewRect();\n+    Dimension viewSize = port.getViewSize();\n     Dimension viewMinimum = view.getMinimumSize();\n-    int width = Math.max(portBounds.width, \n-                         viewMinimum.width);\n-    int height = Math.max(portBounds.height, \n-                          viewMinimum.height);\n-    int x = Math.min(0, portBounds.width - width);\n-    int y = Math.min(0, portBounds.height - height);\n-    // System.err.println(this + \".layoutContainer() : width = \" + width + \", height = \" + height);\n-    vp.setViewPosition(new Point(x, y));\n-    vp.setViewSize(new Dimension(width, height));\n+    Point portLowerRight = new Point(portBounds.x + portBounds.width,\n+                                     portBounds.y + portBounds.height);\n+        \n+    // vertical implementation of the above rules\n+    if (portBounds.height >= viewMinimum.height)\n+      {\n+        portBounds.y = 0;\n+        viewSize.height = portBounds.height;\n+      }\n+    else\n+      {\n+        viewSize.height = viewMinimum.height;\n+        int overextension = portLowerRight.y - viewSize.height;\n+        if (overextension > 0)\n+            portBounds.y -= overextension;\n+      }\n+\n+    // horizontal implementation of the above rules\n+    if (portBounds.width >= viewMinimum.width)\n+      {\n+        portBounds.x = 0;\n+        viewSize.width = portBounds.width;\n+      }\n+    else\n+      {\n+        viewSize.width = viewMinimum.width;\n+        int overextension = portLowerRight.x - viewSize.width;\n+        if (overextension > 0)\n+            portBounds.x -= overextension;\n+      }\n+\n+    port.setViewPosition(portBounds.getLocation());\n+    port.setViewSize(viewSize);\n   }\n }"}, {"sha": "eccc9d3e576628faa6b8382623bb2e537e538d6e", "filename": "libjava/javax/swing/event/DocumentEvent.java", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fevent%2FDocumentEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fevent%2FDocumentEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FDocumentEvent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -87,68 +87,49 @@ public interface ElementChange {\n \n \t} // ElementChange\n \n-\t/**\n-\t * EventType\n-\t */\n-\tclass EventType {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * INSERT\n-\t\t */\n-\t\tEventType INSERT = new EventType(\"INSERT\"); // TODO\n-\n-\t\t/**\n-\t\t * REMOVE\n-\t\t */\n-\t\tEventType REMOVE = new EventType(\"REMOVE\"); // TODO\n-\n-\t\t/**\n-\t\t * CHANGE\n-\t\t */\n-\t\tEventType CHANGE = new EventType(\"CHANGE\"); // TODO\n-\n-\t\t/**\n-\t\t * typeString\n-\t\t */\n-\t\tprivate String type;\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor EventType\n-\t\t * @param type TODO\n-\t\t */\n-\t\tprivate EventType(String type) {\n-\t\t\tthis.type = type;\n-\t\t} // EventType()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * toString\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String toString() {\n-\t\t\treturn type; // TODO\n-\t\t} // toString()\n-\n-\n-\t} // EventType\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  /**\n+   * EventType\n+   */\n+  class EventType\n+  {\n+    /**\n+     * INSERT\n+     */\n+    public static final EventType INSERT = new EventType(\"INSERT\"); // TODO\n+\n+    /**\n+     * REMOVE\n+     */\n+    public static final EventType REMOVE = new EventType(\"REMOVE\"); // TODO\n+\n+    /**\n+     * CHANGE\n+     */\n+    public static final EventType CHANGE = new EventType(\"CHANGE\"); // TODO\n+\n+    /**\n+     * typeString\n+     */\n+    private String type;\n+\n+    /**\n+     * Constructor EventType\n+     * @param type TODO\n+     */\n+    private EventType(String type)\n+    {\n+      this.type = type;\n+    }\n+\n+    /**\n+     * toString\n+     * @returns String\n+     */\n+    public String toString()\n+    {\n+      return type;\n+    }\n+  }\n \n \t/**\n \t * getType"}, {"sha": "9031afe621e7006f7e2cb97e154117a3d3cf49f7", "filename": "libjava/javax/swing/event/UndoableEditListener.java", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fevent%2FUndoableEditListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fevent%2FUndoableEditListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FUndoableEditListener.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n /* UndoableEditListener.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,21 +37,20 @@\n \n package javax.swing.event;\n \n-// Imports\n import java.util.EventListener;\n \n+\n /**\n  * UndoableEditListener public interface\n  * @author Andrew Selkirk\n  * @author Ronald Veldema\n  */\n-public interface UndoableEditListener extends EventListener {\n-\n-\t/**\n-\t * Undoable edit has happened\n-\t * @param event Undoable Edit Event\n-\t */\n-\tvoid undoableEditHappened(UndoableEditEvent event);\n-\n-\n-} // UndoableEditListener\n+public interface UndoableEditListener extends EventListener\n+{\n+  /**\n+   * Undoable edit has happened\n+   *\n+   * @param event Undoable Edit Event\n+   */\n+  void undoableEditHappened(UndoableEditEvent event);\n+}"}, {"sha": "c9ed01116442cb2e8fc84229ccbb7ab437cda963", "filename": "libjava/javax/swing/plaf/BorderUIResource.java", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -270,6 +270,8 @@ public static class BevelBorderUIResource\n     extends BevelBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = -1275542891108351642L;\n+    \n     /**\n      * Constructs a BevelBorderUIResource whose colors will be derived\n      * from the background of the enclosed component. The background\n@@ -399,6 +401,8 @@ public BevelBorderUIResource(int bevelType,\n     extends CompoundBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = 7550017084975167341L;\n+    \n     /**\n      * Constructs a CompoundBorderUIResource with the specified inside\n      * and outside borders.\n@@ -441,6 +445,8 @@ public static class EmptyBorderUIResource\n     extends EmptyBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = -4914187529340071708L;\n+    \n     /**\n      * Constructs an empty border given the number of pixels required\n      * on each side.\n@@ -496,6 +502,8 @@ public EmptyBorderUIResource(Insets insets)\n     extends EtchedBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = -8186391754165296656L;\n+    \n     /**\n      * Constructs an EtchedBorderUIResource that appears lowered into\n      * the surface. The colors will be derived from the background\n@@ -597,6 +605,8 @@ public EtchedBorderUIResource(int etchType,\n     extends LineBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = -6171232338180172310L;\n+    \n     /**\n      * Constructs a LineBorderUIResource given its color.  The border\n      * will be one pixel thick and have plain corners.\n@@ -652,6 +662,8 @@ public LineBorderUIResource(Color color, int thickness)\n     extends MatteBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = -8107923147541851122L;\n+    \n     /**\n      * Constructs a MatteBorderUIResource given the width on each side\n      * and a fill color.\n@@ -731,6 +743,8 @@ public MatteBorderUIResource(Icon tileIcon)\n     extends TitledBorder\n     implements UIResource, Serializable\n   {\n+    private static final long serialVersionUID = 7667113547406407427L;\n+    \n     /**\n      * Constructs a TitledBorderUIResource given the text of its title.\n      *"}, {"sha": "b766d387db90a0706ab9c33596ed5bae5630fcb4", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -304,11 +304,7 @@ protected void paintIcon(Graphics g, JComponent c, Rectangle iconRect)\n     Icon i = currentIcon(b);\n \n     if (i != null)\n-      {\n-        int x = iconRect.x;\n-        int y = iconRect.y;\n-        i.paintIcon(c, g, x, y);\n-      }\n+      i.paintIcon(c, g, iconRect.x, iconRect.y);\n   }\n \n   /**\n@@ -340,7 +336,7 @@ protected void paintButtonPressed(Graphics g, Rectangle area, JComponent b)\n    */\n   protected void paintButtonNormal(Graphics g, Rectangle area, JComponent b)\n   {\n-    if (((AbstractButton)b).isContentAreaFilled())\n+    if (((AbstractButton)b).isContentAreaFilled() && b.isOpaque())\n       {\n         g.setColor(b.getBackground());\n         g.fillRect(area.x, area.y, area.width, area.height);\n@@ -362,9 +358,18 @@ protected void paintText(Graphics g, JComponent c, Rectangle textRect,\n     Font f = c.getFont();\n     g.setFont(f);\n     FontMetrics fm = g.getFontMetrics(f);\n-    g.setColor(c.getForeground());\n-    BasicGraphicsUtils.drawString(g, text, 0,\n-                                  textRect.x, \n-                                  textRect.y + fm.getAscent());\n+\n+    if (c.isEnabled())\n+      {\n+\tg.setColor(c.getForeground());\n+\tg.drawString(text, textRect.x, textRect.y + fm.getAscent());\n+      }\n+    else\n+      {\n+\tg.setColor(c.getBackground().brighter());\n+\tg.drawString(text, textRect.x, textRect.y + fm.getAscent());\n+\tg.setColor(c.getBackground().darker());\n+\tg.drawString(text, textRect.x + 1, textRect.y + fm.getAscent() + 1);\n+      }\n   } \n }"}, {"sha": "b37c2f1e8394ac32db08ac9533f1f4ebb7f6c71d", "filename": "libjava/javax/swing/plaf/basic/BasicDesktopIconUI.java", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopIconUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopIconUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopIconUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -0,0 +1,589 @@\n+/* BasicDesktopIconUI.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyVetoException;\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JInternalFrame.JDesktopIcon;\n+import javax.swing.SwingConstants;\n+import javax.swing.border.Border;\n+import javax.swing.event.MouseInputAdapter;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.DesktopIconUI;\n+import javax.swing.plaf.DesktopPaneUI;\n+\n+\n+/**\n+ * This class acts as the UI delegate for JDesktopIcons for the Basic look and feel.\n+ */\n+public class BasicDesktopIconUI extends DesktopIconUI\n+{\n+  /**\n+   * This helper class handles mouse events that occur on the JDesktopIcon.\n+   */\n+  public class MouseInputHandler extends MouseInputAdapter\n+  {\n+    /** The x offset from the MouseEvent coordinates to the top left corner. */\n+    private transient int xOffset;\n+\n+    /** The y offset fromt he MouseEvent coordinates to the top left corner. */\n+    private transient int yOffset;\n+\n+    /** A cached value of the JDesktopPane that parents this JDesktopIcon. */\n+    private transient JDesktopPane pane;\n+\n+    /**\n+     * This method is called when the mouse is dragged in the JDesktopIcon.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      Rectangle b = desktopIcon.getBounds();\n+\n+      moveAndRepaint(desktopIcon, b.x + e.getX() - xOffset,\n+                     b.y + e.getY() - yOffset, b.width, b.height);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is moved in the JDesktopIcon.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // Nothing to do.\n+    }\n+\n+    /**\n+     * This method is called when the mouse is pressed in the JDesktopIcon.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      xOffset = e.getX();\n+      yOffset = e.getY();\n+      pane = frame.getDesktopPane();\n+      if (pane != null)\n+\tpane.getDesktopManager().beginDraggingFrame(desktopIcon);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is released in the JDesktopIcon.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      if (pane != null)\n+\tpane.getDesktopManager().endDraggingFrame(desktopIcon);\n+      xOffset = 0;\n+      yOffset = 0;\n+    }\n+\n+    /**\n+     * This method moves and repaints the JDesktopIcon to the given bounds.\n+     *\n+     * @param f The JComponent to move and repaint.\n+     * @param newX The new x coordinate.\n+     * @param newY The new y coordinate.\n+     * @param newWidth The new width.\n+     * @param newHeight The new height.\n+     */\n+    public void moveAndRepaint(JComponent f, int newX, int newY, int newWidth,\n+                               int newHeight)\n+    {\n+      if (pane != null)\n+\tpane.getDesktopManager().dragFrame(f, newX, newY);\n+      else\n+\tdesktopIcon.setBounds(newX, newY, newWidth, newHeight);\n+    }\n+  }\n+\n+  /**\n+   * This class acts as the border for the JDesktopIcon.\n+   */\n+  private class DesktopIconBorder implements Border\n+  {\n+    /** The left inset value. */\n+    int left = 10;\n+\n+    /** The top inset value. */\n+    int top = 4;\n+\n+    /** The right inset value. */\n+    int right = top;\n+\n+    /** The bottom inset value. */\n+    int bottom = top;\n+\n+    /**\n+     * This method returns the insets of the border.\n+     *\n+     * @param c The Component to find border insets for.\n+     *\n+     * @return The border insets.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(top, left, bottom, right);\n+    }\n+\n+    /**\n+     * This method returns whether the border is opaque.\n+     *\n+     * @return Whether the border is opaque.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      return true;\n+    }\n+\n+    /**\n+     * This method paints the border.\n+     *\n+     * @param c The Component the border is in.\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate of the Component.\n+     * @param y The y coordinate of the Component.\n+     * @param width The width of the Component.\n+     * @param height The height of the Component.\n+     */\n+    public void paintBorder(Component c, Graphics g, int x, int y, int width,\n+                            int height)\n+    {\n+      g.translate(x, y);\n+      Color saved = g.getColor();\n+\n+      g.setColor(Color.LIGHT_GRAY);\n+\n+      g.fillRect(0, 0, left, height);\n+      g.fillRect(0, 0, width, top);\n+      g.fillRect(0, height - bottom, width, bottom);\n+      g.fillRect(width - right, 0, right, height);\n+\n+      g.setColor(Color.BLACK);\n+      g.drawRect(0, 0, width - 1, height - 1);\n+\n+      int fHeight = height / 4;\n+      int hLeft = left / 2;\n+\n+      g.setColor(Color.BLACK);\n+      g.fillRect(hLeft, fHeight, 2, 2);\n+      g.fillRect(hLeft, fHeight * 2, 2, 2);\n+      g.fillRect(hLeft, fHeight * 3, 2, 2);\n+\n+      g.setColor(saved);\n+      g.translate(-x, -y);\n+    }\n+  }\n+\n+  /** The static width and height of the iconSize. */\n+  private static final int iconSize = 16;\n+\n+  /**\n+   * This class represents the default frame icon when none\n+   * is supplied by the JInternalFrame.\n+   */\n+  static class InternalFrameDefaultMenuIcon implements Icon\n+  {\n+    /**\n+     * This returns the icon height.\n+     *\n+     * @return The icon height.\n+     */\n+    public int getIconHeight()\n+    {\n+      return iconSize;\n+    }\n+\n+    /**\n+     * This returns the icon width.\n+     *\n+     * @return The icon width.\n+     */\n+    public int getIconWidth()\n+    {\n+      return iconSize;\n+    }\n+\n+    /**\n+     * This method paints the icon.\n+     *\n+     * @param c The Component this icon belongs to.\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate to paint at.\n+     * @param y The y coordinate to paint at.\n+     */\n+    public void paintIcon(Component c, Graphics g, int x, int y)\n+    {\n+      g.translate(x, y);\n+      Color saved = g.getColor();\n+\n+      g.setColor(Color.BLUE);\n+      g.fillRect(0, 0, iconSize, (int) ((double) iconSize / 3) + 1);\n+\n+      g.setColor(Color.WHITE);\n+      g.fillRect(0, (int) ((double) iconSize / 3), iconSize, iconSize * 5 / 6);\n+\n+      g.setColor(Color.GRAY);\n+      g.drawRect(0, 0, iconSize, iconSize);\n+\n+      g.setColor(saved);\n+      g.translate(-x, -y);\n+    }\n+  }\n+\n+  /** The default JDesktopIcon width. */\n+  private static final int iconWidth = 160;\n+\n+  /** The default JDesktopIcon height */\n+  private static final int iconHeight = 35;\n+\n+  /** The JDesktopIcon this UI delegate represents. */\n+  protected JDesktopIcon desktopIcon;\n+\n+  /** The JInternalFrame associated with the JDesktopIcon. */\n+  protected JInternalFrame frame;\n+\n+  /** The MouseListener responsible for reacting to MouseEvents on the JDesktopIcon. */\n+  private transient MouseInputListener mouseHandler;\n+\n+  /** The Button in the JDesktopIcon responsible for deiconifying it. */\n+  private transient BoundButton button;\n+\n+  /** The PropertyChangeListener listening to the JDesktopIcon. */\n+  private transient PropertyChangeListener propertyHandler;\n+  \n+  /** The default icon used when no frame icon is given by the JInternalFrame. */\n+  static Icon defaultIcon = new InternalFrameDefaultMenuIcon();\n+\n+  /**\n+   * This is a helper class that is used in JDesktopIcon and gives the Button a predetermined size.\n+   */\n+  private class BoundButton extends JButton\n+  {\n+    /**\n+     * Creates a new BoundButton object.\n+     *\n+     * @param title The title of the button.\n+     */\n+    public BoundButton(String title)\n+    {\n+      super(title);\n+    }\n+\n+    /**\n+     * This method returns a standard size (based on the defaults of the JDesktopIcon) and the insets.\n+     *\n+     * @return The preferred size of the JDesktopIcon.\n+     */\n+    public Dimension getPreferredSize()\n+    {\n+      Insets insets = desktopIcon.getInsets();\n+      return new Dimension(iconWidth - insets.left - insets.right,\n+                           iconHeight - insets.top - insets.bottom);\n+    }\n+\n+    /**\n+     * This method returns the minimum size of the button.\n+     *\n+     * @return The minimum size of the button.\n+     */\n+    public Dimension getMinimumSize()\n+    {\n+      return getPreferredSize();\n+    }\n+\n+    /**\n+     * This method returns the maximum size of the button.\n+     *\n+     * @return The maximum size of the button.\n+     */\n+    public Dimension getMaximumSize()\n+    {\n+      return getPreferredSize();\n+    }\n+  }\n+\n+  /**\n+   * Creates a new BasicDesktopIconUI object.\n+   */\n+  public BasicDesktopIconUI()\n+  {\n+  }\n+\n+  /**\n+   * This method creates a new BasicDesktopIconUI for the given JComponent.\n+   *\n+   * @param c The JComponent to create a UI for.\n+   *\n+   * @return A new BasicDesktopIconUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicDesktopIconUI();\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to install this UI for.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    if (c instanceof JDesktopIcon)\n+      {\n+\tdesktopIcon = (JDesktopIcon) c;\n+\tdesktopIcon.setLayout(new BorderLayout());\n+\tframe = desktopIcon.getInternalFrame();\n+\n+\tinstallDefaults();\n+\tinstallComponents();\n+\tinstallListeners();\n+\n+\tdesktopIcon.setOpaque(true);\n+      }\n+  }\n+\n+  /**\n+   * This method uninstalls the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to uninstall this UI for.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    desktopIcon.setOpaque(false);\n+    \n+    uninstallListeners();\n+    uninstallComponents();\n+    uninstallDefaults();\n+    \n+    frame = null;\n+    desktopIcon.setLayout(null);\n+    desktopIcon = null;\n+  }\n+\n+  /**\n+   * This method installs the necessary sub components for the JDesktopIcon.\n+   */\n+  protected void installComponents()\n+  {\n+    // Try to create a button based on what the frame's\n+    // state is currently\n+    button = new BoundButton(frame.getTitle());\n+    button.setHorizontalAlignment(SwingConstants.LEFT);\n+    button.setHorizontalTextPosition(SwingConstants.TRAILING);\n+\n+    Icon use = frame.getFrameIcon();\n+    if (use == null)\n+      use = defaultIcon;\n+    button.setIcon(use);\n+\n+    desktopIcon.add(button, SwingConstants.CENTER);\n+  }\n+\n+  /**\n+   * This method uninstalls the sub components for the JDesktopIcon.\n+   */\n+  protected void uninstallComponents()\n+  {\n+    desktopIcon.remove(button);\n+    \n+    button = null;\n+  }\n+\n+  /**\n+   * This method installs the listeners needed by this UI.\n+   */\n+  protected void installListeners()\n+  {\n+    mouseHandler = createMouseInputListener();\n+\n+    desktopIcon.addMouseMotionListener(mouseHandler);\n+    desktopIcon.addMouseListener(mouseHandler);\n+\n+    propertyHandler = new PropertyChangeListener()\n+        {\n+\t  public void propertyChange(PropertyChangeEvent e)\n+\t  {\n+\t    if (e.getPropertyName().equals(JInternalFrame.TITLE_PROPERTY))\n+\t      button.setText(desktopIcon.getInternalFrame().getTitle());\n+\t    else if (e.getPropertyName().equals(JInternalFrame.FRAME_ICON_PROPERTY))\n+\t      {\n+\t\tIcon use = desktopIcon.getInternalFrame().getFrameIcon();\n+\t\tif (use == null)\n+\t\t  use = defaultIcon;\n+\t\tbutton.setIcon(use);\n+\t      }\n+\t    desktopIcon.revalidate();\n+\t    desktopIcon.repaint();\n+\t  }\n+        };\n+    frame.addPropertyChangeListener(propertyHandler);\n+\n+    button.addActionListener(new ActionListener()\n+        {\n+\t  public void actionPerformed(ActionEvent e)\n+\t  {\n+            deiconize();\n+\t  }\n+        });\n+  }\n+\n+  /**\n+   * This method uninstalls the listeners needed by the UI.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    // button is nulled so no need to remove it.\n+    \n+    frame.removePropertyChangeListener(propertyHandler);\n+    propertyHandler = null;\n+    \n+    desktopIcon.removeMouseMotionListener(mouseHandler);\n+    desktopIcon.removeMouseListener(mouseHandler);\n+  }\n+\n+  /**\n+   * This method installs the defaults for the JDesktopIcon.\n+   */\n+  protected void installDefaults()\n+  {\n+    // FIXME: Move border to defaults.\n+    desktopIcon.setBorder(new DesktopIconBorder());  \n+  }\n+\n+  /**\n+   * This method uninstalls the defaults for the JDesktopIcon.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    desktopIcon.setBorder(null);\n+  }\n+\n+  /**\n+   * This method creates a new MouseInputListener for the JDesktopIcon.\n+   *\n+   * @return A new MouseInputListener.\n+   */\n+  protected MouseInputListener createMouseInputListener()\n+  {\n+    return new MouseInputHandler();\n+  }\n+\n+  /**\n+   * This method returns the preferred size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a preferred size for.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    return new Dimension(iconWidth, iconHeight);\n+  }\n+\n+  /**\n+   * This method returns the minimum size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the maximum size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a maximum size for.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the insets of the given JComponent.\n+   *\n+   * @param c The JComponent to find insets for.\n+   *\n+   * @return The insets of the given JComponent.\n+   */\n+  public Insets getInsets(JComponent c)\n+  {\n+    return c.getInsets();\n+  }\n+\n+  /**\n+   * This method deiconizes the JInternalFrame associated with the JDesktopIcon.\n+   */\n+  public void deiconize() \n+  {\n+    try\n+    {\n+      frame.setIcon(false);\n+    }\n+    catch (PropertyVetoException pve)\n+    {\n+    }\n+  }\n+}"}, {"sha": "3d43b362636e2bba12b11c7512426a9df56d92c4", "filename": "libjava/javax/swing/plaf/basic/BasicDesktopPaneUI.java", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDesktopPaneUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -0,0 +1,459 @@\n+/* BasicDesktopPaneUI.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyVetoException;\n+import javax.swing.AbstractAction;\n+import javax.swing.DefaultDesktopManager;\n+import javax.swing.DesktopManager;\n+import javax.swing.JComponent;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JInternalFrame.JDesktopIcon;\n+import javax.swing.KeyStroke;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.MouseInputAdapter;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.DesktopIconUI;\n+import javax.swing.plaf.DesktopPaneUI;\n+\n+\n+/**\n+ * This class is the UI delegate for JDesktopPane for the Basic look and feel.\n+ */\n+public class BasicDesktopPaneUI extends DesktopPaneUI\n+{\n+  /**\n+   * This helper class is used to handle key events that cause JInternalFrames\n+   * to be closed.\n+   */\n+  protected class CloseAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the action is performed.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+        {\n+\t  try\n+\t    {\n+\t      desktop.getSelectedFrame().setClosed(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * This method returns whether the action is enabled.\n+     *\n+     * @return Whether the action is enabled.\n+     */\n+    public boolean isEnabled()\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+\treturn desktop.getSelectedFrame().isClosable();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to handle key events that cause JInternalFrames\n+   * to be maximized.\n+   */\n+  protected class MaximizeAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the action is performed.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+        {\n+\t  try\n+\t    {\n+\t      desktop.getSelectedFrame().setMaximum(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * This method returns whether the action is enabled.\n+     *\n+     * @return Whether the action is enabled.\n+     */\n+    public boolean isEnabled()\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+\treturn desktop.getSelectedFrame().isMaximizable();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to handle key events that cause JInternalFrames\n+   * to be minimized.\n+   */\n+  protected class MinimizeAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the action is performed.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+        {\n+\t  try\n+\t    {\n+\t      desktop.getSelectedFrame().setIcon(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * This method returns whether the action is enabled.\n+     *\n+     * @return Whether the action is enabled.\n+     */\n+    public boolean isEnabled()\n+    {\n+      if (desktop.getSelectedFrame() != null)\n+\treturn desktop.getSelectedFrame().isIconifiable();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to handle key events that pass the SELECTED\n+   * property to the next JInternalFrame in the JDesktopPane's list of\n+   * children.\n+   */\n+  protected class NavigateAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the action is performed.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      // This is supposed to set the next selected frame. \n+      JInternalFrame[] frames = desktop.getAllFrames();\n+      if (frames.length == 0)\n+\treturn;\n+\n+      JInternalFrame sFrame = frames[0];\n+      if (desktop.getSelectedFrame() != null)\n+\tsFrame = desktop.getSelectedFrame();\n+\n+      int i = 0;\n+      for (; i < frames.length; i++)\n+\tif (frames[i] == sFrame)\n+\t  break;\n+\n+      // FIXME: Navigate actions go reverse too.\t  \n+      if (i == frames.length)\n+\ti = 0;\n+\n+      desktop.setSelectedFrame(frames[i]);\n+    }\n+\n+    /**\n+     * This method returns whether the action is enabled.\n+     *\n+     * @return Whether this action is enabled.\n+     */\n+    public boolean isEnabled()\n+    {\n+      // Always true.\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to restore the JInternalFrame to its original\n+   * size before maximizing or iconifying.\n+   */\n+  protected class OpenAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the action is performed.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      JInternalFrame frame = desktop.getSelectedFrame();\n+      if (frame != null)\n+        {\n+\t  try\n+\t    {\n+\t      if (frame.isIcon())\n+\t\tframe.setIcon(false);\n+\t      else if (frame.isMaximum())\n+\t\tframe.setMaximum(false);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * This method returns whether the action is enabled.\n+     *\n+     * @return Whether this action is enabled.\n+     */\n+    public boolean isEnabled()\n+    {\n+      // JInternalFrames are always restorable.\n+      return true;\n+    }\n+  }\n+\n+  /** The KeyStroke associated with closing JInternalFrames. */\n+  protected KeyStroke closeKey;\n+\n+  /** The KeyStroke associated with maximizing JInternalFrames. */\n+  protected KeyStroke maximizeKey;\n+\n+  /** The KeyStroke associated with minimizing JInternalFrames. */\n+  protected KeyStroke minimizeKey;\n+\n+  /**\n+   * The KeyStroke associated with navigating (forward?) through\n+   * JInternalFrames.\n+   */\n+  protected KeyStroke navigateKey;\n+\n+  /**\n+   * The KeyStroke associated with navigating (backward?) through\n+   * JInternalFrames.\n+   */\n+  protected KeyStroke navigateKey2;\n+\n+  /** The default desktop manager used with JDesktopPane. */\n+  protected DesktopManager desktopManager;\n+\n+  /** The JDesktopPane this UI is used with. */\n+  protected JDesktopPane desktop;\n+\n+  /**\n+   * Creates a new BasicDesktopPaneUI object.\n+   */\n+  public BasicDesktopPaneUI()\n+  {\n+  }\n+\n+  /**\n+   * This method creates a BasicDesktopPaneUI for the given JComponent.\n+   *\n+   * @param c The JComponent to create a UI for.\n+   *\n+   * @return A new BasicDesktopPaneUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicDesktopPaneUI();\n+  }\n+\n+  /**\n+   * This method returns the maximum size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a maximum size for.\n+   *\n+   * @return The maximum size for the given JComponent.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the minimum size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size for the given JComponent.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the preferred size for the given JComponent.\n+   *\n+   * @param c The JComponent to find a preferred size for.\n+   *\n+   * @return The preferred size for the given JComponent.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    // return null because JDesktopPanes don't have preferred sizes.\n+    return null;\n+  }\n+\n+  /**\n+   * This method installs the defaults for the JDesktopPane provided by the\n+   * current look and feel.\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    desktop.setBackground(defaults.getColor(\"Desktop.background\"));\n+  }\n+\n+  /**\n+   * This method installs the desktop manager for the JDesktopPane.\n+   */\n+  protected void installDesktopManager()\n+  {\n+    desktopManager = new DefaultDesktopManager();\n+    desktop.setDesktopManager(desktopManager);\n+  }\n+\n+  /**\n+   * This method installs the keyboard actions for the JDesktopPane.\n+   */\n+  protected void installKeyboardActions()\n+  {\n+    // FIXME: create actions and keystrokes.\n+    registerKeyboardAction();\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to install this UI for.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    if (c instanceof JDesktopPane)\n+      {\n+\tdesktop = (JDesktopPane) c;\n+\n+\tinstallDefaults();\n+\tinstallDesktopManager();\n+\tinstallKeyboardActions();\n+      }\n+  }\n+\n+  /**\n+   * This method registers the actions to the appropriate Action and Input\n+   * maps.\n+   */\n+  protected void registerKeyboardAction()\n+  {\n+    // FIXME: Do the binding.\n+    // XXX: the gtk windows tend to intercept a lot of the\n+    // key events for themselves. must figure a way past that\n+    // before binding\n+  }\n+\n+  /**\n+   * This method reverses the work done by the installDefaults method.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    desktop.setBackground(null);\n+  }\n+\n+  /**\n+   * This method reverses the work done by the installDesktopManager method.\n+   */\n+  protected void uninstallDesktopManager()\n+  {\n+    desktopManager = null;\n+    desktop.setDesktopManager(null);\n+  }\n+\n+  /**\n+   * This method reverses the work done by the installKeyboardActions method.\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+    unregisterKeyboardActions();\n+    // FIXME: null the actions and keystrokes.\n+  }\n+\n+  /**\n+   * This method reverses the work done by the registerKeyboardActions method.\n+   */\n+  protected void unregisterKeyboardActions()\n+  {\n+    // FIXME: unmap the keystrokes\n+  }\n+\n+  /**\n+   * This method uninstalls the UI for the given JComponent. It should reverse\n+   * all the work done by the installUI method.\n+   *\n+   * @param c The JComponent to uninstall this UI for.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallKeyboardActions();\n+    uninstallDesktopManager();\n+    uninstallDefaults();\n+\n+    desktop = null;\n+  }\n+}"}, {"sha": "3b8a2a20ca20ab3fe036512f1fc9e7d045efe483", "filename": "libjava/javax/swing/plaf/basic/BasicInternalFrameTitlePane.java", "status": "added", "additions": 1004, "deletions": 0, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -0,0 +1,1004 @@\n+/* BasicInternalFrameTitlePane.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyVetoException;\n+import javax.swing.AbstractAction;\n+import javax.swing.Action;\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.event.InternalFrameEvent;\n+import javax.swing.UIManager;\n+import javax.swing.UIDefaults;\n+\n+\n+/**\n+ * This class acts as a titlebar for JInternalFrames.\n+ */\n+public class BasicInternalFrameTitlePane extends JComponent\n+{\n+  /**\n+   * The Action responsible for closing the JInternalFrame.\n+   */\n+  protected class CloseAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when something closes the JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (frame.isClosable())\n+        {\n+\t  try\n+\t    {\n+\t      frame.setClosed(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This Action is responsible for iconifying the JInternalFrame.\n+   */\n+  protected class IconifyAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the user wants to iconify the\n+     * JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (frame.isIconifiable() && ! frame.isIcon())\n+        {\n+\t  try\n+\t    {\n+\t      frame.setIcon(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This Action is responsible for maximizing the JInternalFrame.\n+   */\n+  protected class MaximizeAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the user wants to maximize the\n+     * JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      try\n+        {\n+\t  if (frame.isMaximizable() && ! frame.isMaximum())\n+\t    frame.setMaximum(true);\n+\t  else if (frame.isMaximum())\n+\t    frame.setMaximum(false);\n+        }\n+      catch (PropertyVetoException pve)\n+        {\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This Action is responsible for dragging the JInternalFrame.\n+   */\n+  protected class MoveAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the user wants to drag the JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      // FIXME: Implement keyboard driven? move actions.\n+    }\n+  }\n+\n+  /**\n+   * This Action is responsible for restoring the JInternalFrame. Restoring\n+   * the JInternalFrame is the same as setting the maximum property to false.\n+   */\n+  protected class RestoreAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the user wants to restore the\n+     * JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (frame.isMaximum())\n+        {\n+\t  try\n+\t    {\n+\t      frame.setMaximum(false);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This action is responsible for sizing the JInternalFrame.\n+   */\n+  protected class SizeAction extends AbstractAction\n+  {\n+    /**\n+     * This method is called when the user wants to resize the JInternalFrame.\n+     *\n+     * @param e The ActionEvent.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      // FIXME: Not sure how size actions should be handled.\n+    }\n+  }\n+\n+  /**\n+   * This class is responsible for handling property change events from the\n+   * JInternalFrame and adjusting the Title Pane as necessary.\n+   */\n+  protected class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * This method is called when a PropertyChangeEvent is received by the\n+     * Title Pane.\n+     *\n+     * @param evt The PropertyChangeEvent.\n+     */\n+    public void propertyChange(PropertyChangeEvent evt)\n+    {\n+      // The title and frameIcon are taken care of during painting time.\n+      // The only other thing this will care about are the \"is----izable\"\n+      // properties. So we call enable actions to properly handle the \n+      // buttons and menu items for us.\n+      enableActions();\n+    }\n+  }\n+\n+  /**\n+   * This class acts as the MenuBar for the TitlePane. Clicking on the Frame\n+   * Icon in the top left corner will activate it.\n+   */\n+  protected class SystemMenuBar extends JMenuBar\n+  {\n+    /**\n+     * This method returns true if it can receive focus.\n+     *\n+     * @return True if this Component can receive focus.\n+     */\n+    public boolean isFocusTransversable()\n+    {\n+      return true;\n+    }\n+\n+    /**\n+     * This method returns true if this Component is expected to paint all of\n+     * itself.\n+     *\n+     * @return True if this Component is expect to paint all of itself.\n+     */\n+    public boolean isOpaque()\n+    {\n+      return true;\n+    }\n+\n+    /**\n+     * This method paints this Component.\n+     *\n+     * @param g The Graphics object to paint with.\n+     */\n+    public void paint(Graphics g)\n+    {\n+      Icon frameIcon = frame.getFrameIcon();\n+      if (frameIcon == null)\n+\tframeIcon = BasicDesktopIconUI.defaultIcon;\n+      frameIcon.paintIcon(this, g, 0, 0);\n+    }\n+\n+    /**\n+     * This method requests that focus be given to this Component.\n+     */\n+    public void requestFocus()\n+    {\n+      super.requestFocus();\n+    }\n+  }\n+\n+  /**\n+   * This class acts as the Layout Manager for the TitlePane.\n+   */\n+  protected class TitlePaneLayout implements LayoutManager\n+  {\n+    /**\n+     * This method is called when adding a Component to the Container.\n+     *\n+     * @param name The name to reference the added Component by.\n+     * @param c The Component to add.\n+     */\n+    public void addLayoutComponent(String name, Component c)\n+    {\n+      // Do nothing.\n+    }\n+\n+    /**\n+     * This method is called to lay out the children of the Title Pane.\n+     *\n+     * @param c The Container to lay out.\n+     */\n+    public void layoutContainer(Container c)\n+    {\n+      enableActions();\n+\n+      Insets insets = c.getInsets();\n+      int width = c.getBounds().width - insets.left - insets.right;\n+      int height = c.getBounds().height - insets.top - insets.bottom;\n+\n+      // MenuBar is always present and located at the top left corner.\n+      Dimension menupref = menuBar.getPreferredSize();\n+      menuBar.setBounds(insets.left, insets.top, menupref.width, height);\n+\n+      int loc = width + insets.left;\n+\n+      Insets i = closeButton.getInsets();\n+      Dimension prefs = new Dimension(iconSize + i.left + i.right,\n+                                      iconSize + i.top + i.bottom);\n+      int top = insets.top + (height - prefs.height) / 2;\n+      if (closeAction.isEnabled())\n+        {\n+\t  loc -= prefs.width;\n+\t  closeButton.setVisible(true);\n+\t  closeButton.setBounds(loc, top, prefs.width, prefs.height);\n+        }\n+      else\n+\tcloseButton.setVisible(false);\n+\n+      if (maximizeAction.isEnabled())\n+        {\n+\t  loc -= prefs.width;\n+\t  maxButton.setVisible(true);\n+\t  maxButton.setBounds(loc, top, prefs.width, prefs.height);\n+        }\n+      else\n+\tmaxButton.setVisible(false);\n+\n+      if (iconifyAction.isEnabled())\n+        {\n+\t  loc -= prefs.width;\n+\t  iconButton.setVisible(true);\n+\t  iconButton.setBounds(loc, top, prefs.width, prefs.height);\n+        }\n+      else\n+\ticonButton.setVisible(false);\n+\n+      if (title != null)\n+\ttitle.setBounds(insets.left + menupref.width, insets.top,\n+\t                loc - menupref.width - insets.left, height);\n+    }\n+\n+    /**\n+     * This method returns the minimum size of the given Container given the\n+     * children that it has.\n+     *\n+     * @param c The Container to get a minimum size for.\n+     *\n+     * @return The minimum size of the Container.\n+     */\n+    public Dimension minimumLayoutSize(Container c)\n+    {\n+      return preferredLayoutSize(c);\n+    }\n+\n+    /**\n+     * This method returns the preferred size of the given Container taking\n+     * into account the children that it has.\n+     *\n+     * @param c The Container to lay out.\n+     *\n+     * @return The preferred size of the Container.\n+     */\n+    public Dimension preferredLayoutSize(Container c)\n+    {\n+      Insets frameInsets = frame.getInsets();\n+\n+      // Height is the max of the preferredHeights of all components\n+      // inside the pane\n+      int height = 0;\n+      int width = 0;\n+      Dimension d;\n+\n+      Component[] components = BasicInternalFrameTitlePane.this.getComponents();\n+      for (int i = 0; i < components.length; i++)\n+        {\n+\t  d = components[i].getPreferredSize();\n+\t  height = Math.max(height, d.height);\n+\t  width += d.width;\n+        }\n+\n+      Insets insets = BasicInternalFrameTitlePane.this.getInsets();\n+      height += insets.top + insets.bottom;\n+\n+      return new Dimension(width, height);\n+    }\n+\n+    /**\n+     * This method is called when removing a Component from the Container.\n+     *\n+     * @param c The Component to remove.\n+     */\n+    public void removeLayoutComponent(Component c)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to create the minimize, maximize and close\n+   * buttons in the top right corner of the Title Pane. These buttons are\n+   * special since they cannot be given focus and have no border.\n+   */\n+  private class PaneButton extends JButton\n+  {\n+    /**\n+     * Creates a new PaneButton object with the given Action.\n+     *\n+     * @param a The Action that the button uses.\n+     */\n+    public PaneButton(Action a)\n+    {\n+      super(a);\n+      setMargin(new Insets(0, 0, 0, 0));\n+      setBorder(null);\n+    }\n+\n+    /**\n+     * This method returns true if the Component can be focused.\n+     *\n+     * @return false.\n+     */\n+    public boolean isFocusable()\n+    {\n+      // These buttons cannot be given focus.\n+      return false;\n+    }\n+  }\n+\n+  /** The action command for the Close action. */\n+  protected static String CLOSE_CMD = \"Close\";\n+\n+  /** The action command for the Minimize action. */\n+  protected static String ICONIFY_CMD = \"Minimize\";\n+\n+  /** The action command for the Maximize action. */\n+  protected static String MAXIMIZE_CMD = \"Maximize\";\n+\n+  /** The action command for the Move action. */\n+  protected static String MOVE_CMD = \"Move\";\n+\n+  /** The action command for the Restore action. */\n+  protected static String RESTORE_CMD = \"Restore\";\n+\n+  /** The action command for the Size action. */\n+  protected static String SIZE_CMD = \"Size\";\n+\n+  /** The action associated with closing the JInternalFrame. */\n+  protected Action closeAction;\n+\n+  /** The action associated with iconifying the JInternalFrame. */\n+  protected Action iconifyAction;\n+\n+  /** The action associated with maximizing the JInternalFrame. */\n+  protected Action maximizeAction;\n+\n+  /** The action associated with moving the JInternalFrame. */\n+  protected Action moveAction;\n+\n+  /** The action associated with restoring the JInternalFrame. */\n+  protected Action restoreAction;\n+\n+  /** The action associated with resizing the JInternalFrame. */\n+  protected Action sizeAction;\n+\n+  /** The button that closes the JInternalFrame. */\n+  protected JButton closeButton;\n+\n+  /** The button that iconifies the JInternalFrame. */\n+  protected JButton iconButton;\n+\n+  /** The button that maximizes the JInternalFrame. */\n+  protected JButton maxButton;\n+\n+  /** Active background color. */\n+  protected Color activeBGColor;\n+\n+  /** Active foreground color. */\n+  protected Color activeFGColor;\n+\n+  /** Inactive background color. */\n+  protected Color inactiveBGColor;\n+\n+  /** Inactive foreground color. */\n+  protected Color inactiveFGColor;\n+\n+  // FIXME: These icons need to be moved to MetalIconFactory.\n+\n+  /** The size of the icons in the buttons. */\n+  private static final int iconSize = 16;\n+\n+  /** The icon displayed in the close button. */\n+  protected Icon closeIcon = new Icon()\n+    {\n+      public int getIconHeight()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public int getIconWidth()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public void paintIcon(Component c, Graphics g, int x, int y)\n+      {\n+\tg.translate(x, y);\n+\tColor saved = g.getColor();\n+\tg.setColor(Color.BLACK);\n+\n+\tint four = iconSize / 4;\n+\tint six = iconSize * 6 / 16;\n+\tint ten = iconSize * 10 / 16;\n+\tint twelve = iconSize * 12 / 16;\n+\n+\tPolygon a = new Polygon(new int[] { four, six, ten, twelve },\n+\t                        new int[] { six, four, twelve, ten }, 4);\n+\tPolygon b = new Polygon(new int[] { four, six, ten, twelve },\n+\t                        new int[] { ten, twelve, four, six }, 4);\n+\n+\tg.fillPolygon(a);\n+\tg.fillPolygon(b);\n+\n+\tg.setColor(saved);\n+\tg.translate(-x, -y);\n+      }\n+    };\n+\n+  // FIXME: Create new icon.\n+\n+  /** The icon displayed in the restore button. */\n+  protected Icon minIcon;\n+\n+  /** The icon displayed in the maximize button. */\n+  protected Icon maxIcon = new Icon()\n+    {\n+      public int getIconHeight()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public int getIconWidth()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public void paintIcon(Component c, Graphics g, int x, int y)\n+      {\n+\tg.translate(x, y);\n+\tColor saved = g.getColor();\n+\tg.setColor(Color.BLACK);\n+\n+\tint four = iconSize / 4;\n+\tint two = four / 2;\n+\tint six = iconSize * 6 / 16;\n+\tint eight = four * 2;\n+\n+\tg.fillRect(four, four, eight, two);\n+\tg.drawRect(four, six, eight, six);\n+\n+\tg.setColor(saved);\n+\tg.translate(-x, -y);\n+      }\n+    };\n+\n+  /** The icon displayed in the iconify button. */\n+  protected Icon iconIcon = new Icon()\n+    {\n+      public int getIconHeight()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public int getIconWidth()\n+      {\n+\treturn iconSize;\n+      }\n+\n+      public void paintIcon(Component c, Graphics g, int x, int y)\n+      {\n+\tg.translate(x, y);\n+\tColor saved = g.getColor();\n+\tg.setColor(Color.BLACK);\n+\n+\tg.fillRect(iconSize / 4, iconSize * 10 / 16, iconSize / 2, iconSize / 8);\n+\n+\tg.setColor(saved);\n+\tg.translate(-x, -y);\n+      }\n+    };\n+\n+  /** The JInternalFrame that this TitlePane is used in. */\n+  protected JInternalFrame frame;\n+\n+  /** The JMenuBar that is located at the top left of the Title Pane. */\n+  protected JMenuBar menuBar;\n+\n+  /** The JMenu inside the menuBar. */\n+  protected JMenu windowMenu;\n+\n+  /**\n+   * The text color of the TitlePane when the JInternalFrame is not selected.\n+   */\n+  protected Color notSelectedTextColor;\n+\n+  /**\n+   * The background color of the TitlePane when the JInternalFrame is not\n+   * selected.\n+   */\n+  protected Color notSelectedTitleColor;\n+\n+  /** The text color of the titlePane when the JInternalFrame is selected. */\n+  protected Color selectedTextColor;\n+\n+  /**\n+   * The background color of the TitlePane when the JInternalFrame is\n+   * selected.\n+   */\n+  protected Color selectedTitleColor;\n+\n+  /** The Property Change listener that listens to the JInternalFrame. */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /**\n+   * The label used to display the title. This label is not added to the\n+   * TitlePane.\n+   */\n+  private transient JLabel title;\n+\n+  /**\n+   * Creates a new BasicInternalFrameTitlePane object that is used in the\n+   * given JInternalFrame.\n+   *\n+   * @param f The JInternalFrame this BasicInternalFrameTitlePane will be used\n+   *        in.\n+   */\n+  public BasicInternalFrameTitlePane(JInternalFrame f)\n+  {\n+    frame = f;\n+    setLayout(createLayout());\n+    title = new JLabel();\n+    title.setHorizontalAlignment(SwingConstants.LEFT);\n+    title.setHorizontalTextPosition(SwingConstants.LEFT);\n+    title.setOpaque(false);\n+    setOpaque(true);\n+\n+    setBackground(Color.LIGHT_GRAY);\n+\n+    installTitlePane();\n+  }\n+\n+  /**\n+   * This method installs the TitlePane onto the JInternalFrameTitlePane. It\n+   * also creates any children components that need to be created and adds\n+   * listeners to the appropriate components.\n+   */\n+  protected void installTitlePane()\n+  {\n+    installDefaults();\n+    installListeners();\n+    createActions();\n+\n+    assembleSystemMenu();\n+\n+    createButtons();\n+    setButtonIcons();\n+    addSubComponents();\n+    enableActions();\n+  }\n+\n+  /**\n+   * This method adds the sub components to the TitlePane.\n+   */\n+  protected void addSubComponents()\n+  {\n+    add(menuBar);\n+\n+    add(closeButton);\n+    add(iconButton);\n+    add(maxButton);\n+  }\n+\n+  /**\n+   * This method creates the actions that are used to manipulate the\n+   * JInternalFrame.\n+   */\n+  protected void createActions()\n+  {\n+    closeAction = new CloseAction();\n+    closeAction.putValue(AbstractAction.ACTION_COMMAND_KEY, CLOSE_CMD);\n+\n+    iconifyAction = new IconifyAction();\n+    iconifyAction.putValue(AbstractAction.ACTION_COMMAND_KEY, ICONIFY_CMD);\n+\n+    maximizeAction = new MaximizeAction();\n+    maximizeAction.putValue(AbstractAction.ACTION_COMMAND_KEY, MAXIMIZE_CMD);\n+\n+    sizeAction = new SizeAction();\n+    sizeAction.putValue(AbstractAction.ACTION_COMMAND_KEY, SIZE_CMD);\n+\n+    restoreAction = new RestoreAction();\n+    restoreAction.putValue(AbstractAction.ACTION_COMMAND_KEY, RESTORE_CMD);\n+\n+    moveAction = new MoveAction();\n+    moveAction.putValue(AbstractAction.ACTION_COMMAND_KEY, MOVE_CMD);\n+  }\n+\n+  /**\n+   * This method is used to install the listeners.\n+   */\n+  protected void installListeners()\n+  {\n+    propertyChangeListener = new PropertyChangeHandler();\n+    frame.addPropertyChangeListener(propertyChangeListener);\n+  }\n+\n+  /**\n+   * This method is used to uninstall the listeners.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    frame.removePropertyChangeListener(propertyChangeListener);\n+    propertyChangeListener = null;\n+  }\n+\n+  /**\n+   * This method installs the defaults determined by the look and feel.\n+   */\n+  protected void installDefaults()\n+  {\n+    // FIXME: move icons to defaults.\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    setFont(defaults.getFont(\"InternalFrame.titleFont\"));\n+    activeFGColor = defaults.getColor(\"InternalFrame.activeTitleForeground\");\n+    activeBGColor = defaults.getColor(\"InternalFrame.activeTitleBackground\");\n+    inactiveFGColor = defaults.getColor(\"InternalFrame.inactiveTitleForeground\");\n+    inactiveBGColor = defaults.getColor(\"InternalFrame.inactiveTitleBackground\");\n+  }\n+\n+  /**\n+   * This method uninstalls the defaults.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    setFont(null);\n+    activeFGColor = null;\n+    activeBGColor = null;\n+    inactiveFGColor = null;\n+    inactiveBGColor = null;\n+  }\n+\n+  /**\n+   * This method creates the buttons used in the TitlePane.\n+   */\n+  protected void createButtons()\n+  {\n+    closeButton = new PaneButton(closeAction);\n+    closeButton.setOpaque(false);\n+\n+    iconButton = new PaneButton(iconifyAction);\n+    iconButton.setOpaque(false);\n+\n+    maxButton = new PaneButton(maximizeAction);\n+    maxButton.setOpaque(false);\n+  }\n+\n+  /**\n+   * This method sets the icons in the buttons.\n+   */\n+  protected void setButtonIcons()\n+  {\n+    closeButton.setIcon(closeIcon);\n+    iconButton.setIcon(iconIcon);\n+    maxButton.setIcon(maxIcon);\n+  }\n+\n+  /**\n+   * This method creates the MenuBar used in the TitlePane.\n+   */\n+  protected void assembleSystemMenu()\n+  {\n+    menuBar = createSystemMenuBar();\n+    windowMenu = createSystemMenu();\n+\n+    menuBar.add(windowMenu);\n+\n+    addSystemMenuItems(windowMenu);\n+    enableActions();\n+  }\n+\n+  /**\n+   * This method adds the MenuItems to the given JMenu.\n+   *\n+   * @param systemMenu The JMenu to add MenuItems to.\n+   */\n+  protected void addSystemMenuItems(JMenu systemMenu)\n+  {\n+    JMenuItem tmp;\n+\n+    tmp = new JMenuItem(RESTORE_CMD);\n+    tmp.addActionListener(restoreAction);\n+    tmp.setMnemonic(KeyEvent.VK_R);\n+    systemMenu.add(tmp);\n+\n+    tmp = new JMenuItem(MOVE_CMD);\n+    tmp.addActionListener(moveAction);\n+    tmp.setMnemonic(KeyEvent.VK_M);\n+    systemMenu.add(tmp);\n+\n+    tmp = new JMenuItem(SIZE_CMD);\n+    tmp.addActionListener(sizeAction);\n+    tmp.setMnemonic(KeyEvent.VK_S);\n+    systemMenu.add(tmp);\n+\n+    tmp = new JMenuItem(ICONIFY_CMD);\n+    tmp.addActionListener(iconifyAction);\n+    tmp.setMnemonic(KeyEvent.VK_N);\n+    systemMenu.add(tmp);\n+\n+    tmp = new JMenuItem(MAXIMIZE_CMD);\n+    tmp.addActionListener(maximizeAction);\n+    tmp.setMnemonic(KeyEvent.VK_X);\n+    systemMenu.add(tmp);\n+\n+    systemMenu.addSeparator();\n+\n+    tmp = new JMenuItem(CLOSE_CMD);\n+    tmp.addActionListener(closeAction);\n+    tmp.setMnemonic(KeyEvent.VK_C);\n+    systemMenu.add(tmp);\n+  }\n+\n+  /**\n+   * This method creates a new JMenubar.\n+   *\n+   * @return A new JMenuBar.\n+   */\n+  protected JMenuBar createSystemMenuBar()\n+  {\n+    if (menuBar == null)\n+      menuBar = new SystemMenuBar();\n+    menuBar.removeAll();\n+    return menuBar;\n+  }\n+\n+  /**\n+   * This method creates a new JMenu.\n+   *\n+   * @return A new JMenu.\n+   */\n+  protected JMenu createSystemMenu()\n+  {\n+    if (windowMenu == null)\n+      windowMenu = new JMenu();\n+    windowMenu.removeAll();\n+    return windowMenu;\n+  }\n+\n+  /**\n+   * This method programmatically shows the JMenu.\n+   */\n+  protected void showSystemMenu()\n+  {\n+    // FIXME: Untested as KeyEvents are not hooked up.\n+    menuBar.getMenu(1).getPopupMenu().show();\n+  }\n+\n+  /**\n+   * This method paints the TitlePane.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  public void paintComponent(Graphics g)\n+  {\n+    paintTitleBackground(g);\n+    Font f = g.getFont();\n+    FontMetrics fm = g.getFontMetrics(f);\n+    if (frame.getTitle() != null && title != null)\n+      {\n+\tColor saved = g.getColor();\n+\tif (frame.isSelected())\n+\t  g.setColor(activeFGColor);\n+\telse\n+\t  g.setColor(inactiveFGColor);\n+\ttitle.setText(getTitle(frame.getTitle(), fm, title.getBounds().width));\n+\tSwingUtilities.paintComponent(g, title, null, title.getBounds());\n+\tg.setColor(saved);\n+      }\n+  }\n+\n+  /**\n+   * This method paints the TitlePane's background.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  protected void paintTitleBackground(Graphics g)\n+  {\n+    Color saved = g.getColor();\n+    Dimension dims = getSize();\n+\n+    Color bg = getBackground();\n+    if (frame.isSelected())\n+      bg = activeBGColor;\n+    else\n+      bg = inactiveBGColor;\n+    g.setColor(bg);\n+    g.fillRect(0, 0, dims.width, dims.height);\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method returns the title string based on the available width and the\n+   * font metrics.\n+   *\n+   * @param text The desired title.\n+   * @param fm The FontMetrics of the font used.\n+   * @param availableWidth The available width.\n+   *\n+   * @return The allowable string.\n+   */\n+  protected String getTitle(String text, FontMetrics fm, int availableWidth)\n+  {\n+    Rectangle vr = new Rectangle(0, 0, availableWidth, fm.getHeight());\n+    Rectangle ir = new Rectangle();\n+    Rectangle tr = new Rectangle();\n+    String value = SwingUtilities.layoutCompoundLabel(this, fm, text, null,\n+                                                      SwingConstants.CENTER,\n+                                                      SwingConstants.LEFT,\n+                                                      SwingConstants.CENTER,\n+                                                      SwingConstants.LEFT, vr,\n+                                                      ir, tr, 0);\n+    return value;\n+  }\n+\n+  /**\n+   * This method fires something similar to a WINDOW_CLOSING event.\n+   *\n+   * @param frame The JInternalFrame that is being closed.\n+   */\n+  protected void postClosingEvent(JInternalFrame frame)\n+  {\n+    // FIXME: Implement postClosingEvent when I figure out what\n+    // it's supposed to do.\n+    // It says that this fires an WINDOW_CLOSING like event. \n+    // So the closest thing is some kind of InternalFrameEvent.\n+    // But none is fired.\n+    // Can't see it called or anything.\n+  }\n+\n+  /**\n+   * This method enables the actions for the TitlePane given the frame's\n+   * properties.\n+   */\n+  protected void enableActions()\n+  {\n+    closeAction.setEnabled(frame.isClosable());\n+\n+    iconifyAction.setEnabled(frame.isIconifiable());\n+    // The maximize action is responsible for restoring it\n+    // as well, if clicked from the button\n+    maximizeAction.setEnabled(frame.isMaximizable());\n+\n+    // The restoring action is only active when selected\n+    // from the menu.\n+    restoreAction.setEnabled(frame.isMaximum());\n+\n+    sizeAction.setEnabled(frame.isResizable());\n+\n+    // FIXME: Tie MoveAction enabled status to a variable.\n+    moveAction.setEnabled(false);\n+  }\n+\n+  /**\n+   * This method creates a new PropertyChangeListener.\n+   *\n+   * @return A new PropertyChangeListener.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * This method creates a new LayoutManager for the TitlePane.\n+   *\n+   * @return A new LayoutManager.\n+   */\n+  protected LayoutManager createLayout()\n+  {\n+    return new TitlePaneLayout();\n+  }\n+}"}, {"sha": "5c598b763ce4a7dcea2df282bce6f65cfe87275c", "filename": "libjava/javax/swing/plaf/basic/BasicInternalFrameUI.java", "status": "added", "additions": 1488, "deletions": 0, "changes": 1488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -0,0 +1,1488 @@\n+/* BasicInternalFrameUI.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.AbstractAction;\n+import javax.swing.Action;\n+import javax.swing.DefaultDesktopManager;\n+import javax.swing.DesktopManager;\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.KeyStroke;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.border.AbstractBorder;\n+import javax.swing.event.InternalFrameEvent;\n+import javax.swing.event.InternalFrameListener;\n+import javax.swing.event.MouseInputAdapter;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.InternalFrameUI;\n+import javax.swing.plaf.UIResource;\n+\n+\n+/**\n+ * This is the UI delegate for the Basic look and feel for JInternalFrames.\n+ */\n+public class BasicInternalFrameUI extends InternalFrameUI\n+{\n+  /**\n+   * This is a helper class that listens to the JInternalFrame for\n+   * InternalFrameEvents.\n+   */\n+  protected class BasicInternalFrameListener implements InternalFrameListener\n+  {\n+    /**\n+     * This method is called when the JInternalFrame is activated.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameActivated(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is closed.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameClosed(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is closing.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameClosing(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is deactivated.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameDeactivated(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is  deiconified.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameDeiconified(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is  iconified.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameIconified(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+\n+    /**\n+     * This method is called when the JInternalFrame is opened.\n+     *\n+     * @param e The InternalFrameEvent.\n+     */\n+    public void internalFrameOpened(InternalFrameEvent e)\n+    {\n+      // FIXME: Implement.\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens to the edges of the JInternalFrame and the\n+   * TitlePane for mouse events. It is responsible for dragging  and resizing\n+   * the JInternalFrame in response to the MouseEvents.\n+   */\n+  protected class BorderListener extends MouseInputAdapter\n+    implements SwingConstants\n+  {\n+    /** FIXME: Use for something. */\n+    protected int RESIZE_NONE;\n+\n+    /** The x offset from the top left corner of the JInternalFrame. */\n+    private transient int xOffset = 0;\n+\n+    /** The y offset from the top left corner of the JInternalFrame. */\n+    private transient int yOffset = 0;\n+\n+    /** The direction that the resize is occuring in. */\n+    private transient int direction = -1;\n+\n+    /**\n+     * This method is called when the mouse is clicked.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseClicked(MouseEvent e)\n+    {\n+      // There is nothing to do when the mouse is clicked\n+      // on the border.\n+    }\n+\n+    /**\n+     * This method is called when the mouse is dragged. This method is\n+     * responsible for resizing or dragging the JInternalFrame.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      // If the frame is maximized, there is nothing that \n+      // can be dragged around.\n+      if (frame.isMaximum())\n+\treturn;\n+      DesktopManager dm = getDesktopManager();\n+      Rectangle b = frame.getBounds();\n+      Insets insets = frame.getInsets();\n+      int x = e.getX();\n+      int y = e.getY();\n+      if (e.getSource() == frame && frame.isResizable())\n+        {\n+\t  switch (direction)\n+\t    {\n+\t    case NORTH:\n+\t      dm.resizeFrame(frame, b.x, b.y + y, b.width, b.height - y);\n+\t      break;\n+\t    case NORTH_EAST:\n+\t      dm.resizeFrame(frame, b.x, b.y + y, x, b.height - y);\n+\t      break;\n+\t    case EAST:\n+\t      dm.resizeFrame(frame, b.x, b.y, x, b.height);\n+\t      break;\n+\t    case SOUTH_EAST:\n+\t      dm.resizeFrame(frame, b.x, b.y, x, y);\n+\t      break;\n+\t    case SOUTH:\n+\t      dm.resizeFrame(frame, b.x, b.y, b.width, y);\n+\t      break;\n+\t    case SOUTH_WEST:\n+\t      dm.resizeFrame(frame, b.x + x, b.y, b.width - x, y);\n+\t      break;\n+\t    case WEST:\n+\t      dm.resizeFrame(frame, b.x + x, b.y, b.width - x, b.height);\n+\t      break;\n+\t    case NORTH_WEST:\n+\t      dm.resizeFrame(frame, b.x + x, b.y + y, b.width - x, b.height\n+\t                     - y);\n+\t      break;\n+\t    }\n+        }\n+      else if (e.getSource() == titlePane)\n+        {\n+\t  Rectangle fBounds = frame.getBounds();\n+\n+\t  dm.dragFrame(frame, e.getX() - xOffset + b.x,\n+\t               e.getY() - yOffset + b.y);\n+        }\n+    }\n+\n+    /**\n+     * This method is called when the mouse exits the JInternalFrame.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseExited(MouseEvent e)\n+    {\n+      // There is nothing to do when the mouse exits \n+      // the border area.\n+    }\n+\n+    /**\n+     * This method is called when the mouse is moved inside the\n+     * JInternalFrame.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // There is nothing to do when the mouse moves\n+      // over the border area.\n+    }\n+\n+    /**\n+     * This method is called when the mouse is pressed.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      activateFrame(frame);\n+      DesktopManager dm = getDesktopManager();\n+      int x = e.getX();\n+      int y = e.getY();\n+      Insets insets = frame.getInsets();\n+\n+      if (e.getSource() == frame && frame.isResizable())\n+        {\n+\t  direction = sectionOfClick(x, y);\n+\t  dm.beginResizingFrame(frame, direction);\n+        }\n+      else if (e.getSource() == titlePane)\n+        {\n+\t  Rectangle tBounds = titlePane.getBounds();\n+\n+\t  xOffset = e.getX() - tBounds.x + insets.left;\n+\t  yOffset = e.getY() - tBounds.y + insets.top;\n+\n+\t  dm.beginDraggingFrame(frame);\n+        }\n+    }\n+\n+    /**\n+     * This method is called when the mouse is released.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      DesktopManager dm = getDesktopManager();\n+      xOffset = 0;\n+      yOffset = 0;\n+      if (e.getSource() == frame && frame.isResizable())\n+\tdm.endResizingFrame(frame);\n+      else if (e.getSource() == titlePane)\n+\tdm.endDraggingFrame(frame);\n+    }\n+\n+    /**\n+     * This method determines the direction of the resize based on the\n+     * coordinates and the size of the JInternalFrame.\n+     *\n+     * @param x The x coordinate of the MouseEvent.\n+     * @param y The y coordinate of the MouseEvent.\n+     *\n+     * @return The direction of the resize (a SwingConstant direction).\n+     */\n+    private int sectionOfClick(int x, int y)\n+    {\n+      Insets insets = frame.getInsets();\n+      Rectangle b = frame.getBounds();\n+      if (x < insets.left && y < insets.top)\n+\treturn NORTH_WEST;\n+      else if (x > b.width - insets.right && y < insets.top)\n+\treturn NORTH_EAST;\n+      else if (x > b.width - insets.right && y > b.height - insets.bottom)\n+\treturn SOUTH_EAST;\n+      else if (x < insets.left && y > b.height - insets.bottom)\n+\treturn SOUTH_WEST;\n+      else if (y < insets.top)\n+\treturn NORTH;\n+      else if (x < insets.left)\n+\treturn WEST;\n+      else if (y > b.height - insets.bottom)\n+\treturn SOUTH;\n+      else if (x > b.width - insets.right)\n+\treturn EAST;\n+\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens to the JDesktopPane that parents this\n+   * JInternalFrame and listens for resize events and resizes the\n+   * JInternalFrame appropriately.\n+   */\n+  protected class ComponentHandler implements ComponentListener\n+  {\n+    /**\n+     * This method is called when the JDesktopPane is hidden.\n+     *\n+     * @param e The ComponentEvent fired.\n+     */\n+    public void componentHidden(ComponentEvent e)\n+    {\n+      // Do nothing.\n+    }\n+\n+    /**\n+     * This method is called when the JDesktopPane is moved.\n+     *\n+     * @param e The ComponentEvent fired.\n+     */\n+    public void componentMoved(ComponentEvent e)\n+    {\n+      // Do nothing.\n+    }\n+\n+    /**\n+     * This method is called when the JDesktopPane is resized.\n+     *\n+     * @param e The ComponentEvent fired.\n+     */\n+    public void componentResized(ComponentEvent e)\n+    {\n+      if (frame.isMaximum())\n+        {\n+\t  JDesktopPane pane = (JDesktopPane) e.getSource();\n+\t  Insets insets = pane.getInsets();\n+\t  Rectangle bounds = pane.getBounds();\n+\n+\t  frame.setBounds(bounds.x + insets.left, bounds.y + insets.top,\n+\t                  bounds.width - insets.left - insets.right,\n+\t                  bounds.height - insets.top - insets.bottom);\n+\t  frame.revalidate();\n+\t  frame.repaint();\n+        }\n+\n+      // Sun also resizes the icons. but it doesn't seem to do anything.\n+    }\n+\n+    /**\n+     * This method is called when the JDesktopPane is shown.\n+     *\n+     * @param e The ComponentEvent fired.\n+     */\n+    public void componentShown(ComponentEvent e)\n+    {\n+      // Do nothing.\n+    }\n+  }\n+\n+  /**\n+   * This helper class acts as the LayoutManager for JInternalFrames.\n+   */\n+  public class InternalFrameLayout implements LayoutManager\n+  {\n+    /**\n+     * This method is called when the given Component is added  to the\n+     * JInternalFrame.\n+     *\n+     * @param name The name of the Component.\n+     * @param c The Component added.\n+     */\n+    public void addLayoutComponent(String name, Component c)\n+    {\n+    }\n+\n+    /**\n+     * This method is used to set the bounds of the children of the\n+     * JInternalFrame.\n+     *\n+     * @param c The Container to lay out.\n+     */\n+    public void layoutContainer(Container c)\n+    {\n+      Dimension dims = frame.getSize();\n+      Insets insets = frame.getInsets();\n+\n+      dims.width -= insets.left + insets.right;\n+      dims.height -= insets.top + insets.bottom;\n+\n+      frame.getRootPane().getGlassPane().setBounds(0, 0, dims.width,\n+                                                   dims.height);\n+      int nh = 0;\n+      int sh = 0;\n+      int ew = 0;\n+      int ww = 0;\n+\n+      if (northPane != null)\n+        {\n+\t  Dimension nDims = northPane.getPreferredSize();\n+\t  nh = Math.min(nDims.height, dims.height);\n+\n+\t  northPane.setBounds(insets.left, insets.top, dims.width, nh);\n+        }\n+\n+      if (southPane != null)\n+        {\n+\t  Dimension sDims = southPane.getPreferredSize();\n+\t  sh = Math.min(sDims.height, dims.height - nh);\n+\n+\t  southPane.setBounds(insets.left, insets.top + dims.height - sh,\n+\t                      dims.width, sh);\n+        }\n+\n+      int remHeight = dims.height - sh - nh;\n+\n+      if (westPane != null)\n+        {\n+\t  Dimension wDims = westPane.getPreferredSize();\n+\t  ww = Math.min(dims.width, wDims.width);\n+\n+\t  westPane.setBounds(insets.left, insets.top + nh, ww, remHeight);\n+        }\n+\n+      if (eastPane != null)\n+        {\n+\t  Dimension eDims = eastPane.getPreferredSize();\n+\t  ew = Math.min(eDims.width, dims.width - ww);\n+\n+\t  eastPane.setBounds(insets.left + dims.width - ew, insets.top + nh,\n+\t                     ew, remHeight);\n+        }\n+\n+      int remWidth = dims.width - ww - ew;\n+\n+      frame.getRootPane().setBounds(insets.left + ww, insets.top + nh,\n+                                    remWidth, remHeight);\n+    }\n+\n+    /**\n+     * This method returns the minimum layout size.\n+     *\n+     * @param c The Container to find a minimum layout size for.\n+     *\n+     * @return The minimum dimensions for the JInternalFrame.\n+     */\n+    public Dimension minimumLayoutSize(Container c)\n+    {\n+      return preferredLayoutSize(c);\n+    }\n+\n+    /**\n+     * This method returns the maximum layout size.\n+     *\n+     * @param c The Container to find a maximum layout size for.\n+     *\n+     * @return The maximum dimensions for the JInternalFrame.\n+     */\n+    public Dimension maximumLayoutSize(Container c)\n+    {\n+      return preferredLayoutSize(c);\n+    }\n+\n+    /**\n+     * Th8is method returns the preferred layout size.\n+     *\n+     * @param c The Container to find a preferred layout size for.\n+     *\n+     * @return The preferred dimensions for the JInternalFrame.\n+     */\n+    public Dimension preferredLayoutSize(Container c)\n+    {\n+      Insets insets = frame.getInsets();\n+\n+      Dimension contentDims = frame.getContentPane().getPreferredSize();\n+      int nWidth = 0;\n+      int nHeight = 0;\n+      int sWidth = 0;\n+      int sHeight = 0;\n+      int eWidth = 0;\n+      int eHeight = 0;\n+      int wWidth = 0;\n+      int wHeight = 0;\n+      Dimension dims;\n+\n+      if (northPane != null)\n+        {\n+\t  dims = northPane.getPreferredSize();\n+\t  if (dims != null)\n+\t    {\n+\t      nWidth = dims.width;\n+\t      nHeight = dims.height;\n+\t    }\n+        }\n+\n+      if (southPane != null)\n+        {\n+\t  dims = southPane.getPreferredSize();\n+\t  if (dims != null)\n+\t    {\n+\t      sWidth = dims.width;\n+\t      sHeight = dims.height;\n+\t    }\n+        }\n+\n+      if (eastPane != null)\n+        {\n+\t  dims = eastPane.getPreferredSize();\n+\t  if (dims != null)\n+\t    {\n+\t      sWidth = dims.width;\n+\t      sHeight = dims.height;\n+\t    }\n+        }\n+\n+      if (westPane != null)\n+        {\n+\t  dims = westPane.getPreferredSize();\n+\t  if (dims != null)\n+\t    {\n+\t      wWidth = dims.width;\n+\t      wHeight = dims.height;\n+\t    }\n+        }\n+\n+      int width = Math.max(sWidth, nWidth);\n+      width = Math.max(width, contentDims.width + eWidth + wWidth);\n+\n+      int height = Math.max(contentDims.height, eHeight);\n+      height = Math.max(height, wHeight);\n+      height += nHeight + sHeight;\n+\n+      width += insets.left + insets.right;\n+      height += insets.top + insets.bottom;\n+\n+      return new Dimension(width, height);\n+    }\n+\n+    /**\n+     * This method is called when a Component is removed from the\n+     * JInternalFrame.\n+     *\n+     * @param c The Component that was removed.\n+     */\n+    public void removeLayoutComponent(Component c)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to listen to the JDesktopPane's glassPane for\n+   * MouseEvents. The JInternalFrame can then be selected if a click is\n+   * detected on its children.\n+   */\n+  protected class GlassPaneDispatcher implements MouseInputListener\n+  {\n+    /**\n+     * This method is called when the mouse enters the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseEntered(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is clicked on the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseClicked(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is dragged in the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse exits the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseExited(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is moved in the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is  pressed in the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      activateFrame(frame);\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is  released in the glass pane.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      dispatchFor(e);\n+    }\n+\n+    /**\n+     * This helper method redispatches the MouseEvent to the  proper sub\n+     * component.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    private void dispatchFor(MouseEvent e)\n+    {\n+      Component candidate = SwingUtilities.getDeepestComponentAt(frame.getRootPane()\n+                                                                      .getContentPane(),\n+                                                                 e.getX(),\n+                                                                 e.getY());\n+      if (candidate == null || candidate == frame.getRootPane().getGlassPane())\n+\treturn;\n+      MouseEvent newevt = SwingUtilities.convertMouseEvent(frame.getRootPane()\n+                                                                .getGlassPane(),\n+                                                           e, candidate);\n+      candidate.dispatchEvent(newevt);\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens for PropertyChangeEvents from the\n+   * JInternalFrame.\n+   */\n+  public class InternalFramePropertyChangeListener\n+    implements PropertyChangeListener\n+  {\n+    /**\n+     * This method is called when one of the JInternalFrame's properties\n+     * change.\n+     *\n+     * @param evt The PropertyChangeEvent.\n+     */\n+    public void propertyChange(PropertyChangeEvent evt)\n+    {\n+      if (evt.getPropertyName().equals(JInternalFrame.IS_MAXIMUM_PROPERTY))\n+        {\n+\t  if (frame.isMaximum())\n+\t    maximizeFrame(frame);\n+\t  else\n+\t    minimizeFrame(frame);\n+        }\n+      else if (evt.getPropertyName().equals(JInternalFrame.IS_CLOSED_PROPERTY))\n+\tcloseFrame(frame);\n+      else if (evt.getPropertyName().equals(JInternalFrame.IS_ICON_PROPERTY))\n+        {\n+\t  if (frame.isIcon())\n+\t    iconifyFrame(frame);\n+\t  else\n+\t    deiconifyFrame(frame);\n+        }\n+      else if (evt.getPropertyName().equals(JInternalFrame.IS_SELECTED_PROPERTY))\n+        {\n+\t  if (frame.isSelected())\n+\t    activateFrame(frame);\n+\t  else\n+\t    getDesktopManager().deactivateFrame(frame);\n+        }\n+      else if (evt.getPropertyName().equals(JInternalFrame.ROOT_PANE_PROPERTY)\n+               || evt.getPropertyName().equals(JInternalFrame.GLASS_PANE_PROPERTY))\n+        {\n+\t  Component old = (Component) evt.getOldValue();\n+\t  old.removeMouseListener(glassPaneDispatcher);\n+\t  old.removeMouseMotionListener(glassPaneDispatcher);\n+\n+\t  Component newPane = (Component) evt.getNewValue();\n+\t  newPane.addMouseListener(glassPaneDispatcher);\n+\t  newPane.addMouseMotionListener(glassPaneDispatcher);\n+\n+\t  frame.revalidate();\n+        }\n+      /* FIXME: need to add ancestor properties to JComponents.\n+      else if (evt.getPropertyName().equals(JComponent.ANCESTOR_PROPERTY))\n+      {\n+        if (desktopPane != null)\n+          desktopPane.removeComponentListener(componentListener);\n+        desktopPane = frame.getDesktopPane();\n+        if (desktopPane != null)\n+          desktopPane.addComponentListener(componentListener);\n+      }\n+      */\n+    }\n+  }\n+\n+  /**\n+   * This helper class is the border for the JInternalFrame.\n+   */\n+  private class InternalFrameBorder extends AbstractBorder\n+    implements UIResource\n+  {\n+    /** The width of the border. */\n+    private static final int bSize = 5;\n+\n+    /** The size of the corners. */\n+    private static final int offset = 10;\n+\n+    /**\n+     * This method returns whether the border is opaque.\n+     *\n+     * @return Whether the border is opaque.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      return true;\n+    }\n+\n+    /**\n+     * This method returns the insets of the border.\n+     *\n+     * @param c The Component to find border insets for.\n+     *\n+     * @return The border insets.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(bSize, bSize, bSize, bSize);\n+    }\n+\n+    /**\n+     * This method paints the border.\n+     *\n+     * @param c The Component that owns the border.\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate to paint at.\n+     * @param y The y coordinate to paint at.\n+     * @param width The width of the Component.\n+     * @param height The height of the Component.\n+     */\n+    public void paintBorder(Component c, Graphics g, int x, int y, int width,\n+                            int height)\n+    {\n+      g.translate(x, y);\n+      Color saved = g.getColor();\n+      Rectangle b = frame.getBounds();\n+\n+      Color d = c.getBackground();\n+      g.setColor(d);\n+      g.fillRect(0, 0, bSize, b.height);\n+      g.fillRect(0, 0, b.width, bSize);\n+      g.fillRect(0, b.height - bSize, b.width, bSize);\n+      g.fillRect(b.width - bSize, 0, bSize, b.height);\n+\n+      int x1 = 0;\n+      int x2 = bSize;\n+      int x3 = b.width - bSize;\n+      int x4 = b.width;\n+\n+      int y1 = 0;\n+      int y2 = bSize;\n+      int y3 = b.height - bSize;\n+      int y4 = b.height;\n+\n+      g.setColor(Color.GRAY);\n+      g.fillRect(0, 0, bSize, y4);\n+      g.fillRect(0, 0, x4, bSize);\n+      g.fillRect(0, y3, b.width, bSize);\n+      g.fillRect(x3, 0, bSize, b.height);\n+\n+      g.fill3DRect(0, offset, bSize, b.height - 2 * offset, false);\n+      g.fill3DRect(offset, 0, b.width - 2 * offset, bSize, false);\n+      g.fill3DRect(offset, b.height - bSize, b.width - 2 * offset, bSize, false);\n+      g.fill3DRect(b.width - bSize, offset, bSize, b.height - 2 * offset, false);\n+\n+      g.translate(-x, -y);\n+      g.setColor(saved);\n+    }\n+  }\n+\n+  /**\n+   * The MouseListener that is responsible for dragging and resizing the\n+   * JInternalFrame in response to MouseEvents.\n+   */\n+  protected MouseInputAdapter borderListener;\n+\n+  /**\n+   * The ComponentListener that is responsible for resizing the JInternalFrame\n+   * in response to ComponentEvents from the JDesktopPane.\n+   */\n+  protected ComponentListener componentListener;\n+\n+  /**\n+   * The MouseListener that is responsible for activating the JInternalFrame\n+   * when the mouse press activates one of its descendents.\n+   */\n+  protected MouseInputListener glassPaneDispatcher;\n+\n+  /**\n+   * The PropertyChangeListener that is responsible for listening to\n+   * PropertyChangeEvents from the JInternalFrame.\n+   */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /** The InternalFrameListener that listens to the JInternalFrame. */\n+  private transient BasicInternalFrameListener internalFrameListener;\n+\n+  /** The JComponent placed at the east region of the JInternalFrame. */\n+  protected JComponent eastPane;\n+\n+  /** The JComponent placed at the north region of the JInternalFrame. */\n+  protected JComponent northPane;\n+\n+  /** The JComponent placed at the south region of the JInternalFrame. */\n+  protected JComponent southPane;\n+\n+  /** The JComponent placed at the west region of the JInternalFrame. */\n+  protected JComponent westPane;\n+\n+  /** The Keystroke bound to open the menu. */\n+  protected KeyStroke openMenuKey;\n+\n+  /** The TitlePane displayed at the top of the JInternalFrame. */\n+  protected BasicInternalFrameTitlePane titlePane;\n+\n+  /** The JInternalFrame this UI is responsible for. */\n+  protected JInternalFrame frame;\n+\n+  /** The LayoutManager used in the JInternalFrame. */\n+  protected LayoutManager internalFrameLayout;\n+\n+  /** The JDesktopPane that is the parent of the JInternalFrame. */\n+  private transient JDesktopPane desktopPane;\n+\n+  /**\n+   * Creates a new BasicInternalFrameUI object.\n+   *\n+   * @param b The JInternalFrame this UI will represent.\n+   */\n+  public BasicInternalFrameUI(JInternalFrame b)\n+  {\n+  }\n+\n+  /**\n+   * This method will create a new BasicInternalFrameUI for the given\n+   * JComponent.\n+   *\n+   * @param b The JComponent to create a BasicInternalFrameUI for.\n+   *\n+   * @return A new BasicInternalFrameUI.\n+   */\n+  public static ComponentUI createUI(JComponent b)\n+  {\n+    return new BasicInternalFrameUI((JInternalFrame) b);\n+  }\n+\n+  /**\n+   * This method installs a UI for the JInternalFrame.\n+   *\n+   * @param c The JComponent to install this UI on.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    if (c instanceof JInternalFrame)\n+      {\n+\tframe = (JInternalFrame) c;\n+\n+\tinternalFrameLayout = createLayoutManager();\n+\tframe.setLayout(internalFrameLayout);\n+\n+\t((JComponent) frame.getRootPane().getGlassPane()).setOpaque(false);\n+\tframe.getRootPane().getGlassPane().setVisible(true);\n+\n+\tinstallDefaults();\n+\tinstallListeners();\n+\tinstallComponents();\t\n+\tinstallKeyboardActions();\n+\n+\tframe.setOpaque(true);\n+\ttitlePane.setOpaque(true);\n+\tframe.invalidate();\n+      }\n+  }\n+\n+  /**\n+   * This method reverses the work done by installUI.\n+   *\n+   * @param c The JComponent to uninstall this UI for.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallKeyboardActions();\n+    uninstallComponents();    \n+    uninstallListeners();\n+    uninstallDefaults();\n+\n+    frame.setLayout(null);\n+    ((JComponent) frame.getRootPane().getGlassPane()).setOpaque(true);\n+    frame.getRootPane().getGlassPane().setVisible(false);\n+\n+    frame = null;\n+  }\n+\n+  /**\n+   * This method installs the defaults specified by the look and feel.\n+   */\n+  protected void installDefaults()\n+  {\n+    // FIXME: Move border to MetalBorders\n+    frame.setBorder(new InternalFrameBorder());\n+  }\n+\n+  /**\n+   * This method installs the keyboard actions for the JInternalFrame.\n+   */\n+  protected void installKeyboardActions()\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * This method installs the Components for the JInternalFrame.\n+   */\n+  protected void installComponents()\n+  {\n+    setNorthPane(createNorthPane(frame));\n+    setSouthPane(createSouthPane(frame));\n+    setEastPane(createEastPane(frame));\n+    setWestPane(createWestPane(frame));\n+  }\n+\n+  /**\n+   * This method installs the listeners for the JInternalFrame.\n+   */\n+  protected void installListeners()\n+  {\n+    glassPaneDispatcher = createGlassPaneDispatcher();\n+    createInternalFrameListener();\n+    borderListener = createBorderListener(frame);\n+    componentListener = createComponentListener();\n+    propertyChangeListener = createPropertyChangeListener();\n+\n+    frame.addMouseListener(borderListener);\n+    frame.addMouseMotionListener(borderListener);\n+    frame.addInternalFrameListener(internalFrameListener);\n+    frame.addPropertyChangeListener(propertyChangeListener);\n+\n+    frame.getRootPane().getGlassPane().addMouseListener(glassPaneDispatcher);\n+    frame.getRootPane().getGlassPane().addMouseMotionListener(glassPaneDispatcher);\n+  }\n+\n+  /**\n+   * This method uninstalls the defaults for the JInternalFrame.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    frame.setBorder(null);\n+  }\n+\n+  /**\n+   * This method uninstalls the Components for the JInternalFrame.\n+   */\n+  protected void uninstallComponents()\n+  {\n+    setNorthPane(null);\n+    setSouthPane(null);\n+    setEastPane(null);\n+    setWestPane(null);\n+  }\n+\n+  /**\n+   * This method uninstalls the listeners for the JInternalFrame.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    if (desktopPane != null)\n+      desktopPane.removeComponentListener(componentListener);\n+\n+    frame.getRootPane().getGlassPane().removeMouseMotionListener(glassPaneDispatcher);\n+    frame.getRootPane().getGlassPane().removeMouseListener(glassPaneDispatcher);\n+\n+    frame.removePropertyChangeListener(propertyChangeListener);\n+    frame.removeInternalFrameListener(internalFrameListener);\n+    frame.removeMouseMotionListener(borderListener);\n+    frame.removeMouseListener(borderListener);\n+\n+    propertyChangeListener = null;\n+    componentListener = null;\n+    borderListener = null;\n+    internalFrameListener = null;\n+    glassPaneDispatcher = null;\n+  }\n+\n+  /**\n+   * This method uninstalls the keyboard actions for the JInternalFrame.\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * This method creates a new LayoutManager for the JInternalFrame.\n+   *\n+   * @return A new LayoutManager for the JInternalFrame.\n+   */\n+  protected LayoutManager createLayoutManager()\n+  {\n+    return new InternalFrameLayout();\n+  }\n+\n+  /**\n+   * This method creates a new PropertyChangeListener for the JInternalFrame.\n+   *\n+   * @return A new PropertyChangeListener for the JInternalFrame.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new InternalFramePropertyChangeListener();\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the given JComponent.\n+   *\n+   * @param x The JComponent to find a preferred size for.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent x)\n+  {\n+    return internalFrameLayout.preferredLayoutSize(x);\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the given JComponent.\n+   *\n+   * @param x The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent x)\n+  {\n+    return getPreferredSize(x);\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the given JComponent.\n+   *\n+   * @param x The JComponent to find a maximum size for.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent x)\n+  {\n+    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * This method replaces the currentPane with the newPane. When replacing it\n+   * also removes the MouseHandlers for the old pane and installs  them on\n+   * the new pane.\n+   *\n+   * @param currentPane The old pane to remove.\n+   * @param newPane The new pane to install.\n+   */\n+  protected void replacePane(JComponent currentPane, JComponent newPane)\n+  {\n+    if (currentPane != null)\n+      {\n+\tdeinstallMouseHandlers(currentPane);\n+\tframe.remove(currentPane);\n+      }\n+\n+    if (newPane != null)\n+      {\n+\tinstallMouseHandlers(newPane);\n+\tframe.add(newPane);\n+      }\n+  }\n+\n+  /**\n+   * This method removes the necessary MouseListeners from the given\n+   * JComponent.\n+   *\n+   * @param c The JComponent to remove MouseListeners from.\n+   */\n+  protected void deinstallMouseHandlers(JComponent c)\n+  {\n+    c.removeMouseListener(borderListener);\n+    c.removeMouseMotionListener(borderListener);\n+  }\n+\n+  /**\n+   * This method installs the necessary MouseListeners from the given\n+   * JComponent.\n+   *\n+   * @param c The JComponent to install MouseListeners on.\n+   */\n+  protected void installMouseHandlers(JComponent c)\n+  {\n+    c.addMouseListener(borderListener);\n+    c.addMouseMotionListener(borderListener);\n+  }\n+\n+  /**\n+   * This method creates the north pane used in the JInternalFrame.\n+   *\n+   * @param w The JInternalFrame to create a north pane for.\n+   *\n+   * @return The north pane.\n+   */\n+  protected JComponent createNorthPane(JInternalFrame w)\n+  {\n+    titlePane = new BasicInternalFrameTitlePane(w);\n+    return titlePane;\n+  }\n+\n+  /**\n+   * This method creates the west pane used in the JInternalFrame.\n+   *\n+   * @param w The JInternalFrame to create a west pane for.\n+   *\n+   * @return The west pane.\n+   */\n+  protected JComponent createWestPane(JInternalFrame w)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method creates the south pane used in the JInternalFrame.\n+   *\n+   * @param w The JInternalFrame to create a south pane for.\n+   *\n+   * @return The south pane.\n+   */\n+  protected JComponent createSouthPane(JInternalFrame w)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method creates the east pane used in the JInternalFrame.\n+   *\n+   * @param w The JInternalFrame to create an east pane for.\n+   *\n+   * @return The east pane.\n+   */\n+  protected JComponent createEastPane(JInternalFrame w)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns a new BorderListener for the given JInternalFrame.\n+   *\n+   * @param w The JIntenalFrame to create a BorderListener for.\n+   *\n+   * @return A new BorderListener.\n+   */\n+  protected MouseInputAdapter createBorderListener(JInternalFrame w)\n+  {\n+    return new BorderListener();\n+  }\n+\n+  /**\n+   * This method creates a new InternalFrameListener for the JInternalFrame.\n+   */\n+  protected void createInternalFrameListener()\n+  {\n+    internalFrameListener = new BasicInternalFrameListener();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected final boolean isKeyBindingRegistered()\n+  {\n+    // FIXME: Implement.\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param b DOCUMENT ME!\n+   */\n+  protected final void setKeyBindingRegistered(boolean b)\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public final boolean isKeyBindingActive()\n+  {\n+    // FIXME: Implement.\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param b DOCUMENT ME!\n+   */\n+  protected final void setKeyBindingActive(boolean b)\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void setupMenuOpenKey()\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void setupMenuCloseKey()\n+  {\n+    // FIXME: Implement.\n+  }\n+\n+  /**\n+   * This method returns the north pane.\n+   *\n+   * @return The north pane.\n+   */\n+  public JComponent getNorthPane()\n+  {\n+    return northPane;\n+  }\n+\n+  /**\n+   * This method sets the north pane to be the given JComponent.\n+   *\n+   * @param c The new north pane.\n+   */\n+  public void setNorthPane(JComponent c)\n+  {\n+    replacePane(northPane, c);\n+    northPane = c;\n+  }\n+\n+  /**\n+   * This method returns the south pane.\n+   *\n+   * @return The south pane.\n+   */\n+  public JComponent getSouthPane()\n+  {\n+    return southPane;\n+  }\n+\n+  /**\n+   * This method sets the south pane to be the given JComponent.\n+   *\n+   * @param c The new south pane.\n+   */\n+  public void setSouthPane(JComponent c)\n+  {\n+    replacePane(southPane, c);\n+    southPane = c;\n+  }\n+\n+  /**\n+   * This method sets the east pane to be the given JComponent.\n+   *\n+   * @param c The new east pane.\n+   */\n+  public void setEastPane(JComponent c)\n+  {\n+    replacePane(eastPane, c);\n+    eastPane = c;\n+  }\n+\n+  /**\n+   * This method returns the east pane.\n+   *\n+   * @return The east pane.\n+   */\n+  public JComponent getEastPane()\n+  {\n+    return eastPane;\n+  }\n+\n+  /**\n+   * This method sets the west pane to be the given JComponent.\n+   *\n+   * @param c The new west pane.\n+   */\n+  public void setWestPane(JComponent c)\n+  {\n+    replacePane(westPane, c);\n+    westPane = c;\n+  }\n+\n+  /**\n+   * This method returns the west pane.\n+   *\n+   * @return The west pane.\n+   */\n+  public JComponent getWestPane()\n+  {\n+    return westPane;\n+  }\n+\n+  /**\n+   * This method returns the DesktopManager to use with the JInternalFrame.\n+   *\n+   * @return The DesktopManager to use with the JInternalFrame.\n+   */\n+  protected DesktopManager getDesktopManager()\n+  {\n+    DesktopManager value = frame.getDesktopPane().getDesktopManager();\n+    if (value == null)\n+      value = createDesktopManager();\n+    return value;\n+  }\n+\n+  /**\n+   * This method returns a default DesktopManager that can be used with this\n+   * JInternalFrame.\n+   *\n+   * @return A default DesktopManager that can be used with this\n+   *         JInternalFrame.\n+   */\n+  protected DesktopManager createDesktopManager()\n+  {\n+    return new DefaultDesktopManager();\n+  }\n+\n+  /**\n+   * This is a convenience method that closes the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to close.\n+   */\n+  protected void closeFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().closeFrame(f);\n+  }\n+\n+  /**\n+   * This is a convenience method that maximizes the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to maximize.\n+   */\n+  protected void maximizeFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().maximizeFrame(f);\n+  }\n+\n+  /**\n+   * This is a convenience method that minimizes the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to minimize.\n+   */\n+  protected void minimizeFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().minimizeFrame(f);\n+  }\n+\n+  /**\n+   * This is a convenience method that iconifies the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to iconify.\n+   */\n+  protected void iconifyFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().iconifyFrame(f);\n+  }\n+\n+  /**\n+   * This is a convenience method that deiconifies the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to deiconify.\n+   */\n+  protected void deiconifyFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().deiconifyFrame(f);\n+  }\n+\n+  /**\n+   * This is a convenience method that activates the JInternalFrame.\n+   *\n+   * @param f The JInternalFrame to activate.\n+   */\n+  protected void activateFrame(JInternalFrame f)\n+  {\n+    getDesktopManager().activateFrame(f);\n+  }\n+\n+  /**\n+   * This method returns a new ComponentListener for the JDesktopPane.\n+   *\n+   * @return A new ComponentListener.\n+   */\n+  protected ComponentListener createComponentListener()\n+  {\n+    return new ComponentHandler();\n+  }\n+\n+  /**\n+   * This method returns a new GlassPaneDispatcher.\n+   *\n+   * @return A new GlassPaneDispatcher.\n+   */\n+  protected MouseInputListener createGlassPaneDispatcher()\n+  {\n+    return new GlassPaneDispatcher();\n+  }\n+}"}, {"sha": "0da43dd9a3914e926303795291a34434cfb6c44e", "filename": "libjava/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -110,6 +110,7 @@ protected void initClassDefaults(UIDefaults defaults)\n       \"DesktopIconUI\", \"javax.swing.plaf.basic.BasicDesktopIconUI\",\n       \"DesktopPaneUI\", \"javax.swing.plaf.basic.BasicDesktopPaneUI\",\n       \"EditorPaneUI\", \"javax.swing.plaf.basic.BasicEditorPaneUI\",\n+      \"FormattedTextFieldUI\", \"javax.swing.plaf.basic.BasicFormattedTextFieldUI\",\n       \"InternalFrameUI\", \"javax.swing.plaf.basic.BasicInternalFrameUI\",\n       \"LabelUI\", \"javax.swing.plaf.basic.BasicLabelUI\",\n       \"ListUI\", \"javax.swing.plaf.basic.BasicListUI\",\n@@ -205,15 +206,15 @@ protected void loadSystemColors(UIDefaults defaults, String[] value1,\n   private void loadResourceBundle(UIDefaults defaults)\n   {\n     ResourceBundle bundle;\n-    Enumeration enum;\n+    Enumeration e;\n     String key;\n     String value;\n     bundle = ResourceBundle.getBundle(\"resources/basic\");\n     // Process Resources\n-    enum = bundle.getKeys();\n-    while (enum.hasMoreElements())\n+    e = bundle.getKeys();\n+    while (e.hasMoreElements())\n       {\n-        key = (String) enum.nextElement();\n+        key = (String) e.nextElement();\n         value = bundle.getString(key);\n         defaults.put(key, value);\n       }\n@@ -346,7 +347,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"ctrl F10\", \"maximize\",\n         \"ctrl alt shift F6\",\"selectPreviousFrame\"\n       }),\n-      \"Desktop.background\", new ColorUIResource(0, 92, 92),\n+      \"Desktop.background\", new ColorUIResource(175, 163, 236),\n       \"DesktopIcon.border\", new BorderUIResource.CompoundBorderUIResource(null,\n                                                                           null),\n       \"EditorPane.background\", new ColorUIResource(Color.white),\n@@ -419,16 +420,16 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"FocusManagerClassName\", \"TODO\",\n       \"FormView.resetButtonText\", \"Reset\",\n       \"FormView.submitButtonText\", \"Submit Query\",\n-      \"InternalFrame.activeTitleBackground\", new ColorUIResource(lightPurple),\n+      \"InternalFrame.activeTitleBackground\", new ColorUIResource(162, 167, 241),\n       \"InternalFrame.activeTitleForeground\", new ColorUIResource(Color.black),\n       \"InternalFrame.border\", new BorderUIResource.CompoundBorderUIResource(null,\n                                                                             null),\n       \"InternalFrame.closeIcon\", BasicIconFactory.createEmptyFrameIcon(),\n       // XXX Don't use gif\n       \"InternalFrame.icon\", new IconUIResource(new ImageIcon(\"icons/JavaCup.gif\")),\n       \"InternalFrame.iconifyIcon\", BasicIconFactory.createEmptyFrameIcon(),\n-      \"InternalFrame.inactiveTitleBackground\", new ColorUIResource(Color.gray),\n-      \"InternalFrame.inactiveTitleForeground\", new ColorUIResource(Color.lightGray),\n+      \"InternalFrame.inactiveTitleBackground\", new ColorUIResource(Color.lightGray),\n+      \"InternalFrame.inactiveTitleForeground\", new ColorUIResource(Color.black),\n       \"InternalFrame.maximizeIcon\", BasicIconFactory.createEmptyFrameIcon(),\n       \"InternalFrame.minimizeIcon\", BasicIconFactory.createEmptyFrameIcon(),\n       \"InternalFrame.titleFont\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n@@ -703,7 +704,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"ctrl UP\", \"requestFocus\",\n         \"ctrl KP_UP\", \"requestFocus\"\n       }),\n-      \"TabbedPane.background\", new ColorUIResource(Color.GRAY),\n+      \"TabbedPane.background\", new ColorUIResource(Color.LIGHT_GRAY),\n       \"TabbedPane.contentBorderInsets\", new InsetsUIResource(2, 2, 3, 3),\n       \"TabbedPane.darkShadow\", new ColorUIResource(Color.darkGray),\n       \"TabbedPane.focus\", new ColorUIResource(Color.black),"}, {"sha": "cff8a011cbcc0a65012aed86036080d02d0864b6", "filename": "libjava/javax/swing/plaf/basic/BasicMenuBarUI.java", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n-/* BasicMenuUI.java\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+/* BasicMenuBarUI.java --\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,11 +37,13 @@\n \n package javax.swing.plaf.basic;\n \n+import java.awt.Dimension;\n+import java.awt.GridLayout;\n+import java.awt.Insets;\n import java.awt.event.ContainerEvent;\n import java.awt.event.ContainerListener;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n-import java.awt.Dimension;\n import javax.swing.BoxLayout;\n import javax.swing.ButtonModel;\n import javax.swing.Icon;\n@@ -70,18 +72,22 @@\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.MenuBarUI;\n import javax.swing.plaf.MenuItemUI;\n-import java.awt.Insets;\n-import java.awt.GridLayout;\n \n \n /**\n- * DOCUMENT ME!\n+ * UI Delegate for JMenuBar.\n  */\n public class BasicMenuBarUI extends MenuBarUI\n {\n   protected ChangeListener changeListener;\n+\n+  /*ContainerListener that listens to the ContainerEvents fired from menu bar*/\n   protected ContainerListener containerListener;\n+\n+  /*Property change listeners that listener to PropertyChangeEvent from menu bar*/\n   protected PropertyChangeListener propertyChangeListener;\n+\n+  /* menu bar for which this UI delegate is for*/\n   protected JMenuBar menuBar;\n \n   /**\n@@ -105,33 +111,35 @@ protected ChangeListener createChangeListener()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates ContainerListener() to listen for ContainerEvents\n+   * fired by JMenuBar\n    *\n-   * @return DOCUMENT ME!\n+   * @return The ContainerListener\n    */\n-  protected ContainerListener  createContainerListener()\n+  protected ContainerListener createContainerListener()\n   {\n     return new ContainerHandler();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Factory method to create a BasicMenuBarUI for the given {@link\n+   * JComponent}, which should be a {@link JMenuBar}.\n    *\n-   * @param x DOCUMENT ME!\n+   * @param b The {@link JComponent} a UI is being created for.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A BasicMenuBarUI for the {@link JComponent}.\n    */\n   public static ComponentUI createUI(JComponent x)\n   {\n     return new BasicMenuBarUI();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns maximum size for the specified menu bar\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c component for which to get maximum size\n    *\n-   * @return DOCUMENT ME!\n+   * @return  Maximum size for the specified menu bar\n    */\n   public Dimension getMaximumSize(JComponent c)\n   {\n@@ -140,11 +148,11 @@ public Dimension getMaximumSize(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns maximum allowed size of JMenuBar.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c menuBar for which to return maximum size\n    *\n-   * @return DOCUMENT ME!\n+   * @return Maximum size of the give menu bar.\n    */\n   public Dimension getMinimumSize(JComponent c)\n   {\n@@ -153,11 +161,11 @@ public Dimension getMinimumSize(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns preferred size of JMenuBar.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c menuBar for which to return preferred size\n    *\n-   * @return DOCUMENT ME!\n+   * @return Preferred size of the give menu bar.\n    */\n   public Dimension getPreferredSize(JComponent c)\n   {\n@@ -166,7 +174,8 @@ public Dimension getPreferredSize(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Initializes any default properties that this UI has from the defaults for\n+   * the Basic look and feel.\n    */\n   protected void installDefaults()\n   {\n@@ -179,37 +188,42 @@ protected void installDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the keyboard actions for the JMenuBar.\n    */\n   protected void installKeyboardActions()\n   {\n+    // FIXME: implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the listeners needed for this UI to function.\n    */\n   protected void installListeners()\n-  {        \n+  {\n     menuBar.addContainerListener(containerListener);\n-    menuBar.addPropertyChangeListener(propertyChangeListener);    \n+    menuBar.addPropertyChangeListener(propertyChangeListener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @param c DOCUMENT ME!\n-   */\n+  * Installs and initializes all fields for this UI delegate. Any properties\n+  * of the UI that need to be initialized and/or set to defaults will be\n+  * done now. It will also install any listeners necessary.\n+  *\n+  * @param c The {@link JComponent} that is having this UI installed.\n+  */\n   public void installUI(JComponent c)\n   {\n     super.installUI(c);\n     menuBar = (JMenuBar) c;\n     menuBar.setLayout(new BoxLayout(menuBar, BoxLayout.X_AXIS));\n     installDefaults();\n     installListeners();\n+    installKeyboardActions();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method uninstalls the defaults and nulls any objects created during\n+   * install.\n    */\n   protected void uninstallDefaults()\n   {\n@@ -220,10 +234,11 @@ protected void uninstallDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method reverses the work done in installKeyboardActions.\n    */\n   protected void uninstallKeyboardActions()\n   {\n+    // FIXME: implement. \n   }\n \n   /**\n@@ -236,15 +251,18 @@ protected void uninstallListeners()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Performs the opposite of installUI. Any properties or resources that need\n+   * to be cleaned up will be done now. It will also uninstall any listeners\n+   * it has. In addition, any properties of this UI will be nulled.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} that is having this UI uninstalled.\n    */\n   public void uninstallUI(JComponent c)\n   {\n     uninstallDefaults();\n-    uninstallListeners();    \n-    menuBar= null;\n+    uninstallListeners();\n+    uninstallKeyboardActions();\n+    menuBar = null;\n   }\n \n   protected class ChangeHandler implements ChangeListener\n@@ -254,21 +272,47 @@ public void stateChanged(ChangeEvent event)\n     }\n   }\n \n+  /**\n+   * This class handles ContainerEvents fired by JMenuBar\n+   */\n   protected class ContainerHandler implements ContainerListener\n   {\n+    /**\n+     * This method is called whenever menu is added to the menu bar\n+     *\n+     * @param e The ContainerEvent.\n+     */\n     public void componentAdded(ContainerEvent e)\n     {\n+      System.out.println(\"BasicMenuBar...componentAdded.. listener\");\n     }\n \n+    /**\n+     * This method is called whenever menu is removed from the menu bar\n+     *\n+     * @param e The ContainerEvent.\n+     */\n     public void componentRemoved(ContainerEvent e)\n     {\n+      System.out.println(\"BasicMenuBar...componentRemoved.. listener\");\n     }\n   }\n \n+  /**\n+   * This class handles PropertyChangeEvents fired from the JMenuBar\n+   */\n   protected class PropertyChangeHandler implements PropertyChangeListener\n   {\n+    /**\n+     * This method is called whenever one of the properties of the MenuBar\n+     * changes.\n+     *\n+     * @param e The PropertyChangeEvent.\n+     */\n     public void propertyChange(PropertyChangeEvent e)\n     {\n+      if (e.getPropertyName().equals(JMenuBar.BORDER_PAINTED_CHANGED_PROPERTY))\n+\tmenuBar.repaint();\n     }\n   }\n }"}, {"sha": "e5e407a55bbd1d26a1172be68f686612ba17f89c", "filename": "libjava/javax/swing/plaf/basic/BasicMenuItemUI.java", "status": "modified", "additions": 227, "deletions": 164, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd", "patch": "@@ -1,5 +1,5 @@\n-/* BasicMenuItemUI.java\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+/* BasicMenuItemUI.java --\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n@@ -43,12 +44,15 @@\n import java.awt.Font;\n import java.awt.FontMetrics;\n import java.awt.Graphics;\n+import java.awt.Insets;\n import java.awt.Rectangle;\n+import java.awt.Stroke;\n import java.awt.event.InputEvent;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n+import java.util.ArrayList;\n import java.util.Vector;\n import javax.swing.AbstractButton;\n import javax.swing.ButtonModel;\n@@ -75,7 +79,7 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * UI Delegate for JMenuItem.\n  */\n public class BasicMenuItemUI extends MenuItemUI\n {\n@@ -156,13 +160,20 @@ public class BasicMenuItemUI extends MenuItemUI\n    * String that separates description of the modifiers and the key\n    */\n   private String acceleratorDelimiter;\n+\n+  /**\n+   * PropertyChangeListener to listen for property changes in the menu item\n+   */\n   private PropertyChangeListener propertyChangeListener;\n \n   /**\n    * Number of spaces between accelerator and menu item's label.\n    */\n   private int defaultAcceleratorLabelGap = 4;\n \n+  /**\n+   * Creates a new BasicMenuItemUI object.\n+   */\n   public BasicMenuItemUI()\n   {\n     mouseInputListener = createMouseInputListener(menuItem);\n@@ -171,51 +182,60 @@ public BasicMenuItemUI()\n     propertyChangeListener = new PropertyChangeHandler();\n   }\n \n+  /**\n+   * Create MenuDragMouseListener to listen for mouse dragged events.\n+   *\n+   * @param c menu item to listen to\n+   *\n+   * @return The MenuDragMouseListener\n+   */\n   protected MenuDragMouseListener createMenuDragMouseListener(JComponent c)\n   {\n     return new MenuDragMouseHandler();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates MenuKeyListener to listen to key events occuring when menu item\n+   * is visible on the screen.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c menu item to listen to\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return The MenuKeyListener\n    */\n   protected MenuKeyListener createMenuKeyListener(JComponent c)\n   {\n     return new MenuKeyHandler();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Handles mouse input events occuring for this menu item\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c menu item to listen to\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return The MouseInputListener\n    */\n   protected MouseInputListener createMouseInputListener(JComponent c)\n   {\n     return new MouseInputHandler();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Factory method to create a BasicMenuItemUI for the given {@link\n+   * JComponent}, which should be a {@link JMenuItem}.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} a UI is being created for.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return A BasicMenuItemUI for the {@link JComponent}.\n    */\n   public static ComponentUI createUI(JComponent c)\n   {\n     return new BasicMenuItemUI();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Programatically clicks menu item.\n    *\n-   * @param msm DOCUMENT ME!\n+   * @param msm MenuSelectionManager for the menu hierarchy\n    */\n   protected void doClick(MenuSelectionManager msm)\n   {\n@@ -224,96 +244,94 @@ protected void doClick(MenuSelectionManager msm)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns maximum size for the specified menu item\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c component for which to get maximum size\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return Maximum size for the specified menu item.\n    */\n   public Dimension getMaximumSize(JComponent c)\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns minimum size for the specified menu item\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c component for which to get minimum size\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return Minimum size for the specified menu item.\n    */\n   public Dimension getMinimumSize(JComponent c)\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns path to this menu item.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $MenuElement[]$ Returns array of menu elements\n+   * that constitute a path to this menu item.\n    */\n   public MenuElement[] getPath()\n   {\n-    Vector path = new Vector();\n+    ArrayList path = new ArrayList();\n     Component c = menuItem;\n     while (c instanceof MenuElement)\n       {\n-\tpath.add(c);\n+\tpath.add(0, (MenuElement) c);\n \n \tif (c instanceof JPopupMenu)\n \t  c = ((JPopupMenu) c).getInvoker();\n \telse\n \t  c = c.getParent();\n       }\n \n-    // convert from vector to array\n     MenuElement[] pathArray = new MenuElement[path.size()];\n-    for (int i = 0; i < path.size(); i++)\n-      pathArray[i] = (MenuElement) path.get(path.size() - i - 1);\n-\n+    path.toArray(pathArray);\n     return pathArray;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns preferred size for the given menu item.\n    *\n-   * @param c DOCUMENT ME!\n-   * @param checkIcon DOCUMENT ME!\n-   * @param arrowIcon DOCUMENT ME!\n-   * @param defaultTextIconGap DOCUMENT ME!\n+   * @param c menu item for which to get preferred size\n+   * @param checkIcon chech icon displayed in the given menu item\n+   * @param arrowIcon arrow icon displayed in the given menu item\n+   * @param defaultTextIconGap space between icon and text in the given menuItem\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $Dimension$ preferred size for the given menu item\n    */\n   protected Dimension getPreferredMenuItemSize(JComponent c, Icon checkIcon,\n                                                Icon arrowIcon,\n                                                int defaultTextIconGap)\n   {\n-    // TODO\n+    // FIXME: Need to implement.\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns preferred size of the given component\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c component for which to return preferred size\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $Dimension$ preferred size for the given component\n    */\n   public Dimension getPreferredSize(JComponent c)\n   {\n-    AbstractButton b = (AbstractButton) c;\n-    Dimension d = BasicGraphicsUtils.getPreferredButtonSize(b,\n+    JMenuItem m = (JMenuItem) c;\n+    Dimension d = BasicGraphicsUtils.getPreferredButtonSize(m,\n                                                             defaultTextIconGap);\n \n     // if menu item has accelerator then take accelerator's size into account\n     // when calculating preferred size.\n-    KeyStroke accelerator = ((JMenuItem) c).getAccelerator();\n+    KeyStroke accelerator = m.getAccelerator();\n     Rectangle rect;\n \n     if (accelerator != null)\n       {\n \trect = getAcceleratorRect(accelerator,\n-\t                          b.getToolkit().getFontMetrics(acceleratorFont));\n+\t                          m.getToolkit().getFontMetrics(acceleratorFont));\n \n \t// add width of accelerator's text\n \td.width = d.width + rect.width + defaultAcceleratorLabelGap;\n@@ -349,22 +367,22 @@ public Dimension getPreferredSize(JComponent c)\n    */\n   protected String getPropertyPrefix()\n   {\n-    // TODO\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the components for this {@link JMenuItem}.\n    *\n-   * @param menuItem DOCUMENT ME!\n+   * @param menuItem The {@link JMenuItem} to install components for.\n    */\n   protected void installComponents(JMenuItem menuItem)\n   {\n-    // TODO\n+    // FIXME: Need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the defaults that are defined in  the Basic look and\n+   * feel for this {@link JMenuItem}.\n    */\n   protected void installDefaults()\n   {\n@@ -376,7 +394,6 @@ protected void installDefaults()\n     menuItem.setForeground(defaults.getColor(\"MenuItem.foreground\"));\n     menuItem.setMargin(defaults.getInsets(\"MenuItem.margin\"));\n     menuItem.setOpaque(true);\n-\n     acceleratorFont = defaults.getFont(\"MenuItem.acceleratorFont\");\n     acceleratorForeground = defaults.getColor(\"MenuItem.acceleratorForeground\");\n     acceleratorSelectionForeground = defaults.getColor(\"MenuItem.acceleratorSelectionForeground\");\n@@ -386,15 +403,15 @@ protected void installDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the keyboard actions for this {@link JMenuItem}.\n    */\n   protected void installKeyboardActions()\n   {\n-    // TODO\n+    // FIXME: Need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the listeners for the {@link JMenuItem}.\n    */\n   protected void installListeners()\n   {\n@@ -405,9 +422,11 @@ protected void installListeners()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Installs and initializes all fields for this UI delegate. Any properties\n+   * of the UI that need to be initialized and/or set to defaults will be\n+   * done now. It will also install any listeners necessary.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} that is having this UI installed.\n    */\n   public void installUI(JComponent c)\n   {\n@@ -418,10 +437,10 @@ public void installUI(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints given menu item using specified graphics context\n    *\n-   * @param g DOCUMENT ME!\n-   * @param c DOCUMENT ME!\n+   * @param g The graphics context used to paint this menu item\n+   * @param c Menu Item to paint\n    */\n   public void paint(Graphics g, JComponent c)\n   {\n@@ -430,11 +449,11 @@ public void paint(Graphics g, JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints background of the menu item\n    *\n-   * @param g DOCUMENT ME!\n-   * @param menuItem DOCUMENT ME!\n-   * @param bgColor DOCUMENT ME!\n+   * @param g The graphics context used to paint this menu item\n+   * @param menuItem menu item to paint\n+   * @param bgColor Background color to use when painting menu item\n    */\n   protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n   {\n@@ -446,63 +465,76 @@ protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints specified menu item\n    *\n-   * @param g DOCUMENT ME!\n-   * @param c DOCUMENT ME!\n-   * @param checkIcon DOCUMENT ME!\n-   * @param arrowIcon DOCUMENT ME!\n-   * @param background DOCUMENT ME!\n-   * @param foreground DOCUMENT ME!\n-   * @param defaultTextIconGap DOCUMENT ME!\n+   * @param g The graphics context used to paint this menu item\n+   * @param c menu item to paint\n+   * @param checkIcon check icon to use when painting menu item\n+   * @param arrowIcon arrow icon to use when painting menu item\n+   * @param background Background color of the menu item\n+   * @param foreground Foreground color of the menu item\n+   * @param defaultTextIconGap space to use between icon and\n+   *  text when painting menu item\n    */\n   protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n                                Icon arrowIcon, Color background,\n                                Color foreground, int defaultTextIconGap)\n   {\n-    AbstractButton b = (AbstractButton) c;\n+    JMenuItem m = (JMenuItem) c;\n     Rectangle tr = new Rectangle(); // text rectangle\n     Rectangle ir = new Rectangle(); // icon rectangle\n     Rectangle vr = new Rectangle(); // view rectangle\n     Rectangle br = new Rectangle(); // border rectangle\n     Rectangle ar = new Rectangle(); // accelerator rectangle\n     Rectangle cr = new Rectangle(); // checkIcon rectangle\n \n-    int vertAlign = b.getVerticalAlignment();\n-    int horAlign = b.getHorizontalAlignment();\n-    int vertTextPos = b.getVerticalTextPosition();\n-    int horTextPos = b.getHorizontalTextPosition();\n+    int vertAlign = m.getVerticalAlignment();\n+    int horAlign = m.getHorizontalAlignment();\n+    int vertTextPos = m.getVerticalTextPosition();\n+    int horTextPos = m.getHorizontalTextPosition();\n \n-    Font f = c.getFont();\n+    Font f = m.getFont();\n     g.setFont(f);\n     FontMetrics fm = g.getFontMetrics(f);\n-    SwingUtilities.calculateInnerArea(b, br);\n-    SwingUtilities.calculateInsetArea(br, b.getMargin(), vr);\n-    paintBackground(g, (JMenuItem) c, c.getBackground());\n-\n-    if ((b.getModel().isArmed() && b.getModel().isPressed()))\n+    SwingUtilities.calculateInnerArea(m, br);\n+    SwingUtilities.calculateInsetArea(br, m.getInsets(), vr);\n+    paintBackground(g, m, m.getBackground());\n+\n+    /* MenuItems insets are equal to menuItems margin, space between text and\n+       menuItems border. We need to paint insets region as well. */\n+    Insets insets = m.getInsets();\n+    br.x -= insets.left;\n+    br.y -= insets.top;\n+    br.width += insets.right + insets.left;\n+    br.height += insets.top + insets.bottom;\n+\n+    /* Menu item is considered to be highlighted when it is selected.\n+       It is considered to be selected if menu item is inside some menu\n+       and is armed or if it is both armed and pressed */\n+    if (m.getModel().isArmed()\n+        && (m.getParent() instanceof MenuElement || m.getModel().isPressed()))\n       {\n-\tif (((AbstractButton) b).isContentAreaFilled())\n+\tif (m.isContentAreaFilled())\n \t  {\n-\t    g.setColor(b.getBackground().darker());\n+\t    g.setColor(m.getBackground().darker());\n \t    g.fillRect(br.x, br.y, br.width, br.height);\n \t  }\n       }\n     else\n       {\n-\tif (((AbstractButton) b).isContentAreaFilled())\n+\tif (m.isContentAreaFilled())\n \t  {\n-\t    g.setColor(b.getBackground());\n+\t    g.setColor(m.getBackground());\n \t    g.fillRect(br.x, br.y, br.width, br.height);\n \t  }\n       }\n \n     if (checkIcon != null)\n       {\n-\tSwingUtilities.layoutCompoundLabel(c, fm, null, checkIcon, vertAlign,\n+\tSwingUtilities.layoutCompoundLabel(m, fm, null, checkIcon, vertAlign,\n \t                                   horAlign, vertTextPos, horTextPos,\n \t                                   vr, cr, tr, defaultTextIconGap);\n-\tcheckIcon.paintIcon(c, g, cr.x, cr.y);\n+\tcheckIcon.paintIcon(m, g, cr.x, cr.y);\n \n \t// We need to calculate position of the menu text and position of\n \t// user menu icon if there exists one relative to the check icon.\n@@ -518,25 +550,25 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n \t    int width = arrowIcon.getIconWidth();\n \t    int height = arrowIcon.getIconHeight();\n \n-\t    arrowIcon.paintIcon(c, g, vr.width - width + defaultTextIconGap,\n+\t    arrowIcon.paintIcon(m, g, vr.width - width + defaultTextIconGap,\n \t                        vr.y + 2);\n \t  }\n       }\n \n     // paint text and user menu icon if it exists\t     \n-    SwingUtilities.layoutCompoundLabel(c, fm, b.getText(), b.getIcon(),\n+    SwingUtilities.layoutCompoundLabel(c, fm, m.getText(), m.getIcon(),\n                                        vertAlign, horAlign, vertTextPos,\n                                        horTextPos, vr, ir, tr,\n                                        defaultTextIconGap);\n \n-    paintText(g, (JMenuItem) c, tr, b.getText());\n+    paintText(g, m, tr, m.getText());\n \n     // paint icon\n     // FIXME: should paint different icon at different button state's.\n     // i.e disabled icon when button is disabled.. etc.\n \n     /*\n-    Icon i = b.getIcon();\n+    Icon i = m.getIcon();\n     if (i != null)\n       {\n          int x = ir.x;\n@@ -548,30 +580,31 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n     // paint accelerator    \n     String acceleratorText = \"\";\n \n-    if (((JMenuItem) c).getAccelerator() != null)\n+    if (m.getAccelerator() != null)\n       {\n-\tacceleratorText = getAcceleratorText(((JMenuItem) c).getAccelerator());\n+\tacceleratorText = getAcceleratorText(m.getAccelerator());\n \tfm = g.getFontMetrics(acceleratorFont);\n \tar.width = fm.stringWidth(acceleratorText);\n \tar.x = br.width - ar.width;\n \tvr.x = br.width - ar.width;\n \n-\tSwingUtilities.layoutCompoundLabel(c, fm, acceleratorText, null,\n+\tSwingUtilities.layoutCompoundLabel(m, fm, acceleratorText, null,\n \t                                   vertAlign, horAlign, vertTextPos,\n \t                                   horTextPos, vr, ir, ar,\n \t                                   defaultTextIconGap);\n \n-\tpaintAccelerator(g, (JMenuItem) c, ar, acceleratorText);\n+\tpaintAccelerator(g, m, ar, acceleratorText);\n       }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints label for the given menu item\n    *\n-   * @param g DOCUMENT ME!\n-   * @param menuItem DOCUMENT ME!\n-   * @param textRect DOCUMENT ME!\n-   * @param text DOCUMENT ME!\n+   * @param g The graphics context used to paint this menu item\n+   * @param menuItem menu item for which to draw its label\n+   * @param textRect rectangle specifiying position of the text relative to\n+   * the given menu item\n+   * @param text label of the menu item\n    */\n   protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n                            String text)\n@@ -586,17 +619,18 @@ protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method uninstalls the components for this {@link JMenuItem}.\n    *\n-   * @param menuItem DOCUMENT ME!\n+   * @param menuItem The {@link JMenuItem} to uninstall components for.\n    */\n   protected void uninstallComponents(JMenuItem menuItem)\n   {\n-    // TODO\n+    // FIXME: need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method uninstalls the defaults and sets any objects created during\n+   * install to null\n    */\n   protected void uninstallDefaults()\n   {\n@@ -619,15 +653,15 @@ protected void uninstallDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Uninstalls any keyboard actions.\n    */\n   protected void uninstallKeyboardActions()\n   {\n-    // TODO\n+    // FIXME: need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Unregisters all the listeners that this UI delegate was using.\n    */\n   protected void uninstallListeners()\n   {\n@@ -638,9 +672,11 @@ protected void uninstallListeners()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Performs the opposite of installUI. Any properties or resources that need\n+   * to be cleaned up will be done now. It will also uninstall any listeners\n+   * it has. In addition, any properties of this UI will be nulled.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} that is having this UI uninstalled.\n    */\n   public void uninstallUI(JComponent c)\n   {\n@@ -650,22 +686,22 @@ public void uninstallUI(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method calls paint.\n    *\n-   * @param g DOCUMENT ME!\n-   * @param c DOCUMENT ME!\n+   * @param g The graphics context used to paint this menu item\n+   * @param c The menu item to paint\n    */\n   public void update(Graphics g, JComponent c)\n   {\n     paint(g, c);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return text representation of the specified accelerator\n    *\n-   * @param accelerator DOCUMENT ME!\n+   * @param accelerator Accelerator for which to return string representation\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $String$ Text representation of the given accelerator\n    */\n   private String getAcceleratorText(KeyStroke accelerator)\n   {\n@@ -686,12 +722,12 @@ private String getAcceleratorText(KeyStroke accelerator)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Calculates and return rectange in which accelerator should be displayed\n    *\n-   * @param accelerator DOCUMENT ME!\n-   * @param fm DOCUMENT ME!\n+   * @param accelerator accelerator for which to return the display rectangle\n+   * @param fm The font metrics used to measure the text\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $Rectangle$ reactangle which will be used to display accelerator\n    */\n   private Rectangle getAcceleratorRect(KeyStroke accelerator, FontMetrics fm)\n   {\n@@ -701,12 +737,13 @@ private Rectangle getAcceleratorRect(KeyStroke accelerator, FontMetrics fm)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Paints accelerator inside menu item\n    *\n-   * @param g DOCUMENT ME!\n-   * @param menuItem DOCUMENT ME!\n-   * @param acceleratorRect DOCUMENT ME!\n-   * @param acceleratorText DOCUMENT ME!\n+   * @param g The graphics context used to paint the border\n+   * @param menuItem Menu item for which to draw accelerator\n+   * @param acceleratorRect rectangle representing position\n+   * of the accelerator relative to the menu item\n+   * @param acceleratorText accelerator's text\n    */\n   private void paintAccelerator(Graphics g, JMenuItem menuItem,\n                                 Rectangle acceleratorRect,\n@@ -720,7 +757,10 @@ private void paintAccelerator(Graphics g, JMenuItem menuItem,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This class handles mouse events occuring inside the menu item.\n+   * Most of the events are forwarded for processing to MenuSelectionManager\n+   * of the current menu hierarchy.\n+   *\n    */\n   protected class MouseInputHandler implements MouseInputListener\n   {\n@@ -732,9 +772,10 @@ protected MouseInputHandler()\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse is clicked on the menu item.\n+     * It forwards this event to MenuSelectionManager.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseClicked(MouseEvent e)\n     {\n@@ -743,9 +784,10 @@ public void mouseClicked(MouseEvent e)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse is dragged inside the menu item.\n+     * It forwards this event to MenuSelectionManager.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseDragged(MouseEvent e)\n     {\n@@ -754,20 +796,29 @@ public void mouseDragged(MouseEvent e)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse enters menu item.\n+     * When this happens menu item is considered to be selected and selection path\n+     * in MenuSelectionManager is set. This event is also forwarded to MenuSelection\n+     * Manager for further processing.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseEntered(MouseEvent e)\n     {\n-      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n-      manager.processMouseEvent(e);\n+      Component source = (Component) e.getSource();\n+      if (source.getParent() instanceof MenuElement)\n+        {\n+\t  MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+\t  manager.setSelectedPath(getPath());\n+\t  manager.processMouseEvent(e);\n+        }\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse exits menu item. The event is\n+     * forwarded to MenuSelectionManager for processing.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseExited(MouseEvent e)\n     {\n@@ -776,9 +827,10 @@ public void mouseExited(MouseEvent e)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse is inside the menu item.\n+     * This event is forwarder to MenuSelectionManager for further processing.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseMoved(MouseEvent e)\n     {\n@@ -787,9 +839,10 @@ public void mouseMoved(MouseEvent e)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse is pressed. This event is forwarded to\n+     * MenuSelectionManager for further processing.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mousePressed(MouseEvent e)\n     {\n@@ -798,105 +851,115 @@ public void mousePressed(MouseEvent e)\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is called when mouse is released. If the mouse is released\n+     * inside this menuItem, then this menu item is considered to be chosen and\n+     * the menu hierarchy should be closed.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MouseEvent}.\n      */\n     public void mouseReleased(MouseEvent e)\n     {\n-      // FIXME: Should check if the mouse released while mouse cursor\n-      // was indeed over the menu item. If this wasn't the case we probably \n-      // should sent this event to MenuSelectionManager. \n-      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n-      manager.clearSelectedPath();\n-      menuItem.doClick(0);\n+      Rectangle size = menuItem.getBounds(); //this.getParent().getSize();\n+      if (e.getX() > 0 && e.getX() < size.width && e.getY() > 0\n+          && e.getY() < size.height)\n+        {\n+\t  MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+\t  manager.clearSelectedPath();\n+\t  menuItem.doClick(0);\n+        }\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This class handles mouse dragged events.\n    */\n   protected class MenuDragMouseHandler implements MenuDragMouseListener\n   {\n     /**\n-     * DOCUMENT ME!\n+     * Tbis method is invoked when mouse is dragged over the menu item.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseDragged(MenuDragMouseEvent e)\n     {\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Tbis method is invoked when mouse enters the menu item while it is\n+     * being dragged.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseEntered(MenuDragMouseEvent e)\n     {\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Tbis method is invoked when mouse exits the menu item while\n+     * it is being dragged\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseExited(MenuDragMouseEvent e)\n     {\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Tbis method is invoked when mouse was dragged and released\n+     * inside the menu item.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseReleased(MenuDragMouseEvent e)\n     {\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This class handles key events occuring when menu item is visible on the\n+   * screen.\n    */\n   protected class MenuKeyHandler implements MenuKeyListener\n   {\n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when key has been pressed\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MenuKeyEvent}.\n      */\n     public void menuKeyPressed(MenuKeyEvent e)\n     {\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when key has been pressed\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MenuKeyEvent}.\n      */\n     public void menuKeyReleased(MenuKeyEvent e)\n     {\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when key has been typed\n+     * It handles the mnemonic key for the menu item.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e A {@link MenuKeyEvent}.\n      */\n     public void menuKeyTyped(MenuKeyEvent e)\n     {\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Helper class that listens for changes to the properties of the {@link\n+   * JMenuItem}.\n    */\n   protected class PropertyChangeHandler implements PropertyChangeListener\n   {\n     /**\n-     * DOCUMENT ME!\n+     * This method is called when one of the menu item's properties change.\n      *\n-     * @param evt DOCUMENT ME!\n+     * @param evt A {@link PropertyChangeEvent}.\n      */\n     public void propertyChange(PropertyChangeEvent evt)\n     {"}, {"sha": "1953f480a8e389133b87a41778a6408d127947f3", "filename": "libjava/javax/swing/plaf/basic/BasicMenuUI.java", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "a1adf01731c292cc94abb5fcd496ad250e52fb41", "filename": "libjava/javax/swing/plaf/basic/BasicPopupMenuSeparatorUI.java", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuSeparatorUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "d171917172f2abaf56b3d48ed3f32204d0513609", "filename": "libjava/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "b16f2a733e25f507f355abad4668d1a5d313fd78", "filename": "libjava/javax/swing/plaf/basic/BasicScrollBarUI.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "073e42c0fc10e2fb7b1cbef3fb3bba29a2c027d4", "filename": "libjava/javax/swing/plaf/basic/BasicSliderUI.java", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "b1929aa36d371bf917d1856300f46bf761c762b7", "filename": "libjava/javax/swing/plaf/basic/BasicTabbedPaneUI.java", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "af7ab7e3a9b8e42b78eed4ddfff52c1934288b0e", "filename": "libjava/javax/swing/plaf/basic/BasicTextUI.java", "status": "modified", "additions": 120, "deletions": 125, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "9e935a2766d0d3fbd48c8db022f102ee3bf43f5e", "filename": "libjava/javax/swing/plaf/basic/BasicToolBarUI.java", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "715c11a6845239edc16dbc3f651d938b757d6957", "filename": "libjava/javax/swing/plaf/basic/BasicViewportUI.java", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "18a8ea9e541a4bf384cb55941f0f9dec58d32b7f", "filename": "libjava/javax/swing/text/AbstractDocument.java", "status": "modified", "additions": 442, "deletions": 242, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "01463d139bdb51088402c4da53a9674c4f668169", "filename": "libjava/javax/swing/text/BadLocationException.java", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FBadLocationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FBadLocationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FBadLocationException.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "d79e920aa94465636f93eceb7a70241239d0731c", "filename": "libjava/javax/swing/text/DefaultCaret.java", "status": "modified", "additions": 176, "deletions": 124, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "6ecb7ca21db603e22916b3c585a3235114b3d45b", "filename": "libjava/javax/swing/text/Document.java", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "9344682686808b6709130f562898cf42455fa0c1", "filename": "libjava/javax/swing/text/GapContent.java", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FGapContent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FGapContent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FGapContent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "6451ef5c31ff3acab6bf39ed5c207557f66c8863", "filename": "libjava/javax/swing/text/JTextComponent.java", "status": "modified", "additions": 485, "deletions": 348, "changes": 833, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "d8cb62a7b264cd858f3297951f80f66267f432f2", "filename": "libjava/javax/swing/text/MutableAttributeSet.java", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FMutableAttributeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FMutableAttributeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FMutableAttributeSet.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "930e5d3cb5619d9b5617671bd938efc3394567f7", "filename": "libjava/javax/swing/text/PlainDocument.java", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "d8553c02c92629ca1688ade3e5a3e242127b92a7", "filename": "libjava/javax/swing/text/Style.java", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FStyle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjavax%2Fswing%2Ftext%2FStyle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FStyle.java?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "34d557131ec8fbfd0db04fbf6c8fdadd1c4be2a7", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "bb406c50c4960dd33676a2d516dada96bc04c050", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontMetrics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontMetrics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontMetrics.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "864e465871bb6cc49cf958a0592f4b34f98d0f82", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "97e49625cb70eec9c5404c4f0b14ce3a16d5ce86", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkPixbufDecoder.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "d9647e9ba100e68e8acdc01dfb140e1ec9f17479", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "f5d7cfb89aadf7dbb98067f42aa3be81da21cb9c", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "6f070f68b7418b05214ea0eb23b62c67d39b09f4", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "8fb619e2563f645c4ab167dae9f09bd6340e3838", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "93d30cb697651f257d37e26d57e2e46488d649fa", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "7cefd8dad07d7f139eacdef6b191b412115d6900", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "817bee7520082923968a545768ee46c81a4dd330", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "c9427d49dff956cdf5f7cd9761b58ec7a1f657e0", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "5bea49a3f3c15e1e67cc9b1ca46652017bebf5f1", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextFieldPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextFieldPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextFieldPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextFieldPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "29ff203d4e9e05ff3e691f38676068f0260056f0", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}, {"sha": "18c95102472284436ea31e9f9d519c5c584df606", "filename": "libjava/jni/gtk-peer/gtkpeer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfcdad172a0959dbbbbe5084b393ba8995c67dd/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h?ref=4dfcdad172a0959dbbbbe5084b393ba8995c67dd"}]}