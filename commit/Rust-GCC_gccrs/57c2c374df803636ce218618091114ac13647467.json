{"sha": "57c2c374df803636ce218618091114ac13647467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdjMmMzNzRkZjgwMzYzNmNlMjE4NjE4MDkxMTE0YWMxMzY0NzQ2Nw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-02-24T17:04:03Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-02-24T17:04:03Z"}, "message": "Avoid making unportable assumptions about the relationship between SIZE_MAX\nand UINT_MAX.\n\ngcc/testsuite/ChangeLog:\n        * gcc/testsuite/gcc.dg/builtins-68.c: Avoid making unportable\n        assumptions about the relationship between SIZE_MAX and UINT_MAX.\n        * gcc/testsuite/g++.dg/ext/builtin_alloca.C: Same.\n\nFrom-SVN: r233677", "tree": {"sha": "20a1c935058eea046189d7f537732d0f329c0414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20a1c935058eea046189d7f537732d0f329c0414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57c2c374df803636ce218618091114ac13647467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c2c374df803636ce218618091114ac13647467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c2c374df803636ce218618091114ac13647467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c2c374df803636ce218618091114ac13647467/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65433bb5b64b62dc66c850e312e3edd8236535d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65433bb5b64b62dc66c850e312e3edd8236535d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65433bb5b64b62dc66c850e312e3edd8236535d9"}], "stats": {"total": 74, "additions": 44, "deletions": 30}, "files": [{"sha": "b215d09080e4b05fc2d17108a1c583e3774c12d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57c2c374df803636ce218618091114ac13647467", "patch": "@@ -1,3 +1,9 @@\n+2016-02-24  Martin Sebor  <msebor@redhat.com>\n+\n+\t* gcc/testsuite/gcc.dg/builtins-68.c: Avoid making unportable\n+\tassumptions about the relationship between SIZE_MAX and UINT_MAX.\n+\t* gcc/testsuite/g++.dg/ext/builtin_alloca.C: Same.\n+\n 2016-02-24  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \t    Charles Baylis  <charles.baylis@linaro.org>\n "}, {"sha": "7a0d331ced064ff6fcb93f49cc6b1a594e7f7250", "filename": "gcc/testsuite/g++.dg/ext/builtin_alloca.C", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C?ref=57c2c374df803636ce218618091114ac13647467", "patch": "@@ -4,10 +4,23 @@\n // { dg-do compile }\n \n #define CHAR_BIT  __CHAR_BIT__\n-#define INT_MAX   __INT_MAX__\n-#define INT_MIN   (-INT_MAX - 1)\n-#define LONG_MAX  __LONG_MAX__\n-#define LLONG_MAX __LONG_LONG_MAX__\n+#define SIZE_MAX  __SIZE_MAX__\n+#define UINT_MAX  (__INT_MAX__ + 1U)\n+\n+/* The largest valid alignment is undocumented and subject to change\n+   but for the purposes of white box testing we rely on knowing that\n+   it happens to be defined to (UINT_MAX >> 1) + 1.  */\n+#define ALIGN_MAX ((UINT_MAX >> 1) + 1)\n+\n+#if UINT_MAX < SIZE_MAX\n+/* Define a constant to exercise an alignment that is valid a power\n+   of 2 in excess of the maximum.  */\n+#  define MAX_X_2   (ALIGN_MAX << 1)\n+#else\n+/* For targets where UINT_MAX is the same as SIZE_MAX, use an invalid\n+   alignment that's less than the maximum to elicit the same errors.  */\n+#  define MAX_X_2   (ALIGN_MAX + 1)\n+#endif\n \n static void* p;\n \n@@ -122,10 +135,6 @@ void test_arg2_non_const (int n, int a1)\n // of CHAR_BIT must be rejected.\n void test_arg2_non_pow2 (int n)\n {\n-  p =  __builtin_alloca_with_align (n, INT_MIN);     // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, -1);          // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, !1);          // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, !0);          // { dg-error \"must be a constant integer\" }\n   p =  __builtin_alloca_with_align (n,  0);          // { dg-error \"must be a constant integer\" }\n   p =  __builtin_alloca_with_align (n,  1);          // { dg-error \"must be a constant integer\" }\n   p =  __builtin_alloca_with_align (n,  2);          // { dg-error \"must be a constant integer\" }\n@@ -146,13 +155,8 @@ void test_arg2_non_pow2 (int n)\n   p =  __builtin_alloca_with_align (n, 33);          // { dg-error \"must be a constant integer\" }\n   p =  __builtin_alloca_with_align (n, 63);          // { dg-error \"must be a constant integer\" }\n   p =  __builtin_alloca_with_align (n, 65);          // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, INT_MAX);     // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, ~0U);         // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, LONG_MAX);    // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, ~0LU);        // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, 1LLU << 34);  // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, LLONG_MAX);   // { dg-error \"must be a constant integer\" }\n-  p =  __builtin_alloca_with_align (n, ~0LLU);       // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, SIZE_MAX);    /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, MAX_X_2);     /* { dg-error \"must be a constant integer\" } */\n }\n \n // Exercise invalid alignment specified by a template argument."}, {"sha": "c0cc1ebdcb9ab01a4771d5e5131ba0fdea91919c", "filename": "gcc/testsuite/gcc.dg/builtins-68.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c2c374df803636ce218618091114ac13647467/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c?ref=57c2c374df803636ce218618091114ac13647467", "patch": "@@ -5,10 +5,23 @@\n /* { dg-options \"-Wno-long-long\" } */\n \n #define CHAR_BIT  __CHAR_BIT__\n-#define INT_MAX   __INT_MAX__\n-#define INT_MIN   (-INT_MAX - 1)\n-#define LONG_MAX  __LONG_MAX__\n-#define LLONG_MAX __LONG_LONG_MAX__\n+#define SIZE_MAX  __SIZE_MAX__\n+#define UINT_MAX  (__INT_MAX__ + 1U)\n+\n+/* The largest valid alignment is undocumented and subject to change\n+   but for the purposes of white box testing we rely on knowing that\n+   it happens to be defined to (UINT_MAX >> 1) + 1.  */\n+#define ALIGN_MAX ((UINT_MAX >> 1) + 1)\n+\n+#if UINT_MAX < SIZE_MAX\n+/* Define a constant to exercise an alignment that is valid a power\n+   of 2 in excess of the maximum.  */\n+#  define MAX_X_2   (ALIGN_MAX << 1)\n+#else\n+/* For targets where UINT_MAX is the same as SIZE_MAX, use an invalid\n+   alignment that's less than the maximum to elicit the same errors.  */\n+#  define MAX_X_2   (ALIGN_MAX + 1)\n+#endif\n \n static void* p;\n \n@@ -76,10 +89,6 @@ void test_arg2_non_const (int n, int a1)\n    of CHAR_BIT less than (1LLU << 32) must be rejected.  */\n void test_arg2_non_pow2 (int n)\n {\n-  p =  __builtin_alloca_with_align (n, INT_MIN);     /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, -1);          /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, !1);          /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, !0);          /* { dg-error \"must be a constant integer\" } */\n   p =  __builtin_alloca_with_align (n,  0);          /* { dg-error \"must be a constant integer\" } */\n   p =  __builtin_alloca_with_align (n,  1);          /* { dg-error \"must be a constant integer\" } */\n   p =  __builtin_alloca_with_align (n,  2);          /* { dg-error \"must be a constant integer\" } */\n@@ -100,11 +109,6 @@ void test_arg2_non_pow2 (int n)\n   p =  __builtin_alloca_with_align (n, 33);          /* { dg-error \"must be a constant integer\" } */\n   p =  __builtin_alloca_with_align (n, 63);          /* { dg-error \"must be a constant integer\" } */\n   p =  __builtin_alloca_with_align (n, 65);          /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, INT_MAX);     /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, ~0U);         /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, LONG_MAX);    /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, ~0LU);        /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, 1LLU << 34);  /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, LLONG_MAX);   /* { dg-error \"must be a constant integer\" } */\n-  p =  __builtin_alloca_with_align (n, ~0LLU);       /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, SIZE_MAX);    /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, MAX_X_2);     /* { dg-error \"must be a constant integer\" } */\n }"}]}