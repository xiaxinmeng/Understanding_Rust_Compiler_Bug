{"sha": "fec1ce0a00615fde6d338965a44ebc12db3e1be4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVjMWNlMGEwMDYxNWZkZTZkMzM4OTY1YTQ0ZWJjMTJkYjNlMWJlNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-08-16T01:43:42Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-08-16T01:43:42Z"}, "message": "* java/io/ByteArrayOutputStream.java: Merged with Classpath.\n\nFrom-SVN: r35736", "tree": {"sha": "3debb412acdab88b49f573e48a394499d79f98ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3debb412acdab88b49f573e48a394499d79f98ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fec1ce0a00615fde6d338965a44ebc12db3e1be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec1ce0a00615fde6d338965a44ebc12db3e1be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec1ce0a00615fde6d338965a44ebc12db3e1be4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec1ce0a00615fde6d338965a44ebc12db3e1be4/comments", "author": null, "committer": null, "parents": [{"sha": "0cba764e62331c8272e7069400964fd5155753ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cba764e62331c8272e7069400964fd5155753ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cba764e62331c8272e7069400964fd5155753ab"}], "stats": {"total": 172, "additions": 162, "deletions": 10}, "files": [{"sha": "a6dbef18c1d95166539c767cbbb54fb9b887f3ca", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec1ce0a00615fde6d338965a44ebc12db3e1be4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec1ce0a00615fde6d338965a44ebc12db3e1be4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fec1ce0a00615fde6d338965a44ebc12db3e1be4", "patch": "@@ -1,3 +1,7 @@\n+2000-08-15  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/io/ByteArrayOutputStream.java: Merged with Classpath.\n+\n Sun Aug 13 19:53:01 2000  Anthony Green  <green@redhat.com>\n \n \t* THANKS: More thanks."}, {"sha": "5fba5c5918039acfd5987a7da4268a02a45015bd", "filename": "libjava/java/io/ByteArrayOutputStream.java", "status": "modified", "additions": 158, "deletions": 10, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec1ce0a00615fde6d338965a44ebc12db3e1be4/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec1ce0a00615fde6d338965a44ebc12db3e1be4/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java?ref=fec1ce0a00615fde6d338965a44ebc12db3e1be4", "patch": "@@ -1,6 +1,6 @@\n // ByteArrayOutputStream.java - Write bytes to an array.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -10,57 +10,160 @@\n \n package java.io;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 24, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * Status:  Complete to version 1.1.\n  */\n \n+/**\n+  * This class allows data to be written to a byte array buffer and\n+  * and then retrieved by an application.   The internal byte array\n+  * buffer is dynamically resized to hold all the data written.  Please\n+  * be aware that writing large amounts to data to this stream will\n+  * cause large amounts of memory to be allocated.\n+  * <p>\n+  * The size of the internal buffer defaults to 32 and it is resized\n+  * by doubling the size of the buffer.  This default size can be\n+  * overridden by using the\n+  * <code>gnu.java.io.ByteArrayOutputStream.initialBufferSize</code>\n+  * property.\n+  * <p>\n+  * There is a constructor that specified the initial buffer size and\n+  * that is the preferred way to set that value because it it portable\n+  * across all Java class library implementations.\n+  * <p>\n+  * Note that this class also has methods that convert the byte array\n+  * buffer to a <code>String</code> using either the system default or an\n+  * application specified character encoding.  Thus it can handle \n+  * multibyte character encodings.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Tom Tromey <tromey@cygnus.com>\n+  * @date September 24, 1998 \n+  */\n public class ByteArrayOutputStream extends OutputStream\n {\n+  /**\n+   * This method initializes a new <code>ByteArrayOutputStream</code>\n+   * with the default buffer size of 32 bytes.  If a different initial\n+   * buffer size is desired, see the constructor\n+   * <code>ByteArrayOutputStream(int size)</code>.  For applications\n+   * where the source code is not available, the default buffer size\n+   * can be set using the system property\n+   * <code>gnu.java.io.ByteArrayOutputStream.initialBufferSize</code>\n+   */\n   public ByteArrayOutputStream ()\n   {\n-    this (32);\n+    this (initial_buffer_size);\n   }\n \n+  /**\n+   * This method initializes a new <code>ByteArrayOutputStream</code> with\n+   * a specified initial buffer size.\n+   *\n+   * @param size The initial buffer size in bytes\n+   */\n   public ByteArrayOutputStream (int size)\n   {\n     buf = new byte[size];\n     count = 0;\n   }\n \n+  /**\n+   * This method discards all of the bytes that have been written to\n+   * the internal buffer so far by setting the <code>count</code>\n+   * variable to 0.  The internal buffer remains at its currently\n+   * allocated size.\n+   */\n   public synchronized void reset ()\n   {\n     count = 0;\n   }\n \n+  /**\n+   * This method returns the number of bytes that have been written to\n+   * the buffer so far.  This is the same as the value of the protected\n+   * <code>count</code> variable.  If the <code>reset</code> method is\n+   * called, then this value is reset as well.  Note that this method does\n+   * not return the length of the internal buffer, but only the number\n+   * of bytes that have been written to it.\n+   *\n+   * @return The number of bytes in the internal buffer\n+   *\n+   * @see reset\n+   */\n   public int size ()\n   {\n     return count;\n   }\n \n+  /**\n+   * This method returns a byte array containing the bytes that have been\n+   * written to this stream so far.  This array is a copy of the valid\n+   * bytes in the internal buffer and its length is equal to the number of\n+   * valid bytes, not necessarily to the the length of the current \n+   * internal buffer.  Note that since this method allocates a new array,\n+   * it should be used with caution when the internal buffer is very large.\n+   */\n   public synchronized byte[] toByteArray ()\n   {\n     byte[] ret = new byte[count];\n     System.arraycopy(buf, 0, ret, 0, count);\n     return ret;\n   }\n \n+  /**\n+   * Returns the bytes in the internal array as a <code>String</code>.  The\n+   * bytes in the buffer are converted to characters using the system default\n+   * encoding.  There is an overloaded <code>toString()</code> method that\n+   * allows an application specified character encoding to be used.\n+   *\n+   * @return A <code>String</code> containing the data written to this\n+   * stream so far\n+   */\n   public String toString ()\n   {\n     return new String (buf, 0, count);\n   }\n \n+  /**\n+   * Returns the bytes in the internal array as a <code>String</code>.  The\n+   * bytes in the buffer are converted to characters using the specified\n+   * encoding. \n+   *\n+   * @param enc The name of the character encoding to use\n+   *\n+   * @return A <code>String</code> containing the data written to this\n+   * stream so far\n+   *\n+   * @exception UnsupportedEncodingException If the named encoding is\n+   * not available\n+   */\n   public String toString (String enc) throws UnsupportedEncodingException\n   {\n     return new String (buf, 0, count, enc);\n   }\n \n-  // This is deprecated in the JCL book.\n+  /**\n+   * This method returns the bytes in the internal array as a\n+   * <code>String</code>.  It uses each byte in the array as the low\n+   * order eight bits of the Unicode character value and the passed in\n+   * parameter as the high eight bits.\n+   * <p>\n+   * This method does not convert bytes to characters in the proper way and\n+   * so is deprecated in favor of the other overloaded <code>toString</code>\n+   * methods which use a true character encoding.\n+   *\n+   * @param hibyte The high eight bits to use for each character in\n+   * the <code>String</code> \n+   *\n+   * @return A <code>String</code> containing the data written to this\n+   * stream so far\n+   *\n+   * @deprecrated\n+   */\n   public String toString (int hibyte)\n   {\n     return new String (buf, 0, count, hibyte);\n@@ -80,12 +183,27 @@ private void resize (int add)\n       }\n   }\n \n+  /**\n+   * This method writes the writes the specified byte into the internal\n+   * buffer.\n+   *\n+   * @param oneByte The byte to be read passed as an int\n+   */\n   public synchronized void write (int oneByte)\n   {\n     resize (1);\n     buf[count++] = (byte) oneByte;\n   }\n \n+  /**\n+   * This method writes <code>len</code> bytes from the passed in array \n+   * <code>buf</code> starting at index <code>offset</code> into the\n+   * internal buffer.\n+   *\n+   * @param buffer The byte array to write data from\n+   * @param offset The index into the buffer to start writing data from\n+   * @param add The number of bytes to write\n+   */\n   public synchronized void write (byte[] buffer, int offset, int add)\n   {\n     // If ADD < 0 then arraycopy will throw the appropriate error for\n@@ -96,13 +214,43 @@ public synchronized void write (byte[] buffer, int offset, int add)\n     count += add;\n   }\n \n+  /**\n+   * This method writes all the bytes that have been written to this stream\n+   * from the internal buffer to the specified <code>OutputStream</code>.\n+   *\n+   * @param out The <code>OutputStream</code> to write to\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public synchronized void writeTo (OutputStream out) throws IOException\n   {\n     out.write(buf, 0, count);\n   }\n \n-  // The byte buffer.\n+  /**\n+   * The internal buffer where the data written is stored\n+   */\n   protected byte[] buf;\n-  // Number of valid bytes in buffer.\n+\n+  /**\n+   * The number of bytes that have been written to the buffer\n+   */\n   protected int count;\n+\n+  /**\n+   * The default initial buffer size.  Specified by the JCL.\n+   */\n+  private static final int DEFAULT_INITIAL_BUFFER_SIZE = 32;\n+\n+  // The default buffer size which can be overridden by the user.\n+  private static final int initial_buffer_size;\n+\n+  static\n+  {\n+    initial_buffer_size\n+      = Integer.getInteger (\"gnu.java.io.ByteArrayOutputStream.initialBufferSize\",\n+\t\t\t    DEFAULT_INITIAL_BUFFER_SIZE).intValue ();\n+    if (initial_buffer_size <= 0)\n+      initial_buffer_size = DEFAULT_INITIAL_BUFFER_SIZE;\n+  }\n }"}]}