{"sha": "595f1b1274b1cb86c74c72b9cc297e6981fe4549", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk1ZjFiMTI3NGIxY2I4NmM3NGM3MmI5Y2MyOTdlNjk4MWZlNDU0OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-31T21:34:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-04-01T05:17:23Z"}, "message": "c++: Adjust formatting.\n\nThis patch has no semantic effect; committing it separately makes the change\nfor 94205 easier to read.\n\ngcc/cp/ChangeLog\n2020-03-31  Jason Merrill  <jason@redhat.com>\n\n\t* constexpr.c (cxx_eval_constant_expression) [TARGET_EXPR]: Use\n\tlocal variables.", "tree": {"sha": "e92124fc3474750b16236fe1f2bc649a3cceadb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e92124fc3474750b16236fe1f2bc649a3cceadb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/595f1b1274b1cb86c74c72b9cc297e6981fe4549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/595f1b1274b1cb86c74c72b9cc297e6981fe4549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/595f1b1274b1cb86c74c72b9cc297e6981fe4549", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/595f1b1274b1cb86c74c72b9cc297e6981fe4549/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73dd051894b8293d35ea1c436fa408c404b80813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dd051894b8293d35ea1c436fa408c404b80813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73dd051894b8293d35ea1c436fa408c404b80813"}], "stats": {"total": 109, "additions": 60, "deletions": 49}, "files": [{"sha": "2814a866f5d54a95cdd536d98e8429b7debc4e92", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595f1b1274b1cb86c74c72b9cc297e6981fe4549/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595f1b1274b1cb86c74c72b9cc297e6981fe4549/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=595f1b1274b1cb86c74c72b9cc297e6981fe4549", "patch": "@@ -1,3 +1,8 @@\n+2020-03-31  Jason Merrill  <jason@redhat.com>\n+\n+\t* constexpr.c (cxx_eval_constant_expression) [TARGET_EXPR]: Use\n+\tlocal variables.\n+\n 2020-03-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/90711"}, {"sha": "e85b3c113f06dcb2b26c9d39a1e750893ced7fbc", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595f1b1274b1cb86c74c72b9cc297e6981fe4549/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595f1b1274b1cb86c74c72b9cc297e6981fe4549/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=595f1b1274b1cb86c74c72b9cc297e6981fe4549", "patch": "@@ -5525,56 +5525,62 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case TARGET_EXPR:\n-      if (!literal_type_p (TREE_TYPE (t)))\n-\t{\n-\t  if (!ctx->quiet)\n-\t    {\n-\t      auto_diagnostic_group d;\n-\t      error (\"temporary of non-literal type %qT in a \"\n-\t\t     \"constant expression\", TREE_TYPE (t));\n-\t      explain_non_literal_class (TREE_TYPE (t));\n-\t    }\n-\t  *non_constant_p = true;\n-\t  break;\n-\t}\n-      gcc_checking_assert (!TARGET_EXPR_DIRECT_INIT_P (t));\n-      /* Avoid evaluating a TARGET_EXPR more than once.  */\n-      if (tree *p = ctx->global->values.get (TARGET_EXPR_SLOT (t)))\n-\t{\n-\t  if (lval)\n-\t    return TARGET_EXPR_SLOT (t);\n-\t  r = *p;\n+      {\n+\ttree type = TREE_TYPE (t);\n+\n+\tif (!literal_type_p (type))\n+\t  {\n+\t    if (!ctx->quiet)\n+\t      {\n+\t\tauto_diagnostic_group d;\n+\t\terror (\"temporary of non-literal type %qT in a \"\n+\t\t       \"constant expression\", type);\n+\t\texplain_non_literal_class (type);\n+\t      }\n+\t    *non_constant_p = true;\n+\t    break;\n+\t  }\n+\tgcc_checking_assert (!TARGET_EXPR_DIRECT_INIT_P (t));\n+\t/* Avoid evaluating a TARGET_EXPR more than once.  */\n+\ttree slot = TARGET_EXPR_SLOT (t);\n+\tif (tree *p = ctx->global->values.get (slot))\n+\t  {\n+\t    if (lval)\n+\t      return slot;\n+\t    r = *p;\n+\t    break;\n+\t  }\n+\ttree init = TARGET_EXPR_INITIAL (t);\n+\tif ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type)))\n+\t  {\n+\t    /* We're being expanded without an explicit target, so start\n+\t       initializing a new object; expansion with an explicit target\n+\t       strips the TARGET_EXPR before we get here.  */\n+\t    new_ctx = *ctx;\n+\t    new_ctx.ctor = build_constructor (type, NULL);\n+\t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n+\t    new_ctx.object = slot;\n+\t    ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n+\t    ctx = &new_ctx;\n+\t  }\n+\t/* Pass false for 'lval' because this indicates\n+\t   initialization of a temporary.  */\n+\tr = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n+\t\t\t\t\t  false,\n+\t\t\t\t\t  non_constant_p, overflow_p);\n+\tif (*non_constant_p)\n \t  break;\n-\t}\n-      if ((AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t))))\n-\t{\n-\t  /* We're being expanded without an explicit target, so start\n-\t     initializing a new object; expansion with an explicit target\n-\t     strips the TARGET_EXPR before we get here.  */\n-\t  new_ctx = *ctx;\n-\t  new_ctx.ctor = build_constructor (TREE_TYPE (t), NULL);\n-\t  CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n-\t  new_ctx.object = TARGET_EXPR_SLOT (t);\n-\t  ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n-\t  ctx = &new_ctx;\n-\t}\n-      /* Pass false for 'lval' because this indicates\n-\t initialization of a temporary.  */\n-      r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n-      if (*non_constant_p)\n-\tbreak;\n-      /* Adjust the type of the result to the type of the temporary.  */\n-      r = adjust_temp_type (TREE_TYPE (t), r);\n-      if (TARGET_EXPR_CLEANUP (t) && !CLEANUP_EH_ONLY (t))\n-\tctx->global->cleanups->safe_push (TARGET_EXPR_CLEANUP (t));\n-      r = unshare_constructor (r);\n-      ctx->global->values.put (TARGET_EXPR_SLOT (t), r);\n-      if (ctx->save_exprs)\n-\tctx->save_exprs->safe_push (TARGET_EXPR_SLOT (t));\n-      if (lval)\n-\treturn TARGET_EXPR_SLOT (t);\n+\t/* Adjust the type of the result to the type of the temporary.  */\n+\tr = adjust_temp_type (type, r);\n+\tif (TARGET_EXPR_CLEANUP (t) && !CLEANUP_EH_ONLY (t))\n+\t  ctx->global->cleanups->safe_push (TARGET_EXPR_CLEANUP (t));\n+\tr = unshare_constructor (r);\n+\tctx->global->values.put (slot, r);\n+\tif (ctx->save_exprs)\n+\t  ctx->save_exprs->safe_push (slot);\n+\tif (lval)\n+\t  return slot;\n+      }\n       break;\n \n     case INIT_EXPR:"}]}