{"sha": "ca80e52b017482baf0bc3b91ce59af78a86785ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4MGU1MmIwMTc0ODJiYWYwYmMzYjkxY2U1OWFmNzhhODY3ODViYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-21T17:17:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-21T17:17:13Z"}, "message": "c-common.c (c_common_truthvalue_conversion): Use LOCATION to build NE_EXPR operations as well.\n\n\t* c-common.c (c_common_truthvalue_conversion): Use LOCATION to build\n\tNE_EXPR operations as well.\n\t* c-parser.c (c_parser_condition): Do not set location information on\n\tthe condition.\n\t(c_parser_conditional_expression): Likewise.\n\t(c_parser_binary_expression): Set location information on operators.\n\t* c-typeck.c (build_unary_op) <TRUTH_NOT_EXPR>: Reset the location if\n\tTRUTH_NOT_EXPR has been folded.\n\t* fold-const.c (fold_truth_not_expr): Copy location information from\n\tthe incoming expression to the outgoing one.\n\t* gimplify.c (shortcut_cond_r): Add locus parameter.  Pass it to\n\trecursive calls on the LHS of the operator but pass that of the\n\toperator to recursive calls on the RHS of the operator.  Set it\n\ton the COND_EXPR.\n\t(shortcut_cond_expr): Set the locus of the operator on the second\n\tCOND_EXPR and that of the expression on the first in degenerate cases.\n\tPass the locus of the expression to calls to shortcut_cond_r.\n\tSet the locus of the 'then' block on the associated jump, if any.\n\t(gimplify_boolean_expr): Add locus parameter.  Set it on the COND_EXPR.\n\t(gimplify_expr) <TRUTH_ANDIF_EXPR>: Pass the locus of the outer\n\texpression to call to gimplify_boolean_expr.\nada/\n\t* gcc-interface/trans.c (gnat_to_gnu): Do not overwrite location info.\n\nFrom-SVN: r146532", "tree": {"sha": "4af8030719296e992a9c12adcef79ed4833b2ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4af8030719296e992a9c12adcef79ed4833b2ff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca80e52b017482baf0bc3b91ce59af78a86785ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca80e52b017482baf0bc3b91ce59af78a86785ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca80e52b017482baf0bc3b91ce59af78a86785ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca80e52b017482baf0bc3b91ce59af78a86785ba/comments", "author": null, "committer": null, "parents": [{"sha": "71b495a2ac3a1c89a2f6a1a789dde32d337ef654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b495a2ac3a1c89a2f6a1a789dde32d337ef654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71b495a2ac3a1c89a2f6a1a789dde32d337ef654"}], "stats": {"total": 363, "additions": 285, "deletions": 78}, "files": [{"sha": "3c622f75512ad054e126b6e1a9b6075322b59bd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -1,3 +1,27 @@\n+2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-common.c (c_common_truthvalue_conversion): Use LOCATION to build\n+\tNE_EXPR operations as well.\n+\t* c-parser.c (c_parser_condition): Do not set location information on\n+\tthe condition.\n+\t(c_parser_conditional_expression): Likewise.\n+\t(c_parser_binary_expression): Set location information on operators.\n+\t* c-typeck.c (build_unary_op) <TRUTH_NOT_EXPR>: Reset the location if\n+\tTRUTH_NOT_EXPR has been folded.\n+\t* fold-const.c (fold_truth_not_expr): Copy location information from\n+\tthe incoming expression to the outgoing one.\n+\t* gimplify.c (shortcut_cond_r): Add locus parameter.  Pass it to\n+\trecursive calls on the LHS of the operator but pass that of the\n+\toperator to recursive calls on the RHS of the operator.  Set it\n+\ton the COND_EXPR.\n+\t(shortcut_cond_expr): Set the locus of the operator on the second\n+\tCOND_EXPR and that of the expression on the first in degenerate cases.\n+\tPass the locus of the expression to calls to shortcut_cond_r.\n+\tSet the locus of the 'then' block on the associated jump, if any.\n+\t(gimplify_boolean_expr): Add locus parameter.  Set it on the COND_EXPR.\n+\t(gimplify_expr) <TRUTH_ANDIF_EXPR>: Pass the locus of the outer\n+\texpression to call to gimplify_boolean_expr.\n+\n 2009-04-21  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config.gcc: Add additional configuration for"}, {"sha": "6f31dbd3e3d29b729e844a4c478466e2ee390dd0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -1,3 +1,7 @@\n+2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu): Do not overwrite location info.\n+\n 2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TYPE_RM_SIZE_NUM): Delete."}, {"sha": "84aa3963910a080cd20982d84d7ecfa3e7437b98", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -5303,7 +5303,8 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (gnu_result\n       && EXPR_P (gnu_result)\n       && TREE_CODE (gnu_result) != NOP_EXPR\n-      && !REFERENCE_CLASS_P (gnu_result))\n+      && !REFERENCE_CLASS_P (gnu_result)\n+      && !EXPR_HAS_LOCATION (gnu_result))\n     set_expr_location_from_node (gnu_result, gnat_node);\n \n   /* If we're supposed to return something of void_type, it means we have"}, {"sha": "3595e552966f0f20e709a5dc514cdd12611edd05", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -4114,12 +4114,10 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n       tree fixed_zero_node = build_fixed (TREE_TYPE (expr),\n \t\t\t\t\t  FCONST0 (TYPE_MODE\n \t\t\t\t\t\t   (TREE_TYPE (expr))));\n-      return build_binary_op (EXPR_LOCATION (expr),\n-\t\t\t      NE_EXPR, expr, fixed_zero_node, 1);\n+      return build_binary_op (location, NE_EXPR, expr, fixed_zero_node, 1);\n     }\n \n-  return build_binary_op (EXPR_LOCATION (expr),\n-\t\t\t  NE_EXPR, expr, integer_zero_node, 1);\n+  return build_binary_op (location, NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n static void def_builtin_1  (enum built_in_function fncode,"}, {"sha": "676c709cdf2f179a3c7c142c35808fbd76ad8949", "filename": "gcc/c-parser.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -3835,7 +3835,6 @@ c_parser_condition (c_parser *parser)\n   cond = c_parser_expression_conv (parser).value;\n   cond = c_objc_common_truthvalue_conversion (loc, cond);\n   cond = c_fully_fold (cond, false, NULL);\n-  protected_set_expr_location (cond, loc);\n   if (warn_sequence_point)\n     verify_sequence_points (cond);\n   return cond;\n@@ -4479,7 +4478,6 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \n   cond_loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_binary_expression (parser, after);\n-  protected_set_expr_location (cond.value, cond_loc);\n \n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n@@ -4651,6 +4649,8 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n     enum prec prec;\n     /* The operation on its left.  */\n     enum tree_code op;\n+    /* The source location of this operation.  */\n+    location_t loc;\n   } stack[NUM_PRECS];\n   int sp;\n   /* Location of the binary operator.  */\n@@ -4672,13 +4672,14 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       = default_function_array_conversion (stack[sp - 1].expr);\t\t      \\\n     stack[sp].expr\t\t\t\t\t\t\t      \\\n       = default_function_array_conversion (stack[sp].expr);\t\t      \\\n-    stack[sp - 1].expr = parser_build_binary_op (binary_loc,\t\t      \\\n+    stack[sp - 1].expr = parser_build_binary_op (stack[sp].loc,\t\t      \\\n \t\t\t\t\t\t stack[sp].op,\t\t      \\\n \t\t\t\t\t\t stack[sp - 1].expr,\t      \\\n \t\t\t\t\t\t stack[sp].expr);\t      \\\n     sp--;\t\t\t\t\t\t\t\t      \\\n   } while (0)\n   gcc_assert (!after || c_dialect_objc ());\n+  stack[0].loc = c_parser_peek_token (parser)->location;\n   stack[0].expr = c_parser_cast_expression (parser, after);\n   stack[0].prec = PREC_NONE;\n   sp = 0;\n@@ -4777,20 +4778,21 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t  stack[sp].expr\n \t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n-\t    (binary_loc, default_conversion (stack[sp].expr.value));\n+\t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n \t  stack[sp].expr\n \t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n-\t    (binary_loc, default_conversion (stack[sp].expr.value));\n+\t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n \t  break;\n \tdefault:\n \t  break;\n \t}\n       sp++;\n+      stack[sp].loc = binary_loc;\n       stack[sp].expr = c_parser_cast_expression (parser, NULL);\n       stack[sp].prec = oprec;\n       stack[sp].op = ocode;"}, {"sha": "1ff6e9b744d62cf7c9805ab524008f0ee70a4c6c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -3209,6 +3209,9 @@ build_unary_op (location_t location,\n \t}\n       arg = c_objc_common_truthvalue_conversion (location, arg);\n       ret = invert_truthvalue (arg);\n+      /* If the TRUTH_NOT_EXPR has been folded, reset the location.  */\n+      if (EXPR_P (ret) && EXPR_HAS_LOCATION (ret))\n+\tlocation = EXPR_LOCATION (ret);\n       goto return_build_unary_op;\n \n     case REALPART_EXPR:"}, {"sha": "ca07cf16720427edfad48c1e39044ede0fccbdc9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -3641,7 +3641,7 @@ omit_two_operands (tree type, tree result, tree omitted1, tree omitted2)\n tree\n fold_truth_not_expr (tree arg)\n {\n-  tree type = TREE_TYPE (arg);\n+  tree t, type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n \n   /* If this is a comparison, we can simply invert it, except for\n@@ -3656,16 +3656,15 @@ fold_truth_not_expr (tree arg)\n \t  && code != ORDERED_EXPR && code != UNORDERED_EXPR\n \t  && code != NE_EXPR && code != EQ_EXPR)\n \treturn NULL_TREE;\n-      else\n-\t{\n-\t  code = invert_tree_comparison (code,\n-\t\t\t\t\t HONOR_NANS (TYPE_MODE (op_type)));\n-\t  if (code == ERROR_MARK)\n-\t    return NULL_TREE;\n-\t  else\n-\t    return build2 (code, type,\n-\t\t\t   TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n-\t}\n+\n+      code = invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (op_type)));\n+      if (code == ERROR_MARK)\n+\treturn NULL_TREE;\n+\n+      t = build2 (code, type, TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n+      if (EXPR_HAS_LOCATION (arg))\n+\tSET_EXPR_LOCATION (t, EXPR_LOCATION (arg));\n+      return t;\n     }\n \n   switch (code)\n@@ -3674,14 +3673,16 @@ fold_truth_not_expr (tree arg)\n       return constant_boolean_node (integer_zerop (arg), type);\n \n     case TRUTH_AND_EXPR:\n-      return build2 (TRUTH_OR_EXPR, type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      t = build2 (TRUTH_OR_EXPR, type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      break;\n \n     case TRUTH_OR_EXPR:\n-      return build2 (TRUTH_AND_EXPR, type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      t = build2 (TRUTH_AND_EXPR, type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      break;\n \n     case TRUTH_XOR_EXPR:\n       /* Here we can invert either operand.  We invert the first operand\n@@ -3690,22 +3691,25 @@ fold_truth_not_expr (tree arg)\n \t negation of the second operand.  */\n \n       if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)\n-\treturn build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t       TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n+\tt = build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t    TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n       else\n-\treturn build2 (TRUTH_XOR_EXPR, type,\n-\t\t       invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t       TREE_OPERAND (arg, 1));\n+\tt = build2 (TRUTH_XOR_EXPR, type,\n+\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t    TREE_OPERAND (arg, 1));\n+      break;\n \n     case TRUTH_ANDIF_EXPR:\n-      return build2 (TRUTH_ORIF_EXPR, type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      t = build2 (TRUTH_ORIF_EXPR, type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      break;\n \n     case TRUTH_ORIF_EXPR:\n-      return build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      t = build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      break;\n \n     case TRUTH_NOT_EXPR:\n       return TREE_OPERAND (arg, 0);\n@@ -3717,47 +3721,61 @@ fold_truth_not_expr (tree arg)\n \t/* A COND_EXPR may have a throw as one operand, which\n \t   then has void type.  Just leave void operands\n \t   as they are.  */\n-\treturn build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t       VOID_TYPE_P (TREE_TYPE (arg1))\n-\t\t       ? arg1 : invert_truthvalue (arg1),\n-\t\t       VOID_TYPE_P (TREE_TYPE (arg2))\n-\t\t       ? arg2 : invert_truthvalue (arg2));\n+\tt = build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t    VOID_TYPE_P (TREE_TYPE (arg1))\n+\t\t    ? arg1 : invert_truthvalue (arg1),\n+\t\t    VOID_TYPE_P (TREE_TYPE (arg2))\n+\t\t    ? arg2 : invert_truthvalue (arg2));\n+\tbreak;\n       }\n \n     case COMPOUND_EXPR:\n-      return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      t = build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 1)));\n+      break;\n \n     case NON_LVALUE_EXPR:\n       return invert_truthvalue (TREE_OPERAND (arg, 0));\n \n     case NOP_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n-\treturn build1 (TRUTH_NOT_EXPR, type, arg);\n+\t{\n+\t  t = build1 (TRUTH_NOT_EXPR, type, arg);\n+\t  break;\n+\t}\n+\n+      /* ... fall through ...  */\n \n     case CONVERT_EXPR:\n     case FLOAT_EXPR:\n-      return build1 (TREE_CODE (arg), type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)));\n+      t = build1 (TREE_CODE (arg), type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)));\n+      break;\n \n     case BIT_AND_EXPR:\n       if (!integer_onep (TREE_OPERAND (arg, 1)))\n-\tbreak;\n-      return build2 (EQ_EXPR, type, arg,\n-\t\t     build_int_cst (type, 0));\n+\treturn NULL_TREE;\n+      t = build2 (EQ_EXPR, type, arg, build_int_cst (type, 0));\n+      break;\n \n     case SAVE_EXPR:\n-      return build1 (TRUTH_NOT_EXPR, type, arg);\n+      t = build1 (TRUTH_NOT_EXPR, type, arg);\n+      break;\n \n     case CLEANUP_POINT_EXPR:\n-      return build1 (CLEANUP_POINT_EXPR, type,\n-\t\t     invert_truthvalue (TREE_OPERAND (arg, 0)));\n+      t = build1 (CLEANUP_POINT_EXPR, type,\n+\t\t  invert_truthvalue (TREE_OPERAND (arg, 0)));\n+      break;\n \n     default:\n+      t = NULL_TREE;\n       break;\n     }\n \n-  return NULL_TREE;\n+  if (t && EXPR_HAS_LOCATION (arg))\n+    SET_EXPR_LOCATION (t, EXPR_LOCATION (arg));\n+\n+  return t;\n }\n \n /* Return a simplified tree node for the truth-negation of ARG.  This"}, {"sha": "993f7c2ae449bb698d4172c8cf0c3b1591e27dd6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -2449,12 +2449,15 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n    condition is true or false, respectively.  If null, we should generate\n    our own to skip over the evaluation of this specific expression.\n \n+   LOCUS is the source location of the COND_EXPR.\n+\n    This function is the tree equivalent of do_jump.\n \n    shortcut_cond_r should only be called by shortcut_cond_expr.  */\n \n static tree\n-shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)\n+shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n+\t\t location_t locus)\n {\n   tree local_label = NULL_TREE;\n   tree t, expr = NULL;\n@@ -2464,6 +2467,8 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)\n      shortcut_cond_expr will append the real blocks later.  */\n   if (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)\n     {\n+      location_t new_locus;\n+\n       /* Turn if (a && b) into\n \n \t if (a); else goto no;\n@@ -2473,15 +2478,20 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)\n       if (false_label_p == NULL)\n \tfalse_label_p = &local_label;\n \n-      t = shortcut_cond_r (TREE_OPERAND (pred, 0), NULL, false_label_p);\n+      /* Keep the original source location on the first 'if'.  */\n+      t = shortcut_cond_r (TREE_OPERAND (pred, 0), NULL, false_label_p, locus);\n       append_to_statement_list (t, &expr);\n \n-      t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n-\t\t\t   false_label_p);\n+      /* Set the source location of the && on the second 'if'.  */\n+      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n+      t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,\n+\t\t\t   new_locus);\n       append_to_statement_list (t, &expr);\n     }\n   else if (TREE_CODE (pred) == TRUTH_ORIF_EXPR)\n     {\n+      location_t new_locus;\n+\n       /* Turn if (a || b) into\n \n \t if (a) goto yes;\n@@ -2491,31 +2501,41 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)\n       if (true_label_p == NULL)\n \ttrue_label_p = &local_label;\n \n-      t = shortcut_cond_r (TREE_OPERAND (pred, 0), true_label_p, NULL);\n+      /* Keep the original source location on the first 'if'.  */\n+      t = shortcut_cond_r (TREE_OPERAND (pred, 0), true_label_p, NULL, locus);\n       append_to_statement_list (t, &expr);\n \n-      t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n-\t\t\t   false_label_p);\n+      /* Set the source location of the || on the second 'if'.  */\n+      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n+      t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,\n+\t\t\t   new_locus);\n       append_to_statement_list (t, &expr);\n     }\n   else if (TREE_CODE (pred) == COND_EXPR)\n     {\n+      location_t new_locus;\n+\n       /* As long as we're messing with gotos, turn if (a ? b : c) into\n \t if (a)\n \t   if (b) goto yes; else goto no;\n \t else\n \t   if (c) goto yes; else goto no;  */\n+\n+      /* Keep the original source location on the first 'if'.  Set the source\n+\t location of the ? on the second 'if'.  */\n+      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n       expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),\n \t\t     shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n-\t\t\t\t      false_label_p),\n+\t\t\t\t      false_label_p, locus),\n \t\t     shortcut_cond_r (TREE_OPERAND (pred, 2), true_label_p,\n-\t\t\t\t      false_label_p));\n+\t\t\t\t      false_label_p, new_locus));\n     }\n   else\n     {\n       expr = build3 (COND_EXPR, void_type_node, pred,\n \t\t     build_and_jump (true_label_p),\n \t\t     build_and_jump (false_label_p));\n+      SET_EXPR_LOCATION (expr, locus);\n     }\n \n   if (local_label)\n@@ -2547,14 +2567,24 @@ shortcut_cond_expr (tree expr)\n   /* First do simple transformations.  */\n   if (!else_se)\n     {\n-      /* If there is no 'else', turn (a && b) into if (a) if (b).  */\n+      /* If there is no 'else', turn\n+\t   if (a && b) then c\n+\t into\n+\t   if (a) if (b) then c.  */\n       while (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)\n \t{\n+\t  /* Keep the original source location on the first 'if'.  */\n+\t  location_t locus = EXPR_HAS_LOCATION (expr)\n+\t\t\t     ? EXPR_LOCATION (expr) : input_location;\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n+\t  /* Set the source location of the && on the second 'if'.  */\n+\t  if (EXPR_HAS_LOCATION (pred))\n+\t    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));\n \t  then_ = shortcut_cond_expr (expr);\n \t  then_se = then_ && TREE_SIDE_EFFECTS (then_);\n \t  pred = TREE_OPERAND (pred, 0);\n \t  expr = build3 (COND_EXPR, void_type_node, pred, then_, NULL_TREE);\n+\t  SET_EXPR_LOCATION (expr, locus);\n \t}\n     }\n \n@@ -2566,11 +2596,18 @@ shortcut_cond_expr (tree expr)\n \t   if (a); else if (b); else d.  */\n       while (TREE_CODE (pred) == TRUTH_ORIF_EXPR)\n \t{\n+\t  /* Keep the original source location on the first 'if'.  */\n+\t  location_t locus = EXPR_HAS_LOCATION (expr)\n+\t\t\t     ? EXPR_LOCATION (expr) : input_location;\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n+\t  /* Set the source location of the || on the second 'if'.  */\n+\t  if (EXPR_HAS_LOCATION (pred))\n+\t    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));\n \t  else_ = shortcut_cond_expr (expr);\n \t  else_se = else_ && TREE_SIDE_EFFECTS (else_);\n \t  pred = TREE_OPERAND (pred, 0);\n \t  expr = build3 (COND_EXPR, void_type_node, pred, NULL_TREE, else_);\n+\t  SET_EXPR_LOCATION (expr, locus);\n \t}\n     }\n \n@@ -2624,17 +2661,19 @@ shortcut_cond_expr (tree expr)\n \n   /* If there was nothing else in our arms, just forward the label(s).  */\n   if (!then_se && !else_se)\n-    return shortcut_cond_r (pred, true_label_p, false_label_p);\n+    return shortcut_cond_r (pred, true_label_p, false_label_p,\n+\t\t\t    EXPR_HAS_LOCATION (expr)\n+\t\t\t    ? EXPR_LOCATION (expr) : input_location);\n \n   /* If our last subexpression already has a terminal label, reuse it.  */\n   if (else_se)\n-    expr = expr_last (else_);\n+    t = expr_last (else_);\n   else if (then_se)\n-    expr = expr_last (then_);\n+    t = expr_last (then_);\n   else\n-    expr = NULL;\n-  if (expr && TREE_CODE (expr) == LABEL_EXPR)\n-    end_label = LABEL_EXPR_LABEL (expr);\n+    t = NULL;\n+  if (t && TREE_CODE (t) == LABEL_EXPR)\n+    end_label = LABEL_EXPR_LABEL (t);\n \n   /* If we don't care about jumping to the 'else' branch, jump to the end\n      if the condition is false.  */\n@@ -2655,7 +2694,9 @@ shortcut_cond_expr (tree expr)\n      non-void function.  */\n   jump_over_else = block_may_fallthru (then_);\n \n-  pred = shortcut_cond_r (pred, true_label_p, false_label_p);\n+  pred = shortcut_cond_r (pred, true_label_p, false_label_p,\n+\t\t\t  EXPR_HAS_LOCATION (expr)\n+\t\t\t  ? EXPR_LOCATION (expr) : input_location);\n \n   expr = NULL;\n   append_to_statement_list (pred, &expr);\n@@ -2665,7 +2706,10 @@ shortcut_cond_expr (tree expr)\n     {\n       if (jump_over_else)\n \t{\n+\t  tree last = expr_last (expr);\n \t  t = build_and_jump (&end_label);\n+\t  if (EXPR_HAS_LOCATION (last))\n+\t    SET_EXPR_LOCATION (t, EXPR_LOCATION (last));\n \t  append_to_statement_list (t, &expr);\n \t}\n       if (emit_false)\n@@ -4428,13 +4472,11 @@ gimplify_scalar_mode_aggregate_compare (tree *expr_p)\n \n \ta && b ? true : false\n \n-    gimplify_cond_expr will do the rest.\n-\n-    PRE_P points to the list where side effects that must happen before\n-\t*EXPR_P should be stored.  */\n+    LOCUS is the source location to be put on the generated COND_EXPR.\n+    gimplify_cond_expr will do the rest.  */\n \n static enum gimplify_status\n-gimplify_boolean_expr (tree *expr_p)\n+gimplify_boolean_expr (tree *expr_p, location_t locus)\n {\n   /* Preserve the original type of the expression.  */\n   tree type = TREE_TYPE (*expr_p);\n@@ -4443,6 +4485,8 @@ gimplify_boolean_expr (tree *expr_p)\n \t\t    fold_convert (type, boolean_true_node),\n \t\t    fold_convert (type, boolean_false_node));\n \n+  SET_EXPR_LOCATION (*expr_p, locus);\n+\n   return GS_OK;\n }\n \n@@ -6430,7 +6474,8 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase TRUTH_ANDIF_EXPR:\n \tcase TRUTH_ORIF_EXPR:\n-\t  ret = gimplify_boolean_expr (expr_p);\n+\t  /* Pass the source location of the outer expression.  */\n+\t  ret = gimplify_boolean_expr (expr_p, saved_location);\n \t  break;\n \n \tcase TRUTH_NOT_EXPR:"}, {"sha": "697da24fec6904e06dbfb80f7e5247f143965fa3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -1,3 +1,7 @@\n+2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/debug/dwarf2/short-circuit.c: New test.\n+\n 2009-04-21  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/39829"}, {"sha": "7e745ff19d2ba1802152cbe87d5d776774d7c19f", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fshort-circuit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca80e52b017482baf0bc3b91ce59af78a86785ba/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fshort-circuit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fshort-circuit.c?ref=ca80e52b017482baf0bc3b91ce59af78a86785ba", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+#define True  1\n+#define False 0\n+\n+_Bool F1 (_Bool B1, _Bool B2)\n+{\n+  _Bool R;\n+\n+  if (B1\n+      && B2)\n+    R = True;\n+  else\n+    R = False;\n+  return R;\n+}\n+\n+_Bool F2 (_Bool B1, _Bool B2)\n+{\n+  _Bool R;\n+\n+  R = B1\n+      && B2;\n+  return R;\n+}\n+\n+_Bool F3 (_Bool B1, _Bool B2)\n+{\n+  _Bool R = False;\n+\n+  if (B1\n+      && B2)\n+    R = True;\n+  return R;\n+}\n+\n+_Bool F4 (_Bool B1, _Bool B2)\n+{\n+  _Bool R = False;\n+\n+  if (B1\n+      || B2)\n+    ;\n+  else\n+    R = True;\n+  return R;\n+}\n+\n+_Bool F5 (_Bool B1, _Bool B2)\n+{\n+  _Bool R = False;\n+\n+  if (!(B1\n+        && B2))\n+    R = True;\n+  return R;\n+}\n+\n+_Bool F8 (_Bool B1, _Bool B2, _Bool B3, _Bool B4, _Bool B5, _Bool B6,\n+          _Bool B7, _Bool B8)\n+{\n+  _Bool R;\n+\n+  if ((B1\n+       || B2)\n+       && B3\n+       && !(B4\n+            || B5)\n+       && (B6\n+           || (B7\n+               && B8)))\n+    R = True;\n+  else\n+    R = False;\n+  return R;\n+}\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:11\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:12\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:13\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:15\" } } */\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:23\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:24\" } } */\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:32\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:33\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:34\" } } */\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:42\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:43\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:46\" } } */\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:54\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:55\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:56\" } } */\n+\n+/* { dg-final { scan-assembler \"short-circuit.c:65\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:66\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:67\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:68\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:69\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:70\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:71\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:72\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:73\" } } */\n+/* { dg-final { scan-assembler \"short-circuit.c:75\" } } */"}]}