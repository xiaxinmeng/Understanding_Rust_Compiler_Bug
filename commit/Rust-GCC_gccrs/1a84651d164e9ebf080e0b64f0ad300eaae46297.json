{"sha": "1a84651d164e9ebf080e0b64f0ad300eaae46297", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4NDY1MWQxNjRlOWViZjA4MGUwYjY0ZjBhZDMwMGVhYWU0NjI5Nw==", "commit": {"author": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2020-09-18T07:10:19Z"}, "committer": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2020-09-22T11:55:42Z"}, "message": "IBM Z: Try to make use of load-and-test instructions\n\nThis patch enables a peephole2 optimization which transforms a load of\nconstant zero into a temporary register which is then finally used to\ncompare against a floating-point register of interest into a single load\nand test instruction.  However, the optimization is only applied if both\nregisters are dead afterwards and if we test for (in)equality only.\nThis is relaxed in case of fast math.\n\nThis is a follow up to PR88856.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.md (\"*cmp<mode>_ccs_0\", \"*cmp<mode>_ccz_0\",\n\t\"*cmp<mode>_ccs_0_fastmath\"): Basically change \"*cmp<mode>_ccs_0\" into\n\t\"*cmp<mode>_ccz_0\" and for fast math add \"*cmp<mode>_ccs_0_fastmath\".\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/load-and-test-fp-1.c: Change test to include all\n\tpossible combinations of dead/live registers and comparisons (equality,\n\trelational).\n\t* gcc.target/s390/load-and-test-fp-2.c: Same as load-and-test-fp-1.c\n\tbut for fast math.\n\t* gcc.target/s390/load-and-test-fp.h: New test included by\n\tload-and-test-fp-{1,2}.c.", "tree": {"sha": "adca2864fc047adf2fc0d9d8111b733c10db6c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adca2864fc047adf2fc0d9d8111b733c10db6c62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a84651d164e9ebf080e0b64f0ad300eaae46297", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a84651d164e9ebf080e0b64f0ad300eaae46297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a84651d164e9ebf080e0b64f0ad300eaae46297", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a84651d164e9ebf080e0b64f0ad300eaae46297/comments", "author": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e9cee285e47f806227b22812b15ffea677d578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e9cee285e47f806227b22812b15ffea677d578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e9cee285e47f806227b22812b15ffea677d578"}], "stats": {"total": 104, "additions": 68, "deletions": 36}, "files": [{"sha": "18edea1ce47497a93291dbfb552ee0547c542fbf", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=1a84651d164e9ebf080e0b64f0ad300eaae46297", "patch": "@@ -1391,23 +1391,55 @@\n ; (TF|DF|SF|TD|DD|SD) instructions\n \n \n-; FIXME: load and test instructions turn SNaN into QNaN what is not\n-; acceptable if the target will be used afterwards.  On the other hand\n-; they are quite convenient for implementing comparisons with 0.0. So\n-; try to enable them via splitter/peephole if the value isn't needed anymore.\n-; See testcases: load-and-test-fp-1.c and load-and-test-fp-2.c\n+; load and test instructions turn a signaling NaN into a quiet NaN.  Thus they\n+; may only be used if the target register is dead afterwards or if fast math\n+; is enabled.  The former is done via a peephole optimization.  Note, load and\n+; test instructions may only be used for (in)equality comparisons because\n+; relational comparisons must treat a quiet NaN like a signaling NaN which is\n+; not the case for load and test instructions.  For fast math insn\n+; \"cmp<mode>_ccs_0_fastmath\" applies.\n+; See testcases load-and-test-fp-{1,2}.c\n+\n+(define_peephole2\n+  [(set (match_operand:FP 0 \"register_operand\")\n+\t(match_operand:FP 1 \"const0_operand\"))\n+   (set (reg:CCZ CC_REGNUM)\n+\t(compare:CCZ (match_operand:FP 2 \"register_operand\")\n+\t\t     (match_operand:FP 3 \"register_operand\")))]\n+  \"TARGET_HARD_FLOAT\n+   && FP_REG_P (operands[2])\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && peep2_reg_dead_p (2, operands[0])\n+   && peep2_reg_dead_p (2, operands[2])\"\n+  [(parallel\n+    [(set (reg:CCZ CC_REGNUM)\n+\t  (compare:CCZ (match_dup 2) (match_dup 1)))\n+     (clobber (match_dup 2))])]\n+  \"\")\n \n ; ltxbr, ltdbr, ltebr, ltxtr, ltdtr\n-(define_insn \"*cmp<mode>_ccs_0\"\n-  [(set (reg CC_REGNUM)\n-\t(compare (match_operand:FP 0 \"register_operand\"  \"f\")\n-\t\t (match_operand:FP 1 \"const0_operand\"    \"\")))\n-   (clobber (match_operand:FP      2 \"register_operand\" \"=0\"))]\n-  \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT\"\n+(define_insn \"*cmp<mode>_ccz_0\"\n+  [(set (reg:CCZ CC_REGNUM)\n+\t(compare:CCZ (match_operand:FP 0 \"register_operand\" \"f\")\n+\t\t     (match_operand:FP 1 \"const0_operand\")))\n+   (clobber (match_operand:FP 2 \"register_operand\" \"=0\"))]\n+  \"TARGET_HARD_FLOAT\"\n   \"lt<xde><bt>r\\t%0,%0\"\n    [(set_attr \"op_type\" \"RRE\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n+(define_insn \"*cmp<mode>_ccs_0_fastmath\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (match_operand:FP 0 \"register_operand\" \"f\")\n+\t\t (match_operand:FP 1 \"const0_operand\")))]\n+  \"s390_match_ccmode (insn, CCSmode)\n+   && TARGET_HARD_FLOAT\n+   && !flag_trapping_math\n+   && !flag_signaling_nans\"\n+  \"lt<xde><bt>r\\t%0,%0\"\n+  [(set_attr \"op_type\" \"RRE\")\n+   (set_attr \"type\" \"fsimp<mode>\")])\n+\n ; VX: TFmode in FPR pairs: use cxbr instead of wfcxb\n ; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb\n (define_insn \"*cmp<mode>_ccs\""}, {"sha": "f89d2d36d6191fdf0f54241c298dbc715ab4346d", "filename": "gcc/testsuite/gcc.target/s390/load-and-test-fp-1.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-1.c?ref=1a84651d164e9ebf080e0b64f0ad300eaae46297", "patch": "@@ -1,17 +1,12 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -mzarch\" } */\n+/* { dg-options \"-O3 -mzarch -march=z196\" } */\n \n-/* a is used after the comparison.  We cannot use load and test here\n-   since it would turn SNaNs into QNaNs.  */\n+/* Use load-and-test instructions if compared for (in)equality and if variable\n+   `a` is dead after the comparison.  For all other cases use\n+   compare-and-signal instructions.  */\n \n-double gl;\n+#include \"load-and-test-fp.h\"\n \n-double\n-foo (double dummy, double a)\n-{\n-  if (a == 0.0)\n-    gl = 1;\n-  return a;\n-}\n-\n-/* { dg-final { scan-assembler {\\tcdbr?\\t} } } */\n+/* { dg-final { scan-assembler-times \"ltdbr\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"cdbr\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"kdbr\\t\" 8 } } */"}, {"sha": "53dab3c44240dd869b5bad9712984175cd0816e7", "filename": "gcc/testsuite/gcc.target/s390/load-and-test-fp-2.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp-2.c?ref=1a84651d164e9ebf080e0b64f0ad300eaae46297", "patch": "@@ -1,16 +1,9 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3\" } */\n+/* { dg-options \"-O3 -mzarch -ffast-math\" } */\n \n-/* a is not used after the comparison.  So we should use load and test\n-   here.  */\n+/* Fast-math implies -fno-trapping-math -fno-signaling-nans which imply\n+   that no user visible trap will happen.  */\n \n-double gl;\n+#include \"load-and-test-fp.h\"\n \n-void\n-bar (double a)\n-{\n-  if (a == 0.0)\n-    gl = 1;\n-}\n-\n-/* { dg-final { scan-assembler \"ltdbr\\t\" } } */\n+/* { dg-final { scan-assembler-times \"ltdbr\\t\" 12 } } */"}, {"sha": "f153d96698d9330682ae059028afd59fe106ac5f", "filename": "gcc/testsuite/gcc.target/s390/load-and-test-fp.h", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a84651d164e9ebf080e0b64f0ad300eaae46297/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fload-and-test-fp.h?ref=1a84651d164e9ebf080e0b64f0ad300eaae46297", "patch": "@@ -0,0 +1,12 @@\n+double gl;\n+\n+#define test(N, CMP) \\\n+  void   N ## _dead(double a) { if (a CMP 0.0) gl = 1; } \\\n+  double N ## _live(double a) { if (a CMP 0.0) gl = 1; return a; }\n+\n+test(eq, ==)\n+test(ne, !=)\n+test(ge, >=)\n+test(gt, >)\n+test(le, <=)\n+test(lt, <)"}]}