{"sha": "38877e985111f3a7434aa9583f0789bc157b2993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4NzdlOTg1MTExZjNhNzQzNGFhOTU4M2YwNzg5YmMxNTdiMjk5Mw==", "commit": {"author": {"name": "Zolotukhin Michael", "email": "michael.v.zolotukhin@gmail.com", "date": "2011-11-14T17:28:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-11-14T17:28:11Z"}, "message": "sw-1.c: Force rep;movsb.\n\n\t* gcc.target/i386/sw-1.c: Force rep;movsb.\n\n        * config/i386/i386.h (processor_costs): Add second dimension to\n        stringop_algs array.\n        * config/i386/i386.c (cost models): Initialize second dimension of\n        stringop_algs arrays.\n\t(core_cost): New costs based on generic64 costs with updated stringop\n\tvalues.\n        (promote_duplicated_reg): Add support for vector modes, add\n        declaration.\n        (promote_duplicated_reg_to_size): Likewise.\n\t(processor_target): Set core costs for core variants.\n        (expand_set_or_movmem_via_loop_with_iter): New function.\n        (expand_set_or_movmem_via_loop): Enable reuse of the same iters in\n        different loops, produced by this function.\n        (emit_strset): New function.\n        (expand_movmem_epilogue): Add epilogue generation for bigger sizes,\n        use SSE-moves where possible.\n        (expand_setmem_epilogue): Likewise.\n        (expand_movmem_prologue): Likewise for prologue.\n        (expand_setmem_prologue): Likewise.\n        (expand_constant_movmem_prologue): Likewise.\n        (expand_constant_setmem_prologue): Likewise.\n        (decide_alg): Add new argument align_unknown.  Fix algorithm of\n        strategy selection if TARGET_INLINE_ALL_STRINGOPS is set; Skip sse_loop\n        (decide_alignment): Update desired alignment according to chosen move\n        mode.\n        (ix86_expand_movmem): Change unrolled_loop strategy to use SSE-moves.\n        (ix86_expand_setmem): Likewise.\n        (ix86_slow_unaligned_access): Implementation of new hook\n        slow_unaligned_access.\n        * config/i386/i386.md (strset): Enable half-SSE moves.\n        * config/i386/sse.md (vec_dupv4si): Add expand for vec_dupv4si.\n        (vec_dupv2di): Add expand for vec_dupv2di.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r181357", "tree": {"sha": "a056d217a6b6535a0003656585756c9e14fbf24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a056d217a6b6535a0003656585756c9e14fbf24c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38877e985111f3a7434aa9583f0789bc157b2993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38877e985111f3a7434aa9583f0789bc157b2993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38877e985111f3a7434aa9583f0789bc157b2993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38877e985111f3a7434aa9583f0789bc157b2993/comments", "author": {"login": "ZolotukhinM", "id": 4588111, "node_id": "MDQ6VXNlcjQ1ODgxMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4588111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ZolotukhinM", "html_url": "https://github.com/ZolotukhinM", "followers_url": "https://api.github.com/users/ZolotukhinM/followers", "following_url": "https://api.github.com/users/ZolotukhinM/following{/other_user}", "gists_url": "https://api.github.com/users/ZolotukhinM/gists{/gist_id}", "starred_url": "https://api.github.com/users/ZolotukhinM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ZolotukhinM/subscriptions", "organizations_url": "https://api.github.com/users/ZolotukhinM/orgs", "repos_url": "https://api.github.com/users/ZolotukhinM/repos", "events_url": "https://api.github.com/users/ZolotukhinM/events{/privacy}", "received_events_url": "https://api.github.com/users/ZolotukhinM/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8acdd3c52e497e7139cc19bfa99ca7ac3331850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8acdd3c52e497e7139cc19bfa99ca7ac3331850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8acdd3c52e497e7139cc19bfa99ca7ac3331850"}], "stats": {"total": 1145, "additions": 898, "deletions": 247}, "files": [{"sha": "9a713cfbf1c602dfdf6e45dfe3b8fd04a0e31fe8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -1,3 +1,39 @@\n+2011-11-14  Zolotukhin Michael  <michael.v.zolotukhin@gmail.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+        * config/i386/i386.h (processor_costs): Add second dimension to\n+        stringop_algs array.\n+        * config/i386/i386.c (cost models): Initialize second dimension of\n+        stringop_algs arrays.\n+\t(core_cost): New costs based on generic64 costs with updated stringop\n+\tvalues.\n+        (promote_duplicated_reg): Add support for vector modes, add\n+        declaration.\n+        (promote_duplicated_reg_to_size): Likewise.\n+\t(processor_target): Set core costs for core variants.\n+        (expand_set_or_movmem_via_loop_with_iter): New function.\n+        (expand_set_or_movmem_via_loop): Enable reuse of the same iters in\n+        different loops, produced by this function.\n+        (emit_strset): New function.\n+        (expand_movmem_epilogue): Add epilogue generation for bigger sizes,\n+        use SSE-moves where possible.\n+        (expand_setmem_epilogue): Likewise.\n+        (expand_movmem_prologue): Likewise for prologue.\n+        (expand_setmem_prologue): Likewise.\n+        (expand_constant_movmem_prologue): Likewise.\n+        (expand_constant_setmem_prologue): Likewise.\n+        (decide_alg): Add new argument align_unknown.  Fix algorithm of\n+        strategy selection if TARGET_INLINE_ALL_STRINGOPS is set; Skip sse_loop\n+        (decide_alignment): Update desired alignment according to chosen move\n+        mode.\n+        (ix86_expand_movmem): Change unrolled_loop strategy to use SSE-moves.\n+        (ix86_expand_setmem): Likewise.\n+        (ix86_slow_unaligned_access): Implementation of new hook\n+        slow_unaligned_access.\n+        * config/i386/i386.md (strset): Enable half-SSE moves.\n+        * config/i386/sse.md (vec_dupv4si): Add expand for vec_dupv4si.\n+        (vec_dupv2di): Add expand for vec_dupv2di.\n+\n 2011-11-14  Dimitrios Apostolou  <jimis@gmx.net>\n \n \tPR bootstrap/51094"}, {"sha": "834d3d4a44318c5cb36e10a99ebbe9f89b40b22d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -641,6 +641,7 @@ void debug_varpool_node_set (varpool_node_set);\n void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n bool cgraph_comdat_can_be_unshared_p (struct cgraph_node *);\n+bool varpool_externally_visible_p (struct varpool_node *, bool);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n@@ -681,6 +682,7 @@ bool const_value_known_p (tree);\n bool varpool_for_node_and_aliases (struct varpool_node *,\n \t\t                   bool (*) (struct varpool_node *, void *),\n \t\t\t           void *, bool);\n+void varpool_add_new_variable (tree);\n \n /* Walk all reachable static variables.  */\n #define FOR_EACH_STATIC_VARIABLE(node) \\"}, {"sha": "07f58b99e3502b02077ae3ef6dfc6a209e229a30", "filename": "gcc/config/i386/i386-opts.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-opts.h?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -37,7 +37,8 @@ enum stringop_alg\n    rep_prefix_8_byte,\n    loop_1_byte,\n    loop,\n-   unrolled_loop\n+   unrolled_loop,\n+   sse_loop\n };\n \n /* Available call abi.  */"}, {"sha": "a8e8a6a40e1c50a8c8c88225ce59e4b452b38b07", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 806, "deletions": 240, "changes": 1046, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -561,10 +561,14 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}}},\n+  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n+   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -632,10 +636,14 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -704,10 +712,14 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+  {{{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -774,10 +786,14 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{-1, rep_prefix_4_byte}}},\n+   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{libcall, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{-1, rep_prefix_4_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -849,12 +865,18 @@ struct processor_costs pentiumpro_cost = {\n      noticeable win, for bigger blocks either rep movsl or rep movsb is\n      way to go.  Rep movsb has apparently more expensive startup time in CPU,\n      but after 4K the difference is down in the noise.  */\n-  {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n+  {{{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n \t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{1024, unrolled_loop},\n-  \t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n+   {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n+\t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{rep_prefix_4_byte, {{1024, unrolled_loop},\n+\t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{rep_prefix_4_byte, {{1024, unrolled_loop},\n+\t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -922,10 +944,14 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -995,10 +1021,14 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1068,10 +1098,14 @@ struct processor_costs athlon_cost = {\n   /* For some reason, Athlon deals better with REP prefix (relative to loops)\n      compared to K8. Alignment becomes important after 8 bytes for memcpy and\n      128 bytes for memset.  */\n-  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  {{{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1146,11 +1180,16 @@ struct processor_costs k8_cost = {\n   /* K8 has optimized REP instruction for medium sized blocks, but for very\n      small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n+   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1233,11 +1272,16 @@ struct processor_costs amdfam10_cost = {\n   /* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {512, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {512, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1320,11 +1364,16 @@ struct processor_costs bdver1_cost = {\n   /*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n+   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1407,11 +1456,16 @@ struct processor_costs bdver2_cost = {\n   /*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1489,11 +1543,16 @@ struct processor_costs btver1_cost = {\n   /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n+   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1560,11 +1619,18 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+\n+  {{{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+   {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+   DUMMY_STRINGOP_ALGS}},\n+\n+  {{{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+   {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1631,13 +1697,22 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+\n+  {{{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n \t      {100000, unrolled_loop}, {-1, libcall}}}},\n-  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+   {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n+\t      {100000, unrolled_loop}, {-1, libcall}}}}},\n+\n+  {{{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    {libcall, {{24, loop}, {64, unrolled_loop},\n \t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+   {-1, libcall}}},\n+   {libcall, {{24, loop}, {64, unrolled_loop},\n+\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1704,13 +1779,108 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{32, loop}, {64, rep_prefix_4_byte},\n-\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {15, unrolled_loop},\n-\t  {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{24, loop}, {32, unrolled_loop},\n-\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+\n+  /* stringop_algs for memcpy.  \n+     SSE loops works best on Atom, but fall back into non-SSE unrolled loop variant\n+     if that fails.  */\n+  {{{libcall, {{4096, sse_loop}, {4096, unrolled_loop}, {-1, libcall}}}, /* Known alignment.  */\n+    {libcall, {{4096, sse_loop}, {4096, unrolled_loop}, {-1, libcall}}}},\n+   {{libcall, {{-1, libcall}}},\t\t\t       /* Unknown alignment.  */\n+    {libcall, {{2048, sse_loop}, {2048, unrolled_loop},\n+\t       {-1, libcall}}}}},\n+\n+  /* stringop_algs for memset.  */\n+  {{{libcall, {{4096, sse_loop}, {4096, unrolled_loop}, {-1, libcall}}}, /* Known alignment.  */\n+    {libcall, {{4096, sse_loop}, {4096, unrolled_loop}, {-1, libcall}}}},\n+   {{libcall, {{1024, sse_loop}, {1024, unrolled_loop},\t /* Unknown alignment.  */\n+\t       {-1, libcall}}},\n+    {libcall, {{2048, sse_loop}, {2048, unrolled_loop},\n+\t       {-1, libcall}}}}},\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n+};\n+\n+/* Core should produce code tuned for core variants.  */\n+static const\n+struct processor_costs core_cost = {\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  /* On all chips taken into consideration lea is 2 cycles and more.  With\n+     this cost however our current implementation of synth_mult results in\n+     use of unnecessary temporary registers causing regression on several\n+     SPECfp benchmarks.  */\n+  COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  17,\t\t\t\t\t/* MOVE_RATIO */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  32,\t\t\t\t\t/* size of l1 cache.  */\n+  512,\t\t\t\t\t/* size of l2 cache.  */\n+  64,\t\t\t\t\t/* size of prefetch block */\n+  6,\t\t\t\t\t/* number of parallel prefetches */\n+  /* Benchmarks shows large regressions on K8 sixtrack benchmark when this\n+     value is increased to perhaps more appropriate value of 5.  */\n+  3,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (20),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+\n+  /* stringop_algs for memcpy.  */\n+  {{{libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_4_byte}, {-1, libcall}}}, /* Known alignment.  */\n+    {libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {{libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_4_byte}, {-1, libcall}}}, /* Unknown alignment.  */\n+    {libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_8_byte}, {-1, libcall}}}}},\n+\n+  /* stringop_algs for memset.  */\n+  {{{libcall, {{256, rep_prefix_4_byte}}}, /* Known alignment.  */\n+    {libcall, {{256, rep_prefix_8_byte}}}},\n+   {{libcall, {{256, rep_prefix_4_byte}}}, /* Unknown alignment.  */\n+    {libcall, {{256, rep_prefix_8_byte}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1724,7 +1894,7 @@ struct processor_costs atom_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-/* Generic64 should produce code tuned for Nocona and K8.  */\n+/* Generic64 should produce code tuned for Nocona, Core,  K8, Amdfam10 and buldozer.  */\n static const\n struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1784,10 +1954,16 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+\n+  {{DUMMY_STRINGOP_ALGS,\n+    {libcall, {{16, rep_prefix_4_byte}, {128, rep_prefix_8_byte}, {4096, rep_prefix_1_byte}, {-1, libcall}}}},\n+   {DUMMY_STRINGOP_ALGS,\n+    {libcall, {{128, rep_prefix_4_byte}, {4096, rep_prefix_1_byte}, {-1, libcall}}}}},\n+\n+  {{DUMMY_STRINGOP_ALGS,\n+    {libcall, {{16, rep_prefix_4_byte}, {512, unrolled_loop}, {4096, rep_prefix_1_byte}, {-1, libcall}}}},\n+   {DUMMY_STRINGOP_ALGS,\n+    {libcall, {{16, rep_prefix_4_byte}, {512, unrolled_loop}, {4096, rep_prefix_1_byte}, {-1, libcall}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1801,8 +1977,8 @@ struct processor_costs generic64_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-/* Generic32 should produce code tuned for PPro, Pentium4, Nocona,\n-   Athlon and K8.  */\n+/* Generic32 should produce code tuned for PPro, Pentium4, Nocona, Core\n+   Athlon, K8, amdfam10, buldozer.  */\n static const\n struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1856,10 +2032,16 @@ struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  /* stringop_algs for memcpy.  */\n+  {{{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n+  /* stringop_algs for memset.  */\n+  {{{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -2536,6 +2718,8 @@ static void ix86_set_current_function (tree);\n static unsigned int ix86_minimum_incoming_stack_boundary (bool);\n \n static enum calling_abi ix86_function_abi (const_tree);\n+static rtx promote_duplicated_reg (enum machine_mode, rtx);\n+static rtx promote_duplicated_reg_to_size (rtx, int, int, int);\n \n \f\n #ifndef SUBTARGET32_DEFAULT_CPU\n@@ -2582,13 +2766,13 @@ static const struct ptt processor_target_table[PROCESSOR_max] =\n   {&k8_cost, 16, 7, 16, 7, 16},\n   {&nocona_cost, 0, 0, 0, 0, 0},\n   /* Core 2 32-bit.  */\n-  {&generic32_cost, 16, 10, 16, 10, 16},\n+  {&core_cost, 16, 10, 16, 10, 16},\n   /* Core 2 64-bit.  */\n-  {&generic64_cost, 16, 10, 16, 10, 16},\n+  {&core_cost, 16, 10, 16, 10, 16},\n   /* Core i7 32-bit.  */\n-  {&generic32_cost, 16, 10, 16, 10, 16},\n+  {&core_cost, 16, 10, 16, 10, 16},\n   /* Core i7 64-bit.  */\n-  {&generic64_cost, 16, 10, 16, 10, 16},\n+  {&core_cost, 16, 10, 16, 10, 16},\n   {&generic32_cost, 16, 7, 16, 7, 16},\n   {&generic64_cost, 16, 10, 16, 10, 16},\n   {&amdfam10_cost, 32, 24, 32, 7, 32},\n@@ -20923,33 +21107,50 @@ counter_mode (rtx count_exp)\n   return SImode;\n }\n \n-/* When SRCPTR is non-NULL, output simple loop to move memory\n+/* Helper function for expand_set_or_movmem_via_loop.\n+\n+   When SRCPTR is non-NULL, output simple loop to move memory\n    pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n    overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n    equivalent loop to set memory by VALUE (supposed to be in MODE).\n \n    The size is rounded down to whole number of chunk size moved at once.\n-   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n+   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.\n \n+   If ITER isn't NULL, than it'll be used in the generated loop without\n+   initialization (that allows to generate several consequent loops using the\n+   same iterator).\n+   If CHANGE_PTRS is specified, DESTPTR and SRCPTR would be increased by\n+   iterator value at the end of the function (as if they iterate in the loop).\n+   Otherwise, their vaules'll stay unchanged.\n \n-static void\n-expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n-\t\t\t       rtx destptr, rtx srcptr, rtx value,\n-\t\t\t       rtx count, enum machine_mode mode, int unroll,\n-\t\t\t       int expected_size)\n+   If EXPECTED_SIZE isn't -1, than it's used to compute branch-probabilities on\n+   the loop backedge.  When expected size is unknown (it's -1), the probability\n+   is set to 80%.\n+\n+   Return value is rtx of iterator, used in the loop - it could be reused in\n+   consequent calls of this function.  */\n+static rtx\n+expand_set_or_movmem_via_loop_with_iter (rtx destmem, rtx srcmem,\n+\t\t\t\t\t rtx destptr, rtx srcptr, rtx value,\n+\t\t\t\t\t rtx count, rtx iter,\n+\t\t\t\t\t enum machine_mode mode, int unroll,\n+\t\t\t\t\t int expected_size, bool change_ptrs)\n {\n-  rtx out_label, top_label, iter, tmp;\n+  rtx out_label, top_label, tmp;\n   enum machine_mode iter_mode = counter_mode (count);\n   rtx piece_size = GEN_INT (GET_MODE_SIZE (mode) * unroll);\n   rtx piece_size_mask = GEN_INT (~((GET_MODE_SIZE (mode) * unroll) - 1));\n   rtx size;\n   rtx x_addr;\n   rtx y_addr;\n   int i;\n+  bool reuse_iter = (iter != NULL_RTX);\n \n   top_label = gen_label_rtx ();\n   out_label = gen_label_rtx ();\n-  iter = gen_reg_rtx (iter_mode);\n+  if (!reuse_iter)\n+    iter = gen_reg_rtx (iter_mode);\n \n   size = expand_simple_binop (iter_mode, AND, count, piece_size_mask,\n \t\t\t      NULL, 1, OPTAB_DIRECT);\n@@ -20960,18 +21161,21 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t       true, out_label);\n       predict_jump (REG_BR_PROB_BASE * 10 / 100);\n     }\n-  emit_move_insn (iter, const0_rtx);\n+  if (!reuse_iter)\n+    emit_move_insn (iter, const0_rtx);\n \n   emit_label (top_label);\n \n   tmp = convert_modes (Pmode, iter_mode, iter, true);\n   x_addr = gen_rtx_PLUS (Pmode, destptr, tmp);\n-  destmem = change_address (destmem, mode, x_addr);\n+  destmem =\n+    adjust_automodify_address_nv (copy_rtx (destmem), mode, x_addr, 0);\n \n   if (srcmem)\n     {\n       y_addr = gen_rtx_PLUS (Pmode, srcptr, copy_rtx (tmp));\n-      srcmem = change_address (srcmem, mode, y_addr);\n+      srcmem =\n+\tadjust_automodify_address_nv (copy_rtx (srcmem), mode, y_addr, 0);\n \n       /* When unrolling for chips that reorder memory reads and writes,\n \t we can save registers by using single temporary.\n@@ -21043,19 +21247,43 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n     }\n   else\n     predict_jump (REG_BR_PROB_BASE * 80 / 100);\n-  iter = ix86_zero_extend_to_Pmode (iter);\n-  tmp = expand_simple_binop (Pmode, PLUS, destptr, iter, destptr,\n-\t\t\t     true, OPTAB_LIB_WIDEN);\n-  if (tmp != destptr)\n-    emit_move_insn (destptr, tmp);\n-  if (srcptr)\n+  if (change_ptrs)\n     {\n-      tmp = expand_simple_binop (Pmode, PLUS, srcptr, iter, srcptr,\n+      iter = ix86_zero_extend_to_Pmode (iter);\n+      tmp = expand_simple_binop (Pmode, PLUS, destptr, iter, destptr,\n \t\t\t\t true, OPTAB_LIB_WIDEN);\n-      if (tmp != srcptr)\n-\temit_move_insn (srcptr, tmp);\n+      if (tmp != destptr)\n+\temit_move_insn (destptr, tmp);\n+      if (srcptr)\n+\t{\n+\t  tmp = expand_simple_binop (Pmode, PLUS, srcptr, iter, srcptr,\n+\t\t\t\t     true, OPTAB_LIB_WIDEN);\n+\t  if (tmp != srcptr)\n+\t    emit_move_insn (srcptr, tmp);\n+\t}\n     }\n   emit_label (out_label);\n+  return iter;\n+}\n+\n+/* When SRCPTR is non-NULL, output simple loop to move memory\n+   pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n+   overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n+   equivalent loop to set memory by VALUE (supposed to be in MODE).\n+\n+   The size is rounded down to whole number of chunk size moved at once.\n+   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n+\n+static void\n+expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n+\t\t\t       rtx destptr, rtx srcptr, rtx value,\n+\t\t\t       rtx count, enum machine_mode mode, int unroll,\n+\t\t\t       int expected_size)\n+{\n+  expand_set_or_movmem_via_loop_with_iter (destmem, srcmem,\n+\t\t\t\t destptr, srcptr, value,\n+\t\t\t\t count, NULL_RTX, mode, unroll,\n+\t\t\t\t expected_size, true);\n }\n \n /* Output \"rep; mov\" instruction.\n@@ -21159,7 +21387,18 @@ emit_strmov (rtx destmem, rtx srcmem,\n   emit_insn (gen_strmov (destptr, dest, srcptr, src));\n }\n \n-/* Output code to copy at most count & (max_size - 1) bytes from SRC to DEST.  */\n+/* Emit strset instuction.  If RHS is constant, and vector mode will be used,\n+   then move this constant to a vector register before emitting strset.  */\n+static void\n+emit_strset (rtx destmem, rtx value,\n+\t     rtx destptr, enum machine_mode mode, int offset)\n+{\n+  rtx dest = adjust_automodify_address_nv (destmem, mode, destptr, offset);\n+  emit_insn (gen_strset (destptr, dest, value));\n+}\n+\n+/* Output code to copy (COUNT % MAX_SIZE) bytes from SRCPTR to DESTPTR.\n+   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n static void\n expand_movmem_epilogue (rtx destmem, rtx srcmem,\n \t\t\trtx destptr, rtx srcptr, rtx count, int max_size)\n@@ -21170,43 +21409,55 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n       HOST_WIDE_INT countval = INTVAL (count);\n       int offset = 0;\n \n-      if ((countval & 0x10) && max_size > 16)\n+      int remainder_size = countval % max_size;\n+      enum machine_mode move_mode = Pmode;\n+\n+      /* Firstly, try to move data with the widest possible mode.\n+\t Remaining part we'll move using Pmode and narrower modes.  */\n+      if (TARGET_SSE)\n \t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset + 8);\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t  offset += 16;\n+\t  if (max_size >= GET_MODE_SIZE (V4SImode))\n+\t    move_mode = V4SImode;\n+\t  else if (max_size >= GET_MODE_SIZE (DImode))\n+\t    move_mode = DImode;\n \t}\n-      if ((countval & 0x08) && max_size > 8)\n+\n+      while (remainder_size >= GET_MODE_SIZE (move_mode))\n \t{\n-\t  if (TARGET_64BIT)\n-\t    emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n-\t  else\n-\t    {\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset + 4);\n-\t    }\n-\t  offset += 8;\n+\t  emit_strmov (destmem, srcmem, destptr, srcptr, move_mode, offset);\n+\t  offset += GET_MODE_SIZE (move_mode);\n+\t  remainder_size -= GET_MODE_SIZE (move_mode);\n \t}\n-      if ((countval & 0x04) && max_size > 4)\n+\n+      /* Move the remaining part of epilogue - its size might be\n+\t a size of the widest mode.  */\n+      move_mode = Pmode;\n+      while (remainder_size >= GET_MODE_SIZE (move_mode))\n \t{\n-          emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n+\t  emit_strmov (destmem, srcmem, destptr, srcptr, move_mode, offset);\n+\t  offset += GET_MODE_SIZE (move_mode);\n+\t  remainder_size -= GET_MODE_SIZE (move_mode);\n+\t}\n+\n+      if (remainder_size >= 4)\n+\t{\n+\t  emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n \t  offset += 4;\n+\t  remainder_size -= 4;\n \t}\n-      if ((countval & 0x02) && max_size > 2)\n+      if (remainder_size >= 2)\n \t{\n-          emit_strmov (destmem, srcmem, destptr, srcptr, HImode, offset);\n+\t  emit_strmov (destmem, srcmem, destptr, srcptr, HImode, offset);\n \t  offset += 2;\n+\t  remainder_size -= 2;\n \t}\n-      if ((countval & 0x01) && max_size > 1)\n+      if (remainder_size >= 1)\n \t{\n-          emit_strmov (destmem, srcmem, destptr, srcptr, QImode, offset);\n+\t  emit_strmov (destmem, srcmem, destptr, srcptr, QImode, offset);\n \t  offset += 1;\n+\t  remainder_size -= 1;\n \t}\n+      gcc_assert (remainder_size == 0);\n       return;\n     }\n   if (max_size > 8)\n@@ -21312,87 +21563,121 @@ expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n \t\t\t\t 1, max_size / 2);\n }\n \n-/* Output code to set at most count & (max_size - 1) bytes starting by DEST.  */\n+/* Output code to set with VALUE at most (COUNT % MAX_SIZE) bytes starting from\n+   DESTPTR.\n+   DESTMEM provides MEMrtx to feed proper aliasing info.\n+   PROMOTED_TO_GPR_VALUE is rtx representing a GPR containing broadcasted VALUE.\n+   PROMOTED_TO_VECTOR_VALUE is rtx representing a vector register containing\n+   broadcasted VALUE.\n+   PROMOTED_TO_GPR_VALUE and PROMOTED_TO_VECTOR_VALUE could be NULL if the\n+   promotion hasn't been generated before.  */\n static void\n-expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx count, int max_size)\n+expand_setmem_epilogue (rtx destmem, rtx destptr, rtx promoted_to_vector_value,\n+\t\t\trtx promoted_to_gpr_value, rtx value, rtx count,\n+\t\t\tint max_size)\n {\n-  rtx dest;\n-\n   if (CONST_INT_P (count))\n     {\n       HOST_WIDE_INT countval = INTVAL (count);\n       int offset = 0;\n \n-      if ((countval & 0x10) && max_size > 16)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset + 8);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t  offset += 16;\n-\t}\n-      if ((countval & 0x08) && max_size > 8)\n+      int remainder_size = countval % max_size;\n+      enum machine_mode move_mode = Pmode;\n+\n+      /* Firstly, try to move data with the widest possible mode.\n+\t Remaining part we'll move using Pmode and narrower modes.  */\n+\n+      if (promoted_to_vector_value)\n+\twhile (remainder_size >= 16)\n+\t  {\n+\t    if (GET_MODE (destmem) != move_mode)\n+\t      destmem = adjust_automodify_address_nv (destmem, move_mode,\n+\t\t\t\t\t\t      destptr, offset);\n+\t    emit_strset (destmem, promoted_to_vector_value, destptr,\n+\t\t\t move_mode, offset);\n+\n+\t    offset += 16;\n+\t    remainder_size -= 16;\n+\t  }\n+\n+      /* Move the remaining part of epilogue - its size might be\n+\t a size of the widest mode.  */\n+      while (remainder_size >= GET_MODE_SIZE (Pmode))\n \t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t    }\n-\t  else\n-\t    {\n-\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset + 4);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t    }\n-\t  offset += 8;\n+\t  if (!promoted_to_gpr_value)\n+\t    promoted_to_gpr_value = promote_duplicated_reg (Pmode, value);\n+\t  emit_strset (destmem, promoted_to_gpr_value, destptr, Pmode, offset);\n+\t  offset += GET_MODE_SIZE (Pmode);\n+\t  remainder_size -= GET_MODE_SIZE (Pmode);\n \t}\n-      if ((countval & 0x04) && max_size > 4)\n+\n+      if (!promoted_to_gpr_value && remainder_size > 1)\n+\tpromoted_to_gpr_value = promote_duplicated_reg (remainder_size >= 4\n+\t\t\t\t\t\t\t? SImode : HImode, value);\n+      if (remainder_size >= 4)\n \t{\n-\t  dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (SImode, value)));\n+\t  emit_strset (destmem, gen_lowpart (SImode, promoted_to_gpr_value), destptr,\n+\t\t       SImode, offset);\n \t  offset += 4;\n+\t  remainder_size -= 4;\n \t}\n-      if ((countval & 0x02) && max_size > 2)\n+      if (remainder_size >= 2)\n \t{\n-\t  dest = adjust_automodify_address_nv (destmem, HImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (HImode, value)));\n-\t  offset += 2;\n+\t  emit_strset (destmem, gen_lowpart (HImode, promoted_to_gpr_value), destptr,\n+\t\t       HImode, offset);\n+\t  offset +=2;\n+\t  remainder_size -= 2;\n \t}\n-      if ((countval & 0x01) && max_size > 1)\n+      if (remainder_size >= 1)\n \t{\n-\t  dest = adjust_automodify_address_nv (destmem, QImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (QImode, value)));\n+\t  emit_strset (destmem,\n+\t\t       promoted_to_gpr_value ? gen_lowpart (QImode, promoted_to_gpr_value) : value,\n+\t\t        destptr,\n+\t\t       QImode, offset);\n \t  offset += 1;\n+\t  remainder_size -= 1;\n \t}\n+      gcc_assert (remainder_size == 0);\n       return;\n     }\n+\n+  /* count isn't const.  */\n   if (max_size > 32)\n     {\n-      expand_setmem_epilogue_via_loop (destmem, destptr, value, count, max_size);\n+      expand_setmem_epilogue_via_loop (destmem, destptr, value, count,\n+\t\t\t\t       max_size);\n       return;\n     }\n+\n+  if (!promoted_to_gpr_value)\n+    promoted_to_gpr_value = promote_duplicated_reg_to_size (value,\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode));\n+\n   if (max_size > 16)\n     {\n       rtx label = ix86_expand_aligntest (count, 16, true);\n-      if (TARGET_64BIT)\n+      if (TARGET_SSE && promoted_to_vector_value)\n \t{\n-\t  dest = change_address (destmem, DImode, destptr);\n-\t  emit_insn (gen_strset (destptr, dest, value));\n-\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  destmem = change_address (destmem,\n+\t\t\t\t    GET_MODE (promoted_to_vector_value),\n+\t\t\t\t    destptr);\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_vector_value));\n+\t}\n+      else if (TARGET_64BIT)\n+\t{\n+\t  destmem = change_address (destmem, DImode, destptr);\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n \t}\n       else\n \t{\n-\t  dest = change_address (destmem, SImode, destptr);\n-\t  emit_insn (gen_strset (destptr, dest, value));\n-\t  emit_insn (gen_strset (destptr, dest, value));\n-\t  emit_insn (gen_strset (destptr, dest, value));\n-\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  destmem = change_address (destmem, SImode, destptr);\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n@@ -21402,39 +21687,50 @@ expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx count, int max_\n       rtx label = ix86_expand_aligntest (count, 8, true);\n       if (TARGET_64BIT)\n \t{\n-\t  dest = change_address (destmem, DImode, destptr);\n-\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  destmem = change_address (destmem, DImode, destptr);\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t}\n+      /* FIXME: When this hunk it output, IRA classifies promoted_to_vector_value\n+         as NO_REGS.  */\n+      else if (TARGET_SSE && promoted_to_vector_value && 0)\n+\t{\n+\t  destmem = change_address (destmem, V2SImode, destptr);\n+\t  emit_insn (gen_strset (destptr, destmem,\n+\t\t\t\t gen_lowpart (V2SImode, promoted_to_vector_value)));\n \t}\n       else\n \t{\n-\t  dest = change_address (destmem, SImode, destptr);\n-\t  emit_insn (gen_strset (destptr, dest, value));\n-\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  destmem = change_address (destmem, SImode, destptr);\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 4)\n     {\n       rtx label = ix86_expand_aligntest (count, 4, true);\n-      dest = change_address (destmem, SImode, destptr);\n-      emit_insn (gen_strset (destptr, dest, gen_lowpart (SImode, value)));\n+      destmem = change_address (destmem, SImode, destptr);\n+      emit_insn (gen_strset (destptr, destmem,\n+\t\t\t     gen_lowpart (SImode, promoted_to_gpr_value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 2)\n     {\n       rtx label = ix86_expand_aligntest (count, 2, true);\n-      dest = change_address (destmem, HImode, destptr);\n-      emit_insn (gen_strset (destptr, dest, gen_lowpart (HImode, value)));\n+      destmem = change_address (destmem, HImode, destptr);\n+      emit_insn (gen_strset (destptr, destmem,\n+\t\t\t     gen_lowpart (HImode, promoted_to_gpr_value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 1)\n     {\n       rtx label = ix86_expand_aligntest (count, 1, true);\n-      dest = change_address (destmem, QImode, destptr);\n-      emit_insn (gen_strset (destptr, dest, gen_lowpart (QImode, value)));\n+      destmem = change_address (destmem, QImode, destptr);\n+      emit_insn (gen_strset (destptr, destmem,\n+\t\t\t     gen_lowpart (QImode, promoted_to_gpr_value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n@@ -21450,8 +21746,8 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 1 && desired_alignment > 1)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 1, false);\n-      srcmem = change_address (srcmem, QImode, srcptr);\n-      destmem = change_address (destmem, QImode, destptr);\n+      srcmem = adjust_automodify_address_nv (srcmem, QImode, srcptr, 0);\n+      destmem = adjust_automodify_address_nv (destmem, QImode, destptr, 0);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 1);\n       emit_label (label);\n@@ -21460,8 +21756,8 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 2 && desired_alignment > 2)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 2, false);\n-      srcmem = change_address (srcmem, HImode, srcptr);\n-      destmem = change_address (destmem, HImode, destptr);\n+      srcmem = adjust_automodify_address_nv (srcmem, HImode, srcptr, 0);\n+      destmem = adjust_automodify_address_nv (destmem, HImode, destptr, 0);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 2);\n       emit_label (label);\n@@ -21470,14 +21766,34 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 4 && desired_alignment > 4)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 4, false);\n-      srcmem = change_address (srcmem, SImode, srcptr);\n-      destmem = change_address (destmem, SImode, destptr);\n+      srcmem = adjust_automodify_address_nv (srcmem, SImode, srcptr, 0);\n+      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 4);\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n-  gcc_assert (desired_alignment <= 8);\n+  if (align <= 8 && desired_alignment > 8)\n+    {\n+      rtx label = ix86_expand_aligntest (destptr, 8, false);\n+      if (TARGET_64BIT || TARGET_SSE)\n+\t{\n+\t  srcmem = adjust_automodify_address_nv (srcmem, DImode, srcptr, 0);\n+\t  destmem = adjust_automodify_address_nv (destmem, DImode, destptr, 0);\n+\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n+\t}\n+      else\n+\t{\n+\t  srcmem = adjust_automodify_address_nv (srcmem, SImode, srcptr, 0);\n+\t  destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n+\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n+\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n+\t}\n+      ix86_adjust_counter (count, 8);\n+      emit_label (label);\n+      LABEL_NUSES (label) = 1;\n+    }\n+  gcc_assert (desired_alignment <= 16);\n }\n \n /* Copy enough from DST to SRC to align DST known to DESIRED_ALIGN.\n@@ -21532,14 +21848,47 @@ expand_constant_movmem_prologue (rtx dst, rtx *srcp, rtx destreg, rtx srcreg,\n       off = 4;\n       emit_insn (gen_strmov (destreg, dst, srcreg, src));\n     }\n+  if (align_bytes & 8)\n+    {\n+      if (TARGET_64BIT || TARGET_SSE)\n+\t{\n+\t  dst = adjust_automodify_address_nv (dst, DImode, destreg, off);\n+\t  src = adjust_automodify_address_nv (src, DImode, srcreg, off);\n+\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n+\t}\n+      else\n+\t{\n+\t  dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n+\t  src = adjust_automodify_address_nv (src, SImode, srcreg, off);\n+\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n+\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n+\t}\n+      if (MEM_ALIGN (dst) < 8 * BITS_PER_UNIT)\n+\tset_mem_align (dst, 8 * BITS_PER_UNIT);\n+      if (src_align_bytes >= 0)\n+\t{\n+\t  unsigned int src_align = 0;\n+\t  if ((src_align_bytes & 7) == (align_bytes & 7))\n+\t    src_align = 8;\n+\t  else if ((src_align_bytes & 3) == (align_bytes & 3))\n+\t    src_align = 4;\n+\t  else if ((src_align_bytes & 1) == (align_bytes & 1))\n+\t    src_align = 2;\n+\t  if (MEM_ALIGN (src) < src_align * BITS_PER_UNIT)\n+\t    set_mem_align (src, src_align * BITS_PER_UNIT);\n+\t}\n+      off = 8;\n+    }\n   dst = adjust_automodify_address_nv (dst, BLKmode, destreg, off);\n   src = adjust_automodify_address_nv (src, BLKmode, srcreg, off);\n   if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n     set_mem_align (dst, desired_align * BITS_PER_UNIT);\n   if (src_align_bytes >= 0)\n     {\n       unsigned int src_align = 0;\n-      if ((src_align_bytes & 7) == (align_bytes & 7))\n+      if ((src_align_bytes & 15) == (align_bytes & 15))\n+\tsrc_align = 16;\n+      else if ((src_align_bytes & 7) == (align_bytes & 7))\n \tsrc_align = 8;\n       else if ((src_align_bytes & 3) == (align_bytes & 3))\n \tsrc_align = 4;\n@@ -21567,7 +21916,7 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 1 && desired_alignment > 1)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 1, false);\n-      destmem = change_address (destmem, QImode, destptr);\n+      destmem = adjust_automodify_address_nv (destmem, QImode, destptr, 0);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (QImode, value)));\n       ix86_adjust_counter (count, 1);\n       emit_label (label);\n@@ -21576,7 +21925,7 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 2 && desired_alignment > 2)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 2, false);\n-      destmem = change_address (destmem, HImode, destptr);\n+      destmem = adjust_automodify_address_nv (destmem, HImode, destptr, 0);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (HImode, value)));\n       ix86_adjust_counter (count, 2);\n       emit_label (label);\n@@ -21585,13 +21934,23 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 4 && desired_alignment > 4)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 4, false);\n-      destmem = change_address (destmem, SImode, destptr);\n+      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n       ix86_adjust_counter (count, 4);\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n-  gcc_assert (desired_alignment <= 8);\n+  if (align <= 8 && desired_alignment > 8)\n+    {\n+      rtx label = ix86_expand_aligntest (destptr, 8, false);\n+      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n+      emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n+      emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n+      ix86_adjust_counter (count, 8);\n+      emit_label (label);\n+      LABEL_NUSES (label) = 1;\n+    }\n+  gcc_assert (desired_alignment <= 16);\n }\n \n /* Set enough from DST to align DST known to by aligned by ALIGN to\n@@ -21627,6 +21986,19 @@ expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n       emit_insn (gen_strset (destreg, dst,\n \t\t\t     gen_lowpart (SImode, value)));\n     }\n+  if (align_bytes & 8)\n+    {\n+      dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n+      emit_insn (gen_strset (destreg, dst,\n+\t    gen_lowpart (SImode, value)));\n+      off = 4;\n+      dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n+      emit_insn (gen_strset (destreg, dst,\n+\t    gen_lowpart (SImode, value)));\n+      if (MEM_ALIGN (dst) < 8 * BITS_PER_UNIT)\n+\tset_mem_align (dst, 8 * BITS_PER_UNIT);\n+      off = 4;\n+    }\n   dst = adjust_automodify_address_nv (dst, BLKmode, destreg, off);\n   if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n     set_mem_align (dst, desired_align * BITS_PER_UNIT);\n@@ -21638,7 +22010,7 @@ expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n /* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n static enum stringop_alg\n decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n-\t    int *dynamic_check)\n+\t    int *dynamic_check, bool align_unknown)\n {\n   const struct stringop_algs * algs;\n   bool optimize_for_speed;\n@@ -21647,7 +22019,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n      consider such algorithms if the user has appropriated those\n      registers for their own purposes.\t*/\n   bool rep_prefix_usable = !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n-                             || (memset\n+\t\t\t     || (memset\n \t\t\t\t ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n \n #define ALG_USABLE_P(alg) (rep_prefix_usable\t\t\t\\\n@@ -21660,7 +22032,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n      of time processing large blocks.  */\n   if (optimize_function_for_size_p (cfun)\n       || (optimize_insn_for_size_p ()\n-          && expected_size != -1 && expected_size < 256))\n+\t  && expected_size != -1 && expected_size < 256))\n     optimize_for_speed = false;\n   else\n     optimize_for_speed = true;\n@@ -21669,9 +22041,9 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \n   *dynamic_check = -1;\n   if (memset)\n-    algs = &cost->memset[TARGET_64BIT != 0];\n+    algs = &cost->memset[align_unknown][TARGET_64BIT != 0];\n   else\n-    algs = &cost->memcpy[TARGET_64BIT != 0];\n+    algs = &cost->memcpy[align_unknown][TARGET_64BIT != 0];\n   if (ix86_stringop_alg != no_stringop && ALG_USABLE_P (ix86_stringop_alg))\n     return ix86_stringop_alg;\n   /* rep; movq or rep; movl is the smallest variant.  */\n@@ -21735,29 +22107,33 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n       enum stringop_alg alg;\n       int i;\n       bool any_alg_usable_p = true;\n+      bool only_libcall_fits = true;\n \n       for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n-        {\n-          enum stringop_alg candidate = algs->size[i].alg;\n-          any_alg_usable_p = any_alg_usable_p && ALG_USABLE_P (candidate);\n+\t{\n+\t  enum stringop_alg candidate = algs->size[i].alg;\n+\t  any_alg_usable_p = any_alg_usable_p && ALG_USABLE_P (candidate);\n \n-          if (candidate != libcall && candidate\n-              && ALG_USABLE_P (candidate))\n-              max = algs->size[i].max;\n-        }\n+\t  if (candidate != libcall && candidate\n+\t      && ALG_USABLE_P (candidate))\n+\t    {\n+\t      max = algs->size[i].max;\n+\t      only_libcall_fits = false;\n+\t    }\n+\t}\n       /* If there aren't any usable algorithms, then recursing on\n-         smaller sizes isn't going to find anything.  Just return the\n-         simple byte-at-a-time copy loop.  */\n-      if (!any_alg_usable_p)\n-        {\n-          /* Pick something reasonable.  */\n-          if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n-            *dynamic_check = 128;\n-          return loop_1_byte;\n-        }\n+\t smaller sizes isn't going to find anything.  Just return the\n+\t simple byte-at-a-time copy loop.  */\n+      if (!any_alg_usable_p || only_libcall_fits)\n+\t{\n+\t  /* Pick something reasonable.  */\n+\t  if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n+\t    *dynamic_check = 128;\n+\t  return loop_1_byte;\n+\t}\n       if (max == -1)\n \tmax = 4096;\n-      alg = decide_alg (count, max / 2, memset, dynamic_check);\n+      alg = decide_alg (count, max / 2, memset, dynamic_check, align_unknown);\n       gcc_assert (*dynamic_check == -1);\n       gcc_assert (alg != libcall);\n       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n@@ -21781,9 +22157,14 @@ decide_alignment (int align,\n       case no_stringop:\n \tgcc_unreachable ();\n       case loop:\n+\tdesired_align = GET_MODE_SIZE (Pmode);\n+\tbreak;\n       case unrolled_loop:\n \tdesired_align = GET_MODE_SIZE (Pmode);\n \tbreak;\n+      case sse_loop:\n+\tdesired_align = 16;\n+\tbreak;\n       case rep_prefix_8_byte:\n \tdesired_align = 8;\n \tbreak;\n@@ -21871,6 +22252,11 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   enum stringop_alg alg;\n   int dynamic_check;\n   bool need_zero_guard = false;\n+  bool align_unknown;\n+  int unroll_factor;\n+  enum machine_mode move_mode;\n+  rtx loop_iter = NULL_RTX;\n+  int dst_offset, src_offset;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -21894,9 +22280,17 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n-\n-  alg = decide_alg (count, expected_size, false, &dynamic_check);\n+  dst_offset = get_mem_align_offset (dst, MOVE_MAX*BITS_PER_UNIT);\n+  src_offset = get_mem_align_offset (src, MOVE_MAX*BITS_PER_UNIT);\n+  align_unknown = (dst_offset < 0\n+\t\t   || src_offset < 0\n+\t\t   || src_offset != dst_offset);\n+  alg = decide_alg (count, expected_size, false, &dynamic_check, align_unknown);\n   desired_align = decide_alignment (align, alg, expected_size);\n+  if (align_unknown)\n+    desired_align = align;\n+  unroll_factor = 1;\n+  move_mode = Pmode;\n \n   if (!TARGET_ALIGN_STRINGOPS)\n     align = desired_align;\n@@ -21915,11 +22309,22 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       gcc_unreachable ();\n     case loop:\n       need_zero_guard = true;\n-      size_needed = GET_MODE_SIZE (Pmode);\n+      move_mode = Pmode;\n+      unroll_factor = 1;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n       break;\n     case unrolled_loop:\n       need_zero_guard = true;\n-      size_needed = GET_MODE_SIZE (Pmode) * (TARGET_64BIT ? 4 : 2);\n+      move_mode = Pmode;\n+      unroll_factor = TARGET_64BIT ? 4 : 2;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      break;\n+    case sse_loop:\n+      need_zero_guard = true;\n+      /* Use SSE instructions, if possible.  */\n+      move_mode = align_unknown ? DImode : V4SImode;\n+      unroll_factor = TARGET_64BIT ? 4 : 2;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n       break;\n     case rep_prefix_8_byte:\n       size_needed = 8;\n@@ -21980,6 +22385,12 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t}\n       else\n \t{\n+\t  /* SSE and unrolled algs re-use iteration counter in the epilogue.  */\n+\t  if (alg == sse_loop || alg == unrolled_loop)\n+\t    {\n+\t      loop_iter = gen_reg_rtx (counter_mode (count_exp));\n+              emit_move_insn (loop_iter, const0_rtx);\n+\t    }\n \t  label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (epilogue_size_needed),\n@@ -22031,6 +22442,8 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t  dst = change_address (dst, BLKmode, destreg);\n \t  expand_movmem_prologue (dst, src, destreg, srcreg, count_exp, align,\n \t\t\t\t  desired_align);\n+\t  set_mem_align (src, desired_align*BITS_PER_UNIT);\n+\t  set_mem_align (dst, desired_align*BITS_PER_UNIT);\n \t}\n       else\n \t{\n@@ -22087,12 +22500,16 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, NULL,\n \t\t\t\t     count_exp, Pmode, 1, expected_size);\n       break;\n+    case sse_loop:\n     case unrolled_loop:\n-      /* Unroll only by factor of 2 in 32bit mode, since we don't have enough\n-\t registers for 4 temporaries anyway.  */\n-      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, NULL,\n-\t\t\t\t     count_exp, Pmode, TARGET_64BIT ? 4 : 2,\n-\t\t\t\t     expected_size);\n+      /* In some cases we want to use the same iterator in several adjacent\n+\t loops, so here we save loop iterator rtx and don't update addresses.  */\n+      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, src, destreg,\n+\t\t\t\t\t\t\t   srcreg, NULL,\n+\t\t\t\t\t\t\t   count_exp, loop_iter,\n+\t\t\t\t\t\t\t   move_mode,\n+\t\t\t\t\t\t\t   unroll_factor,\n+\t\t\t\t\t\t\t   expected_size, false);\n       break;\n     case rep_prefix_8_byte:\n       expand_movmem_via_rep_mov (dst, src, destreg, srcreg, count_exp,\n@@ -22143,9 +22560,41 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       LABEL_NUSES (label) = 1;\n     }\n \n+  /* We haven't updated addresses, so we'll do it now.\n+     Also, if the epilogue seems to be big, we'll generate a loop (not\n+     unrolled) in it.  We'll do it only if alignment is unknown, because in\n+     this case in epilogue we have to perform memmove by bytes, which is very\n+     slow.  */\n+  if (alg == sse_loop || alg == unrolled_loop)\n+    {\n+      rtx tmp;\n+      if (align_unknown && unroll_factor > 1)\n+\t{\n+\t  /* Reduce epilogue's size by creating not-unrolled loop.  If we won't\n+\t     do this, we can have very big epilogue - when alignment is statically\n+\t     unknown we'll have the epilogue byte by byte which may be very slow.  */\n+\t  loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, src, destreg,\n+\t      srcreg, NULL, count_exp,\n+\t      loop_iter, move_mode, 1,\n+\t      expected_size, false);\n+\t  src = change_address (src, BLKmode, srcreg);\n+\t  dst = change_address (dst, BLKmode, destreg);\n+\t  epilogue_size_needed = GET_MODE_SIZE (move_mode);\n+\t}\n+      tmp = expand_simple_binop (Pmode, PLUS, destreg, loop_iter, destreg,\n+\t\t\t       true, OPTAB_LIB_WIDEN);\n+      if (tmp != destreg)\n+\temit_move_insn (destreg, tmp);\n+\n+      tmp = expand_simple_binop (Pmode, PLUS, srcreg, loop_iter, srcreg,\n+\t\t\t       true, OPTAB_LIB_WIDEN);\n+      if (tmp != srcreg)\n+\temit_move_insn (srcreg, tmp);\n+    }\n   if (count_exp != const0_rtx && epilogue_size_needed > 1)\n     expand_movmem_epilogue (dst, src, destreg, srcreg, count_exp,\n \t\t\t    epilogue_size_needed);\n+\n   if (jump_around_label)\n     emit_label (jump_around_label);\n   return true;\n@@ -22163,7 +22612,37 @@ promote_duplicated_reg (enum machine_mode mode, rtx val)\n   rtx tmp;\n   int nops = mode == DImode ? 3 : 2;\n \n+  if (VECTOR_MODE_P (mode))\n+    {\n+      enum machine_mode inner = GET_MODE_INNER (mode);\n+      rtx promoted_val, vec_reg;\n+      if (CONST_INT_P (val))\n+\treturn ix86_build_const_vector (mode, true, val);\n+\n+      promoted_val = promote_duplicated_reg (inner, val);\n+      vec_reg = gen_reg_rtx (mode);\n+      switch (mode)\n+\t{\n+\tcase V2DImode:\n+\t  emit_insn (gen_vec_dupv2di (vec_reg, promoted_val));\n+\t  break;\n+\tcase V4SImode:\n+\t  emit_insn (gen_vec_dupv4si (vec_reg, promoted_val));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+\n+      return vec_reg;\n+    }\n   gcc_assert (mode == SImode || mode == DImode);\n+  if (mode == DImode && !TARGET_64BIT)\n+    {\n+      rtx vec_reg = promote_duplicated_reg (V4SImode, val);\n+      vec_reg = convert_to_mode (V2DImode, vec_reg, 1);\n+      return vec_reg;\n+    }\n   if (val == const0_rtx)\n     return copy_to_mode_reg (mode, const0_rtx);\n   if (CONST_INT_P (val))\n@@ -22229,11 +22708,27 @@ promote_duplicated_reg (enum machine_mode mode, rtx val)\n static rtx\n promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align, int align)\n {\n-  rtx promoted_val;\n+  rtx promoted_val = NULL_RTX;\n \n-  if (TARGET_64BIT\n-      && (size_needed > 4 || (desired_align > align && desired_align > 4)))\n-    promoted_val = promote_duplicated_reg (DImode, val);\n+  if (size_needed > 8 || (desired_align > align && desired_align > 8))\n+    {\n+      /* We want to promote to vector register, so we expect that at least SSE\n+\t is available.  */\n+      gcc_assert (TARGET_SSE);\n+\n+      /* In case of promotion to vector register, we expect that val is a\n+\t constant or already promoted to GPR value.  */\n+      gcc_assert (GET_MODE (val) == Pmode || CONSTANT_P (val));\n+      if (TARGET_64BIT)\n+\tpromoted_val = promote_duplicated_reg (V2DImode, val);\n+      else\n+\tpromoted_val = promote_duplicated_reg (V4SImode, val);\n+    }\n+  else if (size_needed > 4 || (desired_align > align && desired_align > 4))\n+    {\n+      gcc_assert (TARGET_64BIT);\n+      promoted_val = promote_duplicated_reg (DImode, val);\n+    }\n   else if (size_needed > 2 || (desired_align > align && desired_align > 2))\n     promoted_val = promote_duplicated_reg (SImode, val);\n   else if (size_needed > 1 || (desired_align > align && desired_align > 1))\n@@ -22261,10 +22756,14 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   int size_needed = 0, epilogue_size_needed;\n   int desired_align = 0, align_bytes = 0;\n   enum stringop_alg alg;\n-  rtx promoted_val = NULL;\n-  bool force_loopy_epilogue = false;\n+  rtx gpr_promoted_val = NULL;\n+  rtx vec_promoted_val = NULL;\n   int dynamic_check;\n   bool need_zero_guard = false;\n+  bool align_unknown;\n+  unsigned int unroll_factor;\n+  enum machine_mode move_mode;\n+  rtx loop_iter = NULL_RTX;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -22284,8 +22783,11 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n \n-  alg = decide_alg (count, expected_size, true, &dynamic_check);\n+  align_unknown = CONST_INT_P (align_exp) && INTVAL (align_exp) > 0;\n+  alg = decide_alg (count, expected_size, true, &dynamic_check, align_unknown);\n   desired_align = decide_alignment (align, alg, expected_size);\n+  unroll_factor = 1;\n+  move_mode = Pmode;\n \n   if (!TARGET_ALIGN_STRINGOPS)\n     align = desired_align;\n@@ -22303,11 +22805,28 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       gcc_unreachable ();\n     case loop:\n       need_zero_guard = true;\n-      size_needed = GET_MODE_SIZE (Pmode);\n+      move_mode = Pmode;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n       break;\n     case unrolled_loop:\n       need_zero_guard = true;\n-      size_needed = GET_MODE_SIZE (Pmode) * 4;\n+      move_mode = Pmode;\n+      unroll_factor = 1;\n+      /* Select maximal available 1,2 or 4 unroll factor.  */\n+      while (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n+\t     && unroll_factor < 4)\n+\tunroll_factor *= 2;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      break;\n+    case sse_loop:\n+      need_zero_guard = true;\n+      move_mode = TARGET_64BIT ? V2DImode : V4SImode;\n+      unroll_factor = 1;\n+      /* Select maximal available 1,2 or 4 unroll factor.  */\n+      while (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n+\t     && unroll_factor < 4)\n+\tunroll_factor *= 2;\n+      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n       break;\n     case rep_prefix_8_byte:\n       size_needed = 8;\n@@ -22352,8 +22871,10 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n      main loop and epilogue (ie one load of the big constant in the\n      front of all code.  */\n   if (CONST_INT_P (val_exp))\n-    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n-\t\t\t\t\t\t   desired_align, align);\n+    gpr_promoted_val = promote_duplicated_reg_to_size (val_exp,\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   align);\n   /* Ensure that alignment prologue won't copy past end of block.  */\n   if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n     {\n@@ -22362,12 +22883,6 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n \n-      /* To improve performance of small blocks, we jump around the VAL\n-\t promoting mode.  This mean that if the promoted VAL is not constant,\n-\t we might not use it in the epilogue and have to use byte\n-\t loop variant.  */\n-      if (epilogue_size_needed > 2 && !promoted_val)\n-        force_loopy_epilogue = true;\n       if (count)\n \t{\n \t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n@@ -22382,6 +22897,12 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t}\n       else\n \t{\n+\t  /* SSE and unrolled_lopo algs re-use iteration counter in the epilogue.  */\n+\t  if (alg == sse_loop || alg == unrolled_loop)\n+\t    {\n+\t      loop_iter = gen_reg_rtx (counter_mode (count_exp));\n+              emit_move_insn (loop_iter, const0_rtx);\n+\t    }\n \t  label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (epilogue_size_needed),\n@@ -22407,9 +22928,11 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   /* Step 2: Alignment prologue.  */\n \n   /* Do the expensive promotion once we branched off the small blocks.  */\n-  if (!promoted_val)\n-    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n-\t\t\t\t\t\t   desired_align, align);\n+  if (!gpr_promoted_val)\n+    gpr_promoted_val = promote_duplicated_reg_to_size (val_exp,\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n+\t\t\t\t\t\t   align);\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n   if (desired_align > align)\n@@ -22421,17 +22944,20 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t     the pain to maintain it for the first move, so throw away\n \t     the info early.  */\n \t  dst = change_address (dst, BLKmode, destreg);\n-\t  expand_setmem_prologue (dst, destreg, promoted_val, count_exp, align,\n+\t  expand_setmem_prologue (dst, destreg, gpr_promoted_val, count_exp, align,\n \t\t\t\t  desired_align);\n+\t  set_mem_align (dst, desired_align*BITS_PER_UNIT);\n \t}\n       else\n \t{\n \t  /* If we know how many bytes need to be stored before dst is\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n-\t  dst = expand_constant_setmem_prologue (dst, destreg, promoted_val,\n+\t  dst = expand_constant_setmem_prologue (dst, destreg, gpr_promoted_val,\n \t\t\t\t\t\t desired_align, align_bytes);\n \t  count_exp = plus_constant (count_exp, -align_bytes);\n \t  count -= align_bytes;\n+\t  if (count < (unsigned HOST_WIDE_INT) size_needed)\n+\t    goto epilogue;\n \t}\n       if (need_zero_guard\n \t  && (count < (unsigned HOST_WIDE_INT) size_needed\n@@ -22459,7 +22985,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n       label = NULL;\n-      promoted_val = val_exp;\n+      gpr_promoted_val = val_exp;\n       epilogue_size_needed = 1;\n     }\n   else if (label == NULL_RTX)\n@@ -22473,27 +22999,40 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     case no_stringop:\n       gcc_unreachable ();\n     case loop_1_byte:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n+      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, val_exp,\n \t\t\t\t     count_exp, QImode, 1, expected_size);\n       break;\n     case loop:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n+      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, gpr_promoted_val,\n \t\t\t\t     count_exp, Pmode, 1, expected_size);\n       break;\n     case unrolled_loop:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n-\t\t\t\t     count_exp, Pmode, 4, expected_size);\n+      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n+\t\t\t\t     NULL, gpr_promoted_val, count_exp,\n+\t\t\t\t     loop_iter, move_mode, unroll_factor,\n+\t\t\t\t     expected_size, false);\n+      break;\n+    case sse_loop:\n+      vec_promoted_val =\n+\tpromote_duplicated_reg_to_size (gpr_promoted_val,\n+\t\t\t\t\tGET_MODE_SIZE (move_mode),\n+\t\t\t\t\tdesired_align, align);\n+      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n+\t\t\t\t     NULL, vec_promoted_val, count_exp,\n+\t\t\t\t     loop_iter, move_mode, unroll_factor,\n+\t\t\t\t     expected_size, false);\n       break;\n     case rep_prefix_8_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n+      gcc_assert (TARGET_64BIT);\n+      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n \t\t\t\t  DImode, val_exp);\n       break;\n     case rep_prefix_4_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n+      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n \t\t\t\t  SImode, val_exp);\n       break;\n     case rep_prefix_1_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n+      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n \t\t\t\t  QImode, val_exp);\n       break;\n     }\n@@ -22524,16 +23063,43 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n+      /* We can not rely on fact that promoved value is known.  */\n+      vec_promoted_val = 0;\n+      gpr_promoted_val = 0;\n     }\n  epilogue:\n-  if (count_exp != const0_rtx && epilogue_size_needed > 1)\n+  if (alg == unrolled_loop || alg == sse_loop)\n     {\n-      if (force_loopy_epilogue)\n-\texpand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n-\t\t\t\t\t epilogue_size_needed);\n-      else\n-\texpand_setmem_epilogue (dst, destreg, promoted_val, count_exp,\n-\t\t\t\tepilogue_size_needed);\n+      rtx tmp;\n+      if (align_unknown && unroll_factor > 1\n+\t  && epilogue_size_needed >= GET_MODE_SIZE (move_mode)\n+\t  && vec_promoted_val)\n+\t{\n+\t  /* Reduce epilogue's size by creating not-unrolled loop.  If we won't\n+\t     do this, we can have very big epilogue - when alignment is statically\n+\t     unknown we'll have the epilogue byte by byte which may be very slow.  */\n+\t  loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n+\t      NULL, vec_promoted_val, count_exp,\n+\t      loop_iter, move_mode, 1,\n+\t      expected_size, false);\n+\t  dst = change_address (dst, BLKmode, destreg);\n+\t  epilogue_size_needed = GET_MODE_SIZE (move_mode);\n+\t}\n+      tmp = expand_simple_binop (Pmode, PLUS, destreg, loop_iter, destreg,\n+\t\t\t       true, OPTAB_LIB_WIDEN);\n+      if (tmp != destreg)\n+\temit_move_insn (destreg, tmp);\n+    }\n+  if (count_exp == const0_rtx)\n+    ;\n+  else if (!gpr_promoted_val && epilogue_size_needed > 1)\n+    expand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n+\t\t\t\t     epilogue_size_needed);\n+  else\n+    {\n+      if (epilogue_size_needed > 1)\n+\texpand_setmem_epilogue (dst, destreg, vec_promoted_val, gpr_promoted_val,\n+\t\t\t\tval_exp, count_exp, epilogue_size_needed);\n     }\n   if (jump_around_label)\n     emit_label (jump_around_label);"}, {"sha": "b10a13cad8ac9f61bf3194b81111cfdab7140616", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -159,8 +159,12 @@ struct processor_costs {\n   const int fchs;\t\t/* cost of FCHS instruction.  */\n   const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n \t\t\t\t/* Specify what algorithm\n-\t\t\t\t   to use for stringops on unknown size.  */\n-  struct stringop_algs memcpy[2], memset[2];\n+\t\t\t\t   to use for stringops on unknown size.\n+\t\t\t\t   First index is used to specify whether\n+\t\t\t\t   alignment is known or not.\n+\t\t\t\t   Second - to specify whether 32 or 64 bits\n+\t\t\t\t   are used.  */\n+  struct stringop_algs memcpy[2][2], memset[2][2];\n   const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n \t\t\t\t   load and store.  */\n   const int scalar_load_cost;   /* Cost of scalar load.  */"}, {"sha": "e797362d2dc0ec822b4a151aaef794214e4c7b87", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -324,6 +324,9 @@ Enum(stringop_alg) String(loop) Value(loop)\n EnumValue\n Enum(stringop_alg) String(unrolled_loop) Value(unrolled_loop)\n \n+EnumValue\n+Enum(stringop_alg) String(sse_loop) Value(sse_loop)\n+\n mtls-dialect=\n Target RejectNegative Joined Var(ix86_tls_dialect) Enum(tls_dialect) Init(TLS_DIALECT_GNU)\n Use given thread-local storage dialect"}, {"sha": "4938abffce5bc2c770a5be888091920155630c48", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -7501,6 +7501,16 @@\n    (set_attr \"prefix\" \"maybe_vex,orig,vex,maybe_vex,orig,orig\")\n    (set_attr \"mode\" \"V2SF,TI,TI,TI,V4SF,V2SF\")])\n \n+(define_expand \"vec_dupv4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+\t(vec_duplicate:V4SI\n+\t  (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_SSE\"\n+{\n+  if (!TARGET_AVX)\n+    operands[1] = force_reg (V4SImode, operands[1]);\n+})\n+\n (define_insn \"*vec_dupv4si\"\n   [(set (match_operand:V4SI 0 \"register_operand\"     \"=x,x,x\")\n \t(vec_duplicate:V4SI\n@@ -7517,6 +7527,16 @@\n    (set_attr \"prefix\" \"maybe_vex,vex,orig\")\n    (set_attr \"mode\" \"TI,V4SF,V4SF\")])\n \n+(define_expand \"vec_dupv2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"\")\n+\t(vec_duplicate:V2DI\n+\t  (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_SSE\"\n+{\n+  if (!TARGET_AVX)\n+    operands[1] = force_reg (V2DImode, operands[1]);\n+})\n+\n (define_insn \"*vec_dupv2di\"\n   [(set (match_operand:V2DI 0 \"register_operand\"     \"=x,x,x,x\")\n \t(vec_duplicate:V2DI"}, {"sha": "2f798460c4a6ec1b7bfa5e78a0dc51f840721447", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -647,7 +647,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n \n /* Return true when variable VNODE should be considered externally visible.  */\n \n-static bool\n+bool\n varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n {\n   if (!DECL_COMDAT (vnode->decl) && !TREE_PUBLIC (vnode->decl))"}, {"sha": "57e5eb57ea55be3c1db897c58b11b6f7de51e6f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -1,3 +1,8 @@\n+2011-11-14  Zolotukhin Michael  <michael.v.zolotukhin@gmail.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.target/i386/sw-1.c: Force rep;movsb.\n+\n 2011-11-14  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR testsuite/51059"}, {"sha": "e3d3b9148606e29741892ffde52bc832b6275027", "filename": "gcc/testsuite/gcc.target/i386/sw-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fshrink-wrap -fdump-rtl-pro_and_epilogue\" } */\n+/* { dg-options \"-O2 -fshrink-wrap -fdump-rtl-pro_and_epilogue -mstringop-strategy=rep_byte\" } */\n \n #include <string.h>\n "}, {"sha": "abf5657ab9df1caf1e65c9932c5207b7b3b9e0ba", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -262,7 +262,7 @@ get_emutls_init_templ_addr (tree decl)\n   if (DECL_EXTERNAL (to))\n     varpool_node (to);\n   else\n-    varpool_finalize_decl (to);\n+    varpool_add_new_variable (to);\n   return build_fold_addr_expr (to);\n }\n \n@@ -334,7 +334,7 @@ new_emutls_decl (tree decl, tree alias_of)\n   if (DECL_EXTERNAL (to))\n     varpool_node (to);\n   else if (!alias_of)\n-    varpool_finalize_decl (to);\n+    varpool_add_new_variable (to);\n   else \n     varpool_create_variable_alias (to,\n \t\t\t\t   varpool_node_for_asm"}, {"sha": "74fc1ba712b6dd321ed2f47083c853e6a35ccafc", "filename": "gcc/varpool.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38877e985111f3a7434aa9583f0789bc157b2993/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=38877e985111f3a7434aa9583f0789bc157b2993", "patch": "@@ -414,6 +414,20 @@ varpool_finalize_decl (tree decl)\n     varpool_assemble_pending_decls ();\n }\n \n+/* Add the variable DECL to the varpool.\n+   Unlike varpool_finalize_decl function is intended to be used\n+   by middle end and allows insertion of new variable at arbitrary point\n+   of compilation.  */\n+void\n+varpool_add_new_variable (tree decl)\n+{\n+  struct varpool_node *node;\n+  varpool_finalize_decl (decl);\n+  node = varpool_node (decl);\n+  if (varpool_externally_visible_p (node, false))\n+    node->externally_visible = true;\n+}\n+\n /* Return variable availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability"}]}