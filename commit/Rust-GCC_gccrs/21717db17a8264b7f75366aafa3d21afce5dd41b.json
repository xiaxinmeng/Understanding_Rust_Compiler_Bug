{"sha": "21717db17a8264b7f75366aafa3d21afce5dd41b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE3MTdkYjE3YTgyNjRiN2Y3NTM2NmFhZmEzZDIxYWZjZTVkZDQxYg==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2020-05-21T12:15:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-27T08:05:19Z"}, "message": "[Ada] Unbounded string overriding control\n\ngcc/ada/\n\n\t* libgnat/a-strunb.adb (Sum, Mul, Saturated_Sum, Saturated_Mul):\n\tNew routines.  Use them when resulting string size more that\n\tlength of the strings in parameters.\n\t(Unbounded_Slice): Use \"- 1\" instead of \"+ 1\" in opposite side\n\tof condition to avoid overflow.\n\t* libgnat/a-strunb__shared.adb (Sum, Mul): New routines.\n\t(Allocate): New routine with 2 parameters.  Use routine above\n\twhen resulting string size more that length of the strings in\n\tparameters.\n\t(Aligned_Max_Length): Do not try to align to more than Natural'Last.\n\t(Unbounded_Slice): Use \"- 1\" instead of \"+ 1\" in opposite side\n\tof condition to avoid overflow.", "tree": {"sha": "332aae03e69a832aced097feff989258fe700c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332aae03e69a832aced097feff989258fe700c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21717db17a8264b7f75366aafa3d21afce5dd41b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21717db17a8264b7f75366aafa3d21afce5dd41b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21717db17a8264b7f75366aafa3d21afce5dd41b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21717db17a8264b7f75366aafa3d21afce5dd41b/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f365be815ea6543ebfddb7d1688817cde5b223b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f365be815ea6543ebfddb7d1688817cde5b223b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f365be815ea6543ebfddb7d1688817cde5b223b"}], "stats": {"total": 188, "additions": 150, "deletions": 38}, "files": [{"sha": "988de424f80403c7fcc9580fe046ba66d403b7ca", "filename": "gcc/ada/libgnat/a-strunb.adb", "status": "modified", "additions": 71, "deletions": 12, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21717db17a8264b7f75366aafa3d21afce5dd41b/gcc%2Fada%2Flibgnat%2Fa-strunb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21717db17a8264b7f75366aafa3d21afce5dd41b/gcc%2Fada%2Flibgnat%2Fa-strunb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strunb.adb?ref=21717db17a8264b7f75366aafa3d21afce5dd41b", "patch": "@@ -35,6 +35,19 @@ with Ada.Unchecked_Deallocation;\n \n package body Ada.Strings.Unbounded is\n \n+   function Sum (Left : Natural; Right : Integer) return Natural with Inline;\n+   --  Returns summary of Left and Right, raise Constraint_Error on overflow\n+\n+   function Mul (Left, Right : Natural) return Natural with Inline;\n+   --  Returns multiplication of Left and Right, raise Constraint_Error on\n+   --  overflow.\n+\n+   function Saturated_Sum (Left : Natural; Right : Integer) return Natural;\n+   --  Returns summary of Left and Right or Natural'Last on overflow\n+\n+   function Saturated_Mul (Left, Right : Natural) return Natural;\n+   --  Returns multiplication of Left and Right or Natural'Last on overflow\n+\n    ---------\n    -- \"&\" --\n    ---------\n@@ -48,7 +61,7 @@ package body Ada.Strings.Unbounded is\n       Result   : Unbounded_String;\n \n    begin\n-      Result.Last := L_Length + R_Length;\n+      Result.Last := Sum (L_Length, R_Length);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -68,7 +81,7 @@ package body Ada.Strings.Unbounded is\n       Result   : Unbounded_String;\n \n    begin\n-      Result.Last := L_Length + Right'Length;\n+      Result.Last := Sum (L_Length, Right'Length);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -86,7 +99,7 @@ package body Ada.Strings.Unbounded is\n       Result   : Unbounded_String;\n \n    begin\n-      Result.Last := Left'Length + R_Length;\n+      Result.Last := Sum (Left'Length, R_Length);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -104,7 +117,7 @@ package body Ada.Strings.Unbounded is\n       Result : Unbounded_String;\n \n    begin\n-      Result.Last := Left.Last + 1;\n+      Result.Last := Sum (Left.Last, 1);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -122,7 +135,7 @@ package body Ada.Strings.Unbounded is\n       Result : Unbounded_String;\n \n    begin\n-      Result.Last := Right.Last + 1;\n+      Result.Last := Sum (Right.Last, 1);\n \n       Result.Reference := new String (1 .. Result.Last);\n       Result.Reference (1) := Left;\n@@ -142,7 +155,7 @@ package body Ada.Strings.Unbounded is\n       Result : Unbounded_String;\n \n    begin\n-      Result.Last   := Left;\n+      Result.Last := Left;\n \n       Result.Reference := new String (1 .. Left);\n       for J in Result.Reference'Range loop\n@@ -161,7 +174,7 @@ package body Ada.Strings.Unbounded is\n       Result : Unbounded_String;\n \n    begin\n-      Result.Last := Left * Len;\n+      Result.Last := Mul (Left, Len);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -183,7 +196,7 @@ package body Ada.Strings.Unbounded is\n       Result : Unbounded_String;\n \n    begin\n-      Result.Last := Left * Len;\n+      Result.Last := Mul (Left, Len);\n \n       Result.Reference := new String (1 .. Result.Last);\n \n@@ -718,6 +731,16 @@ package body Ada.Strings.Unbounded is\n       return Source.Last;\n    end Length;\n \n+   ---------\n+   -- Mul --\n+   ---------\n+\n+   function Mul (Left, Right : Natural) return Natural is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Left * Right;\n+   end Mul;\n+\n    ---------------\n    -- Overwrite --\n    ---------------\n@@ -783,10 +806,12 @@ package body Ada.Strings.Unbounded is\n       if Chunk_Size > S_Length - Source.Last then\n          declare\n             New_Size : constant Positive :=\n-              S_Length + Chunk_Size + (S_Length / Growth_Factor);\n+              Saturated_Sum\n+                (Sum (S_Length, Chunk_Size), S_Length / Growth_Factor);\n \n             New_Rounded_Up_Size : constant Positive :=\n-              ((New_Size - 1) / Min_Mul_Alloc + 1) * Min_Mul_Alloc;\n+              Saturated_Mul\n+                ((New_Size - 1) / Min_Mul_Alloc + 1, Min_Mul_Alloc);\n \n             Tmp : constant String_Access :=\n               new String (1 .. New_Rounded_Up_Size);\n@@ -847,6 +872,30 @@ package body Ada.Strings.Unbounded is\n       Free (Old);\n    end Replace_Slice;\n \n+   -------------------\n+   -- Saturated_Mul --\n+   -------------------\n+\n+   function Saturated_Mul (Left, Right : Natural) return Natural is\n+   begin\n+      return Mul (Left, Right);\n+   exception\n+      when Constraint_Error =>\n+         return Natural'Last;\n+   end Saturated_Mul;\n+\n+   -----------------\n+   -- Saturated_Sum --\n+   -----------------\n+\n+   function Saturated_Sum (Left : Natural; Right : Integer) return Natural is\n+   begin\n+      return Sum (Left, Right);\n+   exception\n+      when Constraint_Error =>\n+         return Natural'Last;\n+   end Saturated_Sum;\n+\n    --------------------------\n    -- Set_Unbounded_String --\n    --------------------------\n@@ -882,6 +931,16 @@ package body Ada.Strings.Unbounded is\n       end if;\n    end Slice;\n \n+   ---------\n+   -- Sum --\n+   ---------\n+\n+   function Sum (Left : Natural; Right : Integer) return Natural is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Left + Right;\n+   end Sum;\n+\n    ----------\n    -- Tail --\n    ----------\n@@ -1047,7 +1106,7 @@ package body Ada.Strings.Unbounded is\n       High   : Natural) return Unbounded_String\n    is\n    begin\n-      if Low > Source.Last + 1 or else High > Source.Last then\n+      if Low - 1 > Source.Last or else High > Source.Last then\n          raise Index_Error;\n       else\n          return To_Unbounded_String (Source.Reference.all (Low .. High));\n@@ -1061,7 +1120,7 @@ package body Ada.Strings.Unbounded is\n       High   : Natural)\n    is\n    begin\n-      if Low > Source.Last + 1 or else High > Source.Last then\n+      if Low - 1 > Source.Last or else High > Source.Last then\n          raise Index_Error;\n       else\n          Target := To_Unbounded_String (Source.Reference.all (Low .. High));"}, {"sha": "0ff34d817efe2601db4965da776f414834563cd5", "filename": "gcc/ada/libgnat/a-strunb__shared.adb", "status": "modified", "additions": 79, "deletions": 26, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21717db17a8264b7f75366aafa3d21afce5dd41b/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21717db17a8264b7f75366aafa3d21afce5dd41b/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.adb?ref=21717db17a8264b7f75366aafa3d21afce5dd41b", "patch": "@@ -56,6 +56,18 @@ package body Ada.Strings.Unbounded is\n    --  allocated memory segments to use memory effectively by Append/Insert/etc\n    --  operations.\n \n+   function Sum (Left : Natural; Right : Integer) return Natural with Inline;\n+   --  Returns summary of Left and Right, raise Constraint_Error on overflow\n+\n+   function Mul (Left, Right : Natural) return Natural with Inline;\n+   --  Returns multiplication of Left and Right, raise Constraint_Error on\n+   --  overflow\n+\n+   function Allocate\n+     (Length, Growth : Natural) return not null Shared_String_Access;\n+   --  Allocates new Shared_String with at least specified Length plus optional\n+   --  Growth.\n+\n    ---------\n    -- \"&\" --\n    ---------\n@@ -66,7 +78,7 @@ package body Ada.Strings.Unbounded is\n    is\n       LR : constant Shared_String_Access := Left.Reference;\n       RR : constant Shared_String_Access := Right.Reference;\n-      DL : constant Natural := LR.Last + RR.Last;\n+      DL : constant Natural := Sum (LR.Last, RR.Last);\n       DR : Shared_String_Access;\n \n    begin\n@@ -104,7 +116,7 @@ package body Ada.Strings.Unbounded is\n       Right : String) return Unbounded_String\n    is\n       LR : constant Shared_String_Access := Left.Reference;\n-      DL : constant Natural := LR.Last + Right'Length;\n+      DL : constant Natural := Sum (LR.Last, Right'Length);\n       DR : Shared_String_Access;\n \n    begin\n@@ -136,7 +148,7 @@ package body Ada.Strings.Unbounded is\n       Right : Unbounded_String) return Unbounded_String\n    is\n       RR : constant Shared_String_Access := Right.Reference;\n-      DL : constant Natural := Left'Length + RR.Last;\n+      DL : constant Natural := Sum (Left'Length, RR.Last);\n       DR : Shared_String_Access;\n \n    begin\n@@ -168,7 +180,7 @@ package body Ada.Strings.Unbounded is\n       Right : Character) return Unbounded_String\n    is\n       LR : constant Shared_String_Access := Left.Reference;\n-      DL : constant Natural := LR.Last + 1;\n+      DL : constant Natural := Sum (LR.Last, 1);\n       DR : Shared_String_Access;\n \n    begin\n@@ -185,7 +197,7 @@ package body Ada.Strings.Unbounded is\n       Right : Unbounded_String) return Unbounded_String\n    is\n       RR : constant Shared_String_Access := Right.Reference;\n-      DL : constant Natural := 1 + RR.Last;\n+      DL : constant Natural := Sum (1, RR.Last);\n       DR : Shared_String_Access;\n \n    begin\n@@ -232,7 +244,7 @@ package body Ada.Strings.Unbounded is\n      (Left  : Natural;\n       Right : String) return Unbounded_String\n    is\n-      DL : constant Natural := Left * Right'Length;\n+      DL : constant Natural := Mul (Left, Right'Length);\n       DR : Shared_String_Access;\n       K  : Positive;\n \n@@ -264,7 +276,7 @@ package body Ada.Strings.Unbounded is\n       Right : Unbounded_String) return Unbounded_String\n    is\n       RR : constant Shared_String_Access := Right.Reference;\n-      DL : constant Natural := Left * RR.Last;\n+      DL : constant Natural := Mul (Left, RR.Last);\n       DR : Shared_String_Access;\n       K  : Positive;\n \n@@ -480,13 +492,16 @@ package body Ada.Strings.Unbounded is\n \n    function Aligned_Max_Length (Max_Length : Natural) return Natural is\n       Static_Size : constant Natural :=\n-        Empty_Shared_String'Size / Standard'Storage_Unit;\n-      --  Total size of all static components\n-\n+                      Empty_Shared_String'Size / Standard'Storage_Unit;\n+      --  Total size of all Shared_String static components\n    begin\n-      return\n-        ((Static_Size + Max_Length - 1) / Min_Mul_Alloc + 2) * Min_Mul_Alloc\n-           - Static_Size;\n+      if Max_Length > Natural'Last - Static_Size then\n+         return Natural'Last;\n+      else\n+         return\n+           ((Static_Size + Max_Length - 1) / Min_Mul_Alloc + 2) * Min_Mul_Alloc\n+             - Static_Size;\n+      end if;\n    end Aligned_Max_Length;\n \n    --------------\n@@ -509,6 +524,23 @@ package body Ada.Strings.Unbounded is\n       end if;\n    end Allocate;\n \n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   function Allocate\n+     (Length, Growth : Natural) return not null Shared_String_Access is\n+   begin\n+      if Natural'Last - Growth < Length then\n+         --  Then Length + Growth would be more than Natural'Last\n+\n+         return new Shared_String (Integer'Last);\n+\n+      else\n+         return Allocate (Length + Growth);\n+      end if;\n+   end Allocate;\n+\n    ------------\n    -- Append --\n    ------------\n@@ -519,7 +551,7 @@ package body Ada.Strings.Unbounded is\n    is\n       SR  : constant Shared_String_Access := Source.Reference;\n       NR  : constant Shared_String_Access := New_Item.Reference;\n-      DL  : constant Natural              := SR.Last + NR.Last;\n+      DL  : constant Natural              := Sum (SR.Last, NR.Last);\n       DR  : Shared_String_Access;\n \n    begin\n@@ -544,7 +576,7 @@ package body Ada.Strings.Unbounded is\n       --  Otherwise, allocate new one and fill it\n \n       else\n-         DR := Allocate (DL + DL / Growth_Factor);\n+         DR := Allocate (DL, DL / Growth_Factor);\n          DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n          DR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n          DR.Last := DL;\n@@ -558,7 +590,7 @@ package body Ada.Strings.Unbounded is\n       New_Item : String)\n    is\n       SR : constant Shared_String_Access := Source.Reference;\n-      DL : constant Natural := SR.Last + New_Item'Length;\n+      DL : constant Natural := Sum (SR.Last, New_Item'Length);\n       DR : Shared_String_Access;\n \n    begin\n@@ -576,7 +608,7 @@ package body Ada.Strings.Unbounded is\n       --  Otherwise, allocate new one and fill it\n \n       else\n-         DR := Allocate (DL + DL / Growth_Factor);\n+         DR := Allocate (DL, DL / Growth_Factor);\n          DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n          DR.Data (SR.Last + 1 .. DL) := New_Item;\n          DR.Last := DL;\n@@ -590,20 +622,20 @@ package body Ada.Strings.Unbounded is\n       New_Item : Character)\n    is\n       SR : constant Shared_String_Access := Source.Reference;\n-      DL : constant Natural := SR.Last + 1;\n+      DL : constant Natural := Sum (SR.Last, 1);\n       DR : Shared_String_Access;\n \n    begin\n       --  Try to reuse existing shared string\n \n-      if Can_Be_Reused (SR, SR.Last + 1) then\n+      if Can_Be_Reused (SR, DL) then\n          SR.Data (SR.Last + 1) := New_Item;\n          SR.Last := SR.Last + 1;\n \n       --  Otherwise, allocate new one and fill it\n \n       else\n-         DR := Allocate (DL + DL / Growth_Factor);\n+         DR := Allocate (DL, DL / Growth_Factor);\n          DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n          DR.Data (DL) := New_Item;\n          DR.Last := DL;\n@@ -1089,7 +1121,7 @@ package body Ada.Strings.Unbounded is\n       --  Otherwise, allocate new shared string and fill it\n \n       else\n-         DR := Allocate (DL + DL / Growth_Factor);\n+         DR := Allocate (DL, DL / Growth_Factor);\n          DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n          DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n          DR.Data (Before + New_Item'Length .. DL) :=\n@@ -1138,7 +1170,7 @@ package body Ada.Strings.Unbounded is\n       --  Otherwise, allocate new shared string and fill it\n \n       else\n-         DR := Allocate (DL + DL / Growth_Factor);\n+         DR := Allocate (DL, DL / Growth_Factor);\n          DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n          DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n          DR.Data (Before + New_Item'Length .. DL) :=\n@@ -1158,6 +1190,16 @@ package body Ada.Strings.Unbounded is\n       return Source.Reference.Last;\n    end Length;\n \n+   ---------\n+   -- Mul --\n+   ---------\n+\n+   function Mul (Left, Right : Natural) return Natural is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Left * Right;\n+   end Mul;\n+\n    ---------------\n    -- Overwrite --\n    ---------------\n@@ -1178,7 +1220,7 @@ package body Ada.Strings.Unbounded is\n          raise Index_Error;\n       end if;\n \n-      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+      DL := Integer'Max (SR.Last, Sum (Position - 1, New_Item'Length));\n \n       --  Result is empty string, reuse empty shared string\n \n@@ -1329,7 +1371,8 @@ package body Ada.Strings.Unbounded is\n       --  Do replace operation when removed slice is not empty\n \n       if High >= Low then\n-         DL := By'Length + SR.Last + Low - Integer'Min (High, SR.Last) - 1;\n+         DL := Sum (SR.Last,\n+                    By'Length + Low - Integer'Min (High, SR.Last) - 1);\n          --  This is the number of characters remaining in the string after\n          --  replacing the slice.\n \n@@ -1473,6 +1516,16 @@ package body Ada.Strings.Unbounded is\n       end if;\n    end Slice;\n \n+   ---------\n+   -- Sum --\n+   ---------\n+\n+   function Sum (Left : Natural; Right : Integer) return Natural is\n+      pragma Unsuppress (Overflow_Check);\n+   begin\n+      return Left + Right;\n+   end Sum;\n+\n    ----------\n    -- Tail --\n    ----------\n@@ -1996,7 +2049,7 @@ package body Ada.Strings.Unbounded is\n    begin\n       --  Check bounds\n \n-      if Low > SR.Last + 1 or else High > SR.Last then\n+      if Low - 1 > SR.Last or else High > SR.Last then\n          raise Index_Error;\n \n       --  Result is empty slice, reuse empty shared string\n@@ -2030,7 +2083,7 @@ package body Ada.Strings.Unbounded is\n    begin\n       --  Check bounds\n \n-      if Low > SR.Last + 1 or else High > SR.Last then\n+      if Low - 1 > SR.Last or else High > SR.Last then\n          raise Index_Error;\n \n       --  Result is empty slice, reuse empty shared string"}]}