{"sha": "5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4ODBiZDI0YmM2NjdkYzQxYTFmMzFkNTcxM2M4ZGJkOTBkODZjMg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-06-17T10:32:14Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-06-17T10:32:14Z"}, "message": "s390-modes.def (CCL3mode): New machine mode.\n\n\t* config/s390/s390-modes.def (CCL3mode): New machine mode.\n\t* config/s390/s390.c (s390_match_ccmode_set): Support CCL3mode.\n\t(s390_alc_comparison, s390_slb_comparison): Likewise.\n\t(s390_branch_condition_mask): Likewise.\n\t* config/s390/s390.md (\"*subdi3_cc2\", \"*subdi3_cconly2\"): New.\n\t(\"*subsi3_cc2\", \"*subsi3_cconly2\"): New.\n\n\t* config/s390/s390.h (PREDICATE_CODE): Accept SIGN_EXTEND and\n\tZERO_EXTEND for s390_alc_comparison and s390_slb_comparison.\n\t* config/s390/s390.c (s390_alc_comparison, s390_slb_comparison):\n\tHandle SIGN_EXTEND and ZERO_EXTEND.\n\n\t* config/s390/s390-protos.h (s390_expand_addcc): New prototype.\n\t* config/s390/s390.c (s390_expand_addcc): New function.\n\t* config/s390/s390.md (\"adddicc\", \"addsicc\"): New expanders.\n\t(\"*sconddi\", \"*scondsi\", \"*sconddi_neg\", \"*scondsi_neg\"): New insns.\n\t(\"sltu\", \"sgtu\", \"sleu\", \"sgeu\"): New expanders.\n\nFrom-SVN: r83287", "tree": {"sha": "1bd5a23cdea9efcce530899b7131b94010d1d3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bd5a23cdea9efcce530899b7131b94010d1d3fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/comments", "author": null, "committer": null, "parents": [{"sha": "ac5347368c5e7943a853427d42c8dd0ca2958939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5347368c5e7943a853427d42c8dd0ca2958939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5347368c5e7943a853427d42c8dd0ca2958939"}], "stats": {"total": 386, "additions": 384, "deletions": 2}, "files": [{"sha": "17ffc884dcbae790d09d1441e6ad8ceb8c72644e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -1,3 +1,23 @@\n+2004-06-17  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-modes.def (CCL3mode): New machine mode.\n+\t* config/s390/s390.c (s390_match_ccmode_set): Support CCL3mode.\n+\t(s390_alc_comparison, s390_slb_comparison): Likewise.\n+\t(s390_branch_condition_mask): Likewise.\n+\t* config/s390/s390.md (\"*subdi3_cc2\", \"*subdi3_cconly2\"): New.\n+\t(\"*subsi3_cc2\", \"*subsi3_cconly2\"): New.\n+\n+\t* config/s390/s390.h (PREDICATE_CODE): Accept SIGN_EXTEND and\n+\tZERO_EXTEND for s390_alc_comparison and s390_slb_comparison.\n+\t* config/s390/s390.c (s390_alc_comparison, s390_slb_comparison):\n+\tHandle SIGN_EXTEND and ZERO_EXTEND.\n+\n+\t* config/s390/s390-protos.h (s390_expand_addcc): New prototype.\n+\t* config/s390/s390.c (s390_expand_addcc): New function.\n+\t* config/s390/s390.md (\"adddicc\", \"addsicc\"): New expanders.\n+\t(\"*sconddi\", \"*scondsi\", \"*sconddi_neg\", \"*scondsi_neg\"): New insns.\n+\t(\"sltu\", \"sgtu\", \"sleu\", \"sgeu\"): New expanders.\n+\n 2004-06-17  Ben Elliston  <bje@au.ibm.com>\n \n \t* tree-alias-common.c: Add whitespace."}, {"sha": "d1e7304e4253885ccb4d0d23de8e755dfd7e849f", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -32,6 +32,7 @@ CC_MODE (CCAN);\n CC_MODE (CCL);\n CC_MODE (CCL1);\n CC_MODE (CCL2);\n+CC_MODE (CCL3);\n CC_MODE (CCU);\n CC_MODE (CCUR);\n CC_MODE (CCS);"}, {"sha": "2362cb66d0a6faea47c3667ad0325395d5bd0f79", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -76,6 +76,7 @@ extern void s390_load_address (rtx, rtx);\n extern void s390_expand_movstr (rtx, rtx, rtx);\n extern void s390_expand_clrstr (rtx, rtx);\n extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n+extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_emit_call (rtx, rtx, rtx, rtx);\n "}, {"sha": "d922e94a4997f3c6fd7cb34c3dd26846bc2488d3", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -282,6 +282,7 @@ s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n     case CCLmode:\n     case CCL1mode:\n     case CCL2mode:\n+    case CCL3mode:\n     case CCT1mode:\n     case CCT2mode:\n     case CCT3mode:\n@@ -477,6 +478,9 @@ s390_alc_comparison (rtx op, enum machine_mode mode)\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n+  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n+    op = XEXP (op, 0);\n+\n   if (!COMPARISON_P (op))\n     return 0;\n \n@@ -493,6 +497,9 @@ s390_alc_comparison (rtx op, enum machine_mode mode)\n     case CCL2mode:\n       return GET_CODE (op) == LEU;\n \n+    case CCL3mode:\n+      return GET_CODE (op) == GEU;\n+\n     case CCUmode:\n       return GET_CODE (op) == GTU;\n \n@@ -519,6 +526,9 @@ s390_slb_comparison (rtx op, enum machine_mode mode)\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n+  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n+    op = XEXP (op, 0);\n+\n   if (!COMPARISON_P (op))\n     return 0;\n \n@@ -535,6 +545,9 @@ s390_slb_comparison (rtx op, enum machine_mode mode)\n     case CCL2mode:\n       return GET_CODE (op) == GTU;\n \n+    case CCL3mode:\n+      return GET_CODE (op) == LTU;\n+\n     case CCUmode:\n       return GET_CODE (op) == LEU;\n \n@@ -640,6 +653,19 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n+    case CCL3mode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase EQ:\treturn CC0 | CC2;\n+\tcase NE:\treturn CC1 | CC3;\n+\tcase LTU:\treturn CC1;\n+\tcase GTU:\treturn CC3;\n+\tcase LEU:\treturn CC1 | CC2;\n+\tcase GEU:\treturn CC2 | CC3;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n     case CCUmode:\n       switch (GET_CODE (code))\n         {\n@@ -3194,6 +3220,174 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n #endif\n }\n \n+\n+/* Expand conditional increment or decrement using alc/slb instructions.\n+   Should generate code setting DST to either SRC or SRC + INCREMENT,\n+   depending on the result of the comparison CMP_OP0 CMP_CODE CMP_OP1.\n+   Returns true if successful, false otherwise.  */\n+\n+bool\n+s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n+\t\t   rtx dst, rtx src, rtx increment)\n+{\n+  enum machine_mode cmp_mode;\n+  enum machine_mode cc_mode;\n+  rtx op_res;\n+  rtx insn;\n+  rtvec p;\n+\n+  if ((GET_MODE (cmp_op0) == SImode || GET_MODE (cmp_op0) == VOIDmode)\n+      && (GET_MODE (cmp_op1) == SImode || GET_MODE (cmp_op1) == VOIDmode))\n+    cmp_mode = SImode;\n+  else if ((GET_MODE (cmp_op0) == DImode || GET_MODE (cmp_op0) == VOIDmode)\n+\t   && (GET_MODE (cmp_op1) == DImode || GET_MODE (cmp_op1) == VOIDmode))\n+    cmp_mode = DImode;\n+  else\n+    return false;\n+\n+  /* Try ADD LOGICAL WITH CARRY.  */\n+  if (increment == const1_rtx)\n+    {\n+      /* Determine CC mode to use.  */\n+      if (cmp_code == EQ || cmp_code == NE)\n+\t{\n+\t  if (cmp_op1 != const0_rtx)\n+\t    {\n+\t      cmp_op0 = expand_simple_binop (cmp_mode, XOR, cmp_op0, cmp_op1,\n+\t\t\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+\t      cmp_op1 = const0_rtx;\n+\t    }\n+\n+\t  cmp_code = cmp_code == EQ ? LEU : GTU;\n+\t}\n+\n+      if (cmp_code == LTU || cmp_code == LEU)\n+\t{\n+\t  rtx tem = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 = tem;\n+\t  cmp_code = swap_condition (cmp_code);\n+\t}\n+\n+      switch (cmp_code)\n+\t{\n+\t  case GTU:\n+\t    cc_mode = CCUmode;\n+\t    break;\n+\n+\t  case GEU:\n+\t    cc_mode = CCL3mode;\n+\t    break;\n+\n+\t  default:\n+\t    return false;\n+\t}\n+\n+      /* Emit comparison instruction pattern. */\n+      if (!register_operand (cmp_op0, cmp_mode))\n+\tcmp_op0 = force_reg (cmp_mode, cmp_op0);\n+\n+      insn = gen_rtx_SET (VOIDmode, gen_rtx_REG (cc_mode, CC_REGNUM),\n+\t\t\t  gen_rtx_COMPARE (cc_mode, cmp_op0, cmp_op1));\n+      /* We use insn_invalid_p here to add clobbers if required.  */\n+      if (insn_invalid_p (emit_insn (insn)))\n+\tabort ();\n+\n+      /* Emit ALC instruction pattern.  */\n+      op_res = gen_rtx_fmt_ee (cmp_code, GET_MODE (dst),\n+\t\t\t       gen_rtx_REG (cc_mode, CC_REGNUM),\n+\t\t\t       const0_rtx);\n+\n+      if (src != const0_rtx)\n+\t{\n+\t  if (!register_operand (src, GET_MODE (dst)))\n+\t    src = force_reg (GET_MODE (dst), src);\n+\n+\t  src = gen_rtx_PLUS (GET_MODE (dst), src, const0_rtx);\n+\t  op_res = gen_rtx_PLUS (GET_MODE (dst), src, op_res);\n+\t}\n+\n+      p = rtvec_alloc (2);\n+      RTVEC_ELT (p, 0) = \n+        gen_rtx_SET (VOIDmode, dst, op_res);\n+      RTVEC_ELT (p, 1) = \n+\tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\n+      return true;\n+    }\n+\n+  /* Try SUBTRACT LOGICAL WITH BORROW.  */\n+  if (increment == constm1_rtx)\n+    {\n+      /* Determine CC mode to use.  */\n+      if (cmp_code == EQ || cmp_code == NE)\n+\t{\n+\t  if (cmp_op1 != const0_rtx)\n+\t    {\n+\t      cmp_op0 = expand_simple_binop (cmp_mode, XOR, cmp_op0, cmp_op1,\n+\t\t\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+\t      cmp_op1 = const0_rtx;\n+\t    }\n+\n+\t  cmp_code = cmp_code == EQ ? LEU : GTU;\n+\t}\n+\n+      if (cmp_code == GTU || cmp_code == GEU)\n+\t{\n+\t  rtx tem = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 = tem;\n+\t  cmp_code = swap_condition (cmp_code);\n+\t}\n+\n+      switch (cmp_code)\n+\t{\n+\t  case LEU:\n+\t    cc_mode = CCUmode;\n+\t    break;\n+\n+\t  case LTU:\n+\t    cc_mode = CCL3mode;\n+\t    break;\n+\n+\t  default:\n+\t    return false;\n+\t}\n+\n+      /* Emit comparison instruction pattern. */\n+      if (!register_operand (cmp_op0, cmp_mode))\n+\tcmp_op0 = force_reg (cmp_mode, cmp_op0);\n+\n+      insn = gen_rtx_SET (VOIDmode, gen_rtx_REG (cc_mode, CC_REGNUM),\n+\t\t\t  gen_rtx_COMPARE (cc_mode, cmp_op0, cmp_op1));\n+      /* We use insn_invalid_p here to add clobbers if required.  */\n+      if (insn_invalid_p (emit_insn (insn)))\n+\tabort ();\n+\n+      /* Emit SLB instruction pattern.  */\n+      if (!register_operand (src, GET_MODE (dst)))\n+\tsrc = force_reg (GET_MODE (dst), src);\n+\n+      op_res = gen_rtx_MINUS (GET_MODE (dst), \n+\t\t\t      gen_rtx_MINUS (GET_MODE (dst), src, const0_rtx), \n+\t\t\t      gen_rtx_fmt_ee (cmp_code, GET_MODE (dst), \n+\t\t\t\t\t      gen_rtx_REG (cc_mode, CC_REGNUM), \n+\t\t\t\t\t      const0_rtx));\n+      p = rtvec_alloc (2);\n+      RTVEC_ELT (p, 0) = \n+        gen_rtx_SET (VOIDmode, dst, op_res);\n+      RTVEC_ELT (p, 1) = \n+\tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n "}, {"sha": "af7551d9318341fd000ea916e4a3aafe7fa8f77f", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -990,8 +990,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"consttable_operand\", { SYMBOL_REF, LABEL_REF, CONST, \t\t\\\n \t\t\t   CONST_INT, CONST_DOUBLE }},\t\t\t\\\n   {\"s390_plus_operand\", { PLUS }},\t\t\t\t\t\\\n-  {\"s390_alc_comparison\", { LTU, GTU, LEU, GEU }},\t\t\t\\\n-  {\"s390_slb_comparison\", { LTU, GTU, LEU, GEU }},\n+  {\"s390_alc_comparison\", { ZERO_EXTEND, SIGN_EXTEND, \t\t\t\\\n+\t\t\t    LTU, GTU, LEU, GEU }},\t\t\t\\\n+  {\"s390_slb_comparison\", { ZERO_EXTEND, SIGN_EXTEND,\t\t\t\\\n+\t\t\t    LTU, GTU, LEU, GEU }},\n \n /* Specify the machine mode that this machine uses for the index in the\n    tablejump instruction.  */"}, {"sha": "8c3708769a6d05644ddcf3dd7390abdb17768cd0", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d880bd24bc667dc41a1f31d5713c8dbd90d86c2/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=5d880bd24bc667dc41a1f31d5713c8dbd90d86c2", "patch": "@@ -3976,6 +3976,18 @@\n    slg\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n+(define_insn \"*subdi3_cc2\"\n+  [(set (reg 33)\n+        (compare (match_operand:DI 1 \"register_operand\" \"0,0\")\n+                 (match_operand:DI 2 \"general_operand\" \"d,m\")))\n+   (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+        (minus:DI (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCL3mode) && TARGET_64BIT\"\n+  \"@\n+   slgr\\t%0,%2\n+   slg\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RRE,RXY\")])\n+\n (define_insn \"*subdi3_cconly\"\n   [(set (reg 33)\n         (compare (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n@@ -3988,6 +4000,17 @@\n    slg\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n+(define_insn \"*subdi3_cconly2\"\n+  [(set (reg 33)\n+        (compare (match_operand:DI 1 \"register_operand\" \"0,0\")\n+                 (match_operand:DI 2 \"general_operand\" \"d,m\")))\n+   (clobber (match_scratch:DI 0 \"=d,d\"))]\n+  \"s390_match_ccmode (insn, CCL3mode) && TARGET_64BIT\"\n+  \"@\n+   slgr\\t%0,%2\n+   slg\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RRE,RXY\")])\n+\n (define_insn \"*subdi3_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n@@ -4111,6 +4134,19 @@\n    sly\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n+(define_insn \"*subsi3_cc2\"\n+  [(set (reg 33)\n+        (compare (match_operand:SI 1 \"register_operand\" \"0,0,0\")\n+                 (match_operand:SI 2 \"general_operand\" \"d,R,T\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+        (minus:SI (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCL3mode)\"\n+  \"@\n+   slr\\t%0,%2\n+   sl\\t%0,%2\n+   sly\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n+\n (define_insn \"*subsi3_cconly\"\n   [(set (reg 33)\n         (compare (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0,0\")\n@@ -4124,6 +4160,18 @@\n    sly\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n+(define_insn \"*subsi3_cconly2\"\n+  [(set (reg 33)\n+        (compare (match_operand:SI 1 \"register_operand\" \"0,0,0\")\n+                 (match_operand:SI 2 \"general_operand\" \"d,R,T\")))\n+   (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n+  \"s390_match_ccmode (insn, CCL3mode)\"\n+  \"@\n+   slr\\t%0,%2\n+   sl\\t%0,%2\n+   sly\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n+\n (define_insn \"*subsi3_sign\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n@@ -4339,6 +4387,17 @@\n    slbg\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n+(define_expand \"adddicc\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:DI 2 \"register_operand\" \"\")\n+   (match_operand:DI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_64BIT\"\n+  \"if (!s390_expand_addcc (GET_CODE (operands[1]), \n+\t\t\t   s390_compare_op0, s390_compare_op1, \n+\t\t\t   operands[0], operands[2], \n+\t\t\t   operands[3])) FAIL; DONE;\")\n+\n ;\n ; addsicc instruction pattern(s).\n ;\n@@ -4397,6 +4456,111 @@\n    slb\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n+(define_expand \"addsicc\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:SI 2 \"register_operand\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+  \"if (!s390_expand_addcc (GET_CODE (operands[1]), \n+\t\t\t   s390_compare_op0, s390_compare_op1, \n+\t\t\t   operands[0], operands[2], \n+\t\t\t   operands[3])) FAIL; DONE;\")\n+\n+;\n+; scond instruction pattern(s).\n+;\n+\n+(define_insn_and_split \"*sconddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (match_operand:DI 1 \"s390_alc_comparison\" \"\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (parallel\n+    [(set (match_dup 0) (plus:DI (plus:DI (match_dup 0) (match_dup 0))\n+                                 (match_dup 1)))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  [(set_attr \"op_type\"  \"NN\")])\n+\n+(define_insn_and_split \"*scondsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+        (match_operand:SI 1 \"s390_alc_comparison\" \"\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_CPU_ZARCH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (parallel\n+    [(set (match_dup 0) (plus:SI (plus:SI (match_dup 0) (match_dup 0))\n+                                 (match_dup 1)))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  [(set_attr \"op_type\"  \"NN\")])\n+\n+(define_insn_and_split \"*sconddi_neg\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (match_operand:DI 1 \"s390_slb_comparison\" \"\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (parallel\n+    [(set (match_dup 0) (minus:DI (minus:DI (match_dup 0) (match_dup 0))\n+                                  (match_dup 1)))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_dup 0) (neg:DI (match_dup 0)))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  [(set_attr \"op_type\"  \"NN\")])\n+\n+(define_insn_and_split \"*scondsi_neg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+        (match_operand:SI 1 \"s390_slb_comparison\" \"\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_CPU_ZARCH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (parallel\n+    [(set (match_dup 0) (minus:SI (minus:SI (match_dup 0) (match_dup 0))\n+                                  (match_dup 1)))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_dup 0) (neg:SI (match_dup 0)))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  [(set_attr \"op_type\"  \"NN\")])\n+\n+(define_expand \"sltu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+  \"if (!s390_expand_addcc (LTU, s390_compare_op0, s390_compare_op1,\n+\t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n+\n+(define_expand \"sgtu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+  \"if (!s390_expand_addcc (GTU, s390_compare_op0, s390_compare_op1,\n+\t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n+\n+(define_expand \"sleu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+  \"if (!s390_expand_addcc (LEU, s390_compare_op0, s390_compare_op1,\n+\t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n+\n+(define_expand \"sgeu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+  \"if (!s390_expand_addcc (GEU, s390_compare_op0, s390_compare_op1,\n+\t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n+\n \n ;;\n ;;- Multiply instructions."}]}