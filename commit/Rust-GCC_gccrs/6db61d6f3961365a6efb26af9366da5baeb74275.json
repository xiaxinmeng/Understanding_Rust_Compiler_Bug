{"sha": "6db61d6f3961365a6efb26af9366da5baeb74275", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRiNjFkNmYzOTYxMzY1YTZlZmIyNmFmOTM2NmRhNWJhZWI3NDI3NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-04-14T07:30:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-04-14T07:30:53Z"}, "message": "re PR tree-optimization/70623 (ICE in compute_antic at -O2)\n\n2016-04-14  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/70623\n\t* tree-ssa-pre.c (changed_blocks): Make global ...\n\t(compute_antic): ... local here.  Move and fix worklist\n\thandling here.  Do not clear EDGE_DFS_BACK or call mark_dfs_back_edges.\n\t(compute_antic_aux): Add dumping for MAX assumed succs.  Remove\n\tworklist handling, dump when ANTIC_IN changed.\n\t(compute_partial_antic_aux): Remove worklist handling.\n\t(init_pre): Do not compute post dominators.  Add a comment about\n\tthe CFG order chosen.\n\t(fini_pre): Do not free post dominators.\n\n\t* gcc.dg/torture/pr70623.c: New testcase.\n\t* gcc.dg/torture/pr70623-2.c: Likewise.\n\nFrom-SVN: r234970", "tree": {"sha": "9e98dff70f5a37f1fd638289b140d7e1595ed361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e98dff70f5a37f1fd638289b140d7e1595ed361"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6db61d6f3961365a6efb26af9366da5baeb74275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db61d6f3961365a6efb26af9366da5baeb74275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6db61d6f3961365a6efb26af9366da5baeb74275", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db61d6f3961365a6efb26af9366da5baeb74275/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16f87bed36630c18ad4af8ac7456d04ee14f7830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16f87bed36630c18ad4af8ac7456d04ee14f7830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16f87bed36630c18ad4af8ac7456d04ee14f7830"}], "stats": {"total": 189, "additions": 140, "deletions": 49}, "files": [{"sha": "495716c90eb8f2ef82fa4ae8dcf76f6c648032d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6db61d6f3961365a6efb26af9366da5baeb74275", "patch": "@@ -1,3 +1,16 @@\n+2016-04-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/70623\n+\t* tree-ssa-pre.c (changed_blocks): Make global ...\n+\t(compute_antic): ... local here.  Move and fix worklist\n+\thandling here.  Do not clear EDGE_DFS_BACK or call mark_dfs_back_edges.\n+\t(compute_antic_aux): Add dumping for MAX assumed succs.  Remove\n+\tworklist handling, dump when ANTIC_IN changed.\n+\t(compute_partial_antic_aux): Remove worklist handling.\n+\t(init_pre): Do not compute post dominators.  Add a comment about\n+\tthe CFG order chosen.\n+\t(fini_pre): Do not free post dominators.\n+\n 2016-04-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/69517"}, {"sha": "c2a4c93209200c6c41dc9fff032b024972032849", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6db61d6f3961365a6efb26af9366da5baeb74275", "patch": "@@ -1,3 +1,9 @@\n+2016-04-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/70623\n+\t* gcc.dg/torture/pr70623.c: New testcase.\n+\t* gcc.dg/torture/pr70623-2.c: Likewise.\n+\n 2016-04-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/69517"}, {"sha": "8e8dc96df0e09e0b00677050209ac0cfe180fc43", "filename": "gcc/testsuite/gcc.dg/torture/pr70623-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623-2.c?ref=6db61d6f3961365a6efb26af9366da5baeb74275", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+\n+int b8, il, rc, nm;\n+\n+void\n+h9(void)\n+{\n+  int *av = &b8;\n+\n+is:\n+  for (;;) {\n+      int vj, wk;\n+      int *m9 = &b8;\n+\n+      if (*m9 == *av) {\n+\t  if (il == 0)\n+\t    goto is;\n+\n+di:\n+\t  continue;\n+\t  for (vj = 0; vj < 1; ++vj) {\n+\t      goto di;\n+kz:\n+\t      ;\n+\t  }\n+      }\n+\n+      for (rc = 0; rc < 2; ++rc) {\n+\t  int bc = rc ? rc : nm;\n+\t  int ud = bc ? (*av ? 0 : rc) : 1;\n+\n+\t  if (ud != 0)\n+\t    if (*av != 0)\n+\t      goto kz;\n+      }\n+\n+      for (wk = 0; wk < 3; ++wk)\n+\t++(*av);\n+      av = 0;\n+  }\n+}"}, {"sha": "37f2712d87d7672b3e39d48dd9e1c0a7b10a4fc3", "filename": "gcc/testsuite/gcc.dg/torture/pr70623.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70623.c?ref=6db61d6f3961365a6efb26af9366da5baeb74275", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-w\" } */\n+\n+int nm;\n+int *av;\n+\n+void\n+h9(void)\n+{\n+  for (;;) {\n+      int wk, rc;\n+      int **ptr_10 = &av;\n+      if (*av != 0) {\n+      }\n+u4:\n+      wk = 0;\n+      for (rc = 0; rc < 3; ++rc) {\n+\t  int bc = (rc ? rc : nm);\n+\t  int ud = bc ? (*av ? 0 : rc) : 1;\n+\t  if (ud != 0) {\n+\t      if (*av != 0)\n+\t\tgoto u4;\n+\t      for (;;) {\n+\t      }\n+\t  }\n+      }\n+      while (wk < 3) {\n+\t  av = **ptr_10;\n+\t  ++wk;\n+      }\n+  }\n+}"}, {"sha": "f1a3130cb1c213955c5368d2a7d2ef3467beb6f0", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db61d6f3961365a6efb26af9366da5baeb74275/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6db61d6f3961365a6efb26af9366da5baeb74275", "patch": "@@ -2062,11 +2062,6 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \n static sbitmap has_abnormal_preds;\n \n-/* List of blocks that may have changed during ANTIC computation and\n-   thus need to be iterated over.  */\n-\n-static sbitmap changed_blocks;\n-\n /* Compute the ANTIC set for BLOCK.\n \n    If succs(BLOCK) > 1 then\n@@ -2125,6 +2120,16 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t    first = e->dest;\n \t  else if (BB_VISITED (e->dest))\n \t    worklist.quick_push (e->dest);\n+\t  else\n+\t    {\n+\t      /* Unvisited successors get their ANTIC_IN replaced by the\n+\t\t maximal set to arrive at a maximum ANTIC_IN solution.\n+\t\t We can ignore them in the intersection operation and thus\n+\t\t need not explicitely represent that maximum solution.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"ANTIC_IN is MAX on %d->%d\\n\",\n+\t\t\t e->src->index, e->dest->index);\n+\t    }\n \t}\n \n       /* Of multiple successors we have to have visited one already\n@@ -2167,21 +2172,16 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n   clean (ANTIC_IN (block));\n \n   if (!bitmap_set_equal (old, ANTIC_IN (block)))\n-    {\n-      changed = true;\n-      bitmap_set_bit (changed_blocks, block->index);\n-      FOR_EACH_EDGE (e, ei, block->preds)\n-\tbitmap_set_bit (changed_blocks, e->src->index);\n-    }\n-  else\n-    bitmap_clear_bit (changed_blocks, block->index);\n+    changed = true;\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       if (ANTIC_OUT)\n \tprint_bitmap_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n \n+      if (changed)\n+\tfprintf (dump_file, \"[changed] \");\n       print_bitmap_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\",\n \t\t\tblock->index);\n \n@@ -2313,14 +2313,7 @@ compute_partial_antic_aux (basic_block block,\n   dependent_clean (PA_IN (block), ANTIC_IN (block));\n \n   if (!bitmap_set_equal (old_PA_IN, PA_IN (block)))\n-    {\n-      changed = true;\n-      bitmap_set_bit (changed_blocks, block->index);\n-      FOR_EACH_EDGE (e, ei, block->preds)\n-\tbitmap_set_bit (changed_blocks, e->src->index);\n-    }\n-  else\n-    bitmap_clear_bit (changed_blocks, block->index);\n+    changed = true;\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2346,6 +2339,8 @@ compute_antic (void)\n   int num_iterations = 0;\n   basic_block block;\n   int i;\n+  edge_iterator ei;\n+  edge e;\n \n   /* If any predecessor edges are abnormal, we punt, so antic_in is empty.\n      We pre-build the map of blocks with incoming abnormal edges here.  */\n@@ -2354,18 +2349,12 @@ compute_antic (void)\n \n   FOR_ALL_BB_FN (block, cfun)\n     {\n-      edge_iterator ei;\n-      edge e;\n-\n       FOR_EACH_EDGE (e, ei, block->preds)\n-\t{\n-\t  e->flags &= ~EDGE_DFS_BACK;\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    {\n-\t      bitmap_set_bit (has_abnormal_preds, block->index);\n-\t      break;\n-\t    }\n-\t}\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    bitmap_set_bit (has_abnormal_preds, block->index);\n+\t    break;\n+\t  }\n \n       BB_VISITED (block) = 0;\n \n@@ -2377,8 +2366,8 @@ compute_antic (void)\n   /* At the exit block we anticipate nothing.  */\n   BB_VISITED (EXIT_BLOCK_PTR_FOR_FN (cfun)) = 1;\n \n-  changed_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n-  bitmap_ones (changed_blocks);\n+  sbitmap worklist = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_ones (worklist);\n   while (changed)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2391,12 +2380,18 @@ compute_antic (void)\n       changed = false;\n       for (i = postorder_num - 1; i >= 0; i--)\n \t{\n-\t  if (bitmap_bit_p (changed_blocks, postorder[i]))\n+\t  if (bitmap_bit_p (worklist, postorder[i]))\n \t    {\n \t      basic_block block = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);\n-\t      changed |= compute_antic_aux (block,\n-\t\t\t\t\t    bitmap_bit_p (has_abnormal_preds,\n-\t\t\t\t\t\t      block->index));\n+\t      bitmap_clear_bit (worklist, block->index);\n+\t      if (compute_antic_aux (block,\n+\t\t\t\t     bitmap_bit_p (has_abnormal_preds,\n+\t\t\t\t\t\t   block->index)))\n+\t\t{\n+\t\t  FOR_EACH_EDGE (e, ei, block->preds)\n+\t\t    bitmap_set_bit (worklist, e->src->index);\n+\t\t  changed = true;\n+\t\t}\n \t    }\n \t}\n       /* Theoretically possible, but *highly* unlikely.  */\n@@ -2408,8 +2403,7 @@ compute_antic (void)\n \n   if (do_partial_partial)\n     {\n-      bitmap_ones (changed_blocks);\n-      mark_dfs_back_edges ();\n+      bitmap_ones (worklist);\n       num_iterations = 0;\n       changed = true;\n       while (changed)\n@@ -2420,13 +2414,18 @@ compute_antic (void)\n \t  changed = false;\n \t  for (i = postorder_num - 1 ; i >= 0; i--)\n \t    {\n-\t      if (bitmap_bit_p (changed_blocks, postorder[i]))\n+\t      if (bitmap_bit_p (worklist, postorder[i]))\n \t\t{\n \t\t  basic_block block = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);\n-\t\t  changed\n-\t\t    |= compute_partial_antic_aux (block,\n-\t\t\t\t\t\t  bitmap_bit_p (has_abnormal_preds,\n-\t\t\t\t\t\t\t    block->index));\n+\t\t  bitmap_clear_bit (worklist, block->index);\n+\t\t  if (compute_partial_antic_aux (block,\n+\t\t\t\t\t\t bitmap_bit_p (has_abnormal_preds,\n+\t\t\t\t\t\t\t       block->index)))\n+\t\t    {\n+\t\t      FOR_EACH_EDGE (e, ei, block->preds)\n+\t\t\tbitmap_set_bit (worklist, e->src->index);\n+\t\t      changed = true;\n+\t\t    }\n \t\t}\n \t    }\n \t  /* Theoretically possible, but *highly* unlikely.  */\n@@ -2436,7 +2435,7 @@ compute_antic (void)\n \t\t\t\t  num_iterations);\n     }\n   sbitmap_free (has_abnormal_preds);\n-  sbitmap_free (changed_blocks);\n+  sbitmap_free (worklist);\n }\n \n \n@@ -4695,12 +4694,14 @@ init_pre (void)\n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n \n+  /* For ANTIC computation we need a postorder that also guarantees that\n+     a block with a single successor is visited after its successor.\n+     RPO on the inverted CFG has this property.  */\n   postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   postorder_num = inverted_post_order_compute (postorder);\n \n   alloc_aux_for_blocks (sizeof (struct bb_bitmap_sets));\n \n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n@@ -4734,8 +4735,6 @@ fini_pre ()\n   name_to_id.release ();\n \n   free_aux_for_blocks ();\n-\n-  free_dominance_info (CDI_POST_DOMINATORS);\n }\n \n namespace {"}]}