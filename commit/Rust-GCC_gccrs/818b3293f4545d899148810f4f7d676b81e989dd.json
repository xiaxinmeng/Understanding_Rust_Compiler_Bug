{"sha": "818b3293f4545d899148810f4f7d676b81e989dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4YjMyOTNmNDU0NWQ4OTkxNDg4MTBmNGY3ZDY3NmI4MWU5ODlkZA==", "commit": {"author": {"name": "Joel Hutton", "email": "Joel.Hutton@arm.com", "date": "2019-11-04T16:39:32Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2019-11-04T16:39:32Z"}, "message": "[SLP] SLP vectorization: vectorize vector constructors\n\ngcc/ChangeLog:\n2019-11-04  Joel Hutton  <Joel.Hutton@arm.com>\n\n\t* expr.c (store_constructor): Modify to handle single element vectors.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Add case for vector\n\tconstructors.\n\t(vect_slp_check_for_constructors): New function.\n\t(vect_slp_analyze_bb_1): Call new function to check for vector\n\tconstructors.\n\t(vectorize_slp_instance_root_stmt): New function.\n\t(vect_schedule_slp): Call new function to vectorize root stmt of vector\n\tconstructors.\n\t* tree-vectorizer.h (SLP_INSTANCE_ROOT_STMT): New field.\n\ngcc/testsuite/ChangeLog:\n2019-11-04  Joel Hutton  <Joel.Hutton@arm.com>\n\n\t* gcc.dg/vect/bb-slp-40.c: New test.\n\t* gcc.dg/vect/bb-slp-41.c: New test.\n\nFrom-SVN: r277784", "tree": {"sha": "2702ccd3ba1baf99c6cb15f51052689b1b0cb9e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2702ccd3ba1baf99c6cb15f51052689b1b0cb9e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/818b3293f4545d899148810f4f7d676b81e989dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b3293f4545d899148810f4f7d676b81e989dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818b3293f4545d899148810f4f7d676b81e989dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b3293f4545d899148810f4f7d676b81e989dd/comments", "author": {"login": "JoelHutton", "id": 4455754, "node_id": "MDQ6VXNlcjQ0NTU3NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4455754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoelHutton", "html_url": "https://github.com/JoelHutton", "followers_url": "https://api.github.com/users/JoelHutton/followers", "following_url": "https://api.github.com/users/JoelHutton/following{/other_user}", "gists_url": "https://api.github.com/users/JoelHutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoelHutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoelHutton/subscriptions", "organizations_url": "https://api.github.com/users/JoelHutton/orgs", "repos_url": "https://api.github.com/users/JoelHutton/repos", "events_url": "https://api.github.com/users/JoelHutton/events{/privacy}", "received_events_url": "https://api.github.com/users/JoelHutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6ba623777513e31721030092e4d786f461a0f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ba623777513e31721030092e4d786f461a0f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ba623777513e31721030092e4d786f461a0f06"}], "stats": {"total": 246, "additions": 243, "deletions": 3}, "files": [{"sha": "25af3fc51d694a3a2fa8deb2b6a8ccc33d740613", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -1,3 +1,16 @@\n+2019-11-04  Joel Hutton  <Joel.Hutton@arm.com>\n+\n+\t* expr.c (store_constructor): Modify to handle single element vectors.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Add case for vector\n+\tconstructors.\n+\t(vect_slp_check_for_constructors): New function.\n+\t(vect_slp_analyze_bb_1): Call new function to check for vector\n+\tconstructors.\n+\t(vectorize_slp_instance_root_stmt): New function.\n+\t(vect_schedule_slp): Call new function to vectorize root stmt of vector\n+\tconstructors.\n+\t* tree-vectorizer.h (SLP_INSTANCE_ROOT_STMT): New field.\n+\n 2019-11-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92345"}, {"sha": "12165af21cb0ded943b63e9e503e42e267de8ce5", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -6809,6 +6809,7 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t    && n_elts.is_constant (&const_n_elts))\n \t  {\n \t    machine_mode emode = eltmode;\n+\t    bool vector_typed_elts_p = false;\n \n \t    if (CONSTRUCTOR_NELTS (exp)\n \t\t&& (TREE_CODE (TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value))\n@@ -6819,13 +6820,14 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t\t\t\t      * TYPE_VECTOR_SUBPARTS (etype),\n \t\t\t\t      n_elts));\n \t\temode = TYPE_MODE (etype);\n+\t\tvector_typed_elts_p = true;\n \t      }\n \t    icode = convert_optab_handler (vec_init_optab, mode, emode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n \t\tunsigned int n = const_n_elts;\n \n-\t\tif (emode != eltmode)\n+\t\tif (vector_typed_elts_p)\n \t\t  {\n \t\t    n = CONSTRUCTOR_NELTS (exp);\n \t\t    vec_vec_init_p = true;"}, {"sha": "2059b594e16b6c25cf66b26d7b0cbb1350e6c105", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -1,3 +1,8 @@\n+2019-11-04  Joel Hutton  <Joel.Hutton@arm.com>\n+\n+\t* gcc.dg/vect/bb-slp-40.c: New test.\n+\t* gcc.dg/vect/bb-slp-41.c: New test.\n+\n 2019-11-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92345"}, {"sha": "a1dd372184623f34f8f2825aa5da50dc70c98084", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-40.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-40.c?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-slp-all\" } */\n+/* { dg-require-effective-target vect_int } */\n+\n+char g_d[1024], g_s1[1024], g_s2[1024];\n+void foo(void)\n+{\n+    char *d = g_d, *s1 = g_s1, *s2 = g_s2;\n+\n+    for ( int y = 0; y < 128; y++ )\n+    {\n+      d[0 ] = s1[0 ] + s2[0 ];\n+      d[1 ] = s1[1 ] + s2[1 ];\n+      d[2 ] = s1[2 ] + s2[2 ];\n+      d[3 ] = s1[3 ] + s2[3 ];\n+      d[4 ] = s1[4 ] + s2[4 ];\n+      d[5 ] = s1[5 ] + s2[5 ];\n+      d[6 ] = s1[6 ] + s2[6 ];\n+      d[7 ] = s1[7 ] + s2[7 ];\n+      d[8 ] = s1[8 ] + s2[8 ];\n+      d[9 ] = s1[9 ] + s2[9 ];\n+      d[10] = s1[10] + s2[10];\n+      d[11] = s1[11] + s2[11];\n+      d[12] = s1[12] + s2[12];\n+      d[13] = s1[13] + s2[13];\n+      d[14] = s1[14] + s2[14];\n+      d[15] = s1[15] + s2[15];\n+      d += 16;\n+    }\n+}\n+\n+/* See that we vectorize an SLP instance.  */\n+/* { dg-final { scan-tree-dump-times \"Found vectorizable constructor\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"slp1\" } } */"}, {"sha": "b4a71241be588744c4c4480eaa8548172e7ddc9d", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-41.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-41.c?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-tree-slp-all -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#define ARR_SIZE 1000\n+\n+void foo (int *a, int *b)\n+{\n+  int i;\n+  for (i = 0; i < (ARR_SIZE - 2); ++i)\n+    a[i] = b[0] + b[1] + b[i+1] + b[i+2];\n+}\n+\n+void bar (int *a, int *b)\n+{\n+  int i;\n+  for (i = 0; i < (ARR_SIZE - 2); ++i)\n+  {\n+    a[i] = b[0];\n+  }\n+  for (i = 0; i < (ARR_SIZE - 2); ++i)\n+  {\n+    a[i] = a[i] + b[1];\n+  }\n+  for (i = 0; i < (ARR_SIZE - 2); ++i)\n+  {\n+    a[i] = a[i] + b[i+1];\n+  }\n+  for (i = 0; i < (ARR_SIZE - 2); ++i)\n+  {\n+    a[i] = a[i] + b[i+2];\n+  }\n+}\n+\n+int main ()\n+{\n+  int a1[ARR_SIZE];\n+  int a2[ARR_SIZE];\n+  int b[ARR_SIZE];\n+  int i;\n+\n+  for (i = 0; i < ARR_SIZE; i++)\n+  {\n+    a1[i] = 0;\n+    a2[i] = 0;\n+    b[i]  = i;\n+  }\n+\n+  foo (a1, b);\n+  bar (a2, b);\n+\n+  for (i = 0; i < ARR_SIZE; i++)\n+    if (a1[i] != a2[i])\n+      return 1;\n+\n+  return 0;\n+\n+}\n+/* See that we vectorize an SLP instance.  */\n+/* { dg-final { scan-tree-dump-times \"Found vectorizable constructor\" 12 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"slp1\" } } */"}, {"sha": "5549d053bf3cd102a4c4fcdc2e890c596927bd55", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -1993,6 +1993,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   unsigned int i;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   vec<stmt_vec_info> scalar_stmts;\n+  bool constructor = false;\n \n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n@@ -2006,6 +2007,13 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       vectype = STMT_VINFO_VECTYPE (stmt_info);\n       group_size = REDUC_GROUP_SIZE (stmt_info);\n     }\n+  else if (is_gimple_assign (stmt_info->stmt)\n+\t    && gimple_assign_rhs_code (stmt_info->stmt) == CONSTRUCTOR)\n+    {\n+      vectype = TREE_TYPE (gimple_assign_rhs1 (stmt_info->stmt));\n+      group_size = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt_info->stmt));\n+      constructor = true;\n+    }\n   else\n     {\n       gcc_assert (is_a <loop_vec_info> (vinfo));\n@@ -2053,6 +2061,25 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))\n \t= STMT_VINFO_REDUC_DEF (vect_orig_stmt (scalar_stmts.last ()));\n     }\n+  else if (constructor)\n+    {\n+      tree rhs = gimple_assign_rhs1 (stmt_info->stmt);\n+      tree val;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n+\t{\n+\t  if (TREE_CODE (val) == SSA_NAME)\n+\t    {\n+\t      gimple* def = SSA_NAME_DEF_STMT (val);\n+\t      stmt_vec_info def_info = vinfo->lookup_stmt (def);\n+\t      /* Value is defined in another basic block.  */\n+\t      if (!def_info)\n+\t\treturn false;\n+\t      scalar_stmts.safe_push (def_info);\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+    }\n   else\n     {\n       /* Collect reduction statements.  */\n@@ -2138,6 +2165,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n \t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n+\t  SLP_INSTANCE_ROOT_STMT (new_instance) = constructor ? stmt_info : NULL;\n+\n \t  vect_gather_slp_loads (new_instance, node);\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2955,6 +2984,43 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   return true;\n }\n \n+/* Find any vectorizable constructors and add them to the grouped_store\n+   array.  */\n+\n+static void\n+vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = bb_vinfo->region_begin;\n+      gsi_stmt (gsi) != gsi_stmt (bb_vinfo->region_end); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (is_gimple_assign (stmt)\n+\t  && gimple_assign_rhs_code (stmt) == CONSTRUCTOR\n+\t  && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t  && TREE_CODE (TREE_TYPE (gimple_assign_lhs (stmt))) == VECTOR_TYPE)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\n+\t  if (CONSTRUCTOR_NELTS (rhs) == 0)\n+\t    continue;\n+\n+\t  poly_uint64 subparts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs));\n+\n+\t  if (maybe_ne (subparts, CONSTRUCTOR_NELTS (rhs)))\n+\t    continue;\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Found vectorizable constructor: %G\\n\", stmt);\n+\t  stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (stmt);\n+\t  BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt_info);\n+\t}\n+    }\n+}\n+\n /* Check if the region described by BB_VINFO can be vectorized, returning\n    true if so.  When returning false, set FATAL to true if the same failure\n    would prevent vectorization at other vector sizes, false if it is still\n@@ -3002,6 +3068,8 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n       return false;\n     }\n \n+  vect_slp_check_for_constructors (bb_vinfo);\n+\n   /* If there are no grouped stores in the region there is no need\n      to continue with pattern recog as vect_analyze_slp will fail\n      anyway.  */\n@@ -3058,6 +3126,8 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n \t relevant.  */\n       vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance));\n       vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n+      if (SLP_INSTANCE_ROOT_STMT (instance))\n+\tSTMT_SLP_TYPE (SLP_INSTANCE_ROOT_STMT (instance)) = pure_slp;\n \n       i++;\n     }\n@@ -4074,6 +4144,49 @@ vect_remove_slp_scalar_calls (slp_tree node)\n   vect_remove_slp_scalar_calls (node, visited);\n }\n \n+/* Vectorize the instance root.  */\n+\n+void\n+vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n+{\n+  gassign *rstmt;\n+\n+  if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) == 1)\n+    {\n+      stmt_vec_info child_stmt_info;\n+      int j;\n+\n+      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt_info)\n+\t{\n+\t  tree vect_lhs = gimple_get_lhs (child_stmt_info->stmt);\n+\t  tree root_lhs = gimple_get_lhs (instance->root_stmt->stmt);\n+\t  rstmt = gimple_build_assign (root_lhs, vect_lhs);\n+\t  break;\n+\t}\n+    }\n+  else if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) > 1)\n+    {\n+      int nelts = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+      stmt_vec_info child_stmt_info;\n+      int j;\n+      vec<constructor_elt, va_gc> *v;\n+      vec_alloc (v, nelts);\n+\n+      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt_info)\n+\t{\n+\t  CONSTRUCTOR_APPEND_ELT (v,\n+\t\t\t\t  NULL_TREE,\n+\t\t\t\t  gimple_get_lhs (child_stmt_info->stmt));\n+\t}\n+      tree lhs = gimple_get_lhs (instance->root_stmt->stmt);\n+      tree rtype = TREE_TYPE (gimple_assign_rhs1 (instance->root_stmt->stmt));\n+      tree r_constructor = build_constructor (rtype, v);\n+      rstmt = gimple_build_assign (lhs, r_constructor);\n+    }\n+    gimple_stmt_iterator rgsi = gsi_for_stmt (instance->root_stmt->stmt);\n+    gsi_replace (&rgsi, rstmt, true);\n+}\n+\n /* Generate vector code for all SLP instances in the loop/basic block.  */\n \n void\n@@ -4088,9 +4201,13 @@ vect_schedule_slp (vec_info *vinfo)\n   slp_instances = vinfo->slp_instances;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n+      slp_tree node = SLP_INSTANCE_TREE (instance);\n       /* Schedule the tree of INSTANCE.  */\n-      vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n-\t\t\t\t  instance, bst_map);\n+      vect_schedule_slp_instance (node, instance, bst_map);\n+\n+      if (SLP_INSTANCE_ROOT_STMT (instance))\n+\tvectorize_slp_instance_root_stmt (node, instance);\n+\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\\n\");\n@@ -4119,6 +4236,9 @@ vect_schedule_slp (vec_info *vinfo)\n \t  if (!STMT_VINFO_DATA_REF (store_info))\n \t    break;\n \n+\t  if (SLP_INSTANCE_ROOT_STMT (instance))\n+\t    continue;\n+\n \t  store_info = vect_orig_stmt (store_info);\n \t  /* Free the attached stmt_vec_info and remove the stmt.  */\n \t  vinfo->remove_stmt (store_info);"}, {"sha": "0fa64357be2c154662378af85642632aac50c523", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b3293f4545d899148810f4f7d676b81e989dd/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=818b3293f4545d899148810f4f7d676b81e989dd", "patch": "@@ -152,6 +152,10 @@ typedef class _slp_instance {\n   /* The root of SLP tree.  */\n   slp_tree root;\n \n+  /* For vector constructors, the constructor stmt that the SLP tree is built\n+     from, NULL otherwise.  */\n+  stmt_vec_info root_stmt;\n+\n   /* Size of groups of scalar stmts that will be replaced by SIMD stmt/s.  */\n   unsigned int group_size;\n \n@@ -171,6 +175,7 @@ typedef class _slp_instance {\n #define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n+#define SLP_INSTANCE_ROOT_STMT(S)                (S)->root_stmt\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts"}]}