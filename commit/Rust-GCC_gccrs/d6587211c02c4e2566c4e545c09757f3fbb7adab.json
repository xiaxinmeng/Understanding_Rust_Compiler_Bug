{"sha": "d6587211c02c4e2566c4e545c09757f3fbb7adab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY1ODcyMTFjMDJjNGUyNTY2YzRlNTQ1YzA5NzU3ZjNmYmI3YWRhYg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-22T20:26:52Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-22T20:26:52Z"}, "message": "c++: Return only in-scope tparms in keep_template_parm [PR95310]\n\nIn the testcase below, the dependent specializations iter_reference_t<F>\nand iter_reference_t<Out> share the same tree due to specialization\ncaching.  So when find_template_parameters walks through the\nrequires-expression (as part of normalization), it sees and includes the\nout-of-scope template parameter F in the list of template parameters\nit found within the requires-expression (along with Out and N).\n\nFrom a correctness perspective this is harmless since the parameter mapping\nroutines only care about the level and index of each parameter, so F is\nno different from Out in that sense.  And it's also harmless that two\nparameters in the parameter mapping have the same level and index.\n\nBut having both Out and F in the parameter mapping means extra work for\nhash_atomic_constrant, tsubst_parameter_mapping and get_mapped_args; and\nit also means we print this irrelevant template parameter in the\ntestcase's diagnostics (via pp_cxx_parameter_mapping):\n\n  in requirements with \u2018Out o\u2019 [with N = (const int&)&a; F = const int*; Out = const int*]\n\nThis patch makes keep_template_parm return only in-scope template\nparameters by looking into ctx_parms for the corresponding in-scope\none, through a new helper function corresponding_template_parameter.\n\n(That we sometimes print irrelevant template parameters in diagnostics\nis also the subject of PR99 and PR66968, so the above diagnostic issue\ncould likely be fixed in a more general way, but this targeted fix to\nkeep_template_parm is perhaps worthwhile on its own.)\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95310\n\t* pt.c (corresponding_template_parameter): Define.\n\t(keep_template_parm): Use it to adjust the given template\n\tparameter to the corresponding in-scope one from ctx_parms.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95310\n\t* g++.dg/concepts/diagnostic15.C: New test.", "tree": {"sha": "5035066819fd8576ea18332ad6eb5ded6a1fd078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5035066819fd8576ea18332ad6eb5ded6a1fd078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6587211c02c4e2566c4e545c09757f3fbb7adab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6587211c02c4e2566c4e545c09757f3fbb7adab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6587211c02c4e2566c4e545c09757f3fbb7adab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6587211c02c4e2566c4e545c09757f3fbb7adab/comments", "author": null, "committer": null, "parents": [{"sha": "c4e4e163c79ca3fca265b85f44b869cb54e802b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e4e163c79ca3fca265b85f44b869cb54e802b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4e4e163c79ca3fca265b85f44b869cb54e802b3"}], "stats": {"total": 60, "additions": 60, "deletions": 0}, "files": [{"sha": "314bd038c6d50b05572eae139da7a12247052805", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6587211c02c4e2566c4e545c09757f3fbb7adab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6587211c02c4e2566c4e545c09757f3fbb7adab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d6587211c02c4e2566c4e545c09757f3fbb7adab", "patch": "@@ -10243,6 +10243,42 @@ lookup_and_finish_template_variable (tree templ, tree targs,\n   return convert_from_reference (templ);\n }\n \n+/* If the set of template parameters PARMS contains a template parameter\n+   at the given LEVEL and INDEX, then return this parameter.  Otherwise\n+   return NULL_TREE.  */\n+\n+static tree\n+corresponding_template_parameter (tree parms, int level, int index)\n+{\n+  while (TMPL_PARMS_DEPTH (parms) > level)\n+    parms = TREE_CHAIN (parms);\n+\n+  if (TMPL_PARMS_DEPTH (parms) != level\n+      || TREE_VEC_LENGTH (TREE_VALUE (parms)) <= index)\n+    return NULL_TREE;\n+\n+  tree t = TREE_VALUE (TREE_VEC_ELT (TREE_VALUE (parms), index));\n+  /* As in template_parm_to_arg.  */\n+  if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == TEMPLATE_DECL)\n+    t = TREE_TYPE (t);\n+  else\n+    t = DECL_INITIAL (t);\n+\n+  gcc_assert (TEMPLATE_PARM_P (t));\n+  return t;\n+}\n+\n+/* Return the template parameter from PARMS that positionally corresponds\n+   to the template parameter PARM, or else return NULL_TREE.  */\n+\n+static tree\n+corresponding_template_parameter (tree parms, tree parm)\n+{\n+  int level, index;\n+  template_parm_level_and_index (parm, &level, &index);\n+  return corresponding_template_parameter (parms, level, index);\n+}\n+\n \f\n struct pair_fn_data\n {\n@@ -10549,6 +10585,14 @@ keep_template_parm (tree t, void* data)\n        BOUND_TEMPLATE_TEMPLATE_PARM itself.  */\n     t = TREE_TYPE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t));\n \n+  /* This template parameter might be an argument to a cached dependent\n+     specalization that was formed earlier inside some other template, in\n+     which case the parameter is not among the ones that are in-scope.\n+     Look in CTX_PARMS to find the corresponding in-scope template\n+     parameter, and use it instead.  */\n+  if (tree in_scope = corresponding_template_parameter (ftpi->ctx_parms, t))\n+    t = in_scope;\n+\n   /* Arguments like const T yield parameters like const T. This means that\n      a template-id like X<T, const T> would yield two distinct parameters:\n      T and const T. Adjust types to their unqualified versions.  */"}, {"sha": "3acd9f67968ffd0215a73196714883684c4a031a", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic15.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6587211c02c4e2566c4e545c09757f3fbb7adab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6587211c02c4e2566c4e545c09757f3fbb7adab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic15.C?ref=d6587211c02c4e2566c4e545c09757f3fbb7adab", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/95310\n+// { dg-do compile { target concepts } }\n+\n+template <class T>\n+using iter_reference_t = decltype(*T{});\n+\n+template <typename F>\n+struct result { using type = iter_reference_t<F>; };\n+\n+template <class Out, const int& N>\n+concept indirectly_writable = requires(Out o) { // { dg-bogus \"F =\" }\n+  iter_reference_t<Out>(*o) = N;\n+};\n+\n+const int a = 0;\n+static_assert(indirectly_writable<const int*, a>); // { dg-error \"assert\" }"}]}