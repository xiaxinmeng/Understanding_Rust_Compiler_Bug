{"sha": "f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjNzJhZjQ2ZmJiZDMwZmQwMWY3YmI4YzY3OGEyNTJmN2JlNjdiYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-04-17T19:24:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-04-17T19:24:17Z"}, "message": "re PR tree-optimization/47679 (Strange uninitialized warning after SRA)\n\n\tPR tree-optimization/47679\n\t* Makefile.in (OBJS); Add tree-ssa-scopedtables.o.\n\t* tree-ssa-scopedtables.c: New file.\n\t* tree-ssa-scopedtables.h: New file.\n\t* tree-ssa-dom.c: Include tree-ssa-scopedtables.h.\n\t(const_and_copies): Change name/type.\n\t(record_const_or_copy): Move into tree-ssa-scopedtables.c\n\t(record_const_or_copy_1): Similarly.\n\t(restore_vars_to_original_value): Similarly.\n\t(pass_dominator::execute): Create and destroy const_and_copies table.\n\t(thread_across_edge): Update passing of const_and_copies.\n\t(record_temporary_equivalence): Use method calls rather than\n\tmanipulating const_and_copies directly.\n\t(record_equality, cprop_into_successor_phis): Similarly.\n\t(dom_opt_dom_walker::before_dom_children): Similarly.\n\t(dom_opt_dom_walker::after_dom_children): Similarly.\n\t(eliminate_redundant_computations): Similarly.\n\t* tree-ssa-threadedge.c (remove_temporary_equivalences): Delete.\n\t(record_temporary_equivalence): Likewise.\n\t(invalidate_equivalences): Likewise.\n\t(record_temporary_equivalences_from_phis): Update due to type\n\tchange of const_and_copies.  Use method calls rather than\n\tmanipulating the stack directly.\n\t(record_temporary_equivalences_from_stmts_at_dest): Likewise.\n\t(thread_through_normal_block, thread_across_edge): Likewise.\n\t(thread_across_edge): Likewise.\n\t* tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n\t* tree-vrp.c: Include tree-ssa-scopedtables.h.  Change type\n\tof equiv_stack.\n\t(identify_jump_threads): Update due to type change of equiv_stack.\n\t(finalize_jump_threads): Delete the equiv_stack when complete.\n\nFrom-SVN: r222195", "tree": {"sha": "41f20ae69b1cc8265e0980bcc7f92a93610686ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41f20ae69b1cc8265e0980bcc7f92a93610686ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/comments", "author": null, "committer": null, "parents": [{"sha": "90e00f872d715c6d54742e6bbcafa2ce4f033dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e00f872d715c6d54742e6bbcafa2ce4f033dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e00f872d715c6d54742e6bbcafa2ce4f033dc8"}], "stats": {"total": 480, "additions": 270, "deletions": 210}, "files": [{"sha": "e0a4cbf3dafa61d0dc2b7be49ab431ac70ccec6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -1,3 +1,37 @@\n+2015-04-17  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* Makefile.in (OBJS); Add tree-ssa-scopedtables.o.\n+\t* tree-ssa-scopedtables.c: New file.\n+\t* tree-ssa-scopedtables.h: New file.\n+\t* tree-ssa-dom.c: Include tree-ssa-scopedtables.h.\n+\t(const_and_copies): Change name/type.\n+\t(record_const_or_copy): Move into tree-ssa-scopedtables.c\n+\t(record_const_or_copy_1): Similarly.\n+\t(restore_vars_to_original_value): Similarly.\n+\t(pass_dominator::execute): Create and destroy const_and_copies table.\n+\t(thread_across_edge): Update passing of const_and_copies.\n+\t(record_temporary_equivalence): Use method calls rather than\n+\tmanipulating const_and_copies directly.\n+\t(record_equality, cprop_into_successor_phis): Similarly.\n+\t(dom_opt_dom_walker::before_dom_children): Similarly.\n+\t(dom_opt_dom_walker::after_dom_children): Similarly.\n+\t(eliminate_redundant_computations): Similarly.\n+\t* tree-ssa-threadedge.c (remove_temporary_equivalences): Delete.\n+\t(record_temporary_equivalence): Likewise.\n+\t(invalidate_equivalences): Likewise.\n+\t(record_temporary_equivalences_from_phis): Update due to type\n+\tchange of const_and_copies.  Use method calls rather than\n+\tmanipulating the stack directly.\n+\t(record_temporary_equivalences_from_stmts_at_dest): Likewise.\n+\t(thread_through_normal_block, thread_across_edge): Likewise.\n+\t(thread_across_edge): Likewise.\n+\t* tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n+\t* tree-vrp.c: Include tree-ssa-scopedtables.h.  Change type\n+\tof equiv_stack.\n+\t(identify_jump_threads): Update due to type change of equiv_stack.\n+\t(finalize_jump_threads): Delete the equiv_stack when complete.\n+\n 2015-04-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (LEGITIMIZE_RELOAD_ADDRESS): Remove."}, {"sha": "80c91f0eb861a5f0e10ad54ab2388494b448c005", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -1452,6 +1452,7 @@ OBJS = \\\n \ttree-ssa-propagate.o \\\n \ttree-ssa-reassoc.o \\\n \ttree-ssa-sccvn.o \\\n+\ttree-ssa-scopedtables.o \\\n \ttree-ssa-sink.o \\\n \ttree-ssa-strlen.o \\\n \ttree-ssa-structalias.o \\"}, {"sha": "8eec5d98799561deb2d0261f3e7fe124dd707942", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadupdate.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n+#include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-dom.h\"\n #include \"inchash.h\"\n@@ -235,11 +236,8 @@ expr_elt_hasher::remove (value_type &element)\n    in this table.  */\n static hash_table<expr_elt_hasher> *avail_exprs;\n \n-/* Stack of dest,src pairs that need to be restored during finalization.\n-\n-   A NULL entry is used to mark the end of pairs which need to be\n-   restored during finalization of this block.  */\n-static vec<tree> const_and_copies_stack;\n+/* Unwindable const/copy equivalences.  */\n+static const_and_copies *const_and_copies;\n \n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n@@ -268,14 +266,12 @@ static hashval_t avail_expr_hash (const void *);\n static void htab_statistics (FILE *,\n \t\t\t     const hash_table<expr_elt_hasher> &);\n static void record_cond (cond_equivalence *);\n-static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n static void remove_local_expressions_from_table (void);\n-static void restore_vars_to_original_value (void);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n \n@@ -1196,7 +1192,7 @@ pass_dominator::execute (function *fun)\n   /* Create our hash tables.  */\n   avail_exprs = new hash_table<expr_elt_hasher> (1024);\n   avail_exprs_stack.create (20);\n-  const_and_copies_stack.create (20);\n+  const_and_copies = new class const_and_copies (dump_file, dump_flags);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_noreturn_fixup.create (0);\n \n@@ -1319,7 +1315,7 @@ pass_dominator::execute (function *fun)\n   BITMAP_FREE (need_eh_cleanup);\n   need_noreturn_fixup.release ();\n   avail_exprs_stack.release ();\n-  const_and_copies_stack.release ();\n+  delete const_and_copies;\n \n   /* Free the value-handle array.  */\n   threadedge_finalize_values ();\n@@ -1420,36 +1416,6 @@ remove_local_expressions_from_table (void)\n     }\n }\n \n-/* Use the source/dest pairs in CONST_AND_COPIES_STACK to restore\n-   CONST_AND_COPIES to its original state, stopping when we hit a\n-   NULL marker.  */\n-\n-static void\n-restore_vars_to_original_value (void)\n-{\n-  while (const_and_copies_stack.length () > 0)\n-    {\n-      tree prev_value, dest;\n-\n-      dest = const_and_copies_stack.pop ();\n-\n-      if (dest == NULL)\n-\tbreak;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"<<<< COPY \");\n-\t  print_generic_expr (dump_file, dest, 0);\n-\t  fprintf (dump_file, \" = \");\n-\t  print_generic_expr (dump_file, SSA_NAME_VALUE (dest), 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      prev_value = const_and_copies_stack.pop ();\n-      set_ssa_name_value (dest, prev_value);\n-    }\n-}\n-\n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n static tree\n@@ -1479,7 +1445,7 @@ record_temporary_equivalences (edge e)\n \n       /* If we have a simple NAME = VALUE equivalence, record it.  */\n       if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\trecord_const_or_copy (lhs, rhs);\n+\tconst_and_copies->record_const_or_copy (lhs, rhs);\n \n       /* If we have 0 = COND or 1 = COND equivalences, record them\n \t into our expression hash tables.  */\n@@ -1505,15 +1471,15 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n      current state.  */\n   avail_exprs_stack.safe_push\n     (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n-  const_and_copies_stack.safe_push (NULL_TREE);\n+  const_and_copies->push_marker ();\n \n   /* Traversing E may result in equivalences we can utilize.  */\n   record_temporary_equivalences (e);\n \n   /* With all the edge equivalences in the tables, go ahead and attempt\n      to thread through E->dest.  */\n   ::thread_across_edge (m_dummy_cond, e, false,\n-\t\t        &const_and_copies_stack,\n+\t\t        const_and_copies,\n \t\t        simplify_stmt_for_jump_threading);\n \n   /* And restore the various tables to their state before\n@@ -1752,48 +1718,6 @@ record_cond (cond_equivalence *p)\n     free_expr_hash_elt (element);\n }\n \n-/* A helper function for record_const_or_copy and record_equality.\n-   Do the work of recording the value and undo info.  */\n-\n-static void\n-record_const_or_copy_1 (tree x, tree y, tree prev_x)\n-{\n-  set_ssa_name_value (x, y);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"0>>> COPY \");\n-      print_generic_expr (dump_file, x, 0);\n-      fprintf (dump_file, \" = \");\n-      print_generic_expr (dump_file, y, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  const_and_copies_stack.reserve (2);\n-  const_and_copies_stack.quick_push (prev_x);\n-  const_and_copies_stack.quick_push (x);\n-}\n-\n-/* Record that X is equal to Y in const_and_copies.  Record undo\n-   information in the block-local vector.  */\n-\n-static void\n-record_const_or_copy (tree x, tree y)\n-{\n-  tree prev_x = SSA_NAME_VALUE (x);\n-\n-  gcc_assert (TREE_CODE (x) == SSA_NAME);\n-\n-  if (TREE_CODE (y) == SSA_NAME)\n-    {\n-      tree tmp = SSA_NAME_VALUE (y);\n-      if (tmp)\n-\ty = tmp;\n-    }\n-\n-  record_const_or_copy_1 (x, y, prev_x);\n-}\n-\n /* Return the loop depth of the basic block of the defining statement of X.\n    This number should not be treated as absolutely correct because the loop\n    information may not be completely up-to-date when dom runs.  However, it\n@@ -1863,7 +1787,7 @@ record_equality (tree x, tree y)\n \t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (y))))\n     return;\n \n-  record_const_or_copy_1 (x, y, prev_x);\n+  const_and_copies->record_const_or_copy (x, y, prev_x);\n }\n \n /* Returns true when STMT is a simple iv increment.  It detects the\n@@ -1940,7 +1864,7 @@ cprop_into_successor_phis (basic_block bb)\n \n       /* Push the unwind marker so we can reset the const and copies\n \t table back to its original state after processing this edge.  */\n-      const_and_copies_stack.safe_push (NULL_TREE);\n+      const_and_copies->push_marker ();\n \n       /* Extract and record any simple NAME = VALUE equivalences.\n \n@@ -1953,7 +1877,7 @@ cprop_into_successor_phis (basic_block bb)\n \t  tree rhs = edge_info->rhs;\n \n \t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t    record_const_or_copy (lhs, rhs);\n+\t    const_and_copies->record_const_or_copy (lhs, rhs);\n \t}\n \n       indx = e->dest_idx;\n@@ -1982,7 +1906,7 @@ cprop_into_successor_phis (basic_block bb)\n \t    propagate_value (orig_p, new_val);\n \t}\n \n-      restore_vars_to_original_value ();\n+      const_and_copies->pop_to_marker ();\n     }\n }\n \n@@ -1998,7 +1922,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n      far to unwind when we finalize this block.  */\n   avail_exprs_stack.safe_push\n     (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n-  const_and_copies_stack.safe_push (NULL_TREE);\n+  const_and_copies->push_marker ();\n \n   record_equivalences_from_incoming_edge (bb);\n \n@@ -2064,7 +1988,7 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n \n   /* These remove expressions local to BB from the tables.  */\n   remove_local_expressions_from_table ();\n-  restore_vars_to_original_value ();\n+  const_and_copies->pop_to_marker ();\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -2128,7 +2052,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n        This should be sufficient to kill the redundant phi.  */\n     {\n       if (def && cached_lhs)\n-\trecord_const_or_copy (def, cached_lhs);\n+\tconst_and_copies->record_const_or_copy (def, cached_lhs);\n       return;\n     }\n   else"}, {"sha": "82340c48f5da1f2d718e276a28a19a3442186e14", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-inline.h\"\n #include \"flags.h\"\n+#include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n \n /* Duplicates headers of loops if they are small enough, so that the statements"}, {"sha": "c336a902a0582751f9654ddaedb6e3a80ac38c56", "filename": "gcc/tree-ssa-scopedtables.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -0,0 +1,152 @@\n+/* Header file for SSA dominator optimizations.\n+   Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hash-table.h\"\n+#include \"tm.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"real.h\"\n+#include \"tree.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-scopedtables.h\"\n+#include \"tree-ssa-threadedge.h\"\n+\n+const_and_copies::const_and_copies (FILE *file, int flags)\n+{\n+  stack.create (20);\n+  dump_file = file;\n+  dump_flags = flags;\n+}\n+\n+/* Pop entries off the stack until we hit the NULL marker.\n+   For each entry popped, use the SRC/DEST pair to restore\n+   SRC to its prior value.  */\n+\n+void\n+const_and_copies::pop_to_marker (void)\n+{\n+  while (stack.length () > 0)\n+    {\n+      tree prev_value, dest;\n+\n+      dest = stack.pop ();\n+\n+      /* A NULL value indicates we should stop unwinding, otherwise\n+\t pop off the next entry as they're recorded in pairs.  */\n+      if (dest == NULL)\n+\tbreak;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"<<<< COPY \");\n+\t  print_generic_expr (dump_file, dest, 0);\n+\t  fprintf (dump_file, \" = \");\n+\t  print_generic_expr (dump_file, SSA_NAME_VALUE (dest), 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      prev_value = stack.pop ();\n+      set_ssa_name_value (dest, prev_value);\n+    }\n+}\n+\n+/* Record that X has the value Y.  */\n+\n+void\n+const_and_copies::record_const_or_copy (tree x, tree y)\n+{\n+  record_const_or_copy (x, y, SSA_NAME_VALUE (x));\n+}\n+\n+/* Record that X has the value Y and that X's previous value is PREV_X.  */\n+\n+void\n+const_and_copies::record_const_or_copy (tree x, tree y, tree prev_x)\n+{\n+  /* Y may be NULL if we are invalidating entries in the table.  */\n+  if (y && TREE_CODE (y) == SSA_NAME)\n+    {\n+      tree tmp = SSA_NAME_VALUE (y);\n+      y = tmp ? tmp : y;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"0>>> COPY \");\n+      print_generic_expr (dump_file, x, 0);\n+      fprintf (dump_file, \" = \");\n+      print_generic_expr (dump_file, y, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  set_ssa_name_value (x, y);\n+  stack.reserve (2);\n+  stack.quick_push (prev_x);\n+  stack.quick_push (x);\n+}\n+\n+/* A new value has been assigned to LHS.  If necessary, invalidate any\n+   equivalences that are no longer valid.   This includes invaliding\n+   LHS and any objects that are currently equivalent to LHS.\n+\n+   Finding the objects that are currently marked as equivalent to LHS\n+   is a bit tricky.  We could walk the ssa names and see if any have\n+   SSA_NAME_VALUE that is the same as LHS.  That's expensive.\n+\n+   However, it's far more efficient to look at the unwinding stack as\n+   that will have all context sensitive equivalences which are the only\n+   ones that we really have to worry about here.   */\n+void\n+const_and_copies::invalidate (tree lhs)\n+{\n+\n+  /* The stack is an unwinding stack.  If the current element is NULL\n+     then it's a \"stop unwinding\" marker.  Else the current marker is\n+     the SSA_NAME with an equivalence and the prior entry in the stack\n+     is what the current element is equivalent to.  */\n+  for (int i = stack.length() - 1; i >= 0; i--)\n+    {\n+      /* Ignore the stop unwinding markers.  */\n+      if ((stack)[i] == NULL)\n+\tcontinue;\n+\n+      /* We want to check the current value of stack[i] to see if\n+\t it matches LHS.  If so, then invalidate.  */\n+      if (SSA_NAME_VALUE ((stack)[i]) == lhs)\n+\trecord_const_or_copy ((stack)[i], NULL_TREE);\n+\n+      /* Remember, we're dealing with two elements in this case.  */\n+      i--;\n+    }\n+\n+  /* And invalidate any known value for LHS itself.  */\n+  if (SSA_NAME_VALUE (lhs))\n+    record_const_or_copy (lhs, NULL_TREE);\n+}"}, {"sha": "bc30ee6758350b31a267c0b7aafd40723f25e31b", "filename": "gcc/tree-ssa-scopedtables.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -0,0 +1,40 @@\n+/* Header file for SSA dominator optimizations.\n+   Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_SCOPED_TABLES_H\n+#define GCC_TREE_SSA_SCOPED_TABLES_H\n+\n+class const_and_copies\n+{\n+ public:\n+  const_and_copies (FILE *, int);\n+  ~const_and_copies (void) { stack.release (); }\n+  void push_marker (void) { stack.safe_push (NULL_TREE); }\n+  void pop_to_marker (void);\n+  void record_const_or_copy (tree, tree);\n+  void record_const_or_copy (tree, tree, tree);\n+  void invalidate (tree);\n+\n+ private:\n+  vec<tree> stack;\n+  FILE *dump_file;\n+  int dump_flags;\n+};\n+\n+#endif /* GCC_TREE_SSA_SCOPED_TABLES_H */"}, {"sha": "acbbb671dccfdc6cde1f2f84cd3564273bdbfd91", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 20, "deletions": 109, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadupdate.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n+#include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-loop.h\"\n #include \"builtins.h\"\n@@ -163,57 +164,6 @@ lhs_of_dominating_assert (tree op, basic_block bb, gimple stmt)\n   return op;\n }\n \n-/* We record temporary equivalences created by PHI nodes or\n-   statements within the target block.  Doing so allows us to\n-   identify more jump threading opportunities, even in blocks\n-   with side effects.\n-\n-   We keep track of those temporary equivalences in a stack\n-   structure so that we can unwind them when we're done processing\n-   a particular edge.  This routine handles unwinding the data\n-   structures.  */\n-\n-static void\n-remove_temporary_equivalences (vec<tree> *stack)\n-{\n-  while (stack->length () > 0)\n-    {\n-      tree prev_value, dest;\n-\n-      dest = stack->pop ();\n-\n-      /* A NULL value indicates we should stop unwinding, otherwise\n-\t pop off the next entry as they're recorded in pairs.  */\n-      if (dest == NULL)\n-\tbreak;\n-\n-      prev_value = stack->pop ();\n-      set_ssa_name_value (dest, prev_value);\n-    }\n-}\n-\n-/* Record a temporary equivalence, saving enough information so that\n-   we can restore the state of recorded equivalences when we're\n-   done processing the current edge.  */\n-\n-static void\n-record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n-{\n-  tree prev_x = SSA_NAME_VALUE (x);\n-\n-  /* Y may be NULL if we are invalidating entries in the table.  */\n-  if (y && TREE_CODE (y) == SSA_NAME)\n-    {\n-      tree tmp = SSA_NAME_VALUE (y);\n-      y = tmp ? tmp : y;\n-    }\n-\n-  set_ssa_name_value (x, y);\n-  stack->reserve (2);\n-  stack->quick_push (prev_x);\n-  stack->quick_push (x);\n-}\n-\n /* Record temporary equivalences created by PHIs at the target of the\n    edge E.  Record unwind information for the equivalences onto STACK.\n \n@@ -225,7 +175,7 @@ record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n    traversing back edges less painful.  */\n \n static bool\n-record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n+record_temporary_equivalences_from_phis (edge e, const_and_copies *const_and_copies)\n {\n   gphi_iterator gsi;\n \n@@ -252,7 +202,7 @@ record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n       if (!virtual_operand_p (dst))\n \tstmt_count++;\n \n-      record_temporary_equivalence (dst, src, stack);\n+      const_and_copies->record_const_or_copy (dst, src);\n     }\n   return true;\n }\n@@ -307,45 +257,6 @@ fold_assignment_stmt (gimple stmt)\n     }\n }\n \n-/* A new value has been assigned to LHS.  If necessary, invalidate any\n-   equivalences that are no longer valid.   This includes invaliding\n-   LHS and any objects that are currently equivalent to LHS.\n-\n-   Finding the objects that are currently marked as equivalent to LHS\n-   is a bit tricky.  We could walk the ssa names and see if any have\n-   SSA_NAME_VALUE that is the same as LHS.  That's expensive.\n-\n-   However, it's far more efficient to look at the unwinding stack as\n-   that will have all context sensitive equivalences which are the only\n-   ones that we really have to worry about here.   */\n-static void\n-invalidate_equivalences (tree lhs, vec<tree> *stack)\n-{\n-\n-  /* The stack is an unwinding stack.  If the current element is NULL\n-     then it's a \"stop unwinding\" marker.  Else the current marker is\n-     the SSA_NAME with an equivalence and the prior entry in the stack\n-     is what the current element is equivalent to.  */\n-  for (int i = stack->length() - 1; i >= 0; i--)\n-    {\n-      /* Ignore the stop unwinding markers.  */\n-      if ((*stack)[i] == NULL)\n-\tcontinue;\n-\n-      /* We want to check the current value of stack[i] to see if\n-\t it matches LHS.  If so, then invalidate.  */\n-      if (SSA_NAME_VALUE ((*stack)[i]) == lhs)\n-\trecord_temporary_equivalence ((*stack)[i], NULL_TREE, stack);\n-\n-      /* Remember, we're dealing with two elements in this case.  */\n-      i--;\n-    }\n-\n-  /* And invalidate any known value for LHS itself.  */\n-  if (SSA_NAME_VALUE (lhs))\n-    record_temporary_equivalence (lhs, NULL_TREE, stack);\n-}\n-\n /* Try to simplify each statement in E->dest, ultimately leading to\n    a simplification of the COND_EXPR at the end of E->dest.\n \n@@ -365,7 +276,7 @@ invalidate_equivalences (tree lhs, vec<tree> *stack)\n \n static gimple\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n-\t\t\t\t\t\t  vec<tree> *stack,\n+\t\t\t\t\t\t  const_and_copies *const_and_copies,\n \t\t\t\t\t\t  tree (*simplify) (gimple,\n \t\t\t\t\t\t\t\t    gimple),\n \t\t\t\t\t\t  bool backedge_seen)\n@@ -425,7 +336,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \n \t  if (backedge_seen)\n \t    FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\t      invalidate_equivalences (op, stack);\n+\t      const_and_copies->invalidate (op);\n \n \t  continue;\n \t}\n@@ -465,7 +376,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t      if (backedge_seen)\n \t\t{\n \t\t  tree lhs = gimple_get_lhs (stmt);\n-\t\t  invalidate_equivalences (lhs, stack);\n+\t\t  const_and_copies->invalidate (lhs);\n \t\t}\n \t      continue;\n \t    }\n@@ -541,9 +452,9 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n-\trecord_temporary_equivalence (gimple_get_lhs (stmt), cached_lhs, stack);\n+\tconst_and_copies->record_const_or_copy (gimple_get_lhs (stmt), cached_lhs);\n       else if (backedge_seen)\n-\tinvalidate_equivalences (gimple_get_lhs (stmt), stack);\n+\tconst_and_copies->invalidate (gimple_get_lhs (stmt));\n     }\n   return stmt;\n }\n@@ -1264,7 +1175,7 @@ static int\n thread_through_normal_block (edge e,\n \t\t\t     gcond *dummy_cond,\n \t\t\t     bool handle_dominating_asserts,\n-\t\t\t     vec<tree> *stack,\n+\t\t\t     const_and_copies *const_and_copies,\n \t\t\t     tree (*simplify) (gimple, gimple),\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited,\n@@ -1281,13 +1192,13 @@ thread_through_normal_block (edge e,\n      Note that if we found a PHI that made the block non-threadable, then\n      we need to bubble that up to our caller in the same manner we do\n      when we prematurely stop processing statements below.  */\n-  if (!record_temporary_equivalences_from_phis (e, stack))\n+  if (!record_temporary_equivalences_from_phis (e, const_and_copies))\n     return -1;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n   gimple stmt\n-    = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n+    = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies, simplify,\n \t\t\t\t\t\t\t*backedge_seen_p);\n \n   /* There's two reasons STMT might be null, and distinguishing\n@@ -1434,7 +1345,7 @@ void\n thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n \t\t    bool handle_dominating_asserts,\n-\t\t    vec<tree> *stack,\n+\t\t    const_and_copies *const_and_copies,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n@@ -1452,13 +1363,13 @@ thread_across_edge (gcond *dummy_cond,\n \n   int threaded = thread_through_normal_block (e, dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n-\t\t\t\t\t      stack, simplify, path,\n+\t\t\t\t\t      const_and_copies, simplify, path,\n \t\t\t\t\t      visited, &backedge_seen);\n   if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n-      remove_temporary_equivalences (stack);\n+      const_and_copies->pop_to_marker ();\n       BITMAP_FREE (visited);\n       register_jump_thread (path);\n       return;\n@@ -1482,7 +1393,7 @@ thread_across_edge (gcond *dummy_cond,\n       if (threaded < 0)\n \t{\n \t  BITMAP_FREE (visited);\n-\t  remove_temporary_equivalences (stack);\n+\t  const_and_copies->pop_to_marker ();\n \t  return;\n \t}\n     }\n@@ -1508,7 +1419,7 @@ thread_across_edge (gcond *dummy_cond,\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       if (taken_edge->flags & EDGE_ABNORMAL)\n \t{\n-\t  remove_temporary_equivalences (stack);\n+\t  const_and_copies->pop_to_marker ();\n \t  BITMAP_FREE (visited);\n \t  return;\n \t}\n@@ -1518,7 +1429,7 @@ thread_across_edge (gcond *dummy_cond,\n       {\n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n-\tstack->safe_push (NULL_TREE);\n+\tconst_and_copies->push_marker ();\n      \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1553,7 +1464,7 @@ thread_across_edge (gcond *dummy_cond,\n \tif (!found)\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n-\t\t\t\t\t       stack, simplify, path, visited,\n+\t\t\t\t\t       const_and_copies, simplify, path, visited,\n \t\t\t\t\t       &backedge_seen) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then\n@@ -1570,10 +1481,10 @@ thread_across_edge (gcond *dummy_cond,\n \t  }\n \n \t/* And unwind the equivalence table.  */\n-\tremove_temporary_equivalences (stack);\n+\tconst_and_copies->pop_to_marker ();\n       }\n     BITMAP_FREE (visited);\n   }\n \n-  remove_temporary_equivalences (stack);\n+  const_and_copies->pop_to_marker ();\n }"}, {"sha": "521fd0e30ed0b4b3c30c8839e3230b49831fc237", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -31,6 +31,6 @@ extern void threadedge_finalize_values (void);\n extern bool potentially_threadable_block (basic_block);\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n extern void thread_across_edge (gcond *, edge, bool,\n-\t\t\t\tvec<tree> *, tree (*) (gimple, gimple));\n+\t\t\t\tconst_and_copies *, tree (*) (gimple, gimple));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "e7ab23c0c0b0c56e6186321d9cf2d15111a3731c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6c72af46fbbd30fd01f7bb8c678a252f7be67ba/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f6c72af46fbbd30fd01f7bb8c678a252f7be67ba", "patch": "@@ -88,6 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n+#include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n \n \n@@ -10054,12 +10055,8 @@ vrp_fold_stmt (gimple_stmt_iterator *si)\n   return simplify_stmt_using_ranges (si);\n }\n \n-/* Stack of dest,src equivalency pairs that need to be restored after\n-   each attempt to thread a block's incoming edge to an outgoing edge.\n-\n-   A NULL entry is used to mark the end of pairs which need to be\n-   restored.  */\n-static vec<tree> equiv_stack;\n+/* Unwindable const/copy equivalences.  */\n+const_and_copies *equiv_stack;\n \n /* A trivial wrapper so that we can present the generic jump threading\n    code with a simple API for simplifying statements.  STMT is the\n@@ -10140,7 +10137,7 @@ identify_jump_threads (void)\n \n   /* Allocate our unwinder stack to unwind any temporary equivalences\n      that might be recorded.  */\n-  equiv_stack.create (20);\n+  equiv_stack = new const_and_copies (dump_file, dump_flags);\n \n   /* To avoid lots of silly node creation, we create a single\n      conditional and just modify it in-place when attempting to\n@@ -10198,7 +10195,7 @@ identify_jump_threads (void)\n \t      if (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t\tcontinue;\n \n-\t      thread_across_edge (dummy, e, true, &equiv_stack,\n+\t      thread_across_edge (dummy, e, true, equiv_stack,\n \t\t\t\t  simplify_stmt_for_jump_threading);\n \t    }\n \t}\n@@ -10219,7 +10216,7 @@ static void\n finalize_jump_threads (void)\n {\n   thread_through_all_blocks (false);\n-  equiv_stack.release ();\n+  delete equiv_stack;\n }\n \n "}]}