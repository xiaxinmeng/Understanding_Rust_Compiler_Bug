{"sha": "ab835497c9a339a644a752a4b0a061d1370a00f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI4MzU0OTdjOWEzMzlhNjQ0YTc1MmE0YjBhMDYxZDEzNzBhMDBmMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T22:12:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T22:12:35Z"}, "message": "Initial revision\n\nFrom-SVN: r193", "tree": {"sha": "cd220794d38e654180f077a010dad37bb71332a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd220794d38e654180f077a010dad37bb71332a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab835497c9a339a644a752a4b0a061d1370a00f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab835497c9a339a644a752a4b0a061d1370a00f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab835497c9a339a644a752a4b0a061d1370a00f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab835497c9a339a644a752a4b0a061d1370a00f1/comments", "author": null, "committer": null, "parents": [{"sha": "a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8efe40d3fd0594aae44253d9ff6ffc466d2f210"}], "stats": {"total": 8368, "additions": 8368, "deletions": 0}, "files": [{"sha": "1d33790b76bc7ee5d2cd7863337041aa239f663c", "filename": "gcc/config/a29k/a29k.md", "status": "added", "additions": 2719, "deletions": 0, "changes": 2719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=ab835497c9a339a644a752a4b0a061d1370a00f1", "patch": "@@ -0,0 +1,2719 @@\n+;;- Machine description for AMD Am29000 for GNU C compiler\n+;;   Copyright (C) 1991 Free Software Foundation, Inc.\n+;;   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; The insns in this file are presented in the same order as the AMD 29000\n+;; User's Manual (i.e., alphabetical by machine op-code).\n+;;\n+;; DEFINE_EXPAND's are located near the first occurrance of the major insn\n+;; that they generate.\n+\f\n+;; The only attribute we have is the type.  We only care about calls, branches,\n+;; loads, stores, floating-point operations, and multi-word insns.\n+;; Everything else is miscellaneous.\n+\n+(define_attr \"type\"\n+  \"call,branch,load,store,fadd,fmul,fam,fdiv,dmul,dam,ddiv,multi,misc\"\n+  (const_string \"misc\"))\n+\n+;; ASM insns cannot go into a delay slot, so call them \"multi\".\n+(define_asm_attributes [(set_attr \"type\" \"multi\")])\n+\n+(define_attr \"in_delay_slot\" \"yes,no\"\n+  (if_then_else (eq_attr \"type\" \"call,branch,multi\")  (const_string \"no\")\n+\t\t(const_string \"yes\")))\n+\n+;; Branch and call insns require a single delay slot.  Annulling is not\n+;; supported.\n+(define_delay (eq_attr \"type\" \"call,branch\")\n+  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n+\n+;; Define the function unit usages.  We first define memory as a unit.\n+(define_function_unit \"memory\" 1 2 (eq_attr \"type\" \"load\") 6 11)\n+(define_function_unit \"memory\" 1 2 (eq_attr \"type\" \"store\") 1 0)\n+\n+;; Now define the function units for the floating-point support.  Most\n+;; units are pipelined and can accept an input every cycle.\n+;;\n+;; Note that we have an inaccuracy here.  If a fmac insn is issued, followed\n+;; 2 cycles later by a fadd, there will be a conflict for the floating\n+;; adder that we can't represent.  Also, all insns will conflict for the\n+;; floating-point rounder.  It isn't clear how to represent this.\n+\n+(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"fmul\") 3 0)\n+(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"dmul\") 6 8)\n+(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"fam\") 6 8)\n+(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"dam\") 9 8)\n+\n+(define_function_unit \"adder\" 1 0 (eq_attr \"type\" \"fadd,fam,dam\") 3 0)\n+\n+(define_function_unit \"divider\" 1 1 (eq_attr \"type\" \"fdiv\") 11 20)\n+(define_function_unit \"divider\" 1 1 (eq_attr \"type\" \"ddiv\") 18 34)\n+\f\n+;; ADD\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"rI,N\")))]\n+  \"\"\n+  \"@\n+   add %0,%1,%2\n+   sub %0,%1,%n2\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"gen_reg_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"add %L0,%L1,%L2\\;addc %0,%1,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; AND/ANDN\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"and_operand\" \"rI,K\")))]\n+  \"\"\n+  \"@\n+   and %0,%1,%2\n+   andn %0,%1,%C2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"srcb_operand\" \"rI\"))\n+\t\t(match_operand:SI 2 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"andn %0,%2,%1\")\n+\n+\f\n+;; CALLI\n+;;\n+;; Start with a subroutine to write out CLOBBERs starting at lr2 up to,\n+;; but not including, the next parameter register.  If operand[0] is null,\n+;; it means that all the argument registers have been used.\n+(define_expand \"clobbers_to\"\n+  [(clobber (match_operand:SI 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  int i;\n+  int high_regno;\n+\n+  if (operands[0] == 0)\n+    high_regno = R_LR (18);\n+  else if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) < R_LR (0)\n+\t   || REGNO (operands[0]) > R_LR (18))\n+    abort ();\n+  else\n+    high_regno = REGNO (operands[0]);\n+\n+  for (i = R_LR (2); i < high_regno; i++)\n+    emit_insn (gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, i)));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 32))])\n+   (match_operand 2 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+\n+  if (! TARGET_SMALL_MEMORY\n+      && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+\n+  operands[2] = gen_clobbers_to (operands[2]);\n+}\")\n+ \n+(define_insn \"\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 32))]\n+  \"\"\n+  \"calli lr0,%0%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t\t   (clobber (reg:SI 32))])\n+   (match_operand 3 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n+  if (! TARGET_SMALL_MEMORY\n+      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+\n+  operands[3] = gen_clobbers_to (operands[3]);\n+}\")\n+ \n+(define_insn \"\"\n+  [(set (match_operand 0 \"gen_reg_operand\" \"=r\")\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 32))]\n+  \"\"\n+  \"calli lr0,%1%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"immediate_operand\" \"i\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 32))]\n+  \"GET_CODE (operands[0]) == SYMBOL_REF\n+   && (TARGET_SMALL_MEMORY\n+       || ! strcmp (XSTR (operands[0], 0), current_function_name))\"\n+  \"call lr0,%F0\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"gen_reg_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n+   (clobber (reg:SI 32))]\n+  \"GET_CODE (operands[1]) == SYMBOL_REF\n+   && (TARGET_SMALL_MEMORY\n+       || ! strcmp (XSTR (operands[1], 0), current_function_name))\"\n+  \"call lr0,%F1\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"probe\"\n+  [(call (mem:SI (symbol_ref:SI \"_msp_check\"))\n+\t (const_int 1))]\n+  \"TARGET_STACK_CHECK\"\n+  \"\")\n+\n+;; This is used for internal routine calls via TPC.  Currently used only\n+;; in probe, above.\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"immediate_operand\" \"s\"))\n+\t (const_int 1))]\n+  \"\"\n+  \"call %*,%0\"\n+  [(set_attr \"type\" \"call\")])\n+\f\n+;; CONST, CONSTH, CONSTN\n+;;\n+;; Many of these are generated from move insns.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"immediate_operand\" \"i\")\n+\t\t(const_int 65535)))]\n+  \"\"\n+  \"const %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 16)\n+\t\t\t (match_operand:SI 1 \"const_0_operand\" \"\"))\n+\t(ashiftrt:SI (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t     (const_int 16)))]\n+  \"\"\n+  \"consth %0,%2\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 16)\n+\t\t\t (match_operand:SI 1 \"const_0_operand\" \"\"))\n+\t(match_operand:SI 2 \"cint_16_operand\" \"J\"))]\n+  \"\"\n+  \"*\n+{ operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) << 16);\n+  return \\\"consth %0,%2\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"gen_reg_operand\" \"0\")\n+\t\t\t(const_int 65535))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"consth %0,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"gen_reg_operand\" \"0\")\n+\t\t\t(const_int 65535))\n+\t\t(and:SI (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t\t(const_int -65536))))]\n+  \"\"\n+  \"consth %0,%2\")\n+\n+\f\n+;; CONVERT\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,3,0,1\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,3,0,2\")\n+\n+(define_insn \"fixuns_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(unsigned_fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,1,3,0,1\")\n+\n+(define_insn \"fixuns_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(unsigned_fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,1,3,0,2\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,4,1,2\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,4,2,1\")\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float:SF (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,4,1,0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float:DF (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,0,4,2,0\")\n+\n+(define_insn \"floatunssisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(unsigned_float:SF (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,1,4,1,0\")\n+\n+(define_insn \"floatunssidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(unsigned_float:DF (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"convert %0,%1,1,4,2,0\")\n+\f\n+;; CPxxx, DEQ, DGT, DGE, FEQ, FGT, FGE\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operator 3 \"comparison_operator\"\n+\t\t\t[(match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"srcb_operand\" \"rI\")]))]\n+  \"\"\n+  \"cp%J3 %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operator 3 \"fp_comparison_operator\"\n+\t\t\t[(match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"r\")]))]\n+  \"\"\n+  \"f%J3 %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operator 3 \"fp_comparison_operator\"\n+\t\t\t[(match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"r\")]))]\n+  \"\"\n+  \"d%J3 %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\f\n+;; DADD\n+(define_expand \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050 \"\n+  \"dadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,a\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,0\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   dadd %0,%1,%2\n+   dmac 8,%0,%1,0\"\n+  [(set_attr \"type\" \"fadd,dam\")])\n+\n+;; DDIV\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"=r\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ddiv %0,%1,%2\"\n+  [(set_attr \"type\" \"ddiv\")])\n+\f\n+;; DIVIDE\n+;;\n+;; We must set Q to the sign extension of the dividend first.  For MOD, we\n+;; must get the remainder from Q.\n+;;\n+;; For divmod: operand 1 is divided by operand 2; quotient goes to operand\n+;; 0 and remainder to operand 3.\n+(define_expand \"divmodsi4\"\n+  [(set (match_dup 4)\n+\t(ashiftrt:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t     (const_int 31)))\n+   (set (reg:SI 180)\n+\t(match_dup 4))\n+   (parallel [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t   (div:SI (match_dup 1)\n+\t\t\t   (match_operand:SI 2 \"gen_reg_operand\" \"\")))\n+\t      (set (reg:SI 180)\n+\t\t   (mod:SI (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+\t      (use (reg:SI 180))])\n+   (set (match_operand:SI 3 \"gen_reg_operand\" \"\")\n+\t(reg:SI 180))]\n+  \"\"\n+  \"\n+{\n+  operands[4] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"gen_reg_operand\" \"r\")))\n+   (set (reg:SI 180)\n+\t(mod:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (use (reg:SI 180))]\n+  \"\"\n+  \"divide %0,%1,%2\")\n+\f\n+;; DIVIDU\n+;;\n+;; Similar to DIVIDE.\n+(define_expand \"udivmodsi4\"\n+  [(set (reg:SI 180)\n+\t(const_int 0))\n+   (parallel [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t   (udiv:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"gen_reg_operand\" \"\")))\n+\t      (set (reg:SI 180)\n+\t\t   (umod:SI (match_dup 1)\n+\t\t\t    (match_dup 2)))\n+\t      (use (reg:SI 180))])\n+   (set (match_operand:SI 3 \"gen_reg_operand\" \"\")\n+\t(reg:SI 180))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"gen_reg_operand\" \"r\")))\n+   (set (reg:SI 180)\n+\t(umod:SI (match_dup 1)\n+\t\t (match_dup 2)))\n+   (use (reg:SI 180))]\n+  \"\"\n+  \"dividu %0,%1,%2\")\n+\f\n+;; DMAC/DMSM\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,*r\")\n+\t(plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"%r,A\")\n+\t\t\t  (match_operand:DF 2 \"register_operand\" \"r,r\"))\n+\t\t (match_operand:DF 3 \"register_operand\" \"0,*r\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   dmac 0,%0,%1,%2\n+   dmsm %0,%2,%3\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(plus:DF (mult:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n+\t\t\t  (match_operand:DF 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:DF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"dmac 1,%0,%2,%1\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t\t   (match_operand:DF 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:DF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"dmac 2,%0,%1,%2\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t\t   (neg:DF (match_operand:DF 2 \"register_operand\" \"r\")))\n+\t\t  (match_operand:DF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"dmac 3,%0,%1,%2\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(mult:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_29050\"\n+  \"dmac 5,%0,%2,%1\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(minus:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n+\t\t  (match_operand:DF 2 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"dmac 11,%0,%1,0\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(neg:DF (plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"0\"))))]\n+  \"TARGET_29050\"\n+  \"dmac 11,%0,%1,0\"\n+  [(set_attr \"type\" \"dam\")])\n+\n+(define_insn \"\"\n+ [(set (match_operand:DF 0 \"register_operand\" \"=r,r,a\")\n+       (neg:DF (match_operand:DF 1 \"register_operand\" \"0,r,r\")))\n+  (clobber (match_scratch:SI 2 \"=&r,&r,X\"))]\n+ \"TARGET_29050\"\n+ \"@\n+  cpeq %2,gr1,gr1\\;xor %0,%1,%2\n+  cpeq %2,gr1,gr1\\;xor %0,%1,%2\\;sll %L0,%L1,0\n+  dmac 13,%0,%1,0\"\n+ [(set_attr \"type\" \"multi,multi,dam\")])\n+\n+;; DMUL\n+(define_expand \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050\"\n+  \"dmul %0,%1,%2\"\n+  [(set_attr \"type\" \"dmul\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,a\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,r\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   dmul %0,%1,%2\n+   dmac 4,%0,%1,%2\"\n+  [(set_attr \"type\" \"dmul,dam\")])\n+\n+;; DSUB\n+(define_expand \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050\"\n+  \"dsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,a,a\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r,0,r\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r,r,0\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   dsub %0,%1,%2\n+   dmac 9,%0,%2,0\n+   dmac 10,%0,%1,0\"\n+  [(set_attr \"type\" \"fadd,dam,dam\")])\n+\f\n+;; EXBYTE\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"srcb_operand\" \"rI\")\n+\t\t\t(const_int -256))\n+\t\t(zero_extract:SI (match_operand:SI 2 \"gen_reg_operand\" \"r\")\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t    (const_int 3)))))]\n+  \"\"\n+  \"exbyte %0,%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"exbyte %0,%1,0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 1 \"const_24_operand\" \"\"))\n+\t(zero_extract:SI (match_operand:SI 2 \"gen_reg_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"exbyte %0,%2,%0\")\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  int size, pos;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT)\n+    FAIL;\n+\n+  size = INTVAL (operands[2]);\n+  pos = INTVAL (operands[3]);\n+  if ((size != 8 && size != 16) || pos % size != 0)\n+    FAIL;\n+\n+  operands[3] = gen_rtx (ASHIFT, SImode,\n+\t\t\t force_reg (SImode,\n+\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n+\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n+}\")\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  int pos;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT)\n+    FAIL;\n+\n+  pos = INTVAL (operands[3]);\n+  if (INTVAL (operands[2]) != 16 || pos % 16 != 0)\n+    FAIL;\n+\n+  operands[3] = gen_rtx (ASHIFT, SImode,\n+\t\t\t force_reg (SImode,\n+\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n+\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n+}\")\n+\n+;; EXHW\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"srcb_operand\" \"rI\")\n+\t\t(const_int -65536))\n+\t\t(zero_extract:SI (match_operand:SI 2 \"gen_reg_operand\" \"r\")\n+\t\t\t\t (const_int 16)\n+\t\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t    (const_int 3)))))]\n+  \"\"\n+  \"exhw %0,%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t (const_int 16)\n+\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"exhw %0,%1,0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 16)\n+\t\t\t (match_operand:SI 1 \"const_16_operand\" \"\"))\n+\t(zero_extract:SI (match_operand:SI 2 \"gen_reg_operand\" \"r\")\n+\t\t\t (const_int 16)\n+\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"exhw %0,%2,%0\")\n+\n+;; EXHWS\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t (const_int 16)\n+\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"exhws %0,%1\")\n+\f\n+;; EXTRACT\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t   (reg:QI 178)))]\n+  \"\"\n+  \"extract %0,%1,%1\")\n+\n+(define_expand \"rotlsi3\"\n+  [(set (reg:QI 178)\n+\t(match_operand: SI 2 \"gen_reg_or_immediate_operand\" \"\"))\n+   (set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(rotate:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t   (reg:QI 178)))]\n+  \"\"\n+  \"\n+{ operands[2] = gen_lowpart (QImode, operands[2]); }\")\n+\f\n+;; FADD\n+(define_expand \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050\"\n+  \"fadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r,0\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   fadd %0,%1,%2\n+   fmac 8,%0,%1,0\"\n+  [(set_attr \"type\" \"fadd,fam\")])\n+\n+;; FDIV\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:SF 1 \"register_operand\" \"=r\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"fdiv %0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+;; FDMUL\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"%r\"))\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"fdmul %0,%1,%2\")\n+\n+;; FMAC/FMSM\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a,*r\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%r,A\")\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"r,r\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"0,*r\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   fmac 0,%0,%1,%2\n+   fmsm %0,%2,%3\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(plus:SF (mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"fmac 1,%0,%2,%1\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"fmac 2,%0,%1,%2\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(minus:SF (mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"fmac 3,%0,%2,%1\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_29050\"\n+  \"fmac 5,%0,%2,%1\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(minus:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"%r\"))\n+\t\t  (match_operand:SF 2 \"register_operand\" \"0\")))]\n+  \"TARGET_29050\"\n+  \"fmac 11,%0,%1,0\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(neg:SF (plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"0\"))))]\n+  \"TARGET_29050\"\n+  \"fmac 11,%0,%1,0\"\n+  [(set_attr \"type\" \"fam\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"r,r\")))\n+   (clobber (match_scratch:SI 2 \"=&r,X\"))]\n+  \"TARGET_29050\"\n+  \"@\n+   cpeq %2,gr1,gr1\\;xor %0,%1,%2\n+   fmac 13,%0,%1,0\"\n+  [(set_attr \"type\" \"multi,fam\")])\n+\n+;; FMUL\n+(define_expand \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050\"\n+  \"fmul %0,%1,%2\"\n+  [(set_attr \"type\" \"fmul\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r,r\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   fmul %0,%1,%2\n+   fmac 4,%0,%1,%2\"\n+  [(set_attr \"type\" \"fmul,fam\")])\n+\n+;; FSUB\n+(define_expand \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"! TARGET_29050\"\n+  \"fsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,a,a\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r,0,r\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"r,r,0\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   fsub %0,%1,%2\n+   fmac 9,%0,%2,0\n+   fmac 10,%0,%1,0\"\n+  [(set_attr \"type\" \"fadd,fam,fam\")])\n+\f\n+;; INBYTE\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3)))\n+\t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n+  \"\"\n+  \"inbyte %0,%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n+\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(ashift:SI (and:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n+\t\t\t\t   (const_int 255))\n+\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+  \"\"\n+  \"inbyte %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n+\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(ashift:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n+\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+  \"\"\n+  \"inbyte %0,%1,%2\")\n+\n+;; INHW\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"+r\")\n+\t\t\t (const_int 16)\n+\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t\t    (const_int 3)))\n+\t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n+  \"\"\n+  \"inhw %0,%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n+\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(ashift:SI (and:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n+\t\t\t\t   (const_int 65535))\n+\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+  \"\"\n+  \"inhw %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n+\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(ashift:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n+\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+  \"\"\n+  \"inhw %0,%1,%2\")\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"\"))\n+\t(match_operand:SI 3 \"srcb_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  int size, pos;\n+\n+  if (GET_CODE (operands[1]) != CONST_INT\n+      || GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  size = INTVAL (operands[1]);\n+  pos = INTVAL (operands[2]);\n+  if ((size != 8 && size != 16) || pos % size != 0)\n+    FAIL;\n+\n+  operands[2] = gen_rtx (ASHIFT, SImode,\n+\t\t\t force_reg (SImode,\n+\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n+\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n+}\")\n+\f\n+;; LOAD (also used by move insn).\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(mem:SI (and:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t(const_int -4))))\n+   (set (reg:SI 177)\n+\t(and:SI (match_dup 1)\n+\t\t(const_int 3)))]\n+  \"! TARGET_DW_ENABLE\"\n+  \"load 0,17,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(mem:SI (and:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t(const_int -4))))\n+   (set (reg:SI 177)\n+\t(and:SI (match_dup 1)\n+\t\t(const_int 2)))]\n+  \"! TARGET_DW_ENABLE\"\n+  \"load 0,18,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operator 2 \"extend_operator\"\n+\t\t\t[(match_operand 1 \"memory_operand\" \"m\")]))]\n+  \"TARGET_DW_ENABLE && GET_MODE (operands[0]) == GET_MODE (operands[2])\"\n+  \"load 0,%X2,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; LOADM\n+(define_expand \"load_multiple\"\n+  [(set (reg:SI 179)\n+\t(match_dup 2))\n+   (match_parallel 3 \"\" [(set (match_operand:SI 0 \"\" \"\")\n+\t\t\t      (match_operand:SI 1 \"\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  int regno;\n+  int count;\n+  rtx from;\n+  int i;\n+\n+  /* Support only loading a constant number of hard registers from memory.  */\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || operands[2] == const1_rtx\n+      || GET_CODE (operands[1]) != MEM\n+      || GET_CODE (operands[0]) != REG\n+      || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  regno = REGNO (operands[0]);\n+\n+  /* CR gets set to the number of registers minus one.  */\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, count - 1);\n+\n+  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n+  from = memory_address (SImode, XEXP (operands[1], 0));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t gen_rtx (REG, SImode, regno),\n+\t\t\t\t\t gen_rtx (MEM, SImode, from));\n+  XVECEXP (operands[3], 0, 1)\n+    = gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+  XVECEXP (operands[3], 0, 2)\n+    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+\n+  for (i = 1; i < count; i++)\n+    XVECEXP (operands[3], 0, i + 2)\n+      = gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, regno + i),\n+\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)));\n+}\")\n+\n+;; Indicate that CR is used and is then clobbered.\n+(define_insn \"\"\n+  [(set (match_operand 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operand 1 \"memory_operand\" \"m\"))\n+   (use (reg:SI 179))\n+   (clobber (reg:SI 179))]\n+  \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\n+   && ! TARGET_29050\"\n+  \"loadm 0,0,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"gen_reg_operand\" \"=&r\")\n+\t(match_operand 1 \"memory_operand\" \"m\"))\n+   (use (reg:SI 179))\n+   (clobber (reg:SI 179))]\n+  \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\n+   && TARGET_29050\"\n+  \"loadm 0,0,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+\t\t   [(set (match_operand:SI 1 \"gen_reg_operand\" \"=r\")\n+\t\t\t (match_operand:SI 2 \"memory_operand\" \"m\"))\n+\t\t    (use (reg:SI 179))\n+\t\t    (clobber (reg:SI 179))])]\n+  \"! TARGET_29050\"\n+  \"loadm 0,0,%1,%2\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+\t\t   [(set (match_operand:SI 1 \"gen_reg_operand\" \"=&r\")\n+\t\t\t (match_operand:SI 2 \"memory_operand\" \"m\"))\n+\t\t    (use (reg:SI 179))\n+\t\t    (clobber (reg:SI 179))])]\n+  \"TARGET_29050\"\n+  \"loadm 0,0,%1,%2\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; MTSR (used also by move insn)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"spec_reg_operand\" \"=*h,*h\")\n+\t(and:SI (match_operand:SI 1 \"gen_reg_or_immediate_operand\" \"r,i\")\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"n,n\")))]\n+  \"masks_bits_for_special (operands[0], operands[2])\"\n+  \"@\n+   mtsr %0,%1\n+   mtsrim %0,%1\")\n+\f\n+;; MULTIPLY, MULTM, MULTMU\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"multiply %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(subreg:SI\n+\t (mult:DI\n+\t  (sign_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"%r\"))\n+\t  (sign_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"r\"))) 0))]\n+  \"\"\n+  \"multm %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(subreg:SI\n+\t (mult:DI\n+\t  (zero_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"%r\"))\n+\t  (zero_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"r\"))) 0))]\n+  \"\"\n+  \"multmu %0,%1,%2\")\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"r\"))))]\n+  \"\"\n+  \"multiply %L0,%1,%2\\;multm %0,%1,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"\"))))]\n+  \"reload_completed\"\n+  [(set (match_dup 3)\n+\t(mult:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 4)\n+\t(subreg:SI (mult:DI\n+\t\t    (sign_extend:DI (match_dup 1))\n+\t\t    (sign_extend:DI (match_dup 2))) 0))]\n+  \"\n+{ operands[3] = operand_subword (operands[0], 1, 1, DImode);\n+  operands[4] = operand_subword (operands[1], 0, 1, DImode); } \")\n+\t\t\t    \n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"r\"))))]\n+  \"\"\n+  \"multiplu %L0,%1,%2\\;multmu %0,%1,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"gen_reg_operand\" \"\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"gen_reg_operand\" \"\"))))]\n+  \"reload_completed\"\n+  [(set (match_dup 3)\n+\t(mult:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 4)\n+\t(subreg:SI (mult:DI (zero_extend:DI (match_dup 1))\n+\t\t\t    (zero_extend:DI (match_dup 2))) 0))]\n+  \"\n+{ operands[3] = operand_subword (operands[0], 1, 1, DImode);\n+  operands[4] = operand_subword (operands[1], 0, 1, DImode); } \")\n+\t\t\t    \n+;; NAND\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\"))\n+\t\t(not:SI (match_operand:SI 2 \"srcb_operand\" \"rI\"))))]\n+  \"\"\n+  \"nand %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"K\")))]\n+  \"((unsigned) ~ INTVAL (operands[2])) < 256\"\n+  \"nand %0,%1,%C2\")\n+\n+;; NOR\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\"))\n+\t\t(not:SI (match_operand:SI 2 \"srcb_operand\" \"rI\"))))]\n+  \"\"\n+  \"nor %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"K\")))]\n+  \"((unsigned) ~ INTVAL (operands[2])) < 256\"\n+  \"nor %0,%1,%C2\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"nor %0,%1,0\")\n+\f\n+;; OR/ORN\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"gen_reg_operand\" \"\")\n+\t\t(match_operand:SI 2 \"srcb_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"srcb_operand\" \"rI\")))]\n+  \"! TARGET_29050\"\n+  \"or %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"srcb_operand\" \"rI,K\")))]\n+  \"TARGET_29050\"\n+  \"@\n+   or %0,%1,%2\n+   orn %0,%1,%C2\")\n+\n+\f\n+;; SLL (also used by move insn)\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"aseq 0x40,gr1,gr1\")\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t   (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n+  \"\"\n+  \"sll %0,%1,%Q2\")\n+\n+;; SRA\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t     (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n+  \"\"\n+  \"sra %0,%1,%Q2\")\n+\n+;; SRL\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t     (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n+  \"\"\n+  \"srl %0,%1,%Q2\")\n+\f\n+;; STORE\n+;;\n+;; These somewhat bogus patterns exist to set OPT = 001/010 for partial-word\n+;; stores on systems with DW not set.\n+(define_insn \"\"\n+  [(set (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"r\")\n+\t\t\t(const_int -4)))\n+\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))]\n+  \"! TARGET_DW_ENABLE\"\n+  \"store 0,1,%1,%0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"r\")\n+\t\t\t(const_int -3)))\n+\t(match_operand:SI 1 \"gen_reg_operand\" \"r\"))]\n+  \"! TARGET_DW_ENABLE\"\n+  \"store 0,2,%1,%0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+;; STOREM\n+(define_expand \"store_multiple\"\n+  [(use (match_operand 0 \"\" \"\"))\n+   (use (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))]\n+  \"\"\n+  \"\n+{ rtx pat;\n+\n+ if (TARGET_NO_STOREM_BUG)\n+    pat = gen_store_multiple_no_bug (operands[0], operands[1], operands[2]);\n+  else\n+    pat = gen_store_multiple_bug (operands[0], operands[1], operands[2]);\n+\n+  if (pat)\n+    emit_insn (pat);\n+  else\n+    FAIL;\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"store_multiple_no_bug\"\n+  [(set (reg:SI 179)\n+\t(match_dup 2))\n+   (match_parallel 3 \"\" [(set (match_operand:SI 0 \"\" \"\")\n+\t\t\t      (match_operand:SI 1 \"\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  int regno;\n+  int count;\n+  rtx from;\n+  int i;\n+\n+  /* Support only storing a constant number of hard registers to memory.  */\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || operands[2] == const1_rtx\n+      || GET_CODE (operands[0]) != MEM\n+      || GET_CODE (operands[1]) != REG\n+      || REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  regno = REGNO (operands[1]);\n+\n+  /* CR gets set to the number of registers minus one.  */\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, count - 1);\n+\n+  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n+  from = memory_address (SImode, XEXP (operands[0], 0));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t gen_rtx (MEM, SImode, from),\n+\t\t\t\t\t gen_rtx (REG, SImode, regno));\n+  XVECEXP (operands[3], 0, 1)\n+    = gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+  XVECEXP (operands[3], 0, 2)\n+    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+\n+  for (i = 1; i < count; i++)\n+    XVECEXP (operands[3], 0, i + 2)\n+      = gen_rtx (SET, VOIDmode,\n+\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)),\n+\t\t gen_rtx (REG, SImode, regno + i));\n+}\")\n+\n+(define_expand \"store_multiple_bug\"\n+  [(match_parallel 3 \"\" [(set (match_operand:SI 0 \"\" \"\")\n+\t\t\t      (match_operand:SI 1 \"\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  int regno;\n+  int count;\n+  rtx from;\n+  int i;\n+\n+  /* Support only storing a constant number of hard registers to memory.  */\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || operands[2] == const1_rtx\n+      || GET_CODE (operands[0]) != MEM\n+      || GET_CODE (operands[1]) != REG\n+      || REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  regno = REGNO (operands[1]);\n+\n+  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 1));\n+  from = memory_address (SImode, XEXP (operands[0], 0));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t gen_rtx (MEM, SImode, from),\n+\t\t\t\t\t gen_rtx (REG, SImode, regno));\n+  XVECEXP (operands[3], 0, 1)\n+    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+\n+  for (i = 1; i < count; i++)\n+    XVECEXP (operands[3], 0, i + 1)\n+      = gen_rtx (SET, VOIDmode,\n+\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)),\n+\t\t gen_rtx (REG, SImode, regno + i));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"memory_operand\" \"=m\")\n+\t(match_operand 1 \"gen_reg_operand\" \"r\"))\n+   (clobber (reg:SI 179))]\n+  \"!TARGET_NO_STOREM_BUG\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n+  \"mtsrim cr,%S1\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+\t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:SI 2 \"gen_reg_operand\" \"r\"))\n+\t\t    (clobber (reg:SI 179))])]\n+  \"!TARGET_NO_STOREM_BUG\"\n+  \"mtsrim cr,%V0\\;storem 0,0,%2,%1\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"memory_operand\" \"=m\")\n+\t(match_operand 1 \"gen_reg_operand\" \"r\"))\n+   (use (reg:SI 179))\n+   (clobber (reg:SI 179))]\n+  \"TARGET_NO_STOREM_BUG\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n+  \"storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+\t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:SI 2 \"gen_reg_operand\" \"r\"))\n+\t\t    (use (reg:SI 179))\n+\t\t    (clobber (reg:SI 179))])]\n+  \"TARGET_NO_STOREM_BUG\"\n+  \"storem 0,0,%2,%1\"\n+  [(set_attr \"type\" \"store\")])\n+\f\n+;; SUB\n+;;\n+;; Either operand can be a register or an 8-bit constant, but both cannot be\n+;; constants (can't usually occur anyway).\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"srcb_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"srcb_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT\n+      && GET_CODE (operands[1]) == CONST_INT)\n+    operands[1] = force_reg (SImode, operands[1]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"srcb_operand\" \"r,I\")\n+\t\t  (match_operand:SI 2 \"srcb_operand\" \"rI,r\")))]\n+  \"register_operand (operands[1], SImode)\n+   || register_operand (operands[2], SImode)\"\n+  \"@\n+   sub %0,%1,%2\n+   subr %0,%2,%1\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"gen_reg_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"sub %L0,%L1,%L2\\;subc %0,%1,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; SUBR (also used above in SUB)\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"subr %L0,%L1,0\\;subrc %0,%1,0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"subr %0,%1,0\")\n+\f\n+;; XNOR\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\")\n+\t\t\t(match_operand:SI 2 \"srcb_operand\" \"rI\"))))]\n+  \"\"\n+  \"xnor %0,%1,%2\")\n+\n+;; XOR\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"gen_reg_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"srcb_operand\" \"rI\")))]\n+  \"\"\n+  \"xor %0,%1,%2\")\n+\n+;; Can use XOR to negate floating-point values, but we are better off not doing\n+;; it that way on the 29050 so it can combine with the fmac insns.\n+(define_expand \"negsf2\"\n+  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t   (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:SI 2 \"\"))])]\n+  \"\"\n+  \"\n+{\n+  rtx result;\n+  rtx target;\n+\n+  if (! TARGET_29050)\n+    {\n+      target = operand_subword_force (operands[0], 0, SFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n+\t\t\t     target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      /* Make a place for REG_EQUAL.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"negdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t   (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:SI 2 \"\"))])]\n+  \"\"\n+  \"\n+{\n+  rtx result;\n+  rtx target;\n+  rtx insns;\n+\n+  if (! TARGET_29050)\n+    {\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, DFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n+\t\t\t     target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 1, DFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n+\f\n+;; Sign extend and truncation operations.\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"gen_reg_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"and %0,%1,255\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"gen_reg_operand\" \"r\")))]\n+  \"\"\n+  \"and %0,%1,255\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"gen_reg_operand\" \"0\")))]\n+  \"\"\n+  \"consth %0,0\")\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_operand:QI 1 \"gen_reg_operand\" \"\")\n+\t\t   (const_int 24)))\n+   (set (match_operand:HI 0 \"gen_reg_operand\" \"\")\n+\t(ashiftrt:SI (match_dup 2)\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"\n+{ operands[0] = gen_lowpart (SImode, operands[0]);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_operand:QI 1 \"gen_reg_operand\" \"\")\n+\t\t   (const_int 24)))\n+   (set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ashiftrt:SI (match_dup 2)\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_operand:HI 1 \"gen_reg_operand\" \"\")\n+\t\t   (const_int 16)))\n+   (set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ashiftrt:SI (match_dup 2)\n+\t\t     (const_int 16)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode); }\")\n+\f\n+;; Define the methods used to move data around.\n+;;\n+;; movsi:\n+;;\n+;; If storing into memory, force source into register.\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && ! gen_reg_operand (operands[1], SImode))\n+    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+  else if (spec_reg_operand (operands[0], SImode)\n+\t   && ! (register_operand (operands[1], SImode)\n+\t\t || cint_16_operand (operands[1], SImode)))\n+    operands[1] = force_reg (SImode, operands[1]);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(match_operand:SI 1 \"long_const_operand\" \"\"))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 1)\n+\t\t(const_int 65535)))\n+   (set (match_dup 0)\n+\t(ior:SI (and:SI (match_dup 0)\n+\t\t\t(const_int 65535))\n+\t\t(and:SI (match_dup 1)\n+\t\t\t(const_int -65536))))]\n+  \"\")\n+\f\n+;; Subroutines to load/store halfwords.  Use TAV (gr121) as scratch.  We have\n+;; two versions of storehi, one when halfword writes are supported and one\n+;; where they aren't.\n+(define_expand \"loadhi\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t\t\t   (const_int -4))))\n+\t      (set (reg:SI 177)\n+\t\t   (and:SI (match_dup 0)\n+\t\t\t   (const_int 2)))])\n+   (set (match_operand:HI 1 \"gen_reg_operand\" \"\")\n+\t(zero_extract:SI (match_dup 2)\n+\t\t\t (const_int 16)\n+\t\t\t (ashift:SI (reg:SI 177)\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"storehinhww\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t\t\t   (const_int -4))))\n+\t      (set (reg:SI 177)\n+\t\t   (and:SI (match_dup 0)\n+\t\t\t     (const_int 2)))])\n+   (set (zero_extract:SI (match_dup 2)\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (reg:SI 177)\n+\t\t\t\t    (const_int 3)))\n+\t(match_operand:HI 1 \"gen_reg_operand\" \"\"))\n+   (set (mem:SI (match_dup 0))\n+\t(match_dup 2))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"storehihww\"\n+  [(set (reg:SI 177)\n+\t(and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t(const_int 3)))\n+   (set (match_dup 2)\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n+\t\t\t\t\t   (ashift:SI (reg:SI 177)\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:HI 1 \"gen_reg_operand\" \"\"))\n+\t\t(ashift:SI (and:SI (match_dup 1)\n+\t\t\t\t   (const_int 65535))\n+\t\t\t   (ashift:SI (reg:SI 177)\n+\t\t\t\t      (const_int 3)))))\n+   (set (mem:SI (and:SI (match_dup 0)\n+\t\t\t(const_int -3)))\n+\t(match_dup 2))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[0]) == MEM) \n+    {\n+      if (! gen_reg_operand (operands[1], HImode))\n+\toperands[1] = copy_to_mode_reg (HImode, operands[1]);\n+      if (! TARGET_DW_ENABLE)\n+\t{\n+\t  if (TARGET_BYTE_WRITES)\n+\t    emit_insn (gen_storehihww (XEXP (operands[0], 0), operands[1]));\n+\t  else\n+\t    emit_insn (gen_storehinhww (XEXP (operands[0], 0), operands[1]));\n+\t  DONE;\n+\t}\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (! TARGET_DW_ENABLE)\n+\t{\n+\t  emit_insn (gen_loadhi (XEXP (operands[1], 0), operands[0]));\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\f\n+;; Subroutines to load/store bytes.  Use TAV (gr121) as scratch.\n+(define_expand \"loadqi\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t\t\t   (const_int -4))))\n+\t      (set (reg:SI 177)\n+\t\t   (and:SI (match_dup 0)\n+\t\t\t   (const_int 3)))])\n+   (set (match_operand:QI 1 \"gen_reg_operand\" \"\")\n+\t(zero_extract:SI (match_dup 2)\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (reg:SI 177)\n+\t\t\t\t    (const_int 3))))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"storeqinhww\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t\t\t   (const_int -4))))\n+\t      (set (reg:SI 177)\n+\t\t   (and:SI (match_dup 0)\n+\t\t\t   (const_int 3)))])\n+   (set (zero_extract:SI (match_dup 2)\n+\t\t\t (const_int 8)\n+\t\t\t (ashift:SI (reg:SI 177)\n+\t\t\t\t    (const_int 3)))\n+\t(match_operand:QI 1 \"gen_reg_operand\" \"\"))\n+   (set (mem:SI (match_dup 0))\n+\t(match_dup 2))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_expand \"storeqihww\"\n+  [(set (reg:SI 177)\n+\t(and:SI (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t(const_int 3)))\n+   (set (match_dup 2)\n+\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n+\t\t\t\t\t   (ashift:SI (reg:SI 177)\n+\t\t\t\t\t\t      (const_int 3))))\n+\t\t\t(match_operand:HI 1 \"gen_reg_operand\" \"\"))\n+\t\t(ashift:SI (and:SI (match_dup 1)\n+\t\t\t\t   (const_int 255))\n+\t\t\t   (ashift:SI (reg:SI 177)\n+\t\t\t\t      (const_int 3)))))\n+   (set (mem:SI (and:SI (match_dup 0)\n+\t\t        (const_int -4)))\n+\t(match_dup 2))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  if (reload_in_progress)\n+    operands[2] = gen_rtx (REG, SImode, R_TAV);\n+  else\n+    operands[2] = gen_reg_rtx (SImode);\n+}\")\n+\f\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (! gen_reg_operand (operands[1], QImode))\n+\toperands[1] = copy_to_mode_reg (QImode, operands[1]);\n+      if (! TARGET_DW_ENABLE)\n+\t{\n+\t  if (TARGET_BYTE_WRITES)\n+\t    emit_insn (gen_storeqihww (XEXP (operands[0], 0), operands[1]));\n+\t  else\n+\t    emit_insn (gen_storeqinhww (XEXP (operands[0], 0), operands[1]));\n+\t  DONE;\n+\t}\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (! TARGET_DW_ENABLE)\n+\t{\n+\t  emit_insn (gen_loadqi (XEXP (operands[1], 0), operands[0]));\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\f\n+;; Now the actual insns used to move data around.  We include here the\n+;; DEFINE_SPLITs that may be needed.  In some cases these will be\n+;; split again.  For floating-point, if we can look inside the constant,\n+;; always split it.  This can eliminate unnecessary insns.\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"out_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:SF 1 \"in_operand\" \"r,E,F,m,r\"))]\n+  \"(gen_reg_operand (operands[0], SFmode)\n+    || gen_reg_operand (operands[1], SFmode))\n+   && ! TARGET_29050\"\n+  \"@\n+   sll %0,%1,0\n+   #\n+   const %0,%1\\;consth %0,%1\n+   load 0,0,%0,%1\n+   store 0,0,%1,%0\"\n+  [(set_attr \"type\" \"misc,multi,multi,load,store\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"out_operand\" \"=r,r,r,r,m,*a,r\")\n+\t(match_operand:SF 1 \"in_operand\" \"r,E,F,m,r,r,*a\"))]\n+  \"(gen_reg_operand (operands[0], SFmode)\n+    || gen_reg_operand (operands[1], SFmode))\n+   && TARGET_29050\"\n+  \"@\n+   sll %0,%1,0\n+   #\n+   const %0,%1\\;consth %0,%1\n+   load 0,0,%0,%1\n+   store 0,0,%1,%0\n+   mtacc %1,1,%0\n+   mfacc %0,1,%1\"\n+  [(set_attr \"type\" \"misc,multi,multi,load,store,fadd,fadd\")])\n+\n+;; Turn this into SImode.  It will then be split up that way.\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"float_const_operand\" \"\"))]\n+  \"HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"\n+{ operands[0] = operand_subword (operands[0], 0, 0, SFmode);\n+  operands[1] = operand_subword (operands[1], 0, 0, SFmode);\n+\n+  if (operands[0] == 0 || operands[1] == 0)\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"out_operand\" \"=r,r,r,m\")\n+\t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], DFmode)\n+    || gen_reg_operand (operands[1], DFmode))\n+   && ! TARGET_29050\"\n+  \"@\n+   #\n+   const %0,%1\\;consth %0,%1\\;const %L0,%L1\\;consth %L0,%L1\n+   mtsrim cr,1\\;loadm 0,0,%0,%1\n+   mtsrim cr,1\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"out_operand\" \"=r,r,&r,m,*a,r\")\n+\t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r,r,*a\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], DFmode)\n+    || gen_reg_operand (operands[1], DFmode))\n+   && TARGET_29050\"\n+  \"@\n+   #\n+   const %0,%1\\;consth %0,%1\\;const %L0,%L1\\;consth %L0,%L1\n+   mtsrim cr,1\\;loadm 0,0,%0,%1\n+   mtsrim cr,1\\;storem 0,0,%1,%0\n+   mtacc %1,2,%0\n+   mfacc %0,2,%1\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi,fadd,fadd\")])\n+\n+;; Split register-register copies and constant loads into two SImode loads,\n+;; one for each word.  In the constant case, they will get further split.\n+;; Don't so this until register allocation, though, since it will\n+;; interfere with register allocation.  Normally copy the lowest-addressed\n+;; word first; the exception is if we are copying register to register and\n+;; the lowest register of the first operand is the highest register of the\n+;; second operand.\n+(define_split\n+  [(set (match_operand:DF 0 \"gen_reg_operand\" \"\")\n+\t(match_operand:DF 1 \"gen_reg_or_float_constant_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[1]) == REG\n+      && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[3] = operand_subword (operands[1], 1, 1, DFmode);\n+      operands[4] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[5] = operand_subword (operands[1], 0, 1, DFmode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[3] = operand_subword (operands[1], 0, 1, DFmode);\n+      operands[4] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[5] = operand_subword (operands[1], 1, 1, DFmode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n+\n+;; Split memory loads and stores into the MTSR and LOADM/STOREM.\n+(define_split\n+  [(set (match_operand:DF 0 \"out_operand\" \"\")\n+\t(match_operand:DF 1 \"in_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"TARGET_NO_STOREM_BUG\n+   && (memory_operand (operands[0], DFmode)\n+       || memory_operand (operands[1], DFmode))\"\n+  [(set (reg:SI 179) (const_int 1))\n+   (parallel [(set (match_dup 0) (match_dup 1))\n+\t      (use (reg:SI 179))\n+\t      (clobber (reg:SI 179))])]\n+  \"\")\n+\n+;; DI move is similar to DF move.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"out_operand\" \"=r,r,m\")\n+\t(match_operand:DI 1 \"in_operand\" \"rn,m,r\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], DImode)\n+     || gen_reg_operand (operands[1], DImode))\n+   && ! TARGET_29050\"\n+  \"@\n+   #\n+   mtsrim cr,1\\;loadm 0,0,%0,%1\n+   mtsrim cr,1\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"out_operand\" \"=r,&r,m\")\n+\t(match_operand:DI 1 \"in_operand\" \"rn,m,r\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], DImode)\n+     || gen_reg_operand (operands[1], DImode))\n+   && TARGET_29050\"\n+  \"@\n+   #\n+   mtsrim cr,1\\;loadm 0,0,%0,%1\n+   mtsrim cr,1\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"gen_reg_or_integer_constant_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[1]) == REG\n+      && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[3] = operand_subword (operands[1], 1, 1, DFmode);\n+      operands[4] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[5] = operand_subword (operands[1], 0, 1, DFmode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[3] = operand_subword (operands[1], 0, 1, DFmode);\n+      operands[4] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[5] = operand_subword (operands[1], 1, 1, DFmode);\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"out_operand\" \"\")\n+\t(match_operand:DI 1 \"in_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"TARGET_NO_STOREM_BUG\n+   && (memory_operand (operands[0], DImode)\n+       || memory_operand (operands[1], DImode))\"\n+  [(set (reg:SI 179) (const_int 1))\n+   (parallel [(set (match_dup 0) (match_dup 1))\n+\t      (use (reg:SI 179))\n+\t      (clobber (reg:SI 179))])]\n+  \"\")\n+\n+;; TImode moves are very similar to DImode moves, except that we can't\n+;; have constants.\n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"out_operand\" \"=r,r,m\")\n+\t(match_operand:TI 1 \"in_operand\" \"r,m,r\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], TImode)\n+    || gen_reg_operand (operands[1], TImode))\n+   && ! TARGET_29050\"\n+  \"@\n+   #\n+   mtsrim cr,3\\;loadm 0,0,%0,%1\n+   mtsrim cr,3\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi,multi,multi\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"out_operand\" \"=r,&r,m\")\n+\t(match_operand:TI 1 \"in_operand\" \"r,m,r\"))\n+   (clobber (reg:SI 179))]\n+  \"(gen_reg_operand (operands[0], TImode)\n+    || gen_reg_operand (operands[1], TImode))\n+   && TARGET_29050\"\n+  \"@\n+   #\n+   mtsrim cr,3\\;loadm 0,0,%0,%1\n+   mtsrim cr,3\\;storem 0,0,%1,%0\"\n+  [(set_attr \"type\" \"multi,multi,multi\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"gen_reg_operand\" \"\")\n+\t(match_operand:TI 1 \"gen_reg_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 6) (match_dup 7))\n+   (set (match_dup 8) (match_dup 9))]\n+  \"\n+{\n+  if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n+      && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n+    {\n+      operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n+      operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3);\n+      operands[4] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+      operands[5] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+      operands[6] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      operands[7] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      operands[8] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+      operands[9] = gen_rtx (REG, SImode, REGNO (operands[1]));\n+    }\n+  else\n+    {\n+      operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+      operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]));\n+      operands[4] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      operands[5] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      operands[6] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+      operands[7] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+      operands[8] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n+      operands[9] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3); \n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"out_operand\" \"\")\n+\t(match_operand:TI 1 \"in_operand\" \"\"))\n+   (clobber (reg:SI 179))]\n+  \"TARGET_NO_STOREM_BUG\n+   && (memory_operand (operands[0], TImode)\n+       || memory_operand (operands[1], TImode))\"\n+  [(set (reg:SI 179) (const_int 1))\n+   (parallel [(set (match_dup 0) (match_dup 1))\n+\t      (use (reg:SI 179))\n+\t      (clobber (reg:SI 179))])]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"out_operand\" \"=r,r,r,r,r,r,r,m,*h,*h\")\n+        (match_operand:SI 1 \"in_operand\" \"r,J,M,O,i,m,*h,r,r,J\"))]\n+  \"(gen_reg_operand (operands[0], SImode)\n+    || gen_reg_operand (operands[1], SImode)\n+    || (spec_reg_operand (operands[0], SImode)\n+        && cint_16_operand (operands[1], SImode)))\n+   && ! TARGET_29050\"\n+  \"@\n+   sll %0,%1,0\n+   const %0,%1\n+   constn %0,%M1\n+   cpeq %0,gr1,gr1\n+   #\n+   load 0,0,%0,%1\n+   mfsr %0,%1\n+   store 0,0,%1,%0\n+   mtsr %0,%1\n+   mtsrim %0,%1\"\n+  [(set_attr \"type\" \"misc,misc,misc,misc,multi,load,misc,store,misc,misc\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"out_operand\" \"=r,r,r,r,r,r,r,m,*h,*h\")\n+        (match_operand:SI 1 \"in_operand\" \"r,J,M,O,i,m,*h,r,r,J\"))]\n+  \"(gen_reg_operand (operands[0], SImode)\n+    || gen_reg_operand (operands[1], SImode)\n+    || (spec_reg_operand (operands[0], SImode)\n+        && cint_16_operand (operands[1], SImode)))\n+   && TARGET_29050\"\n+  \"@\n+   sll %0,%1,0\n+   const %0,%1\n+   constn %0,%M1\n+   consthz %0,%1\n+   #\n+   load 0,0,%0,%1\n+   mfsr %0,%1\n+   store 0,0,%1,%0\n+   mtsr %0,%1\n+   mtsrim %0,%1\"\n+  [(set_attr \"type\" \"misc,misc,misc,misc,multi,load,misc,store,misc,misc\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n+        (match_operand:HI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n+  \"gen_reg_operand (operands[0], HImode)\n+   || gen_reg_operand (operands[1], HImode)\"\n+  \"@\n+   sll %0,%1,0\n+   const %0,%1\n+   load 0,2,%0,%1\n+   store 0,2,%1,%0\n+   mfsr %0,%1\n+   mtsr %0,%1\n+   mtsrim %0,%1\"\n+  [(set_attr \"type\" \"misc,misc,load,store,misc,misc,misc\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n+        (match_operand:QI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n+  \"gen_reg_operand (operands[0], QImode)\n+   || gen_reg_operand (operands[1], QImode)\"\n+  \"@\n+   sll %0,%1,0\n+   const %0,%1\n+   load 0,1,%0,%1\n+   store 0,1,%1,%0\n+   mfsr %0,%1\n+   mtsr %0,%1\n+   mtsrim %0,%1\"\n+  [(set_attr \"type\" \"misc,misc,load,store,misc,misc,misc\")])\n+\f\n+;; Define move insns for DI, TI, SF, and DF.\n+;;\n+;; In no case do we support mem->mem directly.\n+;;\n+;; For DI move of constant to register, split apart at this time since these\n+;; can require anywhere from 2 to 4 insns and determining which is complex.\n+;;\n+;; In other cases, handle similarly to SImode moves.\n+;;\n+;; However, indicate that DI, TI, and DF moves (can) clobber CR (reg 179).\n+(define_expand \"movdi\"\n+  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t\t   (match_operand:DI 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 179))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DImode, operands[1]);\n+}\")\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (SFmode, operands[1]);\n+}\")\n+\n+(define_expand \"movdf\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (match_operand:DF 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 179))])]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DFmode, operands[1]);\n+}\")\n+\n+(define_expand \"movti\"\n+  [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n+\t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 179))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (TImode, operands[1]);\n+}\")\n+\f\n+;; For compare operations, we simply store the comparison operands and\n+;; do nothing else.  The following branch or scc insn will output whatever\n+;; is needed.\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t\t (match_operand:SI 1 \"srcb_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  a29k_compare_op0 = operands[0];\n+  a29k_compare_op1 = operands[1];\n+  a29k_compare_fp_p = 0;\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"gen_reg_operand\" \"\")\n+\t\t (match_operand:SF 1 \"gen_reg_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  a29k_compare_op0 = operands[0];\n+  a29k_compare_op1 = operands[1];\n+  a29k_compare_fp_p = 1;\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"gen_reg_operand\" \"\")\n+\t\t (match_operand:DF 1 \"gen_reg_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  a29k_compare_op0 = operands[0];\n+  a29k_compare_op1 = operands[1];\n+  a29k_compare_fp_p = 1;\n+  DONE;\n+}\")\n+\n+;; We can generate bit-tests better if we use NE instead of EQ, but we\n+;; don't have an NE for floating-point.  So we have to have two patterns\n+;; for EQ and two for NE.\n+\n+(define_expand \"beq\"\n+  [(set (match_dup 1) (ne:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (a29k_compare_op0)) == MODE_FLOAT)\n+    {\n+      emit_insn (gen_beq_fp (operands[0]));\n+      DONE;\n+    }\n+\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"beq_fp\"\n+  [(set (match_dup 1) (eq:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (match_dup 1) (ne:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (a29k_compare_op0)) == MODE_FLOAT)\n+    {\n+      emit_insn (gen_bne_fp (operands[0]));\n+      DONE;\n+    }\n+\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bne_fp\"\n+  [(set (match_dup 1) (eq:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+;; We don't have a floating-point \"lt\" insn, so we have to use \"gt\" in that\n+;; case with the operands swapped.  The operands must both be registers in\n+;; the floating-point case, so we know that swapping them is OK.\n+(define_expand \"blt\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  if (a29k_compare_fp_p)\n+    operands[2] = gen_rtx (GT, SImode, a29k_compare_op1, a29k_compare_op0);\n+  else\n+    operands[2] = gen_rtx (LT, SImode, a29k_compare_op0, a29k_compare_op1);\n+}\")\n+\n+;; Similarly for \"le\".\n+(define_expand \"ble\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  if (a29k_compare_fp_p)\n+    operands[2] = gen_rtx (GE, SImode, a29k_compare_op1, a29k_compare_op0);\n+  else\n+    operands[2] = gen_rtx (LE, SImode, a29k_compare_op0, a29k_compare_op1);\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (match_dup 1) (ltu:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (match_dup 1) (leu:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (match_dup 1) (gt:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (match_dup 1) (ge:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (match_dup 1) (gtu:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (match_dup 1) (geu:SI (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = a29k_compare_op0;\n+  operands[3] = a29k_compare_op1;\n+}\")\n+\f\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(eq:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\t\t \n+;; This is the most complicated case, because we don't have a floating-point\n+;; \"ne\" insn.  If integer, handle normally.  If floating-point, write the\n+;; compare and then write an insn to reverse the test.\n+(define_expand \"sne_fp\"\n+  [(set (match_dup 3)\n+\t(eq:SI (match_operand 1 \"gen_reg_operand\" \"\")\n+\t       (match_operand 2 \"gen_reg_operand\" \"\")))\n+   (set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ge:SI (match_dup 3) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[3] = gen_reg_rtx (SImode);\n+}\");\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ne:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+\n+  if (a29k_compare_fp_p)\n+    {\n+      emit_insn (gen_sne_fp (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\t\t \n+;; We don't have a floating-point \"lt\" insn, so use \"gt\" and swap the\n+;; operands, the same as we do \"blt\".\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  if (a29k_compare_fp_p)\n+    operands[1] = gen_rtx (GT, SImode, a29k_compare_op1, a29k_compare_op0);\n+  else\n+    operands[1] = gen_rtx (LT, SImode, a29k_compare_op0, a29k_compare_op1);\n+}\")\n+\n+;; Similarly for \"le\"\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  if (a29k_compare_fp_p)\n+    operands[1] = gen_rtx (GE, SImode, a29k_compare_op1, a29k_compare_op0);\n+  else\n+    operands[1] = gen_rtx (LE, SImode, a29k_compare_op0, a29k_compare_op1);\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ltu:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(leu:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(gt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(ge:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\t\t \n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(gtu:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"\")\n+\t(geu:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = a29k_compare_op0;\n+  operands[2] = a29k_compare_op1;\n+}\")\n+\f\n+;; Now define the actual jump insns.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"branch_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jmp%b0 %1,%l2%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"branch_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (return)\n+\t\t      (pc)))]\n+  \"null_epilogue ()\"\n+  \"jmp%b0i %1,lr0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"branch_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"jmp%B0 %1,%l2%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"branch_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"gen_reg_operand\" \"r\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (pc)\n+\t\t      (return)))]\n+  \"null_epilogue ()\"\n+  \"jmp%B0i %1,lr0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %e0%E0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"null_epilogue ()\"\n+  \"jmpi lr0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"gen_reg_operand\" \"r\"))]\n+  \"\"\n+  \"jmpi %0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"gen_reg_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmpi %0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; JMPFDEC\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_operand:SI 0 \"gen_reg_operand\" \"r\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"jmpfdec %0,%l1%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}, {"sha": "9c61f1451daac0975b33b8aa3c993caf963acdc8", "filename": "gcc/config/a29k/unix.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fa29k%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fa29k%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Funix.h?ref=ab835497c9a339a644a752a4b0a061d1370a00f1", "patch": "@@ -0,0 +1,44 @@\n+/* Definitions of target machine for GNU compiler, for AMD Am29000 CPU, Unix.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This is mostly the same as a29k.h, except that we define unix instead of\n+   EPI and define unix-style machine names.  */\n+\n+#include \"a29k.h\"\n+\n+/* Set our default target to be the 29050; that is the more interesting chip\n+   for Unix systems.  */\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (1+2+8+64)\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dam29k -Da29k -Dam29000\"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{!m29000:-Dam29050 -D__am29050__}\"\n+\n+/* For some systems, it is best if double-word objects are aligned on a \n+   doubleword boundary.  We want to maintain compatibility with MetaWare in\n+   a29k.h, but do not feel constrained to do so here.  */\n+\n+#undef BIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 64"}, {"sha": "d5b3ba9efd30fbe5253b3c65153f50a05d98e82d", "filename": "gcc/config/sparc/sparc.c", "status": "added", "additions": 2563, "deletions": 0, "changes": 2563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ab835497c9a339a644a752a4b0a061d1370a00f1", "patch": "@@ -0,0 +1,2563 @@\n+/* Subroutines for insn-output.c for Sun SPARC.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+\n+/* Global variables for machine-dependent things.  */\n+\n+/* Save the operands last given to a compare for use when we\n+   generate a scc or bcc insn.  */\n+\n+rtx sparc_compare_op0, sparc_compare_op1;\n+\n+/* We may need an epilogue if we spill too many registers.\n+   If this is non-zero, then we branch here for the epilogue.  */\n+static rtx leaf_label;\n+\n+#ifdef LEAF_REGISTERS\n+\n+/* Vector to say how input registers are mapped to output\n+   registers.  FRAME_POINTER_REGNUM cannot be remapped by\n+   this function to eliminate it.  You must use -fomit-frame-pointer\n+   to get that.  */\n+char leaf_reg_remap[] =\n+{ 0, 1, 2, 3, 4, 5, 6, 7,\n+  -1, -1, -1, -1, -1, -1, 14, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,\n+  8, 9, 10, 11, 12, 13, -1, 15,\n+\n+  32, 33, 34, 35, 36, 37, 38, 39,\n+  40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55,\n+  56, 57, 58, 59, 60, 61, 62, 63};\n+\n+char leaf_reg_backmap[] =\n+{ 0, 1, 2, 3, 4, 5, 6, 7,\n+  24, 25, 26, 27, 28, 29, 14, 31,\n+  -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,\n+\n+  32, 33, 34, 35, 36, 37, 38, 39,\n+  40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55,\n+  56, 57, 58, 59, 60, 61, 62, 63};\n+#endif\n+\n+/* Global variables set by FUNCTION_PROLOGUE.  */\n+/* Size of frame.  Need to know this to emit return insns from\n+   leaf procedures.  */\n+int apparent_fsize;\n+int actual_fsize;\n+\n+/* Name of where we pretend to think the frame pointer points.\n+   Normally, this is \"%fp\", but if we are in a leaf procedure,\n+   this is \"%sp+something\".  */\n+char *frame_base_name;\n+\n+static rtx find_addr_reg ();\n+\n+/* Return non-zero only if OP is a register of mode MODE,\n+   or const0_rtx.  */\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (op == const0_rtx || register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == CONST_DOUBLE\n+      && CONST_DOUBLE_HIGH (op) == 0\n+      && CONST_DOUBLE_LOW (op) == 0)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Nonzero if OP can appear as the dest of a RESTORE insn.  */\n+int\n+restore_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == REG && GET_MODE (op) == mode\n+\t  && (REGNO (op) < 8 || (REGNO (op) >= 24 && REGNO (op) < 32)));\n+}\n+\n+/* PC-relative call insn on SPARC is independent of `memory_operand'.  */\n+\n+int\n+call_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    abort ();\n+  op = XEXP (op, 0);\n+  return (REG_P (op) || CONSTANT_P (op));\n+}\n+\n+int\n+call_operand_address (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (REG_P (op) || CONSTANT_P (op));\n+}\n+\n+/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\n+      /* This clause seems to be irrelevant.  */\n+    case CONST_DOUBLE:\n+      return GET_MODE (op) == mode;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return truth value of statement that OP is a symbolic memory\n+   operand of mode MODE.  */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n+}\n+\n+/* Return 1 if the operand is either a register or a memory operand that is\n+   not symbolic.  */\n+\n+int\n+reg_or_nonsymb_mem_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+sparc_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == CONST_INT)\n+    return SMALL_INT (op);\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == LO_SUM)\n+    return (GET_CODE (XEXP (op, 0)) == REG\n+\t    && symbolic_operand (XEXP (op, 1), Pmode));\n+  return memory_address_p (mode, op);\n+}\n+\n+int\n+move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == DImode && arith_double_operand (op, mode))\n+    return 1;\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == CONST_INT)\n+    return (SMALL_INT (op) || (INTVAL (op) & 0x3ff) == 0);\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == LO_SUM)\n+    return (register_operand (XEXP (op, 0), Pmode)\n+\t    && CONSTANT_P (XEXP (op, 1)));\n+  return memory_address_p (mode, op);\n+}\n+\n+int\n+move_pic_label (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Special case for PIC.  */\n+  if (flag_pic && GET_CODE (op) == LABEL_REF)\n+    return 1;\n+  return 0;\n+}\n+\f\n+/* The rtx for the global offset table which is a special form\n+   that *is* a position independent symbolic constant.  */\n+rtx pic_pc_rtx;\n+\n+/* Ensure that we are not using patterns that are not OK with PIC.  */\n+\n+int\n+check_pic (i)\n+     int i;\n+{\n+  switch (flag_pic)\n+    {\n+    case 1:\n+      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n+\t  || (GET_CODE (recog_operand[i]) == CONST\n+\t      && ! rtx_equal_p (pic_pc_rtx, recog_operand[i])))\n+\tabort ();\n+    case 2:\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Return true if X is an address which needs a temporary register when \n+   reloaded while generating PIC code.  */\n+\n+int\n+pic_address_needs_scratch (x)\n+     rtx x;\n+{\n+  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+memop (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == MEM)\n+    return (mode == VOIDmode || mode == GET_MODE (op));\n+  return 0;\n+}\n+\n+/* Return truth value of whether OP is EQ or NE.  */\n+\n+int\n+eq_or_neq (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n+\n+/* Return 1 if this is a comparison operator, but not an EQ, NE, GEU,\n+   or LTU for non-floating-point.  We handle those specially.  */\n+\n+int\n+normal_comp_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CCFPmode)\n+    return 1;\n+\n+  return (code != NE && code != EQ && code != GEU && code != LTU);\n+}\n+\n+/* Return 1 if this is a comparison operator.  This allows the use of\n+   MATCH_OPERATOR to recognize all the branch insns.  */\n+\n+int\n+noov_compare_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode)\n+    /* These are the only branches which work with CC_NOOVmode.  */\n+    return (code == EQ || code == NE || code == GE || code == LT);\n+  return 1;\n+}\n+\n+/* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */\n+\n+int\n+extend_op (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n+}\n+\n+/* Return nonzero if OP is an operator of mode MODE which can set\n+   the condition codes explicitly.  We do not include PLUS and MINUS\n+   because these require CC_NOOVmode, which we handle explicitly.  */\n+\n+int\n+cc_arithop (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == AND\n+      || GET_CODE (op) == IOR\n+      || GET_CODE (op) == XOR)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if OP is an operator of mode MODE which can bitwise\n+   complement its second operand and set the condition codes explicitly.  */\n+\n+int\n+cc_arithopn (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* XOR is not here because combine canonicalizes (xor (not ...) ...)\n+     and (xor ... (not ...)) to (not (xor ...)).   */\n+  return (GET_CODE (op) == AND\n+\t  || GET_CODE (op) == IOR);\n+}\n+\f\n+/* Return truth value of whether OP can be used as an operands in a three\n+   address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n+}\n+\n+/* Return truth value of whether OP can be used as an operand in a two\n+   address arithmetic insn (such as set 123456,%o4) of mode MODE.  */\n+\n+int\n+arith32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || GET_CODE (op) == CONST_INT);\n+}\n+\n+/* Return truth value of whether OP is a register or a CONST_DOUBLE.  */\n+\n+int\n+arith_double_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n+\t      && ((CONST_DOUBLE_HIGH (op) == -1\n+\t\t   && (CONST_DOUBLE_LOW (op) & 0x1000) == 0x1000)\n+\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n+\t\t      && (CONST_DOUBLE_LOW (op) & 0x1000) == 0)))\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (INTVAL (op) + 0x1000) < 0x2000));\n+}\n+\n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in three-address insns.  */\n+\n+int\n+small_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n+}\n+\n+/* Return truth value of statement that OP is a call-clobbered register.  */\n+int\n+clobbered_register (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == REG && call_used_regs[REGNO (op)]);\n+}\n+\f\n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for register 0 in the proper mode.  */\n+\n+rtx\n+gen_compare_reg (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x);\n+  rtx cc_reg = gen_rtx (REG, mode, 0);\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+\t\t      gen_rtx (COMPARE, mode, x, y)));\n+\n+  return cc_reg;\n+}\n+\f\n+/* Return nonzero if a return peephole merging return with\n+   setting of output register is ok.  */\n+int\n+leaf_return_peephole_ok ()\n+{\n+  return (actual_fsize == 0);\n+}\n+\n+/* Return nonzero if TRIAL can go into the function epilogue's\n+   delay slot.  SLOT is the slot we are trying to fill.  */\n+\n+int\n+eligible_for_epilogue_delay (trial, slot)\n+     rtx trial;\n+     int slot;\n+{\n+  static char *this_function_name;\n+  rtx pat, src;\n+\n+  if (slot >= 1)\n+    return 0;\n+  if (GET_CODE (trial) != INSN\n+      || GET_CODE (PATTERN (trial)) != SET)\n+    return 0;\n+  if (get_attr_length (trial) != 1)\n+    return 0;\n+\n+  /* In the case of a true leaf function, anything can\n+     go into the delay slot.  */\n+  if (leaf_function)\n+    {\n+      if (leaf_return_peephole_ok ())\n+\treturn (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n+      return 0;\n+    }\n+\n+  /* Otherwise, only operations which can be done in tandem with\n+     a `restore' insn can go into the delay slot.  */\n+  pat = PATTERN (trial);\n+  if (GET_CODE (SET_DEST (pat)) != REG\n+      || REGNO (SET_DEST (pat)) == 0\n+      || (leaf_function\n+\t  && REGNO (SET_DEST (pat)) < 32\n+\t  && REGNO (SET_DEST (pat)) >= 16)\n+      || (! leaf_function\n+\t  && (REGNO (SET_DEST (pat)) >= 32\n+\t      || REGNO (SET_DEST (pat)) < 24)))\n+    return 0;\n+  src = SET_SRC (pat);\n+  if (arith_operand (src, GET_MODE (src)))\n+    return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n+  if (arith_double_operand (src, GET_MODE (src)))\n+    return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n+  if (GET_CODE (src) == PLUS)\n+    {\n+      if (register_operand (XEXP (src, 0), SImode)\n+\t  && arith_operand (XEXP (src, 1), SImode))\n+\treturn 1;\n+      if (register_operand (XEXP (src, 1), SImode)\n+\t  && arith_operand (XEXP (src, 0), SImode))\n+\treturn 1;\n+      if (register_operand (XEXP (src, 0), DImode)\n+\t  && arith_double_operand (XEXP (src, 1), DImode))\n+\treturn 1;\n+      if (register_operand (XEXP (src, 1), DImode)\n+\t  && arith_double_operand (XEXP (src, 0), DImode))\n+\treturn 1;\n+    }\n+  if (GET_CODE (src) == MINUS\n+      && register_operand (XEXP (src, 0), SImode)\n+      && small_int (XEXP (src, 1), VOIDmode))\n+    return 1;\n+  if (GET_CODE (src) == MINUS\n+      && register_operand (XEXP (src, 0), DImode)\n+      && !register_operand (XEXP (src, 1), DImode)\n+      && arith_double_operand (XEXP (src, 1), DImode))\n+    return 1;\n+  return 0;\n+}\n+\n+int\n+short_branch (uid1, uid2)\n+     int uid1, uid2;\n+{\n+  unsigned int delta = insn_addresses[uid1] - insn_addresses[uid2];\n+  if (delta + 1024 < 2048)\n+    return 1;\n+  /* warning (\"long branch, distance %d\", delta); */\n+  return 0;\n+}\n+\n+/* Return non-zero if REG is not used after INSN.\n+   We assume REG is a reload reg, and therefore does\n+   not live past labels or calls or jumps.  */\n+int\n+reg_unused_after (reg, insn)\n+     rtx reg;\n+     rtx insn;\n+{\n+  enum rtx_code code, prev_code = UNKNOWN;\n+\n+  while (insn = NEXT_INSN (insn))\n+    {\n+      if (prev_code == CALL_INSN && call_used_regs[REGNO (reg)])\n+\treturn 1;\n+\n+      code = GET_CODE (insn);\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\treturn 1;\n+\n+      if (GET_RTX_CLASS (code) == 'i')\n+\t{\n+\t  rtx set = single_set (insn);\n+\t  int in_src = set && reg_overlap_mentioned_p (reg, SET_SRC (set));\n+\t  if (set && in_src)\n+\t    return 0;\n+\t  if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t    return 1;\n+\t  if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\t    return 0;\n+\t}\n+      prev_code = code;\n+    }\n+  return 1;\n+}\n+\f\n+/* Legitimize PIC addresses.  If the address is already position-independent,\n+   we return ORIG.  Newly generated position-independent addresses go into a\n+   reg.  This is REG if non zero, otherwise we allocate register(s) as\n+   necessary.  If this is called during reload, and we need a second temp\n+   register, then we use SCRATCH, which is provided via the\n+   SECONDARY_INPUT_RELOAD_CLASS mechanism.  */\n+\n+rtx\n+legitimize_pic_address (orig, mode, reg, scratch)\n+     rtx orig;\n+     enum machine_mode mode;\n+     rtx reg, scratch;\n+{\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      rtx pic_ref, address;\n+      rtx insn;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      if (flag_pic == 2)\n+\t{\n+\t  /* If not during reload, allocate another temp reg here for loading\n+\t     in the address, so that these instructions can be optimized\n+\t     properly.  */\n+\t  rtx temp_reg = (reload_in_progress ? reg : gen_reg_rtx (Pmode));\n+\n+\t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n+\t\t\t      gen_rtx (HIGH, Pmode, orig)));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n+\t\t\t      gen_rtx (LO_SUM, Pmode, temp_reg, orig)));\n+\t  address = temp_reg;\n+\t}\n+      else\n+\taddress = orig;\n+\n+      pic_ref = gen_rtx (MEM, Pmode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  pic_offset_table_rtx, address));\n+      current_function_uses_pic_offset_table = 1;\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      insn = emit_move_insn (reg, pic_ref);\n+      /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+\t by loop.  */\n+      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+\t\t\t\t  REG_NOTES (insn));\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode,\n+\t\t\t\t\t reg, 0);\n+\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t\t base == reg ? 0 : reg, 0);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (GET_CODE (offset) == CONST_INT)\n+\t{\n+\t  if (SMALL_INT (offset))\n+\t    return plus_constant_for_output (base, INTVAL (offset));\n+\t  else if (! reload_in_progress)\n+\t    offset = force_reg (Pmode, offset);\n+\t  /* We can't create any new registers during reload, so use the\n+\t     SCRATCH reg provided by the reload_insi pattern.  */\n+\t  else if (scratch)\n+\t    {\n+\t      emit_move_insn (scratch, offset);\n+\t      offset = scratch;\n+\t    }\n+\t  else\n+\t    /* If we reach here, then the SECONDARY_INPUT_RELOAD_CLASS\n+\t       macro needs to be adjusted so that a scratch reg is provided\n+\t       for this address.  */\n+\t    abort ();\n+\t}\n+      return gen_rtx (PLUS, Pmode, base, offset);\n+    }\n+  else if (GET_CODE (orig) == LABEL_REF)\n+    current_function_uses_pic_offset_table = 1;\n+\n+  return orig;\n+}\n+\n+/* Set up PIC-specific rtl.  This should not cause any insns\n+   to be emitted.  */\n+\n+void\n+initialize_pic ()\n+{\n+}\n+\n+/* Emit special PIC prologues and epilogues.  */\n+\n+void\n+finalize_pic ()\n+{\n+  /* The table we use to reference PIC data.  */\n+  rtx global_offset_table;\n+  /* Labels to get the PC in the prologue of this function.  */\n+  rtx l1, l2;\n+  rtx seq;\n+  int orig_flag_pic = flag_pic;\n+\n+  if (current_function_uses_pic_offset_table == 0)\n+    return;\n+\n+  if (! flag_pic)\n+    abort ();\n+\n+  flag_pic = 0;\n+  l1 = gen_label_rtx ();\n+  l2 = gen_label_rtx ();\n+\n+  start_sequence ();\n+\n+  emit_label (l1);\n+  /* Note that we pun calls and jumps here!  */\n+  emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n+                         gen_rtvec (2,\n+                                    gen_rtx (SET, VOIDmode, pc_rtx, gen_rtx (LABEL_REF, VOIDmode, l2)),\n+                                    gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 15), gen_rtx (LABEL_REF, VOIDmode, l2)))));\n+  emit_label (l2);\n+\n+  /* Initialize every time through, since we can't easily\n+     know this to be permanent.  */\n+  global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"*__GLOBAL_OFFSET_TABLE_\");\n+  pic_pc_rtx = gen_rtx (CONST, Pmode,\n+\t\t\tgen_rtx (MINUS, Pmode,\n+\t\t\t\t global_offset_table,\n+\t\t\t\t gen_rtx (CONST, Pmode,\n+\t\t\t\t\t  gen_rtx (MINUS, Pmode,\n+\t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n+\t\t\t\t\t\t   pc_rtx))));\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t      gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (LO_SUM, Pmode,\n+\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (PLUS, Pmode,\n+\t\t\t       pic_offset_table_rtx, gen_rtx (REG, Pmode, 15))));\n+  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n+  LABEL_PRESERVE_P (l1) = 1;\n+  LABEL_PRESERVE_P (l2) = 1;\n+  flag_pic = orig_flag_pic;\n+\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_after (seq, get_insns ());\n+\n+  /* Need to emit this whether or not we obey regdecls,\n+     since setjmp/longjmp can cause life info to screw up.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+}\n+\f\n+/* For the SPARC, REG and REG+CONST is cost 0, REG+REG is cost 1,\n+   and addresses involving symbolic constants are cost 2.\n+\n+   We make REG+REG slightly more expensive because it might keep\n+   a register live for longer than we might like.\n+\n+   PIC addresses are very expensive.\n+\n+   It is no coincidence that this has the same structure\n+   as GO_IF_LEGITIMATE_ADDRESS.  */\n+int\n+sparc_address_cost (X)\n+     rtx X;\n+{\n+#if 0\n+  /* Handled before calling here.  */\n+  if (GET_CODE (X) == REG)\n+    { return 1; }\n+#endif\n+  if (GET_CODE (X) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (X, 0)) == REG\n+\t  && GET_CODE (XEXP (X, 1)) == REG)\n+\treturn 2;\n+      return 1;\n+    }\n+  else if (GET_CODE (X) == LO_SUM)\n+    return 1;\n+  else if (GET_CODE (X) == HIGH)\n+    return 2;\n+  return 4;\n+}\n+\f\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.\n+\n+   SCRATCH_REG if non zero can be used as a scratch register for the move\n+   operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */\n+\n+int\n+emit_move_sequence (operands, mode, scratch_reg)\n+     rtx *operands;\n+     enum machine_mode mode;\n+     rtx scratch_reg;\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+\n+  /* Handle most common case first: storing into a register.  */\n+  if (register_operand (operand0, mode))\n+    {\n+      if (register_operand (operand1, mode)\n+\t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n+\t  || (GET_CODE (operand1) == CONST_DOUBLE\n+\t      && arith_double_operand (operand1, DImode))\n+\t  || (GET_CODE (operand1) == HIGH && GET_MODE (operand1) != DImode)\n+\t  /* Only `general_operands' can come here, so MEM is ok.  */\n+\t  || GET_CODE (operand1) == MEM)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+    }\n+  else if (GET_CODE (operand0) == MEM)\n+    {\n+      if (register_operand (operand1, mode) || operand1 == const0_rtx)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+      if (! reload_in_progress)\n+\t{\n+\t  operands[0] = validize_mem (operand0);\n+\t  operands[1] = operand1 = force_reg (mode, operand1);\n+\t}\n+    }\n+\n+  /* Simplify the source if we need to.  Must handle DImode HIGH operators\n+     here because such a move needs a clobber added.  */\n+  if ((GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n+      || (GET_CODE (operand1) == HIGH && GET_MODE (operand1) == DImode))\n+    {\n+      if (flag_pic && symbolic_operand (operand1, mode))\n+\t{\n+\t  rtx temp_reg = reload_in_progress ? operand0 : 0;\n+\n+\t  operands[1] = legitimize_pic_address (operand1, mode, temp_reg,\n+\t\t\t\t\t\tscratch_reg);\n+\t}\n+      else if (GET_CODE (operand1) == CONST_INT\n+\t       ? (! SMALL_INT (operand1)\n+\t\t  && (INTVAL (operand1) & 0x3ff) != 0)\n+\t       : (GET_CODE (operand1) == CONST_DOUBLE\n+\t\t  ? ! arith_double_operand (operand1, DImode)\n+\t\t  : 1))\n+\t{\n+\t  /* For DImode values, temp must be operand0 because of the way\n+\t     HI and LO_SUM work.  The LO_SUM operator only copies half of\n+\t     the LSW from the dest of the HI operator.  If the LO_SUM dest is\n+\t     not the same as the HI dest, then the MSW of the LO_SUM dest will\n+\t     never be set.\n+\n+\t     ??? The real problem here is that the ...(HI:DImode pattern emits\n+\t     multiple instructions, and the ...(LO_SUM:DImode pattern emits\n+\t     one instruction.  This fails, because the compiler assumes that\n+\t     LO_SUM copies all bits of the first operand to its dest.  Better\n+\t     would be to have the HI pattern emit one instruction and the\n+\t     LO_SUM pattern multiple instructions.  Even better would be\n+\t     to use four rtl insns.  */\n+\t  rtx temp = ((reload_in_progress || mode == DImode)\n+\t\t      ? operand0 : gen_reg_rtx (mode));\n+\n+\t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n+\t\t\t      gen_rtx (HIGH, mode, operand1)));\n+\t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n+\t}\n+    }\n+\n+  if (GET_CODE (operand1) == LABEL_REF && flag_pic)\n+    {\n+      /* The procedure for doing this involves using a call instruction to\n+\t get the pc into o7.  We need to indicate this explicitly because\n+\t the tablejump pattern assumes that it can use this value also.  */\n+      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t  gen_rtvec (2,\n+\t\t\t\t     gen_rtx (SET, VOIDmode, operand0,\n+\t\t\t\t\t      operand1),\n+\t\t\t\t     gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t      gen_rtx (REG, mode, 15),\n+\t\t\t\t\t      pc_rtx))));\n+      return 1;\n+    }\n+\n+  /* Now have insn-emit do whatever it normally does.  */\n+  return 0;\n+}\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) != MEM)\n+\treturn \"st %r1,%0\";\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ld %1,%0\";\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+    {\n+      int i = INTVAL (operands[1]);\n+\n+      /* If all low order 12 bits are clear, then we only need a single\n+\t sethi insn to load the constant.  */\n+      if (i & 0x00000FFF)\n+\treturn \"sethi %%hi(%a1),%0\\n\\tor %0,%%lo(%a1),%0\";\n+      else\n+\treturn \"sethi %%hi(%a1),%0\";\n+    }\n+  /* ??? Wrong if target is DImode?  */\n+  return \"mov %1,%0\";\n+}\n+\f\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use for the\n+     high-numbered (least significant) word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    split_double (operands[1], &operands[1], &latehalf[1]);\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.\n+\n+     RMS says \"This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.\"\n+\n+     but it happens on the sparc when loading parameter registers,\n+     so I am going to define that circumstance, and make it work\n+     as expected.  */\n+\n+  /* Easy case: try moving both words at once.  */\n+  /* First check for moving between an even/odd register pair\n+     and a memory location.  */\n+  if ((optype0 == REGOP && optype1 != REGOP && optype1 != CNSTOP\n+       && (REGNO (operands[0]) & 1) == 0)\n+      || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n+\t  && (REGNO (operands[1]) & 1) == 0))\n+    {\n+      rtx op1, op2;\n+      rtx base = 0, offset = const0_rtx;\n+\n+      /* OP1 gets the register pair, and OP2 gets the memory address.  */\n+      if (optype0 == REGOP)\n+\top1 = operands[0], op2 = operands[1];\n+      else\n+\top1 = operands[1], op2 = operands[0];\n+\n+      /* Now see if we can trust the address to be 8-byte aligned.  */\n+      /* Trust global variables.  */\n+\n+      if (GET_CODE (op2) == LO_SUM)\n+\t{\n+\t  operands[0] = op1;\n+\t  operands[1] = op2;\n+\n+\t  if (final_sequence)\n+\t    abort ();\n+\t  return \"ldd %1,%0\";\n+\t}\n+\n+      if (GET_CODE (XEXP (op2, 0)) == PLUS)\n+\t{\n+\t  rtx temp = XEXP (op2, 0);\n+\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t    base = XEXP (temp, 0), offset = XEXP (temp, 1);\n+\t  else if (GET_CODE (XEXP (temp, 1)) == REG)\n+\t    base = XEXP (temp, 1), offset = XEXP (temp, 0);\n+\t}\n+\n+      /* Trust round enough offsets from the stack or frame pointer.  */\n+      if (base\n+\t  && (REGNO (base) == FRAME_POINTER_REGNUM\n+\t      || REGNO (base) == STACK_POINTER_REGNUM))\n+\t{\n+\t  if (GET_CODE (offset) == CONST_INT\n+\t      && (INTVAL (offset) & 0x7) == 0)\n+\t    {\n+\t      if (op1 == operands[0])\n+\t\treturn \"ldd %1,%0\";\n+\t      else\n+\t\treturn \"std %1,%0\";\n+\t    }\n+\t}\n+      /* We know structs not on the stack are properly aligned.  Since a\n+\t double asks for 8-byte alignment, we know it must have got that\n+\t if it is in a struct.  But a DImode need not be 8-byte aligned,\n+\t because it could be a struct containing two ints or pointers.  */\n+      else if (GET_CODE (operands[1]) == MEM\n+\t       && GET_MODE (operands[1]) == DFmode\n+\t       && (CONSTANT_P (XEXP (operands[1], 0))\n+\t\t   /* Let user ask for it anyway.  */\n+\t\t   || TARGET_ALIGN))\n+\treturn \"ldd %1,%0\";\n+      else if (GET_CODE (operands[0]) == MEM\n+\t       && GET_MODE (operands[0]) == DFmode\n+\t       && (CONSTANT_P (XEXP (operands[0], 0))\n+\t\t   || TARGET_ALIGN))\n+\treturn \"std %1,%0\";\n+    }\n+\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && REGNO (operands[0]) == REGNO (latehalf[1]))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,-0x4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,-0x4,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+  else if (optype0 == REGOP && optype1 != REGOP\n+\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n+    {\n+      /* Do the late half first.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      /* Then clobber.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,-0x4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,-0x4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\f\n+char *\n+output_fp_move_double (operands)\n+     rtx *operands;\n+{\n+  rtx addr;\n+\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\";\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  if ((REGNO (operands[1]) & 1) == 0)\n+\t    return \"std %1,[%@-8]\\n\\tldd [%@-8],%0\";\n+\t  else\n+\t    return \"st %R1,[%@-4]\\n\\tst %1,[%@-8]\\n\\tldd [%@-8],%0\";\n+\t}\n+      addr = XEXP (operands[1], 0);\n+\n+      /* Use ldd if known to be aligned.  */\n+      if (TARGET_ALIGN\n+\t  || (GET_CODE (addr) == PLUS\n+\t      && (((XEXP (addr, 0) == frame_pointer_rtx\n+\t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n+\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t   && (INTVAL (XEXP (addr, 1)) & 0x7) == 0)\n+\t\t  /* Arrays are known to be aligned,\n+\t\t     and reg+reg addresses are used (on this machine)\n+\t\t     only for array accesses.  */\n+\t\t  || (REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))))\n+\t  || (GET_MODE (operands[0]) == DFmode\n+\t      && (GET_CODE (addr) == LO_SUM || CONSTANT_P (addr))))\n+\treturn \"ldd %1,%0\";\n+\n+      /* Otherwise use two ld insns.  */\n+      operands[2]\n+\t= gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t   plus_constant_for_output (addr, 4));\n+\treturn \"ld %1,%0\\n\\tld %2,%R0\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  if ((REGNO (operands[0]) & 1) == 0)\n+\t    return \"std %1,[%@-8]\\n\\tldd [%@-8],%0\";\n+\t  else\n+\t    return \"std %1,[%@-8]\\n\\tld [%@-4],%R0\\n\\tld [%@-8],%0\";\n+\t}\n+      addr = XEXP (operands[0], 0);\n+\n+      /* Use std if we can be sure it is well-aligned.  */\n+      if (TARGET_ALIGN\n+\t  || (GET_CODE (addr) == PLUS\n+\t      && (((XEXP (addr, 0) == frame_pointer_rtx\n+\t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n+\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t   && (INTVAL (XEXP (addr, 1)) & 0x7) == 0)\n+\t\t  /* Arrays are known to be aligned,\n+\t\t     and reg+reg addresses are used (on this machine)\n+\t\t     only for array accesses.  */\n+\t\t  || (REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))))\n+\t  || (GET_MODE (operands[1]) == DFmode\n+\t      && (GET_CODE (addr) == LO_SUM || CONSTANT_P (addr))))\n+\treturn \"std %1,%0\";\n+\n+      /* Otherwise use two st insns.  */\n+      operands[2]\n+\t= gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t   plus_constant_for_output (addr, 4));\n+      return \"st %r1,%0\\n\\tst %R1,%2\";\n+    }\n+  else abort ();\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      /* We absolutely can not fudge the frame pointer here, because the\n+\t frame pointer must always be 8 byte aligned.  It also confuses\n+\t debuggers.  */\n+      if (GET_CODE (XEXP (addr, 0)) == REG\n+\t  && REGNO (XEXP (addr, 0)) != FRAME_POINTER_REGNUM)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG\n+\t       && REGNO (XEXP (addr, 1)) != FRAME_POINTER_REGNUM)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\n+void\n+output_sized_memop (opname, mode, signedp)\n+     char *opname;\n+     enum machine_mode mode;\n+     int signedp;\n+{\n+  static char *ld_size_suffix_u[] = { \"ub\", \"uh\", \"\", \"?\", \"d\" };\n+  static char *ld_size_suffix_s[] = { \"sb\", \"sh\", \"\", \"?\", \"d\" };\n+  static char *st_size_suffix[] = { \"b\", \"h\", \"\", \"?\", \"d\" };\n+  char **opnametab, *modename;\n+\n+  if (opname[0] == 'l')\n+    if (signedp)\n+      opnametab = ld_size_suffix_s;\n+    else\n+      opnametab = ld_size_suffix_u;\n+  else\n+    opnametab = st_size_suffix;\n+  modename = opnametab[GET_MODE_SIZE (mode) >> 1];\n+\n+  fprintf (asm_out_file, \"\\t%s%s\", opname, modename);\n+}\n+\f\n+void\n+output_move_with_extension (operands)\n+     rtx *operands;\n+{\n+  if (GET_MODE (operands[2]) == HImode)\n+    output_asm_insn (\"sll %2,0x10,%0\", operands);\n+  else if (GET_MODE (operands[2]) == QImode)\n+    output_asm_insn (\"sll %2,0x18,%0\", operands);\n+  else\n+    abort ();\n+}\n+\f\n+/* Load the address specified by OPERANDS[3] into the register\n+   specified by OPERANDS[0].\n+\n+   OPERANDS[3] may be the result of a sum, hence it could either be:\n+\n+   (1) CONST\n+   (2) REG\n+   (2) REG + CONST_INT\n+   (3) REG + REG + CONST_INT\n+   (4) REG + REG  (special case of 3).\n+\n+   Note that (3) is not a legitimate address.\n+   All cases are handled here.  */\n+\n+void\n+output_load_address (operands)\n+     rtx *operands;\n+{\n+  rtx base, offset;\n+\n+  if (CONSTANT_P (operands[3]))\n+    {\n+      output_asm_insn (\"set %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (REG_P (operands[3]))\n+    {\n+      if (REGNO (operands[0]) != REGNO (operands[3]))\n+\toutput_asm_insn (\"mov %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (GET_CODE (operands[3]) != PLUS)\n+    abort ();\n+\n+  base = XEXP (operands[3], 0);\n+  offset = XEXP (operands[3], 1);\n+\n+  if (GET_CODE (base) == CONST_INT)\n+    {\n+      rtx tmp = base;\n+      base = offset;\n+      offset = tmp;\n+    }\n+\n+  if (GET_CODE (offset) != CONST_INT)\n+    {\n+      /* Operand is (PLUS (REG) (REG)).  */\n+      base = operands[3];\n+      offset = const0_rtx;\n+    }\n+\n+  if (REG_P (base))\n+    {\n+      operands[6] = base;\n+      operands[7] = offset;\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"add %6,%7,%0\", operands);\n+      else\n+\toutput_asm_insn (\"set %7,%0\\n\\tadd %0,%6,%0\", operands);\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      operands[6] = XEXP (base, 0);\n+      operands[7] = XEXP (base, 1);\n+      operands[8] = offset;\n+\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"add %6,%7,%0\\n\\tadd %0,%8,%0\", operands);\n+      else\n+\toutput_asm_insn (\"set %8,%0\\n\\tadd %0,%6,%0\\n\\tadd %0,%7,%0\", operands);\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* Output code to place a size count SIZE in register REG.\n+   ALIGN is the size of the unit of transfer.\n+\n+   Because block moves are pipelined, we don't include the\n+   first element in the transfer of SIZE to REG.  */\n+\n+static void\n+output_size_for_block_move (size, reg, align)\n+     rtx size, reg;\n+     rtx align;\n+{\n+  rtx xoperands[3];\n+\n+  xoperands[0] = reg;\n+  xoperands[1] = size;\n+  xoperands[2] = align;\n+  if (GET_CODE (size) == REG)\n+    output_asm_insn (\"sub %1,%2,%0\", xoperands);\n+  else\n+    {\n+      xoperands[1]\n+\t= gen_rtx (CONST_INT, VOIDmode, INTVAL (size) - INTVAL (align));\n+      output_asm_insn (\"set %1,%0\", xoperands);\n+    }\n+}\n+\n+/* Emit code to perform a block move.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the alignment safe to use.\n+   OPERANDS[4] is a register we can safely clobber as a temp.  */\n+\n+char *\n+output_block_move (operands)\n+     rtx *operands;\n+{\n+  /* A vector for our computed operands.  Note that load_output_address\n+     makes use of (and can clobber) up to the 8th element of this vector.  */\n+  rtx xoperands[10];\n+  rtx zoperands[10];\n+  static int movstrsi_label = 0;\n+  int i;\n+  rtx temp1 = operands[4];\n+  rtx sizertx = operands[2];\n+  rtx alignrtx = operands[3];\n+  int align = INTVAL (alignrtx);\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = temp1;\n+\n+  /* We can't move more than this many bytes at a time\n+     because we have only one register to move them through.  */\n+  if (align > GET_MODE_SIZE (GET_MODE (temp1)))\n+    {\n+      align = GET_MODE_SIZE (GET_MODE (temp1));\n+      alignrtx = gen_rtx (CONST_INT, VOIDmode, GET_MODE_SIZE (GET_MODE (temp1)));\n+    }\n+\n+  /* If the size isn't known to be a multiple of the alignment,\n+     we have to do it in smaller pieces.  If we could determine that\n+     the size was a multiple of 2 (or whatever), we could be smarter\n+     about this.  */\n+  if (GET_CODE (sizertx) != CONST_INT)\n+    align = 1;\n+  else\n+    {\n+      int size = INTVAL (sizertx);\n+      while (size % align)\n+\talign >>= 1;\n+    }\n+\n+  if (align != INTVAL (alignrtx))\n+    alignrtx = gen_rtx (CONST_INT, VOIDmode, align);\n+\n+  /* Recognize special cases of block moves.  These occur\n+     when GNU C++ is forced to treat something as BLKmode\n+     to keep it in memory, when its mode could be represented\n+     with something smaller.\n+\n+     We cannot do this for global variables, since we don't know\n+     what pages they don't cross.  Sigh.  */\n+  if (GET_CODE (sizertx) == CONST_INT && INTVAL (sizertx) <= 16)\n+    {\n+      int size = INTVAL (sizertx);\n+\n+      if (align == 1)\n+\t{\n+\t  if (memory_address_p (QImode,\n+\t\t\t\tplus_constant_for_output (xoperands[0], size))\n+\t      && memory_address_p (QImode,\n+\t\t\t\t   plus_constant_for_output (xoperands[1],\n+\t\t\t\t\t\t\t     size)))\n+\t    {\n+\t      /* We will store different integers into this particular RTX.  */\n+\t      xoperands[2] = rtx_alloc (CONST_INT);\n+\t      PUT_MODE (xoperands[2], VOIDmode);\n+\t      for (i = size-1; i >= 0; i--)\n+\t\t{\n+\t\t  INTVAL (xoperands[2]) = i;\n+\t\t  output_asm_insn (\"ldub [%a1+%2],%%g1\\n\\tstb %%g1,[%a0+%2]\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else if (align == 2)\n+\t{\n+\t  if (memory_address_p (HImode,\n+\t\t\t\tplus_constant_for_output (xoperands[0], size))\n+\t      && memory_address_p (HImode,\n+\t\t\t\t   plus_constant_for_output (xoperands[1],\n+\t\t\t\t\t\t\t     size)))\n+\t    {\n+\t      /* We will store different integers into this particular RTX.  */\n+\t      xoperands[2] = rtx_alloc (CONST_INT);\n+\t      PUT_MODE (xoperands[2], VOIDmode);\n+\t      for (i = (size>>1)-1; i >= 0; i--)\n+\t\t{\n+\t\t  INTVAL (xoperands[2]) = i<<1;\n+\t\t  output_asm_insn (\"lduh [%a1+%2],%%g1\\n\\tsth %%g1,[%a0+%2]\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (memory_address_p (SImode,\n+\t\t\t\tplus_constant_for_output (xoperands[0], size))\n+\t      && memory_address_p (SImode,\n+\t\t\t\t   plus_constant_for_output (xoperands[1],\n+\t\t\t\t\t\t\t     size)))\n+\t    {\n+\t      /* We will store different integers into this particular RTX.  */\n+\t      xoperands[2] = rtx_alloc (CONST_INT);\n+\t      PUT_MODE (xoperands[2], VOIDmode);\n+\t      for (i = (size>>2)-1; i >= 0; i--)\n+\t\t{\n+\t\t  INTVAL (xoperands[2]) = i<<2;\n+\t\t  output_asm_insn (\"ld [%a1+%2],%%g1\\n\\tst %%g1,[%a0+%2]\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+    }\n+\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n+  xoperands[4] = gen_rtx (CONST_INT, VOIDmode, align);\n+  xoperands[5] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n+\n+  /* This is the size of the transfer.\n+     Either use the register which already contains the size,\n+     or use a free register (used by no operands).\n+     Also emit code to decrement the size value by ALIGN.  */\n+  output_size_for_block_move (sizertx, temp1, alignrtx);\n+\n+  /* Must handle the case when the size is zero or negative, so the first thing\n+     we do is compare the size against zero, and only copy bytes if it is\n+     zero or greater.  Note that we have already subtracted off the alignment\n+     once, so we must copy 1 alignment worth of bytes if the size is zero\n+     here.\n+\n+     The SUN assembler complains about labels in branch delay slots, so we\n+     do this before outputing the load address, so that there will always\n+     be a harmless insn between the branch here and the next label emitted\n+     below.  */\n+\n+#ifdef NO_UNDERSCORES\n+  output_asm_insn (\"cmp %2,0\\n\\tbl .Lm%5\", xoperands);\n+#else\n+  output_asm_insn (\"cmp %2,0\\n\\tbl Lm%5\", xoperands);\n+#endif\n+\n+  zoperands[0] = operands[0];\n+  zoperands[3] = plus_constant_for_output (operands[0], align);\n+  output_load_address (zoperands);\n+\n+  /* ??? This might be much faster if the loops below were preconditioned\n+     and unrolled.\n+\n+     That is, at run time, copy enough bytes one at a time to ensure that the\n+     target and source addresses are aligned to the the largest possible\n+     alignment.  Then use a preconditioned unrolled loop to copy say 16\n+     bytes at a time.  Then copy bytes one at a time until finish the rest.  */\n+\n+  /* Output the first label separately, so that it is spaced properly.  */\n+\n+#ifdef NO_UNDERSCORES\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \".Lm\", INTVAL (xoperands[3]));\n+#else\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"Lm\", INTVAL (xoperands[3]));\n+#endif\n+\n+#ifdef NO_UNDERSCORES\n+  if (align == 1)\n+    output_asm_insn (\"ldub [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tstb %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n+  else if (align == 2)\n+    output_asm_insn (\"lduh [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tsth %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n+  else\n+    output_asm_insn (\"ld [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tst %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n+  return \"\";\n+#else\n+  if (align == 1)\n+    output_asm_insn (\"ldub [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tstb %%g1,[%0+%2]\\nLm%5:\", xoperands);\n+  else if (align == 2)\n+    output_asm_insn (\"lduh [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tsth %%g1,[%0+%2]\\nLm%5:\", xoperands);\n+  else\n+    output_asm_insn (\"ld [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tst %%g1,[%0+%2]\\nLm%5:\", xoperands);\n+  return \"\";\n+#endif\n+}\n+\f\n+/* Output reasonable peephole for set-on-condition-code insns.\n+   Note that these insns assume a particular way of defining\n+   labels.  Therefore, *both* sparc.h and this function must\n+   be changed if a new syntax is needed.    */\n+\n+char *\n+output_scc_insn (operands, insn)\n+     rtx operands[];\n+     rtx insn;\n+{\n+  static char string[100];\n+  rtx label = 0, next = insn;\n+  int need_label = 0;\n+\n+  /* Try doing a jump optimization which jump.c can't do for us\n+     because we did not expose that setcc works by using branches.\n+\n+     If this scc insn is followed by an unconditional branch, then have\n+     the jump insn emitted here jump to that location, instead of to\n+     the end of the scc sequence as usual.  */\n+\n+  do\n+    {\n+      if (GET_CODE (next) == CODE_LABEL)\n+\tlabel = next;\n+      next = NEXT_INSN (next);\n+      if (next == 0)\n+\tbreak;\n+    }\n+  while (GET_CODE (next) == NOTE || GET_CODE (next) == CODE_LABEL);\n+\n+  /* If we are in a sequence, and the following insn is a sequence also,\n+     then just following the current insn's next field will take us to the\n+     first insn of the next sequence, which is the wrong place.  We don't\n+     want to optimize with a branch that has had its delay slot filled.\n+     Avoid this by verifying that NEXT_INSN (PREV_INSN (next)) == next\n+     which fails only if NEXT is such a branch.  */\n+\n+  if (next && GET_CODE (next) == JUMP_INSN && simplejump_p (next)\n+      && (! final_sequence || NEXT_INSN (PREV_INSN (next)) == next))\n+    label = JUMP_LABEL (next);\n+  /* If not optimizing, jump label fields are not set.  To be safe, always\n+     check here to whether label is still zero.  */\n+  if (label == 0)\n+    {\n+      label = gen_label_rtx ();\n+      need_label = 1;\n+    }\n+\n+  LABEL_NUSES (label) += 1;\n+\n+  operands[2] = label;\n+\n+  /* If we are in a delay slot, assume it is the delay slot of an fpcc\n+     insn since our type isn't allowed anywhere else.  */\n+\n+  /* ??? Fpcc instructions no longer have delay slots, so this code is\n+     probably obsolete.  */\n+\n+  /* The fastest way to emit code for this is an annulled branch followed\n+     by two move insns.  This will take two cycles if the branch is taken,\n+     and three cycles if the branch is not taken.\n+\n+     However, if we are in the delay slot of another branch, this won't work,\n+     because we can't put a branch in the delay slot of another branch.\n+     The above sequence would effectively take 3 or 4 cycles respectively\n+     since a no op would have be inserted between the two branches.\n+     In this case, we want to emit a move, annulled branch, and then the\n+     second move.  This sequence always takes 3 cycles, and hence is faster\n+     when we are in a branch delay slot.  */\n+\n+  if (final_sequence)\n+    {\n+      strcpy (string, \"mov 0,%0\\n\\t\");\n+      strcat (string, output_cbranch (operands[1], 2, 0, 1, 0));\n+      strcat (string, \"\\n\\tmov 1,%0\");\n+    }\n+  else\n+    {\n+      strcpy (string, output_cbranch (operands[1], 2, 0, 1, 0));\n+      strcat (string, \"\\n\\tmov 1,%0\\n\\tmov 0,%0\");\n+    }\n+\n+  if (need_label)\n+    strcat (string, \"\\n%l2:\");\n+\n+  return string;\n+}\n+\f\n+/* Vectors to keep interesting information about registers where\n+   it can easily be got.  */\n+\n+/* Modes for condition codes.  */\n+#define C_MODES\t\t\\\n+  ((1 << (int) CCmode) | (1 << (int) CC_NOOVmode) | (1 << (int) CCFPmode))\n+\n+/* Modes for single-word (and smaller) quantities.  */\n+#define S_MODES\t\t\t\t\t\t\\\n+ (~C_MODES\t\t\t\t\t\t\\\n+  & ~ ((1 << (int) DImode) | (1 << (int) TImode)\t\\\n+      | (1 << (int) DFmode) | (1 << (int) TFmode)))\n+\n+/* Modes for double-word (and smaller) quantities.  */\n+#define D_MODES\t\t\t\t\t\\\n+  (~C_MODES\t\t\t\t\t\\\n+   & ~ ((1 << (int) TImode) | (1 << (int) TFmode)))\n+\n+/* Modes for quad-word quantities.  */\n+#define T_MODES (~C_MODES)\n+\n+/* Modes for single-float quantities.  */\n+#define SF_MODES ((1 << (int) SFmode))\n+\n+/* Modes for double-float quantities.  */\n+#define DF_MODES (SF_MODES | (1 << (int) DFmode) | (1 << (int) SCmode))\n+\n+/* Modes for quad-float quantities.  */\n+#define TF_MODES (DF_MODES | (1 << (int) TFmode) | (1 << (int) DCmode))\n+\n+/* Value is 1 if register/mode pair is acceptable on sparc.\n+   The funny mixture of D and T modes is because integer operations\n+   do not specially operate on tetra quantities, so non-quad-aligned\n+   registers can hold quadword quantities (except %o4 and %i4 because\n+   they cross fixed registers.  */\n+\n+int hard_regno_mode_ok[] = {\n+  C_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n+\n+  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES};\n+\f\n+#ifdef __GNUC__\n+inline\n+#endif\n+static int\n+save_regs (file, low, high, base, offset, n_fregs)\n+     FILE *file;\n+     int low, high;\n+     char *base;\n+     int offset;\n+     int n_fregs;\n+{\n+  int i;\n+\n+  for (i = low; i < high; i += 2)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t  fprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n+\t\t   reg_names[i], base, offset + 4 * n_fregs),\n+\t  n_fregs += 2;\n+\telse\n+\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t   reg_names[i], base, offset + 4 * n_fregs),\n+\t  n_fregs += 2;\n+      else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\tfprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t reg_names[i+1], base, offset + 4 * n_fregs),\n+\tn_fregs += 2;\n+    }\n+  return n_fregs;\n+}\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+static int\n+restore_regs (file, low, high, base, offset, n_fregs)\n+     FILE *file;\n+     int low, high;\n+     char *base;\n+     int offset;\n+{\n+  int i;\n+\n+  for (i = low; i < high; i += 2)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t  fprintf (file, \"\\tldd [%s+%d], %s\\n\",\n+\t\t   base, offset + 4 * n_fregs, reg_names[i]),\n+\t  n_fregs += 2;\n+\telse\n+\t  fprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t   base, offset + 4 * n_fregs, reg_names[i]),\n+\t  n_fregs += 2;\n+      else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\tfprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t base, offset + 4 * n_fregs, reg_names[i+1]),\n+\tn_fregs += 2;\n+    }\n+  return n_fregs;\n+}\n+\n+/* Static variables we want to share between prologue and epilogue.  */\n+\n+/* Number of live floating point registers needed to be saved.  */\n+static int num_fregs;\n+\n+/* Nonzero if any floating point register was ever used.  */\n+static int fregs_ever_live;\n+\n+int\n+compute_frame_size (size, leaf_function)\n+     int size;\n+     int leaf_function;\n+{\n+  int fregs_ever_live = 0;\n+  int n_fregs = 0, i;\n+  int outgoing_args_size = (current_function_outgoing_args_size\n+\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n+\n+  apparent_fsize = ((size) + 7 - STARTING_FRAME_OFFSET) & -8;\n+  for (i = 32; i < FIRST_PSEUDO_REGISTER; i += 2)\n+    fregs_ever_live |= regs_ever_live[i]|regs_ever_live[i+1];\n+\n+  if (TARGET_EPILOGUE && fregs_ever_live)\n+    {\n+      for (i = 32; i < FIRST_PSEUDO_REGISTER; i += 2)\n+\tif ((regs_ever_live[i] && ! call_used_regs[i])\n+\t    || (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n+\t  n_fregs += 2;\n+    }\n+\n+  /* Set up values for use in `function_epilogue'.  */\n+  num_fregs = n_fregs;\n+\n+  apparent_fsize += (outgoing_args_size+7) & -8;\n+  if (leaf_function && n_fregs == 0\n+      && apparent_fsize == (REG_PARM_STACK_SPACE (current_function_decl)\n+\t\t\t    - STARTING_FRAME_OFFSET))\n+    apparent_fsize = 0;\n+\n+  actual_fsize = apparent_fsize + n_fregs*4;\n+\n+  /* Make sure nothing can clobber our register windows.\n+     If a SAVE must be done, or there is a stack-local variable,\n+     the register window area must be allocated.  */\n+  if (leaf_function == 0 || size > 0)\n+    actual_fsize += (16 * UNITS_PER_WORD)+8;\n+\n+  return actual_fsize;\n+}\n+\n+void\n+output_function_prologue (file, size, leaf_function)\n+     FILE *file;\n+     int size;\n+{\n+  if (leaf_function)\n+    frame_base_name = \"%sp+80\";\n+  else\n+    frame_base_name = \"%fp\";\n+\n+  actual_fsize = compute_frame_size (size, leaf_function);\n+\n+  fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n+  if (actual_fsize == 0) /* do nothing.  */ ;\n+  else if (actual_fsize < 4096)\n+    {\n+      if (! leaf_function)\n+\tfprintf (file, \"\\tsave %%sp,-%d,%%sp\\n\", actual_fsize);\n+      else\n+\tfprintf (file, \"\\tadd %%sp,-%d,%%sp\\n\", actual_fsize);\n+    }\n+  else if (! leaf_function)\n+    {\n+      /* Need to use actual_fsize, since we are also allocating space for\n+\t our callee (and our own register save area).  */\n+      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\",\n+\t       -actual_fsize, -actual_fsize);\n+      fprintf (file, \"\\tsave %%sp,%%g1,%%sp\\n\");\n+    }\n+  else\n+    {\n+      /* Put pointer to parameters into %g4, and allocate\n+\t frame space using result computed into %g1.  actual_fsize\n+\t used instead of apparent_fsize for reasons stated above.  */\n+      abort ();\n+\n+      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\",\n+\t       -actual_fsize, -actual_fsize);\n+      fprintf (file, \"\\tadd %%sp,64,%%g4\\n\\tadd %%sp,%%g1,%%sp\\n\");\n+    }\n+\n+  /* If doing anything with PIC, do it now.  */\n+  if (! flag_pic)\n+    fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n+\n+  /* Figure out where to save any special registers.  */\n+  if (num_fregs)\n+    {\n+      int offset, n_fregs = num_fregs;\n+\n+      if (! leaf_function)\n+\toffset = -apparent_fsize;\n+      else\n+\toffset = 0;\n+\n+      if (TARGET_EPILOGUE && ! leaf_function)\n+\tn_fregs = save_regs (file, 0, 16, frame_base_name, offset, 0);\n+      else if (leaf_function)\n+\tn_fregs = save_regs (file, 0, 32, frame_base_name, offset, 0);\n+      if (TARGET_EPILOGUE)\n+\tsave_regs (file, 32, FIRST_PSEUDO_REGISTER,\n+\t\t   frame_base_name, offset, n_fregs);\n+    }\n+\n+  if (regs_ever_live[62])\n+    fprintf (file, \"\\tst %s,[%s-16]\\n\\tst %s,[%s-12]\\n\",\n+\t     reg_names[0], frame_base_name,\n+\t     reg_names[0], frame_base_name);\n+\n+  leaf_label = 0;\n+  if (leaf_function && actual_fsize != 0)\n+    {\n+      /* warning (\"leaf procedure with frame size %d\", actual_fsize); */\n+      if (! TARGET_EPILOGUE)\n+\tleaf_label = gen_label_rtx ();\n+    }\n+}\n+\n+void\n+output_function_epilogue (file, size, leaf_function, true_epilogue)\n+     FILE *file;\n+     int size;\n+{\n+  int n_fregs, i;\n+  char *ret;\n+\n+  if (leaf_label)\n+    {\n+      if (leaf_function < 0)\n+\tabort ();\n+      emit_label_after (leaf_label, get_last_insn ());\n+      final_scan_insn (get_last_insn (), file, 0, 0, 1);\n+    }\n+\n+  if (num_fregs)\n+    {\n+      int offset, n_fregs = num_fregs;\n+\n+      if (! leaf_function)\n+\toffset = -apparent_fsize;\n+      else\n+\toffset = 0;\n+\n+      if (TARGET_EPILOGUE && ! leaf_function)\n+\tn_fregs = restore_regs (file, 0, 16, frame_base_name, offset, 0);\n+      else if (leaf_function)\n+\tn_fregs = restore_regs (file, 0, 32, frame_base_name, offset, 0);\n+      if (TARGET_EPILOGUE)\n+\trestore_regs (file, 32, FIRST_PSEUDO_REGISTER,\n+\t\t      frame_base_name, offset, n_fregs);\n+    }\n+\n+  /* Work out how to skip the caller's unimp instruction if required.  */\n+  if (leaf_function)\n+    ret = (current_function_returns_struct ? \"jmp %o7+12\" : \"retl\");\n+  else\n+    ret = (current_function_returns_struct ? \"jmp %i7+12\" : \"ret\");\n+\n+  /* Tail calls have to do this work themselves.  */\n+  if (leaf_function >= 0)\n+    {\n+      if (TARGET_EPILOGUE || leaf_label)\n+\t{\n+\t  int old_target_epilogue = TARGET_EPILOGUE;\n+\t  target_flags &= ~old_target_epilogue;\n+\n+\t  if (! leaf_function)\n+\t    {\n+\t      /* If we wound up with things in our delay slot,\n+\t\t flush them here.  */\n+\t      if (current_function_epilogue_delay_list)\n+\t\t{\n+\t\t  rtx insn = emit_jump_insn_after (gen_rtx (RETURN, VOIDmode),\n+\t\t\t\t\t\t   get_last_insn ());\n+\t\t  PATTERN (insn) = gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\t    gen_rtvec (2,\n+\t\t\t\t\t\t       PATTERN (XEXP (current_function_epilogue_delay_list, 0)),\n+\t\t\t\t\t\t       PATTERN (insn)));\n+\t\t  final_scan_insn (insn, file, 1, 0, 1);\n+\t\t}\n+\t      else\n+\t\tfprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n+\t    }\n+\t  else if (actual_fsize < 4096)\n+\t    {\n+\t      if (current_function_epilogue_delay_list)\n+\t\t{\n+\t\t  fprintf (file, \"\\t%s\\n\", ret);\n+\t\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t\t\t   file, 1, 0, 1);\n+\t\t}\n+\t      else\n+\t\tfprintf (file, \"\\t%s\\n\\tadd %%sp,%d,%%sp\\n\",\n+\t\t\t ret, actual_fsize);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (current_function_epilogue_delay_list)\n+\t\tabort ();\n+\t      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n+\t\t       actual_fsize, actual_fsize, ret);\n+\t    }\n+\t  target_flags |= old_target_epilogue;\n+\t}\n+    }\n+  else if (true_epilogue)\n+    {\n+      /* We may still need a return insn!  Somebody could jump around\n+\t the tail-calls that this function makes.  */\n+      if (TARGET_EPILOGUE)\n+\t{\n+\t  rtx last = get_last_insn ();\n+\n+\t  last = prev_nonnote_insn (last);\n+\t  if (last == 0\n+\t      || (GET_CODE (last) != JUMP_INSN && GET_CODE (last) != BARRIER))\n+\t    fprintf (file, \"\\t%s\\n\\tnop\\n\", ret);\n+\t}\n+    }\n+}\n+\f\n+/* Return the string to output a conditional branch to LABEL, which is\n+   the operand number of the label.  OP is the conditional expression.  The\n+   mode of register 0 says what kind of comparison we made.\n+\n+   REVERSED is non-zero if we should reverse the sense of the comparison.\n+\n+   ANNUL is non-zero if we should generate an annulling branch.\n+\n+   NOOP is non-zero if we have to follow this branch by a noop.  */\n+\n+char *\n+output_cbranch (op, label, reversed, annul, noop)\n+     rtx op;\n+     int label;\n+     int reversed, annul, noop;\n+{\n+  static char string[20];\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  static char labelno[] = \" %lX\";\n+\n+  /* ??? FP branches can not be preceeded by another floating point insn.\n+     Because there is currently no concept of pre-delay slots, we can fix\n+     this only by always emitting a nop before a floating point branch.  */\n+\n+  if (mode == CCFPmode)\n+    strcpy (string, \"nop\\n\\t\");\n+\n+  /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n+  if (reversed && (mode != CCFPmode || code == EQ || code == NE))\n+    code = reverse_condition (code), reversed = 0;\n+\n+  /* Start by writing the branch condition.  */\n+  switch (code)\n+    {\n+    case NE:\n+      if (mode == CCFPmode)\n+\tstrcat (string, \"fbne\");\n+      else\n+\tstrcpy (string, \"bne\");\n+      break;\n+\n+    case EQ:\n+      if (mode == CCFPmode)\n+\tstrcat (string, \"fbe\");\n+      else\n+\tstrcpy (string, \"be\");\n+      break;\n+\n+    case GE:\n+      if (mode == CCFPmode)\n+\t{\n+\t  if (reversed)\n+\t    strcat (string, \"fbul\");\n+\t  else\n+\t    strcat (string, \"fbge\");\n+\t}\n+      else if (mode == CC_NOOVmode)\n+\tstrcpy (string, \"bpos\");\n+      else\n+\tstrcpy (string, \"bge\");\n+      break;\n+\n+    case GT:\n+      if (mode == CCFPmode)\n+\t{\n+\t  if (reversed)\n+\t    strcat (string, \"fbule\");\n+\t  else\n+\t    strcat (string, \"fbg\");\n+\t}\n+      else\n+\tstrcpy (string, \"bg\");\n+      break;\n+\n+    case LE:\n+      if (mode == CCFPmode)\n+\t{\n+\t  if (reversed)\n+\t    strcat (string, \"fbug\");\n+\t  else\n+\t    strcat (string, \"fble\");\n+\t}\n+      else\n+\tstrcpy (string, \"ble\");\n+      break;\n+\n+    case LT:\n+      if (mode == CCFPmode)\n+\t{\n+\t  if (reversed)\n+\t    strcat (string, \"fbuge\");\n+\t  else\n+\t    strcat (string, \"fbl\");\n+\t}\n+      else if (mode == CC_NOOVmode)\n+\tstrcpy (string, \"bneg\");\n+      else\n+\tstrcpy (string, \"bl\");\n+      break;\n+\n+    case GEU:\n+      strcpy (string, \"bgeu\");\n+      break;\n+\n+    case GTU:\n+      strcpy (string, \"bgu\");\n+      break;\n+\n+    case LEU:\n+      strcpy (string, \"bleu\");\n+      break;\n+\n+    case LTU:\n+      strcpy (string, \"blu\");\n+      break;\n+    }\n+\n+  /* Now add the annulling, the label, and a possible noop.  */\n+  if (annul)\n+    strcat (string, \",a\");\n+\n+  labelno[3] = label + '0';\n+  strcat (string, labelno);\n+\n+  if (noop)\n+    strcat (string, \"\\n\\tnop\");\n+\n+  return string;\n+}\n+\n+char *\n+output_return (operands)\n+     rtx *operands;\n+{\n+  if (leaf_label)\n+    {\n+      operands[0] = leaf_label;\n+      return \"b,a %l0\";\n+    }\n+  else if (leaf_function)\n+    {\n+      operands[0] = gen_rtx (CONST_INT, VOIDmode, actual_fsize);\n+      if (actual_fsize < 4096)\n+\t{\n+\t  if (current_function_returns_struct)\n+\t    return \"jmp %%o7+12\\n\\tadd %%sp,%0,%%sp\";\n+\t  else\n+\t    return \"retl\\n\\tadd %%sp,%0,%%sp\";\n+\t}\n+      else\n+\t{\n+\t  if (current_function_returns_struct)\n+\t    return \"sethi %%hi(%a0),%%g1\\n\\tor %%g1,%%lo(%a0),%%g1\\n\\tjmp %%o7+12\\n\\tadd %%sp,%%g1,%%sp\";\n+\t  else\n+\t    return \"sethi %%hi(%a0),%%g1\\n\\tor %%g1,%%lo(%a0),%%g1\\n\\tretl\\n\\tadd %%sp,%%g1,%%sp\";\n+\t}\n+    }\n+  else\n+    {\n+      if (current_function_returns_struct)\n+\treturn \"jmp %%i7+12\\n\\trestore\";\n+      else\n+\treturn \"ret\\n\\trestore\";\n+    }\n+}\n+\n+char *\n+output_floatsisf2 (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ld %1,%0\\n\\tfitos %0,%0\";\n+  else if (FP_REG_P (operands[1]))\n+    return \"fitos %1,%0\";\n+  return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitos %0,%0\";\n+}\n+\n+char *\n+output_floatsidf2 (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ld %1,%0\\n\\tfitod %0,%0\";\n+  else if (FP_REG_P (operands[1]))\n+    return \"fitod %1,%0\";\n+  return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitod %0,%0\";\n+}\n+\n+int\n+tail_call_valid_p ()\n+{\n+  static int checked = 0;\n+  static int valid_p = 0;\n+\n+  if (! checked)\n+    {\n+      register int i;\n+\n+      checked = 1;\n+      for (i = 32; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (! fixed_regs[i] && ! call_used_regs[i])\n+\t  return 0;\n+      valid_p = 1;\n+    }\n+  return valid_p;\n+}\n+\f\n+/* Leaf functions and non-leaf functions have different needs.  */\n+\n+static int\n+reg_leaf_alloc_order[] = REG_LEAF_ALLOC_ORDER;\n+\n+static int\n+reg_nonleaf_alloc_order[] = REG_ALLOC_ORDER;\n+\n+static int *reg_alloc_orders[] = {\n+  reg_leaf_alloc_order,\n+  reg_nonleaf_alloc_order};\n+\n+void\n+order_regs_for_local_alloc ()\n+{\n+  static int last_order_nonleaf = 1;\n+\n+  if (regs_ever_live[15] != last_order_nonleaf)\n+    {\n+      last_order_nonleaf = !last_order_nonleaf;\n+      bcopy (reg_alloc_orders[last_order_nonleaf], reg_alloc_order,\n+\t     FIRST_PSEUDO_REGISTER * sizeof (int));\n+    }\n+}\n+\f\n+/* Machine dependent routines for the branch probability, arc profiling\n+   code.  */\n+\n+/* The label used by the arc profiling code.  */\n+\n+static rtx profiler_label;\n+\n+void\n+init_arc_profiler ()\n+{\n+  /* Generate and save a copy of this so it can be shared.  */\n+  profiler_label = gen_rtx (SYMBOL_REF, Pmode, \"*LPBX2\");\n+}\n+\n+void\n+output_arc_profiler (arcno, insert_after)\n+     int arcno;\n+     rtx insert_after;\n+{\n+  rtx profiler_target_addr\n+    = gen_rtx (CONST, Pmode,\n+\t       gen_rtx (PLUS, Pmode, profiler_label,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 4 * arcno)));\n+  register rtx profiler_reg = gen_reg_rtx (SImode);\n+  register rtx temp = gen_reg_rtx (Pmode);\n+  register rtx profiler_target = gen_rtx (MEM, SImode,\n+\t\t\t\t\t  gen_rtx (LO_SUM, Pmode, temp,\n+\t\t\t\t\t\t   profiler_target_addr));\n+  /* The insns are emitted from last to first after the insn insert_after.\n+     Emit_insn_after is used because sometimes we want to put the\n+     instrumentation code after the last insn of the function.  */\n+  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_target, profiler_reg),\n+\t\t   insert_after);\n+  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg,\n+\t\t\t    gen_rtx (PLUS, SImode, profiler_reg, const1_rtx)),\n+\t\t   insert_after);\n+  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg, profiler_target),\n+\t\t   insert_after);\n+  emit_insn_after (gen_rtx (SET, VOIDmode, temp,\n+\t\t\t    gen_rtx (HIGH, Pmode, profiler_target_addr)),\n+\t\t   insert_after);\n+}\n+\f\n+/* All the remaining routines in this file have been turned off.  */\n+#if 0\n+char *\n+output_tail_call (operands, insn)\n+     rtx *operands;\n+     rtx insn;\n+{\n+  int this_fsize = actual_fsize;\n+  rtx next;\n+  int need_nop_at_end = 0;\n+\n+  next = next_real_insn (insn);\n+  while (next && GET_CODE (next) == CODE_LABEL)\n+    next = next_real_insn (insn);\n+\n+  if (final_sequence && this_fsize > 0)\n+    {\n+      rtx xoperands[1];\n+\n+      /* If we have to restore any registers, don't take any chances\n+\t restoring a register before we discharge it into\n+\t its home.  If the frame size is only 88, we are guaranteed\n+\t that the epilogue will fit in the delay slot.  */\n+      rtx delay_insn = XVECEXP (final_sequence, 0, 1);\n+      if (GET_CODE (PATTERN (delay_insn)) == SET)\n+\t{\n+\t  rtx dest = SET_DEST (PATTERN (delay_insn));\n+\t  if (GET_CODE (dest) == REG\n+\t      && reg_mentioned_p (dest, insn))\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (PATTERN (delay_insn)) == PARALLEL)\n+\tabort ();\n+      xoperands[0] = operands[0];\n+      final_scan_insn (delay_insn, asm_out_file, 0, 0, 1);\n+      operands[0] = xoperands[0];\n+      final_sequence = 0;\n+    }\n+\n+  /* Make sure we are clear to return.  */\n+  output_function_epilogue (asm_out_file, get_frame_size (), -1, 0);\n+\n+  /* Strip the MEM.  */\n+  operands[0] = XEXP (operands[0], 0);\n+\n+  if (final_sequence == 0\n+      && (next == 0\n+\t  || GET_CODE (next) == CALL_INSN\n+\t  || GET_CODE (next) == JUMP_INSN))\n+    need_nop_at_end = 1;\n+\n+  if (flag_pic)\n+    return output_pic_sequence_2 (2, 3, 0, \"jmpl %%g1+%3\", operands, need_nop_at_end);\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    output_asm_insn (\"jmpl %a0,%%g0\", operands);\n+  else if (TARGET_TAIL_CALL)\n+    {\n+      /* We assume all labels will be within 16 MB of our call.  */\n+      if (need_nop_at_end || final_sequence)\n+\toutput_asm_insn (\"b %a0\", operands);\n+      else\n+\toutput_asm_insn (\"b,a %a0\", operands);\n+    }\n+  else if (! final_sequence)\n+    {\n+      output_asm_insn (\"sethi %%hi(%a0),%%g1\\n\\tjmpl %%g1+%%lo(%a0),%%g1\",\n+\t\t       operands);\n+    }\n+  else\n+    {\n+      int i;\n+      rtx x = PATTERN (XVECEXP (final_sequence, 0, 1));\n+      for (i = 1; i < 32; i++)\n+\tif ((i == 1 || ! fixed_regs[i])\n+\t    && call_used_regs[i]\n+\t    && ! refers_to_regno_p (i, i+1, x, 0))\n+\t  break;\n+      if (i == 32)\n+\tabort ();\n+      operands[1] = gen_rtx (REG, SImode, i);\n+      output_asm_insn (\"sethi %%hi(%a0),%1\\n\\tjmpl %1+%%lo(%a0),%1\", operands);\n+    }\n+  return (need_nop_at_end ? \"nop\" : \"\");\n+}\n+#endif\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case '#':\n+      /* Output a 'nop' if there's nothing for the delay slot.  */\n+      if (dbr_sequence_length () == 0)\n+\tfputs (\"\\n\\tnop\", file);\n+      return;\n+    case '*':\n+      /* Output an annul flag if there's nothing for the delay slot.  */\n+      if (dbr_sequence_length () == 0)\n+        fputs (\",a\", file);\n+      return;\n+    case 'Y':\n+      /* Adjust the operand to take into account a RESTORE operation.  */\n+      if (GET_CODE (x) != REG)\n+\tabort ();\n+      if (REGNO (x) < 8)\n+\tfputs (reg_names[REGNO (x)], file);\n+      else if (REGNO (x) >= 24 && REGNO (x) < 32)\n+\tfputs (reg_names[REGNO (x)-16], file);\n+      else\n+\tabort ();\n+      return;\n+    case '@':\n+      /* Print out what we are using as the frame pointer.  This might\n+\t be %fp, or might be %sp+offset.  */\n+      fputs (frame_base_name, file);\n+      return;\n+    case 'R':\n+      /* Print out the second register name of a register pair.\n+\t I.e., R (%o0) => %o1.  */\n+      fputs (reg_names[REGNO (x)+1], file);\n+      return;\n+    case 'm':\n+      /* Print the operand's address only.  */\n+      output_address (XEXP (x, 0));\n+      return;\n+    case 'r':\n+      /* In this case we need a register.  Use %g0 if the\n+\t operand in const0_rtx.  */\n+      if (x == const0_rtx)\n+\t{\n+\t  fputs (\"%g0\", file);\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+\n+    case  'A':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase IOR: fputs (\"or\", file); break;\n+\tcase AND: fputs (\"and\", file); break;\n+\tcase XOR: fputs (\"xor\", file); break;\n+\tdefault: abort ();\n+\t}\n+      return;\n+\n+    case 'B':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase IOR: fputs (\"orn\", file); break;\n+\tcase AND: fputs (\"andn\", file); break;\n+\tcase XOR: fputs (\"xnor\", file); break;\n+\tdefault: abort ();\n+\t}\n+      return;\n+\n+    case 'b':\n+      {\n+\t/* Print a sign-extended character.  */\n+\tint i = INTVAL (x) & 0xff;\n+\tif (i & 0x80)\n+\t  i |= 0xffffff00;\n+\tfprintf (file, \"%d\", i);\n+\treturn;\n+      }\n+\n+    case 0:\n+      /* Do nothing special.  */\n+      break;\n+\n+    default:\n+      /* Undocumented flag.  */\n+      abort ();\n+    }\n+\n+  if (GET_CODE (x) == REG)\n+    fputs (reg_names[REGNO (x)], file);\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      fputc ('[', file);\n+      if (CONSTANT_P (XEXP (x, 0)))\n+\t/* Poor Sun assembler doesn't understand absolute addressing.  */\n+\tfputs (\"%g0+\", file);\n+      output_address (XEXP (x, 0));\n+      fputc (']', file);\n+    }\n+  else if (GET_CODE (x) == HIGH)\n+    {\n+      fputs (\"%hi(\", file);\n+      output_addr_const (file, XEXP (x, 0));\n+      fputc (')', file);\n+    }\n+  else if (GET_CODE (x) == LO_SUM)\n+    {\n+      print_operand (file, XEXP (x, 0), 0);\n+      fputs (\"+%lo(\", file);\n+      output_addr_const (file, XEXP (x, 1));\n+      fputc (')', file);\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE)\n+    {\n+      if (CONST_DOUBLE_HIGH (x) == 0)\n+\tfprintf (file, \"%u\", CONST_DOUBLE_LOW (x));\n+      else if (CONST_DOUBLE_HIGH (x) == -1\n+\t       && CONST_DOUBLE_LOW (x) < 0)\n+\tfprintf (file, \"%d\", CONST_DOUBLE_LOW (x));\n+      else\n+\tabort ();\n+    }\n+  else { output_addr_const (file, x); }\n+}\n+\f\n+/* This function outputs assembler code for VALUE to FILE, where VALUE is\n+   a 64 bit (DImode) value.  */\n+\n+/* ??? If there is a 64 bit counterpart to .word that the assembler\n+   understands, then using that would simply this code greatly.  */\n+\n+void\n+output_double_int (file, value)\n+     FILE *file;\n+     rtx value;\n+{\n+  if (GET_CODE (value) == CONST_INT)\n+    {\n+      if (INTVAL (value) < 0)\n+\tASM_OUTPUT_INT (file, constm1_rtx);\n+      else\n+\tASM_OUTPUT_INT (file, const0_rtx);\n+      ASM_OUTPUT_INT (file, value);\n+    }\n+  else if (GET_CODE (value) == CONST_DOUBLE)\n+    {\n+      ASM_OUTPUT_INT (file, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     CONST_DOUBLE_HIGH (value)));\n+      ASM_OUTPUT_INT (file, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     CONST_DOUBLE_LOW (value)));\n+    }\n+  else if (GET_CODE (value) == SYMBOL_REF\n+\t   || GET_CODE (value) == CONST\n+\t   || GET_CODE (value) == PLUS)\n+    {\n+      /* Addresses are only 32 bits.  */\n+      ASM_OUTPUT_INT (file, const0_rtx);\n+      ASM_OUTPUT_INT (file, value);\n+    }\n+  else\n+    abort ();\n+}\n+"}, {"sha": "459fda9046bfc292a778416e2df424b99925114f", "filename": "gcc/config/vax/vax.h", "status": "added", "additions": 1197, "deletions": 0, "changes": 1197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=ab835497c9a339a644a752a4b0a061d1370a00f1", "patch": "@@ -0,0 +1,1197 @@\n+/* Definitions of target machine for GNU compiler.  Vax version.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dvax -Dunix\"\n+\n+/* If using g-format floating point, alter math.h.  */\n+\n+#define\tCPP_SPEC \"%{mg:-DGFLOAT}\"\n+\n+/* Choose proper libraries depending on float format.\n+   Note that there are no profiling libraries for g-format.\n+   Also use -lg for the sake of dbx.  */\n+\n+#define LIB_SPEC \"%{g:-lg}\\\n+ %{mg:%{lm:-lmg} -lcg \\\n+  %{p:%eprofiling not supported with -mg\\n}\\\n+  %{pg:%eprofiling not supported with -mg\\n}}\\\n+ %{!mg:%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (vax)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Nonzero if compiling code that Unix assembler can assemble.  */\n+#define TARGET_UNIX_ASM (target_flags & 1)\n+\n+/* Nonzero if compiling with VAX-11 \"C\" style structure alignment */\n+#define\tTARGET_VAXC_ALIGNMENT (target_flags & 2)\n+\n+/* Nonzero if compiling with `G'-format floating point */\n+#define TARGET_G_FLOAT (target_flags & 4)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"unix\", 1},  \\\n+    {\"gnu\", -1},  \\\n+    {\"vaxc-alignment\", 2}, \\\n+    {\"g\", 4}, \\\n+    {\"g-float\", 4}, \\\n+    {\"d\", -4},\t\\\n+    {\"d-float\", -4}, \\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Default target_flags if no switches specified.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 1\n+#endif\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the vax.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is not true on the vax.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* This is not true on the vax.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY (TARGET_VAXC_ALIGNMENT ? 8 : 32)\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS (! TARGET_VAXC_ALIGNMENT)\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* No structure field wants to be aligned rounder than this.  */\n+#define BIGGEST_FIELD_ALIGNMENT (TARGET_VAXC_ALIGNMENT ? 8 : 32)\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* #define STRICT_ALIGNMENT */\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the vax, these are the AP, FP, SP and PC.  */\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On the vax, all registers are one word long.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the vax, all registers can hold all modes.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Vax pc is overloaded on a register.  */\n+#define PC_REGNUM 15\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 14\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 13\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 12\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 1\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The vax has only one kind of registers, so NO_REGS and ALL_REGS\n+   are the only classes.  */\n+\n+enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS,\n+   don't give it a different class number; just make it an alias.  */\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0xffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) ALL_REGS\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS ALL_REGS\n+#define BASE_REG_CLASS ALL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   `I' is the constant zero.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'I' ? (VALUE) == 0\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. \n+\n+   `G' is a floating-point zero.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'G' ? ((VALUE) == CONST0_RTX (DFmode)\t\t\\\n+\t\t || (VALUE) == CONST0_RTX (SFmode))\t\\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the vax, this is always the size of MODE in words,\n+   since all registers are the same size.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if longjmp restores from saved registers\n+   rather than from what setjmp saved.  */\n+#define LONGJMP_RESTORE_FROM_STACK\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the vax, -(sp) pushes only the bytes of the operands.  */\n+#define PUSH_ROUNDING(BYTES) (BYTES)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 4\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the Vax, the RET insn always pops all the args for any function.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) (SIZE)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the Vax the return value is in R0 regardless.  */   \n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the Vax the return value is in R0 regardless.  */   \n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the Vax, R0 is the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the Vax, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the vax, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the vax, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the vax all args are pushed.  */   \n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+       mask |= 1 << regno;\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.word 0x%x\\n\", mask);\t\t\t\\\n+  MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\t\t\t\t\\\n+  if ((SIZE) >= 64) fprintf (FILE, \"\\tmovab %d(sp),sp\\n\", -SIZE);\\\n+  else if (SIZE) fprintf (FILE, \"\\tsubl2 $%d,sp\\n\", (SIZE)); }\n+\n+/* vms.h redefines this.  */\n+#define MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tmovab LP%d,r0\\n\\tjsb mcount\\n\", (LABELNO));\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\ttstl LPBX0\\n\\tjneq LPI%d\\n\\tpushal LPBX0\\n\\tcalls $1,__bb_init_func\\nLPI%d:\\n\",  \\\n+\t   LABELNO, LABELNO);\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  This is a real pain in the\n+   sphincter on a VAX, since we do not want to change any of the bits in the\n+   processor status word.  The way it is done here, it is pushed onto the stack\n+   before any flags have changed, and then the stack is fixed up to account for\n+   the fact that the instruction to restore the flags only reads a word.\n+   It may seem a bit clumsy, but at least it works.\n+*/\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+  fprintf (FILE, \"\\tmovpsl -(sp)\\n\\tmovw (sp),2(sp)\\n\\taddl2 $2,sp\\n\\taddl2 $1,LPBX2+%d\\n\\tbicpsw $255\\n\\tbispsw (sp)+\\n\", \\\n+\t\t4 * BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+/* #define FUNCTION_EPILOGUE(FILE, SIZE)  */\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the Vax, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n+   macro doesn't matter.  But it must be defined.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0;\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the vax, the trampoline contains an entry mask and two instructions:\n+     .word NN\n+     movl $STATIC,r0   (store the functions static chain)\n+     jmp  *$FUNCTION   (jump to function code at address FUNCTION)  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x8fd0));\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_BYTE  (FILE, 0x50+STATIC_CHAIN_REGNUM);\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x9f17));\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 15\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+/* We copy the register-mask from the function's pure code\n+   to the start of the trampoline.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, TRAMP),\t\t\t\t\\\n+\t\t  gen_rtx (MEM, HImode, FNADDR));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), CXT);\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 11)),\t\\\n+\t\t  plus_constant (FNADDR, 2));\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT\n+/* #define HAVE_POST_DECREMENT */\n+\n+#define HAVE_PRE_DECREMENT\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 1\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) 1\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+/* Zero if this contains a (CONST (PLUS (SYMBOL_REF) (...))) and the\n+   symbol in the SYMBOL_REF is an external symbol.  */\n+\n+#define INDIRECTABLE_CONSTANT_P(X) \\\n+ (! (GET_CODE ((X)) == CONST\t\t\t\t\t\\\n+     && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\\\n+     && GET_CODE (XEXP (XEXP ((X), 0), 0)) == SYMBOL_REF\t\\\n+     && SYMBOL_REF_FLAG (XEXP (XEXP ((X), 0), 0))))\n+\n+/* Re-definition of CONSTANT_ADDRESS_P, which is true only when there\n+   are no SYMBOL_REFs for external symbols present.  */\n+\n+#define INDIRECTABLE_CONSTANT_ADDRESS_P(X)   \t\t\t\t\\\n+  (GET_CODE (X) == LABEL_REF \t\t\t\t\t\t\\\n+   || (GET_CODE (X) == SYMBOL_REF && !SYMBOL_REF_FLAG (X))\t\t\\\n+   || (GET_CODE (X) == CONST && INDIRECTABLE_CONSTANT_P(X))\t\t\\\n+   || GET_CODE (X) == CONST_INT)\n+\n+\n+/* Non-zero if X is an address which can be indirected.  External symbols\n+   could be in a sharable image library, so we disallow those.  */\n+\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (INDIRECTABLE_CONSTANT_ADDRESS_P (X) \t\t\t\t\t\\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 1))))\n+\n+#else /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n+\n+#define INDIRECTABLE_CONSTANT_ADDRESS_P(X) CONSTANT_ADDRESS_P(X)\n+\n+/* Non-zero if X is an address which can be indirected.  */\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n+\n+#endif /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n+\n+/* Go to ADDR if X is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (xfoob) == REG) goto ADDR;\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\t\\\n+  if (INDIRECTABLE_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\\\n+  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == MEM && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n+      && GET_CODE (xfoob) == REG && REG_OK_FOR_BASE_P (xfoob))\t\t\\\n+    goto ADDR; }\n+\n+/* 1 if PROD is either a reg times size of mode MODE\n+   or just a reg, if MODE is just one byte.\n+   This macro's expansion uses the temporary variables xfoo0 and xfoo1\n+   that must be declared in the surrounding context.  */\n+#define INDEX_TERM_P(PROD, MODE)   \\\n+(GET_MODE_SIZE (MODE) == 1\t\t\t\t\t\t\\\n+ ? (GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n+ : (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n+    &&\t\t\t\t\t\t\t\t\t\\\n+    (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n+     ((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n+       && INTVAL (xfoo0) == GET_MODE_SIZE (MODE)\t\t\t\\\n+       && GET_CODE (xfoo1) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n+      ||\t\t\t\t\t\t\t\t\\\n+      (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n+       && INTVAL (xfoo1) == GET_MODE_SIZE (MODE)\t\t\t\\\n+       && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_INDEX_P (xfoo0))))))\n+\n+/* Go to ADDR if X is the sum of a register\n+   and a valid index term for mode MODE.  */\n+#define GO_IF_REG_PLUS_INDEX(X, MODE, ADDR)\t\\\n+{ register rtx xfooa;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && (xfooa = XEXP (X, 1),\t\t\t\t\t\\\n+\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n+\t  && (xfooa = XEXP (X, 0),\t\t\t\t\t\\\n+\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n+\tgoto ADDR; } }\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ register rtx xfoo, xfoo0, xfoo1;\t\t\t\t\t\\\n+  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { /* Handle <address>[index] represented with index-sum outermost */\\\n+      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 1), ADDR); }\t\t\\\n+      xfoo = XEXP (X, 1);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 0), ADDR); }\t\t\\\n+      /* Handle offset(reg)[index] with offset added outermost */\t\\\n+      if (INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 1), MODE, ADDR); }\t\t\\\n+      if (INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 0), MODE, ADDR); } } }\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the vax, nothing needs to be done.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the VAX, the predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand)\n+   and all indexed address depend thus (because the index scale factor\n+   is the length of the operand).  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n+     goto LABEL; \t\t\t\t\t\t\t\\\n+   if (GET_CODE (ADDR) == PLUS)\t\t\t\t\t\t\\\n+     { if (CONSTANT_ADDRESS_P (XEXP (ADDR, 0))\t\t\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == REG);\t\t\t\\\n+       else if (CONSTANT_ADDRESS_P (XEXP (ADDR, 1))\t\t\t\\\n+\t\t&& GET_CODE (XEXP (ADDR, 0)) == REG);\t\t\t\\\n+       else goto LABEL; }}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE HImode\n+\n+/* Define this if the case instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+#define CASE_DROPS_THROUGH\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* This machine doesn't use IEEE floats.  */\n+\n+#define TARGET_FLOAT_FORMAT VAX_FLOAT_FORMAT\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    /* Constant zero is super cheap due to clr instruction.  */\t\\\n+    if ((RTX) == const0_rtx) return 0;\t\t\t\t\\\n+    /* Constants of +/- 1 should also be super cheap since\t\\\n+       may be used in decl/incl/aob/sob insns.  */\t\t\\\n+    if ((RTX) == const1_rtx || (RTX) == constm1_rtx) return 0;\t\\\n+    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\n+/* On most VAX models, shift are almost as expensive as multiplies, so\n+   we'd rather use multiply unless it can be done in an extremely small\n+   sequence.  */\n+#define RTX_COSTS(RTX,CODE) \\\n+ case LSHIFT:\t\\\n+ case ASHIFT:\t\\\n+ case ASHIFTRT:\t\\\n+ case LSHIFTRT:\t\\\n+ case ROTATE:\t\\\n+ case ROTATERT:\t\\\n+  return COSTS_N_INSNS (4);\n+\n+/* Specify the cost of a branch insn; roughly the number of extra insns that\n+   should be added to avoid a branch.\n+\n+   Branches are extremely cheap on the VAX while the shift insns often\n+   used to replace branches can be expensive.  */\n+\n+#define BRANCH_COST 0\n+\n+/*\n+ * We can use the BSD C library routines for the libgcc calls that are\n+ * still generated, since that's what they boil down to anyways.\n+ */\n+\n+#define UDIVSI3_LIBCALL \"*udiv\"\n+#define UMODSI3_LIBCALL \"*urem\"\n+\n+/* Check a `double' value for validity for a particular machine mode.  */\n+\n+/* note that it is very hard to accidently create a number that fits in a\n+   double but not in a float, since their ranges are almost the same */\n+#define CHECK_FLOAT_VALUE(mode, d) \\\n+  if ((mode) == SFmode) \\\n+    { \\\n+      if ((d) > 1.7014117331926444e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = 1.7014117331926444e+38; } \\\n+      else if ((d) < -1.7014117331926444e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = -1.7014117331926444e+38; } \\\n+      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+    }\n+\n+/* For future reference:\n+   D Float: 9 bit, sign magnitude, excess 128 binary exponent\n+            normalized 56 bit fraction, redundant bit not represented\n+            approximately 16 decimal digits of precision\n+\n+   The values to use if we trust decimal to binary conversions:\n+#define MAX_D_FLOAT 1.7014118346046923e+38\n+#define MIN_D_FLOAT .29387358770557188e-38\n+\n+   G float: 12 bit, sign magnitude, excess 1024 binary exponent\n+            normalized 53 bit fraction, redundant bit not represented\n+            approximately 15 decimal digits precision\n+\n+   The values to use if we trust decimal to binary conversions:\n+#define MAX_G_FLOAT .898846567431157e+308\n+#define MIN_G_FLOAT .556268464626800e-308\n+*/\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the vax.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n+    { if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\t\\\n+\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (EXP)) != PC)\t\t\t\\\n+\t{ cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n+\t  cc_status.value2 = SET_SRC (EXP); } }\t\t\t\\\n+  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n+\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (SET_SRC (XVECEXP (EXP, 0, 0))) == CALL)\t\\\n+\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC) \\\n+\t{ cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n+\t  cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); } } \\\n+  /* PARALLELs whose first element sets the PC are aob, sob insns.\t\\\n+     They do change the cc's.  So drop through and forget the cc's.  */ \\\n+  else CC_STATUS_INIT;\t\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n+    cc_status.value2 = 0;\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n+    cc_status.value2 = 0; }\n+/* Actual condition, one line up, should be that value2's address\n+   depends on value1, but that is too much of a pain.  */\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n+{ if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n+    return NO_OV;\t\t\t\t\t\t\\\n+  return NORMAL; }\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) fprintf (FILE, \"#NO_APP\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n+ \"r9\", \"r10\", \"r11\", \"ap\", \"fp\", \"sp\", \"pc\"}\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* How to renumber registers for dbx and gdb.\n+   Vax needs no change in the numeration.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* This is the char to use for continuation (in case we need to turn\n+   continuation back on).  */\n+\n+#define DBX_CONTIN_CHAR '?'\n+\n+/* Don't use the `xsfoo;' construct in DBX output; this system\n+   doesn't support it.  */\n+\n+#define DBX_NO_XREFS\n+\n+/* Output the .stabs for a C `static' variable in the data section.  */\n+#define DBX_STATIC_STAB_DATA_SECTION\n+\n+/* Vax specific: which type character is used for type double?  */\n+\n+#define ASM_DOUBLE_CHAR (TARGET_G_FLOAT ? 'g' : 'd')\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .dfloat or .gfloat, depending.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.%cfloat 0%c%.20e\\n\", ASM_DOUBLE_CHAR, \\\n+\t\t\t\t\t  ASM_DOUBLE_CHAR, (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tpushl %s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovl (sp)+,%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The Vax does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'.\n+   On the Vax, the codes used are:\n+   `#', indicating that either `d' or `g' should be printed,\n+   depending on whether we're using dfloat or gfloat.\n+   `C', indicating the reverse of the condition name specified by the\n+   operand.\n+   `P', indicating one plus a constant operand\n+   `N', indicating the one's complement of a constant operand\n+   `H', indicating the low-order 16 bits of the one's complement of a constant\n+   `B', similarly for the low-order 8 bits.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '#')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ extern char *rev_cond_name ();\t\t\t\t\t\\\n+  if (CODE == '#') fputc (ASM_DOUBLE_CHAR, FILE);\t\t\t\\\n+  else if (CODE == 'C')\t\t\t\t\t\t\t\\\n+    fputs (rev_cond_name (X), FILE);\t\t\t\t\t\\\n+  else if (CODE == 'P' && GET_CODE (X) == CONST_INT)\t\t\t\\\n+    fprintf (FILE, \"$%d\", INTVAL (X) + 1);\t\t\t\t\\\n+  else if (CODE == 'N' && GET_CODE (X) == CONST_INT)\t\t\t\\\n+    fprintf (FILE, \"$%d\", ~ INTVAL (X));\t\t\t\t\\\n+  /* rotl instruction cannot deal with negative arguments.  */\t\t\\\n+  else if (CODE == 'R' && GET_CODE (X) == CONST_INT)\t\t\t\\\n+    fprintf (FILE, \"$%d\", 32 - INTVAL (X));\t\t\t\t\\\n+  else if (CODE == 'H' && GET_CODE (X) == CONST_INT)\t\t\t\\\n+    fprintf (FILE, \"$%d\", 0xffff & ~ INTVAL (X));\t\t\t\\\n+  else if (CODE == 'B' && GET_CODE (X) == CONST_INT)\t\t\t\\\n+    fprintf (FILE, \"$%d\", 0xff & ~ INTVAL (X));\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"$0%c%.20e\", ASM_DOUBLE_CHAR, u.d); }\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-vax.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+ print_operand_address (FILE, ADDR)"}, {"sha": "6fc91968e652de3f1e3d2b20bed005fba43144cd", "filename": "gcc/config/vax/vax.md", "status": "added", "additions": 1845, "deletions": 0, "changes": 1845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab835497c9a339a644a752a4b0a061d1370a00f1/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=ab835497c9a339a644a752a4b0a061d1370a00f1", "patch": "@@ -0,0 +1,1845 @@\n+;;- Machine description for GNU compiler, Vax Version\n+;;   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- Instruction patterns.  When multiple patterns apply,\n+;;- the first one in the file is chosen.\n+;;-\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+;;-\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"tstl %0\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"tstw %0\")\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"tstb %0\")\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"general_operand\" \"gF\"))]\n+  \"\"\n+  \"tst%# %0\")\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"general_operand\" \"gF\"))]\n+  \"\"\n+  \"tstf %0\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpl %0,%1\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpw %0,%1\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpb %0,%1\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"general_operand\" \"gF\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"cmp%# %0,%1\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"general_operand\" \"gF\")\n+\t\t (match_operand:SF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"cmpf %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitl %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:HI (match_operand:HI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitw %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:QI (match_operand:QI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitb %0,%1\")\n+\n+;; The vax has no sltu or sgeu patterns, but does have two-operand\n+;; add/subtract with carry.  This is still better than the alternative.\n+;; Since the cc0-using insn cannot be separated from the cc0-setting insn,\n+;; and the two are created independently, we can't just use a define_expand\n+;; to try to optimize this.  (The \"movl\" and \"clrl\" insns alter the cc0\n+;; flags, but leave the carry flag alone, but that can't easily be expressed.)\n+;;\n+;; Several two-operator combinations could be added to make slightly more\n+;; optimal code, but they'd have to cover all combinations of plus and minus\n+;; using match_dup.  If you want to do this, I'd suggest changing the \"sgeu\"\n+;; pattern to something like (minus (const_int 1) (ltu ...)), so fewer\n+;; patterns need to be recognized.\n+;; -- Ken Raeburn (Raeburn@Watch.COM) 24 August 1991.\n+\n+(define_insn \"sltu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=ro\")\n+\t(ltu (cc0) (const_int 0)))]\n+  \"\"\n+  \"clrl %0\\;adwc $0,%0\")\n+\n+(define_insn \"sgeu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=ro\")\n+\t(geu (cc0) (const_int 0)))]\n+  \"\"\n+  \"movl $1,%0\\;sbwc $0,%0\")\n+\f\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,g\")\n+\t(match_operand:DF 1 \"general_operand\" \"G,gF\"))]\n+  \"\"\n+  \"@\n+   clr%# %0\n+   mov%# %1,%0\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,g\")\n+\t(match_operand:SF 1 \"general_operand\" \"G,gF\"))]\n+  \"\"\n+  \"@\n+   clrf %0\n+   movf %1,%0\")\n+\n+;; Some vaxes don't support this instruction.\n+;;(define_insn \"movti\"\n+;;  [(set (match_operand:TI 0 \"general_operand\" \"=g\")\n+;;\t(match_operand:TI 1 \"general_operand\" \"g\"))]\n+;;  \"\"\n+;;  \"movh %1,%0\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g,g\")\n+\t(match_operand:DI 1 \"general_operand\" \"I,g\"))]\n+  \"\"\n+  \"@\n+   clrq %0\n+   movq %1,%0\")\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operand:SI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx link;\n+  if (operands[1] == const1_rtx\n+      && (link = find_reg_note (insn, REG_WAS_0, 0))\n+      /* Make sure the insn that stored the 0 is still present.  */\n+      && ! INSN_DELETED_P (XEXP (link, 0))\n+      && GET_CODE (XEXP (link, 0)) != NOTE\n+      /* Make sure cross jumping didn't happen here.  */\n+      && no_labels_between_p (XEXP (link, 0), insn))\n+    /* Fastest way to change a 0 to a 1.  */\n+    return \\\"incl %0\\\";\n+  if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+    {\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushab %a1\\\";\n+      return \\\"movab %a1,%0\\\";\n+    }\n+  /* this is slower than a movl, except when pushing an operand */\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrl %0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && (unsigned) INTVAL (operands[1]) >= 64)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if ((unsigned)(~i) < 64)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, ~i);\n+\t  return \\\"mcoml %1,%0\\\";\n+\t}\n+      if ((unsigned)i < 127)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, 63);\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, i-63);\n+\t  return \\\"addl3 %2,%1,%0\\\";\n+\t}\n+      /* trading speed for space */\n+      if ((unsigned)i < 0x100)\n+\treturn \\\"movzbl %1,%0\\\";\n+      if (i >= -0x80 && i < 0)\n+\treturn \\\"cvtbl %1,%0\\\";\n+      if ((unsigned)i < 0x10000)\n+\treturn \\\"movzwl %1,%0\\\";\n+      if (i >= -0x8000 && i < 0)\n+\treturn \\\"cvtwl %1,%0\\\";\n+    }\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pushl %1\\\";\n+  return \\\"movl %1,%0\\\";\n+}\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx link;\n+  if (operands[1] == const1_rtx\n+      && (link = find_reg_note (insn, REG_WAS_0, 0))\n+      /* Make sure the insn that stored the 0 is still present.  */\n+      && ! INSN_DELETED_P (XEXP (link, 0))\n+      && GET_CODE (XEXP (link, 0)) != NOTE\n+      /* Make sure cross jumping didn't happen here.  */\n+      && no_labels_between_p (XEXP (link, 0), insn))\n+    /* Fastest way to change a 0 to a 1.  */\n+    return \\\"incw %0\\\";\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrw %0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && (unsigned) INTVAL (operands[1]) >= 64)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if ((unsigned)((~i) & 0xffff) < 64)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~i) & 0xffff);\n+\t  return \\\"mcomw %1,%0\\\";\n+\t}\n+      if ((unsigned)(i & 0xffff) < 127)\n+\t{\n+\t   operands[1] = gen_rtx (CONST_INT, VOIDmode, 63);\n+\t   operands[2] = gen_rtx (CONST_INT, VOIDmode, (i-63) & 0xffff);\n+\t   return \\\"addw3 %2,%1,%0\\\";\n+\t}\n+      /* this is a lot slower, and only saves 1 measly byte! */\n+      /* if ((unsigned)i < 0x100)\n+\t   return \\\"movzbw %1,%0\\\"; */\n+      /* if (i >= -0x80 && i < 0)\n+\t   return \\\"cvtbw %1,%0\\\"; */\n+    }\n+  return \\\"movw %1,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrb %0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && (unsigned) INTVAL (operands[1]) >= 64)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if ((unsigned)((~i) & 0xff) < 64)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~i) & 0xff);\n+\t  return \\\"mcomb %1,%0\\\";\n+\t}\n+    }\n+  return \\\"movb %1,%0\\\";\n+}\")\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it won't successfully combine with anything.\n+(define_insn \"movstrhi\"\n+  [(set (match_operand:BLK 0 \"general_operand\" \"=g\")\n+\t(match_operand:BLK 1 \"general_operand\" \"g\"))\n+   (use (match_operand:HI 2 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))]\n+  \"\"\n+  \"movc3 %2,%1,%0\")\n+\f\n+;; Extension and truncation insns.\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtlb %1,%0\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtlw %1,%0\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtwb %1,%0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtwl %1,%0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtbw %1,%0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtbl %1,%0\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g\")\n+\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"cvtf%# %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g\")\n+\t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"cvt%#f %1,%0\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzwl %1,%0\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzbw %1,%0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzbl %1,%0\")\n+\f\n+;; Fix-to-float conversion insns.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtlf %1,%0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtl%# %1,%0\")\n+\n+(define_insn \"floathisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g\")\n+\t(float:SF (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtwf %1,%0\")\n+\n+(define_insn \"floathidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g\")\n+\t(float:DF (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtw%# %1,%0\")\n+\n+(define_insn \"floatqisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g\")\n+\t(float:SF (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtbf %1,%0\")\n+\n+(define_insn \"floatqidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g\")\n+\t(float:DF (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"cvtb%# %1,%0\")\n+\f\n+;; Float-to-fix conversion insns.\n+\n+(define_insn \"fix_truncsfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvtfb %1,%0\")\n+\n+(define_insn \"fix_truncsfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvtfw %1,%0\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvtfl %1,%0\")\n+\n+(define_insn \"fix_truncdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvt%#b %1,%0\")\n+\n+(define_insn \"fix_truncdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvt%#w %1,%0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n+  \"\"\n+  \"cvt%#l %1,%0\")\n+\f\n+;;- All kinds of add instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,g,g\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"0,gF,gF\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"gF,0,gF\")))]\n+  \"\"\n+  \"@\n+   add%#2 %2,%0\n+   add%#2 %1,%0\n+   add%#3 %1,%2,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,g,g\")\n+\t(plus:SF (match_operand:SF 1 \"general_operand\" \"0,gF,gF\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"gF,0,gF\")))]\n+  \"\"\n+  \"@\n+   addf2 %2,%0\n+   addf2 %1,%0\n+   addf3 %1,%2,%0\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incl %0\\\";\n+      if (operands[2] == constm1_rtx)\n+\treturn \\\"decl %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subl2 $%n2,%0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) INTVAL (operands[2]) >= 64\n+\t  && GET_CODE (operands[1]) == REG)\n+\treturn \\\"movab %c2(%1),%0\\\";\n+      return \\\"addl2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addl2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subl3 $%n2,%1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) INTVAL (operands[2]) >= 64\n+      && GET_CODE (operands[1]) == REG)\n+    {\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushab %c2(%1)\\\";\n+      return \\\"movab %c2(%1),%0\\\";\n+    }\n+  return \\\"addl3 %1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incw %0\\\";\n+      if (operands[2] == constm1_rtx)\n+\treturn \\\"decw %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subw2 $%n2,%0\\\";\n+      return \\\"addw2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addw2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subw3 $%n2,%1,%0\\\";\n+  return \\\"addw3 %1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incb %0\\\";\n+      if (operands[2] == constm1_rtx)\n+\treturn \\\"decb %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subb2 $%n2,%0\\\";\n+      return \\\"addb2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addb2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subb3 $%n2,%1,%0\\\";\n+  return \\\"addb3 %1,%2,%0\\\";\n+}\")\n+\n+;; The add-with-carry (adwc) instruction only accepts two operands.\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro>,ro>\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,ro>\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"Fro,F\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx low[3];\n+  char *pattern;\n+  int carry = 1;\n+\n+  split_quadword_operands (operands, low, 3);\n+  /* Add low parts.  */\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (low[2] == const0_rtx)\n+\t/* Should examine operand, punt if not POST_INC.  */\n+\tpattern = \\\"tstl %0\\\", carry = 0;\n+      else if (low[2] == const1_rtx)\n+        pattern = \\\"incl %0\\\";\n+      else\n+        pattern = \\\"addl2 %2,%0\\\";\n+    }\n+  else\n+    {\n+      if (low[2] == const0_rtx)\n+\tpattern = \\\"movl %1,%0\\\", carry = 0;\n+      else\n+\tpattern = \\\"addl3 %2,%1,%0\\\";\n+    }\n+  if (pattern)\n+    output_asm_insn (pattern, low);\n+  if (!carry)\n+    /* If CARRY is 0, we don't have any carry value to worry about.  */\n+    return OUT_FCN (CODE_FOR_addsi3) (operands, insn);\n+  /* %0 = C + %1 + %2 */\n+  if (!rtx_equal_p (operands[0], operands[1]))\n+    output_asm_insn ((operands[1] == const0_rtx\n+\t\t      ? \\\"clrl %0\\\"\n+\t\t      : \\\"movl %1,%0\\\"), operands);\n+  return \\\"adwc %2,%0\\\";\n+}\")\n+\f\n+;;- All kinds of subtract instructions.\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,g\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0,gF\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"gF,gF\")))]\n+  \"\"\n+  \"@\n+   sub%#2 %2,%0\n+   sub%#3 %2,%1,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,g\")\n+\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0,gF\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"gF,gF\")))]\n+  \"\"\n+  \"@\n+   subf2 %2,%0\n+   subf3 %2,%1,%0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   subl2 %2,%0\n+   subl3 %2,%1,%0\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   subw2 %2,%0\n+   subw3 %2,%1,%0\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   subb2 %2,%0\n+   subb3 %2,%1,%0\")\n+\n+;; The subtract-with-carry (sbwc) instruction only takes two operands.\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=or>,or>\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,or>\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"For,F\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx low[3];\n+  char *pattern;\n+  int carry = 1;\n+\n+  split_quadword_operands (operands, low, 3);\n+  /* Subtract low parts.  */\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (low[2] == const0_rtx)\n+\tpattern = 0, carry = 0;\n+      else if (low[2] == constm1_rtx)\n+\tpattern = \\\"decl %0\\\";\n+      else\n+\tpattern = \\\"subl2 %2,%0\\\";\n+    }\n+  else\n+    {\n+      if (low[2] == constm1_rtx)\n+\tpattern = \\\"decl %0\\\";\n+      else if (low[2] == const0_rtx)\n+\tpattern = OUT_FCN (CODE_FOR_movsi) (low, insn), carry = 0;\n+      else\n+\tpattern = \\\"subl3 %2,%1,%0\\\";\n+    }\n+  if (pattern)\n+    output_asm_insn (pattern, low);\n+  if (carry)\n+    {\n+      if (!rtx_equal_p (operands[0], operands[1]))\n+\treturn \\\"movl %1,%0\\;sbwc %2,%0\\\";\n+      return \\\"sbwc %2,%0\\\";\n+      /* %0 = %2 - %1 - C */\n+    }\n+  return OUT_FCN (CODE_FOR_subsi3) (operands, insn);\n+}\")\n+\f\n+;;- Multiply instructions.\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,g,g\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"0,gF,gF\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"gF,0,gF\")))]\n+  \"\"\n+  \"@\n+   mul%#2 %2,%0\n+   mul%#2 %1,%0\n+   mul%#3 %1,%2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,g,g\")\n+\t(mult:SF (match_operand:SF 1 \"general_operand\" \"0,gF,gF\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"gF,0,gF\")))]\n+  \"\"\n+  \"@\n+   mulf2 %2,%0\n+   mulf2 %1,%0\n+   mulf3 %1,%2,%0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g,g\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   mull2 %2,%0\n+   mull2 %1,%0\n+   mull3 %1,%2,%0\")\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g,\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   mulw2 %2,%0\n+   mulw2 %1,%0\n+   mulw3 %1,%2,%0\")\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g,g\")\n+\t(mult:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   mulb2 %2,%0\n+   mulb2 %1,%0\n+   mulb3 %1,%2,%0\")\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(mult:DI (sign_extend:DI\n+\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t (sign_extend:DI\n+\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"g\"))))]\n+  \"\"\n+  \"emul %1,%2,$0,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(plus:DI\n+\t (mult:DI (sign_extend:DI\n+\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t  (sign_extend:DI\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"g\")))\n+\t (sign_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"g\"))))]\n+  \"\"\n+  \"emul %1,%2,%3,%0\")\n+\n+;; 'F' constraint means type CONST_DOUBLE\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(plus:DI\n+\t (mult:DI (sign_extend:DI\n+\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t  (sign_extend:DI\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"g\")))\n+\t (match_operand:DI 3 \"immediate_operand\" \"F\")))]\n+  \"GET_CODE (operands[3]) == CONST_DOUBLE \n+    && CONST_DOUBLE_HIGH (operands[3]) == (CONST_DOUBLE_LOW (operands[3]) >> 31)\"\n+  \"*\n+{\n+  if (CONST_DOUBLE_HIGH (operands[3]))\n+    operands[3] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (operands[3]));\n+  return \\\"emul %1,%2,%3,%0\\\";\n+}\")\n+\f\n+;;- Divide instructions.\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,g\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"0,gF\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"gF,gF\")))]\n+  \"\"\n+  \"@\n+   div%#2 %2,%0\n+   div%#3 %2,%1,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,g\")\n+\t(div:SF (match_operand:SF 1 \"general_operand\" \"0,gF\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"gF,gF\")))]\n+  \"\"\n+  \"@\n+   divf2 %2,%0\n+   divf3 %2,%1,%0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   divl2 %2,%0\n+   divl3 %2,%1,%0\")\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g\")\n+\t(div:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   divw2 %2,%0\n+   divw3 %2,%1,%0\")\n+\n+(define_insn \"divqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g\")\n+\t(div:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"@\n+   divb2 %2,%0\n+   divb3 %2,%1,%0\")\n+\n+;This is left out because it is very slow;\n+;we are better off programming around the \"lack\" of this insn.\n+;(define_insn \"divmoddisi4\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+;\t(div:SI (match_operand:DI 1 \"general_operand\" \"g\")\n+;\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\n+;   (set (match_operand:SI 3 \"general_operand\" \"=g\")\n+;\t(mod:SI (match_operand:DI 1 \"general_operand\" \"g\")\n+;\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+;  \"\"\n+;  \"ediv %2,%1,%0,%3\")\n+\f\n+;; Bit-and on the vax is done with a clear-bits insn.\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    operands[1] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[1]));\n+  else\n+    operands[1] = expand_unop (SImode, one_cmpl_optab, operands[1], 0, 1);\n+}\")\n+\n+(define_expand \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"g\"))\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  rtx op = operands[1];\n+  if (GET_CODE (op) == CONST_INT)\n+    operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t   ((1 << 16) - 1) & ~INTVAL (op));\n+  else\n+    operands[1] = expand_unop (HImode, one_cmpl_optab, op, 0, 1);\n+}\")\n+\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"g\"))\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  rtx op = operands[1];\n+  if (GET_CODE (op) == CONST_INT)\n+    operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t   ((1 << 8) - 1) & ~INTVAL (op));\n+  else\n+    operands[1] = expand_unop (QImode, one_cmpl_optab, op, 0, 1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g,g\"))\n+\t\t(match_operand:SI 2 \"general_operand\" \"0,g\")))]\n+  \"\"\n+  \"@\n+   bicl2 %1,%0\n+   bicl3 %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g\")\n+\t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"g,g\"))\n+\t\t(match_operand:HI 2 \"general_operand\" \"0,g\")))]\n+  \"\"\n+  \"@\n+   bicw2 %1,%0\n+   bicw3 %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g\")\n+\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"g,g\"))\n+\t\t(match_operand:QI 2 \"general_operand\" \"0,g\")))]\n+  \"\"\n+  \"@\n+   bicb2 %1,%0\n+   bicb3 %1,%2,%0\")\n+\n+;; The following used to be needed because constant propagation can\n+;; create them starting from the bic insn patterns above.  This is no\n+;; longer a problem.  However, having these patterns allows optimization\n+;; opportunities in combine.c.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"n,n\")))]\n+  \"\"\n+  \"@\n+   bicl2 %N2,%0\n+   bicl3 %N2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"n,n\")))]\n+  \"\"\n+  \"@\n+   bicw2 %H2,%0\n+   bicw3 %H2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n+\t\t(match_operand:QI 2 \"const_int_operand\" \"n,n\")))]\n+  \"\"\n+  \"@\n+   bicb2 %B2,%0\n+   bicb3 %B2,%1,%0\")\n+\f\n+;;- Bit set instructions.\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g,g\")\n+\t(ior:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   bisl2 %2,%0\n+   bisl2 %1,%0\n+   bisl3 %2,%1,%0\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g,g\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   bisw2 %2,%0\n+   bisw2 %1,%0\n+   bisw3 %2,%1,%0\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g,g\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   bisb2 %2,%0\n+   bisb2 %1,%0\n+   bisb3 %2,%1,%0\")\n+\n+;;- xor instructions.\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g,g\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   xorl2 %2,%0\n+   xorl2 %1,%0\n+   xorl3 %2,%1,%0\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,g,g\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   xorw2 %2,%0\n+   xorw2 %1,%0\n+   xorw3 %2,%1,%0\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,g,g\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n+  \"\"\n+  \"@\n+   xorb2 %2,%0\n+   xorb2 %1,%0\n+   xorb3 %2,%1,%0\")\n+\f\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"mneg%# %1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g\")\n+\t(neg:SF (match_operand:SF 1 \"general_operand\" \"gF\")))]\n+  \"\"\n+  \"mnegf %1,%0\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegl %1,%0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegw %1,%0\")\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegb %1,%0\")\n+\f\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcoml %1,%0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcomw %1,%0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcomb %1,%0\")\n+\f\n+;; Arithmetic right shift on the vax works by negating the shift count,\n+;; then emitting a right shift with the shift count negated.  This means\n+;; that all actual shift counts in the RTL will be positive.  This \n+;; prevents converting shifts to ZERO_EXTRACTs with negative positions,\n+;; which isn't valid.\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"ashl $%n2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"ashl %2,%1,%0\")\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[2] == const1_rtx && rtx_equal_p (operands[0], operands[1]))\n+    return \\\"addl2 %0,%0\\\";\n+  if (GET_CODE (operands[1]) == REG\n+      && GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+      if (i == 1)\n+\treturn \\\"addl3 %1,%1,%0\\\";\n+      if (i == 2)\n+\treturn \\\"moval 0[%1],%0\\\";\n+      if (i == 3)\n+\treturn \\\"movad 0[%1],%0\\\";\n+    }\n+  return \\\"ashl %2,%1,%0\\\";\n+}\")\n+\n+;; Arithmetic right shift on the vax works by negating the shift count.\n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"ashq %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"ashq %2,%1,%0\")\n+\n+;; Rotate right on the vax works by negating the shift count.\n+(define_expand \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"rotl %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"rotl $%R2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"rotl %2,%1,%0\")\n+\n+;This insn is probably slower than a multiply and an add.\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+;\t(mult:SI (plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+;\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+;\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+;  \"\"\n+;  \"index %1,$0x80000000,$0x7fffffff,%3,%2,%0\")\n+\f\n+;; Special cases of bit-field insns which we should\n+;; recognize in preference to the general case.\n+;; These handle aligned 8-bit and 16-bit fields,\n+;; which can usually be done with move instructions.\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+ro\")\n+\t\t\t (match_operand:QI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n+   \"(INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n+   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n+   && (GET_CODE (operands[0]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[0], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[0]))\n+    {\n+      if (INTVAL (operands[2]) != 0)\n+\treturn \\\"insv %3,%2,%1,%0\\\";\n+    }\n+  else\n+    operands[0]\n+      = adj_offsettable_operand (operands[0], INTVAL (operands[2]) / 8);\n+\n+  if (INTVAL (operands[1]) == 8)\n+    return \\\"movb %3,%0\\\";\n+  return \\\"movw %3,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=&g\")\n+\t(zero_extract:SI (match_operand:SI 1 \"general_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (GET_CODE (operands[1]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    {\n+      if (INTVAL (operands[3]) != 0)\n+\treturn \\\"extzv %3,%2,%1,%0\\\";\n+    }\n+  else\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"movzbl %1,%0\\\";\n+  return \\\"movzwl %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:SI 1 \"general_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (GET_CODE (operands[1]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    {\n+      if (INTVAL (operands[3]) != 0)\n+\treturn \\\"extv %3,%2,%1,%0\\\";\n+    }\n+  else\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"cvtbl %1,%0\\\";\n+  return \\\"cvtwl %1,%0\\\";\n+}\")\n+\f\n+;; Register-only SImode cases of bit-field insns.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (sign_extract:SI (match_operand:SI 0 \"nonmemory_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpv %2,%1,%0,%3\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (zero_extract:SI (match_operand:SI 0 \"nonmemory_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpzv %2,%1,%0,%3\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonmemory_operand\" \"r\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"extv %3,%2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonmemory_operand\" \"r\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"extzv %3,%2,%1,%0\")\n+\n+;; Non-register cases.\n+;; nonimmediate_operand is used to make sure that mode-ambiguous cases\n+;; don't match these (and therefore match the cases above instead).\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (sign_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpv %2,%1,%0,%3\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpzv %2,%1,%0,%3\")\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"extv %3,%2,%1,%0\")\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(zero_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"extzv %3,%2,%1,%0\")\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"+g\")\n+\t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"insv %3,%2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"insv %3,%2,%1,%0\")\n+\f\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jbr %l0\")\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jeql %l0\")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jneq %l0\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgtr %l0\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgtru %l0\")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlss %l0\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlssu %l0\")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgeq %l0\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgequ %l0\")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jleq %l0\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlequ %l0\")\n+\n+;; Recognize reversed jumps.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0)\n+\t\t\t\t       (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"j%C0 %l1\") ; %C0 negates condition\n+\f\n+;; Recognize jbs, jlbs, jbc and jlbc instructions.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"g,g\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"@\n+   jlbs %0,%l2\n+   jbs %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"g,g\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"@\n+   jlbc %0,%l2\n+   jbc %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"@\n+   jlbs %0,%l2\n+   jbs %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"@\n+   jlbc %0,%l2\n+   jbc %1,%0,%l2\")\n+\f\n+;; Subtract-and-jump and Add-and-jump insns.\n+;; These are not used when output is for the Unix assembler\n+;; because it does not know how to modify them to reach far.\n+\n+;; Normal sob insns.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (gt (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (const_int 1))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"!TARGET_UNIX_ASM\"\n+  \"jsobgtr %0,%l1\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ge (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (const_int 1))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"!TARGET_UNIX_ASM\"\n+  \"jsobgeq %0,%l1\")\n+\n+;; Normal aob insns.  Define a version for when operands[1] is a constant.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (lt (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"!TARGET_UNIX_ASM\"\n+  \"jaoblss %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (lt (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"!TARGET_UNIX_ASM && GET_CODE (operands[1]) == CONST_INT\"\n+  \"jaoblss %P1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (le (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"!TARGET_UNIX_ASM\"\n+  \"jaobleq %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (le (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"!TARGET_UNIX_ASM && GET_CODE (operands[1]) == CONST_INT\"\n+  \"jaobleq %P1,%0,%l2\")\n+\n+;; Something like a sob insn, but compares against -1.\n+;; This finds `while (foo--)' which was changed to `while (--foo != -1)'.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"general_operand\" \"g\")\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"decl %0\\;jgequ %l1\")\n+\f\n+;; Note that operand 1 is total size of args, in bytes,\n+;; and what the call insn wants is the number of words.\n+(define_insn \"call_pop\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t (match_operand:QI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 14) (plus:SI (reg:SI 14)\n+\t\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) > 255 * 4)\n+    /* Vax `calls' really uses only one byte of #args, so pop explicitly.  */\n+    return \\\"calls $0,%0\\;addl2 %1,sp\\\";\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[1]) + 3)/ 4);\n+  return \\\"calls %1,%0\\\";\n+\")\n+\n+(define_insn \"call_value_pop\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (set (reg:SI 14) (plus:SI (reg:SI 14)\n+\t\t\t     (match_operand:SI 4 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) > 255 * 4)\n+    /* Vax `calls' really uses only one byte of #args, so pop explicitly.  */\n+    return \\\"calls $0,%1\\;addl2 %2,sp\\\";\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[2]) + 3)/ 4);\n+  return \\\"calls %2,%1\\\";\n+\")\n+\n+;; Define another set of these for the case of functions with no\n+;; operands.  In that case, combine may simplify the adjustment of sp.\n+(define_insn \"\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t (match_operand:QI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 14) (reg:SI 14))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) > 255 * 4)\n+    /* Vax `calls' really uses only one byte of #args, so pop explicitly.  */\n+    return \\\"calls $0,%0\\;addl2 %1,sp\\\";\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[1]) + 3)/ 4);\n+  return \\\"calls %1,%0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (set (reg:SI 14) (reg:SI 14))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) > 255 * 4)\n+    /* Vax `calls' really uses only one byte of #args, so pop explicitly.  */\n+    return \\\"calls $0,%1\\;addl2 %2,sp\\\";\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[2]) + 3)/ 4);\n+  return \\\"calls %2,%1\\\";\n+\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+  \"ret\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"general_operand\" \"r\"))]\n+  \"(GET_CODE (operands[0]) != MEM || offsettable_memref_p (operands[0]))\"\n+  \"jmp (%0)\")\n+\n+(define_insn \"casesi\"\n+  [(set (pc)\n+\t(if_then_else (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t\t   (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t      (plus:SI (sign_extend:SI\n+\t\t\t\t(mem:HI\n+\t\t\t\t (plus:SI (pc)\n+\t\t\t\t\t  (mult:SI (minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t     (match_dup 1))\n+\t\t\t\t\t\t   (const_int 2)))))\n+\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))]\n+  \"\"\n+  \"casel %0,%1,%2\")\n+\n+;; This used to arise from the preceding by simplification\n+;; if operand 1 is zero.  Perhaps it is no longer necessary.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t   (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t      (plus:SI (sign_extend:SI\n+\t\t\t\t(mem:HI\n+\t\t\t\t (plus:SI (pc)\n+\t\t\t\t\t  (mult:SI (minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t     (const_int 0))\n+\t\t\t\t\t\t   (const_int 2)))))\n+\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))]\n+  \"\"\n+  \"casel %0,$0,%1\")\n+\f\n+;;- load or push effective address \n+;; These come after the move and add/sub patterns\n+;; because we don't want pushl $1 turned into pushad 1.\n+;; or addl3 r1,r2,r3 turned into movab 0(r1)[r2],r3.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:QI 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushab %a1\n+   movab %a1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:HI 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushaw %a1\n+   movaw %a1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:SI 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushal %a1\n+   moval %a1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:DI 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushaq %a1\n+   movaq %a1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:SF 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushaf %a1\n+   movaf %a1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=<,g\")\n+\t(match_operand:DF 1 \"address_operand\" \"p,p\"))]\n+  \"\"\n+  \"@\n+   pushad %a1\n+   movad %a1,%0\")\n+\f\n+;; These used to be peepholes, but it is more straightforward to do them\n+;; as single insns.  However, we must force the output to be a register\n+;; if it is not an offsettable address so that we know that we can assign\n+;; to it twice. \n+\n+;; If we had a good way of evaluating the relative costs, these could be\n+;; machine-independent.\n+\n+;; Optimize   extzv ...,z;    andl2 ...,z\n+;; or\t      ashl ...,z;     andl2 ...,z\n+;; with other operands constant.  This is what the combiner converts the\n+;; above sequences to before attempting to recognize the new insn.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=ro\")\n+\t(and:SI (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[3]) & ~((1 << (32 - INTVAL (operands[2]))) - 1)) == 0\"\n+  \"*\n+{\n+  unsigned long mask1 = INTVAL (operands[3]);\n+  unsigned long mask2 = (1 << (32 - INTVAL (operands[2]))) - 1;\n+\n+  if ((mask1 & mask2) != mask1)\n+    operands[3] = gen_rtx (CONST_INT, VOIDmode, mask1 & mask2);\n+\n+  return \\\"rotl %R2,%1,%0\\;bicl2 %N3,%0\\\";\n+}\")\n+\n+;; left-shift and mask\n+;; The only case where `ashl' is better is if the mask only turns off\n+;; bits that the ashl would anyways, in which case it should have been\n+;; optimized away.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=ro\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t\t   (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t INTVAL (operands[3]) & ~((1 << INTVAL (operands[2])) - 1));\n+  return \\\"rotl %2,%1,%0\\;bicl2 %N3,%0\\\";\n+}\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}