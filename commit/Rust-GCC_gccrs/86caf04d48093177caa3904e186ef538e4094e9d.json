{"sha": "86caf04d48093177caa3904e186ef538e4094e9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjYWYwNGQ0ODA5MzE3N2NhYTM5MDRlMTg2ZWY1MzhlNDA5NGU5ZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-03-05T10:17:40Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-03-05T10:17:40Z"}, "message": "cse.c (cse_end_of_basic_block): Make static.\n\n2004-02-18  Paolo Bonzini <bonzini@gnu.org>\n\n\t* cse.c (cse_end_of_basic_block): Make static.\n\t* local-alloc.c (function_invariant_p): Move to\n\treload1.c.\n\t* loop.c (libcall_other_reg, record_excess_regs):\n\tMake static.\n\t* reload1.c (function_invariant_p): Moved here\n\tfrom local-alloc.c, made static.\n\t* rtl.h (cse_end_of_basic_block, function_invariant_p,\n\tlibcall_other_reg, record_excess_regs): Remove\n\tdeclarations.\n\nFrom-SVN: r78960", "tree": {"sha": "e25808a224115fb6cb5f5a75d510945a3104eb09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e25808a224115fb6cb5f5a75d510945a3104eb09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86caf04d48093177caa3904e186ef538e4094e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86caf04d48093177caa3904e186ef538e4094e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86caf04d48093177caa3904e186ef538e4094e9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86caf04d48093177caa3904e186ef538e4094e9d/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0fe265e2c15a06650afe13d598e4f4b83fd96d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fe265e2c15a06650afe13d598e4f4b83fd96d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0fe265e2c15a06650afe13d598e4f4b83fd96d6"}], "stats": {"total": 66, "additions": 42, "deletions": 24}, "files": [{"sha": "04774a596f6157d66924c9c1c4be9e1b3963c36f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86caf04d48093177caa3904e186ef538e4094e9d", "patch": "@@ -1,3 +1,16 @@\n+2004-03-05  Paolo Bonzini <bonzini@gnu.org>\n+\n+\t* cse.c (cse_end_of_basic_block): Make static.\n+\t* local-alloc.c (function_invariant_p): Move to\n+\treload1.c.\n+\t* loop.c (libcall_other_reg, record_excess_regs):\n+\tMake static.\n+\t* reload1.c (function_invariant_p): Moved here\n+\tfrom local-alloc.c, made static.\n+\t* rtl.h (cse_end_of_basic_block, function_invariant_p,\n+\tlibcall_other_reg, record_excess_regs): Remove\n+\tdeclarations.\n+\n 2004-03-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/m32r/m32r.c (signed_comparison_operator): Add a"}, {"sha": "27732e4c41ffe8dc42b5a2800ebd6a751b45d012", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=86caf04d48093177caa3904e186ef538e4094e9d", "patch": "@@ -639,6 +639,8 @@ static void record_jump_equiv (rtx, int);\n static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n static void cse_insn (rtx, rtx);\n+static void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n+\t\t\t\t    int, int, int);\n static int addr_affects_sp_p (rtx);\n static void invalidate_from_clobbers (rtx);\n static rtx cse_process_notes (rtx, rtx);\n@@ -6759,7 +6761,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n    the current block.  The incoming structure's branch path, if any, is used\n    to construct the output branch path.  */\n \n-void\n+static void\n cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t\t\tint follow_jumps, int after_loop, int skip_blocks)\n {"}, {"sha": "1802d093a69b61e962d59724bc4d99d42be8f924", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=86caf04d48093177caa3904e186ef538e4094e9d", "patch": "@@ -759,27 +759,6 @@ memref_used_between_p (rtx memref, rtx start, rtx end)\n   return 0;\n }\n \f\n-/* Return nonzero if the rtx X is invariant over the current function.  */\n-/* ??? Actually, the places this is used in reload expect exactly what\n-   is tested here, and not everything that is function invariant.  In\n-   particular, the frame pointer and arg pointer are special cased;\n-   pic_offset_table_rtx is not, and this will cause aborts when we\n-   go to spill these things to memory.  */\n-\n-int\n-function_invariant_p (rtx x)\n-{\n-  if (CONSTANT_P (x))\n-    return 1;\n-  if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n-    return 1;\n-  if (GET_CODE (x) == PLUS\n-      && (XEXP (x, 0) == frame_pointer_rtx || XEXP (x, 0) == arg_pointer_rtx)\n-      && CONSTANT_P (XEXP (x, 1)))\n-    return 1;\n-  return 0;\n-}\n-\n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are set once\n    from a single constant).  Lower their priority for a register."}, {"sha": "5d458cbabc8c717ddc7e90d26f1205fa8cae218f", "filename": "gcc/loop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=86caf04d48093177caa3904e186ef538e4094e9d", "patch": "@@ -263,6 +263,8 @@ static void replace_call_address (rtx, rtx, rtx);\n #endif\n static rtx skip_consec_insns (rtx, int);\n static int libcall_benefit (rtx);\n+static rtx libcall_other_reg (rtx, rtx);\n+static void record_excess_regs (rtx, rtx, rtx *);\n static void ignore_some_movables (struct loop_movables *);\n static void force_movables (struct loop_movables *);\n static void combine_movables (struct loop_movables *, struct loop_regs *);\n@@ -1231,7 +1233,7 @@ scan_loop (struct loop *loop, int flags)\n /* Add elements to *OUTPUT to record all the pseudo-regs\n    mentioned in IN_THIS but not mentioned in NOT_IN_THIS.  */\n \n-void\n+static void\n record_excess_regs (rtx in_this, rtx not_in_this, rtx *output)\n {\n   enum rtx_code code;\n@@ -1285,7 +1287,7 @@ record_excess_regs (rtx in_this, rtx not_in_this, rtx *output)\n    If there are none, return 0.\n    If there are one or more, return an EXPR_LIST containing all of them.  */\n \n-rtx\n+static rtx\n libcall_other_reg (rtx insn, rtx equiv)\n {\n   rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);"}, {"sha": "ce7bf83526e5cfde079db5b1130acbcce13370bd", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86caf04d48093177caa3904e186ef538e4094e9d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=86caf04d48093177caa3904e186ef538e4094e9d", "patch": "@@ -402,6 +402,7 @@ static int reload_reg_free_for_value_p (int, int, int, enum reload_type,\n \t\t\t\t\trtx, rtx, int, int);\n static int free_for_value_p (int, enum machine_mode, int, enum reload_type,\n \t\t\t     rtx, rtx, int, int);\n+static int function_invariant_p (rtx);\n static int reload_reg_reaches_end_p (unsigned int, int, enum reload_type);\n static int allocate_reload_reg (struct insn_chain *, int, int);\n static int conflicts_with_override (rtx);\n@@ -4976,6 +4977,27 @@ free_for_value_p (int regno, enum machine_mode mode, int opnum,\n   return 1;\n }\n \n+/* Return nonzero if the rtx X is invariant over the current function.  */\n+/* ??? Actually, the places where we use this expect exactly what\n+ * is tested here, and not everything that is function invariant.  In\n+ * particular, the frame pointer and arg pointer are special cased;\n+ * pic_offset_table_rtx is not, and this will cause aborts when we\n+ *             go to spill these things to memory.  */\n+\n+static int\n+function_invariant_p (rtx x)\n+{\n+  if (CONSTANT_P (x))\n+    return 1;\n+  if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n+    return 1;\n+  if (GET_CODE (x) == PLUS\n+      && (XEXP (x, 0) == frame_pointer_rtx || XEXP (x, 0) == arg_pointer_rtx)\n+      && CONSTANT_P (XEXP (x, 1)))\n+    return 1;\n+  return 0;\n+}\n+\n /* Determine whether the reload reg X overlaps any rtx'es used for\n    overriding inheritance.  Return nonzero if so.  */\n "}]}