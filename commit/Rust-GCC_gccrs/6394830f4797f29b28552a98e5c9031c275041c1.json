{"sha": "6394830f4797f29b28552a98e5c9031c275041c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM5NDgzMGY0Nzk3ZjI5YjI4NTUyYTk4ZTVjOTAzMWMyNzUwNDFjMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-08-04T15:47:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-08-04T15:47:42Z"}, "message": "re PR bootstrap/49964 (Bootstrap failed with AVX turned on)\n\nPR target/49964\n        * config/i386/i386.c (ix86_expand_call): Don't create nested\n        PARALLELs for TARGET_VZEROUPPER.\n        (ix86_split_call_vzeroupper): Fix extraction of the original call.\n        * config/i386/i386.md (*call_rex64_ms_sysv_vzeroupper): Don't\n        recognize nested PARALLELs.\n        (*call_pop_vzeroupper, *sibcall_pop_vzeroupper,\n        *call_value_rex64_ms_sysv_vzeroupper, *call_value_pop_vzeroupper,\n        *sibcall_value_pop_vzeroupper): Likewise.\n\nFrom-SVN: r177408", "tree": {"sha": "9f00b2ef572e517f62a0eebd2963eb1b74e5e3c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f00b2ef572e517f62a0eebd2963eb1b74e5e3c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6394830f4797f29b28552a98e5c9031c275041c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6394830f4797f29b28552a98e5c9031c275041c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6394830f4797f29b28552a98e5c9031c275041c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6394830f4797f29b28552a98e5c9031c275041c1/comments", "author": null, "committer": null, "parents": [{"sha": "276e7ed0242aaa390159bb8e2e3b57f70face83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276e7ed0242aaa390159bb8e2e3b57f70face83a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276e7ed0242aaa390159bb8e2e3b57f70face83a"}], "stats": {"total": 203, "additions": 108, "deletions": 95}, "files": [{"sha": "7b7967755886126db851909647320a6822fc00fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6394830f4797f29b28552a98e5c9031c275041c1", "patch": "@@ -1,3 +1,15 @@\n+2011-08-04  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/49964\n+\t* config/i386/i386.c (ix86_expand_call): Don't create nested\n+\tPARALLELs for TARGET_VZEROUPPER.\n+\t(ix86_split_call_vzeroupper): Fix extraction of the original call.\n+\t* config/i386/i386.md (*call_rex64_ms_sysv_vzeroupper): Don't\n+\trecognize nested PARALLELs.\n+\t(*call_pop_vzeroupper, *sibcall_pop_vzeroupper,\n+\t*call_value_rex64_ms_sysv_vzeroupper, *call_value_pop_vzeroupper,\n+\t*sibcall_value_pop_vzeroupper): Likewise.\n+\n 2011-08-04  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/49968"}, {"sha": "a7f8ee5bdf3e92e447fe0a5f56ceb6aedaf1726a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6394830f4797f29b28552a98e5c9031c275041c1", "patch": "@@ -21501,7 +21501,17 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t  rtx callarg2,\n \t\t  rtx pop, bool sibcall)\n {\n+  /* We need to represent that SI and DI registers are clobbered\n+     by SYSV calls.  */\n+  static int clobbered_registers[] = {\n+\tXMM6_REG, XMM7_REG, XMM8_REG,\n+\tXMM9_REG, XMM10_REG, XMM11_REG,\n+\tXMM12_REG, XMM13_REG, XMM14_REG,\n+\tXMM15_REG, SI_REG, DI_REG\n+  };\n+  rtx vec[ARRAY_SIZE (clobbered_registers) + 3];\n   rtx use = NULL, call;\n+  unsigned int vec_len;\n \n   if (pop == const0_rtx)\n     pop = NULL;\n@@ -21545,52 +21555,40 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       fnaddr = gen_rtx_MEM (QImode, copy_to_mode_reg (Pmode, fnaddr));\n     }\n \n+  vec_len = 0;\n   call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n   if (retval)\n     call = gen_rtx_SET (VOIDmode, retval, call);\n+  vec[vec_len++] = call;\n+\n   if (pop)\n     {\n       pop = gen_rtx_PLUS (Pmode, stack_pointer_rtx, pop);\n       pop = gen_rtx_SET (VOIDmode, stack_pointer_rtx, pop);\n-      call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, pop));\n+      vec[vec_len++] = pop;\n     }\n+\n   if (TARGET_64BIT_MS_ABI\n       && (!callarg2 || INTVAL (callarg2) != -2))\n     {\n-      /* We need to represent that SI and DI registers are clobbered\n-\t by SYSV calls.  */\n-      static int clobbered_registers[] = {\n-\tXMM6_REG, XMM7_REG, XMM8_REG,\n-\tXMM9_REG, XMM10_REG, XMM11_REG,\n-\tXMM12_REG, XMM13_REG, XMM14_REG,\n-\tXMM15_REG, SI_REG, DI_REG\n-      };\n-      unsigned int i;\n-      rtx vec[ARRAY_SIZE (clobbered_registers) + 2];\n-      rtx unspec = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, const0_rtx),\n-      \t\t\t\t   UNSPEC_MS_TO_SYSV_CALL);\n+      unsigned i;\n \n-      vec[0] = call;\n-      vec[1] = unspec;\n-      for (i = 0; i < ARRAY_SIZE (clobbered_registers); i++)\n-        vec[i + 2] = gen_rtx_CLOBBER (SSE_REGNO_P (clobbered_registers[i])\n-\t\t\t\t      ? TImode : DImode,\n-\t\t\t\t      gen_rtx_REG\n-\t\t\t\t        (SSE_REGNO_P (clobbered_registers[i])\n-\t\t\t\t\t\t      ? TImode : DImode,\n-\t\t\t\t\t clobbered_registers[i]));\n+      vec[vec_len++] = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t       UNSPEC_MS_TO_SYSV_CALL);\n \n-      call = gen_rtx_PARALLEL (VOIDmode,\n-      \t\t\t       gen_rtvec_v (ARRAY_SIZE (clobbered_registers)\n-\t\t\t       + 2, vec));\n+      for (i = 0; i < ARRAY_SIZE (clobbered_registers); i++)\n+        vec[vec_len++]\n+\t  = gen_rtx_CLOBBER (SSE_REGNO_P (clobbered_registers[i])\n+\t\t\t     ? TImode : DImode,\n+\t\t\t     gen_rtx_REG (SSE_REGNO_P (clobbered_registers[i])\n+\t\t\t\t\t  ? TImode : DImode,\n+\t\t\t\t\t  clobbered_registers[i]));\n     }\n \n   /* Add UNSPEC_CALL_NEEDS_VZEROUPPER decoration.  */\n   if (TARGET_VZEROUPPER)\n     {\n-      rtx unspec;\n       int avx256;\n-\n       if (cfun->machine->callee_pass_avx256_p)\n \t{\n \t  if (cfun->machine->callee_return_avx256_p)\n@@ -21606,15 +21604,13 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       if (reload_completed)\n \temit_insn (gen_avx_vzeroupper (GEN_INT (avx256)));\n       else\n-\t{\n-\t  unspec = gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t   gen_rtvec (1, GEN_INT (avx256)),\n-\t\t\t\t   UNSPEC_CALL_NEEDS_VZEROUPPER);\n-\t  call = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t   gen_rtvec (2, call, unspec));\n-\t}\n+\tvec[vec_len++] = gen_rtx_UNSPEC (VOIDmode,\n+\t\t\t\t\t gen_rtvec (1, GEN_INT (avx256)),\n+\t\t\t\t\t UNSPEC_CALL_NEEDS_VZEROUPPER);\n     }\n \n+  if (vec_len > 1)\n+    call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (vec_len, vec));\n   call = emit_call_insn (call);\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n@@ -21625,9 +21621,20 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n void\n ix86_split_call_vzeroupper (rtx insn, rtx vzeroupper)\n {\n-  rtx call = XVECEXP (PATTERN (insn), 0, 0);\n+  rtx pat = PATTERN (insn);\n+  rtvec vec = XVEC (pat, 0);\n+  int len = GET_NUM_ELEM (vec) - 1;\n+\n+  /* Strip off the last entry of the parallel.  */\n+  gcc_assert (GET_CODE (RTVEC_ELT (vec, len)) == UNSPEC);\n+  gcc_assert (XINT (RTVEC_ELT (vec, len), 1) == UNSPEC_CALL_NEEDS_VZEROUPPER);\n+  if (len == 1)\n+    pat = RTVEC_ELT (vec, 0);\n+  else\n+    pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (len, &RTVEC_ELT (vec, 0)));\n+\n   emit_insn (gen_avx_vzeroupper (vzeroupper));\n-  emit_call_insn (call);\n+  emit_call_insn (pat);\n }\n \n /* Output the assembly for a call instruction.  */"}, {"sha": "245ee54785c03acd3bdb03c46eeba258dfa2c3eb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6394830f4797f29b28552a98e5c9031c275041c1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6394830f4797f29b28552a98e5c9031c275041c1", "patch": "@@ -11050,22 +11050,21 @@\n   [(set_attr \"type\" \"call\")])\n \n (define_insn_and_split \"*call_rex64_ms_sysv_vzeroupper\"\n-  [(parallel\n-    [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rzw\"))\n-\t   (match_operand 1 \"\" \"\"))\n-     (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n-     (clobber (reg:TI XMM6_REG))\n-     (clobber (reg:TI XMM7_REG))\n-     (clobber (reg:TI XMM8_REG))\n-     (clobber (reg:TI XMM9_REG))\n-     (clobber (reg:TI XMM10_REG))\n-     (clobber (reg:TI XMM11_REG))\n-     (clobber (reg:TI XMM12_REG))\n-     (clobber (reg:TI XMM13_REG))\n-     (clobber (reg:TI XMM14_REG))\n-     (clobber (reg:TI XMM15_REG))\n-     (clobber (reg:DI SI_REG))\n-     (clobber (reg:DI DI_REG))])\n+  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rzw\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n+   (clobber (reg:TI XMM6_REG))\n+   (clobber (reg:TI XMM7_REG))\n+   (clobber (reg:TI XMM8_REG))\n+   (clobber (reg:TI XMM9_REG))\n+   (clobber (reg:TI XMM10_REG))\n+   (clobber (reg:TI XMM11_REG))\n+   (clobber (reg:TI XMM12_REG))\n+   (clobber (reg:TI XMM13_REG))\n+   (clobber (reg:TI XMM14_REG))\n+   (clobber (reg:TI XMM15_REG))\n+   (clobber (reg:DI SI_REG))\n+   (clobber (reg:DI DI_REG))\n    (unspec [(match_operand 2 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n@@ -11128,12 +11127,11 @@\n })\n \n (define_insn_and_split \"*call_pop_vzeroupper\"\n-  [(parallel\n-    [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lzm\"))\n-\t   (match_operand:SI 1 \"\" \"\"))\n-     (set (reg:SI SP_REG)\n-\t  (plus:SI (reg:SI SP_REG)\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))])\n+  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lzm\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))\n    (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n@@ -11154,12 +11152,11 @@\n   [(set_attr \"type\" \"call\")])\n \n (define_insn_and_split \"*sibcall_pop_vzeroupper\"\n- [(parallel\n-   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"Uz\"))\n-\t  (match_operand 1 \"\" \"\"))\n-     (set (reg:SI SP_REG)\n-\t  (plus:SI (reg:SI SP_REG)\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))])\n+  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"Uz\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))\n    (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n@@ -11248,23 +11245,22 @@\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn_and_split \"*call_value_rex64_ms_sysv_vzeroupper\"\n-  [(parallel\n-    [(set (match_operand 0 \"\" \"\")\n-\t  (call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rzw\"))\n-\t\t(match_operand 2 \"\" \"\")))\n-     (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n-     (clobber (reg:TI XMM6_REG))\n-     (clobber (reg:TI XMM7_REG))\n-     (clobber (reg:TI XMM8_REG))\n-     (clobber (reg:TI XMM9_REG))\n-     (clobber (reg:TI XMM10_REG))\n-     (clobber (reg:TI XMM11_REG))\n-     (clobber (reg:TI XMM12_REG))\n-     (clobber (reg:TI XMM13_REG))\n-     (clobber (reg:TI XMM14_REG))\n-     (clobber (reg:TI XMM15_REG))\n-     (clobber (reg:DI SI_REG))\n-     (clobber (reg:DI DI_REG))])\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rzw\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n+   (clobber (reg:TI XMM6_REG))\n+   (clobber (reg:TI XMM7_REG))\n+   (clobber (reg:TI XMM8_REG))\n+   (clobber (reg:TI XMM9_REG))\n+   (clobber (reg:TI XMM10_REG))\n+   (clobber (reg:TI XMM11_REG))\n+   (clobber (reg:TI XMM12_REG))\n+   (clobber (reg:TI XMM13_REG))\n+   (clobber (reg:TI XMM14_REG))\n+   (clobber (reg:TI XMM15_REG))\n+   (clobber (reg:DI SI_REG))\n+   (clobber (reg:DI DI_REG))\n    (unspec [(match_operand 3 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n@@ -11310,13 +11306,12 @@\n })\n \n (define_insn_and_split \"*call_value_pop_vzeroupper\"\n-  [(parallel\n-    [(set (match_operand 0 \"\" \"\")\n-\t  (call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lzm\"))\n-\t\t(match_operand 2 \"\" \"\")))\n-     (set (reg:SI SP_REG)\n-\t  (plus:SI (reg:SI SP_REG)\n-\t\t   (match_operand:SI 3 \"immediate_operand\" \"i\")))])\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lzm\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))\n    (unspec [(match_operand 4 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n@@ -11338,13 +11333,12 @@\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn_and_split \"*sibcall_value_pop_vzeroupper\"\n- [(parallel\n-   [(set (match_operand 0 \"\" \"\")\n-\t  (call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"Uz\"))\n-\t\t(match_operand 2 \"\" \"\")))\n-     (set (reg:SI SP_REG)\n-\t  (plus:SI (reg:SI SP_REG)\n-\t\t   (match_operand:SI 3 \"immediate_operand\" \"i\")))])\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"Uz\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))\n    (unspec [(match_operand 4 \"const_int_operand\" \"\")]\n    \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n   \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\""}]}