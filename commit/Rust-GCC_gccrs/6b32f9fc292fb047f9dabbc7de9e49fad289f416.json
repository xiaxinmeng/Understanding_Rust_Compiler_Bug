{"sha": "6b32f9fc292fb047f9dabbc7de9e49fad289f416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzMmY5ZmMyOTJmYjA0N2Y5ZGFiYmM3ZGU5ZTQ5ZmFkMjg5ZjQxNg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-03-28T02:52:58Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-03-28T02:52:58Z"}, "message": "Document AIMAG, AINT, ALL\n\nFrom-SVN: r97123", "tree": {"sha": "89423999c64ff3fed8f88411e0569e5e3c0ca155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89423999c64ff3fed8f88411e0569e5e3c0ca155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b32f9fc292fb047f9dabbc7de9e49fad289f416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b32f9fc292fb047f9dabbc7de9e49fad289f416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b32f9fc292fb047f9dabbc7de9e49fad289f416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b32f9fc292fb047f9dabbc7de9e49fad289f416/comments", "author": null, "committer": null, "parents": [{"sha": "7a17ef5e63f029d589de5cb4e499b00cb0f620b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a17ef5e63f029d589de5cb4e499b00cb0f620b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a17ef5e63f029d589de5cb4e499b00cb0f620b5"}], "stats": {"total": 182, "additions": 174, "deletions": 8}, "files": [{"sha": "99671746a88227f30e35fb285348841d24b1e470", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b32f9fc292fb047f9dabbc7de9e49fad289f416/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b32f9fc292fb047f9dabbc7de9e49fad289f416/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6b32f9fc292fb047f9dabbc7de9e49fad289f416", "patch": "@@ -1,3 +1,7 @@\n+2005-03-27  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* intrinsic.texi: Document AIMAG, AINT, ALL\n+\n 2005-03-26  Steven G. Kargl  <kargls@comcast.net>\n \n \t* arith.c (check_result): Fix illogical logic."}, {"sha": "61979dc7f5200bbf38599925fe33b2b4d60033e7", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 170, "deletions": 8, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b32f9fc292fb047f9dabbc7de9e49fad289f416/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b32f9fc292fb047f9dabbc7de9e49fad289f416/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=6b32f9fc292fb047f9dabbc7de9e49fad289f416", "patch": "@@ -39,6 +39,9 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{ACOS}:    ACOS,     Arccosine function\n * @code{ADJUSTL}: ADJUSTL,  Left adjust a string\n * @code{ADJUSTR}: ADJUSTR,  Right adjust a string\n+* @code{AIMAG}:   AIMAG,    Imaginary part of complex number\n+* @code{AINT}:    AINT,     Truncate to a whole number\n+* @code{ALL}:     ALL,      Determine all values are true\n @end menu\n \n @node Introduction\n@@ -339,15 +342,174 @@ end program test_adjustr\n @end table\n \n \n+@node AIMAG\n+@section @code{AIMAG} --- Imaginary part of complex number  \n+@findex @code{AIMAG} intrinsic\n+@findex @code{DIMAG} intrinsic\n+@cindex Imaginary part\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{AIMAG(Z)} yields the imaginary part of complex argument @code{Z}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Type}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = AIMAG(Z)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{Z} @tab The type of the argument shall be @code{COMPLEX(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type real with the\n+kind type parameter of the argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_aimag\n+  complex(4) z4\n+  complex(8) z8\n+  z4 = cmplx(1.e0_4, 0.e0_4)\n+  z8 = cmplx(0.e0_8, 1.e0_8)\n+  print *, aimag(z4), dimag(z8)\n+end program test_aimag\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .24 .24 .24 .24\n+@item Name            @tab Argument            @tab Return type       @tab Option\n+@item @code{DIMAG(Z)} @tab @code{COMPLEX(8) Z} @tab @code{REAL(8)}    @tab f95, gnu\n+@end multitable\n+@end table\n+\n+\n+@node AINT\n+@section @code{AINT} --- Imaginary part of complex number  \n+@findex @code{AINT} intrinsic\n+@findex @code{DINT} intrinsic\n+@cindex whole number\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{AINT(X [, KIND])} truncates its argument to a whole number.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Type}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = AINT(X)} @*\n+@code{X = AINT(X, KIND)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.\n+@item @var{KIND} @tab (Optional) @var{KIND} shall be a scalar integer\n+initialization expression.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type real with the kind type parameter of the\n+argument if the optional @var{KIND} is absence; otherwise, the kind\n+type parameter will be given by @var{KIND}.  If the magnitude of \n+@var{X} is less than one, then @code{AINT(X)} returns zero.  If the\n+magnitude is equal to or greater than one, then it returns the largest\n+whole number that does not exceed its magnitude.  The sign is the same\n+as the sign of @var{X}. \n+\n+@item @emph{Example}:\n+@smallexample\n+program test_aint\n+  real(4) x4\n+  real(8) x8\n+  x4 = 1.234E0_4\n+  x8 = 4.321_8\n+  print *, aint(x4), dint(x8)\n+  x8 = aint(x4,8)\n+end program test_aint\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .24 .24 .24 .24\n+@item Name           @tab Argument         @tab Return type      @tab Option\n+@item @code{DINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab f95, gnu\n+@end multitable\n+@end table\n+\n+\n+@node ALL\n+@section @code{ALL} --- All values in @var{MASK} along @var{DIM} are true \n+  @findex @code{ALL} intrinsic\n+@cindex true values\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ALL(MASK [, DIM])} determines if all the values are true in @var{MASK}\n+in the array along dimension @var{DIM}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Type}:\n+transformational function\n+\n+@item @emph{Syntax}:\n+@code{L = ALL(MASK)} @*\n+@code{L = ALL(MASK, DIM)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and\n+it shall not be scalar.\n+@item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer\n+with a value that lies between one and the rank of @var{MASK}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+@code{ALL(MASK)} returns a scalar value of type @code{LOGICAL(*)} where\n+the kind type parameter is the same as the kind type parameter of\n+@var{MASK}.  If @var{DIM} is present, then @code{ALL(MASK, DIM)} returns\n+an array with the rank of @var{MASK} minus 1.  The shape is determined from\n+the shape of @var{MASK} where the @var{DIM} dimension is elided. \n+\n+@table @asis\n+@item (A)\n+@code{ALL(MASK)} is true if all elements of @var{MASK} are true.\n+It also is true if @var{MASK} has zero size; otherwise, it is false.\n+@item (B)\n+If the rank of @var{MASK} is one, then @code{ALL(MASK,DIM)} is equivalent\n+to @code{ALL(MASK)}.  If the rank is greater than one, then @code{ALL(MASK,DIM)}\n+is determined by applying @code{ALL} to the array sections.\n+@end table\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_all\n+  logical l\n+  l = all((/.true., .true., .true./))\n+  print *, l\n+  call section\n+  contains\n+    subroutine section\n+      integer a(2,3), b(2,3)\n+      a = 1\n+      b = 1\n+      b(2,2) = 2\n+      print *, all(a .eq. b, 1)\n+      print *, all(a .eq. b, 2)\n+    end subroutine section\n+end program test_all\n+@end smallexample\n+@end table\n \n-@comment gen   aimag\n-@comment       dimag \n-@comment \n-@comment gen   aint\n-@comment       dint\n-@comment \n-@comment gen   all\n-@comment \n @comment gen   allocated \n @comment \n @comment gen   anint"}]}