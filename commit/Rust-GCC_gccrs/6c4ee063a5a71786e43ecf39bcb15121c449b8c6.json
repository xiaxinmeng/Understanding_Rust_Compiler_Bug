{"sha": "6c4ee063a5a71786e43ecf39bcb15121c449b8c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM0ZWUwNjNhNWE3MTc4NmU0M2VjZjM5YmNiMTUxMjFjNDQ5YjhjNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-16T22:39:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-16T22:39:45Z"}, "message": "runtime: Don't create threads with a small stack.\n\nWe want to create goroutines with a small stack, at least on\nsystems where split stacks are supported.  We don't need to\ncreate threads with a small stack.\n\nFrom-SVN: r216353", "tree": {"sha": "bc80787210421ca1a94a7a639a8da61ddd21b35c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc80787210421ca1a94a7a639a8da61ddd21b35c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c4ee063a5a71786e43ecf39bcb15121c449b8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4ee063a5a71786e43ecf39bcb15121c449b8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c4ee063a5a71786e43ecf39bcb15121c449b8c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4ee063a5a71786e43ecf39bcb15121c449b8c6/comments", "author": null, "committer": null, "parents": [{"sha": "e4c6530e821ba32c47802cecdb5817995a8b4027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c6530e821ba32c47802cecdb5817995a8b4027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c6530e821ba32c47802cecdb5817995a8b4027"}], "stats": {"total": 55, "additions": 0, "deletions": 55}, "files": [{"sha": "8907c3aa520d7b2e62579ec6e458b2015ea09593", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4ee063a5a71786e43ecf39bcb15121c449b8c6/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4ee063a5a71786e43ecf39bcb15121c449b8c6/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=6c4ee063a5a71786e43ecf39bcb15121c449b8c6", "patch": "@@ -167,15 +167,11 @@ runtime_setmg(M* mp, G* gp)\n \tg = gp;\n }\n \n-// The static TLS size.  See runtime_newm.\n-static int tlssize;\n-\n // Start a new thread.\n static void\n runtime_newosproc(M *mp)\n {\n \tpthread_attr_t attr;\n-\tsize_t stacksize;\n \tsigset_t clear, old;\n \tpthread_t tid;\n \tint ret;\n@@ -185,19 +181,6 @@ runtime_newosproc(M *mp)\n \tif(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0)\n \t\truntime_throw(\"pthread_attr_setdetachstate\");\n \n-\tstacksize = PTHREAD_STACK_MIN;\n-\n-\t// With glibc before version 2.16 the static TLS size is taken\n-\t// out of the stack size, and we get an error or a crash if\n-\t// there is not enough stack space left.  Add it back in if we\n-\t// can, in case the program uses a lot of TLS space.  FIXME:\n-\t// This can be disabled in glibc 2.16 and later, if the bug is\n-\t// indeed fixed then.\n-\tstacksize += tlssize;\n-\n-\tif(pthread_attr_setstacksize(&attr, stacksize) != 0)\n-\t\truntime_throw(\"pthread_attr_setstacksize\");\n-\n \t// Block signals during pthread_create so that the new thread\n \t// starts with signals disabled.  It will enable them in minit.\n \tsigfillset(&clear);\n@@ -306,43 +289,6 @@ runtime_mcall(void (*pfn)(G*))\n \t}\n }\n \n-#ifdef HAVE_DL_ITERATE_PHDR\n-\n-// Called via dl_iterate_phdr.\n-\n-static int\n-addtls(struct dl_phdr_info* info, size_t size __attribute__ ((unused)), void *data)\n-{\n-\tsize_t *total = (size_t *)data;\n-\tunsigned int i;\n-\n-\tfor(i = 0; i < info->dlpi_phnum; ++i) {\n-\t\tif(info->dlpi_phdr[i].p_type == PT_TLS)\n-\t\t\t*total += info->dlpi_phdr[i].p_memsz;\n-\t}\n-\treturn 0;\n-}\n-\n-// Set the total TLS size.\n-\n-static void\n-inittlssize()\n-{\n-\tsize_t total = 0;\n-\n-\tdl_iterate_phdr(addtls, (void *)&total);\n-\ttlssize = total;\n-}\n-\n-#else\n-\n-static void\n-inittlssize()\n-{\n-}\n-\n-#endif\n-\n // Goroutine scheduler\n // The scheduler's job is to distribute ready-to-run goroutines over worker threads.\n //\n@@ -481,7 +427,6 @@ runtime_schedinit(void)\n \tg->m = m;\n \n \tinitcontext();\n-\tinittlssize();\n \n \truntime_sched.maxmcount = 10000;\n \truntime_precisestack = 0;"}]}