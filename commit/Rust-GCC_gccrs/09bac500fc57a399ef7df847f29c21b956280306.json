{"sha": "09bac500fc57a399ef7df847f29c21b956280306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDliYWM1MDBmYzU3YTM5OWVmN2RmODQ3ZjI5YzIxYjk1NjI4MDMwNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-07-28T07:41:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-07-28T07:41:29Z"}, "message": "cfg.c (update_bb_profile_for_threading): Use RDIV.\n\n\n\t* cfg.c (update_bb_profile_for_threading): Use RDIV.\n\t(scale_bbs_frequencies_int): Likewise, assert for possible overflow.\n\t(scale_bbs_frequencies_gcov_type): Be more curefull about overflows and\n\troundoff errors.\n\t* tree-cfg.c (tree_duplicate_sese_region): Use counts for updating\n\tprofile when available.\n\t* update-loopch.c: New testcase.\n\nFrom-SVN: r102466", "tree": {"sha": "fe00ab26a84db5f867ad0e76607a799b23f5a320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe00ab26a84db5f867ad0e76607a799b23f5a320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09bac500fc57a399ef7df847f29c21b956280306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09bac500fc57a399ef7df847f29c21b956280306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09bac500fc57a399ef7df847f29c21b956280306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09bac500fc57a399ef7df847f29c21b956280306/comments", "author": null, "committer": null, "parents": [{"sha": "a71aef0bb317dfa73527e3fd7c4895ca52551901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71aef0bb317dfa73527e3fd7c4895ca52551901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a71aef0bb317dfa73527e3fd7c4895ca52551901"}], "stats": {"total": 137, "additions": 112, "deletions": 25}, "files": [{"sha": "c6b4ecb5c982052819e0d95454a245d0999118ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09bac500fc57a399ef7df847f29c21b956280306/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09bac500fc57a399ef7df847f29c21b956280306/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09bac500fc57a399ef7df847f29c21b956280306", "patch": "@@ -1,4 +1,13 @@\n-2005-07-28 Jan Beulich <jbeulich@novell.com>\n+2005-07-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfg.c (update_bb_profile_for_threading): Use RDIV.\n+\t(scale_bbs_frequencies_int): Likewise, assert for possible overflow.\n+\t(scale_bbs_frequencies_gcov_type): Be more curefull about overflows and\n+\troundoff errors.\n+\t* tree-cfg.c (tree_duplicate_sese_region): Use counts for updating\n+\tprofile when available.\n+\n+2005-07-28  Jan Beulich <jbeulich@novell.com>\n \n \t* config/ia64/ia64.c (ia64_load_pair_ok): New.\n \t(ia64_print_operand): Describe and handle 'X'."}, {"sha": "96441326ac699eb52367a27502fc42b9d3d8f075", "filename": "gcc/cfg.c", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=09bac500fc57a399ef7df847f29c21b956280306", "patch": "@@ -893,11 +893,11 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n     }\n   else if (prob != REG_BR_PROB_BASE)\n     {\n-      int scale = 65536 * REG_BR_PROB_BASE / prob;\n+      int scale = RDIV (65536 * REG_BR_PROB_BASE, prob);\n \n       FOR_EACH_EDGE (c, ei, bb->succs)\n \t{\n-\t  c->probability = (c->probability * scale) / 65536;\n+\t  c->probability = RDIV (c->probability * scale, 65536);\n \t  if (c->probability > REG_BR_PROB_BASE)\n \t    c->probability = REG_BR_PROB_BASE;\n \t}\n@@ -925,16 +925,23 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n     num = 0;\n   if (num > den)\n     return;\n+  /* Assume that the users are producing the fraction from frequencies\n+     that never grow far enought to risk arithmetic overflow.  */\n+  gcc_assert (num < 65536);\n   for (i = 0; i < nbbs; i++)\n     {\n       edge_iterator ei;\n-      bbs[i]->frequency = (bbs[i]->frequency * num) / den;\n+      bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n       bbs[i]->count = RDIV (bbs[i]->count * num, den);\n       FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count = (e->count * num) /den;\n+\te->count = RDIV (e->count * num, den);\n     }\n }\n \n+/* numbers smaller than this value are safe to multiply without getting\n+   64bit overflow.  */\n+#define MAX_SAFE_MULTIPLIER (1 << (sizeof (HOST_WIDEST_INT) * 4 - 1))\n+\n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n    by NUM/DEN, in gcov_type arithmetic.  More accurate than previous\n    function but considerably slower.  */\n@@ -944,15 +951,37 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n {\n   int i;\n   edge e;\n+  gcov_type fraction = RDIV (num * 65536, den);\n \n-  for (i = 0; i < nbbs; i++)\n-    {\n-      edge_iterator ei;\n-      bbs[i]->frequency = (bbs[i]->frequency * num) / den;\n-      bbs[i]->count = RDIV (bbs[i]->count * num, den);\n-      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count = (e->count * num) /den;\n-    }\n+  gcc_assert (fraction >= 0);\n+\n+  if (num < MAX_SAFE_MULTIPLIER)\n+    for (i = 0; i < nbbs; i++)\n+      {\n+\tedge_iterator ei;\n+\tbbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n+\tif (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n+\t  bbs[i]->count = RDIV (bbs[i]->count * num, den);\n+\telse\n+\t  bbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);\n+\tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\t  if (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n+\t    e->count = RDIV (e->count * num, den);\n+\t  else\n+\t    e->count = RDIV (e->count * fraction, 65536);\n+      }\n+   else\n+    for (i = 0; i < nbbs; i++)\n+      {\n+\tedge_iterator ei;\n+\tif (sizeof (gcov_type) > sizeof (int))\n+\t  bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n+\telse\n+\t  bbs[i]->frequency = RDIV (bbs[i]->frequency * fraction, 65536);\n+\tbbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);\n+\tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\t  e->count = RDIV (e->count * fraction, 65536);\n+      }\n }\n \n /* Data structures used to maintain mapping between basic blocks and"}, {"sha": "4eb0e04b1da8e213c9b3cb792efaa67aa73e348e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=09bac500fc57a399ef7df847f29c21b956280306", "patch": "@@ -1,3 +1,7 @@\n+2005-07-28  Jan Hubicka  <jh@suse.cz>\n+\t\n+\t* update-loopch.c: New testcase.\n+\n 2005-07-27  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR rtl-optimization/23047"}, {"sha": "1e5ccaa1021b7cfe1f75d38666c32d2e19a2d9d4", "filename": "gcc/testsuite/gcc.dg/tree-prof/update-loopch.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c?ref=09bac500fc57a399ef7df847f29c21b956280306", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-options \"-O2 -fdump-tree_profile -fdump-tree-optimized\" } */\n+int max = 33333;\n+int a[8];\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < max; i++)\n+    {\n+      a[i % 8]++;\n+    }\n+  return 0;\n+}\n+/* Loop header copying will peel away the initial conditional, so the loop body\n+   is once reached directly from entry point of function, rest via loopback\n+   edge.  */\n+/* { dg-final-use { scan-tree-dump-not \"count:33333\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-tree-dump \"count:33332\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bf25f837e766af1246df232164970b686587f4f7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09bac500fc57a399ef7df847f29c21b956280306/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=09bac500fc57a399ef7df847f29c21b956280306", "patch": "@@ -4246,7 +4246,8 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   edge exit_copy;\n   basic_block *doms;\n   edge redirected;\n-  int total_freq, entry_freq;\n+  int total_freq = 0, entry_freq = 0;\n+  gcov_type total_count = 0, entry_count = 0;\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -4300,19 +4301,42 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \n   n_doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region, doms);\n \n-  total_freq = entry->dest->frequency;\n-  entry_freq = EDGE_FREQUENCY (entry);\n-  /* Fix up corner cases, to avoid division by zero or creation of negative\n-     frequencies.  */\n-  if (total_freq == 0)\n-    total_freq = 1;\n-  else if (entry_freq > total_freq)\n-    entry_freq = total_freq;\n+  if (entry->dest->count)\n+    {\n+      total_count = entry->dest->count;\n+      entry_count = entry->count;\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (entry_count > total_count)\n+\tentry_count = total_count;\n+    }\n+  else\n+    {\n+      total_freq = entry->dest->frequency;\n+      entry_freq = EDGE_FREQUENCY (entry);\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (total_freq == 0)\n+\ttotal_freq = 1;\n+      else if (entry_freq > total_freq)\n+\tentry_freq = total_freq;\n+    }\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop);\n-  scale_bbs_frequencies_int (region, n_region, total_freq - entry_freq,\n-\t\t\t     total_freq);\n-  scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n+  if (total_count)\n+    {\n+      scale_bbs_frequencies_gcov_type (region, n_region,\n+\t\t\t\t       total_count - entry_count,\n+\t\t\t\t       total_count);\n+      scale_bbs_frequencies_gcov_type (region_copy, n_region, entry_count,\n+\t  \t\t\t       total_count);\n+    }\n+  else\n+    {\n+      scale_bbs_frequencies_int (region, n_region, total_freq - entry_freq,\n+\t\t\t\t total_freq);\n+      scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n+    }\n \n   if (copying_header)\n     {"}]}