{"sha": "f916243bde91b7fdca5f6365071d31627e980722", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxNjI0M2JkZTkxYjdmZGNhNWY2MzY1MDcxZDMxNjI3ZTk4MDcyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T12:44:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T12:44:01Z"}, "message": "[multiple changes]\n\n2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch4.adb, gnat1drv.adb, opt.ads, sem_res.adb\n\t(Minimize_Expression_With_Actions): New flag.\n\t(Adjust_Global_Switches): Set Minimize_Expression_With_Actions\n\twhen generating C.\n\t(Resolve_Short_Circuit): Redo previous change\n\tusing Minimize_Expression_With_Actions.\n\t(Expand_N_If_Expression,\n\tExpand_Short_Circuit_Operator): Restore old code to avoid\n\tExpression_With_Actions when Minimize_Expression_With_Actions\n\tis set.\n\n2016-04-18  Vincent Celier  <celier@adacore.com>\n\n\t* s-os_lib.adb (Non_Blocking_Spawn, version with Stdout_File and\n\tStderr_File): Close local file descriptors when no longer needed.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Remove SPARK\n\tmode check that the type of the cursor in an iteration over\n\ta formal container is not volatile. The proper check on the\n\telement type is done elsewhere.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): Do not set a delay freeze on\n\ta subprogram that returns a class-wide type, if the subprogram\n\tis a compilation unit, because otherwise gigi will treat the\n\tsubprogram as external, leading to link errors.\n\nFrom-SVN: r235141", "tree": {"sha": "9f9eaa9288c525e5c6468b08f556f4b4d87da186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9eaa9288c525e5c6468b08f556f4b4d87da186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f916243bde91b7fdca5f6365071d31627e980722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f916243bde91b7fdca5f6365071d31627e980722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f916243bde91b7fdca5f6365071d31627e980722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f916243bde91b7fdca5f6365071d31627e980722/comments", "author": null, "committer": null, "parents": [{"sha": "22071092eda0032c9559d47e1879432ee19926e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22071092eda0032c9559d47e1879432ee19926e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22071092eda0032c9559d47e1879432ee19926e5"}], "stats": {"total": 323, "additions": 254, "deletions": 69}, "files": [{"sha": "9a1aeae53e5d3bc8c90c7573b8bfe6811c3884c0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -1,3 +1,35 @@\n+2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch4.adb, gnat1drv.adb, opt.ads, sem_res.adb\n+\t(Minimize_Expression_With_Actions): New flag.\n+\t(Adjust_Global_Switches): Set Minimize_Expression_With_Actions\n+\twhen generating C.\n+\t(Resolve_Short_Circuit): Redo previous change\n+\tusing Minimize_Expression_With_Actions.\n+\t(Expand_N_If_Expression,\n+\tExpand_Short_Circuit_Operator): Restore old code to avoid\n+\tExpression_With_Actions when Minimize_Expression_With_Actions\n+\tis set.\n+\n+2016-04-18  Vincent Celier  <celier@adacore.com>\n+\n+\t* s-os_lib.adb (Non_Blocking_Spawn, version with Stdout_File and\n+\tStderr_File): Close local file descriptors when no longer needed.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Remove SPARK\n+\tmode check that the type of the cursor in an iteration over\n+\ta formal container is not volatile. The proper check on the\n+\telement type is done elsewhere.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): Do not set a delay freeze on\n+\ta subprogram that returns a class-wide type, if the subprogram\n+\tis a compilation unit, because otherwise gigi will treat the\n+\tsubprogram as external, leading to link errors.\n+\n 2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_res.adb (Resolve_Short_Circuit): Do not use"}, {"sha": "b08ebfe0f919fb0697df1d1c5d594dd128f7cb35", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 202, "deletions": 48, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -5267,31 +5267,59 @@ package body Exp_Ch4 is\n       --  expression, and Sem_Elab circuitry removing it repeatedly.\n \n       if Compile_Time_Known_Value (Cond) then\n-         if Is_True (Expr_Value (Cond)) then\n-            Expr    := Thenx;\n-            Actions := Then_Actions (N);\n-         else\n-            Expr    := Elsex;\n-            Actions := Else_Actions (N);\n-         end if;\n+         declare\n+            function Fold_Known_Value (Cond : Node_Id) return Boolean;\n+            --  Fold at compile time. Assumes condition known.\n+            --  Return True if folding occurred, meaning we're done.\n \n-         Remove (Expr);\n+            ----------------------\n+            -- Fold_Known_Value --\n+            ----------------------\n \n-         if Present (Actions) then\n-            Rewrite (N,\n-              Make_Expression_With_Actions (Loc,\n-                Expression => Relocate_Node (Expr),\n-                Actions    => Actions));\n-            Analyze_And_Resolve (N, Typ);\n-         else\n-            Rewrite (N, Relocate_Node (Expr));\n-         end if;\n+            function Fold_Known_Value (Cond : Node_Id) return Boolean is\n+            begin\n+               if Is_True (Expr_Value (Cond)) then\n+                  Expr    := Thenx;\n+                  Actions := Then_Actions (N);\n+               else\n+                  Expr    := Elsex;\n+                  Actions := Else_Actions (N);\n+               end if;\n \n-         --  Note that the result is never static (legitimate cases of static\n-         --  if expressions were folded in Sem_Eval).\n+               Remove (Expr);\n \n-         Set_Is_Static_Expression (N, False);\n-         return;\n+               if Present (Actions) then\n+\n+                  --  If we want to minimize the use of\n+                  --  Expression_With_Actions, just skip the optimization, it\n+                  --  is not critical for correctness.\n+\n+                  if Minimize_Expression_With_Actions then\n+                     return False;\n+                  end if;\n+\n+                  Rewrite (N,\n+                    Make_Expression_With_Actions (Loc,\n+                      Expression => Relocate_Node (Expr),\n+                      Actions    => Actions));\n+                  Analyze_And_Resolve (N, Typ);\n+\n+               else\n+                  Rewrite (N, Relocate_Node (Expr));\n+               end if;\n+\n+               --  Note that the result is never static (legitimate cases of\n+               --  static if expressions were folded in Sem_Eval).\n+\n+               Set_Is_Static_Expression (N, False);\n+               return True;\n+            end Fold_Known_Value;\n+\n+         begin\n+            if Fold_Known_Value (Cond) then\n+               return;\n+            end if;\n+         end;\n       end if;\n \n       --  If the type is limited, and the back end does not handle limited\n@@ -5423,27 +5451,73 @@ package body Exp_Ch4 is\n \n          --  We now wrap the actions into the appropriate expression\n \n-         if Present (Then_Actions (N)) then\n-            Rewrite (Thenx,\n-              Make_Expression_With_Actions (Sloc (Thenx),\n-                Actions    => Then_Actions (N),\n-                Expression => Relocate_Node (Thenx)));\n+         if Minimize_Expression_With_Actions then\n \n-            Set_Then_Actions (N, No_List);\n-            Analyze_And_Resolve (Thenx, Typ);\n-         end if;\n+            --  If we can't use N_Expression_With_Actions nodes, then we insert\n+            --  the following sequence of actions (using Insert_Actions):\n \n-         if Present (Else_Actions (N)) then\n-            Rewrite (Elsex,\n-              Make_Expression_With_Actions (Sloc (Elsex),\n-                Actions    => Else_Actions (N),\n-                Expression => Relocate_Node (Elsex)));\n+            --      Cnn : typ;\n+            --      if cond then\n+            --         <<then actions>>\n+            --         Cnn := then-expr;\n+            --      else\n+            --         <<else actions>>\n+            --         Cnn := else-expr\n+            --      end if;\n \n-            Set_Else_Actions (N, No_List);\n-            Analyze_And_Resolve (Elsex, Typ);\n-         end if;\n+            --  and replace the if expression by a reference to Cnn\n \n-         return;\n+            Cnn := Make_Temporary (Loc, 'C', N);\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Cnn,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+            New_If :=\n+              Make_Implicit_If_Statement (N,\n+                Condition       => Relocate_Node (Cond),\n+\n+                Then_Statements => New_List (\n+                  Make_Assignment_Statement (Sloc (Thenx),\n+                    Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n+                    Expression => Relocate_Node (Thenx))),\n+\n+                Else_Statements => New_List (\n+                  Make_Assignment_Statement (Sloc (Elsex),\n+                    Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n+                    Expression => Relocate_Node (Elsex))));\n+\n+            Set_Assignment_OK (Name (First (Then_Statements (New_If))));\n+            Set_Assignment_OK (Name (First (Else_Statements (New_If))));\n+\n+            New_N := New_Occurrence_Of (Cnn, Loc);\n+\n+         --  Regular path using Expression_With_Actions\n+\n+         else\n+            if Present (Then_Actions (N)) then\n+               Rewrite (Thenx,\n+                 Make_Expression_With_Actions (Sloc (Thenx),\n+                   Actions    => Then_Actions (N),\n+                   Expression => Relocate_Node (Thenx)));\n+\n+               Set_Then_Actions (N, No_List);\n+               Analyze_And_Resolve (Thenx, Typ);\n+            end if;\n+\n+            if Present (Else_Actions (N)) then\n+               Rewrite (Elsex,\n+                 Make_Expression_With_Actions (Sloc (Elsex),\n+                   Actions    => Else_Actions (N),\n+                   Expression => Relocate_Node (Elsex)));\n+\n+               Set_Else_Actions (N, No_List);\n+               Analyze_And_Resolve (Elsex, Typ);\n+            end if;\n+\n+            return;\n+         end if;\n \n       --  If no actions then no expansion needed, gigi will handle it using the\n       --  same approach as a C conditional expression.\n@@ -11614,6 +11688,31 @@ package body Exp_Ch4 is\n       Shortcut_Ent   : constant Entity_Id := Boolean_Literals (Shortcut_Value);\n       --  If Left = Shortcut_Value then Right need not be evaluated\n \n+      function Make_Test_Expr (Opnd : Node_Id) return Node_Id;\n+      --  For Opnd a boolean expression, return a Boolean expression equivalent\n+      --  to Opnd /= Shortcut_Value.\n+\n+      --------------------\n+      -- Make_Test_Expr --\n+      --------------------\n+\n+      function Make_Test_Expr (Opnd : Node_Id) return Node_Id is\n+      begin\n+         if Shortcut_Value then\n+            return Make_Op_Not (Sloc (Opnd), Opnd);\n+         else\n+            return Opnd;\n+         end if;\n+      end Make_Test_Expr;\n+\n+      --  Local variables\n+\n+      Op_Var : Entity_Id;\n+      --  Entity for a temporary variable holding the value of the operator,\n+      --  used for expansion in the case where actions are present.\n+\n+   --  Start of processing for Expand_Short_Circuit_Operator\n+\n    begin\n       --  Deal with non-standard booleans\n \n@@ -11668,17 +11767,72 @@ package body Exp_Ch4 is\n       if Present (Actions (N)) then\n          Actlist := Actions (N);\n \n-         --  We now use an Expression_With_Actions node for the right operand\n-         --  of the short-circuit form. Note that this solves the traceability\n+         --  The old approach is to expand:\n+\n+         --     left AND THEN right\n+\n+         --  into\n+\n+         --     C : Boolean := False;\n+         --     IF left THEN\n+         --        Actions;\n+         --        IF right THEN\n+         --           C := True;\n+         --        END IF;\n+         --     END IF;\n+\n+         --  and finally rewrite the operator into a reference to C. Similarly\n+         --  for left OR ELSE right, with negated values. Note that this\n+         --  rewrite causes some difficulties for coverage analysis because\n+         --  of the introduction of the new variable C, which obscures the\n+         --  structure of the test.\n+\n+         --  We use this \"old approach\" if Minimize_Expression_With_Actions\n+         --  is True.\n+\n+         if Minimize_Expression_With_Actions then\n+            Op_Var := Make_Temporary (Loc, 'C', Related_Node => N);\n+\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Op_Var,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc),\n+                Expression          =>\n+                  New_Occurrence_Of (Shortcut_Ent, Loc)));\n+\n+            Append_To (Actlist,\n+              Make_Implicit_If_Statement (Right,\n+                Condition       => Make_Test_Expr (Right),\n+                Then_Statements => New_List (\n+                  Make_Assignment_Statement (LocR,\n+                    Name       => New_Occurrence_Of (Op_Var, LocR),\n+                    Expression =>\n+                      New_Occurrence_Of\n+                        (Boolean_Literals (not Shortcut_Value), LocR)))));\n+\n+            Insert_Action (N,\n+              Make_Implicit_If_Statement (Left,\n+                Condition       => Make_Test_Expr (Left),\n+                Then_Statements => Actlist));\n+\n+            Rewrite (N, New_Occurrence_Of (Op_Var, Loc));\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+\n+         --  The new approach (the default) is to use an\n+         --  Expression_With_Actions node for the right operand of the\n+         --  short-circuit form. Note that this solves the traceability\n          --  problems for coverage analysis.\n \n-         Rewrite (Right,\n-           Make_Expression_With_Actions (LocR,\n-             Expression => Relocate_Node (Right),\n-             Actions    => Actlist));\n+         else\n+            Rewrite (Right,\n+              Make_Expression_With_Actions (LocR,\n+                Expression => Relocate_Node (Right),\n+                Actions    => Actlist));\n \n-         Set_Actions (N, No_List);\n-         Analyze_And_Resolve (Right, Standard_Boolean);\n+            Set_Actions (N, No_List);\n+            Analyze_And_Resolve (Right, Standard_Boolean);\n+         end if;\n \n          Adjust_Result_Type (N, Typ);\n          return;\n@@ -11694,8 +11848,8 @@ package body Exp_Ch4 is\n             Set_SCO_Condition (Right, Expr_Value_E (Right) = Standard_True);\n          end if;\n \n-         --  Change (Left and then True), (Left or else False) to Left.\n-         --  Note that we know there are no actions associated with the right\n+         --  Change (Left and then True), (Left or else False) to Left. Note\n+         --  that we know there are no actions associated with the right\n          --  operand, since we just checked for this case above.\n \n          if Expr_Value_E (Right) /= Shortcut_Ent then"}, {"sha": "420482fbcaa98ee3a22741609f9b25dba889f870", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -148,6 +148,7 @@ procedure Gnat1drv is\n       if Generate_C_Code then\n          Modify_Tree_For_C := True;\n          Unnest_Subprogram_Mode := True;\n+         Minimize_Expression_With_Actions := True;\n \n          --  Set operating mode to Generate_Code to benefit from full front-end\n          --  expansion (e.g. generics)."}, {"sha": "ad4ab8155c8e5da588213a85fa150bc0b8ef3a8a", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -1061,6 +1061,12 @@ package Opt is\n    --  GNATMAKE\n    --  Set to True if minimal recompilation mode requested\n \n+   Minimize_Expression_With_Actions : Boolean := False;\n+   --  GNAT\n+   --  If True, minimize the use of N_Expression_With_Actions node.\n+   --  This can be used in particular on some back-ends where this node is\n+   --  difficult to support.\n+\n    Modify_Tree_For_C : Boolean := False;\n    --  GNAT\n    --  If this switch is set True (currently it is set only by -gnatd.V), then"}, {"sha": "92745ba00979573ecaf72b43f9def286331cd59f", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -1867,6 +1867,14 @@ package body System.OS_Lib is\n \n       Result := Non_Blocking_Spawn (Program_Name, Args);\n \n+      --  Close the files just created for the output, as the file descriptors\n+      --  cannot be used anywhere, being local values. It is safe to do that,\n+      --  as the file descriptors have been duplicated to form standard output\n+      --  and standard error of the spawned process.\n+\n+      Close (Stdout_FD);\n+      Close (Stderr_FD);\n+\n       --  Restore the standard output and error\n \n       Dup2 (Saved_Output, Standout);"}, {"sha": "62eea8c6cd9d545385410bf6d1b677d31729f2bc", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -1758,7 +1758,6 @@ package body Sem_Ch5 is\n       Subt      : constant Node_Id    := Subtype_Indication (N);\n       Iter_Name : constant Node_Id    := Name (N);\n \n-      Ent : Entity_Id;\n       Typ : Entity_Id;\n       Bas : Entity_Id;\n \n@@ -2306,28 +2305,13 @@ package body Sem_Ch5 is\n                  Get_Cursor_Type\n                    (Parent (Find_Value_Of_Aspect (Typ, Aspect_Iterable)),\n                     Typ));\n-               Ent := Etype (Def_Id);\n \n             else\n                Set_Etype (Def_Id, Get_Cursor_Type (Typ));\n             end if;\n \n          end if;\n       end if;\n-\n-      --  A loop parameter cannot be effectively volatile (SPARK RM 7.1.3(4)).\n-      --  This check is relevant only when SPARK_Mode is on as it is not a\n-      --  standard Ada legality check.\n-\n-      --  Not clear whether this applies to element iterators, where the\n-      --  cursor is not an explicit entity ???\n-\n-      if SPARK_Mode = On\n-        and then not Of_Present (N)\n-        and then Is_Effectively_Volatile (Ent)\n-      then\n-         Error_Msg_N (\"loop parameter cannot be volatile\", Ent);\n-      end if;\n    end Analyze_Iterator_Specification;\n \n    -------------------"}, {"sha": "17e9fe19fe9b08769d294b4220f8121b9934d758", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -10504,10 +10504,12 @@ package body Sem_Ch6 is\n          Analyze_Return_Type (Related_Nod);\n \n          --  If return type is class-wide, subprogram freezing may be\n-         --  delayed as well.\n+         --  delayed as well, unless the declaration is a compilation unit\n+         --  in which case the freeze node would appear too late.\n \n          if Is_Class_Wide_Type (Etype (Current_Scope))\n            and then not Is_Thunk (Current_Scope)\n+           and then not Is_Compilation_Unit (Current_Scope)\n            and then Nkind (Unit_Declaration_Node (Current_Scope)) =\n              N_Subprogram_Declaration\n          then"}, {"sha": "7cf498de34d51d030cbd764fce938baad967d278", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f916243bde91b7fdca5f6365071d31627e980722/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f916243bde91b7fdca5f6365071d31627e980722", "patch": "@@ -10044,11 +10044,9 @@ package body Sem_Res is\n       --  finalization of transient controlled objects) are fully evaluated\n       --  locally within an expression with actions. This is particularly\n       --  helpful for coverage analysis. However this should not happen in\n-      --  generics. Similarly, we want to minimize use of expression with\n-      --  actions when generating C code, and finalization is not supported\n-      --  in this mode anyway.\n+      --  generics or if Minimize_Expression_With_Actions is set.\n \n-      if Expander_Active and not Generate_C_Code then\n+      if Expander_Active and not Minimize_Expression_With_Actions then\n          declare\n             Reloc_L : constant Node_Id := Relocate_Node (L);\n          begin"}]}