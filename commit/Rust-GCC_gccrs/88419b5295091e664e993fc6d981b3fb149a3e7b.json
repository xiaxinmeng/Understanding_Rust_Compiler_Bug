{"sha": "88419b5295091e664e993fc6d981b3fb149a3e7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg0MTliNTI5NTA5MWU2NjRlOTkzZmM2ZDk4MWIzZmIxNDlhM2U3Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-11-07T06:31:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-11-07T06:31:14Z"}, "message": "[PATCH] Remove more backedge threading support\n\n\t* tree-ssa-threadedge.c (dummy_simplify): Remove.\n\t(thread_around_empty_blocks): Remove backedge_seen_p argument.\n\tIf we thread to a backedge, then return false.  Update recursive\n\tcall to eliminate backedge_seen_p argument.\n\t(thread_through_normal_block): Remove backedge_seen_p argument.\n\tRemove backedge_seen_p argument from calls to\n\tthread_around_empty_blocks.  Remove checks on backedge_seen_p.\n\tIf we thread to a backedge, then return 0.\n\t(thread_across_edge): Remove bookkeeping for backedge_seen.  Don't\n\tpass it to thread_through_normal_block or thread_through_empty_blocks.\n\tFor joiner handling, if we see a backedge, do not try normal\n\tthreading.\n\nFrom-SVN: r229911", "tree": {"sha": "cb5144235434922e5bf66595e3fa1d3005c73a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb5144235434922e5bf66595e3fa1d3005c73a7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88419b5295091e664e993fc6d981b3fb149a3e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88419b5295091e664e993fc6d981b3fb149a3e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88419b5295091e664e993fc6d981b3fb149a3e7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88419b5295091e664e993fc6d981b3fb149a3e7b/comments", "author": null, "committer": null, "parents": [{"sha": "0473915e63175064c9b6c739841bc670c782cdbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0473915e63175064c9b6c739841bc670c782cdbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0473915e63175064c9b6c739841bc670c782cdbd"}], "stats": {"total": 129, "additions": 51, "deletions": 78}, "files": [{"sha": "78dc3f04bdc9ed53daf673505ff2b3937289947b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88419b5295091e664e993fc6d981b3fb149a3e7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88419b5295091e664e993fc6d981b3fb149a3e7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88419b5295091e664e993fc6d981b3fb149a3e7b", "patch": "@@ -1,3 +1,18 @@\n+2015-11-06  Jeff Law <jeff@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (dummy_simplify): Remove.\n+\t(thread_around_empty_blocks): Remove backedge_seen_p argument.\n+\tIf we thread to a backedge, then return false.  Update recursive\n+\tcall to eliminate backedge_seen_p argument.\n+\t(thread_through_normal_block): Remove backedge_seen_p argument.\n+\tRemove backedge_seen_p argument from calls to\n+\tthread_around_empty_blocks.  Remove checks on backedge_seen_p.\n+\tIf we thread to a backedge, then return 0.\n+\t(thread_across_edge): Remove bookkeeping for backedge_seen.  Don't\n+\tpass it to thread_through_normal_block or thread_through_empty_blocks.\n+\tFor joiner handling, if we see a backedge, do not try normal\n+\tthreading.\n+\n 2015-11-06  Abderrazek Zaafrani  <a.zaafrani@samsung.com>\n \n \t* graphite-optimize-isl.c (optimize_isl): Call isl_union_map_is_equal."}, {"sha": "971fc528f635fdbb6c089d9a2fbad5799aaa53e1", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 36, "deletions": 78, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88419b5295091e664e993fc6d981b3fb149a3e7b/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88419b5295091e664e993fc6d981b3fb149a3e7b/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=88419b5295091e664e993fc6d981b3fb149a3e7b", "patch": "@@ -376,17 +376,6 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n   return stmt;\n }\n \n-/* Once we have passed a backedge in the CFG when threading, we do not want to\n-   utilize edge equivalences for simplification purpose.  They are no longer\n-   necessarily valid.  We use this callback rather than the ones provided by\n-   DOM/VRP to achieve that effect.  */\n-static tree\n-dummy_simplify (gimple *stmt1 ATTRIBUTE_UNUSED, gimple *stmt2 ATTRIBUTE_UNUSED,\n-\t\tclass avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED)\n-{\n-  return NULL_TREE;\n-}\n-\n /* Simplify the control statement at the end of the block E->dest.\n \n    To avoid allocating memory unnecessarily, a scratch GIMPLE_COND\n@@ -396,7 +385,7 @@ dummy_simplify (gimple *stmt1 ATTRIBUTE_UNUSED, gimple *stmt2 ATTRIBUTE_UNUSED,\n    a condition using pass specific information.\n \n    Return the simplified condition or NULL if simplification could\n-   not be performed. \n+   not be performed.\n \n    The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n@@ -707,7 +696,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n    return false.\n \n    DUMMY_COND, HANDLE_DOMINATING_ASSERTS and SIMPLIFY are used to\n-   try and simplify the condition at the end of TAKEN_EDGE->dest. \n+   try and simplify the condition at the end of TAKEN_EDGE->dest.\n \n    The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n@@ -718,8 +707,7 @@ thread_around_empty_blocks (edge taken_edge,\n \t\t\t    bool handle_dominating_asserts,\n \t\t\t    pfn_simplify simplify,\n \t\t\t    bitmap visited,\n-\t\t\t    vec<jump_thread_edge *> *path,\n-\t\t\t    bool *backedge_seen_p)\n+\t\t\t    vec<jump_thread_edge *> *path)\n {\n   basic_block bb = taken_edge->dest;\n   gimple_stmt_iterator gsi;\n@@ -754,23 +742,23 @@ thread_around_empty_blocks (edge taken_edge,\n       if (single_succ_p (bb))\n \t{\n \t  taken_edge = single_succ_edge (bb);\n+\n+\t  if ((taken_edge->flags & EDGE_DFS_BACK) != 0)\n+\t    return false;\n+\n \t  if (!bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n \t      jump_thread_edge *x\n \t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \t      path->safe_push (x);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n-\t      *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n-\t      if (*backedge_seen_p)\n-\t\tsimplify = dummy_simplify;\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n \t\t\t\t\t\t avail_exprs_stack,\n \t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t simplify,\n \t\t\t\t\t\t visited,\n-\t\t\t\t\t\t path,\n-\t\t\t\t\t\t backedge_seen_p);\n+\t\t\t\t\t\t path);\n \t    }\n \t}\n \n@@ -786,13 +774,6 @@ thread_around_empty_blocks (edge taken_edge,\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n     return false;\n \n-  /* If we have traversed a backedge, then we do not want to look\n-     at certain expressions in the table that can not be relied upon.\n-     Luckily the only code that looked at those expressions is the\n-     SIMPLIFY callback, which we replace if we can no longer use it.  */\n-  if (*backedge_seen_p)\n-    simplify = dummy_simplify;\n-\n   /* Extract and simplify the condition.  */\n   cond = simplify_control_stmt_condition (taken_edge, stmt,\n \t\t\t\t\t  avail_exprs_stack, dummy_cond,\n@@ -805,25 +786,24 @@ thread_around_empty_blocks (edge taken_edge,\n     {\n       taken_edge = find_taken_edge (bb, cond);\n \n+      if ((taken_edge->flags & EDGE_DFS_BACK) != 0)\n+\treturn false;\n+\n       if (bitmap_bit_p (visited, taken_edge->dest->index))\n \treturn false;\n       bitmap_set_bit (visited, taken_edge->dest->index);\n \n       jump_thread_edge *x\n \t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n       path->safe_push (x);\n-      *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n-      if (*backedge_seen_p)\n-\tsimplify = dummy_simplify;\n \n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n \t\t\t\t  avail_exprs_stack,\n \t\t\t\t  handle_dominating_asserts,\n \t\t\t\t  simplify,\n \t\t\t\t  visited,\n-\t\t\t\t  path,\n-\t\t\t\t  backedge_seen_p);\n+\t\t\t\t  path);\n       return true;\n     }\n \n@@ -871,14 +851,8 @@ thread_through_normal_block (edge e,\n \t\t\t     avail_exprs_stack *avail_exprs_stack,\n \t\t\t     pfn_simplify simplify,\n \t\t\t     vec<jump_thread_edge *> *path,\n-\t\t\t     bitmap visited,\n-\t\t\t     bool *backedge_seen_p)\n+\t\t\t     bitmap visited)\n {\n-  /* If we have seen a backedge, then we rely solely on the FSM threader\n-     to find jump threads.  */\n-  if (*backedge_seen_p)\n-    return 0;\n-\n   /* We want to record any equivalences created by traversing E.  */\n   if (!handle_dominating_asserts)\n     record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n@@ -948,6 +922,7 @@ thread_through_normal_block (edge e,\n \t     address.  */\n \t  if (dest == NULL\n \t      || dest == e->dest\n+\t      || (taken_edge->flags & EDGE_DFS_BACK) != 0\n \t      || bitmap_bit_p (visited, dest->index))\n \t    return 0;\n \n@@ -958,15 +933,11 @@ thread_through_normal_block (edge e,\n               jump_thread_edge *x\n \t        = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n \t      path->safe_push (x);\n-\t      *backedge_seen_p |= ((e->flags & EDGE_DFS_BACK) != 0);\n \t    }\n \n \t  jump_thread_edge *x\n \t    = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);\n \t  path->safe_push (x);\n-\t  *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n-\t  if (*backedge_seen_p)\n-\t    simplify = dummy_simplify;\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n@@ -982,8 +953,7 @@ thread_through_normal_block (edge e,\n \t\t\t\t      handle_dominating_asserts,\n \t\t\t\t      simplify,\n \t\t\t\t      visited,\n-\t\t\t\t      path,\n-\t\t\t\t      backedge_seen_p);\n+\t\t\t\t      path);\n \t  return 1;\n \t}\n     }\n@@ -993,18 +963,6 @@ thread_through_normal_block (edge e,\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n-   Special care is necessary if E is a back edge in the CFG as we\n-   may have already recorded equivalences for E->dest into our\n-   various tables, including the result of the conditional at\n-   the end of E->dest.  Threading opportunities are severely\n-   limited in that case to avoid short-circuiting the loop\n-   incorrectly.\n-\n-   Note it is quite common for the first block inside a loop to\n-   end with a conditional which is either always true or always\n-   false when reached via the loop backedge.  Thus we do not want\n-   to blindly disable threading across a loop backedge.\n-\n    DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n    to avoid allocating memory.\n \n@@ -1029,24 +987,25 @@ thread_across_edge (gcond *dummy_cond,\n \t\t\t\t      class avail_exprs_stack *))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n-  bool backedge_seen;\n \n   stmt_count = 0;\n \n   vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n   bitmap_clear (visited);\n   bitmap_set_bit (visited, e->src->index);\n   bitmap_set_bit (visited, e->dest->index);\n-  backedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n-  if (backedge_seen)\n-    simplify = dummy_simplify;\n-\n-  int threaded = thread_through_normal_block (e, dummy_cond,\n-\t\t\t\t\t      handle_dominating_asserts,\n-\t\t\t\t\t      const_and_copies,\n-\t\t\t\t\t      avail_exprs_stack,\n-\t\t\t\t\t      simplify, path,\n-\t\t\t\t\t      visited, &backedge_seen);\n+\n+  int threaded;\n+  if ((e->flags & EDGE_DFS_BACK) == 0)\n+    threaded = thread_through_normal_block (e, dummy_cond,\n+\t\t\t\t\t    handle_dominating_asserts,\n+\t\t\t\t\t    const_and_copies,\n+\t\t\t\t\t    avail_exprs_stack,\n+\t\t\t\t\t    simplify, path,\n+\t\t\t\t\t    visited);\n+  else\n+    threaded = 0;\n+\n   if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n@@ -1111,6 +1070,13 @@ thread_across_edge (gcond *dummy_cond,\n     /* Look at each successor of E->dest to see if we can thread through it.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       {\n+\tif ((e->flags & EDGE_DFS_BACK) != 0\n+\t    || (taken_edge->flags & EDGE_DFS_BACK) != 0)\n+\t  {\n+\t    find_jump_threads_backwards (taken_edge);\n+\t    continue;\n+\t  }\n+\n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n \tconst_and_copies->push_marker ();\n@@ -1132,29 +1098,21 @@ thread_across_edge (gcond *dummy_cond,\n         x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);\n \tpath->safe_push (x);\n \tfound = false;\n-\tbackedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n-\tbackedge_seen |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n-\tif (backedge_seen)\n-\t  simplify = dummy_simplify;\n \tfound = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t    dummy_cond,\n \t\t\t\t\t    avail_exprs_stack,\n \t\t\t\t\t    handle_dominating_asserts,\n \t\t\t\t\t    simplify,\n \t\t\t\t\t    visited,\n-\t\t\t\t\t    path,\n-\t\t\t\t\t    &backedge_seen);\n-\n-\tif (backedge_seen)\n-\t  simplify = dummy_simplify;\n+\t\t\t\t\t    path);\n \n \tif (!found)\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n \t\t\t\t\t       const_and_copies,\n \t\t\t\t\t       avail_exprs_stack,\n \t\t\t\t\t       simplify, path,\n-\t\t\t\t\t       visited, &backedge_seen) > 0;\n+\t\t\t\t\t       visited) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */"}]}