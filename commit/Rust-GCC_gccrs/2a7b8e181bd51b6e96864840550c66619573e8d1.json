{"sha": "2a7b8e181bd51b6e96864840550c66619573e8d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3YjhlMTgxYmQ1MWI2ZTk2ODY0ODQwNTUwYzY2NjE5NTczZThkMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:16:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:16:40Z"}, "message": "[multiple changes]\n\n2012-10-02  Bob Duff  <duff@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): Disable check in -gnatc mode.\n\n2012-10-02  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Function_Call): Dimension propagation\n\tfor function calls moved to Analyze_Dimension_Call.\n\t* sem_dim.adb (Analyze_Dimension_Call): Properly propagate the\n\tdimensions from the returned type for function calls.\n\n2012-10-02  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: Take into account any configuration pragma file\n\tin the project files for gnat pretty/stub/metric.\n\n2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Check_Indexing_Functions): Refine several tests\n\ton the legality of indexing aspects: Constant_Indexing functions\n\tdo not have to return a reference type, and given an indexing\n\taspect Func, not all overloadings of Func in the current scope\n\tneed to be indexing functions.\n\n2012-10-02  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* gnat_ugn.texi: Adjust docs for overflow checks to be VMS-friendly.\n\n2012-10-02  Vincent Celier  <celier@adacore.com>\n\n\t* switch-m.adb (Normalize_Compiler_Switches): Recognize switches\n\t-gnatox and -gnatoxx when x=0/1/2/3.\n\nFrom-SVN: r191960", "tree": {"sha": "f51de0844cc6806f85f20e8913a750c5ab9a0084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f51de0844cc6806f85f20e8913a750c5ab9a0084"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a7b8e181bd51b6e96864840550c66619573e8d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7b8e181bd51b6e96864840550c66619573e8d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a7b8e181bd51b6e96864840550c66619573e8d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7b8e181bd51b6e96864840550c66619573e8d1/comments", "author": null, "committer": null, "parents": [{"sha": "5f49133f81390b80edb508542edaa91583c9628a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f49133f81390b80edb508542edaa91583c9628a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f49133f81390b80edb508542edaa91583c9628a"}], "stats": {"total": 339, "additions": 214, "deletions": 125}, "files": [{"sha": "79f37c74773266a5861d160c8c935da352d843cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -1,3 +1,36 @@\n+2012-10-02  Bob Duff  <duff@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): Disable check in -gnatc mode.\n+\n+2012-10-02  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Function_Call): Dimension propagation\n+\tfor function calls moved to Analyze_Dimension_Call.\n+\t* sem_dim.adb (Analyze_Dimension_Call): Properly propagate the\n+\tdimensions from the returned type for function calls.\n+\n+2012-10-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: Take into account any configuration pragma file\n+\tin the project files for gnat pretty/stub/metric.\n+\n+2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Indexing_Functions): Refine several tests\n+\ton the legality of indexing aspects: Constant_Indexing functions\n+\tdo not have to return a reference type, and given an indexing\n+\taspect Func, not all overloadings of Func in the current scope\n+\tneed to be indexing functions.\n+\n+2012-10-02  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* gnat_ugn.texi: Adjust docs for overflow checks to be VMS-friendly.\n+\n+2012-10-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* switch-m.adb (Normalize_Compiler_Switches): Recognize switches\n+\t-gnatox and -gnatoxx when x=0/1/2/3.\n+\n 2012-10-02  Vincent Pucci  <pucci@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Indexed_Component_Form): Dimension"}, {"sha": "12a0cef00e847f90df5ddfc0153ec208525c5ece", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -2459,11 +2459,15 @@ package body Checks is\n          else\n             --  If the predicate is a static predicate and the operand is\n             --  static, the predicate must be evaluated statically. If the\n-            --  evaluation fails this is a static constraint error.\n+            --  evaluation fails this is a static constraint error. This check\n+            --  is disabled in -gnatc mode, because the compiler is incapable\n+            --  of evaluating static expressions in that case.\n \n             if Is_OK_Static_Expression (N) then\n                if Present (Static_Predicate (Typ)) then\n-                  if Eval_Static_Predicate_Check (N, Typ) then\n+                  if Operating_Mode < Generate_Code or else\n+                    Eval_Static_Predicate_Check (N, Typ)\n+                  then\n                      return;\n                   else\n                      Error_Msg_NE"}, {"sha": "1d58dc4e1c2dc2ee53f33bc2afa8146028e790ef", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -4346,7 +4346,7 @@ an assertion.\n Enable numeric overflow checking (which is not normally enabled by\n default). Note that division by zero is a separate check that is not\n controlled by this switch (division by zero checking is on by default).\n-The checking mode is set to CHECKED (equivalent to @option{-gnato11}).\n+The checking mode is set to CHECKED (equivalent to @option{^-gnato11^/OVERFLOW_CHECKS=11^}).\n \n @item -gnatp\n @cindex @option{-gnatp} (@command{gcc})"}, {"sha": "7e547535aca851f5cbf44af32b41f4db0664f029", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -2311,10 +2311,15 @@ begin\n                     (new String'(\"-gnatem=\" & Get_Name_String (M_File)));\n                end if;\n \n-               --  For gnatcheck, also indicate a global configuration pragmas\n-               --  file and, if -U is not used, a local one.\n-\n-               if The_Command = Check then\n+               --  For gnatcheck, gnatpp, gnatstub and gnatmetric, also\n+               --  indicate a global configuration pragmas file and, if -U\n+               --  is not used, a local one.\n+\n+               if The_Command = Check  or else\n+                  The_Command = Pretty or else\n+                  The_Command = Stub   or else\n+                  The_Command = Metric\n+               then\n                   declare\n                      Pkg  : constant Prj.Package_Id :=\n                               Prj.Util.Value_Of"}, {"sha": "d365dc78d41980ad82696918b9d4f654edddbae5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -1919,7 +1919,7 @@ package body Sem_Ch13 is\n       procedure Check_Indexing_Functions;\n       --  Check that the function in Constant_Indexing or Variable_Indexing\n       --  attribute has the proper type structure. If the name is overloaded,\n-      --  check that all interpretations are legal.\n+      --  check that some interpretation is legal.\n \n       procedure Check_Iterator_Functions;\n       --  Check that there is a single function in Default_Iterator attribute\n@@ -2070,6 +2070,7 @@ package body Sem_Ch13 is\n       ------------------------------\n \n       procedure Check_Indexing_Functions is\n+         Indexing_Found : Boolean;\n \n          procedure Check_One_Function (Subp : Entity_Id);\n          --  Check one possible interpretation\n@@ -2085,29 +2086,38 @@ package body Sem_Ch13 is\n                                    Aspect_Iterator_Element);\n \n          begin\n-            if not Check_Primitive_Function (Subp) then\n+            if not Check_Primitive_Function (Subp)\n+              and then not Is_Overloaded (Expr)\n+            then\n                Error_Msg_NE\n                  (\"aspect Indexing requires a function that applies to type&\",\n-                   Subp, Ent);\n+                    Subp, Ent);\n             end if;\n \n             --  An indexing function must return either the default element of\n-            --  the container, or a reference type.\n+            --  the container, or a reference type. For variable indexing it\n+            --  must be latter.\n \n             if Present (Default_Element) then\n                Analyze (Default_Element);\n                if Is_Entity_Name (Default_Element)\n                  and then Covers (Entity (Default_Element), Etype (Subp))\n                then\n+                  Indexing_Found := True;\n                   return;\n                end if;\n             end if;\n \n-            --  Otherwise the return type must be a reference type.\n+            --  For variable_indexing the return type must be a reference type.\n \n-            if not Has_Implicit_Dereference (Etype (Subp)) then\n+            if Attr = Name_Variable_Indexing\n+              and then not Has_Implicit_Dereference (Etype (Subp))\n+            then\n                Error_Msg_N\n                  (\"function for indexing must return a reference type\", Subp);\n+\n+            else\n+               Indexing_Found := True;\n             end if;\n          end Check_One_Function;\n \n@@ -2129,6 +2139,7 @@ package body Sem_Ch13 is\n                It : Interp;\n \n             begin\n+               Indexing_Found := False;\n                Get_First_Interp (Expr, I, It);\n                while Present (It.Nam) loop\n \n@@ -2142,6 +2153,11 @@ package body Sem_Ch13 is\n \n                   Get_Next_Interp (I, It);\n                end loop;\n+               if not Indexing_Found then\n+                  Error_Msg_NE (\n+                   \"aspect Indexing requires a function that applies to type&\",\n+                     Expr, Ent);\n+               end if;\n             end;\n          end if;\n       end Check_Indexing_Functions;"}, {"sha": "6d825987c59767191b0a60bba3b0bc5d10649fda", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -500,10 +500,6 @@ package body Sem_Ch6 is\n       end if;\n \n       Analyze_Call (N);\n-\n-      --  Propagate the dimensions from the returned type, if necessary\n-\n-      Analyze_Dimension (N);\n    end Analyze_Function_Call;\n \n    -----------------------------"}, {"sha": "ca7f3b2899f56c24ba760cee1ec86e44995589e6", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 114, "deletions": 105, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -1507,151 +1507,160 @@ package body Sem_Dim is\n       --  so far by the compiler in this routine.\n \n    begin\n-      --  Aspect is an Ada 2012 feature. Nothing to do here if the list of\n-      --  actuals is empty.Note that there is no need to check dimensions for\n-      --  calls that don't come from source.\n+      --  Aspect is an Ada 2012 feature. Note that there is no need to check\n+      --  dimensions for calls that don't come from source.\n \n       if Ada_Version < Ada_2012\n         or else not Comes_From_Source (N)\n-        or else Is_Empty_List (Actuals)\n       then\n          return;\n       end if;\n \n-      --  Special processing for elementary functions\n-\n-      --  For Sqrt call, the resulting dimensions equal to half the dimensions\n-      --  of the actual. For all other elementary calls, this routine check\n-      --  that every actual is dimensionless.\n-\n-      if Nkind (N) = N_Function_Call then\n-         Elementary_Function_Calls : declare\n-            Dims_Of_Call : Dimension_Type;\n-            Ent          : Entity_Id := Nam;\n+      --  Check the dimensions of the actuals, if any\n \n-            function Is_Elementary_Function_Entity\n-              (Sub_Id : Entity_Id) return Boolean;\n-            --  Given Sub_Id, the original subprogram entity, return True if\n-            --  call is to an elementary function\n-            --  (see Ada.Numerics.Generic_Elementary_Functions).\n+      if not Is_Empty_List (Actuals) then\n+         --  Special processing for elementary functions\n \n-            -----------------------------------\n-            -- Is_Elementary_Function_Entity --\n-            -----------------------------------\n+         --  For Sqrt call, the resulting dimensions equal to half the\n+         --  dimensions of the actual. For all other elementary calls, this\n+         --  routine check that every actual is dimensionless.\n \n-            function Is_Elementary_Function_Entity\n-              (Sub_Id : Entity_Id) return Boolean\n-            is\n-               Loc : constant Source_Ptr := Sloc (Sub_Id);\n+         if Nkind (N) = N_Function_Call then\n+            Elementary_Function_Calls : declare\n+               Dims_Of_Call : Dimension_Type;\n+               Ent          : Entity_Id := Nam;\n \n-            begin\n-               --  Is function entity in\n-               --  Ada.Numerics.Generic_Elementary_Functions?\n+               function Is_Elementary_Function_Entity\n+                 (Sub_Id : Entity_Id) return Boolean;\n+               --  Given Sub_Id, the original subprogram entity, return True if\n+               --  call is to an elementary function\n+               --  (see Ada.Numerics.Generic_Elementary_Functions).\n \n-               return\n-                 Loc > No_Location\n-                   and then\n-                     Is_RTU\n-                       (Cunit_Entity (Get_Source_Unit (Loc)),\n-                         Ada_Numerics_Generic_Elementary_Functions);\n-            end Is_Elementary_Function_Entity;\n+               -----------------------------------\n+               -- Is_Elementary_Function_Entity --\n+               -----------------------------------\n \n-         --  Start of processing for Elementary_Function_Calls\n+               function Is_Elementary_Function_Entity\n+                 (Sub_Id : Entity_Id) return Boolean\n+               is\n+                  Loc : constant Source_Ptr := Sloc (Sub_Id);\n \n-         begin\n-            --  Get the original subprogram entity following the renaming chain\n+               begin\n+                  --  Is function entity in\n+                  --  Ada.Numerics.Generic_Elementary_Functions?\n \n-            if Present (Alias (Ent)) then\n-               Ent := Alias (Ent);\n-            end if;\n+                  return\n+                    Loc > No_Location\n+                      and then\n+                        Is_RTU\n+                          (Cunit_Entity (Get_Source_Unit (Loc)),\n+                            Ada_Numerics_Generic_Elementary_Functions);\n+               end Is_Elementary_Function_Entity;\n \n-            --  Check the call is an Elementary function call\n+            --  Start of processing for Elementary_Function_Calls\n \n-            if Is_Elementary_Function_Entity (Ent) then\n+            begin\n+               --  Get the original subprogram entity following the renaming\n+               --  chain.\n \n-               --  Sqrt function call case\n+               if Present (Alias (Ent)) then\n+                  Ent := Alias (Ent);\n+               end if;\n \n-               if Chars (Ent) = Name_Sqrt then\n-                  Dims_Of_Call := Dimensions_Of (First_Actual (N));\n+               --  Check the call is an Elementary function call\n \n-                  --  Eavluates the resulting dimensions (i.e. half the\n-                  --  dimensions of the actual).\n+               if Is_Elementary_Function_Entity (Ent) then\n+                  --  Sqrt function call case\n \n-                  if Exists (Dims_Of_Call) then\n-                     for Position in Dims_Of_Call'Range loop\n-                        Dims_Of_Call (Position) :=\n-                          Dims_Of_Call (Position) *\n-                            Rational'(Numerator   => 1,\n-                                      Denominator => 2);\n-                     end loop;\n+                  if Chars (Ent) = Name_Sqrt then\n+                     Dims_Of_Call := Dimensions_Of (First_Actual (N));\n \n-                     Set_Dimensions (N, Dims_Of_Call);\n-                  end if;\n+                     --  Evaluates the resulting dimensions (i.e. half the\n+                     --  dimensions of the actual).\n \n-               --  All other elementary functions case. Note that every actual\n-               --  here should be dimensionless.\n+                     if Exists (Dims_Of_Call) then\n+                        for Position in Dims_Of_Call'Range loop\n+                           Dims_Of_Call (Position) :=\n+                             Dims_Of_Call (Position) *\n+                               Rational'(Numerator   => 1,\n+                                         Denominator => 2);\n+                        end loop;\n \n-               else\n-                  Actual := First_Actual (N);\n-                  while Present (Actual) loop\n-                     if Exists (Dimensions_Of (Actual)) then\n+                        Set_Dimensions (N, Dims_Of_Call);\n+                     end if;\n \n-                        --  Check if error has already been encountered so far\n+                  --  All other elementary functions case. Note that every\n+                  --  actual here should be dimensionless.\n \n-                        if not Error_Detected then\n-                           Error_Msg_NE (\"dimensions mismatch in call of&\",\n-                                         N, Name (N));\n-                           Error_Detected := True;\n+                  else\n+                     Actual := First_Actual (N);\n+                     while Present (Actual) loop\n+                        if Exists (Dimensions_Of (Actual)) then\n+\n+                           --  Check if error has already been encountered so\n+                           --  far.\n+\n+                           if not Error_Detected then\n+                              Error_Msg_NE (\"dimensions mismatch in call of&\",\n+                                            N, Name (N));\n+                              Error_Detected := True;\n+                           end if;\n+\n+                           Error_Msg_N (\"\\expected dimension [], found \" &\n+                                        Dimensions_Msg_Of (Actual),\n+                                        Actual);\n                         end if;\n \n-                        Error_Msg_N (\"\\expected dimension [], found \" &\n-                                     Dimensions_Msg_Of (Actual),\n-                                     Actual);\n-                     end if;\n+                        Next_Actual (Actual);\n+                     end loop;\n+                  end if;\n \n-                     Next_Actual (Actual);\n-                  end loop;\n-               end if;\n+                  --  Nothing more to do for elementary functions\n \n-               --  Nothing more to do for elementary functions\n+                  return;\n+               end if;\n+            end Elementary_Function_Calls;\n+         end if;\n \n-               return;\n-            end if;\n-         end Elementary_Function_Calls;\n-      end if;\n+         --  General case. Check, for each parameter, the dimensions of the\n+         --  actual and its corresponding formal match. Otherwise, complain.\n \n-      --  General case. Check, for each parameter, the dimensions of the actual\n-      --  and its corresponding formal match. Otherwise, complain.\n+         Actual := First_Actual (N);\n+         Formal := First_Formal (Nam);\n \n-      Actual  := First_Actual (N);\n-      Formal  := First_Formal (Nam);\n+         while Present (Formal) loop\n+            Formal_Typ     := Etype (Formal);\n+            Dims_Of_Formal := Dimensions_Of (Formal_Typ);\n \n-      while Present (Formal) loop\n-         Formal_Typ     := Etype (Formal);\n-         Dims_Of_Formal := Dimensions_Of (Formal_Typ);\n+            --  If the formal is not dimensionless, check dimensions of formal\n+            --  and actual match. Otherwise, complain.\n \n-         --  If the formal is not dimensionless, check dimensions of formal and\n-         --  actual match. Otherwise, complain.\n+            if Exists (Dims_Of_Formal)\n+              and then Dimensions_Of (Actual) /= Dims_Of_Formal\n+            then\n+               --  Check if an error has already been encountered so far\n \n-         if Exists (Dims_Of_Formal)\n-           and then Dimensions_Of (Actual) /= Dims_Of_Formal\n-         then\n-            --  Check if an error has already been encountered so far\n+               if not Error_Detected then\n+                  Error_Msg_NE (\"dimensions mismatch in& call\", N, Name (N));\n+                  Error_Detected := True;\n+               end if;\n \n-            if not Error_Detected then\n-               Error_Msg_NE (\"dimensions mismatch in& call\", N, Name (N));\n-               Error_Detected := True;\n+               Error_Msg_N (\"\\expected dimension \" &\n+                            Dimensions_Msg_Of (Formal_Typ) & \", found \" &\n+                            Dimensions_Msg_Of (Actual),\n+                            Actual);\n             end if;\n \n-            Error_Msg_N (\"\\expected dimension \" &\n-                         Dimensions_Msg_Of (Formal_Typ) & \", found \" &\n-                         Dimensions_Msg_Of (Actual),\n-                         Actual);\n-         end if;\n+            Next_Actual (Actual);\n+            Next_Formal (Formal);\n+         end loop;\n+      end if;\n \n-         Next_Actual (Actual);\n-         Next_Formal (Formal);\n-      end loop;\n+      --  For function calls, propagate the dimensions from the returned type\n+\n+      if Nkind (N) = N_Function_Call then\n+         Analyze_Dimension_Has_Etype (N);\n+      end if;\n    end Analyze_Dimension_Call;\n \n    ---------------------------------------------"}, {"sha": "0d769dc09f15ff18d7fb675ee52da89b19b05504", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b8e181bd51b6e96864840550c66619573e8d1/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=2a7b8e181bd51b6e96864840550c66619573e8d1", "patch": "@@ -236,9 +236,9 @@ package body Switch.M is\n                   --  One-letter switches\n \n                   when 'a' | 'A' | 'b' | 'B' | 'c' | 'C' | 'E' | 'f' |\n-                       'F' | 'g' | 'h' | 'H' | 'I' | 'L' | 'N' | 'o' |\n-                       'p' | 'P' | 'q' | 'Q' | 'r' | 's' | 'S' | 't' |\n-                       'u' | 'U' | 'v' | 'x' | 'X' | 'Z' =>\n+                       'F' | 'g' | 'h' | 'H' | 'I' | 'L' | 'N' | 'p' |\n+                       'P' | 'q' | 'Q' | 'r' | 's' | 'S' | 't' | 'u' |\n+                       'U' | 'v' | 'x' | 'X' | 'Z' =>\n                      Storing (First_Stored) := C;\n                      Add_Switch_Component\n                        (Storing (Storing'First .. First_Stored));\n@@ -441,6 +441,32 @@ package body Switch.M is\n                      Add_Switch_Component\n                        (Storing (Storing'First .. Last_Stored));\n \n+                  --  -gnato may be -gnatox or -gnatoxx, with x=0/1/2/3\n+\n+                  when 'o' =>\n+                     Last_Stored := First_Stored;\n+                     Storing (Last_Stored) := 'o';\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr <= Max\n+                       and then Switch_Chars (Ptr) in '0' .. '3'\n+                     then\n+                        Last_Stored := Last_Stored + 1;\n+                        Storing (Last_Stored) := Switch_Chars (Ptr);\n+                        Ptr := Ptr + 1;\n+\n+                        if Ptr <= Max\n+                          and then Switch_Chars (Ptr) in '0' .. '3'\n+                        then\n+                           Last_Stored := Last_Stored + 1;\n+                           Storing (Last_Stored) := Switch_Chars (Ptr);\n+                           Ptr := Ptr + 1;\n+                        end if;\n+                     end if;\n+\n+                     Add_Switch_Component\n+                       (Storing (Storing'First .. Last_Stored));\n+\n                   --  -gnatR may be followed by '0', '1', '2' or '3',\n                   --  then by 's'\n "}]}