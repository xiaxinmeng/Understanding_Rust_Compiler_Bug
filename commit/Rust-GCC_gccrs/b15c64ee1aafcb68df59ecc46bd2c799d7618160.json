{"sha": "b15c64ee1aafcb68df59ecc46bd2c799d7618160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1YzY0ZWUxYWFmY2I2OGRmNTllY2M0NmJkMmM3OTlkNzYxODE2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-29T21:21:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-29T21:21:46Z"}, "message": "inline-10.c: New testcase.\n\n\t* gcc.dg/tree-ssa/inline-10.c: New testcase.\n\t* gcc.dg/tree-ssa/inline-9.c: Disable partial inlining.\n\t* ipa-inline.h (clause_t): Turn into unsigned int.\n\t* ipa-inline-analysis.c (add_clause): Do more simplification.\n\t(and_predicates): Shortcut more cases.\n\t(predicates_equal_p): Move forward; check that clauses are properly\n\tordered.\n\t(or_predicates): Shortcut more cases.\n\t(edge_execution_predicate): Rewrite as...\n\t(set_cond_stmt_execution_predicate): ... this function; handle\n\t__builtin_constant_p.\n\t(set_switch_stmt_execution_predicate): New .\n\t(compute_bb_predicates): New.\n\t(will_be_nonconstant_predicate): Update TODO.\n\t(estimate_function_body_sizes): Use compute_bb_predicates\n\tand free them later, always try to estimate if stmt is constant.\n\t(estimate_time_after_inlining, estimate_size_after_inlining):\n\tGracefully handle optimized out edges.\n\t(read_predicate): Fix off by one error.\n\nFrom-SVN: r173190", "tree": {"sha": "4798ac9767856709586a6326e09b5dc53ae4cfff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4798ac9767856709586a6326e09b5dc53ae4cfff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b15c64ee1aafcb68df59ecc46bd2c799d7618160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15c64ee1aafcb68df59ecc46bd2c799d7618160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15c64ee1aafcb68df59ecc46bd2c799d7618160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15c64ee1aafcb68df59ecc46bd2c799d7618160/comments", "author": null, "committer": null, "parents": [{"sha": "7097b0410ed48d3b7a5099e12fcec14b80f86910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7097b0410ed48d3b7a5099e12fcec14b80f86910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7097b0410ed48d3b7a5099e12fcec14b80f86910"}], "stats": {"total": 482, "additions": 391, "deletions": 91}, "files": [{"sha": "e64c92f423d3d1b20ede7009de3b4fe02b15d1ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b15c64ee1aafcb68df59ecc46bd2c799d7618160", "patch": "@@ -1,3 +1,25 @@\n+2011-04-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/inline-10.c: New testcase.\n+\t* gcc.dg/tree-ssa/inline-9.c: Disable partial inlining.\n+\t* ipa-inline.h (clause_t): Turn into unsigned int.\n+\t* ipa-inline-analysis.c (add_clause): Do more simplification.\n+\t(and_predicates): Shortcut more cases.\n+\t(predicates_equal_p): Move forward; check that clauses are properly\n+\tordered.\n+\t(or_predicates): Shortcut more cases.\n+\t(edge_execution_predicate): Rewrite as...\n+\t(set_cond_stmt_execution_predicate): ... this function; handle\n+\t__builtin_constant_p.\n+\t(set_switch_stmt_execution_predicate): New .\n+\t(compute_bb_predicates): New.\n+\t(will_be_nonconstant_predicate): Update TODO.\n+\t(estimate_function_body_sizes): Use compute_bb_predicates\n+\tand free them later, always try to estimate if stmt is constant.\n+\t(estimate_time_after_inlining, estimate_size_after_inlining):\n+\tGracefully handle optimized out edges.\n+\t(read_predicate): Fix off by one error.\n+\n 2011-04-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Makefile.in (ENABLE_MAINTAINER_RULES): New."}, {"sha": "2a0a2583aee9f9778ce70c5170eaad58ba4e4a38", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 329, "deletions": 89, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b15c64ee1aafcb68df59ecc46bd2c799d7618160", "patch": "@@ -227,19 +227,20 @@ add_condition (struct inline_summary *summary, int operand_num,\n }\n \n \n-/* Add clause CLAUSE into the predicate.  */\n+/* Add clause CLAUSE into the predicate P.  */\n \n static inline void\n add_clause (struct predicate *p, clause_t clause)\n {\n   int i;\n+  int i2;\n   int insert_here = -1;\n \n   /* True clause.  */\n   if (!clause)\n     return;\n \n-  /* Flase clause makes the whole predicate false.  Kill the other variants.  */\n+  /* False clause makes the whole predicate false.  Kill the other variants.  */\n   if (clause == (1 << predicate_false_condition))\n     {\n       p->clause[0] = (1 << predicate_false_condition);\n@@ -248,26 +249,46 @@ add_clause (struct predicate *p, clause_t clause)\n     }\n   if (false_predicate_p (p))\n     return;\n-  gcc_assert (!(clause & (1 << predicate_false_condition)));\n-  for (i = 0; i < MAX_CLAUSES - 1; i++)\n+\n+  /* No one should be sily enough to add false into nontrivial clauses.  */\n+  gcc_checking_assert (!(clause & (1 << predicate_false_condition)));\n+\n+  /* Look where to insert the clause.  At the same time prune out\n+     clauses of P that are implied by the new clause and thus\n+     redundant.  */\n+  for (i = 0, i2 = 0; i <= MAX_CLAUSES; i++)\n     {\n-      if (p->clause[i] == clause)\n-        return;\n+      p->clause[i2] = p->clause[i];\n+\n       if (!p->clause[i])\n \tbreak;\n-      if (p->clause[i] < clause && !insert_here)\n-\tinsert_here = i;\n+\n+      /* If p->clause[i] implies clause, there is nothing to add.  */\n+      if ((p->clause[i] & clause) == p->clause[i])\n+\t{\n+\t  /* We had nothing to add, none of clauses should've become redundant.  */\n+\t  gcc_checking_assert (i == i2);\n+\t  return;\n+\t}\n+\n+      if (p->clause[i] < clause && insert_here < 0)\n+\tinsert_here = i2;\n+\n+      /* If clause implies p->clause[i], then p->clause[i] becomes redundant.\n+\t Otherwise the p->clause[i] has to stay.  */\n+      if ((p->clause[i] & clause) != clause)\n+\ti2++;\n     }\n-  /* We run out of variants.  Be conservative in positive direciton.  */\n-  if (i == MAX_CLAUSES)\n+  /* We run out of variants.  Be conservative in positive direction.  */\n+  if (i2 == MAX_CLAUSES)\n     return;\n-  /* Keep clauses ordered by index, so equivalence testing is easy.  */\n-  p->clause[i + 1] = 0;\n+  /* Keep clauses in decreasing order. This makes equivalence testing easy.  */\n+  p->clause[i2 + 1] = 0;\n   if (insert_here >= 0)\n-    for (;i > insert_here; i--)\n-      p->clause[i] = p->clause[i - 1];\n+    for (;i2 > insert_here; i2--)\n+      p->clause[i2] = p->clause[i2 - 1];\n   else\n-    insert_here = i;\n+    insert_here = i2;\n   p->clause[insert_here] = clause;\n }\n \n@@ -280,7 +301,20 @@ and_predicates (struct predicate *p, struct predicate *p2)\n   struct predicate out = *p;\n   int i;\n \n-  for (i = 0; p2->clause[i]; i++)\n+  /* Avoid busy work.  */\n+  if (false_predicate_p (p2) || true_predicate_p (p))\n+    return *p2;\n+  if (false_predicate_p (p) || true_predicate_p (p2))\n+    return *p;\n+\n+  /* See how far predicates match.  */\n+  for (i = 0; p->clause[i] && p->clause[i] == p2->clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+    }\n+    \n+  /* Combine the predicates rest.  */\n+  for (; p2->clause[i]; i++)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n       add_clause (&out, p2->clause[i]);\n@@ -289,6 +323,24 @@ and_predicates (struct predicate *p, struct predicate *p2)\n }\n \n \n+/* Return true if predicates are obviously equal.  */\n+\n+static inline bool\n+predicates_equal_p (struct predicate *p, struct predicate *p2)\n+{\n+  int i;\n+  for (i = 0; p->clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+      gcc_checking_assert (p->clause [i] > p->clause[i + 1]);\n+      gcc_checking_assert (!p2->clause[i] || p2->clause [i] > p2->clause[i + 1]);\n+      if (p->clause[i] != p2->clause[i])\n+        return false;\n+    }\n+  return !p2->clause[i];\n+}\n+\n+\n /* Return P | P2.  */\n \n static struct predicate\n@@ -297,11 +349,15 @@ or_predicates (struct predicate *p, struct predicate *p2)\n   struct predicate out = true_predicate ();\n   int i,j;\n \n-  /* If one of conditions is false, return the other.  */\n-  if (false_predicate_p (p2))\n+  /* Avoid busy work.  */\n+  if (false_predicate_p (p2) || true_predicate_p (p))\n     return *p;\n-  if (false_predicate_p (p))\n+  if (false_predicate_p (p) || true_predicate_p (p2))\n     return *p2;\n+  if (predicates_equal_p (p, p2))\n+    return *p;\n+\n+  /* OK, combine the predicates.  */\n   for (i = 0; p->clause[i]; i++)\n     for (j = 0; p2->clause[j]; j++)\n       {\n@@ -312,22 +368,6 @@ or_predicates (struct predicate *p, struct predicate *p2)\n }\n \n \n-/* Return true if predicates are obviously equal.  */\n-\n-static inline bool\n-predicates_equal_p (struct predicate *p, struct predicate *p2)\n-{\n-  int i;\n-  for (i = 0; p->clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n-      if (p->clause[i] != p2->clause[i])\n-        return false;\n-    }\n-  return !p2->clause[i];\n-}\n-\n-\n /* Having partial truth assignment in POSSIBLE_TRUTHS, return false if predicate P\n    to be false.  */\n \n@@ -885,50 +925,226 @@ eliminated_by_inlining_prob (gimple stmt)\n }\n \n \n-/* Return predicate that must be true when is E executable.  */\n+/* If BB ends by a conditional we can turn into predicates, attach corresponding\n+   predicates to the CFG edges.   */\n \n-static struct predicate\n-edge_execution_predicate (struct ipa_node_params *info,\n-\t\t\t  struct inline_summary *summary,\n-\t\t\t  edge e)\n+static void\n+set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n+\t\t\t           struct inline_summary *summary,\n+\t\t\t           basic_block bb)\n {\n-  struct predicate p = true_predicate ();\n   gimple last;\n   tree op;\n   int index;\n-  enum tree_code code;\n+  enum tree_code code, inverted_code;\n+  edge e;\n+  edge_iterator ei;\n+  gimple set_stmt;\n+  tree op2;\n \n-  if (e->src == ENTRY_BLOCK_PTR)\n-    return p;\n-\n-  last = last_stmt (e->src);\n-  /* TODO: handle switch.  */\n+  last = last_stmt (bb);\n   if (!last\n       || gimple_code (last) != GIMPLE_COND)\n-    return p;\n+    return;\n   if (!is_gimple_ip_invariant (gimple_cond_rhs (last)))\n-    return p;\n+    return;\n   op = gimple_cond_lhs (last);\n   /* TODO: handle conditionals like\n      var = op0 < 4;\n-     if (var != 0)\n-     and __bulitin_constant_p.  */\n+     if (var != 0).  */\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return;\n+  if (SSA_NAME_IS_DEFAULT_DEF (op))\n+    {\n+      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op));\n+      if (index == -1)\n+\treturn;\n+      code = gimple_cond_code (last);\n+      inverted_code = invert_tree_comparison (code,\n+\t\t\t\t\t      HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  struct predicate p = add_condition (summary,\n+\t\t\t\t\t      index,\n+\t\t\t\t\t      e->flags & EDGE_TRUE_VALUE\n+\t\t\t\t\t      ? code : inverted_code,\n+\t\t\t\t\t      gimple_cond_rhs (last));\n+\t  e->aux = pool_alloc (edge_predicate_pool);\n+\t  *(struct predicate *)e->aux = p;\n+\t}\n+    }\n+\n+  /* Special case\n+     if (builtin_constant_p (op))\n+       constant_code\n+     else\n+       nonconstant_code.\n+     Here we can predicate nonconstant_code.  We can't\n+     really handle constant_code since we have no predicate\n+     for this and also the constant code is not known to be\n+     optimized away when inliner doen't see operand is constant.\n+     Other optimizers might think otherwise.  */\n+  set_stmt = SSA_NAME_DEF_STMT (op);\n+  if (!gimple_call_builtin_p (set_stmt, BUILT_IN_CONSTANT_P)\n+      || gimple_call_num_args (set_stmt) != 1)\n+    return;\n+  op2 = gimple_call_arg (set_stmt, 0);\n+  if (!SSA_NAME_IS_DEFAULT_DEF (op2))\n+    return;\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op2));\n+  if (index == -1)\n+    return;\n+  if (gimple_cond_code (last) != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (last)))\n+    return;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_FALSE_VALUE)\n+      {\n+\tstruct predicate p = add_condition (summary,\n+\t\t\t\t\t    index,\n+\t\t\t\t\t    IS_NOT_CONSTANT,\n+\t\t\t\t\t    NULL);\n+\te->aux = pool_alloc (edge_predicate_pool);\n+\t*(struct predicate *)e->aux = p;\n+      }\n+}\n+\n+\n+/* If BB ends by a switch we can turn into predicates, attach corresponding\n+   predicates to the CFG edges.   */\n+\n+static void\n+set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n+\t\t\t           struct inline_summary *summary,\n+\t\t\t           basic_block bb)\n+{\n+  gimple last;\n+  tree op;\n+  int index;\n+  edge e;\n+  edge_iterator ei;\n+  size_t n;\n+  size_t case_idx;\n+\n+  last = last_stmt (bb);\n+  if (!last\n+      || gimple_code (last) != GIMPLE_SWITCH)\n+    return;\n+  op = gimple_switch_index (last);\n   if (TREE_CODE (op) != SSA_NAME\n       || !SSA_NAME_IS_DEFAULT_DEF (op))\n-    return p;\n+    return;\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op));\n   if (index == -1)\n-    return p;\n-  code = gimple_cond_code (last);\n+    return;\n \n-  if (EDGE_TRUE_VALUE)\n-    code = invert_tree_comparison (code,\n-\t\t\t\t   HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      e->aux = pool_alloc (edge_predicate_pool);\n+      *(struct predicate *)e->aux = false_predicate ();\n+    }\n+  n = gimple_switch_num_labels(last);\n+  for (case_idx = 0; case_idx < n; ++case_idx)\n+    {\n+      tree cl = gimple_switch_label (last, case_idx);\n+      tree min, max;\n+      struct predicate p;\n \n-  return add_condition (summary,\n-\t\t\tindex,\n-\t\t\tgimple_cond_code (last),\n-\t\t\tgimple_cond_rhs (last));\n+      e = find_edge (bb, label_to_block (CASE_LABEL (cl)));\n+      min = CASE_LOW (cl);\n+      max = CASE_HIGH (cl);\n+\n+      /* For default we might want to construct predicate that none\n+\t of cases is met, but it is bit hard to do not having negations\n+\t of conditionals handy.  */\n+      if (!min && !max)\n+\tp = true_predicate ();\n+      else if (!max)\n+\tp = add_condition (summary, index,\n+\t\t\t   EQ_EXPR,\n+\t\t\t   min);\n+      else\n+\t{\n+\t  struct predicate p1, p2;\n+\t  p1 = add_condition (summary, index,\n+\t\t\t      GE_EXPR,\n+\t\t\t      min);\n+\t  p2 = add_condition (summary, index,\n+\t\t\t      LE_EXPR,\n+\t\t\t      max);\n+\t  p = and_predicates (&p1, &p2);\n+\t}\n+      *(struct predicate *)e->aux\n+\t= or_predicates (&p, (struct predicate *)e->aux);\n+    }\n+}\n+\n+\n+/* For each BB in NODE attach to its AUX pointer predicate under\n+   which it is executable.  */\n+\n+static void\n+compute_bb_predicates (struct cgraph_node *node,\n+\t\t       struct ipa_node_params *parms_info,\n+\t\t       struct inline_summary *summary)\n+{\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n+  bool done = false;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, my_function)\n+    {\n+      set_cond_stmt_execution_predicate (parms_info, summary, bb);\n+      set_switch_stmt_execution_predicate (parms_info, summary, bb);\n+    }\n+\n+  /* Entry block is always executable.  */\n+  ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux = pool_alloc (edge_predicate_pool);\n+  *(struct predicate *)ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n+    = true_predicate ();\n+\n+  /* A simple dataflow propagation of predicates forward in the CFG.\n+     TODO: work in reverse postorder.  */\n+  while (!done)\n+    {\n+      done = true;\n+      FOR_EACH_BB_FN (bb, my_function)\n+\t{\n+          struct predicate p = false_predicate ();\n+          edge e;\n+          edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      if (e->src->aux)\n+\t\t{\n+\t\t  struct predicate this_bb_predicate = *(struct predicate *)e->src->aux;\n+\t\t  if (e->aux)\n+\t\t    this_bb_predicate = and_predicates (&this_bb_predicate,\n+\t\t\t\t\t\t\t(struct predicate *)e->aux);\n+\t\t  p = or_predicates (&p, &this_bb_predicate);\n+\t\t  if (true_predicate_p (&p))\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (false_predicate_p (&p))\n+\t    gcc_assert (!bb->aux);\n+\t  else\n+\t    {\n+\t      if (!bb->aux)\n+\t\t{\n+\t\t  done = false;\n+\t\t  bb->aux = pool_alloc (edge_predicate_pool);\n+\t\t  *((struct predicate *)bb->aux) = p;\n+\t\t}\n+\t      else if (!predicates_equal_p (&p, (struct predicate *)bb->aux))\n+\t\t{\n+\t\t  done = false;\n+\t\t  *((struct predicate *)bb->aux) = p;\n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n \n@@ -956,7 +1172,8 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \n   /* What statments might be optimized away\n      when their arguments are constant\n-     TODO: also trivial builtins, especially builtin_constant_p.  */\n+     TODO: also trivial builtins.\n+     builtin_constant_p is already handled later.  */\n   if (gimple_code (stmt) != GIMPLE_ASSIGN\n       && gimple_code (stmt) != GIMPLE_COND\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n@@ -1050,23 +1267,19 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);\n \n   gcc_assert (my_function && my_function->cfg);\n+  if (parms_info)\n+    compute_bb_predicates (node, parms_info, info);\n   FOR_EACH_BB_FN (bb, my_function)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n       freq = compute_call_stmt_bb_frequency (node->decl, bb);\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n       if (parms_info)\n \t{\n-          bb_predicate = false_predicate ();\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    {\n-\t      struct predicate ep;\n-\t      ep = edge_execution_predicate (parms_info, info, e);\n-\t      bb_predicate = or_predicates (&ep, &bb_predicate);\n-\t    }\n+\t  if (bb->aux)\n+\t    bb_predicate = *(struct predicate *)bb->aux;\n+\t  else\n+\t    bb_predicate = false_predicate ();\n \t}\n       else\n \tbb_predicate = true_predicate ();\n@@ -1083,6 +1296,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n \t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n \t  int prob;\n+\t  struct predicate will_be_nonconstant;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1127,9 +1341,15 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tgcc_assert (!gimple_call_cannot_inline_p (stmt));\n \t    }\n \n+\t  /* TODO: When conditional jump or swithc is known to be constant, but\n+ \t     we did not translate it into the predicates, we really can account\n+\t     just maximum of the possible paths.  */\n+\t  if (parms_info)\n+\t    will_be_nonconstant\n+\t       = will_be_nonconstant_predicate (parms_info, info,\n+\t\t\t\t\t\tstmt, nonconstant_names);\n \t  if (this_time || this_size)\n \t    {\n-\t      struct predicate will_be_nonconstant;\n \t      struct predicate p;\n \n \t      this_time *= freq;\n@@ -1143,12 +1363,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tfprintf (dump_file, \"\\t\\twill eliminated by inlining\\n\");\n \n \t      if (parms_info)\n-\t\t{\n-\t\t  will_be_nonconstant\n-\t\t     = will_be_nonconstant_predicate (parms_info, info,\n-\t\t\t\t\t\t      stmt, nonconstant_names);\n-\t\t  p = and_predicates (&bb_predicate, &will_be_nonconstant);\n-\t\t}\n+\t\tp = and_predicates (&bb_predicate, &will_be_nonconstant);\n \t      else\n \t\tp = true_predicate ();\n \n@@ -1174,6 +1389,21 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t}\n     }\n+  FOR_ALL_BB_FN (bb, my_function)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (bb->aux)\n+\tpool_free (edge_predicate_pool, bb->aux);\n+      bb->aux = NULL;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->aux)\n+\t    pool_free (edge_predicate_pool, e->aux);\n+\t  e->aux = NULL;\n+\t}\n+    }\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n@@ -1677,12 +1907,17 @@ int\n estimate_time_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  gcov_type time = inline_summary (node)->time + estimate_edge_time (edge);\n-  if (time < 0)\n-    time = 0;\n-  if (time > MAX_TIME)\n-    time = MAX_TIME;\n-  return time;\n+  struct inline_edge_summary *es = inline_edge_summary (edge);\n+  if (!es->predicate || !false_predicate_p (es->predicate))\n+    {\n+      gcov_type time = inline_summary (node)->time + estimate_edge_time (edge);\n+      if (time < 0)\n+\ttime = 0;\n+      if (time > MAX_TIME)\n+\ttime = MAX_TIME;\n+      return time;\n+    }\n+  return inline_summary (node)->time;\n }\n \n \n@@ -1693,9 +1928,14 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  int size = inline_summary (node)->size + estimate_edge_growth (edge);\n-  gcc_assert (size >= 0);\n-  return size;\n+  struct inline_edge_summary *es = inline_edge_summary (edge);\n+  if (!es->predicate || !false_predicate_p (es->predicate))\n+    {\n+      int size = inline_summary (node)->size + estimate_edge_growth (edge);\n+      gcc_assert (size >= 0);\n+      return size;\n+    }\n+  return inline_summary (node)->size;\n }\n \n \n@@ -1826,8 +2066,8 @@ read_predicate (struct lto_input_block *ib)\n \n   do \n     {\n+      gcc_assert (k <= MAX_CLAUSES);\n       clause = out.clause[k++] = lto_input_uleb128 (ib);\n-      gcc_assert (k < MAX_CLAUSES);\n     }\n   while (clause);\n   return out;"}, {"sha": "480a9fadf293fa5ead3ce54b0ca0bfe3f1969d48", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=b15c64ee1aafcb68df59ecc46bd2c799d7618160", "patch": "@@ -48,7 +48,7 @@ typedef VEC(condition,gc) *conditions;\n    must be true in order for clause to be true.  */\n \n #define MAX_CLAUSES 8\n-typedef int clause_t;\n+typedef unsigned int clause_t;\n struct GTY(()) predicate\n {\n   clause_t clause[MAX_CLAUSES + 1];"}, {"sha": "1d7aeef2aa0e472f9729283d4b3dcc9204cb4e39", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-10.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-10.c?ref=b15c64ee1aafcb68df59ecc46bd2c799d7618160", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fdump-tree-optimized -fno-partial-inlining\" } */\n+void do_something1(void);\n+void do_something2(void);\n+void do_something3(void);\n+void do_something4(void);\n+void do_something5(void);\n+void do_something_big(int);\n+\n+int do_something (int size)\n+{\n+  if (__builtin_constant_p (size))\n+    switch (size)\n+      {\n+\tcase 1:do_something1 (); break;\n+\tcase 2:do_something2 (); break;\n+\tcase 5:do_something1 ();  do_something1 ();\n+\tcase 3:do_something3 (); break;\n+\tcase 4:do_something4 (); break;\n+      }\n+  else\n+    do_something_big (size);\n+}\n+extern int n;\n+main()\n+{\n+  do_something (2);\n+  do_something (3);\n+  do_something (5);\n+  do_something (70);\n+}\n+/* All calls should be inlined, except for do_something (5).  */\n+/* { dg-final { scan-tree-dump-not \"do_something1\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"do_something2\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"do_something3\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"do_something \\\\(5\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"do_something \\\\(70\\\\)\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "678dd852db6aedec71a9a7deda40d864e70ccb8b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15c64ee1aafcb68df59ecc46bd2c799d7618160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c?ref=b15c64ee1aafcb68df59ecc46bd2c799d7618160", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Os -fdump-tree-optimized\" } */\n+/* { dg-options \"-Os -fdump-tree-optimized -fno-partial-inlining\" } */\n \n /* When optimizing for size, t should be inlined when it expands to one call only.  */\n extern int q(int);"}]}