{"sha": "1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMxMjg5ZTdmYjJmZTliM2IzOTEyYzdlZmZhMWNlNDZjNjYxNjBhZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T12:28:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T12:28:37Z"}, "message": "[multiple changes]\n\n2010-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch6.adb (Check_Overriding_Indicator, New_Overloaded_Entity): When\n\tsetting attribute Overridden_Operation do not reference the entities\n\tgenerated by Derive_Subprograms but their aliased entity (which\n\tis the primitive inherited from the parent type).\n\n2010-10-26  Bob Duff  <duff@adacore.com>\n\n\t* namet.adb, namet.ads: Minor cleanup.\n\nFrom-SVN: r165948", "tree": {"sha": "7a5bc172e7a2a453a56a41318fa5aa392df35a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a5bc172e7a2a453a56a41318fa5aa392df35a3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/comments", "author": null, "committer": null, "parents": [{"sha": "3019e9b6be184ca563cf76bc70b03c2012095dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3019e9b6be184ca563cf76bc70b03c2012095dc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3019e9b6be184ca563cf76bc70b03c2012095dc7"}], "stats": {"total": 226, "additions": 151, "deletions": 75}, "files": [{"sha": "3d1b464c1b812e8226edf641a09038853af7425a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "patch": "@@ -1,3 +1,14 @@\n+2010-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Overriding_Indicator, New_Overloaded_Entity): When\n+\tsetting attribute Overridden_Operation do not reference the entities\n+\tgenerated by Derive_Subprograms but their aliased entity (which\n+\tis the primitive inherited from the parent type).\n+\n+2010-10-26  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.adb, namet.ads: Minor cleanup.\n+\n 2010-10-26  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "fc8b4e22ddacd4b44f34fb1a2b73a49bed9e7c94", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 101, "deletions": 70, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "patch": "@@ -123,112 +123,143 @@ package body Namet is\n    --------------\n \n    procedure Finalize is\n-      Max_Chain_Length : constant := 50;\n-      --  Max length of chains for which specific information is output\n+      F : array (Int range 0 .. 50) of Int;\n+      --  N'th entry is the number of chains of length N, except last entry,\n+      --  which is the number of chains of length F'Last or more.\n \n-      F : array (Int range 0 .. Max_Chain_Length) of Int;\n-      --  N'th entry is number of chains of length N\n+      Max_Chain_Length : Int := 0;\n+      --  Maximum length of all chains\n \n       Probes : Int := 0;\n       --  Used to compute average number of probes\n \n       Nsyms : Int := 0;\n       --  Number of symbols in table\n \n+      Verbosity : constant Int range 1 .. 3 := 1;\n+      pragma Warnings (Off, Verbosity);\n+      --  1 => print basic summary information\n+      --  2 => in addition print number of entries per hash chain\n+      --  3 => in addition print content of entries\n+\n    begin\n-      if Debug_Flag_H then\n-         for J in F'Range loop\n-            F (J) := 0;\n-         end loop;\n+      if not Debug_Flag_H then\n+         return;\n+      end if;\n \n-         for J in Hash_Index_Type loop\n-            if Hash_Table (J) = No_Name then\n-               F (0) := F (0) + 1;\n+      for J in F'Range loop\n+         F (J) := 0;\n+      end loop;\n \n-            else\n-               Write_Str (\"Hash_Table (\");\n-               Write_Int (J);\n-               Write_Str (\") has \");\n+      for J in Hash_Index_Type loop\n+         if Hash_Table (J) = No_Name then\n+            F (0) := F (0) + 1;\n \n-               declare\n-                  C : Int := 1;\n-                  N : Name_Id;\n-                  S : Int;\n+         else\n+            declare\n+               C : Int;\n+               N : Name_Id;\n+               S : Int;\n+\n+            begin\n+               C := 0;\n+               N := Hash_Table (J);\n+\n+               while N /= No_Name loop\n+                  N := Name_Entries.Table (N).Hash_Link;\n+                  C := C + 1;\n+               end loop;\n \n-               begin\n-                  C := 0;\n-                  N := Hash_Table (J);\n+               Nsyms := Nsyms + 1;\n+               Probes := Probes + (1 + C) * 100;\n \n-                  while N /= No_Name loop\n-                     N := Name_Entries.Table (N).Hash_Link;\n-                     C := C + 1;\n-                  end loop;\n+               if C > Max_Chain_Length then\n+                  Max_Chain_Length := C;\n+               end if;\n \n+               if Verbosity >= 2 then\n+                  Write_Str (\"Hash_Table (\");\n+                  Write_Int (J);\n+                  Write_Str (\") has \");\n                   Write_Int (C);\n                   Write_Str (\" entries\");\n                   Write_Eol;\n+               end if;\n \n-                  if C < Max_Chain_Length then\n-                     F (C) := F (C) + 1;\n-                  else\n-                     F (Max_Chain_Length) := F (Max_Chain_Length) + 1;\n-                  end if;\n+               if C < F'Last then\n+                  F (C) := F (C) + 1;\n+               else\n+                  F (F'Last) := F (F'Last) + 1;\n+               end if;\n \n-                  N := Hash_Table (J);\n+               N := Hash_Table (J);\n \n-                  while N /= No_Name loop\n-                     S := Name_Entries.Table (N).Name_Chars_Index;\n+               while N /= No_Name loop\n+                  S := Name_Entries.Table (N).Name_Chars_Index;\n+\n+                  if Verbosity >= 3 then\n                      Write_Str (\"      \");\n \n                      for J in 1 .. Name_Entries.Table (N).Name_Len loop\n                         Write_Char (Name_Chars.Table (S + Int (J)));\n                      end loop;\n \n                      Write_Eol;\n-                     N := Name_Entries.Table (N).Hash_Link;\n-                  end loop;\n-               end;\n-            end if;\n-         end loop;\n-\n-         Write_Eol;\n+                  end if;\n \n-         for J in Int range 0 .. Max_Chain_Length loop\n-            if F (J) /= 0 then\n-               Write_Str (\"Number of hash chains of length \");\n+                  N := Name_Entries.Table (N).Hash_Link;\n+               end loop;\n+            end;\n+         end if;\n+      end loop;\n \n-               if J < 10 then\n-                  Write_Char (' ');\n-               end if;\n+      Write_Eol;\n \n-               Write_Int (J);\n+      for J in F'Range loop\n+         if F (J) /= 0 then\n+            Write_Str (\"Number of hash chains of length \");\n \n-               if J = Max_Chain_Length then\n-                  Write_Str (\" or greater\");\n-               end if;\n+            if J < 10 then\n+               Write_Char (' ');\n+            end if;\n \n-               Write_Str (\" = \");\n-               Write_Int (F (J));\n-               Write_Eol;\n+            Write_Int (J);\n \n-               if J /= 0 then\n-                  Nsyms := Nsyms + F (J);\n-                  Probes := Probes + F (J) * (1 + J) * 100;\n-               end if;\n+            if J = F'Last then\n+               Write_Str (\" or greater\");\n             end if;\n-         end loop;\n \n-         Write_Eol;\n-         Write_Str (\"Average number of probes for lookup = \");\n-         Probes := Probes / Nsyms;\n-         Write_Int (Probes / 200);\n-         Write_Char ('.');\n-         Probes := (Probes mod 200) / 2;\n-         Write_Char (Character'Val (48 + Probes / 10));\n-         Write_Char (Character'Val (48 + Probes mod 10));\n-         Write_Eol;\n-         Write_Eol;\n-      end if;\n+            Write_Str (\" = \");\n+            Write_Int (F (J));\n+            Write_Eol;\n+         end if;\n+      end loop;\n+\n+      --  Print out average number of probes, in the case where Name_Find is\n+      --  called for a string that is already in the table.\n+\n+      Write_Eol;\n+      Write_Str (\"Average number of probes for lookup = \");\n+      Probes := Probes / Nsyms;\n+      Write_Int (Probes / 200);\n+      Write_Char ('.');\n+      Probes := (Probes mod 200) / 2;\n+      Write_Char (Character'Val (48 + Probes / 10));\n+      Write_Char (Character'Val (48 + Probes mod 10));\n+      Write_Eol;\n+\n+      Write_Str (\"Max_Chain_Length = \");\n+      Write_Int (Max_Chain_Length);\n+      Write_Eol;\n+      Write_Str (\"Name_Chars'Length = \");\n+      Write_Int (Name_Chars.Last - Name_Chars.First + 1);\n+      Write_Eol;\n+      Write_Str (\"Name_Entries'Length = \");\n+      Write_Int (Int (Name_Entries.Last - Name_Entries.First + 1));\n+      Write_Eol;\n+      Write_Str (\"Nsyms = \");\n+      Write_Int (Nsyms);\n+      Write_Eol;\n    end Finalize;\n \n    -----------------------------"}, {"sha": "8eb56835bbad47581ca5af3b10470146f58f94e3", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "patch": "@@ -70,7 +70,7 @@ package Namet is\n --                       followed by an upper case letter or an underscore.\n \n --    Character literals Character literals have names that are used only for\n---                       debugging and error message purposes. The form is a\n+--                       debugging and error message purposes. The form is an\n --                       upper case Q followed by a single lower case letter,\n --                       or by a Uxx/Wxxxx/WWxxxxxxx encoding as described for\n --                       identifiers. The Set_Character_Literal_Name procedure\n@@ -139,8 +139,8 @@ package Namet is\n    -----------------------------\n \n    --  Name_Id values are used to identify entries in the names table. Except\n-   --  for the special values No_Name, and Error_Name, they are subscript\n-   --  values for the Names table defined in package Namet.\n+   --  for the special values No_Name and Error_Name, they are subscript values\n+   --  for the Names table defined in this package.\n \n    --  Note that with only a few exceptions, which are clearly documented, the\n    --  type Name_Id should be regarded as a private type. In particular it is"}, {"sha": "8abe3cd79248445f9ce75d0b587f3c7e08f719e1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1c1289e7fb2fe9b3b3912c7effa1ce46c66160ad", "patch": "@@ -4672,7 +4672,25 @@ package body Sem_Ch6 is\n             end if;\n \n          elsif Is_Subprogram (Subp) then\n-            Set_Overridden_Operation (Subp, Overridden_Subp);\n+            if No (Overridden_Operation (Subp)) then\n+\n+               --  For entities generated by Derive_Subprograms the overridden\n+               --  operation is the inherited primitive (which is available\n+               --  through the attribute alias)\n+\n+               if (Is_Dispatching_Operation (Subp)\n+                     or else Is_Dispatching_Operation (Overridden_Subp))\n+                 and then not Comes_From_Source (Overridden_Subp)\n+                 and then Find_Dispatching_Type (Overridden_Subp)\n+                            = Find_Dispatching_Type (Subp)\n+                 and then Present (Alias (Overridden_Subp))\n+                 and then Comes_From_Source (Alias (Overridden_Subp))\n+               then\n+                  Set_Overridden_Operation (Subp, Alias (Overridden_Subp));\n+               else\n+                  Set_Overridden_Operation (Subp, Overridden_Subp);\n+               end if;\n+            end if;\n          end if;\n \n          --  If primitive flag is set or this is a protected operation, then\n@@ -8142,7 +8160,23 @@ package body Sem_Ch6 is\n                      end if;\n \n                      Enter_Overloaded_Entity (S);\n-                     Set_Overridden_Operation (S, E);\n+\n+                     --  For entities generated by Derive_Subprograms the\n+                     --  overridden operation is the inherited primitive\n+                     --  (which is available through the attribute alias).\n+\n+                     if not (Comes_From_Source (E))\n+                       and then Is_Dispatching_Operation (E)\n+                       and then Find_Dispatching_Type (E)\n+                                  = Find_Dispatching_Type (S)\n+                       and then Present (Alias (E))\n+                       and then Comes_From_Source (Alias (E))\n+                     then\n+                        Set_Overridden_Operation (S, Alias (E));\n+                     else\n+                        Set_Overridden_Operation (S, E);\n+                     end if;\n+\n                      Check_Overriding_Indicator (S, E, Is_Primitive => True);\n \n                      --  If S is a user-defined subprogram or a null procedure"}]}