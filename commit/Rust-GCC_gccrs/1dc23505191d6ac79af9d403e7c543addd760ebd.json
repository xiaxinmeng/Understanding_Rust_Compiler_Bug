{"sha": "1dc23505191d6ac79af9d403e7c543addd760ebd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjMjM1MDUxOTFkNmFjNzlhZjlkNDAzZTdjNTQzYWRkZDc2MGViZA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2018-03-06T21:11:46Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2018-03-06T21:11:46Z"}, "message": "re PR c++/84684 (inserting random code / flags produces wrong code)\n\n\tPR c++/84684\n\t* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated\n\targuments.\n\n\t* g++.dg/cpp1z/constexpr-84684.C: New test.\n\nFrom-SVN: r258303", "tree": {"sha": "340e30c9dd00d90c29656bf58a339c40b6f6f53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/340e30c9dd00d90c29656bf58a339c40b6f6f53c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dc23505191d6ac79af9d403e7c543addd760ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc23505191d6ac79af9d403e7c543addd760ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc23505191d6ac79af9d403e7c543addd760ebd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc23505191d6ac79af9d403e7c543addd760ebd/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "849bbdb99c5c8b1a97041a533c69bbaf8376c975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849bbdb99c5c8b1a97041a533c69bbaf8376c975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/849bbdb99c5c8b1a97041a533c69bbaf8376c975"}], "stats": {"total": 176, "additions": 176, "deletions": 0}, "files": [{"sha": "ac7bd4b749e8d06bf73ed9f88191f1d275f57ffe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1dc23505191d6ac79af9d403e7c543addd760ebd", "patch": "@@ -1,3 +1,9 @@\n+2018-03-06  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/84684\n+\t* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated\n+\targuments.\n+\n 2018-03-06  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/84231"}, {"sha": "bd53bfbfe4730893413c27143782f4467f90ee7d", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=1dc23505191d6ac79af9d403e7c543addd760ebd", "patch": "@@ -1313,6 +1313,8 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \n       if (!*non_constant_p)\n \t{\n+\t  /* Don't share a CONSTRUCTOR that might be changed.  */\n+\t  arg = unshare_constructor (arg);\n \t  /* Make sure the binding has the same type as the parm.  But\n \t     only for constant args.  */\n \t  if (TREE_CODE (type) != REFERENCE_TYPE)"}, {"sha": "9ca476fdef555f320c9047df941d71c78c532e67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1dc23505191d6ac79af9d403e7c543addd760ebd", "patch": "@@ -1,3 +1,8 @@\n+2018-03-06  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/84684\n+\t* g++.dg/cpp1z/constexpr-84684.C: New test.\n+\n 2018-03-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/84721"}, {"sha": "0e7912d406704b9ee4af211ee0c9fcb112b00dd0", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-84684.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc23505191d6ac79af9d403e7c543addd760ebd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-84684.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-84684.C?ref=1dc23505191d6ac79af9d403e7c543addd760ebd", "patch": "@@ -0,0 +1,163 @@\n+// PR c++/84684\n+// { dg-options -std=c++17 }\n+\n+typedef decltype (sizeof (0)) size_t;\n+\n+namespace std {\n+  template<class _E>\n+  struct initializer_list\n+  {\n+    typedef _E value_type;\n+    typedef const _E& reference;\n+    typedef const _E& const_reference;\n+    typedef size_t size_type;\n+    typedef const _E* iterator;\n+    typedef const _E* const_iterator;\n+    iterator _M_array;\n+    size_type _M_len;\n+    constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) { }\n+    constexpr initializer_list() noexcept : _M_array(0), _M_len(0) { }\n+    constexpr size_type size() const noexcept { return _M_len; }\n+    constexpr const_iterator begin() const noexcept { return _M_array; }\n+    constexpr const_iterator end() const noexcept { return begin() + size(); }\n+  };\n+}\n+\n+template <typename E, size_t N>\n+struct array\n+{\n+  constexpr E &operator[](size_t n) noexcept { return elems[n]; }\n+  constexpr const E &operator[](size_t n) const noexcept { return elems[n]; }\n+  constexpr size_t size() const { return N; }\n+  E elems[N];\n+};\n+\n+template<typename T>\n+constexpr\n+inline T\n+max (std::initializer_list<T> i)\n+{\n+  const T *b = i.begin ();\n+  const T *e = i.end ();\n+  if (b == e) return *b;\n+  const T *r = b;\n+  while (++b != e)\n+  if (*r < *b)\n+    r = b;\n+  return *r;\n+}\n+\n+template <typename alphabet_type>\n+constexpr char to_char(alphabet_type const alph)\n+{\n+  return alph.to_char();\n+}\n+\n+template <typename ...alphabet_types>\n+struct union_composition\n+{\n+  static constexpr size_t value_size = (alphabet_types::value_size + ... );\n+  unsigned char _value;\n+  template <size_t fixed_size, typename alphabet_t>\n+  static constexpr auto value_to_char_helper(alphabet_t alphabet)\n+  {\n+    array<char, fixed_size> value_to_char{};\n+    for (size_t i = 0u; i < alphabet_t::value_size; ++i)\n+      value_to_char[i] = to_char(alphabet.assign_rank(i));\n+    return value_to_char;\n+  }\n+\n+  static constexpr auto make_value_to_char()\n+  {\n+    constexpr auto N = sizeof...(alphabet_types);\n+    constexpr array<size_t, N> alphabet_sizes { alphabet_types::value_size... };\n+    constexpr size_t fixed_size = max({alphabet_types::value_size...});\n+    array value_to_char_tables = array<array<char, fixed_size>, N> {\n+      value_to_char_helper<fixed_size>(alphabet_types{})...\n+    };\n+    array<char, value_size> value_to_char{};\n+    for (size_t i = 0u, value = 0u; i < N; ++i)\n+      for (size_t k = 0u; k < alphabet_sizes[i]; ++k, ++value)\n+        value_to_char[value] = value_to_char_tables[i][k];\n+    return value_to_char;\n+  }\n+};\n+\n+struct gap\n+{\n+  constexpr char to_char() const noexcept { return '-'; }\n+  constexpr gap & assign_rank([[maybe_unused]] bool const i) noexcept { return *this; }\n+  static constexpr size_t value_size{1};\n+};\n+\n+struct dna4\n+{\n+  constexpr char to_char() const noexcept { return value_to_char[_value]; }\n+  constexpr dna4 & assign_rank(unsigned char const c) { _value = c; return *this; }\n+  static constexpr size_t value_size{4};\n+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T' };\n+  unsigned char _value;\n+};\n+\n+struct dna5\n+{\n+  constexpr char to_char() const noexcept { return value_to_char[_value]; }\n+  constexpr dna5 & assign_rank(unsigned char const c) { _value = c; return *this; }\n+  static constexpr size_t value_size{5};\n+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T', 'N' };\n+  unsigned char _value;\n+};\n+\n+constexpr array value_to_char1 = union_composition<dna4>::make_value_to_char();\n+static_assert(value_to_char1.size() == 4u);\n+static_assert(value_to_char1[0] == 'A');\n+static_assert(value_to_char1[1] == 'C');\n+static_assert(value_to_char1[2] == 'G');\n+static_assert(value_to_char1[3] == 'T');\n+\n+constexpr array value_to_char2 = union_composition<dna4, gap>::make_value_to_char();\n+static_assert(value_to_char2.size() == 5u);\n+static_assert(value_to_char2[0] == 'A');\n+static_assert(value_to_char2[1] == 'C');\n+static_assert(value_to_char2[2] == 'G');\n+static_assert(value_to_char2[3] == 'T');\n+static_assert(value_to_char2[4] == '-');\n+\n+constexpr array value_to_char3 = union_composition<dna4, gap, dna5>::make_value_to_char();\n+static_assert(value_to_char3.size() == 10u);\n+static_assert(value_to_char3[0] == 'A');\n+static_assert(value_to_char3[1] == 'C');\n+static_assert(value_to_char3[2] == 'G');\n+static_assert(value_to_char3[3] == 'T');\n+static_assert(value_to_char3[4] == '-');\n+static_assert(value_to_char3[5] == 'A');\n+static_assert(value_to_char3[6] == 'C');\n+static_assert(value_to_char3[7] == 'G');\n+static_assert(value_to_char3[8] == 'T');\n+static_assert(value_to_char3[9] == 'N');\n+\n+constexpr array value_to_char4 = union_composition<dna5, gap, dna4>::make_value_to_char();\n+static_assert(value_to_char4.size() == 10u);\n+static_assert(value_to_char4[0] == 'A');\n+static_assert(value_to_char4[1] == 'C');\n+static_assert(value_to_char4[2] == 'G');\n+static_assert(value_to_char4[3] == 'T');\n+static_assert(value_to_char4[4] == 'N');\n+static_assert(value_to_char4[5] == '-');\n+static_assert(value_to_char4[6] == 'A');\n+static_assert(value_to_char4[7] == 'C');\n+static_assert(value_to_char4[8] == 'G');\n+static_assert(value_to_char4[9] == 'T');\n+\n+constexpr array value_to_char5 = union_composition<gap, dna4, dna5>::make_value_to_char();\n+static_assert(value_to_char5.size() == 10u);\n+static_assert(value_to_char5[0] == '-');\n+static_assert(value_to_char5[1] == 'A');\n+static_assert(value_to_char5[2] == 'C');\n+static_assert(value_to_char5[3] == 'G');\n+static_assert(value_to_char5[4] == 'T');\n+static_assert(value_to_char5[5] == 'A');\n+static_assert(value_to_char5[6] == 'C');\n+static_assert(value_to_char5[7] == 'G');\n+static_assert(value_to_char5[8] == 'T');\n+static_assert(value_to_char5[9] == 'N');"}]}