{"sha": "c5e12904bcca3866f419bb91365dbdfb052b8782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlMTI5MDRiY2NhMzg2NmY0MTliYjkxMzY1ZGJkZmIwNTJiODc4Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:35:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:35:16Z"}, "message": "decl.c (compatible_signatures_p): New function.\n\n\t* decl.c (compatible_signatures_p): New function. The intended purpose\n\tis to check if two function signatures for a call-site and a callee are\n\tcompatible enough for the call to be valid. The underlying purpose is\n\tto check if a call to a mapped builtin is using the right interface.\n\tThe current code actually does not check antyhing - this a placeholder\n\tfor future refinements.\n\t(gnat_to_gnu_entity) <E_Subprogram_Call>: Add preliminary bits to handle\n\tbuiltin calls for convention Intrinsic.\n\n\t* gigi.h (builtin_decl_for): Declare (new function).\n\n\t* utils.c (gnat_install_builtins): Install the target specific builtins.\n\t(builtin_decl_for): New function, provide a dummy body for now.\n\nFrom-SVN: r92833", "tree": {"sha": "53590e1867ac15c4a766621c129b8b6971ad96f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53590e1867ac15c4a766621c129b8b6971ad96f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e12904bcca3866f419bb91365dbdfb052b8782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e12904bcca3866f419bb91365dbdfb052b8782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e12904bcca3866f419bb91365dbdfb052b8782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e12904bcca3866f419bb91365dbdfb052b8782/comments", "author": null, "committer": null, "parents": [{"sha": "ddda9d0f19611a053a759c415cc2f835c1051f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddda9d0f19611a053a759c415cc2f835c1051f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddda9d0f19611a053a759c415cc2f835c1051f22"}], "stats": {"total": 94, "additions": 91, "deletions": 3}, "files": [{"sha": "710d0f1a4f07e00ec4e3cdb3fc1625cf25a6b198", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=c5e12904bcca3866f419bb91365dbdfb052b8782", "patch": "@@ -101,7 +101,8 @@ static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n-\f\n+static int  compatible_signatures_p (tree ftype1, tree ftype2);\n+\n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n    refer to an Ada type.  */\n@@ -3242,6 +3243,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   corresponding to that field.  This list will be saved in the\n \t   TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n \ttree gnu_return_list = NULL_TREE;\n+\t/* If an import pragma asks to map this subprogram to a GCC builtin,\n+\t   this is the builtin DECL node.  */\n+\ttree gnu_builtin_decl = NULL_TREE;\n \tEntity_Id gnat_param;\n \tbool inline_flag = Is_Inlined (gnat_entity);\n \tbool public_flag = Is_Public (gnat_entity);\n@@ -3283,6 +3287,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n+\t/* If this subprogram is expectedly bound to a GCC builtin, fetch the\n+\t   corresponding DECL node.\n+\n+\t   We still want the parameter associations to take place because the\n+\t   proper generation of calls depends on it (a GNAT parameter without\n+\t   a corresponding GCC tree has a very specific meaning), so we don't\n+\t   just break here.  */\n+\tif (Convention (gnat_entity) == Convention_Intrinsic)\n+\t  gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n+\n+\t/* ??? What if we don't find the builtin node above ? warn ? err ?\n+\t   In the current state we neither warn nor err, and calls will just\n+\t   be handled as for regular subprograms. */\n+\n \tif (kind == E_Function || kind == E_Subprogram_Type)\n \t  gnu_return_type = gnat_to_gnu_type (Etype (gnat_entity));\n \n@@ -3378,9 +3396,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    bool copy_in_copy_out_flag = false;\n \t    bool req_by_copy = false, req_by_ref = false;\n \n-\t    /* See if a Mechanism was supplied that forced this\n+\t    /* Builtins are expanded inline and there is no real call sequence\n+\t       involved. so the type expected by the underlying expander is\n+\t       always the type of each argument \"as is\".  */\n+\t    if (gnu_builtin_decl)\n+\t      req_by_copy = 1;\n+\n+\t    /* Otherwise, see if a Mechanism was supplied that forced this\n \t       parameter to be passed one way or another.  */\n-\t    if (Is_Valued_Procedure (gnat_entity) && parmnum == 0)\n+\t    else if (Is_Valued_Procedure (gnat_entity) && parmnum == 0)\n \t      req_by_copy = true;\n \t    else if (Mechanism (gnat_param) == Default)\n \t      ;\n@@ -3638,6 +3662,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \tSloc_to_locus (Sloc (gnat_entity), &input_location);\n \n+        /* If we have a builtin decl for that function, check the signatures\n+           compatibilities.  If the signatures are compatible, use the builtin\n+           decl.  If they are not, we expect the checker predicate to have\n+           posted the appropriate errors, and just continue with what we have\n+           so far.  */\n+        if (gnu_builtin_decl)\n+          {\n+            tree gnu_builtin_type =  TREE_TYPE (gnu_builtin_decl);\n+\n+            if (compatible_signatures_p (gnu_type, gnu_builtin_type))\n+              {\n+                gnu_decl = gnu_builtin_decl;\n+                gnu_type = gnu_builtin_type;\n+                break;\n+              }\n+          }\n+\n \t/* If there was no specified Interface_Name and the external and\n \t   internal names of the subprogram are the same, only use the\n \t   internal name to allow disambiguation of nested subprograms.  */\n@@ -6210,6 +6251,34 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, bool comp_p)\n \t\t   gnat_error_point, gnat_entity);\n }\n \f\n+/* Check if FTYPE1 and FTYPE2, two potentially different function type nodes,\n+   have compatible signatures so that a call using one type may be safely\n+   issued if the actual target function type is the other. Return 1 if it is\n+   the case, 0 otherwise, and post errors on the incompatibilities.\n+\n+   This is used when an Ada subprogram is mapped onto a GCC builtin, to ensure\n+   that calls to the subprogram will have arguments suitable for the later\n+   underlying builtin expansion.  */\n+\n+static int\n+compatible_signatures_p (tree ftype1, tree ftype2)\n+{\n+  /* As of now, we only perform very trivial tests and consider it's the\n+     programmer's responsability to ensure the type correctness in the Ada\n+     declaration, as in the regular Import cases.\n+\n+     Mismatches typically result in either error messages from the builtin\n+     expander, internal compiler errors, or in a real call sequence.  This\n+     should be refined to issue diagnostics helping error detection and\n+     correction.  */\n+\n+  /* Almost fake test, ensuring a use of each argument.  */\n+  if (ftype1 == ftype2)\n+    return 1;\n+\n+  return 1;\n+}\n+\f\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a new type\n    with all size expressions that contain F updated by replacing F with R.\n    This is identical to GCC's substitute_in_type except that it knows about"}, {"sha": "bb03912a637ff92b7c7c64c4f233cdba9f6c2fa8", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c5e12904bcca3866f419bb91365dbdfb052b8782", "patch": "@@ -687,6 +687,11 @@ extern bool gnat_mark_addressable (tree);\n extern tree builtin_function (const char *, tree, int, enum built_in_class,\n \t\t\t      const char *, tree);\n \n+/* Search the chain of currently reachable declarations for a builtin\n+   FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n+   Return the first node found, if any, or NULL_TREE otherwise.  */\n+extern tree builtin_decl_for (tree);\n+\n /* This function is called by the front end to enumerate all the supported\n    modes for the machine.  We pass a function which is called back with\n    the following integer parameters:"}, {"sha": "b92fe4bd7c6f89cedbc9ea341704f3cbe40f682c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e12904bcca3866f419bb91365dbdfb052b8782/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c5e12904bcca3866f419bb91365dbdfb052b8782", "patch": "@@ -509,6 +509,9 @@ gnat_install_builtins ()\n   ftype = build_function_type (ptr_void_type_node, tmp);\n   gnat_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n \t\t       \"alloca\", false);\n+\n+  /* Target specific builtins, such as the AltiVec family on ppc.  */\n+  targetm.init_builtins ();\n }\n \n /* Create the predefined scalar types such as `integer_type_node' needed\n@@ -3305,6 +3308,17 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \n   return expr;\n }\n+\f\n+/* Search the chain of currently reachable declarations for a builtin\n+   FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n+   Return the first node found, if any, or NULL_TREE otherwise.  */\n+tree\n+builtin_decl_for (tree name __attribute__ ((unused)))\n+{\n+  /* ??? not clear yet how to implement this function in tree-ssa, so\n+     return NULL_TREE for now */\n+  return NULL_TREE;\n+}\n \n #include \"gt-ada-utils.h\"\n #include \"gtype-ada.h\""}]}