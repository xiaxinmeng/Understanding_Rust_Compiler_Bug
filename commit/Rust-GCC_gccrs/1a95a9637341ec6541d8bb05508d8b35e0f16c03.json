{"sha": "1a95a9637341ec6541d8bb05508d8b35e0f16c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE5NWE5NjM3MzQxZWM2NTQxZDhiYjA1NTA4ZDhiMzVlMGYxNmMwMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-18T22:41:00Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-18T22:41:00Z"}, "message": "(ctype.h): Delete.\n\n(regno_reg_class, reg_class_from_letter, prepare_scc_operands,\nbroken_move, push, pop, push_regs, calc_live_regs, sh_expand_prologue,\nsh_expand_epilogue, initial_elimination_offset, arith_reg_operand):\nAdd SH3e support.\n(sh_builtin_saveregs, fp_zero_operand, fp_one_operand): New functions.\n(sh_function_arg, sh_function_arg_partial_nregs): Delete.\n\nFrom-SVN: r11068", "tree": {"sha": "84bf9efa55ad53ce50f29919daabec4ccd35e43f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84bf9efa55ad53ce50f29919daabec4ccd35e43f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a95a9637341ec6541d8bb05508d8b35e0f16c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a95a9637341ec6541d8bb05508d8b35e0f16c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a95a9637341ec6541d8bb05508d8b35e0f16c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a95a9637341ec6541d8bb05508d8b35e0f16c03/comments", "author": null, "committer": null, "parents": [{"sha": "5c3ea8054637ec397cdc68b22f3c06ce7920a205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c3ea8054637ec397cdc68b22f3c06ce7920a205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c3ea8054637ec397cdc68b22f3c06ce7920a205"}], "stats": {"total": 234, "additions": 154, "deletions": 80}, "files": [{"sha": "1a9cda919c19077413c5265abb51edaac13a0ee0", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 154, "deletions": 80, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a95a9637341ec6541d8bb05508d8b35e0f16c03/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a95a9637341ec6541d8bb05508d8b35e0f16c03/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1a95a9637341ec6541d8bb05508d8b35e0f16c03", "patch": "@@ -23,7 +23,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n \n-#include <ctype.h>\n #include <stdio.h>\n \n #include \"rtl.h\"\n@@ -85,7 +84,11 @@ int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, PR_REGS, T_REGS, NO_REGS,\n-  MAC_REGS, MAC_REGS,\n+  MAC_REGS, MAC_REGS, FPUL_REGS, NO_REGS,\n+  FP0_REGS,FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n };\n \n /* Provide reg_class from a letter such as appears in the machine\n@@ -94,12 +97,12 @@ int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n enum reg_class reg_class_from_letter[] =\n {\n   /* a */ NO_REGS, /* b */ NO_REGS, /* c */ NO_REGS, /* d */ NO_REGS,\n-  /* e */ NO_REGS, /* f */ NO_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n+  /* e */ NO_REGS, /* f */ FP_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n   /* i */ NO_REGS, /* j */ NO_REGS, /* k */ NO_REGS, /* l */ PR_REGS,\n   /* m */ NO_REGS, /* n */ NO_REGS, /* o */ NO_REGS, /* p */ NO_REGS,\n   /* q */ NO_REGS, /* r */ NO_REGS, /* s */ NO_REGS, /* t */ T_REGS,\n-  /* u */ NO_REGS, /* v */ NO_REGS, /* w */ NO_REGS, /* x */ MAC_REGS,\n-  /* y */ NO_REGS, /* z */ R0_REGS\n+  /* u */ NO_REGS, /* v */ NO_REGS, /* w */ FP0_REGS, /* x */ MAC_REGS,\n+  /* y */ FPUL_REGS, /* z */ R0_REGS\n };\n \f\n /* Print the operand address in x to the stream.  */\n@@ -367,6 +370,8 @@ prepare_scc_operands (code)\n \t  || code == GTU  || code == GEU || code == LTU || code == LEU))\n     sh_compare_op1 = force_reg (mode, sh_compare_op1);\n \n+  /* ??? This should be `mode' not `SImode' in the compare, but that would\n+     require fixing the branch patterns too.  */\n   emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n \t\t      gen_rtx (code, SImode, sh_compare_op0,\n \t\t\t       sh_compare_op1)));\n@@ -1212,6 +1217,12 @@ broken_move (insn)\n \t order bits end up as.  */\n       && GET_MODE (SET_DEST (PATTERN (insn))) != QImode\n       && CONSTANT_P (SET_SRC (PATTERN (insn)))\n+      && ! (GET_CODE (SET_SRC (PATTERN (insn))) == CONST_DOUBLE\n+\t    && (fp_zero_operand (SET_SRC (PATTERN (insn)))\n+\t\t|| fp_one_operand (SET_SRC (PATTERN (insn))))\n+\t    && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n+\t    && REGNO (SET_DEST (PATTERN (insn))) >= FIRST_FP_REG\n+\t    && REGNO (SET_DEST (PATTERN (insn))) <= LAST_FP_REG)\n       && (GET_CODE (SET_SRC (PATTERN (insn))) != CONST_INT\n \t  || ! CONST_OK_FOR_I (INTVAL (SET_SRC (PATTERN (insn))))))\n     return 1;\n@@ -1828,7 +1839,12 @@ push (rn)\n      int rn;\n {\n   rtx x;\n-  x = emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n+  if ((rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n+      || rn == FPUL_REG)\n+    x = emit_insn (gen_push_e (gen_rtx (REG, SFmode, rn)));\n+  else\n+    x = emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n+\n   REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n \t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n }\n@@ -1840,7 +1856,12 @@ pop (rn)\n      int rn;\n {\n   rtx x;\n-  x = emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n+  if ((rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n+      || rn == FPUL_REG)\n+    x = emit_insn (gen_pop_e (gen_rtx (REG, SFmode, rn)));\n+  else\n+    x = emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n+    \n   REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n \t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n }\n@@ -1849,14 +1870,17 @@ pop (rn)\n    the number of bytes the insns take.  */\n \n static void\n-push_regs (mask)\n-     int mask;\n+push_regs (mask, mask2)\n+     int mask, mask2;\n {\n   int i;\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (i = 0; i < 32; i++)\n     if (mask & (1 << i))\n       push (i);\n+  for (i = 32; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (mask2 & (1 << (i - 32)))\n+      push (i);\n }\n \n /* Work out the registers which need to be saved, both as a mask and a\n@@ -1867,27 +1891,29 @@ push_regs (mask)\n    make sure that all the regs it clobbers are safe too.  */\n \n static int\n-calc_live_regs (count_ptr)\n+calc_live_regs (count_ptr, live_regs_mask2)\n      int *count_ptr;\n+     int *live_regs_mask2;\n {\n   int reg;\n   int live_regs_mask = 0;\n   int count = 0;\n \n+  *live_regs_mask2 = 0;\n   for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     {\n       if (pragma_interrupt && ! pragma_trapa)\n \t{\n-\t  /* Normally, we must save all the regs ever live.\n-\t     If pragma_nosave_low_regs, then don't save any of the\n-\t     registers which are banked on the SH3.  */\n+\t  /* Need to save all the regs ever live.  */\n \t  if ((regs_ever_live[reg]\n \t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n \t      && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n-\t      && reg != T_REG && reg != GBR_REG\n-\t      && ! (sh_cpu == CPU_SH3 && pragma_nosave_low_regs && reg < 8))\n+\t      && reg != T_REG && reg != GBR_REG)\n \t    {\n-\t      live_regs_mask |= 1 << reg;\n+\t      if (reg >= 32)\n+\t\t*live_regs_mask2 |= 1 << (reg - 32);\n+\t      else\n+\t\tlive_regs_mask |= 1 << reg;\n \t      count++;\n \t    }\n \t}\n@@ -1896,7 +1922,10 @@ calc_live_regs (count_ptr)\n \t  /* Only push those regs which are used and need to be saved.  */\n \t  if (regs_ever_live[reg] && ! call_used_regs[reg])\n \t    {\n-\t      live_regs_mask |= (1 << reg);\n+\t      if (reg >= 32)\n+\t\t*live_regs_mask2 |= 1 << (reg - 32);\n+\t      else\n+\t\tlive_regs_mask |= (1 << reg);\n \t      count++;\n \t    }\n \t}\n@@ -1913,7 +1942,8 @@ sh_expand_prologue ()\n {\n   int live_regs_mask;\n   int d, i;\n-  live_regs_mask = calc_live_regs (&d);\n+  int live_regs_mask2;\n+  live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n \n   /* We have pretend args if we had an object sent partially in registers\n      and partially on the stack, e.g. a large structure.  */\n@@ -1922,23 +1952,30 @@ sh_expand_prologue ()\n   extra_push = 0;\n \n   /* This is set by SETUP_VARARGS to indicate that this is a varargs\n-     routine.  Clear it here so that the next function isn't affected.  */\n+     routine.  Clear it here so that the next function isn't affected. */\n   if (current_function_anonymous_args)\n     {\n       current_function_anonymous_args = 0;\n \n-      /* Push arg regs as if they'd been provided by caller in stack.  */\n-      for (i = 0; i < NPARM_REGS; i++)\n-\t{\n-\t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n-\t  if (i > (NPARM_REGS - current_function_args_info\n-\t\t   - current_function_varargs))\n-\t    break;\n-\t  push (rn);\n-\t  extra_push += 4;\n-\t}\n+      /* This is not used by the SH3E calling convention  */\n+      if (!TARGET_SH3E)\n+        {\n+\t  /* Push arg regs as if they'd been provided by caller in stack.  */\n+\t  for (i = 0; i < NPARM_REGS(SImode); i++)\n+\t    {\n+\t      int rn = NPARM_REGS(SImode) + FIRST_PARM_REG - i - 1;\n+\t      if (i > (NPARM_REGS(SImode) \n+\t\t       - current_function_args_info.arg_count[(int) SH_ARG_INT]\n+\t\t       - current_function_varargs))\n+\t\tbreak;\n+\t      push (rn);\n+\t      extra_push += 4;\n+\t    }\n+        }\n     }\n-  push_regs (live_regs_mask);\n+\n+  push_regs (live_regs_mask, live_regs_mask2);\n+\n   output_stack_adjust (-get_frame_size (), stack_pointer_rtx);\n \n   if (frame_pointer_needed)\n@@ -1951,7 +1988,8 @@ sh_expand_epilogue ()\n   int live_regs_mask;\n   int d, i;\n \n-  live_regs_mask = calc_live_regs (&d);\n+  int live_regs_mask2;\n+  live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n \n   if (frame_pointer_needed)\n     {\n@@ -1970,7 +2008,9 @@ sh_expand_epilogue ()\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n-      if (live_regs_mask & (1 << j))\n+      if (j < 32 && (live_regs_mask & (1 << j)))\n+\tpop (j);\n+      else if (j >= 32 && (live_regs_mask2 & (1 << (j - 32))))\n \tpop (j);\n     }\n \n@@ -1988,6 +2028,62 @@ function_epilogue (stream, size)\n   pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n }\n \n+rtx\n+sh_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  /* First unnamed integer register.  */\n+  int first_intreg = current_function_args_info.arg_count[(int) SH_ARG_INT];\n+  /* Number of integer registers we need to save.  */\n+  int n_intregs = MAX (0, NPARM_REGS (SImode) - first_intreg);\n+  /* First unnamed SFmode float reg */\n+  int first_floatreg = current_function_args_info.arg_count[(int) SH_ARG_FLOAT];\n+  /* Number of SFmode float regs to save.  */\n+  int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n+  int ptrsize = GET_MODE_SIZE (Pmode);\n+  rtx valist, regbuf, fpregs;\n+  int bufsize, regno;\n+\n+  /* Allocate block of memory for the regs. */\n+  /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n+     Or can assign_stack_local accept a 0 SIZE argument?  */\n+  bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * UNITS_PER_WORD);\n+\n+  regbuf = assign_stack_local (BLKmode, bufsize, 0);\n+  MEM_IN_STRUCT_P (regbuf) = 1;\n+\n+  /* Save int args.\n+     This is optimized to only save the regs that are necessary.  Explicitly\n+     named args need not be saved.  */\n+  if (n_intregs > 0)\n+    move_block_from_reg (BASE_ARG_REG (SImode) + first_intreg,\n+\t\t\t gen_rtx (MEM, BLKmode, \n+\t\t\t \tplus_constant (XEXP (regbuf, 0),\n+\t\t\t\t\tn_floatregs * UNITS_PER_WORD)), \n+\t\t\t n_intregs, n_intregs * UNITS_PER_WORD);\n+\n+  /* Save float args.\n+     This is optimized to only save the regs that are necessary.  Explicitly\n+     named args need not be saved.\n+     We explicitly build a pointer to the buffer because it halves the insn\n+     count when not optimizing (otherwise the pointer is built for each reg\n+     saved).  */\n+\n+  fpregs = gen_reg_rtx (Pmode);\n+  emit_move_insn (fpregs, XEXP (regbuf, 0));\n+  for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno ++)\n+    emit_move_insn (gen_rtx (MEM, SFmode,\n+\t\t\t     plus_constant (fpregs,\n+\t\t\t\t\t    GET_MODE_SIZE (SFmode)\n+\t\t\t\t\t    * (regno - first_floatreg))),\n+\t\t    gen_rtx (REG, SFmode,\n+\t\t\t     BASE_ARG_REG (SFmode) + regno));\n+\n+  /* Return the address of the regbuf.  */\n+  return XEXP (regbuf, 0);\n+}\n+\n /* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n \n@@ -2000,7 +2096,9 @@ initial_elimination_offset (from, to)\n   int total_saved_regs_space;\n   int total_auto_space = get_frame_size ();\n \n-  calc_live_regs (&regs_saved);\n+  int live_regs_mask2;\n+  calc_live_regs (&regs_saved, &live_regs_mask2);\n+\n   total_saved_regs_space = (regs_saved) * 4;\n \n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n@@ -2138,6 +2236,7 @@ arith_reg_operand (op, mode)\n       if (GET_CODE (op) == REG)\n \treturn (REGNO (op) != T_REG\n \t\t&& REGNO (op) != PR_REG\n+\t\t&& REGNO (op) != FPUL_REG\n \t\t&& REGNO (op) != MACH_REG\n \t\t&& REGNO (op) != MACL_REG);\n       return 1;\n@@ -2192,60 +2291,35 @@ logical_operand (op, mode)\n \n   return 0;\n }\n-\f\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n \n-rtx\n-sh_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+/* Nonzero if OP is a floating point value with value 0.0.  */\n+\n+int\n+fp_zero_operand (op)\n+     rtx op;\n {\n-  if (named)\n-    {\n-      int rr = (ROUND_REG (cum, mode));\n+  REAL_VALUE_TYPE r;\n \n-      if (rr < NPARM_REGS)\n-\treturn ((type == 0 || ! TREE_ADDRESSABLE (type))\n-\t\t? gen_rtx (REG, mode, FIRST_PARM_REG + rr) : 0);\n-    }\n-  return 0;\n+  if (GET_MODE (op) != SFmode)\n+    return 0;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+  return REAL_VALUES_EQUAL (r, dconst0);\n }\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-   Any arg that starts in the first 4 regs but won't entirely fit in them\n-   needs partial registers on the SH.  */\n+/* Nonzero if OP is a floating point value with value 1.0.  */\n \n int\n-sh_function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+fp_one_operand (op)\n+     rtx op;\n {\n-  if (cum < NPARM_REGS)\n-    {\n-      if ((type == 0 || ! TREE_ADDRESSABLE (type))\n-\t  && (cum + (mode == BLKmode\n-\t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n-\t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))) - NPARM_REGS > 0))\n-\treturn NPARM_REGS - cum;\n-    }\n-  return 0;\n+  REAL_VALUE_TYPE r;\n+\n+  if (GET_MODE (op) != SFmode)\n+    return 0;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+  return REAL_VALUES_EQUAL (r, dconst1);\n }\n \f\n /* Return non-zero if REG is not used after INSN."}]}