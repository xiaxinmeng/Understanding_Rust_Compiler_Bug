{"sha": "d44b26bdf402498112c770368f75529847d13067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ0YjI2YmRmNDAyNDk4MTEyYzc3MDM2OGY3NTUyOTg0N2QxMzA2Nw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-10-26T11:59:41Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-10-26T11:59:41Z"}, "message": "rs6000.c (rs6000_make_savres_rtx): Delete unneeded declaration.\n\n\t* config/rs6000/rs6000.c (rs6000_make_savres_rtx): Delete unneeded\n\tdeclaration.\n\t(rs6000_emit_stack_reset): Only return insn emitted when it adjusts sp.\n\t(rs6000_make_savres_rtx): Rename to rs6000_emit_savres_rtx.  Use\n\tsimple_return in pattern, emit instruction, and set jump_label.\n\t(rs6000_emit_prologue): Update for rs6000_emit_savres_rtx.  Use\n\tsimple_return rather than return.\n\t(emit_cfa_restores): New function.\n\t(rs6000_emit_epilogue): Emit cfa_restores when flag_shrink_wrap.\n\tAdd missing cfa_restores for SAVE_WORLD.  Add missing LR cfa_restore\n\twhen using out-of-line gpr restore.  Add missing LR and FP regs\n\tcfa_restores for out-of-line fpr restore.  Consolidate code setting\n\tup cfa_restores.  Formatting.  Use LR_REGNO define.\n\t(rs6000_output_mi_thunk): Use simple_return rather than return.\n\t* config/rs6000/rs6000.md (sibcall*, sibcall_value*): Likewise.\n\t(return_internal*): Likewise.\n\t(any_return, return_pred, return_str): New iterators.\n\t(return, conditional return insns): Provide both return and\n\tsimple_return variants.\n\t* config/rs6000/rs6000.h (EARLY_R12, LATE_R12): Define.\n\t(REG_ALLOC_ORDER): Move r12 before call-saved regs when FIXED_R13.\n\tMove r11 and r0 later to suit shrink-wrapping.\n\nFrom-SVN: r180522", "tree": {"sha": "8e10aedbe360067edf2b2caf5c4b4bdb4089f568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e10aedbe360067edf2b2caf5c4b4bdb4089f568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d44b26bdf402498112c770368f75529847d13067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44b26bdf402498112c770368f75529847d13067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44b26bdf402498112c770368f75529847d13067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44b26bdf402498112c770368f75529847d13067/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4559db79d8d4d34a30c578260094efd430489f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4559db79d8d4d34a30c578260094efd430489f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4559db79d8d4d34a30c578260094efd430489f17"}], "stats": {"total": 468, "additions": 281, "deletions": 187}, "files": [{"sha": "1fba7d7227d46e3502a57ea98f28386286332db3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44b26bdf402498112c770368f75529847d13067/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44b26bdf402498112c770368f75529847d13067/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d44b26bdf402498112c770368f75529847d13067", "patch": "@@ -1,3 +1,28 @@\n+2011-10-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_make_savres_rtx): Delete unneeded\n+\tdeclaration.\n+\t(rs6000_emit_stack_reset): Only return insn emitted when it adjusts sp.\n+\t(rs6000_make_savres_rtx): Rename to rs6000_emit_savres_rtx.  Use\n+\tsimple_return in pattern, emit instruction, and set jump_label.\n+\t(rs6000_emit_prologue): Update for rs6000_emit_savres_rtx.  Use\n+\tsimple_return rather than return.\n+\t(emit_cfa_restores): New function.\n+\t(rs6000_emit_epilogue): Emit cfa_restores when flag_shrink_wrap.\n+\tAdd missing cfa_restores for SAVE_WORLD.  Add missing LR cfa_restore\n+\twhen using out-of-line gpr restore.  Add missing LR and FP regs\n+\tcfa_restores for out-of-line fpr restore.  Consolidate code setting\n+\tup cfa_restores.  Formatting.  Use LR_REGNO define.\n+\t(rs6000_output_mi_thunk): Use simple_return rather than return.\n+\t* config/rs6000/rs6000.md (sibcall*, sibcall_value*): Likewise.\n+\t(return_internal*): Likewise.\n+\t(any_return, return_pred, return_str): New iterators.\n+\t(return, conditional return insns): Provide both return and\n+\tsimple_return variants.\n+\t* config/rs6000/rs6000.h (EARLY_R12, LATE_R12): Define.\n+\t(REG_ALLOC_ORDER): Move r12 before call-saved regs when FIXED_R13.\n+\tMove r11 and r0 later to suit shrink-wrapping.\n+\n 2011-10-26  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-wrapper.c (run_gcc): Properly init/free obstack."}, {"sha": "353e04046c769905106c8d7d040538ccba75f935", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 217, "deletions": 163, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d44b26bdf402498112c770368f75529847d13067", "patch": "@@ -899,8 +899,6 @@ static const char *rs6000_mangle_type (const_tree);\n static void rs6000_set_default_type_attributes (tree);\n static rtx rs6000_savres_routine_sym (rs6000_stack_t *, bool, bool, bool);\n static rtx rs6000_emit_stack_reset (rs6000_stack_t *, rtx, rtx, int, bool);\n-static rtx rs6000_make_savres_rtx (rs6000_stack_t *, rtx, int,\n-\t\t\t\t   enum machine_mode, bool, bool, bool);\n static bool rs6000_reg_live_or_pic_offset_p (int);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static tree rs6000_builtin_vectorized_function (tree, tree, tree);\n@@ -19643,8 +19641,10 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n       if (sp_offset != 0)\n \t{\n \t  rtx dest_reg = savres ? gen_rtx_REG (Pmode, 11) : sp_reg_rtx;\n-\t  return emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx,\n-\t\t\t\t\t   GEN_INT (sp_offset)));\n+\t  rtx insn = emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx,\n+\t\t\t\t\t       GEN_INT (sp_offset)));\n+\t  if (!savres)\n+\t    return insn;\n \t}\n       else if (!savres)\n \treturn emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n@@ -19668,10 +19668,11 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n }\n \n /* Construct a parallel rtx describing the effect of a call to an\n-   out-of-line register save/restore routine.  */\n+   out-of-line register save/restore routine, and emit the insn\n+   or jump_insn as appropriate.  */\n \n static rtx\n-rs6000_make_savres_rtx (rs6000_stack_t *info,\n+rs6000_emit_savres_rtx (rs6000_stack_t *info,\n \t\t\trtx frame_reg_rtx, int save_area_offset,\n \t\t\tenum machine_mode reg_mode,\n \t\t\tbool savep, bool gpr, bool lr)\n@@ -19681,6 +19682,7 @@ rs6000_make_savres_rtx (rs6000_stack_t *info,\n   int reg_size = GET_MODE_SIZE (reg_mode);\n   rtx sym;\n   rtvec p;\n+  rtx par, insn;\n \n   offset = 0;\n   start_reg = (gpr\n@@ -19694,7 +19696,7 @@ rs6000_make_savres_rtx (rs6000_stack_t *info,\n     RTVEC_ELT (p, offset++) = ret_rtx;\n \n   RTVEC_ELT (p, offset++)\n-    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 65));\n+    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNO));\n \n   sym = rs6000_savres_routine_sym (info, savep, gpr, lr);\n   RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n@@ -19727,7 +19729,16 @@ rs6000_make_savres_rtx (rs6000_stack_t *info,\n       RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode, mem, reg);\n     }\n \n-  return gen_rtx_PARALLEL (VOIDmode, p);\n+  par = gen_rtx_PARALLEL (VOIDmode, p);\n+\n+  if (!savep && lr)\n+    {\n+      insn = emit_jump_insn (par);\n+      JUMP_LABEL (insn) = ret_rtx;\n+    }\n+  else\n+    insn = emit_insn (par);\n+  return insn;\n }\n \n /* Determine whether the gp REG is really used.  */\n@@ -20026,16 +20037,13 @@ rs6000_emit_prologue (void)\n     }\n   else if (!WORLD_SAVE_P (info) && info->first_fp_reg_save != 64)\n     {\n-      rtx par;\n-\n-      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\t    info->fp_save_offset + sp_offset,\n-\t\t\t\t    DFmode,\n-\t\t\t\t    /*savep=*/true, /*gpr=*/false,\n-\t\t\t\t    /*lr=*/(strategy\n-\t\t\t\t\t    & SAVE_NOINLINE_FPRS_SAVES_LR)\n-\t\t\t\t\t   != 0);\n-      insn = emit_insn (par);\n+      insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\t     info->fp_save_offset + sp_offset,\n+\t\t\t\t     DFmode,\n+\t\t\t\t     /*savep=*/true, /*gpr=*/false,\n+\t\t\t\t     /*lr=*/((strategy\n+\t\t\t\t\t      & SAVE_NOINLINE_FPRS_SAVES_LR)\n+\t\t\t\t\t     != 0));\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n@@ -20125,13 +20133,10 @@ rs6000_emit_prologue (void)\n \t}\n       else\n \t{\n-\t  rtx par;\n-\n-\t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n-\t\t\t\t\t0, reg_mode,\n-\t\t\t\t\t/*savep=*/true, /*gpr=*/true,\n-\t\t\t\t\t/*lr=*/false);\n-\t  insn = emit_insn (par);\n+\t  insn = rs6000_emit_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n+\t\t\t\t\t 0, reg_mode,\n+\t\t\t\t\t /*savep=*/true, /*gpr=*/true,\n+\t\t\t\t\t /*lr=*/false);\n \t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t\tNULL_RTX, NULL_RTX);\n \t}\n@@ -20143,8 +20148,6 @@ rs6000_emit_prologue (void)\n     }\n   else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n     {\n-      rtx par;\n-\n       /* Need to adjust r11 (r12) if we saved any FPRs.  */\n       if (info->first_fp_reg_save != 64)\n         {\n@@ -20155,14 +20158,13 @@ rs6000_emit_prologue (void)\n \t  emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n         }\n \n-      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\t    info->gp_save_offset + sp_offset,\n-\t\t\t\t    reg_mode,\n-\t\t\t\t    /*savep=*/true, /*gpr=*/true,\n-\t\t\t\t    /*lr=*/(strategy\n-\t\t\t\t\t    & SAVE_NOINLINE_GPRS_SAVES_LR)\n-\t\t\t\t\t   != 0);\n-      insn = emit_insn (par);\n+      insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\t     info->gp_save_offset + sp_offset,\n+\t\t\t\t     reg_mode,\n+\t\t\t\t     /*savep=*/true, /*gpr=*/true,\n+\t\t\t\t     /*lr=*/((strategy\n+\t\t\t\t\t      & SAVE_NOINLINE_GPRS_SAVES_LR)\n+\t\t\t\t\t     != 0));\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n@@ -20611,6 +20613,20 @@ offset_below_red_zone_p (HOST_WIDE_INT offset)\n \t\t   : TARGET_32BIT ? -220 : -288);\n }\n \n+/* Append CFA_RESTORES to any existing REG_NOTES on the last insn.  */\n+\n+static void\n+emit_cfa_restores (rtx cfa_restores)\n+{\n+  rtx insn = get_last_insn ();\n+  rtx *loc = &REG_NOTES (insn);\n+\n+  while (*loc)\n+    loc = &XEXP (*loc, 1);\n+  *loc = cfa_restores;\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* Emit function epilogue as insns.  */\n \n void\n@@ -20708,6 +20724,14 @@ rs6000_emit_epilogue (int sibcall)\n \trtx mem = gen_frame_mem (reg_mode, addr);\n \n \tRTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\n+\tif (flag_shrink_wrap)\n+\t  {\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n+\t\t\t\t\t   cfa_restores);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n+\t  }\n       }\n \n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n@@ -20719,6 +20743,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  rtx mem = gen_frame_mem (reg_mode, addr);\n \n \t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  if (flag_shrink_wrap)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n \t{\n@@ -20729,6 +20755,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  rtx mem = gen_frame_mem (V4SImode, addr);\n \n \t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  if (flag_shrink_wrap)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       for (i = 0; info->first_fp_reg_save + i <= 63; i++)\n \t{\n@@ -20742,6 +20770,8 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t     ? DFmode : SFmode), addr);\n \n \t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  if (flag_shrink_wrap)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       RTVEC_ELT (p, j++)\n \t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 0));\n@@ -20753,8 +20783,14 @@ rs6000_emit_epilogue (int sibcall)\n \t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 8));\n       RTVEC_ELT (p, j++)\n \t= gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, 10));\n-      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+      insn = emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n \n+      if (flag_shrink_wrap)\n+\t{\n+\t  REG_NOTES (insn) = cfa_restores;\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA, sp_reg_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n       return;\n     }\n \n@@ -20799,9 +20835,10 @@ rs6000_emit_epilogue (int sibcall)\n \n \t    reg = gen_rtx_REG (V4SImode, i);\n \t    emit_move_insn (reg, mem);\n-\t    if (offset_below_red_zone_p (info->altivec_save_offset\n-\t\t\t\t\t + (i - info->first_altivec_reg_save)\n-\t\t\t\t\t   * 16))\n+\t    if (flag_shrink_wrap\n+\t\t|| offset_below_red_zone_p (info->altivec_save_offset\n+\t\t\t\t\t    + (i - info->first_altivec_reg_save)\n+\t\t\t\t\t    * 16))\n \t      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n \t\t\t\t\t     cfa_restores);\n \t  }\n@@ -20940,7 +20977,7 @@ rs6000_emit_epilogue (int sibcall)\n \n \t    reg = gen_rtx_REG (V4SImode, i);\n \t    emit_move_insn (reg, mem);\n-\t    if (DEFAULT_ABI == ABI_V4)\n+\t    if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n \t      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n \t\t\t\t\t     cfa_restores);\n \t  }\n@@ -20990,8 +21027,7 @@ rs6000_emit_epilogue (int sibcall)\n       emit_move_insn (cr_save_reg, mem);\n     }\n \n-  /* Set LR here to try to overlap restores below.  LR is always saved\n-     above incoming stack, so it never needs REG_CFA_RESTORE.  */\n+  /* Set LR here to try to overlap restores below.  */\n   if (restore_lr && restoring_GPRs_inline)\n     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n \t\t    gen_rtx_REG (Pmode, 0));\n@@ -21029,7 +21065,7 @@ rs6000_emit_epilogue (int sibcall)\n   /* Restore GPRs.  This is done as a PARALLEL if we are using\n      the load-multiple instructions.  */\n   if (TARGET_SPE_ABI\n-      && info->spe_64bit_regs_used != 0\n+      && info->spe_64bit_regs_used\n       && info->first_gp_reg_save != 32)\n     {\n       /* Determine whether we can address all of the registers that need\n@@ -21053,7 +21089,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  int ool_adjust = (restoring_GPRs_inline\n \t\t\t    ? 0\n \t\t\t    : (info->first_gp_reg_save\n-\t\t\t       - (FIRST_SAVRES_REGISTER+1))*8);\n+\t\t\t       - (FIRST_SAVRES_REGISTER + 1)) * 8);\n \n \t  if (frame_reg_rtx == sp_reg_rtx)\n \t    frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n@@ -21084,48 +21120,28 @@ rs6000_emit_epilogue (int sibcall)\n \t\tmem = gen_rtx_MEM (V2SImode, addr);\n \t\treg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n \n-\t\tinsn = emit_move_insn (reg, mem);\n-\t\tif (DEFAULT_ABI == ABI_V4)\n-\t\t  {\n-\t\t    if (frame_pointer_needed\n-\t\t\t&& info->first_gp_reg_save + i\n-\t\t\t   == HARD_FRAME_POINTER_REGNUM)\n-\t\t      {\n-\t\t\tadd_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t\t      plus_constant (frame_reg_rtx,\n-\t\t\t\t\t\t     sp_offset));\n-\t\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t\t      }\n-\n-\t\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t\t   cfa_restores);\n-\t\t  }\n+\t\temit_move_insn (reg, mem);\n \t      }\n \t}\n       else\n-\t{\n-\t  rtx par;\n-\n-\t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n-\t\t\t\t\t0, reg_mode,\n-\t\t\t\t\t/*savep=*/false, /*gpr=*/true,\n-\t\t\t\t\t/*lr=*/true);\n-\t  emit_jump_insn (par);\n-\t  /* We don't want anybody else emitting things after we jumped\n-\t     back.  */\n-\t  return;\n-\t}\n+\trs6000_emit_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n+\t\t\t\t0, reg_mode,\n+\t\t\t\t/*savep=*/false, /*gpr=*/true,\n+\t\t\t\t/*lr=*/true);\n     }\n   else if (!restoring_GPRs_inline)\n     {\n       /* We are jumping to an out-of-line function.  */\n       bool can_use_exit = info->first_fp_reg_save == 64;\n-      rtx par;\n \n       /* Emit stack reset code if we need it.  */\n       if (can_use_exit)\n-\trs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n-\t\t\t\t sp_offset, can_use_exit);\n+\t{\n+\t  rs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n+\t\t\t\t   sp_offset, can_use_exit);\n+\t  if (info->cr_save_p)\n+\t    rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n+\t}\n       else\n \t{\n \t  emit_insn (gen_add3_insn (gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX\n@@ -21136,45 +21152,10 @@ rs6000_emit_epilogue (int sibcall)\n \t    sp_offset += info->fp_size;\n \t}\n \n-      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\t    info->gp_save_offset, reg_mode,\n-\t\t\t\t    /*savep=*/false, /*gpr=*/true,\n-\t\t\t\t    /*lr=*/can_use_exit);\n-\n-      if (can_use_exit)\n-\t{\n-\t  if (info->cr_save_p)\n-\t    {\n-\t      rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n-\t      if (DEFAULT_ABI == ABI_V4)\n-\t\tcfa_restores\n-\t\t  = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t    gen_rtx_REG (SImode, CR2_REGNO),\n-\t\t\t\t    cfa_restores);\n-\t    }\n-\n-\t  emit_jump_insn (par);\n-\n-\t  /* We don't want anybody else emitting things after we jumped\n-\t     back.  */\n-\t  return;\n-\t}\n-\n-      insn = emit_insn (par);\n-      if (DEFAULT_ABI == ABI_V4)\n-\t{\n-\t  if (frame_pointer_needed)\n-\t    {\n-\t      add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t    plus_constant (frame_reg_rtx, sp_offset));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\n-\t  for (i = info->first_gp_reg_save; i < 32; i++)\n-\t    cfa_restores\n-\t      = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (reg_mode, i), cfa_restores);\n-\t}\n+      rs6000_emit_savres_rtx (info, frame_reg_rtx,\n+\t\t\t      info->gp_save_offset, reg_mode,\n+\t\t\t      /*savep=*/false, /*gpr=*/true,\n+\t\t\t      /*lr=*/can_use_exit);\n     }\n   else if (using_load_multiple)\n     {\n@@ -21190,17 +21171,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n \n \t  RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, reg, mem);\n-\t  if (DEFAULT_ABI == ABI_V4)\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t   cfa_restores);\n-\t}\n-      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-      if (DEFAULT_ABI == ABI_V4 && frame_pointer_needed)\n-\t{\n-\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\tplus_constant (frame_reg_rtx, sp_offset));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n     }\n   else\n     {\n@@ -21214,24 +21186,70 @@ rs6000_emit_epilogue (int sibcall)\n             rtx mem = gen_frame_mem (reg_mode, addr);\n \t    rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n \n-\t    insn = emit_move_insn (reg, mem);\n-\t    if (DEFAULT_ABI == ABI_V4)\n-\t      {\n-\t        if (frame_pointer_needed\n-\t\t    && info->first_gp_reg_save + i\n-\t\t       == HARD_FRAME_POINTER_REGNUM)\n-\t\t  {\n-\t\t    add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t\t  plus_constant (frame_reg_rtx, sp_offset));\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  }\n-\n-\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t       cfa_restores);\n-\t      }\n+\t    emit_move_insn (reg, mem);\n           }\n     }\n \n+  if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+    {\n+      /* If the frame pointer was used then we can't delay emitting\n+\t a REG_CFA_DEF_CFA note.  This must happen on the insn that\n+\t restores the frame pointer, r31.  We may have already emitted\n+\t a REG_CFA_DEF_CFA note, but that's OK;  A duplicate is\n+\t discarded by dwarf2cfi.c/dwarf2out.c, and in any case would\n+\t be harmless if emitted.  */\n+      if (frame_pointer_needed)\n+\t{\n+\t  insn = get_last_insn ();\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tplus_constant (frame_reg_rtx, sp_offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      /* Set up cfa_restores.  We always need these when\n+\t shrink-wrapping.  If not shrink-wrapping then we only need\n+\t the cfa_restore when the stack location is no longer valid.\n+\t The cfa_restores must be emitted on or before the insn that\n+\t invalidates the stack, and of course must not be emitted\n+\t before the insn that actually does the restore.  The latter\n+\t is why the LR cfa_restore condition below is a little\n+\t complicated.  It's also why it is a bad idea to emit the\n+\t cfa_restores as a group on the last instruction here that\n+\t actually does a restore: That insn may be reordered with\n+\t respect to others doing restores.  */\n+      if (info->cr_save_p)\n+\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t       gen_rtx_REG (SImode, CR2_REGNO),\n+\t\t\t\t       cfa_restores);\n+      if (flag_shrink_wrap\n+\t  && (restore_lr\n+\t      || (info->lr_save_p\n+\t\t  && !restoring_GPRs_inline\n+\t\t  && info->first_fp_reg_save == 64)))\n+\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t       gen_rtx_REG (Pmode, LR_REGNO),\n+\t\t\t\t       cfa_restores);\n+\n+      for (i = info->first_gp_reg_save; i < 32; i++)\n+\tif (!restoring_GPRs_inline\n+\t    || using_load_multiple\n+\t    || rs6000_reg_live_or_pic_offset_p (i))\n+\t  {\n+\t    rtx reg = gen_rtx_REG (reg_mode, i);\n+\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n+\t  }\n+    }\n+\n+  if (!restoring_GPRs_inline\n+      && info->first_fp_reg_save == 64)\n+    {\n+      /* We are jumping to an out-of-line function.  */\n+      if (cfa_restores)\n+\temit_cfa_restores (cfa_restores);\n+      return;\n+    }\n+\n   if (restore_lr && !restoring_GPRs_inline)\n     {\n       rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n@@ -21245,8 +21263,8 @@ rs6000_emit_epilogue (int sibcall)\n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-      if ((df_regs_ever_live_p (info->first_fp_reg_save+i)\n-\t   && ! call_used_regs[info->first_fp_reg_save+i]))\n+      if ((df_regs_ever_live_p (info->first_fp_reg_save + i)\n+\t   && !call_used_regs[info->first_fp_reg_save + i]))\n \t{\n \t  rtx addr, mem, reg;\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n@@ -21260,20 +21278,13 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t     info->first_fp_reg_save + i);\n \n  \t  emit_move_insn (reg, mem);\n-\t  if (DEFAULT_ABI == ABI_V4)\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t   cfa_restores);\n+\t  if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n \n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)\n-    {\n-      rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n-      if (DEFAULT_ABI == ABI_V4)\n-\tcfa_restores\n-\t  = alloc_reg_note (REG_CFA_RESTORE, gen_rtx_REG (SImode, CR2_REGNO),\n-\t\t\t    cfa_restores);\n-    }\n+    rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n \n   /* If this is V.4, unwind the stack pointer after all of the loads\n      have been done.  */\n@@ -21301,15 +21312,40 @@ rs6000_emit_epilogue (int sibcall)\n       rtvec p;\n       bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n       if (! restoring_FPRs_inline)\n-\tp = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n+\t{\n+\t  p = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n+\t  RTVEC_ELT (p, 0) = ret_rtx;\n+\t}\n       else\n-\tp = rtvec_alloc (2);\n+\t{\n+\t  if (cfa_restores)\n+\t    {\n+\t      /* We can't hang the cfa_restores off a simple return,\n+\t\t since the shrink-wrap code sometimes uses an existing\n+\t\t return.  This means there might be a path from\n+\t\t pre-prologue code to this return, and dwarf2cfi code\n+\t\t wants the eh_frame unwinder state to be the same on\n+\t\t all paths to any point.  So we need to emit the\n+\t\t cfa_restores before the return.  For -m64 we really\n+\t\t don't need epilogue cfa_restores at all, except for\n+\t\t this irritating dwarf2cfi with shrink-wrap\n+\t\t requirement;  The stack red-zone means eh_frame info\n+\t\t from the prologue telling the unwinder to restore\n+\t\t from the stack is perfectly good right to the end of\n+\t\t the function.  */\n+\t      emit_insn (gen_blockage ());\n+\t      emit_cfa_restores (cfa_restores);\n+\t      cfa_restores = NULL_RTX;\n+\t    }\n+\t  p = rtvec_alloc (2);\n+\t  RTVEC_ELT (p, 0) = simple_return_rtx;\n+\t}\n \n-      RTVEC_ELT (p, 0) = ret_rtx;\n       RTVEC_ELT (p, 1) = ((restoring_FPRs_inline || !lr)\n-\t\t\t  ? gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 65))\n+\t\t\t  ? gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t gen_rtx_REG (Pmode, LR_REGNO))\n \t\t\t  : gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t     gen_rtx_REG (Pmode, 65)));\n+\t\t\t\t\t     gen_rtx_REG (Pmode, LR_REGNO)));\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n@@ -21318,6 +21354,12 @@ rs6000_emit_epilogue (int sibcall)\n \t  int i;\n \t  rtx sym;\n \n+\t  if ((DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t      && lr)\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n+\t\t\t\t\t   cfa_restores);\n+\n \t  sym = rs6000_savres_routine_sym (info,\n \t\t\t\t\t   /*savep=*/false,\n \t\t\t\t\t   /*gpr=*/false,\n@@ -21329,20 +21371,32 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t\t\t       ? 1 : 11));\n \t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \t    {\n-\t      rtx addr, mem;\n+\t      rtx addr, mem, reg;\n+\n \t      addr = gen_rtx_PLUS (Pmode, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->fp_save_offset + 8*i));\n+\t\t\t\t   GEN_INT (info->fp_save_offset + 8 * i));\n \t      mem = gen_frame_mem (DFmode, addr);\n+\t      reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n \n-\t      RTVEC_ELT (p, i+4) =\n-\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_REG (DFmode, info->first_fp_reg_save + i),\n-\t\t\t     mem);\n+\t      RTVEC_ELT (p, i + 4) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t      if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t       cfa_restores);\n \t    }\n \t}\n \n       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n     }\n+\n+  if (cfa_restores)\n+    {\n+      if (sibcall)\n+\t/* Ensure the cfa_restores are hung off an insn that won't\n+\t   be reordered above other restores.  */\n+\temit_insn (gen_blockage ());\n+\n+      emit_cfa_restores (cfa_restores);\n+    }\n }\n \n /* Write function epilogue.  */\n@@ -21707,7 +21761,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t\tgen_rtx_USE (VOIDmode,\n \t\t\t\t     gen_rtx_REG (SImode,\n \t\t\t\t\t\t  LR_REGNO)),\n-\t\t\tret_rtx)));\n+\t\t\tsimple_return_rtx)));\n   SIBLING_CALL_P (insn) = 1;\n   emit_barrier ();\n "}, {"sha": "112a32e50db32dc93ff6fee31d7ae63d747907be", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d44b26bdf402498112c770368f75529847d13067", "patch": "@@ -894,10 +894,11 @@ extern unsigned rs6000_pointer_size;\n \tcr1\t\t(not saved, but used for FP operations)\n \tcr0\t\t(not saved, but used for arithmetic operations)\n \tcr4, cr3, cr2\t(saved)\n-\tr0\t\t(not saved; cannot be base reg)\n \tr9\t\t(not saved; best for TImode)\n-\tr11, r10, r8-r4\t(not saved; highest used first to make less conflict)\n+\tr10, r8-r4\t(not saved; highest first for less conflict with params)\n \tr3\t\t(not saved; return value register)\n+\tr11\t\t(not saved; later alloc to help shrink-wrap)\n+\tr0\t\t(not saved; cannot be base reg)\n \tr31 - r13\t(saved; order given to save least number)\n \tr12\t\t(not saved; if used for DImode or DFmode would use r13)\n \tmq\t\t(not saved; best to use it if we can)\n@@ -922,18 +923,26 @@ extern unsigned rs6000_pointer_size;\n #define MAYBE_R2_FIXED\n #endif\n \n+#if FIXED_R13 == 1\n+#define EARLY_R12 12,\n+#define LATE_R12\n+#else\n+#define EARLY_R12\n+#define LATE_R12 12,\n+#endif\n+\n #define REG_ALLOC_ORDER\t\t\t\t\t\t\\\n   {32,\t\t\t\t\t\t\t\t\\\n    45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34,\t\t\\\n    33,\t\t\t\t\t\t\t\t\\\n    63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\t\\\n    50, 49, 48, 47, 46,\t\t\t\t\t\t\\\n    75, 74, 69, 68, 72, 71, 70,\t\t\t\t\t\\\n-   0, MAYBE_R2_AVAILABLE\t\t\t\t\t\\\n-   9, 11, 10, 8, 7, 6, 5, 4,\t\t\t\t\t\\\n-   3,\t\t\t\t\t\t\t\t\\\n+   MAYBE_R2_AVAILABLE\t\t\t\t\t\t\\\n+   9, 10, 8, 7, 6, 5, 4,\t\t\t\t\t\\\n+   3, EARLY_R12 11, 0,\t\t\t\t\t\t\\\n    31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19,\t\t\\\n-   18, 17, 16, 15, 14, 13, 12,\t\t\t\t\t\\\n+   18, 17, 16, 15, 14, 13, LATE_R12\t\t\t\t\\\n    64, 66, 65,\t\t\t\t\t\t\t\\\n    73, 1, MAYBE_R2_FIXED 67, 76,\t\t\t\t\\\n    /* AltiVec registers.  */\t\t\t\t\t\\"}, {"sha": "b992f621a1b517528e14fed587f394f574381c92", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44b26bdf402498112c770368f75529847d13067/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d44b26bdf402498112c770368f75529847d13067", "patch": "@@ -264,6 +264,12 @@\n ; Iterator for just SF/DF\n (define_mode_iterator SFDF [SF DF])\n \n+; Conditional returns.\n+(define_code_iterator any_return [return simple_return])\n+(define_code_attr return_pred [(return \"direct_return ()\")\n+\t\t\t       (simple_return \"\")])\n+(define_code_attr return_str [(return \"\") (simple_return \"simple_\")])\n+\n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n (define_mode_attr wd [(QI \"b\") (HI \"h\") (SI \"w\") (DI \"d\")])\n@@ -12718,7 +12724,7 @@\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (use (match_operand 2 \"\" \"\"))\n \t      (use (reg:SI LR_REGNO))\n-\t      (return)])]\n+\t      (simple_return)])]\n   \"\"\n   \"\n {\n@@ -12742,7 +12748,7 @@\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -12762,7 +12768,7 @@\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -12783,7 +12789,7 @@\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -12805,7 +12811,7 @@\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -12825,7 +12831,7 @@\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,O\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"@\n@@ -12840,7 +12846,7 @@\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,O\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"@\n@@ -12854,7 +12860,7 @@\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"immediate_operand\" \"O,n,O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n@@ -12885,7 +12891,7 @@\n \t\t      (match_operand 2 \"\" \"\")))\n \t      (use (match_operand 3 \"\" \"\"))\n \t      (use (reg:SI LR_REGNO))\n-\t      (return)])]\n+\t      (simple_return)])]\n   \"\"\n   \"\n {\n@@ -12906,7 +12912,7 @@\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n,O,n\"))\n    (use (reg:SI LR_REGNO))\n-   (return)]\n+   (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n@@ -15236,9 +15242,9 @@\n \t\t\t\t      [(match_operand 1\n \t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n \t\t\t\t       (const_int 0)])\n-\t\t      (return)\n+\t\t      (any_return)\n \t\t      (pc)))]\n-  \"direct_return ()\"\n+  \"<return_pred>\"\n   \"*\n {\n   return output_cbranch (operands[0], NULL, 0, insn);\n@@ -15268,8 +15274,8 @@\n \t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n-\t\t      (return)))]\n-  \"direct_return ()\"\n+\t\t      (any_return)))]\n+  \"<return_pred>\"\n   \"*\n {\n   return output_cbranch (operands[0], NULL, 1, insn);\n@@ -15399,9 +15405,9 @@\n   \"b %l0\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"direct_return ()\"\n+(define_insn \"<return_str>return\"\n+  [(any_return)]\n+  \"<return_pred>\"\n   \"{br|blr}\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n@@ -15923,7 +15929,7 @@\n    (set_attr \"cell_micro\" \"always\")])\n \n (define_insn \"*return_internal_<mode>\"\n-  [(return)\n+  [(simple_return)\n    (use (match_operand:P 0 \"register_operand\" \"lc\"))]\n   \"\"\n   \"b%T0\""}]}