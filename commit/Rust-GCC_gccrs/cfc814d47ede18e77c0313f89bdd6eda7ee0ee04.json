{"sha": "cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjODE0ZDQ3ZWRlMThlNzdjMDMxM2Y4OWJkZDZlZGE3ZWUwZWUwNA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-11-22T16:48:52Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-11-22T16:48:52Z"}, "message": "URL.java: Merge with Classpath (partly).\n\n\t* java/net/URL.java: Merge with Classpath (partly).\n\t* java/net/URLStreamHandler: Merge with Classpath.\n\nFrom-SVN: r59378", "tree": {"sha": "7240fe6ca9986219a94f85d6a064896b8d224e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7240fe6ca9986219a94f85d6a064896b8d224e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/comments", "author": null, "committer": null, "parents": [{"sha": "41c3eb5d451b5c045decbfa24426c595b7dbd0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c3eb5d451b5c045decbfa24426c595b7dbd0f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c3eb5d451b5c045decbfa24426c595b7dbd0f4"}], "stats": {"total": 639, "additions": 474, "deletions": 165}, "files": [{"sha": "e86ab93c93dd7919e7fd6c8f52e3f9f048b5bf64", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "patch": "@@ -1,3 +1,8 @@\n+2002-11-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/net/URL.java: Merge with Classpath (partly).\n+\t* java/net/URLStreamHandler: Merge with Classpath.\n+\n 2002-11-22  Michael Koch <konqueror@gmx.de>\n \n \t* include/posix.h:"}, {"sha": "98e7d5f7c3148c3442ecb3c72cc196eaf2b489f6", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 312, "deletions": 104, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "patch": "@@ -1,56 +1,180 @@\n-// URL.java - A Uniform Resource Locator.\n+/* URL.java -- Uniform Resource Locator Class\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.net;\n \n-import java.io.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Hashtable;\n import java.util.StringTokenizer;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date March 4, 1999.\n- */\n \n-/**\n+/*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+  * This final class represents an Internet Uniform Resource Locator (URL).\n+  * For details on the syntax of URL's and what they can be used for,\n+  * refer to RFC 1738, available from <a \n+  * href=\"http://ds.internic.net/rfcs/rfc1738.txt\">http://ds.internic.net/rfcs/rfc1738.txt</a>\n+  * <p>\n+  * There are a great many protocols supported by URL's such as \"http\",\n+  * \"ftp\", and \"file\".  This object can handle any arbitrary URL for which\n+  * a URLStreamHandler object can be written.  Default protocol handlers\n+  * are provided for the \"http\" and \"ftp\" protocols.  Additional protocols\n+  * handler implementations may be provided in the future.  In any case,\n+  * an application or applet can install its own protocol handlers that\n+  * can be \"chained\" with other protocol hanlders in the system to extend\n+  * the base functionality provided with this class. (Note, however, that\n+  * unsigned applets cannot access properties by default or install their\n+  * own protocol handlers).\n+  * <p>\n+  * This chaining is done via the system property java.protocol.handler.pkgs\n+  * If this property is set, it is assumed to be a \"|\" separated list of\n+  * package names in which to attempt locating protocol handlers.  The\n+  * protocol handler is searched for by appending the string \n+  * \".<protocol>.Handler\" to each packed in the list until a hander is found.\n+  * If a protocol handler is not found in this list of packages, or if the\n+  * property does not exist, then the default protocol handler of\n+  * \"gnu.java.net.<protocol>.Handler\" is tried.  If this is\n+  * unsuccessful, a MalformedURLException is thrown.\n+  * <p>\n+  * All of the constructor methods of URL attempt to load a protocol\n+  * handler and so any needed protocol handlers must be installed when\n+  * the URL is constructed.\n+  * <p>\n+  * Here is an example of how URL searches for protocol handlers.  Assume\n+  * the value of java.protocol.handler.pkgs is \"com.foo|com.bar\" and the\n+  * URL is \"news://comp.lang.java.programmer\".  URL would looking the \n+  * following places for protocol handlers:\n+  * <p><pre>\n+  * com.foo.news.Handler\n+  * com.bar.news.Handler\n+  * gnu.java.net.news.Handler\n+  * </pre><p>\n+  * If the protocol handler is not found in any of those locations, a\n+  * MalformedURLException would be thrown.\n+  * <p>\n+  * Please note that a protocol handler must be a subclass of\n+  * URLStreamHandler.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  *\n+  * @see URLStreamHandler\n+  */\n public final class URL implements Serializable\n {\n+  /**\n+   * The name of the protocol for this URL.\n+   * The protocol is always stored in lower case.\n+   */\n   private String protocol;\n+\n+  /**\n+   * The \"authority\" portion of the URL.\n+   */\n   private String authority;\n-  private String userInfo;\n+\n+  /**\n+   * The hostname or IP address of this protocol.\n+   * This includes a possible user. For example <code>joe@some.host.net</code>.\n+   */\n   private String host;\n+\n+  /**\n+   * The port number of this protocol or -1 if the port number used is\n+   * the default for this protocol.\n+   */\n   private int port = -1;\t// Initialize for constructor using context.\n+\n+  /**\n+   * The \"file\" portion of the URL. It is defined as <code>path[?query]</code>.\n+   */\n   private String file;\n-  private String query;\n+\n+  /**\n+   * The anchor portion of the URL.\n+   */\n   private String ref;\n+\n+  /**\n+   * This is the hashCode for this URL\n+   */\n   private int hashCode = 0;\n+\n+  /**\n+   * The protocol handler in use for this URL\n+   */\n   transient private URLStreamHandler handler;\n+\n+  /**\n+   * This a table where we cache protocol handlers to avoid the overhead\n+   * of looking them up each time.\n+   */\n   private static Hashtable handlers = new Hashtable();\n+\n+  /**\n+   * If an application installs its own protocol handler factory, this is\n+   * where we keep track of it.\n+   */\n   private static URLStreamHandlerFactory factory;\n \n   private static final long serialVersionUID = -7627629688361524110L;\n \n   /**\n-   * Creates an URL object from the given arguments\n-   *\n-   * @param protocol The protocol of the URL\n-   * @param host The host of the URL\n-   * @param port The port of the URL\n-   * @param file The file of the URL\n+   * Constructs a URL and loads a protocol handler for the values passed as\n+   * arguments.\n+   * \n+   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n+   * @param host The hostname or IP address to connect to\n+   * @param port The port number to use, or -1 to use the protocol's\n+   * default port\n+   * @param file The \"file\" portion of the URL.\n    *\n-   * @exception MalformedURLException If an error occurs\n+   * @exception MalformedURLException If a protocol handler cannot be loaded or\n+   * a parse error occurs.\n    */\n   public URL(String protocol, String host, int port, String file)\n     throws MalformedURLException\n@@ -59,33 +183,42 @@ public URL(String protocol, String host, int port, String file)\n   }\n \n   /**\n-   * Creates an URL object from the given arguments\n+   * Constructs a URL and loads a protocol handler for the values passed in\n+   * as arugments.  Uses the default port for the protocol.\n    *\n-   * @param protocol The protocol of the URL\n-   * @param host The host of the URL\n-   * @param file The file of the URL\n+   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n+   * @param host The hostname or IP address for this URL\n+   * @param file The \"file\" portion of this URL.\n    *\n-   * @exception MalformedURLException If an error occurs\n+   * @exception MalformedURLException If a protocol handler cannot be loaded or\n+   * a parse error occurs.\n    */\n   public URL(String protocol, String host, String file)\n     throws MalformedURLException\n   {\n     this(protocol, host, -1, file, null);\n   }\n \n+\n   /**\n-   * Creates an URL object from the given arguments\n+   * This method initializes a new instance of <code>URL</code> with the\n+   * specified protocol, host, port, and file.  Additionally, this method\n+   * allows the caller to specify a protocol handler to use instead of \n+   * the default.  If this handler is specified, the caller must have\n+   * the \"specifyStreamHandler\" permission (see <code>NetPermission</code>)\n+   * or a <code>SecurityException</code> will be thrown.\n    *\n-   * @param protocol The protocol of the URL\n-   * @param host The host of the URL\n-   * @param port The port of the URL\n-   * @param file The file of the URL\n-   * @param handler The stream handler for the URL\n+   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n+   * @param host The hostname or IP address to connect to\n+   * @param port The port number to use, or -1 to use the protocol's default\n+   * port\n+   * @param file The \"file\" portion of the URL.\n+   * @param handler The protocol handler to use with this URL.\n    *\n-   * @exception MalformedURLException If an error occurs\n-   * @exception SecurityException If  a security manager exists and its\n-   * checkPermission method doesn't allow specifying a stream handler\n-   * explicitly\n+   * @exception MalformedURLException If no protocol handler can be loaded\n+   * for the specified protocol.\n+   * @exception SecurityException If the <code>SecurityManager</code> exists\n+   * and does not allow the caller to specify its own protocol handler.\n    *\n    * @since 1.2\n    */\n@@ -94,28 +227,26 @@ public URL(String protocol, String host, int port, String file,\n   {\n     if (protocol == null)\n       throw new MalformedURLException(\"null protocol\");\n-    this.protocol = protocol;\n+    this.protocol = protocol.toLowerCase();\n \n     if (handler != null)\n       {\n-\tSecurityManager s = System.getSecurityManager ();\n+\tSecurityManager s = System.getSecurityManager();\n \tif (s != null)\n \t  s.checkPermission (new NetPermission (\"specifyStreamHandler\"));\n \n         this.handler = handler;\n       }\n     else\n-      this.handler = setURLStreamHandler(protocol);\n+      this.handler = getURLStreamHandler(protocol);\n \n     if (this.handler == null)\n       throw new MalformedURLException (\n \t\t      \"Protocol handler not found: \" + protocol);\n \n     this.host = host;\n     this.port = port;\n-    this.userInfo = null;\n     this.authority = null;\n-    this.query = null;\n \n     int hashAt = file.indexOf('#');\n     if (hashAt < 0)\n@@ -132,24 +263,37 @@ public URL(String protocol, String host, int port, String file,\n   }\n \n   /**\n-   * Creates an URL object from the given arguments\n-   * \n-   * @param spec The string to parse an URL\n+   * Initializes a URL from a complete string specification such as\n+   * \"http://www.urbanophile.com/arenn/\".  First the protocol name is parsed\n+   * out of the string.  Then a handler is located for that protocol and\n+   * the parseURL() method of that protocol handler is used to parse the\n+   * remaining fields.\n    *\n-   * @exception MalformedURLException If an error occurs\n+   * @param spec The complete String representation of a URL\n+   *\n+   * @exception MalformedURLException If a protocol handler cannot be found\n+   * or the URL cannot be parsed\n    */\n   public URL(String spec) throws MalformedURLException\n   {\n     this((URL) null, spec, (URLStreamHandler) null);\n   }\n \n-  /**\n-   * Creates an URL object from the given arguments\n-   * \n+  /*\n+   * This method parses a String representation of a URL within the\n+   * context of an existing URL.  Principally this means that any\n+   * fields not present the URL are inheritied from the context URL.\n+   * This allows relative URL's to be easily constructed.  If the\n+   * context argument is null, then a complete URL must be specified\n+   * in the URL string.  If the protocol parsed out of the URL is\n+   * different from the context URL's protocol, then then URL String\n+   * is also expected to be a complete URL.\n+   *\n    * @param context The context on which to parse the specification\n    * @param spec The string to parse an URL\n    *\n-   * @exception MalformedURLException If an error occurs\n+   * @exception MalformedURLException If a protocol handler cannot be found \n+   * for the URL cannot be parsed\n    */\n   public URL(URL context, String spec) throws MalformedURLException\n   {\n@@ -158,16 +302,30 @@ public URL(URL context, String spec) throws MalformedURLException\n \n   /**\n    * Creates an URL from given arguments\n+   * This method parses a String representation of a URL within the\n+   * context of an existing URL.  Principally this means that any fields\n+   * not present the URL are inheritied from the context URL.  This allows\n+   * relative URL's to be easily constructed.  If the context argument is\n+   * null, then a complete URL must be specified in the URL string.\n+   * If the protocol parsed out of the URL is different \n+   * from the context URL's protocol, then then URL String is also\n+   * expected to be a complete URL.\n+   * <p>\n+   * Additionally, this method allows the caller to specify a protocol handler\n+   * to use instead of  the default.  If this handler is specified, the caller\n+   * must have the \"specifyStreamHandler\" permission\n+   * (see <code>NetPermission</code>) or a <code>SecurityException</code>\n+   * will be thrown.\n    *\n    * @param context The context in which to parse the specification\n    * @param spec The string to parse as an URL\n    * @param handler The stream handler for the URL\n    *\n-   * @exception MalformedURLException If an error occurs\n-   * @exception SecurityException If  a security manager exists and its\n-   * checkPermission method doesn't allow specifying a stream handler\n-   * explicitly\n-   * \n+   * @exception MalformedURLException If a protocol handler cannot be found\n+   * or the URL cannot be parsed\n+   * @exception SecurityException If the <code>SecurityManager</code> exists\n+   * and does not allow the caller to specify its own protocol handler.\n+   *\n    * @since 1.2\n    */\n   public URL(URL context, String spec, URLStreamHandler handler)\n@@ -198,16 +356,14 @@ public URL(URL context, String spec, URLStreamHandler handler)\n \t(colon < (slash = spec.indexOf('/')) || slash < 0))\n       {\n \t// Protocol specified in spec string.\n-\tprotocol = spec.substring(0, colon);\n+\tprotocol = spec.substring(0, colon).toLowerCase();\n \tif (context != null && context.protocol.equals(protocol))\n \t  {\n \t    // The 1.2 doc specifically says these are copied to the new URL.\n \t    host = context.host;\n \t    port = context.port;\n \t    file = context.file;\n-\t    userInfo = context.userInfo;\n \t    authority = context.authority;\n-\t    query = context.query;\n \t  }\n       }\n     else if (context != null)\n@@ -219,9 +375,7 @@ else if (context != null)\n \thost = context.host;\n \tport = context.port;\n \tfile = context.file;\n-        userInfo = context.userInfo;\n         authority = context.authority;\n-        query = context.query;\n       }\n     else\t// Protocol NOT specified in spec. and no context available.\n       throw new\n@@ -236,7 +390,7 @@ else if (context != null)\n         this.handler = handler;\n       }\n     else\n-      this.handler = setURLStreamHandler(protocol);\n+      this.handler = getURLStreamHandler(protocol);\n \n     if (this.handler == null)\n       throw new MalformedURLException(\"Protocol handler not found: \"\n@@ -255,7 +409,14 @@ else if (context != null)\n   }\n \n   /**\n-   * Checks if two URLs are equal\n+   * Test another URL for equality with this one.  This will be true only if\n+   * the argument is non-null and all of the fields in the URL's match \n+   * exactly (ie, protocol, host, port, file, and ref).  Overrides\n+   * Object.equals(), implemented by calling the equals method of the handler.\n+   *\n+   * @param url The URL to compare with\n+   *\n+   * @return true if the URL is equal, false otherwise\n    */\n   public boolean equals(Object obj)\n   {\n@@ -268,9 +429,12 @@ public boolean equals(Object obj)\n   }\n \n   /**\n-   * Gets the contents of this URL\n+   * Returns the contents of this URL as an object by first opening a\n+   * connection, then calling the getContent() method against the connection\n    *\n-   * @exception IOException If an error occurs\n+   * @return A content object for this URL\n+   * @exception IOException If opening the connection or getting the\n+   * content fails.\n    *\n    * @since 1.3\n    */\n@@ -291,15 +455,18 @@ public final Object getContent (Class[] classes) throws IOException\n   }\n \n   /**\n-   * Returns the file of the URL\n+   * Returns the file portion of the URL.\n+   * Defined as <code>path[?query]</code>.\n+   * Returns the empty string if there is no file portion.\n    */\n   public String getFile()\n   {\n-    return file;\n+    return file == null ? \"\" : file;\n   }\n \n   /**\n-   * Returns the path of the URL\n+   * Returns the path of the URL. This is the part of the file before any '?'\n+   * character.\n    *\n    * @since 1.3\n    */\n@@ -324,23 +491,30 @@ public String getAuthority()\n    */\n   public String getHost()\n   {\n-    return host;\n+    int at = (host == null) ? -1 : host.indexOf('@');\n+    return at < 0 ? host : host.substring(at + 1, host.length());\n   }\n \n   /**\n-   * Returns of port of the URL\n+   * Returns the port number of this URL or -1 if the default port number is\n+   * being used.\n+   *\n+   * @return The port number\n+   *\n+   * @see #getDefaultPort()\n    */\n   public int getPort()\n   {\n     return port;\n   }\n \n   /**\n-   * Returns the default port of the URL\n+   * Returns the default port of the URL. If the StreamHandler for the URL\n+   * protocol does not define a default port it returns -1.\n    */\n   public int getDefaultPort()\n   {\n-    return 0;\n+    return handler.getDefaultPort();\n   }\n \n   /**\n@@ -351,13 +525,22 @@ public String getProtocol()\n     return protocol;\n   }\n \n+  /**\n+   * Returns the ref (sometimes called the \"# reference\" or \"anchor\") portion\n+   * of the URL.\n+   *\n+   * @return The ref\n+   */\n   public String getRef()\n   {\n     return ref;\n   }\n \n   /**\n-   * Returns the user information of the URL\n+   * Returns the user information of the URL. This is the part of the host\n+   * name before the '@'.\n+   *\n+   * @return the user at a particular host or null when no user defined.\n    */\n   public String getUserInfo ()\n   {\n@@ -366,32 +549,22 @@ public String getUserInfo ()\n   }\n \n   /**\n-   * Returns the query of the URL\n+   * Returns the query of the URL. This is the part of the file before the\n+   * '?'.\n+   *\n+   * @ return the query part of the file, or null when there is no query part.\n    */\n   public String getQuery ()\n   {\n-    return query;\n+    int quest = file.indexOf('?');\n+    return quest < 0 ? null : file.substring(quest + 1, file.length());\n   }\n \n   /**\n    * Returns a hashcode computed by the URLStreamHandler of this URL\n    */\n   public int hashCode()\n   {\n-    // JCL book says this is computed using (only) the hashcodes of the \n-    // protocol, host and file fields.  Empirical evidence indicates this\n-    // is probably XOR in JDK 1.1.  In JDK 1.2 it seems to be a sum including\n-    // the port.\n-    //\n-    // JDK 1.2 online doc infers that host could be null because it\n-    // explicitly states that file cannot be null but is silent on host.\n-    // A simple example with protocol \"http\" (hashcode 3213448), host null,\n-    // file \"/\" (hashcode 47) produced a hashcode (3213494) which appeared\n-    // to be the sum of the two hashcodes plus the port.  Another example\n-    // using \"/index.html\" for file bore this out; as well as \"#\" for file\n-    // (which was reduced to \"\" with a hashcode of zero).  A \"\" host also\n-    // causes the port number and the two hashcodes to be summed.\n-\n     if (hashCode != 0)\n       return hashCode;\t\t// Use cached value if available.\n     else\n@@ -400,8 +573,10 @@ public int hashCode()\n \n   /**\n    * Returns a URLConnection object that represents a connection to the remote\n-   * object referred to by the URL\n+   * object referred to by the URL. The URLConnection is created by calling the\n+   * openConnection() method of the protocol handler\n    *\n+   * @return A URLConnection for this URL\n    * @exception IOException If an error occurs\n    */\n   public URLConnection openConnection() throws IOException\n@@ -420,15 +595,32 @@ public final InputStream openStream() throws IOException\n     return openConnection().getInputStream();\n   }\n \n+  /**\n+   * Tests whether or not another URL refers to the same \"file\" as this one.\n+   * This will be true if and only if the passed object is not null, is a\n+   * URL, and matches all fields but the ref (ie, protocol, host, port,\n+   * and file);\n+   *\n+   * @param url The URL object to test with\n+   *\n+   * @return true if URL matches this URL's file, false otherwise\n+   */\n   public boolean sameFile(URL other)\n   {\n     return handler.sameFile(this, other);\n   }\n \n   /**\n    * Sets the specified fields of the URL. This is not a public method so\n-   * that only URLStreamHandlers can modify URL fields. URLs are otherwise\n-   * constant\n+   * that only URLStreamHandlers can modify URL fields. This might be called\n+   * by the <code>parseURL()</code> method in that class. URLs are otherwise\n+   * constant.\n+   *\n+   * @param protocol The protocol name for this URL\n+   * @param host The hostname or IP address for this URL\n+   * @param port The port number of this URL\n+   * @param file The \"file\" portion of this URL.\n+   * @param ref The anchor portion of this URL.\n    */\n   protected void set(String protocol, String host, int port, String file,\n \t\t     String ref)\n@@ -437,22 +629,20 @@ protected void set(String protocol, String host, int port, String file,\n     // invalid protocol.  It will cause the handler to be set to null\n     // thus overriding a valid handler.  Callers of this method should\n     // be aware of this.\n-    this.handler = setURLStreamHandler(protocol);\n-    this.protocol = protocol;\n+    this.handler = getURLStreamHandler(protocol);\n+    this.protocol = protocol.toLowerCase();\n     this.authority = null;\n-    this.userInfo = null;\n     this.port = port;\n     this.host = host;\n     this.file = file;\n-    this.query = null;\n     this.ref = ref;\n     hashCode = hashCode();\t\t\t// Used for serialization.\n   }\n \n   /**\n    * Sets the specified fields of the URL. This is not a public method so\n    * that only URLStreamHandlers can modify URL fields. URLs are otherwise\n-   * constant\n+   * constant.\n    *\n    * @since 1.3\n    */\n@@ -464,8 +654,8 @@ protected void set(String protocol, String host, int port,\n     // invalid protocol.  It will cause the handler to be set to null\n     // thus overriding a valid handler.  Callers of this method should\n     // be aware of this.\n-    this.handler = setURLStreamHandler(protocol);\n-    this.protocol = protocol;\n+    this.handler = getURLStreamHandler(protocol);\n+    this.protocol = protocol.toLowerCase();\n     if (userInfo == null)\n       this.host = host;\n     else\n@@ -480,9 +670,13 @@ protected void set(String protocol, String host, int port,\n   }\n \n   /**\n-   * Sets an application's URLStreamHandlerFactory\n+   * Sets the URLStreamHandlerFactory for this class.  This factory is\n+   * responsible for returning the appropriate protocol handler for\n+   * a given URL.\n+   *\n+   * @param fac The URLStreamHandlerFactory class to use\n    *\n-   * @exception Error If the application has already set a factory\n+   * @exception Error If the factory is alread set.\n    * @exception SecurityException If a security manager exists and its\n    * checkSetFactory method doesn't allow the operation\n    */\n@@ -500,19 +694,33 @@ protected void set(String protocol, String host, int port,\n     factory = fac;\n   }\n \n+  /**\n+   * Returns a String representing this URL.  The String returned is\n+   * created by calling the protocol handler's toExternalForm() method.\n+   *\n+   * @return A string for this URL\n+   */\n   public String toExternalForm()\n   {\n     // Identical to toString().\n     return handler.toExternalForm(this);\n   }\n \n+  /**\n+   * Returns a String representing this URL.  Identical to toExternalForm().\n+   * The value returned is created by the protocol handler's \n+   * toExternalForm method.  Overrides Object.toString()\n+   *\n+   * @return A string for this URL\n+   */\n   public String toString()\n   {\n     // Identical to toExternalForm().\n     return handler.toExternalForm(this);\n   }\n \n-  private URLStreamHandler setURLStreamHandler(String protocol)\n+  private static synchronized URLStreamHandler\n+    getURLStreamHandler(String protocol)\n   {\n     URLStreamHandler handler;\n \n@@ -532,7 +740,7 @@ else if (protocol.equals (\"file\"))\n \t// This is an interesting case.  It's tempting to think that we\n \t// could call Class.forName (\"gnu.gcj.protocol.file.Handler\") to\n \t// get the appropriate class.  Unfortunately, if we do that the\n-\t// program will never terminate, because setURLStreamHandler is\n+\t// program will never terminate, because getURLStreamHandler is\n \t// eventually called by Class.forName.\n \t//\n \t// Treating \"file\" as a special case is the minimum that will\n@@ -587,7 +795,7 @@ private void readObject(ObjectInputStream ois)\n     throws IOException, ClassNotFoundException\n   {\n     ois.defaultReadObject();\n-    this.handler = setURLStreamHandler(protocol);\n+    this.handler = getURLStreamHandler(protocol);\n     if (this.handler == null)\n       throw new IOException(\"Handler for protocol \" + protocol + \" not found\");\n   }"}, {"sha": "128a0d2d3da0bc1b1d8df60ba2e813d4aeb03b5c", "filename": "libjava/java/net/URLStreamHandler.java", "status": "modified", "additions": 157, "deletions": 61, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc814d47ede18e77c0313f89bdd6eda7ee0ee04/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=cfc814d47ede18e77c0313f89bdd6eda7ee0ee04", "patch": "@@ -1,28 +1,78 @@\n-// URLStreamHandler.java - Superclass of all stream protocol handlers.\n+/* URLStreamHandler.java -- Abstract superclass for all protocol handlers\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-/* Copyright (C) 1999, 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.net;\n \n import java.io.IOException;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date March 4, 1999.\n- */\n-\n-/**\n+/*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+ * This class is the superclass of all URL protocol handlers.  The URL\n+ * class loads the appropriate protocol handler to establish a connection\n+ * to a (possibly) remote service (eg, \"http\", \"ftp\") and to do protocol\n+ * specific parsing of URL's.  Refer to the URL class documentation for\n+ * details on how that class locates and loads protocol handlers.\n+ * <p>\n+ * A protocol handler implementation should override the openConnection()\n+ * method, and optionally override the parseURL() and toExternalForm()\n+ * methods if necessary. (The default implementations will parse/write all\n+ * URL's in the same form as http URL's).  A protocol  specific subclass \n+ * of URLConnection will most likely need to be created as well.\n+ * <p>\n+ * Note that the instance methods in this class are called as if they\n+ * were static methods.  That is, a URL object to act on is passed with\n+ * every call rather than the caller assuming the URL is stored in an\n+ * instance variable of the \"this\" object.\n+ * <p>\n+ * The methods in this class are protected and accessible only to subclasses.\n+ * URLStreamConnection objects are intended for use by the URL class only,\n+ * not by other classes (unless those classes are implementing protocols).\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy (warrenl@cygnus.com)\n+ * \n+ * @see URL\n+ */\n public abstract class URLStreamHandler\n {\n   /**\n@@ -33,37 +83,49 @@ public URLStreamHandler ()\n   }\n \n   /**\n-   * Opens a connection to the object referenced by the URL argument.\n-   * This method should be overridden by a subclass.\n+   * Returns a URLConnection for the passed in URL.  Note that this should\n+   * not actually create the connection to the (possibly) remote host, but\n+   * rather simply return a URLConnection object.  The connect() method of\n+   * URL connection is used to establish the actual connection, possibly\n+   * after the caller sets up various connection options.\n+   *\n+   * @param url The URL to get a connection object for\n+   *\n+   * @return A URLConnection object for the given URL\n    *\n    * @exception IOException If an error occurs\n    */\n   protected abstract URLConnection openConnection(URL u)\n     throws IOException;\n \n   /**\n-   * Pasrses the given URL\n+   * This method parses the string passed in as a URL and set's the\n+   * instance data fields in the URL object passed in to the various values\n+   * parsed out of the string.  The start parameter is the position to start\n+   * scanning the string.  This is usually the position after the \":\" which\n+   * terminates the protocol name.  The end parameter is the position to\n+   * stop scanning.  This will be either the end of the String, or the\n+   * position of the \"#\" character, which separates the \"file\" portion of\n+   * the URL from the \"anchor\" portion.\n+   * <p>\n+   * This method assumes URL's are formatted like http protocol URL's, so \n+   * subclasses that implement protocols with URL's the follow a different \n+   * syntax should override this method.  The lone exception is that if\n+   * the protocol name set in the URL is \"file\", this method will accept\n+   * a an empty hostname (i.e., \"file:///\"), which is legal for that protocol\n    *\n-   * @param u The URL to parse\n-   * @param spec The specification to use\n-   * @param start The character index at which to begin parsing. This is just\n-   * past the ':' (if there is one) that specifies the determination of the\n-   * protocol name\n-   * @param limit The character position to stop parsing at. This is the end\n-   * of the string or the position of the \"#\" character, if present. All\n-   * information after the sharp sign indicates an anchor\n+   * @param url The URL object in which to store the results\n+   * @param spec The String-ized URL to parse\n+   * @param start The position in the string to start scanning from\n+   * @param end The position in the string to stop scanning\n    */\n-  protected void parseURL(URL u, String spec, int start, int limit)\n+  protected void parseURL(URL url, String spec, int start, int end)\n   {\n-    String host = u.getHost();\n-    int port = u.getPort();\n-    String file = u.getFile();\n+    String host = url.getHost();\n+    int port = url.getPort();\n+    String file = url.getFile();\n+    String ref = url.getRef();\n     \n-    /* TBD: The JDK 1.2 doc specifically says that limit is the position\n-     * to stop parsing at and that it will be either the end of the string\n-     * or the position of '#'; thus the doc infers that this method does\n-     * not set the ref.\n-     */\n     if (spec.regionMatches (start, \"//\", 0, 2))\n       {\n \tint hostEnd;\n@@ -74,7 +136,7 @@ protected void parseURL(URL u, String spec, int start, int limit)\n \tif (slash >= 0) \n \t  hostEnd = slash;\n         else\n-\t  hostEnd = limit;\n+\t  hostEnd = end;\n \n \thost = spec.substring (start, hostEnd);\n \t\n@@ -103,28 +165,46 @@ protected void parseURL(URL u, String spec, int start, int limit)\n     else if (host == null) \n       host = \"\";\n \n-    if (start < limit && spec.charAt(start) == '/') \n-      {\n-\t// This is an absolute path name; ignore any file context.\n-\tfile = spec.substring(start, limit);\n-      } \n-    else if (file == null || file.length() <= 0)\n+    if (file == null || file.length() == 0\n+\t|| (start < end && spec.charAt(start) == '/')) \n       {\n \t// No file context available; just spec for file.\n-\tfile = spec.substring(start, limit);\n-      }\n-    else if (start < limit)\n+\t// Or this is an absolute path name; ignore any file context.\n+\tfile = spec.substring(start, end);\n+\tref = null;\n+      } \n+    else if (start < end)\n       {\n \t// Context is available, but only override it if there is a new file.\n \tfile = file.substring(0, file.lastIndexOf('/'))\n-\t\t+ '/' + spec.substring(start, limit);\n+\t\t+ '/' + spec.substring(start, end);\n+\tref = null;\n       }\n \n-    u.set(u.getProtocol(), host, port, file, u.getRef());\n+    if (ref == null)\n+      {\n+\t// Normally there should be no '#' in the file part,\n+\t// but we are nice.\n+\tint hash = file.indexOf('#');\n+\tif (hash != -1)\n+\t  {\n+\t    ref = file.substring(hash + 1, file.length());\n+\t    file = file.substring(0, hash);\n+\t  }\n+      }\n+\n+    // XXX - Classpath used to call PlatformHelper.toCanonicalForm() on\n+    // the file part. It seems like overhead, but supposedly there is some\n+    // benefit in windows based systems (it also lowercased the string).\n+\n+    setURL(url, url.getProtocol(), host, port, file, ref);\n   }\n   \n   private static String canonicalizeFilename(String file)\n   {\n+    // XXX - GNU Classpath has an implementation that might be more appropriate\n+    // for Windows based systems (gnu.java.io.PlatformHelper.toCanonicalForm)\n+\n     int index;\n \n     // Replace \"/./\" with \"/\".  This probably isn't very efficient in\n@@ -179,7 +259,8 @@ protected boolean sameFile(URL url1, URL url2)\n   }\n \n   /**\n-   * Sets the fields of the URL argument to the indicated values\n+   * This methods sets the instance variables representing the various fields\n+   * of the URL to the values passed in.\n    *\n    * @param u The URL to modify\n    * @param protocol The protocol to set\n@@ -317,38 +398,53 @@ protected int hashCode (URL url)\n   }\n \n   /**\n-   * Converts an URL of a specific protocol to a string\n+   * This method converts a URL object into a String.  This method creates\n+   * Strings in the mold of http URL's, so protocol handlers which use URL's\n+   * that have a different syntax should override this method\n    *\n-   * @param u The URL to convert\n+   * @param url The URL object to convert\n    */\n   protected String toExternalForm(URL u)\n   {\n-    String resStr, host, file, ref;\n+    String protocol, host, file, ref;\n     int port;\n \n-    resStr = u.getProtocol() + \":\";\n+    protocol = u.getProtocol();\n+\n+    // JDK 1.2 online doc infers that host could be null because it\n+    // explicitly states that file cannot be null, but is silent on host.\n     host = u.getHost();\n+    if (host == null)\n+      host = \"\";\n+\n     port = u.getPort();\n     file = u.getFile();\n     ref = u.getRef();\n \n-    // JDK 1.2 online doc infers that host could be null because it\n-    // explicitly states that file cannot be null, but is silent on host.\n-    //\n+    // Guess a reasonable size for the string buffer so we have to resize\n+    // at most once.\n+    int size = protocol.length() + host.length() + file.length() + 24;\n+    StringBuffer sb = new StringBuffer(size);\n+\n+    sb.append(protocol);\n+    sb.append(':');\n+\n+    if (host.length() != 0)\n+      sb.append(\"//\").append(host);\n+\n     // Note that this produces different results from JDK 1.2 as JDK 1.2\n     // ignores a non-default port if host is null or \"\".  That is inconsistent\n     // with the spec since the result of this method is spec'ed so it can be\n     // used to construct a new URL that is equivalent to the original.\n-    if (host == null)\n-      host = \"\";\n-    if (port >= 0 || ! (host.length() == 0))\n-      resStr = resStr + \"//\" + host + (port < 0 ? \"\" : \":\" + port);\n+    boolean port_needed = port >= 0 && port != getDefaultPort();\n+    if (port_needed)\n+      sb.append(':').append(port);\n \n-    resStr = resStr + file;\n+    sb.append(file);\n \n     if (ref != null)\n-      resStr = resStr + \"#\" + ref;\n+      sb.append('#').append(ref);\n \n-    return resStr;\n+    return sb.toString();\n   }\n }"}]}