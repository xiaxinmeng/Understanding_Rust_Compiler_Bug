{"sha": "aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhMmJkN2M0N2Q3NjA3ZjVmYTYxNjMyYmY1Y2EwNjYxNjI2YWQ2YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-08-26T01:28:10Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-08-26T01:28:10Z"}, "message": "Document new ssa operand iterator.\n\nFrom-SVN: r86599", "tree": {"sha": "5f6aa1b4851d2ae4ac7c00d65172f65443fdd0a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f6aa1b4851d2ae4ac7c00d65172f65443fdd0a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a/comments", "author": null, "committer": null, "parents": [{"sha": "0423421f6f73c7375200a3a59da5269b31c6af28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0423421f6f73c7375200a3a59da5269b31c6af28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0423421f6f73c7375200a3a59da5269b31c6af28"}], "stats": {"total": 119, "additions": 118, "deletions": 1}, "files": [{"sha": "fe284a989689bbd00524dadc8b9f0b2172a9d043", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "patch": "@@ -1,3 +1,7 @@\n+2004-08-25  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* doc/tree-ssa.texi: Document new operand iterator.\n+\n 2004-08-26  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/16480"}, {"sha": "e54383ab3e610f5067e98ace82a697794d2e4df6", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca2bd7c47d7607f5fa61632bf5ca0661626ad6a/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=aca2bd7c47d7607f5fa61632bf5ca0661626ad6a", "patch": "@@ -817,7 +817,10 @@ print_ops (tree stmt)\n   \n   v_may_defs = V_MAY_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    print_generic_expr (stderr, V_MAY_DEF_OP (v_may_defs, i), 0);\n+    @{\n+      print_generic_expr (stderr, V_MAY_DEF_OP (v_may_defs, i), 0);\n+      print_generic_expr (stderr, V_MAY_DEF_RESULT (v_may_defs, i), 0);\n+    @}\n \n   v_must_defs = V_MUST_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n@@ -835,6 +838,116 @@ operation, statements are only scanned if they have been marked\n modified by a call to @code{modify_stmt}.  So, if your pass replaces\n operands in a statement, make sure to call @code{modify_stmt}.\n \n+@subsection Operand Iterators\n+@cindex Operand Iterators\n+\n+There is an alternative to iterating over the operands in a statement.\n+It is especially useful when you wish to perform the same operation on\n+more than one type of operand.  The previous example could be\n+rewritten as follows:\n+\n+@smallexample\n+void\n+print_ops (tree stmt)\n+@{\n+  ssa_op_iter;\n+  tree var;\n+\n+  get_stmt_operands (stmt);\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)\n+    print_generic_expr (stderr, var, 0);\n+@}\n+@end smallexample\n+\n+\n+@enumerate\n+@item Determine whether you are need to see the operand pointers, or just the\n+    trees, and choose the appropriate macro: \n+\n+@smallexample\n+Need            Macro: \n+----            ------- \n+use_operand_p   FOR_EACH_SSA_USE_OPERAND \n+def_operand_p   FOR_EACH_SSA_DEF_OPERAND \n+tree            FOR_EACH_SSA_TREE_OPERAND \n+@end smallexample\n+\n+@item You need to declare a variable of the type you are interested\n+    in, and an ssa_op_iter structure which serves as the loop\n+    controlling variable. \n+\n+@item Determine which operands you wish to use, and specify the flags of\n+    those you are interested in.  They are documented in\n+    @file{tree-ssa-operands.h}: \n+\n+@smallexample\n+#define SSA_OP_USE              0x01    /* Real USE operands.  */\n+#define SSA_OP_DEF              0x02    /* Real DEF operands.  */\n+#define SSA_OP_VUSE             0x04    /* VUSE operands.  */\n+#define SSA_OP_VMAYUSE          0x08    /* USE portion of V_MAY_DEFS.  */\n+#define SSA_OP_VMAYDEF          0x10    /* DEF portion of V_MAY_DEFS.  */\n+#define SSA_OP_VMUSTDEF         0x20    /* V_MUST_DEF definitions.  */\n+\n+/* These are commonly grouped operand flags.  */\n+#define SSA_OP_VIRTUAL_USES     (SSA_OP_VUSE | SSA_OP_VMAYUSE)\n+#define SSA_OP_VIRTUAL_DEFS     (SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF)\n+#define SSA_OP_ALL_USES         (SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n+#define SSA_OP_ALL_DEFS         (SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n+#define SSA_OP_ALL_OPERANDS     (SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)\n+@end smallexample\n+@end enumerate\n+\n+So if you want to look at the use pointers for all the @code{USE} and\n+@code{VUSE} operands, you would do something like: \n+\n+@smallexample\n+  use_operand_p use_p; \n+  ssa_op_iter iter; \n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))\n+    @{ \n+      process_use_ptr (use_p); \n+    @} \n+@end smallexample\n+\n+The @code{_TREE_} macro is basically the same as the @code{USE} and\n+@code{DEF} macros, only with the use or def dereferenced via\n+@code{USE_FROM_PTR (use_p)} and @code{DEF_FROM_PTR (def_p)}. Since we\n+aren't using operand pointers, use and defs flags can be mixed. \n+\n+@smallexample\n+  tree var;\n+  ssa_op_iter iter;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE | SSA_OP_VMUSTDEF)\n+    @{\n+       print_generic_expr (stderr, var, TDF_SLIM);\n+    @}\n+@end smallexample\n+\n+Note that @code{V_MAY_DEFS} are broken into 2 flags, one for the\n+@code{DEF} portion (@code{SSA_OP_VMAYDEF}) and one for the USE portion\n+(@code{SSA_OP_VMAYUSE}). If all you want to look at are the\n+@code{V_MAY_DEFS} together, there is a fourth iterator macro for this,\n+which returns both a def_operand_p and a use_operand_p for each\n+@code{V_MAY_DEF} in the statement. Note that you don't need any flags for\n+this one. \n+\n+@smallexample\n+  use_operand_p use_p; \n+  def_operand_p def_p; \n+  ssa_op_iter iter; \n+\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter) \n+    @{ \n+      my_code; \n+    @} \n+@end smallexample\n+\n+\n+There are many examples in the code as well, as well as the\n+documentation in @file{tree-ssa-operands.h}. \n+\n \n @node SSA\n @section Static Single Assignment"}]}