{"sha": "43c013df02fdb07f9b7a5e7e6669e6d69769d451", "node_id": "C_kwDOANBUbNoAKDQzYzAxM2RmMDJmZGIwN2Y5YjdhNWU3ZTY2NjllNmQ2OTc2OWQ0NTE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-03T13:29:12Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-03T13:29:12Z"}, "message": "c++: don't substitute TEMPLATE_PARM_CONSTRAINTS [PR100374]\n\nThis patch makes us avoid substituting into the TEMPLATE_PARM_CONSTRAINTS\nof each template parameter except as necessary for declaration matching,\nlike we already do for the other constituent constraints of a declaration.\n\nThis patch also improves the CA104 implementation of explicit\nspecialization matching of a constrained function template inside a\nclass template, by considering the function's combined constraints\ninstead of just its trailing constraints.  This allows us to correctly\nhandle the first three explicit specializations in concepts-spec2.C\nbelow, but because we compare the constraints as a whole, it means we\nincorrectly accept the fourth explicit specialization which writes #3's\nconstraints in a different way.  For complete correctness here,\ndetermine_specialization should use tsubst_each_template_parm_constraints\nand template_parameter_heads_equivalent_p.\n\n\tPR c++/100374\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (determine_specialization): Compare overall constraints\n\tnot just the trailing constraints.\n\t(tsubst_each_template_parm_constraints): Define.\n\t(tsubst_friend_function): Use it.\n\t(tsubst_friend_class): Use it.\n\t(tsubst_template_parm): Don't substitute TEMPLATE_PARM_CONSTRAINTS.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-spec2.C: New test.\n\t* g++.dg/cpp2a/concepts-template-parm11.C: New test.", "tree": {"sha": "a9021ab5d91e98311f65e0267fbe7ac76420d734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9021ab5d91e98311f65e0267fbe7ac76420d734"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43c013df02fdb07f9b7a5e7e6669e6d69769d451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c013df02fdb07f9b7a5e7e6669e6d69769d451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c013df02fdb07f9b7a5e7e6669e6d69769d451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c013df02fdb07f9b7a5e7e6669e6d69769d451/comments", "author": null, "committer": null, "parents": [{"sha": "df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562"}], "stats": {"total": 78, "additions": 71, "deletions": 7}, "files": [{"sha": "59b94317e88955a8ad6a1778fda46e67a7da3084", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=43c013df02fdb07f9b7a5e7e6669e6d69769d451", "patch": "@@ -184,6 +184,7 @@ static int unify_pack_expansion (tree, tree, tree,\n \t\t\t\t tree, unification_kind_t, bool, bool);\n static tree copy_template_args (tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n+static void tsubst_each_template_parm_constraints (tree, tree, tsubst_flags_t);\n tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);\n@@ -2323,8 +2324,8 @@ determine_specialization (tree template_id,\n \t      if (!compparms (fn_arg_types, decl_arg_types))\n \t\tcontinue;\n \n-\t      tree freq = get_trailing_function_requirements (fn);\n-\t      tree dreq = get_trailing_function_requirements (decl);\n+\t      tree freq = get_constraints (fn);\n+\t      tree dreq = get_constraints (decl);\n \t      if (!freq != !dreq)\n \t\tcontinue;\n \t      if (freq)\n@@ -2333,7 +2334,7 @@ determine_specialization (tree template_id,\n \t\t     constraint-expression.  */\n \t\t  tree fargs = DECL_TI_ARGS (fn);\n \t\t  tsubst_flags_t complain = tf_none;\n-\t\t  freq = tsubst_constraint (freq, fargs, complain, fn);\n+\t\t  freq = tsubst_constraint_info (freq, fargs, complain, fn);\n \t\t  if (!cp_tree_equal (freq, dreq))\n \t\t    continue;\n \t\t}\n@@ -11240,7 +11241,13 @@ tsubst_friend_function (tree decl, tree args)\n       tree parms = DECL_TEMPLATE_PARMS (new_friend);\n       tree treqs = TEMPLATE_PARMS_CONSTRAINTS (parms);\n       treqs = maybe_substitute_reqs_for (treqs, new_friend);\n-      TEMPLATE_PARMS_CONSTRAINTS (parms) = treqs;\n+      if (treqs != TEMPLATE_PARMS_CONSTRAINTS (parms))\n+\t{\n+\t  TEMPLATE_PARMS_CONSTRAINTS (parms) = treqs;\n+\t  /* As well as each TEMPLATE_PARM_CONSTRAINTS.  */\n+\t  tsubst_each_template_parm_constraints (parms, args,\n+\t\t\t\t\t\t tf_warning_or_error);\n+\t}\n     }\n \n   /* The mangled name for the NEW_FRIEND is incorrect.  The function\n@@ -11486,6 +11493,8 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \t{\n \t  tree parms = tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n \t\t\t\t\t      args, tf_warning_or_error);\n+\t  tsubst_each_template_parm_constraints (parms, args,\n+\t\t\t\t\t\t tf_warning_or_error);\n           location_t saved_input_location = input_location;\n           input_location = DECL_SOURCE_LOCATION (friend_tmpl);\n           tree cons = get_constraints (tmpl);\n@@ -11520,6 +11529,8 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \t\t\t\t\t   DECL_FRIEND_CONTEXT (friend_tmpl));\n \t      --processing_template_decl;\n \t      set_constraints (tmpl, ci);\n+\t      tsubst_each_template_parm_constraints (DECL_TEMPLATE_PARMS (tmpl),\n+\t\t\t\t\t\t     args, tf_warning_or_error);\n \t    }\n \n \t  /* Inject this template into the enclosing namspace scope.  */\n@@ -13632,21 +13643,38 @@ tsubst_template_parm (tree t, tree args, tsubst_flags_t complain)\n \n   default_value = TREE_PURPOSE (t);\n   parm_decl = TREE_VALUE (t);\n-  tree constraint = TEMPLATE_PARM_CONSTRAINTS (t);\n \n   parm_decl = tsubst (parm_decl, args, complain, NULL_TREE);\n   if (TREE_CODE (parm_decl) == PARM_DECL\n       && invalid_nontype_parm_type_p (TREE_TYPE (parm_decl), complain))\n     parm_decl = error_mark_node;\n   default_value = tsubst_template_arg (default_value, args,\n \t\t\t\t       complain, NULL_TREE);\n-  constraint = tsubst_constraint (constraint, args, complain, NULL_TREE);\n \n   tree r = build_tree_list (default_value, parm_decl);\n-  TEMPLATE_PARM_CONSTRAINTS (r) = constraint;\n+  TEMPLATE_PARM_CONSTRAINTS (r) = TEMPLATE_PARM_CONSTRAINTS (t);\n   return r;\n }\n \n+/* Substitute in-place the TEMPLATE_PARM_CONSTRAINTS of each template\n+   parameter in PARMS for sake of declaration matching.  */\n+\n+static void\n+tsubst_each_template_parm_constraints (tree parms, tree args,\n+\t\t\t\t       tsubst_flags_t complain)\n+{\n+  ++processing_template_decl;\n+  for (; parms; parms = TREE_CHAIN (parms))\n+    {\n+      tree level = TREE_VALUE (parms);\n+      for (tree parm : tree_vec_range (level))\n+\tTEMPLATE_PARM_CONSTRAINTS (parm)\n+\t  = tsubst_constraint (TEMPLATE_PARM_CONSTRAINTS (parm), args,\n+\t\t\t       complain, NULL_TREE);\n+    }\n+  --processing_template_decl;\n+}\n+\n /* Substitute the ARGS into the indicated aggregate (or enumeration)\n    type T.  If T is not an aggregate or enumeration type, it is\n    handled as if by tsubst.  IN_DECL is as for tsubst.  If"}, {"sha": "4de07352c273639c87cfec6324fcbe3262e718e6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-spec2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-spec2.C?ref=43c013df02fdb07f9b7a5e7e6669e6d69769d451", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++20 } }\n+\n+template<class T, int> concept C = true;\n+\n+template<class T> struct A {\n+  template<C<sizeof(T)> U> void f(); // #1\n+  template<C<0> U>         void f(); // #2\n+  template<C<-1> U>        void f(); // #3\n+};\n+\n+constexpr int n = sizeof(int);\n+template<> template<C<n> U>  void A<int>::f() { } // matches #1\n+template<> template<C<0> U>  void A<int>::f() { } // matches #2\n+template<> template<C<-2> U> void A<int>::f() { } // no match { dg-error \"match\" }\n+template<> template<class U> void A<int>::f() requires C<U, -1> { } // shouldn't match #3\n+// { dg-error \"match\" \"\" { xfail *-*-* } .-1 }"}, {"sha": "498e3c175cfad68426c6ebecf15366e7dd731ccc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-template-parm11.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-template-parm11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c013df02fdb07f9b7a5e7e6669e6d69769d451/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-template-parm11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-template-parm11.C?ref=43c013df02fdb07f9b7a5e7e6669e6d69769d451", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/100374\n+// { dg-do compile { target c++20 } }\n+\n+template<class T, class U>\n+concept C = requires { typename T; };\n+\n+template<class T>\n+struct A {\n+  template<C<typename T::value_type> U>\n+  void f();\n+\n+  template<C<typename T::value_type> U>\n+  struct B;\n+};\n+\n+int main() {\n+  A<int> a;\n+  a.f<void>();\n+  using type = A<int>::B<void>;\n+}"}]}