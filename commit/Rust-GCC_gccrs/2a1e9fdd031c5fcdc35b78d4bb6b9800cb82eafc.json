{"sha": "2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExZTlmZGQwMzFjNWZjZGMzNWI3OGQ0YmI2Yjk4MDBjYjgyZWFmYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-08T20:12:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-08T20:12:35Z"}, "message": "cp-tree.h (copy_to_permanent): Remove.\n\n\t* cp-tree.h (copy_to_permanent): Remove.\n\t(permanent_p): Likewise.\n\t* decl.c (building_typename_type): Don't use copy_to_permanent.\n\t(start_decl): Likewise.\n\t(grok_reference_init): Likewise.\n\t(cp_finish_decl): Likewise.\n\t* init.c (build_new_1): Don't use mapcar.\n\t(build_vec_delete_1): Don't use copy_to_permanent.\n\t(build_vec_init): Likewise.\n\t* parse.y (primary): Likewise.\n\t* parse.c: Regenerated.\n\t* pt.c (push_template_decl_real): Don't use copy_to_permanent.\n\t(lookup_template_class): Likewise.\n\t(tsubst_friend_function): Likewise.\n\t(instantiate_class_template): Likewise.\n\t(tsubst_decl): Likewise.\n\t(tsubst): Likewise.\n\t(instantiate_template): Likewise.\n\t(unify): Likewise.\n\t* rtti.c (get_tinfo_fn): Likewise.\n\t(build_dynamic_cast): Likewise.\n\t* semantics.c (finish_if_stmt_cond): Likewise.\n\t(finish_while_stmt_cond): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t(finish_for_expr): Likewise.\n\t(finish_cleanup): Likewise.\n\t(add_decl_stmt): Likewise.\n\t(finish_named_return_value): Likewise.\n\t(finish_qualified_call_expr): Likewise.\n\t* tree.c (perm_manip): Remove.\n\t(build_exception_variant): Don't use copy_to_permanent.\n\t(permanent_p): Remove.\n\t(copy_to_permament): Remove.\n\t(build_min_nt): Don't use copy_to_permanent.\n\t(build_min): Likewise.\n\t(min_tree_cons): Likewise.\n\t* typeckc.c (build_static_cast): Likewise.\n\t(build_reinterpret_cast): Likewise.\n\t(build_const_cast): Likewise.\n\nFrom-SVN: r29211", "tree": {"sha": "adf9be1d936c0ca1288a7994361c1272e150dc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf9be1d936c0ca1288a7994361c1272e150dc7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/comments", "author": null, "committer": null, "parents": [{"sha": "ce3700e3ba57f07a44a2edc9d8b146a7682bb54e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3700e3ba57f07a44a2edc9d8b146a7682bb54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3700e3ba57f07a44a2edc9d8b146a7682bb54e"}], "stats": {"total": 193, "additions": 67, "deletions": 126}, "files": [{"sha": "4b689dec6fe33b767be2acb2dc6ae7623a430941", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -1,3 +1,46 @@\n+1999-09-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (copy_to_permanent): Remove.\n+\t(permanent_p): Likewise.\n+\t* decl.c (building_typename_type): Don't use copy_to_permanent.\n+\t(start_decl): Likewise.\n+\t(grok_reference_init): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t* init.c (build_new_1): Don't use mapcar.\n+\t(build_vec_delete_1): Don't use copy_to_permanent.\n+\t(build_vec_init): Likewise.\n+\t* parse.y (primary): Likewise.\n+\t* parse.c: Regenerated.\n+\t* pt.c (push_template_decl_real): Don't use copy_to_permanent.\n+\t(lookup_template_class): Likewise.\n+\t(tsubst_friend_function): Likewise.\n+\t(instantiate_class_template): Likewise.\n+\t(tsubst_decl): Likewise.\n+\t(tsubst): Likewise.\n+\t(instantiate_template): Likewise.\n+\t(unify): Likewise.\n+\t* rtti.c (get_tinfo_fn): Likewise.\n+\t(build_dynamic_cast): Likewise.\n+\t* semantics.c (finish_if_stmt_cond): Likewise.\n+\t(finish_while_stmt_cond): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t(finish_for_expr): Likewise.\n+\t(finish_cleanup): Likewise.\n+\t(add_decl_stmt): Likewise.\n+\t(finish_named_return_value): Likewise.\n+\t(finish_qualified_call_expr): Likewise.\n+\t* tree.c (perm_manip): Remove.\n+\t(build_exception_variant): Don't use copy_to_permanent.\n+\t(permanent_p): Remove.\n+\t(copy_to_permament): Remove.\n+\t(build_min_nt): Don't use copy_to_permanent.\n+\t(build_min): Likewise.\n+\t(min_tree_cons): Likewise.\n+\t* typeckc.c (build_static_cast): Likewise.\n+\t(build_reinterpret_cast): Likewise.\n+\t(build_const_cast): Likewise.\n+\t\n 1999-09-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (ggc_p): Set it to 1."}, {"sha": "bba4076b856faf762d945150936eed8fad37e810", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -3676,8 +3676,6 @@ extern int is_aggr_type_2\t\t\tPROTO((tree, tree));\n extern const char *lang_printable_name\t\tPROTO((tree, int));\n extern tree build_exception_variant\t\tPROTO((tree, tree));\n extern tree copy_template_template_parm\t\tPROTO((tree));\n-extern tree copy_to_permanent\t\t\tPROTO((tree));\n-extern tree permanent_p                         PROTO((tree));\n extern void print_lang_statistics\t\tPROTO((void));\n extern void __eprintf\n \tPROTO((const char *, const char *, unsigned, const char *));"}, {"sha": "c66ba022e221ab4298e183fe20365c3afde06c67", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -5365,11 +5365,6 @@ build_typename_type (context, name, fullname, base_type)\n       ggc_add_tree_hash_table_root (&h, 1);\n     }\n \n-  /* The FULLNAME needs to exist for the life of the hash table, i.e.,\n-     for the entire compilation.  */\n-  if (!TREE_PERMANENT (fullname))\n-    fullname = copy_to_permanent (fullname);\n-\n   /* Build the TYPENAME_TYPE.  */\n   t = make_lang_type (TYPENAME_TYPE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n@@ -6908,7 +6903,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t  tree itype = TYPE_DOMAIN (type);\n \t  if (itype && ! TREE_PERMANENT (itype))\n \t    {\n-\t      itype = build_index_type (copy_to_permanent (TYPE_MAX_VALUE (itype)));\n+\t      itype = build_index_type (TYPE_MAX_VALUE (itype));\n \t      type = build_cplus_array_type (TREE_TYPE (type), itype);\n \t      TREE_TYPE (decl) = type;\n \t    }\n@@ -7218,8 +7213,6 @@ grok_reference_init (decl, type, init)\n   if (TYPE_SIZE (TREE_TYPE (type)))\n     {\n       init = convert_from_reference (decl);\n-      if (TREE_PERMANENT (decl))\n-\tinit = copy_to_permanent (init);\n       SET_DECL_REFERENCE_SLOT (decl, init);\n     }\n \n@@ -7900,7 +7893,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (processing_template_decl)\n     {\n       if (init && DECL_INITIAL (decl))\n-\tDECL_INITIAL (decl) = copy_to_permanent (init);\n+\tDECL_INITIAL (decl) = init;\n       goto finish_end0;\n     }\n "}, {"sha": "a550a72a3f086a6b2ef4848a12b7ce93db59bcb7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -2444,9 +2444,6 @@ build_new_1 (exp)\n \t  fn = TREE_OPERAND (alloc_expr, 1);\n \t  fn = TREE_OPERAND (fn, 0);\n \n-\t  /* Copy size to the saveable obstack.  */\n-\t  size = mapcar (size, permanent_p);\n-\n \t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags, fn);\n \n \t  resume_momentary (yes);\n@@ -2654,15 +2651,6 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \n   if (controller)\n     {\n-      /* The CONTROLLER is a BIND_EXPR.  Such things are always\n-\t allocated on at least the saveable obstack.  Since we may\n-\t need to copy this expression to the permanent obstack, we\n-\t must make sure that the operand is on the same obstack as the\n-\t BIND_EXPR.  Otherwise, copy_to_permanent will not copy the\n-\t operand, since it will assume that anything under a permanent\n-\t node is permanent.  */\n-      if (TREE_PERMANENT (controller))\n-\tbody = copy_to_permanent (body);\n       TREE_OPERAND (controller, 1) = body;\n       return controller;\n     }\n@@ -3010,9 +2998,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t on the temporary obstack.  */\n       push_obstacks_nochange ();\n       resume_temporary_allocation ();\n-      /* And MAXINDEX needs to be copied to the current obstack.  It's\n-\t probably on the momentary obstack now.  */\n-      maxindex = mapcar (maxindex, permanent_p);\n       e = build_vec_delete_1 (rval,\n \t\t\t      build_binary_op (MINUS_EXPR, maxindex, \n \t\t\t\t\t       iterator),"}, {"sha": "9ec49033522cac20b9f5619b739ad858578650f7", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -5820,7 +5820,7 @@ case 340:\n case 341:\n #line 1542 \"parse.y\"\n { if (processing_template_decl)\n-\t\t    yyval.ttype = build_min_nt (COMPONENT_REF, yyvsp[-1].ttype, copy_to_permanent (yyvsp[0].ttype));\n+\t\t    yyval.ttype = build_min_nt (COMPONENT_REF, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  else\n \t\t    yyval.ttype = build_object_ref (yyval.ttype, OP0 (yyvsp[0].ttype), OP1 (yyvsp[0].ttype)); ;\n     break;}"}, {"sha": "e12d1b245910fcba7f1f58611bf33c7899606120", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -1540,7 +1540,7 @@ primary:\n \t\t{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object overqualified_id  %prec UNARY\n \t\t{ if (processing_template_decl)\n-\t\t    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));\n+\t\t    $$ = build_min_nt (COMPONENT_REF, $1, $2);\n \t\t  else\n \t\t    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n \t| object unqualified_id '(' nonnull_exprlist ')'"}, {"sha": "a02e17a06b9210f50e19b52941edaeac79655c8c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -2604,7 +2604,7 @@ push_template_decl_real (decl, is_friend)\n   if (primary)\n     DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n \n-  info = perm_tree_cons (tmpl, copy_to_permanent (args), NULL_TREE);\n+  info = perm_tree_cons (tmpl, args, NULL_TREE);\n \n   if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n@@ -3801,7 +3801,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       if (arglist2 == error_mark_node)\n \treturn error_mark_node;\n \n-      arglist2 = copy_to_permanent (arglist2);\n       TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm)\n \t= perm_tree_cons (template2, arglist2, NULL_TREE);\n       TYPE_SIZE (parm) = 0;\n@@ -4059,7 +4058,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t    my_friendly_abort (0);\n \t}\n \n-      arglist = copy_to_permanent (arglist);\n       SET_TYPE_TEMPLATE_INFO (t,\n \t\t\t      tree_cons (found, arglist, NULL_TREE));  \n       DECL_TEMPLATE_INSTANTIATIONS (template) \n@@ -4706,8 +4704,6 @@ tsubst_friend_function (decl, args)\n \t\t      DECL_TI_ARGS (spec) \n \t\t\t= add_outermost_template_args (new_friend_args,\n \t\t\t\t\t\t       DECL_TI_ARGS (spec));\n-\t\t      DECL_TI_ARGS (spec)\n-\t\t\t= copy_to_permanent (DECL_TI_ARGS (spec));\n \t\t    }\n \n \t\t  /* Now, since specializations are always supposed to\n@@ -5019,11 +5015,6 @@ instantiate_class_template (type)\n   if (ANON_AGGR_TYPE_P (pattern))\n     SET_ANON_AGGR_TYPE_P (type);\n \n-  /* We must copy the arguments to the permanent obstack since\n-     during the tsubst'ing below they may wind up in the\n-     DECL_TI_ARGS of some instantiated member template.  */\n-  args = copy_to_permanent (args);\n-\n   if (TYPE_BINFO_BASETYPES (pattern))\n     {\n       tree base_list = NULL_TREE;\n@@ -5778,9 +5769,6 @@ tsubst_decl (t, args, type, in_decl)\n \t\tbreak;\n \t      }\n \n-\t    /* We're going to need to keep the ARGVEC, so we copy it\n-\t       here.  */\n-\t    argvec = copy_to_permanent (argvec);\n \t    pop_momentary ();\n \n \t    /* Here, we deal with the peculiar case:\n@@ -5900,9 +5888,6 @@ tsubst_decl (t, args, type, in_decl)\n \t   case mentioned above where GEN_TMPL is NULL.  */\n \tif (gen_tmpl)\n \t  {\n-\t    /* The ARGVEC was built on the momentary obstack.  Make it\n-\t       permanent now.  */\n-\t    argvec = copy_to_permanent (argvec);\n \t    DECL_TEMPLATE_INFO (r) \n \t      = perm_tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -6412,8 +6397,6 @@ tsubst (t, args, complain, in_decl)\n \t  }\n \n \tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node));\n-\tif (!TREE_PERMANENT (max) && !allocation_temporary_p ())\n-\t  max = copy_to_permanent (max);\n \treturn build_index_type (max);\n       }\n \n@@ -7561,7 +7544,6 @@ instantiate_template (tmpl, targ_ptr)\n \t    }\n \t}\n     }\n-  targ_ptr = copy_to_permanent (targ_ptr);\n \n   /* substitute template parameters */\n   fndecl = tsubst (DECL_RESULT (gen_tmpl), targ_ptr, /*complain=*/1, gen_tmpl);\n@@ -8534,7 +8516,7 @@ unify (tparms, targs, parm, arg, strict)\n       else\n \treturn 1;\n \n-      TREE_VEC_ELT (targs, idx) = copy_to_permanent (arg);\n+      TREE_VEC_ELT (targs, idx) = arg;\n       return 0;\n \n     case POINTER_TYPE:"}, {"sha": "d5d3377ba1fcdc21553e2d28c1ca212136445181", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -385,7 +385,7 @@ get_tinfo_fn (type)\n   DECL_ARTIFICIAL (d) = 1;\n   DECL_NOT_REALLY_EXTERN (d) = 1;\n   SET_DECL_TINFO_FN_P (d);\n-  TREE_TYPE (name) = copy_to_permanent (type);\n+  TREE_TYPE (name) = type;\n \n   pushdecl_top_level (d);\n   make_function_rtl (d);\n@@ -703,7 +703,7 @@ build_dynamic_cast (type, expr)\n     return error_mark_node;\n   \n   if (processing_template_decl)\n-    return build_min (DYNAMIC_CAST_EXPR, copy_to_permanent (type), expr);\n+    return build_min (DYNAMIC_CAST_EXPR, type, expr);\n \n   return convert_from_reference (build_dynamic_cast_1 (type, expr));\n }"}, {"sha": "bd444491b3b236dacc0b41e53960f20f85a7bce2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -138,7 +138,7 @@ finish_if_stmt_cond (cond, if_stmt)\n       if (last_tree != if_stmt)\n \tRECHAIN_STMTS_FROM_LAST (if_stmt, IF_COND (if_stmt));\n       else\n-\tIF_COND (if_stmt) = copy_to_permanent (cond);\n+\tIF_COND (if_stmt) = cond;\n     }\n   else\n     {\n@@ -236,7 +236,7 @@ finish_while_stmt_cond (cond, while_stmt)\n       if (last_tree != while_stmt)\n \tRECHAIN_STMTS_FROM_LAST (while_stmt, WHILE_COND (while_stmt)); \n       else\n-\tTREE_OPERAND (while_stmt, 0) = copy_to_permanent (cond);\n+\tTREE_OPERAND (while_stmt, 0) = cond;\n     }\n   else\n     {\n@@ -311,7 +311,7 @@ finish_do_stmt (cond, do_stmt)\n      tree do_stmt;\n {\n   if (building_stmt_tree ())\n-    DO_COND (do_stmt) = copy_to_permanent (cond);\n+    DO_COND (do_stmt) = cond;\n   else\n     {\n       emit_line_note (input_filename, lineno);\n@@ -401,7 +401,7 @@ finish_for_cond (cond, for_stmt)\n       if (last_tree != for_stmt)\n \tRECHAIN_STMTS_FROM_LAST (for_stmt, FOR_COND (for_stmt));\n       else\n-\tFOR_COND (for_stmt) = copy_to_permanent (cond);\n+\tFOR_COND (for_stmt) = cond;\n     }\n   else\n     {\n@@ -429,7 +429,7 @@ finish_for_expr (expr, for_stmt)\n      tree for_stmt;\n {\n   if (building_stmt_tree ())\n-    FOR_EXPR (for_stmt) = copy_to_permanent (expr);\n+    FOR_EXPR (for_stmt) = expr;\n \n   /* Don't let the tree nodes for EXPR be discarded\n      by clear_momentary during the parsing of the next stmt.  */\n@@ -659,7 +659,7 @@ finish_cleanup (cleanup, try_block)\n {\n   if (building_stmt_tree ()) \n     {\n-      TRY_HANDLERS (try_block) = copy_to_permanent (cleanup);\n+      TRY_HANDLERS (try_block) = cleanup;\n       CLEANUP_P (try_block) = 1;\n     }\n   else\n@@ -924,7 +924,6 @@ add_decl_stmt (decl)\n   tree decl_stmt;\n \n   /* We need the type to last until instantiation time.  */\n-  TREE_TYPE (decl) = copy_to_permanent (TREE_TYPE (decl));\n   decl_stmt = build_min_nt (DECL_STMT, decl);\n   add_tree (decl_stmt);\n }\n@@ -990,8 +989,7 @@ finish_named_return_value (return_id, init)\n       pushdecl (decl);\n \n       if (building_stmt_tree ())\n-\tadd_tree (build_min_nt (RETURN_INIT, return_id,\n-\t\t\t\tcopy_to_permanent (init)));\n+\tadd_tree (build_min_nt (RETURN_INIT, return_id, init));\n       else\n \t{\n \t  cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n@@ -1302,8 +1300,7 @@ finish_qualified_call_expr (fn, args)\n      tree args;\n {\n   if (processing_template_decl)\n-    return build_min_nt (CALL_EXPR, copy_to_permanent (fn), args,\n-\t\t\t NULL_TREE);\n+    return build_min_nt (CALL_EXPR, fn, args, NULL_TREE);\n   else\n     return build_member_call (TREE_OPERAND (fn, 0),\n \t\t\t      TREE_OPERAND (fn, 1),"}, {"sha": "e71cf1279254091d17afb4415ba94650870551f9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n \n static tree bot_manip PROTO((tree));\n-static tree perm_manip PROTO((tree));\n static tree build_cplus_array_type_1 PROTO((tree, tree));\n static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n@@ -1504,10 +1503,6 @@ build_exception_variant (type, raises)\n \n   /* Need to build a new variant.  */\n   v = build_type_copy (type);\n-\n-  if (raises && ! TREE_PERMANENT (raises))\n-    raises = copy_to_permanent (raises);\n-\n   TYPE_RAISES_EXCEPTIONS (v) = raises;\n   return v;\n }\n@@ -2030,55 +2025,6 @@ mapcar (t, func)\n   return NULL_TREE;\n }\n \n-/* Returns T if T is allocated on the permanent obstack, NULL_TREE\n-   otherwise.  */\n-\n-tree\n-permanent_p (t)\n-     tree t;\n-{\n-  return TREE_PERMANENT (t) ? t : NULL_TREE;\n-}\n-\n-static tree\n-perm_manip (t)\n-     tree t;\n-{\n-  if (TREE_PERMANENT (t))\n-    return t;\n-\n-  /* Support `void f () { extern int i; A<&i> a; }' */\n-  if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == FUNCTION_DECL)\n-      && TREE_PUBLIC (t))\n-    {\n-      t = copy_node (t);\n-\n-      /* copy_rtx won't make a new SYMBOL_REF, so call make_decl_rtl again.  */\n-      DECL_RTL (t) = 0;\n-      make_decl_rtl (t, NULL_PTR, 1);\n-\n-      return t;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Assuming T is a node built bottom-up, make it all exist on\n-   permanent obstack, if it is not permanent already.  */\n-\n-tree\n-copy_to_permanent (t)\n-     tree t;\n-{\n-  if (t == NULL_TREE || TREE_PERMANENT (t))\n-    return t;\n-\n-  push_permanent_obstack ();\n-  t = mapcar (t, perm_manip);\n-  pop_obstacks ();\n-\n-  return t;\n-}\n-\n #ifdef GATHER_STATISTICS\n extern int depth_reached;\n #endif\n@@ -2214,7 +2160,7 @@ build_min_nt VPROTO((enum tree_code code, ...))\n   for (i = 0; i < length; i++)\n     {\n       tree x = va_arg (p, tree);\n-      TREE_OPERAND (t, i) = copy_to_permanent (x);\n+      TREE_OPERAND (t, i) = x;\n     }\n \n   va_end (p);\n@@ -2249,13 +2195,13 @@ build_min VPROTO((enum tree_code code, tree tt, ...))\n \n   t = make_node (code);\n   length = tree_code_length[(int) code];\n-  TREE_TYPE (t) = copy_to_permanent (tt);\n+  TREE_TYPE (t) = tt;\n   TREE_COMPLEXITY (t) = lineno;\n \n   for (i = 0; i < length; i++)\n     {\n       tree x = va_arg (p, tree);\n-      TREE_OPERAND (t, i) = copy_to_permanent (x);\n+      TREE_OPERAND (t, i) = x;\n     }\n \n   va_end (p);\n@@ -2273,8 +2219,8 @@ min_tree_cons (purpose, value, chain)\n   register struct obstack *ambient_obstack = current_obstack;\n   current_obstack = &permanent_obstack;\n \n-  node = tree_cons (copy_to_permanent (purpose),\n-\t\t    copy_to_permanent (value), chain);\n+  node = tree_cons (purpose, value, chain);\n+\n   current_obstack = ambient_obstack;\n   return node;\n }"}, {"sha": "68563f801ac8b6026ff53b60f14de467fd0c7dd4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2a1e9fdd031c5fcdc35b78d4bb6b9800cb82eafc", "patch": "@@ -5239,8 +5239,7 @@ build_static_cast (type, expr)\n \n   if (processing_template_decl)\n     {\n-      tree t = build_min (STATIC_CAST_EXPR, copy_to_permanent (type),\n-\t\t\t  expr); \n+      tree t = build_min (STATIC_CAST_EXPR, type, expr); \n       return t;\n     }\n \n@@ -5332,8 +5331,7 @@ build_reinterpret_cast (type, expr)\n \n   if (processing_template_decl)\n     {\n-      tree t = build_min (REINTERPRET_CAST_EXPR, \n-\t\t\t  copy_to_permanent (type), expr);\n+      tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n       return t;\n     }\n \n@@ -5427,8 +5425,7 @@ build_const_cast (type, expr)\n \n   if (processing_template_decl)\n     {\n-      tree t = build_min (CONST_CAST_EXPR, copy_to_permanent (type),\n-\t\t\t  expr);\n+      tree t = build_min (CONST_CAST_EXPR, type, expr);\n       return t;\n     }\n "}]}