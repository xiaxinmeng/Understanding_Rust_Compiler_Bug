{"sha": "f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU5NTc0YTFjNDQzYWI1YTFkMDZkYTRiMDllZDZkNDY3N2E3MTU4YQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2014-10-24T11:47:21Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2014-10-24T11:47:21Z"}, "message": "binary_sat_op.inc: New file.\n\n2014-10-24  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* gcc.target/aarch64/advsimd-intrinsics/binary_sat_op.inc: New\n\tfile.\n\t* gcc.target/aarch64/advsimd-intrinsics/vqadd.c: Likewise.\n\t* gcc.target/aarch64/advsimd-intrinsics/vqsub.c: Likewise.\n\nFrom-SVN: r216647", "tree": {"sha": "ecd6658dfcf94c51e9279c040eb80763b99a8ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd6658dfcf94c51e9279c040eb80763b99a8ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/comments", "author": null, "committer": null, "parents": [{"sha": "56900c9c77443e4209ed558f511440f954c884f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56900c9c77443e4209ed558f511440f954c884f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56900c9c77443e4209ed558f511440f954c884f2"}], "stats": {"total": 654, "additions": 654, "deletions": 0}, "files": [{"sha": "6fd81c8359ecb83ba434e2799d6542673ac2eaa5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "patch": "@@ -1,3 +1,10 @@\n+2014-10-24  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/binary_sat_op.inc: New\n+\tfile.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vqadd.c: Likewise.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vqsub.c: Likewise.\n+\n 2014-10-24  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/unary_sat_op.inc: New"}, {"sha": "35d77015bb9479e2757396e0d30ced941eb6bb70", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/binary_sat_op.inc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fbinary_sat_op.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fbinary_sat_op.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fbinary_sat_op.inc?ref=f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "patch": "@@ -0,0 +1,91 @@\n+/* Template file for saturating binary operator validation.\n+\n+   This file is meant to be included by the relevant test files, which\n+   have to define the intrinsic family to test. If a given intrinsic\n+   supports variants which are not supported by all the other\n+   saturating binary operators, these can be tested by providing a\n+   definition for EXTRA_TESTS.  */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+#define FNNAME1(NAME) exec_ ## NAME\n+#define FNNAME(NAME) FNNAME1(NAME)\n+\n+void FNNAME (INSN_NAME) (void)\n+{\n+  /* vector_res = OP(vector1,vector2), then store the result.  */\n+\n+#define TEST_BINARY_SAT_OP1(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \\\n+  Set_Neon_Cumulative_Sat(0);\t\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    INSN##Q##_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n+\t\t      VECT_VAR(vector2, T1, W, N));\t\t\t\\\n+    vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),\t\t\t\\\n+\t\t      VECT_VAR(vector_res, T1, W, N));\t\t\t\\\n+      CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)\n+\n+#define TEST_BINARY_SAT_OP(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \\\n+  TEST_BINARY_SAT_OP1(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector1);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+\n+  clean_results ();\n+\n+  /* Initialize input \"vector1\" from \"buffer\".  */\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector1, buffer);\n+\n+  /* Choose arbitrary initialization values.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x11);\n+  VDUP(vector2, , int, s, 16, 4, 0x22);\n+  VDUP(vector2, , int, s, 32, 2, 0x33);\n+  VDUP(vector2, , int, s, 64, 1, 0x44);\n+  VDUP(vector2, , uint, u, 8, 8, 0x55);\n+  VDUP(vector2, , uint, u, 16, 4, 0x66);\n+  VDUP(vector2, , uint, u, 32, 2, 0x77);\n+  VDUP(vector2, , uint, u, 64, 1, 0x88);\n+\n+  VDUP(vector2, q, int, s, 8, 16, 0x11);\n+  VDUP(vector2, q, int, s, 16, 8, 0x22);\n+  VDUP(vector2, q, int, s, 32, 4, 0x33);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x55);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x66);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x77);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+\n+  /* Apply a saturating binary operator named INSN_NAME.  */\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 8, 8, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 16, 4, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 32, 2, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 8, 8, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 16, 4, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 32, 2, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat, \"\");\n+\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 8, 16, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 16, 8, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 32, 4, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 8, 16, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 16, 8, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 32, 4, expected_cumulative_sat, \"\");\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat, \"\");\n+\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+\n+#ifdef EXTRA_TESTS\n+  EXTRA_TESTS();\n+#endif\n+}\n+\n+int main (void)\n+{\n+  FNNAME (INSN_NAME) ();\n+\n+  return 0;\n+}"}, {"sha": "c07f5ff00466118f91bd91b5b37c6bd98af44760", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqadd.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqadd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqadd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqadd.c?ref=f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "patch": "@@ -0,0 +1,278 @@\n+#define INSN_NAME vqadd\n+#define TEST_MSG \"VQADD/VQADDQ\"\n+\n+/* Extra tests for special cases:\n+   - some requiring intermediate types larger than 64 bits to\n+   compute saturation flag.\n+   - corner case saturations with types smaller than 64 bits.\n+*/\n+void vqadd_extras(void);\n+#define EXTRA_TESTS vqadd_extras\n+\n+#include \"binary_sat_op.inc\"\n+\n+/* Expected values of cumulative_saturation flag.  */\n+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat,int,8,16) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,8,16) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;\n+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0x1, 0x2, 0x3, 0x4,\n+\t\t\t\t       0x5, 0x6, 0x7, 0x8 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0x12, 0x13, 0x14, 0x15 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0x23, 0x24 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0x34 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffff };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0x1, 0x2, 0x3, 0x4,\n+\t\t\t\t\t0x5, 0x6, 0x7, 0x8,\n+\t\t\t\t\t0x9, 0xa, 0xb, 0xc,\n+\t\t\t\t\t0xd, 0xe, 0xf, 0x10 };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0x12, 0x13, 0x14, 0x15,\n+\t\t\t\t\t0x16, 0x17, 0x18, 0x19 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0x23, 0x24, 0x25, 0x26 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0x34, 0x35 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t 0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,\n+\t\t\t\t\t 0xffff, 0xffff, 0xffff, 0xffff };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,\n+\t\t\t\t\t 0xffffffff, 0xffffffff };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffff,\n+\t\t\t\t\t 0xffffffffffffffff };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,\n+\t\t\t\t\t 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,\n+\t\t\t\t\t   0x33333333, 0x33333333 };\n+\n+\n+/* 64-bits types, with 0 as second input.  */\n+int VECT_VAR(expected_cumulative_sat_64,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,uint,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,uint,64,2) = 0;\n+VECT_VAR_DECL(expected_64,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected_64,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected_64,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t   0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected_64,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t    0xfffffffffffffff1 };\n+\n+/* 64-bits types, some cases causing cumulative saturation.  */\n+int VECT_VAR(expected_cumulative_sat_64_2,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64_2,uint,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_2,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat_64_2,uint,64,2) = 1;\n+VECT_VAR_DECL(expected_64_2,int,64,1) [] = { 0x34 };\n+VECT_VAR_DECL(expected_64_2,uint,64,1) [] = { 0xffffffffffffffff };\n+VECT_VAR_DECL(expected_64_2,int,64,2) [] = { 0x34, 0x35 };\n+VECT_VAR_DECL(expected_64_2,uint,64,2) [] = { 0xffffffffffffffff,\n+\t\t\t\t\t      0xffffffffffffffff };\n+\n+/* 64-bits types, all causing cumulative saturation.  */\n+int VECT_VAR(expected_cumulative_sat_64_3,int,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,uint,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,int,64,2) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,uint,64,2) = 1;\n+VECT_VAR_DECL(expected_64_3,int,64,1) [] = { 0x8000000000000000 };\n+VECT_VAR_DECL(expected_64_3,uint,64,1) [] = { 0xffffffffffffffff };\n+VECT_VAR_DECL(expected_64_3,int,64,2) [] = { 0x7fffffffffffffff,\n+\t\t\t\t\t     0x7fffffffffffffff };\n+VECT_VAR_DECL(expected_64_3,uint,64,2) [] = { 0xffffffffffffffff,\n+\t\t\t\t\t      0xffffffffffffffff };\n+\n+/* smaller types, corner cases causing cumulative saturation. (1)  */\n+int VECT_VAR(expected_csat_lt_64_1,int,8,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,16,4) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,32,2) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,8,16) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,16,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,32,4) = 1;\n+VECT_VAR_DECL(expected_lt_64_1,int,8,8) [] = { 0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t       0x80, 0x80, 0x80, 0x80 };\n+VECT_VAR_DECL(expected_lt_64_1,int,16,4) [] = { 0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,32,2) [] = { 0x80000000, 0x80000000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80 };\n+VECT_VAR_DECL(expected_lt_64_1,int,16,8) [] = { 0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,32,4) [] = { 0x80000000, 0x80000000,\n+\t\t\t\t\t\t0x80000000, 0x80000000 };\n+\n+/* smaller types, corner cases causing cumulative saturation. (2)  */\n+int VECT_VAR(expected_csat_lt_64_2,uint,8,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,16,4) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,32,2) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,8,16) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,16,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,32,4) = 1;\n+VECT_VAR_DECL(expected_lt_64_2,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t\t0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected_lt_64_2,uint,16,4) [] = { 0xffff, 0xffff,\n+\t\t\t\t\t\t 0xffff, 0xffff };\n+VECT_VAR_DECL(expected_lt_64_2,uint,32,2) [] = { 0xffffffff,\n+\t\t\t\t\t\t 0xffffffff };\n+VECT_VAR_DECL(expected_lt_64_2,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t\t 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t\t 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t\t 0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected_lt_64_2,uint,16,8) [] = { 0xffff, 0xffff,\n+\t\t\t\t\t\t 0xffff, 0xffff,\n+\t\t\t\t\t\t 0xffff, 0xffff,\n+\t\t\t\t\t\t 0xffff, 0xffff };\n+VECT_VAR_DECL(expected_lt_64_2,uint,32,4) [] = { 0xffffffff, 0xffffffff,\n+\t\t\t\t\t\t 0xffffffff, 0xffffffff };\n+\n+void vqadd_extras(void)\n+{\n+  DECL_VARIABLE_ALL_VARIANTS(vector1);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+\n+  /* Initialize input \"vector1\" from \"buffer\".  */\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector1, buffer);\n+\n+  /* Use a second vector full of 0.  */\n+  VDUP(vector2, , int, s, 64, 1, 0);\n+  VDUP(vector2, , uint, u, 64, 1, 0);\n+  VDUP(vector2, q, int, s, 64, 2, 0);\n+  VDUP(vector2, q, uint, u, 64, 2, 0);\n+\n+#define MSG \"64 bits saturation adding zero\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64, MSG);\n+\n+  /* Another set of tests with non-zero values, some chosen to create\n+     overflow.  */\n+  VDUP(vector2, , int, s, 64, 1, 0x44);\n+  VDUP(vector2, , uint, u, 64, 1, 0x88);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+\n+#undef MSG\n+#define MSG \"64 bits saturation cumulative_sat (2)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64_2, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64_2, MSG);\n+\n+  /* Another set of tests, with input values chosen to set\n+     cumulative_sat in all cases.  */\n+  VDUP(vector2, , int, s, 64, 1, 0x8000000000000003LL);\n+  VDUP(vector2, , uint, u, 64, 1, 0x88);\n+  /* To check positive saturation, we need to write a positive value\n+     in vector1.  */\n+  VDUP(vector1, q, int, s, 64, 2, 0x4000000000000000LL);\n+  VDUP(vector2, q, int, s, 64, 2, 0x4000000000000000LL);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x22);\n+\n+#undef MSG\n+#define MSG \"64 bits saturation cumulative_sat (3)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64_3, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64_3, MSG);\n+\n+  /* To improve coverage, check saturation with less than 64 bits\n+     too.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x81);\n+  VDUP(vector2, , int, s, 16, 4, 0x8001);\n+  VDUP(vector2, , int, s, 32, 2, 0x80000001);\n+  VDUP(vector2, q, int, s, 8, 16, 0x81);\n+  VDUP(vector2, q, int, s, 16, 8, 0x8001);\n+  VDUP(vector2, q, int, s, 32, 4, 0x80000001);\n+\n+#undef MSG\n+#define MSG \"less than 64 bits saturation cumulative_sat (1)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 8, 8, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 16, 4, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 32, 2, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 8, 16, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 16, 8, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 32, 4, expected_csat_lt_64_1, MSG);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_lt_64_1, MSG);\n+\n+  /* Another set of tests with large vector1 values.  */\n+  VDUP(vector1, , uint, u, 8, 8, 0xF0);\n+  VDUP(vector1, , uint, u, 16, 4, 0xFFF0);\n+  VDUP(vector1, , uint, u, 32, 2, 0xFFFFFFF0);\n+  VDUP(vector1, q, uint, u, 8, 16, 0xF0);\n+  VDUP(vector1, q, uint, u, 16, 8, 0xFFF0);\n+  VDUP(vector1, q, uint, u, 32, 4, 0xFFFFFFF0);\n+\n+  VDUP(vector2, , uint, u, 8, 8, 0x20);\n+  VDUP(vector2, , uint, u, 16, 4, 0x20);\n+  VDUP(vector2, , uint, u, 32, 2, 0x20);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x20);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x20);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x20);\n+\n+#undef MSG\n+#define MSG \"less than 64 bits saturation cumulative_sat (2)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 8, 8, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 16, 4, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 32, 2, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 8, 16, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 16, 8, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 32, 4, expected_csat_lt_64_2, MSG);\n+\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_lt_64_2, MSG);\n+}"}, {"sha": "04df5feac27f960e31bd3fd5a45b9e69830f39f8", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqsub.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqsub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f59574a1c443ab5a1d06da4b09ed6d4677a7158a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqsub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvqsub.c?ref=f59574a1c443ab5a1d06da4b09ed6d4677a7158a", "patch": "@@ -0,0 +1,278 @@\n+#define INSN_NAME vqsub\n+#define TEST_MSG \"VQSUB/VQSUBQ\"\n+\n+/* Extra tests for special cases:\n+   - some requiring intermediate types larger than 64 bits to\n+   compute saturation flag.\n+   - corner case saturations with types smaller than 64 bits.\n+*/\n+void vqsub_extras(void);\n+#define EXTRA_TESTS vqsub_extras\n+\n+#include \"binary_sat_op.inc\"\n+\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xdf, 0xe0, 0xe1, 0xe2,\n+\t\t\t\t       0xe3, 0xe4, 0xe5, 0xe6 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xffce, 0xffcf,\n+\t\t\t\t\t0xffd0, 0xffd1 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xffffffbd, 0xffffffbe };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffffac };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x9b, 0x9c, 0x9d, 0x9e,\n+\t\t\t\t\t0x9f, 0xa0, 0xa1, 0xa2 };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff8a, 0xff8b,\n+\t\t\t\t\t 0xff8c, 0xff8d };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffff79, 0xffffff7a };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffff68 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0xdf, 0xe0, 0xe1, 0xe2,\n+\t\t\t\t\t0xe3, 0xe4, 0xe5, 0xe6,\n+\t\t\t\t\t0xe7, 0xe8, 0xe9, 0xea,\n+\t\t\t\t\t0xeb, 0xec, 0xed, 0xee };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xffce, 0xffcf, 0xffd0, 0xffd1,\n+\t\t\t\t\t0xffd2, 0xffd3, 0xffd4, 0xffd5 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffbd, 0xffffffbe,\n+\t\t\t\t\t0xffffffbf, 0xffffffc0 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffac,\n+\t\t\t\t\t0xffffffffffffffad };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x9b, 0x9c, 0x9d, 0x9e,\n+\t\t\t\t\t 0x9f, 0xa0, 0xa1, 0xa2,\n+\t\t\t\t\t 0xa3, 0xa4, 0xa5, 0xa6,\n+\t\t\t\t\t 0xa7, 0xa8, 0xa9, 0xaa };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xff8a, 0xff8b, 0xff8c, 0xff8d,\n+\t\t\t\t\t 0xff8e, 0xff8f, 0xff90, 0xff91 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffff79, 0xffffff7a,\n+\t\t\t\t\t 0xffffff7b, 0xffffff7c };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffff68,\n+\t\t\t\t\t 0xffffffffffffff69 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,\n+\t\t\t\t\t 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,\n+\t\t\t\t\t   0x33333333, 0x33333333 };\n+\n+/* Expected values of cumulative saturation flag.  */\n+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,8,16) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,8,16) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 0;\n+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 0;\n+\n+/* 64-bits types, with 0 as second input.  */\n+VECT_VAR_DECL(expected_64,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected_64,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected_64,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t   0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected_64,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t    0xfffffffffffffff1 };\n+int VECT_VAR(expected_cumulative_sat_64,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,uint,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat_64,uint,64,2) = 0;\n+\n+/* 64-bits types, other cases.  */\n+VECT_VAR_DECL(expected_64_2,int,64,1) [] = { 0xffffffffffffffac };\n+VECT_VAR_DECL(expected_64_2,uint,64,1) [] = { 0xffffffffffffff68 };\n+VECT_VAR_DECL(expected_64_2,int,64,2) [] = { 0xffffffffffffffac,\n+\t\t\t\t\t     0xffffffffffffffad };\n+VECT_VAR_DECL(expected_64_2,uint,64,2) [] = { 0xffffffffffffff68,\n+\t\t\t\t\t      0xffffffffffffff69 };\n+int VECT_VAR(expected_cumulative_sat_64_2,int,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64_2,uint,64,1) = 0;\n+int VECT_VAR(expected_cumulative_sat_64_2,int,64,2) = 0;\n+int VECT_VAR(expected_cumulative_sat_64_2,uint,64,2) = 0;\n+\n+/* 64-bits types, all causing cumulative saturation.  */\n+VECT_VAR_DECL(expected_64_3,int,64,1) [] = { 0x8000000000000000 };\n+VECT_VAR_DECL(expected_64_3,uint,64,1) [] = { 0x0 };\n+VECT_VAR_DECL(expected_64_3,int,64,2) [] = { 0x7fffffffffffffff,\n+\t\t\t\t\t     0x7fffffffffffffff };\n+VECT_VAR_DECL(expected_64_3,uint,64,2) [] = { 0x0, 0x0 };\n+int VECT_VAR(expected_cumulative_sat_64_3,int,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,uint,64,1) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,int,64,2) = 1;\n+int VECT_VAR(expected_cumulative_sat_64_3,uint,64,2) = 1;\n+\n+/* smaller types, corner cases causing cumulative saturation. (1)  */\n+VECT_VAR_DECL(expected_lt_64_1,int,8,8) [] = { 0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t       0x80, 0x80, 0x80, 0x80 };\n+VECT_VAR_DECL(expected_lt_64_1,int,16,4) [] = { 0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,32,2) [] = { 0x80000000, 0x80000000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80,\n+\t\t\t\t\t\t0x80, 0x80, 0x80, 0x80 };\n+VECT_VAR_DECL(expected_lt_64_1,int,16,8) [] = { 0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000,\n+\t\t\t\t\t\t0x8000, 0x8000 };\n+VECT_VAR_DECL(expected_lt_64_1,int,32,4) [] = { 0x80000000, 0x80000000,\n+\t\t\t\t\t\t0x80000000, 0x80000000 };\n+int VECT_VAR(expected_csat_lt_64_1,int,8,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,16,4) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,32,2) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,8,16) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,16,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_1,int,32,4) = 1;\n+\n+/* smaller types, corner cases causing cumulative saturation. (2)  */\n+VECT_VAR_DECL(expected_lt_64_2,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_lt_64_2,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_lt_64_2,uint,32,2) [] = { 0x0, 0x0 };\n+VECT_VAR_DECL(expected_lt_64_2,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_lt_64_2,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_lt_64_2,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+int VECT_VAR(expected_csat_lt_64_2,uint,8,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,16,4) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,32,2) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,8,16) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,16,8) = 1;\n+int VECT_VAR(expected_csat_lt_64_2,uint,32,4) = 1;\n+\n+void vqsub_extras(void)\n+{\n+  DECL_VARIABLE_ALL_VARIANTS(vector1);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+\n+  /* Initialize input \"vector1\" from \"buffer\".  */\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector1, buffer);\n+\n+  /* Use a second vector full of 0.  */\n+  VDUP(vector2, , int, s, 64, 1, 0x0);\n+  VDUP(vector2, , uint, u, 64, 1, 0x0);\n+  VDUP(vector2, q, int, s, 64, 2, 0x0);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x0);\n+\n+#define MSG \"64 bits saturation when adding zero\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64, MSG);\n+\n+  /* Another set of tests with non-zero values.  */\n+  VDUP(vector2, , int, s, 64, 1, 0x44);\n+  VDUP(vector2, , uint, u, 64, 1, 0x88);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+\n+#undef MSG\n+#define MSG \"64 bits saturation cumulative_sat (2)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64_2, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64_2, MSG);\n+\n+  /* Another set of tests, with input values chosen to set\n+     cumulative_sat in all cases.  */\n+  VDUP(vector2, , int, s, 64, 1, 0x7fffffffffffffffLL);\n+  VDUP(vector2, , uint, u, 64, 1, 0xffffffffffffffffULL);\n+  /* To check positive saturation, we need to write a positive value\n+     in vector1.  */\n+  VDUP(vector1, q, int, s, 64, 2, 0x3fffffffffffffffLL);\n+  VDUP(vector2, q, int, s, 64, 2, 0x8000000000000000LL);\n+  VDUP(vector2, q, uint, u, 64, 2, 0xffffffffffffffffULL);\n+\n+#undef MSG\n+#define MSG \"64 bits saturation cumulative_sat (3)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 64, 1, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 64, 1, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 64, 2, expected_cumulative_sat_64_3, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat_64_3, MSG);\n+\n+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64_3, MSG);\n+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_64_3, MSG);\n+\n+  /* To improve coverage, check saturation with less than 64 bits\n+     too.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x7F);\n+  VDUP(vector2, , int, s, 16, 4, 0x7FFF);\n+  VDUP(vector2, , int, s, 32, 2, 0x7FFFFFFF);\n+  VDUP(vector2, q, int, s, 8, 16, 0x7F);\n+  VDUP(vector2, q, int, s, 16, 8, 0x7FFF);\n+  VDUP(vector2, q, int, s, 32, 4, 0x7FFFFFFF);\n+\n+#undef MSG\n+#define MSG \"less than 64 bits saturation cumulative_sat (1)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 8, 8, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 16, 4, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , int, s, 32, 2, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 8, 16, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 16, 8, expected_csat_lt_64_1, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, int, s, 32, 4, expected_csat_lt_64_1, MSG);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_lt_64_1, MSG);\n+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_lt_64_1, MSG);\n+\n+  /* Another set of tests with vector1 values smaller than\n+     vector2.  */\n+  VDUP(vector1, , uint, u, 8, 8, 0x10);\n+  VDUP(vector1, , uint, u, 16, 4, 0x10);\n+  VDUP(vector1, , uint, u, 32, 2, 0x10);\n+  VDUP(vector1, q, uint, u, 8, 16, 0x10);\n+  VDUP(vector1, q, uint, u, 16, 8, 0x10);\n+  VDUP(vector1, q, uint, u, 32, 4, 0x10);\n+\n+  VDUP(vector2, , uint, u, 8, 8, 0x20);\n+  VDUP(vector2, , uint, u, 16, 4, 0x20);\n+  VDUP(vector2, , uint, u, 32, 2, 0x20);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x20);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x20);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x20);\n+\n+#undef MSG\n+#define MSG \"less than 64 bits saturation cumulative_sat (2)\"\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 8, 8, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 16, 4, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, , uint, u, 32, 2, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 8, 16, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 16, 8, expected_csat_lt_64_2, MSG);\n+  TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 32, 4, expected_csat_lt_64_2, MSG);\n+\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_lt_64_2, MSG);\n+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_lt_64_2, MSG);\n+}"}]}