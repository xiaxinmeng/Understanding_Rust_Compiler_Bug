{"sha": "9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5N2ZmNjE4M2RkNzVlOGQwY2QyODMxZTg3NjQ2ZjAxZDNiNDE3MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-08-21T12:36:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-08-21T12:36:19Z"}, "message": "tree-pass.h (pass_ipa_cdtor_merge): New function.\n\n\n\t* tree-pass.h (pass_ipa_cdtor_merge): New function.\n\t* cgraphunit.c (static_ctors, static_dtors): Move to ipa.c; make\n\theap allocated.\n\t(record_cdtor_fn): Move to ipa.c; do not test for\n\thave_ctors_dtors.\n\t(build_cdtor): Move to ipa.c; add code avoiding construction\n\twhen target have ctors/dtors and there is only one ctor/dtor at given\n\tpriority.\n\t(compare_ctor, compare_dtor): Move to ipa.c; use DECL_UID to stabilize sort;\n\treverse order of constructors.\n\t(cgraph_build_cdtor_fns):Move to ipa.c; rename to build_cdtor_fns.\n\t(cgraph_finalize_function): Do not call record_cdtor_fn.\n\t(cgraph_finalize_compilation_unit): Do not call cgraph_build_cdtor_fns.\n\t(cgraph_build_static_cdtor): Move to ipa.c.\n\t* ipa.c: Include target.h and tree-iterator.h.\n\t(cgraph_build_static_cdtor, static_ctors, static_dtors,\n\trecord_cdtor_fn, build_cdtor, compare_ctor, compare_dtor,\n\tbuild_cdtor_fns, ipa_cdtor_merge, gate_ipa_cdtor_merge,\n\tpass_ipa_cdtor_merge): New.\n\t* passes.c (init_optimization_passes): Enqueue pass_ipa_cdtor_merge.\n\t* ipa-prop.c (update_indirect_edges_after_inlining): Avoid out of bounds access.\n\nFrom-SVN: r163443", "tree": {"sha": "a5bb59f19d8d091599bf4239efb438a415ce4c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5bb59f19d8d091599bf4239efb438a415ce4c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/comments", "author": null, "committer": null, "parents": [{"sha": "000eef232bb6480f70b68c48c7d689e958ee5059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000eef232bb6480f70b68c48c7d689e958ee5059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/000eef232bb6480f70b68c48c7d689e958ee5059"}], "stats": {"total": 589, "additions": 343, "deletions": 246}, "files": [{"sha": "7b87da391c5501a70f04d940ae78ec8b92305177", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -1,3 +1,27 @@\n+2010-08-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (pass_ipa_cdtor_merge): New function.\n+\t* cgraphunit.c (static_ctors, static_dtors): Move to ipa.c; make\n+\theap allocated.\n+\t(record_cdtor_fn): Move to ipa.c; do not test for\n+\thave_ctors_dtors.\n+\t(build_cdtor): Move to ipa.c; add code avoiding construction\n+\twhen target have ctors/dtors and there is only one ctor/dtor at given\n+\tpriority.\n+\t(compare_ctor, compare_dtor): Move to ipa.c; use DECL_UID to stabilize sort;\n+\treverse order of constructors.\n+\t(cgraph_build_cdtor_fns):Move to ipa.c; rename to build_cdtor_fns.\n+\t(cgraph_finalize_function): Do not call record_cdtor_fn.\n+\t(cgraph_finalize_compilation_unit): Do not call cgraph_build_cdtor_fns.\n+\t(cgraph_build_static_cdtor): Move to ipa.c.\n+\t* ipa.c: Include target.h and tree-iterator.h.\n+\t(cgraph_build_static_cdtor, static_ctors, static_dtors,\n+\trecord_cdtor_fn, build_cdtor, compare_ctor, compare_dtor,\n+\tbuild_cdtor_fns, ipa_cdtor_merge, gate_ipa_cdtor_merge,\n+\tpass_ipa_cdtor_merge): New.\n+\t* passes.c (init_optimization_passes): Enqueue pass_ipa_cdtor_merge.\n+\t* ipa-prop.c (update_indirect_edges_after_inlining): Avoid out of bounds access.\n+\n 2010-08-20  Jan Hubicka  <jh@suse.cz>\n \n \tPR c++/45307"}, {"sha": "024a3bc2eedaf070aaa2d16df33d4f87e114f755", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 242, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -147,174 +147,9 @@ static void cgraph_analyze_function (struct cgraph_node *);\n \n FILE *cgraph_dump_file;\n \n-/* A vector of FUNCTION_DECLs declared as static constructors.  */\n-static GTY (()) VEC(tree, gc) *static_ctors;\n-/* A vector of FUNCTION_DECLs declared as static destructors.  */\n-static GTY (()) VEC(tree, gc) *static_dtors;\n-\n /* Used for vtable lookup in thunk adjusting.  */\n static GTY (()) tree vtable_entry_type;\n \n-/* When target does not have ctors and dtors, we call all constructor\n-   and destructor by special initialization/destruction function\n-   recognized by collect2.\n-\n-   When we are going to build this function, collect all constructors and\n-   destructors and turn them into normal functions.  */\n-\n-static void\n-record_cdtor_fn (tree fndecl)\n-{\n-  struct cgraph_node *node;\n-  if (targetm.have_ctors_dtors\n-      || (!DECL_STATIC_CONSTRUCTOR (fndecl)\n-\t  && !DECL_STATIC_DESTRUCTOR (fndecl)))\n-    return;\n-\n-  if (DECL_STATIC_CONSTRUCTOR (fndecl))\n-    {\n-      VEC_safe_push (tree, gc, static_ctors, fndecl);\n-      DECL_STATIC_CONSTRUCTOR (fndecl) = 0;\n-    }\n-  if (DECL_STATIC_DESTRUCTOR (fndecl))\n-    {\n-      VEC_safe_push (tree, gc, static_dtors, fndecl);\n-      DECL_STATIC_DESTRUCTOR (fndecl) = 0;\n-    }\n-  node = cgraph_node (fndecl);\n-  node->local.disregard_inline_limits = 1;\n-  cgraph_mark_reachable_node (node);\n-}\n-\n-/* Define global constructors/destructor functions for the CDTORS, of\n-   which they are LEN.  The CDTORS are sorted by initialization\n-   priority.  If CTOR_P is true, these are constructors; otherwise,\n-   they are destructors.  */\n-\n-static void\n-build_cdtor (bool ctor_p, tree *cdtors, size_t len)\n-{\n-  size_t i;\n-\n-  i = 0;\n-  while (i < len)\n-    {\n-      tree body;\n-      tree fn;\n-      priority_type priority;\n-\n-      priority = 0;\n-      body = NULL_TREE;\n-      /* Find the next batch of constructors/destructors with the same\n-\t initialization priority.  */\n-      do\n-\t{\n-\t  priority_type p;\n-\t  tree call;\n-\t  fn = cdtors[i];\n-\t  p = ctor_p ? DECL_INIT_PRIORITY (fn) : DECL_FINI_PRIORITY (fn);\n-\t  if (!body)\n-\t    priority = p;\n-\t  else if (p != priority)\n-\t    break;\n-\t  call = build_call_expr (fn, 0);\n-\t  append_to_statement_list (call, &body);\n-\t  ++i;\n-\t}\n-      while (i < len);\n-      gcc_assert (body != NULL_TREE);\n-      /* Generate a function to call all the function of like\n-\t priority.  */\n-      cgraph_build_static_cdtor (ctor_p ? 'I' : 'D', body, priority);\n-    }\n-}\n-\n-/* Comparison function for qsort.  P1 and P2 are actually of type\n-   \"tree *\" and point to static constructors.  DECL_INIT_PRIORITY is\n-   used to determine the sort order.  */\n-\n-static int\n-compare_ctor (const void *p1, const void *p2)\n-{\n-  tree f1;\n-  tree f2;\n-  int priority1;\n-  int priority2;\n-\n-  f1 = *(const tree *)p1;\n-  f2 = *(const tree *)p2;\n-  priority1 = DECL_INIT_PRIORITY (f1);\n-  priority2 = DECL_INIT_PRIORITY (f2);\n-\n-  if (priority1 < priority2)\n-    return -1;\n-  else if (priority1 > priority2)\n-    return 1;\n-  else\n-    /* Ensure a stable sort.  */\n-    return (const tree *)p1 - (const tree *)p2;\n-}\n-\n-/* Comparison function for qsort.  P1 and P2 are actually of type\n-   \"tree *\" and point to static destructors.  DECL_FINI_PRIORITY is\n-   used to determine the sort order.  */\n-\n-static int\n-compare_dtor (const void *p1, const void *p2)\n-{\n-  tree f1;\n-  tree f2;\n-  int priority1;\n-  int priority2;\n-\n-  f1 = *(const tree *)p1;\n-  f2 = *(const tree *)p2;\n-  priority1 = DECL_FINI_PRIORITY (f1);\n-  priority2 = DECL_FINI_PRIORITY (f2);\n-\n-  if (priority1 < priority2)\n-    return -1;\n-  else if (priority1 > priority2)\n-    return 1;\n-  else\n-    /* Ensure a stable sort.  */\n-    return (const tree *)p1 - (const tree *)p2;\n-}\n-\n-/* Generate functions to call static constructors and destructors\n-   for targets that do not support .ctors/.dtors sections.  These\n-   functions have magic names which are detected by collect2.  */\n-\n-static void\n-cgraph_build_cdtor_fns (void)\n-{\n-  if (!VEC_empty (tree, static_ctors))\n-    {\n-      gcc_assert (!targetm.have_ctors_dtors);\n-      qsort (VEC_address (tree, static_ctors),\n-\t     VEC_length (tree, static_ctors),\n-\t     sizeof (tree),\n-\t     compare_ctor);\n-      build_cdtor (/*ctor_p=*/true,\n-\t\t   VEC_address (tree, static_ctors),\n-\t\t   VEC_length (tree, static_ctors));\n-      VEC_truncate (tree, static_ctors, 0);\n-    }\n-\n-  if (!VEC_empty (tree, static_dtors))\n-    {\n-      gcc_assert (!targetm.have_ctors_dtors);\n-      qsort (VEC_address (tree, static_dtors),\n-\t     VEC_length (tree, static_dtors),\n-\t     sizeof (tree),\n-\t     compare_dtor);\n-      build_cdtor (/*ctor_p=*/false,\n-\t\t   VEC_address (tree, static_dtors),\n-\t\t   VEC_length (tree, static_dtors));\n-      VEC_truncate (tree, static_dtors, 0);\n-    }\n-}\n-\n /* Determine if function DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n    configury.  */\n@@ -519,7 +354,6 @@ cgraph_finalize_function (tree decl, bool nested)\n   node->local.finalized = true;\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n   node->finalized_by_frontend = true;\n-  record_cdtor_fn (node->decl);\n \n   if (cgraph_decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n@@ -1155,10 +989,6 @@ cgraph_finalize_compilation_unit (void)\n   /* Emit size functions we didn't inline.  */\n   finalize_size_functions ();\n \n-  /* Call functions declared with the \"constructor\" or \"destructor\"\n-     attribute.  */\n-  cgraph_build_cdtor_fns ();\n-\n   /* Mark alias targets necessary and emit diagnostics.  */\n   finish_aliases_1 ();\n \n@@ -2007,78 +1837,6 @@ cgraph_optimize (void)\n #endif\n }\n \n-\n-/* Generate and emit a static constructor or destructor.  WHICH must\n-   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n-   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n-   initialization priority for this constructor or destructor.  */\n-\n-void\n-cgraph_build_static_cdtor (char which, tree body, int priority)\n-{\n-  static int counter = 0;\n-  char which_buf[16];\n-  tree decl, name, resdecl;\n-\n-  /* The priority is encoded in the constructor or destructor name.\n-     collect2 will sort the names and arrange that they are called at\n-     program startup.  */\n-  sprintf (which_buf, \"%c_%.5d_%d\", which, priority, counter++);\n-  name = get_file_function_name (which_buf);\n-\n-  decl = build_decl (input_location, FUNCTION_DECL, name,\n-\t\t     build_function_type_list (void_type_node, NULL_TREE));\n-  current_function_decl = decl;\n-\n-  resdecl = build_decl (input_location,\n-\t\t\tRESULT_DECL, NULL_TREE, void_type_node);\n-  DECL_ARTIFICIAL (resdecl) = 1;\n-  DECL_RESULT (decl) = resdecl;\n-  DECL_CONTEXT (resdecl) = decl;\n-\n-  allocate_struct_function (decl, false);\n-\n-  TREE_STATIC (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n-  DECL_SAVED_TREE (decl) = body;\n-  if (!targetm.have_ctors_dtors)\n-    {\n-      TREE_PUBLIC (decl) = 1;\n-      DECL_PRESERVE_P (decl) = 1;\n-    }\n-  DECL_UNINLINABLE (decl) = 1;\n-\n-  DECL_INITIAL (decl) = make_node (BLOCK);\n-  TREE_USED (DECL_INITIAL (decl)) = 1;\n-\n-  DECL_SOURCE_LOCATION (decl) = input_location;\n-  cfun->function_end_locus = input_location;\n-\n-  switch (which)\n-    {\n-    case 'I':\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      decl_init_priority_insert (decl, priority);\n-      break;\n-    case 'D':\n-      DECL_STATIC_DESTRUCTOR (decl) = 1;\n-      decl_fini_priority_insert (decl, priority);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  gimplify_function_tree (decl);\n-\n-  cgraph_add_new_function (decl, false);\n-  cgraph_mark_needed_node (cgraph_node (decl));\n-\n-  set_cfun (NULL);\n-  current_function_decl = NULL;\n-}\n-\n void\n init_cgraph (void)\n {"}, {"sha": "99e59b0ed7860eb894a427a0b59ecd84814a814b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -1541,11 +1541,12 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_node *node,\n \t\t\t\t      VEC (cgraph_edge_p, heap) **new_edges)\n {\n-  struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n+  struct ipa_edge_args *top;\n   struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n+  top = IPA_EDGE_REF (cs);\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {"}, {"sha": "e1d2f7eb3f20052d66de0bdf57e17d77f1670aab", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -427,7 +427,7 @@ worse_state (enum pure_const_state_e *state, bool *looping,\n /* Recognize special cases of builtins that are by themself not pure or const\n    but function using them is.  */\n static bool\n-special_builtlin_state (enum pure_const_state_e *state, bool *looping,\n+special_builtin_state (enum pure_const_state_e *state, bool *looping,\n \t\t\ttree callee)\n {\n   if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n@@ -510,7 +510,7 @@ check_call (funct_state local, gimple call, bool ipa)\n       enum pure_const_state_e call_state;\n       bool call_looping;\n \n-      if (special_builtlin_state (&call_state, &call_looping, callee_t))\n+      if (special_builtin_state (&call_state, &call_looping, callee_t))\n \t{\n \t  worse_state (&local->pure_const_state, &local->looping,\n \t\t       call_state, call_looping);\n@@ -1203,7 +1203,7 @@ propagate_pure_const (void)\n \t\t      edge_looping = y_l->looping;\n \t\t    }\n \t\t}\n-\t      else if (special_builtlin_state (&edge_state, &edge_looping,\n+\t      else if (special_builtin_state (&edge_state, &edge_looping,\n \t\t\t\t\t       y->decl))\n \t\t;\n \t      else"}, {"sha": "021398b6748ec52c1be950d5e7a884c88e40af8f", "filename": "gcc/ipa.c", "status": "modified", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -29,6 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"flags.h\"\n #include \"pointer-set.h\"\n+#include \"target.h\"\n+#include \"tree-iterator.h\"\n \n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  */\n@@ -1317,3 +1319,313 @@ struct ipa_opt_pass_d pass_ipa_profile =\n  NULL,\t\t\t                /* function_transform */\n  NULL\t\t\t\t\t/* variable_transform */\n };\n+\n+/* Generate and emit a static constructor or destructor.  WHICH must\n+   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n+   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n+   initialization priority for this constructor or destructor.  */\n+\n+void\n+cgraph_build_static_cdtor (char which, tree body, int priority)\n+{\n+  static int counter = 0;\n+  char which_buf[16];\n+  tree decl, name, resdecl;\n+\n+  /* The priority is encoded in the constructor or destructor name.\n+     collect2 will sort the names and arrange that they are called at\n+     program startup.  */\n+  sprintf (which_buf, \"%c_%.5d_%d\", which, priority, counter++);\n+  name = get_file_function_name (which_buf);\n+\n+  decl = build_decl (input_location, FUNCTION_DECL, name,\n+\t\t     build_function_type_list (void_type_node, NULL_TREE));\n+  current_function_decl = decl;\n+\n+  resdecl = build_decl (input_location,\n+\t\t\tRESULT_DECL, NULL_TREE, void_type_node);\n+  DECL_ARTIFICIAL (resdecl) = 1;\n+  DECL_RESULT (decl) = resdecl;\n+  DECL_CONTEXT (resdecl) = decl;\n+\n+  allocate_struct_function (decl, false);\n+\n+  TREE_STATIC (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n+  DECL_SAVED_TREE (decl) = body;\n+  if (!targetm.have_ctors_dtors)\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      DECL_PRESERVE_P (decl) = 1;\n+    }\n+  DECL_UNINLINABLE (decl) = 1;\n+\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  TREE_USED (DECL_INITIAL (decl)) = 1;\n+\n+  DECL_SOURCE_LOCATION (decl) = input_location;\n+  cfun->function_end_locus = input_location;\n+\n+  switch (which)\n+    {\n+    case 'I':\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      decl_init_priority_insert (decl, priority);\n+      break;\n+    case 'D':\n+      DECL_STATIC_DESTRUCTOR (decl) = 1;\n+      decl_fini_priority_insert (decl, priority);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gimplify_function_tree (decl);\n+\n+  cgraph_add_new_function (decl, false);\n+\n+  set_cfun (NULL);\n+  current_function_decl = NULL;\n+}\n+\n+\n+/* A vector of FUNCTION_DECLs declared as static constructors.  */\n+static VEC(tree, heap) *static_ctors;\n+/* A vector of FUNCTION_DECLs declared as static destructors.  */\n+static VEC(tree, heap) *static_dtors;\n+\n+/* When target does not have ctors and dtors, we call all constructor\n+   and destructor by special initialization/destruction function\n+   recognized by collect2.\n+\n+   When we are going to build this function, collect all constructors and\n+   destructors and turn them into normal functions.  */\n+\n+static void\n+record_cdtor_fn (struct cgraph_node *node)\n+{\n+  if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+    VEC_safe_push (tree, heap, static_ctors, node->decl);\n+  if (DECL_STATIC_DESTRUCTOR (node->decl))\n+    VEC_safe_push (tree, heap, static_dtors, node->decl);\n+  node = cgraph_node (node->decl);\n+  node->local.disregard_inline_limits = 1;\n+}\n+\n+/* Define global constructors/destructor functions for the CDTORS, of\n+   which they are LEN.  The CDTORS are sorted by initialization\n+   priority.  If CTOR_P is true, these are constructors; otherwise,\n+   they are destructors.  */\n+\n+static void\n+build_cdtor (bool ctor_p, tree *cdtors, size_t len)\n+{\n+  size_t i,j;\n+\n+  i = 0;\n+  while (i < len)\n+    {\n+      tree body;\n+      tree fn;\n+      priority_type priority;\n+\n+      priority = 0;\n+      body = NULL_TREE;\n+      j = i;\n+      do\n+\t{\n+\t  priority_type p;\n+\t  fn = cdtors[i];\n+\t  p = ctor_p ? DECL_INIT_PRIORITY (fn) : DECL_FINI_PRIORITY (fn);\n+\t  if (j == i)\n+\t    priority = p;\n+\t  else if (p != priority)\n+\t    break;\n+\t  j++;\n+\t}\n+      while (j < len);\n+\n+      /* When there is only once constructor and target supports them, do nothing.  */\n+      if (j == i + 1\n+\t  && targetm.have_ctors_dtors)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      /* Find the next batch of constructors/destructors with the same\n+\t initialization priority.  */\n+      do\n+\t{\n+\t  priority_type p;\n+\t  tree call;\n+\t  fn = cdtors[i];\n+\t  p = ctor_p ? DECL_INIT_PRIORITY (fn) : DECL_FINI_PRIORITY (fn);\n+\t  if (p != priority)\n+\t    break;\n+\t  call = build_call_expr (fn, 0);\n+\t  if (ctor_p)\n+\t    DECL_STATIC_CONSTRUCTOR (fn) = 0;\n+\t  else\n+\t    DECL_STATIC_DESTRUCTOR (fn) = 0;\n+\t  /* We do not want to optimize away pure/const calls here.\n+\t     When optimizing, these should be already removed, when not\n+\t     optimizing, we want user to be able to breakpoint in them.  */\n+\t  TREE_SIDE_EFFECTS (call) = 1;\n+\t  append_to_statement_list (call, &body);\n+\t  ++i;\n+\t}\n+      while (i < len);\n+      gcc_assert (body != NULL_TREE);\n+      /* Generate a function to call all the function of like\n+\t priority.  */\n+      cgraph_build_static_cdtor (ctor_p ? 'I' : 'D', body, priority);\n+    }\n+}\n+\n+/* Comparison function for qsort.  P1 and P2 are actually of type\n+   \"tree *\" and point to static constructors.  DECL_INIT_PRIORITY is\n+   used to determine the sort order.  */\n+\n+static int\n+compare_ctor (const void *p1, const void *p2)\n+{\n+  tree f1;\n+  tree f2;\n+  int priority1;\n+  int priority2;\n+\n+  f1 = *(const tree *)p1;\n+  f2 = *(const tree *)p2;\n+  priority1 = DECL_INIT_PRIORITY (f1);\n+  priority2 = DECL_INIT_PRIORITY (f2);\n+\n+  if (priority1 < priority2)\n+    return -1;\n+  else if (priority1 > priority2)\n+    return 1;\n+  else\n+    /* Ensure a stable sort.  Constructors are executed in backwarding\n+       order to make LTO initialize braries first.  */\n+    return DECL_UID (f2) - DECL_UID (f1);\n+}\n+\n+/* Comparison function for qsort.  P1 and P2 are actually of type\n+   \"tree *\" and point to static destructors.  DECL_FINI_PRIORITY is\n+   used to determine the sort order.  */\n+\n+static int\n+compare_dtor (const void *p1, const void *p2)\n+{\n+  tree f1;\n+  tree f2;\n+  int priority1;\n+  int priority2;\n+\n+  f1 = *(const tree *)p1;\n+  f2 = *(const tree *)p2;\n+  priority1 = DECL_FINI_PRIORITY (f1);\n+  priority2 = DECL_FINI_PRIORITY (f2);\n+\n+  if (priority1 < priority2)\n+    return -1;\n+  else if (priority1 > priority2)\n+    return 1;\n+  else\n+    /* Ensure a stable sort.  */\n+    return DECL_UID (f1) - DECL_UID (f2);\n+}\n+\n+/* Generate functions to call static constructors and destructors\n+   for targets that do not support .ctors/.dtors sections.  These\n+   functions have magic names which are detected by collect2.  */\n+\n+static void\n+build_cdtor_fns (void)\n+{\n+  if (!VEC_empty (tree, static_ctors))\n+    {\n+      gcc_assert (!targetm.have_ctors_dtors || in_lto_p);\n+      qsort (VEC_address (tree, static_ctors),\n+\t     VEC_length (tree, static_ctors),\n+\t     sizeof (tree),\n+\t     compare_ctor);\n+      build_cdtor (/*ctor_p=*/true,\n+\t\t   VEC_address (tree, static_ctors),\n+\t\t   VEC_length (tree, static_ctors));\n+      VEC_truncate (tree, static_ctors, 0);\n+    }\n+\n+  if (!VEC_empty (tree, static_dtors))\n+    {\n+      gcc_assert (!targetm.have_ctors_dtors || in_lto_p);\n+      qsort (VEC_address (tree, static_dtors),\n+\t     VEC_length (tree, static_dtors),\n+\t     sizeof (tree),\n+\t     compare_dtor);\n+      build_cdtor (/*ctor_p=*/false,\n+\t\t   VEC_address (tree, static_dtors),\n+\t\t   VEC_length (tree, static_dtors));\n+      VEC_truncate (tree, static_dtors, 0);\n+    }\n+}\n+\n+/* Look for constructors and destructors and produce function calling them.\n+   This is needed for targets not supporting ctors or dtors, but we perform the\n+   transformation also at linktime to merge possibly numberous\n+   constructors/destructors into single function to improve code locality and\n+   reduce size.  */\n+\n+static unsigned int\n+ipa_cdtor_merge (void)\n+{\n+  struct cgraph_node *node;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed\n+\t&& (DECL_STATIC_CONSTRUCTOR (node->decl)\n+\t    || DECL_STATIC_DESTRUCTOR (node->decl)))\n+       record_cdtor_fn (node);\n+  build_cdtor_fns ();\n+  VEC_free (tree, heap, static_ctors);\n+  VEC_free (tree, heap, static_dtors);\n+  return 0;\n+}\n+\n+/* Perform the pass when we have no ctors/dtors support\n+   or at LTO time to merge multiple constructors into single\n+   function.  */\n+\n+static bool\n+gate_ipa_cdtor_merge (void)\n+{\n+  return !targetm.have_ctors_dtors || (optimize && in_lto_p);\n+}\n+\n+struct ipa_opt_pass_d pass_ipa_cdtor_merge =\n+{\n+ {\n+  IPA_PASS,\n+  \"cdtor\",\t\t\t\t/* name */\n+  gate_ipa_cdtor_merge,\t\t\t/* gate */\n+  ipa_cdtor_merge,\t\t        /* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_CGRAPHOPT,\t\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ },\n+ NULL,\t\t\t\t        /* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* write_optimization_summary */\n+ NULL,\t\t\t\t\t/* read_optimization_summary */\n+ NULL,\t\t\t\t\t/* stmt_fixup */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n+};"}, {"sha": "4823c6397c27ef59ee8f1ab27175fd57cf07095c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -811,6 +811,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_ipa_whole_program_visibility);\n   NEXT_PASS (pass_ipa_profile);\n   NEXT_PASS (pass_ipa_cp);\n+  NEXT_PASS (pass_ipa_cdtor_merge);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n   NEXT_PASS (pass_ipa_reference);"}, {"sha": "0dd6dd19a63a8e82903fc5a4b4d7c9378a9218e1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e97ff6183dd75e8d0cd2831e87646f01d3b4171/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=9e97ff6183dd75e8d0cd2831e87646f01d3b4171", "patch": "@@ -468,6 +468,7 @@ extern struct simple_ipa_opt_pass pass_ipa_struct_reorg;\n extern struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup;\n extern struct ipa_opt_pass_d pass_ipa_lto_finish_out;\n extern struct ipa_opt_pass_d pass_ipa_profile;\n+extern struct ipa_opt_pass_d pass_ipa_cdtor_merge;\n \n extern struct gimple_opt_pass pass_all_optimizations;\n extern struct gimple_opt_pass pass_cleanup_cfg_post_optimizing;"}]}