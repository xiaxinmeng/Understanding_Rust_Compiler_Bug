{"sha": "a37739c10ee16f9972fd059486971b572a67b545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3NzM5YzEwZWUxNmY5OTcyZmQwNTk0ODY5NzFiNTcyYTY3YjU0NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-16T23:26:21Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-16T23:26:21Z"}, "message": "* expmed.c, ra-colorize.c: Fix comment typos.\n\nFrom-SVN: r90771", "tree": {"sha": "3debab0fef36871a46e30a7f10f099287d239727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3debab0fef36871a46e30a7f10f099287d239727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a37739c10ee16f9972fd059486971b572a67b545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37739c10ee16f9972fd059486971b572a67b545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37739c10ee16f9972fd059486971b572a67b545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37739c10ee16f9972fd059486971b572a67b545/comments", "author": null, "committer": null, "parents": [{"sha": "d3f2f8aec2d6873c7ba01bc0e0b6143af1a3702a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f2f8aec2d6873c7ba01bc0e0b6143af1a3702a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f2f8aec2d6873c7ba01bc0e0b6143af1a3702a"}], "stats": {"total": 8, "additions": 6, "deletions": 2}, "files": [{"sha": "da8619d6bb09f5d12508516eabb0471769281166", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37739c10ee16f9972fd059486971b572a67b545/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37739c10ee16f9972fd059486971b572a67b545/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a37739c10ee16f9972fd059486971b572a67b545", "patch": "@@ -1,3 +1,7 @@\n+2004-11-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expmed.c, ra-colorize.c: Fix comment typos.\n+\n 2004-11-16  Daniel Jacobowitz  <dan@codesourcery.com>\n             Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "033d94952be8468a74cc3361380e2d5e052857d9", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37739c10ee16f9972fd059486971b572a67b545/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37739c10ee16f9972fd059486971b572a67b545/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a37739c10ee16f9972fd059486971b572a67b545", "patch": "@@ -2555,7 +2555,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  /* If the target has a cheap shift-and-add instruction use\n \t     that in preference to a shift insn followed by an add insn.\n \t     Assume that the shift-and-add is \"atomic\" with a latency\n-\t     equal to it's cost, otherwise assume that on superscalar\n+\t     equal to its cost, otherwise assume that on superscalar\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n \t  op_cost = add_cost[mode] + shift_cost[mode][m];"}, {"sha": "08bd960d24c6bdce0e5b9b62d9c9549443be2cf2", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37739c10ee16f9972fd059486971b572a67b545/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37739c10ee16f9972fd059486971b572a67b545/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=a37739c10ee16f9972fd059486971b572a67b545", "patch": "@@ -1323,7 +1323,7 @@ colorize_one_web (struct web *web, int hard)\n \t usable_regs of this web (which is probably larger than that of\n \t the preferred or alternate class).  All searches first try to\n \t find a non-call-clobbered hard-reg.\n-         XXX this should be more finegraned... First look into preferred\n+         XXX this should be more fine grained... First look into preferred\n          non-callclobbered hardregs, then _if_ the web crosses calls, in\n          alternate non-cc hardregs, and only _then_ also in preferred cc\n          hardregs (and alternate ones).  Currently we don't track the number"}]}