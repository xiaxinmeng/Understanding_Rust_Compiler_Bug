{"sha": "00f93defed4254cb9303f0a085f0c5b22d164283", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmOTNkZWZlZDQyNTRjYjkzMDNmMGEwODVmMGM1YjIyZDE2NDI4Mw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-05-24T14:46:54Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-05-24T14:46:54Z"}, "message": "expr.c (quick_stack): Change type to a VEC.\n\n\t* expr.c (quick_stack): Change type to a VEC.  Update comment.\n\t(tree_list_free_list): Delete.\n\t(flush_quick_stack): Update for quick_stack type change.\n\t(push_value): Likewise.\n\t(pop_value): Likewise.\n\nFrom-SVN: r159782", "tree": {"sha": "9134fd216e7da2fde6943f343736f7193b111a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9134fd216e7da2fde6943f343736f7193b111a22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f93defed4254cb9303f0a085f0c5b22d164283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f93defed4254cb9303f0a085f0c5b22d164283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f93defed4254cb9303f0a085f0c5b22d164283", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f93defed4254cb9303f0a085f0c5b22d164283/comments", "author": null, "committer": null, "parents": [{"sha": "1db0429a13b229a2a2ad43ca895786871f0b4834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db0429a13b229a2a2ad43ca895786871f0b4834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db0429a13b229a2a2ad43ca895786871f0b4834"}], "stats": {"total": 71, "additions": 26, "deletions": 45}, "files": [{"sha": "b0382bb87316d34bc36d1760dcbe7a7026dc27a9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f93defed4254cb9303f0a085f0c5b22d164283/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f93defed4254cb9303f0a085f0c5b22d164283/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=00f93defed4254cb9303f0a085f0c5b22d164283", "patch": "@@ -1,3 +1,11 @@\n+2010-05-24  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* expr.c (quick_stack): Change type to a VEC.  Update comment.\n+\t(tree_list_free_list): Delete.\n+\t(flush_quick_stack): Update for quick_stack type change.\n+\t(push_value): Likewise.\n+\t(pop_value): Likewise.\n+\n 2010-05-23  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* java-gimplify.c: Do not include tm.h, toplev.h."}, {"sha": "0f3cf1aef4ef4094f256c4eadb090ecbe03ee90e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f93defed4254cb9303f0a085f0c5b22d164283/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f93defed4254cb9303f0a085f0c5b22d164283/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=00f93defed4254cb9303f0a085f0c5b22d164283", "patch": "@@ -90,8 +90,8 @@ tree dtable_ident = NULL_TREE;\n int always_initialize_class_p = 0;\n \n /* We store the stack state in two places:\n-   Within a basic block, we use the quick_stack, which is a\n-   pushdown list (TREE_LISTs) of expression nodes.\n+   Within a basic block, we use the quick_stack, which is a VEC of expression\n+   nodes.\n    This is the top part of the stack;  below that we use find_stack_slot.\n    At the end of a basic block, the quick_stack must be flushed\n    to the stack slot array (as handled by find_stack_slot).\n@@ -116,10 +116,7 @@ int always_initialize_class_p = 0;\n    So dup cannot just add an extra element to the quick_stack, but iadd can.\n */\n \n-static GTY(()) tree quick_stack;\n-\n-/* A free-list of unused permanent TREE_LIST nodes.  */\n-static GTY((deletable)) tree tree_list_free_list;\n+static GTY(()) VEC(tree,gc) *quick_stack;\n \n /* The physical memory page size used in this computer.  See\n    build_field_ref().  */\n@@ -215,33 +212,24 @@ static void\n flush_quick_stack (void)\n {\n   int stack_index = stack_pointer;\n-  tree prev, cur, next;\n+  unsigned ix;\n+  tree t;\n \n-  /* First reverse the quick_stack, and count the number of slots it has. */\n-  for (cur = quick_stack, prev = NULL_TREE; cur != NULL_TREE; cur = next)\n-    {\n-      next = TREE_CHAIN (cur);\n-      TREE_CHAIN (cur) = prev;\n-      prev = cur;\n-      stack_index -= 1 + TYPE_IS_WIDE (TREE_TYPE (TREE_VALUE (cur)));\n-    }\n-  quick_stack = prev;\n+  /* Count the number of slots the quick stack is holding.  */\n+  for (ix = 0; VEC_iterate(tree, quick_stack, ix, t); ix++)\n+    stack_index -= 1 + TYPE_IS_WIDE (TREE_TYPE (t));\n \n-  while (quick_stack != NULL_TREE)\n+  for (ix = 0; VEC_iterate(tree, quick_stack, ix, t); ix++)\n     {\n-      tree decl;\n-      tree node = quick_stack, type;\n-      quick_stack = TREE_CHAIN (node);\n-      TREE_CHAIN (node) = tree_list_free_list;\n-      tree_list_free_list = node;\n-      node = TREE_VALUE (node);\n-      type = TREE_TYPE (node);\n+      tree decl, type = TREE_TYPE (t);\n \n       decl = find_stack_slot (stack_index, type);\n-      if (decl != node)\n-\tjava_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (node), decl, node));\n+      if (decl != t)\n+\tjava_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (t), decl, t));\n       stack_index += 1 + TYPE_IS_WIDE (type);\n     }\n+\n+  VEC_truncate (tree, quick_stack, 0);\n }\n \n /* Push TYPE on the type stack.\n@@ -282,16 +270,8 @@ push_value (tree value)\n       value = convert (type, value);\n     }\n   push_type (type);\n-  if (tree_list_free_list == NULL_TREE)\n-    quick_stack = tree_cons (NULL_TREE, value, quick_stack);\n-  else\n-    {\n-      tree node = tree_list_free_list;\n-      tree_list_free_list = TREE_CHAIN (tree_list_free_list);\n-      TREE_VALUE (node) = value;\n-      TREE_CHAIN (node) = quick_stack;\n-      quick_stack = node;\n-    }\n+  VEC_safe_push (tree, gc, quick_stack, value);\n+\n   /* If the value has a side effect, then we need to evaluate it\n      whether or not the result is used.  If the value ends up on the\n      quick stack and is then popped, this won't happen -- so we flush\n@@ -604,15 +584,8 @@ static tree\n pop_value (tree type)\n {\n   type = pop_type (type);\n-  if (quick_stack)\n-    {\n-      tree node = quick_stack;\n-      quick_stack = TREE_CHAIN (quick_stack);\n-      TREE_CHAIN (node) = tree_list_free_list;\n-      tree_list_free_list = node;\n-      node = TREE_VALUE (node);\n-      return node;\n-    }\n+  if (VEC_length (tree, quick_stack) != 0)\n+    return VEC_pop (tree, quick_stack);\n   else\n     return find_stack_slot (stack_pointer, promote_type (type));\n }"}]}