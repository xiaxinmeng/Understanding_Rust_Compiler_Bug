{"sha": "fce547639dcebba692c4c864287cb371360a6661", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNlNTQ3NjM5ZGNlYmJhNjkyYzRjODY0Mjg3Y2IzNzEzNjBhNjY2MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:27:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:27:23Z"}, "message": "[multiple changes]\n\n2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n\n\t* lib-writ.adb (Write_Unit_Information): Fix case where U =\n\tNo_Unit.\n\n2014-07-31  Claire Dross  <dross@adacore.com>\n\n\t* exp_util.adb, exp_util.ads\n\t(Get_First_Parent_With_External_Axiomatization_For_Entity):\n\tNew routine to find the first parent of an entity with\n\ta pragma Annotate (GNATprove, External_Axiomatization).\n\t(Has_Annotate_Pragma_For_External_Axiomatization): New function\n\tto check if a package has a pragma Annotate (GNATprove,\n\tExternal_Axiomatization).\n\t* einfo.ads, einfo.adb (Is_Generic_Actual_Subprogram): New\n\tflag on the entity for the declaration created for a formal\n\tsubprogram in an instance. This is a renaming declaration,\n\tor in GNATprove_Mode the declaration of an expression function\n\tthat captures the axiomatization of the actual.\n\t* sem_ch6.adb (Analyze_Expression_Function): For a\n\tGeneric_Actual_Subprogram, place body immediately after the\n\tdeclaration because it may be used in a subsequent declaration\n\tin the instance.\n\t* sem_ch12.adb (Build_Wrapper): Add code to handle instances where\n\tthe actual is a function, not an operator. Handle functions with\n\tone and two parameters and binary and unary operators.\n\n2014-07-31  Pascal Obry  <obry@adacore.com>\n\n\t* cstreams.c (__gnat_is_regular_file_fd): Removed.\n\t* adaint.c (__gnat_is_regular_file_fd): Added.\n\nFrom-SVN: r213364", "tree": {"sha": "7c587eb438e9a664240705f87f8dde3890f47eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c587eb438e9a664240705f87f8dde3890f47eb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fce547639dcebba692c4c864287cb371360a6661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce547639dcebba692c4c864287cb371360a6661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce547639dcebba692c4c864287cb371360a6661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce547639dcebba692c4c864287cb371360a6661/comments", "author": null, "committer": null, "parents": [{"sha": "7f3d273a22571f6dd578c079dbdba9340790c8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3d273a22571f6dd578c079dbdba9340790c8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3d273a22571f6dd578c079dbdba9340790c8c2"}], "stats": {"total": 495, "additions": 396, "deletions": 99}, "files": [{"sha": "08ec13efe68812ca15f1c94ec767b943b7b32f15", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -1,3 +1,35 @@\n+2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* lib-writ.adb (Write_Unit_Information): Fix case where U =\n+\tNo_Unit.\n+\n+2014-07-31  Claire Dross  <dross@adacore.com>\n+\n+\t* exp_util.adb, exp_util.ads\n+\t(Get_First_Parent_With_External_Axiomatization_For_Entity):\n+\tNew routine to find the first parent of an entity with\n+\ta pragma Annotate (GNATprove, External_Axiomatization).\n+\t(Has_Annotate_Pragma_For_External_Axiomatization): New function\n+\tto check if a package has a pragma Annotate (GNATprove,\n+\tExternal_Axiomatization).\n+\t* einfo.ads, einfo.adb (Is_Generic_Actual_Subprogram): New\n+\tflag on the entity for the declaration created for a formal\n+\tsubprogram in an instance. This is a renaming declaration,\n+\tor in GNATprove_Mode the declaration of an expression function\n+\tthat captures the axiomatization of the actual.\n+\t* sem_ch6.adb (Analyze_Expression_Function): For a\n+\tGeneric_Actual_Subprogram, place body immediately after the\n+\tdeclaration because it may be used in a subsequent declaration\n+\tin the instance.\n+\t* sem_ch12.adb (Build_Wrapper): Add code to handle instances where\n+\tthe actual is a function, not an operator. Handle functions with\n+\tone and two parameters and binary and unary operators.\n+\n+2014-07-31  Pascal Obry  <obry@adacore.com>\n+\n+\t* cstreams.c (__gnat_is_regular_file_fd): Removed.\n+\t* adaint.c (__gnat_is_regular_file_fd): Added.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_strm.adb: Minor reformatting."}, {"sha": "5acb3210947a5ea4197d2fc438664df4057ae78b", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -2023,6 +2023,16 @@ __gnat_is_regular_file (char *name)\n    return __gnat_is_regular_file_attr (name, &attr);\n }\n \n+int\n+__gnat_is_regular_file_fd (int fd)\n+{\n+  int ret;\n+  GNAT_STRUCT_STAT statbuf;\n+\n+  ret = GNAT_FSTAT (fd, &statbuf);\n+  return (!ret && S_ISREG (statbuf.st_mode));\n+}\n+\n int\n __gnat_is_directory_attr (char* name, struct file_attributes* attr)\n {"}, {"sha": "5d5bc8d7882f36f3b7ac489ef15444761d98e2a4", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *              Auxiliary C functions for Interfaces.C.Streams              *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -106,16 +106,6 @@ __gnat_fileno (FILE *stream)\n    return (fileno (stream));\n }\n \n-int\n-__gnat_is_regular_file_fd (int fd)\n-{\n-  int ret;\n-  GNAT_STRUCT_STAT statbuf;\n-\n-  ret = GNAT_FSTAT (fd, &statbuf);\n-  return (!ret && S_ISREG (statbuf.st_mode));\n-}\n-\n /* on some systems, the constants for seek are not defined, if so, then\n    provide the conventional definitions */\n "}, {"sha": "d4929c3904fa2a11eba6c2d06b07e3763fab1ace", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -569,10 +569,11 @@ package body Einfo is\n    --    (SSO_Set_Low_By_Default)        Flag272\n    --    (SSO_Set_Low_By_Default)        Flag273\n \n+   --    Is_Generic_Actual_Subprogram    Flag274\n+\n    --    (unused)                        Flag2\n    --    (unused)                        Flag3\n \n-   --    (unused)                        Flag274\n    --    (unused)                        Flag275\n    --    (unused)                        Flag276\n    --    (unused)                        Flag277\n@@ -2053,6 +2054,12 @@ package body Einfo is\n       return Flag4 (Id);\n    end Is_Frozen;\n \n+   function Is_Generic_Actual_Subprogram (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      return Flag274 (Id);\n+   end Is_Generic_Actual_Subprogram;\n+\n    function Is_Generic_Actual_Type (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4840,6 +4847,12 @@ package body Einfo is\n       Set_Flag4 (Id, V);\n    end Set_Is_Frozen;\n \n+   procedure Set_Is_Generic_Actual_Subprogram (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      Set_Flag274 (Id, V);\n+   end Set_Is_Generic_Actual_Subprogram;\n+\n    procedure Set_Is_Generic_Actual_Type (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -8391,6 +8404,7 @@ package body Einfo is\n       W (\"Is_For_Access_Subtype\",           Flag118 (Id));\n       W (\"Is_Formal_Subprogram\",            Flag111 (Id));\n       W (\"Is_Frozen\",                       Flag4   (Id));\n+      W (\"Is_Generic_Actual_Subprogram\",    Flag274 (Id));\n       W (\"Is_Generic_Actual_Type\",          Flag94  (Id));\n       W (\"Is_Generic_Instance\",             Flag130 (Id));\n       W (\"Is_Generic_Type\",                 Flag13  (Id));"}, {"sha": "e71b57606acf91e11dde2c54514799cdb56a3ca7", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -2388,6 +2388,17 @@ package Einfo is\n --       Defined in all type and subtype entities. Set if type or subtype has\n --       been frozen.\n \n+--    Is_Generic_Actual_Subprogram (Flag274)\n+--       Defined on functions and procedures. Set on the entity of the renaming\n+--       declaration created within an instance for an actual subprogram.\n+--       Used to generate constraint checks on calls to these subprograms, even\n+--       within an instance of a predefined run-time unit, in which checks\n+--       are otherwise suppressed.\n+--\n+--       The flag is also set on the entity of the expression function created\n+--       within an instance, for a function that has external axiomatization,\n+--       for use in GNATprove mode.\n+\n --    Is_Generic_Actual_Type (Flag94)\n --       Defined in all type and subtype entities. Set in the subtype\n --       declaration that renames the generic formal as a subtype of the\n@@ -5674,6 +5685,7 @@ package Einfo is\n    --    Is_Discrim_SO_Function              (Flag176)\n    --    Is_Discriminant_Check_Function      (Flag264)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Inlined_Always                   (Flag1)    (non-generic case only)\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n@@ -5968,6 +5980,7 @@ package Einfo is\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Inlined_Always                   (Flag1)    (non-generic case only)\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n+   --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Interrupt_Handler                (Flag89)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n@@ -6905,6 +6918,7 @@ package Einfo is\n    function Is_Formal                           (Id : E) return B;\n    function Is_Formal_Object                    (Id : E) return B;\n    function Is_Formal_Subprogram                (Id : E) return B;\n+   function Is_Generic_Actual_Subprogram        (Id : E) return B;\n    function Is_Generic_Actual_Type              (Id : E) return B;\n    function Is_Generic_Unit                     (Id : E) return B;\n    function Is_Generic_Type                     (Id : E) return B;\n@@ -7314,6 +7328,7 @@ package Einfo is\n    procedure Set_Is_For_Access_Subtype           (Id : E; V : B := True);\n    procedure Set_Is_Formal_Subprogram            (Id : E; V : B := True);\n    procedure Set_Is_Frozen                       (Id : E; V : B := True);\n+   procedure Set_Is_Generic_Actual_Subprogram    (Id : E; V : B := True);\n    procedure Set_Is_Generic_Actual_Type          (Id : E; V : B := True);\n    procedure Set_Is_Generic_Instance             (Id : E; V : B := True);\n    procedure Set_Is_Generic_Type                 (Id : E; V : B := True);\n@@ -8081,6 +8096,7 @@ package Einfo is\n    pragma Inline (Is_Formal_Object);\n    pragma Inline (Is_Formal_Subprogram);\n    pragma Inline (Is_Frozen);\n+   pragma Inline (Is_Generic_Actual_Subprogram);\n    pragma Inline (Is_Generic_Actual_Type);\n    pragma Inline (Is_Generic_Instance);\n    pragma Inline (Is_Generic_Subprogram);\n@@ -8541,6 +8557,7 @@ package Einfo is\n    pragma Inline (Set_Is_For_Access_Subtype);\n    pragma Inline (Set_Is_Formal_Subprogram);\n    pragma Inline (Set_Is_Frozen);\n+   pragma Inline (Set_Is_Generic_Actual_Subprogram);\n    pragma Inline (Set_Is_Generic_Actual_Type);\n    pragma Inline (Set_Is_Generic_Instance);\n    pragma Inline (Set_Is_Generic_Type);"}, {"sha": "5b7447c5fb8d409c615adfb4925e7b0d8d3e57bc", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -3228,6 +3228,53 @@ package body Exp_Util is\n       end;\n    end Get_Current_Value_Condition;\n \n+   --------------------------------------------------------------\n+   -- Get_First_Parent_With_External_Axiomatization_For_Entity --\n+   --------------------------------------------------------------\n+\n+   function Get_First_Parent_With_External_Axiomatization_For_Entity\n+     (E : Entity_Id) return Entity_Id is\n+\n+      Decl : Node_Id;\n+\n+   begin\n+      if Ekind (E) = E_Package then\n+         if Nkind (Parent (E)) = N_Defining_Program_Unit_Name then\n+            Decl := Parent (Parent (E));\n+         else\n+            Decl := Parent (E);\n+         end if;\n+      end if;\n+\n+      --  E is the package which is externally axiomatized\n+\n+      if Ekind (E) = E_Package\n+        and then Has_Annotate_Pragma_For_External_Axiomatization (E)\n+      then\n+         return E;\n+\n+         --  E is a package instance, in which case it is axiomatized iff the\n+         --  corresponding generic package is Axiomatized.\n+\n+      elsif Ekind (E) = E_Package\n+        and then Present (Generic_Parent (Decl))\n+      then\n+         return Get_First_Parent_With_External_Axiomatization_For_Entity\n+           (Generic_Parent (Decl));\n+\n+         --  Otherwise, look at E's scope instead if present\n+\n+      elsif Present (Scope (E)) then\n+         return Get_First_Parent_With_External_Axiomatization_For_Entity\n+             (Scope (E));\n+\n+         --  Else there is no such axiomatized package\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Get_First_Parent_With_External_Axiomatization_For_Entity;\n+\n    ---------------------\n    -- Get_Stream_Size --\n    ---------------------\n@@ -3271,6 +3318,119 @@ package body Exp_Util is\n       end if;\n    end Has_Access_Constraint;\n \n+   -----------------------------------------------------\n+   -- Has_Annotate_Pragma_For_External_Axiomatization --\n+   -----------------------------------------------------\n+\n+   function Has_Annotate_Pragma_For_External_Axiomatization\n+     (E : Entity_Id) return Boolean\n+   is\n+\n+      function Is_Annotate_Pragma_For_External_Axiomatization\n+        (N : Node_Id) return Boolean;\n+      --  Returns whether N is\n+      --    pragma Annotate (GNATprove, External_Axiomatization);\n+\n+      ----------------------------------------------------\n+      -- Is_Annotate_Pragma_For_External_Axiomatization --\n+      ----------------------------------------------------\n+\n+      --  The general form of pragma Annotate is\n+\n+      --    pragma Annotate (IDENTIFIER [, IDENTIFIER {, ARG}]);\n+      --    ARG ::= NAME | EXPRESSION\n+\n+      --  The first two arguments are by convention intended to refer to an\n+      --  external tool and a tool-specific function. These arguments are\n+      --  not analyzed.\n+\n+      --  The following is used to annotate a package specification which\n+      --  GNATprove should treat specially, because the axiomatization of\n+      --  this unit is given by the user instead of being automatically\n+      --  generated.\n+\n+      --    pragma Annotate (GNATprove, External_Axiomatization);\n+\n+      function Is_Annotate_Pragma_For_External_Axiomatization\n+        (N : Node_Id) return Boolean is\n+\n+         -------------------\n+         -- Special Names --\n+         -------------------\n+\n+         Name_GNATprove : constant String := \"gnatprove\";\n+         Name_External_Axiomatization : constant String :=\n+           \"external_axiomatization\";\n+      begin\n+         if Nkind (N) = N_Pragma\n+           and then Get_Pragma_Id (Pragma_Name (N)) = Pragma_Annotate\n+           and then List_Length (Pragma_Argument_Associations (N)) = 2\n+         then\n+            declare\n+               Arg1 : constant Node_Id :=\n+                 First (Pragma_Argument_Associations (N));\n+               Arg2 : constant Node_Id := Next (Arg1);\n+               Nam1 : Name_Id;\n+               Nam2 : Name_Id;\n+            begin\n+               --  Fill in Name_Buffer with Name_GNATprove first, and then with\n+               --  Name_External_Axiomatization so that Name_Find returns the\n+               --  corresponding name. This takes care of all possible casings.\n+\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (Name_GNATprove);\n+               Nam1 := Name_Find;\n+\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (Name_External_Axiomatization);\n+               Nam2 := Name_Find;\n+\n+               return Chars (Get_Pragma_Arg (Arg1)) = Nam1\n+                 and then\n+                   Chars (Get_Pragma_Arg (Arg2)) = Nam2;\n+            end;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Annotate_Pragma_For_External_Axiomatization;\n+\n+      Decl : Node_Id;\n+      Vis_Decls : List_Id;\n+      N         : Node_Id;\n+\n+   begin\n+      if Nkind (Parent (E)) = N_Defining_Program_Unit_Name then\n+         Decl := Parent (Parent (E));\n+      else\n+         Decl := Parent (E);\n+      end if;\n+\n+      Vis_Decls := Visible_Declarations (Decl);\n+\n+      N := First (Vis_Decls);\n+      while Present (N) loop\n+\n+         --  Skip declarations generated by the frontend. Skip all pragmas\n+         --  that are not the desired Annotate pragma. Stop the search on\n+         --  the first non-pragma source declaration.\n+\n+         if Comes_From_Source (N) then\n+            if Nkind (N) = N_Pragma then\n+               if Is_Annotate_Pragma_For_External_Axiomatization (N) then\n+                  return True;\n+               end if;\n+            else\n+               return False;\n+            end if;\n+         end if;\n+\n+         Next (N);\n+      end loop;\n+\n+      return False;\n+   end Has_Annotate_Pragma_For_External_Axiomatization;\n+\n    ----------------------------------\n    -- Has_Following_Address_Clause --\n    ----------------------------------"}, {"sha": "d5db0f6a5a5b72e4749b84692fa0de09d6d337a3", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -525,12 +525,23 @@ package Exp_Util is\n    --  N_Op_Eq), or to determine the result of some other test in other cases\n    --  (e.g. no access check required if N_Op_Ne Null).\n \n+   function Get_First_Parent_With_External_Axiomatization_For_Entity\n+     (E : Entity_Id) return Entity_Id;\n+   --  Returns the package entity with an external axiomatization containing E,\n+   --  if any, or Empty if none.\n+\n    function Get_Stream_Size (E : Entity_Id) return Uint;\n    --  Return the stream size value of the subtype E\n \n    function Has_Access_Constraint (E : Entity_Id) return Boolean;\n    --  Given object or type E, determine if a discriminant is of an access type\n \n+   function Has_Annotate_Pragma_For_External_Axiomatization\n+     (E : Entity_Id) return Boolean;\n+   --  Returns whether E is a package entity, for which the initial list of\n+   --  pragmas at the start of the package declaration contains\n+   --    pragma Annotate (GNATprove, External_Axiomatization);\n+\n    function Has_Following_Address_Clause (D : Node_Id) return Boolean;\n    --  D is the node for an object declaration. This function searches the\n    --  current declarative part to look for an address clause for the object"}, {"sha": "b4346a63c8516370c0bf6e57bdc4882c57ec813d", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -662,7 +662,9 @@ package body Lib.Writ is\n                --  compilation unit.\n \n             begin\n-               if Nkind (Unit (Cunit (U))) = N_Subunit then\n+               if U /= No_Unit\n+                 and then Nkind (Unit (Cunit (U))) = N_Subunit\n+               then\n                   Note_Unit := Main_Unit;\n                else\n                   Note_Unit := U;"}, {"sha": "363786218494bd3322b62257a5137776452b6341", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 115, "deletions": 65, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -954,10 +954,14 @@ package body Sem_Ch12 is\n       --  In Ada 2005, indicates partial parameterization of a formal\n       --  package. As usual an other association must be last in the list.\n \n-      function Build_Wrapper (Formal : Entity_Id) return Node_Id;\n+      function Build_Wrapper\n+        (Formal : Entity_Id;\n+         Actual : Entity_Id := Empty) return Node_Id;\n       --  In GNATProve mode, create a wrapper function for actuals that are\n       --  operators, in order to propagate their contract to the renaming\n-      --  declarations generated for them.\n+      --  declarations generated for them. If the actual is absent, this is\n+      --  a formal with a default, and the name of the operator is that of the\n+      --  formal.\n \n       procedure Check_Overloaded_Formal_Subprogram (Formal : Entity_Id);\n       --  Apply RM 12.3 (9): if a formal subprogram is overloaded, the instance\n@@ -1010,113 +1014,141 @@ package body Sem_Ch12 is\n       -- Build_Wrapper --\n       -------------------\n \n-      function Build_Wrapper (Formal : Entity_Id) return Node_Id is\n+      function Build_Wrapper\n+        (Formal : Entity_Id;\n+         Actual : Entity_Id := Empty) return Node_Id\n+      is\n          Loc     : constant Source_Ptr := Sloc (I_Node);\n-         Op_Name : constant Name_Id := Chars (Formal);\n          Typ     : constant Entity_Id := Etype (Formal);\n+         Is_Binary : constant Boolean :=\n+                        Present (Next_Formal (First_Formal (Formal)));\n \n          Decl   : Node_Id;\n          Expr   : Node_Id;\n          F1, F2 : Entity_Id;\n          Func   : Entity_Id;\n+         Op_Name : Name_Id;\n          Spec   : Node_Id;\n \n          L, R   : Node_Id;\n \n       begin\n+         if No (Actual) then\n+            Op_Name := Chars (Formal);\n+         else\n+            Op_Name := Chars (Actual);\n+         end if;\n+\n          --  Create entities for wrapper function and its formals\n \n          F1 := Make_Temporary (Loc, 'A');\n          F2 := Make_Temporary (Loc, 'B');\n          L  := New_Occurrence_Of (F1, Loc);\n          R  := New_Occurrence_Of (F2, Loc);\n \n-         Func := Make_Temporary (Loc, 'F');\n+         Func := Make_Defining_Identifier (Loc, Chars (Formal));\n+         Set_Ekind (Func, E_Function);\n+         Set_Is_Generic_Actual_Subprogram (Func);\n \n          Spec := Make_Function_Specification (Loc,\n-               Defining_Unit_Name => Func,\n+            Defining_Unit_Name => Func,\n \n             Parameter_Specifications => New_List (\n               Make_Parameter_Specification (Loc,\n                 Defining_Identifier => F1,\n-                Parameter_Type => Make_Identifier (Loc, Chars (Typ))),\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => F2,\n-                Parameter_Type => Make_Identifier (Loc, Chars (Typ)))),\n+                Parameter_Type => Make_Identifier\n+                  (Loc, Chars (Etype (First_Formal (Formal)))))),\n \n             Result_Definition => Make_Identifier (Loc, Chars (Typ)));\n \n-         --  Build expression as an operator node that corresponds to the\n-         --  name of the actual, starting with binary operators.\n+         if Is_Binary then\n+            Append_To (Parameter_Specifications (Spec),\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier => F2,\n+                 Parameter_Type => Make_Identifier (Loc,\n+                   Chars (Etype (Next_Formal (First_Formal (Formal)))))));\n+         end if;\n \n-         if Op_Name = Name_Op_And then\n-            Expr := Make_Op_And (Loc, Left_Opnd => L, Right_Opnd => R);\n+         --  Build expression as a function call, or as an operator node\n+         --  that corresponds to the name of the actual, starting with binary\n+         --  operators.\n \n-         elsif Op_Name = Name_Op_Or then\n-            Expr := Make_Op_Or (Loc, Left_Opnd => L, Right_Opnd => R);\n+         if Present (Actual) and then Op_Name not in Any_Operator_Name then\n+            Expr := Make_Function_Call (Loc,\n+                      Name => New_Occurrence_Of (Entity (Actual), Loc),\n+                      Parameter_Associations => New_List (L));\n \n-         elsif Op_Name = Name_Op_Xor then\n-            Expr := Make_Op_Xor (Loc, Left_Opnd => L, Right_Opnd => R);\n+            if Is_Binary then\n+               Append_To (Parameter_Associations (Expr), R);\n+            end if;\n \n-         elsif Op_Name = Name_Op_Eq then\n-            Expr := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Is_Binary then\n+            if Op_Name = Name_Op_And then\n+               Expr := Make_Op_And (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Ne then\n-            Expr := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Or then\n+               Expr := Make_Op_Or (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Le then\n-            Expr := Make_Op_Le (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Xor then\n+               Expr := Make_Op_Xor (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Gt then\n-            Expr := Make_Op_Gt (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Eq then\n+               Expr := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Ge then\n-            Expr := Make_Op_Ge (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Ne then\n+               Expr := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Lt then\n-            Expr := Make_Op_Lt (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Le then\n+               Expr := Make_Op_Le (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Add then\n-            Expr := Make_Op_Add (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Gt then\n+               Expr := Make_Op_Gt (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Subtract then\n-            Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Ge then\n+               Expr := Make_Op_Ge (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Concat then\n-            Expr := Make_Op_Concat (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Lt then\n+               Expr := Make_Op_Lt (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Multiply then\n-            Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Add then\n+               Expr := Make_Op_Add (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Divide then\n-            Expr := Make_Op_Divide (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Subtract then\n+               Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Mod then\n-            Expr := Make_Op_Mod (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Concat then\n+               Expr := Make_Op_Concat (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Rem then\n-            Expr := Make_Op_Rem (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Multiply then\n+               Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Expon then\n-            Expr := Make_Op_Expon (Loc, Left_Opnd => L, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Divide then\n+               Expr := Make_Op_Divide (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         --  Unary operators.\n+            elsif Op_Name = Name_Op_Mod then\n+               Expr := Make_Op_Mod (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Add\n-           and then No (Next_Formal (First_Formal (Actual)))\n-         then\n-            Expr := Make_Op_Plus (Loc, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Rem then\n+               Expr := Make_Op_Rem (Loc, Left_Opnd => L, Right_Opnd => R);\n \n-         elsif Op_Name = Name_Op_Subtract\n-           and then No (Next_Formal (First_Formal (Actual)))\n-         then\n-            Expr := Make_Op_Minus (Loc, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Expon then\n+               Expr := Make_Op_Expon (Loc, Left_Opnd => L, Right_Opnd => R);\n+            end if;\n+\n+         else    --  Unary operators.\n+\n+            if Op_Name = Name_Op_Add then\n+               Expr := Make_Op_Plus (Loc, Right_Opnd => L);\n \n-         elsif Op_Name = Name_Op_Abs then\n-            Expr := Make_Op_Abs (Loc, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Subtract then\n+               Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n \n-         elsif Op_Name = Name_Op_Not then\n-            Expr := Make_Op_Not (Loc, Right_Opnd => R);\n+            elsif Op_Name = Name_Op_Abs then\n+               Expr := Make_Op_Abs (Loc, Right_Opnd => L);\n+\n+            elsif Op_Name = Name_Op_Not then\n+               Expr := Make_Op_Not (Loc, Right_Opnd => L);\n+            end if;\n          end if;\n \n          Decl := Make_Expression_Function (Loc,\n@@ -1642,24 +1674,42 @@ package body Sem_Ch12 is\n                      end if;\n \n                   else\n-                     Append_To (Assoc,\n-                       Instantiate_Formal_Subprogram\n-                         (Formal, Match, Analyzed_Formal));\n+                     if GNATprove_Mode\n+                        and then Ekind (Defining_Entity (Analyzed_Formal))\n+                          = E_Function\n+                     then\n+\n+                        --  If actual is an entity (function or operator),\n+                        --  build wrapper for it.\n \n-                     if GNATprove_Mode then\n-                        if Nkind (Match) = N_Operator_Symbol then\n+                        if Present (Match) and then Is_Entity_Name (Match) then\n                            Append_To (Assoc,\n                              Build_Wrapper\n-                               (Defining_Entity (Analyzed_Formal)));\n+                               (Defining_Entity (Analyzed_Formal), Match));\n+\n+                        --  Ditto if formal is an operator with a default.\n \n                         elsif Box_Present (Formal)\n                            and then Nkind (Defining_Entity (Analyzed_Formal))\n                              = N_Defining_Operator_Symbol\n+\n                         then\n                            Append_To (Assoc,\n                              Build_Wrapper\n                                (Defining_Entity (Analyzed_Formal)));\n+\n+                        --  Otherwise create renaming declaration.\n+\n+                        else\n+                           Append_To (Assoc,\n+                             Instantiate_Formal_Subprogram\n+                               (Formal, Match, Analyzed_Formal));\n                         end if;\n+\n+                     else\n+                        Append_To (Assoc,\n+                          Instantiate_Formal_Subprogram\n+                            (Formal, Match, Analyzed_Formal));\n                      end if;\n \n                      --  An instantiation is a freeze point for the actuals,"}, {"sha": "9b261d96cc658c17ee5d147469eade50c9c6b2aa", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce547639dcebba692c4c864287cb371360a6661/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=fce547639dcebba692c4c864287cb371360a6661", "patch": "@@ -473,34 +473,45 @@ package body Sem_Ch6 is\n             Id    : constant Entity_Id := Defining_Entity (N);\n \n          begin\n-            if Nkind (Par) = N_Package_Specification\n-              and then Decls = Visible_Declarations (Par)\n-              and then Present (Private_Declarations (Par))\n-              and then not Is_Empty_List (Private_Declarations (Par))\n+            --  If this is a wrapper created for in an instance for a formal\n+            --  subprogram, insert body after declaration, to be analyzed when\n+            --  the enclosing instance is analyzed.\n+\n+            if GNATprove_Mode\n+              and then Is_Generic_Actual_Subprogram (Defining_Entity (N))\n             then\n-               Decls := Private_Declarations (Par);\n-            end if;\n+               Insert_After (N, New_Body);\n \n-            Insert_After (Last (Decls), New_Body);\n-            Push_Scope (Id);\n-            Install_Formals (Id);\n+            else\n+               if Nkind (Par) = N_Package_Specification\n+                 and then Decls = Visible_Declarations (Par)\n+                 and then Present (Private_Declarations (Par))\n+                 and then not Is_Empty_List (Private_Declarations (Par))\n+               then\n+                  Decls := Private_Declarations (Par);\n+               end if;\n \n-            --  Preanalyze the expression for name capture, except in an\n-            --  instance, where this has been done during generic analysis,\n-            --  and will be redone when analyzing the body.\n+               Insert_After (Last (Decls), New_Body);\n+               Push_Scope (Id);\n+               Install_Formals (Id);\n \n-            declare\n-               Expr : constant Node_Id := Expression (Ret);\n+               --  Preanalyze the expression for name capture, except in an\n+               --  instance, where this has been done during generic analysis,\n+               --  and will be redone when analyzing the body.\n \n-            begin\n-               Set_Parent (Expr, Ret);\n+               declare\n+                  Expr : constant Node_Id := Expression (Ret);\n \n-               if not In_Instance then\n-                  Preanalyze_Spec_Expression (Expr, Etype (Id));\n-               end if;\n-            end;\n+               begin\n+                  Set_Parent (Expr, Ret);\n \n-            End_Scope;\n+                  if not In_Instance then\n+                     Preanalyze_Spec_Expression (Expr, Etype (Id));\n+                  end if;\n+               end;\n+\n+               End_Scope;\n+            end if;\n          end;\n       end if;\n "}]}