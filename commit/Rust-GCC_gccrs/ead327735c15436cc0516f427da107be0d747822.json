{"sha": "ead327735c15436cc0516f427da107be0d747822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkMzI3NzM1YzE1NDM2Y2MwNTE2ZjQyN2RhMTA3YmUwZDc0NzgyMg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:05:09Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:05:09Z"}, "message": "[arm] Early expansion of subvdi4\n\nThis patch adds early expansion of subvdi4.  The expansion sequence\nis broadly based on the expansion of usubvdi4.\n\n\t* config/arm/arm.md (subvdi4): Decompose calculation into 32-bit\n\toperations.\n\t(subdi3_compare1): Delete pattern.\n\t(subvsi3_borrow): New insn pattern.\n\t(subvsi3_borrow_imm): Likewise.\n\nFrom-SVN: r277190", "tree": {"sha": "9b0b25b1f6956080a0b7948ad71694fc0ed40027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b0b25b1f6956080a0b7948ad71694fc0ed40027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead327735c15436cc0516f427da107be0d747822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead327735c15436cc0516f427da107be0d747822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead327735c15436cc0516f427da107be0d747822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead327735c15436cc0516f427da107be0d747822/comments", "author": null, "committer": null, "parents": [{"sha": "238273fe06e3da6dd1d80b04217d53c76cf5fa41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/238273fe06e3da6dd1d80b04217d53c76cf5fa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/238273fe06e3da6dd1d80b04217d53c76cf5fa41"}], "stats": {"total": 139, "additions": 122, "deletions": 17}, "files": [{"sha": "3f2fbb7336ed3fbdf55f11eb189a3879e6d0a7f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead327735c15436cc0516f427da107be0d747822/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead327735c15436cc0516f427da107be0d747822/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ead327735c15436cc0516f427da107be0d747822", "patch": "@@ -1,3 +1,11 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (subvdi4): Decompose calculation into 32-bit\n+\toperations.\n+\t(subdi3_compare1): Delete pattern.\n+\t(subvsi3_borrow): New insn pattern.\n+\t(subvsi3_borrow_imm): Likewise.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (subv<mode>4): Delete."}, {"sha": "5a8175ff8b007b7abc72bd519080bd0d25692cde", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 114, "deletions": 17, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead327735c15436cc0516f427da107be0d747822/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead327735c15436cc0516f427da107be0d747822/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ead327735c15436cc0516f427da107be0d747822", "patch": "@@ -1395,12 +1395,79 @@\n \n (define_expand \"subvdi4\"\n   [(match_operand:DI 0 \"s_register_operand\")\n-   (match_operand:DI 1 \"s_register_operand\")\n-   (match_operand:DI 2 \"s_register_operand\")\n+   (match_operand:DI 1 \"reg_or_int_operand\")\n+   (match_operand:DI 2 \"reg_or_int_operand\")\n    (match_operand 3 \"\")]\n   \"TARGET_32BIT\"\n {\n-  emit_insn (gen_subdi3_compare1 (operands[0], operands[1], operands[2]));\n+  rtx lo_result, hi_result;\n+  rtx lo_op1, hi_op1, lo_op2, hi_op2;\n+  lo_result = gen_lowpart (SImode, operands[0]);\n+  hi_result = gen_highpart (SImode, operands[0]);\n+  machine_mode mode = CCmode;\n+\n+  if (CONST_INT_P (operands[1]) && CONST_INT_P (operands[2]))\n+    {\n+      /* If both operands are constants we can decide the result statically.  */\n+      wi::overflow_type overflow;\n+      wide_int val = wi::sub (rtx_mode_t (operands[1], DImode),\n+\t\t\t      rtx_mode_t (operands[2], DImode),\n+\t\t\t      SIGNED, &overflow);\n+      emit_move_insn (operands[0], GEN_INT (val.to_shwi ()));\n+      if (overflow != wi::OVF_NONE)\n+\temit_jump_insn (gen_jump (operands[3]));\n+      DONE;\n+    }\n+  else if (CONST_INT_P (operands[1]))\n+    {\n+      arm_decompose_di_binop (operands[2], operands[1], &lo_op2, &hi_op2,\n+\t\t\t      &lo_op1, &hi_op1);\n+      if (const_ok_for_arm (INTVAL (lo_op1)))\n+\t{\n+\t  emit_insn (gen_rsb_imm_compare (lo_result, lo_op1, lo_op2,\n+\t\t\t\t\t  GEN_INT (~UINTVAL (lo_op1))));\n+\t  /* We could potentially use RSC here in Arm state, but not\n+\t     in Thumb, so it's probably not worth the effort of handling\n+\t     this.  */\n+\t  hi_op1 = force_reg (SImode, hi_op1);\n+\t  mode = CC_RSBmode;\n+\t  goto highpart;\n+\t}\n+      operands[1] = force_reg (DImode, operands[1]);\n+    }\n+\n+  arm_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,\n+\t\t\t  &lo_op2, &hi_op2);\n+  if (lo_op2 == const0_rtx)\n+    {\n+      emit_move_insn (lo_result, lo_op1);\n+      if (!arm_add_operand (hi_op2, SImode))\n+        hi_op2 = force_reg (SImode, hi_op2);\n+      emit_insn (gen_subvsi4 (hi_result, hi_op1, hi_op2, operands[3]));\n+      DONE;\n+    }\n+\n+  if (CONST_INT_P (lo_op2) && !arm_addimm_operand (lo_op2, SImode))\n+    lo_op2 = force_reg (SImode, lo_op2);\n+  if (CONST_INT_P (lo_op2))\n+    emit_insn (gen_cmpsi2_addneg (lo_result, lo_op1, lo_op2,\n+\t\t\t\t  GEN_INT (-INTVAL (lo_op2))));\n+  else\n+    emit_insn (gen_subsi3_compare1 (lo_result, lo_op1, lo_op2));\n+\n+ highpart:\n+  if (!arm_not_operand (hi_op2, SImode))\n+    hi_op2 = force_reg (SImode, hi_op2);\n+  rtx ccreg = gen_rtx_REG (mode, CC_REGNUM);\n+  if (CONST_INT_P (hi_op2))\n+    emit_insn (gen_subvsi3_borrow_imm (hi_result, hi_op1, hi_op2,\n+\t\t\t\t       gen_rtx_LTU (SImode, ccreg, const0_rtx),\n+\t\t\t\t       gen_rtx_LTU (DImode, ccreg,\n+\t\t\t\t\t\t    const0_rtx)));\n+  else\n+    emit_insn (gen_subvsi3_borrow (hi_result, hi_op1, hi_op2,\n+\t\t\t\t   gen_rtx_LTU (SImode, ccreg, const0_rtx),\n+\t\t\t\t   gen_rtx_LTU (DImode, ccreg, const0_rtx)));\n   arm_gen_unlikely_cbranch (NE, CC_Vmode, operands[3]);\n \n   DONE;\n@@ -1523,20 +1590,6 @@\n   DONE;\n })\n \n-(define_insn \"subdi3_compare1\"\n-  [(set (reg:CC CC_REGNUM)\n-\t(compare:CC\n-\t  (match_operand:DI 1 \"s_register_operand\" \"r\")\n-\t  (match_operand:DI 2 \"s_register_operand\" \"r\")))\n-   (set (match_operand:DI 0 \"s_register_operand\" \"=&r\")\n-\t(minus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_32BIT\"\n-  \"subs\\\\t%Q0, %Q1, %Q2;sbcs\\\\t%R0, %R1, %R2\"\n-  [(set_attr \"conds\" \"set\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn \"subsi3_compare1\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC\n@@ -2016,6 +2069,50 @@\n    (set_attr \"type\" \"alus_imm\")]\n )\n \n+(define_insn \"subvsi3_borrow\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t (minus:DI\n+\t  (minus:DI\n+\t   (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"0,r\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"l,r\")))\n+\t  (match_operand:DI 4 \"arm_borrow_operation\" \"\"))\n+\t (sign_extend:DI\n+\t  (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t    (match_operand:SI 3 \"arm_borrow_operation\" \"\")))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=l,r\")\n+\t(minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t  (match_dup 3)))]\n+  \"TARGET_32BIT\"\n+  \"sbcs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")]\n+)\n+\n+(define_insn \"subvsi3_borrow_imm\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t (minus:DI\n+\t  (minus:DI\n+\t   (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t   (match_operand 2 \"arm_adcimm_operand\" \"I,K\"))\n+\t  (match_operand:DI 4 \"arm_borrow_operation\" \"\"))\n+\t (sign_extend:DI\n+\t  (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t    (match_operand:SI 3 \"arm_borrow_operation\" \"\")))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t  (match_dup 3)))]\n+  \"TARGET_32BIT\n+   && INTVAL (operands[2]) == ARM_SIGN_EXTEND (INTVAL (operands[2]))\"\n+  \"@\n+  sbcs%?\\\\t%0, %1, %2\n+  adcs%?\\\\t%0, %1, #%B2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n (define_expand \"subsf3\"\n   [(set (match_operand:SF           0 \"s_register_operand\")\n \t(minus:SF (match_operand:SF 1 \"s_register_operand\")"}]}