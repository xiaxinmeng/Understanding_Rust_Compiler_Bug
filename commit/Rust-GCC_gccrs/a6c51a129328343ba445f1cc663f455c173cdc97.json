{"sha": "a6c51a129328343ba445f1cc663f455c173cdc97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjNTFhMTI5MzI4MzQzYmE0NDVmMWNjNjYzZjQ1NWMxNzNjZGM5Nw==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2015-07-17T09:08:31Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-07-17T09:08:31Z"}, "message": "tree-vect-loop-manip.c (rename_variables_in_bb): Add argument to allow renaming of PHI arguments on edges incoming from outer...\n\ngcc/\n\n\t* tree-vect-loop-manip.c (rename_variables_in_bb): Add argument\n\tto allow renaming of PHI arguments on edges incoming from outer\n\tloop header, add corresponding check before start PHI iterator.\n\t(slpeel_tree_duplicate_loop_to_edge_cfg): Introduce new bool\n\tvariable DUPLICATE_OUTER_LOOP and set it to true for outer loops\n\twith true force_vectorize.  Set-up dominator for outer loop too.\n\tPass DUPLICATE_OUTER_LOOP as argument to rename_variables_in_bb.\n\t(slpeel_can_duplicate_loop_p): Allow duplicate of outer loop if it\n\twas marked with force_vectorize and has restricted cfg.\n\t(slpeel_tree_peel_loop_to_edge): Do not rename exit PHI uses in\n\tinner loop.\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Do not\n\tdo peeling for outer loops.\n\ngcc/testsuite/\n\n\t* gcc.dg/vect/vect-outer-simd-2.c: New test.\n\nFrom-SVN: r225923", "tree": {"sha": "b6e8894ec7114571f4f2b95603cc0465c3c8ef79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6e8894ec7114571f4f2b95603cc0465c3c8ef79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6c51a129328343ba445f1cc663f455c173cdc97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c51a129328343ba445f1cc663f455c173cdc97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c51a129328343ba445f1cc663f455c173cdc97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c51a129328343ba445f1cc663f455c173cdc97/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54b710be6484a9decdeac33125e41f384489ed3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b710be6484a9decdeac33125e41f384489ed3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54b710be6484a9decdeac33125e41f384489ed3c"}], "stats": {"total": 147, "additions": 131, "deletions": 16}, "files": [{"sha": "33279aa2a41c443203b705276fe3a884cb092271", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6c51a129328343ba445f1cc663f455c173cdc97", "patch": "@@ -1,3 +1,19 @@\n+2015-07-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* tree-vect-loop-manip.c (rename_variables_in_bb): Add argument\n+\tto allow renaming of PHI arguments on edges incoming from outer\n+\tloop header, add corresponding check before start PHI iterator.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Introduce new bool\n+\tvariable DUPLICATE_OUTER_LOOP and set it to true for outer loops\n+\twith true force_vectorize.  Set-up dominator for outer loop too.\n+\tPass DUPLICATE_OUTER_LOOP as argument to rename_variables_in_bb.\n+\t(slpeel_can_duplicate_loop_p): Allow duplicate of outer loop if it\n+\twas marked with force_vectorize and has restricted cfg.\n+\t(slpeel_tree_peel_loop_to_edge): Do not rename exit PHI uses in\n+\tinner loop.\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Do not\n+\tdo peeling for outer loops.\n+\n 2015-07-17  Yvan Roux  <yvan.roux@linaro.org>\n \t    Matthias Klose  <doko@ubuntu.com>\n "}, {"sha": "bfa11ee46001acbbb2b21eac35218ef719417672", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6c51a129328343ba445f1cc663f455c173cdc97", "patch": "@@ -1,3 +1,7 @@\n+2015-07-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* gcc.dg/vect/vect-outer-simd-2.c: New test.\n+\n 2015-07-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/66891"}, {"sha": "3ae1020936f960a5e46d6c74bee80d3b52df6db5", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-simd-2.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-simd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-simd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-simd-2.c?ref=a6c51a129328343ba445f1cc663f455c173cdc97", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd -ffast-math\" } */\n+#include <stdlib.h>\n+#include \"tree-vect.h\"\n+#define N 64\n+\n+float *px, *py;\n+float *tx, *ty;\n+float *x1, *z1, *t1, *t2;\n+\n+static void inline bar (const float cx, float cy,\n+                         float *vx, float *vy)\n+{\n+  int j;\n+    for (j = 0; j < N; ++j)\n+    {\n+        const float dx  = cx - px[j];\n+        const float dy  = cy - py[j];\n+        *vx               -= dx * tx[j];\n+        *vy               -= dy * ty[j];\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void foo1 (int n)\n+{\n+  int i;\n+#pragma omp simd\n+  for (i=0; i<n; i++)\n+    bar (px[i], py[i], x1+i, z1+i);\n+}\n+\n+__attribute__((noinline, noclone)) void foo2 (int n)\n+{\n+  volatile int i;\n+  for (i=0; i<n; i++)\n+    bar (px[i], py[i], x1+i, z1+i);\n+}\n+\n+\n+int main ()\n+{\n+  float *X = (float*)malloc (N * 8 * sizeof (float));\n+  int i;\n+  int n = N - 1;\n+  check_vect ();\n+  px = &X[0];\n+  py = &X[N * 1];\n+  tx = &X[N * 2];\n+  ty = &X[N * 3];\n+  x1 = &X[N * 4];\n+  z1 = &X[N * 5];\n+  t1 = &X[N * 6];\n+  t2 = &X[N * 7];\n+\n+  for (i=0; i<N; i++)\n+    {\n+      px[i] = (float) (i+2);\n+      tx[i] = (float) (i+1);\n+      py[i] = (float) (i+4);\n+      ty[i] = (float) (i+3);\n+      x1[i] = z1[i] = 1.0f;\n+    }\n+  foo1 (n);  /* vector variant.  */\n+  for (i=0; i<N;i++)\n+    {\n+      t1[i] = x1[i]; x1[i] = 1.0f;\n+      t2[i] = z1[i]; z1[i] = 1.0f;\n+    }\n+  foo2 (n);  /* scalar variant.  */\n+  for (i=0; i<N; i++)\n+    if (x1[i] != t1[i] || z1[i] != t2[i])\n+      abort ();\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"OUTER LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "c98cee4d94af45279c5b95654290d5573269520d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a6c51a129328343ba445f1cc663f455c173cdc97", "patch": "@@ -1516,7 +1516,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   /* Check if we can possibly peel the loop.  */\n   if (!vect_can_advance_ivs_p (loop_vinfo)\n-      || !slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n+      || !slpeel_can_duplicate_loop_p (loop, single_exit (loop))\n+      || loop->inner)\n     do_peeling = false;\n \n   if (do_peeling"}, {"sha": "bafd1297488888a1f7c84e152133df27268a75d0", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c51a129328343ba445f1cc663f455c173cdc97/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=a6c51a129328343ba445f1cc663f455c173cdc97", "patch": "@@ -77,17 +77,26 @@ rename_use_op (use_operand_p op_p)\n }\n \n \n-/* Renames the variables in basic block BB.  */\n+/* Renames the variables in basic block BB.  Allow renaming  of PHI argumnets\n+   on edges incoming from outer-block header if RENAME_FROM_OUTER_LOOP is\n+   true.  */\n \n static void\n-rename_variables_in_bb (basic_block bb)\n+rename_variables_in_bb (basic_block bb, bool rename_from_outer_loop)\n {\n   gimple stmt;\n   use_operand_p use_p;\n   ssa_op_iter iter;\n   edge e;\n   edge_iterator ei;\n   struct loop *loop = bb->loop_father;\n+  struct loop *outer_loop = NULL;\n+\n+  if (rename_from_outer_loop)\n+    {\n+      gcc_assert (loop);\n+      outer_loop = loop_outer (loop);\n+    }\n \n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))\n@@ -99,7 +108,8 @@ rename_variables_in_bb (basic_block bb)\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      if (!flow_bb_inside_loop_p (loop, e->src))\n+      if (!flow_bb_inside_loop_p (loop, e->src)\n+\t  && (!rename_from_outer_loop || e->src != outer_loop->header))\n \tcontinue;\n       for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n@@ -755,6 +765,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n   bool was_imm_dom;\n   basic_block exit_dest;\n   edge exit, new_exit;\n+  bool duplicate_outer_loop = false;\n \n   exit = single_exit (loop);\n   at_exit = (e == exit);\n@@ -766,7 +777,9 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n \n   bbs = XNEWVEC (basic_block, scalar_loop->num_nodes + 1);\n   get_loop_body_with_size (scalar_loop, bbs, scalar_loop->num_nodes);\n-\n+  /* Allow duplication of outer loops.  */\n+  if (scalar_loop->inner)\n+    duplicate_outer_loop = true;\n   /* Check whether duplication is possible.  */\n   if (!can_copy_bbs_p (bbs, scalar_loop->num_nodes))\n     {\n@@ -835,7 +848,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n       redirect_edge_and_branch_force (e, new_preheader);\n       flush_pending_stmts (e);\n       set_immediate_dominator (CDI_DOMINATORS, new_preheader, e->src);\n-      if (was_imm_dom)\n+      if (was_imm_dom || duplicate_outer_loop)\n \tset_immediate_dominator (CDI_DOMINATORS, exit_dest, new_exit->src);\n \n       /* And remove the non-necessary forwarder again.  Keep the other\n@@ -878,7 +891,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n     }\n \n   for (unsigned i = 0; i < scalar_loop->num_nodes + 1; i++)\n-    rename_variables_in_bb (new_bbs[i]);\n+    rename_variables_in_bb (new_bbs[i], duplicate_outer_loop);\n \n   if (scalar_loop != loop)\n     {\n@@ -960,11 +973,11 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n \n \n /* This function verifies that the following restrictions apply to LOOP:\n-   (1) it is innermost\n-   (2) it consists of exactly 2 basic blocks - header, and an empty latch.\n-   (3) it is single entry, single exit\n-   (4) its exit condition is the last stmt in the header\n-   (5) E is the entry/exit edge of LOOP.\n+   (1) it consists of exactly 2 basic blocks - header, and an empty latch\n+       for innermost loop and 5 basic blocks for outer-loop.\n+   (2) it is single entry, single exit\n+   (3) its exit condition is the last stmt in the header\n+   (4) E is the entry/exit edge of LOOP.\n  */\n \n bool\n@@ -974,12 +987,12 @@ slpeel_can_duplicate_loop_p (const struct loop *loop, const_edge e)\n   edge entry_e = loop_preheader_edge (loop);\n   gcond *orig_cond = get_loop_exit_condition (loop);\n   gimple_stmt_iterator loop_exit_gsi = gsi_last_bb (exit_e->src);\n+  unsigned int num_bb = loop->inner? 5 : 2;\n \n-  if (loop->inner\n       /* All loops have an outer scope; the only case loop->outer is NULL is for\n          the function itself.  */\n-      || !loop_outer (loop)\n-      || loop->num_nodes != 2\n+      if (!loop_outer (loop)\n+      || loop->num_nodes != num_bb\n       || !empty_block_p (loop->latch)\n       || !single_exit (loop)\n       /* Verify that new loop exit condition can be trivially modified.  */\n@@ -1165,6 +1178,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n \t\t\t       int bound1, int bound2)\n {\n   struct loop *new_loop = NULL, *first_loop, *second_loop;\n+  struct loop *inner_loop = NULL;\n   edge skip_e;\n   tree pre_condition = NULL_TREE;\n   basic_block bb_before_second_loop, bb_after_second_loop;\n@@ -1185,6 +1199,9 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n   if (!slpeel_can_duplicate_loop_p (loop, e))\n     return NULL;\n \n+  if (loop->inner)\n+    inner_loop = loop->inner;\n+\n   /* We might have a queued need to update virtual SSA form.  As we\n      delete the update SSA machinery below after doing a regular\n      incremental SSA update during loop copying make sure we don't\n@@ -1220,7 +1237,9 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n \t    add_phi_arg (new_phi, vop, exit_e, UNKNOWN_LOCATION);\n \t    gimple_phi_set_result (new_phi, new_vop);\n \t    FOR_EACH_IMM_USE_STMT (stmt, imm_iter, vop)\n-\t      if (stmt != new_phi && gimple_bb (stmt) != loop->header)\n+\t      if (stmt != new_phi && gimple_bb (stmt) != loop->header\n+\t\t  /* Do not rename PHI arguments in inner-loop.  */\n+\t\t  && (!inner_loop || gimple_bb (stmt) != inner_loop->header))\n \t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t\t  SET_USE (use_p, new_vop);\n \t  }"}]}