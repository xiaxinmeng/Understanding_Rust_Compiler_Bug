{"sha": "5a5a3bc5fa14664be26748c11325021b6b6f8e74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE1YTNiYzVmYTE0NjY0YmUyNjc0OGMxMTMyNTAyMWI2YjZmOGU3NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:19:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:19:49Z"}, "message": "Add a function for getting the ABI of a call insn target\n\nThis patch replaces get_call_reg_set_usage with insn_callee_abi,\nwhich returns the ABI of the target of a call insn.  The ABI's\nfull_reg_clobbers corresponds to regs_invalidated_by_call,\nwhereas many callers instead passed call_used_or_fixed_regs, i.e.:\n\n  (regs_invalidated_by_call | fixed_reg_set)\n\nThe patch slavishly preserves the \"| fixed_reg_set\" for these callers;\nlater patches will clean this up.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (insn_callee_abi): New hook.\n\t(remove_extra_call_preserved_regs): Delete.\n\t* doc/tm.texi.in (TARGET_INSN_CALLEE_ABI): New macro.\n\t(TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS): Delete.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_remove_extra_call_preserved_regs): Delete.\n\t* targhooks.c (default_remove_extra_call_preserved_regs): Delete.\n\t* config/aarch64/aarch64.c (aarch64_simd_call_p): Constify the\n\tinsn argument.\n\t(aarch64_remove_extra_call_preserved_regs): Delete.\n\t(aarch64_insn_callee_abi): New function.\n\t(TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS): Delete.\n\t(TARGET_INSN_CALLEE_ABI): New macro.\n\t* rtl.h (get_call_fndecl): Declare.\n\t(cgraph_rtl_info): Fix formatting.  Tweak comment for\n\tfunction_used_regs.  Remove function_used_regs_valid.\n\t* rtlanal.c (get_call_fndecl): Moved from final.c\n\t* function-abi.h (insn_callee_abi): Declare.\n\t(target_function_abi_info): Mention insn_callee_abi.\n\t* function-abi.cc (fndecl_abi): Handle flag_ipa_ra in a similar\n\tway to get_call_reg_set_usage did.\n\t(insn_callee_abi): New function.\n\t* regs.h (get_call_reg_set_usage): Delete.\n\t* final.c: Include function-abi.h.\n\t(collect_fn_hard_reg_usage): Add fixed and stack registers to\n\tfunction_used_regs before the main loop rather than afterwards.\n\tUse insn_callee_abi instead of get_call_reg_set_usage.  Exit early\n\tif function_used_regs ends up not being useful.\n\t(get_call_fndecl): Move to rtlanal.c\n\t(get_call_cgraph_rtl_info, get_call_reg_set_usage): Delete.\n\t* caller-save.c: Include function-abi.h.\n\t(setup_save_areas, save_call_clobbered_regs): Use insn_callee_abi\n\tinstead of get_call_reg_set_usage.\n\t* cfgcleanup.c: Include function-abi.h.\n\t(old_insns_match_p): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* cgraph.h (cgraph_node::rtl_info): Take a const_tree instead of\n\ta tree.\n\t* cgraph.c (cgraph_node::rtl_info): Likewise.  Initialize\n\tfunction_used_regs.\n\t* df-scan.c: Include function-abi.h.\n\t(df_get_call_refs): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* ira-lives.c: Include function-abi.h.\n\t(process_bb_node_lives): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* lra-lives.c: Include function-abi.h.\n\t(process_bb_lives): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* postreload.c: Include function-abi.h.\n\t(reload_combine): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* regcprop.c: Include function-abi.h.\n\t(copyprop_hardreg_forward_1): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\t* resource.c: Include function-abi.h.\n\t(mark_set_resources, mark_target_live_regs): Use insn_callee_abi\n\tinstead of get_call_reg_set_usage.\n\t* var-tracking.c: Include function-abi.h.\n\t(dataflow_set_clear_at_call): Use insn_callee_abi instead of\n\tget_call_reg_set_usage.\n\nFrom-SVN: r276309", "tree": {"sha": "049b62e2f4fbaa496017f9703a2f5375610da646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/049b62e2f4fbaa496017f9703a2f5375610da646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a5a3bc5fa14664be26748c11325021b6b6f8e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5a3bc5fa14664be26748c11325021b6b6f8e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5a3bc5fa14664be26748c11325021b6b6f8e74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5a3bc5fa14664be26748c11325021b6b6f8e74/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "002ffd3caa684c3eb30f8f53206439b7aa34b370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002ffd3caa684c3eb30f8f53206439b7aa34b370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002ffd3caa684c3eb30f8f53206439b7aa34b370"}], "stats": {"total": 408, "additions": 221, "deletions": 187}, "files": [{"sha": "43c34559df22bfd89b455cdf8311e5d13082b147", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1,3 +1,67 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (insn_callee_abi): New hook.\n+\t(remove_extra_call_preserved_regs): Delete.\n+\t* doc/tm.texi.in (TARGET_INSN_CALLEE_ABI): New macro.\n+\t(TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS): Delete.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_remove_extra_call_preserved_regs): Delete.\n+\t* targhooks.c (default_remove_extra_call_preserved_regs): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_simd_call_p): Constify the\n+\tinsn argument.\n+\t(aarch64_remove_extra_call_preserved_regs): Delete.\n+\t(aarch64_insn_callee_abi): New function.\n+\t(TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS): Delete.\n+\t(TARGET_INSN_CALLEE_ABI): New macro.\n+\t* rtl.h (get_call_fndecl): Declare.\n+\t(cgraph_rtl_info): Fix formatting.  Tweak comment for\n+\tfunction_used_regs.  Remove function_used_regs_valid.\n+\t* rtlanal.c (get_call_fndecl): Moved from final.c\n+\t* function-abi.h (insn_callee_abi): Declare.\n+\t(target_function_abi_info): Mention insn_callee_abi.\n+\t* function-abi.cc (fndecl_abi): Handle flag_ipa_ra in a similar\n+\tway to get_call_reg_set_usage did.\n+\t(insn_callee_abi): New function.\n+\t* regs.h (get_call_reg_set_usage): Delete.\n+\t* final.c: Include function-abi.h.\n+\t(collect_fn_hard_reg_usage): Add fixed and stack registers to\n+\tfunction_used_regs before the main loop rather than afterwards.\n+\tUse insn_callee_abi instead of get_call_reg_set_usage.  Exit early\n+\tif function_used_regs ends up not being useful.\n+\t(get_call_fndecl): Move to rtlanal.c\n+\t(get_call_cgraph_rtl_info, get_call_reg_set_usage): Delete.\n+\t* caller-save.c: Include function-abi.h.\n+\t(setup_save_areas, save_call_clobbered_regs): Use insn_callee_abi\n+\tinstead of get_call_reg_set_usage.\n+\t* cfgcleanup.c: Include function-abi.h.\n+\t(old_insns_match_p): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* cgraph.h (cgraph_node::rtl_info): Take a const_tree instead of\n+\ta tree.\n+\t* cgraph.c (cgraph_node::rtl_info): Likewise.  Initialize\n+\tfunction_used_regs.\n+\t* df-scan.c: Include function-abi.h.\n+\t(df_get_call_refs): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* ira-lives.c: Include function-abi.h.\n+\t(process_bb_node_lives): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* lra-lives.c: Include function-abi.h.\n+\t(process_bb_lives): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* postreload.c: Include function-abi.h.\n+\t(reload_combine): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* regcprop.c: Include function-abi.h.\n+\t(copyprop_hardreg_forward_1): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\t* resource.c: Include function-abi.h.\n+\t(mark_set_resources, mark_target_live_regs): Use insn_callee_abi\n+\tinstead of get_call_reg_set_usage.\n+\t* var-tracking.c: Include function-abi.h.\n+\t(dataflow_set_clear_at_call): Use insn_callee_abi instead of\n+\tget_call_reg_set_usage.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (fntype_abi): New target hook."}, {"sha": "10b67370de53e828b8fda52a495ca1b34261db31", "filename": "gcc/caller-save.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"rtl-iter.h\"\n #include \"target.h\"\n+#include \"function-abi.h\"\n \n #define MOVE_MAX_WORDS (MOVE_MAX / UNITS_PER_WORD)\n \n@@ -426,7 +427,9 @@ setup_save_areas (void)\n       freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n       REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t       &chain->live_throughout);\n-      get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n+      used_regs = insn_callee_abi (insn).full_reg_clobbers ();\n+      /* ??? This preserves traditional behavior; it might not be needed.  */\n+      used_regs |= fixed_reg_set;\n \n       /* Record all registers set in this call insn.  These don't\n \t need to be saved.  N.B. the call insn might set a subreg\n@@ -509,7 +512,10 @@ setup_save_areas (void)\n \n \t  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t\t   &chain->live_throughout);\n-\t  get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n+\t  used_regs = insn_callee_abi (insn).full_reg_clobbers ();\n+\t  /* ??? This preserves traditional behavior; it might not\n+\t     be needed.  */\n+\t  used_regs |= fixed_reg_set;\n \n \t  /* Record all registers set in this call insn.  These don't\n \t     need to be saved.  N.B. the call insn might set a subreg\n@@ -838,8 +844,10 @@ save_call_clobbered_regs (void)\n \t\t\t\t     | this_insn_sets\n \t\t\t\t     | hard_regs_saved);\n \t      hard_regs_to_save &= savable_regs;\n-\t      get_call_reg_set_usage (insn, &call_def_reg_set,\n-\t\t\t\t      call_used_or_fixed_regs);\n+\t      call_def_reg_set = insn_callee_abi (insn).full_reg_clobbers ();\n+\t      /* ??? This preserves traditional behavior; it might not\n+\t\t be needed.  */\n+\t      call_def_reg_set |= fixed_reg_set;\n \t      hard_regs_to_save &= call_def_reg_set;\n \n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)"}, {"sha": "329fa0cc901412e74d64807dac5776985f585738", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n #include \"regs.h\"\n+#include \"function-abi.h\"\n \n #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)\n \n@@ -1226,10 +1227,11 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)\n \t    }\n \t}\n \n-      HARD_REG_SET i1_used, i2_used;\n-\n-      get_call_reg_set_usage (i1, &i1_used, call_used_or_fixed_regs);\n-      get_call_reg_set_usage (i2, &i2_used, call_used_or_fixed_regs);\n+      HARD_REG_SET i1_used = insn_callee_abi (i1).full_reg_clobbers ();\n+      HARD_REG_SET i2_used = insn_callee_abi (i2).full_reg_clobbers ();\n+      /* ??? This preserves traditional behavior; it might not be needed.  */\n+      i1_used |= fixed_reg_set;\n+      i2_used |= fixed_reg_set;\n \n       if (i1_used != i2_used)\n         return dir_none;"}, {"sha": "19158f08818e319a1377f376e062f43495ef3cd2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1839,7 +1839,7 @@ cgraph_node::local_info (tree decl)\n /* Return local info for the compiled function.  */\n \n cgraph_rtl_info *\n-cgraph_node::rtl_info (tree decl)\n+cgraph_node::rtl_info (const_tree decl)\n {\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   cgraph_node *node = get (decl);\n@@ -1854,7 +1854,10 @@ cgraph_node::rtl_info (tree decl)\n     return NULL;\n   /* Allocate if it doesn't exist.  */\n   if (node->rtl == NULL)\n-    node->rtl = ggc_cleared_alloc<cgraph_rtl_info> ();\n+    {\n+      node->rtl = ggc_cleared_alloc<cgraph_rtl_info> ();\n+      node->rtl->function_used_regs = reg_class_contents[ALL_REGS];\n+    }\n   return node->rtl;\n }\n "}, {"sha": "c35b6b975169d06b60f82674ec409b149d697261", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1379,7 +1379,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   static cgraph_local_info *local_info (tree decl);\n \n   /* Return local info for the compiled function.  */\n-  static struct cgraph_rtl_info *rtl_info (tree);\n+  static struct cgraph_rtl_info *rtl_info (const_tree);\n \n   /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n      Return NULL if there's no such node.  */"}, {"sha": "71cdce3033c33e86df6ec12b1ea1b2e9542ab8de", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1877,7 +1877,7 @@ aarch64_reg_save_mode (tree fndecl, unsigned regno)\n    the function.  */\n \n static bool\n-aarch64_simd_call_p (rtx_insn *insn)\n+aarch64_simd_call_p (const rtx_insn *insn)\n {\n   rtx symbol;\n   rtx call;\n@@ -1895,20 +1895,14 @@ aarch64_simd_call_p (rtx_insn *insn)\n   return aarch64_simd_decl_p (fndecl);\n }\n \n-/* Implement TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS.  If INSN calls\n-   a function that uses the SIMD ABI, take advantage of the extra\n-   call-preserved registers that the ABI provides.  */\n+/* Implement TARGET_INSN_CALLEE_ABI.  */\n \n-void\n-aarch64_remove_extra_call_preserved_regs (rtx_insn *insn,\n-\t\t\t\t\t  HARD_REG_SET *return_set)\n+const predefined_function_abi &\n+aarch64_insn_callee_abi (const rtx_insn *insn)\n {\n   if (aarch64_simd_call_p (insn))\n-    {\n-      for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (FP_SIMD_SAVED_REGNUM_P (regno))\n-\t  CLEAR_HARD_REG_BIT (*return_set, regno);\n-    }\n+    return aarch64_simd_abi ();\n+  return default_function_abi;\n }\n \n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The callee only saves\n@@ -21004,9 +20998,8 @@ aarch64_libgcc_floating_mode_supported_p\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   aarch64_hard_regno_call_part_clobbered\n \n-#undef TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS\n-#define TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS \\\n-  aarch64_remove_extra_call_preserved_regs\n+#undef TARGET_INSN_CALLEE_ABI\n+#define TARGET_INSN_CALLEE_ABI aarch64_insn_callee_abi\n \n #undef TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n #define TARGET_RETURN_CALL_WITH_MAX_CLOBBERS \\"}, {"sha": "7ca1050f789fb7c558e9a45e84866d9d5c49ba89", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n #include \"dumpfile.h\"\n #include \"calls.h\"\n-\n+#include \"function-abi.h\"\n \n /* The set of hard registers in eliminables[i].from. */\n \n@@ -3088,13 +3088,11 @@ df_get_call_refs (class df_collection_rec *collection_rec,\n   bool is_sibling_call;\n   unsigned int i;\n   HARD_REG_SET defs_generated;\n-  HARD_REG_SET fn_reg_set_usage;\n \n   CLEAR_HARD_REG_SET (defs_generated);\n   df_find_hard_reg_defs (PATTERN (insn_info->insn), &defs_generated);\n   is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n-  get_call_reg_set_usage (insn_info->insn, &fn_reg_set_usage,\n-\t\t\t  regs_invalidated_by_call);\n+  function_abi callee_abi = insn_callee_abi (insn_info->insn);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -3118,7 +3116,7 @@ df_get_call_refs (class df_collection_rec *collection_rec,\n \t\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags);\n \t    }\n \t}\n-      else if (TEST_HARD_REG_BIT (fn_reg_set_usage, i)\n+      else if (callee_abi.clobbers_full_reg_p (i)\n \t       /* no clobbers for regs that are the result of the call */\n \t       && !TEST_HARD_REG_BIT (defs_generated, i)\n \t       && (!is_sibling_call"}, {"sha": "33997a5c7a0823d9215067b089a4f2cfb9577c59", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1905,6 +1905,17 @@ descriptor.  Targets only need to define this hook if they support\n interoperability between several ABIs in the same translation unit.\n @end deftypefn\n \n+@deftypefn {Target Hook} {const predefined_function_abi &} TARGET_INSN_CALLEE_ABI (const rtx_insn *@var{insn})\n+This hook returns a description of the ABI used by the target of\n+call instruction @var{insn}; see the definition of\n+@code{predefined_function_abi} for details of the ABI descriptor.\n+Only the global function @code{insn_callee_abi} should call this hook\n+directly.\n+\n+Targets only need to define this hook if they support\n+interoperability between several ABIs in the same translation unit.\n+@end deftypefn\n+\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n@@ -1921,18 +1932,6 @@ The default implementation returns false, which is correct\n for targets that don't have partly call-clobbered registers.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS (rtx_insn *@var{insn}, HARD_REG_SET *@var{used_regs})\n-This hook removes registers from the set of call-clobbered registers\n- in @var{used_regs} if, contrary to the default rules, something guarantees\n- that @samp{insn} preserves those registers.  For example, some targets\n- support variant ABIs in which functions preserve more registers than\n- normal functions would.  Removing those extra registers from @var{used_regs}\n- can lead to better register allocation.\n- \n- The default implementation does nothing, which is always safe.\n- Defining the hook is purely an optimization.\n-@end deftypefn\n-\n @deftypefn {Target Hook} {rtx_insn *} TARGET_RETURN_CALL_WITH_MAX_CLOBBERS (rtx_insn *@var{call_1}, rtx_insn *@var{call_2})\n This hook returns a pointer to the call that partially clobbers the\n most registers.  If a platform supports multiple ABIs where the registers"}, {"sha": "55fb5d4175a5921d48aa3d4e22edfffb0ea46dc9", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -1711,13 +1711,13 @@ must be defined.  Modern ports should define @code{CALL_REALLY_USED_REGISTERS}.\n @cindex call-saved register\n @hook TARGET_FNTYPE_ABI\n \n+@hook TARGET_INSN_CALLEE_ABI\n+\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n @hook TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n \n-@hook TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS\n-\n @hook TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n \n @hook TARGET_GET_MULTILIB_ABI_NAME"}, {"sha": "7cf9ef1effda2870b67e26c5b9e2e2a3a7e5289b", "filename": "gcc/final.c", "status": "modified", "additions": 20, "deletions": 84, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"rtl-iter.h\"\n #include \"print-rtl.h\"\n+#include \"function-abi.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data declarations.  */\n@@ -230,7 +231,6 @@ static int alter_cond (rtx);\n #endif\n static int align_fuzz (rtx, rtx, int, unsigned);\n static void collect_fn_hard_reg_usage (void);\n-static tree get_call_fndecl (rtx_insn *);\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n \n@@ -4994,7 +4994,16 @@ collect_fn_hard_reg_usage (void)\n   if (!targetm.call_fusage_contains_non_callee_clobbers)\n     return;\n \n-  CLEAR_HARD_REG_SET (function_used_regs);\n+  /* Be conservative - mark fixed and global registers as used.  */\n+  function_used_regs = fixed_reg_set;\n+\n+#ifdef STACK_REGS\n+  /* Handle STACK_REGS conservatively, since the df-framework does not\n+     provide accurate information for them.  */\n+\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    SET_HARD_REG_BIT (function_used_regs, i);\n+#endif\n \n   for (insn = get_insns (); insn != NULL_RTX; insn = next_insn (insn))\n     {\n@@ -5005,96 +5014,23 @@ collect_fn_hard_reg_usage (void)\n \n       if (CALL_P (insn)\n \t  && !self_recursive_call_p (insn))\n-\t{\n-\t  if (!get_call_reg_set_usage (insn, &insn_used_regs,\n-\t\t\t\t       call_used_or_fixed_regs))\n-\t    return;\n-\n-\t  function_used_regs |= insn_used_regs;\n-\t}\n+\tfunction_used_regs\n+\t  |= insn_callee_abi (insn).full_and_partial_reg_clobbers ();\n \n       find_all_hard_reg_sets (insn, &insn_used_regs, false);\n       function_used_regs |= insn_used_regs;\n-    }\n \n-  /* Be conservative - mark fixed and global registers as used.  */\n-  function_used_regs |= fixed_reg_set;\n-\n-#ifdef STACK_REGS\n-  /* Handle STACK_REGS conservatively, since the df-framework does not\n-     provide accurate information for them.  */\n-\n-  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-    SET_HARD_REG_BIT (function_used_regs, i);\n-#endif\n+      if (hard_reg_set_subset_p (crtl->abi->full_and_partial_reg_clobbers (),\n+\t\t\t\t function_used_regs))\n+\treturn;\n+    }\n \n-  /* The information we have gathered is only interesting if it exposes a\n-     register from the call_used_regs that is not used in this function.  */\n-  if (hard_reg_set_subset_p (call_used_or_fixed_regs, function_used_regs))\n-    return;\n+  /* Mask out fully-saved registers, so that they don't affect equality\n+     comparisons between function_abis.  */\n+  function_used_regs &= crtl->abi->full_and_partial_reg_clobbers ();\n \n   node = cgraph_node::rtl_info (current_function_decl);\n   gcc_assert (node != NULL);\n \n   node->function_used_regs = function_used_regs;\n-  node->function_used_regs_valid = 1;\n-}\n-\n-/* Get the declaration of the function called by INSN.  */\n-\n-static tree\n-get_call_fndecl (rtx_insn *insn)\n-{\n-  rtx note, datum;\n-\n-  note = find_reg_note (insn, REG_CALL_DECL, NULL_RTX);\n-  if (note == NULL_RTX)\n-    return NULL_TREE;\n-\n-  datum = XEXP (note, 0);\n-  if (datum != NULL_RTX)\n-    return SYMBOL_REF_DECL (datum);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return the cgraph_rtl_info of the function called by INSN.  Returns NULL for\n-   call targets that can be overwritten.  */\n-\n-static struct cgraph_rtl_info *\n-get_call_cgraph_rtl_info (rtx_insn *insn)\n-{\n-  tree fndecl;\n-\n-  if (insn == NULL_RTX)\n-    return NULL;\n-\n-  fndecl = get_call_fndecl (insn);\n-  if (fndecl == NULL_TREE\n-      || !decl_binds_to_current_def_p (fndecl))\n-    return NULL;\n-\n-  return cgraph_node::rtl_info (fndecl);\n-}\n-\n-/* Find hard registers used by function call instruction INSN, and return them\n-   in REG_SET.  Return DEFAULT_SET in REG_SET if not found.  */\n-\n-bool\n-get_call_reg_set_usage (rtx_insn *insn, HARD_REG_SET *reg_set,\n-\t\t\tHARD_REG_SET default_set)\n-{\n-  if (flag_ipa_ra)\n-    {\n-      struct cgraph_rtl_info *node = get_call_cgraph_rtl_info (insn);\n-      if (node != NULL\n-\t  && node->function_used_regs_valid)\n-\t{\n-\t  *reg_set = node->function_used_regs & default_set;\n-\t  return true;\n-\t}\n-    }\n-  *reg_set = default_set;\n-  targetm.remove_extra_call_preserved_regs (insn, reg_set);\n-  return false;\n }"}, {"sha": "e2c35b6a274cb87c4560779c4350c5585595622e", "filename": "gcc/function-abi.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffunction-abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffunction-abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.cc?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -143,5 +143,28 @@ function_abi\n fndecl_abi (const_tree fndecl)\n {\n   gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n-  return fntype_abi (TREE_TYPE (fndecl));\n+  const predefined_function_abi &base_abi = fntype_abi (TREE_TYPE (fndecl));\n+\n+  if (flag_ipa_ra && decl_binds_to_current_def_p (fndecl))\n+    if (cgraph_rtl_info *info = cgraph_node::rtl_info (fndecl))\n+      return function_abi (base_abi, info->function_used_regs);\n+\n+  return base_abi;\n+}\n+\n+/* Return the ABI of the function called by INSN.  */\n+\n+function_abi\n+insn_callee_abi (const rtx_insn *insn)\n+{\n+  gcc_assert (insn && CALL_P (insn));\n+\n+  if (flag_ipa_ra)\n+    if (tree fndecl = get_call_fndecl (insn))\n+      return fndecl_abi (fndecl);\n+\n+  if (targetm.calls.insn_callee_abi)\n+    return targetm.calls.insn_callee_abi (insn);\n+\n+  return default_function_abi;\n }"}, {"sha": "c8f3f291a888cd9b926a0b5dccd65916c61eaddc", "filename": "gcc/function-abi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffunction-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ffunction-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.h?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -224,6 +224,8 @@ struct target_function_abi_info\n      * crtl->abi is the ABI of the function that we are currently\n        compiling to rtl.\n \n+     * insn_callee_abi (INSN) is the ABI used by the target of call insn INSN.\n+\n      * eh_edge_abi is the \"ABI\" used when taking an EH edge from an\n        exception-throwing statement to an exception handler.  Catching\n        exceptions from calls can be treated as an abnormal return from\n@@ -265,5 +267,6 @@ extern target_function_abi_info *this_target_function_abi_info;\n \n extern const predefined_function_abi &fntype_abi (const_tree);\n extern function_abi fndecl_abi (const_tree);\n+extern function_abi insn_callee_abi (const rtx_insn *);\n \n #endif"}, {"sha": "e24831a207cedfcc42256103c293e3d79ce0ba37", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira.h\"\n #include \"ira-int.h\"\n #include \"sparseset.h\"\n+#include \"function-abi.h\"\n \n /* The code in this file is similar to one in global but the code\n    works on the allocno basis and creates live ranges instead of\n@@ -1254,10 +1255,11 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  ira_object_t obj = ira_object_id_map[i];\n \t\t  a = OBJECT_ALLOCNO (obj);\n \t\t  int num = ALLOCNO_NUM (a);\n-\t\t  HARD_REG_SET this_call_used_reg_set;\n-\n-\t\t  get_call_reg_set_usage (insn, &this_call_used_reg_set,\n-\t\t\t\t\t  call_used_or_fixed_regs);\n+\t\t  HARD_REG_SET this_call_used_reg_set\n+\t\t    = insn_callee_abi (insn).full_reg_clobbers ();\n+\t\t  /* ??? This preserves traditional behavior; it might not be\n+\t\t     needed.  */\n+\t\t  this_call_used_reg_set |= fixed_reg_set;\n \n \t\t  /* Don't allocate allocnos that cross setjmps or any\n \t\t     call, if this function receives a nonlocal"}, {"sha": "b84d6461c4cc8ecf5270f56848403f4a768d621a", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"sparseset.h\"\n #include \"lra-int.h\"\n #include \"target.h\"\n+#include \"function-abi.h\"\n \n /* Program points are enumerated by numbers from range\n    0..LRA_LIVE_MAX_POINT-1.  There are approximately two times more\n@@ -931,9 +932,11 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    last_call_used_reg_set = call_used_or_fixed_regs;\n \t  else\n \t    {\n-\t      HARD_REG_SET this_call_used_reg_set;\n-\t      get_call_reg_set_usage (curr_insn, &this_call_used_reg_set,\n-\t\t\t\t      call_used_or_fixed_regs);\n+\t      HARD_REG_SET this_call_used_reg_set\n+\t\t= insn_callee_abi (curr_insn).full_reg_clobbers ();\n+\t      /* ??? This preserves traditional behavior; it might not\n+\t\t be needed.  */\n+\t      this_call_used_reg_set |= fixed_reg_set;\n \n \t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n \t\t\t    && (last_call_used_reg_set"}, {"sha": "467df7bb0b642930dc1e4f6b6a5359503bea0747", "filename": "gcc/postreload.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cselib.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n+#include \"function-abi.h\"\n \n static int reload_cse_noop_set_p (rtx);\n static bool reload_cse_simplify (rtx_insn *, rtx);\n@@ -1330,9 +1331,10 @@ reload_combine (void)\n       if (CALL_P (insn))\n \t{\n \t  rtx link;\n-\t  HARD_REG_SET used_regs;\n-\n-\t  get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n+\t  HARD_REG_SET used_regs = insn_callee_abi (insn).full_reg_clobbers ();\n+\t  /* ??? This preserves traditional behavior; it might not be\n+\t     needed.  */\n+\t  used_regs |= fixed_reg_set;\n \n \t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t    if (TEST_HARD_REG_BIT (used_regs, r))"}, {"sha": "4879063ea69e63d195cce3959a51ed76d4b41f24", "filename": "gcc/regcprop.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -35,6 +35,7 @@\n #include \"rtl-iter.h\"\n #include \"cfgrtl.h\"\n #include \"target.h\"\n+#include \"function-abi.h\"\n \n /* The following code does forward propagation of hard register copies.\n    The object is to eliminate as many dependencies as possible, so that\n@@ -1035,7 +1036,6 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  unsigned int set_nregs = 0;\n \t  unsigned int regno;\n \t  rtx exp;\n-\t  HARD_REG_SET regs_invalidated_by_this_call;\n \n \t  for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))\n \t    {\n@@ -1053,11 +1053,9 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\t}\n \t    }\n \n-\t  get_call_reg_set_usage (insn,\n-\t\t\t\t  &regs_invalidated_by_this_call,\n-\t\t\t\t  regs_invalidated_by_call);\n+\t  function_abi callee_abi = insn_callee_abi (insn);\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t    if ((TEST_HARD_REG_BIT (regs_invalidated_by_this_call, regno)\n+\t    if ((callee_abi.clobbers_full_reg_p (regno)\n \t\t || (targetm.hard_regno_call_part_clobbered\n \t\t     (insn, regno, vd->e[regno].mode)))\n \t\t&& (regno < set_regno || regno >= set_regno + set_nregs))"}, {"sha": "821979ec67251fa78ce1209e89f641b7dcac0c23", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -383,8 +383,4 @@ range_in_hard_reg_set_p (const_hard_reg_set set, unsigned regno, int nregs)\n   return true;\n }\n \n-/* Get registers used by given function call instruction.  */\n-extern bool get_call_reg_set_usage (rtx_insn *insn, HARD_REG_SET *reg_set,\n-\t\t\t\t    HARD_REG_SET default_set);\n-\n #endif /* GCC_REGS_H */"}, {"sha": "c66b6e3ee3260b51866d895b8eb0dd2ef18c256e", "filename": "gcc/resource.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"resource.h\"\n #include \"insn-attr.h\"\n #include \"params.h\"\n+#include \"function-abi.h\"\n \n /* This structure is used to record liveness information at the targets or\n    fallthrough insns of branches.  We will most likely need the information\n@@ -662,12 +663,10 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t{\n \t  rtx_call_insn *call_insn = as_a <rtx_call_insn *> (x);\n \t  rtx link;\n-\t  HARD_REG_SET regs;\n \n \t  res->cc = res->memory = 1;\n \n-\t  get_call_reg_set_usage (call_insn, &regs, regs_invalidated_by_call);\n-\t  res->regs |= regs;\n+\t  res->regs |= insn_callee_abi (call_insn).full_reg_clobbers ();\n \n \t  for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n \t       link; link = XEXP (link, 1))\n@@ -1038,10 +1037,8 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t\t predicated instruction, or if the CALL is NORETURN.  */\n \t      if (GET_CODE (PATTERN (real_insn)) != COND_EXEC)\n \t\t{\n-\t\t  HARD_REG_SET regs_invalidated_by_this_call;\n-\t\t  get_call_reg_set_usage (real_insn,\n-\t\t\t\t\t  &regs_invalidated_by_this_call,\n-\t\t\t\t\t  regs_invalidated_by_call);\n+\t\t  HARD_REG_SET regs_invalidated_by_this_call\n+\t\t    = insn_callee_abi (real_insn).full_reg_clobbers ();\n \t\t  /* CALL clobbers all call-used regs that aren't fixed except\n \t\t     sp, ap, and fp.  Do this before setting the result of the\n \t\t     call live.  */"}, {"sha": "d798562cb31c5b94ad62a25b2b2dce8d74cc84e0", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -3447,6 +3447,7 @@ extern int rtx_unstable_p (const_rtx);\n extern bool rtx_varies_p (const_rtx, bool);\n extern bool rtx_addr_varies_p (const_rtx, bool);\n extern rtx get_call_rtx_from (const rtx_insn *);\n+extern tree get_call_fndecl (const rtx_insn *);\n extern HOST_WIDE_INT get_integer_term (const_rtx);\n extern rtx get_related_value (const_rtx);\n extern bool offset_within_block_p (const_rtx, HOST_WIDE_INT);\n@@ -4401,14 +4402,11 @@ extern tree GTY(()) global_regs_decl[FIRST_PSEUDO_REGISTER];\n    Available only for functions that has been already assembled.  */\n \n struct GTY(()) cgraph_rtl_info {\n-   unsigned int preferred_incoming_stack_boundary;\n+  unsigned int preferred_incoming_stack_boundary;\n \n-  /* Call unsaved hard registers really used by the corresponding\n-     function (including ones used by functions called by the\n-     function).  */\n+  /* Which registers the function clobbers, either directly or by\n+     calling another function.  */\n   HARD_REG_SET function_used_regs;\n-  /* Set if function_used_regs is valid.  */\n-  unsigned function_used_regs_valid: 1;\n };\n \n /* If loads from memories of mode MODE always sign or zero extend,"}, {"sha": "9c70eee4ccb1b1da765f2f80a0c90c23fb457a19", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -822,6 +822,24 @@ get_call_rtx_from (const rtx_insn *insn)\n     return x;\n   return NULL_RTX;\n }\n+\n+/* Get the declaration of the function called by INSN.  */\n+\n+tree\n+get_call_fndecl (const rtx_insn *insn)\n+{\n+  rtx note, datum;\n+\n+  note = find_reg_note (insn, REG_CALL_DECL, NULL_RTX);\n+  if (note == NULL_RTX)\n+    return NULL_TREE;\n+\n+  datum = XEXP (note, 0);\n+  if (datum != NULL_RTX)\n+    return SYMBOL_REF_DECL (datum);\n+\n+  return NULL_TREE;\n+}\n \f\n /* Return the value of the integer term in X, if one is apparent;\n    otherwise return 0."}, {"sha": "adf7a96e419ef0c52fc4c98423a218b72a8efa3f", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -4952,6 +4952,19 @@ interoperability between several ABIs in the same translation unit.\",\n  const predefined_function_abi &, (const_tree type),\n  NULL)\n \n+DEFHOOK\n+(insn_callee_abi,\n+ \"This hook returns a description of the ABI used by the target of\\n\\\n+call instruction @var{insn}; see the definition of\\n\\\n+@code{predefined_function_abi} for details of the ABI descriptor.\\n\\\n+Only the global function @code{insn_callee_abi} should call this hook\\n\\\n+directly.\\n\\\n+\\n\\\n+Targets only need to define this hook if they support\\n\\\n+interoperability between several ABIs in the same translation unit.\",\n+ const predefined_function_abi &, (const rtx_insn *insn),\n+ NULL)\n+\n /* ??? Documenting this hook requires a GFDL license grant.  */\n DEFHOOK_UNDOC\n (internal_arg_pointer,\n@@ -5834,20 +5847,6 @@ DEFHOOK\n  const char *, (void),\n  hook_constcharptr_void_null)\n \n-DEFHOOK\n-(remove_extra_call_preserved_regs,\n- \"This hook removes registers from the set of call-clobbered registers\\n\\\n- in @var{used_regs} if, contrary to the default rules, something guarantees\\n\\\n- that @samp{insn} preserves those registers.  For example, some targets\\n\\\n- support variant ABIs in which functions preserve more registers than\\n\\\n- normal functions would.  Removing those extra registers from @var{used_regs}\\n\\\n- can lead to better register allocation.\\n\\\n- \\n\\\n- The default implementation does nothing, which is always safe.\\n\\\n- Defining the hook is purely an optimization.\",\n- void, (rtx_insn *insn, HARD_REG_SET *used_regs),\n- default_remove_extra_call_preserved_regs)\n-\n /* Return the smallest number of different values for which it is best to\n    use a jump-table instead of a tree of conditional branches.  */\n DEFHOOK"}, {"sha": "d2e3ff662b67ae4a0c2c281ec26c312c52f12847", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -2363,9 +2363,4 @@ default_speculation_safe_value (machine_mode mode ATTRIBUTE_UNUSED,\n   return result;\n }\n \n-void\n-default_remove_extra_call_preserved_regs (rtx_insn *, HARD_REG_SET *)\n-{\n-}\n-\n #include \"gt-targhooks.h\""}, {"sha": "d4c3563e82587feea9523a15c2dcc490dad9919e", "filename": "gcc/targhooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -281,7 +281,5 @@ extern tree default_preferred_else_value (unsigned, tree, unsigned, tree *);\n extern bool default_have_speculation_safe_value (bool);\n extern bool speculation_safe_value_not_needed (bool);\n extern rtx default_speculation_safe_value (machine_mode, rtx, rtx, rtx);\n-extern void default_remove_extra_call_preserved_regs (rtx_insn *,\n-\t\t\t\t\t\t      HARD_REG_SET *);\n \n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "3d069e41323c03fb8aaf33672eb49c9f9c3cd15b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5a3bc5fa14664be26748c11325021b6b6f8e74/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=5a5a3bc5fa14664be26748c11325021b6b6f8e74", "patch": "@@ -116,6 +116,7 @@\n #include \"rtl-iter.h\"\n #include \"fibonacci_heap.h\"\n #include \"print-rtl.h\"\n+#include \"function-abi.h\"\n \n typedef fibonacci_heap <long, basic_block_def> bb_heap_t;\n typedef fibonacci_node <long, basic_block_def> bb_heap_node_t;\n@@ -4900,12 +4901,10 @@ dataflow_set_clear_at_call (dataflow_set *set, rtx_insn *call_insn)\n {\n   unsigned int r;\n   hard_reg_set_iterator hrsi;\n-  HARD_REG_SET invalidated_regs;\n \n-  get_call_reg_set_usage (call_insn, &invalidated_regs,\n-\t\t\t  regs_invalidated_by_call);\n+  function_abi callee_abi = insn_callee_abi (call_insn);\n \n-  EXECUTE_IF_SET_IN_HARD_REG_SET (invalidated_regs, 0, r, hrsi)\n+  EXECUTE_IF_SET_IN_HARD_REG_SET (callee_abi.full_reg_clobbers (), 0, r, hrsi)\n     var_regno_delete (set, r);\n \n   if (MAY_HAVE_DEBUG_BIND_INSNS)"}]}