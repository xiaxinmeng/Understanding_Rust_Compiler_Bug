{"sha": "39f309aca6e6b756ffab4222ffc39094042b9413", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmMzA5YWNhNmU2Yjc1NmZmYWI0MjIyZmZjMzkwOTQwNDJiOTQxMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-13T18:22:36Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-13T18:22:36Z"}, "message": "re PR fortran/83744 (ICE in ../../gcc/gcc/fortran/dump-parse-tree.c:3093 while using -fc-prototypes)\n\n2018-01-13  Thomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/83744\n\t* dump-parse-tree.c (get_c_type_name): Remove extra line.\n\tChange for loop to use declaration in for loop. Handle BT_LOGICAL\n\tand BT_CHARACTER.\n\t(write_decl): Add where argument. Fix indentation. Replace\n\tassert with error message. Add typename to warning\n\tin comment.\n\t(write_type): Adjust locus to call of write_decl.\n\t(write_variable): Likewise.\n\t(write_proc): Likewise. Replace assert with error message.\n\nFrom-SVN: r256645", "tree": {"sha": "9c42300bee1375ff895865f927ad5f079c0485a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c42300bee1375ff895865f927ad5f079c0485a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39f309aca6e6b756ffab4222ffc39094042b9413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f309aca6e6b756ffab4222ffc39094042b9413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39f309aca6e6b756ffab4222ffc39094042b9413", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f309aca6e6b756ffab4222ffc39094042b9413/comments", "author": null, "committer": null, "parents": [{"sha": "a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57776a11369621f9e9e8a8a3db6cb406c8bf27b"}], "stats": {"total": 114, "additions": 91, "deletions": 23}, "files": [{"sha": "d7ec5806f82c39fb42d2392642c085bbec104d38", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39f309aca6e6b756ffab4222ffc39094042b9413/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39f309aca6e6b756ffab4222ffc39094042b9413/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=39f309aca6e6b756ffab4222ffc39094042b9413", "patch": "@@ -1,3 +1,16 @@\n+2018-01-13  Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/83744\n+\t* dump-parse-tree.c (get_c_type_name): Remove extra line.\n+\tChange for loop to use declaration in for loop. Handle BT_LOGICAL\n+\tand BT_CHARACTER.\n+\t(write_decl): Add where argument. Fix indentation. Replace\n+\tassert with error message. Add typename to warning\n+\tin comment.\n+\t(write_type): Adjust locus to call of write_decl.\n+\t(write_variable): Likewise.\n+\t(write_proc): Likewise. Replace assert with error message.\n+\n 2018-01-13  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/52162"}, {"sha": "5ff531682e3c2f928b21b2821887e02a070b9ca7", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39f309aca6e6b756ffab4222ffc39094042b9413/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39f309aca6e6b756ffab4222ffc39094042b9413/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=39f309aca6e6b756ffab4222ffc39094042b9413", "patch": "@@ -3006,7 +3006,6 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n   *type_name = \"<error>\";\n   if (ts->type == BT_REAL || ts->type == BT_INTEGER)\n     {\n- \n       if (ts->is_c_interop && ts->interop_kind)\n \t{\n \t  *type_name = ts->interop_kind->name + 2;\n@@ -3021,8 +3020,7 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t{\n \t  /* The user did not specify a C interop type.  Let's look through\n \t     the available table and use the first one, but warn.  */\n-\t  int i;\n-\t  for (i=0; i<ISOCBINDING_NUMBER; i++)\n+\t  for (int i = 0; i < ISOCBINDING_NUMBER; i++)\n \t    {\n \t      if (c_interop_kinds_table[i].f90_type == ts->type\n \t\t  && c_interop_kinds_table[i].value == ts->kind)\n@@ -3039,6 +3037,48 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t    }\n \t}\n     }\n+  else if (ts->type == BT_LOGICAL)\n+    {\n+      if (ts->is_c_interop && ts->interop_kind)\n+\t{\n+\t  *type_name = \"_Bool\";\n+\t  ret = T_OK;\n+\t}\n+      else\n+\t{\n+\t  /* Let's select an appropriate int, with a warning. */\n+\t  for (int i = 0; i < ISOCBINDING_NUMBER; i++)\n+\t    {\n+\t      if (c_interop_kinds_table[i].f90_type == BT_INTEGER\n+\t\t  && c_interop_kinds_table[i].value == ts->kind)\n+\t\t{\n+\t\t  *type_name = c_interop_kinds_table[i].name + 2;\n+\t\t  ret = T_WARN;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (ts->type == BT_CHARACTER)\n+    {\n+      if (ts->is_c_interop)\n+\t{\n+\t  *type_name = \"char\";\n+\t  ret = T_OK;\n+\t}\n+      else\n+\t{\n+\t  /* Let's select an appropriate int, with a warning. */\n+\t  for (int i = 0; i < ISOCBINDING_NUMBER; i++)\n+\t    {\n+\t      if (c_interop_kinds_table[i].f90_type == BT_INTEGER\n+\t\t  && c_interop_kinds_table[i].value == ts->kind)\n+\t\t{\n+\t\t  *type_name = c_interop_kinds_table[i].name + 2;\n+\t\t  ret = T_WARN;\n+\t\t}\n+\t    }\n+\t}\n+    }\n   else if (ts->type == BT_DERIVED)\n     {\n       if (ts->u.derived->from_intmod == INTMOD_ISO_C_BINDING)\n@@ -3082,24 +3122,32 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n /* Write out a declaration.  */\n static void\n write_decl (gfc_typespec *ts, gfc_array_spec *as, const char *sym_name,\n-\t    bool func_ret)\n+\t    bool func_ret, locus *where)\n {\n-    const char *pre, *type_name, *post;\n-    bool asterisk;\n-    enum type_return rok;\n-\n-    rok = get_c_type_name (ts, as, &pre, &type_name, &asterisk, &post, func_ret);\n-    gcc_assert (rok != T_ERROR);\n-    fputs (type_name, dumpfile);\n-    fputs (pre, dumpfile);\n-    if (asterisk)\n-      fputs (\"*\", dumpfile);\n-\n-    fputs (sym_name, dumpfile);\n-    fputs (post, dumpfile);\n+  const char *pre, *type_name, *post;\n+  bool asterisk;\n+  enum type_return rok;\n+\n+  rok = get_c_type_name (ts, as, &pre, &type_name, &asterisk, &post, func_ret);\n+  if (rok == T_ERROR)\n+    {\n+      gfc_error_now (\"Cannot convert %qs to interoperable type at %L\",\n+\t\t     gfc_typename (ts), where);\n+      fprintf (dumpfile, \"/* Cannot convert '%s' to interoperable type */\",\n+\t       gfc_typename (ts));\n+      return;\n+    }\n+  fputs (type_name, dumpfile);\n+  fputs (pre, dumpfile);\n+  if (asterisk)\n+    fputs (\"*\", dumpfile);\n+\n+  fputs (sym_name, dumpfile);\n+  fputs (post, dumpfile);\n     \n-    if (rok == T_WARN)\n-      fputs(\" /* WARNING: non-interoperable KIND */\", dumpfile);\n+  if (rok == T_WARN)\n+    fprintf (dumpfile,\" /* WARNING: Converting '%s' to interoperable type */\",\n+\t     gfc_typename (ts));\n }\n \n /* Write out an interoperable type.  It will be written as a typedef\n@@ -3114,7 +3162,7 @@ write_type (gfc_symbol *sym)\n   for (c = sym->components; c; c = c->next)\n     {\n       fputs (\"    \", dumpfile);\n-      write_decl (&(c->ts), c->as, c->name, false);\n+      write_decl (&(c->ts), c->as, c->name, false, &sym->declared_at);\n       fputs (\";\\n\", dumpfile);\n     }\n \n@@ -3136,7 +3184,7 @@ write_variable (gfc_symbol *sym)\n     sym_name = sym->name;\n \n   fputs (\"extern \", dumpfile);\n-  write_decl (&(sym->ts), sym->as, sym_name, false);\n+  write_decl (&(sym->ts), sym->as, sym_name, false, &sym->declared_at);\n   fputs (\";\\n\", dumpfile);\n }\n \n@@ -3163,7 +3211,7 @@ write_proc (gfc_symbol *sym)\n       fputs (sym_name, dumpfile);\n     }\n   else\n-    write_decl (&(sym->ts), sym->as, sym->name, true);\n+    write_decl (&(sym->ts), sym->as, sym->name, true, &sym->declared_at);\n \n   fputs (\" (\", dumpfile);\n \n@@ -3173,7 +3221,14 @@ write_proc (gfc_symbol *sym)\n       s = f->sym;\n       rok = get_c_type_name (&(s->ts), NULL, &pre, &type_name, &asterisk,\n \t\t\t     &post, false);\n-      gcc_assert (rok != T_ERROR);\n+      if (rok == T_ERROR)\n+\t{\n+\t  gfc_error_now (\"Cannot convert %qs to interoperable type at %L\",\n+\t\t\t gfc_typename (&s->ts), &s->declared_at);\n+\t  fprintf (stderr, \"/* Cannot convert '%s' to interoperable type */\",\n+\t\t   gfc_typename (&s->ts));\n+\t  return;\n+\t}\n \n       if (!s->attr.value)\n \tasterisk = true;"}]}