{"sha": "1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyODEwNWMwZDdjYTc4NDZjYjFlMWFkODkyOWY0YTRkZmY2ZWEwOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-04-17T08:09:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-04-17T08:09:02Z"}, "message": "re PR tree-optimization/60841 (gcc: internal compiler error: Killed (program cc1) out of memory)\n\n2014-04-17   Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/60841\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Count stmts.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Pass down number\n\tof stmts to SLP build.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Likewise.\n\t(vect_analyze_slp): Likewise.\n\t(vect_analyze_slp_instance): Likewise.\n\t(vect_build_slp_tree): Limit overall SLP tree growth.\n\t* tree-vectorizer.h (vect_analyze_data_refs,\n\tvect_analyze_slp): Adjust prototypes.\n\n\t* gcc.dg/vect/pr60841.c: New testcase.\n\nFrom-SVN: r209467", "tree": {"sha": "9edf96e0eafb060a1f8cca9c941d0213c5d5bffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9edf96e0eafb060a1f8cca9c941d0213c5d5bffa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "170c1776c45f875d346519a06514d510b0905fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170c1776c45f875d346519a06514d510b0905fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170c1776c45f875d346519a06514d510b0905fa8"}], "stats": {"total": 261, "additions": 244, "deletions": 17}, "files": [{"sha": "a8664ea9836d89682ad1a5060073c7f113be9ae0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -1,3 +1,16 @@\n+2014-04-17   Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60841\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Count stmts.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Pass down number\n+\tof stmts to SLP build.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Likewise.\n+\t(vect_analyze_slp): Likewise.\n+\t(vect_analyze_slp_instance): Likewise.\n+\t(vect_build_slp_tree): Limit overall SLP tree growth.\n+\t* tree-vectorizer.h (vect_analyze_data_refs,\n+\tvect_analyze_slp): Adjust prototypes.\n+\n 2014-04-17  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \t* config/i386/i386.c (x86_add_stmt_cost): Fix vector cost model for"}, {"sha": "7e9b599766f211cb2115a561724df0b848d7410b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -1,3 +1,8 @@\n+2014-04-17   Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60841\n+\t* gcc.dg/vect/pr60841.c: New testcase.\n+\n 2014-04-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/ipa/devirt-31.C: New testcase."}, {"sha": "44b5d0191699402782cc0d830b99cdbf933c1e44", "filename": "gcc/testsuite/gcc.dg/vect/pr60841.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60841.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60841.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60841.c?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -0,0 +1,183 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-ffast-math\" } */\n+\n+/* This testcase shouldn't consume much memory or produce a 1GB vectorizer\n+   dump file due to SLP tree explosion.  */\n+\n+struct S { int f1, f2, f3, f4; } a;\n+struct T { short f3, f2, f1, f4; };\n+int b, c, d, e, f, g;\n+unsigned long z;\n+\n+void\n+foo (struct T *p, struct T *q, int x, int w)\n+{\n+  for (; x; x++)\n+    {\n+      struct S h;\n+      int i;\n+      struct T j;\n+      struct T *r;\n+      h = a;\n+      g = 0;\n+      r = p + 2 * (c + 4) + 1;\n+      j = *r;\n+      r = p;\n+      f = r->f1 - 1;\n+      b = +1.0 + f * f;\n+      i = (r->f2 + j.f2) / 2;\n+      f = r->f3 - 1;\n+      b += 1.0 - i * f * f;\n+      f = r->f4 - 1;\n+      if (b)\n+\tb += -1.0 - i * f;\n+      if (b / w)\n+\t{\n+\t  h.f1 += 8.0 * r->f1;\n+\t  h.f2 += 8.0 * r->f2;\n+\t  h.f3 += 8.0 * r->f3;\n+\t  h.f4 += 8.0 * r->f4;\n+\t  g = 1;\n+\t}\n+      r++;\n+      f = r->f1;\n+      i = (r->f2 + j.f2) / 2;\n+      f = r->f3 - 1;\n+      b += 1.0 - i * f * f;\n+      i = (r->f4);\n+      if (b * 65535UL / w)\n+\t{\n+\t  h.f1 += 10.0 * r->f1;\n+\t  h.f2 += 10.0 * r->f2;\n+\t  h.f3 += 10.0 * r->f3;\n+\t  h.f4 += 10.0 * r->f4;\n+\t  g += 10.0;\n+\t}\n+      r++;\n+      f = r->f1;\n+      z = 5UL * i;\n+      f = r->f2;\n+      i = (r->f3 + j.f3) / 2;\n+      b = -i * f * f;\n+      i = (r->f4 + j.f4) / 2;\n+      if (b * 65535UL / 25.0f)\n+\t{\n+\t  h.f1 += 8.0 * r->f1;\n+\t  h.f2 += 8.0 * r->f2;\n+\t  h.f3 += 8.0 * r->f3;\n+\t  h.f4 += 8.0 * r->f4;\n+\t  g += 8.0;\n+\t}\n+      r++;\n+      f = r->f1 - j.f1;\n+      b = 1 * 2.0 * i * f * f;\n+      f = r->f2;\n+      b += 4.0 * f;\n+      i = r->f3 / 2;\n+      f = r->f4 - 1;\n+      if (b * 1)\n+\t{\n+\t  h.f1 += 8.0 * r->f1;\n+\t  h.f2 += 8.0 * r->f2;\n+\t  h.f3 += 8.0 * r->f3;\n+\t  h.f4 += 8.0 * r->f4;\n+\t  g += 8.0;\n+\t}\n+      b = 4.0 * 1 * f;\n+      if (b * 65535UL / 25.0f)\n+\t{\n+\t  h.f1 += 20.0 * r->f1;\n+\t  h.f2 += 20.0 * r->f2;\n+\t  h.f3 += 20.0 * r->f3;\n+\t  h.f4 += 20.0 * r->f4;\n+\t  g += 20.0;\n+\t}\n+      b = 5 * (0.0 - i);\n+      if (b < 0)\n+\t{\n+\t  h.f1 += 8.0 * r->f1;\n+\t  h.f2 += 8.0 * r->f2;\n+\t  h.f3 += 8.0 * r->f3;\n+\t  h.f4 += 8.0 * r->f4;\n+\t  g += 8.0;\n+\t}\n+      r = p + 2 * (c + 4);\n+      i = (r->f1 + j.f1);\n+      b = 1 * 2.0 * i * 1;\n+      f = r->f2 - 1;\n+      i = (r->f3 + j.f3) / 2;\n+      b = 5 * (0.0 - i) * f * f;\n+      i = (r->f4 + j.f4) / 2;\n+      if (b * 65535UL / 25.0f)\n+\t{\n+\t  h.f1 += 10.0 * r->f1;\n+\t  h.f2 += 10.0 * r->f2;\n+\t  h.f3 += 10.0 * r->f3;\n+\t  h.f4 += 10.0 * r->f4;\n+\t  g += 10.0;\n+\t}\n+      r++;\n+      f = r->f1;\n+      b = 5UL * i * f;\n+      i = (r->f2 + j.f2) / 2;\n+      f = r->f3 - 1;\n+      b = 5 * (0.0 - i) * f * f;\n+      f = r->f4 - 1;\n+      if (b * 65535UL / 25.0f)\n+\t{\n+\t  h.f1 += 40.0 * r->f1;\n+\t  h.f2 += 40.0 * r->f2;\n+\t  h.f3 += 40.0 * r->f3;\n+\t  h.f4 += 40.0 * r->f4;\n+\t  g += 40.0;\n+\t}\n+      r++;\n+      i = (r->f1 + j.f1);\n+      b = 5 * i * f;\n+      f = r->f2;\n+      b = 4.0 * f * f;\n+      f = r->f3;\n+      i = (r->f4 + j.f4) / 2;\n+      b = 5 * (0.0 - i) * f * f;\n+      if (b * 25.0f)\n+\t{\n+\t  h.f1 += 8.0 * r->f1;\n+\t  h.f2 += 8.0 * r->f2;\n+\t  h.f3 += 8.0 * r->f3;\n+\t  h.f4 += 8.0 * r->f4;\n+\t  g += 8.0;\n+\t}\n+      r = p + 4 * (c + 4);\n+      i = r->f1 / 2;\n+      b = 5 * (1.0 + i);\n+      i = r->f2 + j.f2;\n+      f = r->f3 - 1;\n+      b = 5 * (0.0 - i) * f * f;\n+      i = (r->f4 + j.f4) / 2;\n+      if (b * 65535UL / 25.0f)\n+\t{\n+\t  h.f1 += 5.0 * r->f1;\n+\t  h.f2 += 5.0 * r->f2;\n+\t  h.f3 += 5.0 * r->f3;\n+\t  h.f4 += 5.0 * r->f4;\n+\t  g += 5.0;\n+\t}\n+      b = 5 * (1.0 + i);\n+      if (b < 0)\n+\t{\n+\t  h.f1 += 5.0 * r->f1;\n+\t  h.f2 += 5.0 * r->f2;\n+\t  h.f3 += 5.0 * r->f3;\n+\t  h.f4 += 5.0 * r->f4;\n+\t  g += 5.0;\n+\t}\n+      q->f1 = (h.f1 + g / 2 - 1) / g;\n+      q->f2 = (h.f2 + g / 2 - 1) / g;\n+      q->f3 = (h.f3 + g / 2 - 1) / g;\n+      q->f4 = (h.f4 + g / 2 - 1) / g;\n+      p++;\n+      q++;\n+    }\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "274cdbdcf80ba926725524d1347f49e02f3ffcf6", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -3172,7 +3172,7 @@ vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n bool\n vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t\tbb_vec_info bb_vinfo,\n-\t\t\tint *min_vf)\n+\t\t\tint *min_vf, unsigned *n_stmts)\n {\n   struct loop *loop = NULL;\n   basic_block bb = NULL;\n@@ -3207,6 +3207,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_debug (stmt))\n+\t\tcontinue;\n+\t      ++*n_stmts;\n \t      if (!find_data_references_in_stmt (loop, stmt, &datarefs))\n \t\t{\n \t\t  if (is_gimple_call (stmt) && loop->safelen)\n@@ -3260,6 +3263,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\t  ++*n_stmts;\n \t  if (!find_data_references_in_stmt (NULL, stmt,\n \t\t\t\t\t     &BB_VINFO_DATAREFS (bb_vinfo)))\n \t    {"}, {"sha": "7ec079a83749232e7fa10b889680b3a5b832fbc7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -1629,6 +1629,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n   unsigned int th;\n+  unsigned int n_stmts = 0;\n \n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n      and analyze their evolution in the loop.  Also adjust the minimal\n@@ -1637,7 +1638,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n      FORNOW: Handle only simple, array references, which\n      alignment can be forced, and aligned pointer-references.  */\n \n-  ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf);\n+  ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf, &n_stmts);\n   if (!ok)\n     {\n       if (dump_enabled_p ())\n@@ -1747,7 +1748,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     }\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, NULL);\n+  ok = vect_analyze_slp (loop_vinfo, NULL, n_stmts);\n   if (ok)\n     {\n       /* Decide which possible SLP instances to SLP.  */"}, {"sha": "0ab267f7d8e0ee3c8ca3f37db07a5528f2a57329", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -849,9 +849,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      unsigned int *max_nunits,\n                      vec<slp_tree> *loads,\n                      unsigned int vectorization_factor,\n-\t\t     bool *matches, unsigned *npermutes)\n+\t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n+\t\t     unsigned max_tree_size)\n {\n-  unsigned nops, i, this_npermutes = 0;\n+  unsigned nops, i, this_npermutes = 0, this_tree_size = 0;\n   gimple stmt;\n \n   if (!matches)\n@@ -911,6 +912,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (oprnd_info->first_dt != vect_internal_def)\n         continue;\n \n+      if (++this_tree_size > max_tree_size)\n+\t{\n+\t  vect_free_oprnd_info (oprnds_info);\n+\t  return false;\n+\t}\n+\n       child = vect_create_new_slp_node (oprnd_info->def_stmts);\n       if (!child)\n \t{\n@@ -921,7 +928,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       bool *matches = XALLOCAVEC (bool, group_size);\n       if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n \t\t\t       group_size, max_nunits, loads,\n-\t\t\t       vectorization_factor, matches, npermutes))\n+\t\t\t       vectorization_factor, matches,\n+\t\t\t       npermutes, &this_tree_size, max_tree_size))\n \t{\n \t  oprnd_info->def_stmts = vNULL;\n \t  SLP_TREE_CHILDREN (*node).quick_push (child);\n@@ -961,7 +969,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n \t\t\t\t   group_size, max_nunits, loads,\n \t\t\t\t   vectorization_factor,\n-\t\t\t\t   matches, npermutes))\n+\t\t\t\t   matches, npermutes, &this_tree_size,\n+\t\t\t\t   max_tree_size))\n \t    {\n \t      oprnd_info->def_stmts = vNULL;\n \t      SLP_TREE_CHILDREN (*node).quick_push (child);\n@@ -977,6 +986,9 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       return false;\n     }\n \n+  if (tree_size)\n+    *tree_size += this_tree_size;\n+\n   vect_free_oprnd_info (oprnds_info);\n   return true;\n }\n@@ -1436,7 +1448,7 @@ vect_analyze_slp_cost (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n static bool\n vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-                           gimple stmt)\n+                           gimple stmt, unsigned max_tree_size)\n {\n   slp_instance new_instance;\n   slp_tree node;\n@@ -1536,7 +1548,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n \t\t\t   &max_nunits, &loads,\n-\t\t\t   vectorization_factor, NULL, NULL))\n+\t\t\t   vectorization_factor, NULL, NULL, NULL,\n+\t\t\t   max_tree_size))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1641,7 +1654,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n    trees of packed scalar stmts if SLP is possible.  */\n \n bool\n-vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+\t\t  unsigned max_tree_size)\n {\n   unsigned int i;\n   vec<gimple> grouped_stores;\n@@ -1664,7 +1678,8 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   /* Find SLP sequences starting from groups of grouped stores.  */\n   FOR_EACH_VEC_ELT (grouped_stores, i, first_element)\n-    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element))\n+    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element,\n+\t\t\t\t   max_tree_size))\n       ok = true;\n \n   if (bb_vinfo && !ok)\n@@ -1681,7 +1696,8 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     {\n       /* Find SLP sequences starting from reduction chains.  */\n       FOR_EACH_VEC_ELT (reduc_chains, i, first_element)\n-        if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element))\n+        if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element,\n+\t\t\t\t       max_tree_size))\n           ok = true;\n         else\n           return false;\n@@ -1693,7 +1709,8 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   /* Find SLP sequences starting from groups of reductions.  */\n   if (loop_vinfo && LOOP_VINFO_REDUCTIONS (loop_vinfo).length () > 1\n-      && vect_analyze_slp_instance (loop_vinfo, bb_vinfo, reductions[0]))\n+      && vect_analyze_slp_instance (loop_vinfo, bb_vinfo, reductions[0],\n+\t\t\t\t    max_tree_size))\n     ok = true;\n \n   return true;\n@@ -2071,12 +2088,13 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   slp_instance instance;\n   int i;\n   int min_vf = 2;\n+  unsigned n_stmts = 0;\n \n   bb_vinfo = new_bb_vec_info (bb);\n   if (!bb_vinfo)\n     return NULL;\n \n-  if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf))\n+  if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf, &n_stmts))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2124,7 +2142,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   /* Check the SLP opportunities in the basic block, analyze and build SLP\n      trees.  */\n-  if (!vect_analyze_slp (NULL, bb_vinfo))\n+  if (!vect_analyze_slp (NULL, bb_vinfo, n_stmts))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, "}, {"sha": "c5cb037042fc474ab522be0fb30e65066f0d8eaa", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1428105c0d7ca7846cb1e1ad8929f4a4dff6ea08", "patch": "@@ -1057,7 +1057,8 @@ extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern tree vect_check_gather (gimple, loop_vec_info, tree *, tree *,\n \t\t\t       int *);\n-extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *);\n+extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *,\n+\t\t\t\t    unsigned *);\n extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n \t\t\t\t      gimple *, bool, bool *);\n@@ -1107,7 +1108,7 @@ extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           slp_instance, bool);\n extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n-extern bool vect_analyze_slp (loop_vec_info, bb_vec_info);\n+extern bool vect_analyze_slp (loop_vec_info, bb_vec_info, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree,"}]}