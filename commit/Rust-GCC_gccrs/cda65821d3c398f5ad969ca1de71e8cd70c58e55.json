{"sha": "cda65821d3c398f5ad969ca1de71e8cd70c58e55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RhNjU4MjFkM2MzOThmNWFkOTY5Y2ExZGU3MWU4Y2Q3MGM1OGU1NQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-09-16T14:23:04Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-09-16T14:23:04Z"}, "message": "Rewrite second part of or_comparisons_1 into match.pd.\n\n2019-09-16  Martin Liska  <mliska@suse.cz>\n\n\t* gimple-fold.c (or_comparisons_1): Remove rules moved\n\tto ...\n\t* match.pd: ... here.\n\nFrom-SVN: r275752", "tree": {"sha": "6fbc4b75458998b9de00ffd7f8b8945c8ec5c80a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fbc4b75458998b9de00ffd7f8b8945c8ec5c80a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cda65821d3c398f5ad969ca1de71e8cd70c58e55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda65821d3c398f5ad969ca1de71e8cd70c58e55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda65821d3c398f5ad969ca1de71e8cd70c58e55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda65821d3c398f5ad969ca1de71e8cd70c58e55/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "130c4034c732fae5196f02fe4248fb1a5a602276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130c4034c732fae5196f02fe4248fb1a5a602276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/130c4034c732fae5196f02fe4248fb1a5a602276"}], "stats": {"total": 89, "additions": 44, "deletions": 45}, "files": [{"sha": "1921bc775d604a614d9c02f1856ef25aca1dacdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cda65821d3c398f5ad969ca1de71e8cd70c58e55", "patch": "@@ -1,3 +1,9 @@\n+2019-09-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* gimple-fold.c (or_comparisons_1): Remove rules moved\n+\tto ...\n+\t* match.pd: ... here.\n+\n 2019-09-16  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-fold.c (or_comparisons_1): Remove rules"}, {"sha": "8d642de2f67e227b8c4d9ec3a54ab7fd553ed39a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=cda65821d3c398f5ad969ca1de71e8cd70c58e55", "patch": "@@ -6042,51 +6042,6 @@ or_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n \treturn t;\n     }\n \n-  /* If both comparisons are of the same value against constants, we might\n-     be able to merge them.  */\n-  if (operand_equal_p (op1a, op2a, 0)\n-      && TREE_CODE (op1b) == INTEGER_CST\n-      && TREE_CODE (op2b) == INTEGER_CST)\n-    {\n-      int cmp = tree_int_cst_compare (op1b, op2b);\n-\n-      /* Chose the less restrictive of two < or <= comparisons.  */\n-      if ((code1 == LT_EXPR || code1 == LE_EXPR)\n-\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n-\t{\n-\t  if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t  else\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t}\n-\n-      /* Likewise chose the less restrictive of two > or >= comparisons.  */\n-      else if ((code1 == GT_EXPR || code1 == GE_EXPR)\n-\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n-\t{\n-\t  if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t  else\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t}\n-\n-      /* Check for singleton ranges.  */\n-      else if (cmp == 0\n-\t       && ((code1 == LT_EXPR && code2 == GT_EXPR)\n-\t\t   || (code1 == GT_EXPR && code2 == LT_EXPR)))\n-\treturn fold_build2 (NE_EXPR, boolean_type_node, op1a, op2b);\n-\n-      /* Check for less/greater pairs that don't restrict the range at all.  */\n-      else if (cmp >= 0\n-\t       && (code1 == LT_EXPR || code1 == LE_EXPR)\n-\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n-\treturn boolean_true_node;\n-      else if (cmp <= 0\n-\t       && (code1 == GT_EXPR || code1 == GE_EXPR)\n-\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n-\treturn boolean_true_node;\n-    }\n-\n   /* Perhaps the first comparison is (NAME != 0) or (NAME == 1) where\n      NAME's definition is a truth value.  See if there are any simplifications\n      that can be done against the NAME's definition.  */"}, {"sha": "4fd7590cc39fee6c58262fc68791de71952fdb32", "filename": "gcc/match.pd", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda65821d3c398f5ad969ca1de71e8cd70c58e55/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=cda65821d3c398f5ad969ca1de71e8cd70c58e55", "patch": "@@ -2051,6 +2051,44 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       (if (code1 == NE_EXPR && val) { constant_boolean_node (true, type); })\n       (if (code1 == NE_EXPR && !val) @3))))))\n \n+/* Convert (X OP1 CST1) || (X OP2 CST2).  */\n+\n+(for code1 (lt le gt ge)\n+ (for code2 (lt le gt ge)\n+  (simplify\n+  (bit_ior (code1@3 @0 INTEGER_CST@1) (code2@4 @0 INTEGER_CST@2))\n+   (with\n+    {\n+     int cmp = tree_int_cst_compare (@1, @2);\n+    }\n+    (switch\n+     /* Choose the more restrictive of two < or <= comparisons.  */\n+     (if ((code1 == LT_EXPR || code1 == LE_EXPR)\n+\t  && (code2 == LT_EXPR || code2 == LE_EXPR))\n+      (if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n+       @4\n+       @3))\n+     /* Likewise chose the more restrictive of two > or >= comparisons.  */\n+     (if ((code1 == GT_EXPR || code1 == GE_EXPR)\n+\t  && (code2 == GT_EXPR || code2 == GE_EXPR))\n+      (if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n+       @4\n+       @3))\n+     /* Check for singleton ranges.  */\n+     (if (cmp == 0\n+\t  && ((code1 == LT_EXPR && code2 == GT_EXPR)\n+\t      || (code1 == GT_EXPR && code2 == LT_EXPR)))\n+      (ne @0 @2))\n+     /* Check for disjoint ranges.  */\n+     (if (cmp >= 0\n+\t  && (code1 == LT_EXPR || code1 == LE_EXPR)\n+\t  && (code2 == GT_EXPR || code2 == GE_EXPR))\n+      { constant_boolean_node (true, type); })\n+     (if (cmp <= 0\n+\t  && (code1 == GT_EXPR || code1 == GE_EXPR)\n+\t  && (code2 == LT_EXPR || code2 == LE_EXPR))\n+      { constant_boolean_node (true, type); })\n+     )))))\n \n /* We can't reassociate at all for saturating types.  */\n (if (!TYPE_SATURATING (type))"}]}