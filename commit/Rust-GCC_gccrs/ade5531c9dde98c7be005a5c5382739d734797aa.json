{"sha": "ade5531c9dde98c7be005a5c5382739d734797aa", "node_id": "C_kwDOANBUbNoAKGFkZTU1MzFjOWRkZTk4YzdiZTAwNWE1YzUzODI3MzlkNzM0Nzk3YWE", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-12T16:00:39Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-13T15:04:15Z"}, "message": "Move VREL values to their own enumerated type.\n\nRe-using some common things like EQ_EXPR and other relationals made\ncertain things easier, but complicated debugging and added extra overhead\nwhen accessing lookup tables.   With forthcoming additional relation types,\nit makes more sense to simple have a distinct relation kind.\n\n\t* gimple-range-fold.cc (fold_using_range::range_of_phi): Use new VREL_*\n\tenumerated values.\n\t* gimple-range-path.cc (maybe_register_phi_relation): Ditto.\n\t* range-op.cc (*::lhs_op1_relation): Return relation_kind, and use\n\tnew VREL enumerated values.\n\t(*::lhs_op2_relation): Ditto.\n\t(*::op1_op2_relation): Ditto.\n\t(*::fold_range): Use new VREL enumerated values.\n\t(minus_op1_op2_relation_effect): Ditto.\n\t(range_relational_tests): Ditto.\n\t* range-op.h (fold_range, op1_range, op2_range): Use VREL_VARYING.\n\t(lhs_op1_relation, lhs_op2_relation, op1_op2_relation): Return\n\trelation_kind.\n\t(*_op1_op2_relation): Return relation_kind.\n\t(relop_early_resolve): Use VREL_UNDEFINED.\n\t* value-query.cc (range_query::query_relation): Use VREL_VARYING.\n\t* value-relation.cc (VREL_LAST): Change enumerated value.\n\t(vrel_range_assert): Delete.\n\t(print_relation): Remove range assert.\n\t(rr_negate_table): Adjust table to use new enumerated values..\n\t(relation_negate): Remove range assert.\n\t(rr_swap_table): Adjust.\n\t(relation_swap): Remove range assert.\n\t(rr_intersect_table): Adjust.\n\t(relation_intersect): Remove range assert.\n\t(rr_union_table): Adjust.\n\t(relation_union): Remove range assert.\n\t(rr_transitive_table): Adjust.\n\t(relation_transitive): Remove range assert.\n\t(equiv_oracle::query_relation): Use new VREL enumerated values.\n\t(equiv_oracle::register_relation): Ditto.\n\t(relation_oracle::register_stmt): Ditto.\n\t(dom_oracle::set_one_relation): Ditto.\n\t(dom_oracle::register_transitives): Ditto.\n\t(dom_oracle::query_relation): Ditto.\n\t(path_oracle::register_relation): Ditto.\n\t(path_oracle::query_relation): Ditto.\n\t* value-relation.h (enum relation_kind_t): New relation_kind.\n\t(*_op1_op2_relation): Adjust prototypes.", "tree": {"sha": "10a4873e8cb4956ea7a583bc9253a2edf30aa232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10a4873e8cb4956ea7a583bc9253a2edf30aa232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ade5531c9dde98c7be005a5c5382739d734797aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade5531c9dde98c7be005a5c5382739d734797aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade5531c9dde98c7be005a5c5382739d734797aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade5531c9dde98c7be005a5c5382739d734797aa/comments", "author": null, "committer": null, "parents": [{"sha": "f3204ce1ae6b97f7e79d633844d61d021da8502e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3204ce1ae6b97f7e79d633844d61d021da8502e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3204ce1ae6b97f7e79d633844d61d021da8502e"}], "stats": {"total": 698, "additions": 350, "deletions": 348}, "files": [{"sha": "5f1b3b99f45de758cf0134e3847e5213403bddce", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -80,7 +80,7 @@ relation_kind\n fur_source::query_relation (tree op1 ATTRIBUTE_UNUSED,\n \t\t\t    tree op2 ATTRIBUTE_UNUSED)\n {\n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // Default registers nothing.\n@@ -613,14 +613,14 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t\tsrc.gori ()->register_dependency (lhs, op1);\n \t      relation_kind rel;\n \t      rel = handler->lhs_op1_relation (r, range1, range1);\n-\t      if (rel != VREL_NONE)\n+\t      if (rel != VREL_VARYING)\n \t\tsrc.register_relation (s, rel, lhs, op1);\n \t    }\n \t}\n       else if (src.get_operand (range2, op2))\n \t{\n \t  relation_kind rel = src.query_relation (op1, op2);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_NONE)\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_VARYING)\n \t    {\n \t      fprintf (dump_file, \" folding with relation \");\n \t      print_generic_expr (dump_file, op1, TDF_SLIM);\n@@ -641,13 +641,13 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t      if (gimple_range_ssa_p (op1))\n \t\t{\n \t\t  rel = handler->lhs_op1_relation (r, range1, range2, rel);\n-\t\t  if (rel != VREL_NONE)\n+\t\t  if (rel != VREL_VARYING)\n \t\t    src.register_relation (s, rel, lhs, op1);\n \t\t}\n \t      if (gimple_range_ssa_p (op2))\n \t\t{\n \t\t  rel= handler->lhs_op2_relation (r, range1, range2, rel);\n-\t\t  if (rel != VREL_NONE)\n+\t\t  if (rel != VREL_VARYING)\n \t\t    src.register_relation (s, rel, lhs, op2);\n \t\t}\n \t    }\n@@ -804,7 +804,7 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n \t  // Likewise, if the incoming PHI argument is equivalent to this\n \t  // PHI definition, it provides no new info.  Accumulate these ranges\n \t  // in case all arguments are equivalences.\n-\t  if (src.query ()->query_relation (e, arg, phi_def, false) == EQ_EXPR)\n+\t  if (src.query ()->query_relation (e, arg, phi_def, false) == VREL_EQ)\n \t    equiv_range.union_(arg_range);\n \t  else\n \t    r.union_ (arg_range);\n@@ -837,7 +837,7 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n       {\n \t// Symbolic arguments are equivalences.\n \tif (gimple_range_ssa_p (single_arg))\n-\t  src.register_relation (phi, EQ_EXPR, phi_def, single_arg);\n+\t  src.register_relation (phi, VREL_EQ, phi_def, single_arg);\n \telse if (src.get_operand (arg_range, single_arg)\n \t\t && arg_range.singleton_p ())\n \t  {\n@@ -1402,18 +1402,18 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n \n   relation_kind relation1 = handler1->op1_op2_relation (bool_one);\n   relation_kind relation2 = handler2->op1_op2_relation (bool_one);\n-  if (relation1 == VREL_NONE || relation2 == VREL_NONE)\n+  if (relation1 == VREL_VARYING || relation2 == VREL_VARYING)\n     return;\n \n   if (reverse_op2)\n     relation2 = relation_negate (relation2);\n \n   // x && y is false if the relation intersection of the true cases is NULL.\n-  if (is_and && relation_intersect (relation1, relation2) == VREL_EMPTY)\n+  if (is_and && relation_intersect (relation1, relation2) == VREL_UNDEFINED)\n     lhs_range = int_range<2> (boolean_false_node, boolean_false_node);\n   // x || y is true if the union of the true cases is NO-RELATION..\n   // ie, one or the other being true covers the full range of possibilties.\n-  else if (!is_and && relation_union (relation1, relation2) == VREL_NONE)\n+  else if (!is_and && relation_union (relation1, relation2) == VREL_VARYING)\n     lhs_range = bool_one;\n   else\n     return;\n@@ -1477,13 +1477,13 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n       if (e0)\n \t{\n \t  relation_kind relation = handler->op1_op2_relation (e0_range);\n-\t  if (relation != VREL_NONE)\n+\t  if (relation != VREL_VARYING)\n \t    register_relation (e0, relation, ssa1, ssa2);\n \t}\n       if (e1)\n \t{\n \t  relation_kind relation = handler->op1_op2_relation (e1_range);\n-\t  if (relation != VREL_NONE)\n+\t  if (relation != VREL_VARYING)\n \t    register_relation (e1, relation, ssa1, ssa2);\n \t}\n     }\n@@ -1512,14 +1512,14 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \t      && r.singleton_p ())\n \t    {\n \t      relation_kind relation = handler->op1_op2_relation (r);\n-\t      if (relation != VREL_NONE)\n+\t      if (relation != VREL_VARYING)\n \t\tregister_relation (e0, relation, ssa1, ssa2);\n \t    }\n \t  if (e1 && gori ()->outgoing_edge_range_p (r, e1, name, *m_query)\n \t      && r.singleton_p ())\n \t    {\n \t      relation_kind relation = handler->op1_op2_relation (r);\n-\t      if (relation != VREL_NONE)\n+\t      if (relation != VREL_VARYING)\n \t\tregister_relation (e1, relation, ssa1, ssa2);\n \t    }\n \t}"}, {"sha": "ff39833a3a1f66d2d0ed25207f515a695b361c5e", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -740,10 +740,10 @@ relation_kind\n jt_fur_source::query_relation (tree op1, tree op2)\n {\n   if (!m_oracle)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   return m_oracle->query_relation (m_entry, op1, op2);\n }\n@@ -799,7 +799,7 @@ path_range_query::maybe_register_phi_relation (gphi *phi, edge e)\n     fprintf (dump_file, \"maybe_register_phi_relation in bb%d:\", bb->index);\n \n   get_path_oracle ()->killing_def (result);\n-  m_oracle->register_relation (entry_bb (), EQ_EXPR, arg, result);\n+  m_oracle->register_relation (entry_bb (), VREL_EQ, arg, result);\n }\n \n // Compute relations for each PHI in BB.  For example:"}, {"sha": "e6b32e288b099d23fe1362878ebc50451172e6a9", "filename": "gcc/range-op.cc", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -244,30 +244,30 @@ range_operator::op2_range (irange &r ATTRIBUTE_UNUSED,\n   return false;\n }\n \n-// The default relation routines return VREL_NONE.\n+// The default relation routines return VREL_VARYING.\n \n-enum tree_code\n+relation_kind\n range_operator::lhs_op1_relation (const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t  const irange &op1 ATTRIBUTE_UNUSED,\n \t\t\t\t  const irange &op2 ATTRIBUTE_UNUSED,\n \t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n range_operator::lhs_op2_relation (const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t  const irange &op1 ATTRIBUTE_UNUSED,\n \t\t\t\t  const irange &op2 ATTRIBUTE_UNUSED,\n \t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n range_operator::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) const\n {\n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // Default is no relation affects the LHS.\n@@ -450,37 +450,37 @@ class operator_equal : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &val,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &val,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_equal;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n equal_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 == op2 indicates NE_EXPR.\n   if (lhs.zero_p ())\n-    return NE_EXPR;\n+    return VREL_NE;\n \n   // TRUE = op1 == op2 indicates EQ_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return EQ_EXPR;\n-  return VREL_NONE;\n+    return VREL_EQ;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_equal::op1_op2_relation (const irange &lhs) const\n {\n   return equal_op1_op2_relation (lhs);\n@@ -493,7 +493,7 @@ operator_equal::fold_range (irange &r, tree type,\n \t\t\t    const irange &op2,\n \t\t\t    relation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, EQ_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_EQ))\n     return true;\n \n   // We can be sure the values are always equal or not if both ranges\n@@ -566,37 +566,37 @@ class operator_not_equal : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_not_equal;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n not_equal_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 != op2  indicates EQ_EXPR.\n   if (lhs.zero_p ())\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   // TRUE = op1 != op2  indicates NE_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return NE_EXPR;\n-  return VREL_NONE;\n+    return VREL_NE;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_not_equal::op1_op2_relation (const irange &lhs) const\n {\n   return not_equal_op1_op2_relation (lhs);\n@@ -608,7 +608,7 @@ operator_not_equal::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &op2,\n \t\t\t\trelation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, NE_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_NE))\n     return true;\n \n   // We can be sure the values are always equal or not if both ranges\n@@ -742,37 +742,37 @@ class operator_lt :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_lt;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n lt_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 < op2 indicates GE_EXPR.\n   if (lhs.zero_p ())\n-    return GE_EXPR;\n+    return VREL_GE;\n \n   // TRUE = op1 < op2 indicates LT_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return LT_EXPR;\n-  return VREL_NONE;\n+    return VREL_LT;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_lt::op1_op2_relation (const irange &lhs) const\n {\n   return lt_op1_op2_relation (lhs);\n@@ -784,7 +784,7 @@ operator_lt::fold_range (irange &r, tree type,\n \t\t\t const irange &op2,\n \t\t\t relation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, LT_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -850,37 +850,37 @@ class operator_le :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_le;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n le_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 <= op2 indicates GT_EXPR.\n   if (lhs.zero_p ())\n-    return GT_EXPR;\n+    return VREL_GT;\n \n   // TRUE = op1 <= op2 indicates LE_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return LE_EXPR;\n-  return VREL_NONE;\n+    return VREL_LE;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_le::op1_op2_relation (const irange &lhs) const\n {\n   return le_op1_op2_relation (lhs);\n@@ -892,7 +892,7 @@ operator_le::fold_range (irange &r, tree type,\n \t\t\t const irange &op2,\n \t\t\t relation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, LE_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -958,37 +958,37 @@ class operator_gt :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_gt;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n gt_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 > op2 indicates LE_EXPR.\n   if (lhs.zero_p ())\n-    return LE_EXPR;\n+    return VREL_LE;\n \n   // TRUE = op1 > op2 indicates GT_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return GT_EXPR;\n-  return VREL_NONE;\n+    return VREL_GT;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_gt::op1_op2_relation (const irange &lhs) const\n {\n   return gt_op1_op2_relation (lhs);\n@@ -1000,7 +1000,7 @@ operator_gt::fold_range (irange &r, tree type,\n \t\t\t const irange &op1, const irange &op2,\n \t\t\t relation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, GT_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -1065,37 +1065,37 @@ class operator_ge :  public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n } op_ge;\n \n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n ge_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n-    return VREL_EMPTY;\n+    return VREL_UNDEFINED;\n \n   // FALSE = op1 >= op2 indicates LT_EXPR.\n   if (lhs.zero_p ())\n-    return LT_EXPR;\n+    return VREL_LT;\n \n   // TRUE = op1 >= op2 indicates GE_EXPR.\n   if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n-    return GE_EXPR;\n-  return VREL_NONE;\n+    return VREL_GE;\n+  return VREL_VARYING;\n }\n \n-enum tree_code\n+relation_kind\n operator_ge::op1_op2_relation (const irange &lhs) const\n {\n   return ge_op1_op2_relation (lhs);\n@@ -1107,7 +1107,7 @@ operator_ge::fold_range (irange &r, tree type,\n \t\t\t const irange &op2,\n \t\t\t relation_kind rel) const\n {\n-  if (relop_early_resolve (r, type, op1, op2, rel, GE_EXPR))\n+  if (relop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -1183,25 +1183,25 @@ class operator_plus : public range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n-  virtual enum tree_code lhs_op1_relation (const irange &lhs, const irange &op1,\n-\t\t\t\t\t   const irange &op2,\n-\t\t\t\t\t   relation_kind rel) const;\n-  virtual enum tree_code lhs_op2_relation (const irange &lhs, const irange &op1,\n-\t\t\t\t\t   const irange &op2,\n-\t\t\t\t\t   relation_kind rel) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs, const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind rel) const;\n+  virtual relation_kind lhs_op2_relation (const irange &lhs, const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind rel) const;\n } op_plus;\n \n // Check to see if the range of OP2 indicates anything about the relation\n // between LHS and OP1.\n \n-enum tree_code\n+relation_kind\n operator_plus::lhs_op1_relation (const irange &lhs,\n \t\t\t\t const irange &op1,\n \t\t\t\t const irange &op2,\n \t\t\t\t relation_kind) const\n {\n   if (lhs.undefined_p () || op1.undefined_p () || op2.undefined_p ())\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   tree type = lhs.type ();\n   unsigned prec = TYPE_PRECISION (type);\n@@ -1210,7 +1210,7 @@ operator_plus::lhs_op1_relation (const irange &lhs,\n \n   // LHS = OP1 + 0  indicates LHS == OP1.\n   if (op2.zero_p ())\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   if (TYPE_OVERFLOW_WRAPS (type))\n     {\n@@ -1225,43 +1225,43 @@ operator_plus::lhs_op1_relation (const irange &lhs,\n     {\n       // Positive op2 means lhs > op1.\n       if (wi::gt_p (op2.lower_bound (), wi::zero (prec), sign))\n-\treturn GT_EXPR;\n+\treturn VREL_GT;\n       if (wi::ge_p (op2.lower_bound (), wi::zero (prec), sign))\n-\treturn GE_EXPR;\n+\treturn VREL_GE;\n \n       // Negative op2 means lhs < op1.\n       if (wi::lt_p (op2.upper_bound (), wi::zero (prec), sign))\n-\treturn LT_EXPR;\n+\treturn VREL_LT;\n       if (wi::le_p (op2.upper_bound (), wi::zero (prec), sign))\n-\treturn LE_EXPR;\n+\treturn VREL_LE;\n     }\n   // Always wrapping additions.\n   else if (ovf1 && ovf1 == ovf2)\n     {\n       // Positive op2 means lhs < op1.\n       if (wi::gt_p (op2.lower_bound (), wi::zero (prec), sign))\n-\treturn LT_EXPR;\n+\treturn VREL_LT;\n       if (wi::ge_p (op2.lower_bound (), wi::zero (prec), sign))\n-\treturn LE_EXPR;\n+\treturn VREL_LE;\n \n       // Negative op2 means lhs > op1.\n       if (wi::lt_p (op2.upper_bound (), wi::zero (prec), sign))\n-\treturn GT_EXPR;\n+\treturn VREL_GT;\n       if (wi::le_p (op2.upper_bound (), wi::zero (prec), sign))\n-\treturn GE_EXPR;\n+\treturn VREL_GE;\n     }\n \n   // If op2 does not contain 0, then LHS and OP1 can never be equal.\n   if (!range_includes_zero_p (&op2))\n-    return NE_EXPR;\n+    return VREL_NE;\n \n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // PLUS is symmetrical, so we can simply call lhs_op1_relation with reversed\n // operands.\n \n-enum tree_code\n+relation_kind\n operator_plus::lhs_op2_relation (const irange &lhs, const irange &op1,\n \t\t\t\t const irange &op2, relation_kind rel) const\n {\n@@ -1315,7 +1315,7 @@ class operator_minus : public range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n-  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t   const irange &op1,\n \t\t\t\t\t   const irange &op2,\n \t\t\t\t\t   relation_kind rel) const;\n@@ -1342,21 +1342,21 @@ operator_minus::wi_fold (irange &r, tree type,\n // Return the relation between LHS and OP1 based on the relation between\n // OP1 and OP2.\n \n-enum tree_code\n+relation_kind\n operator_minus::lhs_op1_relation (const irange &lhs, const irange &,\n \t\t\t\t  const irange &, relation_kind rel) const\n {\n   if (TYPE_SIGN (lhs.type ()) == UNSIGNED)\n     switch (rel)\n       {\n-      case GT_EXPR:\n-\treturn LT_EXPR;\n-      case GE_EXPR:\n-\treturn LE_EXPR;\n+      case VREL_GT:\n+\treturn VREL_LT;\n+      case VREL_GE:\n+\treturn VREL_LE;\n       default:\n \tbreak;\n       }\n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // Check to see if the relation REL between OP1 and OP2 has any effect on the\n@@ -1369,17 +1369,17 @@ minus_op1_op2_relation_effect (irange &lhs_range, tree type,\n \t\t\t       const irange &op2_range ATTRIBUTE_UNUSED,\n \t\t\t       relation_kind rel)\n {\n-  if (rel == VREL_NONE)\n+  if (rel == VREL_VARYING)\n     return false;\n \n   int_range<2> rel_range;\n   unsigned prec = TYPE_PRECISION (type);\n   signop sgn = TYPE_SIGN (type);\n \n   // == and != produce [0,0] and ~[0,0] regardless of wrapping.\n-  if (rel == EQ_EXPR)\n+  if (rel == VREL_EQ)\n     rel_range = int_range<2> (type, wi::zero (prec), wi::zero (prec));\n-  else if (rel == NE_EXPR)\n+  else if (rel == VREL_NE)\n     rel_range = int_range<2> (type, wi::zero (prec), wi::zero (prec),\n \t\t\t      VR_ANTI_RANGE);\n   else if (TYPE_OVERFLOW_WRAPS (type))\n@@ -1388,8 +1388,8 @@ minus_op1_op2_relation_effect (irange &lhs_range, tree type,\n \t{\n \t  // For wrapping signed values and unsigned, if op1 > op2 or\n \t  // op1 < op2, then op1 - op2 can be restricted to ~[0, 0].\n-\t  case GT_EXPR:\n-\t  case LT_EXPR:\n+\t  case VREL_GT:\n+\t  case VREL_LT:\n \t      rel_range = int_range<2> (type, wi::zero (prec), wi::zero (prec),\n \t\t\t\t\tVR_ANTI_RANGE);\n \t    break;\n@@ -1402,22 +1402,22 @@ minus_op1_op2_relation_effect (irange &lhs_range, tree type,\n       switch (rel)\n \t{\n \t  // op1 > op2, op1 - op2 can be restricted to [1, +INF]\n-\t  case GT_EXPR:\n+\t  case VREL_GT:\n \t    rel_range = int_range<2> (type, wi::one (prec),\n \t\t\t\t      wi::max_value (prec, sgn));\n \t    break;\n \t  // op1 >= op2, op1 - op2 can be restricted to [0, +INF]\n-\t  case GE_EXPR:\n+\t  case VREL_GE:\n \t    rel_range = int_range<2> (type, wi::zero (prec),\n \t\t\t\t      wi::max_value (prec, sgn));\n \t    break;\n \t  // op1 < op2, op1 - op2 can be restricted to [-INF, -1]\n-\t  case LT_EXPR:\n+\t  case VREL_LT:\n \t    rel_range = int_range<2> (type, wi::min_value (prec, sgn),\n \t\t\t\t      wi::minus_one (prec));\n \t    break;\n \t  // op1 <= op2, op1 - op2 can be restricted to [-INF, 0]\n-\t  case LE_EXPR:\n+\t  case VREL_LE:\n \t    rel_range = int_range<2> (type, wi::min_value (prec, sgn),\n \t\t\t\t      wi::zero (prec));\n \t    break;\n@@ -1892,11 +1892,11 @@ class operator_lshift : public cross_product_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n \n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n@@ -1913,7 +1913,7 @@ class operator_rshift : public cross_product_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb,\n \t\t\tconst wide_int &lh_ub,\n@@ -1926,15 +1926,15 @@ class operator_rshift : public cross_product_operator\n   virtual bool op1_range (irange &, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t   const irange &op1,\n \t\t\t\t\t   const irange &op2,\n \t\t\t\t\t   relation_kind rel) const;\n } op_rshift;\n \n \n-enum tree_code\n+relation_kind\n operator_rshift::lhs_op1_relation (const irange &lhs ATTRIBUTE_UNUSED,\n \t\t\t\t   const irange &op1,\n \t\t\t\t   const irange &op2,\n@@ -1944,8 +1944,8 @@ operator_rshift::lhs_op1_relation (const irange &lhs ATTRIBUTE_UNUSED,\n   if (!op1.undefined_p () && !op2.undefined_p ()\n       && wi::ge_p (op1.lower_bound (), 0, TYPE_SIGN (op1.type ()))\n       && wi::ge_p (op2.lower_bound (), 0, TYPE_SIGN (op2.type ())))\n-    return LE_EXPR;\n-  return VREL_NONE;\n+    return VREL_LE;\n+  return VREL_VARYING;\n }\n \n bool\n@@ -2252,11 +2252,11 @@ class operator_cast: public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n private:\n   bool truncating_cast_p (const irange &inner, const irange &outer) const;\n   bool inside_domain_p (const wide_int &min, const wide_int &max,\n@@ -2473,15 +2473,15 @@ class operator_logical_and : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_logical_and;\n \n \n@@ -2546,15 +2546,15 @@ class operator_bitwise_and : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -2992,15 +2992,15 @@ class operator_logical_or : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_logical_or;\n \n bool\n@@ -3055,11 +3055,11 @@ class operator_bitwise_or : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel= VREL_NONE) const;\n+\t\t\t  relation_kind rel= VREL_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -3164,11 +3164,11 @@ class operator_bitwise_xor : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_op2_relation_effect (irange &lhs_range,\n \t\t\t\t\ttree type,\n \t\t\t\t\tconst irange &op1_range,\n@@ -3229,17 +3229,17 @@ operator_bitwise_xor::op1_op2_relation_effect (irange &lhs_range,\n \t\t\t\t\t       const irange &,\n \t\t\t\t\t       relation_kind rel) const\n {\n-  if (rel == VREL_NONE)\n+  if (rel == VREL_VARYING)\n     return false;\n \n   int_range<2> rel_range;\n \n   switch (rel)\n     {\n-    case EQ_EXPR:\n+    case VREL_EQ:\n       rel_range.set_zero (type);\n       break;\n-    case NE_EXPR:\n+    case VREL_NE:\n       rel_range.set_nonzero (type);\n       break;\n     default:\n@@ -3436,11 +3436,11 @@ class operator_logical_not : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_logical_not;\n \n // Folding a logical NOT, oddly enough, involves doing nothing on the\n@@ -3491,11 +3491,11 @@ class operator_bitwise_not : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_bitwise_not;\n \n bool\n@@ -3537,7 +3537,7 @@ class operator_cst : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n } op_integer_cst;\n \n bool\n@@ -3557,29 +3557,29 @@ class operator_identity : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n \t\t\t\t\t   const irange &op1,\n \t\t\t\t\t   const irange &op2,\n \t\t\t\t\t   relation_kind rel) const;\n } op_identity;\n \n // Determine if there is a relationship between LHS and OP1.\n \n-enum tree_code\n+relation_kind\n operator_identity::lhs_op1_relation (const irange &lhs,\n \t\t\t\t     const irange &op1 ATTRIBUTE_UNUSED,\n \t\t\t\t     const irange &op2 ATTRIBUTE_UNUSED,\n \t\t\t\t     relation_kind) const\n {\n   if (lhs.undefined_p ())\n-    return VREL_NONE;\n+    return VREL_VARYING;\n   // Simply a copy, so they are equivalent.\n-  return EQ_EXPR;\n+  return VREL_EQ;\n }\n \n bool\n@@ -3609,7 +3609,7 @@ class operator_unknown : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n } op_unknown;\n \n bool\n@@ -3794,11 +3794,11 @@ class operator_negate : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_negate;\n \n bool\n@@ -3832,11 +3832,11 @@ class operator_addr_expr : public range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   const irange &op2,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n } op_addr;\n \n bool\n@@ -3982,11 +3982,11 @@ class pointer_or_operator : public range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n@@ -4461,20 +4461,20 @@ range_relational_tests ()\n   int_range<2> op2 (UCHAR (20), UCHAR (20));\n \n   // Never wrapping additions mean LHS > OP1.\n-  tree_code code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_NONE);\n-  ASSERT_TRUE (code == GT_EXPR);\n+  relation_kind code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_VARYING);\n+  ASSERT_TRUE (code == VREL_GT);\n \n   // Most wrapping additions mean nothing...\n   op1 = int_range<2> (UCHAR (8), UCHAR (10));\n   op2 = int_range<2> (UCHAR (0), UCHAR (255));\n-  code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_NONE);\n-  ASSERT_TRUE (code == VREL_NONE);\n+  code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_VARYING);\n+  ASSERT_TRUE (code == VREL_VARYING);\n \n   // However, always wrapping additions mean LHS < OP1.\n   op1 = int_range<2> (UCHAR (1), UCHAR (255));\n   op2 = int_range<2> (UCHAR (255), UCHAR (255));\n-  code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_NONE);\n-  ASSERT_TRUE (code == LT_EXPR);\n+  code = op_plus.lhs_op1_relation (lhs, op1, op2, VREL_VARYING);\n+  ASSERT_TRUE (code == VREL_LT);\n }\n \n void"}, {"sha": "5fdda326d4bc0b5197a65fc6ccf16947ac4ab16b", "filename": "gcc/range-op.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -53,7 +53,7 @@ class range_operator\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n \t\t\t   const irange &rh,\n-\t\t\t   relation_kind rel = VREL_NONE) const;\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -69,25 +69,25 @@ class range_operator\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel = VREL_NONE) const;\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n \n   // The following routines are used to represent relations between the\n   // various operations.  If the caller knows where the symbolics are,\n   // it can query for relationships between them given known ranges.\n   // the optional relation passed in is the relation between op1 and op2.\n-  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n-\t\t\t\t\t   const irange &op1,\n-\t\t\t\t\t   const irange &op2,\n-\t\t\t\t\t   relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code lhs_op2_relation (const irange &lhs,\n-\t\t\t\t\t   const irange &op1,\n-\t\t\t\t\t   const irange &op2,\n-\t\t\t\t\t   relation_kind rel = VREL_NONE) const;\n-  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t  const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind lhs_op2_relation (const irange &lhs,\n+\t\t\t\t\t  const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n protected:\n   // Perform an integral operation between 2 sub-ranges and return it.\n   virtual void wi_fold (irange &r, tree type,\n@@ -116,12 +116,12 @@ extern void wi_set_zero_nonzero_bits (tree type,\n \t\t\t\t      wide_int &mustbe_nonzero);\n \n // op1_op2_relation methods that are the same across irange and frange.\n-enum tree_code equal_op1_op2_relation (const irange &lhs);\n-enum tree_code not_equal_op1_op2_relation (const irange &lhs);\n-enum tree_code lt_op1_op2_relation (const irange &lhs);\n-enum tree_code le_op1_op2_relation (const irange &lhs);\n-enum tree_code gt_op1_op2_relation (const irange &lhs);\n-enum tree_code ge_op1_op2_relation (const irange &lhs);\n+relation_kind equal_op1_op2_relation (const irange &lhs);\n+relation_kind not_equal_op1_op2_relation (const irange &lhs);\n+relation_kind lt_op1_op2_relation (const irange &lhs);\n+relation_kind le_op1_op2_relation (const irange &lhs);\n+relation_kind gt_op1_op2_relation (const irange &lhs);\n+relation_kind ge_op1_op2_relation (const irange &lhs);\n \n enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n bool_range_state get_bool_state (irange &r, const irange &lhs, tree val_type);\n@@ -162,7 +162,7 @@ relop_early_resolve (irange &r, tree type, const irange &op1,\n     }\n \n   // If known relation has no subset of this relation, always false.\n-  if (relation_intersect (rel, my_rel) == VREL_EMPTY)\n+  if (relation_intersect (rel, my_rel) == VREL_UNDEFINED)\n     {\n       r = range_false (type);\n       return true;"}, {"sha": "9ccd802457b8b1a0e99d9624a43018d532d01267", "filename": "gcc/value-query.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -457,7 +457,7 @@ range_query::query_relation (gimple *s, tree ssa1, tree ssa2, bool get_range)\n {\n   int_range_max tmp;\n   if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // Ensure ssa1 and ssa2 have both been evaluated.\n   if (get_range)\n@@ -478,7 +478,7 @@ range_query::query_relation (edge e, tree ssa1, tree ssa2, bool get_range)\n   basic_block bb;\n   int_range_max tmp;\n   if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // Use destination block if it has a single predecessor, and this picks\n   // up any relation on the edge."}, {"sha": "a93565109f97b2273ba2ef90b3055601e9cb9e28", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 137, "deletions": 141, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -32,160 +32,156 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"dominance.h\"\n \n-// These VREL codes are arranged such that VREL_NONE is the first\n-// code, and all the rest are contiguous up to and including VREL_LAST.\n-\n-#define VREL_FIRST              VREL_NONE\n-#define VREL_LAST               NE_EXPR\n-#define VREL_COUNT              (VREL_LAST - VREL_FIRST + 1)\n-\n-// vrel_range_assert will either assert that the tree code passed is valid,\n-// or mark invalid codes as unreachable to help with table optimation.\n-#if CHECKING_P\n-  #define vrel_range_assert(c) \t\t\t\\\n-    gcc_checking_assert ((c) >= VREL_FIRST && (c) <= VREL_LAST)\n-#else\n-  #define vrel_range_assert(c)\t\t\t\\\n-    if ((c) < VREL_FIRST || (c) > VREL_LAST)\t\\\n-      gcc_unreachable ();\n-#endif\n-\n-static const char *kind_string[VREL_COUNT] =\n-{ \"none\", \"<\", \"<=\", \">\", \">=\", \"empty\", \"==\", \"!=\" };\n+#define VREL_LAST               VREL_NE\n+\n+static const char *kind_string[VREL_LAST + 1] =\n+{ \"varying\", \"undefined\", \"<\", \"<=\", \">\", \">=\", \"==\", \"!=\" };\n \n // Print a relation_kind REL to file F.\n \n void\n print_relation (FILE *f, relation_kind rel)\n {\n-  vrel_range_assert (rel);\n-  fprintf (f, \" %s \", kind_string[rel - VREL_FIRST]);\n+  fprintf (f, \" %s \", kind_string[rel]);\n }\n \n // This table is used to negate the operands.  op1 REL op2 -> !(op1 REL op2).\n-relation_kind rr_negate_table[VREL_COUNT] = {\n-//     NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY,      EQ_EXPR, NE_EXPR\n-  VREL_NONE, GE_EXPR, GT_EXPR, LE_EXPR, LT_EXPR, VREL_EMPTY, NE_EXPR, EQ_EXPR };\n+relation_kind rr_negate_table[VREL_LAST + 1] = {\n+  VREL_VARYING, VREL_UNDEFINED, VREL_GE, VREL_GT, VREL_LE, VREL_LT, VREL_NE,\n+  VREL_EQ };\n \n // Negate the relation, as in logical negation.\n \n relation_kind\n relation_negate (relation_kind r)\n {\n-  vrel_range_assert (r);\n-  return rr_negate_table [r - VREL_FIRST];\n+  return rr_negate_table [r];\n }\n \n // This table is used to swap the operands.  op1 REL op2 -> op2 REL op1.\n-relation_kind rr_swap_table[VREL_COUNT] = {\n-//     NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY,      EQ_EXPR, NE_EXPR\n-  VREL_NONE, GT_EXPR, GE_EXPR, LT_EXPR, LE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR };\n+relation_kind rr_swap_table[VREL_LAST + 1] = {\n+  VREL_VARYING, VREL_UNDEFINED, VREL_GT, VREL_GE, VREL_LT, VREL_LE, VREL_EQ,\n+  VREL_NE };\n \n // Return the relation as if the operands were swapped.\n \n relation_kind\n relation_swap (relation_kind r)\n {\n-  vrel_range_assert (r);\n-  return rr_swap_table [r - VREL_FIRST];\n+  return rr_swap_table [r];\n }\n \n // This table is used to perform an intersection between 2 relations.\n \n-relation_kind rr_intersect_table[VREL_COUNT][VREL_COUNT] = {\n-//   NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n-// VREL_NONE\n-  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR },\n-// LT_EXPR\n-  { LT_EXPR, LT_EXPR, LT_EXPR, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, LT_EXPR },\n-// LE_EXPR\n-  { LE_EXPR, LT_EXPR, LE_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, LT_EXPR },\n-// GT_EXPR\n-  { GT_EXPR, VREL_EMPTY, VREL_EMPTY, GT_EXPR, GT_EXPR, VREL_EMPTY, VREL_EMPTY, GT_EXPR },\n-// GE_EXPR\n-  { GE_EXPR, VREL_EMPTY, EQ_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, GT_EXPR },\n-// VREL_EMPTY\n-  { VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY },\n-// EQ_EXPR\n-  { EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY },\n-// NE_EXPR\n-  { NE_EXPR, LT_EXPR, LT_EXPR, GT_EXPR, GT_EXPR, VREL_EMPTY, VREL_EMPTY, NE_EXPR } };\n+relation_kind rr_intersect_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+// VREL_VARYING\n+  { VREL_VARYING, VREL_UNDEFINED, VREL_LT, VREL_LE, VREL_GT, VREL_GE, VREL_EQ,\n+    VREL_NE },\n+// VREL_UNDEFINED\n+  { VREL_UNDEFINED, VREL_UNDEFINED, VREL_UNDEFINED, VREL_UNDEFINED,\n+    VREL_UNDEFINED, VREL_UNDEFINED, VREL_UNDEFINED, VREL_UNDEFINED },\n+// VREL_LT\n+  { VREL_LT, VREL_UNDEFINED, VREL_LT, VREL_LT, VREL_UNDEFINED, VREL_UNDEFINED,\n+    VREL_UNDEFINED, VREL_LT },\n+// VREL_LE\n+  { VREL_LE, VREL_UNDEFINED, VREL_LT, VREL_LE, VREL_UNDEFINED, VREL_EQ,\n+    VREL_EQ, VREL_LT },\n+// VREL_GT\n+  { VREL_GT, VREL_UNDEFINED, VREL_UNDEFINED, VREL_UNDEFINED, VREL_GT, VREL_GT,\n+    VREL_UNDEFINED, VREL_GT },\n+// VREL_GE\n+  { VREL_GE, VREL_UNDEFINED, VREL_UNDEFINED, VREL_EQ, VREL_GT, VREL_GE,\n+    VREL_EQ, VREL_GT },\n+// VREL_EQ\n+  { VREL_EQ, VREL_UNDEFINED, VREL_UNDEFINED, VREL_EQ, VREL_UNDEFINED, VREL_EQ,\n+    VREL_EQ, VREL_UNDEFINED },\n+// VREL_NE\n+  { VREL_NE, VREL_UNDEFINED, VREL_LT, VREL_LT, VREL_GT, VREL_GT,\n+    VREL_UNDEFINED, VREL_NE } };\n \n \n // Intersect relation R1 with relation R2 and return the resulting relation.\n \n relation_kind\n relation_intersect (relation_kind r1, relation_kind r2)\n {\n-  vrel_range_assert (r1);\n-  vrel_range_assert (r2);\n-  return rr_intersect_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+  return rr_intersect_table[r1][r2];\n }\n \n \n // This table is used to perform a union between 2 relations.\n \n-relation_kind rr_union_table[VREL_COUNT][VREL_COUNT] = {\n-//    \t NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n-// VREL_NONE\n-  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n-// LT_EXPR\n-  { VREL_NONE, LT_EXPR, LE_EXPR, NE_EXPR, VREL_NONE, LT_EXPR, LE_EXPR, NE_EXPR },\n-// LE_EXPR\n-  { VREL_NONE, LE_EXPR, LE_EXPR, VREL_NONE, VREL_NONE, LE_EXPR, LE_EXPR, VREL_NONE },\n-// GT_EXPR\n-  { VREL_NONE, NE_EXPR, VREL_NONE, GT_EXPR, GE_EXPR, GT_EXPR, GE_EXPR, NE_EXPR },\n-// GE_EXPR\n-  { VREL_NONE, VREL_NONE, VREL_NONE, GE_EXPR, GE_EXPR, GE_EXPR, GE_EXPR, VREL_NONE },\n-// VREL_EMPTY\n-  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR },\n-// EQ_EXPR\n-  { VREL_NONE, LE_EXPR, LE_EXPR, GE_EXPR, GE_EXPR, EQ_EXPR, EQ_EXPR, VREL_NONE },\n-// NE_EXPR\n-  { VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR } };\n+relation_kind rr_union_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+// VREL_VARYING\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n+    VREL_VARYING, VREL_VARYING, VREL_VARYING },\n+// VREL_UNDEFINED\n+  { VREL_VARYING, VREL_LT, VREL_LE, VREL_GT, VREL_GE, VREL_UNDEFINED,\n+    VREL_EQ, VREL_NE },\n+// VREL_LT\n+  { VREL_VARYING, VREL_LT, VREL_LT, VREL_LE, VREL_NE, VREL_VARYING, VREL_LE,\n+    VREL_NE },\n+// VREL_LE\n+  { VREL_VARYING, VREL_LE, VREL_LE, VREL_LE, VREL_VARYING, VREL_VARYING,\n+    VREL_LE, VREL_VARYING },\n+// VREL_GT\n+  { VREL_VARYING, VREL_GT, VREL_NE, VREL_VARYING, VREL_GT, VREL_GE, VREL_GE,\n+    VREL_NE },\n+// VREL_GE\n+  { VREL_VARYING, VREL_GE, VREL_VARYING, VREL_VARYING, VREL_GE, VREL_GE,\n+    VREL_GE, VREL_VARYING },\n+// VREL_EQ\n+  { VREL_VARYING, VREL_EQ, VREL_LE, VREL_LE, VREL_GE, VREL_GE, VREL_EQ,\n+    VREL_VARYING },\n+// VREL_NE\n+  { VREL_VARYING, VREL_NE, VREL_NE, VREL_VARYING, VREL_NE, VREL_VARYING,\n+    VREL_VARYING, VREL_NE } };\n \n // Union relation R1 with relation R2 and return the result.\n \n relation_kind\n relation_union (relation_kind r1, relation_kind r2)\n {\n-  vrel_range_assert (r1);\n-  vrel_range_assert (r2);\n-  return rr_union_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+  return rr_union_table[r1][r2];\n }\n \n \n // This table is used to determine transitivity between 2 relations.\n // (A relation0 B) and (B relation1 C) implies  (A result C)\n \n-relation_kind rr_transitive_table[VREL_COUNT][VREL_COUNT] = {\n-//   NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n-// VREL_NONE\n-  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n-// LT_EXPR\n-  { VREL_NONE, LT_EXPR, LT_EXPR, VREL_NONE, VREL_NONE, VREL_NONE, LT_EXPR, VREL_NONE },\n-// LE_EXPR\n-  { VREL_NONE, LT_EXPR, LE_EXPR, VREL_NONE, VREL_NONE, VREL_NONE, LE_EXPR, VREL_NONE },\n-// GT_EXPR\n-  { VREL_NONE, VREL_NONE, VREL_NONE, GT_EXPR, GT_EXPR, VREL_NONE, GT_EXPR, VREL_NONE },\n-// GE_EXPR\n-  { VREL_NONE, VREL_NONE, VREL_NONE, GT_EXPR, GE_EXPR, VREL_NONE, GE_EXPR, VREL_NONE },\n-// VREL_EMPTY\n-  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n-// EQ_EXPR\n-  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_NONE, EQ_EXPR, VREL_NONE },\n-// NE_EXPR\n-  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE } };\n+relation_kind rr_transitive_table[VREL_LAST + 1][VREL_LAST + 1] = {\n+// VREL_VARYING\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n+    VREL_VARYING, VREL_VARYING, VREL_VARYING },\n+// VREL_UNDEFINED\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n+    VREL_VARYING, VREL_VARYING, VREL_VARYING },\n+// VREL_LT\n+  { VREL_VARYING, VREL_VARYING, VREL_LT, VREL_LT, VREL_VARYING, VREL_VARYING,\n+    VREL_LT, VREL_VARYING },\n+// VREL_LE\n+  { VREL_VARYING, VREL_VARYING, VREL_LT, VREL_LE, VREL_VARYING, VREL_VARYING,\n+    VREL_LE, VREL_VARYING },\n+// VREL_GT\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_GT, VREL_GT,\n+    VREL_GT, VREL_VARYING },\n+// VREL_GE\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_GT, VREL_GE,\n+    VREL_GE, VREL_VARYING },\n+// VREL_EQ\n+  { VREL_VARYING, VREL_VARYING, VREL_LT, VREL_LE, VREL_GT, VREL_GE, VREL_EQ,\n+    VREL_VARYING },\n+// VREL_NE\n+  { VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING, VREL_VARYING,\n+    VREL_VARYING, VREL_VARYING, VREL_VARYING } };\n \n // Apply transitive operation between relation R1 and relation R2, and\n // return the resulting relation, if any.\n \n relation_kind\n relation_transitive (relation_kind r1, relation_kind r2)\n {\n-  vrel_range_assert (r1);\n-  vrel_range_assert (r2);\n-  return rr_transitive_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+  return rr_transitive_table[r1][r2];\n }\n \n // Given an equivalence set EQUIV, set all the bits in B that are still valid\n@@ -311,8 +307,8 @@ equiv_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n {\n   // If the 2 ssa names share the same equiv set, they are equal.\n   if (equiv_set (ssa1, bb) == equiv_set (ssa2, bb))\n-    return EQ_EXPR;\n-  return VREL_NONE;\n+    return VREL_EQ;\n+  return VREL_VARYING;\n }\n \n // Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n@@ -323,8 +319,8 @@ equiv_oracle::query_relation (basic_block bb ATTRIBUTE_UNUSED, const_bitmap e1,\n {\n   // If the 2 ssa names share the same equiv set, they are equal.\n   if (bitmap_equal_p (e1, e2))\n-    return EQ_EXPR;\n-  return VREL_NONE;\n+    return VREL_EQ;\n+  return VREL_VARYING;\n }\n \n // If SSA has an equivalence in block BB, find and return it.\n@@ -455,7 +451,7 @@ equiv_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n \t\t\t\t tree ssa2)\n {\n   // Only handle equality relations.\n-  if (k != EQ_EXPR)\n+  if (k != VREL_EQ)\n     return;\n \n   unsigned v1 = SSA_NAME_VERSION (ssa1);\n@@ -617,7 +613,7 @@ value_relation::set_relation (relation_kind r, tree n1, tree n2)\n inline\n value_relation::value_relation ()\n {\n-  related = VREL_NONE;\n+  related = VREL_VARYING;\n   name1 = NULL_TREE;\n   name2 = NULL_TREE;\n }\n@@ -680,7 +676,7 @@ value_relation::union_ (value_relation &p)\n bool\n value_relation::apply_transitive (const value_relation &rel)\n {\n-  relation_kind k = VREL_NONE;\n+  relation_kind k = VREL_VARYING;\n \n   // Idenity any common operand, and notrmalize the relations to\n   // the form : A < B  B < C produces A < C\n@@ -690,7 +686,7 @@ value_relation::apply_transitive (const value_relation &rel)\n       if (rel.op2 () == name1)\n \treturn false;\n       k = relation_transitive (kind (), rel.kind ());\n-      if (k != VREL_NONE)\n+      if (k != VREL_VARYING)\n \t{\n \t  related = k;\n \t  name2 = rel.op2 ();\n@@ -703,7 +699,7 @@ value_relation::apply_transitive (const value_relation &rel)\n       if (rel.op2 () == name2)\n \treturn false;\n       k = relation_transitive (relation_swap (kind ()), rel.kind ());\n-      if (k != VREL_NONE)\n+      if (k != VREL_VARYING)\n \t{\n \t  related = k;\n \t  name1 = name2;\n@@ -717,7 +713,7 @@ value_relation::apply_transitive (const value_relation &rel)\n        if (rel.op1 () == name1)\n \t return false;\n       k = relation_transitive (kind (), relation_swap (rel.kind ()));\n-      if (k != VREL_NONE)\n+      if (k != VREL_VARYING)\n \t{\n \t  related = k;\n \t  name2 = rel.op1 ();\n@@ -731,7 +727,7 @@ value_relation::apply_transitive (const value_relation &rel)\n \treturn false;\n       k = relation_transitive (relation_swap (kind ()),\n \t\t\t       relation_swap (rel.kind ()));\n-      if (k != VREL_NONE)\n+      if (k != VREL_VARYING)\n \t{\n \t  related = k;\n \t  name1 = name2;\n@@ -776,11 +772,11 @@ relation_kind\n relation_chain_head::find_relation (const_bitmap b1, const_bitmap b2) const\n {\n   if (!m_names)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // If both b1 and b2 aren't referenced in thie block, cant be a relation\n   if (!bitmap_intersect_p (m_names, b1) || !bitmap_intersect_p (m_names, b2))\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // Search for the fiorst relation that contains BOTH an element from B1\n   // and B2, and return that relation.\n@@ -794,7 +790,7 @@ relation_chain_head::find_relation (const_bitmap b1, const_bitmap b2) const\n \treturn relation_swap (ptr->kind ());\n     }\n \n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // Instantiate a relation oracle.\n@@ -826,7 +822,7 @@ relation_oracle::register_stmt (gimple *stmt, relation_kind k, tree op1,\n   gcc_checking_assert (stmt && gimple_bb (stmt));\n \n   // Don't register lack of a relation.\n-  if (k == VREL_NONE)\n+  if (k == VREL_VARYING)\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -842,7 +838,7 @@ relation_oracle::register_stmt (gimple *stmt, relation_kind k, tree op1,\n   // make sure that that argument is not defined in the same block.\n   // This can happen along back edges and the equivalence will not be\n   // applicable as it would require a use before def.\n-  if (k == EQ_EXPR && is_a<gphi *> (stmt))\n+  if (k == VREL_EQ && is_a<gphi *> (stmt))\n     {\n       tree phi_def = gimple_phi_result (stmt);\n       gcc_checking_assert (phi_def == op1 || phi_def == op2);\n@@ -873,7 +869,7 @@ relation_oracle::register_edge (edge e, relation_kind k, tree op1, tree op2)\n \n   // Do not register lack of relation, or blocks which have more than\n   // edge E for a predecessor.\n-  if (k == VREL_NONE || !single_pred_p (e->dest))\n+  if (k == VREL_VARYING || !single_pred_p (e->dest))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -901,7 +897,7 @@ dom_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n     return;\n \n   // Equivalencies are handled by the equivalence oracle.\n-  if (k == EQ_EXPR)\n+  if (k == VREL_EQ)\n     equiv_oracle::register_relation (bb, k, op1, op2);\n   else\n     {\n@@ -919,7 +915,7 @@ relation_chain *\n dom_oracle::set_one_relation (basic_block bb, relation_kind k, tree op1,\n \t\t\t      tree op2)\n {\n-  gcc_checking_assert (k != VREL_NONE && k != EQ_EXPR);\n+  gcc_checking_assert (k != VREL_VARYING && k != VREL_EQ);\n \n   value_relation vr(k, op1, op2);\n   int bbi = bb->index;\n@@ -938,7 +934,7 @@ dom_oracle::set_one_relation (basic_block bb, relation_kind k, tree op1,\n   relation_chain *ptr;\n   curr = find_relation_block (bbi, v1, v2, &ptr);\n   // There is an existing relation in this block, just intersect with it.\n-  if (curr != VREL_NONE)\n+  if (curr != VREL_VARYING)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -969,7 +965,7 @@ dom_oracle::set_one_relation (basic_block bb, relation_kind k, tree op1,\n       // By including dominating relations, The first one found in any search\n       // will be the aggregate of all the previous ones.\n       curr = find_relation_dom (bb, v1, v2);\n-      if (curr != VREL_NONE)\n+      if (curr != VREL_VARYING)\n \tk = relation_intersect (curr, k);\n \n       bitmap_set_bit (bm, v1);\n@@ -999,10 +995,10 @@ dom_oracle::register_transitives (basic_block root_bb,\n   // Only apply transitives to certain kinds of operations.\n   switch (relation.kind ())\n     {\n-      case LE_EXPR:\n-      case LT_EXPR:\n-      case GT_EXPR:\n-      case GE_EXPR:\n+      case VREL_LE:\n+      case VREL_LT:\n+      case VREL_GT:\n+      case VREL_GE:\n \tbreak;\n       default:\n \treturn;\n@@ -1087,7 +1083,7 @@ dom_oracle::find_relation_block (unsigned bb, const_bitmap b1,\n \t\t\t\t      const_bitmap b2) const\n {\n   if (bb >= m_relations.length())\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   return m_relations[bb].find_relation (b1, b2);\n }\n@@ -1101,21 +1097,21 @@ dom_oracle::query_relation (basic_block bb, const_bitmap b1,\n {\n   relation_kind r;\n   if (bitmap_equal_p (b1, b2))\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   // If either name does not occur in a relation anywhere, there isnt one.\n   if (!bitmap_intersect_p (m_relation_set, b1)\n       || !bitmap_intersect_p (m_relation_set, b2))\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // Search each block in the DOM tree checking.\n   for ( ; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n       r = find_relation_block (bb->index, b1, b2);\n-      if (r != VREL_NONE)\n+      if (r != VREL_VARYING)\n \treturn r;\n     }\n-  return VREL_NONE;\n+  return VREL_VARYING;\n \n }\n \n@@ -1127,15 +1123,15 @@ dom_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n \t\t\t\t     relation_chain **obj) const\n {\n   if (bb >= (int)m_relations.length())\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   const_bitmap bm = m_relations[bb].m_names;\n   if (!bm)\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   // If both b1 and b2 aren't referenced in thie block, cant be a relation\n   if (!bitmap_bit_p (bm, v1) || !bitmap_bit_p (bm, v2))\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   relation_chain *ptr;\n   for (ptr = m_relations[bb].m_head; ptr ; ptr = ptr->m_next)\n@@ -1156,7 +1152,7 @@ dom_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n \t}\n     }\n \n-  return VREL_NONE;\n+  return VREL_VARYING;\n }\n \n // Find a relation between SSA version V1 and V2 in the dominator tree\n@@ -1168,15 +1164,15 @@ dom_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2) const\n   relation_kind r;\n   // IF either name does not occur in a relation anywhere, there isnt one.\n   if (!bitmap_bit_p (m_relation_set, v1) || !bitmap_bit_p (m_relation_set, v2))\n-    return VREL_NONE;\n+    return VREL_VARYING;\n \n   for ( ; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n       r = find_relation_block (bb->index, v1, v2);\n-      if (r != VREL_NONE)\n+      if (r != VREL_VARYING)\n \treturn r;\n     }\n-  return VREL_NONE;\n+  return VREL_VARYING;\n \n }\n \n@@ -1190,17 +1186,17 @@ dom_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   unsigned v1 = SSA_NAME_VERSION (ssa1);\n   unsigned v2 = SSA_NAME_VERSION (ssa2);\n   if (v1 == v2)\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   // Check for equivalence first.  They must be in each equivalency set.\n   const_bitmap equiv1 = equiv_set (ssa1, bb);\n   const_bitmap equiv2 = equiv_set (ssa2, bb);\n   if (bitmap_bit_p (equiv1, v2) && bitmap_bit_p (equiv2, v1))\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   // Initially look for a direct relationship and just return that.\n   kind = find_relation_dom (bb, v1, v2);\n-  if (kind != VREL_NONE)\n+  if (kind != VREL_VARYING)\n     return kind;\n \n   // Query using the equiovalence sets.\n@@ -1388,14 +1384,14 @@ path_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n       fprintf (dump_file, \" (root: bb%d)\\n\", bb->index);\n     }\n \n-  if (k == EQ_EXPR)\n+  if (k == VREL_EQ)\n     {\n       register_equiv (bb, ssa1, ssa2);\n       return;\n     }\n \n   relation_kind curr = query_relation (bb, ssa1, ssa2);\n-  if (curr != VREL_NONE)\n+  if (curr != VREL_VARYING)\n     k = relation_intersect (curr, k);\n \n   bitmap_set_bit (m_relations.m_names, SSA_NAME_VERSION (ssa1));\n@@ -1414,7 +1410,7 @@ relation_kind\n path_oracle::query_relation (basic_block bb, const_bitmap b1, const_bitmap b2)\n {\n   if (bitmap_equal_p (b1, b2))\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   relation_kind k = m_relations.find_relation (b1, b2);\n \n@@ -1424,7 +1420,7 @@ path_oracle::query_relation (basic_block bb, const_bitmap b1, const_bitmap b2)\n       || bitmap_intersect_p (m_killed_defs, b2))\n     return k;\n \n-  if (k == VREL_NONE && m_root)\n+  if (k == VREL_VARYING && m_root)\n     k = m_root->query_relation (bb, b1, b2);\n \n   return k;\n@@ -1440,12 +1436,12 @@ path_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   unsigned v2 = SSA_NAME_VERSION (ssa2);\n \n   if (v1 == v2)\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   const_bitmap equiv_1 = equiv_set (ssa1, bb);\n   const_bitmap equiv_2 = equiv_set (ssa2, bb);\n   if (bitmap_bit_p (equiv_1, v2) && bitmap_bit_p (equiv_2, v1))\n-    return EQ_EXPR;\n+    return VREL_EQ;\n \n   return query_relation (bb, equiv_1, equiv_2);\n }"}, {"sha": "19762d8ce2b764f2e95c28540f0e6b44e7445c8d", "filename": "gcc/value-relation.h", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade5531c9dde98c7be005a5c5382739d734797aa/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=ade5531c9dde98c7be005a5c5382739d734797aa", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n // The general range_query object provided in value-query.h provides\n // access to an oracle, if one is available, via the oracle() method.\n // Thre are also a couple of access routines provided, which even if there is\n-// no oracle, will return the default VREL_NONE no relation.\n+// no oracle, will return the default VREL_VARYING no relation.\n //\n // Typically, when a ranger object is active, there will be an oracle, and\n // any information available can be directly queried.  Ranger also sets and\n@@ -43,8 +43,8 @@ along with GCC; see the file COPYING3.  If not see\n // block, or on an edge, the possible return values are:\n //\n //  EQ_EXPR, NE_EXPR, LT_EXPR, LE_EXPR, GT_EXPR, and GE_EXPR mean the same.\n-//  VREL_NONE : No relation between the 2 names.\n-//  VREL_EMPTY : Impossible relation (ie, A < B && A > B produces VREL_EMPTY.\n+//  VREL_VARYING : No relation between the 2 names.\n+//  VREL_UNDEFINED : Impossible relation (ie, A < B && A > B)\n //\n // The oracle maintains EQ_EXPR relations with equivalency sets, so if a\n // relation comes back EQ_EXPR, it is also possible to query the set of\n@@ -58,13 +58,20 @@ along with GCC; see the file COPYING3.  If not see\n \n // Rather than introduce a new enumerated type for relations, we can use the\n // existing tree_codes for relations, plus add a couple of #defines for\n-// the other cases.  These codes are arranged such that VREL_NONE is the first\n-// code, and all the rest are contiguous.\n+// the other cases.  These codes are arranged such that VREL_VARYING is the\n+// first code, and all the rest are contiguous.\n \n-typedef enum tree_code relation_kind;\n-\n-#define VREL_NONE\t\tTRUTH_NOT_EXPR\n-#define VREL_EMPTY\t\tLTGT_EXPR\n+typedef enum relation_kind_t\n+{\n+  VREL_VARYING = 0,\t// No known relation,  AKA varying.\n+  VREL_UNDEFINED,\t// Impossible relation, ie (r1 < r2) && (r2 > r1)\n+  VREL_LT,\t\t// r1 < r2\n+  VREL_LE,\t\t// r1 <= r2\n+  VREL_GT,\t\t// r1 > r2\n+  VREL_GE,\t\t// r1 >= r2\n+  VREL_EQ,\t\t// r1 == r2\n+  VREL_NE\t\t// r1 != r2\n+} relation_kind;\n \n // General relation kind transformations.\n relation_kind relation_union (relation_kind r1, relation_kind r2);\n@@ -73,7 +80,6 @@ relation_kind relation_negate (relation_kind r);\n relation_kind relation_swap (relation_kind r);\n void print_relation (FILE *f, relation_kind rel);\n \n-\n class relation_oracle\n {\n public:"}]}