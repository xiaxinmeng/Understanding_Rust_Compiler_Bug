{"sha": "28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhmNGE0YTg1ZjNiOTVmN2NjZjc1ODVlYWE1Y2JkNTBjYmUxNjc3ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-10-31T11:57:10Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-10-31T11:57:10Z"}, "message": "GCOV: introduce usage of terminal colors.\n\n2017-10-31  Martin Liska  <mliska@suse.cz>\n\n\t* color-macros.h: New file.\n\t* diagnostic-color.c: Factor out color related to macros to\n\tcolor-macros.h.\n\t* doc/gcov.texi: Document -k option.\n\t* gcov.c (INCLUDE_STRING): Include string.h.\n\t(print_usage): Add -k option.\n\t(process_args): Parse it.\n\t(pad_count_string): New function.\n\t(output_line_beginning): Likewise.\n\t(DEFAULT_LINE_START): New macro.\n\t(output_lines): Support color output.\n\nFrom-SVN: r254258", "tree": {"sha": "1cf4d862d50b7877bf04bb3a8fec394f9b192782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf4d862d50b7877bf04bb3a8fec394f9b192782"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00da60d4def3782039bef86fbdf07fd620d8b57a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00da60d4def3782039bef86fbdf07fd620d8b57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00da60d4def3782039bef86fbdf07fd620d8b57a"}], "stats": {"total": 321, "additions": 220, "deletions": 101}, "files": [{"sha": "b1d984ad0c7a019036d0efd4e8ab473ebb55b4e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "patch": "@@ -1,3 +1,17 @@\n+2017-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* color-macros.h: New file.\n+\t* diagnostic-color.c: Factor out color related to macros to\n+\tcolor-macros.h.\n+\t* doc/gcov.texi: Document -k option.\n+\t* gcov.c (INCLUDE_STRING): Include string.h.\n+\t(print_usage): Add -k option.\n+\t(process_args): Parse it.\n+\t(pad_count_string): New function.\n+\t(output_line_beginning): Likewise.\n+\t(DEFAULT_LINE_START): New macro.\n+\t(output_lines): Support color output.\n+\n 2017-10-31  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/82633"}, {"sha": "37ed4d197cfa5dec66190d6f60a0f17f1c94bef6", "filename": "gcc/color-macros.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fcolor-macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fcolor-macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcolor-macros.h?ref=28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "patch": "@@ -0,0 +1,108 @@\n+/* Terminal color manipulation macros.\n+   Copyright (C) 2005-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_COLOR_MACROS_H\n+#define GCC_COLOR_MACROS_H\n+\n+/* Select Graphic Rendition (SGR, \"\\33[...m\") strings.  */\n+/* Also Erase in Line (EL) to Right (\"\\33[K\") by default.  */\n+/*    Why have EL to Right after SGR?\n+\t -- The behavior of line-wrapping when at the bottom of the\n+\t    terminal screen and at the end of the current line is often\n+\t    such that a new line is introduced, entirely cleared with\n+\t    the current background color which may be different from the\n+\t    default one (see the boolean back_color_erase terminfo(5)\n+\t    capability), thus scrolling the display by one line.\n+\t    The end of this new line will stay in this background color\n+\t    even after reverting to the default background color with\n+\t    \"\\33[m', unless it is explicitly cleared again with \"\\33[K\"\n+\t    (which is the behavior the user would instinctively expect\n+\t    from the whole thing).  There may be some unavoidable\n+\t    background-color flicker at the end of this new line because\n+\t    of this (when timing with the monitor's redraw is just right).\n+\t -- The behavior of HT (tab, \"\\t\") is usually the same as that of\n+\t    Cursor Forward Tabulation (CHT) with a default parameter\n+\t    of 1 (\"\\33[I\"), i.e., it performs pure movement to the next\n+\t    tab stop, without any clearing of either content or screen\n+\t    attributes (including background color); try\n+\t       printf 'asdfqwerzxcv\\rASDF\\tZXCV\\n'\n+\t    in a bash(1) shell to demonstrate this.  This is not what the\n+\t    user would instinctively expect of HT (but is ok for CHT).\n+\t    The instinctive behavior would include clearing the terminal\n+\t    cells that are skipped over by HT with blank cells in the\n+\t    current screen attributes, including background color;\n+\t    the boolean dest_tabs_magic_smso terminfo(5) capability\n+\t    indicates this saner behavior for HT, but only some rare\n+\t    terminals have it (although it also indicates a special\n+\t    glitch with standout mode in the Teleray terminal for which\n+\t    it was initially introduced).  The remedy is to add \"\\33K\"\n+\t    after each SGR sequence, be it START (to fix the behavior\n+\t    of any HT after that before another SGR) or END (to fix the\n+\t    behavior of an HT in default background color that would\n+\t    follow a line-wrapping at the bottom of the screen in another\n+\t    background color, and to complement doing it after START).\n+\t    Piping GCC's output through a pager such as less(1) avoids\n+\t    any HT problems since the pager performs tab expansion.\n+\n+      Generic disadvantages of this remedy are:\n+\t -- Some very rare terminals might support SGR but not EL (nobody\n+\t    will use \"gcc -fdiagnostics-color\" on a terminal that does not\n+\t    support SGR in the first place).\n+\t -- Having these extra control sequences might somewhat complicate\n+\t    the task of any program trying to parse \"gcc -fdiagnostics-color\"\n+\t    output in order to extract structuring information from it.\n+      A specific disadvantage to doing it after SGR START is:\n+\t -- Even more possible background color flicker (when timing\n+\t    with the monitor's redraw is just right), even when not at the\n+\t    bottom of the screen.\n+      There are no additional disadvantages specific to doing it after\n+      SGR END.\n+\n+      It would be impractical for GCC to become a full-fledged\n+      terminal program linked against ncurses or the like, so it will\n+      not detect terminfo(5) capabilities.  */\n+\n+#define COLOR_SEPARATOR\t\t\";\"\n+#define COLOR_NONE\t\t\"00\"\n+#define COLOR_BOLD\t\t\"01\"\n+#define COLOR_UNDERSCORE\t\"04\"\n+#define COLOR_BLINK\t\t\"05\"\n+#define COLOR_REVERSE\t\t\"07\"\n+#define COLOR_FG_BLACK\t\t\"30\"\n+#define COLOR_FG_RED\t\t\"31\"\n+#define COLOR_FG_GREEN\t\t\"32\"\n+#define COLOR_FG_YELLOW\t\t\"33\"\n+#define COLOR_FG_BLUE\t\t\"34\"\n+#define COLOR_FG_MAGENTA\t\"35\"\n+#define COLOR_FG_CYAN\t\t\"36\"\n+#define COLOR_FG_WHITE\t\t\"37\"\n+#define COLOR_BG_BLACK\t\t\"40\"\n+#define COLOR_BG_RED\t\t\"41\"\n+#define COLOR_BG_GREEN\t\t\"42\"\n+#define COLOR_BG_YELLOW\t\t\"43\"\n+#define COLOR_BG_BLUE\t\t\"44\"\n+#define COLOR_BG_MAGENTA\t\"45\"\n+#define COLOR_BG_CYAN\t\t\"46\"\n+#define COLOR_BG_WHITE\t\t\"47\"\n+#define SGR_START\t\t\"\\33[\"\n+#define SGR_END\t\t\t\"m\\33[K\"\n+#define SGR_SEQ(str)\t\tSGR_START str SGR_END\n+#define SGR_RESET\t\tSGR_SEQ(\"\")\n+\n+#endif  /* GCC_COLOR_MACROS_H */"}, {"sha": "ccbae4ba22363172f0842f6cf25600717d731cc7", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 1, "deletions": 84, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "patch": "@@ -24,90 +24,7 @@\n #  include <windows.h>\n #endif\n \n-/* Select Graphic Rendition (SGR, \"\\33[...m\") strings.  */\n-/* Also Erase in Line (EL) to Right (\"\\33[K\") by default.  */\n-/*    Why have EL to Right after SGR?\n-\t -- The behavior of line-wrapping when at the bottom of the\n-\t    terminal screen and at the end of the current line is often\n-\t    such that a new line is introduced, entirely cleared with\n-\t    the current background color which may be different from the\n-\t    default one (see the boolean back_color_erase terminfo(5)\n-\t    capability), thus scrolling the display by one line.\n-\t    The end of this new line will stay in this background color\n-\t    even after reverting to the default background color with\n-\t    \"\\33[m', unless it is explicitly cleared again with \"\\33[K\"\n-\t    (which is the behavior the user would instinctively expect\n-\t    from the whole thing).  There may be some unavoidable\n-\t    background-color flicker at the end of this new line because\n-\t    of this (when timing with the monitor's redraw is just right).\n-\t -- The behavior of HT (tab, \"\\t\") is usually the same as that of\n-\t    Cursor Forward Tabulation (CHT) with a default parameter\n-\t    of 1 (\"\\33[I\"), i.e., it performs pure movement to the next\n-\t    tab stop, without any clearing of either content or screen\n-\t    attributes (including background color); try\n-\t       printf 'asdfqwerzxcv\\rASDF\\tZXCV\\n'\n-\t    in a bash(1) shell to demonstrate this.  This is not what the\n-\t    user would instinctively expect of HT (but is ok for CHT).\n-\t    The instinctive behavior would include clearing the terminal\n-\t    cells that are skipped over by HT with blank cells in the\n-\t    current screen attributes, including background color;\n-\t    the boolean dest_tabs_magic_smso terminfo(5) capability\n-\t    indicates this saner behavior for HT, but only some rare\n-\t    terminals have it (although it also indicates a special\n-\t    glitch with standout mode in the Teleray terminal for which\n-\t    it was initially introduced).  The remedy is to add \"\\33K\"\n-\t    after each SGR sequence, be it START (to fix the behavior\n-\t    of any HT after that before another SGR) or END (to fix the\n-\t    behavior of an HT in default background color that would\n-\t    follow a line-wrapping at the bottom of the screen in another\n-\t    background color, and to complement doing it after START).\n-\t    Piping GCC's output through a pager such as less(1) avoids\n-\t    any HT problems since the pager performs tab expansion.\n-\n-      Generic disadvantages of this remedy are:\n-\t -- Some very rare terminals might support SGR but not EL (nobody\n-\t    will use \"gcc -fdiagnostics-color\" on a terminal that does not\n-\t    support SGR in the first place).\n-\t -- Having these extra control sequences might somewhat complicate\n-\t    the task of any program trying to parse \"gcc -fdiagnostics-color\"\n-\t    output in order to extract structuring information from it.\n-      A specific disadvantage to doing it after SGR START is:\n-\t -- Even more possible background color flicker (when timing\n-\t    with the monitor's redraw is just right), even when not at the\n-\t    bottom of the screen.\n-      There are no additional disadvantages specific to doing it after\n-      SGR END.\n-\n-      It would be impractical for GCC to become a full-fledged\n-      terminal program linked against ncurses or the like, so it will\n-      not detect terminfo(5) capabilities.  */\n-#define COLOR_SEPARATOR\t\t\";\"\n-#define COLOR_NONE\t\t\"00\"\n-#define COLOR_BOLD\t\t\"01\"\n-#define COLOR_UNDERSCORE\t\"04\"\n-#define COLOR_BLINK\t\t\"05\"\n-#define COLOR_REVERSE\t\t\"07\"\n-#define COLOR_FG_BLACK\t\t\"30\"\n-#define COLOR_FG_RED\t\t\"31\"\n-#define COLOR_FG_GREEN\t\t\"32\"\n-#define COLOR_FG_YELLOW\t\t\"33\"\n-#define COLOR_FG_BLUE\t\t\"34\"\n-#define COLOR_FG_MAGENTA\t\"35\"\n-#define COLOR_FG_CYAN\t\t\"36\"\n-#define COLOR_FG_WHITE\t\t\"37\"\n-#define COLOR_BG_BLACK\t\t\"40\"\n-#define COLOR_BG_RED\t\t\"41\"\n-#define COLOR_BG_GREEN\t\t\"42\"\n-#define COLOR_BG_YELLOW\t\t\"43\"\n-#define COLOR_BG_BLUE\t\t\"44\"\n-#define COLOR_BG_MAGENTA\t\"45\"\n-#define COLOR_BG_CYAN\t\t\"46\"\n-#define COLOR_BG_WHITE\t\t\"47\"\n-#define SGR_START\t\t\"\\33[\"\n-#define SGR_END\t\t\t\"m\\33[K\"\n-#define SGR_SEQ(str)\t\tSGR_START str SGR_END\n-#define SGR_RESET\t\tSGR_SEQ(\"\")\n-\n+#include \"color-macros.h\"\n \n /* The context and logic for choosing default --color screen attributes\n    (foreground and background colors, etc.) are the following."}, {"sha": "9abc6030c2144b6e708bb2bd7f3dd377b4f2cd72", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "patch": "@@ -125,6 +125,7 @@ gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n      [@option{-d}|@option{--display-progress}]\n      [@option{-f}|@option{--function-summaries}]\n      [@option{-i}|@option{--intermediate-format}]\n+     [@option{-k}|@option{--use-colors}]\n      [@option{-l}|@option{--long-file-names}]\n      [@option{-m}|@option{--demangled-names}]\n      [@option{-n}|@option{--no-output}]\n@@ -215,6 +216,14 @@ lcount:26,1\n branch:28,nottaken\n @end smallexample\n \n+@item -k\n+@itemx --use-colors\n+\n+Use colors for lines of code that have zero coverage.  We use red color for\n+non-exceptional lines and cyan for exceptional.  Same colors are used for\n+basic blocks with @option{-a} option.\n+\n+\n @item -l\n @itemx --long-file-names\n Create long file names for included source files.  For example, if the"}, {"sha": "e53bcf0fd88ee57f3c37f18e350e8994ce6ad5fc", "filename": "gcc/gcov.c", "status": "modified", "additions": 88, "deletions": 17, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=28f4a4a85f3b95f7ccf7585eaa5cbd50cbe1677d", "patch": "@@ -33,13 +33,15 @@ along with Gcov; see the file COPYING3.  If not see\n #include \"config.h\"\n #define INCLUDE_ALGORITHM\n #define INCLUDE_VECTOR\n+#define INCLUDE_STRING\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n #include \"version.h\"\n #include \"demangle.h\"\n+#include \"color-macros.h\"\n \n #include <getopt.h>\n \n@@ -381,6 +383,10 @@ static int flag_hash_filenames = 0;\n \n static int flag_verbose = 0;\n \n+/* Print colored output.  */\n+\n+static int flag_use_colors = 0;\n+\n /* Output count information for every basic block, not merely those\n    that contain line number information.  */\n \n@@ -703,6 +709,7 @@ print_usage (int error_p)\n   fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n   fnotice (file, \"  -i, --intermediate-format       Output .gcov file in intermediate text format\\n\");\n+  fnotice (file, \"  -k, --use-colors                Emit colored output\\n\");\n   fnotice (file, \"  -l, --long-file-names           Use long output file names for included\\n\\\n                                     source files\\n\");\n   fnotice (file, \"  -m, --demangled-names           Output demangled function names\\n\");\n@@ -756,6 +763,7 @@ static const struct option options[] =\n   { \"unconditional-branches\", no_argument,     NULL, 'u' },\n   { \"display-progress\",     no_argument,       NULL, 'd' },\n   { \"hash-filenames\",\t    no_argument,       NULL, 'x' },\n+  { \"use-colors\",\t    no_argument,       NULL, 'k' },\n   { 0, 0, 0, 0 }\n };\n \n@@ -766,7 +774,7 @@ process_args (int argc, char **argv)\n {\n   int opt;\n \n-  const char *opts = \"abcdfhilmno:prs:uvwx\";\n+  const char *opts = \"abcdfhiklmno:prs:uvwx\";\n   while ((opt = getopt_long (argc, argv, opts, options, NULL)) != -1)\n     {\n       switch (opt)\n@@ -789,6 +797,9 @@ process_args (int argc, char **argv)\n \tcase 'l':\n \t  flag_long_names = 1;\n \t  break;\n+\tcase 'k':\n+\t  flag_use_colors = 1;\n+\t  break;\n \tcase 'm':\n \t  flag_demangled_names = 1;\n \t  break;\n@@ -2468,28 +2479,89 @@ read_line (FILE *file)\n   return pos ? string : NULL;\n }\n \n+/* Pad string S with spaces from left to have total width equal to 9.  */\n+\n+static void\n+pad_count_string (string &s)\n+{\n+  if (s.size () < 9)\n+    s.insert (0, 9 - s.size (), ' ');\n+}\n+\n+/* Print GCOV line beginning to F stream.  If EXISTS is set to true, the\n+   line exists in source file.  UNEXCEPTIONAL indicated that it's not in\n+   an exceptional statement.  The output is printed for LINE_NUM of given\n+   COUNT of executions.  EXCEPTIONAL_STRING and UNEXCEPTIONAL_STRING are\n+   used to indicate non-executed blocks.  */\n+\n+static void\n+output_line_beginning (FILE *f, bool exists, bool unexceptional,\n+\t\t       gcov_type count, unsigned line_num,\n+\t\t       const char *exceptional_string,\n+\t\t       const char *unexceptional_string)\n+{\n+  string s;\n+  if (exists)\n+    {\n+      if (count > 0)\n+\t{\n+\t  s = format_gcov (count, 0, -1);\n+\t  pad_count_string (s);\n+\t}\n+      else\n+\t{\n+\t  if (flag_use_colors)\n+\t    {\n+\t      s = \"0\";\n+\t      pad_count_string (s);\n+\t      if (unexceptional)\n+\t\ts.insert (0, SGR_SEQ (COLOR_BG_RED\n+\t\t\t\t      COLOR_SEPARATOR COLOR_FG_WHITE));\n+\t      else\n+\t\ts.insert (0, SGR_SEQ (COLOR_BG_CYAN\n+\t\t\t\t      COLOR_SEPARATOR COLOR_FG_WHITE));\n+\t      s += SGR_RESET;\n+\t    }\n+\t  else\n+\t    {\n+\t      s = unexceptional ? unexceptional_string : exceptional_string;\n+\t      pad_count_string (s);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      s = \"-\";\n+      pad_count_string (s);\n+    }\n+\n+  fprintf (f, \"%s:%5u\", s.c_str (), line_num);\n+}\n+\n /* Read in the source file one line at a time, and output that line to\n    the gcov file preceded by its execution count and other\n    information.  */\n \n static void\n output_lines (FILE *gcov_file, const source_t *src)\n {\n+#define  DEFAULT_LINE_START \"        -:    0:\"\n+\n   FILE *source_file;\n   unsigned line_num;\t/* current line number.  */\n   const line_t *line;           /* current line info ptr.  */\n   const char *retval = \"\";\t/* status of source file reading.  */\n   function_t *fn = NULL;\n \n-  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, src->coverage.name);\n+  fprintf (gcov_file, DEFAULT_LINE_START \"Source:%s\\n\", src->coverage.name);\n   if (!multiple_files)\n     {\n-      fprintf (gcov_file, \"%9s:%5d:Graph:%s\\n\", \"-\", 0, bbg_file_name);\n-      fprintf (gcov_file, \"%9s:%5d:Data:%s\\n\", \"-\", 0,\n+      fprintf (gcov_file, DEFAULT_LINE_START \"Graph:%s\\n\", bbg_file_name);\n+      fprintf (gcov_file, DEFAULT_LINE_START \"Data:%s\\n\",\n \t       no_data_file ? \"-\" : da_file_name);\n-      fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0, object_runs);\n+      fprintf (gcov_file, DEFAULT_LINE_START \"Runs:%u\\n\", object_runs);\n     }\n-  fprintf (gcov_file, \"%9s:%5d:Programs:%u\\n\", \"-\", 0, program_count);\n+  fprintf (gcov_file, DEFAULT_LINE_START \"Programs:%u\\n\", program_count);\n \n   source_file = fopen (src->name, \"r\");\n   if (!source_file)\n@@ -2498,7 +2570,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n       retval = NULL;\n     }\n   else if (src->file_time == 0)\n-    fprintf (gcov_file, \"%9s:%5d:Source is newer than graph\\n\", \"-\", 0);\n+    fprintf (gcov_file, DEFAULT_LINE_START \"Source is newer than graph\\n\");\n \n   if (flag_branches)\n     fn = src->functions;\n@@ -2537,11 +2609,10 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t Otherwise, print the execution count before the source line.\n \t There are 16 spaces of indentation added before the source\n \t line so that tabs won't be messed up.  */\n-      fprintf (gcov_file, \"%9s:%5u:%s\\n\",\n-\t       !line->exists ? \"-\" : line->count\n-\t       ? format_gcov (line->count, 0, -1)\n-\t       : line->unexceptional ? \"#####\" : \"=====\", line_num,\n-\t       retval ? retval : \"/*EOF*/\");\n+      output_line_beginning (gcov_file, line->exists, line->unexceptional,\n+\t\t\t     line->count, line_num,\n+\t\t\t     \"=====\", \"#####\");\n+      fprintf (gcov_file, \":%s\\n\", retval ? retval : \"/*EOF*/\");\n \n       if (flag_all_blocks)\n \t{\n@@ -2554,11 +2625,11 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t    {\n \t      if (!block->is_call_return)\n \t\t{\n-\t\t  fprintf (gcov_file, \"%9s:%5u-block %2d\",\n-\t\t\t   !line->exists ? \"-\" : block->count\n-\t\t\t   ? format_gcov (block->count, 0, -1)\n-\t\t\t   : block->exceptional ? \"%%%%%\" : \"$$$$$\",\n-\t\t\t   line_num, ix++);\n+\t\t  output_line_beginning (gcov_file, line->exists,\n+\t\t\t\t\t block->exceptional,\n+\t\t\t\t\t block->count, line_num,\n+\t\t\t\t\t \"%%%%%\", \"$$$$$\");\n+\t\t  fprintf (gcov_file, \"-block %2d\", ix++);\n \t\t  if (flag_verbose)\n \t\t    fprintf (gcov_file, \" (BB %u)\", block->id);\n \t\t  fprintf (gcov_file, \"\\n\");"}]}