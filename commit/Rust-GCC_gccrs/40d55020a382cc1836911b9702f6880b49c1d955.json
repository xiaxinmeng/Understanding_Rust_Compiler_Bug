{"sha": "40d55020a382cc1836911b9702f6880b49c1d955", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBkNTUwMjBhMzgyY2MxODM2OTExYjk3MDJmNjg4MGI0OWMxZDk1NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-29T17:15:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-29T17:15:06Z"}, "message": "re PR c++/49554 ([C++0x] lambda capture causes \"cannot call member function ... without object\")\n\n\tPR c++/49554\n\t* semantics.c (lambda_proxy_type): New.\n\t(build_capture_proxy): Use it.\n\t* cp-tree.h (DECLTYPE_FOR_LAMBDA_PROXY): New.\n\t* pt.c (tsubst) [DECLTYPE_TYPE]: Use them.\n\nFrom-SVN: r175657", "tree": {"sha": "24938062efd7fb502da82065526a9b3c36fe7213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24938062efd7fb502da82065526a9b3c36fe7213"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40d55020a382cc1836911b9702f6880b49c1d955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d55020a382cc1836911b9702f6880b49c1d955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40d55020a382cc1836911b9702f6880b49c1d955", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d55020a382cc1836911b9702f6880b49c1d955/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de95483d1e787c73bf1c84e47254bdab4f839762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de95483d1e787c73bf1c84e47254bdab4f839762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de95483d1e787c73bf1c84e47254bdab4f839762"}], "stats": {"total": 74, "additions": 71, "deletions": 3}, "files": [{"sha": "083d5459662559e91a01e9ce9d3f53200d61f8c2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -1,5 +1,11 @@\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/49554\n+\t* semantics.c (lambda_proxy_type): New.\n+\t(build_capture_proxy): Use it.\n+\t* cp-tree.h (DECLTYPE_FOR_LAMBDA_PROXY): New.\n+\t* pt.c (tsubst) [DECLTYPE_TYPE]: Use them.\n+\n \tPR c++/45923\n \t* class.c (explain_non_literal_class): New.\n \t(finalize_literal_type_property): Call it."}, {"sha": "55c88e384821af0afea98dc1ddb7993c7ea3149e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -3418,11 +3418,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* These flags indicate that we want different semantics from normal\n    decltype: lambda capture just drops references, lambda return also does\n-   type decay.  */\n+   type decay, lambda proxies look through implicit dereference.  */\n #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \\\n   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))\n #define DECLTYPE_FOR_LAMBDA_RETURN(NODE) \\\n   TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))\n+#define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \\\n+  TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))\n \n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  This can also be set for an\n@@ -5455,6 +5457,7 @@ extern tree build_lambda_object\t\t\t(tree);\n extern tree begin_lambda_type                   (tree);\n extern tree lambda_capture_field_type\t\t(tree);\n extern tree lambda_return_type\t\t\t(tree);\n+extern tree lambda_proxy_type\t\t\t(tree);\n extern tree lambda_function\t\t\t(tree);\n extern void apply_lambda_return_type            (tree, tree);\n extern tree add_capture                         (tree, tree, tree, bool, bool);"}, {"sha": "d1d8336b1bd747d52c1721b1d7ca41ca0a8b9d70", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -11108,6 +11108,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  type = lambda_capture_field_type (type);\n \telse if (DECLTYPE_FOR_LAMBDA_RETURN (t))\n \t  type = lambda_return_type (type);\n+\telse if (DECLTYPE_FOR_LAMBDA_PROXY (t))\n+\t  type = lambda_proxy_type (type);\n \telse\n \t  type = finish_decltype_type\n \t    (type, DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t), complain);"}, {"sha": "fb984d4799a5dbe4e224e657b626e541d5657a73", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -8489,14 +8489,35 @@ insert_pending_capture_proxies (void)\n   LAMBDA_EXPR_PENDING_PROXIES (lam) = NULL;\n }\n \n+/* Given REF, a COMPONENT_REF designating a field in the lambda closure,\n+   return the type we want the proxy to have: the type of the field itself,\n+   with added const-qualification if the lambda isn't mutable and the\n+   capture is by value.  */\n+\n+tree\n+lambda_proxy_type (tree ref)\n+{\n+  tree type;\n+  if (REFERENCE_REF_P (ref))\n+    ref = TREE_OPERAND (ref, 0);\n+  type = TREE_TYPE (ref);\n+  if (!dependent_type_p (type))\n+    return type;\n+  type = cxx_make_type (DECLTYPE_TYPE);\n+  DECLTYPE_TYPE_EXPR (type) = ref;\n+  DECLTYPE_FOR_LAMBDA_PROXY (type) = true;\n+  SET_TYPE_STRUCTURAL_EQUALITY (type);\n+  return type;\n+}\n+\n /* MEMBER is a capture field in a lambda closure class.  Now that we're\n    inside the operator(), build a placeholder var for future lookups and\n    debugging.  */\n \n tree\n build_capture_proxy (tree member)\n {\n-  tree var, object, fn, closure, name, lam;\n+  tree var, object, fn, closure, name, lam, type;\n \n   closure = DECL_CONTEXT (member);\n   fn = lambda_function (closure);\n@@ -8511,7 +8532,8 @@ build_capture_proxy (tree member)\n   /* Remove the __ inserted by add_capture.  */\n   name = get_identifier (IDENTIFIER_POINTER (DECL_NAME (member)) + 2);\n \n-  var = build_decl (input_location, VAR_DECL, name, TREE_TYPE (object));\n+  type = lambda_proxy_type (object);\n+  var = build_decl (input_location, VAR_DECL, name, type);\n   SET_DECL_VALUE_EXPR (var, object);\n   DECL_HAS_VALUE_EXPR_P (var) = 1;\n   DECL_ARTIFICIAL (var) = 1;"}, {"sha": "522c41cac6bdb03e37e59a5118b94151d9dd3749", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -1,5 +1,7 @@\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/lambda/lambda-template3.C: New.\n+\n \tPR c++/45923\n \t* g++.dg/cpp0x/constexpr-diag3.C: New.\n \t* g++.dg/cpp0x/constexpr-diag1.C: Adjust error message."}, {"sha": "fd6f1d3192f05c335782ba77b369f05d610b461d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template3.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d55020a382cc1836911b9702f6880b49c1d955/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template3.C?ref=40d55020a382cc1836911b9702f6880b49c1d955", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/49554\n+// { dg-options -std=c++0x }\n+\n+template<typename T>\n+  struct base\n+  {\n+    struct iterator { };\n+\n+    iterator begin();\n+  };\n+\n+template<typename T>\n+class flist : public base<T>\n+{\n+  typedef base<T> Base;\n+\n+  typedef typename Base::iterator Base_iterator;\n+public:\n+\n+  void\n+  resize()\n+  {\n+    Base_iterator b = Base::begin();\n+\n+    [b](int i) { return i; };\n+  }\n+};\n+\n+void test01()\n+{\n+  flist<int> fl;\n+  fl.resize();\n+}"}]}