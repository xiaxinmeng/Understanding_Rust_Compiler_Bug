{"sha": "8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4MzMwYjdlZjVhYWQyODYwY2M1NTMzYTE0MGZjNmUxZmQzNzkzYg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2016-08-02T16:07:36Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2016-08-02T16:07:36Z"}, "message": "re PR rtl-optimization/69847 (Spec 2006 403.gcc slows down with -mlra vs. reload on PowerPC)\n\n2016-08-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/69847\n\t* lra-int.h (struct lra-reg): Use restore_rtx instead of\n\trestore_regno.\n\t(lra_rtx_hash): New.\n\t* lra.c (initialize_lra_reg_info_element): Use restore_rtx instead\n\tof restore_regno.\n\t(lra_rtx_hash): Rename and move lra-remat.c::rtx_hash.\n\t* lra-remat.c (rtx_hash): Rename and Move to lra.c.\n\t* lra-spills.c (lra_final_code_change): Don't delete insn when the\n\tnext insn is USE with the same reg as the current insn source.\n\t* lra-constraints.c (curr_insn_transform): Use restore_rtx instead\n\tof restore_regno.\n\t(lra_constraints_init): Call initiate_invariants.\n\t(lra_constraints_finish): Call finish_invariants.\n\t(struct invariant, invariant_t, invariant_ptr_t): New.\n\t(const_invariant_ptr_t, invariants, invariants_pool): New.\n\t(invariant_table, invariant_hash, invariant_eq_p): New.\n\t(insert_invariant, initiate_invariants, finish_invariants): New.\n\t(clear_invariants, invalid_invariant_regs): New.\n\t(inherit_reload_reg, split_reg, fix_bb_live_info): Use restore_rtx\n\tinstead of restore_regno.\n\t(invariant_p, process_invariant_for_inheritance): New.\n\t(inherit_in_ebb): Implement invariant inheritance.\n\t(lra_inheritance): Initialize and finalize invalid_invariant_regs.\n\t(remove_inheritance_pseudos): Implement undoing invariant\n\tinheritance.\n\t(undo_optional_reloads, lra_undo_inheritance): Use restore_rtx\n\tinstead of restore_regno.\n\t* lra-assigns.c (regno_live_length): New.\n\t(reload_pseudo_compare_func): Use regno_live_length.\n\t(assign_by_spills): Use restore_rtx instead of restore_regno.\n\t(lra_assign): Ditto.  Initiate regno_live_length.\n\nFrom-SVN: r238991", "tree": {"sha": "7c2848d5a635da4f8a9ad968219e25a2afa416ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c2848d5a635da4f8a9ad968219e25a2afa416ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "354c5470d8fca735c82165530beae642ed78feb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354c5470d8fca735c82165530beae642ed78feb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354c5470d8fca735c82165530beae642ed78feb0"}], "stats": {"total": 695, "additions": 533, "deletions": 162}, "files": [{"sha": "a5fe1d5cf319d6111fb2069a1a66b07bdd79619d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -1,3 +1,38 @@\n+2016-08-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/69847\n+\t* lra-int.h (struct lra-reg): Use restore_rtx instead of\n+\trestore_regno.\n+\t(lra_rtx_hash): New.\n+\t* lra.c (initialize_lra_reg_info_element): Use restore_rtx instead\n+\tof restore_regno.\n+\t(lra_rtx_hash): Rename and move lra-remat.c::rtx_hash.\n+\t* lra-remat.c (rtx_hash): Rename and Move to lra.c.\n+\t* lra-spills.c (lra_final_code_change): Don't delete insn when the\n+\tnext insn is USE with the same reg as the current insn source.\n+\t* lra-constraints.c (curr_insn_transform): Use restore_rtx instead\n+\tof restore_regno.\n+\t(lra_constraints_init): Call initiate_invariants.\n+\t(lra_constraints_finish): Call finish_invariants.\n+\t(struct invariant, invariant_t, invariant_ptr_t): New.\n+\t(const_invariant_ptr_t, invariants, invariants_pool): New.\n+\t(invariant_table, invariant_hash, invariant_eq_p): New.\n+\t(insert_invariant, initiate_invariants, finish_invariants): New.\n+\t(clear_invariants, invalid_invariant_regs): New.\n+\t(inherit_reload_reg, split_reg, fix_bb_live_info): Use restore_rtx\n+\tinstead of restore_regno.\n+\t(invariant_p, process_invariant_for_inheritance): New.\n+\t(inherit_in_ebb): Implement invariant inheritance.\n+\t(lra_inheritance): Initialize and finalize invalid_invariant_regs.\n+\t(remove_inheritance_pseudos): Implement undoing invariant\n+\tinheritance.\n+\t(undo_optional_reloads, lra_undo_inheritance): Use restore_rtx\n+\tinstead of restore_regno.\n+\t* lra-assigns.c (regno_live_length): New.\n+\t(reload_pseudo_compare_func): Use regno_live_length.\n+\t(assign_by_spills): Use restore_rtx instead of restore_regno.\n+\t(lra_assign): Ditto.  Initiate regno_live_length.\n+\n 2016-02-08  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/arm_neon.h (vminnm_f64): Add back missing 'f' from"}, {"sha": "7248f89869e267ab10780dc94d84d48f687c5cd9", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -107,6 +107,10 @@ static bool former_reload_pseudo_spill_p;\n    lra_get_allocno_class.  It is used to speed up the code.  */\n static enum reg_class *regno_allocno_class_array;\n \n+/* Array containing lengths of pseudo live ranges.  It is used to\n+   speed up the code.  */\n+static int *regno_live_length;\n+\n /* Information about the thread to which a pseudo belongs.  Threads are\n    a set of connected reload and inheritance pseudos with the same set of\n    available hard registers.  Lone registers belong to their own threads.  */\n@@ -227,6 +231,11 @@ reload_pseudo_compare_func (const void *v1p, const void *v2p)\n   /* Put pseudos from the thread nearby.  */\n   if ((diff = regno_assign_info[r1].first - regno_assign_info[r2].first) != 0)\n     return diff;\n+  /* Prefer pseudos with longer live ranges.  It sets up better\n+     prefered hard registers for the thread pseudos and decreases\n+     register-register moves between the thread pseudos.  */\n+  if ((diff = regno_live_length[r2] - regno_live_length[r1]) != 0)\n+    return diff;\n   /* If regs are equally good, sort by their numbers, so that the\n      results of qsort leave nothing to chance.\t*/\n   return r1 - r2;\n@@ -1300,7 +1309,8 @@ find_all_spills_for (int regno)\n static void\n assign_by_spills (void)\n {\n-  int i, n, nfails, iter, regno, hard_regno, cost, restore_regno;\n+  int i, n, nfails, iter, regno, hard_regno, cost;\n+  rtx restore_rtx;\n   rtx_insn *insn;\n   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;\n   unsigned int u, conflict_regno;\n@@ -1333,6 +1343,8 @@ assign_by_spills (void)\n       for (i = 0; i < n; i++)\n \t{\n \t  regno = sorted_pseudos[i];\n+\t  if (reg_renumber[regno] >= 0)\n+\t    continue;\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file, \"\t Assigning to %d \"\n \t\t     \"(cl=%s, orig=%d, freq=%d, tfirst=%d, tfreq=%d)...\\n\",\n@@ -1471,21 +1483,25 @@ assign_by_spills (void)\n \t such inheritance or split pseudos.  */\n       bitmap_initialize (&do_not_assign_nonreload_pseudos, &reg_obstack);\n       EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, u, bi)\n-\tif ((restore_regno = lra_reg_info[u].restore_regno) >= 0\n+\tif ((restore_rtx = lra_reg_info[u].restore_rtx) != NULL_RTX\n+\t    && REG_P (restore_rtx)\n \t    && reg_renumber[u] < 0\n \t    && bitmap_bit_p (&lra_inheritance_pseudos, u))\n-\t  bitmap_set_bit (&do_not_assign_nonreload_pseudos, restore_regno);\n+\t  bitmap_set_bit (&do_not_assign_nonreload_pseudos, REGNO (restore_rtx));\n       EXECUTE_IF_SET_IN_BITMAP (&lra_split_regs, 0, u, bi)\n-\tif ((restore_regno = lra_reg_info[u].restore_regno) >= 0\n+\tif ((restore_rtx = lra_reg_info[u].restore_rtx) != NULL_RTX\n \t    && reg_renumber[u] >= 0)\n-\t  bitmap_set_bit (&do_not_assign_nonreload_pseudos, restore_regno);\n+\t  {\n+\t    lra_assert (REG_P (restore_rtx));\n+\t    bitmap_set_bit (&do_not_assign_nonreload_pseudos, REGNO (restore_rtx));\n+\t  }\n       for (n = 0, i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (((i < lra_constraint_new_regno_start\n \t      && ! bitmap_bit_p (&do_not_assign_nonreload_pseudos, i))\n \t     || (bitmap_bit_p (&lra_inheritance_pseudos, i)\n-\t\t && lra_reg_info[i].restore_regno >= 0)\n+\t\t && lra_reg_info[i].restore_rtx != NULL_RTX)\n \t     || (bitmap_bit_p (&lra_split_regs, i)\n-\t\t && lra_reg_info[i].restore_regno >= 0)\n+\t\t && lra_reg_info[i].restore_rtx != NULL_RTX)\n \t     || bitmap_bit_p (&lra_subreg_reload_pseudos, i)\n \t     || bitmap_bit_p (&lra_optional_reload_pseudos, i))\n \t    && reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0\n@@ -1513,7 +1529,7 @@ assign_by_spills (void)\n \t      enum reg_class spill_class;\n \t      \n \t      if (targetm.spill_class == NULL\n-\t\t  || lra_reg_info[regno].restore_regno < 0\n+\t\t  || lra_reg_info[regno].restore_rtx == NULL_RTX\n \t\t  || ! bitmap_bit_p (&lra_inheritance_pseudos, regno)\n \t\t  || (spill_class\n \t\t      = ((enum reg_class)\n@@ -1570,8 +1586,17 @@ lra_assign (void)\n   sorted_pseudos = XNEWVEC (int, max_regno);\n   sorted_reload_pseudos = XNEWVEC (int, max_regno);\n   regno_allocno_class_array = XNEWVEC (enum reg_class, max_regno);\n+  regno_live_length = XNEWVEC (int, max_regno);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    regno_allocno_class_array[i] = lra_get_allocno_class (i);\n+    {\n+      int l;\n+      lra_live_range_t r;\n+\n+      regno_allocno_class_array[i] = lra_get_allocno_class (i);\n+      for (l = 0, r = lra_reg_info[i].live_ranges; r != NULL; r = r->next)\n+\tl  += r->finish - r->start + 1;\n+      regno_live_length[i] = l;\n+    }\n   former_reload_pseudo_spill_p = false;\n   init_regno_assign_info ();\n   bitmap_initialize (&all_spilled_pseudos, &reg_obstack);\n@@ -1594,7 +1619,7 @@ lra_assign (void)\n   EXECUTE_IF_SET_IN_BITMAP (&all_spilled_pseudos, 0, u, bi)\n     /* We ignore spilled pseudos created on last inheritance pass\n        because they will be removed.  */\n-    if (lra_reg_info[u].restore_regno < 0)\n+    if (lra_reg_info[u].restore_rtx == NULL_RTX)\n       {\n \tno_spills_p = false;\n \tbreak;\n@@ -1613,6 +1638,7 @@ lra_assign (void)\n     }\n   bitmap_clear (&insns_to_process);\n   finish_regno_assign_info ();\n+  free (regno_live_length);\n   free (regno_allocno_class_array);\n   free (sorted_pseudos);\n   free (sorted_reload_pseudos);\n@@ -1631,3 +1657,4 @@ lra_assign (void)\n        LRA_MAX_ASSIGNMENT_ITERATION_NUMBER);\n   return no_spills_p;\n }\n+"}, {"sha": "43c05ba06d44646c878abd55b00971e90d3546db", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 363, "deletions": 60, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -4105,14 +4105,16 @@ curr_insn_transform (bool check_only_p)\n \n       if (optional_p)\n \t{\n-\t  lra_assert (REG_P (op));\n-\t  regno = REGNO (op);\n+\t  rtx reg = op;\n+\n+\t  lra_assert (REG_P (reg));\n+\t  regno = REGNO (reg);\n \t  op = *curr_id->operand_loc[i]; /* Substitution.  */\n \t  if (GET_CODE (op) == SUBREG)\n \t    op = SUBREG_REG (op);\n \t  gcc_assert (REG_P (op) && (int) REGNO (op) >= new_regno_start);\n \t  bitmap_set_bit (&lra_optional_reload_pseudos, REGNO (op));\n-\t  lra_reg_info[REGNO (op)].restore_regno = regno;\n+\t  lra_reg_info[REGNO (op)].restore_rtx = reg;\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file,\n \t\t     \"      Making reload reg %d for reg %d optional\\n\",\n@@ -4646,18 +4648,116 @@ lra_constraints (bool first_p)\n   return changed_p;\n }\n \n+static void initiate_invariants (void);\n+static void finish_invariants (void);\n+\n /* Initiate the LRA constraint pass.  It is done once per\n    function.  */\n void\n lra_constraints_init (void)\n {\n+  initiate_invariants ();\n }\n \n /* Finalize the LRA constraint pass.  It is done once per\n    function.  */\n void\n lra_constraints_finish (void)\n {\n+  finish_invariants ();\n+}\n+\n+\f\n+\n+/* Structure describes invariants for ineheritance.  */\n+struct invariant\n+{\n+  /* The order number of the invariant.  */\n+  int num;\n+  /* The invariant RTX.  */\n+  rtx invariant_rtx;\n+  /* The origin insn of the invariant.  */\n+  rtx_insn *insn;\n+};\n+\n+typedef struct invariant invariant_t;\n+typedef invariant_t *invariant_ptr_t;\n+typedef const invariant_t *const_invariant_ptr_t;\n+\n+/* Pointer to the inheritance invariants.  */\n+static vec<invariant_ptr_t> invariants;\n+\n+/* Allocation pool for the invariants.  */\n+static object_allocator<struct invariant> *invariants_pool;\n+\n+/* Hash table for the invariants.  */\n+static htab_t invariant_table;\n+\n+/* Hash function for INVARIANT.  */\n+static hashval_t\n+invariant_hash (const void *invariant)\n+{\n+  rtx inv = ((const_invariant_ptr_t) invariant)->invariant_rtx;\n+  return lra_rtx_hash (inv);\n+}\n+\n+/* Equal function for invariants INVARIANT1 and INVARIANT2.  */\n+static int\n+invariant_eq_p (const void *invariant1, const void *invariant2)\n+{\n+  rtx inv1 = ((const_invariant_ptr_t) invariant1)->invariant_rtx;\n+  rtx inv2 = ((const_invariant_ptr_t) invariant2)->invariant_rtx;\n+\n+  return rtx_equal_p (inv1, inv2);\n+}\n+\n+/* Insert INVARIANT_RTX into the table if it is not there yet.  Return\n+   invariant which is in the table.  */\n+static invariant_ptr_t\n+insert_invariant (rtx invariant_rtx)\n+{\n+  void **entry_ptr;\n+  invariant_t invariant;\n+  invariant_ptr_t invariant_ptr;\n+\n+  invariant.invariant_rtx = invariant_rtx;\n+  entry_ptr = htab_find_slot (invariant_table, &invariant, INSERT);\n+  if (*entry_ptr == NULL)\n+    {\n+      invariant_ptr = invariants_pool->allocate ();\n+      invariant_ptr->invariant_rtx = invariant_rtx;\n+      invariant_ptr->insn = NULL;\n+      invariants.safe_push (invariant_ptr);\n+      *entry_ptr = (void *) invariant_ptr;\n+    }\n+  return (invariant_ptr_t) *entry_ptr;\n+}\n+\n+/* Initiate the invariant table.  */\n+static void\n+initiate_invariants (void)\n+{\n+  invariants.create (100);\n+  invariants_pool = new object_allocator<struct invariant> (\"Inheritance invariants\");\n+  invariant_table = htab_create (100, invariant_hash, invariant_eq_p, NULL);\n+}\n+\n+/* Finish the invariant table.  */\n+static void\n+finish_invariants (void)\n+{\n+  htab_delete (invariant_table);\n+  delete invariants_pool;\n+  invariants.release ();\n+}\n+\n+/* Make the invariant table empty.  */\n+static void\n+clear_invariants (void)\n+{\n+  htab_empty (invariant_table);\n+  invariants_pool->release ();\n+  invariants.truncate (0);\n }\n \n \f\n@@ -4789,6 +4889,10 @@ check_secondary_memory_needed_p (enum reg_class inher_cl ATTRIBUTE_UNUSED,\n    (inheritance/split pseudos and original registers).\t*/\n static bitmap_head check_only_regs;\n \n+/* Reload pseudos can not be involded in invariant inheritance in the\n+   current EBB.  */\n+static bitmap_head invalid_invariant_regs;\n+\n /* Do inheritance transformations for insn INSN, which defines (if\n    DEF_P) or uses ORIGINAL_REGNO.  NEXT_USAGE_INSNS specifies which\n    instruction in the EBB next uses ORIGINAL_REGNO; it has the same\n@@ -4910,7 +5014,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file, \"    Original reg change %d->%d (bb%d):\\n\",\n \t     original_regno, REGNO (new_reg), BLOCK_FOR_INSN (insn)->index);\n-  lra_reg_info[REGNO (new_reg)].restore_regno = original_regno;\n+  lra_reg_info[REGNO (new_reg)].restore_rtx = regno_reg_rtx[original_regno];\n   bitmap_set_bit (&check_only_regs, REGNO (new_reg));\n   bitmap_set_bit (&check_only_regs, original_regno);\n   bitmap_set_bit (&lra_inheritance_pseudos, REGNO (new_reg));\n@@ -5194,7 +5298,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       return false;\n     }\n   after_p = usage_insns[original_regno].after_p;\n-  lra_reg_info[REGNO (new_reg)].restore_regno = original_regno;\n+  lra_reg_info[REGNO (new_reg)].restore_rtx = regno_reg_rtx[original_regno];\n   bitmap_set_bit (&check_only_regs, REGNO (new_reg));\n   bitmap_set_bit (&check_only_regs, original_regno);\n   bitmap_set_bit (&lra_split_regs, REGNO (new_reg));\n@@ -5273,6 +5377,134 @@ split_if_necessary (int regno, machine_mode mode,\n   return res;\n }\n \n+/* Return TRUE if rtx X is considered as an invariant for\n+   inheritance.  */\n+static bool\n+invariant_p (const_rtx x)\n+{\n+  machine_mode mode;\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j;\n+\n+  code = GET_CODE (x);\n+  mode = GET_MODE (x);\n+  if (code == SUBREG)\n+    {\n+      x = SUBREG_REG (x);\n+      code = GET_CODE (x);\n+      if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n+\tmode = GET_MODE (x);\n+    }\n+\n+  if (MEM_P (x))\n+    return false;\n+\n+  if (REG_P (x))\n+    {\n+      int i, nregs, regno = REGNO (x);\n+\n+      if (regno >= FIRST_PSEUDO_REGISTER || regno == STACK_POINTER_REGNUM\n+\t  || TEST_HARD_REG_BIT (eliminable_regset, regno)\n+\t  || GET_MODE_CLASS (GET_MODE (x)) == MODE_CC)\n+\treturn false;\n+      nregs = hard_regno_nregs[regno][mode];\n+      for (i = 0; i < nregs; i++)\n+\tif (! fixed_regs[regno + i]\n+\t    /* A hard register may be clobbered in the current insn\n+\t       but we can ignore this case because if the hard\n+\t       register is used it should be set somewhere after the\n+\t       clobber.  */\n+\t    || bitmap_bit_p (&invalid_invariant_regs, regno + i))\n+\t  return false;\n+    }\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (! invariant_p (XEXP (x, i)))\n+\t    return false;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (! invariant_p (XVECEXP (x, i, j)))\n+\t      return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* We have 'dest_reg <- invariant'.  Let us try to make an invariant\n+   inheritance transformation (using dest_reg instead invariant in a\n+   subsequent insn).  */\n+static bool\n+process_invariant_for_inheritance (rtx dst_reg, rtx invariant_rtx)\n+{\n+  invariant_ptr_t invariant_ptr;\n+  rtx_insn *insn, *new_insns;\n+  rtx insn_set, insn_reg, new_reg;\n+  int insn_regno;\n+  bool succ_p = false;\n+  int dst_regno = REGNO (dst_reg);\n+  enum machine_mode dst_mode = GET_MODE (dst_reg);\n+  enum reg_class cl = lra_get_allocno_class (dst_regno), insn_reg_cl;\n+\n+  invariant_ptr = insert_invariant (invariant_rtx);\n+  if ((insn = invariant_ptr->insn) != NULL_RTX)\n+    {\n+      /* We have a subsequent insn using the invariant.  */\n+      insn_set = single_set (insn);\n+      lra_assert (insn_set != NULL);\n+      insn_reg = SET_DEST (insn_set);\n+      lra_assert (REG_P (insn_reg));\n+      insn_regno = REGNO (insn_reg);\n+      insn_reg_cl = lra_get_allocno_class (insn_regno);\n+\n+      if (dst_mode == GET_MODE (insn_reg)\n+\t  /* We should consider only result move reg insns which are\n+\t     cheap.  */\n+\t  && targetm.register_move_cost (dst_mode, cl, insn_reg_cl) == 2\n+\t  && targetm.register_move_cost (dst_mode, cl, cl) == 2)\n+\t{\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file,\n+\t\t     \"    [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\\n\");\n+\t  new_reg = lra_create_new_reg (dst_mode, dst_reg,\n+\t\t\t\t\tcl, \"invariant inheritance\");\n+\t  bitmap_set_bit (&lra_inheritance_pseudos, REGNO (new_reg));\n+\t  bitmap_set_bit (&check_only_regs, REGNO (new_reg));\n+\t  lra_reg_info[REGNO (new_reg)].restore_rtx = invariant_rtx;\n+\t  start_sequence ();\n+\t  lra_emit_move (new_reg, dst_reg);\n+\t  new_insns = get_insns ();\n+\t  end_sequence ();\n+\t  lra_process_new_insns (curr_insn, NULL, new_insns,\n+\t\t\t\t \"Add invariant inheritance<-original\");\n+\t  start_sequence ();\n+\t  lra_emit_move (SET_DEST (insn_set), new_reg);\n+\t  new_insns = get_insns ();\n+\t  end_sequence ();\n+\t  lra_process_new_insns (insn, NULL, new_insns,\n+\t\t\t\t \"Changing reload<-inheritance\");\n+\t  lra_set_insn_deleted (insn);\n+\t  succ_p = true;\n+\t  if (lra_dump_file != NULL)\n+\t    {\n+\t      fprintf (lra_dump_file,\n+\t\t       \"    Invariant inheritance reuse change %d (bb%d):\\n\",\n+\t\t       REGNO (new_reg), BLOCK_FOR_INSN (insn)->index);\n+\t      dump_insn_slim (lra_dump_file, insn);\n+\t      fprintf (lra_dump_file,\n+\t\t       \"\t  ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\\n\");\n+\t    }\n+\t}\n+    }\n+  invariant_ptr->insn = curr_insn;\n+  return succ_p;\n+}\n+\n /* Check only registers living at the current program point in the\n    current EBB.\t */\n static bitmap_head live_regs;\n@@ -5495,7 +5727,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n   int i, src_regno, dst_regno, nregs;\n   bool change_p, succ_p, update_reloads_num_p;\n   rtx_insn *prev_insn, *last_insn;\n-  rtx next_usage_insns, set;\n+  rtx next_usage_insns, curr_set;\n   enum reg_class cl;\n   struct lra_insn_reg *reg;\n   basic_block last_processed_bb, curr_bb = NULL;\n@@ -5507,8 +5739,10 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \n   change_p = false;\n   curr_usage_insns_check++;\n+  clear_invariants ();\n   reloads_num = calls_num = 0;\n   bitmap_clear (&check_only_regs);\n+  bitmap_clear (&invalid_invariant_regs);\n   last_processed_bb = NULL;\n   CLEAR_HARD_REG_SET (potential_reload_hard_regs);\n   COPY_HARD_REG_SET (live_hard_regs, eliminable_regset);\n@@ -5556,13 +5790,11 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t    }\n \t}\n       src_regno = dst_regno = -1;\n-      if (NONDEBUG_INSN_P (curr_insn)\n-\t  && (set = single_set (curr_insn)) != NULL_RTX\n-\t  && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))\n-\t{\n-\t  src_regno = REGNO (SET_SRC (set));\n-\t  dst_regno = REGNO (SET_DEST (set));\n-\t}\n+      curr_set = single_set (curr_insn);\n+      if (curr_set != NULL_RTX && REG_P (SET_DEST (curr_set)))\n+\tdst_regno = REGNO (SET_DEST (curr_set));\n+      if (curr_set != NULL_RTX && REG_P (SET_SRC (curr_set)))\n+\tsrc_regno = REGNO (SET_SRC (curr_set));\n       update_reloads_num_p = true;\n       if (src_regno < lra_constraint_new_regno_start\n \t  && src_regno >= FIRST_PSEUDO_REGISTER\n@@ -5587,6 +5819,22 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t    IOR_HARD_REG_SET (potential_reload_hard_regs,\n \t\t\t      reg_class_contents[cl]);\n \t}\n+      else if (src_regno < 0\n+\t       && dst_regno >= lra_constraint_new_regno_start\n+\t       && invariant_p (SET_SRC (curr_set))\n+\t       && (cl = lra_get_allocno_class (dst_regno)) != NO_REGS\n+\t       && ! bitmap_bit_p (&invalid_invariant_regs, dst_regno))\n+\t{\n+\t  /* 'reload_pseudo <- invariant'.  */\n+\t  if (ira_class_hard_regs_num[cl] <= max_small_class_regs_num)\n+\t    reloads_num++;\n+\t  update_reloads_num_p = false;\n+\t  if (process_invariant_for_inheritance (SET_DEST (curr_set), SET_SRC (curr_set)))\n+\t    change_p = true;\n+\t  if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n+\t    IOR_HARD_REG_SET (potential_reload_hard_regs,\n+\t\t\t      reg_class_contents[cl]);\n+\t}\n       else if (src_regno >= lra_constraint_new_regno_start\n \t       && dst_regno < lra_constraint_new_regno_start\n \t       && dst_regno >= FIRST_PSEUDO_REGISTER\n@@ -5819,16 +6067,15 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t    }\n \t}\n       if (update_reloads_num_p\n-\t  && NONDEBUG_INSN_P (curr_insn)\n-          && (set = single_set (curr_insn)) != NULL_RTX)\n+\t  && NONDEBUG_INSN_P (curr_insn) && curr_set != NULL_RTX)\n \t{\n \t  int regno = -1;\n-\t  if ((REG_P (SET_DEST (set))\n-\t       && (regno = REGNO (SET_DEST (set))) >= lra_constraint_new_regno_start\n+\t  if ((REG_P (SET_DEST (curr_set))\n+\t       && (regno = REGNO (SET_DEST (curr_set))) >= lra_constraint_new_regno_start\n \t       && reg_renumber[regno] < 0\n \t       && (cl = lra_get_allocno_class (regno)) != NO_REGS)\n-\t      || (REG_P (SET_SRC (set))\n-\t          && (regno = REGNO (SET_SRC (set))) >= lra_constraint_new_regno_start\n+\t      || (REG_P (SET_SRC (curr_set))\n+\t          && (regno = REGNO (SET_SRC (curr_set))) >= lra_constraint_new_regno_start\n \t          && reg_renumber[regno] < 0\n \t          && (cl = lra_get_allocno_class (regno)) != NO_REGS))\n \t    {\n@@ -5839,6 +6086,25 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t                          reg_class_contents[cl]);\n \t    }\n \t}\n+      if (NONDEBUG_INSN_P (curr_insn))\n+\t{\n+\t  int regno;\n+\n+\t  /* Invalidate invariants with changed regs.  */\n+\t  curr_id = lra_get_insn_recog_data (curr_insn);\n+\t  for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type != OP_IN)\n+\t      bitmap_set_bit (&invalid_invariant_regs, reg->regno);\n+\t  curr_static_id = curr_id->insn_static_data;\n+\t  for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type != OP_IN)\n+\t      bitmap_set_bit (&invalid_invariant_regs, reg->regno);\n+\t  if (curr_id->arg_hard_regs != NULL)\n+\t    for (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n+\t\tbitmap_set_bit (&invalid_invariant_regs,\n+\t\t\t\tregno >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t? regno : regno - FIRST_PSEUDO_REGISTER);\n+\t}\n       /* We reached the start of the current basic block.  */\n       if (prev_insn == NULL_RTX || prev_insn == PREV_INSN (head)\n \t  || BLOCK_FOR_INSN (prev_insn) != curr_bb)\n@@ -5911,6 +6177,7 @@ lra_inheritance (void)\n   for (i = 0; i < lra_constraint_new_regno_start; i++)\n     usage_insns[i].check = 0;\n   bitmap_initialize (&check_only_regs, &reg_obstack);\n+  bitmap_initialize (&invalid_invariant_regs, &reg_obstack);\n   bitmap_initialize (&live_regs, &reg_obstack);\n   bitmap_initialize (&temp_bitmap, &reg_obstack);\n   bitmap_initialize (&ebb_global_regs, &reg_obstack);\n@@ -5947,6 +6214,7 @@ lra_inheritance (void)\n   bitmap_clear (&ebb_global_regs);\n   bitmap_clear (&temp_bitmap);\n   bitmap_clear (&live_regs);\n+  bitmap_clear (&invalid_invariant_regs);\n   bitmap_clear (&check_only_regs);\n   free (usage_insns);\n \n@@ -5970,8 +6238,9 @@ fix_bb_live_info (bitmap live, bitmap removed_pseudos)\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (removed_pseudos, 0, regno, bi)\n-    if (bitmap_clear_bit (live, regno))\n-      bitmap_set_bit (live, lra_reg_info[regno].restore_regno);\n+    if (bitmap_clear_bit (live, regno)\n+\t&& REG_P (lra_reg_info[regno].restore_rtx))\n+      bitmap_set_bit (live, REGNO (lra_reg_info[regno].restore_rtx));\n }\n \n /* Return regno of the (subreg of) REG. Otherwise, return a negative\n@@ -6024,7 +6293,8 @@ static bool\n remove_inheritance_pseudos (bitmap remove_pseudos)\n {\n   basic_block bb;\n-  int regno, sregno, prev_sregno, dregno, restore_regno;\n+  int regno, sregno, prev_sregno, dregno;\n+  rtx restore_rtx;\n   rtx set, prev_set;\n   rtx_insn *prev_insn;\n   bool change_p, done_p;\n@@ -6053,13 +6323,42 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \n \t  if (sregno >= 0 && dregno >= 0)\n \t    {\n-\t      if ((bitmap_bit_p (remove_pseudos, sregno)\n-\t\t   && (lra_reg_info[sregno].restore_regno == dregno\n+\t      if (bitmap_bit_p (remove_pseudos, dregno)\n+\t\t  && ! REG_P (lra_reg_info[dregno].restore_rtx))\n+\t\t{\n+\t\t  /* invariant inheritance pseudo <- original pseudo */\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    {\n+\t\t      fprintf (lra_dump_file, \"\t   Removing invariant inheritance:\\n\");\n+\t\t      dump_insn_slim (lra_dump_file, curr_insn);\n+\t\t      fprintf (lra_dump_file, \"\\n\");\n+\t\t    }\n+\t\t  delete_move_and_clobber (curr_insn, dregno);\n+\t\t  done_p = true;\n+\t\t}\n+\t      else if (bitmap_bit_p (remove_pseudos, sregno)\n+\t\t       && ! REG_P (lra_reg_info[sregno].restore_rtx))\n+\t\t{\n+\t\t  /* reload pseudo <- invariant inheritance pseudo */\n+\t\t  start_sequence ();\n+\t\t  /* We can not just change the source.  It might be\n+\t\t     an insn different from the move.  */\n+\t\t  lra_emit_move (SET_DEST (set), lra_reg_info[sregno].restore_rtx);\n+\t\t  rtx_insn *new_insns = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  lra_process_new_insns (curr_insn, NULL, new_insns,\n+\t\t\t\t\t \"Changing reload<-invariant inheritance\");\n+\t\t  delete_move_and_clobber (curr_insn, dregno);\n+\t\t  done_p = true;\n+\t\t}\n+\t      else if ((bitmap_bit_p (remove_pseudos, sregno)\n+\t\t\t&& (get_regno (lra_reg_info[sregno].restore_rtx) == dregno\n+\t\t\t    || (bitmap_bit_p (remove_pseudos, dregno)\n+\t\t\t\t&& get_regno (lra_reg_info[sregno].restore_rtx) >= 0\n+\t\t\t\t&& (get_regno (lra_reg_info[sregno].restore_rtx)\n+\t\t\t\t    == get_regno (lra_reg_info[dregno].restore_rtx)))))\n \t\t       || (bitmap_bit_p (remove_pseudos, dregno)\n-\t\t\t   && (lra_reg_info[sregno].restore_regno\n-\t\t\t       == lra_reg_info[dregno].restore_regno))))\n-\t\t  || (bitmap_bit_p (remove_pseudos, dregno)\n-\t\t      && lra_reg_info[dregno].restore_regno == sregno))\n+\t\t\t   && get_regno (lra_reg_info[dregno].restore_rtx) == sregno))\n \t\t/* One of the following cases:\n \t\t     original <- removed inheritance pseudo\n \t\t     removed inherit pseudo <- another removed inherit pseudo\n@@ -6104,13 +6403,16 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t      && (int) REGNO (SET_DEST (prev_set)) == sregno\n \t\t      && ((prev_sregno = REGNO (SET_SRC (prev_set)))\n \t\t\t  >= FIRST_PSEUDO_REGISTER)\n-\t\t      /* As we consider chain of inheritance or\n-\t\t\t splitting described in above comment we should\n-\t\t\t check that sregno and prev_sregno were\n-\t\t\t inheritance/split pseudos created from the\n-\t\t\t same original regno.  */\n-\t\t      && (lra_reg_info[sregno].restore_regno\n-\t\t\t  == lra_reg_info[prev_sregno].restore_regno)\n+\t\t      && (lra_reg_info[prev_sregno].restore_rtx == NULL_RTX\n+\t\t\t  ||\n+\t\t\t  /* As we consider chain of inheritance or\n+\t\t\t     splitting described in above comment we should\n+\t\t\t     check that sregno and prev_sregno were\n+\t\t\t     inheritance/split pseudos created from the\n+\t\t\t     same original regno.  */\n+\t\t\t  (get_regno (lra_reg_info[sregno].restore_rtx) >= 0\n+\t\t\t   && (get_regno (lra_reg_info[sregno].restore_rtx)\n+\t\t\t       == get_regno (lra_reg_info[prev_sregno].restore_rtx))))\n \t\t      && ! bitmap_bit_p (remove_pseudos, prev_sregno))\n \t\t    {\n \t\t      lra_assert (GET_MODE (SET_SRC (prev_set))\n@@ -6124,14 +6426,13 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t\t inheritance pseudo for another pseudo.  */\n \t\t      if (bitmap_bit_p (remove_pseudos, dregno)\n \t\t\t  && bitmap_bit_p (&lra_inheritance_pseudos, dregno)\n-\t\t\t  && (restore_regno\n-\t\t\t      = lra_reg_info[dregno].restore_regno) >= 0)\n+\t\t\t  && (restore_rtx\n+\t\t\t      = lra_reg_info[dregno].restore_rtx) != NULL_RTX)\n \t\t\t{\n \t\t\t  if (GET_CODE (SET_DEST (set)) == SUBREG)\n-\t\t\t    SUBREG_REG (SET_DEST (set))\n-\t\t\t      = regno_reg_rtx[restore_regno];\n+\t\t\t    SUBREG_REG (SET_DEST (set)) = restore_rtx;\n \t\t\t  else\n-\t\t\t    SET_DEST (set) = regno_reg_rtx[restore_regno];\n+\t\t\t    SET_DEST (set) = restore_rtx;\n \t\t\t}\n \t\t      lra_push_insn_and_update_insn_regno_info (curr_insn);\n \t\t      lra_set_used_insn_alternative_by_uid\n@@ -6155,14 +6456,13 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t      for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t\t{\n \t\t  regno = reg->regno;\n-\t\t  restore_regno = lra_reg_info[regno].restore_regno;\n-\t\t  if (restore_regno >= 0)\n+\t\t  restore_rtx = lra_reg_info[regno].restore_rtx;\n+\t\t  if (restore_rtx != NULL_RTX)\n \t\t    {\n \t\t      if (change_p && bitmap_bit_p (remove_pseudos, regno))\n \t\t\t{\n \t\t\t  lra_substitute_pseudo_within_insn\n-\t\t\t    (curr_insn, regno, regno_reg_rtx[restore_regno],\n-\t\t\t     false);\n+\t\t\t    (curr_insn, regno, restore_rtx, false);\n \t\t\t  restored_regs_p = true;\n \t\t\t}\n \t\t      else\n@@ -6213,11 +6513,11 @@ undo_optional_reloads (void)\n     {\n       keep_p = false;\n       /* Keep optional reloads from previous subpasses.  */\n-      if (lra_reg_info[regno].restore_regno < 0\n+      if (lra_reg_info[regno].restore_rtx == NULL_RTX\n \t  /* If the original pseudo changed its allocation, just\n \t     removing the optional pseudo is dangerous as the original\n \t     pseudo will have longer live range.  */\n-\t  || reg_renumber[lra_reg_info[regno].restore_regno] >= 0)\n+\t  || reg_renumber[REGNO (lra_reg_info[regno].restore_rtx)] >= 0)\n \tkeep_p = true;\n       else if (reg_renumber[regno] >= 0)\n \tEXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi2)\n@@ -6231,7 +6531,7 @@ undo_optional_reloads (void)\n \t      continue;\n \t    if (REGNO (dest) == regno\n \t\t/* Ignore insn for optional reloads itself.  */\n-\t\t&& lra_reg_info[regno].restore_regno != (int) REGNO (src)\n+\t\t&& REGNO (lra_reg_info[regno].restore_rtx) != REGNO (src)\n \t\t/* Check only inheritance on last inheritance pass.  */\n \t\t&& (int) REGNO (src) >= new_regno_start\n \t\t/* Check that the optional reload was inherited.  */\n@@ -6264,11 +6564,11 @@ undo_optional_reloads (void)\n \t      dest = SET_DEST (set);\n \t      if (REG_P (src) && REG_P (dest)\n \t\t  && ((REGNO (src) == regno\n-\t\t       && (lra_reg_info[regno].restore_regno\n-\t\t\t   == (int) REGNO (dest)))\n+\t\t       && (REGNO (lra_reg_info[regno].restore_rtx)\n+\t\t\t   == REGNO (dest)))\n \t\t      || (REGNO (dest) == regno\n-\t\t\t  && (lra_reg_info[regno].restore_regno\n-\t\t\t      == (int) REGNO (src)))))\n+\t\t\t  && (REGNO (lra_reg_info[regno].restore_rtx)\n+\t\t\t      == REGNO (src)))))\n \t\t{\n \t\t  if (lra_dump_file != NULL)\n \t\t    {\n@@ -6286,8 +6586,7 @@ undo_optional_reloads (void)\n \t\t reload.  */\n \t    }\n \t  lra_substitute_pseudo_within_insn\n-\t    (insn, regno, regno_reg_rtx[lra_reg_info[regno].restore_regno],\n-\t     false);\n+\t    (insn, regno, lra_reg_info[regno].restore_rtx, false);\n \t  lra_update_insn_regno_info (insn);\n \t  if (lra_dump_file != NULL)\n \t    {\n@@ -6299,7 +6598,7 @@ undo_optional_reloads (void)\n     }\n   /* Clear restore_regnos.  */\n   EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n-    lra_reg_info[regno].restore_regno = -1;\n+    lra_reg_info[regno].restore_rtx = NULL_RTX;\n   bitmap_clear (&insn_bitmap);\n   bitmap_clear (&removed_optional_reload_pseudos);\n   return change_p;\n@@ -6311,8 +6610,9 @@ bool\n lra_undo_inheritance (void)\n {\n   unsigned int regno;\n-  int restore_regno, hard_regno;\n+  int hard_regno;\n   int n_all_inherit, n_inherit, n_all_split, n_split;\n+  rtx restore_rtx;\n   bitmap_head remove_pseudos;\n   bitmap_iterator bi;\n   bool change_p;\n@@ -6327,14 +6627,15 @@ lra_undo_inheritance (void)\n   bitmap_initialize (&remove_pseudos, &reg_obstack);\n   n_inherit = n_all_inherit = 0;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, regno, bi)\n-    if (lra_reg_info[regno].restore_regno >= 0)\n+    if (lra_reg_info[regno].restore_rtx != NULL_RTX)\n       {\n \tn_all_inherit++;\n \tif (reg_renumber[regno] < 0\n \t    /* If the original pseudo changed its allocation, just\n \t       removing inheritance is dangerous as for changing\n \t       allocation we used shorter live-ranges.  */\n-\t    && reg_renumber[lra_reg_info[regno].restore_regno] < 0)\n+\t    && (! REG_P (lra_reg_info[regno].restore_rtx)\n+\t\t|| reg_renumber[REGNO (lra_reg_info[regno].restore_rtx)] < 0))\n \t  bitmap_set_bit (&remove_pseudos, regno);\n \telse\n \t  n_inherit++;\n@@ -6345,8 +6646,10 @@ lra_undo_inheritance (void)\n \t     (double) n_inherit / n_all_inherit * 100);\n   n_split = n_all_split = 0;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_split_regs, 0, regno, bi)\n-    if ((restore_regno = lra_reg_info[regno].restore_regno) >= 0)\n+    if ((restore_rtx = lra_reg_info[regno].restore_rtx) != NULL_RTX)\n       {\n+\tint restore_regno = REGNO (restore_rtx);\n+\n \tn_all_split++;\n \thard_regno = (restore_regno >= FIRST_PSEUDO_REGISTER\n \t\t      ? reg_renumber[restore_regno] : restore_regno);\n@@ -6368,9 +6671,9 @@ lra_undo_inheritance (void)\n   bitmap_clear (&remove_pseudos);\n   /* Clear restore_regnos.  */\n   EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, regno, bi)\n-    lra_reg_info[regno].restore_regno = -1;\n+    lra_reg_info[regno].restore_rtx = NULL_RTX;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_split_regs, 0, regno, bi)\n-    lra_reg_info[regno].restore_regno = -1;\n+    lra_reg_info[regno].restore_rtx = NULL_RTX;\n   change_p = undo_optional_reloads () || change_p;\n   return change_p;\n }"}, {"sha": "cfab209cef1ea57f7cadcd3762906b0af5123f4c", "filename": "gcc/lra-int.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -99,9 +99,9 @@ struct lra_reg\n      *non-debug* insns.\t */\n   int nrefs, freq;\n   int last_reload;\n-  /* Regno used to undo the inheritance.  It can be non-zero only\n-     between couple of inheritance and undo inheritance passes.\t */\n-  int restore_regno;\n+  /* rtx used to undo the inheritance.  It can be non-null only\n+     between subsequent inheritance and undo inheritance passes.  */\n+  rtx restore_rtx;\n   /* Value holding by register.\t If the pseudos have the same value\n      they do not conflict.  */\n   int val;\n@@ -285,6 +285,7 @@ extern lra_insn_recog_data_t *lra_insn_recog_data;\n extern int lra_curr_reload_num;\n \n extern void lra_dump_bitmap_with_title (const char *, bitmap, int);\n+extern hashval_t lra_rtx_hash (rtx x);\n extern void lra_push_insn (rtx_insn *);\n extern void lra_push_insn_by_uid (unsigned int);\n extern void lra_push_insn_and_update_insn_regno_info (rtx_insn *);"}, {"sha": "c124d5ba2e1d0764e31ece64bbcd7420625f4e62", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -167,92 +167,6 @@ get_remat_bb_data_by_index (int index)\n \n \f\n \n-/* Recursive hash function for RTL X.  */\n-static hashval_t\n-rtx_hash (rtx x)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-  hashval_t val = 0;\n-\n-  if (x == 0)\n-    return val;\n-\n-  code = GET_CODE (x);\n-  val += (int) code + 4095;\n-\n-  /* Some RTL can be compared nonrecursively.  */\n-  switch (code)\n-    {\n-    case REG:\n-      return val + REGNO (x);\n-\n-    case LABEL_REF:\n-      return iterative_hash_object (XEXP (x, 0), val);\n-\n-    case SYMBOL_REF:\n-      return iterative_hash_object (XSTR (x, 0), val);\n-\n-    case SCRATCH:\n-    case CONST_DOUBLE:\n-    case CONST_INT:\n-    case CONST_VECTOR:\n-      return val;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Hash the elements.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'w':\n-\t  val += XWINT (x, i);\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  val += XINT (x, i);\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  val += XVECLEN (x, i);\n-\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    val += rtx_hash (XVECEXP (x, i, j));\n-\t  break;\n-\n-\tcase 'e':\n-\t  val += rtx_hash (XEXP (x, i));\n-\t  break;\n-\n-\tcase 'S':\n-\tcase 's':\n-\t  val += htab_hash_string (XSTR (x, i));\n-\t  break;\n-\n-\tcase 'u':\n-\tcase '0':\n-\tcase 't':\n-\t  break;\n-\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's, except for\n-\t     within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  return val;\n-}\n-\n-\f\n-\n /* Hash table for the candidates.  Different insns (e.g. structurally\n    the same insns or even insns with different unused output regs) can\n    be represented by the same candidate in the table.  */"}, {"sha": "1801b7bb391d50f9880b49e2ec84477736e55b27", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -693,7 +693,7 @@ lra_final_code_change (void)\n {\n   int i, hard_regno;\n   basic_block bb;\n-  rtx_insn *insn, *curr;\n+  rtx_insn *insn, *curr, *next_insn;\n   int max_regno = max_reg_num ();\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n@@ -727,7 +727,12 @@ lra_final_code_change (void)\n \t  if (NONJUMP_INSN_P (insn) && GET_CODE (pat) == SET\n \t      && REG_P (SET_SRC (pat)) && REG_P (SET_DEST (pat))\n \t      && REGNO (SET_SRC (pat)) == REGNO (SET_DEST (pat))\n-\t      && ! return_regno_p (REGNO (SET_SRC (pat))))\n+\t      && (! return_regno_p (REGNO (SET_SRC (pat)))\n+\t\t  || (next_insn = next_nondebug_insn (insn)) == NULL_RTX\n+\t\t  || ! INSN_P (next_insn)\n+\t\t  || GET_CODE (PATTERN (next_insn)) != USE\n+\t\t  || ! REG_P (XEXP (PATTERN (next_insn), 0))\n+\t\t  || REGNO (SET_SRC (pat)) != REGNO (XEXP (PATTERN (next_insn), 0))))\n \t    {\n \t      lra_invalidate_insn_data (insn);\n \t      delete_insn (insn);"}, {"sha": "cb2bd35cffd6b2c74784eeb4a07c0d8b881fe18d", "filename": "gcc/lra.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "patch": "@@ -1286,7 +1286,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].live_ranges = NULL;\n   lra_reg_info[i].nrefs = lra_reg_info[i].freq = 0;\n   lra_reg_info[i].last_reload = 0;\n-  lra_reg_info[i].restore_regno = -1;\n+  lra_reg_info[i].restore_rtx = NULL_RTX;\n   lra_reg_info[i].val = get_new_reg_value ();\n   lra_reg_info[i].offset = 0;\n   lra_reg_info[i].copies = NULL;\n@@ -1621,6 +1621,92 @@ lra_get_insn_regs (int uid)\n \n \f\n \n+/* Recursive hash function for RTL X.  */\n+hashval_t\n+lra_rtx_hash (rtx x)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  hashval_t val = 0;\n+\n+  if (x == 0)\n+    return val;\n+\n+  code = GET_CODE (x);\n+  val += (int) code + 4095;\n+\n+  /* Some RTL can be compared nonrecursively.  */\n+  switch (code)\n+    {\n+    case REG:\n+      return val + REGNO (x);\n+\n+    case LABEL_REF:\n+      return iterative_hash_object (XEXP (x, 0), val);\n+\n+    case SYMBOL_REF:\n+      return iterative_hash_object (XSTR (x, 0), val);\n+\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+    case CONST_VECTOR:\n+      return val;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Hash the elements.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  val += XWINT (x, i);\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  val += XINT (x, i);\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  val += XVECLEN (x, i);\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    val += lra_rtx_hash (XVECEXP (x, i, j));\n+\t  break;\n+\n+\tcase 'e':\n+\t  val += lra_rtx_hash (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  val += htab_hash_string (XSTR (x, i));\n+\t  break;\n+\n+\tcase 'u':\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's, except for\n+\t     within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return val;\n+}\n+\n+\f\n+\n /* This page contains code dealing with stack of the insns which\n    should be processed by the next constraint pass.  */\n "}]}