{"sha": "26132f7136c30b670786d3e8cb4b033de8d2a179", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxMzJmNzEzNmMzMGI2NzA3ODZkM2U4Y2I0YjAzM2RlOGQyYTE3OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1999-11-05T07:08:13Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1999-11-05T07:08:13Z"}, "message": "Fix cse bug that broke the ia64 port.\n\n\t* cse.c (cse_insn): Revert Oct 31 change.  When computing src_elt,\n\tif REG_RETVAL check succeeds, then put classp in src_elt.\n\nFrom-SVN: r30406", "tree": {"sha": "1dd3c96327028acd2fd8f6312dae83512578d0e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dd3c96327028acd2fd8f6312dae83512578d0e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26132f7136c30b670786d3e8cb4b033de8d2a179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26132f7136c30b670786d3e8cb4b033de8d2a179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26132f7136c30b670786d3e8cb4b033de8d2a179", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26132f7136c30b670786d3e8cb4b033de8d2a179/comments", "author": null, "committer": null, "parents": [{"sha": "9399d5c63fc03d80fb57868f6ab4a26657358445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9399d5c63fc03d80fb57868f6ab4a26657358445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9399d5c63fc03d80fb57868f6ab4a26657358445"}], "stats": {"total": 52, "additions": 30, "deletions": 22}, "files": [{"sha": "a5dec539d2abdf76a946ddbbcf65fc2d45d69d74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26132f7136c30b670786d3e8cb4b033de8d2a179/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26132f7136c30b670786d3e8cb4b033de8d2a179/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26132f7136c30b670786d3e8cb4b033de8d2a179", "patch": "@@ -1,3 +1,8 @@\n+Thu Nov  4 23:07:14 1999  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* cse.c (cse_insn): Revert Oct 31 change.  When computing src_elt,\n+\tif REG_RETVAL check succeeds, then put classp in src_elt.\n+\n Thu Nov  4 23:48:14 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* function.c (pad_to_arg_alignment): Only update argument_pad"}, {"sha": "bac710bf8cef931ea01c620eb8691fba1365839e", "filename": "gcc/cse.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26132f7136c30b670786d3e8cb4b033de8d2a179/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26132f7136c30b670786d3e8cb4b033de8d2a179/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=26132f7136c30b670786d3e8cb4b033de8d2a179", "patch": "@@ -5730,9 +5730,8 @@ cse_insn (insn, libcall_insn)\n \t does not yet have an elt, and if so set the elt of the set source\n \t to src_eqv_elt.  */\n       for (i = 0; i < n_sets; i++)\n-\tif (n_sets == 1\n-\t    || (sets[i].rtl && sets[i].src_elt == 0\n-\t\t&& rtx_equal_p (SET_SRC (sets[i].rtl), src_eqv)))\n+\tif (sets[i].rtl && sets[i].src_elt == 0\n+\t    && rtx_equal_p (SET_SRC (sets[i].rtl), src_eqv))\n \t  sets[i].src_elt = src_eqv_elt;\n     }\n \n@@ -5760,29 +5759,33 @@ cse_insn (insn, libcall_insn)\n \t    enum machine_mode mode\n \t      = GET_MODE (src) == VOIDmode ? GET_MODE (dest) : GET_MODE (src);\n \n-\t    /* Don't put a hard register source into the table if this is\n-\t       the last insn of a libcall.  */\n-\t    if (sets[i].src_elt == 0\n-\t\t&& (GET_CODE (src) != REG\n-\t\t    || REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t\t    || ! find_reg_note (insn, REG_RETVAL, NULL_RTX)))\n+\t    if (sets[i].src_elt == 0)\n \t      {\n-\t\tregister struct table_elt *elt;\n-\n-\t\t/* Note that these insert_regs calls cannot remove\n-\t\t   any of the src_elt's, because they would have failed to\n-\t\t   match if not still valid.  */\n-\t\tif (insert_regs (src, classp, 0))\n+\t\t/* Don't put a hard register source into the table if this is\n+\t\t   the last insn of a libcall.  In this case, we only need\n+\t\t   to put src_eqv_elt in src_elt.  */\n+\t\tif (GET_CODE (src) != REG\n+\t\t    || REGNO (src) >= FIRST_PSEUDO_REGISTER\n+\t\t    || ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t\t  {\n-\t\t    rehash_using_reg (src);\n-\t\t    sets[i].src_hash = HASH (src, mode);\n+\t\t    register struct table_elt *elt;\n+\n+\t\t    /* Note that these insert_regs calls cannot remove\n+\t\t       any of the src_elt's, because they would have failed to\n+\t\t       match if not still valid.  */\n+\t\t    if (insert_regs (src, classp, 0))\n+\t\t      {\n+\t\t\trehash_using_reg (src);\n+\t\t\tsets[i].src_hash = HASH (src, mode);\n+\t\t      }\n+\t\t    elt = insert (src, classp, sets[i].src_hash, mode);\n+\t\t    elt->in_memory = sets[i].src_in_memory;\n+\t\t    elt->in_struct = sets[i].src_in_struct;\n+\t\t    sets[i].src_elt = classp = elt;\n \t\t  }\n-\t\telt = insert (src, classp, sets[i].src_hash, mode);\n-\t\telt->in_memory = sets[i].src_in_memory;\n-\t\telt->in_struct = sets[i].src_in_struct;\n-\t\tsets[i].src_elt = classp = elt;\n+\t\telse\n+\t\t  sets[i].src_elt = classp;\n \t      }\n-\n \t    if (sets[i].src_const && sets[i].src_const_elt == 0\n \t\t&& src != sets[i].src_const\n \t\t&& ! rtx_equal_p (sets[i].src_const, src))"}]}