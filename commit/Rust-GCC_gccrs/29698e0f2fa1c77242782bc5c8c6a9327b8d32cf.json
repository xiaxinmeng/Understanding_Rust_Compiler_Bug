{"sha": "29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2OThlMGYyZmExYzc3MjQyNzgyYmM1YzhjNmE5MzI3YjhkMzJjZg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-08-19T07:28:17Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-08-19T07:28:17Z"}, "message": "re PR fortran/36158 (Transformational function BESSEL_YN(n1,n2,x) and BESSEL_JN missing)\n\n2010-08-19  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36158\n        PR fortran/33197\n        * check.c (gfc_check_bessel_n2): New function.\n        * gfortran.h (gfc_isym_id): Add GFC_ISYM_JN2 and GFC_ISYM_YN2.\n        * intrinsic.c (add_functions): Add transformational version\n        of the Bessel_jn/yn intrinsics.\n        * intrinsic.h (gfc_check_bessel_n2,gfc_simplify_bessel_jn2,\n        gfc_simplify_bessel_yn2): New prototypes.\n        * intrinsic.texi (Bessel_jn, Bessel_yn): Document\n        transformational variant.\n        * simplify.c (gfc_simplify_bessel_jn, gfc_simplify_bessel_yn):\n        Check for negative order.\n        (gfc_simplify_bessel_n2,gfc_simplify_bessel_jn2,\n        gfc_simplify_bessel_yn2): New functions.\n\n2010-08-19  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36158\n        PR fortran/33197\n        * gfortran.dg/bessel_3.f90: New.\n        * gfortran.dg/bessel_4.f90: New.\n        * gfortran.dg/bessel_5.f90: New.\n\nFrom-SVN: r163364", "tree": {"sha": "444e1c1a219a8b1f5c18e7b23532f2e12dbfa224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/444e1c1a219a8b1f5c18e7b23532f2e12dbfa224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "771c5727a06b8d64ce037f592737108ce5fd93e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771c5727a06b8d64ce037f592737108ce5fd93e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771c5727a06b8d64ce037f592737108ce5fd93e9"}], "stats": {"total": 437, "additions": 425, "deletions": 12}, "files": [{"sha": "2c6e6f65a775f2e9c16128a793310fe228ce2514", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -1,3 +1,20 @@\n+2010-08-19  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36158\n+\tPR fortran/33197\n+\t* check.c (gfc_check_bessel_n2): New function.\n+\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_JN2 and GFC_ISYM_YN2.\n+\t* intrinsic.c (add_functions): Add transformational version\n+\tof the Bessel_jn/yn intrinsics.\n+\t* intrinsic.h (gfc_check_bessel_n2,gfc_simplify_bessel_jn2,\n+\tgfc_simplify_bessel_yn2): New prototypes.\n+\t* intrinsic.texi (Bessel_jn, Bessel_yn): Document\n+\ttransformational variant.\n+\t* simplify.c (gfc_simplify_bessel_jn, gfc_simplify_bessel_yn):\n+\tCheck for negative order.\n+\t(gfc_simplify_bessel_n2,gfc_simplify_bessel_jn2,\n+\tgfc_simplify_bessel_yn2): New functions.\n+\n 2010-08-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/41859"}, {"sha": "36efffa6dfa3c8fc062037cc0b80452534cd9fa2", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -884,6 +884,14 @@ gfc_check_besn (gfc_expr *n, gfc_expr *x)\n {\n   if (type_check (n, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n+  if (n->expr_type == EXPR_CONSTANT)\n+    {\n+      int i;\n+      gfc_extract_int (n, &i);\n+      if (i < 0 && gfc_notify_std (GFC_STD_GNU, \"Extension: Negative argument \"\n+\t\t\t\t   \"N at %L\", &n->where) == FAILURE)\n+\treturn FAILURE;\n+    }\n \n   if (type_check (x, 1, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -892,6 +900,34 @@ gfc_check_besn (gfc_expr *n, gfc_expr *x)\n }\n \n \n+/* Transformational version of the Bessel JN and YN functions.  */\n+\n+gfc_try\n+gfc_check_bessel_n2 (gfc_expr *n1, gfc_expr *n2, gfc_expr *x)\n+{\n+  if (type_check (n1, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (scalar_check (n1, 0) == FAILURE)\n+    return FAILURE;\n+  if (nonnegative_check(\"N1\", n1) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (n2, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (scalar_check (n2, 1) == FAILURE)\n+    return FAILURE;\n+  if (nonnegative_check(\"N2\", n2) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (x, 2, BT_REAL) == FAILURE)\n+    return FAILURE;\n+  if (scalar_check (x, 2) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_bitfcn (gfc_expr *i, gfc_expr *pos)\n {"}, {"sha": "5ca24880179758c0e25c22ff0823affc3fae5018", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -422,6 +422,7 @@ enum gfc_isym_id\n   GFC_ISYM_J0,\n   GFC_ISYM_J1,\n   GFC_ISYM_JN,\n+  GFC_ISYM_JN2,\n   GFC_ISYM_KILL,\n   GFC_ISYM_KIND,\n   GFC_ISYM_LBOUND,\n@@ -531,7 +532,8 @@ enum gfc_isym_id\n   GFC_ISYM_XOR,\n   GFC_ISYM_Y0,\n   GFC_ISYM_Y1,\n-  GFC_ISYM_YN\n+  GFC_ISYM_YN,\n+  GFC_ISYM_YN2\n };\n typedef enum gfc_isym_id gfc_isym_id;\n "}, {"sha": "3751167e75b70ee6047f28a602db3822f4e952b1", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -1317,6 +1317,11 @@ add_functions (void)\n \t     gfc_check_besn, gfc_simplify_bessel_jn, gfc_resolve_besn,\n \t     n, BT_INTEGER, di, REQUIRED, x, BT_REAL, dd, REQUIRED);\n \n+  add_sym_3 (\"bessel_jn\", GFC_ISYM_JN2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n+\t     gfc_check_bessel_n2, gfc_simplify_bessel_jn2, NULL,\n+\t     \"n1\", BT_INTEGER, di, REQUIRED,\"n2\", BT_INTEGER, di, REQUIRED,\n+\t     x, BT_REAL, dr, REQUIRED);\n+\n   make_generic (\"bessel_jn\", GFC_ISYM_JN, GFC_STD_F2008);\n \n   add_sym_1 (\"besy0\", GFC_ISYM_Y0, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_GNU,\n@@ -1353,6 +1358,11 @@ add_functions (void)\n \t     gfc_check_besn, gfc_simplify_bessel_yn, gfc_resolve_besn,\n \t     n, BT_INTEGER, di, REQUIRED, x, BT_REAL, dd, REQUIRED);\n \n+  add_sym_3 (\"bessel_yn\", GFC_ISYM_YN2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n+\t     gfc_check_bessel_n2, gfc_simplify_bessel_yn2, NULL,\n+\t     \"n1\", BT_INTEGER, di, REQUIRED,\"n2\", BT_INTEGER, di, REQUIRED,\n+\t      x, BT_REAL, dr, REQUIRED);\n+\n   make_generic (\"bessel_yn\", GFC_ISYM_YN, GFC_STD_F2008);\n \n   add_sym_1 (\"bit_size\", GFC_ISYM_BIT_SIZE, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,"}, {"sha": "7780ebca232f2c5cf4c015f6915d01e2a3cff310", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -40,6 +40,7 @@ gfc_try gfc_check_associated (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_besn (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_bitfcn (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_char (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_chdir (gfc_expr *);\n@@ -223,9 +224,11 @@ gfc_expr *gfc_simplify_atan2 (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bessel_j0 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_j1 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_jn (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_bessel_jn2 (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bessel_y0 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_y1 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_yn (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_bessel_yn2 (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bit_size (gfc_expr *);\n gfc_expr *gfc_simplify_btest (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ceiling (gfc_expr *, gfc_expr *);"}, {"sha": "3c82ffc2c142a2cbdecc6272d17b0aa7100c8362", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -1630,29 +1630,41 @@ end program test_besj1\n @item @emph{Description}:\n @code{BESSEL_JN(N, X)} computes the Bessel function of the first kind of\n order @var{N} of @var{X}. This function is available under the name\n-@code{BESJN} as a GNU extension.\n+@code{BESJN} as a GNU extension.  If @var{N} and @var{X} are arrays,\n+their ranks and shapes shall conform.  \n \n-If both arguments are arrays, their ranks and shapes shall conform.\n+@code{BESSEL_JN(N1, N2, X)} returns an array with the Bessel functions\n+of the first kind of the orders @var{N1} to @var{N2}.\n \n @item @emph{Standard}:\n-Fortran 2008 and later\n+Fortran 2008 and later, negative @var{N} is allowed as GNU extension\n \n @item @emph{Class}:\n-Elemental function\n+Elemental function, except for the tranformational function\n+@code{BESSEL_JN(N1, N2, X)}\n \n @item @emph{Syntax}:\n @code{RESULT = BESSEL_JN(N, X)}\n+@code{RESULT = BESSEL_JN(N1, N2, X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER}.\n-@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL}.\n+@item @var{N1} @tab Shall be a non-negative scalar of type  @code{INTEGER}.\n+@item @var{N2} @tab Shall be a non-negative scalar of type  @code{INTEGER}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL};\n+for @code{BESSEL_JN(N1, N2, X)} it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n The return value is a scalar of type @code{REAL}. It has the same\n kind as @var{X}.\n \n+@item @emph{Note}:\n+The transformational function uses a recurrance algorithm which might,\n+for some values of @var{X}, lead to different results than calls to\n+the elemental function.\n+\n @item @emph{Example}:\n @smallexample\n program test_besjn\n@@ -1778,29 +1790,41 @@ end program test_besy1\n @item @emph{Description}:\n @code{BESSEL_YN(N, X)} computes the Bessel function of the second kind of\n order @var{N} of @var{X}. This function is available under the name\n-@code{BESYN} as a GNU extension.\n+@code{BESYN} as a GNU extension.  If @var{N} and @var{X} are arrays,\n+their ranks and shapes shall conform.  \n \n-If both arguments are arrays, their ranks and shapes shall conform.\n+@code{BESSEL_YN(N1, N2, X)} returns an array with the Bessel functions\n+of the first kind of the orders @var{N1} to @var{N2}.\n \n @item @emph{Standard}:\n-Fortran 2008 and later\n+Fortran 2008 and later, negative @var{N} is allowed as GNU extension\n \n @item @emph{Class}:\n-Elemental function\n+Elemental function, except for the tranformational function\n+@code{BESSEL_YN(N1, N2, X)}\n \n @item @emph{Syntax}:\n @code{RESULT = BESSEL_YN(N, X)}\n+@code{RESULT = BESSEL_YN(N1, N2, X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER}.\n-@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL}.\n+@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER} .\n+@item @var{N1} @tab Shall be a non-negative scalar of type  @code{INTEGER}.\n+@item @var{N2} @tab Shall be a non-negative scalar of type  @code{INTEGER}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL};\n+for @code{BESSEL_YN(N1, N2, X)} it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n The return value is a scalar of type @code{REAL}. It has the same\n kind as @var{X}.\n \n+@item @emph{Note}:\n+The transformational function uses a recurrance algorithm which might,\n+for some values of @var{X}, lead to different results than calls to\n+the elemental function.\n+\n @item @emph{Example}:\n @smallexample\n program test_besyn"}, {"sha": "d1e94af4db2b4c8e79f4f70bae27a802e774e514", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -1196,6 +1196,184 @@ gfc_simplify_bessel_jn (gfc_expr *order, gfc_expr *x)\n }\n \n \n+/* Simplify transformational form of JN and YN.  */\n+\n+static gfc_expr *\n+gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n+\t\t\tbool jn)\n+{\n+  gfc_expr *result;\n+  gfc_expr *e;\n+  long n1, n2;\n+  int i;\n+  mpfr_t x2rev, last1, last2;\n+\n+  if (x->expr_type != EXPR_CONSTANT || order1->expr_type != EXPR_CONSTANT\n+      || order2->expr_type != EXPR_CONSTANT)\n+    {\n+      gfc_error (\"Sorry, non-constant transformational Bessel function at %L\"\n+\t\t   \" not yet supported\", &order2->where);\n+      return &gfc_bad_expr;\n+    }\n+\n+  n1 = mpz_get_si (order1->value.integer);\n+  n2 = mpz_get_si (order2->value.integer);\n+  result = gfc_get_array_expr (x->ts.type, x->ts.kind, &x->where);\n+  result->rank = 1;\n+  result->shape = gfc_get_shape (1);\n+  mpz_init_set_ui (result->shape[0], MAX (n2-n1+1, 0));\n+\n+  if (n2 < n1)\n+    return result;\n+\n+  /* Special case: x == 0; it is J0(0.0) == 1, JN(N > 0, 0.0) == 0; and\n+     YN(N, 0.0) = -Inf.  */\n+\n+  if (mpfr_cmp_ui (x->value.real, 0.0) == 0)\n+    {\n+      if (!jn && gfc_option.flag_range_check)\n+\t{\n+\t  gfc_error (\"Result of BESSEL_YN is -INF at %L\", &result->where);\n+ \t  gfc_free_expr (result);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      if (jn && n1 == 0)\n+\t{\n+\t  e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+\t  mpfr_set_ui (e->value.real, 1.0, GFC_RND_MODE);\n+\t  gfc_constructor_append_expr (&result->value.constructor, e,\n+\t\t\t\t       &x->where);\n+\t  n1++;\n+\t}\n+\n+      for (i = n1; i <= n2; i++)\n+\t{\n+\t  e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+\t  if (jn)\n+\t    mpfr_set_ui (e->value.real, 0.0, GFC_RND_MODE);\n+\t  else\n+            mpfr_set_inf (e->value.real, -1);\n+\t  gfc_constructor_append_expr (&result->value.constructor, e,\n+\t\t\t\t       &x->where);\n+\t}\n+\n+      return result;\n+    }\n+\n+  /* Use the faster but more verbose recursion algorithm. Bessel functions\n+     are stable for downward recursion and Neumann functions are stable\n+     for upward recursion. It is\n+       x2rev = 2.0/x,\n+       J(N-1, x) = x2rev * N * J(N, x) - J(N+1, x),\n+       Y(N+1, x) = x2rev * N * Y(N, x) - Y(N-1, x).\n+     Cf. http://dlmf.nist.gov/10.74#iv and http://dlmf.nist.gov/10.6#E1  */\n+\n+  gfc_set_model_kind (x->ts.kind);\n+\n+  /* Get first recursion anchor.  */\n+\n+  mpfr_init (last1);\n+  if (jn)\n+    mpfr_jn (last1, n2, x->value.real, GFC_RND_MODE);\n+  else\n+    mpfr_yn (last1, n1, x->value.real, GFC_RND_MODE);\n+\n+  e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (e->value.real, last1, GFC_RND_MODE);\n+  if (range_check (e, jn ? \"BESSEL_JN\" : \"BESSEL_YN\") == &gfc_bad_expr)\n+    {\n+      mpfr_clear (last1);\n+      gfc_free_expr (e);\n+      gfc_free_expr (result);\n+      return &gfc_bad_expr;\n+    }\n+  gfc_constructor_append_expr (&result->value.constructor, e, &x->where);\n+\n+  if (n1 == n2)\n+    {\n+      mpfr_clear (last1);\n+      return result;\n+    }\n+ \n+  /* Get second recursion anchor.  */\n+\n+  mpfr_init (last2);\n+  if (jn)\n+    mpfr_jn (last2, n2-1, x->value.real, GFC_RND_MODE);\n+  else\n+    mpfr_yn (last2, n1+1, x->value.real, GFC_RND_MODE);\n+\n+  e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (e->value.real, last2, GFC_RND_MODE);\n+  if (range_check (e, jn ? \"BESSEL_JN\" : \"BESSEL_YN\") == &gfc_bad_expr)\n+    {\n+      mpfr_clear (last1);\n+      mpfr_clear (last2);\n+      gfc_free_expr (e);\n+      gfc_free_expr (result);\n+      return &gfc_bad_expr;\n+    }\n+  if (jn)\n+     gfc_constructor_insert_expr (&result->value.constructor, e, &x->where, -2);\n+  else \n+    gfc_constructor_append_expr (&result->value.constructor, e, &x->where);\n+\n+  if (n1 + 1 == n2)\n+    {\n+      mpfr_clear (last1);\n+      mpfr_clear (last2);\n+      return result;\n+    }\n+\n+  /* Start actual recursion.  */\n+\n+  mpfr_init (x2rev);\n+  mpfr_ui_div (x2rev, 2, x->value.real, GFC_RND_MODE);\n+ \n+  for (i = 2; i <= n2-n1; i++)\n+    {\n+      e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+      mpfr_mul_si (e->value.real, x2rev, jn ? (n2-i+1) : (n1+i-1),\n+\t\t   GFC_RND_MODE);\n+      mpfr_mul (e->value.real, e->value.real, last2, GFC_RND_MODE);\n+      mpfr_sub (e->value.real, e->value.real, last1, GFC_RND_MODE);\n+\n+      if (range_check (e, jn ? \"BESSEL_JN\" : \"BESSEL_YN\") == &gfc_bad_expr)\n+\tgoto error;\n+\n+      if (jn)\n+\tgfc_constructor_insert_expr (&result->value.constructor, e, &x->where,\n+\t\t\t\t     -i-1);\n+      else\n+\tgfc_constructor_append_expr (&result->value.constructor, e, &x->where);\n+\n+      mpfr_set (last1, last2, GFC_RND_MODE);\n+      mpfr_set (last2, e->value.real, GFC_RND_MODE);\n+    }\n+\n+  mpfr_clear (last1);\n+  mpfr_clear (last2);\n+  mpfr_clear (x2rev);\n+  return result;\n+\n+error:\n+  mpfr_clear (last1);\n+  mpfr_clear (last2);\n+  mpfr_clear (x2rev);\n+  gfc_free_expr (e);\n+  gfc_free_expr (result);\n+  return &gfc_bad_expr;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_bessel_jn2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x)\n+{\n+  return gfc_simplify_bessel_n2 (order1, order2, x, true);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_bessel_y0 (gfc_expr *x)\n {\n@@ -1243,6 +1421,13 @@ gfc_simplify_bessel_yn (gfc_expr *order, gfc_expr *x)\n }\n \n \n+gfc_expr *\n+gfc_simplify_bessel_yn2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x)\n+{\n+  return gfc_simplify_bessel_n2 (order1, order2, x, false);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_bit_size (gfc_expr *e)\n {"}, {"sha": "db26a97676ec50829f3abe03419672dfbc697916", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -1,3 +1,11 @@\n+2010-08-19  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36158\n+\tPR fortran/33197\n+\t* gfortran.dg/bessel_3.f90: New.\n+\t* gfortran.dg/bessel_4.f90: New.\n+\t* gfortran.dg/bessel_5.f90: New.\n+\n 2010-08-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/45290"}, {"sha": "271768dd890f09c94f58cc78f3234118c3722da0", "filename": "gcc/testsuite/gfortran.dg/bessel_3.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003 -Wimplicit-procedure\" }\n+!\n+! PR fortran/36158 - Transformational BESSEL_JN/YN\n+! PR fortran/33197 - F2008 math functions\n+!\n+IMPLICIT NONE\n+print *, SIN (1.0)\n+print *, BESSEL_J0(1.0) ! { dg-error \"has no IMPLICIT type\" })\n+print *, BESSEL_J1(1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_JN(1,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_JN(1,2,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+\n+print *, BESSEL_Y0(1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_Y1(1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_YN(1,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_YN(1,2,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+end"}, {"sha": "7da1bf9aa17d0cdb4fd518b00d65a1f86f9382b1", "filename": "gcc/testsuite/gfortran.dg/bessel_4.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_4.f90?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n+! PR fortran/36158 - Transformational BESSEL_JN/YN\n+! PR fortran/33197 - F2008 math functions\n+!\n+implicit none\n+! OK, elemental function:\n+ print *, bessel_yn(1, [1.0, 2.0])\n+ print *, bessel_yn([1, 2], 2.0)\n+\n+! Wrong, transformational function:\n+! Does not pass check.c -- thus regarded as wrong generic function\n+! and thus rejected with a slightly misleading error message\n+ print *, bessel_yn(1, 2, [2.0, 3.0]) ! { dg-error \"Too many arguments\" }\n+\n+! Wrong in F2008: Negative argument, ok as GNU extension\n+ print *, bessel_yn(-1, 3.0) ! { dg-error \"Extension: Negative argument N \" }\n+\n+! Wrong in F2008: Negative argument -- and no need for a GNU extension\n+! Does not pass check.c -- thus regarded as wrong generic function\n+! and thus rejected with a slightly misleading error message\n+ print *, bessel_yn(-1, 2, 3.0) ! { dg-error \"Too many arguments\" }\n+end"}, {"sha": "aab45cafe17fd373776b9bcf2a175c00d0b9ad2a", "filename": "gcc/testsuite/gfortran.dg/bessel_5.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29698e0f2fa1c77242782bc5c8c6a9327b8d32cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_5.f90?ref=29698e0f2fa1c77242782bc5c8c6a9327b8d32cf", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! { dg-options \"-Wall -fno-range-check\" }\n+!\n+! PR fortran/36158 - Transformational BESSEL_JN/YN\n+! PR fortran/33197 - F2008 math functions\n+!\n+! This is a dg-do run test as the middle end cannot simplify the\n+! the scalarization of the elemental function (cf. PR 45305).\n+!\n+! -Wall has been specified to disabled -pedantic, which warns about the\n+! negative order (GNU extension) to the order of the Bessel functions of\n+! first and second kind.\n+!\n+\n+implicit none\n+integer :: i\n+\n+\n+! Difference to mpfr_jn <= 1 epsilon\n+\n+if (any (abs (BESSEL_JN(2, 5, 2.457) - [(BESSEL_JN(i, 2.457), i = 2, 5)]) &\n+          > epsilon(0.0))) then\n+  print *, 'FAIL 1'\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_yn <= 4 epsilon\n+\n+if (any (abs (BESSEL_YN(2, 5, 2.457) - [(BESSEL_YN(i, 2.457), i = 2, 5)]) &\n+         > epsilon(0.0)*4)) then\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_jn <= 1 epsilon\n+\n+if (any (abs (BESSEL_JN(0, 10, 4.457) &\n+              - [ (BESSEL_JN(i, 4.457), i = 0, 10) ]) &\n+         > epsilon(0.0))) then\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_yn <= 192 epsilon\n+\n+if (any (abs (BESSEL_YN(0, 10, 4.457) &\n+              - [ (BESSEL_YN(i, 4.457), i = 0, 10) ]) &\n+         > epsilon(0.0)*192)) then\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_jn: None.  (Special case: X = 0.0)\n+\n+if (any (BESSEL_JN(0, 10, 0.0) /= [ (BESSEL_JN(i, 0.0), i = 0, 10) ])) &\n+then\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_yn: None.  (Special case: X = 0.0)\n+\n+if (any (BESSEL_YN(0, 10, 0.0) /= [ (BESSEL_YN(i, 0.0), i = 0, 10) ])) &\n+then\n+  call abort()\n+end if\n+\n+\n+! Difference to mpfr_jn <= 1 epsilon\n+\n+if (any (abs (BESSEL_JN(0, 10, 1.0) &\n+              - [ (BESSEL_JN(i, 1.0), i = 0, 10) ]) &\n+         > epsilon(0.0)*1)) then\n+ call abort()\n+end if\n+\n+! Difference to mpfr_yn <= 32 epsilon\n+\n+if (any (abs (BESSEL_YN(0, 10, 1.0) &\n+              - [ (BESSEL_YN(i, 1.0), i = 0, 10) ]) &\n+         > epsilon(0.0)*32)) then\n+  call abort()\n+end if\n+\n+end"}]}