{"sha": "de76b467535988c00f9bc1bd97d9674ddfe84ed1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU3NmI0Njc1MzU5ODhjMDBmOWJjMWJkOTdkOTY3NGRkZmU4NGVkMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-03-22T10:51:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-03-22T10:51:10Z"}, "message": "* calls.c: re-install Mar 16 emit_library_call merge.\n\nFrom-SVN: r32685", "tree": {"sha": "717f3fb899c42bdffeb36d86a18c94d9f094823d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717f3fb899c42bdffeb36d86a18c94d9f094823d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de76b467535988c00f9bc1bd97d9674ddfe84ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de76b467535988c00f9bc1bd97d9674ddfe84ed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de76b467535988c00f9bc1bd97d9674ddfe84ed1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de76b467535988c00f9bc1bd97d9674ddfe84ed1/comments", "author": null, "committer": null, "parents": [{"sha": "7e9d4b22c9add58eae44c1207d8b0e29c1cd1534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9d4b22c9add58eae44c1207d8b0e29c1cd1534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9d4b22c9add58eae44c1207d8b0e29c1cd1534"}], "stats": {"total": 683, "additions": 114, "deletions": 569}, "files": [{"sha": "820a0da78e7addcc4de0cc7223425d2083c08c3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de76b467535988c00f9bc1bd97d9674ddfe84ed1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de76b467535988c00f9bc1bd97d9674ddfe84ed1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de76b467535988c00f9bc1bd97d9674ddfe84ed1", "patch": "@@ -1,3 +1,7 @@\n+Wed Mar 22 11:44:50 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c: re-install Mar 16 emit_library_call merge.\n+\n 2000-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (mem_min_alignment): If not optimizing,"}, {"sha": "c8ef7fea9ca48c6a94846f4298a2e4b5aa247591", "filename": "gcc/calls.c", "status": "modified", "additions": 110, "deletions": 569, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de76b467535988c00f9bc1bd97d9674ddfe84ed1/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de76b467535988c00f9bc1bd97d9674ddfe84ed1/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=de76b467535988c00f9bc1bd97d9674ddfe84ed1", "patch": "@@ -172,6 +172,9 @@ static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n static void load_register_parameters\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t int, rtx *));\n static int libfunc_nothrow\t\t\tPARAMS ((rtx));\n+static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx, int,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t int, va_list));\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPARAMS ((int, rtx, int *, int *));\n@@ -3026,559 +3029,20 @@ libfunc_nothrow (fun)\n \n   return 1;\n }\n-\n-/* Output a library call to function FUN (a SYMBOL_REF rtx)\n-   (emitting the queue unless NO_QUEUE is nonzero),\n-   for a value of mode OUTMODE,\n-   with NARGS different arguments, passed as alternating rtx values\n-   and machine_modes to convert them to.\n-   The rtx values should have been passed through protect_from_queue already.\n-\n-   NO_QUEUE will be true if and only if the library call is a `const' call\n-   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n-   to the variable is_const in expand_call.\n-\n-   NO_QUEUE must be true for const calls, because if it isn't, then\n-   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n-   and will be lost if the libcall sequence is optimized away.\n-\n-   NO_QUEUE must be false for non-const calls, because if it isn't, the\n-   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n-   optimized.  For instance, the instruction scheduler may incorrectly\n-   move memory references across the non-const call.  */\n-\n-void\n-emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n-\t\t\t   int nargs, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  rtx orgfun;\n-  int no_queue;\n-  enum machine_mode outmode;\n-  int nargs;\n-#endif\n-  va_list p;\n-  /* Total size in bytes of all the stack-parms scanned so far.  */\n-  struct args_size args_size;\n-  /* Size of arguments before any adjustments (such as rounding).  */\n-  struct args_size original_args_size;\n-  register int argnum;\n-  rtx fun;\n-  int inc;\n-  int count;\n-  struct args_size alignment_pad;\n-  rtx argblock = 0;\n-  CUMULATIVE_ARGS args_so_far;\n-  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; rtx save_area; };\n-  struct arg *argvec;\n-  int old_inhibit_defer_pop = inhibit_defer_pop;\n-  rtx call_fusage = 0;\n-  int reg_parm_stack_space = 0;\n-  int nothrow;\n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n-  /* Define the boundary of the register parm stack space that needs to be\n-     save, if any.  */\n-  int low_to_save = -1, high_to_save = 0;\n-  rtx save_area = 0;            /* Place that it is saved */\n-#endif\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n-  char *initial_stack_usage_map = stack_usage_map;\n-  int needed;\n-#endif\n-\n-#ifdef REG_PARM_STACK_SPACE\n-  /* Size of the stack reserved for parameter registers.  */\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n-#endif\n-#endif\n-\n-  VA_START (p, nargs);\n-\n-#ifndef ANSI_PROTOTYPES\n-  orgfun = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-#endif\n-\n-  fun = orgfun;\n-\n-  nothrow = libfunc_nothrow (fun);\n-\n-  /* Copy all the libcall-arguments out of the varargs data\n-     and into a vector ARGVEC.\n-\n-     Compute how to pass each argument.  We only support a very small subset\n-     of the full argument passing conventions to limit complexity here since\n-     library functions shouldn't have many args.  */\n-\n-  argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n-  bzero ((char *) argvec, nargs * sizeof (struct arg));\n-\n-\n-  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n-\n-  args_size.constant = 0;\n-  args_size.var = 0;\n-\n-  push_temp_slots ();\n-\n-#ifdef PREFERRED_STACK_BOUNDARY\n-  /* Ensure current function's preferred stack boundary is at least\n-     what we need.  */\n-  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n-    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n-#endif\n-\n-  for (count = 0; count < nargs; count++)\n-    {\n-      rtx val = va_arg (p, rtx);\n-      enum machine_mode mode = va_arg (p, enum machine_mode);\n-\n-      /* We cannot convert the arg value to the mode the library wants here;\n-\t must do it earlier where we know the signedness of the arg.  */\n-      if (mode == BLKmode\n-\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n-\tabort ();\n-\n-      /* On some machines, there's no way to pass a float to a library fcn.\n-\t Pass it as a double instead.  */\n-#ifdef LIBGCC_NEEDS_DOUBLE\n-      if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n-\tval = convert_modes (DFmode, SFmode, val, 0), mode = DFmode;\n-#endif\n-\n-      /* There's no need to call protect_from_queue, because\n-\t either emit_move_insn or emit_push_insn will do that.  */\n-\n-      /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n-\t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n-\tval = force_operand (val, NULL_RTX);\n-\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n-\t{\n-\t  /* We do not support FUNCTION_ARG_CALLEE_COPIES here since it can\n-\t     be viewed as just an efficiency improvement.  */\n-\t  rtx slot = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n-\t  emit_move_insn (slot, val);\n-\t  val = force_operand (XEXP (slot, 0), NULL_RTX);\n-\t  mode = Pmode;\n-\t}\n-#endif\n-\n-      argvec[count].value = val;\n-      argvec[count].mode = mode;\n-\n-      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      argvec[count].partial\n-\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n-#else\n-      argvec[count].partial = 0;\n-#endif\n-\n-      locate_and_pad_parm (mode, NULL_TREE,\n-\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size, &alignment_pad);\n-\n-      if (argvec[count].size.var)\n-\tabort ();\n-\n-      if (reg_parm_stack_space == 0 && argvec[count].partial)\n-\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0\n-\t  || reg_parm_stack_space > 0)\n-\targs_size.constant += argvec[count].size.constant;\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n-    }\n-  va_end (p);\n-\n-#ifdef FINAL_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n-\t\t\t\t\t\t     args_size.var);\n-#endif\n-      \n-  /* If this machine requires an external definition for library\n-     functions, write one out.  */\n-  assemble_external_libcall (fun);\n-\n-  original_args_size = args_size;\n-#ifdef PREFERRED_STACK_BOUNDARY\n-  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n-\t\t\t / STACK_BYTES) * STACK_BYTES);\n-#endif\n-\n-  args_size.constant = MAX (args_size.constant,\n-\t\t\t    reg_parm_stack_space);\n-\n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  args_size.constant -= reg_parm_stack_space;\n-#endif\n-\n-  if (args_size.constant > current_function_outgoing_args_size)\n-    current_function_outgoing_args_size = args_size.constant;\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  /* Since the stack pointer will never be pushed, it is possible for\n-     the evaluation of a parm to clobber something we have already\n-     written to the stack.  Since most function calls on RISC machines\n-     do not use the stack, this is uncommon, but must work correctly.\n-\n-     Therefore, we save any area of the stack that was already written\n-     and that we are using.  Here we set up to do this by making a new\n-     stack usage map from the old one.\n-\n-     Another approach might be to try to reorder the argument\n-     evaluations to avoid this conflicting stack usage.  */\n-\n-  needed = args_size.constant;\n-\n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  /* Since we will be writing into the entire argument area, the\n-     map must be allocated for its entire size, not just the part that\n-     is the responsibility of the caller.  */\n-  needed += reg_parm_stack_space;\n-#endif\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t     needed + 1);\n-#else\n-  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t     needed);\n-#endif\n-  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n-\n-  if (initial_highest_arg_in_use)\n-    bcopy (initial_stack_usage_map, stack_usage_map,\n-\t   initial_highest_arg_in_use);\n-\n-  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-    bzero (&stack_usage_map[initial_highest_arg_in_use],\n-\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n-  needed = 0;\n-\n-  /* The address of the outgoing argument list must not be copied to a\n-     register here, because argblock would be left pointing to the\n-     wrong place after the call to allocate_dynamic_stack_space below.\n-     */\n-\n-  argblock = virtual_outgoing_args_rtx;\n-#else /* not ACCUMULATE_OUTGOING_ARGS */\n-#ifndef PUSH_ROUNDING\n-  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-#ifdef PREFERRED_STACK_BOUNDARY\n-  /* If we push args individually in reverse order, perform stack alignment\n-     before the first push (the last arg).  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  inc = -1;\n-  argnum = nargs - 1;\n-#else\n-  inc = 1;\n-  argnum = 0;\n-#endif\n-\n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n-  /* The argument list is the property of the called routine and it\n-     may clobber it.  If the fixed area has been used for previous\n-     parameters, we must save and restore it.\n-\n-     Here we compute the boundary of the that needs to be saved, if any.  */\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-  for (count = 0; count < reg_parm_stack_space + 1; count++)\n-#else\n-  for (count = 0; count < reg_parm_stack_space; count++)\n-#endif\n-    {\n-      if (count >=  highest_outgoing_arg_in_use\n-\t  || stack_usage_map[count] == 0)\n-\tcontinue;\n-\n-      if (low_to_save == -1)\n-\tlow_to_save = count;\n-\n-      high_to_save = count;\n-    }\n-\n-  if (low_to_save >= 0)\n-    {\n-      int num_to_save = high_to_save - low_to_save + 1;\n-      enum machine_mode save_mode\n-\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n-      rtx stack_area;\n-\n-      /* If we don't have the required alignment, must do this in BLKmode.  */\n-      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n-\tsave_mode = BLKmode;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       - high_to_save)));\n-#else\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       low_to_save)));\n-#endif\n-      if (save_mode == BLKmode)\n-\t{\n-\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t   GEN_INT (num_to_save),\n-\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n-\t}\n-      else\n-\t{\n-\t  save_area = gen_reg_rtx (save_mode);\n-\t  emit_move_insn (save_area, stack_area);\n-\t}\n-    }\n-#endif\n-\t  \n-  /* Push the args that need to be pushed.  */\n-\n-  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n-     are to be pushed.  */\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      int lower_bound, upper_bound, i;\n-#endif\n-\n-      if (! (reg != 0 && partial == 0))\n-\t{\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t  /* If this is being stored into a pre-allocated, fixed-size, stack\n-\t     area, save any previous data at that location.  */\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-\t  /* stack_slot is negative, but we want to index stack_usage_map\n-\t     with positive values.  */\n-\t  upper_bound = -argvec[argnum].offset.constant + 1;\n-\t  lower_bound = upper_bound - argvec[argnum].size.constant;\n-#else\n-\t  lower_bound = argvec[argnum].offset.constant;\n-\t  upper_bound = lower_bound + argvec[argnum].size.constant;\n-#endif\n-\n-\t  for (i = lower_bound; i < upper_bound; i++)\n-\t    if (stack_usage_map[i]\n-\t\t/* Don't store things in the fixed argument area at this point;\n-\t\t   it has already been saved.  */\n-\t\t&& i > reg_parm_stack_space)\n-\t      break;\n-\n-\t  if (i != upper_bound)\n-\t    {\n-\t      /* We need to make a save area.  See what mode we can make it. */\n-\t      enum machine_mode save_mode\n-\t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n-\t\t\t\t MODE_INT, 1);\n-\t      rtx stack_area\n-\t\t= gen_rtx_MEM\n-\t\t  (save_mode,\n-\t\t   memory_address\n-\t\t   (save_mode,\n-\t\t    plus_constant (argblock,\n-\t\t\t\t   argvec[argnum].offset.constant)));\n-\n-\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n-\t      emit_move_insn (argvec[argnum].save_area, stack_area);\n-\t    }\n-#endif\n-\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n-\t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t  /* Now mark the segment we just used.  */\n-\t  for (i = lower_bound; i < upper_bound; i++)\n-\t    stack_usage_map[i] = 1;\n-#endif\n-\n-\t  NO_DEFER_POP;\n-\t}\n-    }\n-\n-#ifndef PUSH_ARGS_REVERSED\n-#ifdef PREFERRED_STACK_BOUNDARY\n-  /* If we pushed args in forward order, perform stack alignment\n-     after pushing the last arg.  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  argnum = nargs - 1;\n-#else\n-  argnum = 0;\n-#endif\n-\n-  fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0);\n-\n-  /* Now load any reg parms into their regs.  */\n-\n-  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n-     are to be pushed.  */\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-\n-      /* Handle calls that pass values in multiple non-contiguous\n-\t locations.  The PA64 has examples of this for library calls.  */\n-      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n-\temit_group_load (reg, val,\n-\t\t\t GET_MODE_SIZE (GET_MODE (val)),\n-\t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n-      else if (reg != 0 && partial == 0)\n-\temit_move_insn (reg, val);\n-\n-      NO_DEFER_POP;\n-    }\n-\n-  /* For version 1.37, try deleting this entirely.  */\n-  if (! no_queue)\n-    emit_queue ();\n-\n-  /* Any regs containing parms remain in use through the call.  */\n-  for (count = 0; count < nargs; count++)\n-    {\n-      rtx reg = argvec[count].reg;\n-      if (reg != 0 && GET_CODE (argvec[count].reg) == PARALLEL)\n-\tuse_group_regs (&call_fusage, reg);\n-      else if (reg != 0)\n-\tuse_reg (&call_fusage, reg);\n-    }\n-\n-  /* Don't allow popping to be deferred, since then\n-     cse'ing of library calls could delete a call and leave the pop.  */\n-  NO_DEFER_POP;\n-\n-  /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n-     will set inhibit_defer_pop to that value.  */\n-\n-  /* The return type is needed to decide how many bytes the function pops.\n-     Signedness plays no role in that, so for simplicity, we pretend it's\n-     always signed.  We also assume that the list of arguments passed has\n-     no impact, so we pretend it is unknown.  */\n-\n-  emit_call_1 (fun, \n-               get_identifier (XSTR (orgfun, 0)), \n-\t       build_function_type (outmode == VOIDmode ? void_type_node\n-\t\t\t\t    : type_for_mode (outmode, 0), NULL_TREE),\n-\t       original_args_size.constant, args_size.constant, 0,\n-\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n-\t       old_inhibit_defer_pop + 1, call_fusage,\n-\t       ((no_queue ? ECF_IS_CONST : 0)\n-\t\t| (nothrow ? ECF_NOTHROW : 0)));\n-\n-  pop_temp_slots ();\n-\n-  /* Now restore inhibit_defer_pop to its actual original value.  */\n-  OK_DEFER_POP;\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-#ifdef REG_PARM_STACK_SPACE\n-  if (save_area)\n-    {\n-      enum machine_mode save_mode = GET_MODE (save_area);\n-#ifdef ARGS_GROW_DOWNWARD\n-      rtx stack_area\n-\t= gen_rtx_MEM (save_mode,\n-\t\t       memory_address (save_mode,\n-\t\t\t\t       plus_constant (argblock,\n-\t\t\t\t\t\t       - high_to_save)));\n-#else\n-      rtx stack_area\n-\t= gen_rtx_MEM (save_mode,\n-\t\t       memory_address (save_mode,\n-\t\t\t\t       plus_constant (argblock, low_to_save)));\n-#endif\n-\n-      if (save_mode != BLKmode)\n-\temit_move_insn (stack_area, save_area);\n-      else\n-\temit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t PARM_BOUNDARY / BITS_PER_UNIT);\n-    }\n-#endif\n-\t  \n-  /* If we saved any argument areas, restore them.  */\n-  for (count = 0; count < nargs; count++)\n-    if (argvec[count].save_area)\n-      {\n-\tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n-\trtx stack_area\n-\t  = gen_rtx_MEM (save_mode,\n-\t\t\t memory_address\n-\t\t\t (save_mode,\n-\t\t\t  plus_constant (argblock,\n-\t\t\t\t\t argvec[count].offset.constant)));\n-\n-\temit_move_insn (stack_area, argvec[count].save_area);\n-      }\n-\n-  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n-  stack_usage_map = initial_stack_usage_map;\n-#endif\n-}\n \f\n-/* Like emit_library_call except that an extra argument, VALUE,\n-   comes second and says where to store the result.\n-   (If VALUE is zero, this function chooses a convenient way\n-   to return the value.\n-\n-   This function returns an rtx for where the value is to be found.\n-   If VALUE is nonzero, VALUE is returned.  */\n-\n-rtx\n-emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n-\t\t\t\t enum machine_mode outmode, int nargs, ...))\n+/* Output a library call to function FUN (a SYMBOL_REF rtx).\n+   The RETVAL parameter specifies whether return value needs to be saved, other \n+   parameters are documented in the emit_library_call function bellow.  */\n+static rtx\n+emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n+     int retval;\n+     rtx orgfun;\n+     rtx value;\n+     int no_queue;\n+     enum machine_mode outmode;\n+     int nargs;\n+     va_list p;\n {\n-#ifndef ANSI_PROTOTYPES\n-  rtx orgfun;\n-  rtx value;\n-  int no_queue;\n-  enum machine_mode outmode;\n-  int nargs;\n-#endif\n-  va_list p;\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n   /* Size of arguments before any adjustments (such as rounding).  */\n@@ -3626,16 +3090,6 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n #endif\n #endif\n \n-  VA_START (p, nargs);\n-\n-#ifndef ANSI_PROTOTYPES\n-  orgfun = va_arg (p, rtx);\n-  value = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-#endif\n-\n   is_const = no_queue;\n   fun = orgfun;\n \n@@ -3650,7 +3104,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \n   /* If this kind of value comes back in memory,\n      decide where in memory it should come back.  */\n-  if (aggregate_value_p (type_for_mode (outmode, 0)))\n+  if (outmode != VOIDmode && aggregate_value_p (type_for_mode (outmode, 0)))\n     {\n #ifdef PCC_STATIC_STRUCT_RETURN\n       rtx pointer_reg\n@@ -3763,7 +3217,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \t     be viewed as just an efficiency improvement.  */\n \t  rtx slot = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n \t  emit_move_insn (slot, val);\n-\t  val = XEXP (slot, 0);\n+\t  val = force_operand (XEXP (slot, 0), NULL_RTX);\n \t  mode = Pmode;\n \t}\n #endif\n@@ -3797,7 +3251,6 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n-  va_end (p);\n \n #ifdef FINAL_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n@@ -4096,16 +3549,19 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n-  /* See the comment in emit_library_call about the function type we build\n-     and pass here.  */\n+  /* The return type is needed to decide how many bytes the function pops.\n+     Signedness plays no role in that, so for simplicity, we pretend it's\n+     always signed.  We also assume that the list of arguments passed has\n+     no impact, so we pretend it is unknown.  */\n \n   emit_call_1 (fun, \n                get_identifier (XSTR (orgfun, 0)),\n-\t       build_function_type (type_for_mode (outmode, 0), NULL_TREE),\n+\t       build_function_type (outmode == VOIDmode ? void_type_node\n+\t\t\t\t    : type_for_mode (outmode, 0), NULL_TREE),\n                original_args_size.constant, args_size.constant,\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       mem_value == 0 ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       mem_value == 0 && outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n \t       old_inhibit_defer_pop + 1, call_fusage,\n \t       ((is_const ? ECF_IS_CONST : 0)\n \t\t| (nothrow ? ECF_NOTHROW : 0)));\n@@ -4116,7 +3572,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */\n-  if (outmode != VOIDmode)\n+  if (outmode != VOIDmode && retval)\n     {\n       if (mem_value)\n \t{\n@@ -4176,6 +3632,91 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n   stack_usage_map = initial_stack_usage_map;\n #endif\n \n+  return value;\n+\n+}\n+\f\n+/* Output a library call to function FUN (a SYMBOL_REF rtx)\n+   (emitting the queue unless NO_QUEUE is nonzero),\n+   for a value of mode OUTMODE,\n+   with NARGS different arguments, passed as alternating rtx values\n+   and machine_modes to convert them to.\n+   The rtx values should have been passed through protect_from_queue already.\n+\n+   NO_QUEUE will be true if and only if the library call is a `const' call\n+   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n+   to the variable is_const in expand_call.\n+\n+   NO_QUEUE must be true for const calls, because if it isn't, then\n+   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n+   and will be lost if the libcall sequence is optimized away.\n+\n+   NO_QUEUE must be false for non-const calls, because if it isn't, the\n+   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n+   optimized.  For instance, the instruction scheduler may incorrectly\n+   move memory references across the non-const call.  */\n+\n+void\n+emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n+\t\t\t   int nargs, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  rtx orgfun;\n+  int no_queue;\n+  enum machine_mode outmode;\n+  int nargs;\n+#endif\n+  va_list p;\n+\n+  VA_START (p, nargs);\n+\n+#ifndef ANSI_PROTOTYPES\n+  orgfun = va_arg (p, rtx);\n+  no_queue = va_arg (p, int);\n+  outmode = va_arg (p, enum machine_mode);\n+  nargs = va_arg (p, int);\n+#endif\n+\n+  emit_library_call_value_1 (0, orgfun, NULL_RTX, no_queue, outmode, nargs, p);\n+\n+  va_end (p);\n+}\n+\f\n+/* Like emit_library_call except that an extra argument, VALUE,\n+   comes second and says where to store the result.\n+   (If VALUE is zero, this function chooses a convenient way\n+   to return the value.\n+\n+   This function returns an rtx for where the value is to be found.\n+   If VALUE is nonzero, VALUE is returned.  */\n+\n+rtx\n+emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n+\t\t\t\t enum machine_mode outmode, int nargs, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  rtx orgfun;\n+  rtx value;\n+  int no_queue;\n+  enum machine_mode outmode;\n+  int nargs;\n+#endif\n+  va_list p;\n+\n+  VA_START (p, nargs);\n+\n+#ifndef ANSI_PROTOTYPES\n+  orgfun = va_arg (p, rtx);\n+  value = va_arg (p, rtx);\n+  no_queue = va_arg (p, int);\n+  outmode = va_arg (p, enum machine_mode);\n+  nargs = va_arg (p, int);\n+#endif\n+\n+  value = emit_library_call_value_1 (1, orgfun, value, no_queue, outmode, nargs, p);\n+\n+  va_end (p);\n+\n   return value;\n }\n \f"}]}