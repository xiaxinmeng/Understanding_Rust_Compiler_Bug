{"sha": "28164eedaf926e36382ca5c8949e1756f2d4200f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxNjRlZWRhZjkyNmUzNjM4MmNhNWM4OTQ5ZTE3NTZmMmQ0MjAwZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-07-11T12:11:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-11T12:11:33Z"}, "message": "expr.c (expand_expr_real_1): Use expand_insn for movmisalign.\n\ngcc/\n\t* expr.c (expand_expr_real_1): Use expand_insn for movmisalign.\n\nFrom-SVN: r176150", "tree": {"sha": "83d2810d6f312e95977f7500df9f9abc47c713b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83d2810d6f312e95977f7500df9f9abc47c713b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28164eedaf926e36382ca5c8949e1756f2d4200f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28164eedaf926e36382ca5c8949e1756f2d4200f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28164eedaf926e36382ca5c8949e1756f2d4200f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28164eedaf926e36382ca5c8949e1756f2d4200f/comments", "author": null, "committer": null, "parents": [{"sha": "f305422365c1f70e00ae6f5d9bc8bc8cad4928ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f305422365c1f70e00ae6f5d9bc8bc8cad4928ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f305422365c1f70e00ae6f5d9bc8bc8cad4928ed"}], "stats": {"total": 43, "additions": 22, "deletions": 21}, "files": [{"sha": "e10d69d23d9cfc39c042a8735a8a9847e5418706", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28164eedaf926e36382ca5c8949e1756f2d4200f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28164eedaf926e36382ca5c8949e1756f2d4200f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28164eedaf926e36382ca5c8949e1756f2d4200f", "patch": "@@ -1,3 +1,7 @@\n+2011-07-11  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* expr.c (expand_expr_real_1): Use expand_insn for movmisalign.\n+\n 2011-07-11  Arthur Loiret  <aloiret@debian.org>\n \n \t* config.gcc (s390-*-linux*): If 'enabled_targets' is 'all', build"}, {"sha": "77039e8edaaaab41660b6ba570cab4506e83f5fa", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28164eedaf926e36382ca5c8949e1756f2d4200f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28164eedaf926e36382ca5c8949e1756f2d4200f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=28164eedaf926e36382ca5c8949e1756f2d4200f", "patch": "@@ -8692,7 +8692,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n \tstruct mem_address addr;\n-\tint icode, align;\n+\tenum insn_code icode;\n+\tint align;\n \n \tget_address_description (exp, &addr);\n \top0 = addr_for_mem_ref (&addr, as, true);\n@@ -8709,18 +8710,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    && ((icode = optab_handler (movmisalign_optab, mode))\n \t\t!= CODE_FOR_nothing))\n \t  {\n-\t    rtx reg, insn;\n+\t    struct expand_operand ops[2];\n \n \t    /* We've already validated the memory, and we're creating a\n-\t       new pseudo destination.  The predicates really can't fail.  */\n-\t    reg = gen_reg_rtx (mode);\n-\n-\t    /* Nor can the insn generator.  */\n-\t    insn = GEN_FCN (icode) (reg, temp);\n-\t    gcc_assert (insn != NULL_RTX);\n-\t    emit_insn (insn);\n-\n-\t    return reg;\n+\t       new pseudo destination.  The predicates really can't fail,\n+\t       nor can the generator.  */\n+\t    create_output_operand (&ops[0], NULL_RTX, mode);\n+\t    create_fixed_operand (&ops[1], temp);\n+\t    expand_insn (icode, 2, ops);\n+\t    return ops[0].value;\n \t  }\n \treturn temp;\n       }\n@@ -8732,7 +8730,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tenum machine_mode address_mode;\n \ttree base = TREE_OPERAND (exp, 0);\n \tgimple def_stmt;\n-\tint icode, align;\n+\tenum insn_code icode;\n+\tint align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n \tif (TREE_CODE (base) == ADDR_EXPR)\n@@ -8806,17 +8805,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    && ((icode = optab_handler (movmisalign_optab, mode))\n \t\t!= CODE_FOR_nothing))\n \t  {\n-\t    rtx reg, insn;\n+\t    struct expand_operand ops[2];\n \n \t    /* We've already validated the memory, and we're creating a\n-\t       new pseudo destination.  The predicates really can't fail.  */\n-\t    reg = gen_reg_rtx (mode);\n-\n-\t    /* Nor can the insn generator.  */\n-\t    insn = GEN_FCN (icode) (reg, temp);\n-\t    emit_insn (insn);\n-\n-\t    return reg;\n+\t       new pseudo destination.  The predicates really can't fail,\n+\t       nor can the generator.  */\n+\t    create_output_operand (&ops[0], NULL_RTX, mode);\n+\t    create_fixed_operand (&ops[1], temp);\n+\t    expand_insn (icode, 2, ops);\n+\t    return ops[0].value;\n \t  }\n \treturn temp;\n       }"}]}