{"sha": "b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRiNGRiOTQ0ZGMyM2RkNTM4Yjc0MmI0NzM1ZmI0YmY3NGI4Y2ZmYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T18:46:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T18:46:58Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r223", "tree": {"sha": "17ce2df734d4d21ff9a135a09e95a3b3a029fe1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17ce2df734d4d21ff9a135a09e95a3b3a029fe1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b4db944dc23dd538b742b4735fb4bf74b8cffa/comments", "author": null, "committer": null, "parents": [{"sha": "70beb075423137ae0c28fd21fe8cbd9395bf61f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70beb075423137ae0c28fd21fe8cbd9395bf61f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70beb075423137ae0c28fd21fe8cbd9395bf61f5"}], "stats": {"total": 26, "additions": 22, "deletions": 4}, "files": [{"sha": "b644624d9bb3aca670ded2721e7fbe69fc63e6fb", "filename": "gcc/global.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b4db944dc23dd538b742b4735fb4bf74b8cffa/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b4db944dc23dd538b742b4735fb4bf74b8cffa/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "patch": "@@ -308,15 +308,33 @@ global_alloc (file)\n \n   /* Track which registers have already been used.  Start with registers\n      explicitly in the rtl, then registers allocated by local register\n-     allocation.\n-     \n-     We consider registers that do not have to be saved over calls as if\n-     they were already used since there is no cost in using them.  */\n+     allocation.  */\n \n   CLEAR_HARD_REG_SET (regs_used_so_far);\n+#ifdef LEAF_REGISTERS\n+  /* If we are doing the leaf function optimization, and this is a leaf\n+     function, it means that the registers that take work to save are those\n+     that need a register window.  So prefer the ones that can be used in\n+     a leaf function.  */\n+  {\n+    char *cheap_regs;\n+    static char leaf_regs[] = LEAF_REGISTERS;\n+\n+    if (only_leaf_regs_used () && leaf_function_p ())\n+      cheap_regs = leaf_regs;\n+    else\n+      cheap_regs = call_used_regs;\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (regs_ever_live[i] || cheap_regs[i])\n+\tSET_HARD_REG_BIT (regs_used_so_far, i);\n+  }\n+#else\n+  /* We consider registers that do not have to be saved over calls as if\n+     they were already used since there is no cost in using them.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i] || call_used_regs[i])\n       SET_HARD_REG_BIT (regs_used_so_far, i);\n+#endif\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] >= 0)"}]}