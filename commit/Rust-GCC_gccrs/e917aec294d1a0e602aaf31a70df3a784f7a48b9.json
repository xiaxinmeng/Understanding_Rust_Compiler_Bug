{"sha": "e917aec294d1a0e602aaf31a70df3a784f7a48b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxN2FlYzI5NGQxYTBlNjAyYWFmMzFhNzBkZjNhNzg0ZjdhNDhiOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-03T09:47:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:47:07Z"}, "message": "sem_aggr.adb, [...]: Minor reformatting\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb, sem_ch3.adb, lib.ads, gnatcmd.adb, prj-proc.adb,\n\tmake.adb, lib-writ.adb, prj-part.adb, prj-part.ads, prj-ext.adb,\n\tfname-uf.adb, prj-ext.ads, prj.adb, prj.ads, sem_attr.adb, alfa.adb,\n\tprj-makr.adb, errout.adb, makeutl.adb, makeutl.ads, restrict.ads,\n\tsem_ch6.adb, g-pehage.adb, clean.adb, put_alfa.adb, lib-xref-alfa.adb,\n\tprj-nmsc.adb, prj-nmsc.ads, sem_ch8.adb, prj-pars.ads, exp_aggr.adb,\n\tprj-attr.ads, sem_ch13.adb, get_alfa.adb, prj-env.adb, prj-env.ads,\n\talfa_test.adb, prj-tree.adb, prj-tree.ads, einfo.ads: Minor reformatting\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* repinfo.adb (List_Mechanism): Add handling of\n\tConvention_Ada_Pass_By_XXX.\n\t* sem_mech.adb (Set_Mechanism): Ditto.\n\t* sem_prag.adb (Process_Convention): Add entries for\n\tConvention_Ada_Pass_By_XXX.\n\t* snames.adb-tmpl, snames.ads-tmpl: Ditto.\n\nFrom-SVN: r177252", "tree": {"sha": "bf32fcc18f39f261c97a358abbe5ce7237af61a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf32fcc18f39f261c97a358abbe5ce7237af61a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e917aec294d1a0e602aaf31a70df3a784f7a48b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e917aec294d1a0e602aaf31a70df3a784f7a48b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e917aec294d1a0e602aaf31a70df3a784f7a48b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e917aec294d1a0e602aaf31a70df3a784f7a48b9/comments", "author": null, "committer": null, "parents": [{"sha": "49bfcf43817fb7d36f168ef2ba992b652747e0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bfcf43817fb7d36f168ef2ba992b652747e0b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49bfcf43817fb7d36f168ef2ba992b652747e0b2"}], "stats": {"total": 1040, "additions": 564, "deletions": 476}, "files": [{"sha": "5cd400aea4df986fc1248cd49d781fd5465e4b2f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1,3 +1,23 @@\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aggr.adb, sem_ch3.adb, lib.ads, gnatcmd.adb, prj-proc.adb,\n+\tmake.adb, lib-writ.adb, prj-part.adb, prj-part.ads, prj-ext.adb,\n+\tfname-uf.adb, prj-ext.ads, prj.adb, prj.ads, sem_attr.adb, alfa.adb,\n+\tprj-makr.adb, errout.adb, makeutl.adb, makeutl.ads, restrict.ads,\n+\tsem_ch6.adb, g-pehage.adb, clean.adb, put_alfa.adb, lib-xref-alfa.adb,\n+\tprj-nmsc.adb, prj-nmsc.ads, sem_ch8.adb, prj-pars.ads, exp_aggr.adb,\n+\tprj-attr.ads, sem_ch13.adb, get_alfa.adb, prj-env.adb, prj-env.ads,\n+\talfa_test.adb, prj-tree.adb, prj-tree.ads, einfo.ads: Minor reformatting\n+\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* repinfo.adb (List_Mechanism): Add handling of\n+\tConvention_Ada_Pass_By_XXX.\n+\t* sem_mech.adb (Set_Mechanism): Ditto.\n+\t* sem_prag.adb (Process_Convention): Add entries for\n+\tConvention_Ada_Pass_By_XXX.\n+\t* snames.adb-tmpl, snames.ads-tmpl: Ditto.\n+\n 2011-08-03  Pascal Obry  <obry@adacore.com>\n \n \t* makeutl.adb: Minor reformatting."}, {"sha": "6fd1d8f8aae85706286cfeab8ded7ed380dc0fdb", "filename": "gcc/ada/alfa.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Falfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Falfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -194,7 +194,7 @@ package body ALFA is\n \n       procedure Debug_Put_ALFA is new Put_ALFA;\n \n-      --  Start of processing for palfa\n+   --  Start of processing for palfa\n \n    begin\n       Debug_Put_ALFA;"}, {"sha": "259040a4d2e1bb2f993bf923a36bb6f099f19c01", "filename": "gcc/ada/alfa_test.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Falfa_test.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Falfa_test.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa_test.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -117,6 +117,7 @@ begin\n \n       procedure Put_Char (F : File_Type; C : Character) is\n          Item : Stream_Element_Array (1 .. 1);\n+\n       begin\n          if C /= CR and then C /= EOF then\n             if C = LF then\n@@ -157,6 +158,7 @@ begin\n \n       function Nextc return Character is\n          C : Character;\n+\n       begin\n          C := Get_Char (Infile);\n "}, {"sha": "9bbf11590518bae666c1ca025f2fd0ce549f8c3d", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1875,9 +1875,9 @@ package body Clean is\n                            end if;\n \n                            if not OK\n-                              or else not Prj.Ext.Check\n-                                (Root_Environment.External,\n-                                 Ext_Asgn (Start .. Stop))\n+                             or else not\n+                               Prj.Ext.Check (Root_Environment.External,\n+                                              Ext_Asgn (Start .. Stop))\n                            then\n                               Fail\n                                 (\"illegal external assignment '\""}, {"sha": "e05834c428d37998a6d778fd99a1819f773b842f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -2940,11 +2940,11 @@ package Einfo is\n --       are suppressed.\n \n --    Machine_Radix_10 (Flag84)\n---       Present in decimal types and subtypes, set if the Machine_Radix\n---       is 10, as the result of the specification of a machine radix\n---       representation clause. Note that it is possible for this flag\n---       to be set without having Has_Machine_Radix_Clause True. This\n---       happens when a type is derived from a type with a clause present.\n+--       Present in decimal types and subtypes, set if the Machine_Radix is 10,\n+--       as the result of the specification of a machine radix representation\n+--       clause. Note that it is possible for this flag to be set without\n+--       having Has_Machine_Radix_Clause True. This happens when a type is\n+--       derived from a type with a clause present.\n \n --    Master_Id (Node17)\n --       Present in access types and subtypes. Empty unless Has_Task is\n@@ -2968,18 +2968,17 @@ package Einfo is\n --       entity but not used in this context.\n \n --    Modulus (Uint17) [base type only]\n---       Present in modular types. Contains the modulus. For the binary\n---       case, this will be a power of 2, but if Non_Binary_Modulus is\n---       set, then it will not be a power of 2.\n+--       Present in modular types. Contains the modulus. For the binary case,\n+--       this will be a power of 2, but if Non_Binary_Modulus is set, then it\n+--       will not be a power of 2.\n \n --    Must_Be_On_Byte_Boundary (Flag183)\n---       Present in entities for types and subtypes. Set if objects of\n---       the type must always be allocated on a byte boundary (more\n---       accurately a storage unit boundary). The front end checks that\n---       component clauses respect this rule, and the back end ensures\n---       that record packing does not violate this rule. Currently the\n---       flag is set only for packed arrays longer than 64 bits where\n---       the component size is not a power of 2.\n+--       Present in entities for types and subtypes. Set if objects of the type\n+--       must always be allocated on a byte boundary (more accurately a storage\n+--       unit boundary). The front end checks that component clauses respect\n+--       this rule, and the back end ensures that record packing does not\n+--       violate this rule. Currently the flag is set only for packed arrays\n+--       longer than 64 bits where the component size is not a power of 2.\n \n --    Must_Have_Preelab_Init (Flag208)\n --       Present in entities for types and subtypes. Set in the full type of a"}, {"sha": "6a6142d4121abe60ba09aaab35d4159287fc5dcf", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -752,7 +752,8 @@ package body Errout is\n             null;\n \n          --  If the main unit has not been read yet. the warning must be on\n-         --  a configuration file: gnat.adc or user-defined.\n+         --  a configuration file: gnat.adc or user-defined. This means we\n+         --  are not parsing the main unit yet, so skip following checks.\n \n          elsif No (Cunit (Main_Unit)) then\n             null;"}, {"sha": "27602cd64a66b0fe705395ed99cd1f96e741dba0", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -2174,7 +2174,7 @@ package body Exp_Aggr is\n       begin\n          Btype := Base_Type (Typ);\n          while Is_Derived_Type (Btype)\n-            and then Present (Stored_Constraint (Btype))\n+           and then Present (Stored_Constraint (Btype))\n          loop\n             Parent_Type := Etype (Btype);\n "}, {"sha": "e3a731fefae6553b65188e57c01db54413545cb9", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -73,8 +73,8 @@ package body Fname.UF is\n      Key        => Unit_Name_Type,\n      Hash       => SFN_Hash,\n      Equal      => \"=\");\n-   --  Hash table allowing rapid access to SFN_Table, the element value\n-   --  is an index into this table.\n+   --  Hash table allowing rapid access to SFN_Table, the element value is an\n+   --  index into this table.\n \n    type SFN_Pattern_Entry is record\n       Pat : String_Ptr;   -- File name pattern (with asterisk in it)\n@@ -91,9 +91,8 @@ package body Fname.UF is\n      Table_Initial        => 10,\n      Table_Increment      => 100,\n      Table_Name           => \"SFN_Patterns\");\n-   --  Table recording all calls to Set_File_Name_Pattern. Note that the\n-   --  first two entries are set to represent the standard GNAT rules\n-   --  for file naming.\n+   --  Table recording calls to Set_File_Name_Pattern. Note that the first two\n+   --  entries are set to represent the standard GNAT rules for file naming.\n \n    -----------------------\n    -- File_Name_Of_Body --\n@@ -127,18 +126,18 @@ package body Fname.UF is\n      (Fname : File_Name_Type) return Expected_Unit_Type\n    is\n    begin\n-      --  In syntax checking only mode or in multiple unit per file mode,\n-      --  there can be more than one unit in a file, so the file name is\n-      --  not a useful guide to the nature of the unit.\n+      --  In syntax checking only mode or in multiple unit per file mode, there\n+      --  can be more than one unit in a file, so the file name is not a useful\n+      --  guide to the nature of the unit.\n \n       if Operating_Mode = Check_Syntax\n         or else Multiple_Unit_Index /= 0\n       then\n          return Unknown;\n       end if;\n \n-      --  Search the file mapping table, if we find an entry for this\n-      --  file we know whether it is a spec or a body.\n+      --  Search the file mapping table, if we find an entry for this file we\n+      --  know whether it is a spec or a body.\n \n       for J in SFN_Table.First .. SFN_Table.Last loop\n          if Fname = SFN_Table.Table (J).F then\n@@ -150,8 +149,8 @@ package body Fname.UF is\n          end if;\n       end loop;\n \n-      --  If no entry in file naming table, assume .ads/.adb for spec/body\n-      --  and return unknown if we have neither of these two cases.\n+      --  If no entry in file naming table, assume .ads/.adb for spec/body and\n+      --  return unknown if we have neither of these two cases.\n \n       Get_Name_String (Fname);\n \n@@ -179,8 +178,8 @@ package body Fname.UF is\n       --  Set to 's' or 'b' for spec or body or to 'u' for a subunit\n \n       Unit_Char_Search : Character;\n-      --  Same as Unit_Char, except that in the case of 'u' for a subunit,\n-      --  we set Unit_Char_Search to 'b' if we do not find a subunit match.\n+      --  Same as Unit_Char, except that in the case of 'u' for a subunit, we\n+      --  set Unit_Char_Search to 'b' if we do not find a subunit match.\n \n       N : Int;\n \n@@ -189,8 +188,8 @@ package body Fname.UF is\n       --  Path name and File name for mapping\n \n    begin\n-      --  Null or error name means that some previous error occurred\n-      --  This is an unrecoverable error, so signal it.\n+      --  Null or error name means that some previous error occurred. This is\n+      --  an unrecoverable error, so signal it.\n \n       if Uname in Error_Unit_Name_Or_No_Unit_Name then\n          raise Unrecoverable_Error;\n@@ -200,8 +199,8 @@ package body Fname.UF is\n \n       Fname := Mapped_File_Name (Uname);\n \n-      --  If the unit name is already mapped, return the corresponding\n-      --  file name from the map.\n+      --  If the unit name is already mapped, return the corresponding file\n+      --  name from the map.\n \n       if Fname /= No_File then\n          return Fname;\n@@ -232,9 +231,9 @@ package body Fname.UF is\n \n       --    _and_.ads\n \n-      --  which is bit peculiar, but we keep it that way. This means that\n-      --  we avoid bombs due to writing a bad file name, and w get expected\n-      --  error processing downstream, e.g. a compilation following gnatchop.\n+      --  which is bit peculiar, but we keep it that way. This means that we\n+      --  avoid bombs due to writing a bad file name, and w get expected error\n+      --  processing downstream, e.g. a compilation following gnatchop.\n \n       if Name_Buffer (1) = '\"' then\n          Get_Name_String (Uname);\n@@ -283,12 +282,12 @@ package body Fname.UF is\n       --  Start of search through pattern table\n \n       begin\n-         --  Search pattern table to find a matching entry. In the general\n-         --  case we do two complete searches. The first time through we\n-         --  stop only if a matching file is found, the second time through\n-         --  we accept the first match regardless. Note that there will\n-         --  always be a match the second time around, because of the\n-         --  default entries at the end of the table.\n+         --  Search pattern table to find a matching entry. In the general case\n+         --  we do two complete searches. The first time through we stop only\n+         --  if a matching file is found, the second time through we accept the\n+         --  first match regardless. Note that there will always be a match the\n+         --  second time around, because of the default entries at the end of\n+         --  the table.\n \n          for No_File_Check in False .. True loop\n             Unit_Char_Search := Unit_Char;\n@@ -345,8 +344,8 @@ package body Fname.UF is\n \n                            J := J + Dotl;\n \n-                        --  Skip past wide char sequences to avoid messing\n-                        --  with dot characters that are part of a sequence.\n+                        --  Skip past wide char sequences to avoid messing with\n+                        --  dot characters that are part of a sequence.\n \n                         elsif Name_Buffer (J) = ASCII.ESC\n                           or else (Upper_Half_Encoding\n@@ -421,8 +420,8 @@ package body Fname.UF is\n                         Name_Len := Name_Len + Ext'Length;\n                      end;\n \n-                  --  Case of no extension present, straight krunch on\n-                  --  the entire file name.\n+                  --  Case of no extension present, straight krunch on the\n+                  --  entire file name.\n \n                   else\n                      Krunch\n@@ -435,9 +434,9 @@ package body Fname.UF is\n                   Fnam := Name_Find;\n \n                   --  If we are in the second search of the table, we accept\n-                  --  the file name without checking, because we know that\n-                  --  the file does not exist, except when May_Fail is True,\n-                  --  in which case we return No_File.\n+                  --  the file name without checking, because we know that the\n+                  --  file does not exist, except when May_Fail is True, in\n+                  --  which case we return No_File.\n \n                   if No_File_Check then\n                      if May_Fail then\n@@ -451,26 +450,25 @@ package body Fname.UF is\n                   else\n                      Pname := Find_File (Fnam, Source);\n \n-                     --  If it does exist, we add it to the mappings and\n-                     --  return the file name.\n+                     --  If it does exist, we add it to the mappings and return\n+                     --  the file name.\n \n                      if Pname /= No_File then\n \n-                        --  Add to mapping, so that we don't do another\n-                        --  path search in Find_File for this file name\n-                        --  and, if we use a mapping file, we are ready\n-                        --  to update it at the end of this compilation\n-                        --  for the benefit of other compilation processes.\n+                        --  Add to mapping, so that we don't do another path\n+                        --  search in Find_File for this file name and, if we\n+                        --  use a mapping file, we are ready to update it at\n+                        --  the end of this compilation for the benefit of\n+                        --  other compilation processes.\n \n                         Add_To_File_Map (Get_File_Name.Uname, Fnam, Pname);\n                         return Fnam;\n \n-                     --  If there are only two entries, they are those of\n-                     --  the default GNAT naming scheme. The file does\n-                     --  not exist, but there is no point doing the\n-                     --  second search, because we will end up with the\n-                     --  same file name. Just return the file name, or No_File\n-                     --  if May_Fail is True.\n+                     --  If there are only two entries, they are those of the\n+                     --  default GNAT naming scheme. The file does not exist,\n+                     --  but there is no point doing the second search, because\n+                     --  we will end up with the same file name. Just return\n+                     --  the file name, or No_File if May_Fail is True.\n \n                      elsif SFN_Patterns.Last = 2 then\n                         if May_Fail then\n@@ -479,8 +477,8 @@ package body Fname.UF is\n                            return Fnam;\n                         end if;\n \n-                     --  The file does not exist, but there may be other\n-                     --  naming scheme. Keep on searching.\n+                     --  The file does not exist, but there may be other naming\n+                     --  scheme. Keep on searching.\n \n                      else\n                         Fnam := No_File;\n@@ -491,9 +489,9 @@ package body Fname.UF is\n                Pent := Pent + 1;\n             end loop;\n \n-            --  If search failed, and was for a subunit, repeat the search\n-            --  with Unit_Char_Search reset to 'b', since in the normal case\n-            --  we simply treat subunits as bodies.\n+            --  If search failed, and was for a subunit, repeat the search with\n+            --  Unit_Char_Search reset to 'b', since in the normal case we\n+            --  simply treat subunits as bodies.\n \n             if Fnam = No_File and then Unit_Char_Search = 'u' then\n                Unit_Char_Search := 'b';\n@@ -504,8 +502,8 @@ package body Fname.UF is\n \n          end loop;\n \n-         --  Something is wrong if search fails completely, since the\n-         --  default entries should catch all possibilities at this stage.\n+         --  Something is wrong if search fails completely, since the default\n+         --  entries should catch all possibilities at this stage.\n \n          raise Program_Error;\n       end;\n@@ -534,8 +532,8 @@ package body Fname.UF is\n       SFN_Table.Init;\n       SFN_Patterns.Init;\n \n-      --  Add default entries to SFN_Patterns.Table to represent the\n-      --  standard default GNAT rules for file name translation.\n+      --  Add default entries to SFN_Patterns.Table to represent the standard\n+      --  default GNAT rules for file name translation.\n \n       SFN_Patterns.Append (New_Val =>\n         (Pat => new String'(\"*.ads\"),\n@@ -590,9 +588,9 @@ package body Fname.UF is\n    begin\n       SFN_Patterns.Increment_Last;\n \n-      --  Move up the last two entries (the default ones) and then\n-      --  put the new entry into the table just before them (we\n-      --  always have the default entries be the last ones).\n+      --  Move up the last two entries (the default ones) and then put the new\n+      --  entry into the table just before them (we always have the default\n+      --  entries be the last ones).\n \n       SFN_Patterns.Table (L + 1) := SFN_Patterns.Table (L);\n       SFN_Patterns.Table (L)     := SFN_Patterns.Table (L - 1);"}, {"sha": "ce2428ddd8598df244c4d5633cd8be7fffda295b", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -909,10 +909,11 @@ package body GNAT.Perfect_Hash_Generators is\n          New_Line (Output);\n       end if;\n \n-      --  Deallocate all the WT components (both initial and reduced\n-      --  ones) to avoid memory leaks.\n+      --  Deallocate all the WT components (both initial and reduced ones) to\n+      --  avoid memory leaks.\n \n       for W in 0 .. WT.Last loop\n+\n          --  Note: WT.Table (NK) is a temporary variable, do not free it since\n          --  this would cause a double free.\n "}, {"sha": "e78badcd0c8bad846366400337f5946f5ca31be2", "filename": "gcc/ada/get_alfa.adb", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fget_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fget_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_alfa.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -29,7 +29,7 @@ with Types; use Types;\n with Ada.IO_Exceptions; use Ada.IO_Exceptions;\n \n procedure Get_ALFA is\n-   C    : Character;\n+   C : Character;\n \n    use ASCII;\n    --  For CR/LF\n@@ -56,9 +56,8 @@ procedure Get_ALFA is\n    -----------------------\n \n    function At_EOL return Boolean;\n-   --  Skips any spaces, then checks if we are the end of a line. If so,\n-   --  returns True (but does not skip over the EOL sequence). If not,\n-   --  then returns False.\n+   --  Skips any spaces, then checks if at the end of a line. If so, returns\n+   --  True (but does not skip the EOL sequence). If not, then returns False.\n \n    procedure Check (C : Character);\n    --  Checks that file is positioned at given character, and if so skips past\n@@ -72,8 +71,8 @@ procedure Get_ALFA is\n \n    procedure Get_Name;\n    --  On entry the file is positioned to a name. On return, the file is\n-   --  positioned past the last character, and the name scanned is returned in\n-   --  Name_Str (1 .. Name_Len).\n+   --  positioned past the last character, and the name scanned is returned\n+   --  in Name_Str (1 .. Name_Len).\n \n    procedure Skip_EOL;\n    --  Called with the current character about to be read being LF or CR. Skips\n@@ -355,10 +354,10 @@ begin\n                XR_Entity_Line : Nat;\n                XR_Entity_Col  : Nat;\n \n-               XR_File        : Nat;\n+               XR_File : Nat;\n                --  Keeps track of the current file (changed by nn|)\n \n-               XR_Scope       : Nat;\n+               XR_Scope : Nat;\n                --  Keeps track of the current scope (changed by nn:)\n \n             begin\n@@ -413,9 +412,10 @@ begin\n                            Rtype := Getc;\n                            Col   := Get_Nat;\n \n-                           pragma Assert         (Rtype = 'r'\n-                                          or else Rtype = 'm'\n-                                          or else Rtype = 's');\n+                           pragma Assert\n+                             (Rtype = 'r' or else\n+                              Rtype = 'm' or else\n+                              Rtype = 's');\n \n                            ALFA_Xref_Table.Append (\n                              (Entity_Name => XR_Entity,\n@@ -438,16 +438,14 @@ begin\n             raise Data_Error;\n       end case;\n \n-      --  For cross reference lines, the end-of-line character has been skipped\n-      --  already.\n+      --  For cross reference lines, the EOL character has been skipped already\n \n       if C /= ' ' then\n          Skip_EOL;\n       end if;\n    end loop;\n \n-   --  Here with all Xrefs stored, complete last entries in File and Scope\n-   --  tables.\n+   --  Here with all Xrefs stored, complete last entries in File/Scope tables\n \n    if ALFA_File_Table.Last /= 0 then\n       ALFA_File_Table.Table (ALFA_File_Table.Last).To_Scope :="}, {"sha": "99d6953c423c00f1e03384bba8480eded8111108", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1349,7 +1349,7 @@ begin\n \n    Prj.Tree.Initialize (Root_Environment, Gnatmake_Flags);\n    Prj.Env.Initialize_Default_Project_Path\n-      (Root_Environment.Project_Path, Target_Name => \"\");\n+     (Root_Environment.Project_Path, Target_Name => \"\");\n \n    Project_Node_Tree := new Project_Node_Tree_Data;\n    Prj.Tree.Initialize (Project_Node_Tree);"}, {"sha": "78a55ed8a599f65e69f7aeb7bea0a9538e7061cf", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1307,8 +1307,7 @@ package body Lib.Writ is\n       --  Output ALFA information if needed\n \n       if Opt.Xref_Active and then ALFA_Mode then\n-         Collect_ALFA (Sdep_Table => Sdep_Table,\n-                       Num_Sdep   => Num_Sdep);\n+         Collect_ALFA (Sdep_Table => Sdep_Table, Num_Sdep => Num_Sdep);\n          Output_ALFA;\n       end if;\n "}, {"sha": "94d2725b7d5375d67352ddf10d740fba59b96776", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -35,7 +35,8 @@ package body ALFA is\n    -- Local Constants --\n    ---------------------\n \n-   --  True for each entity kind used in ALFA\n+   --  Table of ALFA_Entities, True for each entity kind used in ALFA\n+\n    ALFA_Entities : constant array (Entity_Kind) of Boolean :=\n      (E_Void                                       => False,\n       E_Variable                                   => True,\n@@ -171,6 +172,7 @@ package body ALFA is\n       From : Scope_Index;\n \n       S : constant Source_File_Index := Source_Index (U);\n+\n    begin\n       --  Source file could be inexistant as a result of an error, if option\n       --  gnatQ is used.\n@@ -409,11 +411,11 @@ package body ALFA is\n          T2 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op2)));\n \n       begin\n-         --  First test: if entity is in different unit, sort by unit. Notice\n+         --  First test: if entity is in different unit, sort by unit. Note:\n          --  that we use Ent_Scope_File rather than Eun, as Eun may refer to\n-         --  the file where the generic scope is defined, and it may be\n-         --  different from the file where the enclosing scope is defined. It\n-         --  is the latter which matters for a correct order here.\n+         --  the file where the generic scope is defined, which may differ from\n+         --  the file where the enclosing scope is defined. It is the latter\n+         --  which matters for a correct order here.\n \n          if T1.Ent_Scope_File /= T2.Ent_Scope_File then\n             return Dependency_Num (T1.Ent_Scope_File) <\n@@ -472,12 +474,11 @@ package body ALFA is\n          elsif T1.Loc /= T2.Loc then\n             return T1.Loc < T2.Loc;\n \n-         --  Finally, for two locations at the same address, we prefer the one\n-         --  that does NOT have the type 'r' so that a modification or\n-         --  extension takes preference, when there are more than one reference\n-         --  at the same location. As a result, in the case of entities that\n-         --  are in-out actuals, the read reference follows the modify\n-         --  reference.\n+         --  Finally, for two locations at the same address prefer the one that\n+         --  does NOT have the type 'r', so that a modification or extension\n+         --  takes preference, when there are more than one reference at the\n+         --  same location. As a result, in the case of entities that are\n+         --  in-out actuals, the read reference follows the modify reference.\n \n          else\n             return T2.Typ = 'r';\n@@ -507,10 +508,9 @@ package body ALFA is\n          Rnums (J) := J;\n       end loop;\n \n-      --  Eliminate entries not appropriate for ALFA. Should be prior to\n-      --  sorting cross-references, as it discards useless references which do\n-      --  not have a proper format for the comparison function (like no\n-      --  location).\n+      --  Eliminate entries not appropriate for ALFA. Done prior to sorting\n+      --  cross-references, as it discards useless references which do not have\n+      --  a proper format for the comparison function (like no location).\n \n       Eliminate_Before_Sort : declare\n          NR : Nat;\n@@ -553,7 +553,7 @@ package body ALFA is\n       Sorting.Sort (Integer (Nrefs));\n \n       Eliminate_After_Sort : declare\n-         NR    : Nat;\n+         NR : Nat;\n \n          Crloc : Source_Ptr;\n          --  Current reference location\n@@ -583,8 +583,8 @@ package body ALFA is\n          end if;\n \n          --  Eliminate the reference if it is at the same location as the\n-         --  previous one, unless it is a read-reference that indicates that\n-         --  the entity is an in-out actual in a call.\n+         --  previous one, unless it is a read-reference indicating that the\n+         --  entity is an in-out actual in a call.\n \n          NR    := Nrefs;\n          Nrefs := 0;\n@@ -625,8 +625,8 @@ package body ALFA is\n             -----------------------\n \n             function Cur_Scope return Node_Id;\n-            --  Return the scope entity which corresponds to index\n-            --  Cur_Scope_Idx in table ALFA_Scope_Table.\n+            --  Return scope entity which corresponds to index Cur_Scope_Idx in\n+            --  table ALFA_Scope_Table.\n \n             function Is_Future_Scope_Entity (E : Entity_Id) return Boolean;\n             --  Check whether entity E is in ALFA_Scope_Table at index\n@@ -688,10 +688,10 @@ package body ALFA is\n             XE  : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n \n          begin\n-            --  If this assertion fails, this means that the scope which we\n-            --  are looking for is not in ALFA scope table, which reveals\n-            --  either a problem in the construction of the scope table, or an\n-            --  erroneous scope for the current cross-reference.\n+            --  If this assertion fails, the scope which we are looking for is\n+            --  not in ALFA scope table, which reveals either a problem in the\n+            --  construction of the scope table, or an erroneous scope for the\n+            --  current cross-reference.\n \n             pragma Assert (Is_Future_Scope_Entity (XE.Ent_Scope));\n "}, {"sha": "76810c22862dc916062b66edb6d2dc13d8b1ca57", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -555,8 +555,10 @@ package Lib is\n    --  called after Sprint has been called with -gnatD set.\n \n    function Exact_Source_Name (Loc : Source_Ptr) return String;\n-   --  Return the name of an entity at location Loc exactly as written in the\n-   --  source.\n+   --  Return name of entity at location Loc exactly as written in the source.\n+   --  this includes copying the wide character encodings exactly as they were\n+   --  used in the source, so the caller must be aware of the possibility of\n+   --  such encodings.\n \n    function Compilation_Switches_Last return Nat;\n    --  Return the count of stored compilation switches"}, {"sha": "73f022e9d5e09ed48c0d91bf88bf6432472f3e59", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -6650,7 +6650,7 @@ package body Make is\n \n       Prj.Tree.Initialize (Env, Gnatmake_Flags);\n       Prj.Env.Initialize_Default_Project_Path\n-         (Env.Project_Path, Target_Name => \"\");\n+        (Env.Project_Path, Target_Name => \"\");\n \n       Project_Node_Tree := new Project_Node_Tree_Data;\n       Prj.Tree.Initialize (Project_Node_Tree);"}, {"sha": "a8c54e640e099b7f42e60a79a1b03abae49535e9", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -23,12 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Command_Line;          use Ada.Command_Line;\n-\n-with GNAT.Case_Util;            use GNAT.Case_Util;\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.HTable;\n-\n with ALI;      use ALI;\n with Debug;\n with Fname;\n@@ -42,6 +36,12 @@ with Snames;   use Snames;\n with Table;\n with Tempdir;\n \n+with Ada.Command_Line; use Ada.Command_Line;\n+\n+with GNAT.Case_Util;            use GNAT.Case_Util;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.HTable;\n+\n package body Makeutl is\n \n    type Mark_Key is record"}, {"sha": "28b59c57ca49dc76e4d8717c76bf207ef8465b47", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -163,12 +163,11 @@ package Makeutl is\n       Value        : out Variable_Value;\n       Is_Default   : out Boolean);\n    --  Compute the switches (Compilation switches for instance) for the given\n-   --  file. This checks various attributes to see whether there are file\n-   --  specific switches, or else defaults on the switches for the\n-   --  corresponding language.\n-   --  Is_Default is set to False if there were file-specific switches\n-   --  Source_File can be set to No_File to force retrieval of the default\n-   --  switches.\n+   --  file. This checks various attributes to see if there are file specific\n+   --  switches, or else defaults on the switches for the corresponding\n+   --  language. Is_Default is set to False if there were file-specific\n+   --  switches Source_File can be set to No_File to force retrieval of\n+   --  the default switches.\n \n    function Linker_Options_Switches\n      (Project  : Project_Id;"}, {"sha": "03e63d140f99a7d7f4438c596b5b47dc86f12b14", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -154,18 +154,19 @@ package Prj.Attr is\n    --  Attribute is Empty_Attribute.\n    --\n    --  To use this function, the following code should be used:\n+   --\n    --      Pkg : constant Package_Node_Id :=\n-   --        Prj.Attr.Package_Node_Id_Of (Name => <package name>);\n+   --              Prj.Attr.Package_Node_Id_Of (Name => <package name>);\n    --      Att : constant Attribute_Node_Id :=\n-   --        Prj.Attr.Attribute_Node_Id_Of\n-   --          (Name => <attribute name>,\n-   --           Starting_At => First_Attribute_Of (Pkg));\n+   --              Prj.Attr.Attribute_Node_Id_Of\n+   --                (Name        => <attribute name>,\n+   --                 Starting_At => First_Attribute_Of (Pkg));\n    --      Kind : constant Attribute_Kind := Attribute_Kind_Of (Att);\n    --\n-   --  However, you should not use this function once you have an already\n-   --  parsed project tree. Instead, given a Project_Node_Id corresponding to\n-   --  the attribute declaration (\"for Attr (index) use ...\"), it is simpler to\n-   --  use\n+   --  However, do not use this function once you have an already parsed\n+   --  project tree. Instead, given a Project_Node_Id corresponding to the\n+   --  attribute declaration (\"for Attr (index) use ...\"), use for example:\n+   --\n    --      if Case_Insensitive (Attr, Tree) then ...\n \n    procedure Set_Attribute_Kind_Of"}, {"sha": "62852220b37d627c0bb0a7cf8fad062d45a2ef77", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1784,7 +1784,7 @@ package body Prj.Env is\n    begin\n       return Self.Path /= null\n         and then (Self.Path'Length = 0\n-                  or else Self.Path (Self.Path'First) /= '#');\n+                   or else Self.Path (Self.Path'First) /= '#');\n    end Is_Initialized;\n \n    ----------------------\n@@ -1802,7 +1802,8 @@ package body Prj.Env is\n    -------------------------------------\n \n    procedure Initialize_Default_Project_Path\n-     (Self : in out Project_Search_Path; Target_Name : String)\n+     (Self        : in out Project_Search_Path;\n+      Target_Name : String)\n    is\n       Add_Default_Dir : Boolean := True;\n       First           : Positive;\n@@ -1984,9 +1985,7 @@ package body Prj.Env is\n    -- Get_Path --\n    --------------\n \n-   procedure Get_Path\n-     (Self        : Project_Search_Path;\n-      Path        : out String_Access) is\n+   procedure Get_Path (Self : Project_Search_Path; Path : out String_Access) is\n    begin\n       pragma Assert (Is_Initialized (Self));\n       Path := Self.Path;\n@@ -1996,8 +1995,7 @@ package body Prj.Env is\n    -- Set_Path --\n    --------------\n \n-   procedure Set_Path\n-     (Self : in out Project_Search_Path; Path : String) is\n+   procedure Set_Path (Self : in out Project_Search_Path; Path : String) is\n    begin\n       Free (Self.Path);\n       Self.Path := new String'(Path);"}, {"sha": "61c043108b981a4ef482d628a13919826e83946b", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -163,16 +163,16 @@ package Prj.Env is\n    --  efficiency).\n \n    procedure Initialize_Default_Project_Path\n-     (Self : in out Project_Search_Path; Target_Name : String);\n-   --  Initialize Self.\n-   --  It will then contain the default project path on the given target\n-   --  (including directories specified by the environment variables\n-   --  ADA_PROJECT_PATH and GPR_PROJECT_PATH).\n-   --  This does nothing if Self has already been initialized.\n+     (Self        : in out Project_Search_Path;\n+      Target_Name : String);\n+   --  Initialize Self. It will then contain the default project path on the\n+   --  given target (including directories specified by the environment\n+   --  variables ADA_PROJECT_PATH and GPR_PROJECT_PATH). This does nothing if\n+   --  Self has already been initialized.\n \n    procedure Initialize_Empty (Self : in out Project_Search_Path);\n-   --  Initialize self with an empty list of directories.\n-   --  If Self had already been set, it is reset.\n+   --  Initialize self with an empty list of directories. If Self had already\n+   --  been set, it is reset.\n \n    function Is_Initialized (Self : Project_Search_Path) return Boolean;\n    --  Whether Self has been initialized\n@@ -191,19 +191,16 @@ package Prj.Env is\n    --  Calls to this subprogram must be performed before the first call to\n    --  Find_Project below, or PATH will be added at the end of the search path.\n \n-   procedure Get_Path\n-     (Self        : Project_Search_Path;\n-      Path        : out String_Access);\n+   procedure Get_Path (Self : Project_Search_Path; Path : out String_Access);\n    --  Return the current value of the project path, either the value set\n    --  during elaboration of the package or, if procedure Set_Project_Path has\n    --  been called, the value set by the last call to Set_Project_Path. The\n    --  returned value must not be modified.\n    --  Self must have been initialized first.\n \n-   procedure Set_Path\n-     (Self : in out Project_Search_Path; Path : String);\n+   procedure Set_Path (Self : in out Project_Search_Path; Path : String);\n    --  Override the value of the project path. This also removes the implicit\n-   --  default search directories\n+   --  default search directories.\n \n    procedure Find_Project\n      (Self               : in out Project_Search_Path;\n@@ -213,9 +210,7 @@ package Prj.Env is\n    --  Search for a project with the given name either in Directory (which\n    --  often will be the directory contain the project we are currently parsing\n    --  and which we found a reference to another project), or in the project\n-   --  path Self.\n-   --\n-   --  Self must have been initialized first.\n+   --  path Self. Self must have been initialized first.\n    --\n    --  Project_File_Name can optionally contain directories, and the extension\n    --  (.gpr) for the file name is optional."}, {"sha": "b9885c310a753d24543bb5ba1de3dadf4a739b00", "filename": "gcc/ada/prj-ext.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -23,9 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Unchecked_Deallocation;\n with Osint;    use Osint;\n \n+with Ada.Unchecked_Deallocation;\n+\n package body Prj.Ext is\n \n    ----------------\n@@ -65,6 +66,7 @@ package body Prj.Ext is\n       Value         : String)\n    is\n       N : Name_To_Name_Ptr;\n+\n    begin\n       N := new Name_To_Name;\n \n@@ -179,6 +181,7 @@ package body Prj.Ext is\n                Debug_Output (\"Value_Of (\" & Get_Name_String (External_Name)\n                              & \") is default\", With_Default);\n             end if;\n+\n             Free (Env_Value);\n             return With_Default;\n          end if;"}, {"sha": "4ea46080814115c7e69092b5306917cca6daae52", "filename": "gcc/ada/prj-ext.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-ext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-ext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -79,7 +79,8 @@ package Prj.Ext is\n \n private\n \n-   --  Use a Static_HTable, not a Simple_HTable.\n+   --  Use a Static_HTable, rather than a Simple_HTable\n+\n    --  The issue is that we need to be able to copy the contents of the table\n    --  (in Initialize), but this isn't doable for Simple_HTable for which\n    --  iterators do not return the key."}, {"sha": "678492106c1601f49bc6640428c4b478085c73c6", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -802,7 +802,7 @@ package body Prj.Makr is\n \n       Prj.Tree.Initialize (Root_Environment, Flags);\n       Prj.Env.Initialize_Default_Project_Path\n-         (Root_Environment.Project_Path, Target_Name => \"\");\n+        (Root_Environment.Project_Path, Target_Name => \"\");\n \n       Prj.Tree.Initialize (Tree);\n "}, {"sha": "743a1fc79ca9deb27847530dc49dfd3dd8bf9586", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -197,8 +197,8 @@ package body Prj.Nmsc is\n    --  Free the memory occupied by Data\n \n    procedure Check\n-     (Project      : Project_Id;\n-      Data         : in out Tree_Processing_Data);\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data);\n    --  Process the naming scheme for a single project\n \n    procedure Initialize\n@@ -241,12 +241,15 @@ package body Prj.Nmsc is\n    --  directories that match the globbing patterns found in Patterns (for\n    --  instance \"**/*.adb\"). Typically, Patterns will be the value of the\n    --  Source_Dirs or Excluded_Source_Dirs attributes.\n+   --\n    --  Every time such a file or directory is found, the callback is called.\n    --  Resolve_Links indicates whether we should resolve links while\n    --  normalizing names.\n+   --\n    --  In the callback, Pattern_Index is the index within Patterns where the\n    --  expanded pattern was found (1 for the first element of Patterns and\n    --  all its matching directories, then 2,...).\n+   --\n    --  We use a generic and not an access-to-subprogram because in some cases\n    --  this code is compiled with the restriction No_Implicit_Dynamic_Code.\n    --  An error message is raised if a pattern does not match any file.\n@@ -269,15 +272,12 @@ package body Prj.Nmsc is\n       Location            : Source_Ptr       := No_Location);\n    --  Add a new source to the different lists: list of all sources in the\n    --  project tree, list of source of a project and list of sources of a\n-   --  language.\n-   --\n-   --  If Path is specified, the file is also added to Source_Paths_HT.\n-   --\n-   --  Location is used for error messages\n+   --  language. If Path is specified, the file is also added to\n+   --  Source_Paths_HT. Location is used for error messages\n \n    function Canonical_Case_File_Name (Name : Name_Id) return File_Name_Type;\n    --  Same as Osint.Canonical_Case_File_Name but applies to Name_Id.\n-   --  This alters Name_Buffer\n+   --  This alters Name_Buffer.\n \n    function Suffix_Matches\n      (Filename : String;\n@@ -924,16 +924,16 @@ package body Prj.Nmsc is\n    ---------------------------------\n \n    procedure Process_Aggregated_Projects\n-     (Tree         : Project_Tree_Ref;\n-      Project      : Project_Id;\n-      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n-      Flags        : Processing_Flags)\n+     (Tree      : Project_Tree_Ref;\n+      Project   : Project_Id;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Processing_Flags)\n    is\n       Data : Tree_Processing_Data :=\n-        (Tree           => Tree,\n-         Node_Tree      => Node_Tree,\n-         File_To_Source => Files_Htable.Nil,\n-         Flags          => Flags);\n+               (Tree           => Tree,\n+                Node_Tree      => Node_Tree,\n+                File_To_Source => Files_Htable.Nil,\n+                Flags          => Flags);\n \n       Project_Files : constant Prj.Variable_Value :=\n                         Prj.Util.Value_Of\n@@ -949,8 +949,7 @@ package body Prj.Nmsc is\n       procedure Expand_Project_Files is\n         new Expand_Subdirectory_Pattern (Callback => Found_Project_File);\n       --  Search for all project files referenced by the patterns given in\n-      --  parameter.\n-      --  Calls Found_Project_File for each of them\n+      --  parameter. Calls Found_Project_File for each of them.\n \n       ------------------------\n       -- Found_Project_File --\n@@ -966,6 +965,7 @@ package body Prj.Nmsc is\n          --  can only do this when processing the aggregate project, since the\n          --  exact list of project files or project directories can depend on\n          --  scenario variables.\n+         --\n          --  We only load the projects explicitly here, but do not process\n          --  them. For the processing, Prj.Proc will take care of processing\n          --  them, within the same call to Recursive_Process (thus avoiding the\n@@ -1065,7 +1065,7 @@ package body Prj.Nmsc is\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data)\n    is\n-      Prj_Data  : Project_Processing_Data;\n+      Prj_Data : Project_Processing_Data;\n \n    begin\n       Debug_Increase_Indent (\"Check\", Project.Name);\n@@ -6387,6 +6387,7 @@ package body Prj.Nmsc is\n \n                      if Current_Verbosity = High then\n                         Debug_Indent;\n+\n                         if Source.Path /= No_Path_Information then\n                            Write_Line (\"Setting full path for \"\n                                        & Get_Name_String (Source.File)"}, {"sha": "fd45ba91e7f295889c0743e1f90259ca28a691bc", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -43,10 +43,10 @@ private package Prj.Nmsc is\n    --  information is only valid while the external references are preserved.\n \n    procedure Process_Aggregated_Projects\n-     (Tree         : Project_Tree_Ref;\n-      Project      : Project_Id;\n-      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n-      Flags        : Processing_Flags);\n+     (Tree      : Project_Tree_Ref;\n+      Project   : Project_Id;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Processing_Flags);\n    --  Assuming Project is an aggregate project, find out (based on the\n    --  current external references) what are the projects it aggregates.\n    --  This has to be done in phase 1 of the processing, so that we know the"}, {"sha": "fb424a900338640b881ca347f04091cad096007c", "filename": "gcc/ada/prj-pars.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -42,6 +42,7 @@ package Prj.Pars is\n       Env               : in out Prj.Tree.Environment);\n    --  Parse and process a project files and all its imported project files, in\n    --  the project tree In_Tree.\n+   --\n    --  All the project files are parsed (through Prj.Tree) to create a tree in\n    --  memory. That tree is then processed (through Prj.Proc) to create a\n    --  expanded representation of the tree based on the current external"}, {"sha": "dbb5473727c9ad1db39c5fa56a84fce8aba26863", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -440,16 +440,16 @@ package body Prj.Part is\n    -----------\n \n    procedure Parse\n-     (In_Tree                : Project_Node_Tree_Ref;\n-      Project                : out Project_Node_Id;\n-      Project_File_Name      : String;\n-      Errout_Handling        : Errout_Mode := Always_Finalize;\n-      Packages_To_Check      : String_List_Access := All_Packages;\n-      Store_Comments         : Boolean := False;\n-      Current_Directory      : String := \"\";\n-      Is_Config_File         : Boolean;\n-      Env                    : in out Prj.Tree.Environment;\n-      Target_Name            : String := \"\")\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Project           : out Project_Node_Id;\n+      Project_File_Name : String;\n+      Errout_Handling   : Errout_Mode := Always_Finalize;\n+      Packages_To_Check : String_List_Access := All_Packages;\n+      Store_Comments    : Boolean := False;\n+      Current_Directory : String := \"\";\n+      Is_Config_File    : Boolean;\n+      Env               : in out Prj.Tree.Environment;\n+      Target_Name       : String := \"\")\n    is\n       Dummy : Boolean;\n       pragma Warnings (Off, Dummy);"}, {"sha": "1184c77a08d87ea3d761006969d46f96a09a884b", "filename": "gcc/ada/prj-part.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -38,16 +38,16 @@ package Prj.Part is\n    --  either at the beginning of Parse.\n \n    procedure Parse\n-     (In_Tree                : Project_Node_Tree_Ref;\n-      Project                : out Project_Node_Id;\n-      Project_File_Name      : String;\n-      Errout_Handling        : Errout_Mode := Always_Finalize;\n-      Packages_To_Check      : String_List_Access := All_Packages;\n-      Store_Comments         : Boolean := False;\n-      Current_Directory      : String := \"\";\n-      Is_Config_File         : Boolean;\n-      Env                    : in out Prj.Tree.Environment;\n-      Target_Name            : String := \"\");\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Project           : out Project_Node_Id;\n+      Project_File_Name : String;\n+      Errout_Handling   : Errout_Mode := Always_Finalize;\n+      Packages_To_Check : String_List_Access := All_Packages;\n+      Store_Comments    : Boolean := False;\n+      Current_Directory : String := \"\";\n+      Is_Config_File    : Boolean;\n+      Env               : in out Prj.Tree.Environment;\n+      Target_Name       : String := \"\");\n    --  Parse project file and all its imported project files and create a tree.\n    --  Return the node for the project (or Empty_Node if parsing failed). If\n    --  Always_Errout_Finalize is True, Errout.Finalize is called in all cases,"}, {"sha": "f83a05f6c979f29ffe417ea24eaa2b0cf7a393f0", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 139, "deletions": 151, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -125,13 +125,13 @@ package body Prj.Proc is\n    --  Find the package of Project whose name is With_Name\n \n    procedure Process_Declarative_Items\n-     (Project                : Project_Id;\n-      In_Tree                : Project_Tree_Ref;\n-      From_Project_Node      : Project_Node_Id;\n-      Node_Tree              : Project_Node_Tree_Ref;\n-      Env                    : Prj.Tree.Environment;\n-      Pkg                    : Package_Id;\n-      Item                   : Project_Node_Id);\n+     (Project           : Project_Id;\n+      In_Tree           : Project_Tree_Ref;\n+      From_Project_Node : Project_Node_Id;\n+      Node_Tree         : Project_Node_Tree_Ref;\n+      Env               : Prj.Tree.Environment;\n+      Pkg               : Package_Id;\n+      Item              : Project_Node_Id);\n    --  Process declarative items starting with From_Project_Node, and put them\n    --  in declarations Decl. This is a recursive procedure; it calls itself for\n    --  a package declaration or a case construction.\n@@ -460,7 +460,8 @@ package body Prj.Proc is\n    function Get_Attribute_Index\n      (Tree   : Project_Node_Tree_Ref;\n       Attr   : Project_Node_Id;\n-      Index  : Name_Id) return Name_Id is\n+      Index  : Name_Id) return Name_Id\n+   is\n    begin\n       if Index = All_Other_Names\n         or else not Case_Insensitive (Attr, Tree)\n@@ -580,7 +581,7 @@ package body Prj.Proc is\n                   if Present (String_Node) then\n \n                      --  If String_Node is nil, it is an empty list, there is\n-                     --  nothing to do\n+                     --  nothing to do.\n \n                      Value := Expression\n                        (Project                => Project,\n@@ -623,7 +624,7 @@ package body Prj.Proc is\n \n                      loop\n                         --  Add the other element of the literal string list\n-                        --  one after the other\n+                        --  one after the other.\n \n                         String_Node :=\n                           Next_Expression_In_List\n@@ -646,11 +647,10 @@ package body Prj.Proc is\n \n                         String_Element_Table.Increment_Last\n                           (In_Tree.String_Elements);\n-                        In_Tree.String_Elements.Table\n-                          (Last).Next := String_Element_Table.Last\n-                                        (In_Tree.String_Elements);\n-                        Last := String_Element_Table.Last\n-                          (In_Tree.String_Elements);\n+                        In_Tree.String_Elements.Table (Last).Next :=\n+                          String_Element_Table.Last (In_Tree.String_Elements);\n+                        Last :=\n+                          String_Element_Table.Last (In_Tree.String_Elements);\n                         In_Tree.String_Elements.Table (Last) :=\n                           (Value    => Value.Value,\n                            Display_Value => No_Name,\n@@ -706,16 +706,14 @@ package body Prj.Proc is\n                                   (The_Package).Name /= The_Name\n                      loop\n                         The_Package :=\n-                          In_Tree.Packages.Table\n-                            (The_Package).Next;\n+                          In_Tree.Packages.Table (The_Package).Next;\n                      end loop;\n \n                      pragma Assert\n-                       (The_Package /= No_Package,\n-                        \"package not found.\");\n+                       (The_Package /= No_Package, \"package not found.\");\n \n                   elsif Kind_Of (The_Current_Term, From_Project_Node_Tree) =\n-                          N_Attribute_Reference\n+                                                        N_Attribute_Reference\n                   then\n                      The_Package := No_Package;\n                   end if;\n@@ -724,7 +722,7 @@ package body Prj.Proc is\n                     Name_Of (The_Current_Term, From_Project_Node_Tree);\n \n                   if Kind_Of (The_Current_Term, From_Project_Node_Tree) =\n-                       N_Attribute_Reference\n+                                                        N_Attribute_Reference\n                   then\n                      Index :=\n                        Associative_Array_Index_Of\n@@ -742,7 +740,7 @@ package body Prj.Proc is\n                         --  First, if there is a package, look into the package\n \n                         if Kind_Of (The_Current_Term, From_Project_Node_Tree) =\n-                             N_Variable_Reference\n+                                                        N_Variable_Reference\n                         then\n                            The_Variable_Id :=\n                              In_Tree.Packages.Table\n@@ -808,8 +806,7 @@ package body Prj.Proc is\n                      begin\n                         if The_Package /= No_Package then\n                            The_Array :=\n-                             In_Tree.Packages.Table\n-                               (The_Package).Decl.Arrays;\n+                             In_Tree.Packages.Table (The_Package).Decl.Arrays;\n                         else\n                            The_Array := The_Project.Decl.Arrays;\n                         end if;\n@@ -818,23 +815,21 @@ package body Prj.Proc is\n                           and then In_Tree.Arrays.Table\n                                      (The_Array).Name /= The_Name\n                         loop\n-                           The_Array := In_Tree.Arrays.Table\n-                                          (The_Array).Next;\n+                           The_Array := In_Tree.Arrays.Table (The_Array).Next;\n                         end loop;\n \n                         if The_Array /= No_Array then\n-                           The_Element := In_Tree.Arrays.Table\n-                                            (The_Array).Value;\n+                           The_Element :=\n+                             In_Tree.Arrays.Table (The_Array).Value;\n                            Array_Index :=\n                              Get_Attribute_Index\n                                (From_Project_Node_Tree,\n                                 The_Current_Term,\n                                 Index);\n \n                            while The_Element /= No_Array_Element\n-                             and then\n-                             In_Tree.Array_Elements.Table\n-                               (The_Element).Index /= Array_Index\n+                             and then In_Tree.Array_Elements.Table\n+                                        (The_Element).Index /= Array_Index\n                            loop\n                               The_Element :=\n                                 In_Tree.Array_Elements.Table\n@@ -845,8 +840,7 @@ package body Prj.Proc is\n \n                         if The_Element /= No_Array_Element then\n                            The_Variable :=\n-                             In_Tree.Array_Elements.Table\n-                               (The_Element).Value;\n+                             In_Tree.Array_Elements.Table (The_Element).Value;\n \n                         else\n                            if Expression_Kind_Of\n@@ -1037,8 +1031,8 @@ package body Prj.Proc is\n                   end if;\n \n                   Ext_List := Expression_Kind_Of\n-                               (The_Current_Term,\n-                                From_Project_Node_Tree) = List;\n+                                (The_Current_Term,\n+                                 From_Project_Node_Tree) = List;\n \n                   if Ext_List then\n                      Value := Prj.Ext.Value_Of (Env.External, Name, No_Name);\n@@ -1362,7 +1356,7 @@ package body Prj.Proc is\n       From_Project_Node      : Project_Node_Id;\n       From_Project_Node_Tree : Project_Node_Tree_Ref;\n       Env                    : in out Prj.Tree.Environment;\n-      Reset_Tree             : Boolean       := True)\n+      Reset_Tree             : Boolean := True)\n    is\n    begin\n       Process_Project_Tree_Phase_1\n@@ -1410,7 +1404,8 @@ package body Prj.Proc is\n \n       procedure Process_Package_Declaration\n         (Current_Item : Project_Node_Id);\n-      procedure Process_Attribute_Declaration (Current : Project_Node_Id);\n+      procedure Process_Attribute_Declaration\n+        (Current : Project_Node_Id);\n       procedure Process_Case_Construction\n         (Current_Item : Project_Node_Id);\n       procedure Process_Associative_Array\n@@ -1460,12 +1455,13 @@ package body Prj.Proc is\n             --  Loop through all the valid strings for the\n             --  string type and compare to the string value.\n \n-            Current_String := First_Literal_String\n-              (String_Type_Of (Declaration, Node_Tree), Node_Tree);\n+            Current_String :=\n+              First_Literal_String\n+                (String_Type_Of (Declaration, Node_Tree), Node_Tree);\n \n             while Present (Current_String)\n               and then String_Value_Of (Current_String, Node_Tree) /=\n-                 Value.Value\n+                                                                 Value.Value\n             loop\n                Current_String :=\n                  Next_Literal_String (Current_String, Node_Tree);\n@@ -1506,22 +1502,25 @@ package body Prj.Proc is\n       ---------------------------------\n \n       procedure Process_Package_Declaration\n-        (Current_Item : Project_Node_Id) is\n+        (Current_Item : Project_Node_Id)\n+      is\n       begin\n          --  Do not process a package declaration that should be ignored\n \n          if Expression_Kind_Of (Current_Item, Node_Tree) /= Ignored then\n+\n             --  Create the new package\n \n             Package_Table.Increment_Last (In_Tree.Packages);\n \n             declare\n                New_Pkg         : constant Package_Id :=\n-                 Package_Table.Last (In_Tree.Packages);\n+                                   Package_Table.Last (In_Tree.Packages);\n                The_New_Package : Package_Element;\n \n                Project_Of_Renamed_Package : constant Project_Node_Id :=\n-                 Project_Of_Renamed_Package_Of (Current_Item, Node_Tree);\n+                                              Project_Of_Renamed_Package_Of\n+                                                (Current_Item, Node_Tree);\n \n             begin\n                --  Set the name of the new package\n@@ -1560,10 +1559,10 @@ package body Prj.Proc is\n                           Name_Of (Current_Item, Node_Tree));\n \n                   begin\n-                     --  For a renamed package, copy the declarations of\n-                     --  the renamed package, but set all the locations\n-                     --  to the location of the package name in the\n-                     --  renaming declaration.\n+                     --  For a renamed package, copy the declarations of the\n+                     --  renamed package, but set all the locations to the\n+                     --  location of the package name in the renaming\n+                     --  declaration.\n \n                      Copy_Package_Declarations\n                        (From => In_Tree.Packages.Table (Renamed_Package).Decl,\n@@ -1587,9 +1586,8 @@ package body Prj.Proc is\n                      Project_Level => False);\n                end if;\n \n-               --  Process declarative items (nothing to do when the\n-               --  package is renaming, as the first declarative item is\n-               --  null).\n+               --  Process declarative items (nothing to do when the package is\n+               --  renaming, as the first declarative item is null).\n \n                Process_Declarative_Items\n                  (Project                => Project,\n@@ -1612,11 +1610,11 @@ package body Prj.Proc is\n         (Current_Item : Project_Node_Id)\n       is\n          Current_Item_Name : constant Name_Id :=\n-           Name_Of (Current_Item, Node_Tree);\n+                               Name_Of (Current_Item, Node_Tree);\n          --  The name of the attribute\n \n          Current_Location  : constant Source_Ptr :=\n-           Location_Of (Current_Item, Node_Tree);\n+                               Location_Of (Current_Item, Node_Tree);\n \n          New_Array : Array_Id;\n          --  The new associative array created\n@@ -1633,12 +1631,12 @@ package body Prj.Proc is\n          --  value is.\n \n          Orig_Package_Name : Name_Id := No_Name;\n-         --  The name of the package, if any, where the associative\n-         --  array value is.\n+         --  The name of the package, if any, where the associative array value\n+         --  is located.\n \n          Orig_Package : Package_Id := No_Package;\n-         --  The id of the package, if any, where the associative\n-         --  array value is.\n+         --  The id of the package, if any, where the associative array value\n+         --  is located.\n \n          New_Element : Array_Element_Id := No_Array_Element;\n          --  Id of a new array element created\n@@ -1650,16 +1648,16 @@ package body Prj.Proc is\n          --  Current array element in original associative array\n \n          Next_Element : Array_Element_Id := No_Array_Element;\n-         --  Id of the array element that follows the new element.\n-         --  This is not always nil, because values for the\n-         --  associative array attribute may already have been\n-         --  declared, and the array elements declared are reused.\n+         --  Id of the array element that follows the new element. This is not\n+         --  always nil, because values for the associative array attribute may\n+         --  already have been declared, and the array elements declared are\n+         --  reused.\n \n          Prj : Project_List;\n \n       begin\n-         --  First find if the associative array attribute already\n-         --  has elements declared.\n+         --  First find if the associative array attribute already has elements\n+         --  declared.\n \n          if Pkg /= No_Package then\n             New_Array := In_Tree.Packages.Table (Pkg).Decl.Arrays;\n@@ -1673,8 +1671,8 @@ package body Prj.Proc is\n             New_Array := In_Tree.Arrays.Table (New_Array).Next;\n          end loop;\n \n-         --  If the attribute has never been declared add new entry\n-         --  in the arrays of the project/package and link it.\n+         --  If the attribute has never been declared add new entry in the\n+         --  arrays of the project/package and link it.\n \n          if New_Array = No_Array then\n             Array_Table.Increment_Last (In_Tree.Arrays);\n@@ -1722,8 +1720,7 @@ package body Prj.Proc is\n             Orig_Array := Orig_Project.Decl.Arrays;\n \n          else\n-            --  If in a package, find the package where the value\n-            --  is declared.\n+            --  If in a package, find the package where the value is declared\n \n             Orig_Package_Name :=\n               Name_Of\n@@ -1734,7 +1731,7 @@ package body Prj.Proc is\n                            \"original package not found\");\n \n             while In_Tree.Packages.Table\n-              (Orig_Package).Name /= Orig_Package_Name\n+                    (Orig_Package).Name /= Orig_Package_Name\n             loop\n                Orig_Package := In_Tree.Packages.Table (Orig_Package).Next;\n                pragma Assert (Orig_Package /= No_Package,\n@@ -1770,8 +1767,8 @@ package body Prj.Proc is\n \n                if Prev_Element = No_Array_Element then\n \n-                  --  And there is no array element declared yet,\n-                  --  create a new first array element.\n+                  --  And there is no array element declared yet, create a new\n+                  --  first array element.\n \n                   if In_Tree.Arrays.Table (New_Array).Value =\n                     No_Array_Element\n@@ -1834,8 +1831,8 @@ package body Prj.Proc is\n                  In_Tree.Array_Elements.Table (Orig_Element).Next;\n             end loop;\n \n-            --  Make sure that the array ends here, in case there\n-            --  previously a greater number of elements.\n+            --  Make sure that the array ends here, in case there previously a\n+            --  greater number of elements.\n \n             In_Tree.Array_Elements.Table (New_Element).Next :=\n               No_Array_Element;\n@@ -1850,15 +1847,15 @@ package body Prj.Proc is\n         (Current   : Project_Node_Id;\n          New_Value : Variable_Value)\n       is\n-         Name : constant Name_Id := Name_Of (Current, Node_Tree);\n+         Name             : constant Name_Id := Name_Of (Current, Node_Tree);\n          Current_Location : constant Source_Ptr :=\n-           Location_Of (Current, Node_Tree);\n+                              Location_Of (Current, Node_Tree);\n \n          Index_Name : Name_Id :=\n-           Associative_Array_Index_Of (Current, Node_Tree);\n+                        Associative_Array_Index_Of (Current, Node_Tree);\n \n          Source_Index : constant Int :=\n-           Source_Index_Of (Current, Node_Tree);\n+                          Source_Index_Of (Current, Node_Tree);\n \n          The_Array : Array_Id;\n          Elem      : Array_Element_Id := No_Array_Element;\n@@ -1882,10 +1879,9 @@ package body Prj.Proc is\n             The_Array := In_Tree.Arrays.Table (The_Array).Next;\n          end loop;\n \n-         --  If the array cannot be found, create a new entry\n-         --  in the list. As The_Array_Element is initialized\n-         --  to No_Array_Element, a new element will be\n-         --  created automatically later\n+         --  If the array cannot be found, create a new entry in the list.\n+         --  As The_Array_Element is initialized to No_Array_Element, a new\n+         --  element will be created automatically later\n \n          if The_Array = No_Array then\n             Array_Table.Increment_Last (In_Tree.Arrays);\n@@ -1914,14 +1910,14 @@ package body Prj.Proc is\n             Elem := In_Tree.Arrays.Table (The_Array).Value;\n          end if;\n \n-         --  Look in the list, if any, to find an element\n-         --  with the same index and same source index.\n+         --  Look in the list, if any, to find an element with the same index\n+         --  and same source index.\n \n          while Elem /= No_Array_Element\n            and then\n              (In_Tree.Array_Elements.Table (Elem).Index /= Index_Name\n-              or else\n-                In_Tree.Array_Elements.Table (Elem).Src_Index /= Source_Index)\n+               or else\n+                 In_Tree.Array_Elements.Table (Elem).Src_Index /= Source_Index)\n          loop\n             Elem := In_Tree.Array_Elements.Table (Elem).Next;\n          end loop;\n@@ -1946,8 +1942,8 @@ package body Prj.Proc is\n             In_Tree.Arrays.Table (The_Array).Value := Elem;\n \n          else\n-            --  An element with the same index already exists,\n-            --  just replace its value with the new one.\n+            --  An element with the same index already exists, just replace its\n+            --  value with the new one.\n \n             In_Tree.Array_Elements.Table (Elem).Value := New_Value;\n          end if;\n@@ -1968,9 +1964,11 @@ package body Prj.Proc is\n          New_Value    : Variable_Value)\n       is\n          Name : constant Name_Id := Name_Of (Current_Item, Node_Tree);\n-         Var : Variable_Id := No_Variable;\n+         Var  : Variable_Id := No_Variable;\n+\n          Is_Attribute : constant Boolean :=\n-           Kind_Of (Current_Item, Node_Tree) = N_Attribute_Declaration;\n+                          Kind_Of (Current_Item, Node_Tree) =\n+                            N_Attribute_Declaration;\n \n       begin\n          --  First, find the list where to find the variable or attribute.\n@@ -1998,13 +1996,12 @@ package body Prj.Proc is\n             Var := In_Tree.Variable_Elements.Table (Var).Next;\n          end loop;\n \n-         --  If it has not been declared, create a new entry\n-         --  in the list.\n+         --  If it has not been declared, create a new entry in the list\n \n          if Var = No_Variable then\n \n-            --  All single string attribute should already have\n-            --  been declared with a default empty string value.\n+            --  All single string attribute should already have been declared\n+            --  with a default empty string value.\n \n             pragma Assert\n               (not Is_Attribute,\n@@ -2030,8 +2027,8 @@ package body Prj.Proc is\n                Project.Decl.Variables := Var;\n             end if;\n \n-            --  If the variable/attribute has already been\n-            --  declared, just change the value.\n+            --  If the variable/attribute has already been declared, just\n+            --  change the value.\n \n          else\n             In_Tree.Variable_Elements.Table (Var).Value := New_Value;\n@@ -2042,28 +2039,25 @@ package body Prj.Proc is\n       -- Process_Expression --\n       ------------------------\n \n-      procedure Process_Expression\n-        (Current : Project_Node_Id)\n-      is\n+      procedure Process_Expression (Current : Project_Node_Id) is\n          New_Value : Variable_Value :=\n-           Expression\n-             (Project                => Project,\n-              In_Tree                => In_Tree,\n-              From_Project_Node      => From_Project_Node,\n-              From_Project_Node_Tree => Node_Tree,\n-              Env                    => Env,\n-              Pkg                    => Pkg,\n-              First_Term             =>\n-                Tree.First_Term\n-                  (Expression_Of (Current, Node_Tree), Node_Tree),\n-              Kind                 => Expression_Kind_Of (Current, Node_Tree));\n+                       Expression\n+                         (Project                => Project,\n+                          In_Tree                => In_Tree,\n+                          From_Project_Node      => From_Project_Node,\n+                          From_Project_Node_Tree => Node_Tree,\n+                          Env                    => Env,\n+                          Pkg                    => Pkg,\n+                          First_Term             =>\n+                            Tree.First_Term\n+                              (Expression_Of (Current, Node_Tree), Node_Tree),\n+                          Kind                 =>\n+                            Expression_Kind_Of (Current, Node_Tree));\n \n       begin\n          --  Process a typed variable declaration\n \n-         if Kind_Of (Current, Node_Tree) =\n-           N_Typed_Variable_Declaration\n-         then\n+         if Kind_Of (Current, Node_Tree) = N_Typed_Variable_Declaration then\n             Check_Or_Set_Typed_Variable (New_Value, Current);\n          end if;\n \n@@ -2094,7 +2088,7 @@ package body Prj.Proc is\n       -------------------------------\n \n       procedure Process_Case_Construction\n-        (Current_Item             : Project_Node_Id)\n+        (Current_Item : Project_Node_Id)\n       is\n          The_Project : Project_Id := Project;\n          --  The id of the project of the case variable\n@@ -2123,8 +2117,7 @@ package body Prj.Proc is\n             Name   : Name_Id     := No_Name;\n \n          begin\n-            --  If a project was specified for the case variable,\n-            --  get its id.\n+            --  If a project was specified for the case variable, get its id\n \n             if Present (Project_Node_Of (Variable_Node, Node_Tree)) then\n                Name :=\n@@ -2134,8 +2127,7 @@ package body Prj.Proc is\n                  Imported_Or_Extended_Project_From (Project, Name);\n             end if;\n \n-            --  If a package were specified for the case variable,\n-            --  get its id.\n+            --  If a package was specified for the case variable, get its id\n \n             if Present (Package_Node_Of (Variable_Node, Node_Tree)) then\n                Name :=\n@@ -2146,21 +2138,21 @@ package body Prj.Proc is\n \n             Name := Name_Of (Variable_Node, Node_Tree);\n \n-            --  First, look for the case variable into the package,\n-            --  if any.\n+            --  First, look for the case variable into the package, if any\n \n             if The_Package /= No_Package then\n-               Var_Id := In_Tree.Packages.Table (The_Package).Decl.Variables;\n                Name := Name_Of (Variable_Node, Node_Tree);\n+\n+               Var_Id := In_Tree.Packages.Table (The_Package).Decl.Variables;\n                while Var_Id /= No_Variable\n                  and then In_Tree.Variable_Elements.Table (Var_Id).Name /= Name\n                loop\n                   Var_Id := In_Tree.Variable_Elements.Table (Var_Id).Next;\n                end loop;\n             end if;\n \n-            --  If not found in the package, or if there is no\n-            --  package, look at the project level.\n+            --  If not found in the package, or if there is no package, look at\n+            --  the project level.\n \n             if Var_Id = No_Variable\n               and then No (Package_Node_Of (Variable_Node, Node_Tree))\n@@ -2175,8 +2167,8 @@ package body Prj.Proc is\n \n             if Var_Id = No_Variable then\n \n-               --  Should never happen, because this has already been\n-               --  checked during parsing.\n+               --  Should never happen, because this has already been checked\n+               --  during parsing.\n \n                Write_Line\n                  (\"variable \"\"\" & Get_Name_String (Name) & \"\"\" not found\");\n@@ -2189,15 +2181,16 @@ package body Prj.Proc is\n \n             if The_Variable.Kind /= Single then\n \n-               --  Should never happen, because this has already been\n-               --  checked during parsing.\n+               --  Should never happen, because this has already been checked\n+               --  during parsing.\n \n                Write_Line (\"variable\"\"\" & Get_Name_String (Name) &\n                            \"\"\" is not a single string variable\");\n                raise Program_Error;\n             end if;\n \n             --  Get the case variable value\n+\n             Case_Value := The_Variable.Value;\n          end;\n \n@@ -2209,8 +2202,8 @@ package body Prj.Proc is\n          while Present (Case_Item) loop\n             Choice_String := First_Choice_Of (Case_Item, Node_Tree);\n \n-            --  When Choice_String is nil, it means that it is\n-            --  the \"when others =>\" alternative.\n+            --  When Choice_String is nil, it means that it is the\n+            --  \"when others =>\" alternative.\n \n             if No (Choice_String) then\n                Decl_Item := First_Declarative_Item_Of (Case_Item, Node_Tree);\n@@ -2265,8 +2258,9 @@ package body Prj.Proc is\n             when N_Package_Declaration =>\n                Process_Package_Declaration (Current);\n \n+            --  Nothing to process for string type declaration\n+\n             when N_String_Type_Declaration =>\n-               --  There is nothing to process\n                null;\n \n             when N_Attribute_Declaration      |\n@@ -2369,12 +2363,14 @@ package body Prj.Proc is\n          declare\n             Object_Dir : constant Path_Information :=\n                            Project.Object_Directory;\n+\n          begin\n             Prj := In_Tree.Projects;\n             while Prj /= null loop\n                if Prj.Project.Virtual then\n                   Prj.Project.Object_Directory := Object_Dir;\n                end if;\n+\n                Prj := Prj.Next;\n             end loop;\n          end;\n@@ -2463,14 +2459,13 @@ package body Prj.Proc is\n       --  Imported is the id of the last imported project.\n \n       procedure Process_Aggregated_Projects;\n-      --  Process all the projects aggregated in List.\n-      --  This does nothing if the project is not an aggregate project.\n+      --  Process all the projects aggregated in List. This does nothing if the\n+      --  project is not an aggregate project.\n \n       procedure Process_Extended_Project;\n-      --  Process the extended project:\n-      --  inherit all packages from the extended project that are not\n-      --  explicitly defined or renamed. Also inherit the languages, if\n-      --  attribute Languages is not explicitly defined.\n+      --  Process the extended project: inherit all packages from the extended\n+      --  project that are not explicitly defined or renamed. Also inherit the\n+      --  languages, if attribute Languages is not explicitly defined.\n \n       -------------------------------\n       -- Process_Imported_Projects --\n@@ -2611,8 +2606,7 @@ package body Prj.Proc is\n             end loop;\n \n             if Current_Pkg = No_Package then\n-               Package_Table.Increment_Last\n-                 (In_Tree.Packages);\n+               Package_Table.Increment_Last (In_Tree.Packages);\n                Current_Pkg := Package_Table.Last (In_Tree.Packages);\n                In_Tree.Packages.Table (Current_Pkg) :=\n                  (Name   => Element.Name,\n@@ -2622,8 +2616,7 @@ package body Prj.Proc is\n                Project.Decl.Packages := Current_Pkg;\n                Copy_Package_Declarations\n                  (From       => Element.Decl,\n-                  To         =>\n-                    In_Tree.Packages.Table (Current_Pkg).Decl,\n+                  To         => In_Tree.Packages.Table (Current_Pkg).Decl,\n                   New_Loc    => No_Location,\n                   Restricted => True,\n                   In_Tree    => In_Tree);\n@@ -2632,38 +2625,33 @@ package body Prj.Proc is\n             Extended_Pkg := Element.Next;\n          end loop;\n \n-         --  Check if attribute Languages is declared in the\n-         --  extending project.\n+         --  Check if attribute Languages is declared in the extending project\n \n          Attribute1 := Project.Decl.Attributes;\n          while Attribute1 /= No_Variable loop\n-            Attr_Value1 := In_Tree.Variable_Elements.\n-              Table (Attribute1);\n+            Attr_Value1 := In_Tree.Variable_Elements. Table (Attribute1);\n             exit when Attr_Value1.Name = Snames.Name_Languages;\n             Attribute1 := Attr_Value1.Next;\n          end loop;\n \n-         if Attribute1 = No_Variable or else\n-           Attr_Value1.Value.Default\n+         if Attribute1 = No_Variable\n+           or else Attr_Value1.Value.Default\n          then\n-            --  Attribute Languages is not declared in the extending\n-            --  project. Check if it is declared in the project being\n-            --  extended.\n+            --  Attribute Languages is not declared in the extending project.\n+            --  Check if it is declared in the project being extended.\n \n             Attribute2 := Project.Extends.Decl.Attributes;\n             while Attribute2 /= No_Variable loop\n-               Attr_Value2 := In_Tree.Variable_Elements.\n-                 Table (Attribute2);\n+               Attr_Value2 := In_Tree.Variable_Elements.Table (Attribute2);\n                exit when Attr_Value2.Name = Snames.Name_Languages;\n                Attribute2 := Attr_Value2.Next;\n             end loop;\n \n             if Attribute2 /= No_Variable and then\n               not Attr_Value2.Value.Default\n             then\n-               --  As attribute Languages is declared in the project\n-               --  being extended, copy its value for the extending\n-               --  project.\n+               --  As attribute Languages is declared in the project being\n+               --  extended, copy its value for the extending project.\n \n                if Attribute1 = No_Variable then\n                   Variable_Element_Table.Increment_Last"}, {"sha": "3dda4714dd86034a28f960b412c772fb52e98bfb", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -993,7 +993,9 @@ package body Prj.Tree is\n    --------------------\n \n    procedure Override_Flags\n-     (Self : in out Environment; Flags : Prj.Processing_Flags) is\n+     (Self  : in out Environment;\n+      Flags : Prj.Processing_Flags)\n+   is\n    begin\n       Self.Flags := Flags;\n    end Override_Flags;\n@@ -1006,11 +1008,13 @@ package body Prj.Tree is\n      (Self : in out Environment; Flags : Processing_Flags) is\n    begin\n       --  Do not reset the external references, in case we are reloading a\n-      --  project, since we want to preserve the current environment.\n-      --  But we still need to ensure that the external references are properly\n+      --  project, since we want to preserve the current environment. But we\n+      --  still need to ensure that the external references are properly\n       --  initialized.\n \n       Prj.Ext.Initialize (Self.External);\n+\n+      --  Why is this line commented out ???\n       --  Prj.Ext.Reset (Tree.External);\n \n       Self.Flags := Flags;"}, {"sha": "69372ae5d6b006552ca489596722c77e80b624f9", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -40,8 +40,11 @@ package Prj.Tree is\n    -- Environment --\n    -----------------\n \n+   --  The following record contains the context in which projects are parsed\n+   --  and processed (finding importing project, resolving external values,..).\n+\n    type Environment is record\n-      External     : Prj.Ext.External_References;\n+      External : Prj.Ext.External_References;\n       --  External references are stored in this hash table (and manipulated\n       --  through subprograms in prj-ext.ads). External references are\n       --  project-tree specific so that one can load the same tree twice but\n@@ -53,11 +56,9 @@ package Prj.Tree is\n       --  particular when using different compilers with different default\n       --  search directories.\n \n-      Flags        : Prj.Processing_Flags;\n+      Flags : Prj.Processing_Flags;\n       --  Configure errors and warnings\n    end record;\n-   --  This record contains the context in which projects are parsed and\n-   --  processed (finding importing project, resolving external values,...)\n \n    procedure Initialize (Self : in out Environment; Flags : Processing_Flags);\n    --  Initialize a new environment"}, {"sha": "cc5733555a6df36a1a60610508b5eb0b3a670b21", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -49,7 +49,7 @@ package body Prj is\n    The_Empty_String : Name_Id := No_Name;\n \n    Debug_Level : Integer := 0;\n-   --  Current indentation level for debug traces.\n+   --  Current indentation level for debug traces\n \n    type Cst_String_Access is access constant String;\n \n@@ -222,12 +222,14 @@ package body Prj is\n    -------------------\n \n    function Empty_Project\n-     (Qualifier : Project_Qualifier) return Project_Data is\n+     (Qualifier : Project_Qualifier) return Project_Data\n+   is\n    begin\n       Prj.Initialize (Tree => No_Project_Tree);\n \n       declare\n          Data : Project_Data (Qualifier => Qualifier);\n+\n       begin\n          --  Only the fields for which no default value could be provided in\n          --  prj.ads are initialized below\n@@ -253,7 +255,9 @@ package body Prj is\n    procedure Expect (The_Token : Token_Type; Token_Image : String) is\n    begin\n       if Token /= The_Token then\n+\n          --  ??? Should pass user flags here instead\n+\n          Error_Msg (Gnatmake_Flags, Token_Image & \" expected\", Token_Ptr);\n       end if;\n    end Expect;\n@@ -399,10 +403,10 @@ package body Prj is\n    --------------------------------\n \n    procedure For_Every_Project_Imported\n-     (By             : Project_Id;\n-      With_State     : in out State;\n+     (By                 : Project_Id;\n+      With_State         : in out State;\n       Include_Aggregated : Boolean := True;\n-      Imported_First : Boolean := False)\n+      Imported_First     : Boolean := False)\n    is\n       use Project_Boolean_Htable;\n       Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;"}, {"sha": "1e60bdc6f8bae15b890e1e1e2f1deefec879582f", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1102,7 +1102,8 @@ package Prj is\n    --  Free the memory used for List\n \n    procedure Add_Aggregated_Project\n-     (Project : Project_Id; Path : Path_Name_Type);\n+     (Project : Project_Id;\n+      Path    : Path_Name_Type);\n    --  Add a new aggregated project in Project.\n    --  The aggregated project has not been processed yet. This procedure should\n    --  the called while processing the aggregate project, and as a result\n@@ -1111,6 +1112,7 @@ package Prj is\n    ------------------\n    -- Project_Data --\n    ------------------\n+\n    --  The following record describes a project file representation\n \n    type Project_Data (Qualifier : Project_Qualifier := Unspecified) is record\n@@ -1314,9 +1316,10 @@ package Prj is\n       --  in the project tree.\n \n       -----------------------------\n-      -- qualifier-specific data --\n+      -- Qualifier-Specific data --\n       -----------------------------\n-      --  The following fields are only valid for specific types of projects.\n+\n+      --  The following fields are only valid for specific types of projects\n \n       case Qualifier is\n          when Aggregate =>\n@@ -1462,10 +1465,10 @@ package Prj is\n         (Project    : Project_Id;\n          With_State : in out State);\n    procedure For_Every_Project_Imported\n-     (By             : Project_Id;\n-      With_State     : in out State;\n+     (By                 : Project_Id;\n+      With_State         : in out State;\n       Include_Aggregated : Boolean := True;\n-      Imported_First : Boolean := False);\n+      Imported_First     : Boolean := False);\n    --  Call Action for each project imported directly or indirectly by project\n    --  By, as well as extended projects.\n    --"}, {"sha": "58021145d1bbadde195e47159ef60124372a48ef", "filename": "gcc/ada/put_alfa.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fput_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fput_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -32,7 +32,6 @@ begin\n    for J in 1 .. ALFA_File_Table.Last loop\n       declare\n          F     : ALFA_File_Record renames ALFA_File_Table.Table (J);\n-\n          Start : Scope_Index;\n          Stop  : Scope_Index;\n \n@@ -92,10 +91,8 @@ begin\n    for J in 1 .. ALFA_File_Table.Last loop\n       declare\n          F           : ALFA_File_Record renames ALFA_File_Table.Table (J);\n-\n          Start       : Scope_Index;\n          Stop        : Scope_Index;\n-\n          File        : Nat;\n          Scope       : Nat;\n          Entity_Line : Nat;"}, {"sha": "c3e6772ed502a05fb90cfee1fa222accc2d1a342", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -665,19 +665,36 @@ package body Repinfo is\n       Write_Str (\"  convention : \");\n \n       case Convention (Ent) is\n-         when Convention_Ada       => Write_Line (\"Ada\");\n-         when Convention_Intrinsic => Write_Line (\"InLineinsic\");\n-         when Convention_Entry     => Write_Line (\"Entry\");\n-         when Convention_Protected => Write_Line (\"Protected\");\n-         when Convention_Assembler => Write_Line (\"Assembler\");\n-         when Convention_C         => Write_Line (\"C\");\n-         when Convention_CIL       => Write_Line (\"CIL\");\n-         when Convention_COBOL     => Write_Line (\"COBOL\");\n-         when Convention_CPP       => Write_Line (\"C++\");\n-         when Convention_Fortran   => Write_Line (\"Fortran\");\n-         when Convention_Java      => Write_Line (\"Java\");\n-         when Convention_Stdcall   => Write_Line (\"Stdcall\");\n-         when Convention_Stubbed   => Write_Line (\"Stubbed\");\n+         when Convention_Ada                   =>\n+            Write_Line (\"Ada\");\n+         when Convention_Ada_Pass_By_Copy      =>\n+            Write_Line (\"Ada_Pass_By_Copy\");\n+         when Convention_Ada_Pass_By_Reference =>\n+            Write_Line (\"Ada_Pass_By_Reference\");\n+         when Convention_Intrinsic             =>\n+            Write_Line (\"Intrinsic\");\n+         when Convention_Entry                 =>\n+            Write_Line (\"Entry\");\n+         when Convention_Protected             =>\n+            Write_Line (\"Protected\");\n+         when Convention_Assembler             =>\n+            Write_Line (\"Assembler\");\n+         when Convention_C                     =>\n+            Write_Line (\"C\");\n+         when Convention_CIL                   =>\n+            Write_Line (\"CIL\");\n+         when Convention_COBOL                 =>\n+            Write_Line (\"COBOL\");\n+         when Convention_CPP                   =>\n+            Write_Line (\"C++\");\n+         when Convention_Fortran               =>\n+            Write_Line (\"Fortran\");\n+         when Convention_Java                  =>\n+            Write_Line (\"Java\");\n+         when Convention_Stdcall               =>\n+            Write_Line (\"Stdcall\");\n+         when Convention_Stubbed               =>\n+            Write_Line (\"Stubbed\");\n       end case;\n \n       --  Find max length of formal name"}, {"sha": "0c1c5b6cbfa14b6cd02b94984f7a6466d6a62035", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -239,21 +239,21 @@ package Restrict is\n    --  known, V is left at its default of -1 which indicates an unknown count.\n \n    procedure Check_Restriction\n-     (R          : Restriction_Id;\n-      N          : Node_Id;\n-      V          : Uint := Uint_Minus_1);\n+     (R : Restriction_Id;\n+      N : Node_Id;\n+      V : Uint := Uint_Minus_1);\n    --  Wrapper on Check_Restriction with Msg_Issued, with the out-parameter\n    --  being ignored here.\n \n    procedure Check_Restriction_No_Dependence (U : Node_Id; Err : Node_Id);\n    --  Called when a dependence on a unit is created (either implicitly, or by\n-   --  an explicit WITH clause). U is a node for the unit involved, and Err\n-   --  is the node to which an error will be attached if necessary.\n+   --  an explicit WITH clause). U is a node for the unit involved, and Err is\n+   --  the node to which an error will be attached if necessary.\n \n    procedure Check_Elaboration_Code_Allowed (N : Node_Id);\n    --  Tests to see if elaboration code is allowed by the current restrictions\n-   --  settings. This function is called by Gigi when it needs to define\n-   --  an elaboration routine. If elaboration code is not allowed, an error\n+   --  settings. This function is called by Gigi when it needs to define an\n+   --  elaboration routine. If elaboration code is not allowed, an error\n    --  message is posted on the node given as argument.\n \n    procedure Check_SPARK_Restriction"}, {"sha": "71fe0fbbbb3114dce8b4300b55c92101d6fc418c", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1127,21 +1127,22 @@ package body Sem_Aggr is\n \n             Set_Etype (N, Aggr_Typ);  --  May be overridden later on\n \n-            if Pkind = N_Assignment_Statement or else\n-              (Is_Constrained (Typ) and then\n-                 (Pkind = N_Parameter_Association     or else\n-                  Pkind = N_Function_Call             or else\n-                  Pkind = N_Procedure_Call_Statement  or else\n-                  Pkind = N_Generic_Association       or else\n-                  Pkind = N_Formal_Object_Declaration or else\n-                  Pkind = N_Simple_Return_Statement   or else\n-                  Pkind = N_Object_Declaration        or else\n-                  Pkind = N_Component_Declaration     or else\n-                  Pkind = N_Parameter_Specification   or else\n-                  Pkind = N_Qualified_Expression      or else\n-                  Pkind = N_Aggregate                 or else\n-                  Pkind = N_Extension_Aggregate       or else\n-                  Pkind = N_Component_Association))\n+            if Pkind = N_Assignment_Statement\n+              or else (Is_Constrained (Typ)\n+                        and then\n+                          (Pkind = N_Parameter_Association     or else\n+                           Pkind = N_Function_Call             or else\n+                           Pkind = N_Procedure_Call_Statement  or else\n+                           Pkind = N_Generic_Association       or else\n+                           Pkind = N_Formal_Object_Declaration or else\n+                           Pkind = N_Simple_Return_Statement   or else\n+                           Pkind = N_Object_Declaration        or else\n+                           Pkind = N_Component_Declaration     or else\n+                           Pkind = N_Parameter_Specification   or else\n+                           Pkind = N_Qualified_Expression      or else\n+                           Pkind = N_Aggregate                 or else\n+                           Pkind = N_Extension_Aggregate       or else\n+                           Pkind = N_Component_Association))\n             then\n                Aggr_Resolved :=\n                  Resolve_Array_Aggregate\n@@ -1185,6 +1186,7 @@ package body Sem_Aggr is\n                end if;\n \n                Aggr_Subtyp := Any_Composite;\n+\n             else\n                Aggr_Subtyp := Array_Aggr_Subtype (N, Typ);\n             end if;"}, {"sha": "7ece5832a7c74a90eb083cd071b7e1d57f9ac379", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -1289,16 +1289,6 @@ package body Sem_Attr is\n          Check_E2;\n       end Check_Floating_Point_Type_2;\n \n-      ------------------------------------------\n-      -- Check_SPARK_Restriction_On_Attribute --\n-      ------------------------------------------\n-\n-      procedure Check_SPARK_Restriction_On_Attribute is\n-      begin\n-         Error_Msg_Name_1 := Aname;\n-         Check_SPARK_Restriction (\"attribute % is not allowed\", P);\n-      end Check_SPARK_Restriction_On_Attribute;\n-\n       ------------------------\n       -- Check_Integer_Type --\n       ------------------------\n@@ -1540,6 +1530,16 @@ package body Sem_Attr is\n          end if;\n       end Check_Scalar_Type;\n \n+      ------------------------------------------\n+      -- Check_SPARK_Restriction_On_Attribute --\n+      ------------------------------------------\n+\n+      procedure Check_SPARK_Restriction_On_Attribute is\n+      begin\n+         Error_Msg_Name_1 := Aname;\n+         Check_SPARK_Restriction (\"attribute % is not allowed\", P);\n+      end Check_SPARK_Restriction_On_Attribute;\n+\n       ---------------------------\n       -- Check_Standard_Prefix --\n       ---------------------------"}, {"sha": "ac0654143753640d3254e4f7ac130a1b8f81e545", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -7300,7 +7300,8 @@ package body Sem_Ch13 is\n \n             else\n                return Has_Aliased_Components (Base_Type (T1))\n-                 = Has_Aliased_Components (Base_Type (T2));\n+                        =\n+                      Has_Aliased_Components (Base_Type (T2));\n             end if;\n          end if;\n       end if;"}, {"sha": "c37a086b517b2e07b1217c6f0e5f78329b1f6454", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -8636,7 +8636,7 @@ package body Sem_Ch3 is\n       IR : constant Node_Id := Make_Itype_Reference (Sloc (Nod));\n    begin\n \n-      --  Itype references are only created for use by the back-end.\n+      --  Itype references are only created for use by the back-end\n \n       if Inside_A_Generic then\n          return;"}, {"sha": "ca7831e7ef6111253f7eef3f3a0f8b5a1fe357d8", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -629,8 +629,8 @@ package body Sem_Ch6 is\n       if Nkind (N) = N_Simple_Return_Statement then\n          Expr := Expression (N);\n \n-         --  Guard against a malformed expression. The parser may have\n-         --  tried to recover but the node is not analyzable.\n+         --  Guard against a malformed expression. The parser may have tried to\n+         --  recover but the node is not analyzable.\n \n          if Nkind (Expr) = N_Error then\n             Set_Etype (Expr, Any_Type);\n@@ -8614,8 +8614,8 @@ package body Sem_Ch6 is\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent\n-         --  operation was dispatching), so we don't call\n-         --  Check_Dispatching_Operation in that case.\n+         --  operation was dispatching), so Check_Dispatching_Operation is not\n+         --  called in that case.\n \n          if No (Derived_Type)\n            or else Is_Tagged_Type (Derived_Type)"}, {"sha": "e0e1e06ef1caba95fe4887666ad84814dbc1e786", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -708,17 +708,15 @@ package body Sem_Ch8 is\n          Subt : Entity_Id;\n \n       begin\n-         if (Nkind (Nam) = N_Function_Call\n-              or else Nkind (Nam) = N_Explicit_Dereference)\n+         if Nkind_In (Nam, N_Function_Call, N_Explicit_Dereference)\n            and then Is_Composite_Type (Etype (Nam))\n            and then not Is_Constrained (Etype (Nam))\n            and then not Has_Unknown_Discriminants (Etype (Nam))\n            and then Expander_Active\n          then\n-            --  If Actual_Sbutype is already set, nothing to do.\n+            --  If Actual_Subtype is already set, nothing to do\n \n-            if (Ekind (Id) = E_Variable\n-                 or else Ekind (Id) = E_Constant)\n+            if Ekind_In (Id, E_Variable, E_Constant)\n               and then Present (Actual_Subtype (Id))\n             then\n                null;"}, {"sha": "d21e6ae6fa53ac445b279749fad5dec0fc13c792", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -324,6 +324,14 @@ package body Sem_Mech is\n                      null;\n                   end if;\n \n+               --  Special Ada conventions specifying passing mechanism\n+\n+               when Convention_Ada_Pass_By_Copy =>\n+                  Set_Mechanism (Formal, By_Copy);\n+\n+               when Convention_Ada_Pass_By_Reference =>\n+                  Set_Mechanism (Formal, By_Reference);\n+\n                -------\n                -- C --\n                -------"}, {"sha": "840592f289b932d96ed0129f8e2ce38471715421", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -3014,6 +3014,38 @@ package body Sem_Prag is\n \n          Ent := E;\n \n+         --  Ada_Pass_By_Copy special checking\n+\n+         if C = Convention_Ada_Pass_By_Copy then\n+            if not Is_First_Subtype (E) then\n+               Error_Pragma_Arg\n+                 (\"convention `Ada_Pass_By_Copy` only \"\n+                  & \"allowed for types\", Arg2);\n+            end if;\n+\n+            if Is_By_Reference_Type (E) then\n+               Error_Pragma_Arg\n+                 (\"convention `Ada_Pass_By_Copy` not allowed for \"\n+                  & \"by-reference type\", Arg1);\n+            end if;\n+         end if;\n+\n+         --  Ada_Pass_By_Reference special checking\n+\n+         if C = Convention_Ada_Pass_By_Reference then\n+            if not Is_First_Subtype (E) then\n+               Error_Pragma_Arg\n+                 (\"convention `Ada_Pass_By_Reference` only \"\n+                  & \"allowed for types\", Arg2);\n+            end if;\n+\n+            if Is_By_Copy_Type (E) then\n+               Error_Pragma_Arg\n+                 (\"convention `Ada_Pass_By_Reference` not allowed for \"\n+                  & \"by-copy type\", Arg1);\n+            end if;\n+         end if;\n+\n          --  Go to renamed subprogram if present, since convention applies to\n          --  the actual renamed entity, not to the renaming entity. If the\n          --  subprogram is inherited, go to parent subprogram."}, {"sha": "defe9495ee9f14596d4498f6156ad971895280b0", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -137,22 +137,25 @@ package body Snames is\n    function Get_Convention_Id (N : Name_Id) return Convention_Id is\n    begin\n       case N is\n-         when Name_Ada        => return Convention_Ada;\n-         when Name_Assembler  => return Convention_Assembler;\n-         when Name_C          => return Convention_C;\n-         when Name_CIL        => return Convention_CIL;\n-         when Name_COBOL      => return Convention_COBOL;\n-         when Name_CPP        => return Convention_CPP;\n-         when Name_Fortran    => return Convention_Fortran;\n-         when Name_Intrinsic  => return Convention_Intrinsic;\n-         when Name_Java       => return Convention_Java;\n-         when Name_Stdcall    => return Convention_Stdcall;\n-         when Name_Stubbed    => return Convention_Stubbed;\n+         when Name_Ada                   => return Convention_Ada;\n+         when Name_Ada_Pass_By_Copy      => return Convention_Ada_Pass_By_Copy;\n+         when Name_Ada_Pass_By_Reference =>\n+            return Convention_Ada_Pass_By_Reference;\n+         when Name_Assembler             => return Convention_Assembler;\n+         when Name_C                     => return Convention_C;\n+         when Name_CIL                   => return Convention_CIL;\n+         when Name_COBOL                 => return Convention_COBOL;\n+         when Name_CPP                   => return Convention_CPP;\n+         when Name_Fortran               => return Convention_Fortran;\n+         when Name_Intrinsic             => return Convention_Intrinsic;\n+         when Name_Java                  => return Convention_Java;\n+         when Name_Stdcall               => return Convention_Stdcall;\n+         when Name_Stubbed               => return Convention_Stubbed;\n \n          --  If no direct match, then we must have a convention\n          --  identifier pragma that has specified this name.\n \n-         when others          =>\n+         when others                     =>\n             for J in 1 .. Convention_Identifiers.Last loop\n                if N = Convention_Identifiers.Table (J).Name then\n                   return Convention_Identifiers.Table (J).Convention;\n@@ -170,19 +173,22 @@ package body Snames is\n    function Get_Convention_Name (C : Convention_Id) return Name_Id is\n    begin\n       case C is\n-         when Convention_Ada       => return Name_Ada;\n-         when Convention_Assembler => return Name_Assembler;\n-         when Convention_C         => return Name_C;\n-         when Convention_CIL       => return Name_CIL;\n-         when Convention_COBOL     => return Name_COBOL;\n-         when Convention_CPP       => return Name_CPP;\n-         when Convention_Entry     => return Name_Entry;\n-         when Convention_Fortran   => return Name_Fortran;\n-         when Convention_Intrinsic => return Name_Intrinsic;\n-         when Convention_Java      => return Name_Java;\n-         when Convention_Protected => return Name_Protected;\n-         when Convention_Stdcall   => return Name_Stdcall;\n-         when Convention_Stubbed   => return Name_Stubbed;\n+         when Convention_Ada                   => return Name_Ada;\n+         when Convention_Ada_Pass_By_Copy      => return Name_Ada_Pass_By_Copy;\n+         when Convention_Ada_Pass_By_Reference =>\n+            return Name_Ada_Pass_By_Reference;\n+         when Convention_Assembler             => return Name_Assembler;\n+         when Convention_C                     => return Name_C;\n+         when Convention_CIL                   => return Name_CIL;\n+         when Convention_COBOL                 => return Name_COBOL;\n+         when Convention_CPP                   => return Name_CPP;\n+         when Convention_Entry                 => return Name_Entry;\n+         when Convention_Fortran               => return Name_Fortran;\n+         when Convention_Intrinsic             => return Name_Intrinsic;\n+         when Convention_Java                  => return Name_Java;\n+         when Convention_Protected             => return Name_Protected;\n+         when Convention_Stdcall               => return Name_Stdcall;\n+         when Convention_Stubbed               => return Name_Stubbed;\n       end case;\n    end Get_Convention_Name;\n "}, {"sha": "981784bb37f36c7347ffac61d97bcb22c2047933", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e917aec294d1a0e602aaf31a70df3a784f7a48b9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e917aec294d1a0e602aaf31a70df3a784f7a48b9", "patch": "@@ -579,6 +579,8 @@ package Snames is\n \n    First_Convention_Name               : constant Name_Id := N + $;\n    Name_Ada                            : constant Name_Id := N + $;\n+   Name_Ada_Pass_By_Copy               : constant Name_Id := N + $;\n+   Name_Ada_Pass_By_Reference          : constant Name_Id := N + $;\n    Name_Assembler                      : constant Name_Id := N + $;\n    Name_CIL                            : constant Name_Id := N + $;\n    Name_COBOL                          : constant Name_Id := N + $;\n@@ -1424,6 +1426,12 @@ package Snames is\n       Convention_Protected,\n       Convention_Stubbed,\n \n+      --  The following conventions are equivalent to Ada for all purposes\n+      --  except controlling the way parameters are passed.\n+\n+      Convention_Ada_Pass_By_Copy,\n+      Convention_Ada_Pass_By_Reference,\n+\n       --  The remaining conventions are foreign language conventions\n \n       Convention_Assembler,  --  also Asm, Assembly\n@@ -1435,10 +1443,10 @@ package Snames is\n       Convention_Java,\n       Convention_Stdcall);   --  also DLL, Win32\n \n-      --  Note: Convention C_Pass_By_Copy is allowed only for record\n-      --  types (where it is treated like C except that the appropriate\n-      --  flag is set in the record type). Recognizing this convention\n-      --  is specially handled in Sem_Prag.\n+      --  Note: Convention C_Pass_By_Copy is allowed only for record types\n+      --  (where it is treated like C except that the appropriate flag is set\n+      --  in the record type). Recognizing this convention is specially handled\n+      --  in Sem_Prag.\n \n    for Convention_Id'Size use 8;\n    --  Plenty of space for expansion"}]}