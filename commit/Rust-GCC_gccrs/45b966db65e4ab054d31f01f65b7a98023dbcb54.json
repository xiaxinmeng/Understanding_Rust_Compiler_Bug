{"sha": "45b966db65e4ab054d31f01f65b7a98023dbcb54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViOTY2ZGI2NWU0YWIwNTRkMzFmMDFmNjViN2E5ODAyM2RiY2I1NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-13T22:01:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-13T22:01:08Z"}, "message": "Makefile.in (LIBCPP_OBJS): Add cpplex.o.\n\n\t* Makefile.in (LIBCPP_OBJS): Add cpplex.o.\n\t(cpplex.o): New target.\n\t* po/POTFILES.in: Add cpplex.c.\n\n\t* cpplex.c (_cpp_grow_token_buffer, null_cleanup,\n\tcpp_push_buffer, cpp_pop_buffer, cpp_scan_buffer,\n\tcpp_expand_to_buffer, cpp_buf_line_and_col, cpp_file_buffer,\n\tskip_block_comment, skip_line_comment, skip_comment,\n\tcopy_comment, _cpp_skip_hspace, _cpp_skip_rest_of_line,\n\t_cpp_parse_name, skip_string, parse_string,\n\t_cpp_parse_assertion, cpp_get_token, cpp_get_non_space_token,\n\t_cpp_get_directive_token, find_position,\n\t_cpp_read_and_prescan, _cpp_init_input_buffer): Move here.\n\t(maybe_macroexpand, _cpp_lex_token): New functions.\n\n\t* cpplib.c (SKIP_WHITE_SPACE, eval_if_expr, parse_set_mark,\n\tparse_goto_mark): Delete.\n\t(_cpp_handle_eof): New function.\n\t(_cpp_handle_directive): Rename from handle_directive.\n\t(_cpp_output_line_command): Rename from output_line_command.\n\t(do_if, do_elif): Call _cpp_parse_expr directly.\n\t* cppfiles.c (_cpp_read_include_file): Don't call\n\tinit_input_buffer here.\n\t* cpphash.c (quote_string): Move here, rename _cpp_quote_string.\n\t* cppexp.c (_cpp_parse_expr): Diddle parsing_if_directive\n\there; pop the token_buffer and skip the rest of the line here.\n\t* cppinit.c (cpp_start_read): Call _cpp_init_input_buffer\n\there.\n\n\t* cpphash.h (CPP_RESERVE, CPP_IS_MACRO_BUFFER, ACTIVE_MARK_P):\n\tDefine here.\n\t(CPP_SET_BUF_MARK, CPP_GOTO_BUF_MARK, CPP_SET_MARK,\n\tCPP_GOTO_MARK): New macros.\n\t(_cpp_quote_string, _cpp_parse_name, _cpp_skip_rest_of_line,\n\t_cpp_skip_hspace, _cpp_parse_assertion, _cpp_lex_token,\n\t_cpp_read_and_prescan, _cpp_init_input_buffer,\n\t_cpp_grow_token_buffer, _cpp_get_directive_token,\n\t_cpp_handle_directive, _cpp_handle_eof,\n\t_cpp_output_line_command): Prototype them here.\n\t* cpplib.h (enum cpp_token): Add CPP_MACRO.\n\t(CPP_RESERVE, get_directive_token, cpp_grow_buffer,\n\tquote_string, output_line_command): Remove.\n\nFrom-SVN: r32513", "tree": {"sha": "665428b0af6694941ce92f0755dc66596d94fa55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/665428b0af6694941ce92f0755dc66596d94fa55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45b966db65e4ab054d31f01f65b7a98023dbcb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b966db65e4ab054d31f01f65b7a98023dbcb54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b966db65e4ab054d31f01f65b7a98023dbcb54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b966db65e4ab054d31f01f65b7a98023dbcb54/comments", "author": null, "committer": null, "parents": [{"sha": "46089b8642e5054073af90a85cfdd07f0f09353b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46089b8642e5054073af90a85cfdd07f0f09353b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46089b8642e5054073af90a85cfdd07f0f09353b"}], "stats": {"total": 3949, "additions": 2007, "deletions": 1942}, "files": [{"sha": "0abf7f545e66100cc7f98e89726fe32fd9f95adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -1,3 +1,48 @@\n+2000-03-13  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* Makefile.in (LIBCPP_OBJS): Add cpplex.o.\n+\t(cpplex.o): New target.\n+\t* po/POTFILES.in: Add cpplex.c.\n+\n+\t* cpplex.c (_cpp_grow_token_buffer, null_cleanup,\n+\tcpp_push_buffer, cpp_pop_buffer, cpp_scan_buffer,\n+\tcpp_expand_to_buffer, cpp_buf_line_and_col, cpp_file_buffer,\n+\tskip_block_comment, skip_line_comment, skip_comment,\n+\tcopy_comment, _cpp_skip_hspace, _cpp_skip_rest_of_line,\n+\t_cpp_parse_name, skip_string, parse_string,\n+\t_cpp_parse_assertion, cpp_get_token, cpp_get_non_space_token,\n+\t_cpp_get_directive_token, find_position,\n+\t_cpp_read_and_prescan, _cpp_init_input_buffer): Move here.\n+\t(maybe_macroexpand, _cpp_lex_token): New functions.\n+\n+\t* cpplib.c (SKIP_WHITE_SPACE, eval_if_expr, parse_set_mark,\n+\tparse_goto_mark): Delete.\n+\t(_cpp_handle_eof): New function.\n+\t(_cpp_handle_directive): Rename from handle_directive.\n+\t(_cpp_output_line_command): Rename from output_line_command.\n+\t(do_if, do_elif): Call _cpp_parse_expr directly.\n+\t* cppfiles.c (_cpp_read_include_file): Don't call\n+\tinit_input_buffer here.\n+\t* cpphash.c (quote_string): Move here, rename _cpp_quote_string.\n+\t* cppexp.c (_cpp_parse_expr): Diddle parsing_if_directive\n+\there; pop the token_buffer and skip the rest of the line here.\n+\t* cppinit.c (cpp_start_read): Call _cpp_init_input_buffer\n+\there.\n+\n+\t* cpphash.h (CPP_RESERVE, CPP_IS_MACRO_BUFFER, ACTIVE_MARK_P):\n+\tDefine here.\n+\t(CPP_SET_BUF_MARK, CPP_GOTO_BUF_MARK, CPP_SET_MARK,\n+\tCPP_GOTO_MARK): New macros.\n+\t(_cpp_quote_string, _cpp_parse_name, _cpp_skip_rest_of_line,\n+\t_cpp_skip_hspace, _cpp_parse_assertion, _cpp_lex_token,\n+\t_cpp_read_and_prescan, _cpp_init_input_buffer,\n+\t_cpp_grow_token_buffer, _cpp_get_directive_token,\n+\t_cpp_handle_directive, _cpp_handle_eof,\n+\t_cpp_output_line_command): Prototype them here.\n+\t* cpplib.h (enum cpp_token): Add CPP_MACRO.\n+\t(CPP_RESERVE, get_directive_token, cpp_grow_buffer,\n+\tquote_string, output_line_command): Remove.\n+\n 2000-03-13  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* stmt.c (expand_end_case): RANGE may be signed, and when checking"}, {"sha": "3da645277502a414fb9d3c6c03658f6ba55c4045", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -2025,7 +2025,7 @@ cccp.o: cccp.c $(CONFIG_H) intl.h pcp.h version.c config.status system.h \\\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n LIBCPP_OBJS =\tcpplib.o cpphash.o cpperror.o cppexp.o cppfiles.o \\\n-\t\tcppinit.o cppulp.o mkdeps.o \\\n+\t\tcppinit.o cppulp.o cpplex.o mkdeps.o \\\n \t\tprefix.o version.o mbchar.o @extra_cpp_objs@\n \n LIBCPP_DEPS = cpplib.h cpphash.h intl.h system.h\n@@ -2048,6 +2048,7 @@ cppmain.o:  cppmain.c  $(CONFIG_H) cpplib.h intl.h system.h\n cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n+cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h"}, {"sha": "4d1cf10eeb65e1c12b154b47dfbc96c5b9fa4b54", "filename": "gcc/cppexp.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -352,12 +352,12 @@ parse_defined (pfile)\n   op.op = INT;\n \n   pfile->no_macro_expand++;\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token == CPP_LPAREN)\n     {\n       paren++;\n       CPP_SET_WRITTEN (pfile, old_written);\n-      token = get_directive_token (pfile);\n+      token = _cpp_get_directive_token (pfile);\n     }\n \n   if (token != CPP_NAME)\n@@ -369,7 +369,7 @@ parse_defined (pfile)\n \n   if (paren)\n     {\n-      if (get_directive_token (pfile) != CPP_RPAREN)\n+      if (_cpp_get_directive_token (pfile) != CPP_RPAREN)\n \tgoto oops;\n     }\n   CPP_SET_WRITTEN (pfile, old_written);\n@@ -419,7 +419,7 @@ lex (pfile, skip_evaluation)\n   long old_written;\n \n   old_written = CPP_WRITTEN (pfile);\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n \n   tok_start = pfile->token_buffer + old_written;\n   tok_end = CPP_PWRITTEN (pfile);\n@@ -689,7 +689,10 @@ _cpp_parse_expr (pfile)\n   register struct operation *top = stack;\n   unsigned int lprio, rprio = 0;\n   int skip_evaluation = 0;\n+  long old_written = CPP_WRITTEN (pfile);\n+  int result;\n \n+  pfile->parsing_if_directive++;\n   top->rprio = 0;\n   top->flags = 0;\n   for (;;)\n@@ -999,9 +1002,8 @@ _cpp_parse_expr (pfile)\n \t{\n \t  if (top != stack)\n \t    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n-\t  if (stack != init_stack)\n-\t    free (stack);\n-\t  return (top->value != 0);\n+\t  result = (top->value != 0);\n+\t  goto done;\n \t}\n       top++;\n       \n@@ -1041,7 +1043,12 @@ _cpp_parse_expr (pfile)\n \t}\n     }\n  syntax_error:\n+  _cpp_skip_rest_of_line (pfile);\n+  result = 0;\n+ done:\n+  pfile->parsing_if_directive--;\n+  CPP_SET_WRITTEN (pfile, old_written);\n   if (stack != init_stack)\n     free (stack);\n-  return 0;\n+  return result;\n }"}, {"sha": "ec7529f5f00fb5cb996bbd567c0f62df9f426d70", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 404, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -38,17 +38,13 @@ static struct file_name_map *read_name_map\n static char *read_filename_string PARAMS ((int, FILE *));\n static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t struct file_name_list *));\n-static long read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n-\t\t\t\t\t int, size_t));\n static struct file_name_list *actual_directory\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n \n static unsigned int hash_IHASH\tPARAMS ((const void *));\n static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n \n-static void init_input_buffer\tPARAMS ((cpp_reader *, int, struct stat *));\n static int file_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n-static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -587,14 +583,11 @@ _cpp_read_include_file (pfile, fd, ihash)\n       goto fail;\n     }\n \n-  if (pfile->input_buffer == NULL)\n-    init_input_buffer (pfile, fd, &st);\n-\n   /* Read the file, converting end-of-line characters and trigraphs\n      (if enabled). */\n   fp->ihash = ihash;\n   fp->nominal_fname = ihash->name;\n-  length = read_and_prescan (pfile, fp, fd, st_size);\n+  length = _cpp_read_and_prescan (pfile, fp, fd, st_size);\n   if (length < 0)\n     goto fail;\n   if (length == 0)\n@@ -687,402 +680,6 @@ actual_directory (pfile, fname)\n   return x;\n }\n \n-/* Determine the current line and column.  Used only by read_and_prescan. */\n-static U_CHAR *\n-find_position (start, limit, linep)\n-     U_CHAR *start;\n-     U_CHAR *limit;\n-     unsigned long *linep;\n-{\n-  unsigned long line = *linep;\n-  U_CHAR *lbase = start;\n-  while (start < limit)\n-    {\n-      U_CHAR ch = *start++;\n-      if (ch == '\\n' || ch == '\\r')\n-\t{\n-\t  line++;\n-\t  lbase = start;\n-\t}\n-    }\n-  *linep = line;\n-  return lbase;\n-}\n-\n-/* Read the entire contents of file DESC into buffer BUF.  LEN is how\n-   much memory to allocate initially; more will be allocated if\n-   necessary.  Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n-   canonical form (\\n).  If enabled, convert and/or warn about\n-   trigraphs.  Convert backslash-newline to a one-character escape\n-   (\\r) and remove it from \"embarrassing\" places (i.e. the middle of a\n-   token).  If there is no newline at the end of the file, add one and\n-   warn.  Returns -1 on failure, or the actual length of the data to\n-   be scanned.\n-\n-   This function does a lot of work, and can be a serious performance\n-   bottleneck.  It has been tuned heavily; make sure you understand it\n-   before hacking.  The common case - no trigraphs, Unix style line\n-   breaks, backslash-newline set off by whitespace, newline at EOF -\n-   has been optimized at the expense of the others.  The performance\n-   penalty for DOS style line breaks (\\r\\n) is about 15%.\n-   \n-   Warnings lose particularly heavily since we have to determine the\n-   line number, which involves scanning from the beginning of the file\n-   or from the last warning.  The penalty for the absence of a newline\n-   at the end of reload1.c is about 60%.  (reload1.c is 329k.)\n-\n-   If your file has more than one kind of end-of-line marker, you\n-   will get messed-up line numbering.  */\n-\n-/* Table of characters that can't be handled in the inner loop.\n-   Keep these contiguous to optimize the performance of the code generated\n-   for the switch that uses them.  */\n-#define SPECCASE_EMPTY     0\n-#define SPECCASE_NUL       1\n-#define SPECCASE_CR        2\n-#define SPECCASE_BACKSLASH 3\n-#define SPECCASE_QUESTION  4\n-\n-static long\n-read_and_prescan (pfile, fp, desc, len)\n-     cpp_reader *pfile;\n-     cpp_buffer *fp;\n-     int desc;\n-     size_t len;\n-{\n-  U_CHAR *buf = (U_CHAR *) xmalloc (len);\n-  U_CHAR *ip, *op, *line_base;\n-  U_CHAR *ibase;\n-  U_CHAR *speccase = pfile->input_speccase;\n-  unsigned long line;\n-  unsigned int deferred_newlines;\n-  int count;\n-  size_t offset;\n-\n-  offset = 0;\n-  op = buf;\n-  line_base = buf;\n-  line = 1;\n-  ibase = pfile->input_buffer + 2;\n-  deferred_newlines = 0;\n-\n-  for (;;)\n-    {\n-    read_next:\n-\n-      count = read (desc, pfile->input_buffer + 2, pfile->input_buffer_len);\n-      if (count < 0)\n-\tgoto error;\n-      else if (count == 0)\n-\tbreak;\n-\n-      offset += count;\n-      ip = ibase;\n-      ibase = pfile->input_buffer + 2;\n-      ibase[count] = ibase[count+1] = '\\0';\n-\n-      if (offset > len)\n-\t{\n-\t  size_t delta_op;\n-\t  size_t delta_line_base;\n-\t  len *= 2;\n-\t  if (offset > len)\n-\t    /* len overflowed.\n-\t       This could happen if the file is larger than half the\n-\t       maximum address space of the machine. */\n-\t    goto too_big;\n-\n-\t  delta_op = op - buf;\n-\t  delta_line_base = line_base - buf;\n-\t  buf = (U_CHAR *) xrealloc (buf, len);\n-\t  op = buf + delta_op;\n-\t  line_base = buf + delta_line_base;\n-\t}\n-\n-      for (;;)\n-\t{\n-\t  unsigned int span = 0;\n-\n-\t  /* Deal with \\-newline in the middle of a token. */\n-\t  if (deferred_newlines)\n-\t    {\n-\t      while (speccase[ip[span]] == SPECCASE_EMPTY\n-\t\t     && ip[span] != '\\n'\n-\t\t     && ip[span] != '\\t'\n-\t\t     && ip[span] != ' ')\n-\t\tspan++;\n-\t      memcpy (op, ip, span);\n-\t      op += span;\n-\t      ip += span;\n-\t      /* If ip[0] is SPECCASE_EMPTY, we have hit white space.\n-\t\t Dump out the remaining deferred \\-newlines.  */\n-\t      if (speccase[ip[0]] == SPECCASE_EMPTY)\n-\t\twhile (deferred_newlines)\n-\t\t  deferred_newlines--, *op++ = '\\r';\n-\t      span = 0;\n-\t    }\n-\n-\t  /* Copy as much as we can without special treatment. */\n-\t  while (speccase[ip[span]] == SPECCASE_EMPTY) span++;\n-\t  memcpy (op, ip, span);\n-\t  op += span;\n-\t  ip += span;\n-\n-\t  switch (speccase[*ip++])\n-\t    {\n-\t    case SPECCASE_NUL:  /* \\0 */\n-\t      ibase[-1] = op[-1];\n-\t      goto read_next;\n-\n-\t    case SPECCASE_CR:  /* \\r */\n-\t      if (ip[-2] == '\\n')\n-\t\tcontinue;\n-\t      else if (*ip == '\\n')\n-\t\tip++;\n-\t      else if (*ip == '\\0')\n-\t\t{\n-\t\t  *--ibase = '\\r';\n-\t\t  goto read_next;\n-\t\t}\n-\t      *op++ = '\\n';\n-\t      break;\n-\n-\t    case SPECCASE_BACKSLASH:  /* \\ */\n-\t    backslash:\n-\t    {\n-\t      /* If we're at the end of the intermediate buffer,\n-\t\t we have to shift the backslash down to the start\n-\t\t and come back next pass. */\n-\t      if (*ip == '\\0')\n-\t\t{\n-\t\t  *--ibase = '\\\\';\n-\t\t  goto read_next;\n-\t\t}\n-\t      else if (*ip == '\\n')\n-\t\t{\n-\t\t  ip++;\n-\t\t  if (*ip == '\\r') ip++;\n-\t\t  if (*ip == '\\n' || *ip == '\\t' || *ip == ' ')\n-\t\t    *op++ = '\\r';\n-\t\t  else if (op[-1] == '\\t' || op[-1] == ' '\n-\t\t\t   || op[-1] == '\\r' || op[-1] == '\\n')\n-\t\t    *op++ = '\\r';\n-\t\t  else\n-\t\t    deferred_newlines++;\n-\t\t}\n-\t      else if (*ip == '\\r')\n-\t\t{\n-\t\t  ip++;\n-\t\t  if (*ip == '\\n') ip++;\n-\t\t  else if (*ip == '\\0')\n-\t\t    {\n-\t\t      *--ibase = '\\r';\n-\t\t      *--ibase = '\\\\';\n-\t\t      goto read_next;\n-\t\t    }\n-\t\t  else if (*ip == '\\r' || *ip == '\\t' || *ip == ' ')\n-\t\t    *op++ = '\\r';\n-\t\t  else\n-\t\t    deferred_newlines++;\n-\t\t}\n-\t      else\n-\t\t*op++ = '\\\\';\n-\t    }\n-\t    break;\n-\n-\t    case SPECCASE_QUESTION: /* ? */\n-\t      {\n-\t\tunsigned int d, t;\n-\t\t/* If we're at the end of the intermediate buffer,\n-\t\t   we have to shift the ?'s down to the start and\n-\t\t   come back next pass. */\n-\t\td = ip[0];\n-\t\tif (d == '\\0')\n-\t\t  {\n-\t\t    *--ibase = '?';\n-\t\t    goto read_next;\n-\t\t  }\n-\t\tif (d != '?')\n-\t\t  {\n-\t\t    *op++ = '?';\n-\t\t    break;\n-\t\t  }\n-\t\td = ip[1];\n-\t\tif (d == '\\0')\n-\t\t  {\n-\t\t    *--ibase = '?';\n-\t\t    *--ibase = '?';\n-\t\t    goto read_next;\n-\t\t  }\n-\n-\t\t/* Trigraph map:\n-\t\t *\tfrom\tto\tfrom\tto\tfrom\tto\n-\t\t *\t?? =\t#\t?? )\t]\t?? !\t|\n-\t\t *\t?? (\t[\t?? '\t^\t?? >\t}\n-\t\t *\t?? /\t\\\t?? <\t{\t?? -\t~\n-\t\t */\n-\t\tif (d == '=') t = '#';\n-\t\telse if (d == ')') t = ']';\n-\t\telse if (d == '!') t = '|';\n-\t\telse if (d == '(') t = '[';\n-\t\telse if (d == '\\'') t = '^';\n-\t\telse if (d == '>') t = '}';\n-\t\telse if (d == '/') t = '\\\\';\n-\t\telse if (d == '<') t = '{';\n-\t\telse if (d == '-') t = '~';\n-\t\telse\n-\t\t  {\n-\t\t    *op++ = '?';\n-\t\t    break;\n-\t\t  }\n-\t\tip += 2;\n-\t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n-\t\t  {\n-\t\t    unsigned long col;\n-\t\t    line_base = find_position (line_base, op, &line);\n-\t\t    col = op - line_base + 1;\n-\t\t    if (CPP_OPTIONS (pfile)->trigraphs)\n-\t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t     \"trigraph ??%c converted to %c\", d, t);\n-\t\t    else\n-\t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t     \"trigraph ??%c ignored\", d);\n-\t\t  }\n-\t\tif (CPP_OPTIONS (pfile)->trigraphs)\n-\t\t  {\n-\t\t    if (t == '\\\\')\n-\t\t      goto backslash;\n-\t\t    else\n-\t\t      *op++ = t;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    *op++ = '?';\n-\t\t    *op++ = '?';\n-\t\t    *op++ = d;\n-\t\t  }\n-\t      }\n-\t    }\n-\t}\n-    }\n-\n-  if (offset == 0)\n-    return 0;\n-\n-  /* Deal with pushed-back chars at true EOF.\n-     This may be any of:  ?? ? \\ \\r \\n \\\\r \\\\n.\n-     \\r must become \\n, \\\\r or \\\\n must become \\r.\n-     We know we have space already. */\n-  if (ibase == pfile->input_buffer)\n-    {\n-      if (*ibase == '?')\n-\t{\n-\t  *op++ = '?';\n-\t  *op++ = '?';\n-\t}\n-      else\n-\t*op++ = '\\r';\n-    }\n-  else if (ibase == pfile->input_buffer + 1)\n-    {\n-      if (*ibase == '\\r')\n-\t*op++ = '\\n';\n-      else\n-\t*op++ = *ibase;\n-    }\n-\n-  if (op[-1] != '\\n')\n-    {\n-      unsigned long col;\n-      line_base = find_position (line_base, op, &line);\n-      col = op - line_base + 1;\n-      cpp_warning_with_line (pfile, line, col, \"no newline at end of file\\n\");\n-      if (offset + 1 > len)\n-\t{\n-\t  len += 1;\n-\t  if (offset + 1 > len)\n-\t    goto too_big;\n-\t  buf = (U_CHAR *) xrealloc (buf, len);\n-\t  op = buf + offset;\n-\t}\n-      *op++ = '\\n';\n-    }\n-\n-  fp->buf = ((len - offset < 20) ? buf : (U_CHAR *)xrealloc (buf, op - buf));\n-  return op - buf;\n-\n- too_big:\n-  cpp_error (pfile, \"file is too large (>%lu bytes)\\n\", (unsigned long)offset);\n-  free (buf);\n-  return -1;\n-\n- error:\n-  cpp_error_from_errno (pfile, fp->ihash->name);\n-  free (buf);\n-  return -1;\n-}\n-\n-/* Initialize the `input_buffer' and `input_speccase' tables.\n-   These are only used by read_and_prescan, but they're large and\n-   somewhat expensive to set up, so we want them allocated once for\n-   the duration of the cpp run.  */\n-\n-static void\n-init_input_buffer (pfile, fd, st)\n-     cpp_reader *pfile;\n-     int fd;\n-     struct stat *st;\n-{\n-  long pipe_buf;\n-  U_CHAR *tmp;\n-\n-  /* Table of characters that cannot be handled by the\n-     read_and_prescan inner loop.  The number of non-EMPTY entries\n-     should be as small as humanly possible.  */\n-\n-  tmp = (U_CHAR *) xmalloc (1 << CHAR_BIT);\n-  memset (tmp, SPECCASE_EMPTY, 1 << CHAR_BIT);\n-  tmp['\\0'] = SPECCASE_NUL;\n-  tmp['\\r'] = SPECCASE_CR;\n-  tmp['\\\\'] = SPECCASE_BACKSLASH;\n-  if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n-    tmp['?'] = SPECCASE_QUESTION;\n-\n-  pfile->input_speccase = tmp;\n-\n-  /* Determine the appropriate size for the input buffer.  Normal C\n-     source files are smaller than eight K.  If we are reading a pipe,\n-     we want to make sure the input buffer is bigger than the kernel's\n-     pipe buffer.  */\n-  pipe_buf = -1;\n-\n-  if (! S_ISREG (st->st_mode))\n-    {\n-#ifdef _PC_PIPE_BUF\n-      pipe_buf = fpathconf (fd, _PC_PIPE_BUF);\n-#endif\n-      if (pipe_buf == -1)\n-\t{\n-#ifdef PIPE_BUF\n-\t  pipe_buf = PIPE_BUF;\n-#else\n-\t  pipe_buf = 8192;\n-#endif\n-\t}\n-    }\n-\n-  if (pipe_buf < 8192)\n-    pipe_buf = 8192;\n-  /* PIPE_BUF bytes of buffer proper, 2 to detect running off the end\n-     without address arithmetic all the time, and 2 for pushback in\n-     the case there's a potential trigraph or end-of-line digraph at\n-     the end of a block. */\n-\n-  tmp = (U_CHAR *) xmalloc (pipe_buf + 2 + 2);\n-  pfile->input_buffer = tmp;\n-  pfile->input_buffer_len = pipe_buf;\n-}\n-\n /* Simplify a path name in place, deleting redundant components.  This\n    reduces OS overhead and guarantees that equivalent paths compare\n    the same (modulo symlinks)."}, {"sha": "d3dac0b40f3b82cee3a69fa9646a5501dd98bbef", "filename": "gcc/cpphash.c", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -307,7 +307,7 @@ collect_expansion (pfile, arglist)\n   last -= 2;  /* two extra chars for the leading escape */\n   for (;;)\n     {\n-      /* We use cpp_get_token because get_directive_token would\n+      /* We use cpp_get_token because _cpp_get_directive_token would\n \t discard whitespace and we can't cope with that yet.  Macro\n \t expansion is off, so we are guaranteed not to see POP or EOF.  */\n \n@@ -570,7 +570,7 @@ collect_formal_parameters (pfile)\n   long old_written;\n \n   old_written = CPP_WRITTEN (pfile);\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token != CPP_LPAREN)\n     {\n       cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n@@ -584,7 +584,7 @@ collect_formal_parameters (pfile)\n   for (;;)\n     {\n       CPP_SET_WRITTEN (pfile, old_written);\n-      token = get_directive_token (pfile);\n+      token = _cpp_get_directive_token (pfile);\n       switch (token)\n \t{\n \tcase CPP_NAME:\n@@ -660,7 +660,7 @@ collect_formal_parameters (pfile)\n \n   argv[argc].rest_arg = 1;\n   \n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token != CPP_RPAREN)\n     {\n       cpp_error (pfile, \"another parameter follows `...'\");\n@@ -826,6 +826,43 @@ static const char * const monthnames[] =\n   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n };\n \n+/* Place into PFILE a quoted string representing the string SRC.\n+   Caller must reserve enough space in pfile->token_buffer.  */\n+\n+void\n+_cpp_quote_string (pfile, src)\n+     cpp_reader *pfile;\n+     const char *src;\n+{\n+  U_CHAR c;\n+\n+  CPP_PUTC_Q (pfile, '\\\"');\n+  for (;;)\n+    switch ((c = *src++))\n+      {\n+      default:\n+        if (ISPRINT (c))\n+\t  CPP_PUTC_Q (pfile, c);\n+\telse\n+\t  {\n+\t    sprintf ((char *)CPP_PWRITTEN (pfile), \"\\\\%03o\", c);\n+\t    CPP_ADJUST_WRITTEN (pfile, 4);\n+\t  }\n+\tbreak;\n+\n+      case '\\\"':\n+      case '\\\\':\n+\tCPP_PUTC_Q (pfile, '\\\\');\n+\tCPP_PUTC_Q (pfile, c);\n+\tbreak;\n+      \n+      case '\\0':\n+\tCPP_PUTC_Q (pfile, '\\\"');\n+\tCPP_NUL_TERMINATE_Q (pfile);\n+\treturn;\n+      }\n+}\n+\n /*\n  * expand things like __FILE__.  Place the expansion into the output\n  * buffer *without* rescanning.\n@@ -857,7 +894,7 @@ special_symbol (hp, pfile)\n \tif (!buf)\n \t  buf = \"\";\n \tCPP_RESERVE (pfile, 3 + 4 * strlen (buf));\n-\tquote_string (pfile, buf);\n+\t_cpp_quote_string (pfile, buf);\n \treturn;\n       }\n \n@@ -1597,7 +1634,7 @@ _cpp_dump_definition (pfile, sym, len, defn)\n      DEFINITION *defn;\n {\n   if (pfile->lineno == 0)\n-    output_line_command (pfile, same_file);\n+    _cpp_output_line_command (pfile, same_file);\n \n   CPP_RESERVE (pfile, len + sizeof \"#define \");\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);"}, {"sha": "4468d42475a25b3dc8ff4d05b161fdbc06f366a3", "filename": "gcc/cpphash.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -217,6 +217,11 @@ extern unsigned char _cpp_IStable[256];\n   ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n #define CPP_FORWARD(BUFFER, N) ((BUFFER)->cur += (N))\n \n+/* Make sure PFILE->token_buffer has space for at least N more characters. */\n+#define CPP_RESERVE(PFILE, N) \\\n+  (CPP_WRITTEN (PFILE) + (size_t)(N) > (PFILE)->token_buffer_size \\\n+   && (_cpp_grow_token_buffer (PFILE, N), 0))\n+\n /* Append string STR (of length N) to PFILE's output buffer.\n    Assume there is enough space. */\n #define CPP_PUTS_Q(PFILE, STR, N) \\\n@@ -242,6 +247,29 @@ extern unsigned char _cpp_IStable[256];\n #define CPP_PEDANTIC(PFILE) \\\n   (CPP_OPTIONS (PFILE)->pedantic && !CPP_BUFFER (pfile)->system_header_p)\n \n+/* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.\n+   (Note that it is false while we're expanding macro *arguments*.) */\n+#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n+\n+/* Remember the current position of PFILE so it may be returned to\n+   after looking ahead a bit.\n+\n+   Note that when you set a mark, you _must_ return to that mark.  You\n+   may not forget about it and continue parsing.  You may not pop a\n+   buffer with an active mark.  You may not call CPP_BUMP_LINE while a\n+   mark is active.  */\n+#define CPP_SET_BUF_MARK(IP)   ((IP)->mark = (IP)->cur - (IP)->buf)\n+#define CPP_GOTO_BUF_MARK(IP)  ((IP)->cur = (IP)->buf + (IP)->mark, \\\n+\t\t\t\t(IP)->mark = -1)\n+#define CPP_SET_MARK(PFILE)  CPP_SET_BUF_MARK(CPP_BUFFER(PFILE))\n+#define CPP_GOTO_MARK(PFILE) CPP_GOTO_BUF_MARK(CPP_BUFFER(PFILE))\n+\n+/* ACTIVE_MARK_P is true if there's a live mark in the buffer.  */\n+#define ACTIVE_MARK_P(PFILE) (CPP_BUFFER (PFILE)->mark != -1)\n+\n+/* Last arg to output_line_command.  */\n+enum file_change_code {same_file, rename_file, enter_file, leave_file};\n+\n /* In cpphash.c */\n extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t enum node_type,\n@@ -257,6 +285,7 @@ extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t long, DEFINITION *));\n extern int _cpp_compare_defs\t\tPARAMS ((cpp_reader *, DEFINITION *,\n \t\t\t\t\t\t DEFINITION *));\n+extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, HASHNODE *));\n extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n@@ -272,4 +301,24 @@ extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n \n+/* In cpplex.c */\n+extern void _cpp_parse_name\t\tPARAMS ((cpp_reader *, int));\n+extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n+extern void _cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n+extern int _cpp_parse_assertion\t\tPARAMS ((cpp_reader *));\n+extern enum cpp_token _cpp_lex_token\tPARAMS ((cpp_reader *));\n+extern long _cpp_read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n+\t\t\t\t\t\t int, size_t));\n+extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n+extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n+extern enum cpp_token _cpp_get_directive_token\n+\t\t\t\t\tPARAMS ((cpp_reader *));\n+\n+/* In cpplib.c */\n+extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n+extern void _cpp_handle_eof\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_output_line_command\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t enum file_change_code));\n+\n+\n #endif"}, {"sha": "674e140db09fa8e52855bbe844753685c0a4491a", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -519,7 +519,7 @@ dump_special_to_buffer (pfile, macro_name)\n {\n   static const char define_directive[] = \"#define \";\n   int macro_name_length = strlen (macro_name);\n-  output_line_command (pfile, same_file);\n+  _cpp_output_line_command (pfile, same_file);\n   CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n   CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n   CPP_PUTS_Q (pfile, macro_name, macro_name_length);\n@@ -872,6 +872,9 @@ cpp_start_read (pfile, fname)\n      with a compiler that supports C99 designated initializers.  */\n   init_IStable ();\n \n+  /* Set up the tables used by read_and_prescan.  */\n+  _cpp_init_input_buffer (pfile);\n+  \n   /* Set up the include search path now.  */\n   if (! opts->no_standard_includes)\n     initialize_standard_includes (pfile);\n@@ -933,7 +936,7 @@ cpp_start_read (pfile, fname)\n        counter accordingly.  */\n     pfile->lineno = CPP_BUFFER (pfile)->lineno;\n   else\n-    output_line_command (pfile, same_file);\n+    _cpp_output_line_command (pfile, same_file);\n   pfile->only_seen_white = 2;\n \n   /* The -imacros files can be scanned now, but the -include files\n@@ -957,7 +960,7 @@ cpp_start_read (pfile, fname)\n   while (p)\n     {\n       if (cpp_read_file (pfile, p->arg))\n-\toutput_line_command (pfile, enter_file);\n+\t_cpp_output_line_command (pfile, enter_file);\n \n       q = p->next;\n       free (p);"}, {"sha": "674db90e60843f9b6ea5205b0e570f7ed8a0b152", "filename": "gcc/cpplex.c", "status": "added", "additions": 1620, "deletions": 0, "changes": 1620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -0,0 +1,1620 @@\n+/* CPP Library - lexical analysis.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Per Bothner, 1994-95.\n+   Based on CCCP program by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+   Broken out to separate file, Zack Weinberg, Mar 2000\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"intl.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+#define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) \\\n+\t\t  ? CPP_BUFFER (pfile)->cur[N] : EOF)\n+#define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n+#define GETC() CPP_BUF_GET (CPP_BUFFER (pfile))\n+#define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n+\n+static void skip_block_comment\tPARAMS ((cpp_reader *));\n+static void skip_line_comment\tPARAMS ((cpp_reader *));\n+static int maybe_macroexpand\tPARAMS ((cpp_reader *, long));\n+static int skip_comment\t\tPARAMS ((cpp_reader *, int));\n+static int copy_comment\t\tPARAMS ((cpp_reader *, int));\n+static void skip_string\t\tPARAMS ((cpp_reader *, int));\n+static void parse_string\tPARAMS ((cpp_reader *, int));\n+static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n+static int null_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n+\n+/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n+\n+void\n+_cpp_grow_token_buffer (pfile, n)\n+     cpp_reader *pfile;\n+     long n;\n+{\n+  long old_written = CPP_WRITTEN (pfile);\n+  pfile->token_buffer_size = n + 2 * pfile->token_buffer_size;\n+  pfile->token_buffer = (U_CHAR *)\n+    xrealloc(pfile->token_buffer, pfile->token_buffer_size);\n+  CPP_SET_WRITTEN (pfile, old_written);\n+}\n+\n+static int\n+null_cleanup (pbuf, pfile)\n+     cpp_buffer *pbuf ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n+   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n+   as the new input buffer.\n+   Return the new buffer, or NULL on failure.  */\n+\n+cpp_buffer *\n+cpp_push_buffer (pfile, buffer, length)\n+     cpp_reader *pfile;\n+     const U_CHAR *buffer;\n+     long length;\n+{\n+  cpp_buffer *buf = CPP_BUFFER (pfile);\n+  cpp_buffer *new;\n+  if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n+    {\n+      cpp_fatal (pfile, \"macro or `#include' recursion too deep\");\n+      return NULL;\n+    }\n+\n+  new = (cpp_buffer *) xcalloc (1, sizeof (cpp_buffer));\n+\n+  new->if_stack = pfile->if_stack;\n+  new->cleanup = null_cleanup;\n+  new->buf = new->cur = buffer;\n+  new->alimit = new->rlimit = buffer + length;\n+  new->prev = buf;\n+  new->mark = -1;\n+  new->line_base = NULL;\n+\n+  CPP_BUFFER (pfile) = new;\n+  return new;\n+}\n+\n+cpp_buffer *\n+cpp_pop_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buf = CPP_BUFFER (pfile);\n+  if (ACTIVE_MARK_P (pfile))\n+    cpp_ice (pfile, \"mark active in cpp_pop_buffer\");\n+  (*buf->cleanup) (buf, pfile);\n+  CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n+  free (buf);\n+  pfile->buffer_stack_depth--;\n+  return CPP_BUFFER (pfile);\n+}\n+\n+/* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.\n+   Pop the buffer when done.  */\n+\n+void\n+cpp_scan_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = CPP_BUFFER (pfile);\n+  enum cpp_token token;\n+  if (CPP_OPTIONS (pfile)->no_output)\n+    {\n+      long old_written = CPP_WRITTEN (pfile);\n+      /* In no-output mode, we can ignore everything but directives.  */\n+      for (;;)\n+\t{\n+\t  if (! pfile->only_seen_white)\n+\t    _cpp_skip_rest_of_line (pfile);\n+\t  token = cpp_get_token (pfile);\n+\t  if (token == CPP_EOF) /* Should not happen ...  */\n+\t    break;\n+\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t    {\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n+\t\tcpp_pop_buffer (pfile);\n+\t      break;\n+\t    }\n+\t}\n+      CPP_SET_WRITTEN (pfile, old_written);\n+    }\n+  else\n+    {\n+      for (;;)\n+\t{\n+\t  token = cpp_get_token (pfile);\n+\t  if (token == CPP_EOF) /* Should not happen ...  */\n+\t    break;\n+\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t    {\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n+\t\tcpp_pop_buffer (pfile);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/*\n+ * Rescan a string (which may have escape marks) into pfile's buffer.\n+ * Place the result in pfile->token_buffer.\n+ *\n+ * The input is copied before it is scanned, so it is safe to pass\n+ * it something from the token_buffer that will get overwritten\n+ * (because it follows CPP_WRITTEN).  This is used by do_include.\n+ */\n+\n+void\n+cpp_expand_to_buffer (pfile, buf, length)\n+     cpp_reader *pfile;\n+     const U_CHAR *buf;\n+     int length;\n+{\n+  register cpp_buffer *ip;\n+  U_CHAR *buf1;\n+  int save_no_output;\n+\n+  if (length < 0)\n+    {\n+      cpp_ice (pfile, \"length < 0 in cpp_expand_to_buffer\");\n+      return;\n+    }\n+\n+  /* Set up the input on the input stack.  */\n+\n+  buf1 = (U_CHAR *) alloca (length + 1);\n+  memcpy (buf1, buf, length);\n+  buf1[length] = 0;\n+\n+  ip = cpp_push_buffer (pfile, buf1, length);\n+  if (ip == NULL)\n+    return;\n+  ip->has_escapes = 1;\n+\n+  /* Scan the input, create the output.  */\n+  save_no_output = CPP_OPTIONS (pfile)->no_output;\n+  CPP_OPTIONS (pfile)->no_output = 0;\n+  CPP_OPTIONS (pfile)->no_line_commands++;\n+  cpp_scan_buffer (pfile);\n+  CPP_OPTIONS (pfile)->no_line_commands--;\n+  CPP_OPTIONS (pfile)->no_output = save_no_output;\n+\n+  CPP_NUL_TERMINATE (pfile);\n+}\n+\n+void\n+cpp_buf_line_and_col (pbuf, linep, colp)\n+     register cpp_buffer *pbuf;\n+     long *linep, *colp;\n+{\n+  if (pbuf)\n+    {\n+      *linep = pbuf->lineno;\n+      if (colp)\n+\t*colp = pbuf->cur - pbuf->line_base;\n+    }\n+  else\n+    {\n+      *linep = 0;\n+      if (colp)\n+\t*colp = 0;\n+    }\n+}\n+\n+/* Return the topmost cpp_buffer that corresponds to a file (not a macro).  */\n+\n+cpp_buffer *\n+cpp_file_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip;\n+\n+  for (ip = CPP_BUFFER (pfile); ip; ip = CPP_PREV_BUFFER (ip))\n+    if (ip->ihash != NULL)\n+      return ip;\n+  return NULL;\n+}\n+\n+/* Skip a C-style block comment.  We know it's a comment, and point is\n+   at the second character of the starter.  */\n+static void\n+skip_block_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  int c, prev_c = -1;\n+  long line, col;\n+\n+  FORWARD(1);\n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n+  for (;;)\n+    {\n+      c = GETC ();\n+      if (c == EOF)\n+\t{\n+\t  cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n+\t  return;\n+\t}\n+      else if (c == '\\n' || c == '\\r')\n+\t{\n+\t  /* \\r cannot be a macro escape marker here. */\n+\t  if (!ACTIVE_MARK_P (pfile))\n+\t    CPP_BUMP_LINE (pfile);\n+\t}\n+      else if (c == '/' && prev_c == '*')\n+\treturn;\n+      else if (c == '*' && prev_c == '/'\n+\t       && CPP_OPTIONS (pfile)->warn_comments)\n+\tcpp_warning (pfile, \"`/*' within comment\");\n+\n+      prev_c = c;\n+    }\n+}\n+\n+/* Skip a C++/Chill line comment.  We know it's a comment, and point\n+   is at the second character of the initiator.  */\n+static void\n+skip_line_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  FORWARD(1);\n+  for (;;)\n+    {\n+      int c = GETC ();\n+\n+      /* We don't have to worry about EOF in here.  */\n+      if (c == '\\n')\n+\t{\n+\t  /* Don't consider final '\\n' to be part of comment.  */\n+\t  FORWARD(-1);\n+\t  return;\n+\t}\n+      else if (c == '\\r')\n+\t{\n+\t  /* \\r cannot be a macro escape marker here. */\n+\t  if (!ACTIVE_MARK_P (pfile))\n+\t    CPP_BUMP_LINE (pfile);\n+\t  if (CPP_OPTIONS (pfile)->warn_comments)\n+\t    cpp_warning (pfile, \"backslash-newline within line comment\");\n+\t}\n+    }\n+}\n+\n+/* Skip a comment - C, C++, or Chill style.  M is the first character\n+   of the comment marker.  If this really is a comment, skip to its\n+   end and return ' '.  If this is not a comment, return M (which will\n+   be '/' or '-').  */\n+\n+static int\n+skip_comment (pfile, m)\n+     cpp_reader *pfile;\n+     int m;\n+{\n+  if (m == '/' && PEEKC() == '*')\n+    {\n+      skip_block_comment (pfile);\n+      return ' ';\n+    }\n+  else if (m == '/' && PEEKC() == '/')\n+    {\n+      if (CPP_BUFFER (pfile)->system_header_p)\n+\t{\n+\t  /* We silently allow C++ comments in system headers, irrespective\n+\t     of conformance mode, because lots of busted systems do that\n+\t     and trying to clean it up in fixincludes is a nightmare.  */\n+\t  skip_line_comment (pfile);\n+\t  return ' ';\n+\t}\n+      else if (CPP_OPTIONS (pfile)->cplusplus_comments)\n+\t{\n+\t  if (CPP_OPTIONS (pfile)->c89\n+\t      && CPP_PEDANTIC (pfile)\n+\t      && ! CPP_BUFFER (pfile)->warned_cplusplus_comments)\n+\t    {\n+\t      cpp_pedwarn (pfile,\n+\t\t\t   \"C++ style comments are not allowed in ISO C89\");\n+\t      cpp_pedwarn (pfile,\n+\t\t\t   \"(this will be reported only once per input file)\");\n+\t      CPP_BUFFER (pfile)->warned_cplusplus_comments = 1;\n+\t    }\n+\t  skip_line_comment (pfile);\n+\t  return ' ';\n+\t}\n+      else\n+\treturn m;\n+    }\n+  else if (m == '-' && PEEKC() == '-'\n+\t   && CPP_OPTIONS (pfile)->chill)\n+    {\n+      skip_line_comment (pfile);\n+      return ' ';\n+    }\n+  else\n+    return m;\n+}\n+\n+/* Identical to skip_comment except that it copies the comment into the\n+   token_buffer.  This is used if !discard_comments.  */\n+static int\n+copy_comment (pfile, m)\n+     cpp_reader *pfile;\n+     int m;\n+{\n+  const U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n+  const U_CHAR *limit;\n+\n+  if (skip_comment (pfile, m) == m)\n+    return m;\n+\n+  limit = CPP_BUFFER (pfile)->cur;\n+  CPP_RESERVE (pfile, limit - start + 2);\n+  CPP_PUTC_Q (pfile, m);\n+  for (; start <= limit; start++)\n+    if (*start != '\\r')\n+      CPP_PUTC_Q (pfile, *start);\n+\n+  return ' ';\n+}\n+\n+/* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n+\n+void\n+_cpp_skip_hspace (pfile)\n+     cpp_reader *pfile;\n+{\n+  int c;\n+  while (1)\n+    {\n+      c = GETC();\n+      if (c == EOF)\n+\treturn;\n+      else if (is_hspace(c))\n+\t{\n+\t  if ((c == '\\f' || c == '\\v') && CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n+\t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n+\t}\n+      else if (c == '\\r')\n+\t{\n+\t  /* \\r is a backslash-newline marker if !has_escapes, and\n+\t     a deletable-whitespace or no-reexpansion marker otherwise. */\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    {\n+\t      if (PEEKC() == ' ')\n+\t\tFORWARD(1);\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    CPP_BUMP_LINE (pfile);\n+\t}\n+      else if (c == '/' || c == '-')\n+\t{\n+\t  c = skip_comment (pfile, c);\n+\t  if (c  != ' ')\n+\t    break;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  FORWARD(-1);\n+}\n+\n+/* Read and discard the rest of the current line.  */\n+\n+void\n+_cpp_skip_rest_of_line (pfile)\n+     cpp_reader *pfile;\n+{\n+  for (;;)\n+    {\n+      int c = GETC();\n+      switch (c)\n+\t{\n+\tcase '\\n':\n+\t  FORWARD(-1);\n+\tcase EOF:\n+\t  return;\n+\n+\tcase '\\r':\n+\t  if (! CPP_BUFFER (pfile)->has_escapes)\n+\t    CPP_BUMP_LINE (pfile);\n+\t  break;\n+\t  \n+\tcase '\\'':\n+\tcase '\\\"':\n+\t  skip_string (pfile, c);\n+\t  break;\n+\n+\tcase '/':\n+\tcase '-':\n+\t  skip_comment (pfile, c);\n+\t  break;\n+\n+\tcase '\\f':\n+\tcase '\\v':\n+\t  if (CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n+\t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n+\t  break;\n+\n+\t}\n+    }\n+}\n+\n+/* Parse an identifier starting with C.  */\n+\n+void\n+_cpp_parse_name (pfile, c)\n+     cpp_reader *pfile;\n+     int c;\n+{\n+  for (;;)\n+  {\n+      if (! is_idchar(c))\n+      {\n+\t  FORWARD (-1);\n+\t  break;\n+      }\n+\n+      if (c == '$' && CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn (pfile, \"`$' in identifier\");\n+\n+      CPP_RESERVE(pfile, 2); /* One more for final NUL.  */\n+      CPP_PUTC_Q (pfile, c);\n+      c = GETC();\n+      if (c == EOF)\n+\tbreak;\n+  }\n+  CPP_NUL_TERMINATE_Q (pfile);\n+  return;\n+}\n+\n+/* Parse and skip over a string starting with C.  A single quoted\n+   string is treated like a double -- some programs (e.g., troff) are\n+   perverse this way.  (However, a single quoted string is not allowed\n+   to extend over multiple lines.)  */\n+static void\n+skip_string (pfile, c)\n+     cpp_reader *pfile;\n+     int c;\n+{\n+  long start_line, start_column;\n+  cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n+\n+  while (1)\n+    {\n+      int cc = GETC();\n+      switch (cc)\n+\t{\n+\tcase EOF:\n+\t  cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t       \"unterminated string or character constant\");\n+\t  if (pfile->multiline_string_line != start_line\n+\t      && pfile->multiline_string_line != 0)\n+\t    cpp_error_with_line (pfile,\n+\t\t\t\t pfile->multiline_string_line, -1,\n+\t\t\t \"possible real start of unterminated constant\");\n+\t  pfile->multiline_string_line = 0;\n+\t  return;\n+\n+\tcase '\\n':\n+\t  CPP_BUMP_LINE (pfile);\n+\t  /* In Fortran and assembly language, silently terminate\n+\t     strings of either variety at end of line.  This is a\n+\t     kludge around not knowing where comments are in these\n+\t     languages.  */\n+\t  if (CPP_OPTIONS (pfile)->lang_fortran\n+\t      || CPP_OPTIONS (pfile)->lang_asm)\n+\t    {\n+\t      FORWARD(-1);\n+\t      return;\n+\t    }\n+\t  /* Character constants may not extend over multiple lines.\n+\t     In Standard C, neither may strings.  We accept multiline\n+\t     strings as an extension.  */\n+\t  if (c == '\\'')\n+\t    {\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t\t   \"unterminated character constant\");\n+\t      FORWARD(-1);\n+\t      return;\n+\t    }\n+\t  if (CPP_PEDANTIC (pfile) && pfile->multiline_string_line == 0)\n+\t    cpp_pedwarn_with_line (pfile, start_line, start_column,\n+\t\t\t\t   \"string constant runs past end of line\");\n+\t  if (pfile->multiline_string_line == 0)\n+\t    pfile->multiline_string_line = start_line;\n+\t  break;\n+\n+\tcase '\\r':\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    {\n+\t      cpp_ice (pfile, \"\\\\r escape inside string constant\");\n+\t      FORWARD(1);\n+\t    }\n+\t  else\n+\t    /* Backslash newline is replaced by nothing at all.  */\n+\t    CPP_BUMP_LINE (pfile);\n+\t  break;\n+\n+\tcase '\\\\':\n+\t  FORWARD(1);\n+\t  break;\n+\n+\tcase '\\\"':\n+\tcase '\\'':\n+\t  if (cc == c)\n+\t    return;\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Parse a string and copy it to the output.  */\n+\n+static void\n+parse_string (pfile, c)\n+     cpp_reader *pfile;\n+     int c;\n+{\n+  const U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n+  const U_CHAR *limit;\n+\n+  skip_string (pfile, c);\n+\n+  limit = CPP_BUFFER (pfile)->cur;\n+  CPP_RESERVE (pfile, limit - start + 2);\n+  CPP_PUTC_Q (pfile, c);\n+  for (; start < limit; start++)\n+    if (*start != '\\r')\n+      CPP_PUTC_Q (pfile, *start);\n+}\n+\n+/* Read an assertion into the token buffer, converting to\n+   canonical form: `#predicate(a n swe r)'  The next non-whitespace\n+   character to read should be the first letter of the predicate.\n+   Returns 0 for syntax error, 1 for bare predicate, 2 for predicate\n+   with answer (see callers for why). In case of 0, an error has been\n+   printed. */\n+int\n+_cpp_parse_assertion (pfile)\n+     cpp_reader *pfile;\n+{\n+  int c, dropwhite;\n+  _cpp_skip_hspace (pfile);\n+  c = PEEKC();\n+  if (! is_idstart(c))\n+    {\n+      cpp_error (pfile, \"assertion predicate is not an identifier\");\n+      return 0;\n+    }\n+  CPP_PUTC(pfile, '#');\n+  FORWARD(1);\n+  _cpp_parse_name (pfile, c);\n+\n+  c = PEEKC();\n+  if (c != '(')\n+    {\n+      if (is_hspace(c) || c == '\\r')\n+\t_cpp_skip_hspace (pfile);\n+      c = PEEKC();\n+    }\n+  if (c != '(')\n+    return 1;\n+\n+  CPP_PUTC(pfile, '(');\n+  FORWARD(1);\n+  dropwhite = 1;\n+  while ((c = GETC()) != ')')\n+    {\n+      if (is_space(c))\n+\t{\n+\t  if (! dropwhite)\n+\t    {\n+\t      CPP_PUTC(pfile, ' ');\n+\t      dropwhite = 1;\n+\t    }\n+\t}\n+      else if (c == '\\n' || c == EOF)\n+\t{\n+\t  if (c == '\\n') FORWARD(-1);\n+\t  cpp_error (pfile, \"un-terminated assertion answer\");\n+\t  return 0;\n+\t}\n+      else if (c == '\\r')\n+\t/* \\r cannot be a macro escape here. */\n+\tCPP_BUMP_LINE (pfile);\n+      else\n+\t{\n+\t  CPP_PUTC (pfile, c);\n+\t  dropwhite = 0;\n+\t}\n+    }\n+\n+  if (pfile->limit[-1] == ' ')\n+    pfile->limit[-1] = ')';\n+  else if (pfile->limit[-1] == '(')\n+    {\n+      cpp_error (pfile, \"empty token sequence in assertion\");\n+      return 0;\n+    }\n+  else\n+    CPP_PUTC (pfile, ')');\n+\n+  CPP_NUL_TERMINATE (pfile);\n+  return 2;\n+}\n+\n+/* Get the next token, and add it to the text in pfile->token_buffer.\n+   Return the kind of token we got.  */\n+\n+enum cpp_token\n+_cpp_lex_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  register int c, c2, c3;\n+  enum cpp_token token;\n+  struct cpp_options *opts = CPP_OPTIONS (pfile);\n+\n+ get_next:\n+  c = GETC();\n+  switch (c)\n+    {\n+    case EOF:\n+      return CPP_EOF;\n+\n+    case '/':\n+      if (PEEKC () == '=')\n+\tgoto op2;\n+\n+    comment:\n+      if (opts->discard_comments)\n+\tc = skip_comment (pfile, c);\n+      else\n+\tc = copy_comment (pfile, c);\n+      if (c != ' ')\n+\tgoto randomchar;\n+\t  \n+      /* Comments are equivalent to spaces.\n+\t For -traditional, a comment is equivalent to nothing.  */\n+      if (opts->traditional || !opts->discard_comments)\n+\treturn CPP_COMMENT;\n+      else\n+\t{\n+\t  CPP_PUTC (pfile, c);\n+\t  return CPP_HSPACE;\n+\t}\n+\n+    case '#':\n+      if (pfile->parsing_if_directive)\n+\t{\n+\t  _cpp_skip_hspace (pfile);\n+\t  _cpp_parse_assertion (pfile);\n+\t  return CPP_ASSERTION;\n+\t}\n+\n+      if (pfile->parsing_define_directive && ! CPP_TRADITIONAL (pfile))\n+\t{\n+\t  CPP_RESERVE (pfile, 3);\n+\t  CPP_PUTC_Q (pfile, '#');\n+\t  CPP_NUL_TERMINATE_Q (pfile);\n+\t  if (PEEKC () != '#')\n+\t    return CPP_STRINGIZE;\n+\t      \n+\t  FORWARD (1);\n+\t  CPP_PUTC_Q (pfile, '#');\n+\t  CPP_NUL_TERMINATE_Q (pfile);\n+\t  return CPP_TOKPASTE;\n+\t}\n+\n+      if (!pfile->only_seen_white)\n+\tgoto randomchar;\n+      /* -traditional directives are recognized only with the # in\n+\t column 1.\n+\t XXX Layering violation.  */\n+      if (CPP_TRADITIONAL (pfile)\n+\t  && CPP_BUFFER (pfile)->cur - CPP_BUFFER (pfile)->line_base != 1)\n+\tgoto randomchar;\n+      return CPP_DIRECTIVE;\n+\n+    case '\\\"':\n+    case '\\'':\n+      parse_string (pfile, c);\n+      pfile->only_seen_white = 0;\n+      return c == '\\'' ? CPP_CHAR : CPP_STRING;\n+\n+    case '$':\n+      if (!opts->dollars_in_ident)\n+\tgoto randomchar;\n+      goto letter;\n+\n+    case ':':\n+      if (opts->cplusplus && PEEKC () == ':')\n+\tgoto op2;\n+      goto randomchar;\n+\n+    case '&':\n+    case '+':\n+    case '|':\n+      c2 = PEEKC ();\n+      if (c2 == c || c2 == '=')\n+\tgoto op2;\n+      goto randomchar;\n+\n+    case '*':\n+    case '!':\n+    case '%':\n+    case '=':\n+    case '^':\n+      if (PEEKC () == '=')\n+\tgoto op2;\n+      goto randomchar;\n+\n+    case '-':\n+      c2 = PEEKC ();\n+      if (c2 == '-')\n+\t{\n+\t  if (opts->chill)\n+\t    goto comment;  /* Chill style comment */\n+\t  else\n+\t    goto op2;\n+\t}\n+      else if (c2 == '=')\n+\tgoto op2;\n+      else if (c2 == '>')\n+\t{\n+\t  if (opts->cplusplus && PEEKN (1) == '*')\n+\t    {\n+\t      /* In C++, there's a ->* operator.  */\n+\t      token = CPP_OTHER;\n+\t      pfile->only_seen_white = 0;\n+\t      CPP_RESERVE (pfile, 4);\n+\t      CPP_PUTC_Q (pfile, c);\n+\t      CPP_PUTC_Q (pfile, GETC ());\n+\t      CPP_PUTC_Q (pfile, GETC ());\n+\t      CPP_NUL_TERMINATE_Q (pfile);\n+\t      return token;\n+\t    }\n+\t  goto op2;\n+\t}\n+      goto randomchar;\n+\n+    case '<':\n+      if (pfile->parsing_include_directive)\n+\t{\n+\t  for (;;)\n+\t    {\n+\t      CPP_PUTC (pfile, c);\n+\t      if (c == '>')\n+\t\tbreak;\n+\t      c = GETC ();\n+\t      if (c == '\\n' || c == EOF)\n+\t\t{\n+\t\t  cpp_error (pfile,\n+\t\t\t     \"missing '>' in `#include <FILENAME>'\");\n+\t\t  break;\n+\t\t}\n+\t      else if (c == '\\r')\n+\t\t{\n+\t\t  if (!CPP_BUFFER (pfile)->has_escapes)\n+\t\t    {\n+\t\t      /* Backslash newline is replaced by nothing. */\n+\t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t      CPP_BUMP_LINE (pfile);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* We might conceivably get \\r- or \\r<space> in\n+\t\t\t here.  Just delete 'em. */\n+\t\t      int d = GETC();\n+\t\t      if (d != '-' && d != ' ')\n+\t\t\tcpp_ice (pfile, \"unrecognized escape \\\\r%c\", d);\n+\t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t    }\t\t\t  \n+\t\t}\n+\t    }\n+\t  return CPP_STRING;\n+\t}\n+      /* else fall through */\n+    case '>':\n+      c2 = PEEKC ();\n+      if (c2 == '=')\n+\tgoto op2;\n+      /* GNU C++ supports MIN and MAX operators <? and >?.  */\n+      if (c2 != c && (!opts->cplusplus || c2 != '?'))\n+\tgoto randomchar;\n+      FORWARD(1);\n+      CPP_RESERVE (pfile, 4);\n+      CPP_PUTC (pfile, c);\n+      CPP_PUTC (pfile, c2);\n+      c3 = PEEKC ();\n+      if (c3 == '=')\n+\tCPP_PUTC_Q (pfile, GETC ());\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      pfile->only_seen_white = 0;\n+      return CPP_OTHER;\n+\n+    case '.':\n+      c2 = PEEKC ();\n+      if (ISDIGIT(c2))\n+\t{\n+\t  CPP_RESERVE(pfile, 2);\n+\t  CPP_PUTC_Q (pfile, '.');\n+\t  c = GETC ();\n+\t  goto number;\n+\t}\n+\n+      /* In C++ there's a .* operator.  */\n+      if (opts->cplusplus && c2 == '*')\n+\tgoto op2;\n+\n+      if (c2 == '.' && PEEKN(1) == '.')\n+\t{\n+\t  CPP_RESERVE(pfile, 4);\n+\t  CPP_PUTC_Q (pfile, '.');\n+\t  CPP_PUTC_Q (pfile, '.');\n+\t  CPP_PUTC_Q (pfile, '.');\n+\t  FORWARD (2);\n+\t  CPP_NUL_TERMINATE_Q (pfile);\n+\t  pfile->only_seen_white = 0;\n+\t  return CPP_3DOTS;\n+\t}\n+      goto randomchar;\n+\n+    op2:\n+      token = CPP_OTHER;\n+      pfile->only_seen_white = 0;\n+      CPP_RESERVE(pfile, 3);\n+      CPP_PUTC_Q (pfile, c);\n+      CPP_PUTC_Q (pfile, GETC ());\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      return token;\n+\n+    case 'L':\n+      c2 = PEEKC ();\n+      if ((c2 == '\\'' || c2 == '\\\"') && !CPP_TRADITIONAL (pfile))\n+\t{\n+\t  CPP_PUTC (pfile, c);\n+\t  c = GETC ();\n+\t  parse_string (pfile, c);\n+\t  pfile->only_seen_white = 0;\n+\t  return c == '\\'' ? CPP_WCHAR : CPP_WSTRING;\n+\t}\n+      goto letter;\n+\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+    number:\n+    c2  = '.';\n+    for (;;)\n+      {\n+\tCPP_RESERVE (pfile, 2);\n+\tCPP_PUTC_Q (pfile, c);\n+\tc = PEEKC ();\n+\tif (c == EOF)\n+\t  break;\n+\tif (!is_numchar(c) && c != '.'\n+\t    && ((c2 != 'e' && c2 != 'E'\n+\t\t && ((c2 != 'p' && c2 != 'P')\n+\t\t     || CPP_OPTIONS (pfile)->c89))\n+\t\t|| (c != '+' && c != '-')))\n+\t  break;\n+\tFORWARD(1);\n+\tc2= c;\n+      }\n+    CPP_NUL_TERMINATE_Q (pfile);\n+    pfile->only_seen_white = 0;\n+    return CPP_NUMBER;\n+    case 'b': case 'c': case 'd': case 'h': case 'o':\n+    case 'B': case 'C': case 'D': case 'H': case 'O':\n+      if (opts->chill && PEEKC () == '\\'')\n+\t{\n+\t  pfile->only_seen_white = 0;\n+\t  CPP_RESERVE (pfile, 2);\n+\t  CPP_PUTC_Q (pfile, c);\n+\t  CPP_PUTC_Q (pfile, '\\'');\n+\t  FORWARD(1);\n+\t  for (;;)\n+\t    {\n+\t      c = GETC();\n+\t      if (c == EOF)\n+\t\tgoto chill_number_eof;\n+\t      if (!is_numchar(c))\n+\t\tbreak;\n+\t      CPP_PUTC (pfile, c);\n+\t    }\n+\t  if (c == '\\'')\n+\t    {\n+\t      CPP_RESERVE (pfile, 2);\n+\t      CPP_PUTC_Q (pfile, c);\n+\t      CPP_NUL_TERMINATE_Q (pfile);\n+\t      return CPP_STRING;\n+\t    }\n+\t  else\n+\t    {\n+\t      FORWARD(-1);\n+\t    chill_number_eof:\n+\t      CPP_NUL_TERMINATE (pfile);\n+\t      return CPP_NUMBER;\n+\t    }\n+\t}\n+      else\n+\tgoto letter;\n+    case '_':\n+    case 'a': case 'e': case 'f': case 'g': case 'i': case 'j':\n+    case 'k': case 'l': case 'm': case 'n': case 'p': case 'q':\n+    case 'r': case 's': case 't': case 'u': case 'v': case 'w':\n+    case 'x': case 'y': case 'z':\n+    case 'A': case 'E': case 'F': case 'G': case 'I': case 'J':\n+    case 'K': case 'M': case 'N': case 'P': case 'Q': case 'R':\n+    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+    case 'Y': case 'Z':\n+    letter:\n+    pfile->only_seen_white = 0;\n+    _cpp_parse_name (pfile, c);\n+    return CPP_MACRO;\n+\n+    case ' ':  case '\\t':  case '\\v':\n+      for (;;)\n+\t{\n+\t  CPP_PUTC (pfile, c);\n+\t  c = PEEKC ();\n+\t  if (c == EOF || !is_hspace(c))\n+\t    break;\n+\t  FORWARD(1);\n+\t}\n+      return CPP_HSPACE;\n+\n+    case '\\r':\n+      if (CPP_BUFFER (pfile)->has_escapes)\n+\t{\n+\t  c = GETC ();\n+\t  if (c == '-')\n+\t    {\n+\t      if (pfile->output_escapes)\n+\t\tCPP_PUTS (pfile, \"\\r-\", 2);\n+\t      _cpp_parse_name (pfile, GETC ());\n+\t      return CPP_NAME;\n+\t    }\n+\t  else if (c == ' ')\n+\t    {\n+\t      CPP_RESERVE (pfile, 2);\n+\t      if (pfile->output_escapes)\n+\t\tCPP_PUTC_Q (pfile, '\\r');\n+\t      CPP_PUTC_Q (pfile, c);\n+\t      return CPP_HSPACE;\n+\t    }\n+\t  else\n+\t    {\n+\t      cpp_ice (pfile, \"unrecognized escape \\\\r%c\", c);\n+\t      goto get_next;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Backslash newline is ignored. */\n+\t  CPP_BUMP_LINE (pfile);\n+\t  goto get_next;\n+\t}\n+\n+    case '\\n':\n+      CPP_PUTC (pfile, c);\n+      if (pfile->only_seen_white == 0)\n+\tpfile->only_seen_white = 1;\n+      CPP_BUMP_LINE (pfile);\n+      if (! CPP_OPTIONS (pfile)->no_line_commands)\n+\t{\n+\t  pfile->lineno++;\n+\t  if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n+\t    _cpp_output_line_command (pfile, same_file);\n+\t}\n+      return CPP_VSPACE;\n+\n+    case '(': token = CPP_LPAREN;    goto char1;\n+    case ')': token = CPP_RPAREN;    goto char1;\n+    case '{': token = CPP_LBRACE;    goto char1;\n+    case '}': token = CPP_RBRACE;    goto char1;\n+    case ',': token = CPP_COMMA;     goto char1;\n+    case ';': token = CPP_SEMICOLON; goto char1;\n+\n+    randomchar:\n+    default:\n+      token = CPP_OTHER;\n+    char1:\n+      pfile->only_seen_white = 0;\n+      CPP_PUTC (pfile, c);\n+      return token;\n+    }\n+}\n+\n+/* Check for and expand a macro, which is from WRITTEN to CPP_WRITTEN (pfile).\n+   Caller is expected to have checked no_macro_expand.  */\n+static int\n+maybe_macroexpand (pfile, written)\n+     cpp_reader *pfile;\n+     long written;\n+{\n+  U_CHAR *macro = pfile->token_buffer + written;\n+  size_t len = CPP_WRITTEN (pfile) - written;\n+  HASHNODE *hp = _cpp_lookup (pfile, macro, len);\n+\n+  if (!hp)\n+    return 0;\n+  if (hp->type == T_DISABLED)\n+    {\n+      if (pfile->output_escapes)\n+\t{\n+\t  /* Insert a no-reexpand marker before IDENT.  */\n+\t  CPP_RESERVE (pfile, 2);\n+\t  CPP_ADJUST_WRITTEN (pfile, 2);\n+\t  macro = pfile->token_buffer + written;\n+\n+\t  memmove (macro + 2, macro, len);\n+\t  macro[0] = '\\r';\n+\t  macro[1] = '-';\n+\t}\n+      return 0;\n+    }\n+\n+  /* If macro wants an arglist, verify that a '(' follows.  */\n+  if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n+    {\n+      int macbuf_whitespace = 0;\n+      int c;\n+\n+      while (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t{\n+\t  const U_CHAR *point = CPP_BUFFER (pfile)->cur;\n+\t  for (;;)\n+\t    {\n+\t      _cpp_skip_hspace (pfile);\n+\t      c = PEEKC ();\n+\t      if (c == '\\n')\n+\t\tFORWARD(1);\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  if (point != CPP_BUFFER (pfile)->cur)\n+\t    macbuf_whitespace = 1;\n+\t  if (c == '(')\n+\t    goto is_macro_call;\n+\t  else if (c != EOF)\n+\t    goto not_macro_call;\n+\t  cpp_pop_buffer (pfile);\n+\t}\n+\n+      CPP_SET_MARK (pfile);\n+      for (;;)\n+\t{\n+\t  _cpp_skip_hspace (pfile);\n+\t  c = PEEKC ();\n+\t  if (c == '\\n')\n+\t    FORWARD(1);\n+\t  else\n+\t    break;\n+\t}\n+      CPP_GOTO_MARK (pfile);\n+\n+      if (c != '(')\n+\t{\n+\tnot_macro_call:\n+\t  if (macbuf_whitespace)\n+\t    CPP_PUTC (pfile, ' ');\n+\t  return 0;\n+\t}\n+    }\n+\n+ is_macro_call:\n+  /* This is now known to be a macro call.\n+     Expand the macro, reading arguments as needed,\n+     and push the expansion on the input stack.  */\n+  _cpp_macroexpand (pfile, hp);\n+  CPP_SET_WRITTEN (pfile, written);\n+  return 1;\n+}\n+\n+enum cpp_token\n+cpp_get_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  enum cpp_token token;\n+  long written = CPP_WRITTEN (pfile);\n+\n+ get_next:\n+  token = _cpp_lex_token (pfile);\n+\n+  switch (token)\n+    {\n+    default:\n+      return token;\n+\n+    case CPP_DIRECTIVE:\n+      if (_cpp_handle_directive (pfile))\n+\treturn CPP_DIRECTIVE;\n+      pfile->only_seen_white = 0;\n+      CPP_PUTC (pfile, '#');\n+      return CPP_OTHER;\n+\n+    case CPP_MACRO:\n+      if (! pfile->no_macro_expand\n+\t  && maybe_macroexpand (pfile, written))\n+\tgoto get_next;\n+      return CPP_NAME;\n+\n+    case CPP_EOF:\n+      if (CPP_BUFFER (pfile)->manual_pop)\n+\t/* If we've been reading from redirected input, the\n+\t   frontend will pop the buffer.  */\n+\treturn CPP_EOF;\n+      else if (CPP_BUFFER (pfile)->seen_eof)\n+\t{\n+\t  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) == NULL)\n+\t    return CPP_EOF;\n+\n+\t  cpp_pop_buffer (pfile);\n+\t  goto get_next;\n+\t}\n+      else\n+\t{\n+\t  _cpp_handle_eof (pfile);\n+\t  return CPP_POP;\n+\t}\n+    }\n+}\n+\n+/* Like cpp_get_token, but skip spaces and comments.  */\n+\n+enum cpp_token\n+cpp_get_non_space_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  int old_written = CPP_WRITTEN (pfile);\n+  for (;;)\n+    {\n+      enum cpp_token token = cpp_get_token (pfile);\n+      if (token != CPP_COMMENT && token != CPP_POP\n+\t  && token != CPP_HSPACE && token != CPP_VSPACE)\n+\treturn token;\n+      CPP_SET_WRITTEN (pfile, old_written);\n+    }\n+}\n+\n+/* Like cpp_get_token, except that it does not read past end-of-line.\n+   Also, horizontal space is skipped, and macros are popped.  */\n+\n+enum cpp_token\n+_cpp_get_directive_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  long old_written = CPP_WRITTEN (pfile);\n+  enum cpp_token token;\n+\n+  for (;;)\n+    {\n+      _cpp_skip_hspace (pfile);\n+      if (PEEKC () == '\\n')\n+\treturn CPP_VSPACE;\n+\n+      token = cpp_get_token (pfile);\n+      /* token could be hspace at the beginning of a macro.  */\n+      if (token == CPP_HSPACE || token == CPP_COMMENT)\n+\t{\n+\t  CPP_SET_WRITTEN (pfile, old_written);\n+\t  continue;\n+\t}\n+\n+      /* token cannot be vspace, it would have been caught above.  */\n+      if (token == CPP_VSPACE)\n+\t{\n+\t  cpp_ice (pfile, \"VSPACE in get_directive_token\");\n+\t  return token;\n+\t}\n+\n+      /* token cannot be POP unless the buffer is a macro buffer.  */\n+      if (token != CPP_POP)\n+\treturn token;\n+\n+      if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t{\n+\t  cpp_ice (pfile, \"POP of file buffer in get_directive_token\");\n+\t  return token;\n+\t}\n+\n+      /* We must pop the buffer by hand, or else cpp_get_token might\n+\t hand us white space or newline on the next invocation.  */\n+      cpp_pop_buffer (pfile);\n+    }\n+}\n+\n+/* Determine the current line and column.  Used only by read_and_prescan. */\n+static U_CHAR *\n+find_position (start, limit, linep)\n+     U_CHAR *start;\n+     U_CHAR *limit;\n+     unsigned long *linep;\n+{\n+  unsigned long line = *linep;\n+  U_CHAR *lbase = start;\n+  while (start < limit)\n+    {\n+      U_CHAR ch = *start++;\n+      if (ch == '\\n' || ch == '\\r')\n+\t{\n+\t  line++;\n+\t  lbase = start;\n+\t}\n+    }\n+  *linep = line;\n+  return lbase;\n+}\n+\n+/* Read the entire contents of file DESC into buffer BUF.  LEN is how\n+   much memory to allocate initially; more will be allocated if\n+   necessary.  Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n+   canonical form (\\n).  If enabled, convert and/or warn about\n+   trigraphs.  Convert backslash-newline to a one-character escape\n+   (\\r) and remove it from \"embarrassing\" places (i.e. the middle of a\n+   token).  If there is no newline at the end of the file, add one and\n+   warn.  Returns -1 on failure, or the actual length of the data to\n+   be scanned.\n+\n+   This function does a lot of work, and can be a serious performance\n+   bottleneck.  It has been tuned heavily; make sure you understand it\n+   before hacking.  The common case - no trigraphs, Unix style line\n+   breaks, backslash-newline set off by whitespace, newline at EOF -\n+   has been optimized at the expense of the others.  The performance\n+   penalty for DOS style line breaks (\\r\\n) is about 15%.\n+   \n+   Warnings lose particularly heavily since we have to determine the\n+   line number, which involves scanning from the beginning of the file\n+   or from the last warning.  The penalty for the absence of a newline\n+   at the end of reload1.c is about 60%.  (reload1.c is 329k.)\n+\n+   If your file has more than one kind of end-of-line marker, you\n+   will get messed-up line numbering.  */\n+\n+/* Table of characters that can't be handled in the inner loop.\n+   Keep these contiguous to optimize the performance of the code generated\n+   for the switch that uses them.  */\n+#define SPECCASE_EMPTY     0\n+#define SPECCASE_NUL       1\n+#define SPECCASE_CR        2\n+#define SPECCASE_BACKSLASH 3\n+#define SPECCASE_QUESTION  4\n+\n+long\n+_cpp_read_and_prescan (pfile, fp, desc, len)\n+     cpp_reader *pfile;\n+     cpp_buffer *fp;\n+     int desc;\n+     size_t len;\n+{\n+  U_CHAR *buf = (U_CHAR *) xmalloc (len);\n+  U_CHAR *ip, *op, *line_base;\n+  U_CHAR *ibase;\n+  U_CHAR *speccase = pfile->input_speccase;\n+  unsigned long line;\n+  unsigned int deferred_newlines;\n+  int count;\n+  size_t offset;\n+\n+  offset = 0;\n+  op = buf;\n+  line_base = buf;\n+  line = 1;\n+  ibase = pfile->input_buffer + 2;\n+  deferred_newlines = 0;\n+\n+  for (;;)\n+    {\n+    read_next:\n+\n+      count = read (desc, pfile->input_buffer + 2, pfile->input_buffer_len);\n+      if (count < 0)\n+\tgoto error;\n+      else if (count == 0)\n+\tbreak;\n+\n+      offset += count;\n+      ip = ibase;\n+      ibase = pfile->input_buffer + 2;\n+      ibase[count] = ibase[count+1] = '\\0';\n+\n+      if (offset > len)\n+\t{\n+\t  size_t delta_op;\n+\t  size_t delta_line_base;\n+\t  len *= 2;\n+\t  if (offset > len)\n+\t    /* len overflowed.\n+\t       This could happen if the file is larger than half the\n+\t       maximum address space of the machine. */\n+\t    goto too_big;\n+\n+\t  delta_op = op - buf;\n+\t  delta_line_base = line_base - buf;\n+\t  buf = (U_CHAR *) xrealloc (buf, len);\n+\t  op = buf + delta_op;\n+\t  line_base = buf + delta_line_base;\n+\t}\n+\n+      for (;;)\n+\t{\n+\t  unsigned int span = 0;\n+\n+\t  /* Deal with \\-newline in the middle of a token. */\n+\t  if (deferred_newlines)\n+\t    {\n+\t      while (speccase[ip[span]] == SPECCASE_EMPTY\n+\t\t     && ip[span] != '\\n'\n+\t\t     && ip[span] != '\\t'\n+\t\t     && ip[span] != ' ')\n+\t\tspan++;\n+\t      memcpy (op, ip, span);\n+\t      op += span;\n+\t      ip += span;\n+\t      /* If ip[0] is SPECCASE_EMPTY, we have hit white space.\n+\t\t Dump out the remaining deferred \\-newlines.  */\n+\t      if (speccase[ip[0]] == SPECCASE_EMPTY)\n+\t\twhile (deferred_newlines)\n+\t\t  deferred_newlines--, *op++ = '\\r';\n+\t      span = 0;\n+\t    }\n+\n+\t  /* Copy as much as we can without special treatment. */\n+\t  while (speccase[ip[span]] == SPECCASE_EMPTY) span++;\n+\t  memcpy (op, ip, span);\n+\t  op += span;\n+\t  ip += span;\n+\n+\t  switch (speccase[*ip++])\n+\t    {\n+\t    case SPECCASE_NUL:  /* \\0 */\n+\t      ibase[-1] = op[-1];\n+\t      goto read_next;\n+\n+\t    case SPECCASE_CR:  /* \\r */\n+\t      if (ip[-2] == '\\n')\n+\t\tcontinue;\n+\t      else if (*ip == '\\n')\n+\t\tip++;\n+\t      else if (*ip == '\\0')\n+\t\t{\n+\t\t  *--ibase = '\\r';\n+\t\t  goto read_next;\n+\t\t}\n+\t      *op++ = '\\n';\n+\t      break;\n+\n+\t    case SPECCASE_BACKSLASH:  /* \\ */\n+\t    backslash:\n+\t    {\n+\t      /* If we're at the end of the intermediate buffer,\n+\t\t we have to shift the backslash down to the start\n+\t\t and come back next pass. */\n+\t      if (*ip == '\\0')\n+\t\t{\n+\t\t  *--ibase = '\\\\';\n+\t\t  goto read_next;\n+\t\t}\n+\t      else if (*ip == '\\n')\n+\t\t{\n+\t\t  ip++;\n+\t\t  if (*ip == '\\r') ip++;\n+\t\t  if (*ip == '\\n' || *ip == '\\t' || *ip == ' ')\n+\t\t    *op++ = '\\r';\n+\t\t  else if (op[-1] == '\\t' || op[-1] == ' '\n+\t\t\t   || op[-1] == '\\r' || op[-1] == '\\n')\n+\t\t    *op++ = '\\r';\n+\t\t  else\n+\t\t    deferred_newlines++;\n+\t\t}\n+\t      else if (*ip == '\\r')\n+\t\t{\n+\t\t  ip++;\n+\t\t  if (*ip == '\\n') ip++;\n+\t\t  else if (*ip == '\\0')\n+\t\t    {\n+\t\t      *--ibase = '\\r';\n+\t\t      *--ibase = '\\\\';\n+\t\t      goto read_next;\n+\t\t    }\n+\t\t  else if (*ip == '\\r' || *ip == '\\t' || *ip == ' ')\n+\t\t    *op++ = '\\r';\n+\t\t  else\n+\t\t    deferred_newlines++;\n+\t\t}\n+\t      else\n+\t\t*op++ = '\\\\';\n+\t    }\n+\t    break;\n+\n+\t    case SPECCASE_QUESTION: /* ? */\n+\t      {\n+\t\tunsigned int d, t;\n+\t\t/* If we're at the end of the intermediate buffer,\n+\t\t   we have to shift the ?'s down to the start and\n+\t\t   come back next pass. */\n+\t\td = ip[0];\n+\t\tif (d == '\\0')\n+\t\t  {\n+\t\t    *--ibase = '?';\n+\t\t    goto read_next;\n+\t\t  }\n+\t\tif (d != '?')\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    break;\n+\t\t  }\n+\t\td = ip[1];\n+\t\tif (d == '\\0')\n+\t\t  {\n+\t\t    *--ibase = '?';\n+\t\t    *--ibase = '?';\n+\t\t    goto read_next;\n+\t\t  }\n+\n+\t\t/* Trigraph map:\n+\t\t *\tfrom\tto\tfrom\tto\tfrom\tto\n+\t\t *\t?? =\t#\t?? )\t]\t?? !\t|\n+\t\t *\t?? (\t[\t?? '\t^\t?? >\t}\n+\t\t *\t?? /\t\\\t?? <\t{\t?? -\t~\n+\t\t */\n+\t\tif (d == '=') t = '#';\n+\t\telse if (d == ')') t = ']';\n+\t\telse if (d == '!') t = '|';\n+\t\telse if (d == '(') t = '[';\n+\t\telse if (d == '\\'') t = '^';\n+\t\telse if (d == '>') t = '}';\n+\t\telse if (d == '/') t = '\\\\';\n+\t\telse if (d == '<') t = '{';\n+\t\telse if (d == '-') t = '~';\n+\t\telse\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    break;\n+\t\t  }\n+\t\tip += 2;\n+\t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n+\t\t  {\n+\t\t    unsigned long col;\n+\t\t    line_base = find_position (line_base, op, &line);\n+\t\t    col = op - line_base + 1;\n+\t\t    if (CPP_OPTIONS (pfile)->trigraphs)\n+\t\t      cpp_warning_with_line (pfile, line, col,\n+\t\t\t     \"trigraph ??%c converted to %c\", d, t);\n+\t\t    else\n+\t\t      cpp_warning_with_line (pfile, line, col,\n+\t\t\t     \"trigraph ??%c ignored\", d);\n+\t\t  }\n+\t\tif (CPP_OPTIONS (pfile)->trigraphs)\n+\t\t  {\n+\t\t    if (t == '\\\\')\n+\t\t      goto backslash;\n+\t\t    else\n+\t\t      *op++ = t;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    *op++ = '?';\n+\t\t    *op++ = d;\n+\t\t  }\n+\t      }\n+\t    }\n+\t}\n+    }\n+\n+  if (offset == 0)\n+    return 0;\n+\n+  /* Deal with pushed-back chars at true EOF.\n+     This may be any of:  ?? ? \\ \\r \\n \\\\r \\\\n.\n+     \\r must become \\n, \\\\r or \\\\n must become \\r.\n+     We know we have space already. */\n+  if (ibase == pfile->input_buffer)\n+    {\n+      if (*ibase == '?')\n+\t{\n+\t  *op++ = '?';\n+\t  *op++ = '?';\n+\t}\n+      else\n+\t*op++ = '\\r';\n+    }\n+  else if (ibase == pfile->input_buffer + 1)\n+    {\n+      if (*ibase == '\\r')\n+\t*op++ = '\\n';\n+      else\n+\t*op++ = *ibase;\n+    }\n+\n+  if (op[-1] != '\\n')\n+    {\n+      unsigned long col;\n+      line_base = find_position (line_base, op, &line);\n+      col = op - line_base + 1;\n+      cpp_warning_with_line (pfile, line, col, \"no newline at end of file\\n\");\n+      if (offset + 1 > len)\n+\t{\n+\t  len += 1;\n+\t  if (offset + 1 > len)\n+\t    goto too_big;\n+\t  buf = (U_CHAR *) xrealloc (buf, len);\n+\t  op = buf + offset;\n+\t}\n+      *op++ = '\\n';\n+    }\n+\n+  fp->buf = ((len - offset < 20) ? buf : (U_CHAR *)xrealloc (buf, op - buf));\n+  return op - buf;\n+\n+ too_big:\n+  cpp_error (pfile, \"file is too large (>%lu bytes)\\n\", (unsigned long)offset);\n+  free (buf);\n+  return -1;\n+\n+ error:\n+  cpp_error_from_errno (pfile, fp->ihash->name);\n+  free (buf);\n+  return -1;\n+}\n+\n+/* Initialize the `input_buffer' and `input_speccase' tables.\n+   These are only used by read_and_prescan, but they're large and\n+   somewhat expensive to set up, so we want them allocated once for\n+   the duration of the cpp run.  */\n+\n+void\n+_cpp_init_input_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  U_CHAR *tmp;\n+\n+  /* Table of characters that cannot be handled by the\n+     read_and_prescan inner loop.  The number of non-EMPTY entries\n+     should be as small as humanly possible.  */\n+\n+  tmp = (U_CHAR *) xmalloc (1 << CHAR_BIT);\n+  memset (tmp, SPECCASE_EMPTY, 1 << CHAR_BIT);\n+  tmp['\\0'] = SPECCASE_NUL;\n+  tmp['\\r'] = SPECCASE_CR;\n+  tmp['\\\\'] = SPECCASE_BACKSLASH;\n+  if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n+    tmp['?'] = SPECCASE_QUESTION;\n+\n+  pfile->input_speccase = tmp;\n+\n+  /* Determine the appropriate size for the input buffer.  Normal C\n+     source files are smaller than eight K.  */\n+  /* 8Kbytes of buffer proper, 2 to detect running off the end without\n+     address arithmetic all the time, and 2 for pushback in the case\n+     there's a potential trigraph or end-of-line digraph at the end of\n+     a block. */\n+\n+  tmp = (U_CHAR *) xmalloc (8192 + 2 + 2);\n+  pfile->input_buffer = tmp;\n+  pfile->input_buffer_len = 8192;\n+}"}, {"sha": "1de14d39df4ba4b4832144afe08db7f658625718", "filename": "gcc/cpplib.c", "status": "modified", "additions": 224, "deletions": 1507, "changes": 1731, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -28,19 +28,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"mkdeps.h\"\n \n-#define SKIP_WHITE_SPACE(p) do { while (is_hspace(*p)) p++; } while (0)\n-\n-#define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) ? CPP_BUFFER (pfile)->cur[N] : EOF)\n+#define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) \\\n+\t\t  ? CPP_BUFFER (pfile)->cur[N] : EOF)\n #define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n #define GETC() CPP_BUF_GET (CPP_BUFFER (pfile))\n #define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n-/* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.\n-   (Note that it is false while we're expanding macro *arguments*.) */\n-#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n-\n-/* ACTIVE_MARK_P is true if there's a live mark in the buffer, in which\n-   case CPP_BUMP_LINE must not be called.  */\n-#define ACTIVE_MARK_P() (CPP_BUFFER (pfile)->mark != -1)\n \n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n@@ -93,34 +85,19 @@ static int do_warning PARAMS ((cpp_reader *, const struct directive *));\n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n-static int eval_if_expr\t\t\tPARAMS ((cpp_reader *));\n static void conditional_skip\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t\tenum node_type, U_CHAR *));\n static void skip_if_group\t\tPARAMS ((cpp_reader *));\n-static void parse_name\t\t\tPARAMS ((cpp_reader *, int));\n-static void parse_string\t\tPARAMS ((cpp_reader *, int));\n-static int parse_assertion\t\tPARAMS ((cpp_reader *));\n-static const char *if_directive_name\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct if_stack *));\n-static int null_cleanup\t\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n-static int skip_comment\t\t\tPARAMS ((cpp_reader *, int));\n-static int copy_comment\t\t\tPARAMS ((cpp_reader *, int));\n-static void skip_string\t\t\tPARAMS ((cpp_reader *, int));\n-static void skip_rest_of_line\t\tPARAMS ((cpp_reader *));\n-static void cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n-static int handle_directive\t\tPARAMS ((cpp_reader *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t cpp_reader *,\n \t\t\t\t\t\t const struct directive *));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n static int consider_directive_while_skipping\n \t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n-static void skip_block_comment\t\tPARAMS ((cpp_reader *));\n-static void skip_line_comment\t\tPARAMS ((cpp_reader *));\n-static void parse_set_mark\t\tPARAMS ((cpp_reader *));\n-static void parse_goto_mark\t\tPARAMS ((cpp_reader *));\n static int get_macro_name\t\tPARAMS ((cpp_reader *));\n+static const char *if_directive_name\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t struct if_stack *));\n \n /* Here is the actual list of #-directives.\n    This table is ordered by frequency of occurrence; the numbers\n@@ -156,367 +133,11 @@ static const struct directive directive_table[] = {\n   {  -1, 0, \"\", T_UNUSED }\n };\n \n-/* Place into PFILE a quoted string representing the string SRC.\n-   Caller must reserve enough space in pfile->token_buffer.  */\n-\n-void\n-quote_string (pfile, src)\n-     cpp_reader *pfile;\n-     const char *src;\n-{\n-  U_CHAR c;\n-\n-  CPP_PUTC_Q (pfile, '\\\"');\n-  for (;;)\n-    switch ((c = *src++))\n-      {\n-      default:\n-        if (ISPRINT (c))\n-\t  CPP_PUTC_Q (pfile, c);\n-\telse\n-\t  {\n-\t    sprintf ((char *)CPP_PWRITTEN (pfile), \"\\\\%03o\", c);\n-\t    CPP_ADJUST_WRITTEN (pfile, 4);\n-\t  }\n-\tbreak;\n-\n-      case '\\\"':\n-      case '\\\\':\n-\tCPP_PUTC_Q (pfile, '\\\\');\n-\tCPP_PUTC_Q (pfile, c);\n-\tbreak;\n-      \n-      case '\\0':\n-\tCPP_PUTC_Q (pfile, '\\\"');\n-\tCPP_NUL_TERMINATE_Q (pfile);\n-\treturn;\n-      }\n-}\n-\n-/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n-\n-void\n-cpp_grow_buffer (pfile, n)\n-     cpp_reader *pfile;\n-     long n;\n-{\n-  long old_written = CPP_WRITTEN (pfile);\n-  pfile->token_buffer_size = n + 2 * pfile->token_buffer_size;\n-  pfile->token_buffer = (U_CHAR *)\n-    xrealloc(pfile->token_buffer, pfile->token_buffer_size);\n-  CPP_SET_WRITTEN (pfile, old_written);\n-}\n-\n-/* Process the string STR as if it appeared as the body of a #define.\n-   If STR is just an identifier, define it with value 1.\n-   If STR has anything after the identifier, then it should\n-   be identifier=definition. */\n-\n-void\n-cpp_define (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n-{\n-  char *buf, *p;\n-  size_t count;\n-\n-  p = strchr (str, '=');\n-  /* Copy the entire option so we can modify it. \n-     Change the first \"=\" in the string to a space.  If there is none,\n-     tack \" 1\" on the end.  Then add a newline and a NUL.  */\n-  \n-  if (p)\n-    {\n-      count = strlen (str) + 2;\n-      buf = alloca (count);\n-      memcpy (buf, str, count - 2);\n-      buf[p - str] = ' ';\n-      buf[count - 2] = '\\n';\n-      buf[count - 1] = '\\0';\n-    }\n-  else\n-    {\n-      count = strlen (str) + 4;\n-      buf = alloca (count);\n-      memcpy (buf, str, count - 4);\n-      strcpy (&buf[count-4], \" 1\\n\");\n-    }\n-\n-  if (cpp_push_buffer (pfile, buf, count - 1) != NULL)\n-    {\n-      do_define (pfile, NULL);\n-      cpp_pop_buffer (pfile);\n-    }\n-}\n-\n-/* Process the string STR as if it appeared as the body of a #assert. */\n-void\n-cpp_assert (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n-{\n-  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n-    {\n-      do_assert (pfile, NULL);\n-      cpp_pop_buffer (pfile);\n-    }\n-}\n-\n-/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n-int\n-cpp_defined (pfile, id, len)\n-     cpp_reader *pfile;\n-     const U_CHAR *id;\n-     int len;\n-{\n-  HASHNODE *hp = _cpp_lookup (pfile, id, len);\n-  if (hp && hp->type == T_POISON)\n-    {\n-      cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n-      return 0;\n-    }\n-  return (hp != NULL);\n-}\n-\n-static int\n-null_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf ATTRIBUTE_UNUSED;\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n-/* Skip a C-style block comment.  We know it's a comment, and point is\n-   at the second character of the starter.  */\n-static void\n-skip_block_comment (pfile)\n-     cpp_reader *pfile;\n-{\n-  int c, prev_c = -1;\n-  long line, col;\n-\n-  FORWARD(1);\n-  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n-  for (;;)\n-    {\n-      c = GETC ();\n-      if (c == EOF)\n-\t{\n-\t  cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n-\t  return;\n-\t}\n-      else if (c == '\\n' || c == '\\r')\n-\t{\n-\t  /* \\r cannot be a macro escape marker here. */\n-\t  if (!ACTIVE_MARK_P())\n-\t    CPP_BUMP_LINE (pfile);\n-\t}\n-      else if (c == '/' && prev_c == '*')\n-\treturn;\n-      else if (c == '*' && prev_c == '/'\n-\t       && CPP_OPTIONS (pfile)->warn_comments)\n-\tcpp_warning (pfile, \"`/*' within comment\");\n-\n-      prev_c = c;\n-    }\n-}\n-\n-/* Skip a C++/Chill line comment.  We know it's a comment, and point\n-   is at the second character of the initiator.  */\n-static void\n-skip_line_comment (pfile)\n-     cpp_reader *pfile;\n-{\n-  FORWARD(1);\n-  for (;;)\n-    {\n-      int c = GETC ();\n-\n-      /* We don't have to worry about EOF in here.  */\n-      if (c == '\\n')\n-\t{\n-\t  /* Don't consider final '\\n' to be part of comment.  */\n-\t  FORWARD(-1);\n-\t  return;\n-\t}\n-      else if (c == '\\r')\n-\t{\n-\t  /* \\r cannot be a macro escape marker here. */\n-\t  if (!ACTIVE_MARK_P())\n-\t    CPP_BUMP_LINE (pfile);\n-\t  if (CPP_OPTIONS (pfile)->warn_comments)\n-\t    cpp_warning (pfile, \"backslash-newline within line comment\");\n-\t}\n-    }\n-}\n-\n-/* Skip a comment - C, C++, or Chill style.  M is the first character\n-   of the comment marker.  If this really is a comment, skip to its\n-   end and return ' '.  If this is not a comment, return M (which will\n-   be '/' or '-').  */\n-\n-static int\n-skip_comment (pfile, m)\n-     cpp_reader *pfile;\n-     int m;\n-{\n-  if (m == '/' && PEEKC() == '*')\n-    {\n-      skip_block_comment (pfile);\n-      return ' ';\n-    }\n-  else if (m == '/' && PEEKC() == '/')\n-    {\n-      if (CPP_BUFFER (pfile)->system_header_p)\n-\t{\n-\t  /* We silently allow C++ comments in system headers, irrespective\n-\t     of conformance mode, because lots of busted systems do that\n-\t     and trying to clean it up in fixincludes is a nightmare.  */\n-\t  skip_line_comment (pfile);\n-\t  return ' ';\n-\t}\n-      else if (CPP_OPTIONS (pfile)->cplusplus_comments)\n-\t{\n-\t  if (CPP_OPTIONS (pfile)->c89\n-\t      && CPP_PEDANTIC (pfile)\n-\t      && ! CPP_BUFFER (pfile)->warned_cplusplus_comments)\n-\t    {\n-\t      cpp_pedwarn (pfile,\n-\t\t\t   \"C++ style comments are not allowed in ISO C89\");\n-\t      cpp_pedwarn (pfile,\n-\t\t\t   \"(this will be reported only once per input file)\");\n-\t      CPP_BUFFER (pfile)->warned_cplusplus_comments = 1;\n-\t    }\n-\t  skip_line_comment (pfile);\n-\t  return ' ';\n-\t}\n-      else\n-\treturn m;\n-    }\n-  else if (m == '-' && PEEKC() == '-'\n-\t   && CPP_OPTIONS (pfile)->chill)\n-    {\n-      skip_line_comment (pfile);\n-      return ' ';\n-    }\n-  else\n-    return m;\n-}\n-\n-/* Identical to skip_comment except that it copies the comment into the\n-   token_buffer.  This is used if !discard_comments.  */\n-static int\n-copy_comment (pfile, m)\n-     cpp_reader *pfile;\n-     int m;\n-{\n-  const U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n-  const U_CHAR *limit;\n-\n-  if (skip_comment (pfile, m) == m)\n-    return m;\n-\n-  limit = CPP_BUFFER (pfile)->cur;\n-  CPP_RESERVE (pfile, limit - start + 2);\n-  CPP_PUTC_Q (pfile, m);\n-  for (; start <= limit; start++)\n-    if (*start != '\\r')\n-      CPP_PUTC_Q (pfile, *start);\n-\n-  return ' ';\n-}\n-\n-/* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n-\n-static void\n-cpp_skip_hspace (pfile)\n-     cpp_reader *pfile;\n-{\n-  int c;\n-  while (1)\n-    {\n-      c = GETC();\n-      if (c == EOF)\n-\treturn;\n-      else if (is_hspace(c))\n-\t{\n-\t  if ((c == '\\f' || c == '\\v') && CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n-\t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n-\t}\n-      else if (c == '\\r')\n-\t{\n-\t  /* \\r is a backslash-newline marker if !has_escapes, and\n-\t     a deletable-whitespace or no-reexpansion marker otherwise. */\n-\t  if (CPP_BUFFER (pfile)->has_escapes)\n-\t    {\n-\t      if (PEEKC() == ' ')\n-\t\tFORWARD(1);\n-\t      else\n-\t\tbreak;\n-\t    }\n-\t  else\n-\t    CPP_BUMP_LINE (pfile);\n-\t}\n-      else if (c == '/' || c == '-')\n-\t{\n-\t  c = skip_comment (pfile, c);\n-\t  if (c  != ' ')\n-\t    break;\n-\t}\n-      else\n-\tbreak;\n-    }\n-  FORWARD(-1);\n-}\n-\n-/* Read and discard the rest of the current line.  */\n-\n-static void\n-skip_rest_of_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  for (;;)\n-    {\n-      int c = GETC();\n-      switch (c)\n-\t{\n-\tcase '\\n':\n-\t  FORWARD(-1);\n-\tcase EOF:\n-\t  return;\n-\n-\tcase '\\r':\n-\t  if (! CPP_BUFFER (pfile)->has_escapes)\n-\t    CPP_BUMP_LINE (pfile);\n-\t  break;\n-\t  \n-\tcase '\\'':\n-\tcase '\\\"':\n-\t  skip_string (pfile, c);\n-\t  break;\n-\n-\tcase '/':\n-\tcase '-':\n-\t  skip_comment (pfile, c);\n-\t  break;\n-\n-\tcase '\\f':\n-\tcase '\\v':\n-\t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n-\t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n-\t  break;\n-\n-\t}\n-    }\n-}\n-\n /* Handle a possible # directive.\n    '#' has already been read.  */\n \n-static int\n-handle_directive (pfile)\n+int\n+_cpp_handle_directive (pfile)\n      cpp_reader *pfile;\n {\n   int c;\n@@ -531,7 +152,7 @@ handle_directive (pfile)\n       return 0;\n     }\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n \n   c = PEEKC ();\n   /* # followed by a number is equivalent to #line.  Do not recognize\n@@ -558,7 +179,7 @@ handle_directive (pfile)\n \n   /* Now find the directive name.  */\n   CPP_PUTC (pfile, '#');\n-  parse_name (pfile, GETC());\n+  _cpp_parse_name (pfile, GETC());\n   ident = pfile->token_buffer + old_written + 1;\n   ident_length = CPP_PWRITTEN (pfile) - ident;\n   if (ident_length == 0)\n@@ -588,7 +209,7 @@ handle_directive (pfile)\n     {\n       cpp_error (pfile, \"`#%s' may not be used inside a macro argument\",\n \t\t kt->name);\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n     }\n   else\n     (*kt->func) (pfile, kt);\n@@ -629,7 +250,7 @@ get_macro_name (pfile)\n \n   here = CPP_WRITTEN (pfile);\n   pfile->no_macro_expand++;\n-  if (get_directive_token (pfile) != CPP_NAME)\n+  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n     {\n       cpp_error (pfile, \"`#define' must be followed by an identifier\");\n       goto invalid;\n@@ -646,7 +267,7 @@ get_macro_name (pfile)\n   return len;\n \n  invalid:\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   pfile->no_macro_expand--;\n   return 0;\n }\n@@ -748,222 +369,48 @@ do_define (pfile, keyword)\n   return 0;\n }\n \n+/*\n+ * write out a #line command, for instance, after an #include file.\n+ * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n+ */\n \n-/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n-   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n-   as the new input buffer.\n-   Return the new buffer, or NULL on failure.  */\n-\n-cpp_buffer *\n-cpp_push_buffer (pfile, buffer, length)\n+void\n+_cpp_output_line_command (pfile, file_change)\n      cpp_reader *pfile;\n-     const U_CHAR *buffer;\n-     long length;\n+     enum file_change_code file_change;\n {\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n-  cpp_buffer *new;\n-  if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n-    {\n-      cpp_fatal (pfile, \"macro or `#include' recursion too deep\");\n-      return NULL;\n-    }\n-\n-  new = (cpp_buffer *) xcalloc (1, sizeof (cpp_buffer));\n-\n-  new->if_stack = pfile->if_stack;\n-  new->cleanup = null_cleanup;\n-  new->buf = new->cur = buffer;\n-  new->alimit = new->rlimit = buffer + length;\n-  new->prev = buf;\n-  new->mark = -1;\n-  new->line_base = NULL;\n-\n-  CPP_BUFFER (pfile) = new;\n-  return new;\n-}\n+  long line;\n+  cpp_buffer *ip;\n \n-cpp_buffer *\n-cpp_pop_buffer (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n-  if (ACTIVE_MARK_P())\n-    cpp_ice (pfile, \"mark active in cpp_pop_buffer\");\n-  (*buf->cleanup) (buf, pfile);\n-  CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n-  free (buf);\n-  pfile->buffer_stack_depth--;\n-  return CPP_BUFFER (pfile);\n-}\n+  if (CPP_OPTIONS (pfile)->no_line_commands\n+      || CPP_OPTIONS (pfile)->no_output)\n+    return;\n \n-/* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.\n-   Pop the buffer when done.  */\n+  ip = cpp_file_buffer (pfile);\n+  cpp_buf_line_and_col (ip, &line, NULL);\n \n-void\n-cpp_scan_buffer (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *buffer = CPP_BUFFER (pfile);\n-  enum cpp_token token;\n-  if (CPP_OPTIONS (pfile)->no_output)\n+  /* If the current file has not changed, we omit the #line if it would\n+     appear to be a no-op, and we output a few newlines instead\n+     if we want to increase the line number by a small amount.\n+     We cannot do this if pfile->lineno is zero, because that means we\n+     haven't output any line commands yet.  (The very first line command\n+     output is a `same_file' command.)  */\n+  if (file_change == same_file && pfile->lineno != 0)\n     {\n-      long old_written = CPP_WRITTEN (pfile);\n-      /* In no-output mode, we can ignore everything but directives.  */\n-      for (;;)\n+      if (line == pfile->lineno)\n+\treturn;\n+\n+      /* If the inherited line number is a little too small,\n+\t output some newlines instead of a #line command.  */\n+      if (line > pfile->lineno && line < pfile->lineno + 8)\n \t{\n-\t  if (! pfile->only_seen_white)\n-\t    skip_rest_of_line (pfile);\n-\t  token = cpp_get_token (pfile);\n-\t  if (token == CPP_EOF) /* Should not happen ...  */\n-\t    break;\n-\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t  CPP_RESERVE (pfile, 20);\n+\t  while (line > pfile->lineno)\n \t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n-\t\tcpp_pop_buffer (pfile);\n-\t      break;\n+\t      CPP_PUTC_Q (pfile, '\\n');\n+\t      pfile->lineno++;\n \t    }\n-\t}\n-      CPP_SET_WRITTEN (pfile, old_written);\n-    }\n-  else\n-    {\n-      for (;;)\n-\t{\n-\t  token = cpp_get_token (pfile);\n-\t  if (token == CPP_EOF) /* Should not happen ...  */\n-\t    break;\n-\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n-\t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n-\t\tcpp_pop_buffer (pfile);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/*\n- * Rescan a string (which may have escape marks) into pfile's buffer.\n- * Place the result in pfile->token_buffer.\n- *\n- * The input is copied before it is scanned, so it is safe to pass\n- * it something from the token_buffer that will get overwritten\n- * (because it follows CPP_WRITTEN).  This is used by do_include.\n- */\n-\n-void\n-cpp_expand_to_buffer (pfile, buf, length)\n-     cpp_reader *pfile;\n-     const U_CHAR *buf;\n-     int length;\n-{\n-  register cpp_buffer *ip;\n-  U_CHAR *buf1;\n-  int save_no_output;\n-\n-  if (length < 0)\n-    {\n-      cpp_ice (pfile, \"length < 0 in cpp_expand_to_buffer\");\n-      return;\n-    }\n-\n-  /* Set up the input on the input stack.  */\n-\n-  buf1 = (U_CHAR *) alloca (length + 1);\n-  memcpy (buf1, buf, length);\n-  buf1[length] = 0;\n-\n-  ip = cpp_push_buffer (pfile, buf1, length);\n-  if (ip == NULL)\n-    return;\n-  ip->has_escapes = 1;\n-\n-  /* Scan the input, create the output.  */\n-  save_no_output = CPP_OPTIONS (pfile)->no_output;\n-  CPP_OPTIONS (pfile)->no_output = 0;\n-  CPP_OPTIONS (pfile)->no_line_commands++;\n-  cpp_scan_buffer (pfile);\n-  CPP_OPTIONS (pfile)->no_line_commands--;\n-  CPP_OPTIONS (pfile)->no_output = save_no_output;\n-\n-  CPP_NUL_TERMINATE (pfile);\n-}\n-\n-void\n-cpp_buf_line_and_col (pbuf, linep, colp)\n-     register cpp_buffer *pbuf;\n-     long *linep, *colp;\n-{\n-  if (pbuf)\n-    {\n-      *linep = pbuf->lineno;\n-      if (colp)\n-\t*colp = pbuf->cur - pbuf->line_base;\n-    }\n-  else\n-    {\n-      *linep = 0;\n-      if (colp)\n-\t*colp = 0;\n-    }\n-}\n-\n-/* Return the cpp_buffer that corresponds to a file (not a macro).  */\n-\n-cpp_buffer *\n-cpp_file_buffer (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip;\n-\n-  for (ip = CPP_BUFFER (pfile); ip; ip = CPP_PREV_BUFFER (ip))\n-    if (ip->ihash != NULL)\n-      return ip;\n-  return NULL;\n-}\n-\n-/*\n- * write out a #line command, for instance, after an #include file.\n- * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n- */\n-\n-void\n-output_line_command (pfile, file_change)\n-     cpp_reader *pfile;\n-     enum file_change_code file_change;\n-{\n-  long line;\n-  cpp_buffer *ip;\n-\n-  if (CPP_OPTIONS (pfile)->no_line_commands\n-      || CPP_OPTIONS (pfile)->no_output)\n-    return;\n-\n-  ip = cpp_file_buffer (pfile);\n-  cpp_buf_line_and_col (ip, &line, NULL);\n-\n-  /* If the current file has not changed, we omit the #line if it would\n-     appear to be a no-op, and we output a few newlines instead\n-     if we want to increase the line number by a small amount.\n-     We cannot do this if pfile->lineno is zero, because that means we\n-     haven't output any line commands yet.  (The very first line command\n-     output is a `same_file' command.)  */\n-  if (file_change == same_file && pfile->lineno != 0)\n-    {\n-      if (line == pfile->lineno)\n-\treturn;\n-\n-      /* If the inherited line number is a little too small,\n-\t output some newlines instead of a #line command.  */\n-      if (line > pfile->lineno && line < pfile->lineno + 8)\n-\t{\n-\t  CPP_RESERVE (pfile, 20);\n-\t  while (line > pfile->lineno)\n-\t    {\n-\t      CPP_PUTC_Q (pfile, '\\n');\n-\t      pfile->lineno++;\n-\t    }\n-\t  return;\n+\t  return;\n \t}\n     }\n \n@@ -973,7 +420,7 @@ output_line_command (pfile, file_change)\n   sprintf ((char *) CPP_PWRITTEN (pfile), \"%ld \", line);\n   CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n \n-  quote_string (pfile, ip->nominal_fname); \n+  _cpp_quote_string (pfile, ip->nominal_fname); \n   if (file_change != same_file && file_change != rename_file)\n     {\n       CPP_PUTC_Q (pfile, ' ');\n@@ -997,61 +444,7 @@ output_line_command (pfile, file_change)\n   pfile->lineno = line;\n }\n \n-\n-/* Like cpp_get_token, except that it does not read past end-of-line.\n-   Also, horizontal space is skipped, and macros are popped.  */\n-\n-enum cpp_token\n-get_directive_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  long old_written = CPP_WRITTEN (pfile);\n-  enum cpp_token token;\n-\n-  for (;;)\n-    {\n-      cpp_skip_hspace (pfile);\n-      if (PEEKC () == '\\n')\n-\treturn CPP_VSPACE;\n-\n-      token = cpp_get_token (pfile);\n-      /* token could be hspace at the beginning of a macro.  */\n-      if (token == CPP_HSPACE || token == CPP_COMMENT)\n-\t{\n-\t  CPP_SET_WRITTEN (pfile, old_written);\n-\t  continue;\n-\t}\n-\n-      /* token cannot be vspace, it would have been caught above.  */\n-      if (token == CPP_VSPACE)\n-\t{\n-\t  cpp_ice (pfile, \"VSPACE in get_directive_token\");\n-\t  return token;\n-\t}\n-\n-      /* token cannot be POP unless the buffer is a macro buffer.  */\n-      if (token != CPP_POP)\n-\treturn token;\n-\n-      if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t{\n-\t  cpp_ice (pfile, \"POP of file buffer in get_directive_token\");\n-\t  return token;\n-\t}\n-\n-      /* We must pop the buffer by hand, or else cpp_get_token might\n-\t hand us white space or newline on the next invocation.  */\n-      cpp_pop_buffer (pfile);\n-    }\n-}\n-\f\n-/* Handle #include and #import.\n-   This function expects to see \"fname\" or <fname> on the input.\n-\n-   The input is normally in part of the output_buffer following\n-   CPP_WRITTEN, and will get overwritten by output_line_command.\n-   I.e. in input file specification has been popped by handle_directive.\n-   This is safe.  */\n+/* Handle #include and #import.  */\n \n static int\n do_include (pfile, keyword)\n@@ -1094,7 +487,7 @@ do_include (pfile, keyword)\n     }\n \n   pfile->parsing_include_directive++;\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   pfile->parsing_include_directive--;\n \n   if (token == CPP_STRING)\n@@ -1120,7 +513,7 @@ do_include (pfile, keyword)\n       cpp_error (pfile,\n \t\t \"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", keyword->name);\n       CPP_SET_WRITTEN (pfile, old_written);\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n       return 0;\n     }\n \n@@ -1129,10 +522,10 @@ do_include (pfile, keyword)\n   memcpy (ftok, pfile->token_buffer + old_written, flen);\n   ftok[flen] = '\\0';\n \n-  if (get_directive_token (pfile) != CPP_VSPACE)\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of `#include'\");\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n     }\n \n   CPP_SET_WRITTEN (pfile, old_written);\n@@ -1270,7 +663,7 @@ do_include (pfile, keyword)\n   \n   if (_cpp_read_include_file (pfile, fd, ihash))\n     {\n-      output_line_command (pfile, enter_file);\n+      _cpp_output_line_command (pfile, enter_file);\n       if (angle_brackets)\n \tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n     }\n@@ -1288,9 +681,10 @@ read_line_number (pfile, num)\n      int *num;\n {\n   long save_written = CPP_WRITTEN (pfile);\n-  U_CHAR *p = pfile->token_buffer + save_written;\n-  enum cpp_token token = get_directive_token (pfile);\n+  U_CHAR *p;\n+  enum cpp_token token = _cpp_get_directive_token (pfile);\n   CPP_SET_WRITTEN (pfile, save_written);\n+  p = pfile->token_buffer + save_written;\n \n   if (token == CPP_NUMBER && *p >= '1' && *p <= '4' && p[1] == '\\0')\n     {\n@@ -1321,7 +715,7 @@ do_line (pfile, keyword)\n   enum cpp_token token;\n   char *x;\n \n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n \n   if (token != CPP_NUMBER)\n     {\n@@ -1340,7 +734,7 @@ do_line (pfile, keyword)\n   if (CPP_PEDANTIC (pfile) && (new_lineno <= 0 || new_lineno > 32767))\n     cpp_pedwarn (pfile, \"line number out of range in `#line' command\");\n \n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n \n   if (token == CPP_STRING)\n     {\n@@ -1416,11 +810,11 @@ do_line (pfile, keyword)\n      we must store a line number now that is one less.  */\n   ip->lineno = new_lineno - 1;\n   CPP_SET_WRITTEN (pfile, old_written);\n-  output_line_command (pfile, file_change);\n+  _cpp_output_line_command (pfile, file_change);\n   return 0;\n \n  bad_line_directive:\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);\n   return 0;\n }\n@@ -1440,16 +834,16 @@ do_undef (pfile, keyword)\n   long here = CPP_WRITTEN (pfile);\n   enum cpp_token token;\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   c = GETC();\n   if (! is_idstart(c))\n   {\n       cpp_error (pfile, \"token after #undef is not an identifier\");\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n       return 1;\n   }\n \n-  parse_name (pfile, c);\n+  _cpp_parse_name (pfile, c);\n   buf = pfile->token_buffer + here;\n   limit = CPP_PWRITTEN(pfile);\n \n@@ -1459,11 +853,11 @@ do_undef (pfile, keyword)\n   memcpy (name, buf, len);\n   name[len] = '\\0';\n \n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token != CPP_VSPACE)\n   {\n       cpp_pedwarn (pfile, \"junk on line after #undef\");\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n   }\n   CPP_SET_WRITTEN (pfile, here);\n \n@@ -1489,25 +883,6 @@ do_undef (pfile, keyword)\n   return 0;\n }\n \n-/* Wrap do_undef for -U processing. */\n-void\n-cpp_undef (pfile, macro)\n-     cpp_reader *pfile;\n-     const char *macro;\n-{\n-  /* Copy the string so we can append a newline.  */\n-  size_t len = strlen (macro);\n-  char *buf = alloca (len + 2);\n-  memcpy (buf, macro, len);\n-  buf[len]     = '\\n';\n-  buf[len + 1] = '\\0';\n-  if (cpp_push_buffer (pfile, buf, len + 1))\n-    {\n-      do_undef (pfile, NULL);\n-      cpp_pop_buffer (pfile);\n-    }\n-}\n-\n /*\n  * Report an error detected by the program we are processing.\n  * Use the text of the line in the error message.\n@@ -1521,9 +896,9 @@ do_error (pfile, keyword)\n {\n   const U_CHAR *text, *limit;\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   text = CPP_BUFFER (pfile)->cur;\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   limit = CPP_BUFFER (pfile)->cur;\n \n   cpp_error (pfile, \"#error %.*s\", (int)(limit - text), text);\n@@ -1542,9 +917,9 @@ do_warning (pfile, keyword)\n {\n   const U_CHAR *text, *limit;\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   text = CPP_BUFFER (pfile)->cur;\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   limit = CPP_BUFFER (pfile)->cur;\n \n   if (CPP_PEDANTIC (pfile))\n@@ -1570,14 +945,14 @@ do_ident (pfile, keyword)\n   CPP_PUTS (pfile, \"#ident \", 7);\n \n   /* Next token should be a string constant.  */\n-  if (get_directive_token (pfile) == CPP_STRING)\n+  if (_cpp_get_directive_token (pfile) == CPP_STRING)\n     /* And then a newline.  */\n-    if (get_directive_token (pfile) == CPP_VSPACE)\n+    if (_cpp_get_directive_token (pfile) == CPP_VSPACE)\n       /* Good - ship it.  */\n       return 0;\n \n   cpp_error (pfile, \"invalid #ident\");\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);  /* discard directive */\n \n   return 0;\n@@ -1616,7 +991,7 @@ do_pragma (pfile, keyword)\n \n   key = CPP_WRITTEN (pfile);\n   pfile->no_macro_expand++;\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token != CPP_NAME)\n     {\n       if (token == CPP_VSPACE)\n@@ -1639,7 +1014,7 @@ do_pragma (pfile, keyword)\n     pop = do_pragma_default (pfile);\n #undef tokis\n \n-  if (get_directive_token (pfile) != CPP_VSPACE)\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     goto skip;\n \n   if (pop)\n@@ -1649,7 +1024,7 @@ do_pragma (pfile, keyword)\n \n  skip:\n   cpp_error (pfile, \"malformed #pragma directive\");\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n  empty:\n   CPP_SET_WRITTEN (pfile, here);\n   pfile->no_macro_expand--;\n@@ -1660,7 +1035,7 @@ static int\n do_pragma_default (pfile)\n      cpp_reader *pfile;\n {\n-  while (get_directive_token (pfile) != CPP_VSPACE)\n+  while (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     CPP_PUTC (pfile, ' ');\n   return 0;\n }\n@@ -1696,7 +1071,7 @@ do_pragma_implementation (pfile)\n   U_CHAR *copy;\n   size_t len;\n \n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   if (token == CPP_VSPACE)\n     return 0;\n   else if (token != CPP_STRING)\n@@ -1742,13 +1117,13 @@ do_pragma_poison (pfile)\n   for (;;)\n     {\n       written = CPP_WRITTEN (pfile);\n-      token = get_directive_token (pfile);\n+      token = _cpp_get_directive_token (pfile);\n       if (token == CPP_VSPACE)\n \tbreak;\n       if (token != CPP_NAME)\n \t{\n \t  cpp_error (pfile, \"invalid #pragma poison directive\");\n-\t  skip_rest_of_line (pfile);\n+\t  _cpp_skip_rest_of_line (pfile);\n \t  return 1;\n \t}\n \n@@ -1789,7 +1164,7 @@ do_sccs (pfile, keyword)\n {\n   if (CPP_PEDANTIC (pfile))\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#sccs'\");\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   return 0;\n }\n #endif\n@@ -1817,18 +1192,18 @@ detect_if_not_defined (pfile)\n \n       /* Save state required for restore.  */\n       pfile->no_macro_expand++;\n-      parse_set_mark (pfile);\n+      CPP_SET_MARK (pfile);\n       base_offset = CPP_WRITTEN (pfile);\n \n       /* Look for `!', */\n-      if (get_directive_token (pfile) != CPP_OTHER\n+      if (_cpp_get_directive_token (pfile) != CPP_OTHER\n \t  || CPP_WRITTEN (pfile) != (size_t) base_offset + 1\n \t  || CPP_PWRITTEN (pfile)[-1] != '!')\n \tgoto restore;\n \n       /* ...then `defined', */\n       token_offset = CPP_WRITTEN (pfile);\n-      token = get_directive_token (pfile);\n+      token = _cpp_get_directive_token (pfile);\n       if (token != CPP_NAME)\n \tgoto restore;\n       ident = pfile->token_buffer + token_offset;\n@@ -1838,11 +1213,11 @@ detect_if_not_defined (pfile)\n \n       /* ...then an optional '(' and the name, */\n       token_offset = CPP_WRITTEN (pfile);\n-      token = get_directive_token (pfile);\n+      token = _cpp_get_directive_token (pfile);\n       if (token == CPP_LPAREN)\n \t{\n \t  token_offset = CPP_WRITTEN (pfile);\n-\t  token = get_directive_token (pfile);\n+\t  token = _cpp_get_directive_token (pfile);\n \t  if (token != CPP_NAME)\n \t    goto restore;\n \t  need_rparen = 1;\n@@ -1854,22 +1229,22 @@ detect_if_not_defined (pfile)\n       CPP_NUL_TERMINATE (pfile);\n \n       /* ...then the ')', if necessary, */\n-      if ((!need_rparen || get_directive_token (pfile) == CPP_RPAREN)\n+      if ((!need_rparen || _cpp_get_directive_token (pfile) == CPP_RPAREN)\n \t  /* ...and make sure there's nothing else on the line.  */\n-\t  && get_directive_token (pfile) == CPP_VSPACE)\n+\t  && _cpp_get_directive_token (pfile) == CPP_VSPACE)\n \tcontrol_macro = (U_CHAR *) xstrdup (ident);\n \n     restore:\n       CPP_SET_WRITTEN (pfile, base_offset);\n       pfile->no_macro_expand--;\n-      parse_goto_mark (pfile);\n+      CPP_GOTO_MARK (pfile);\n     }\n \n   return control_macro;\n }\n \n /*\n- * #if is straightforward; just call eval_if_expr, then conditional_skip.\n+ * #if is straightforward; just call _cpp_parse_expr, then conditional_skip.\n  * Also, check for a reinclude preventer of the form #if !defined (MACRO).\n  */\n \n@@ -1879,7 +1254,7 @@ do_if (pfile, keyword)\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *control_macro = detect_if_not_defined (pfile);\n-  int value = eval_if_expr (pfile);\n+  int value = _cpp_parse_expr (pfile);\n   conditional_skip (pfile, value == 0, T_IF, control_macro);\n   return 0;\n }\n@@ -1914,39 +1289,17 @@ do_elif (pfile, keyword)\n     skip_if_group (pfile);\n   else\n     {\n-      int value = eval_if_expr (pfile);\n-      if (value == 0)\n+      if (_cpp_parse_expr (pfile) == 0)\n \tskip_if_group (pfile);\n       else\n \t{\n \t  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n-\t  output_line_command (pfile, same_file);\n+\t  _cpp_output_line_command (pfile, same_file);\n \t}\n     }\n   return 0;\n }\n \n-/* Thin wrapper around _cpp_parse_expr, which doesn't have access to\n- * skip_rest_of_line.  Also centralizes toggling parsing_if_directive.\n- */\n-\n-static int\n-eval_if_expr (pfile)\n-     cpp_reader *pfile;\n-{\n-  int value;\n-  long old_written = CPP_WRITTEN (pfile);\n-\n-  pfile->parsing_if_directive++;\n-  value = _cpp_parse_expr (pfile);\n-  pfile->parsing_if_directive--;\n-\n-  skip_rest_of_line (pfile);\n-  CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n-\n-  return value;\n-}\n-\n /*\n  * routine to handle ifdef/ifndef.  Try to look up the symbol,\n  * then do or don't skip to the #endif/#else/#elif depending\n@@ -1971,7 +1324,7 @@ do_ifdef (pfile, keyword)\n     start_of_file = pfile->only_seen_white == 2;\n \n   pfile->no_macro_expand++;\n-  token = get_directive_token (pfile);\n+  token = _cpp_get_directive_token (pfile);\n   pfile->no_macro_expand--;\n \n   ident = pfile->token_buffer + old_written;\n@@ -2005,12 +1358,12 @@ do_ifdef (pfile, keyword)\n \n   if (!CPP_TRADITIONAL (pfile))\n     { int c;\n-      cpp_skip_hspace (pfile);\n+      _cpp_skip_hspace (pfile);\n       c = PEEKC ();\n       if (c != EOF && c != '\\n')\n \tcpp_pedwarn (pfile, \"garbage at end of `#%s' argument\", keyword->name);\n     }\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n \n   conditional_skip (pfile, skip, T_IF, control_macro);\n   return 0;\n@@ -2043,7 +1396,7 @@ conditional_skip (pfile, skip, type, control_macro)\n     return;\n   } else {\n     ++pfile->if_stack->if_succeeded;\n-    output_line_command (pfile, same_file);\n+    _cpp_output_line_command (pfile, same_file);\n   }\n }\n \n@@ -2061,10 +1414,10 @@ consider_directive_while_skipping (pfile, stack)\n   const struct directive *kt;\n   IF_STACK *temp;\n     \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n \n   ident = CPP_WRITTEN (pfile);\n-  parse_name (pfile, GETC());\n+  _cpp_parse_name (pfile, GETC());\n   ident_len = CPP_WRITTEN (pfile) - ident;\n \n   CPP_SET_WRITTEN (pfile, ident);\n@@ -2137,7 +1490,7 @@ skip_if_group (pfile)\n       beg_of_line = CPP_BUFFER (pfile)->cur;\n \n       if (! CPP_TRADITIONAL (pfile))\n-\tcpp_skip_hspace (pfile);\n+\t_cpp_skip_hspace (pfile);\n       c = GETC();\n       if (c == '\\n')\n \t{\n@@ -2153,7 +1506,7 @@ skip_if_group (pfile)\n \treturn;\t /* Caller will issue error. */\n \n       FORWARD(-1);\n-      skip_rest_of_line (pfile);\n+      _cpp_skip_rest_of_line (pfile);\n \n       c = GETC();\n       if (c == EOF)\n@@ -2181,7 +1534,7 @@ do_else (pfile, keyword)\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   validate_else (pfile, \"#else\");\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n     {\n@@ -2208,7 +1561,7 @@ do_else (pfile, keyword)\n   else\n     {\n       ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n-      output_line_command (pfile, same_file);\n+      _cpp_output_line_command (pfile, same_file);\n     }\n   return 0;\n }\n@@ -2223,7 +1576,7 @@ do_endif (pfile, keyword)\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   validate_else (pfile, \"#endif\");\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n     cpp_error (pfile, \"`#endif' not within a conditional\");\n@@ -2237,16 +1590,16 @@ do_endif (pfile, keyword)\n \t     See if it is at the end of the file.  */\n \t  int c;\n \n-\t  parse_set_mark (pfile);\n+\t  CPP_SET_MARK (pfile);\n \n \t  for (;;)\n \t    {\n-\t      cpp_skip_hspace (pfile);\n+\t      _cpp_skip_hspace (pfile);\n \t      c = GETC ();\n \t      if (c != '\\n')\n \t\tbreak;\n \t    }\n-\t  parse_goto_mark (pfile);\n+\t  CPP_GOTO_MARK (pfile);\n \n \t  if (c == EOF)\n \t    {\n@@ -2258,7 +1611,7 @@ do_endif (pfile, keyword)\n \t    }\n         }\n       free (temp);\n-      output_line_command (pfile, same_file);\n+      _cpp_output_line_command (pfile, same_file);\n     }\n   return 0;\n }\n@@ -2275,7 +1628,7 @@ validate_else (pfile, directive)\n   if (! CPP_PEDANTIC (pfile))\n     return;\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   if (PEEKC () != '\\n')\n     cpp_pedwarn (pfile,\n \t\t \"text following `%s' violates ANSI standard\", directive);\n@@ -2300,734 +1653,40 @@ if_directive_name (pfile, ifs)\n     }\n }\n \n-/* Get the next token, and add it to the text in pfile->token_buffer.\n-   Return the kind of token we got.  */\n-\n-enum cpp_token\n-cpp_get_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  register int c, c2, c3;\n-  enum cpp_token token;\n-  struct cpp_options *opts = CPP_OPTIONS (pfile);\n-\n- get_next:\n-  c = GETC();\n-  if (c == EOF)\n-    {\n-      if (CPP_BUFFER (pfile)->manual_pop)\n-\t/* If we've been reading from redirected input, the\n-\t   frontend will pop the buffer.  */\n-\treturn CPP_EOF;\n-      else if (CPP_BUFFER (pfile)->seen_eof)\n-\t{\n-\t  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) == NULL)\n-\t    return CPP_EOF;\n-\n-\t  cpp_pop_buffer (pfile);\n-\t  goto get_next;\n-\t}\n-      else\n-\t{\n-\t  cpp_buffer *next_buf = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-\t  struct if_stack *ifs, *nifs;\n-\n-\t  /* Unwind the conditional stack and generate error messages.  */\n-\t  for (ifs = pfile->if_stack;\n-\t       ifs != CPP_BUFFER (pfile)->if_stack;\n-\t       ifs = nifs)\n-\t    {\n-\t      cpp_error_with_line (pfile, ifs->lineno, -1,\n-\t\t\t\t   \"unterminated `%s' conditional\",\n-\t\t\t\t   if_directive_name (pfile, ifs));\n-\n-\t      nifs = ifs->next;\n-\t      free (ifs);\n-\t    }\n-\t  pfile->if_stack = ifs;\n-\n-\t  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != NULL)\n-\t    {\n-\t      /* We're about to return from an #include file.\n-\t\t Emit #line information now (as part of the CPP_POP) result.\n-\t\t But the #line refers to the file we will pop to.  */\n-\t      cpp_buffer *cur_buffer = CPP_BUFFER (pfile);\n-\t      CPP_BUFFER (pfile) = next_buf;\n-\t      pfile->input_stack_listing_current = 0;\n-\t      output_line_command (pfile, leave_file);\n-\t      CPP_BUFFER (pfile) = cur_buffer;\n-\t    }\n-\n-\t  CPP_BUFFER (pfile)->seen_eof = 1;\n-\t  return CPP_POP;\n-\t}\n-    }\n-  else\n-    {\n-      switch (c)\n-\t{\n-\tcase '/':\n-\t  if (PEEKC () == '=')\n-\t    goto op2;\n-\n-\tcomment:\n-\t  if (opts->discard_comments)\n-\t    c = skip_comment (pfile, c);\n-\t  else\n-\t    c = copy_comment (pfile, c);\n-\t  if (c != ' ')\n-\t    goto randomchar;\n-\t  \n-\t  /* Comments are equivalent to spaces.\n-\t     For -traditional, a comment is equivalent to nothing.  */\n-\t  if (opts->traditional || !opts->discard_comments)\n-\t    return CPP_COMMENT;\n-\t  else\n-\t    {\n-\t      CPP_PUTC (pfile, c);\n-\t      return CPP_HSPACE;\n-\t    }\n-\n-\tcase '#':\n-\t  if (pfile->parsing_if_directive)\n-\t    {\n-\t      cpp_skip_hspace (pfile);\n-\t      parse_assertion (pfile);\n-\t      return CPP_ASSERTION;\n-\t    }\n-\n-\t  if (pfile->parsing_define_directive && ! CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      CPP_RESERVE (pfile, 3);\n-\t      CPP_PUTC_Q (pfile, '#');\n-\t      CPP_NUL_TERMINATE_Q (pfile);\n-\t      if (PEEKC () != '#')\n-\t\treturn CPP_STRINGIZE;\n-\t      \n-\t      FORWARD (1);\n-\t      CPP_PUTC_Q (pfile, '#');\n-\t      CPP_NUL_TERMINATE_Q (pfile);\n-\t      return CPP_TOKPASTE;\n-\t    }\n-\n-\t  if (!pfile->only_seen_white)\n-\t    goto randomchar;\n-\t  /* -traditional directives are recognized only with the # in\n-\t     column 1.\n-\t     XXX Layering violation.  */\n-\t  if (CPP_TRADITIONAL (pfile)\n-\t      && CPP_BUFFER (pfile)->cur - CPP_BUFFER (pfile)->line_base != 1)\n-\t    goto randomchar;\n-\t  if (handle_directive (pfile))\n-\t    return CPP_DIRECTIVE;\n-\t  pfile->only_seen_white = 0;\n-\t  goto randomchar;\n-\n-\tcase '\\\"':\n-\tcase '\\'':\n-\t  parse_string (pfile, c);\n-\t  pfile->only_seen_white = 0;\n-\t  return c == '\\'' ? CPP_CHAR : CPP_STRING;\n-\n-\tcase '$':\n-\t  if (!opts->dollars_in_ident)\n-\t    goto randomchar;\n-\t  goto letter;\n-\n-\tcase ':':\n-\t  if (opts->cplusplus && PEEKC () == ':')\n-\t    goto op2;\n-\t  goto randomchar;\n-\n-\tcase '&':\n-\tcase '+':\n-\tcase '|':\n-\t  c2 = PEEKC ();\n-\t  if (c2 == c || c2 == '=')\n-\t    goto op2;\n-\t  goto randomchar;\n-\n-\tcase '*':\n-\tcase '!':\n-\tcase '%':\n-\tcase '=':\n-\tcase '^':\n-\t  if (PEEKC () == '=')\n-\t    goto op2;\n-\t  goto randomchar;\n-\n-\tcase '-':\n-\t  c2 = PEEKC ();\n-\t  if (c2 == '-' && opts->chill)\n-\t    goto comment;  /* Chill style comment */\n-\t  if (c2 == '-' || c2 == '=')\n-\t    goto op2;\n-\t  if (c2 == '>')\n-\t    {\n-\t      if (opts->cplusplus && PEEKN (1) == '*')\n-\t\t{\n-\t\t  /* In C++, there's a ->* operator.  */\n-\t\t  token = CPP_OTHER;\n-\t\t  pfile->only_seen_white = 0;\n-\t\t  CPP_RESERVE (pfile, 4);\n-\t\t  CPP_PUTC_Q (pfile, c);\n-\t\t  CPP_PUTC_Q (pfile, GETC ());\n-\t\t  CPP_PUTC_Q (pfile, GETC ());\n-\t\t  CPP_NUL_TERMINATE_Q (pfile);\n-\t\t  return token;\n-\t\t}\n-\t      goto op2;\n-\t    }\n-\t  goto randomchar;\n-\n-\tcase '<':\n-\t  if (pfile->parsing_include_directive)\n-\t    {\n-\t      for (;;)\n-\t\t{\n-\t\t  CPP_PUTC (pfile, c);\n-\t\t  if (c == '>')\n-\t\t    break;\n-\t\t  c = GETC ();\n-\t\t  if (c == '\\n' || c == EOF)\n-\t\t    {\n-\t\t      cpp_error (pfile,\n-\t\t\t\t \"missing '>' in `#include <FILENAME>'\");\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (c == '\\r')\n-\t\t    {\n-\t\t      if (!CPP_BUFFER (pfile)->has_escapes)\n-\t\t\t{\n-\t\t\t  /* Backslash newline is replaced by nothing. */\n-\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t\t\t  CPP_BUMP_LINE (pfile);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* We might conceivably get \\r- or \\r<space> in\n-\t\t\t     here.  Just delete 'em. */\n-\t\t\t  int d = GETC();\n-\t\t\t  if (d != '-' && d != ' ')\n-\t\t\t    cpp_ice (pfile, \"unrecognized escape \\\\r%c\", d);\n-\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t\t\t}\t\t\t  \n-\t\t    }\n-\t\t}\n-\t      return CPP_STRING;\n-\t    }\n-\t  /* else fall through */\n-\tcase '>':\n-\t  c2 = PEEKC ();\n-\t  if (c2 == '=')\n-\t    goto op2;\n-\t  /* GNU C++ supports MIN and MAX operators <? and >?.  */\n-\t  if (c2 != c && (!opts->cplusplus || c2 != '?'))\n-\t    goto randomchar;\n-\t  FORWARD(1);\n-\t  CPP_RESERVE (pfile, 4);\n-\t  CPP_PUTC (pfile, c);\n-\t  CPP_PUTC (pfile, c2);\n-\t  c3 = PEEKC ();\n-\t  if (c3 == '=')\n-\t    CPP_PUTC_Q (pfile, GETC ());\n-\t  CPP_NUL_TERMINATE_Q (pfile);\n-\t  pfile->only_seen_white = 0;\n-\t  return CPP_OTHER;\n-\n-\tcase '.':\n-\t  c2 = PEEKC ();\n-\t  if (ISDIGIT(c2))\n-\t    {\n-\t      CPP_RESERVE(pfile, 2);\n-\t      CPP_PUTC_Q (pfile, '.');\n-\t      c = GETC ();\n-\t      goto number;\n-\t    }\n-\n-\t  /* In C++ there's a .* operator.  */\n-\t  if (opts->cplusplus && c2 == '*')\n-\t    goto op2;\n-\n-\t  if (c2 == '.' && PEEKN(1) == '.')\n-\t    {\n-\t      CPP_RESERVE(pfile, 4);\n-\t      CPP_PUTC_Q (pfile, '.');\n-\t      CPP_PUTC_Q (pfile, '.');\n-\t      CPP_PUTC_Q (pfile, '.');\n-\t      FORWARD (2);\n-\t      CPP_NUL_TERMINATE_Q (pfile);\n-\t      pfile->only_seen_white = 0;\n-\t      return CPP_3DOTS;\n-\t    }\n-\t  goto randomchar;\n-\n-\top2:\n-\t  token = CPP_OTHER;\n-\t  pfile->only_seen_white = 0;\n-\t  CPP_RESERVE(pfile, 3);\n-\t  CPP_PUTC_Q (pfile, c);\n-\t  CPP_PUTC_Q (pfile, GETC ());\n-\t  CPP_NUL_TERMINATE_Q (pfile);\n-\t  return token;\n-\n-\tcase 'L':\n-\t  c2 = PEEKC ();\n-\t  if ((c2 == '\\'' || c2 == '\\\"') && !CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      CPP_PUTC (pfile, c);\n-\t      c = GETC ();\n-\t      parse_string (pfile, c);\n-\t      pfile->only_seen_white = 0;\n-\t      return c == '\\'' ? CPP_WCHAR : CPP_WSTRING;\n-\t    }\n-\t  goto letter;\n-\n-\tcase '0': case '1': case '2': case '3': case '4':\n-\tcase '5': case '6': case '7': case '8': case '9':\n-\tnumber:\n-\t  c2  = '.';\n-\t  for (;;)\n-\t    {\n-\t      CPP_RESERVE (pfile, 2);\n-\t      CPP_PUTC_Q (pfile, c);\n-\t      c = PEEKC ();\n-\t      if (c == EOF)\n-\t\tbreak;\n-\t      if (!is_numchar(c) && c != '.'\n-\t\t  && ((c2 != 'e' && c2 != 'E'\n-\t\t       && ((c2 != 'p' && c2 != 'P')\n-\t\t\t   || CPP_OPTIONS (pfile)->c89))\n-\t\t      || (c != '+' && c != '-')))\n-\t\tbreak;\n-\t      FORWARD(1);\n-\t      c2= c;\n-\t    }\n-\t  CPP_NUL_TERMINATE_Q (pfile);\n-\t  pfile->only_seen_white = 0;\n-\t  return CPP_NUMBER;\n-\tcase 'b': case 'c': case 'd': case 'h': case 'o':\n-\tcase 'B': case 'C': case 'D': case 'H': case 'O':\n-\t  if (opts->chill && PEEKC () == '\\'')\n-\t    {\n-\t      pfile->only_seen_white = 0;\n-\t      CPP_RESERVE (pfile, 2);\n-\t      CPP_PUTC_Q (pfile, c);\n-\t      CPP_PUTC_Q (pfile, '\\'');\n-\t      FORWARD(1);\n-\t      for (;;)\n-\t\t{\n-\t\t  c = GETC();\n-\t\t  if (c == EOF)\n-\t\t    goto chill_number_eof;\n-\t\t  if (!is_numchar(c))\n-\t\t    break;\n-\t\t  CPP_PUTC (pfile, c);\n-\t\t}\n-\t      if (c == '\\'')\n-\t\t{\n-\t\t  CPP_RESERVE (pfile, 2);\n-\t\t  CPP_PUTC_Q (pfile, c);\n-\t\t  CPP_NUL_TERMINATE_Q (pfile);\n-\t\t  return CPP_STRING;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  FORWARD(-1);\n-\t\tchill_number_eof:\n-\t\t  CPP_NUL_TERMINATE (pfile);\n-\t\t  return CPP_NUMBER;\n-\t\t}\n-\t    }\n-\t  else\n-\t    goto letter;\n-\tcase '_':\n-\tcase 'a': case 'e': case 'f': case 'g': case 'i': case 'j':\n-\tcase 'k': case 'l': case 'm': case 'n': case 'p': case 'q':\n-\tcase 'r': case 's': case 't': case 'u': case 'v': case 'w':\n-\tcase 'x': case 'y': case 'z':\n-\tcase 'A': case 'E': case 'F': case 'G': case 'I': case 'J':\n-\tcase 'K': case 'M': case 'N': case 'P': case 'Q': case 'R':\n-\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-\tcase 'Y': case 'Z':\n-        letter:\n-          {\n-\t    HASHNODE *hp;\n-\t    unsigned char *ident;\n-\t    int before_name_written = CPP_WRITTEN (pfile);\n-\t    int ident_len;\n-\t    parse_name (pfile, c);\n-\t    pfile->only_seen_white = 0;\n-\t    if (pfile->no_macro_expand)\n-\t      return CPP_NAME;\n-\t    ident = pfile->token_buffer + before_name_written;\n-\t    ident_len = CPP_PWRITTEN (pfile) - ident;\n-\t    hp = _cpp_lookup (pfile, ident, ident_len);\n-\t    if (!hp)\n-\t      return CPP_NAME;\n-\t    if (hp->type == T_DISABLED)\n-\t      {\n-\t\tif (pfile->output_escapes)\n-\t\t  { /* Return \"\\r-IDENT\", followed by '\\0'.  */\n-\t\t    int i;\n-\t\t    CPP_RESERVE (pfile, 3);\n-\t\t    ident = pfile->token_buffer + before_name_written;\n-\t\t    CPP_ADJUST_WRITTEN (pfile, 2);\n-\t\t    for (i = ident_len; i >= 0; i--) ident[i+2] = ident[i];\n-\t\t    ident[0] = '\\r';\n-\t\t    ident[1] = '-';\n-\t\t  }\n-\t\treturn CPP_NAME;\n-\t      }\n-\n-\t    /* If macro wants an arglist, verify that a '(' follows.  */\n-\t    if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n-\t    {\n-\t      int macbuf_whitespace = 0;\n-\n-\t      while (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t\t{\n-\t\t  const U_CHAR *point = CPP_BUFFER (pfile)->cur;\n-\t\t  for (;;)\n-\t\t    {\n-\t\t      cpp_skip_hspace (pfile);\n-\t\t      c = PEEKC ();\n-\t\t      if (c == '\\n')\n-\t\t\tFORWARD(1);\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (point != CPP_BUFFER (pfile)->cur)\n-\t\t    macbuf_whitespace = 1;\n-\t\t  if (c == '(')\n-\t\t    goto is_macro_call;\n-\t\t  else if (c != EOF)\n-\t\t    goto not_macro_call;\n-\t\t  cpp_pop_buffer (pfile);\n-\t\t}\n-\n-\t      parse_set_mark (pfile);\n-\t      for (;;)\n-\t\t{\n-\t\t  cpp_skip_hspace (pfile);\n-\t\t  c = PEEKC ();\n-\t\t  if (c == '\\n')\n-\t\t    FORWARD(1);\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t      parse_goto_mark (pfile);\n-\n-\t      if (c == '(')\n-\t\tgoto is_macro_call;\n-\n-\t    not_macro_call:\n-\t      if (macbuf_whitespace)\n-\t\tCPP_PUTC (pfile, ' ');\n-\t      return CPP_NAME;\n-\t    }\n-\t  is_macro_call:\n-\t    /* This is now known to be a macro call.\n-\t       Expand the macro, reading arguments as needed,\n-\t       and push the expansion on the input stack.  */\n-\t    _cpp_macroexpand (pfile, hp);\n-\t    CPP_SET_WRITTEN (pfile, before_name_written);\n-\t  }\n-\t  goto get_next;\n-\n-\tcase ' ':  case '\\t':  case '\\v':\n-\t  for (;;)\n-\t    {\n-\t      CPP_PUTC (pfile, c);\n-\t      c = PEEKC ();\n-\t      if (c == EOF || !is_hspace(c))\n-\t\tbreak;\n-\t      FORWARD(1);\n-\t    }\n-\t  return CPP_HSPACE;\n-\n-\tcase '\\r':\n-\t  if (CPP_BUFFER (pfile)->has_escapes)\n-\t    {\n-\t      c = GETC ();\n-\t      if (c == '-')\n-\t\t{\n-\t\t  if (pfile->output_escapes)\n-\t\t    CPP_PUTS (pfile, \"\\r-\", 2);\n-\t\t  parse_name (pfile, GETC ());\n-\t\t  return CPP_NAME;\n-\t\t}\n-\t      else if (c == ' ')\n-\t\t{\n-\t\t  CPP_RESERVE (pfile, 2);\n-\t\t  if (pfile->output_escapes)\n-\t\t    CPP_PUTC_Q (pfile, '\\r');\n-\t\t  CPP_PUTC_Q (pfile, c);\n-\t\t  return CPP_HSPACE;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  cpp_ice (pfile, \"unrecognized escape \\\\r%c\", c);\n-\t\t  goto get_next;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Backslash newline is ignored. */\n-\t      CPP_BUMP_LINE (pfile);\n-\t      goto get_next;\n-\t    }\n-\n-\tcase '\\n':\n-\t  CPP_PUTC (pfile, c);\n-\t  if (pfile->only_seen_white == 0)\n-\t    pfile->only_seen_white = 1;\n-\t  CPP_BUMP_LINE (pfile);\n-\t  if (! CPP_OPTIONS (pfile)->no_line_commands)\n-\t    {\n-\t      pfile->lineno++;\n-\t      if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n-\t\toutput_line_command (pfile, same_file);\n-\t    }\n-\t  return CPP_VSPACE;\n-\n-\tcase '(': token = CPP_LPAREN;    goto char1;\n-\tcase ')': token = CPP_RPAREN;    goto char1;\n-\tcase '{': token = CPP_LBRACE;    goto char1;\n-\tcase '}': token = CPP_RBRACE;    goto char1;\n-\tcase ',': token = CPP_COMMA;     goto char1;\n-\tcase ';': token = CPP_SEMICOLON; goto char1;\n-\n-\trandomchar:\n-\tdefault:\n-\t  token = CPP_OTHER;\n-\tchar1:\n-\t  pfile->only_seen_white = 0;\n-\t  CPP_PUTC (pfile, c);\n-\t  return token;\n-\t}\n-    }\n-}\n-\n-/* Like cpp_get_token, but skip spaces and comments.  */\n-\n-enum cpp_token\n-cpp_get_non_space_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  int old_written = CPP_WRITTEN (pfile);\n-  for (;;)\n-    {\n-      enum cpp_token token = cpp_get_token (pfile);\n-      if (token != CPP_COMMENT && token != CPP_POP\n-\t  && token != CPP_HSPACE && token != CPP_VSPACE)\n-\treturn token;\n-      CPP_SET_WRITTEN (pfile, old_written);\n-    }\n-}\n-\n-/* Parse an identifier starting with C.  */\n-\n-static void\n-parse_name (pfile, c)\n-     cpp_reader *pfile;\n-     int c;\n-{\n-  for (;;)\n-  {\n-      if (! is_idchar(c))\n-      {\n-\t  FORWARD (-1);\n-\t  break;\n-      }\n-\n-      if (c == '$' && CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"`$' in identifier\");\n-\n-      CPP_RESERVE(pfile, 2); /* One more for final NUL.  */\n-      CPP_PUTC_Q (pfile, c);\n-      c = GETC();\n-      if (c == EOF)\n-\tbreak;\n-  }\n-  CPP_NUL_TERMINATE_Q (pfile);\n-  return;\n-}\n-\n-/* Parse and skip over a string starting with C.  A single quoted\n-   string is treated like a double -- some programs (e.g., troff) are\n-   perverse this way.  (However, a single quoted string is not allowed\n-   to extend over multiple lines.)  */\n-static void\n-skip_string (pfile, c)\n-     cpp_reader *pfile;\n-     int c;\n-{\n-  long start_line, start_column;\n-  cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n-\n-  while (1)\n-    {\n-      int cc = GETC();\n-      switch (cc)\n-\t{\n-\tcase EOF:\n-\t  cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t       \"unterminated string or character constant\");\n-\t  if (pfile->multiline_string_line != start_line\n-\t      && pfile->multiline_string_line != 0)\n-\t    cpp_error_with_line (pfile,\n-\t\t\t\t pfile->multiline_string_line, -1,\n-\t\t\t \"possible real start of unterminated constant\");\n-\t  pfile->multiline_string_line = 0;\n-\t  return;\n-\n-\tcase '\\n':\n-\t  CPP_BUMP_LINE (pfile);\n-\t  /* In Fortran and assembly language, silently terminate\n-\t     strings of either variety at end of line.  This is a\n-\t     kludge around not knowing where comments are in these\n-\t     languages.  */\n-\t  if (CPP_OPTIONS (pfile)->lang_fortran\n-\t      || CPP_OPTIONS (pfile)->lang_asm)\n-\t    {\n-\t      FORWARD(-1);\n-\t      return;\n-\t    }\n-\t  /* Character constants may not extend over multiple lines.\n-\t     In Standard C, neither may strings.  We accept multiline\n-\t     strings as an extension.  */\n-\t  if (c == '\\'')\n-\t    {\n-\t      cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t\t   \"unterminated character constant\");\n-\t      FORWARD(-1);\n-\t      return;\n-\t    }\n-\t  if (CPP_PEDANTIC (pfile) && pfile->multiline_string_line == 0)\n-\t    cpp_pedwarn_with_line (pfile, start_line, start_column,\n-\t\t\t\t   \"string constant runs past end of line\");\n-\t  if (pfile->multiline_string_line == 0)\n-\t    pfile->multiline_string_line = start_line;\n-\t  break;\n-\n-\tcase '\\r':\n-\t  if (CPP_BUFFER (pfile)->has_escapes)\n-\t    {\n-\t      cpp_ice (pfile, \"\\\\r escape inside string constant\");\n-\t      FORWARD(1);\n-\t    }\n-\t  else\n-\t    /* Backslash newline is replaced by nothing at all.  */\n-\t    CPP_BUMP_LINE (pfile);\n-\t  break;\n-\n-\tcase '\\\\':\n-\t  FORWARD(1);\n-\t  break;\n-\n-\tcase '\\\"':\n-\tcase '\\'':\n-\t  if (cc == c)\n-\t    return;\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Parse a string and copy it to the output.  */\n-\n-static void\n-parse_string (pfile, c)\n+void\n+_cpp_handle_eof (pfile)\n      cpp_reader *pfile;\n-     int c;\n {\n-  const U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n-  const U_CHAR *limit;\n+  cpp_buffer *next_buf = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n+  struct if_stack *ifs, *nifs;\n \n-  skip_string (pfile, c);\n-\n-  limit = CPP_BUFFER (pfile)->cur;\n-  CPP_RESERVE (pfile, limit - start + 2);\n-  CPP_PUTC_Q (pfile, c);\n-  for (; start < limit; start++)\n-    if (*start != '\\r')\n-      CPP_PUTC_Q (pfile, *start);\n-}\n-\n-/* Read an assertion into the token buffer, converting to\n-   canonical form: `#predicate(a n swe r)'  The next non-whitespace\n-   character to read should be the first letter of the predicate.\n-   Returns 0 for syntax error, 1 for bare predicate, 2 for predicate\n-   with answer (see callers for why). In case of 0, an error has been\n-   printed. */\n-static int\n-parse_assertion (pfile)\n-     cpp_reader *pfile;\n-{\n-  int c, dropwhite;\n-  cpp_skip_hspace (pfile);\n-  c = PEEKC();\n-  if (! is_idstart(c))\n+  /* Unwind the conditional stack and generate error messages.  */\n+  for (ifs = pfile->if_stack;\n+       ifs != CPP_BUFFER (pfile)->if_stack;\n+       ifs = nifs)\n     {\n-      cpp_error (pfile, \"assertion predicate is not an identifier\");\n-      return 0;\n-    }\n-  CPP_PUTC(pfile, '#');\n-  FORWARD(1);\n-  parse_name(pfile, c);\n+      cpp_error_with_line (pfile, ifs->lineno, -1,\n+\t\t\t   \"unterminated `%s' conditional\",\n+\t\t\t   if_directive_name (pfile, ifs));\n \n-  c = PEEKC();\n-  if (c != '(')\n-    {\n-      if (is_hspace(c) || c == '\\r')\n-\tcpp_skip_hspace (pfile);\n-      c = PEEKC();\n+      nifs = ifs->next;\n+      free (ifs);\n     }\n-  if (c != '(')\n-    return 1;\n+  pfile->if_stack = ifs;\n \n-  CPP_PUTC(pfile, '(');\n-  FORWARD(1);\n-  dropwhite = 1;\n-  while ((c = GETC()) != ')')\n+  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != NULL)\n     {\n-      if (is_space(c))\n-\t{\n-\t  if (! dropwhite)\n-\t    {\n-\t      CPP_PUTC(pfile, ' ');\n-\t      dropwhite = 1;\n-\t    }\n-\t}\n-      else if (c == '\\n' || c == EOF)\n-\t{\n-\t  if (c == '\\n') FORWARD(-1);\n-\t  cpp_error (pfile, \"un-terminated assertion answer\");\n-\t  return 0;\n-\t}\n-      else if (c == '\\r')\n-\t/* \\r cannot be a macro escape here. */\n-\tCPP_BUMP_LINE (pfile);\n-      else\n-\t{\n-\t  CPP_PUTC (pfile, c);\n-\t  dropwhite = 0;\n-\t}\n+      /* We're about to return from an #include file.\n+\t Emit #line information now (as part of the CPP_POP) result.\n+\t But the #line refers to the file we will pop to.  */\n+      cpp_buffer *cur_buffer = CPP_BUFFER (pfile);\n+      CPP_BUFFER (pfile) = next_buf;\n+      pfile->input_stack_listing_current = 0;\n+      _cpp_output_line_command (pfile, leave_file);\n+      CPP_BUFFER (pfile) = cur_buffer;\n     }\n \n-  if (pfile->limit[-1] == ' ')\n-    pfile->limit[-1] = ')';\n-  else if (pfile->limit[-1] == '(')\n-    {\n-      cpp_error (pfile, \"empty token sequence in assertion\");\n-      return 0;\n-    }\n-  else\n-    CPP_PUTC (pfile, ')');\n-\n-  CPP_NUL_TERMINATE (pfile);\n-  return 2;\n+  CPP_BUFFER (pfile)->seen_eof = 1;\n }\n \n static int\n@@ -3045,9 +1704,9 @@ do_assert (pfile, keyword)\n   if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->done_initializing)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#assert'\");\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n-  ret = parse_assertion (pfile);\n+  ret = _cpp_parse_assertion (pfile);\n   if (ret == 0)\n     goto error;\n   else if (ret == 1)\n@@ -3056,7 +1715,7 @@ do_assert (pfile, keyword)\n       goto error;\n     }\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   c = PEEKC();\n   if (c != EOF && c != '\\n')\n     {\n@@ -3094,7 +1753,7 @@ do_assert (pfile, keyword)\n   return 0;\n \n  error:\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   pfile->limit = sym;\t\t/* Pop */\n   return 0;\n }\n@@ -3112,14 +1771,14 @@ do_unassert (pfile, keyword)\n   if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->done_initializing)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#unassert'\");\n \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n \n   sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n-  ret = parse_assertion (pfile);\n+  ret = _cpp_parse_assertion (pfile);\n   if (ret == 0)\n     goto error;\n   \n-  cpp_skip_hspace (pfile);\n+  _cpp_skip_hspace (pfile);\n   c = PEEKC ();\n   if (c != EOF && c != '\\n')\n       cpp_error (pfile, \"junk at end of `#unassert'\");\n@@ -3163,54 +1822,112 @@ do_unassert (pfile, keyword)\n   pfile->limit = sym;\t\t/* Pop */\n   return 0;\n  error:\n-  skip_rest_of_line (pfile);\n+  _cpp_skip_rest_of_line (pfile);\n   pfile->limit = sym;\t\t/* Pop */\n   return 0;\n }\n \n-/* Process STR as if it appeared as the body of an #unassert. */\n+/* These are for -D, -U, -A.  */\n+\n+/* Process the string STR as if it appeared as the body of a #define.\n+   If STR is just an identifier, define it with value 1.\n+   If STR has anything after the identifier, then it should\n+   be identifier=definition. */\n+\n void\n-cpp_unassert (pfile, str)\n+cpp_define (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n+  char *buf, *p;\n+  size_t count;\n+\n+  p = strchr (str, '=');\n+  /* Copy the entire option so we can modify it. \n+     Change the first \"=\" in the string to a space.  If there is none,\n+     tack \" 1\" on the end.  Then add a newline and a NUL.  */\n+  \n+  if (p)\n     {\n-      do_unassert (pfile, NULL);\n-      cpp_pop_buffer (pfile);\n+      count = strlen (str) + 2;\n+      buf = alloca (count);\n+      memcpy (buf, str, count - 2);\n+      buf[p - str] = ' ';\n+      buf[count - 2] = '\\n';\n+      buf[count - 1] = '\\0';\n+    }\n+  else\n+    {\n+      count = strlen (str) + 4;\n+      buf = alloca (count);\n+      memcpy (buf, str, count - 4);\n+      strcpy (&buf[count-4], \" 1\\n\");\n     }\n-}  \n-\n-/* Remember the current position of PFILE so it may be returned to\n-   after looking ahead a bit.\n \n-   Note that when you set a mark, you _must_ return to that mark.  You\n-   may not forget about it and continue parsing.  You may not pop a\n-   buffer with an active mark.  You may not call CPP_BUMP_LINE while a\n-   mark is active.  */\n+  if (cpp_push_buffer (pfile, buf, count - 1) != NULL)\n+    {\n+      do_define (pfile, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n+}\n \n-static void\n-parse_set_mark (pfile)\n+/* Process MACRO as if it appeared as the body of an #undef.  */\n+void\n+cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n+     const char *macro;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-  if (ACTIVE_MARK_P())\n-      cpp_ice (pfile, \"mark active in parse_set_mark\");\n-\n-  ip->mark = ip->cur - ip->buf;\n+  /* Copy the string so we can append a newline.  */\n+  size_t len = strlen (macro);\n+  char *buf = alloca (len + 2);\n+  memcpy (buf, macro, len);\n+  buf[len]     = '\\n';\n+  buf[len + 1] = '\\0';\n+  if (cpp_push_buffer (pfile, buf, len + 1))\n+    {\n+      do_undef (pfile, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n }\n \n-/* Backup the current position of PFILE to that saved in its mark,\n-   and clear the mark.  */\n+/* Process the string STR as if it appeared as the body of a #assert. */\n+void\n+cpp_assert (pfile, str)\n+     cpp_reader *pfile;\n+     const char *str;\n+{\n+  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n+    {\n+      do_assert (pfile, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n+}\n \n-static void\n-parse_goto_mark (pfile)\n+/* Process STR as if it appeared as the body of an #unassert. */\n+void\n+cpp_unassert (pfile, str)\n      cpp_reader *pfile;\n+     const char *str;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-  if (!ACTIVE_MARK_P())\n-      cpp_ice (pfile, \"mark not active in parse_goto_mark\");\n+  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n+    {\n+      do_unassert (pfile, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n+}  \n \n-  ip->cur = ip->buf + ip->mark;\n-  ip->mark = -1;\n+/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n+int\n+cpp_defined (pfile, id, len)\n+     cpp_reader *pfile;\n+     const U_CHAR *id;\n+     int len;\n+{\n+  HASHNODE *hp = _cpp_lookup (pfile, id, len);\n+  if (hp && hp->type == T_POISON)\n+    {\n+      cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n+      return 0;\n+    }\n+  return (hp != NULL);\n }"}, {"sha": "19f958f3229a2bb24ed442ad6181a9e657fe3afd", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -40,6 +40,7 @@ enum cpp_token\n   CPP_HSPACE,\n   CPP_VSPACE, /* newlines and #line directives */\n   CPP_NAME,\n+  CPP_MACRO,\n   CPP_NUMBER,\n   CPP_CHAR,\n   CPP_WCHAR,\n@@ -233,11 +234,6 @@ struct cpp_reader\n #define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n #define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n \n-/* Make sure PFILE->token_buffer has space for at least N more characters. */\n-#define CPP_RESERVE(PFILE, N) \\\n-  (CPP_WRITTEN (PFILE) + (size_t)(N) > (PFILE)->token_buffer_size \\\n-   && (cpp_grow_buffer (PFILE, N), 0))\n-\n #define CPP_OPTIONS(PFILE) ((PFILE)->opts)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n \n@@ -438,7 +434,6 @@ extern const char *progname;\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n-extern enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n \n extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern void cpp_options_init PARAMS ((cpp_options *));\n@@ -482,22 +477,15 @@ extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *,\n extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n \n-extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    const unsigned char *, long));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n-extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));\n extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const unsigned char *, int));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n \n-/* Last arg to output_line_command.  */\n-enum file_change_code {same_file, rename_file, enter_file, leave_file};\n-extern void output_line_command\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t enum file_change_code));\n-\n /* In cppfiles.c */\n extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));"}, {"sha": "48e1b5dcfd2b9062ace345c23fc23b896d68edf8", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b966db65e4ab054d31f01f65b7a98023dbcb54/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=45b966db65e4ab054d31f01f65b7a98023dbcb54", "patch": "@@ -594,6 +594,7 @@ cppfiles.c\n cpphash.c\n cpphash.h\n cppinit.c\n+cpplex.c\n cpplib.c\n cpplib.h\n cppmain.c"}]}