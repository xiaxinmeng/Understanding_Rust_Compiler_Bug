{"sha": "e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkM2VlZjExZDZlZDQ2MGRiNmFhNjZmZWE0ODliZDNlMGM5ZjU3Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-10T01:52:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-10T01:52:53Z"}, "message": "builtins.c (std_gimplify_va_arg_expr): Deny ARGS_GROW_DOWNWARD.\n\n        * builtins.c (std_gimplify_va_arg_expr): Deny ARGS_GROW_DOWNWARD.\n        Always align upward to arg boundary.  Use size_in_bytes/round_up.\n        Maintain type-correctness of constants.\n        * stor-layout.c (round_up, round_down): Special-case powers of 2.\n\nFrom-SVN: r84430", "tree": {"sha": "236f16934f66ba6982429b03b99f0240e991c0d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/236f16934f66ba6982429b03b99f0240e991c0d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/comments", "author": null, "committer": null, "parents": [{"sha": "ffe384ff8643d92dc213b386b3dadb8d90c4b0d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe384ff8643d92dc213b386b3dadb8d90c4b0d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe384ff8643d92dc213b386b3dadb8d90c4b0d1"}], "stats": {"total": 116, "additions": 70, "deletions": 46}, "files": [{"sha": "d99487d72131afc631c77822ef20168c8713e88f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "patch": "@@ -1,3 +1,10 @@\n+2004-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (std_gimplify_va_arg_expr): Deny ARGS_GROW_DOWNWARD.\n+\tAlways align upward to arg boundary.  Use size_in_bytes/round_up.\n+\tMaintain type-correctness of constants.\n+\t* stor-layout.c (round_up, round_down): Special-case powers of 2.\n+\n 2004-07-09  David S. Miller  <davem@nuts.davemloft.net>\n \n \t* config/sparc/sparc.c (*_costs): Scale instruction costs"}, {"sha": "dd39967de6a28ca7c792eb3c97d33884005e6e2f", "filename": "gcc/builtins.c", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "patch": "@@ -4473,72 +4473,61 @@ expand_builtin_va_arg (tree valist, tree type)\n tree\n std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n {\n-  tree addr, t, type_size = NULL;\n-  tree align, alignm1, malign;\n-  tree rounded_size;\n-  tree valist_tmp;\n-  HOST_WIDE_INT boundary;\n+  tree addr, t, type_size, rounded_size, valist_tmp;\n+  unsigned int align, boundary;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  /* All of the alignment and movement below is for args-grow-up machines.\n+     As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n+     implement their own specialized gimplify_va_arg_expr routines.  */\n+  abort ();\n+#endif\n \n   /* Compute the rounded size of the type.  */\n-  align = size_int (PARM_BOUNDARY / BITS_PER_UNIT);\n-  alignm1 = size_int (PARM_BOUNDARY / BITS_PER_UNIT - 1);\n-  malign = size_int (-(PARM_BOUNDARY / BITS_PER_UNIT));\n+  align = PARM_BOUNDARY / BITS_PER_UNIT;\n   boundary = FUNCTION_ARG_BOUNDARY (TYPE_MODE (type), type);\n \n+  /* Hoist the valist value into a temporary for the moment.  */\n   valist_tmp = get_initialized_tmp_var (valist, pre_p, NULL);\n \n   /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n      requires greater alignment, we must perform dynamic alignment.  */\n-\n   if (boundary > PARM_BOUNDARY)\n     {\n-      if (!PAD_VARARGS_DOWN)\n-\t{\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t      build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t\t      build_int_2 (boundary / BITS_PER_UNIT - 1, 0)));\n-\t  gimplify_and_add (t, pre_p);\n-\t}\n+      unsigned byte_bound = boundary / BITS_PER_UNIT;\n+\n+      t = fold_convert (TREE_TYPE (valist), size_int (byte_bound - 1));\n       t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t\t  build_int_2 (~(boundary / BITS_PER_UNIT - 1), -1)));\n+\t\t  build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t));\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+\t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist_tmp, t));\n       gimplify_and_add (t, pre_p);\n-    }\n-  if (type == error_mark_node\n-      || (type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type))) == NULL\n-      || TREE_OVERFLOW (type_size))\n-    rounded_size = size_zero_node;\n-  else\n-    {\n-      rounded_size = fold (build2 (PLUS_EXPR, sizetype, type_size, alignm1));\n-      rounded_size = fold (build2 (BIT_AND_EXPR, sizetype,\n-\t\t\t\t   rounded_size, malign));\n     }\n \n+  type_size = size_in_bytes (type);\n+  rounded_size = round_up (type_size, align);\n+\n   /* Reduce rounded_size so it's sharable with the postqueue.  */\n   gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n \n   /* Get AP.  */\n   addr = valist_tmp;\n-  if (PAD_VARARGS_DOWN && ! integer_zerop (rounded_size))\n+  if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n     {\n       /* Small args are padded downward.  */\n-      addr = fold (build2 (PLUS_EXPR, TREE_TYPE (addr), addr,\n-\t\t\t\tfold (build3 (COND_EXPR, sizetype,\n-\t\t\t\t\t      fold (build2 (GT_EXPR, sizetype,\n-\t\t\t\t\t\t\t    rounded_size,\n-\t\t\t\t\t\t\t    align)),\n-\t\t\t\t\t      size_zero_node,\n-\t\t\t\t\t      fold (build2 (MINUS_EXPR,\n-\t\t\t\t\t\t\t    sizetype,\n-\t\t\t\t\t\t\t    rounded_size,\n-\t\t\t\t\t\t\t    type_size))))));\n+      t = fold (build2 (GT_EXPR, sizetype, rounded_size, size_int (align)));\n+      t = fold (build3 (COND_EXPR, sizetype, t, size_zero_node,\n+\t\t\tsize_binop (MINUS_EXPR, rounded_size, type_size)));\n+      t = fold_convert (TREE_TYPE (addr), t);\n+      addr = build2 (PLUS_EXPR, TREE_TYPE (addr), addr, t);\n     }\n \n   /* Compute new value for AP.  */\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t      fold (build2 (PLUS_EXPR, TREE_TYPE (valist),\n-\t\t\t    valist_tmp, rounded_size)));\n+  t = fold_convert (TREE_TYPE (valist), rounded_size);\n+  t = build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n   gimplify_and_add (t, pre_p);\n \n   addr = fold_convert (build_pointer_type (type), addr);"}, {"sha": "689768536af17a88f5f97a08000d2b60c00f24af", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d3eef11d6ed460db6aa66fea489bd3e0c9f577/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e4d3eef11d6ed460db6aa66fea489bd3e0c9f577", "patch": "@@ -274,19 +274,47 @@ get_mode_alignment (enum machine_mode mode)\n tree\n round_up (tree value, int divisor)\n {\n-  tree arg = size_int_type (divisor, TREE_TYPE (value));\n+  tree t;\n+\n+  /* If divisor is a power of two, simplify this to bit manipulation.  */\n+  if (divisor == (divisor & -divisor))\n+    {\n+      t = size_int_type (divisor - 1, TREE_TYPE (value));\n+      value = size_binop (PLUS_EXPR, value, t);\n+      t = size_int_type (-divisor, TREE_TYPE (value));\n+      value = size_binop (BIT_AND_EXPR, value, t);\n+    }\n+  else\n+    {\n+      t = size_int_type (divisor, TREE_TYPE (value));\n+      value = size_binop (CEIL_DIV_EXPR, value, t);\n+      value = size_binop (MULT_EXPR, value, t);\n+    }\n \n-  return size_binop (MULT_EXPR, size_binop (CEIL_DIV_EXPR, value, arg), arg);\n+  return value;\n }\n \n /* Likewise, but round down.  */\n \n tree\n round_down (tree value, int divisor)\n {\n-  tree arg = size_int_type (divisor, TREE_TYPE (value));\n+  tree t;\n+\n+  /* If divisor is a power of two, simplify this to bit manipulation.  */\n+  if (divisor == (divisor & -divisor))\n+    {\n+      t = size_int_type (-divisor, TREE_TYPE (value));\n+      value = size_binop (BIT_AND_EXPR, value, t);\n+    }\n+  else\n+    {\n+      t = size_int_type (divisor, TREE_TYPE (value));\n+      value = size_binop (FLOOR_DIV_EXPR, value, t);\n+      value = size_binop (MULT_EXPR, value, t);\n+    }\n \n-  return size_binop (MULT_EXPR, size_binop (FLOOR_DIV_EXPR, value, arg), arg);\n+  return value;\n }\n \f\n /* Subroutine of layout_decl: Force alignment required for the data type."}]}