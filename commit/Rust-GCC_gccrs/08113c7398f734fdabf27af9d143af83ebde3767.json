{"sha": "08113c7398f734fdabf27af9d143af83ebde3767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxMTNjNzM5OGY3MzRmZGFiZjI3YWY5ZDE0M2FmODNlYmRlMzc2Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-24T19:15:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-24T19:15:27Z"}, "message": "re PR fortran/31205 (aliased operator assignment produces wrong result)\n\n2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31205\n\tPR fortran/32842\n\t* trans-expr.c (gfc_conv_function_call): Remove the default\n\tinitialization of intent(out) derived types.\n\t* symbol.c (gfc_lval_expr_from_sym): New function.\n\t* matchexp.c (gfc_get_parentheses): Return argument, if it is\n\tcharacter and posseses a ref.\n\t* gfortran.h : Add prototype for gfc_lval_expr_from_sym.\n\t* resolve.c (has_default_initializer): Move higher up in file.\n\t(resolve_code): On detecting an interface assignment, check\n\tif the rhs and the lhs are the same symbol.  If this is so,\n\tenclose the rhs in parenetheses to generate a temporary and\n\tprevent any possible aliasing.\n\t(apply_default_init): Remove code making the lval and call\n\tgfc_lval_expr_from_sym instead.\n\t(resolve_operator): Give a parentheses expression a type-\n\tspec if it has no type.\n\t* trans-decl.c (gfc_trans_deferred_vars): Apply the a default\n\tinitializer, if any, to an intent(out) derived type, using\n\tgfc_lval_expr_from_sym and gfc_trans_assignment.  Check if\n\tthe dummy is present.\n\n\n2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31205\n\t* gfortran.dg/alloc_comp_basics_1.f90 : Restore number of\n\t\"deallocates\" to 24, since patch has code rid of much spurious\n\tcode.\n\t* gfortran.dg/interface_assignment_1.f90 : New test.\n\n\tPR fortran/32842\n\t* gfortran.dg/interface_assignment_2.f90 : New test.\n\nFrom-SVN: r126885", "tree": {"sha": "32b8097802564b8678cba249265de7ae9a445e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32b8097802564b8678cba249265de7ae9a445e64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08113c7398f734fdabf27af9d143af83ebde3767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08113c7398f734fdabf27af9d143af83ebde3767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08113c7398f734fdabf27af9d143af83ebde3767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08113c7398f734fdabf27af9d143af83ebde3767/comments", "author": null, "committer": null, "parents": [{"sha": "b21a6ea1002424fcb2b3d5d5661526ce7abbb358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b21a6ea1002424fcb2b3d5d5661526ce7abbb358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b21a6ea1002424fcb2b3d5d5661526ce7abbb358"}], "stats": {"total": 203, "additions": 144, "deletions": 59}, "files": [{"sha": "7050f52569af93dd4503280eb635f00e4f911c2a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -1,3 +1,27 @@\n+2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/31205\n+\tPR fortran/32842\n+\t* trans-expr.c (gfc_conv_function_call): Remove the default\n+\tinitialization of intent(out) derived types.\n+\t* symbol.c (gfc_lval_expr_from_sym): New function.\n+\t* matchexp.c (gfc_get_parentheses): Return argument, if it is\n+\tcharacter and posseses a ref.\n+\t* gfortran.h : Add prototype for gfc_lval_expr_from_sym.\n+\t* resolve.c (has_default_initializer): Move higher up in file.\n+\t(resolve_code): On detecting an interface assignment, check\n+\tif the rhs and the lhs are the same symbol.  If this is so,\n+\tenclose the rhs in parenetheses to generate a temporary and\n+\tprevent any possible aliasing.\n+\t(apply_default_init): Remove code making the lval and call\n+\tgfc_lval_expr_from_sym instead.\n+\t(resolve_operator): Give a parentheses expression a type-\n+\tspec if it has no type.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Apply the a default\n+\tinitializer, if any, to an intent(out) derived type, using\n+\tgfc_lval_expr_from_sym and gfc_trans_assignment.  Check if\n+\tthe dummy is present.\n+\n 2007-07-24  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/32867"}, {"sha": "f475c1e9209bbd334499245d86e8eb16a2f16147", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -2120,6 +2120,8 @@ void gfc_free_st_label (gfc_st_label *);\n void gfc_define_st_label (gfc_st_label *, gfc_sl_type, locus *);\n try gfc_reference_st_label (gfc_st_label *, gfc_sl_type);\n \n+gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);\n+\n gfc_namespace *gfc_get_namespace (gfc_namespace *, int);\n gfc_symtree *gfc_new_symtree (gfc_symtree **, const char *);\n gfc_symtree *gfc_find_symtree (gfc_symtree *, const char *);"}, {"sha": "f67871b6b11f103ffb53038b57e15db6e25fed07", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -131,6 +131,13 @@ gfc_get_parentheses (gfc_expr *e)\n {\n   gfc_expr *e2;\n \n+  /* This is a temporary fix, awaiting the patch for various\n+     other character problems.  The resolution and translation\n+     of substrings and concatenations are so kludged up that\n+     putting parentheses around them breaks everything.  */\n+  if (e->ts.type == BT_CHARACTER && e->ref)\n+    return e;\n+\n   e2 = gfc_get_expr();\n   e2->expr_type = EXPR_OP;\n   e2->ts = e->ts;\n@@ -181,13 +188,9 @@ match_primary (gfc_expr **result)\n     gfc_error (\"Expected a right parenthesis in expression at %C\");\n \n   /* Now we have the expression inside the parentheses, build the\n-     expression pointing to it. By 7.1.7.2 the integrity of\n-     parentheses is only conserved in numerical calculations, so we\n-     don't bother to keep the parentheses otherwise.  */\n-  if(!gfc_numeric_ts(&e->ts))\n-    *result = e;\n-  else\n-    *result = gfc_get_parentheses (e);\n+     expression pointing to it. By 7.1.7.2, any expression in\n+     parentheses shall be treated as a data entity.  */\n+  *result = gfc_get_parentheses (e);\n \n   if (m != MATCH_YES)\n     {"}, {"sha": "7580d805e471fb0c83150729db6b4636b6c3a58f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -2937,16 +2937,24 @@ resolve_operator (gfc_expr *e)\n \n       break;\n \n+    case INTRINSIC_PARENTHESES:\n+\n+      /*  This is always correct and sometimes necessary!  */\n+      if (e->ts.type == BT_UNKNOWN)\n+\te->ts = op1->ts;\n+\n+      if (e->ts.type == BT_CHARACTER && !e->ts.cl)\n+\te->ts.cl = op1->ts.cl;\n+\n     case INTRINSIC_NOT:\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n-    case INTRINSIC_PARENTHESES:\n+      /* Simply copy arrayness attribute */\n       e->rank = op1->rank;\n \n       if (e->shape == NULL)\n \te->shape = gfc_copy_shape (op1->shape, op1->rank);\n \n-      /* Simply copy arrayness attribute */\n       break;\n \n     default:\n@@ -5710,6 +5718,21 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n }\n \n \n+static gfc_component *\n+has_default_initializer (gfc_symbol *der)\n+{\n+  gfc_component *c;\n+  for (c = der->components; c; c = c->next)\n+    if ((c->ts.type != BT_DERIVED && c->initializer)\n+        || (c->ts.type == BT_DERIVED\n+              && !c->pointer\n+              && has_default_initializer (c->ts.derived)))\n+      break;\n+\n+  return c;\n+}\n+\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -5829,13 +5852,25 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \t  if (gfc_extend_assign (code, ns) == SUCCESS)\n \t    {\n+\t      gfc_expr *lhs = code->ext.actual->expr;\n+\t      gfc_expr *rhs = code->ext.actual->next->expr;\n+\n \t      if (gfc_pure (NULL) && !gfc_pure (code->symtree->n.sym))\n \t\t{\n \t\t  gfc_error (\"Subroutine '%s' called instead of assignment at \"\n \t\t\t     \"%L must be PURE\", code->symtree->n.sym->name,\n \t\t\t     &code->loc);\n \t\t  break;\n \t\t}\n+\n+\t      /* Make a temporary rhs when there is a default initializer\n+\t\t and rhs is the same symbol as the lhs.  */\n+\t      if (rhs->expr_type == EXPR_VARIABLE\n+\t\t    && rhs->symtree->n.sym->ts.type == BT_DERIVED\n+\t\t    && has_default_initializer (rhs->symtree->n.sym->ts.derived)\n+\t\t    && (lhs->symtree->n.sym == rhs->symtree->n.sym))\n+\t        code->ext.actual->next->expr = gfc_get_parentheses (rhs);\n+\n \t      goto call;\n \t    }\n \n@@ -6413,23 +6448,7 @@ apply_default_init (gfc_symbol *sym)\n     }\n \n   /* Build an l-value expression for the result.  */\n-  lval = gfc_get_expr ();\n-  lval->expr_type = EXPR_VARIABLE;\n-  lval->where = sym->declared_at;\n-  lval->ts = sym->ts;\n-  lval->symtree = gfc_find_symtree (sym->ns->sym_root, sym->name);\n-\n-  /* It will always be a full array.  */\n-  lval->rank = sym->as ? sym->as->rank : 0;\n-  if (lval->rank)\n-    {\n-      lval->ref = gfc_get_ref ();\n-      lval->ref->type = REF_ARRAY;\n-      lval->ref->u.ar.type = AR_FULL;\n-      lval->ref->u.ar.dimen = lval->rank;\n-      lval->ref->u.ar.where = sym->declared_at;\n-      lval->ref->u.ar.as = sym->as;\n-    }\n+  lval = gfc_lval_expr_from_sym (sym);\n \n   /* Add the code at scope entry.  */\n   init_st = gfc_get_code ();\n@@ -6485,21 +6504,6 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n }\n \n \n-static gfc_component *\n-has_default_initializer (gfc_symbol *der)\n-{\n-  gfc_component *c;\n-  for (c = der->components; c; c = c->next)\n-    if ((c->ts.type != BT_DERIVED && c->initializer)\n-        || (c->ts.type == BT_DERIVED\n-              && !c->pointer\n-              && has_default_initializer (c->ts.derived)))\n-      break;\n-\n-  return c;\n-}\n-\n-\n /* Resolve symbols with flavor variable.  */\n \n static try"}, {"sha": "af42e9b6146ea6e2526510c180fd46b962ca3d66", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -1959,6 +1959,35 @@ gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n }\n \n \n+/*******A helper function for creating new expressions*************/\n+\n+\n+gfc_expr *\n+gfc_lval_expr_from_sym (gfc_symbol *sym)\n+{\n+  gfc_expr *lval;\n+  lval = gfc_get_expr ();\n+  lval->expr_type = EXPR_VARIABLE;\n+  lval->where = sym->declared_at;\n+  lval->ts = sym->ts;\n+  lval->symtree = gfc_find_symtree (sym->ns->sym_root, sym->name);\n+\n+  /* It will always be a full array.  */\n+  lval->rank = sym->as ? sym->as->rank : 0;\n+  if (lval->rank)\n+    {\n+      lval->ref = gfc_get_ref ();\n+      lval->ref->type = REF_ARRAY;\n+      lval->ref->u.ar.type = AR_FULL;\n+      lval->ref->u.ar.dimen = lval->rank;\n+      lval->ref->u.ar.where = sym->declared_at;\n+      lval->ref->u.ar.as = sym->as;\n+    }\n+\n+  return lval;\n+}\n+\n+\n /************** Symbol table management subroutines ****************/\n \n /* Basic details: Fortran 95 requires a potentially unlimited number"}, {"sha": "6c6cba0a013d12f9c5eb14c54ed0e4eedaf47e28", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -2725,12 +2725,35 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   gfc_init_block (&body);\n \n   for (f = proc_sym->formal; f; f = f->next)\n-    if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n-      {\n-\tgcc_assert (f->sym->ts.cl->backend_decl != NULL);\n-\tif (TREE_CODE (f->sym->ts.cl->backend_decl) == PARM_DECL)\n-\t  gfc_trans_vla_type_sizes (f->sym, &body);\n-      }\n+    {\n+      if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n+\t{\n+\t  gcc_assert (f->sym->ts.cl->backend_decl != NULL);\n+\t  if (TREE_CODE (f->sym->ts.cl->backend_decl) == PARM_DECL)\n+\t    gfc_trans_vla_type_sizes (f->sym, &body);\n+\t}\n+\n+      /* If an INTENT(OUT) dummy of derived type has a default\n+\t initializer, it must be initialized here.  */\n+      if (f->sym && f->sym->attr.referenced\n+\t    && f->sym->attr.intent == INTENT_OUT\n+\t    && f->sym->ts.type == BT_DERIVED\n+\t    && !f->sym->ts.derived->attr.alloc_comp\n+\t    && f->sym->value)\n+\t{\n+\t  gfc_expr *tmpe;\n+\t  tree tmp, present;\n+\t  gcc_assert (!f->sym->attr.allocatable);\n+\t  tmpe = gfc_lval_expr_from_sym (f->sym);\n+\t  tmp = gfc_trans_assignment (tmpe, f->sym->value, false);\n+\n+\t  present = gfc_conv_expr_present (f->sym);\n+\t  tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n+\t\t\ttmp, build_empty_stmt ());\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\t  gfc_free_expr (tmpe);\n+\t}\n+    }\n \n   if (gfc_return_by_reference (proc_sym) && proc_sym->ts.type == BT_CHARACTER\n       && current_fake_result_decl != NULL)"}, {"sha": "2436574aa3d179c8f924af199eb760b02caa14cb", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -2245,17 +2245,6 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t    && fsym->attr.optional)\n \t\tgfc_conv_missing_dummy (&parmse, e, fsym->ts);\n \n-\t      /* If an INTENT(OUT) dummy of derived type has a default\n-\t\t initializer, it must be (re)initialized here.  */\n-\t      if (fsym->attr.intent == INTENT_OUT\n-\t\t    && fsym->ts.type == BT_DERIVED\n-\t\t    && fsym->value)\n-\t\t{\n-\t\t  gcc_assert (!fsym->attr.allocatable);\n-\t\t  tmp = gfc_trans_assignment (e, fsym->value, false);\n-\t\t  gfc_add_expr_to_block (&se->pre, tmp);\n-\t\t}\n-\n \t      /* Obtain the character length of an assumed character\n \t\t length procedure from the typespec.  */\n \t      if (fsym->ts.type == BT_CHARACTER"}, {"sha": "6a39a3a24f310686783adbd0ce10c1fe56300c9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -1,3 +1,14 @@\n+2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/31205\n+\t* gfortran.dg/alloc_comp_basics_1.f90 : Restore number of\n+\t\"deallocates\" to 24, since patch has code rid of much spurious\n+\tcode.\n+\t* gfortran.dg/interface_assignment_1.f90 : New test.\n+\n+\tPR fortran/32842\n+\t* gfortran.dg/interface_assignment_2.f90 : New test.\n+\n 2007-07-24  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/32867"}, {"sha": "a4617cbf01edbe3412754fb1177c8e3ed97d8242", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08113c7398f734fdabf27af9d143af83ebde3767/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=08113c7398f734fdabf27af9d143af83ebde3767", "patch": "@@ -139,6 +139,6 @@ subroutine check_alloc2(b)\n     end subroutine check_alloc2\n \n end program alloc\n-! { dg-final { scan-tree-dump-times \"deallocate\" 33 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"deallocate\" 24 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-modules \"alloc_m\" } }"}]}