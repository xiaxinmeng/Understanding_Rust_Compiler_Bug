{"sha": "2127637945ea6b763966398130e0770fa993c860", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEyNzYzNzk0NWVhNmI3NjM5NjYzOTgxMzBlMDc3MGZhOTkzYzg2MA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2006-01-17T18:09:40Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2006-01-17T18:09:40Z"}, "message": "Imported GNU Classpath 0.20\n\n       Imported GNU Classpath 0.20\n       * Makefile.am (AM_CPPFLAGS): Add classpath/include.\n       * java/nio/charset/spi/CharsetProvider.java: New override file.\n       * java/security/Security.java: Likewise.\n       * sources.am: Regenerated.\n       * Makefile.in: Likewise.\n\nFrom-SVN: r109831", "tree": {"sha": "c976ca91e3ef0bda3b34b37c0195145638d8d08e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c976ca91e3ef0bda3b34b37c0195145638d8d08e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2127637945ea6b763966398130e0770fa993c860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2127637945ea6b763966398130e0770fa993c860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2127637945ea6b763966398130e0770fa993c860", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2127637945ea6b763966398130e0770fa993c860/comments", "author": null, "committer": null, "parents": [{"sha": "bcb36c3e02e3bd2843aad1b9888513dfb5d6e337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337"}], "stats": {"total": 117245, "additions": 81146, "deletions": 36099}, "files": [{"sha": "f8df781bde1b5983711a54e3cb98e94542936a65", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,3 +1,12 @@\n+2006-01-16  Mark Wielaard  <mark@klomp.org>\n+\n+\tImported GNU Classpath 0.20\n+\t* Makefile.am (AM_CPPFLAGS): Add classpath/include.\n+\t* java/nio/charset/spi/CharsetProvider.java: New override file.\n+\t* java/security/Security.java: Likewise.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Likewise.\n+\n 2006-01-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.ac (dbexecdir): New substituted var."}, {"sha": "9ec3a549ccc4f3edf16c55738d7c1313d6d716b0", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -152,6 +152,7 @@ LIBFFIINCS = @LIBFFIINCS@\n AM_CPPFLAGS = -I$(top_srcdir) \\\n \t-Iinclude -I$(top_srcdir)/include \\\n \t-I$(top_srcdir)/classpath/include \\\n+\t-Iclasspath/include \\\n \t-I$(top_srcdir)/classpath/native/fdlibm \\\n \t$(GCINCS) $(THREADINCS) $(INCLTDL) \\\n \t$(GCC_UNWIND_INCLUDE) $(ZINCS) $(LIBFFIINCS)"}, {"sha": "118b49251816444e8b8cdae56da4db26e0f317ef", "filename": "libjava/Makefile.in", "status": "modified", "additions": 105, "deletions": 27, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -192,24 +192,25 @@ am__DEPENDENCIES_2 = gnu/awt.lo gnu/awt/j2d.lo gnu/classpath.lo \\\n \tjava/util/jar.lo java/util/logging.lo java/util/prefs.lo \\\n \tjava/util/regex.lo java/util/zip.lo javax/accessibility.lo \\\n \tjavax/crypto.lo javax/crypto/interfaces.lo \\\n-\tjavax/crypto/spec.lo javax/naming.lo javax/naming/directory.lo \\\n-\tjavax/naming/event.lo javax/naming/ldap.lo javax/naming/spi.lo \\\n-\tjavax/net.lo javax/net/ssl.lo javax/print.lo \\\n-\tjavax/print/attribute.lo javax/print/attribute/standard.lo \\\n-\tjavax/print/event.lo javax/security/auth.lo \\\n-\tjavax/security/auth/callback.lo javax/security/auth/login.lo \\\n-\tjavax/security/auth/spi.lo javax/security/auth/x500.lo \\\n-\tjavax/security/cert.lo javax/security/sasl.lo \\\n-\tjavax/sound/midi.lo javax/sound/midi/spi.lo \\\n-\tjavax/sound/sampled.lo javax/sound/sampled/spi.lo javax/sql.lo \\\n-\tjavax/swing.lo javax/swing/border.lo \\\n-\tjavax/swing/colorchooser.lo javax/swing/event.lo \\\n-\tjavax/swing/filechooser.lo javax/swing/plaf.lo \\\n-\tjavax/swing/plaf/basic.lo javax/swing/plaf/metal.lo \\\n-\tjavax/swing/plaf/multi.lo javax/swing/table.lo \\\n-\tjavax/swing/text.lo javax/swing/text/html.lo \\\n-\tjavax/swing/text/html/parser.lo javax/swing/text/rtf.lo \\\n-\tjavax/swing/tree.lo javax/swing/undo.lo javax/transaction.lo \\\n+\tjavax/crypto/spec.lo javax/management.lo javax/naming.lo \\\n+\tjavax/naming/directory.lo javax/naming/event.lo \\\n+\tjavax/naming/ldap.lo javax/naming/spi.lo javax/net.lo \\\n+\tjavax/net/ssl.lo javax/print.lo javax/print/attribute.lo \\\n+\tjavax/print/attribute/standard.lo javax/print/event.lo \\\n+\tjavax/security/auth.lo javax/security/auth/callback.lo \\\n+\tjavax/security/auth/login.lo javax/security/auth/spi.lo \\\n+\tjavax/security/auth/x500.lo javax/security/cert.lo \\\n+\tjavax/security/sasl.lo javax/sound/midi.lo \\\n+\tjavax/sound/midi/spi.lo javax/sound/sampled.lo \\\n+\tjavax/sound/sampled/spi.lo javax/sql.lo javax/swing.lo \\\n+\tjavax/swing/border.lo javax/swing/colorchooser.lo \\\n+\tjavax/swing/event.lo javax/swing/filechooser.lo \\\n+\tjavax/swing/plaf.lo javax/swing/plaf/basic.lo \\\n+\tjavax/swing/plaf/metal.lo javax/swing/plaf/multi.lo \\\n+\tjavax/swing/table.lo javax/swing/text.lo \\\n+\tjavax/swing/text/html.lo javax/swing/text/html/parser.lo \\\n+\tjavax/swing/text/rtf.lo javax/swing/tree.lo \\\n+\tjavax/swing/undo.lo javax/transaction.lo \\\n \tjavax/transaction/xa.lo org/ietf/jgss.lo\n am__DEPENDENCIES_3 = gnu-CORBA.lo gnu-java-beans.lo gnu-javax-rmi.lo \\\n \tgnu-javax-sound-midi.lo gnu-xml.lo javax-imageio.lo \\\n@@ -582,6 +583,7 @@ build_os = @build_os@\n build_subdir = @build_subdir@\n build_vendor = @build_vendor@\n datadir = @datadir@\n+dbexecdir = @dbexecdir@\n exec_prefix = @exec_prefix@\n extra_ldflags_libjava = @extra_ldflags_libjava@\n gxx_include_dir = @gxx_include_dir@\n@@ -622,7 +624,6 @@ target_vendor = @target_vendor@\n toolexecdir = @toolexecdir@\n toolexeclibdir = @toolexeclibdir@\n toolexecmainlibdir = @toolexecmainlibdir@\n-dbexecdir = @dbexecdir@\n AUTOMAKE_OPTIONS = foreign subdir-objects\n ACLOCAL_AMFLAGS = -I . -I .. -I ../config\n \n@@ -697,6 +698,7 @@ JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n AM_CPPFLAGS = -I$(top_srcdir) \\\n \t-Iinclude -I$(top_srcdir)/include \\\n \t-I$(top_srcdir)/classpath/include \\\n+\t-Iclasspath/include \\\n \t-I$(top_srcdir)/classpath/native/fdlibm \\\n \t$(GCINCS) $(THREADINCS) $(INCLTDL) \\\n \t$(GCC_UNWIND_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n@@ -1395,7 +1397,37 @@ classpath/gnu/java/beans/editors/NativeFloatEditor.java \\\n classpath/gnu/java/beans/editors/NativeIntEditor.java \\\n classpath/gnu/java/beans/editors/NativeLongEditor.java \\\n classpath/gnu/java/beans/editors/NativeShortEditor.java \\\n-classpath/gnu/java/beans/editors/StringEditor.java\n+classpath/gnu/java/beans/editors/StringEditor.java \\\n+classpath/gnu/java/beans/encoder/ArrayPersistenceDelegate.java \\\n+classpath/gnu/java/beans/encoder/ClassPersistenceDelegate.java \\\n+classpath/gnu/java/beans/encoder/CollectionPersistenceDelegate.java \\\n+classpath/gnu/java/beans/encoder/Context.java \\\n+classpath/gnu/java/beans/encoder/GenericScannerState.java \\\n+classpath/gnu/java/beans/encoder/IgnoringScannerState.java \\\n+classpath/gnu/java/beans/encoder/MapPersistenceDelegate.java \\\n+classpath/gnu/java/beans/encoder/ObjectId.java \\\n+classpath/gnu/java/beans/encoder/PrimitivePersistenceDelegate.java \\\n+classpath/gnu/java/beans/encoder/ReportingScannerState.java \\\n+classpath/gnu/java/beans/encoder/Root.java \\\n+classpath/gnu/java/beans/encoder/ScanEngine.java \\\n+classpath/gnu/java/beans/encoder/ScannerState.java \\\n+classpath/gnu/java/beans/encoder/StAXWriter.java \\\n+classpath/gnu/java/beans/encoder/Writer.java \\\n+classpath/gnu/java/beans/encoder/elements/ArrayInstantiation.java \\\n+classpath/gnu/java/beans/encoder/elements/Array_Get.java \\\n+classpath/gnu/java/beans/encoder/elements/Array_Set.java \\\n+classpath/gnu/java/beans/encoder/elements/ClassResolution.java \\\n+classpath/gnu/java/beans/encoder/elements/Element.java \\\n+classpath/gnu/java/beans/encoder/elements/List_Get.java \\\n+classpath/gnu/java/beans/encoder/elements/List_Set.java \\\n+classpath/gnu/java/beans/encoder/elements/MethodInvocation.java \\\n+classpath/gnu/java/beans/encoder/elements/NullObject.java \\\n+classpath/gnu/java/beans/encoder/elements/ObjectInstantiation.java \\\n+classpath/gnu/java/beans/encoder/elements/ObjectReference.java \\\n+classpath/gnu/java/beans/encoder/elements/PrimitiveInstantiation.java \\\n+classpath/gnu/java/beans/encoder/elements/StaticFieldAccess.java \\\n+classpath/gnu/java/beans/encoder/elements/StaticMethodInvocation.java \\\n+classpath/gnu/java/beans/encoder/elements/StringReference.java\n \n gnu_java_io_source_files = \\\n classpath/gnu/java/io/ASN1ParsingException.java \\\n@@ -1885,7 +1917,8 @@ classpath/gnu/java/text/WordBreakIterator.java\n gnu_java_text_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_text_source_files)))\n gnu_java_util_source_files = \\\n classpath/gnu/java/util/DoubleEnumeration.java \\\n-classpath/gnu/java/util/EmptyEnumeration.java\n+classpath/gnu/java/util/EmptyEnumeration.java \\\n+classpath/gnu/java/util/WeakIdentityHashMap.java\n \n gnu_java_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_util_source_files)))\n gnu_java_util_prefs_source_files = \\\n@@ -2005,7 +2038,6 @@ classpath/gnu/regexp/UncheckedRE.java\n \n gnu_regexp_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_regexp_source_files)))\n gnu_xml_source_files = \\\n-classpath/gnu/xml/aelfred2/ContentHandler2.java \\\n classpath/gnu/xml/aelfred2/JAXPFactory.java \\\n classpath/gnu/xml/aelfred2/SAXDriver.java \\\n classpath/gnu/xml/aelfred2/XmlParser.java \\\n@@ -2166,6 +2198,8 @@ classpath/gnu/xml/pipeline/WellFormednessFilter.java \\\n classpath/gnu/xml/pipeline/XIncludeFilter.java \\\n classpath/gnu/xml/pipeline/XsltFilter.java \\\n classpath/gnu/xml/stream/AttributeImpl.java \\\n+classpath/gnu/xml/stream/BufferedReader.java \\\n+classpath/gnu/xml/stream/CRLFReader.java \\\n classpath/gnu/xml/stream/CharactersImpl.java \\\n classpath/gnu/xml/stream/CommentImpl.java \\\n classpath/gnu/xml/stream/DTDImpl.java \\\n@@ -2180,16 +2214,21 @@ classpath/gnu/xml/stream/LocationImpl.java \\\n classpath/gnu/xml/stream/NamespaceImpl.java \\\n classpath/gnu/xml/stream/NotationDeclarationImpl.java \\\n classpath/gnu/xml/stream/ProcessingInstructionImpl.java \\\n+classpath/gnu/xml/stream/SAXParser.java \\\n+classpath/gnu/xml/stream/SAXParserFactory.java \\\n classpath/gnu/xml/stream/StartDocumentImpl.java \\\n classpath/gnu/xml/stream/StartElementImpl.java \\\n classpath/gnu/xml/stream/StartEntityImpl.java \\\n+classpath/gnu/xml/stream/UnicodeReader.java \\\n+classpath/gnu/xml/stream/XIncludeFilter.java \\\n classpath/gnu/xml/stream/XMLEventAllocatorImpl.java \\\n classpath/gnu/xml/stream/XMLEventFactoryImpl.java \\\n classpath/gnu/xml/stream/XMLEventImpl.java \\\n classpath/gnu/xml/stream/XMLEventReaderImpl.java \\\n classpath/gnu/xml/stream/XMLEventWriterImpl.java \\\n classpath/gnu/xml/stream/XMLInputFactoryImpl.java \\\n classpath/gnu/xml/stream/XMLOutputFactoryImpl.java \\\n+classpath/gnu/xml/stream/XMLParser.java \\\n classpath/gnu/xml/stream/XMLStreamReaderImpl.java \\\n classpath/gnu/xml/stream/XMLStreamWriterImpl.java \\\n classpath/gnu/xml/transform/AbstractNumberNode.java \\\n@@ -2218,6 +2257,7 @@ classpath/gnu/xml/transform/Key.java \\\n classpath/gnu/xml/transform/KeyFunction.java \\\n classpath/gnu/xml/transform/LiteralNode.java \\\n classpath/gnu/xml/transform/MessageNode.java \\\n+classpath/gnu/xml/transform/NamespaceProxy.java \\\n classpath/gnu/xml/transform/NodeNumberNode.java \\\n classpath/gnu/xml/transform/NumberNode.java \\\n classpath/gnu/xml/transform/OtherwiseNode.java \\\n@@ -2226,6 +2266,7 @@ classpath/gnu/xml/transform/ProcessingInstructionNode.java \\\n classpath/gnu/xml/transform/SAXSerializer.java \\\n classpath/gnu/xml/transform/SortKey.java \\\n classpath/gnu/xml/transform/StreamSerializer.java \\\n+classpath/gnu/xml/transform/StrippingInstruction.java \\\n classpath/gnu/xml/transform/Stylesheet.java \\\n classpath/gnu/xml/transform/SystemPropertyFunction.java \\\n classpath/gnu/xml/transform/Template.java \\\n@@ -2686,17 +2727,21 @@ classpath/java/beans/BeanDescriptor.java \\\n classpath/java/beans/BeanInfo.java \\\n classpath/java/beans/Beans.java \\\n classpath/java/beans/Customizer.java \\\n+classpath/java/beans/DefaultPersistenceDelegate.java \\\n classpath/java/beans/DesignMode.java \\\n+classpath/java/beans/Encoder.java \\\n classpath/java/beans/EventHandler.java \\\n classpath/java/beans/EventSetDescriptor.java \\\n classpath/java/beans/ExceptionListener.java \\\n classpath/java/beans/Expression.java \\\n classpath/java/beans/FeatureDescriptor.java \\\n+classpath/java/beans/IndexedPropertyChangeEvent.java \\\n classpath/java/beans/IndexedPropertyDescriptor.java \\\n classpath/java/beans/IntrospectionException.java \\\n classpath/java/beans/Introspector.java \\\n classpath/java/beans/MethodDescriptor.java \\\n classpath/java/beans/ParameterDescriptor.java \\\n+classpath/java/beans/PersistenceDelegate.java \\\n classpath/java/beans/PropertyChangeEvent.java \\\n classpath/java/beans/PropertyChangeListener.java \\\n classpath/java/beans/PropertyChangeListenerProxy.java \\\n@@ -2712,7 +2757,8 @@ classpath/java/beans/VetoableChangeListener.java \\\n classpath/java/beans/VetoableChangeListenerProxy.java \\\n classpath/java/beans/VetoableChangeSupport.java \\\n classpath/java/beans/Visibility.java \\\n-classpath/java/beans/XMLDecoder.java\n+classpath/java/beans/XMLDecoder.java \\\n+classpath/java/beans/XMLEncoder.java\n \n java_beans_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_beans_source_files)))\n java_beans_beancontext_source_files = \\\n@@ -3091,9 +3137,9 @@ classpath/java/nio/charset/UnsupportedCharsetException.java\n \n java_nio_charset_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_nio_charset_source_files)))\n java_nio_charset_spi_source_files = \\\n-classpath/java/nio/charset/spi/CharsetProvider.java\n+java/nio/charset/spi/CharsetProvider.java\n \n-java_nio_charset_spi_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_nio_charset_spi_source_files)))\n+java_nio_charset_spi_header_files = $(patsubst %.java,%.h,$(java_nio_charset_spi_source_files))\n java_rmi_source_files = \\\n classpath/java/rmi/AccessException.java \\\n classpath/java/rmi/AlreadyBoundException.java \\\n@@ -3235,7 +3281,7 @@ classpath/java/security/PublicKey.java \\\n classpath/java/security/SecureClassLoader.java \\\n classpath/java/security/SecureRandom.java \\\n classpath/java/security/SecureRandomSpi.java \\\n-classpath/java/security/Security.java \\\n+java/security/Security.java \\\n classpath/java/security/SecurityPermission.java \\\n classpath/java/security/Signature.java \\\n classpath/java/security/SignatureException.java \\\n@@ -3372,6 +3418,7 @@ classpath/java/text/Annotation.java \\\n classpath/java/text/AttributedCharacterIterator.java \\\n classpath/java/text/AttributedString.java \\\n classpath/java/text/AttributedStringIterator.java \\\n+classpath/java/text/Bidi.java \\\n classpath/java/text/BreakIterator.java \\\n classpath/java/text/CharacterIterator.java \\\n classpath/java/text/ChoiceFormat.java \\\n@@ -3647,6 +3694,10 @@ classpath/javax/imageio/stream/ImageOutputStreamImpl.java \\\n classpath/javax/imageio/stream/MemoryCacheImageInputStream.java \\\n classpath/javax/imageio/stream/MemoryCacheImageOutputStream.java\n \n+javax_management_source_files = \\\n+classpath/javax/management/Attribute.java\n+\n+javax_management_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(javax_management_source_files)))\n javax_naming_source_files = \\\n classpath/javax/naming/AuthenticationException.java \\\n classpath/javax/naming/AuthenticationNotSupportedException.java \\\n@@ -3870,9 +3921,11 @@ classpath/javax/print/attribute/standard/JobState.java \\\n classpath/javax/print/attribute/standard/JobStateReason.java \\\n classpath/javax/print/attribute/standard/JobStateReasons.java \\\n classpath/javax/print/attribute/standard/Media.java \\\n+classpath/javax/print/attribute/standard/MediaName.java \\\n classpath/javax/print/attribute/standard/MediaPrintableArea.java \\\n classpath/javax/print/attribute/standard/MediaSize.java \\\n classpath/javax/print/attribute/standard/MediaSizeName.java \\\n+classpath/javax/print/attribute/standard/MediaTray.java \\\n classpath/javax/print/attribute/standard/MultipleDocumentHandling.java \\\n classpath/javax/print/attribute/standard/NumberOfDocuments.java \\\n classpath/javax/print/attribute/standard/NumberOfInterveningJobs.java \\\n@@ -3956,10 +4009,15 @@ classpath/javax/security/auth/callback/UnsupportedCallbackException.java\n \n javax_security_auth_callback_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(javax_security_auth_callback_source_files)))\n javax_security_auth_login_source_files = \\\n+classpath/javax/security/auth/login/AccountException.java \\\n classpath/javax/security/auth/login/AccountExpiredException.java \\\n+classpath/javax/security/auth/login/AccountLockedException.java \\\n+classpath/javax/security/auth/login/AccountNotFoundException.java \\\n classpath/javax/security/auth/login/AppConfigurationEntry.java \\\n classpath/javax/security/auth/login/Configuration.java \\\n+classpath/javax/security/auth/login/CredentialException.java \\\n classpath/javax/security/auth/login/CredentialExpiredException.java \\\n+classpath/javax/security/auth/login/CredentialNotFoundException.java \\\n classpath/javax/security/auth/login/FailedLoginException.java \\\n classpath/javax/security/auth/login/LoginContext.java \\\n classpath/javax/security/auth/login/LoginException.java \\\n@@ -4348,6 +4406,7 @@ classpath/javax/swing/plaf/basic/BasicEditorPaneUI.java \\\n classpath/javax/swing/plaf/basic/BasicFileChooserUI.java \\\n classpath/javax/swing/plaf/basic/BasicFormattedTextFieldUI.java \\\n classpath/javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n+classpath/javax/swing/plaf/basic/BasicHTML.java \\\n classpath/javax/swing/plaf/basic/BasicIconFactory.java \\\n classpath/javax/swing/plaf/basic/BasicInternalFrameTitlePane.java \\\n classpath/javax/swing/plaf/basic/BasicInternalFrameUI.java \\\n@@ -4492,6 +4551,7 @@ classpath/javax/swing/text/DateFormatter.java \\\n classpath/javax/swing/text/DefaultCaret.java \\\n classpath/javax/swing/text/DefaultEditorKit.java \\\n classpath/javax/swing/text/DefaultFormatter.java \\\n+classpath/javax/swing/text/DefaultFormatterFactory.java \\\n classpath/javax/swing/text/DefaultHighlighter.java \\\n classpath/javax/swing/text/DefaultStyledDocument.java \\\n classpath/javax/swing/text/DefaultTextUI.java \\\n@@ -4512,8 +4572,10 @@ classpath/javax/swing/text/Keymap.java \\\n classpath/javax/swing/text/LabelView.java \\\n classpath/javax/swing/text/LayeredHighlighter.java \\\n classpath/javax/swing/text/LayoutQueue.java \\\n+classpath/javax/swing/text/MaskFormatter.java \\\n classpath/javax/swing/text/MutableAttributeSet.java \\\n classpath/javax/swing/text/NavigationFilter.java \\\n+classpath/javax/swing/text/NumberFormatter.java \\\n classpath/javax/swing/text/ParagraphView.java \\\n classpath/javax/swing/text/PasswordView.java \\\n classpath/javax/swing/text/PlainDocument.java \\\n@@ -4531,6 +4593,7 @@ classpath/javax/swing/text/TabExpander.java \\\n classpath/javax/swing/text/TabSet.java \\\n classpath/javax/swing/text/TabStop.java \\\n classpath/javax/swing/text/TabableView.java \\\n+classpath/javax/swing/text/TableView.java \\\n classpath/javax/swing/text/TextAction.java \\\n classpath/javax/swing/text/Utilities.java \\\n classpath/javax/swing/text/View.java \\\n@@ -4539,11 +4602,14 @@ classpath/javax/swing/text/WrappedPlainView.java\n \n javax_swing_text_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(javax_swing_text_source_files)))\n javax_swing_text_html_source_files = \\\n+classpath/javax/swing/text/html/BlockView.java \\\n classpath/javax/swing/text/html/CSS.java \\\n+classpath/javax/swing/text/html/CSSParser.java \\\n classpath/javax/swing/text/html/HTML.java \\\n classpath/javax/swing/text/html/HTMLDocument.java \\\n classpath/javax/swing/text/html/HTMLEditorKit.java \\\n-classpath/javax/swing/text/html/HTMLFrameHyperlinkEvent.java\n+classpath/javax/swing/text/html/HTMLFrameHyperlinkEvent.java \\\n+classpath/javax/swing/text/html/StyleSheet.java\n \n javax_swing_text_html_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(javax_swing_text_html_source_files)))\n javax_swing_text_html_parser_source_files = \\\n@@ -5558,6 +5624,7 @@ all_packages_source_files = \\\n   javax/crypto.list \\\n   javax/crypto/interfaces.list \\\n   javax/crypto/spec.list \\\n+  javax/management.list \\\n   javax/naming.list \\\n   javax/naming/directory.list \\\n   javax/naming/event.list \\\n@@ -5711,6 +5778,7 @@ ordinary_header_files = \\\n   $(javax_crypto_header_files) \\\n   $(javax_crypto_interfaces_header_files) \\\n   $(javax_crypto_spec_header_files) \\\n+  $(javax_management_header_files) \\\n   $(javax_naming_header_files) \\\n   $(javax_naming_directory_header_files) \\\n   $(javax_naming_event_header_files) \\\n@@ -8705,6 +8773,16 @@ javax-imageio.lo: $(javax_imageio_source_files)\n \t$(LTGCJCOMPILE) -fjni -findirect-dispatch -c -o javax-imageio.lo @javax-imageio.list\n \t@rm -f javax-imageio.list\n \n+javax/management.list: $(javax_management_source_files)\n+\t@$(mkinstalldirs) $(dir $@)\n+\t@for file in $(javax_management_source_files); do \\\n+\t  if test -f $(srcdir)/$$file; then \\\n+\t    echo $(srcdir)/$$file; \\\n+\t  else echo $$file; fi; \\\n+\tdone > javax/management.list\n+\n+-include javax/management.deps\n+\n javax/naming.list: $(javax_naming_source_files)\n \t@$(mkinstalldirs) $(dir $@)\n \t@for file in $(javax_naming_source_files); do \\"}, {"sha": "a6051b111c31b0f07ac981c0e1c084892934bbfa", "filename": "libjava/classpath/.externalToolBuilders/Autogen.launch", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,11 +1,2 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<launchConfiguration type=\"org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType\">\n-<booleanAttribute key=\"org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND\" value=\"false\"/>\n-<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS\" value=\"./autogen.sh\"/>\n-<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS\" value=\"full,incremental,\"/>\n-<stringAttribute key=\"org.eclipse.debug.core.ATTR_REFRESH_SCOPE\" value=\"${project}\"/>\n-<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY\" value=\"${build_project}\"/>\n-<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_LOCATION\" value=\"/bin/sh\"/>\n-<booleanAttribute key=\"org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED\" value=\"true\"/>\n-<booleanAttribute key=\"org.eclipse.debug.core.appendEnvironmentVariables\" value=\"true\"/>\n-</launchConfiguration>\n+<?xml version='1.0'?>\n+<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.debug.core.ATTR_REFRESH_SCOPE' value='${project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,auto,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/external/sax/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/external/w3c_dom/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/java.net/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/java-nio/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/midi-dssi/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/vmi/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/java.util/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/target/generic/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/lib/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/fdlibm/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/target/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/target/Linux/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/examples/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jawt/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/gtk-peer/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/classpath/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/midi-alsa/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/java.lang.reflect/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/java.io/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/external/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/xmlj/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/compat/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/qt-peer/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/vm/reference/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/java-util/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/test/gnu.java.lang.reflect/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/configure.ac&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/compat/java.net/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/include/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/java-lang/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/java-io/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/doc/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/gnu/test/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/doc/api/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/testsuite/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/java-net/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/vm/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native/jni/Makefile.am&quot; type=&quot;1&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='/bin/sh'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_BUILDER_ENABLED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='./autogen.sh'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file"}, {"sha": "0c8481719eb0cd4acb1881b57daf601f0b9799dd", "filename": "libjava/classpath/.externalToolBuilders/ClasspathHeaders.launch", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,2 @@\n+<?xml version='1.0'?>\n+<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,auto,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/include/Makefile&quot; type=&quot;1&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='${system_path:make}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='-C ${build_project}/include CLASSDIR=install/share/classpath USER_CLASSLIB=../install/share/classpath all install'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file"}, {"sha": "e58a58b3a534ffa8d914cb825dee8456abb94ac8", "filename": "libjava/classpath/.externalToolBuilders/ClasspathJar.launch", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<launchConfiguration type=\"org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType\">\n+<booleanAttribute key=\"org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND\" value=\"true\"/>\n+<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE\" value=\"${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/install/share/classpath&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}\"/>\n+<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS\" value=\"-cf glibj.zip META-INF java gnu org javax vm\"/>\n+<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS\" value=\"full,incremental,auto,\"/>\n+<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY\" value=\"${build_project:install/share/classpath}\"/>\n+<stringAttribute key=\"org.eclipse.ui.externaltools.ATTR_LOCATION\" value=\"${system_path:jar}\"/>\n+<booleanAttribute key=\"org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED\" value=\"true\"/>\n+<booleanAttribute key=\"org.eclipse.debug.core.appendEnvironmentVariables\" value=\"true\"/>\n+</launchConfiguration>"}, {"sha": "c6a6b9f06a950822d2a9d3715c8f6f8a4e8dacd8", "filename": "libjava/classpath/.externalToolBuilders/CompileNative.launch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,2 +1,2 @@\n <?xml version='1.0'?>\n-<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.debug.core.ATTR_REFRESH_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;working set&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='${system_path:make}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='-C ${build_project}/native all install'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file\n+<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.debug.core.ATTR_REFRESH_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;working set&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,auto,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/native&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='${system_path:make}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='-C ${build_project}/native all install'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file"}, {"sha": "96bcda0fef12715b5679ecef42614dae050c3a27", "filename": "libjava/classpath/.externalToolBuilders/Configure.launch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,2 +1,2 @@\n <?xml version='1.0'?>\n-<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.debug.core.ATTR_REFRESH_SCOPE' value='${project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='${build_project}/configure'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='--prefix=${build_project}/install'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file\n+<launchConfiguration type='org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType'><stringAttribute key='org.eclipse.debug.core.ATTR_REFRESH_SCOPE' value='${project}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS' value='full,incremental,auto,'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE' value='${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; name=&quot;workingSet&quot; editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/classpath/Makefile.in&quot; type=&quot;1&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_LOCATION' value='${build_project}/configure'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY' value='${build_project}'/><booleanAttribute key='org.eclipse.ui.externaltools.ATTR_BUILDER_ENABLED' value='true'/><stringAttribute key='org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS' value='--prefix=${build_project}/install --enable-regen-headers --enable-gtk-cairo'/><booleanAttribute key='org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND' value='false'/><booleanAttribute key='org.eclipse.debug.core.appendEnvironmentVariables' value='true'/></launchConfiguration>\n\\ No newline at end of file"}, {"sha": "31f6e3a258931e2b4a9f52faae49185f93caacef", "filename": "libjava/classpath/.project", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.project", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2F.project", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.project?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -7,7 +7,7 @@\n \t<buildSpec>\n \t\t<buildCommand>\n \t\t\t<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>\n-\t\t\t<triggers>full,incremental,</triggers>\n+\t\t\t<triggers>auto,full,incremental,</triggers>\n \t\t\t<arguments>\n \t\t\t\t<dictionary>\n \t\t\t\t\t<key>LaunchConfigHandle</key>\n@@ -17,7 +17,7 @@\n \t\t</buildCommand>\n \t\t<buildCommand>\n \t\t\t<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>\n-\t\t\t<triggers>full,incremental,</triggers>\n+\t\t\t<triggers>auto,full,incremental,</triggers>\n \t\t\t<arguments>\n \t\t\t\t<dictionary>\n \t\t\t\t\t<key>LaunchConfigHandle</key>\n@@ -37,7 +37,17 @@\n \t\t</buildCommand>\n \t\t<buildCommand>\n \t\t\t<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>\n-\t\t\t<triggers>full,incremental,</triggers>\n+\t\t\t<triggers>auto,full,incremental,</triggers>\n+\t\t\t<arguments>\n+\t\t\t\t<dictionary>\n+\t\t\t\t\t<key>LaunchConfigHandle</key>\n+\t\t\t\t\t<value>&lt;project&gt;/.externalToolBuilders/ClasspathHeaders.launch</value>\n+\t\t\t\t</dictionary>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>\n+\t\t\t<triggers>auto,full,incremental,</triggers>\n \t\t\t<arguments>\n \t\t\t\t<dictionary>\n \t\t\t\t\t<key>LaunchConfigHandle</key>\n@@ -50,6 +60,16 @@\n \t\t\t<arguments>\n \t\t\t</arguments>\n \t\t</buildCommand>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>\n+\t\t\t<triggers>auto,full,incremental,</triggers>\n+\t\t\t<arguments>\n+\t\t\t\t<dictionary>\n+\t\t\t\t\t<key>LaunchConfigHandle</key>\n+\t\t\t\t\t<value>&lt;project&gt;/.externalToolBuilders/ClasspathJar.launch</value>\n+\t\t\t\t</dictionary>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n \t</buildSpec>\n \t<natures>\n \t\t<nature>org.eclipse.jdt.core.javanature</nature>"}, {"sha": "9ffb0ea64e2a3d8e6b67517021f6971a5324740a", "filename": "libjava/classpath/AUTHORS", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FAUTHORS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FAUTHORS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FAUTHORS?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -8,15 +8,19 @@ Lillian Angel (langel@redhat.com)\n Anthony Balkissoon (abalkiss@redhat.com)\n Stuart Ballard (stuart.a.ballard@gmail.com)\n Mark Benvenuto (mcb54@columbia.edu)\n+Gary Benson (gbenson@redhat.com)\n Geoff Berry (gcb@gnu.org)\n James E. Blair (corvus@gnu.org)\n Eric Blake (ebb9@email.byu.edu)\n Sascha Brawer (brawer@acm.org)\n+Chris Burdess (dog@gnu.org)\n+David Daney (ddaney@avtrex.com)\n Nic Ferrier (nferrier@tapsellferrier.co.uk)\n Paul Fisher (rao@gnu.org)\n David Gilbert (david.gilbert@object-refinery.com)\n Anthony Green (green@redhat.com)\n Jochen Hoenicke (Jochen.Hoenicke@Informatik.Uni-Oldenburg.de)\n+Kazumitsu Ito (kaz@maczuka.gcd.org)\n Andrew John Hughes (gnu_andrew@member.fsf.org)\n Brian Jones (cbj@gnu.org)\n Roman Kennke (roman@kennke.org) \n@@ -25,8 +29,10 @@ John Keiser (jkeiser@iname.com)\n John Leuner (jewel@debian.org)\n Warren Levy (warrenl@cygnus.com)\n Sven de Marothy (sven@physto.se)\n+Casey Marshall (csm@gnu.org)\n Bryce McKinlay (bryce@waitaki.otago.ac.nz)\n Audrius Meskauskas (audriusa@Bioinformatics.org)\n+Raif S. Naffah (raif@swiftdsl.com.au)\n Aaron M. Renn (arenn@urbanophile.com)\n Andrew Selkirk (aselkirk@sympatico.ca)\n Christian Thalinger (twisti@complang.tuwien.ac.at)"}, {"sha": "2653abd43d4b69a2bbbe0b4d41a83772b164251c", "filename": "libjava/classpath/ChangeLog", "status": "modified", "additions": 6260, "deletions": 27123, "changes": 33383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "45ad84db66fe5cc89150766738e05dd7bf37321d", "filename": "libjava/classpath/ChangeLog-2005", "status": "added", "additions": 31069, "deletions": 0, "changes": 31069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog-2005", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog-2005", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2005?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "7ba6136833a2e15e4f361aceaf603d8aafa84569", "filename": "libjava/classpath/ChangeLog.gcj", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,3 +1,13 @@\n+2006-01-16  Mark Wielaard  <mark@klomp.org>\n+\n+\t* native/fdlibm/namespace.h: Empty for gcj.\n+\n+2006-01-14  Anthony Green  <green@redhat.com>\n+\n+\t* java/net/ServerSocket.java (accept): Remove bogus\n+\tsecurity check.\n+\t(implAccept): Add FIXME comment.\n+\n 2006-01-06  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/23499:"}, {"sha": "3e532a05ff68f65dd1161d85cb6784e6ad897683", "filename": "libjava/classpath/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FMakefile.am?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -10,7 +10,7 @@ ACLOCAL_AMFLAGS = -I m4 -I ../.. -I ../../config\n native: lib\n \n EXTRA_DIST = HACKING BUGS THANKYOU mauve-classpath LICENSE \\\n-             ChangeLog-2003 ChangeLog-2004 \\\n+             ChangeLog-2003 ChangeLog-2004 ChangeLog-2005 \\\n              ChangeLog.gnujaxp.1 ChangeLog.gnujaxp.2 ChangeLog.libxmlj \\\n \t     autogen.sh\n "}, {"sha": "565fa5b0a960520bd0839a2e011b95517dbf957d", "filename": "libjava/classpath/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -46,10 +46,11 @@ subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n@@ -165,6 +166,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n@@ -275,7 +277,7 @@ SUBDIRS = lib doc external include native resource scripts $(EXAMPLESDIR)\n DIST_SUBDIRS = lib doc external include native resource scripts examples\n ACLOCAL_AMFLAGS = -I m4 -I ../.. -I ../../config\n EXTRA_DIST = HACKING BUGS THANKYOU mauve-classpath LICENSE \\\n-             ChangeLog-2003 ChangeLog-2004 \\\n+             ChangeLog-2003 ChangeLog-2004 ChangeLog-2005 \\\n              ChangeLog.gnujaxp.1 ChangeLog.gnujaxp.2 ChangeLog.libxmlj \\\n \t     autogen.sh\n "}, {"sha": "bbf1fdc11ac6bf7744972d32ae39c553de8fc394", "filename": "libjava/classpath/NEWS", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FNEWS?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,10 +1,47 @@\n-New in release 0.20\n+New in release 0.20 (Jan 13, 2006)\n+\n+* New StAX pull parser and SAX-over-StAX driver. Lots of DOM, SAX/StAX,\n+  XPath and XSLT improvements.  Support for XInclude and XML Base added.\n+  Conformance is now regularly tested against various test-suites at\n+  http://builder.classpath.org/xml/ See also doc/README.jaxp.\n+\n+* Full beans XMLEncoder implementation.\n+\n+* javax.sound.sampled implementation.\n+\n+* javax.print.attribute and javax.print.event implementated.\n+\n+* Lots of new datatransfer, print swing and swing.text work and optimization.\n+\n+* Additional 1.5 support. Including new (separate) generic branch release.\n+\n+* SecurityManager cleanups and start of review of all Permission checks\n+  (includes adding lots of new checks to the Mauve test-suite).\n+\n+* Buildable on cygwin.\n+\n+* Fully buildable as \"in-workspace\" library-plus-vm inside (native) Eclipse\n+  see http://developer.classpath.org/mediation/ClasspathHackingWithEclipse\n+\n+* Full example that shows a real world CORBA and Free Swing implementation.\n+  See examples/gnu/classpath/examples/CORBA/swing/README.html\n+\n+* A list of bug fixes can be found at:\n+http://gcc.gnu.org/bugzilla/buglist.cgi?product=classpath&target_milestone=0.20\n \n Runtime interface changes:\n \n * New method VMStackWalker.getClassLoader() was added to avoid an infinite\n   loop between getCallingClassLoader() and Class.getClassLoader().\n \n+* The included fdlibm implementation has seen several cleanups to handle\n+  new architectures and namespacing issues (in particular for ppc, darwin\n+  and non-C99 compilers). Please double check any arithmetic test against\n+  new platforms/runtimes.\n+\n+* The gnu.java.net.Plain[Datagram]Socket implementations have been\n+  turned into VM reference classes with JNI/Posix implementations.\n+\n New in release 0.19 (Nov 2, 2005)\n \n * The Swing RepaintManager has been reworked for more efficient painting,"}, {"sha": "f0a3d72af58a92b6120fd6ed77b635195bfeca13", "filename": "libjava/classpath/aclocal.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Faclocal.m4?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1090,6 +1090,7 @@ m4_include([../../libtool.m4])\n m4_include([m4/acattribute.m4])\n m4_include([m4/accross.m4])\n m4_include([m4/acinclude.m4])\n+m4_include([m4/ax_create_stdint_h.m4])\n m4_include([m4/iconv.m4])\n m4_include([m4/lib-ld.m4])\n m4_include([m4/lib-link.m4])"}, {"sha": "52c01be4c86d5bd9ac02d0c2506a2cbe7a742bd6", "filename": "libjava/classpath/config.guess", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfig.guess", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfig.guess", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfig.guess?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -3,7 +3,7 @@\n #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n #   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n-timestamp='2005-07-08'\n+timestamp='2005-11-11'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -779,7 +779,7 @@ EOF\n     i*:PW*:*)\n \techo ${UNAME_MACHINE}-pc-pw32\n \texit ;;\n-    x86:Interix*:[34]*)\n+    x86:Interix*:[345]*)\n \techo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\\..*//'\n \texit ;;\n     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)\n@@ -794,7 +794,7 @@ EOF\n     i*:UWIN*:*)\n \techo ${UNAME_MACHINE}-pc-uwin\n \texit ;;\n-    amd64:CYGWIN*:*:*)\n+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n \techo x86_64-unknown-cygwin\n \texit ;;\n     p*:CYGWIN*:*)\n@@ -873,6 +873,9 @@ EOF\n \teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`\n \ttest x\"${CPU}\" != x && { echo \"${CPU}-unknown-linux-gnu\"; exit; }\n \t;;\n+    or32:Linux:*:*)\n+\techo or32-unknown-linux-gnu\n+\texit ;;\n     ppc:Linux:*:*)\n \techo powerpc-unknown-linux-gnu\n \texit ;;\n@@ -1182,7 +1185,6 @@ EOF\n     *:Darwin:*:*)\n \tUNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown\n \tcase $UNAME_PROCESSOR in\n-\t    *86) UNAME_PROCESSOR=i686 ;;\n \t    unknown) UNAME_PROCESSOR=powerpc ;;\n \tesac\n \techo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}"}, {"sha": "eb6b3eb89ce18575987f142778a6d0ac087e5a03", "filename": "libjava/classpath/config.sub", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfig.sub?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -3,7 +3,7 @@\n #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n #   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n-timestamp='2005-07-08'\n+timestamp='2005-12-06'\n \n # This file is (in principle) common to ALL GNU software.\n # The presence of a machine in this file suggests that SOME GNU software\n@@ -171,6 +171,10 @@ case $os in\n \t-hiux*)\n \t\tos=-hiuxwe2\n \t\t;;\n+\t-sco6)\n+\t\tos=-sco5v6\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n \t-sco5)\n \t\tos=-sco3.2v5\n \t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n@@ -187,6 +191,10 @@ case $os in\n \t\t# Don't forget version if it is 3.2v4 or newer.\n \t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n \t\t;;\n+\t-sco5v6*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n \t-sco*)\n \t\tos=-sco3.2v2\n \t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n@@ -257,7 +265,7 @@ case $basic_machine in\n \t| mipsisa64sr71k | mipsisa64sr71kel \\\n \t| mipstx39 | mipstx39el \\\n \t| mn10200 | mn10300 \\\n-\t| ms1 \\\n+\t| mt \\\n \t| msp430 \\\n \t| ns16k | ns32k \\\n \t| or32 \\\n@@ -287,6 +295,9 @@ case $basic_machine in\n \tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n \t\t;;\n \n+        ms1)\n+\t    basic_machine=mt-unknown\n+\t    ;;\n \t# We use `pc' rather than `unknown'\n \t# because (1) that's what they normally are, and\n \t# (2) the word \"unknown\" tends to confuse beginning users.\n@@ -336,7 +347,7 @@ case $basic_machine in\n \t| mipsisa64sr71k-* | mipsisa64sr71kel-* \\\n \t| mipstx39-* | mipstx39el-* \\\n \t| mmix-* \\\n-\t| ms1-* \\\n+\t| mt-* \\\n \t| msp430-* \\\n \t| none-* | np1-* | ns16k-* | ns32k-* \\\n \t| orion-* \\\n@@ -696,6 +707,9 @@ case $basic_machine in\n \t\tbasic_machine=i386-pc\n \t\tos=-msdos\n \t\t;;\n+\tms1-*)\n+\t        basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`\n+\t\t;;\n \tmvs)\n \t\tbasic_machine=i370-ibm\n \t\tos=-mvs"}, {"sha": "a07c29846eea68dc81934b34bd5b47f7ab9bea41", "filename": "libjava/classpath/configure", "status": "modified", "additions": 3538, "deletions": 250, "changes": 3788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d9e442c15e4aacea0f144de0e40b721b40ebc714", "filename": "libjava/classpath/configure.ac", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure.ac?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -6,7 +6,7 @@ dnl -----------------------------------------------------------\n dnl define([AC_CACHE_LOAD], )dnl\n dnl define([AC_CACHE_SAVE], )dnl\n \n-AC_INIT([GNU Classpath],[0.20-pre],[classpath@gnu.org],[classpath])\n+AC_INIT([GNU Classpath],[0.20],[classpath@gnu.org],[classpath])\n AC_CONFIG_SRCDIR(java/lang/System.java)\n \n AC_CANONICAL_TARGET\n@@ -274,7 +274,8 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n \t\t  localtime_r \\\n \t\t  strerror_r \\\n                   fcntl \\\n-\t\t  mmap munmap mincore msync madvise getpagesize sysconf])\n+\t\t  mmap munmap mincore msync madvise getpagesize sysconf \\\n+\t\t  isnan])\n \n   AC_HEADER_TIME\n   AC_STRUCT_TM\n@@ -370,7 +371,7 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n \n   dnl Check for AWT related Qt4\n   if test \"x${COMPILE_QT_PEER}\" = xyes; then\n-    PKG_CHECK_MODULES(QT, QtGui >= 4.0.1, HAVE_QT4=\"yes\", HAVE_QT4=\"no\")\n+    PKG_CHECK_MODULES(QT, QtCore QtGui >= 4.1.0, HAVE_QT4=\"yes\", HAVE_QT4=\"no\")\n     if test \"x$HAVE_QT4\" = \"xyes\"; then\n       dnl Check needed because in some cases the QtGui includedir\n       dnl doesn't contain the subsystem dir.\n@@ -560,6 +561,8 @@ AC_ARG_ENABLE([portable-native-sync],\n               esac],\n               [])\n \n+AX_CREATE_STDINT_H([include/config-int.h])\n+\n dnl -----------------------------------------------------------\n dnl output files\n dnl -----------------------------------------------------------"}, {"sha": "77e60a9683ecb8e01a19e7a4e6af141cc3c3124d", "filename": "libjava/classpath/doc/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -41,10 +41,11 @@ DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in texinfo.tex\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -149,6 +150,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@"}, {"sha": "55a1df52ff1f96715fd146a16925b29e2f306134", "filename": "libjava/classpath/doc/README.jaxp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -17,7 +17,7 @@ PACKAGES\n . gnu.xml.xpath.* ... JAXP XPath implementation\n . gnu.xml.transform.* ... JAXP XSL transformer implementation\n . gnu.xml.pipeline.* ... SAX2 event pipeline support\n-. gnu.xml.stream.* ... StAX pull parser implementation\n+. gnu.xml.stream.* ... StAX pull parser and SAX-over-StAX driver\n . gnu.xml.util.* ... various XML utility classes\n . gnu.xml.libxmlj.dom.* ... libxmlj DOM Level 3 Core and XPath\n . gnu.xml.libxmlj.sax.* ... libxmlj SAX parser\n@@ -139,6 +139,9 @@ To enable the various GNU JAXP factories, set the following system properties\n    -Djavax.xml.stream.XMLInputFactory=gnu.xml.stream.XMLInputFactoryImpl\n    -Djavax.xml.stream.XMLOutputFactory=gnu.xml.stream.XMLOutputFactoryImpl\n \n+  GNU SAX-over-StAX:\n+   -Djavax.xml.parsers.SAXParserFactory=gnu.xml.stream.SAXParserFactory\n+\n   libxmlj SAX:\n    -Djavax.xml.parsers.SAXParserFactory=gnu.xml.libxmlj.sax.GnomeSAXParserFactory\n "}, {"sha": "e2e0a1a115ea7e5dcc08308102640f6e63f068d9", "filename": "libjava/classpath/doc/api/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -42,10 +42,11 @@ DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -142,6 +143,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@"}, {"sha": "34b1099fdc482996afc5dacdc3d5d79805a0bb75", "filename": "libjava/classpath/doc/hacking.texinfo", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fhacking.texinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fhacking.texinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fhacking.texinfo?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -83,6 +83,11 @@ Programming Standards\n \n Working on the code, Working with others\n \n+* Branches::                    \n+* Writing ChangeLogs::          \n+\n+Working with branches\n+\n * Writing ChangeLogs::          \n \n Programming Goals\n@@ -493,7 +498,7 @@ The following lists how code is formatted (and some other code\n conventions):\n \n \n-@itemize\n+@itemize @bullet\n \n @item\n Java source files in GNU Classpath are encoded using UTF-8.  However,\n@@ -689,7 +694,7 @@ fail to compile the offending source code.\n \n Some things are the same as in the normal GNU Coding Standards:\n \n-@itemize\n+@itemize @bullet\n \n @item\n Unnecessary braces can be removed, one line after an if, for, while as\n@@ -806,11 +811,71 @@ But don't just ignore the rules!  Other hackers depend on them being\n followed to be the most productive they can be (given the above\n constraints).\n \n+@menu\n+* Branches::                    \n+* Writing ChangeLogs::          \n+@end menu\n+\n+@node Branches, Writing ChangeLogs, Hacking Code, Hacking Code\n+@comment node-name, next, previous, up\n+@section Working with branches\n+\n+Sometimes it is necessary to create branch of the source for doing new\n+work that is disruptive to the other hackers, or that needs new\n+language or libraries not yet (easily) available.\n+\n+After discussing the need for a branch on the main mailinglist with\n+the other hackers explaining the need of a branch and suggestion of\n+the particular branch rules (what will be done on the branch, who will\n+work on it, will there be different commit guidelines then for the\n+mainline trunk and when is the branch estimated to be finished and\n+merged back into the trunk) every GNU Classpath hacker with commit\n+access should feel free to create a branch. There are however a couple\n+of rules that every branch should follow:\n+\n+@itemize @bullet\n+\n+@item All branches ought to be documented in the developer wiki at\n+@uref{http://developer.classpath.org/mediation/ClasspathBranches}, so\n+we can know which are live, who owns them, and when they die.\n+\n+@item Some rules can be changed on a branch.  In particular the branch\n+maintainer can change the review requirements, and the requirement of\n+keeping things building, testing, etc, can also be lifted.  (These\n+should be documented along with the branch name and owner if they\n+differ from the trunk.)\n+\n+@item Requirements for patch email to classpath-patches and for paperwork\n+@strong{cannot} be lifted. See @ref{Requirements}.\n+\n+@item A branch should not be seen as ``private'' or\n+``may be completely broken''. It should be as much as possible\n+something that you work on with a team (and if there is no team - yet\n+- then there is nothing as bad as having a completely broken build to\n+get others to help out). There can of course be occasional breakage, but\n+it should be planned and explained. And you can certainly have a rule\n+like ``please ask me before committing to this branch''.\n+\n+@item Merges from the trunk to a branch are at the discretion of the\n+branch maintainer.\n+\n+@item A merge from a branch to the trunk is treated like any other patch.\n+In particular, it has to go through review, it must satisfy all the\n+trunk requirements (build, regression test, documentation).\n+\n+@item There may be additional timing requirements on merging a branch to\n+the trunk depending on the release schedule, etc.  For instance we may\n+not want to do a branch merge just before a release.\n+\n+@end itemize\n+\n+If any of these rules are unclear please discuss on the list first.\n+\n @menu\n * Writing ChangeLogs::          \n @end menu\n \n-@node Writing ChangeLogs,  , Hacking Code, Hacking Code\n+@node Writing ChangeLogs,  , Branches, Hacking Code\n @comment node-name, next, previous, up\n @section Documenting what changed when with ChangeLog entries\n \n@@ -828,7 +893,7 @@ A good ChangeLog entry guideline can be found in the Guile Manual at\n Here are some example to explain what should or shouldn't be in a\n ChangeLog entry (and the corresponding commit message):\n \n-@itemize\n+@itemize @bullet\n \n @item\n The first line of a ChangeLog entry should be:"}, {"sha": "fa5f747ffeae441e9d175f3e90f6d13754e18012", "filename": "libjava/classpath/doc/vmintegration.texinfo", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fvmintegration.texinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fvmintegration.texinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fvmintegration.texinfo?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -226,6 +226,7 @@ become operable.\n * java.lang.VMRuntime::\n * java.lang.VMString::\n * java.lang.VMThread::\n+* java.lang.VMInstrumentationImpl::\n @end menu\n \n @node java.lang.VMClass, java.lang.VMObject ,java.lang,java.lang\n@@ -607,7 +608,7 @@ A new mapping is created for each new string being @code{intern}ed.\n A VM may implement this differently by implementing this method,\n which is @code{static} and the only one in @code{VMString}.\n \n-@node java.lang.VMThread,, java.lang.VMString, java.lang\n+@node java.lang.VMThread,java.lang.VMInstrumentationImpl, java.lang.VMString, java.lang\n @subsection @code{java.lang.VMThread}\n \n @code{VMThread} provides the link between Java's threads and the platform\n@@ -683,6 +684,45 @@ having returned true, and is thus deprecated as a result.\n @end itemize\n @end itemize\n \n+@node java.lang.VMInstrumentationImpl,, java.lang.VMThread, java.lang\n+@subsection @code{java.lang.VMInstrumentationImpl}\n+\n+The @code{java.lang.VMInstrumentationImpl} and\n+@code{java.lang.InstrumentationImpl} provides an implementation of the\n+@code{java.lang.instrument.Instrument} interface. This interface is for java\n+1.5 and is only in the generics branch.\n+A @code{InstrumentationImpl} object should be given to any agent\n+given in the command line (see the @code{java.lang.instrument} package\n+documentation). A VM has to implement the static native methods of the\n+@code{VMInstrumentationImpl} class.\n+\n+@itemize @bullet\n+@item @code{isRedefineClassesSupported()} -- Returns true if the JVM supports\n+class redefinition.\n+@item @code{redefineClasses()} -- Gives a set of classes with new bytecodes.\n+The VM must redefine the classes by reading the new bytecodes.\n+@item @code{getAllLoadedClass()} -- Returns an array of all loaded classes.\n+@item @code{getInitiatedClass()} -- Returns an array of all classes loaded\n+by a specific class loader.\n+@item @code{getObjectSize()} -- Gives the size of an object.\n+@end itemize\n+\n+When agents are defined, the VM has to call transformers of the\n+@code{InstrumentImpl} object each time a class is loaded, eg a call to\n+@code{VMClassLoader.defineClass}. The @code{InstrumentationImpl} class defines\n+a method that has to be called before reading a class file in the VM.\n+\n+@itemize @bullet\n+@item @code{callTransformers} -- Calls each transformer registered to\n+the @code{InstrumentationImpl} object and returns a new bytecode file.\n+@end itemize\n+\n+No default implementation is provided in gnu classpath for the\n+@code{VMInstrumentationImpl} methods. A default implementation will perhaps\n+be written, but it might break the @code{ClassLoader/VMClassLoader} interface\n+for calling the @code{InstrumentationImpl.callTransformers} when a class byte\n+code is defined with @code{ClassLoader.defineClass}.\n+\n @node gnu.classpath, java.util, java.lang, Classpath Hooks\n @section @code{gnu.classpath}\n "}, {"sha": "7d9514bdf9d60dca51bf0a197748fb5c7aa7022a", "filename": "libjava/classpath/doc/www.gnu.org/events/events.wml", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Fevents.wml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Fevents.wml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Fevents.wml?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -9,18 +9,21 @@\n <boxitem>\n <strong>Upcoming Events:</strong><br>\n <ul>\n-<li>[1-5 Aug 2005] <a href=\"http://conferences.oreillynet.com/os2005/\">OSCON</a>, Portland, Oregon - USA\n-<ul>\n-<li><a href=\"http://conferences.oreillynet.com/cs/os2005/view/e_sess/6730\">The State of Free JVMs</a>\n-Tom Tromey</li>\n-</ul>\n+<li>[25+26 Feb. 2006] FOSDEM'06 in Brussels, Belgium. [<createlink name=\"GNU Classpath and friends\" url=\"events/fosdem06.html\">]</li>\n </ul>\n </boxitem>\n \n <boxitem>\n <strong>Past Events:</strong><br>\n <ul>\n \n+<li>\n+[1-5 Aug 2005] <a href=\"http://conferences.oreillynet.com/os2005/\">OSCON</a>, Portland, Oregon - USA\n+<ul>\n+<li><a href=\"http://conferences.oreillynet.com/cs/os2005/view/e_sess/6730\">The State of Free JVMs</a>\n+Tom Tromey</li>\n+</ul>\n+\n <li>\n [29-31 May 2005] <a href=\"http://2005.guadec.org/\">Guadec</a>, Stuttgart - Germany\n <ul>"}, {"sha": "2623ef06630ca2e1be1e8ee3540d38d34b00176d", "filename": "libjava/classpath/doc/www.gnu.org/events/fosdem06.wml", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Ffosdem06.wml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Ffosdem06.wml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fevents%2Ffosdem06.wml?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,191 @@\n+#!wml --include=..\n+\n+#include \"include/layout.wml\"\n+\n+<set-var last-modified-author=\"mjw\">\n+<subject \"GNU Classpath and friends @ Fosdem 2006\">\n+\n+<box>\n+<boxitem>\n+<h2>GNU Classpath and friends meeting during Fosdem 2006</h2>\n+\n+<i>Fosdem, Saturday/Sunday 25/26 February 2006, Brussels, Belgium</i>\n+<p>\n+The various free software library, runtimes, compiler and tool\n+projects around GNU Classpath will meet in Brussel to discuss what has\n+happened in the last year in the Free Software community and what the\n+next year will bring us during Fosdem.\n+<p>\n+The 6th edition of FOSDEM (Free and Opensource Software Developers'\n+European Meeting) will take place on February 25+26 2006 in Brussels\n+(Belgium), at the Solbosch Campus of the ULB (Free University of\n+Brussels). FOSDEM is a free and non-commercial event for the community\n+and organized by the community.\n+See <a href=\"http://www.fosdem.org/\">http://www.fosdem.org/</a>.\n+</boxitem>\n+\n+<boxitem>\n+  <h3>Saturday from 13:00 to 17:00 - \"End-User talks\"</h3>\n+\n+  <p>\n+    Presentations that show what cool stuff can be done with the Free\n+    Stack right now.\n+  </p>\n+\n+    <p>\n+    <b>Putting the 'Free' into JFreeChart</b>\n+    <i>Dave Gilbert, JFreeChart Project Leader</i>\n+      <p>\n+\tA review of the efforts to make JFreeChart work with GNU\n+\tClasspath-based runtimes, including a brief history, a demonstration\n+\tof the current state (using the java bindings for Cairo), and an\n+\toverview of the work that remains to be done.\n+      </p>\n+    </p>\n+\n+    <p>\n+    <b>Using Eclipse for GNU Classpath development</b>\n+    <i>Tom Tromey</i>\n+      <p>\n+\tLearn how to setup a fully working development environment based\n+\ton GNU Classpath in Eclipse that can be used to bootstrap the full\n+\tfree toolchain (and can be used to run Eclipse itself) in just 10\n+\tminutes.\n+      </p>\n+    </p>\n+\n+    <p>\n+    <b>Eclipse RCP and GCJ/GIJ</b>\n+    <i>Wayne Beaton</i>\n+      <p>\n+\tEclipse Rich Client Platform (RCP) is a runtime platform for\n+\tdelivering your Java applications on multiple platforms. RCP is far\n+\tmore than just a windowing toolkit; it is rich client \"middleware\"\n+\tthat provides a comprehensive framework for building and deploying\n+\tapplications that are modular, extensible, and updatable. The kinds\n+\tof applications you can build with Eclipse RCP are limited only by\n+\tyour imagination. During this talk, we will discuss how the Eclipse\n+\tRCP can be used in conjunction with the Eclipse Eco-system and\n+\tGCJ/GIJ to build high quality applications.\n+      </p>\n+    </p>\n+\n+<p>\n+</boxitem>\n+\n+<boxitem>\n+  <h3>Sunday from 09:00 to 13:00 - \"Developer talks\"</h3>\n+\n+  <p>\n+    Presentations of (core) libraries and runtimes that are in progress,\n+    made a lot of progress in the last year and are in active development.\n+  </p>\n+\n+    <p>\n+    <b>Free Swing, past, present and future</b>\n+    <i>Roman Kennke</i>\n+      <p>\n+\tAn overview of that state of Free Swing one year ago, what has been\n+\tdone in the meantime, what still must be done and which applications\n+\twork now.\n+      </p>\n+    </p>\n+\n+    <p>\n+    <b>The Free CORBA comes</b>\n+    <i>Dr Audrius Meskauskas</i>\n+      <p>\n+    If the Free world does not want to step back in the battle, we need\n+    a complete set of the Free tools for advanced communication over\n+    the network. For our CORBA implementation we needed:\n+    <p>\n+    <ol>\n+    <li> Free. No classes with restricted license.\n+    <li> Fully workable, interoperable and pass tests, recognized by\n+       the CORBA user community as serious (we needed to find a well\n+       known Free testing suite).\n+    <li> Properly commented, being ready for the long life in the Free\n+       world.\n+    <li> No pressure to use the outdated approaches.\n+       CORBA 3.0.3 and jdk 1.5.\n+    </ol>\n+    <p>\n+    To reach these goals, we have chosen for implementing a clean room\n+    implementation, using the published standard specifications only.\n+    During the recent year of the GNU Classpath development, this goal\n+    is in large degree achieved. The important directions of future\n+    development could be providing features that are outside the scope\n+    of the both CORBA standard and Sun API, but included in the near all\n+    proprietary implementations (SSH, HTTP and other bridges, get rid of\n+    rmic code generator for RMI/IIOP, fault tolerant behavior, reduced\n+    the footprint and others).\n+      </p>\n+    </p>\n+\n+    <p>\n+      <b>The JamVM runtime</b>\n+      <i>Robert Lougher</i>\n+      <p>\n+\tAn overview of the JamVM virtual machine, with comparisons to other\n+\tGNU Classpath runtimes, and a section on the VM interface.\n+      </p>\n+    </p>\n+\n+    <p>\n+    <b>Integrating Vmgen-based interpreters</b>\n+    <i>Christian Thalinger</i>\n+      <p>\n+\tVmgen is a tool for writing efficient interpreters. The Cacao\n+\truntime recently added a Vmgen based interpreter in addition to\n+\tthe JIT engine.\n+      </p>\n+    </p>\n+\n+<p>\n+<boxitem>\n+\n+<boxitem>\n+  <h3>Sunday from 14:00 to 17:30 - \"The Future\"</h3>\n+\n+   <p>\n+     Interactive technical hacker discussions on how to integrate\n+     the projects more and move forward in the next year.\n+   </p>\n+\n+    <p>\n+    <b>State of the world, beyond japi</b>\n+    <i>Mark Wielaard, GNU Classpath Maintainer</i>\n+      <p>\n+\tAfter a short overview of the various free stacks, libraries,\n+\tcompilers, tools and runtimes this session is mostly open discussion\n+\tabout what work remains to be done and how to integrate the various\n+\tefforts better. Ideas for work items welcome.\n+      </p>\n+    </p>\n+\n+<p>\n+</boxitem>\n+\n+<boxitem>\n+<b>Additional Resources:</b>\n+<ul>\n+<li><createlink name=\"Free But Shackled - The Java Trap\"\n+\turl=\"http://www.gnu.org/philosophy/java-trap.html\">\n+\t(by Richard Stallman)\n+</li>\n+<li><createlink name=\"Escaping the Java Trap: A practical road map to the Free Software and Open Source alternatives\"\n+\turl=\"http://developer.classpath.org/support/\">\n+</li>\n+</ul>\n+<p>\n+</boxitem>\n+\n+<boxitem>\n+<b>Official links:</b>\n+<ul>\n+<li><createlink name=\"FOSDEM Homepage\"\n+\turl=\"http://www.fosdem.org/\">\n+</li>\n+</ul>\n+</boxitem>\n+</box>"}, {"sha": "97c14244e656c64a2d41c33db39aa3276939f342", "filename": "libjava/classpath/doc/www.gnu.org/newsitems.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fnewsitems.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fnewsitems.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fwww.gnu.org%2Fnewsitems.txt?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,3 +1,8 @@\n+<newsitem date=\"25/26 Feb 2006\">\n+<createlink name=\"GNU Classpath and friends meeting during Fosdem 2006\"\n+            url=\"events/fosdem06.html\">\n+</newsitem>\n+\n <newsitem date=\"02 Nov 2005\">\n <createlink name=\"GNU Classpath 0.19\"\n             url=\"announce/20051102.html\">"}, {"sha": "db6cac0d6862d9a3b71708e548657d845d33625a", "filename": "libjava/classpath/examples/Makefile.am", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.am?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -53,25 +53,25 @@ install-data-local:\n \tfor file in $(ALL_EXAMPLE_FILES); do \\\n \t  f=`echo $$file | cut -c$$srcdir_cnt-`; \\\n \t  fdir=`dirname $$f`; \\\n-\t  if test ! -d $(DESTDIR)/$(pkgdatadir)/examples/$$fdir; then \\\n-\t    echo \"$(mkinstalldirs) $(DESTDIR)/$(pkgdatadir)/examples/$$fdir\"; \\\n-\t    $(mkinstalldirs) $(DESTDIR)/$(pkgdatadir)/examples/$$fdir; \\\n+\t  if test ! -d $(DESTDIR)$(pkgdatadir)/examples/$$fdir; then \\\n+\t    echo \"$(mkinstalldirs) $(DESTDIR)$(pkgdatadir)/examples/$$fdir\"; \\\n+\t    $(mkinstalldirs) $(DESTDIR)$(pkgdatadir)/examples/$$fdir; \\\n \t  fi; \\\n-\t  echo \"$(INSTALL_DATA) $$file $(DESTDIR)/$(pkgdatadir)/examples/$$f\"; \\\n-\t  $(INSTALL_DATA) $$file $(DESTDIR)/$(pkgdatadir)/examples/$$f; \\\n+\t  echo \"$(INSTALL_DATA) $$file $(DESTDIR)$(pkgdatadir)/examples/$$f\"; \\\n+\t  $(INSTALL_DATA) $$file $(DESTDIR)$(pkgdatadir)/examples/$$f; \\\n \tdone\n-\techo \"$(INSTALL_DATA) Makefile.jawt $(DESTDIR)/$(pkgdatadir)/examples/\"\n-\t$(INSTALL_DATA) Makefile.jawt $(DESTDIR)/$(pkgdatadir)/examples/\n+\techo \"$(INSTALL_DATA) Makefile.jawt $(DESTDIR)$(pkgdatadir)/examples/\"\n+\t$(INSTALL_DATA) Makefile.jawt $(DESTDIR)$(pkgdatadir)/examples/\n \n uninstall-local:\n \tsrcdir_cnt=`echo $(srcdir) | wc -c`; \\\n \tfor file in $(ALL_EXAMPLE_FILES); do \\\n \t  f=`echo $$file | cut -c$$srcdir_cnt-`; \\\n-\t  echo \"rm -f $(DESTDIR)/$(pkgdatadir)/examples/$$f\"; \\\n-\t  rm -f $(DESTDIR)/$(pkgdatadir)/examples/$$f; \\\n+\t  echo \"rm -f $(DESTDIR)$(pkgdatadir)/examples/$$f\"; \\\n+\t  rm -f $(DESTDIR)$(pkgdatadir)/examples/$$f; \\\n \tdone\n-\techo \"rm -f $(DESTDIR)/$(pkgdatadir)/examples/Makefile.jawt\"\n-\trm -f $(DESTDIR)/$(pkgdatadir)/examples/Makefile.jawt\n+\techo \"rm -f $(DESTDIR)$(pkgdatadir)/examples/Makefile.jawt\"\n+\trm -f $(DESTDIR)$(pkgdatadir)/examples/Makefile.jawt\n \n # Make sure everything is included in the distribution.\n EXTRA_DIST = README Makefile.jawt.in"}, {"sha": "f554fd7c2fc629a18aca041dafd68ea8b7ab5d3c", "filename": "libjava/classpath/examples/Makefile.in", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -43,10 +43,11 @@ DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -151,6 +152,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n@@ -491,25 +493,25 @@ install-data-local:\n \tfor file in $(ALL_EXAMPLE_FILES); do \\\n \t  f=`echo $$file | cut -c$$srcdir_cnt-`; \\\n \t  fdir=`dirname $$f`; \\\n-\t  if test ! -d $(DESTDIR)/$(pkgdatadir)/examples/$$fdir; then \\\n-\t    echo \"$(mkinstalldirs) $(DESTDIR)/$(pkgdatadir)/examples/$$fdir\"; \\\n-\t    $(mkinstalldirs) $(DESTDIR)/$(pkgdatadir)/examples/$$fdir; \\\n+\t  if test ! -d $(DESTDIR)$(pkgdatadir)/examples/$$fdir; then \\\n+\t    echo \"$(mkinstalldirs) $(DESTDIR)$(pkgdatadir)/examples/$$fdir\"; \\\n+\t    $(mkinstalldirs) $(DESTDIR)$(pkgdatadir)/examples/$$fdir; \\\n \t  fi; \\\n-\t  echo \"$(INSTALL_DATA) $$file $(DESTDIR)/$(pkgdatadir)/examples/$$f\"; \\\n-\t  $(INSTALL_DATA) $$file $(DESTDIR)/$(pkgdatadir)/examples/$$f; \\\n+\t  echo \"$(INSTALL_DATA) $$file $(DESTDIR)$(pkgdatadir)/examples/$$f\"; \\\n+\t  $(INSTALL_DATA) $$file $(DESTDIR)$(pkgdatadir)/examples/$$f; \\\n \tdone\n-\techo \"$(INSTALL_DATA) Makefile.jawt $(DESTDIR)/$(pkgdatadir)/examples/\"\n-\t$(INSTALL_DATA) Makefile.jawt $(DESTDIR)/$(pkgdatadir)/examples/\n+\techo \"$(INSTALL_DATA) Makefile.jawt $(DESTDIR)$(pkgdatadir)/examples/\"\n+\t$(INSTALL_DATA) Makefile.jawt $(DESTDIR)$(pkgdatadir)/examples/\n \n uninstall-local:\n \tsrcdir_cnt=`echo $(srcdir) | wc -c`; \\\n \tfor file in $(ALL_EXAMPLE_FILES); do \\\n \t  f=`echo $$file | cut -c$$srcdir_cnt-`; \\\n-\t  echo \"rm -f $(DESTDIR)/$(pkgdatadir)/examples/$$f\"; \\\n-\t  rm -f $(DESTDIR)/$(pkgdatadir)/examples/$$f; \\\n+\t  echo \"rm -f $(DESTDIR)$(pkgdatadir)/examples/$$f\"; \\\n+\t  rm -f $(DESTDIR)$(pkgdatadir)/examples/$$f; \\\n \tdone\n-\techo \"rm -f $(DESTDIR)/$(pkgdatadir)/examples/Makefile.jawt\"\n-\trm -f $(DESTDIR)/$(pkgdatadir)/examples/Makefile.jawt\n+\techo \"rm -f $(DESTDIR)$(pkgdatadir)/examples/Makefile.jawt\"\n+\trm -f $(DESTDIR)$(pkgdatadir)/examples/Makefile.jawt\n dist-hook:\n \tsrcdir_cnt=`echo $(srcdir) | wc -c`; \\\n \tfor file in $(ALL_EXAMPLE_FILES); do \\"}, {"sha": "d3cbe2fb0aabdff6ab9f728b5d8177b00d83bee9", "filename": "libjava/classpath/external/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -41,10 +41,11 @@ DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -149,6 +150,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@"}, {"sha": "0793c56e1ab95646ffdb30c0d76cea5c05b986b7", "filename": "libjava/classpath/external/sax/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -41,10 +41,11 @@ DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -140,6 +141,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@"}, {"sha": "2e589749ff016b79674839a65c569a0ae5868510", "filename": "libjava/classpath/external/w3c_dom/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -41,10 +41,11 @@ DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -140,6 +141,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@"}, {"sha": "70e787af15137e41f93ea1b27c18c19eeabf1066", "filename": "libjava/classpath/gnu/CORBA/Poa/AOM.java", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FAOM.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FAOM.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FAOM.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -40,6 +40,8 @@\n \n import gnu.CORBA.ByteArrayComparator;\n \n+import org.omg.CORBA.portable.Delegate;\n+import org.omg.CORBA.portable.ObjectImpl;\n import org.omg.PortableServer.Servant;\n \n import java.util.Iterator;\n@@ -66,7 +68,7 @@\n     /**\n      * Create an initialised instance.\n      */\n-    Obj(org.omg.CORBA.Object _object, byte[] _key, Servant _servant, gnuPOA _poa)\n+    Obj(gnuServantObject _object, byte[] _key, Servant _servant, gnuPOA _poa)\n     {\n       object = _object;\n       key = _key;\n@@ -77,7 +79,7 @@\n     /**\n      * The object.\n      */\n-    public final org.omg.CORBA.Object object;\n+    public final gnuServantObject object;\n \n     /**\n      * The servant, serving the given object.\n@@ -158,24 +160,47 @@ public void setDeactivated(boolean state)\n   Map objects = new TreeMap(new ByteArrayComparator());\n \n   /**\n-   * Get the record of the stored object. If the object is mapped\n-   * several times under the different keys, one of the mappings\n-   * is used.\n-   *\n+   * Get the record of the stored object. If the object is mapped several times\n+   * under the different keys, one of the mappings is used.\n+   * \n    * @param object the stored object\n-   *\n-   * @return the record about the stored object, null if\n-   * this object is not stored here.\n+   * \n+   * @return the record about the stored object, null if this object is not\n+   * stored here.\n    */\n   public Obj findObject(org.omg.CORBA.Object stored_object)\n   {\n     if (stored_object == null)\n       return null;\n \n     Map.Entry item;\n-    Iterator iter = objects.entrySet().iterator();\n+    Iterator iter;\n     Obj ref;\n \n+    if (stored_object instanceof ObjectImpl)\n+      {\n+        // If the delegate is available, search by delegate.\n+        Delegate d = ((ObjectImpl) stored_object)._get_delegate();\n+        Delegate d2;\n+\n+        if (d != null)\n+          {\n+            iter = objects.entrySet().iterator();\n+            while (iter.hasNext())\n+              {\n+                item = (Map.Entry) iter.next();\n+                ref = (Obj) item.getValue();\n+                d2 = ref.object._get_delegate();\n+\n+                if (d == d2 || (d2 != null && d2.equals(d)))\n+                  return ref;\n+              }\n+          }\n+      }\n+\n+    // For other objects (or if not possible to get the delegate),\n+    // search by .equals\n+    iter = objects.entrySet().iterator();\n     while (iter.hasNext())\n       {\n         item = (Map.Entry) iter.next();\n@@ -187,12 +212,11 @@ public Obj findObject(org.omg.CORBA.Object stored_object)\n   }\n \n   /**\n-   * Find the reference info for the given servant.\n-   * If the servant is mapped to several objects, this\n-   * returns the first found occurence.\n-   *\n+   * Find the reference info for the given servant. If the servant is mapped to\n+   * several objects, this returns the first found occurence.\n+   * \n    * @param servant a servant to find.\n-   *\n+   * \n    * @return the servant/object/POA binding or null if no such found.\n    */\n   public Obj findServant(Servant servant)\n@@ -257,7 +281,7 @@ public Obj findServant(Servant servant, boolean inactive)\n    *\n    * @return the newly created object record.\n    */\n-  public Obj add(org.omg.CORBA.Object object, Servant servant, gnuPOA poa)\n+  public Obj add(gnuServantObject object, Servant servant, gnuPOA poa)\n   {\n     return add(generateObjectKey(object), object, servant, poa);\n   }\n@@ -270,7 +294,7 @@ public Obj add(org.omg.CORBA.Object object, Servant servant, gnuPOA poa)\n    * @param servant a servant, serving the given object.\n    * @param poa the POA, where the object is connected.\n    */\n-  public Obj add(byte[] key, org.omg.CORBA.Object object, Servant servant,\n+  public Obj add(byte[] key, gnuServantObject object, Servant servant,\n                  gnuPOA poa\n                 )\n   {"}, {"sha": "460a0a6029a071cca356159e2ae0e7ace466c523", "filename": "libjava/classpath/gnu/CORBA/Poa/gnuPOA.java", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FgnuPOA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FgnuPOA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2FCORBA%2FPoa%2FgnuPOA.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1052,27 +1052,39 @@ public byte[] reference_to_id(org.omg.CORBA.Object the_Object)\n \n   /**\n    * Returns the servant that is serving this object.\n-   *\n-   * @return if the RETAIN policy applies and the object is in the Active\n-   * Object Map, the method returns the servant, associated with this object.\n+   * \n+   * @return if the RETAIN policy applies and the object is in the Active Object\n+   * Map, the method returns the servant, associated with this object.\n    * Otherwise, if the USE_DEFAULT_SERVANT policy applies, the method returns\n    * the default servant (if one was set).\n-   *\n+   * \n    * @throws ObjectNotActive if none of the conditions above are satisfied.\n    * @throws WrongAdapter if the object reference was not created with this POA.\n    * @throws WrongPolicy. This method requires either RETAIN or\n    * USE_DEFAULT_SERVANT policies and reaises the WrongPolicy if none of them\n    * apply to this POA.\n    */\n   public Servant reference_to_servant(org.omg.CORBA.Object the_Object)\n-                               throws ObjectNotActive, WrongPolicy,\n-                                      WrongAdapter\n+    throws ObjectNotActive, WrongPolicy, WrongAdapter\n   {\n     if (applies(ServantRetentionPolicyValue.RETAIN))\n       {\n         AOM.Obj ref = aom.findObject(the_Object);\n         if (ref == null)\n-          throw new WrongAdapter();\n+          {\n+            String object;\n+            if (the_Object == null)\n+              object = \"null passed\"; \n+            else if (the_Object instanceof gnuServantObject)\n+              {\n+                gnuServantObject gs = (gnuServantObject) the_Object;\n+                object = \"Wrong owner POA \" + gs.poa.the_name();\n+              }\n+            else\n+              object = \"Unknown \" + the_Object.getClass().getName();\n+\n+            throw new WrongAdapter(object + \" for '\" + the_name() + \"'\");\n+          }\n         else if (ref.isDeactiveted() || ref.servant == null)\n           {\n             if (default_servant != null)\n@@ -1092,32 +1104,30 @@ else if (default_servant != null)\n   }\n \n   /**\n-  * Returns the id of the object, served by the given servant\n-  * (assuming that the servant serves only one object).\n-  * The id is found in one of the following ways.\n-  * <ul>\n-  * <li>If the POA has both the RETAIN and the UNIQUE_ID policy and\n-  * the specified servant is active, the method return the Object Id associated\n-  * with that servant.\n-  * </li><li>\n-  * If the POA has both the RETAIN and the IMPLICIT_ACTIVATION policy and\n-  * either the POA has the MULTIPLE_ID policy or the specified servant is\n-  * inactive, the method activates the servant using a POA-generated Object Id\n-  * and the Interface Id associated with the servant, and returns that\n-  * Object Id.\n-  * </li>\n-  * <li>If the POA has the USE_DEFAULT_SERVANT policy, the servant specified\n-  * is the default servant, and the method is being invoked in the context of\n-  * executing a request on the default servant, the method returns the\n-  * ObjectId associated with the current invocation.\n-  * </li>\n-  * </ul>\n-  * @throws ServantNotActive in all cases, not listed in the list above.\n-  * @throws WrongPolicy The method requres USE_DEFAULT_SERVANT policy or\n-  * a combination of the RETAIN policy and either the UNIQUE_ID or\n-  * IMPLICIT_ACTIVATION policies and throws the WrongPolicy if these conditions\n-  * are not satisfied.\n-  */\n+   * Returns the id of the object, served by the given servant (assuming that\n+   * the servant serves only one object). The id is found in one of the\n+   * following ways.\n+   * <ul>\n+   * <li>If the POA has both the RETAIN and the UNIQUE_ID policy and the\n+   * specified servant is active, the method return the Object Id associated\n+   * with that servant. </li>\n+   * <li> If the POA has both the RETAIN and the IMPLICIT_ACTIVATION policy and\n+   * either the POA has the MULTIPLE_ID policy or the specified servant is\n+   * inactive, the method activates the servant using a POA-generated Object Id\n+   * and the Interface Id associated with the servant, and returns that Object\n+   * Id. </li>\n+   * <li>If the POA has the USE_DEFAULT_SERVANT policy, the servant specified\n+   * is the default servant, and the method is being invoked in the context of\n+   * executing a request on the default servant, the method returns the ObjectId\n+   * associated with the current invocation. </li>\n+   * </ul>\n+   * \n+   * @throws ServantNotActive in all cases, not listed in the list above.\n+   * @throws WrongPolicy The method requres USE_DEFAULT_SERVANT policy or a\n+   * combination of the RETAIN policy and either the UNIQUE_ID or\n+   * IMPLICIT_ACTIVATION policies and throws the WrongPolicy if these conditions\n+   * are not satisfied.\n+   */\n   public byte[] servant_to_id(Servant the_Servant)\n                        throws ServantNotActive, WrongPolicy\n   {"}, {"sha": "43a37de2435beb8fceb028c61124d06b89952019", "filename": "libjava/classpath/gnu/classpath/jdwp/Jdwp.java", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2FJdwp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2FJdwp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2FJdwp.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -42,6 +42,7 @@\n import gnu.classpath.jdwp.event.Event;\n import gnu.classpath.jdwp.event.EventManager;\n import gnu.classpath.jdwp.event.EventRequest;\n+import gnu.classpath.jdwp.exception.JdwpException;\n import gnu.classpath.jdwp.id.ThreadId;\n import gnu.classpath.jdwp.processor.PacketProcessor;\n import gnu.classpath.jdwp.transport.ITransport;\n@@ -206,7 +207,20 @@ public static void notify (Event event)\n \tEventManager em = EventManager.getDefault ();\n \tEventRequest request = em.getEventRequest (event);\n \tif (request != null)\n-\t  sendEvent (request, event);\n+\t  {\n+\t    try\n+\t      {\n+\t\tSystem.out.println (\"Jdwp.notify: sending event \" + event);\n+\t\tsendEvent (request, event);\n+\t\tjdwp._enforceSuspendPolicy (request.getSuspendPolicy ());\n+\t      }\n+\t    catch (Exception e)\n+\t      {\n+\t\t/* Really not much we can do. For now, just print out\n+\t\t   a warning to the user. */\n+\t\tSystem.out.println (\"Jdwp.notify: caught exception: \" + e);\n+\t      }\n+\t  }\n       }\n   }\n   \n@@ -217,32 +231,25 @@ public static void notify (Event event)\n    *\n    * @param  request  the debugger request for the event\n    * @param  event    the event to send\n+   * @throws IOException if a communications failure occurs\n    */\n   public static void sendEvent (EventRequest request, Event event)\n+      throws IOException\n   {\n     Jdwp jdwp = getDefault ();\n     if (jdwp != null)\n       {\n-\ttry\n-\t  {\n-\t    // !! May need to implement send queue?\n-\t    synchronized (jdwp._connection)\n-\t      {\n-\t\tjdwp._connection.sendEvent (request, event);\n-\t      }\n-\t    \n-\t    // Follow suspend policy\n-\t    jdwp._enforceSuspendPolicy (request.getSuspendPolicy ());\n-\t  }\n-\tcatch (IOException ie)\n+\t// !! May need to implement send queue?\n+\tsynchronized (jdwp._connection)\n \t  {\n-\t    System.out.println (\"Jdwp.notify: caught exception: \" + ie);\n+\t    jdwp._connection.sendEvent (request, event);\n \t  }\n       }\n   }\n \n   // Helper function to enforce suspend policies on event notification\n   private void _enforceSuspendPolicy (byte suspendPolicy)\n+    throws JdwpException\n   {\n     switch (suspendPolicy)\n       {"}, {"sha": "82d1d71e41e48dea537c46e8117ef27f314dde7e", "filename": "libjava/classpath/gnu/classpath/jdwp/event/EventManager.java", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2Fevent%2FEventManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2Fevent%2FEventManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fclasspath%2Fjdwp%2Fevent%2FEventManager.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -41,6 +41,7 @@\n \n import gnu.classpath.jdwp.VMVirtualMachine;\n import gnu.classpath.jdwp.exception.InvalidEventTypeException;\n+import gnu.classpath.jdwp.exception.JdwpException;\n \n import java.util.Collection;\n import java.util.Hashtable;\n@@ -133,7 +134,7 @@ private EventManager ()\n \t\t\t\t\tEventRequest.EVENT_VM_DEATH,\n \t\t\t\t\tEventRequest.SUSPEND_NONE));\n       }\n-    catch (InvalidEventTypeException e)\n+    catch (JdwpException e)\n       {\n \t// This can't happen\n       }\n@@ -187,9 +188,10 @@ public EventRequest getEventRequest (Event event)\n    *\n    * @param request  the request to monitor\n    * @throws InvalidEventTypeException for invalid event kind\n+   * @throws JdwpException for other errors involving request\n    */\n   public void requestEvent (EventRequest request)\n-    throws InvalidEventTypeException\n+    throws JdwpException\n   {\n     // Add request to request list\n     Hashtable requests;\n@@ -212,8 +214,10 @@ public void requestEvent (EventRequest request)\n    * @param  kind  the event kind\n    * @param  id    the ID of the request to delete\n    * @throws IllegalArgumentException for invalid event kind\n+   * @throws JdwpException for other errors deleting request\n    */\n   public void deleteRequest (byte kind, int id)\n+    throws JdwpException\n   {\n     Hashtable requests;\n     requests = (Hashtable) _requests.get (new Byte (kind));\n@@ -237,8 +241,10 @@ public void deleteRequest (byte kind, int id)\n    *\n    * @param  kind  the event kind\n    * @throws IllegalArgumentException for invalid event kind\n+   * @throws JdwpException for error clearing events\n    */\n   public void clearRequests (byte kind)\n+    throws JdwpException\n   {\n     Hashtable requests = (Hashtable) _requests.get (new Byte (kind));\n     if (requests == null)"}, {"sha": "8e8eecb25990410eb464f1beea5264e2b5e09e76", "filename": "libjava/classpath/gnu/java/awt/image/ImageDecoder.java", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -40,6 +40,8 @@\n import java.awt.image.ImageConsumer;\n import java.awt.image.ImageProducer;\n import java.io.ByteArrayInputStream;\n+import java.io.DataInput;\n+import java.io.EOFException;\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -55,6 +57,7 @@ public abstract class ImageDecoder implements ImageProducer\n   int offset;\n   int length;\n   InputStream input;\n+  DataInput datainput;\n \n   static\n   {\n@@ -79,6 +82,11 @@ public ImageDecoder (InputStream is)\n     this.input = is;\n   }\n \n+  public ImageDecoder (DataInput datainput)\n+  {\n+    this.datainput = datainput;\n+  }\n+\n   public ImageDecoder (byte[] imagedata, int imageoffset, int imagelength)\n   {\n     data = imagedata;\n@@ -119,6 +127,8 @@ public void startProduction (ImageConsumer ic)\n               {\n                 if (url != null)\n                   input = url.openStream();\n+\t\telse if (datainput != null)\n+\t\t  input = new DataInputStreamWrapper(datainput);\n                 else\n                   {\n                     if (filename != null)\n@@ -153,4 +163,26 @@ public void requestTopDownLeftRightResend (ImageConsumer ic)\n   }\n \n   public abstract void produce (Vector v, InputStream is) throws IOException;\n+\n+  private static class DataInputStreamWrapper extends InputStream\n+  {\n+    private final DataInput datainput;\n+\n+    DataInputStreamWrapper(DataInput datainput)\n+    {\n+      this.datainput = datainput;\n+    }\n+\n+    public int read() throws IOException\n+    {\n+      try\n+\t{\n+\t  return datainput.readByte() & 0xFF;\n+\t}\n+      catch (EOFException eofe)\n+\t{\n+\t  return -1;\n+\t}\n+    }\n+  }\n }"}, {"sha": "d7217aa7a3f7554cb958d6616d53791f888e1f9a", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphics.java", "status": "modified", "additions": 79, "deletions": 15, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -48,7 +48,6 @@\n import java.awt.Image;\n import java.awt.Rectangle;\n import java.awt.Shape;\n-import java.awt.SystemColor;\n import java.awt.image.ImageObserver;\n import java.text.AttributedCharacterIterator;\n \n@@ -81,18 +80,23 @@ public class GdkGraphics extends Graphics\n   native void initStateUnlocked (GtkComponentPeer component);\n   native void initState (int width, int height);\n   native void initFromImage (GtkImage image);\n-  native void copyState (GdkGraphics g);\n+  native void nativeCopyState (GdkGraphics g);\n+\n+  /**\n+   * A cached instance that is used by {@link #create} in order to avoid\n+   * massive allocation of graphics contexts.\n+   */\n+  GdkGraphics cached = null;\n+\n+  /**\n+   * A link to the parent context. This is used in {@link #dispose} to put\n+   * this graphics context into the cache.\n+   */\n+  GdkGraphics parent = null;\n \n   GdkGraphics (GdkGraphics g)\n   {\n-    color = g.color;\n-    xorColor = g.xorColor;\n-    font = g.font;\n-    if (font == null)\n-      font = new Font (\"Dialog\", Font.PLAIN, 12);\n-    clip = new Rectangle (g.clip);\n-    component = g.component;\n-\n+    parent = g;\n     copyState (g);\n   }\n \n@@ -162,12 +166,54 @@ public void clipRect (int x, int y, int width, int height)\n   public native void copyArea(int x, int y, int width, int height, \n \t\t\t      int dx, int dy);\n \n-  public Graphics create ()\n+  /**\n+   * Creates a copy of this GdkGraphics instance. This implementation can\n+   * reuse a cached instance to avoid massive instantiation of Graphics objects\n+   * during painting.\n+   *\n+   * @return a copy of this graphics context\n+   */\n+  public Graphics create()\n+  {\n+    GdkGraphics copy = cached;\n+    if (copy == null)\n+      copy = new GdkGraphics(this);\n+    else\n+      {\n+        copy.copyState(this);\n+        cached = null;\n+      }\n+    return copy;\n+  }\n+\n+  public native void nativeDispose();\n+\n+  /**\n+   * Disposes this graphics object. This puts this graphics context into the\n+   * cache of its parent graphics if there is one.\n+   */\n+  public void dispose()\n   {\n-    return new GdkGraphics (this);\n+    if (parent != null)\n+      {\n+        parent.cached = this;\n+        parent = null;\n+      }\n+    else\n+      nativeDispose();\n   }\n \n-  public native void dispose();\n+  /**\n+   * This is called when this object gets finalized by the garbage collector.\n+   * In addition to {@link Graphics#finalize()} this calls nativeDispose() to\n+   * make sure the native resources are freed before the graphics context is\n+   * thrown away.\n+   */\n+  public void finalize()\n+  {\n+    super.finalize();\n+    nativeDispose();\n+  }\n \n   public boolean drawImage (Image img, int x, int y, \n \t\t\t    Color bgcolor, ImageObserver observer)\n@@ -248,9 +294,8 @@ GdkFontPeer getFontPeer()\n   public void drawString (String str, int x, int y)\n   {\n     drawString(getFontPeer(), str, x, y);\n-  }\n+  }  \n   \n-\n   public void drawString (AttributedCharacterIterator ci, int x, int y)\n   {\n     throw new Error (\"not implemented\");\n@@ -419,4 +464,23 @@ public void translate (int x, int y)\n \n     translateNative (x, y);\n   }\n+\n+  /**\n+   * Copies over the state of another GdkGraphics to this instance. This is\n+   * used by the {@link #GdkGraphics(GdkGraphics)} constructor and the\n+   * {@link #create()} method.\n+   *\n+   * @param g the GdkGraphics object to copy the state from\n+   */\n+  private void copyState(GdkGraphics g)\n+  {\n+    color = g.color;\n+    xorColor = g.xorColor;\n+    font = g.font;\n+    if (font == null)\n+      font = new Font (\"Dialog\", Font.PLAIN, 12);\n+    clip = new Rectangle (g.clip);\n+    component = g.component;\n+    nativeCopyState(g);\n+  }\n }"}, {"sha": "195304dcee23d87c703290dc42cac49a2c057ec2", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -180,11 +180,14 @@ private void fail_g2d ()\n     else\n       fg = new Color(g.fg.getRGB());\n \n-    if (g.bg.getAlpha() != -1)\n-      bg = new Color(g.bg.getRed(), g.bg.getGreen(), g.bg.getBlue(),\n-                     g.bg.getAlpha());\n-    else\n-      bg = new Color(g.bg.getRGB());\n+    if (g.bg != null)\n+      {\n+        if (g.bg.getAlpha() != -1)\n+          bg = new Color(g.bg.getRed(), g.bg.getGreen(), g.bg.getBlue(),\n+                         g.bg.getAlpha());\n+        else\n+          bg = new Color(g.bg.getRGB());\n+      }\n \n     if (g.clip == null)\n       clip = null;\n@@ -1088,6 +1091,8 @@ public void clearRect(int x, int y, int width, int height)\n \n   public void setBackground(Color c)\n   {\n+    if (c == null)\n+      c = Color.WHITE;\n     bg = c;\n   }\n "}, {"sha": "054ebaaaef39b0656649832919071e2ca8e07204", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -47,6 +47,7 @@\n import java.awt.image.ImageProducer;\n import java.awt.image.Raster;\n import java.awt.image.RenderedImage;\n+import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -102,6 +103,11 @@ public class GdkPixbufDecoder extends gnu.java.awt.image.ImageDecoder\n                                                      0x00ff0000, \n                                                      0x0000ff00, \n                                                      0x000000ff);\n+  public GdkPixbufDecoder (DataInput datainput)\n+  {\n+    super (datainput);\n+  }\n+\n   public GdkPixbufDecoder (InputStream in)\n   {\n     super (in);\n@@ -630,7 +636,14 @@ public void setInput(Object input,\n                          boolean ignoreMetadata)\n     {\n       super.setInput(input, seekForwardOnly, ignoreMetadata);\n-      dec = new GdkPixbufDecoder((InputStream) getInput());\n+      Object get = getInput();\n+      if (get instanceof InputStream)\n+        dec = new GdkPixbufDecoder((InputStream) get);\n+      else if (get instanceof DataInput)\n+        dec = new GdkPixbufDecoder((DataInput) get);\n+      else\n+\tthrow new IllegalArgumentException(\"input object not supported: \"\n+\t\t\t\t\t   + get);\n     }\n \n     public BufferedImage read(int imageIndex, ImageReadParam param)"}, {"sha": "12d757e2dde7f44d803f35854f27cbd72708d14a", "filename": "libjava/classpath/gnu/java/beans/encoder/ArrayPersistenceDelegate.java", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FArrayPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FArrayPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FArrayPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,153 @@\n+/* ArrayPersistenceDelegate.java - A PersistenceDelegate that handles arrays.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+ \n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.beans.Encoder;\n+import java.beans.Expression;\n+import java.beans.PersistenceDelegate;\n+import java.beans.Statement;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+\n+public class ArrayPersistenceDelegate extends PersistenceDelegate\n+{\n+  private static final HashMap NULL_VALUES = new HashMap();\n+\n+  static\n+    {\n+      NULL_VALUES.put(Boolean.TYPE, Boolean.FALSE);\n+      NULL_VALUES.put(Byte.TYPE, Byte.valueOf((byte) 0));\n+      NULL_VALUES.put(Short.TYPE, Short.valueOf((short) 0));\n+      NULL_VALUES.put(Integer.TYPE, Integer.valueOf(0));\n+      NULL_VALUES.put(Long.TYPE, Long.valueOf(0));\n+      NULL_VALUES.put(Float.TYPE, Float.valueOf(0.0f));\n+      NULL_VALUES.put(Double.TYPE, Double.valueOf(0.0));\n+    }\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    Class type = oldInstance.getClass().getComponentType();\n+\n+    // oldInstance is expected to be an array, then\n+    // getClass().getComponentType() should lead\n+    // to its component type.\n+    assert (type != null);\n+\n+    // Not handling primitive types in a special way here\n+    // causes that Class.forName(\"int\") is built as an Expression\n+    // later which would cause an exception if executed. A special\n+    // handling to avoid the execution for primitive types can be\n+    // java.beans.Encoder.writeExpression() .\n+    return new Expression(\n+                          oldInstance,\n+                          Array.class,\n+                          \"newInstance\",\n+                          new Object[] {\n+                            type,\n+                            new Integer(Array.getLength(oldInstance)) });\n+  }\n+\n+  protected void initialize(Class type, Object oldInstance, Object newInstance,\n+                            Encoder out)\n+  {\n+    int length = Array.getLength(oldInstance);\n+\n+    // Compares the array value against a prototypical\n+    // null value of the array's component type in order to skip\n+    // writing the default values of an array.\n+    \n+    // Note: I have no idea why the persistence delegate for arrays writes\n+    // an Expression that reads the value and then writes a Statement that sets\n+    // the value. However it turned out that object arrays work better with the\n+    // get-Expression and primitive array work fine with the set-Statement.\n+    \n+    type = type.getComponentType();\n+    if (type.isPrimitive())\n+      {\n+        Object nullValue = NULL_VALUES.get(type);\n+\n+        for (int i = 0; i < length; i++)\n+          {\n+            Object oldValue = Array.get(oldInstance, i);\n+\n+            if (!oldValue.equals(nullValue))\n+              {\n+                out.writeExpression(new Expression(Array.class, \"get\",\n+                                                   new Object[] { oldInstance,\n+                                                                 Integer.valueOf(i),\n+                                                                 }));\n+                \n+                out.writeStatement(new Statement(Array.class, \"set\",\n+                                               new Object[] {\n+                                                 oldInstance,\n+                                                 Integer.valueOf(i),\n+                                                 oldValue\n+                                                 }));\n+              }\n+          }\n+        \n+      }\n+    else\n+      {\n+\n+        for (int i = 0; i < length; i++)\n+          {\n+            Object oldValue = Array.get(oldInstance, i);\n+            \n+            if (oldValue != null)\n+              {\n+                out.writeExpression(new Expression(Array.class, \"get\",\n+                                                 new Object[] { oldInstance,\n+                                                               Integer.valueOf(i),\n+                                                               }));\n+                \n+                out.writeStatement(new Statement(Array.class, \"set\",\n+                                                   new Object[] {\n+                                                     oldInstance,\n+                                                     Integer.valueOf(i),\n+                                                     oldValue\n+                                                     }));\n+              }\n+          }\n+      }\n+    \n+  }\n+\n+}"}, {"sha": "7b0656a5d35b8aada20c46c8ee3acf5e5e9614b9", "filename": "libjava/classpath/gnu/java/beans/encoder/ClassPersistenceDelegate.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FClassPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FClassPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FClassPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,80 @@\n+/* ClassPersistenceDelegate.java - A PersistenceDelegate for the Class type.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.beans.encoder;\n+\n+import java.beans.Encoder;\n+import java.beans.Expression;\n+import java.beans.PersistenceDelegate;\n+\n+/** <p>The <code>ClassPersistenceDelegate</code> creates\n+ * <code>Expression</code> instances which denote class resolutions.</p>\n+ * \n+ * <p>The class resolution is always the last step when serializing a tree\n+ * of objects. Due to the recursive nature of the algorithm we need a way\n+ * to end the recursion. This is achieved by the implementation of this\n+ * {@link instantiate} method. Arbitrary classes are described with a call\n+ * to <code>Class.forName</code>. However for the <code>Class</code> class\n+ * we call <code>getClass()</code> on a <code>String.class</code> instance.\n+ * This in turn lead to the resolution of the String class which is always\n+ * encoded as <code>\"\".getClass()</code>. Finally the <code>Encoder</code>\n+ * treats strings in a special way so that the recursion ends here.  \n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class ClassPersistenceDelegate extends PersistenceDelegate\n+{\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    Class oldClass = (Class) oldInstance;\n+    \n+    // Due to the special handling of String instances in the Encoder\n+    // this Expression does not lead to further class resolutions.\n+    if (oldClass == String.class)\n+      return new Expression(oldClass, \"\", \"getClass\", null);\n+\n+    // This Expression will lead to the class resolution of String.class.\n+    if (oldClass == Class.class)\n+      return new Expression(oldClass, String.class, \"getClass\", null);\n+\n+    // This Expression will lead to the class resolution of Class.class. \n+    return new Expression(oldClass, Class.class, \"forName\",\n+                          new Object[] { oldClass.getName() });\n+  }\n+\n+}"}, {"sha": "f1375d2ec18fb2b7d7bed3b4d2c4bebe4387c6f9", "filename": "libjava/classpath/gnu/java/beans/encoder/CollectionPersistenceDelegate.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FCollectionPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FCollectionPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FCollectionPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,84 @@\n+/* CollectionPersistenceDelegate.java - A PersistenceDelegate for Collection subclasses.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+ \n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.util.Collection;\n+import java.beans.Encoder;\n+import java.beans.Expression;\n+import java.beans.PersistenceDelegate;\n+import java.beans.Statement;\n+\n+import java.util.Iterator;\n+\n+/** <p>A <code>PersistenceDelegate</code> implementation that calls\n+ * the no-argument constructor to create the Collection instance and\n+ * uses an iterator to add all the objects it reaches through it.</p>\n+ * \n+ * <p>It is used for <code>Set</code> and <code>List</code>\n+ * implementations.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class CollectionPersistenceDelegate extends PersistenceDelegate\n+{\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    return new Expression(\n+                          oldInstance,\n+                          oldInstance.getClass(),\n+                          \"new\",\n+                          null);\n+  }\n+\n+  protected void initialize(Class type, Object oldInstance, Object newInstance,\n+                            Encoder out)\n+  {\n+    Iterator ite = ((Collection) oldInstance).iterator();\n+\n+    while (ite.hasNext())\n+      {\n+        out.writeStatement(new Statement(oldInstance, \"add\",\n+                                         new Object[] { ite.next() }));\n+\n+      }\n+\n+  }\n+\n+}"}, {"sha": "9126d496fc5d51a52d7ff73d6eb6b0d1ac212d82", "filename": "libjava/classpath/gnu/java/beans/encoder/Context.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FContext.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,88 @@\n+/* Context.java -- Provides calling context information to ScannerStates.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+/** A <code>Contect</code> object describes the current state\n+ * and the call number while processing the original object\n+ * tree in the {@link ScanEngine}.\n+ * \n+ * <p>The class allows to distinguish the different calling states\n+ * and is neccessary for the child element skipping feature of\n+ * the {@link GenericScannerState}.</p> \n+ *  \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class Context\n+{\n+  private String state;\n+  \n+  private int call;\n+  \n+  Context(String newState, int newCall)\n+  {\n+    state = newState;\n+    call = newCall;\n+  }\n+\n+  public int hashCode()\n+  {\n+    int hc = 7;\n+    hc = 31 * hc + state.hashCode();\n+    hc = 31 * hc + call;\n+    \n+    return hc;\n+  }\n+  \n+  public boolean equals(Object o)\n+  {\n+    if (!(o instanceof Context))\n+      return false;\n+    \n+    Context that = (Context) o;\n+    \n+    return state.equals(that.state)\n+      && call == that.call;\n+  }\n+  \n+  public String toString()\n+  {\n+    return \"Context [state=\" + state + \", call=\" + call + \"]\";\n+  }\n+}"}, {"sha": "3c3f8a3d2e77ff97c254d058a2b80ae0565f9c65", "filename": "libjava/classpath/gnu/java/beans/encoder/GenericScannerState.java", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FGenericScannerState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FGenericScannerState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FGenericScannerState.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,257 @@\n+/* GenericScannerState.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.util.HashMap;\n+\n+import gnu.java.beans.encoder.elements.ArrayInstantiation;\n+import gnu.java.beans.encoder.elements.Array_Get;\n+import gnu.java.beans.encoder.elements.Array_Set;\n+import gnu.java.beans.encoder.elements.ClassResolution;\n+import gnu.java.beans.encoder.elements.Element;\n+import gnu.java.beans.encoder.elements.List_Get;\n+import gnu.java.beans.encoder.elements.List_Set;\n+import gnu.java.beans.encoder.elements.MethodInvocation;\n+import gnu.java.beans.encoder.elements.NullObject;\n+import gnu.java.beans.encoder.elements.ObjectInstantiation;\n+import gnu.java.beans.encoder.elements.ObjectReference;\n+import gnu.java.beans.encoder.elements.PrimitiveInstantiation;\n+import gnu.java.beans.encoder.elements.StaticFieldAccess;\n+import gnu.java.beans.encoder.elements.StaticMethodInvocation;\n+import gnu.java.beans.encoder.elements.StringReference;\n+\n+/**\n+ * This class is a {@link ScannerState} implementation that creates\n+ * suitable {@link gnu.java.beans.encoder.elements.Element} instances\n+ * for each transition variant.\n+ * \n+ * <p>Furthermore it can optionally skip a certain number of child\n+ * elements. The algorithm can cope with the fact that one \n+ * <code>GenericScannerState</code> instance may be called at\n+ * different levels of recursions.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+class GenericScannerState extends ScannerState\n+{\n+  private int skipElements, initialSkipElements;\n+\n+  final Root root;\n+\n+  HashMap skipValues;\n+\n+  GenericScannerState(Root newRoot)\n+  {\n+    root = newRoot;\n+  }\n+\n+  GenericScannerState(Root root, int skipElements)\n+  {\n+    this(root);\n+    this.skipElements = initialSkipElements = skipElements;\n+\n+    if (skipElements > 0)\n+      skipValues = new HashMap();\n+  }\n+  \n+  protected void enterImpl(Context ctx)\n+  {\n+    if (skipValues != null)\n+      {\n+        Integer skip = (Integer) skipValues.get(ctx);\n+        \n+        if (skip == null)\n+          {\n+            skip = Integer.valueOf(initialSkipElements);\n+            skipValues.put(ctx, skip);\n+          }\n+        \n+        skipElements = skip.intValue();\n+      }\n+  }\n+\n+  void methodInvocation(String methodName)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new MethodInvocation(methodName));\n+  }\n+\n+  void staticMethodInvocation(String className, String methodName)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new StaticMethodInvocation(className, methodName));\n+  }\n+\n+  void staticFieldAccess(String className, String fieldName)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new StaticFieldAccess(className, fieldName));\n+  }\n+\n+  void classResolution(String className)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new ClassResolution(className));\n+  }\n+\n+  void objectInstantiation(String className, ObjectId objectId)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    Element elem = new ObjectInstantiation(className);\n+    elem.initId(objectId);\n+\n+    root.addChild(elem);\n+  }\n+\n+  void primitiveInstantiation(String primitiveName, String valueAsString)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new PrimitiveInstantiation(primitiveName, valueAsString));\n+  }\n+\n+  void objectArrayInstantiation(String arrayClassName, String lengthAsString,\n+                          ObjectId objectId)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    Element elem = new ArrayInstantiation(arrayClassName, lengthAsString);\n+    elem.initId(objectId);\n+\n+    root.addChild(elem);\n+  }\n+\n+  void primitiveArrayInstantiation(String arrayClassName, String lengthAsString,\n+                                ObjectId objectId)\n+  {\n+    objectArrayInstantiation(arrayClassName, lengthAsString, objectId);\n+  }\n+\n+  void arraySet(String indexAsString)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new Array_Set(indexAsString));\n+  }\n+\n+  void arrayGet(String indexAsString)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new Array_Get(indexAsString));\n+  }\n+\n+  void listGet()\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new List_Get());\n+  }\n+\n+  void listSet()\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new List_Set());\n+  }\n+\n+  void nullObject()\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new NullObject());\n+  }\n+\n+  void stringReference(String string)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new StringReference(string));\n+  }\n+\n+  void objectReference(ObjectId id)\n+  {\n+    if (skipValues != null && skipElements > 0)\n+      return;\n+\n+    root.addChild(new ObjectReference(id));\n+  }\n+\n+  void end()\n+  {\n+    if (skipValues != null)\n+      {\n+        if (skipElements > 0)\n+          skipElements--;\n+        else\n+          {\n+            // Finishes the Element we are constructing.\n+            root.end();\n+          }\n+        skipValues.put(context(), Integer.valueOf(skipElements));\n+      }\n+    else\n+      root.end();\n+\n+  }\n+\n+  void enter()\n+  {\n+\n+  }\n+\n+}"}, {"sha": "054f1f0051cc1a288cbc4fadbd8b7f11b2f5067a", "filename": "libjava/classpath/gnu/java/beans/encoder/IgnoringScannerState.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FIgnoringScannerState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FIgnoringScannerState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FIgnoringScannerState.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,133 @@\n+/* IgnoringScannerState.java -- A ScannerState that does nothing.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+/** A special {@link ScannerState} implementation that ignores all child\n+ * elements.\n+ * \n+ * <p>Consider the call hierarchy:\n+ * <code>\n+ * methodInvocation\n+ *   objectInstantiation\n+ *     classResolution*\n+ *       objectInstantiation\n+ *         classResolution\n+ * </code>\n+ * </p>\n+ * \n+ * <p>When the ignoring state is active one can filter the elements of\n+ * one level. One has to set up the state machine that a transition\n+ * via \"class resolution\" from a state that was reached via \"object\n+ * instantation\" reaches an <code>IgnoringScannerState</code>.</p>\n+ * \n+ * <p>Setting the default successor of a <code>IgnoringScannerState</code>\n+ * to itself causes all elements of the call hierarchy to be skipped\n+ * until another state is reached by going back.</p> \n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+class IgnoringScannerState extends ScannerState\n+{\n+\n+  void methodInvocation(String methodName)\n+  {\n+  }\n+\n+  void staticMethodInvocation(String className, String methodName)\n+  {\n+  }\n+\n+  void staticFieldAccess(String className, String fieldName)\n+  {\n+  }\n+\n+  void classResolution(String className)\n+  {\n+  }\n+\n+  void objectInstantiation(String className, ObjectId objectId)\n+  {\n+  }\n+\n+  void primitiveInstantiation(String primitiveName, String valueAsString)\n+  {\n+  }\n+\n+  void objectArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId)\n+  {\n+  }\n+\n+  void primitiveArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId)\n+  {\n+  }\n+\n+  void arraySet(String indexAsString)\n+  {\n+  }\n+\n+  void arrayGet(String indexAsString)\n+  {\n+  }\n+\n+  void listGet()\n+  {\n+  }\n+\n+  void listSet()\n+  {\n+  }\n+\n+  void nullObject()\n+  {\n+  }\n+\n+  void stringReference(String string)\n+  {\n+  }\n+\n+  void objectReference(ObjectId id)\n+  {\n+  }\n+  \n+  void end()\n+  {\n+  }\n+  \n+}"}, {"sha": "84cdce94dbe4435be90918aa08df8074aaba37cb", "filename": "libjava/classpath/gnu/java/beans/encoder/MapPersistenceDelegate.java", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FMapPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FMapPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FMapPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,81 @@\n+/* MapPersistenceDelegate.java -- A PersistenceDelegate for Map subclasses.\n+\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+ \n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.util.Map;\n+import java.beans.Encoder;\n+import java.beans.Expression;\n+import java.beans.PersistenceDelegate;\n+import java.beans.Statement;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class MapPersistenceDelegate extends PersistenceDelegate\n+{\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    return new Expression(\n+                          oldInstance,\n+                          oldInstance.getClass(),\n+                          \"new\",\n+                          null);\n+  }\n+\n+  protected void initialize(Class type, Object oldInstance, Object newInstance,\n+                            Encoder out)\n+  {\n+    Map map = (Map) oldInstance;\n+    Iterator ite = map.keySet().iterator();\n+\n+    while (ite.hasNext())\n+      {\n+        Object key = ite.next();\n+        out.writeStatement(new Statement(oldInstance, \"put\",\n+                                         new Object[] { key, map.get(key) }));\n+\n+      }\n+\n+  }\n+\n+}"}, {"sha": "eca5c3da477652cfd631144d0fa90ac5f221abfb", "filename": "libjava/classpath/gnu/java/beans/encoder/ObjectId.java", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FObjectId.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FObjectId.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FObjectId.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,132 @@\n+/* ObjectId.java -- Simple object identification mechanism for XML encoding.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.util.HashMap;\n+\n+/**\n+ * <p>\n+ * ObjectId provides an object identification mechanism which gives each object\n+ * a name in the form <code>&lt;class&gt;&lt;Nameindex&gt;</code>.\n+ * </p>\n+ * \n+ * <p>\n+ * Each id can be in an unused state which means that only one instance of the\n+ * object is in use and a special id is not needed. Certain {@link\n+ * gnu.java.beans.encoder.elements.Element} subclasses use this feature to find\n+ * out whether they write the \"id\" attribute or not.\n+ * </p>\n+ * <p>\n+ * An <code>ObjectId</code> instance is typically given to multiple objects.\n+ * The second user should then invoke the {@link #init} method to generate the\n+ * identification string and bring the id in the 'used' state.\n+ * </p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class ObjectId\n+{\n+  /**\n+   * Stores the index an object of a specific type should be given.\n+   */\n+  private static HashMap nameIndices = new HashMap();\n+\n+  private String id;\n+\n+  private Class klass;\n+\n+  ObjectId(Class klass)\n+  {\n+    this.klass = klass;\n+  }\n+\n+  public boolean isUnused()\n+  {\n+    return id == null;\n+  }\n+\n+  public String toString()\n+  {\n+    return (id != null) ? id : \"<unused id>\";\n+  }\n+\n+  /**\n+   * <p>\n+   * Generates a simple Id by concatenating a class name with a self-increasing\n+   * number.\n+   * </p>\n+   */\n+  public void init()\n+  {\n+    assert (klass != null);\n+\n+    if (id != null)\n+      return;\n+\n+    Integer count = (Integer) nameIndices.get(klass);\n+    if (count == null)\n+      {\n+        count = Integer.valueOf(0);\n+      }\n+\n+    if (klass.isArray())\n+      {\n+        Class ct = klass.getComponentType();\n+        if (ct == Boolean.TYPE)\n+          id = \"booleanArray\" + count.intValue();\n+        else if (ct == Byte.TYPE)\n+          id = \"byteArray\" + count.intValue();\n+        else if (ct == Short.TYPE)\n+          id = \"shortArray\" + count.intValue();\n+        else if (ct == Integer.TYPE)\n+          id = \"intArray\" + count.intValue();\n+        else if (ct == Long.TYPE)\n+          id = \"longArray\" + count.intValue();\n+        else if (ct == Float.TYPE)\n+          id = \"floatArray\" + count.intValue();\n+        else if (ct == Double.TYPE)\n+          id = \"doubleArray\" + count.intValue();\n+      }\n+    else\n+      id = klass.getName() + count.intValue();\n+\n+    nameIndices.put(klass, Integer.valueOf(count.intValue() + 1));\n+  }\n+\n+}"}, {"sha": "8cb3705b4d878cca46f0779a04279e02cf90b974", "filename": "libjava/classpath/gnu/java/beans/encoder/PrimitivePersistenceDelegate.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FPrimitivePersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FPrimitivePersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FPrimitivePersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,74 @@\n+/* PrimitivePersistenceDelegate.java\n+ -- A PersistenceDelegate for primitive data types.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.beans.encoder;\n+\n+import java.beans.Encoder;\n+import java.beans.Expression;\n+import java.beans.PersistenceDelegate;\n+\n+/**\n+ * A shared PersistenceDelegate implementation for all primitive types.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class PrimitivePersistenceDelegate extends PersistenceDelegate\n+{\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    // The implementation relies on the fact that every primitive\n+    // wrapper class has a constructor accepting a String argument.\n+    // By using these constructors creating a primitive instance\n+    // depends on the String class only.\n+    return new Expression(oldInstance, oldInstance.getClass(), \"new\",\n+                          new Object[] { oldInstance.toString() });\n+  }\n+\n+  protected void initialize(Class type, Object oldInstance, Object newInstance, Encoder out)\n+  {\n+    // This is a hack to make serializing primitive arrays work correctly.\n+    // Instead of modifying an existing primitive instance to make it equal\n+    // with another instance (which is not possible because primitives are\n+    // immutable) we create a new instance. This is against the specification\n+    // of the initialize method but make things work fine.\n+    out.writeExpression(new Expression(oldInstance, oldInstance.getClass(), \"new\",\n+                          new Object[] { oldInstance.toString() }));\n+  }\n+  \n+}"}, {"sha": "fb6e061ae4da6e292e5a186da3cdd42551b80aa3", "filename": "libjava/classpath/gnu/java/beans/encoder/ReportingScannerState.java", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FReportingScannerState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FReportingScannerState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FReportingScannerState.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,131 @@\n+/* ReportingScannerState.java -- A state for debugging purposes.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+/**\n+ * A <code>ScannerState</code> implementation that prints useful details\n+ * about its arguments. Use it when the XML encoding does not work correctly\n+ * and you want to find out how things relate to each other.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+class ReportingScannerState extends ScannerState\n+{\n+\n+  void methodInvocation(String methodName)\n+  {\n+\tSystem.out.println(\"methodInvocation: \" + methodName + \"()\");\n+  }\n+\n+  void staticMethodInvocation(String className, String methodName)\n+  {\n+\tSystem.out.println(\"staticMethodInvocation: \" + className + \".\" + methodName + \"()\");\n+  }\n+\n+  void staticFieldAccess(String className, String fieldName)\n+  {\n+    System.out.println(\"staticFieldAccess: \" + className + \".\" + fieldName);\n+  }\n+\n+  void classResolution(String className)\n+  {\n+\tSystem.out.println(\"classResolution: \" + className);\n+  }\n+\n+  void objectInstantiation(String className, ObjectId objectId)\n+  {\n+\tSystem.out.println(\"objectInstantiation: \" + className);\n+  }\n+\n+  void primitiveInstantiation(String primitiveName, String valueAsString)\n+  {\n+\tSystem.out.println(\"primitiveInstantiation: (\" + primitiveName + \") \" + valueAsString);\n+  }\n+\n+  void objectArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId)\n+  {\n+    System.out.println(\"objectArrayInstantiation: new \" + arrayClassName + \"[\" + lengthAsString + \"]\");\n+  }\n+\n+  void primitiveArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId)\n+  {\n+    System.out.println(\"primitiveArrayInstantiation: new \" + arrayClassName + \"[\" + lengthAsString + \"]\");\n+  }\n+\n+  void arraySet(String indexAsString)\n+  {\n+\tSystem.out.println(\"arraySet: \" + indexAsString);\n+  }\n+\n+  void arrayGet(String indexAsString)\n+  {\n+\tSystem.out.println(\"arrayGet: \" + indexAsString);\n+  }\n+\n+  void listGet()\n+  {\n+\tSystem.out.println(\"listGet\");\n+  }\n+\n+  void listSet()\n+  {\n+\tSystem.out.println(\"listSet\");\n+  }\n+\n+  void nullObject()\n+  {\n+\tSystem.out.println(\"nullObject\");\n+  }\n+\n+  void stringReference(String string)\n+  {\n+    System.out.println(\"stringReference: \" + string);\n+  }\n+\n+  void objectReference(ObjectId id)\n+  {\n+    System.out.println(\"objectReference: \" + id);\n+  }\n+\n+ void end()\n+ {\n+ \tSystem.out.println(\"-close\");\n+ }\n+ \n+}"}, {"sha": "f4eade1939d11fd6d39e0394213579327096cbce", "filename": "libjava/classpath/gnu/java/beans/encoder/Root.java", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FRoot.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FRoot.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FRoot.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,198 @@\n+/* Root.java -- The root of an object tree.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.beans.XMLEncoder;\n+import java.util.Iterator;\n+import java.util.Stack;\n+\n+import gnu.java.beans.encoder.elements.Element;\n+\n+/** <p><code>Root</code> provides a simple interface to a tree of\n+ * objects.</p>\n+ * \n+ * <p>Using an instance of this class a logical representation of\n+ * the real object tree that is serialized can be built. When the\n+ * actual data should be written as XML <code>Root</code> and\n+ * {@link gnu.java.beans.encoder.elements.Element} class can provide\n+ * context information which is used to write the best fitting\n+ * XML representation.</p>\n+ *   \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class Root\n+{\n+  private Stack parents = new Stack();\n+\n+  private Element rootElement, current;\n+  \n+  private boolean started;\n+\n+  public Root()\n+  {\n+    rootElement = current = new RootElement();\n+  }\n+\n+  /** <p>Adds another child element to the tree.</p>\n+   * \n+   * <p>The new element automatically becomes the current\n+   * element.</p>\n+   * \n+   * @param elem The new child element.\n+   */\n+  public void addChild(Element elem)\n+  {\n+    current.addChild(elem);\n+\n+    parents.push(current);\n+    current = elem;\n+  }\n+\n+  /**\n+   * <p>Marks that the end of the current element\n+   * is reached and that no more childs are added to\n+   * it.</p>\n+   * \n+   * <p>The behavior is to return to the nearest parent\n+   * element.</p>\n+   */\n+  public void end()\n+  {\n+    current = (Element) parents.pop();\n+  }\n+\n+  /**\n+   * <p>Goes back to the nearest parent element but\n+   * deletes the just created child.</p>\n+   * \n+   * <p>This is used if something went wrong while\n+   * processing the child element's {@link java.beans.Expression}\n+   * or {@link java.beans.Statement}.</p>\n+   *\n+   */\n+  public void deleteLast()\n+  {\n+    current = (Element) parents.pop();\n+\n+    current.removeLast();\n+  }\n+\n+  /**\n+   * <p>Traverses the elements in the object tree\n+   * and creates their XML representation in the output\n+   * stream of the given {@link Writer}.</p>\n+   * \n+   * <p>Finally the <code>Writer</code> is flushed.</p>\n+   *  \n+   * @param writer The Writer instance that generates the XML representation.\n+   */\n+  public void traverse(Writer writer)\n+  {\n+    if (!started)\n+      {\n+        writer.writePreamble();\n+        rootElement.writeStart(writer);\n+      }\n+    started = true;\n+    \n+    traverse(writer, rootElement.iterator());\n+    \n+    rootElement.clear();\n+    \n+    writer.flush();\n+  }\n+\n+  /** Writes the closing element and closes the {@link Writer}\n+   * \n+   * @param writer The Writer instance that generates the XML representation.\n+   */\n+  public void close(Writer writer)\n+  {\n+    rootElement.writeEnd(writer);\n+    writer.close();\n+  }\n+\n+  /** Recursively traverses the object tree.\n+   * \n+   * @param writer The Writer instance that generates the XML representation.\n+   * @param ite An Iterator returning Element instances.\n+   */\n+  private void traverse(Writer writer, Iterator ite)\n+  {\n+    while (ite.hasNext())\n+      {\n+        Element e = (Element) ite.next();\n+        e.writeStart(writer);\n+\n+        traverse(writer, e.iterator());\n+\n+        e.writeEnd(writer);\n+        \n+        e.clear();\n+      }\n+  }\n+\n+  /** <p>A special Element implementation that represents the\n+   * encoder's context.</p>\n+   * \n+   * <p>This element is written only once per Writer.</p>\n+   * \n+   * <p>It is assumed that this element is never empty to simplify\n+   * the implementation.</p>\n+   * \n+   * @author Robert Schuster (robertschuster@fsfe.org);\n+   *\n+   */\n+  static class RootElement extends Element\n+  {\n+    public void writeStart(Writer writer)\n+    {\n+      writer.write(\"java\", new String[] { \"version\", \"class\" },\n+                   new String[] { System.getProperty(\"java.version\"),\n+                                 XMLEncoder.class.getName() }, false);\n+    }\n+    \n+    public void writeEnd(Writer writer)\n+    {\n+      writer.writeEnd(false);\n+    }\n+\n+  }\n+\n+}"}, {"sha": "edf07d760d3201b999b2aee8f350ec95624c4bfd", "filename": "libjava/classpath/gnu/java/beans/encoder/ScanEngine.java", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScanEngine.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScanEngine.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScanEngine.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,860 @@\n+/* ScanEngine.java \n+ -- Scans the input and generates an object tree that can be written as XML.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.beans.Expression;\n+import java.beans.Statement;\n+import java.io.OutputStream;\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Stack;\n+\n+/** <p>The <code>ScanEngine</code> is the main class of the backend of the\n+ * XML persistence algorithm. It scans {@link java.beans.Expression} and\n+ * {@link java.beans.Statement} instances and some raw objects via the\n+ * {@link #writeObject} method and feeds it to a state machine. The\n+ * state machine then constructs and object tree which is finally\n+ * written as XML by a {@link Writer} implementation.</p>\n+ * \n+ * <p>How does it work?</p>\n+ * <p>The <code>ScanEngine</code> sits below the {@link java.beans.XMLEncoder}\n+ * class and is called by it exclusively. The <code>XMLEncoder</code> sends\n+ * interpretive data by invoking {@link #writeExpression}, {@link #writeStatement}\n+ * and {@link #writeObject}. The invocations of <code>writeExpression</code> and\n+ * <code>writeStatement</code> are usually nested into each other and provide\n+ * more information then necessary to generate the XML representation.\n+ * Furthermore the meaning of certain <code>Expressions</code> differs\n+ * depending on the enclosing elements or the inner elements have to be\n+ * simply discarded.</p>\n+ * \n+ * <p>To cope with this state dependant nature the <code>ScanEngine</code>\n+ * contains a state machine which is programmed statically (no adjustments are\n+ * needed, all <code>ScanEngine</code> engines use the same setup). The\n+ * <code>ScanEngine</code>'s job is to decode the <code>Expression</code>s,\n+ * <code>Statement</code>s and certain objects (namely <code>String</code>,\n+ * <code>null</code> objects and instances which are repeatedly provided to\n+ * the encoder) into 13 low-level (event) methods, which denote the meaning of the\n+ * argument. For example an <code>Expression</code> can be an array\n+ * instantiation which provokes a call to {@link arrayInstantiation} or\n+ * it can be a class resolution leading to a call to {@link #classResolution}.\n+ * For the state machione the 13 methods are the distinct way to transit\n+ * from one state to another. Whenever the <code>ScanEngine</code> calls\n+ * one of the event methods the current's state successor for that event\n+ * is fetched from the state machine configuration, the successpr becomes\n+ * the current state and then the event method is called in the new current\n+ * state. The last step allows the state instance to do something meaningful\n+ * to the object tree.</p>\n+ * \n+ * <p>The state machine knows the concept of returning to the previous\n+ * state. This is done using a stack of states which is popped every\n+ * time a call to <code>writeStatement</code>, <code>writeExpression</code>\n+ * in the <code>XMLEncoder</code> ends by calling the {@link #end} method.\n+ * Note that due to the inheritance relationship of <code>Encoder</code>\n+ * and <code>XMLEncoder</code> it is impossible for the\n+ * <code>ScanEngine</code> itself to decide when an expression or statement\n+ * ended. This can only be done in case of {@link #writeObject} calls because\n+ * they are not nested.</p>\n+ * \n+ * <p>When the XML persistence mechanism reaches an object twice (and more)\n+ * it should generate an XML element using the \"idref\" attribute and add\n+ * an \"id\" attribute to its first instantiation. This complicates things a bit\n+ * because the first instantiation will always be part of the object tree\n+ * as some {@link gnu.java.beans.encoder.elements.Element} subclass instance when the\n+ * second and further objects accesses are written. Therefore the {@link ObjectId}\n+ * class was introduced which is shared between all the object tree elements\n+ * and has the notion of an \"unused\" state meaning that no identification\n+ * is needed. The relationship between an object and its <code>ObjectId</code>\n+ * instance is stored in the <code>ScanEngine</code> and gets cleared whenever\n+ * the {@link #flush} method is called. This method also writes the currently\n+ * built object tree and generates the XML representation.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class ScanEngine\n+{\n+  \n+  /** Change this to true to let the ScanEngine print state transition\n+   * information.\n+   */\n+  boolean DEBUG = false;\n+\n+  /**\n+   * Stores the scanner engine states as values and their names as keys.\n+   */\n+  HashMap states = new HashMap();\n+\n+  /**\n+   * Stores former scanner state and makes it possible to come back to them.\n+   */\n+  Stack parents = new Stack();\n+\n+  /**\n+   * The currently active scanner state.\n+   */\n+  ScannerState current;\n+\n+  /**\n+   * The root of an object tree that is later written to XML.\n+   */\n+  Root root;\n+\n+  /**\n+   * The Writer used to generate the XML output.\n+   */\n+  Writer writer;\n+\n+  /** Stores the relationship between objects and their {@link ObjectId} instance.\n+   */\n+  IdentityHashMap objects = new IdentityHashMap();\n+  \n+  public ScanEngine(OutputStream os)\n+  {\n+    // TODO: Provide another Writer implementation (e.g. one that does not use\n+    // the XML APIs at all).\n+    writer = new StAXWriter(os);\n+    root = new Root();\n+\n+    final ScannerState start = current = new GenericScannerState(root);;\n+    ScannerState conf;\n+\n+    // Use the ReportingScannerState to debug serialization issues.\n+    register(ScannerState.DEFAULT_STATE_NAME, new IgnoringScannerState());\n+\n+    register(\"start\", start);\n+\n+    // Special dead-end state where all transitions are ignored.\n+    register(\"ignoreAll\", new IgnoringScannerState())\n+      .setDefaultSuccessor(\"ignoreAll\");\n+\n+    // Object reference, string reference, null object\n+    start.putSuccessor(ScannerState.TRANSITION_OBJECT_REFERENCE, \"simple\");\n+    start.putSuccessor(ScannerState.TRANSITION_STRING_REFERENCE, \"simple\");\n+    start.putSuccessor(ScannerState.TRANSITION_NULL_OBJECT, \"simple\");\n+    register(\"simple\", new GenericScannerState(root))\n+      .setDefaultSuccessor(\"ignoreAll\");\n+\n+    // Class resolution.\n+    start.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"classRes0\");\n+    register(\"classRes0\",\n+             new GenericScannerState(root)).setDefaultSuccessor(\"ignoreAll\");\n+\n+    // Object instantiation.\n+    start.putSuccessor(ScannerState.TRANSITION_OBJECT_INSTANTIATION,\n+                       \"newObj0\");\n+    conf = register(\"newObj0\", new GenericScannerState(root));\n+    conf.setDefaultSuccessor(\"ignoreAll\");\n+    \n+    // Simply use the start state to encode method invocations inside of\n+    // objects.\n+    conf.putSuccessor(ScannerState.TRANSITION_METHOD_INVOCATION, \"start\");\n+\n+    // Primitive instantiations.\n+    start.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                       \"newPrimitive0\");\n+    register(\"newPrimitive0\",\n+             new GenericScannerState(root)).setDefaultSuccessor(\"ignoreAll\");\n+\n+    // Object arrays use the ARRAY_GET transition to create setting the\n+    // array values.\n+    start.putSuccessor(ScannerState.TRANSITION_OBJECT_ARRAY_INSTANTIATION,\n+                       \"newObjectArray\");\n+    conf = register(\"newObjectArray\", new GenericScannerState(root));\n+    conf.putSuccessor(ScannerState.TRANSITION_ARRAY_GET, \"newOArrayGet\");\n+    conf.putSuccessor(ScannerState.TRANSITION_ARRAY_SET, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"ignoreAll\");\n+    \n+    // Get here when a value is set in the array.\n+    register(\"newOArrayGet\",\n+             conf = new GenericScannerState(root));\n+    \n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"newOArrayGet_ignoreFirstInteger\");\n+    \n+    // \"newArrayGet_ignoreFirstInteger\" is set up mostly identical like the \"start\"\n+    // state. Otherwise things would not behave the same when done inside\n+    // arrays.\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_REFERENCE, \"simple\");\n+    conf.putSuccessor(ScannerState.TRANSITION_STRING_REFERENCE, \"simple\");\n+    conf.putSuccessor(ScannerState.TRANSITION_NULL_OBJECT, \"simple\");\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"classRes0\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_INSTANTIATION, \"newObj0\");\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_ARRAY_INSTANTIATION,\n+                      \"newPrimitiveArray\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_ARRAY_INSTANTIATION,\n+                      \"newObjectArray\");\n+    \n+    conf = register(\"newOArrayGet_ignoreFirstInteger\",\n+                    new GenericScannerState(root, 1));\n+    \n+    // In non-int primitive arrays class resolutions can happen\n+    // but they should be ignored.\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"ignoreAll\");\n+    \n+    // Spurious object and string references occur when setting array\n+    // elements. This suppresses them.\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_REFERENCE, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_STRING_REFERENCE, \"ignoreAll\");\n+    \n+    conf.setDefaultSuccessor(\"start\");\n+\n+    // Primitive arrays use the ARRAY_SET transition to create setting the\n+    // array values. This turned out to be the only working solution.\n+    // When primitive arrays were handled by ARRAY_GET the values in boolean\n+    // arrays were always skipped.\n+    start.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_ARRAY_INSTANTIATION,\n+                       \"newPrimitiveArray\");\n+    conf = register(\"newPrimitiveArray\", new GenericScannerState(root));\n+    conf.putSuccessor(ScannerState.TRANSITION_ARRAY_GET, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_ARRAY_SET, \"newPArraySet\");\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"ignoreAll\");\n+    \n+    conf = register(\"newPArraySet\", new GenericScannerState(root));\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"newPArraySet_ignoreFirstInteger\");\n+    \n+    // Primitive arrays ignore all kinds of non-primitive object information.\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_REFERENCE,\n+                      \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_STRING_REFERENCE, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_NULL_OBJECT, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"ingoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_INSTANTIATION, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_ARRAY_INSTANTIATION,\n+                      \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_ARRAY_INSTANTIATION,\n+                      \"ignoreAll\");\n+\n+    conf = register(\"newPArraySet_ignoreFirstInteger\",\n+                    new GenericScannerState(root, 1));\n+    \n+    // In non-int primitive arrays class resolutions can happen\n+    // but they should be ignored.\n+    conf.putSuccessor(ScannerState.TRANSITION_CLASS_RESOLUTION, \"ignoreAll\");\n+    \n+    // Spurious object and string references occur when setting array\n+    // elements. This suppresses them.\n+    conf.putSuccessor(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION,\n+                      \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_OBJECT_REFERENCE, \"ignoreAll\");\n+    conf.putSuccessor(ScannerState.TRANSITION_STRING_REFERENCE, \"ignoreAll\");\n+    conf.setDefaultSuccessor(\"start\");\n+\n+  }\n+\n+  /** Registers a <code>ScannerState</code> under a certain name.\n+   * \n+   * @param name Name of the state\n+   * @param state The <code>ScannerState</code> instance.\n+   * @return The second argument.\n+   */\n+  private ScannerState register(String name, ScannerState state)\n+  {\n+    state.init(name);\n+    \n+    states.put(name, state);\n+\n+    return state;\n+  }\n+  \n+  /** Generates or returns an id for the given object which can be activated\n+   * later if the object is suitable.\n+   * \n+   * <p>Objects are unsuitable if they are an instance of a primitive wrapper\n+   * or String.</p>\n+   * \n+   * @param value The object to retrieve an id for. \n+   * @return The id for the object or <code>null</code>.\n+   */\n+  private ObjectId retrieveId(Object value)\n+  {\n+    Class valueClass = value.getClass();\n+    ObjectId id = null;\n+    \n+    // Although multiple accesses to Class objects are not handled\n+    // through ids we generate one for them, too. This allows us to detect\n+    // second time references to such objects in the writeObject method\n+    // and handle them in a special way.\n+    if (valueClass != String.class\n+        && valueClass.getSuperclass() != Number.class\n+        && valueClass != Boolean.class)\n+      {\n+        if ((id = (ObjectId) objects.get(value)) == null)\n+          {\n+            id = new ObjectId(valueClass);\n+            objects.put(value, id);\n+          }\n+      }\n+    \n+    return id;\n+  }\n+\n+  /** Scans the argument and calls one of event methods. See\n+   * the introduction of this class for details.\n+   * \n+   * @param expr The expression to serialize.\n+   */\n+  public void writeExpression(Expression expr)\n+  {\n+    String methodName = expr.getMethodName();\n+    Object[] args = expr.getArguments();\n+    Object target = expr.getTarget();\n+    Object value = null;\n+    \n+    try\n+      {\n+        value = expr.getValue();\n+      }\n+    catch (Exception e)\n+      {\n+        throw (InternalError)\n+          new InternalError(\n+          \"The Expression's value should be available at this point.\")\n+          .initCause(e);\n+      }\n+\n+    // TODO: What if the value is null?\n+    ObjectId id;\n+    Class valueClass = value.getClass();\n+\n+    if (target == Array.class)\n+      {\n+        if (methodName.equals(\"newInstance\"))\n+          {\n+            id = retrieveId(value);\n+            \n+            Class ct = (Class) args[0];\n+            \n+            if (ct.isPrimitive() || ct == Boolean.class || ct == Byte.class\n+                || ct == Short.class || ct == Integer.class || ct == Long.class\n+                || ct == Float.class || ct == Double.class)\n+              primitiveArrayInstantiation(ct.getName(),\n+                                          args[1].toString(),\n+                                          id);\n+            else\n+              objectArrayInstantiation(ct.getName(),\n+                                       args[1].toString(),\n+                                       id);\n+            \n+            return;\n+          }\n+        else if (methodName.equals(\"get\"))\n+          {\n+            arrayGet(args[1].toString());\n+\n+            // The encoder does not call the ScanEngine\n+            // when an object is serialized that we already know.\n+            // We test for this situation and insert the object reference\n+            // manually.\n+            // Since there is already a workaround for the Class class\n+            // in writeObject we have to except it from this behavior.\n+            id = (ObjectId) objects.get(value);\n+            if (id != null && valueClass != Class.class)\n+              {\n+                objectReference(id);\n+                end();\n+              }\n+            \n+            return;\n+          }\n+        else if (methodName.equals(\"set\"))\n+          {\n+            arraySet(args[1].toString());\n+            return;\n+          }\n+      }\n+    \n+    id = retrieveId(value);\n+\n+    if (target instanceof Class)\n+      {\n+        if (methodName.equals(\"new\"))\n+          {\n+            Class targetClass = (Class) target;\n+\n+            // All primitive types have short-hand forms for their\n+            // constructors.\n+            if (valueClass == Boolean.class)\n+              primitiveInstantiation(\"boolean\", args[0].toString());\n+            else if (valueClass == Byte.class)\n+              primitiveInstantiation(\"byte\", args[0].toString());\n+            else if (valueClass == Short.class)\n+              primitiveInstantiation(\"short\", args[0].toString());\n+            else if (valueClass == Integer.class)\n+              primitiveInstantiation(\"int\", args[0].toString());\n+            else if (valueClass == Long.class)\n+              primitiveInstantiation(\"long\", args[0].toString());\n+            else if (valueClass == Float.class)\n+              primitiveInstantiation(\"float\", args[0].toString());\n+            else if (valueClass == Double.class)\n+              primitiveInstantiation(\"double\", args[0].toString());\n+            else\n+              objectInstantiation(targetClass.getName(), id);\n+\n+            return;\n+          }\n+        else if (value instanceof Class)\n+          {\n+            String className = ((Class) value).getName();\n+\n+            // At this point we know that some *static* method will be called.\n+\n+            if (methodName.equals(\"forName\"))\n+              {\n+                // However \"Class.forName\" represents class resolution and has a\n+                // special syntax.\n+                classResolution(className);\n+                return;\n+              }\n+            else if (methodName.equals(\"getField\"))\n+              {\n+                // The same goes for \"Class.getField\".\n+                // Note: The name of the wanted field is given in\n+                // the argument array.\n+                staticFieldAccess(className, args[0].toString());\n+                return;\n+              }\n+            else\n+              {\n+                // If nothing fits it is just a static method\n+                // invocation which we decode as such.\n+                staticMethodInvocation(className, methodName);\n+                return;\n+              }\n+          }\n+      }\n+    else if (target instanceof List)\n+      {\n+        // Special behavior for indexed get and set method for list-style\n+        // classes.\n+        // The arguments are in the args array but we need them as subelements.\n+        if (methodName.equals(\"get\"))\n+          {\n+            listGet();\n+            return;\n+          }\n+        else if (methodName.equals(\"set\"))\n+          {\n+            listSet();\n+            return;\n+          }\n+      }\n+\n+    // If nothing else could be used then this is a normal\n+    // method invocation.\n+    methodInvocation(methodName);\n+  }\n+\n+  /**\n+   * Ends the current state and returns to the last one.\n+   */\n+  public void end()\n+  {\n+    current.end();\n+\n+    if (DEBUG) System.err.print(\"back from \" + current.getName());\n+\n+    ScannerState oldCurrent = current;\n+    current = (ScannerState) parents.pop();\n+\n+    if (DEBUG) System.err.println(\" to \" + current.getName());\n+  }\n+\n+  /**\n+   * Returns to the last state and deletes the last element in the object tree.\n+   */\n+  public void revoke()\n+  {\n+    ScannerState oldCurrent = current;\n+    current = (ScannerState) parents.pop();\n+\n+    root.deleteLast();\n+  }\n+\n+  /** Scans the argument and calls one of event methods. See\n+   * the introduction of this class for details.\n+   * \n+   * @param stmt The statement to serialize.\n+   */\n+  public void writeStatement(Statement stmt)\n+  {\n+    // This is a simplified version of writeExpression. Everything\n+    // that would not create something that is embedded in a <void> tag\n+    // is left out (instantiation, getters, ...).\n+    // TODO: Is this the right thing to do?\n+\n+    String methodName = stmt.getMethodName();\n+    Object target = stmt.getTarget();\n+    Object[] args = stmt.getArguments();\n+\n+    if (target == Array.class && methodName.equals(\"set\"))\n+      {\n+        arraySet(args[1].toString());\n+        return;\n+      }\n+\n+    if (target instanceof List)\n+      {\n+        if (methodName.equals(\"set\"))\n+          {\n+            listSet();\n+            return;\n+          }\n+      }\n+\n+    // If nothing else could be used then this is a normal\n+    // method invocation.\n+    methodInvocation(methodName);\n+  }\n+\n+  /** Scans the argument and calls one of event methods. See\n+   * the introduction of this class for details.\n+   * \n+   * @param o The object to serialize.\n+   */\n+  public boolean writeObject(Object o)\n+  {\n+    ObjectId id = null;\n+\n+    if (o == null)\n+      {\n+        // Handle null objects which have a special syntax.\n+        nullObject();\n+        end();\n+      }\n+    else if (o.getClass() == String.class)\n+      {\n+        // Handle strings which are treated extremely special\n+        // in the encoder (they are never converted into a\n+        // Expression).\n+        stringReference((String) o);\n+        end();\n+      }\n+    else if ((id = (ObjectId) objects.get(o)) != null)\n+      {\n+        // Multiple references to a Class object do not generate\n+        // an object reference but we use the id to detect that\n+        // situation.\n+        if (o.getClass() == Class.class)\n+          {\n+            classResolution(((Class) o).getName());\n+            end();\n+            return false;\n+          }\n+        \n+        // If our object has a corresponding ObjectId instance\n+        // then generate an objectReference. This will \n+        // initialize the id (= brings it in the \"used\" state)\n+        // when this is the first referal.\n+        objectReference(id);\n+        end();\n+        return false;\n+      }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Writes the currently constructed object tree out as\n+   * XML and clears the object to {@link ObjectId} relations.\n+   */\n+  public void flush()\n+  {\n+    // Make all references unreachable. That means we have to generate\n+    // new object ids.\n+    objects.clear();\n+\n+    root.traverse(writer);\n+  }\n+\n+  /** Writes the final bits if the object tree and closes the stream\n+   * afterwards.\n+   */\n+  public void close()\n+  {\n+    flush();\n+    root.close(writer);\n+  }\n+\n+  /**\n+   * Does a transition from one state to another using the given event.\n+   * \n+   * <p>This involves saving the current state, retrieving it's\n+   * successor and setting it as the current state.</p>\n+   * \n+   * @param transition One of {@link ScannerStates]'s transition constants.\n+   */\n+  private void transition(int transition)\n+  {\n+    parents.push(current);\n+\n+    String stateName = current.getSuccessor(transition);\n+    \n+    if (DEBUG)\n+      {\n+        System.err.println(\"from state: \" + current.getName() + \"\\n\\troute: \"\n+                           + ScannerState.transitionNames[transition]\n+                           + \"\\n\\t\\tto state: \"\n+                           + stateName);\n+      }\n+    \n+    ScannerState newState = (ScannerState) states.get(stateName);\n+    \n+    newState.enter(new Context(current.getName(), current.getCalls()));\n+\n+    assert (newState != null) : \"State '\" + stateName + \"' was not defined.\";\n+\n+    current = newState;\n+  }\n+\n+  /** Event method that denotes a (non-static) method invocation.\n+   *\n+   * <p>More details about this method can be found in this\n+   * class' introduction.</p>\n+   * \n+   * @param methodName The name of the method which is called.\n+   */\n+  void methodInvocation(String methodName)\n+  {\n+    transition(ScannerState.TRANSITION_METHOD_INVOCATION);\n+\n+    current.methodInvocation(methodName);\n+  }\n+\n+  /** Event method that denotes a static method invocation.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param methodName The name of the method which is called.\n+  * @param className The name of the class in which the method is called.\n+  */\n+  void staticMethodInvocation(String className, String methodName)\n+  {\n+    transition(ScannerState.TRANSITION_STATIC_METHOD_INVOCATION);\n+\n+    current.staticMethodInvocation(className, methodName);\n+  }\n+\n+  /** Event method that denotes the retrieval of a static field's value.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param fieldName The name of the field whose value is retrieved.\n+  * @param className The name of the class in which the method is called.\n+  */\n+  void staticFieldAccess(String className, String fieldName)\n+  {\n+    transition(ScannerState.TRANSITION_STATIC_FIELD_ACCESS);\n+\n+    current.staticFieldAccess(className, fieldName);\n+  }\n+\n+  /** Event method that denotes the resolution of a class.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param className The name of the class in which the method is called.\n+  */\n+  void classResolution(String className)\n+  {\n+    transition(ScannerState.TRANSITION_CLASS_RESOLUTION);\n+\n+    current.classResolution(className);\n+  }\n+\n+  /** Event method that denotes the instantiation of an object.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param className The name of the class in which the method is called.\n+  * @param objectId An ObjectId instance which can be activated later.\n+  */\n+  void objectInstantiation(String className, ObjectId objectId)\n+  {\n+    transition(ScannerState.TRANSITION_OBJECT_INSTANTIATION);\n+\n+    current.objectInstantiation(className, objectId);\n+  }\n+\n+  /** Event method that denotes the instantiation of a primitive.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param primitiveName One of \"boolean, \"byte\", \"short\", \"int\", \"long\"\n+  * , \"float\" or \"double\"\n+  * @param valueAsString The value of the primitive as a String.\n+  */\n+  void primitiveInstantiation(String primitiveName, String valueAsString)\n+  {\n+    transition(ScannerState.TRANSITION_PRIMITIVE_INSTANTIATION);\n+\n+    current.primitiveInstantiation(primitiveName, valueAsString);\n+  }\n+\n+  /** Event method that denotes the instantiation of an object array.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param arrayClassName The array's class name.\n+  * @param objectId An ObjectId instance which can be activated later.\n+  * @param lengthAsString The array's length as String.\n+  */\n+  void objectArrayInstantiation(String arrayClassName, String lengthAsString,\n+                          ObjectId objectId)\n+  {\n+    transition(ScannerState.TRANSITION_OBJECT_ARRAY_INSTANTIATION);\n+\n+    current.objectArrayInstantiation(arrayClassName, lengthAsString, objectId);\n+  }\n+\n+  /** Event method that denotes the instantiation of a primitive array.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param arrayClassName The array's class name.\n+  * @param objectId An ObjectId instance which can be activated later.\n+  * @param lengthAsString The array's length as String.\n+  */\n+  void primitiveArrayInstantiation(String arrayClassName, String lengthAsString,\n+                                ObjectId objectId)\n+  {\n+    transition(ScannerState.TRANSITION_PRIMITIVE_ARRAY_INSTANTIATION);\n+\n+    current.objectArrayInstantiation(arrayClassName, lengthAsString, objectId);\n+  }\n+  \n+  /** Event method that denotes the setting of a value in an array.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param indexAsString The index to as a String.\n+  */\n+  void arraySet(String indexAsString)\n+  {\n+    transition(ScannerState.TRANSITION_ARRAY_SET);\n+\n+    current.arraySet(indexAsString);\n+  }\n+\n+  /** Event method that denotes the retrieval of a value in an array.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  * \n+  * @param indexAsString The index to as a String.\n+  */\n+  void arrayGet(String indexAsString)\n+  {\n+    transition(ScannerState.TRANSITION_ARRAY_GET);\n+\n+    current.arrayGet(indexAsString);\n+  }\n+\n+  /** Event method that denotes the setting of a value in a list.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  */\n+  void listSet()\n+  {\n+    transition(ScannerState.TRANSITION_LIST_SET);\n+\n+    current.listSet();\n+  }\n+\n+  /** Event method that denotes the retrieval of a value in a list.\n+  *\n+  * <p>More details about this method can be found in this\n+  * class' introduction.</p>\n+  */\n+  void listGet()\n+  {\n+    transition(ScannerState.TRANSITION_LIST_GET);\n+\n+    current.listGet();\n+  }\n+\n+  /** Event method that denotes the null value.\n+  */\n+  void nullObject()\n+  {\n+    transition(ScannerState.TRANSITION_NULL_OBJECT);\n+\n+    current.nullObject();\n+  }\n+\n+  /** Event method that denotes a string.\n+   * \n+   * @param string The string that should be written.\n+   */\n+  void stringReference(String string)\n+  {\n+    transition(ScannerState.TRANSITION_STRING_REFERENCE);\n+\n+    current.stringReference(string);\n+  }\n+\n+  /** Event method that denotes a reference to an existing object.\n+   * \n+   * @param id The ObjectId to be used.\n+   */\n+  void objectReference(ObjectId id)\n+  {\n+    transition(ScannerState.TRANSITION_OBJECT_REFERENCE);\n+\n+    current.objectReference(id);\n+  }\n+\n+}"}, {"sha": "888478a8efd4da23da8d984f41a119797fbc548d", "filename": "libjava/classpath/gnu/java/beans/encoder/ScannerState.java", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScannerState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScannerState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FScannerState.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,236 @@\n+/* ScannerState.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.util.HashMap;\n+\n+/** <p>Provides the infrastructure for the state machine and the transition\n+ * mechanism.</p>\n+ * \n+ * <p>Each states knows a set of successor. There can be one successor for\n+ * every transition variant. Furthermore a state knows about a default\n+ * successor which is taken when there is no special setup for a\n+ * transition.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public abstract class ScannerState\n+{\n+\n+  static final int TRANSITION_METHOD_INVOCATION = 0;\n+\n+  static final int TRANSITION_STATIC_METHOD_INVOCATION = 1;\n+\n+  static final int TRANSITION_STATIC_FIELD_ACCESS = 2;\n+\n+  static final int TRANSITION_CLASS_RESOLUTION = 3;\n+\n+  static final int TRANSITION_OBJECT_INSTANTIATION = 4;\n+\n+  static final int TRANSITION_PRIMITIVE_INSTANTIATION = 5;\n+\n+  static final int TRANSITION_OBJECT_ARRAY_INSTANTIATION = 6;\n+\n+  static final int TRANSITION_PRIMITIVE_ARRAY_INSTANTIATION = 7;\n+\n+  static final int TRANSITION_ARRAY_SET = 8;\n+\n+  static final int TRANSITION_ARRAY_GET = 9;\n+\n+  static final int TRANSITION_LIST_SET = 10;\n+\n+  static final int TRANSITION_LIST_GET = 11;\n+\n+  static final int TRANSITION_NULL_OBJECT = 12;\n+\n+  static final int TRANSITION_STRING_REFERENCE = 13;\n+\n+  static final int TRANSITION_OBJECT_REFERENCE = 14;\n+\n+  static final int TRANSITION_FIRST = 0;\n+\n+  static final int TRANSITION_LAST = 14;\n+\n+  static final String DEFAULT_STATE_NAME = \"default\";\n+\n+  String defaultSuccessor = DEFAULT_STATE_NAME;\n+\n+  static String[] transitionNames = { \"METHOD_INVOCATION\", \"STATIC_METHOD_INVOCATION\",\n+                              \"STATIC_FIELD_ACCESS\", \"CLASS_RESOLUTION\",\n+                              \"OBJECT_INSTANTIATION\",\n+                              \"PRIMITIVE_INSTANTIATION\", \"OBJECT_ARRAY_INSTANTIATION\",\n+                              \"PRIMITIVE_ARRAY_INSTANTIATION\",\n+                              \"ARRAY_SET\", \"ARRAY_GET\", \"LIST_SET\", \"LIST_GET\",\n+                              \"NULL_OBJECT\", \"STRING_REFERENCE\", \"OBJECT_REFERENCE\" };\n+\n+  /**\n+   * Stores the transition setup as the relation\n+   * transition->successor's state name.\n+   */\n+  HashMap transitions = new HashMap();\n+  \n+  int calls;\n+  \n+  Context context;\n+  \n+  String name;\n+  \n+  final void init(String newName)\n+  {\n+    assert (name == null);\n+    \n+    name = newName;\n+  }\n+  \n+  final String getName()\n+  {\n+    return name;\n+  }\n+  \n+  final void enter(Context ctx)\n+  {\n+    calls++;\n+    context = ctx;\n+    \n+    enterImpl(ctx);\n+  }\n+  \n+  protected void enterImpl(Context ctx)\n+  {\n+  }\n+  \n+  final Context context()\n+  {\n+    return context;\n+  }\n+  \n+  final int getCalls()\n+  {\n+    return calls;\n+  }\n+\n+  /**\n+   * <p>Stores a successor's state name for a certain transition.</p>\n+   * \n+   * <p>This method is only used at the configuration time of the state\n+   * machine.</p>\n+   * \n+   * @param transition One of the transition constants.\n+   * @param stateName The state name of the successor.\n+   */\n+  final void putSuccessor(int transition, String stateName)\n+  {\n+    assert (transition >= TRANSITION_FIRST && transition <= TRANSITION_LAST) :\n+      \"Transition identifier '\" + transition + \"' is unknown.\";\n+\n+    transitions.put(new Integer(transition), stateName);\n+  }\n+\n+  /** <p>Retrieves a the state name of a successor for the given transition\n+   * constant.</p>\n+   * \n+   * <p>Returns the default successor's state name if no special setup was\n+   * prepared.</p>\n+   * \n+   * @param transition One of the transition constants.\n+   * @return The state name of the successor.\n+   */\n+  final String getSuccessor(int transition)\n+  {\n+    String state = (String) transitions.get(new Integer(transition));\n+\n+    return (state == null) ? defaultSuccessor : state;\n+  }\n+\n+  /**\n+   * Sets the name for the default successor state.\n+   * \n+   * @param newDefaultSuccessor The default successor's state name.\n+   */\n+  final void setDefaultSuccessor(String newDefaultSuccessor)\n+  {\n+    defaultSuccessor = newDefaultSuccessor;\n+  }\n+\n+  abstract void methodInvocation(String methodName);\n+\n+  abstract void staticMethodInvocation(String className, String methodName);\n+\n+  abstract void staticFieldAccess(String className, String fieldName);\n+\n+  abstract void classResolution(String className);\n+\n+  abstract void objectInstantiation(String className, ObjectId objectId);\n+\n+  abstract void primitiveInstantiation(String primitiveName,\n+                                       String valueAsString);\n+\n+  abstract void objectArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId);\n+  \n+  abstract void primitiveArrayInstantiation(String arrayClassName, String lengthAsString, ObjectId objectId);\n+\n+  abstract void arraySet(String indexAsString);\n+\n+  abstract void arrayGet(String indexAsString);\n+\n+  abstract void listGet();\n+\n+  abstract void listSet();\n+\n+  abstract void nullObject();\n+\n+  abstract void stringReference(String string);\n+\n+  abstract void objectReference(ObjectId id);\n+\n+  /**\n+   * <p>A special event that does not provoke a direct transition.</p>\n+   * \n+   * <p>Instead the transition is done by the <code>ScanEngine</code>: It goes\n+   * back to the previous state and just uses this method to inform the state\n+   * about this happening.</p>\n+   */\n+  abstract void end();\n+\n+  void enter()\n+  {\n+  }\n+  \n+}"}, {"sha": "fdb5f7d4571b43d03e02bdc8e71f0b3f99d58c71", "filename": "libjava/classpath/gnu/java/beans/encoder/StAXWriter.java", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FStAXWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FStAXWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FStAXWriter.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,233 @@\n+/* StAXWriter.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+import java.io.OutputStream;\n+\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+/** A {@link Writer} implementation based on the StAX API.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class StAXWriter implements Writer\n+{\n+  XMLStreamWriter writer;\n+\n+  int indent = 0;\n+  \n+  public StAXWriter(OutputStream os)\n+  {\n+    try\n+      {\n+        XMLOutputFactory factory = XMLOutputFactory.newInstance();\n+        writer = factory.createXMLStreamWriter(os);\n+      }\n+    catch (XMLStreamException se)\n+      {\n+        throw (InternalError)\n+          new InternalError(\n+          \"Could not instantiate a streaming XML writer.\")\n+          .initCause(se);\n+      }\n+\n+  }\n+  \n+  public void flush()\n+  {\n+    if (writer != null)\n+      {\n+        try\n+          {\n+            writer.flush();\n+          }\n+        catch (XMLStreamException xse)\n+          {\n+            // TODO: find out\n+          }\n+      }\n+\n+  }\n+\n+  public void close()\n+  {\n+    if (writer != null)\n+      {\n+        try\n+          {\n+            writer.close();\n+          }\n+        catch (XMLStreamException xse)\n+          {\n+            // TODO: find out\n+          }\n+        writer = null;\n+      }\n+\n+  }\n+\n+  public void writePreamble()\n+  {\n+    try\n+      {\n+        writer.writeStartDocument(\"UTF-8\", \"1.0\");\n+      }\n+    catch (XMLStreamException xmlse)\n+      {\n+\n+      }\n+  }\n+\n+  public void writeEnd(boolean wasEmpty)\n+  {\n+    try\n+      {\n+        indent -= 2;\n+\n+        if (wasEmpty)\n+          return;\n+\n+        for (int i = 0; i < indent; i++)\n+          writer.writeCharacters(\" \");\n+\n+        writer.writeEndElement();\n+\n+        writer.writeCharacters(\"\\n\");\n+      }\n+    catch (XMLStreamException xmlse)\n+      {\n+\n+      }\n+  }\n+  \n+  public void writeEndNoChildren()\n+  {\n+    try\n+      {\n+        writer.writeEndElement();\n+        writer.writeCharacters(\"\\n\");\n+      }\n+    catch (XMLStreamException xmlse)\n+      {\n+\n+      }\n+  }\n+\n+  public void write(String tagName, boolean empty)\n+  {\n+    write(tagName, null, null, null, empty);\n+  }\n+\n+  public void write(String tagName, String value)\n+  {\n+    write(tagName, value, null, null, value == null);\n+  }\n+\n+  public void writeNoChildren(String tagName, String value)\n+  {\n+    try\n+      {\n+        for (int i = 0; i < indent; i++)\n+          writer.writeCharacters(\" \");\n+\n+        writer.writeStartElement(tagName);\n+\n+        writer.writeCharacters(value);\n+      }\n+    catch (XMLStreamException xmlse)\n+      {\n+\n+      }\n+  }\n+\n+  public void write(String tagName, String attributeName,\n+                    String attributeValue, boolean empty)\n+  {\n+    write(tagName, null, new String[] { attributeName },\n+          new String[] { attributeValue }, empty);\n+  }\n+\n+  public void write(String tagName, String value, String[] attributeNames,\n+                    String[] attributeValues, boolean empty)\n+  {\n+    try\n+      {\n+        for (int i = 0; i < indent; i++)\n+\n+          writer.writeCharacters(\" \");\n+\n+        if (empty)\n+          writer.writeEmptyElement(tagName);\n+        else\n+          writer.writeStartElement(tagName);\n+\n+        if (attributeNames != null)\n+          for (int i = 0; i < attributeNames.length; i++)\n+            writer.writeAttribute(attributeNames[i], attributeValues[i]);\n+\n+        writer.writeCharacters(\"\\n\");\n+\n+        indent += 2;\n+\n+        if (value != null)\n+          {\n+            for (int i = 0; i < indent; i++)\n+              writer.writeCharacters(\" \");\n+\n+            writer.writeCharacters(value);\n+\n+            writer.writeCharacters(\"\\n\");\n+          }\n+      }\n+    catch (XMLStreamException xmlse)\n+      {\n+\n+      }\n+  }\n+\n+  public void write(String tagName, String[] attributeNames,\n+                    String[] attributeValues, boolean empty)\n+  {\n+    write(tagName, null, attributeNames, attributeValues, empty);\n+  }\n+\n+}"}, {"sha": "57203d23e8290182b9d5699a4e63295fecc532ec", "filename": "libjava/classpath/gnu/java/beans/encoder/Writer.java", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2FWriter.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,174 @@\n+/* Writer.java -- Writing interface for XML persistence.\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder;\n+\n+/** A <code>Writer</code> represents a simplified interface to an XML\n+ * writer that is used for the XML persistence mechanism.\n+ * \n+ * <p>Its sole purpose is to allow multiple backends which may remove\n+ * the need to have certain APIs in the classpath. Eg. it is possible\n+ * to write a stripped down XML Writer that does not rely on SAX, StAX\n+ * or DOM APIs.</p>\n+ * \n+ * <p>The caller may assume that every action is done immediately. However\n+ * it is possible that the underlying implementation uses buffering streams.\n+ * To make sure the data is written call the {@link flush} method.</p>\n+ * \n+ * <p>The <code>Writer</code> implementation should care about the formatting\n+ * of the XML stream making it possible to generate three types of formats using\n+ * a special method invocation chain.</p>\n+ * \n+ * <p>Write\n+ * <code>\n+ * &lt;element/&gt;\n+ * </code>\n+ * by issuing <code>write(\"element\", true)</code> (or any of the other\n+ * write-variants that allows specifying the <code>isEmpty</code> argument)\n+ * and <code>writeEnd(true)</code>.</p>\n+ * \n+ * <p>Write\n+ * <code>\n+ * &lt;element&gt;body&lt;/element&gt;\n+ * </code>\n+ * by issuing <code>writeNoChildren(\"element\", \"body\")</code> and <code>writeNoChildrenEnd()</code>.</p>\n+ * \n+ * <p>\n+ * Write\n+ * <code>\n+ * &lt;element&gt;\n+ *   &lt;child1/&gt;\n+ *   &lt;child2/&gt;\n+ *   ...\n+ * &lt;element/&gt;\n+ * </code>\n+ * by issuing <code>write(\"element\", false)</code> (or any of the other\n+ * write-variants that allows specifying the <code>isEmpty</code> argument)\n+ * and <code>writeEnd(false)</code>.</p>\n+ * \n+ * <p>Note: It is important that the values of <code>isEmpty</code> and\n+ * <code>wasEmpty</code> match. Otherwise strange things might happen to\n+ * the layout.</p>\n+ *\n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public interface Writer\n+{\n+  // TODO: This interface's design is not the best. Feel free to \n+  // improve it as you like.\n+\n+  /** Writes the XML preamble. */\n+  void writePreamble();\n+\n+  /** Writes the end of an XML tag.\n+   * \n+   * <p>If your tag has not generated any body text or child\n+   * elements provide <code>true</code> as the argument to generate\n+   * more space efficient variant of the tag.>/p> \n+   * \n+   * @param wasEmpty Whether the tag was empty or not.\n+   */\n+  void writeEnd(boolean wasEmpty);\n+\n+  /** Writes an XML tag without any attributes. \n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param empty Whether the element has child elements.\n+   */\n+  void write(String tagName, boolean empty);\n+\n+  /** Writes an XML tag with one attribute name and value.\n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param attributeName The name of attribute. \n+   * @param attributeValue The attribute's value.\n+   * @param empty Whether the element has child elements.\n+   */\n+  void write(String tagName, String attributeName, String attributeValue, boolean empty);\n+\n+  /** Writes an XML tag with multiple attributes and a body text.\n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param value The element's body content.\n+   * @param attributeNames A set of attribute names.\n+   * @param attributeValues A set of attribute values.\n+   * @param empty Whether the element has child elements.\n+   */\n+  void write(String tagName, String value, String[] attributeNames,\n+             String[] attributeValues, boolean empty);\n+\n+  /** Writes an XML tag with multiple attributes without a body text.\n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param attributeNames A set of attribute names.\n+   * @param attributeValues A set of attribute values.\n+   * @param empty Whether the element has child elements.\n+   */\n+  void write(String tagName, String[] attributeNames, String[] attributeValues, boolean empty);\n+\n+  /** Writes an XML tag with no attributes but with a body text\n+   * that may have child elements.\n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param value The element's body content.\n+   */\n+  void write(String tagName, String value);\n+\n+  /** Writes an XML tag with no attributes but with a body text\n+   * that does not have child elements.\n+   * \n+   * @param tagName The name of the tag to write.\n+   * @param value The element's body content.\n+   */\n+  void writeNoChildren(String tagName, String value);\n+  \n+  /** Writes the end of an XML tag that has no child elements.\n+   * \n+   * <p>Must be used in combination with {@link writeNoChildren} only.</p>\n+   */\n+  void writeEndNoChildren();\n+\n+  /** Forces the implementation to write some data.\n+   */\n+  void flush();\n+\n+  /** Closes the writer.\n+   */\n+  void close();\n+}"}, {"sha": "a9aef89c7728ffdaa2d7ba58ae191f660db1095b", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/ArrayInstantiation.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArrayInstantiation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArrayInstantiation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArrayInstantiation.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,74 @@\n+/* ArrayInstantiation.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.ObjectId;\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting the instantiation of an array.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class ArrayInstantiation extends Element\n+{\n+  final String className;\n+\n+  final String lengthAsString;\n+\n+  public ArrayInstantiation(String newClassName, String newLengthAsString)\n+  {\n+    className = newClassName;\n+    lengthAsString = newLengthAsString;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    ObjectId objectId = getId();\n+    if (objectId.isUnused())\n+      writer.write(\"array\", new String[] { \"class\", \"length\" },\n+                   new String[] { className, lengthAsString }, isEmpty());\n+    else\n+      writer.write(\"array\", new String[] { \"id\", \"class\", \"length\" },\n+                   new String[] { objectId.toString(), className,\n+                                 lengthAsString }, isEmpty());\n+\n+  }\n+\n+}"}, {"sha": "ca2ce0fa6630f3b959c321e46cd049b8d2dad4cc", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/Array_Get.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Get.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Get.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Get.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,62 @@\n+/* Array_Get.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/**\n+ * Generates an XML element denoting the retrieval of an array value.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public class Array_Get extends Element\n+{\n+  final String indexAsString;\n+\n+  public Array_Get(String newIndexAsString)\n+  {\n+    indexAsString = newIndexAsString;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"void\", \"index\", indexAsString, isEmpty());\n+  }\n+\n+}"}, {"sha": "0962320554828036bb8e7330afc122962d9bd620", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/Array_Set.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Set.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Set.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FArray_Set.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,57 @@\n+/* Array_Set.java -- FIXME: briefly describe file purpose\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+public class Array_Set extends Element\n+{\n+  final String indexAsString;\n+\n+  public Array_Set(String newIndexAsString)\n+  {\n+    indexAsString = newIndexAsString;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"void\", \"index\", indexAsString, isEmpty());\n+  }\n+\n+}"}, {"sha": "8e640d183505694b65fa440ab67a4f87c9dbf904", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/ClassResolution.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FClassResolution.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FClassResolution.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FClassResolution.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,67 @@\n+/* ClassResolution.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting the resolution of a class.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class ClassResolution extends Element\n+{\n+  final String className;\n+\n+  public ClassResolution(String newClassName)\n+  {\n+    className = newClassName;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.writeNoChildren(\"class\", className);\n+  }\n+  \n+  public void writeEnd(Writer writer)\n+  {\n+    writer.writeEndNoChildren();\n+  }\n+\n+}"}, {"sha": "5681d2b76a0350611c48061d2fc0365d23b56f7b", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/Element.java", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FElement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FElement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FElement.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,157 @@\n+/* Element.java -- Base class for object tree elements.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+import gnu.java.beans.encoder.ObjectId;\n+import gnu.java.beans.encoder.Writer;\n+\n+/** <code>Element</code> is the base class for the object tree elements.\n+ * \n+ * <p>It provides the neccessary infrastructure every element subclass\n+ * needs in order to interact with the {@link gnu.java.beans.encoder.Root}\n+ * class.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ */\n+public abstract class Element\n+{\n+  /**\n+   * Stores the child elements.\n+   */\n+  private LinkedList children = new LinkedList();\n+  \n+  /**\n+   * An optional ObjectId instance which is needed for certain subclasses\n+   * only.\n+   */\n+  private ObjectId objectId;\n+  \n+  /** Sets an {@link gnu.java.beans.encoder.ObjectId} instance in this\n+   * <code>Element</code>.\n+   * \n+   * <p>This can only be done once.</p>\n+   * \n+   * @param objectId An ObjectId instance.\n+   */\n+  public final void initId(ObjectId objectId)\n+  {\n+    assert (this.objectId == null);\n+    assert (objectId != null);\n+    \n+    this.objectId = objectId;\n+  }\n+\n+  /** Adds a child element to this <code>Element</code>.\n+   * \n+   * @param elem The new child.\n+   */\n+  public final void addChild(Element elem)\n+  {\n+    children.add(elem);\n+  }\n+  \n+  /** Removes the child element added last.\n+   */\n+  public final void removeLast()\n+  {\n+    children.removeLast();\n+  }\n+  \n+  /** Provides access to the child elements via an iterator.\n+   * \n+   * @return An iterator for the child elements.\n+   */\n+  public final Iterator iterator(){\n+    return children.iterator();\n+  }\n+  \n+  /** Clears all the stored child elements.\n+   * \n+   */\n+  public final void clear()\n+  {\n+   children.clear(); \n+  }\n+  \n+  /** Returns whether this element contains child elements.\n+   * \n+   * <p>This method is useful to decide which formatting variant\n+   * for the XML element can be chosen.</p>\n+   * \n+   * @return Whether the element has child elements.\n+   */\n+  public final boolean isEmpty()\n+  {\n+    return children.isEmpty(); \n+  }\n+  \n+  /** Retrieves the element's {@link gnu.java.beans.encoder.ObjectId} instance\n+   * if it has one.\n+   * \n+   * @return The ObjectId instance or <code>null</code>.\n+   */\n+  public final ObjectId getId()\n+  {\n+    return objectId;\n+  }\n+  \n+  /** Writes the opening XML tag.\n+   * \n+   * @param writer The writer to be used for XML writing.\n+   */\n+  public abstract void writeStart(Writer writer);\n+  \n+  /** Writes the closing XML tag.\n+   * \n+   * <p>By default this does <code>writer.writeEnd(children.isEmpty())</code>.\n+   * Override if neccessary, for example when using the\n+   * {@link gnu.java.beans.encoder.Writer#writeNoChildren}</code> method\n+   * variants. \n+   * \n+   * @param writer The writer to be used for XML writing.\n+   */\n+  public void writeEnd(Writer writer)\n+  {\n+    writer.writeEnd(children.isEmpty());\n+  }\n+  \n+}"}, {"sha": "e73afa8e9170fa8a65d536d8ee6dc1320047d90f", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/List_Get.java", "status": "renamed", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Get.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Get.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Get.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,13 +1,13 @@\n-/* javaio.h - Declaration for common java.io native functions\n-   Copyright (C) 1998, 2004 Free Software Foundation, Inc.\n+/* List_Get.java\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,23 +36,21 @@ obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n \n-#ifndef JAVAIO_H_INCLUDED\n-#define JAVAIO_H_INCLUDED\n+package gnu.java.beans.encoder.elements;\n \n-#include <stddef.h>\n+import gnu.java.beans.encoder.Writer;\n \n-/*\n- * Function Prototypes\n+/** Generates an XML element denoting the retrieval of a list's element.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n  */\n-\n-extern jlong _javaio_get_file_length(JNIEnv *, jint);\n-extern jlong _javaio_skip_bytes(JNIEnv *, jint, jlong);\n-extern jint _javaio_open(JNIEnv *, jstring, int);\n-extern jint _javaio_open_read(JNIEnv *, jstring);\n-extern jint _javaio_open_readwrite(JNIEnv *, jstring);\n-extern void _javaio_close(JNIEnv *, jint fd);\n-extern jint _javaio_read(JNIEnv *, jint, jarray, jint, jint);\n-extern jint _javaio_write(JNIEnv *, jint, jarray, jint, jint);\n-\n-#endif /* JAVAIO_H_INCLUDED */\n-\n+public class List_Get extends Element\n+{\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"object\", \"get\");\n+  }\n+  \n+}", "previous_filename": "libjava/classpath/native/jni/java-io/javaio.h"}, {"sha": "03c73fd20891708746625daa7a4f19eddbacb011", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/List_Set.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Set.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Set.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FList_Set.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,56 @@\n+/* List_Set.java\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting the setting of a list's element.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class List_Set extends Element\n+{\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"object\", \"set\");\n+  }\n+  \n+}"}, {"sha": "d5b317496d5c3b1709e339aa400292414979d380", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/MethodInvocation.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FMethodInvocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FMethodInvocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FMethodInvocation.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,62 @@\n+/* MethodCall.java\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting a non-static method call.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class MethodInvocation extends Element\n+{\n+  final String methodName;\n+  \n+  public MethodInvocation(String newMethodName)\n+  {\n+    methodName = newMethodName;\n+  }\n+  \n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"void\", \"method\", methodName, isEmpty());\n+  }\n+  \n+}"}, {"sha": "599c4d85fc3e48ef8ab145ac0a01c79eecb65c1c", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/NullObject.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FNullObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FNullObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FNullObject.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,61 @@\n+/* NullObject.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting the <code>null</code> value.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class NullObject extends Element\n+{\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"null\", true);\n+  }\n+\n+  public void writeEnd(Writer writer)\n+  {\n+    writer.writeEnd(true);\n+  }\n+\n+}"}, {"sha": "692227d59c584b1935ba63daf13a015b1fd34594", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/ObjectInstantiation.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectInstantiation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectInstantiation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectInstantiation.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,68 @@\n+/* ObjectInstantiation.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.ObjectId;\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting the instantiation of an object.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class ObjectInstantiation extends Element\n+{\n+  final String className;\n+\n+  public ObjectInstantiation(String newClassName)\n+  {\n+    className = newClassName;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    ObjectId objectId = getId();\n+    if (objectId.isUnused())\n+      writer.write(\"object\", \"class\", className, isEmpty());\n+    else\n+      writer.write(\"object\", new String[] { \"id\", \"class\" },\n+                   new String[] { objectId.toString(), className }, isEmpty());\n+  }\n+\n+}"}, {"sha": "a44c2ee605523517a07cb493f3e870427d3ed768", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/ObjectReference.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FObjectReference.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,68 @@\n+/* StringInstantiation.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.ObjectId;\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting referencing an existing object.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class ObjectReference extends Element\n+{\n+  final ObjectId id;\n+\n+  public ObjectReference(ObjectId newId)\n+  {\n+    id = newId;\n+    \n+    // Initializing the Id here is making sure it gets\n+    // actually used. This step modifies the Id instance\n+    // in other elements.\n+    id.init();\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"object\", \"idref\", id.toString(), isEmpty());\n+  }\n+  \n+}"}, {"sha": "db08edbf8a05df59c43171491f09c3c27ea1c894", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/PrimitiveInstantiation.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FPrimitiveInstantiation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FPrimitiveInstantiation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FPrimitiveInstantiation.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,69 @@\n+/* PrimitiveInstantiation.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting a primitive data value.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class PrimitiveInstantiation extends Element\n+{\n+  final String primitiveName;\n+\n+  final String valueAsString;\n+\n+  public PrimitiveInstantiation(String newPrimitiveName, String newValueAsString)\n+  {\n+    primitiveName = newPrimitiveName;\n+    valueAsString = newValueAsString;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.writeNoChildren(primitiveName, valueAsString);\n+  }\n+\n+  public void writeEnd(Writer writer)\n+  {\n+    writer.writeEndNoChildren();\n+  }\n+}"}, {"sha": "7ed935d49a026813deb11991b2d9dee5c8e6f042", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/StaticFieldAccess.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticFieldAccess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticFieldAccess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticFieldAccess.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,66 @@\n+/* StaticFieldAccess.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/** Generates an XML element denoting a static method call.\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class StaticFieldAccess extends Element\n+{\n+  final String className;\n+\n+  final String fieldName;\n+\n+  public StaticFieldAccess(String newClassName, String newFieldName)\n+  {\n+    className = newClassName;\n+    fieldName = newFieldName;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"object\", new String[] { \"class\", \"field\" },\n+                 new String[] { className, fieldName }, isEmpty());\n+  }\n+\n+}"}, {"sha": "40c46a5346b75980e98126c97cb828dc36b5ee1b", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/StaticMethodInvocation.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticMethodInvocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticMethodInvocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStaticMethodInvocation.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,67 @@\n+/* StaticMethodCall.java\n+  -- A class denoting an XML element which makes up a static method call.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+/**\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ *\n+ */\n+public class StaticMethodInvocation extends Element\n+{\n+  final String className;\n+  \n+  final String methodName;\n+  \n+  public StaticMethodInvocation(String newClassName, String newMethodName)\n+  {\n+    className = newClassName;\n+    methodName = newMethodName;\n+  }\n+  \n+  public void writeStart(Writer writer)\n+  {\n+    writer.write(\"void\", new String[] { \"class\", \"method\" },\n+                 new String[] { className, methodName }, isEmpty());\n+  }\n+  \n+}"}, {"sha": "c368e652851652d4ca163013f11e6556ac075efd", "filename": "libjava/classpath/gnu/java/beans/encoder/elements/StringReference.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStringReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStringReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fbeans%2Fencoder%2Felements%2FStringReference.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,63 @@\n+/* StringInstantiation.java\n+  -- A class denoting an XML element which retrieves an array element.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.beans.encoder.elements;\n+\n+import gnu.java.beans.encoder.Writer;\n+\n+public class StringReference extends Element\n+{\n+  final String string;\n+\n+  public StringReference(String newString)\n+  {\n+    string = newString;\n+  }\n+\n+  public void writeStart(Writer writer)\n+  {\n+    writer.writeNoChildren(\"string\", string);\n+  }\n+  \n+  public void writeEnd(Writer writer)\n+  {\n+    writer.writeEndNoChildren();\n+  }\n+\n+}"}, {"sha": "91fd840b862e2ee21a2a686aa2ec80bed03c68f0", "filename": "libjava/classpath/gnu/java/net/CRLFInputStream.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -128,7 +128,7 @@ public int read(byte[] b, int off, int len)\n             in.reset();\n             if (i != -1)\n               {\n-                l = in.read(b, off, i + 1); // read to CR\n+                l = in.read(b, off, (i + 1) - off); // read to CR\n                 in.read(); // skip LF\n                 b[i] = LF; // fix CR as LF\n               }"}, {"sha": "0fcd780dfb9c69b7d7855f8c0b43a967d2cdee57", "filename": "libjava/classpath/gnu/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -38,8 +38,6 @@\n \n package gnu.java.net;\n \n-import gnu.classpath.Configuration;\n-\n import java.io.IOException;\n import java.net.DatagramPacket;\n import java.net.DatagramSocketImpl;\n@@ -64,20 +62,7 @@\n  */\n public final class PlainDatagramSocketImpl extends DatagramSocketImpl\n {\n-  // Static initializer to load native library\n-  static\n-  {\n-    if (Configuration.INIT_LOAD_LIBRARY)\n-      {\n-        System.loadLibrary(\"javanet\");\n-      }\n-  }\n-  \n-  /**\n-   * Option id for the IP_TTL (time to live) value.\n-   */\n-  private static final int IP_TTL = 0x1E61; // 7777\n-\n+   \n   /**\n    * This is the actual underlying file descriptor\n    */\n@@ -98,6 +83,7 @@ public final class PlainDatagramSocketImpl extends DatagramSocketImpl\n    */\n   public PlainDatagramSocketImpl()\n   {\n+    // Nothing to do here.\n   }\n \n   protected void finalize() throws Throwable\n@@ -123,15 +109,48 @@ public int getNativeFD()\n    *\n    * @exception SocketException If an error occurs\n    */\n-  protected synchronized native void bind(int port, InetAddress addr)\n-    throws SocketException;\n+  protected  synchronized void bind(int port, InetAddress addr)\n+    throws SocketException\n+    {\n+      VMPlainDatagramSocketImpl.bind(this, port, addr);\n+    }\n \n   /**\n    * Creates a new datagram socket\n    *\n    * @exception SocketException If an error occurs\n    */\n-  protected synchronized native void create() throws SocketException;\n+  protected  synchronized void create() throws SocketException\n+  {\n+    VMPlainDatagramSocketImpl.create(this);\n+  }\n+\n+  /**\n+   * Connects to the remote address and port specified as arguments.\n+   *\n+   * @param addr The remote address to connect to\n+   * @param port The remote port to connect to\n+   *\n+   * @exception SocketException If an error occurs\n+   */\n+  protected void connect(InetAddress addr, int port) throws SocketException\n+  {\n+    VMPlainDatagramSocketImpl.connect(this, addr, port);\n+  }\n+\n+  /**\n+   * Disconnects the socket.\n+   *\n+   * @since 1.4\n+   */\n+  protected void disconnect()\n+  {\n+    synchronized (this)\n+      {\n+\tif (native_fd != -1)\n+\t  close();\n+      }\n+  }\n \n   /**\n    * Sets the Time to Live value for the socket\n@@ -142,7 +161,7 @@ protected synchronized native void bind(int port, InetAddress addr)\n    */\n   protected synchronized void setTimeToLive(int ttl) throws IOException\n   {\n-    setOption(IP_TTL, new Integer(ttl));\n+    setOption(VMPlainDatagramSocketImpl.IP_TTL, new Integer(ttl));\n   }\n \n   /**\n@@ -154,28 +173,14 @@ protected synchronized void setTimeToLive(int ttl) throws IOException\n    */\n   protected synchronized int getTimeToLive() throws IOException\n   {\n-    Object obj = getOption(IP_TTL);\n+    Object obj = getOption(VMPlainDatagramSocketImpl.IP_TTL);\n \n     if (! (obj instanceof Integer))\n       throw new IOException(\"Internal Error\");\n \n     return ((Integer) obj).intValue();\n   }\n \n-  /**\n-   * Sends a packet of data to a remote host\n-   *\n-   * @param addr The address to send to\n-   * @param port The port to send to \n-   * @param buf The buffer to send\n-   * @param offset The offset of the data in the buffer to send\n-   * @param len The length of the data to send\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  private native void sendto (InetAddress addr, int port,\n-                              byte[] buf, int offset, int len)\n-    throws IOException;\n \n   /**\n    * Sends a packet of data to a remote host\n@@ -186,12 +191,13 @@ private native void sendto (InetAddress addr, int port,\n    */\n   protected void send(DatagramPacket packet) throws IOException\n   {\n-    synchronized(SEND_LOCK)\n+    if (native_fd != -1)\n       {\n-      sendto(packet.getAddress(), packet.getPort(), packet.getData(), \n-             packet.getOffset(), packet.getLength());\n-      }\n-    \n+        synchronized(SEND_LOCK)\n+          {\n+            VMPlainDatagramSocketImpl.send(this, packet);\n+          }\n+      }    \n   }\n \n   /**\n@@ -206,18 +212,10 @@ protected void receive(DatagramPacket packet)\n   {\n       synchronized(RECEIVE_LOCK)\n         {\n-        receive0(packet);\t\t\n+          VMPlainDatagramSocketImpl.receive(this, packet);\t\n         }\n   }\n \n-  /**\n-   * Native call to receive a UDP packet from the network\n-   * \n-   * @param packet The packet to fill in with the data received\n-   *\n-   * @exception IOException IOException If an error occurs\n-   */\n-  private native void receive0(DatagramPacket packet) throws IOException;\n \n   /**\n    * Sets the value of an option on the socket\n@@ -227,8 +225,11 @@ protected void receive(DatagramPacket packet)\n    *\n    * @exception SocketException If an error occurs\n    */\n-  public synchronized native void setOption(int option_id, Object val)\n-    throws SocketException;\n+  public synchronized void setOption(int option_id, Object val)\n+    throws SocketException\n+    {\n+      VMPlainDatagramSocketImpl.setOption(this, option_id, val);\n+    }\n \n   /**\n    * Retrieves the value of an option on the socket\n@@ -239,13 +240,19 @@ public synchronized native void setOption(int option_id, Object val)\n    *\n    * @exception SocketException If an error occurs\n    */\n-  public synchronized native Object getOption(int option_id)\n-    throws SocketException;\n+  public synchronized Object getOption(int option_id)\n+    throws SocketException\n+    {\n+      return VMPlainDatagramSocketImpl.getOption(this, option_id);\n+    }\n \n   /**\n    * Closes the socket\n    */\n-  protected synchronized native void close();\n+  protected synchronized void close()\n+  {\n+    VMPlainDatagramSocketImpl.close(this);\n+  }\n \n   /**\n    * Gets the Time to Live value for the socket\n@@ -282,7 +289,10 @@ protected synchronized void setTTL(byte ttl) throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected synchronized native void join(InetAddress addr) throws IOException;\n+  protected synchronized void join(InetAddress addr) throws IOException\n+  {\n+    VMPlainDatagramSocketImpl.join(this,addr);\n+  }\n \n   /**\n    * Leaves a multicast group\n@@ -291,7 +301,10 @@ protected synchronized void setTTL(byte ttl) throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected synchronized native void leave(InetAddress addr) throws IOException;\n+  protected synchronized void leave(InetAddress addr) throws IOException\n+  {\n+    VMPlainDatagramSocketImpl.leave(this, addr);\n+  }\n \n   /**\n    * What does this method really do?\n@@ -308,14 +321,14 @@ public int peekData(DatagramPacket packet)\n   }\n \n   public void joinGroup(SocketAddress address, NetworkInterface netIf)\n+    throws IOException\n   {\n-    throw new InternalError\n-      (\"PlainDatagramSocketImpl::joinGroup is not implemented\");\n+    VMPlainDatagramSocketImpl.joinGroup(this, address, netIf);\n   }\n \n   public void leaveGroup(SocketAddress address, NetworkInterface netIf)\n+    throws IOException\n   {\n-    throw new InternalError\n-      (\"PlainDatagramSocketImpl::leaveGroup is not implemented\");\n+    VMPlainDatagramSocketImpl.leaveGroup(this, address, netIf);\n   }\n }"}, {"sha": "47d05aa410d850cc6ece2cbb51a5438ceeb154ab", "filename": "libjava/classpath/gnu/java/net/PlainSocketImpl.java", "status": "modified", "additions": 131, "deletions": 113, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -39,17 +39,13 @@\n \n package gnu.java.net;\n \n-import gnu.classpath.Configuration;\n-\n-import java.io.IOException;\n import java.io.InputStream;\n+import java.io.IOException;\n import java.io.OutputStream;\n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n import java.net.SocketException;\n import java.net.SocketImpl;\n-import java.net.SocketOptions;\n \n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n@@ -69,14 +65,6 @@\n  */\n public final class PlainSocketImpl extends SocketImpl\n {\n-  // Static initializer to load native library.\n-  static\n-    {\n-      if (Configuration.INIT_LOAD_LIBRARY)\n-        {\n-          System.loadLibrary(\"javanet\");\n-        }\n-    }\n \n   /**\n    * The OS file handle representing the socket.\n@@ -125,10 +113,11 @@ public final void setInChannelOperation(boolean b)\n   }\n  \n   /**\n-   * Default do nothing constructor\n+   * Default do nothing constructor.\n    */\n   public PlainSocketImpl()\n   {\n+    // Nothing to do here.\n   }\n   \n   protected void finalize() throws Throwable\n@@ -142,6 +131,7 @@ protected void finalize() throws Throwable\n \t    }\n \t  catch (IOException ex)\n \t    {\n+          // Nothing we can do about it.\n \t    }\n       }\n     super.finalize();\n@@ -158,121 +148,111 @@ public int getNativeFD()\n    * Integer.  The option_id parameter is one of the defined constants in\n    * this interface.\n    *\n-   * @param option_id The identifier of the option\n-   * @param val The value to set the option to\n+   * @param optionId The identifier of the option\n+   * @param value The value to set the option to\n    *\n-   * @exception SocketException If an error occurs\n+   * @throws SocketException if an error occurs\n    */\n-  public native void setOption(int optID, Object value) throws SocketException;\n+  public void setOption(int optionId, Object value) throws SocketException\n+  {\n+    VMPlainSocketImpl.setOption(this, optionId, value);\n+  }\n \n   /**\n    * Returns the current setting of the specified option.  The Object returned\n    * will be an Integer for options that have integer values.  The option_id\n    * is one of the defined constants in this interface.\n    *\n-   * @param option_id The option identifier\n+   * @param optionId the option identifier\n    *\n-   * @return The current value of the option\n+   * @return the current value of the option\n    *\n-   * @exception SocketException If an error occurs\n+   * @throws SocketException if an error occurs\n    */\n-  public native Object getOption(int optID) throws SocketException;\n+  public Object getOption(int optionId) throws SocketException\n+  {\n+    return VMPlainSocketImpl.getOption(this, optionId);\n+  }\n \n-  /**\n-   * Flushes the input stream and closes it. If you read from the input stream\n-   * after calling this method a <code>IOException</code> will be thrown.\n-   * \n-   * @throws IOException if an error occurs\n-   */\n-  public native void shutdownInput() throws IOException;\n+  public void shutdownInput() throws IOException\n+  {\n+    VMPlainSocketImpl.shutdownInput(this);\n+  }\n \n-  /**\n-   * Flushes the output stream and closes it. If you write to the output stream\n-   * after calling this method a <code>IOException</code> will be thrown.\n-   * \n-   * @throws IOException if an error occurs\n-   */\n-  public native void shutdownOutput() throws IOException;\n+  public void shutdownOutput() throws IOException\n+  {\n+    VMPlainSocketImpl.shutdownOutput(this);\n+  }\n \n   /**\n    * Creates a new socket that is not bound to any local address/port and\n-   * is not connected to any remote address/port.  This will be created as\n-   * a stream socket if the stream parameter is true, or a datagram socket\n-   * if the stream parameter is false.\n+   * is not connected to any remote address/port.  The stream parameter will be\n+   * ignored since PlainSocketImpl always is a stream socket. Datagram sockets\n+   * are handled by PlainDatagramSocketImpl.\n    *\n-   * @param stream true for a stream socket, false for a datagram socket\n+   * @param stream <code>true</code> for stream sockets, <code>false</code> for\n+   *        datagram sockets\n    */\n-  protected synchronized native void create(boolean stream) throws IOException;\n+  protected synchronized void create(boolean stream) throws IOException\n+  {\n+    VMPlainSocketImpl.create(this);\n+  }\n \n   /**\n    * Connects to the remote hostname and port specified as arguments.\n    *\n-   * @param hostname The remote hostname to connect to\n-   * @param port The remote port to connect to\n+   * @param hostname the remote hostname to connect to\n+   * @param port the remote port to connect to\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException If an error occurs\n    */\n-  protected synchronized void connect(String host, int port) throws IOException\n+  protected synchronized void connect(String hostname, int port)\n+    throws IOException\n   {\n-    connect(InetAddress.getByName(host), port);\n+    connect(InetAddress.getByName(hostname), port);\n   }\n \n   /**\n    * Connects to the remote address and port specified as arguments.\n    *\n-   * @param addr The remote address to connect to\n-   * @param port The remote port to connect to\n+   * @param addr the remote address to connect to\n+   * @param port the remote port to connect to\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException If an error occurs\n    */\n-  protected native void connect(InetAddress addr, int port) throws IOException;\n+  protected void connect(InetAddress addr, int port) throws IOException\n+  {\n+    VMPlainSocketImpl.connect(this, addr, port);\n+  }\n \n   /**\n    * Connects to the remote socket address with a specified timeout.\n    *\n-   * @param timeout The timeout to use for this connect, 0 means infinite.\n+   * @param address the remote address to connect to\n+   * @param timeout the timeout to use for this connect, 0 means infinite.\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException If an error occurs\n    */\n-  protected synchronized void connect(SocketAddress address, int timeout) throws IOException\n+  protected synchronized void connect(SocketAddress address, int timeout)\n+    throws IOException\n   {\n-    InetSocketAddress sockAddr = (InetSocketAddress) address;\n-    InetAddress addr = sockAddr.getAddress();\n-\n-    if (addr == null)\n-      throw new IllegalArgumentException(\"address is unresolved: \" + sockAddr);\n-\n-    int port = sockAddr.getPort();\n-    \n-    if (timeout < 0)\n-      throw new IllegalArgumentException(\"negative timeout\");\n-\n-    Object oldTimeoutObj = null;\n-    \n-    try\n-      {\n- \toldTimeoutObj = this.getOption (SocketOptions.SO_TIMEOUT);\n- \tthis.setOption (SocketOptions.SO_TIMEOUT, new Integer (timeout));\n- \tconnect (addr, port);\n-      }\n-    finally\n-      {\n-\tif (oldTimeoutObj != null)\n-\t  this.setOption (SocketOptions.SO_TIMEOUT, oldTimeoutObj);\n-      }\n+    VMPlainSocketImpl.connect(this, address, timeout);\n   }\n \n   /**\n    * Binds to the specified port on the specified addr.  Note that this addr\n    * must represent a local IP address.  **** How bind to INADDR_ANY? ****\n    *\n-   * @param addr The address to bind to\n-   * @param port The port number to bind to\n+   * @param addr the address to bind to\n+   * @param port the port number to bind to\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException if an error occurs\n    */\n-  protected synchronized native void bind(InetAddress addr, int port)\n-    throws IOException;\n+  protected synchronized void bind(InetAddress addr, int port)\n+    throws IOException\n+  {\n+    VMPlainSocketImpl.bind(this, addr, port);\n+  }\n \n   /**\n    * Starts listening for connections on a socket. The queuelen parameter\n@@ -282,67 +262,112 @@ protected synchronized native void bind(InetAddress addr, int port)\n    *\n    * @param queuelen The length of the pending connection queue\n    * \n-   * @exception IOException If an error occurs\n+   * @throws IOException If an error occurs\n    */\n-  protected synchronized native void listen(int queuelen)\n-    throws IOException;\n+  protected synchronized void listen(int queuelen)\n+    throws IOException\n+  {\n+    VMPlainSocketImpl.listen(this, queuelen);\n+  }\n \n   /**\n    * Accepts a new connection on this socket and returns in in the \n    * passed in SocketImpl.\n    *\n    * @param impl The SocketImpl object to accept this connection.\n    */\n-  protected synchronized native void accept(SocketImpl impl)\n-    throws IOException;\n+  protected synchronized void accept(SocketImpl impl)\n+    throws IOException\n+  {\n+    VMPlainSocketImpl.accept(this, impl);\n+  }\n \n   /**\n    * Returns the number of bytes that the caller can read from this socket\n    * without blocking. \n    *\n-   * @return The number of readable bytes before blocking\n+   * @return the number of readable bytes before blocking\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException if an error occurs\n    */\n-  protected native int available() throws IOException;\n+  protected int available() throws IOException\n+  {\n+    return VMPlainSocketImpl.available(this);\n+  }\n \n   /**\n    * Closes the socket.  This will cause any InputStream or OutputStream\n    * objects for this Socket to be closed as well.\n+   *\n    * <p>\n    * Note that if the SO_LINGER option is set on this socket, then the\n    * operation could block.\n+   * </p>\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException if an error occurs\n    */\n-  protected native void close() throws IOException;\n+  protected void close() throws IOException\n+  {\n+    VMPlainSocketImpl.close(this);\n+  }\n \n   public void sendUrgentData(int data)\n   {\n-    throw new InternalError (\"PlainSocketImpl::sendUrgentData not implemented\");\n+    VMPlainSocketImpl.sendUrgendData(this, data);\n   }\n \n   /**\n    * Internal method used by SocketInputStream for reading data from\n    * the connection.  Reads up to len bytes of data into the buffer\n    * buf starting at offset bytes into the buffer.\n    *\n-   * @return The actual number of bytes read or -1 if end of stream.\n+   * @return the actual number of bytes read or -1 if end of stream.\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException if an error occurs\n+   */\n+  protected int read(byte[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    return VMPlainSocketImpl.read(this, buf, offset, len);\n+  }\n+\n+  /**\n+   * Internal method used by SocketInputStream for reading data from\n+   * the connection.  Reads and returns one byte of data.\n+   *\n+   * @return the read byte\n+   *\n+   * @throws IOException if an error occurs\n    */\n-  protected native int read(byte[] buf, int offset, int len)\n-    throws IOException;\n+  protected int read()\n+    throws IOException\n+  {\n+    return VMPlainSocketImpl.read(this);\n+  }\n \n   /**\n    * Internal method used by SocketOuputStream for writing data to\n    * the connection.  Writes up to len bytes of data from the buffer\n    * buf starting at offset bytes into the buffer.\n    *\n-   * @exception IOException If an error occurs\n+   * @throws IOException If an error occurs\n+   */\n+  protected void write(byte[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    VMPlainSocketImpl.write(this, buf, offset, len);\n+  }\n+\n+  /**\n+   * Internal method used by SocketOuputStream for writing data to\n+   * the connection.  Writes up one byte to the socket.\n+   *\n+   * @throws IOException If an error occurs\n    */\n-  protected native void write(byte[] buf, int offset, int len)\n-    throws IOException;\n+  protected void write(int data) throws IOException\n+  {\n+    VMPlainSocketImpl.write(this, data);\n+  }\n \n   /**\n    * Returns an InputStream object for reading from this socket.  This will\n@@ -356,7 +381,7 @@ protected synchronized InputStream getInputStream() throws IOException\n   {\n     if (in == null)\n       in = new SocketInputStream();\n-    \n+\n     return in;\n   }\n \n@@ -372,15 +397,15 @@ protected synchronized OutputStream getOutputStream() throws IOException\n   {\n     if (out == null)\n       out = new SocketOutputStream();\n-    \n+\n     return out;\n   }\n \n   /**\n    * This class contains an implementation of <code>InputStream</code> for \n    * sockets.  It in an internal only class used by <code>PlainSocketImpl</code>.\n    *\n-   * @author Nic Ferrier (nferrier@tapsellferrier.co.uk)\n+   * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>\n    */\n   final class SocketInputStream\n     extends InputStream\n@@ -412,13 +437,7 @@ public void close() throws IOException\n      */\n     public int read() throws IOException\n     {\n-      byte buf[] = new byte [1];\n-      int bytes_read = read(buf, 0, 1);\n- \n-      if (bytes_read == -1)\n-        return -1;\n-\n-      return buf[0] & 0xFF;\n+      return PlainSocketImpl.this.read();\n     }\n \n     /**\n@@ -450,7 +469,7 @@ public int read (byte[] buf, int offset, int len) throws IOException\n    * <code>getOutputStream method</code>.  It expects only to  be used in that\n    * context.\n    *\n-   * @author Nic Ferrier (nferrier@tapsellferrier.co.uk)\n+   * @author Nic Ferrier  <nferrier@tapsellferrier.co.uk>\n    */\n   final class SocketOutputStream\n     extends OutputStream\n@@ -476,8 +495,7 @@ public void close() throws IOException\n      */\n     public void write(int b) throws IOException\n     {\n-      byte buf[] = { (byte) b };\n-      write(buf, 0, 1);\n+      PlainSocketImpl.this.write(b);\n     }\n \n     /**"}, {"sha": "a557c7d3ba602293efa5efa15ac7e3b90bca83b6", "filename": "libjava/classpath/gnu/java/nio/channels/FileChannelImpl.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* FileChannelImpl.java -- \n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -301,8 +301,10 @@ public MappedByteBuffer map (FileChannel.MapMode mode,\n     else if (mode == MapMode.READ_WRITE || mode == MapMode.PRIVATE)\n       {\n \tnmode = mode == MapMode.READ_WRITE ? '+' : 'c';\n-\tif ((this.mode & (READ|WRITE)) != (READ|WRITE))\n+\tif ((this.mode & WRITE) != WRITE)\n \t  throw new NonWritableChannelException();\n+\tif ((this.mode & READ) != READ)\n+\t  throw new NonReadableChannelException();\n       }\n     else\n       throw new IllegalArgumentException (\"mode: \" + mode);"}, {"sha": "01c2650a81b7c56d949a059a38e238a981de4000", "filename": "libjava/classpath/gnu/java/nio/charset/Provider.java", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* Provider.java -- \n-   Copyright (C) 2002, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,6 +39,8 @@\n \n import java.nio.charset.Charset;\n import java.nio.charset.spi.CharsetProvider;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n@@ -47,6 +49,11 @@\n  * Charset provider for the required charsets.  Used by\n  * {@link Charset#charsetForName} and * {@link Charset#availableCharsets}.\n  *\n+ * Note: This class is a privileged class, because it can be instantiated without\n+ * requiring the RuntimePermission(\"charsetProvider\"). There is a check in\n+ * java.nio.charset.spi.CharsetProvider to skip the security check if the provider\n+ * is an instance of this class.\n+ *\n  * @author Jesse Rosenstock\n  * @author Robert Schuster (thebohemian@gmx.net)\n  * @see Charset\n@@ -55,14 +62,6 @@ public final class Provider extends CharsetProvider\n {\n   private static Provider singleton;\n \n-  static\n-  {\n-    synchronized (Provider.class)\n-      {\n-        singleton = null;\n-      }\n-  }\n-\n   /**\n    * Map from charset name to charset canonical name. The strings\n    * are all lower-case to allow case-insensitive retrieval of\n@@ -232,8 +231,16 @@ private void addCharset (Charset cs)\n \n   public static synchronized Provider provider ()\n   {\n+    // The default provider is safe to instantiate.\n     if (singleton == null)\n-      singleton = new Provider ();\n+      singleton = (Provider) AccessController.doPrivileged\n+\t(new PrivilegedAction()\n+\t  {\n+\t    public Object run()\n+\t    {\n+\t      return new Provider();\n+\t    }\n+\t  });\n     return singleton;\n   }\n }"}, {"sha": "6fd8b7440823a9783ca6a464f3b9d0865d57f574", "filename": "libjava/classpath/gnu/java/nio/charset/iconv/IconvProvider.java", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2Ficonv%2FIconvProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2Ficonv%2FIconvProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnio%2Fcharset%2Ficonv%2FIconvProvider.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* IconvProvider.java --\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -48,20 +48,17 @@\n /**\n  * Charset provider wrapping iconv.\n  *\n+ * Note: This class is a privileged class, because it can be instantiated without\n+ * requiring the RuntimePermission(\"charsetProvider\"). There is a check in\n+ * java.nio.charset.spi.CharsetProvider to skip the security check if the provider\n+ * is an instance of this class.\n+ *\n  * @author Sven de Marothy\n  */\n public final class IconvProvider extends CharsetProvider\n {\n   private static IconvProvider singleton;\n \n-  static\n-    {\n-      synchronized (IconvProvider.class)\n-        {\n-\t  singleton = null;\n-        }\n-    }\n-\n   // Declaring the construtor public may violate the use of singleton.\n   // But it must be public so that an instance of this class can be\n   // created by Class.newInstance(), which is the case when this provider is"}, {"sha": "8097a04663c990bdf6d36e1af20830ec93879354", "filename": "libjava/classpath/gnu/java/rmi/server/UnicastRef.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -47,6 +47,7 @@\n import java.io.ObjectOutputStream;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.rmi.ConnectException;\n import java.rmi.Remote;\n import java.rmi.RemoteException;\n import java.rmi.server.ObjID;\n@@ -195,7 +196,7 @@ public RemoteCall newCall(RemoteObject obj, Operation[] op, int opnum, long hash\n \t\tconn = manager.getConnection();\n \t}\n \tcatch (IOException e1) {\n-\t\tthrow new RemoteException(\"connection failed to host: \" + manager.serverName, e1);\n+\t\tthrow new ConnectException(\"connection failed to host: \" + manager.serverName, e1);\n \t}\n \n     //obj: useless?"}, {"sha": "4b6bd10d9dd52e3990b591649dc3cfc6cea1dafc", "filename": "libjava/classpath/gnu/java/security/Engine.java", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fsecurity%2FEngine.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Fsecurity%2FEngine.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fsecurity%2FEngine.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* Engine -- generic getInstance method.\n-   Copyright (C) 2003  Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -130,7 +130,14 @@ public static Object getInstance(String service, String algorithm,\n                                    Provider provider, Object[] initArgs)\n     throws InvocationTargetException, NoSuchAlgorithmException\n   {\n-    if (service == null || algorithm == null\n+    if (service != null)\n+      service = service.trim();\n+\n+    if (algorithm != null)\n+      algorithm = algorithm.trim();\n+\n+    if (service == null || service.length() == 0\n+        || algorithm == null || algorithm.length() == 0\n         || provider == null || initArgs == null)\n       throw new IllegalArgumentException();\n "}, {"sha": "210a3d8c58b9c0cddb349fd272437ed78d1c341a", "filename": "libjava/classpath/gnu/java/util/WeakIdentityHashMap.java", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FWeakIdentityHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FWeakIdentityHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FWeakIdentityHashMap.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,862 @@\n+/* WeakIdentityHashMap -- an identity hashtable that keeps only weak references\n+   to its keys, allowing the virtual machine to reclaim them\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.util;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A weak hash map has only weak references to the key. This means that it\n+ * allows the key to be garbage collected if it is not used otherwise. If\n+ * this happens, the entry will eventually disappear from the map,\n+ * asynchronously.\n+ *\n+ * <p>Other strange behaviors to be aware of: The size of this map may\n+ * spontaneously shrink (even if you use a synchronized map and synchronize\n+ * it); it behaves as if another thread removes entries from this table\n+ * without synchronization.  The entry set returned by <code>entrySet</code>\n+ * has similar phenomenons: The size may spontaneously shrink, or an\n+ * entry, that was in the set before, suddenly disappears.\n+ *\n+ * <p>A weak hash map is not meant for caches; use a normal map, with\n+ * soft references as values instead, or try {@link LinkedHashMap}.\n+ *\n+ * <p>The weak hash map supports null values and null keys.  The null key\n+ * is never deleted from the map (except explictly of course). The\n+ * performance of the methods are similar to that of a hash map.\n+ *\n+ * <p>The value objects are strongly referenced by this table.  So if a\n+ * value object maintains a strong reference to the key (either direct\n+ * or indirect) the key will never be removed from this map.  According\n+ * to Sun, this problem may be fixed in a future release.  It is not\n+ * possible to do it with the jdk 1.2 reference model, though.\n+ *\n+ * @author Jochen Hoenicke\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ * @author Jeroen Frijters\n+ *\n+ * @see HashMap\n+ * @see WeakReference\n+ * @see WeakHashMap\n+ * @see IdentityHashMap\n+ * @see LinkedHashMap\n+ */\n+public class WeakIdentityHashMap extends AbstractMap implements Map\n+{\n+  /**\n+   * The default capacity for an instance of HashMap.\n+   * Sun's documentation mildly suggests that this (11) is the correct\n+   * value.\n+   */\n+  private static final int DEFAULT_CAPACITY = 11;\n+\n+  /**\n+   * The default load factor of a HashMap.\n+   */\n+  private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n+\n+  /**\n+   * This is used instead of the key value <i>null</i>.  It is needed\n+   * to distinguish between an null key and a removed key.\n+   */\n+  // Package visible for use by nested classes.\n+  static final Object NULL_KEY = new Object();\n+\n+  /**\n+   * The reference queue where our buckets (which are WeakReferences) are\n+   * registered to.\n+   */\n+  private final ReferenceQueue queue;\n+\n+  /**\n+   * The number of entries in this hash map.\n+   */\n+  // Package visible for use by nested classes.\n+  int size;\n+\n+  /**\n+   * The load factor of this WeakIdentityHashMap.  This is the maximum ratio of\n+   * size versus number of buckets.  If size grows the number of buckets\n+   * must grow, too.\n+   */\n+  private float loadFactor;\n+\n+  /**\n+   * The rounded product of the capacity (i.e. number of buckets) and\n+   * the load factor. When the number of elements exceeds the\n+   * threshold, the HashMap calls <code>rehash()</code>.\n+   */\n+  private int threshold;\n+\n+  /**\n+   * The number of structural modifications.  This is used by\n+   * iterators, to see if they should fail.  This doesn't count\n+   * the silent key removals, when a weak reference is cleared\n+   * by the garbage collection.  Instead the iterators must make\n+   * sure to have strong references to the entries they rely on.\n+   */\n+  // Package visible for use by nested classes.\n+  int modCount;\n+\n+  /**\n+   * The entry set.  There is only one instance per hashmap, namely\n+   * theEntrySet.  Note that the entry set may silently shrink, just\n+   * like the WeakIdentityHashMap.\n+   */\n+  private final class WeakEntrySet extends AbstractSet\n+  {\n+    /**\n+     * Non-private constructor to reduce bytecode emitted.\n+     */\n+    WeakEntrySet()\n+    {\n+    }\n+\n+    /**\n+     * Returns the size of this set.\n+     *\n+     * @return the set size\n+     */\n+    public int size()\n+    {\n+      return size;\n+    }\n+\n+    /**\n+     * Returns an iterator for all entries.\n+     *\n+     * @return an Entry iterator\n+     */\n+    public Iterator iterator()\n+    {\n+      return new Iterator()\n+      {\n+        /**\n+         * The entry that was returned by the last\n+         * <code>next()</code> call.  This is also the entry whose\n+         * bucket should be removed by the <code>remove</code> call. <br>\n+         *\n+         * It is null, if the <code>next</code> method wasn't\n+         * called yet, or if the entry was already removed.  <br>\n+         *\n+         * Remembering this entry here will also prevent it from\n+         * being removed under us, since the entry strongly refers\n+         * to the key.\n+         */\n+        WeakBucket.WeakEntry lastEntry;\n+\n+        /**\n+         * The entry that will be returned by the next\n+         * <code>next()</code> call.  It is <code>null</code> if there\n+         * is no further entry. <br>\n+         *\n+         * Remembering this entry here will also prevent it from\n+         * being removed under us, since the entry strongly refers\n+         * to the key.\n+         */\n+        WeakBucket.WeakEntry nextEntry = findNext(null);\n+\n+        /**\n+         * The known number of modification to the list, if it differs\n+         * from the real number, we throw an exception.\n+         */\n+        int knownMod = modCount;\n+\n+        /**\n+         * Check the known number of modification to the number of\n+         * modifications of the table.  If it differs from the real\n+         * number, we throw an exception.\n+         * @throws ConcurrentModificationException if the number\n+         *         of modifications doesn't match.\n+         */\n+        private void checkMod()\n+        {\n+          // This method will get inlined.\n+          cleanQueue();\n+          if (knownMod != modCount)\n+            throw new ConcurrentModificationException(knownMod + \" != \"\n+                                                      + modCount);\n+        }\n+\n+        /**\n+         * Get a strong reference to the next entry after\n+         * lastBucket.\n+         * @param lastEntry the previous bucket, or null if we should\n+         * get the first entry.\n+         * @return the next entry.\n+         */\n+        private WeakBucket.WeakEntry findNext(WeakBucket.WeakEntry lastEntry)\n+        {\n+          int slot;\n+          WeakBucket nextBucket;\n+          if (lastEntry != null)\n+            {\n+              nextBucket = lastEntry.getBucket().next;\n+              slot = lastEntry.getBucket().slot;\n+            }\n+          else\n+            {\n+              nextBucket = buckets[0];\n+              slot = 0;\n+            }\n+\n+          while (true)\n+            {\n+              while (nextBucket != null)\n+                {\n+                  WeakBucket.WeakEntry entry = nextBucket.getEntry();\n+                  if (entry != null)\n+                    // This is the next entry.\n+                    return entry;\n+\n+                  // Entry was cleared, try next.\n+                  nextBucket = nextBucket.next;\n+                }\n+\n+              slot++;\n+              if (slot == buckets.length)\n+                // No more buckets, we are through.\n+                return null;\n+\n+              nextBucket = buckets[slot];\n+            }\n+        }\n+\n+        /**\n+         * Checks if there are more entries.\n+         * @return true, iff there are more elements.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         */\n+        public boolean hasNext()\n+        {\n+          checkMod();\n+          return nextEntry != null;\n+        }\n+\n+        /**\n+         * Returns the next entry.\n+         * @return the next entry.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         * @throws NoSuchElementException if there is no entry.\n+         */\n+        public Object next()\n+        {\n+          checkMod();\n+          if (nextEntry == null)\n+            throw new NoSuchElementException();\n+          lastEntry = nextEntry;\n+          nextEntry = findNext(lastEntry);\n+          return lastEntry;\n+        }\n+\n+        /**\n+         * Removes the last returned entry from this set.  This will\n+         * also remove the bucket of the underlying weak hash map.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         * @throws IllegalStateException if <code>next()</code> was\n+         *         never called or the element was already removed.\n+         */\n+        public void remove()\n+        {\n+          checkMod();\n+          if (lastEntry == null)\n+            throw new IllegalStateException();\n+          modCount++;\n+          internalRemove(lastEntry.getBucket());\n+          lastEntry = null;\n+          knownMod++;\n+        }\n+      };\n+    }\n+  }\n+\n+  /**\n+   * A bucket is a weak reference to the key, that contains a strong\n+   * reference to the value, a pointer to the next bucket and its slot\n+   * number. <br>\n+   *\n+   * It would be cleaner to have a WeakReference as field, instead of\n+   * extending it, but if a weak reference gets cleared, we only get\n+   * the weak reference (by queue.poll) and wouldn't know where to\n+   * look for this reference in the hashtable, to remove that entry.\n+   *\n+   * @author Jochen Hoenicke\n+   */\n+  private static class WeakBucket extends WeakReference\n+  {\n+    /**\n+     * The value of this entry.  The key is stored in the weak\n+     * reference that we extend.\n+     */\n+    Object value;\n+\n+    /**\n+     * The next bucket describing another entry that uses the same\n+     * slot.\n+     */\n+    WeakBucket next;\n+\n+    /**\n+     * The slot of this entry. This should be\n+     * <code>Math.abs(key.hashCode() % buckets.length)</code>.\n+     *\n+     * But since the key may be silently removed we have to remember\n+     * the slot number.\n+     *\n+     * If this bucket was removed the slot is -1.  This marker will\n+     * prevent the bucket from being removed twice.\n+     */\n+    int slot;\n+\n+    /**\n+     * Creates a new bucket for the given key/value pair and the specified\n+     * slot.\n+     * @param key the key\n+     * @param queue the queue the weak reference belongs to\n+     * @param value the value\n+     * @param slot the slot.  This must match the slot where this bucket\n+     *        will be enqueued.\n+     */\n+    public WeakBucket(Object key, ReferenceQueue queue, Object value,\n+                      int slot)\n+    {\n+      super(key, queue);\n+      this.value = value;\n+      this.slot = slot;\n+    }\n+\n+    /**\n+     * This class gives the <code>Entry</code> representation of the\n+     * current bucket.  It also keeps a strong reference to the\n+     * key; bad things may happen otherwise.\n+     */\n+    class WeakEntry implements Map.Entry\n+    {\n+      /**\n+       * The strong ref to the key.\n+       */\n+      Object key;\n+\n+      /**\n+       * Creates a new entry for the key.\n+       * @param key the key\n+       */\n+      public WeakEntry(Object key)\n+      {\n+        this.key = key;\n+      }\n+\n+      /**\n+       * Returns the underlying bucket.\n+       * @return the owning bucket\n+       */\n+      public WeakBucket getBucket()\n+      {\n+        return WeakBucket.this;\n+      }\n+\n+      /**\n+       * Returns the key.\n+       * @return the key\n+       */\n+      public Object getKey()\n+      {\n+        return key == NULL_KEY ? null : key;\n+      }\n+\n+      /**\n+       * Returns the value.\n+       * @return the value\n+       */\n+      public Object getValue()\n+      {\n+        return value;\n+      }\n+\n+      /**\n+       * This changes the value.  This change takes place in\n+       * the underlying hash map.\n+       * @param newVal the new value\n+       * @return the old value\n+       */\n+      public Object setValue(Object newVal)\n+      {\n+        Object oldVal = value;\n+        value = newVal;\n+        return oldVal;\n+      }\n+\n+      /**\n+       * The hashCode as specified in the Entry interface.\n+       * @return the hash code\n+       */\n+      public int hashCode()\n+      {\n+        return System.identityHashCode(key)\n+            ^ (value == null ? 0 : value.hashCode());\n+      }\n+\n+      /**\n+       * The equals method as specified in the Entry interface.\n+       * @param o the object to compare to\n+       * @return true iff o represents the same key/value pair\n+       */\n+      public boolean equals(Object o)\n+      {\n+        if (o instanceof Map.Entry)\n+          {\n+            Map.Entry e = (Map.Entry) o;\n+            return getKey() == e.getKey()\n+              && (value == null ? e.getValue() == null\n+                                : value.equals(e.getValue()));\n+          }\n+        return false;\n+      }\n+\n+      public String toString()\n+      {\n+        return getKey() + \"=\" + value;\n+      }\n+    }\n+\n+    /**\n+     * This returns the entry stored in this bucket, or null, if the\n+     * bucket got cleared in the mean time.\n+     * @return the Entry for this bucket, if it exists\n+     */\n+    WeakEntry getEntry()\n+    {\n+      final Object key = this.get();\n+      if (key == null)\n+        return null;\n+      return new WeakEntry(key);\n+    }\n+  }\n+\n+  /**\n+   * The entry set returned by <code>entrySet()</code>.\n+   */\n+  private final WeakEntrySet theEntrySet;\n+\n+  /**\n+   * The hash buckets.  These are linked lists. Package visible for use in\n+   * nested classes.\n+   */\n+  WeakBucket[] buckets;\n+\n+  /**\n+   * Creates a new weak hash map with default load factor and default\n+   * capacity.\n+   */\n+  public WeakIdentityHashMap()\n+  {\n+    this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * Creates a new weak hash map with default load factor and the given\n+   * capacity.\n+   * @param initialCapacity the initial capacity\n+   * @throws IllegalArgumentException if initialCapacity is negative\n+   */\n+  public WeakIdentityHashMap(int initialCapacity)\n+  {\n+    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+  }\n+\n+  /**\n+   * Creates a new weak hash map with the given initial capacity and\n+   * load factor.\n+   * @param initialCapacity the initial capacity.\n+   * @param loadFactor the load factor (see class description of HashMap).\n+   * @throws IllegalArgumentException if initialCapacity is negative, or\n+   *         loadFactor is non-positive\n+   */\n+  public WeakIdentityHashMap(int initialCapacity, float loadFactor)\n+  {\n+    // Check loadFactor for NaN as well.\n+    if (initialCapacity < 0 || ! (loadFactor > 0))\n+      throw new IllegalArgumentException();\n+    if (initialCapacity == 0)\n+      initialCapacity = 1;\n+    this.loadFactor = loadFactor;\n+    threshold = (int) (initialCapacity * loadFactor);\n+    theEntrySet = new WeakEntrySet();\n+    queue = new ReferenceQueue();\n+    buckets = new WeakBucket[initialCapacity];\n+  }\n+\n+  /**\n+   * Construct a new WeakIdentityHashMap with the same mappings as the given map.\n+   * The WeakIdentityHashMap has a default load factor of 0.75.\n+   *\n+   * @param m the map to copy\n+   * @throws NullPointerException if m is null\n+   * @since 1.3\n+   */\n+  public WeakIdentityHashMap(Map m)\n+  {\n+    this(m.size(), DEFAULT_LOAD_FACTOR);\n+    putAll(m);\n+  }\n+\n+  /**\n+   * Simply hashes a non-null Object to its array index.\n+   * @param key the key to hash\n+   * @return its slot number\n+   */\n+  private int hash(Object key)\n+  {\n+    return Math.abs(System.identityHashCode(key) % buckets.length);\n+  }\n+\n+  /**\n+   * Cleans the reference queue.  This will poll all references (which\n+   * are WeakBuckets) from the queue and remove them from this map.\n+   * This will not change modCount, even if it modifies the map.  The\n+   * iterators have to make sure that nothing bad happens.  <br>\n+   *\n+   * Currently the iterator maintains a strong reference to the key, so\n+   * that is no problem.\n+   */\n+  // Package visible for use by nested classes.\n+  void cleanQueue()\n+  {\n+    Object bucket = queue.poll();\n+    while (bucket != null)\n+      {\n+        internalRemove((WeakBucket) bucket);\n+        bucket = queue.poll();\n+      }\n+  }\n+\n+  /**\n+   * Rehashes this hashtable.  This will be called by the\n+   * <code>add()</code> method if the size grows beyond the threshold.\n+   * It will grow the bucket size at least by factor two and allocates\n+   * new buckets.\n+   */\n+  private void rehash()\n+  {\n+    WeakBucket[] oldBuckets = buckets;\n+    int newsize = buckets.length * 2 + 1; // XXX should be prime.\n+    threshold = (int) (newsize * loadFactor);\n+    buckets = new WeakBucket[newsize];\n+\n+    // Now we have to insert the buckets again.\n+    for (int i = 0; i < oldBuckets.length; i++)\n+      {\n+        WeakBucket bucket = oldBuckets[i];\n+        WeakBucket nextBucket;\n+        while (bucket != null)\n+          {\n+            nextBucket = bucket.next;\n+\n+            Object key = bucket.get();\n+            if (key == null)\n+              {\n+                // This bucket should be removed; it is probably\n+                // already on the reference queue.  We don't insert it\n+                // at all, and mark it as cleared.\n+                bucket.slot = -1;\n+                size--;\n+              }\n+            else\n+              {\n+                // Add this bucket to its new slot.\n+                int slot = hash(key);\n+                bucket.slot = slot;\n+                bucket.next = buckets[slot];\n+                buckets[slot] = bucket;\n+              }\n+            bucket = nextBucket;\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Finds the entry corresponding to key.  Since it returns an Entry\n+   * it will also prevent the key from being removed under us.\n+   * @param key the key, may be null\n+   * @return The WeakBucket.WeakEntry or null, if the key wasn't found.\n+   */\n+  private WeakBucket.WeakEntry internalGet(Object key)\n+  {\n+    if (key == null)\n+      key = NULL_KEY;\n+    int slot = hash(key);\n+    WeakBucket bucket = buckets[slot];\n+    while (bucket != null)\n+      {\n+        WeakBucket.WeakEntry entry = bucket.getEntry();\n+        if (entry != null && key == entry.key)\n+          return entry;\n+\n+        bucket = bucket.next;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Adds a new key/value pair to the hash map.\n+   * @param key the key. This mustn't exists in the map. It may be null.\n+   * @param value the value.\n+   */\n+  private void internalAdd(Object key, Object value)\n+  {\n+    if (key == null)\n+      key = NULL_KEY;\n+    int slot = hash(key);\n+    WeakBucket bucket = new WeakBucket(key, queue, value, slot);\n+    bucket.next = buckets[slot];\n+    buckets[slot] = bucket;\n+    size++;\n+  }\n+\n+  /**\n+   * Removes a bucket from this hash map, if it wasn't removed before\n+   * (e.g. one time through rehashing and one time through reference queue).\n+   * Package visible for use in nested classes.\n+   *\n+   * @param bucket the bucket to remove.\n+   */\n+  void internalRemove(WeakBucket bucket)\n+  {\n+    int slot = bucket.slot;\n+    if (slot == -1)\n+      // This bucket was already removed.\n+      return;\n+\n+    // Mark the bucket as removed.  This is necessary, since the\n+    // bucket may be enqueued later by the garbage collection, and\n+    // internalRemove will be called a second time.\n+    bucket.slot = -1;\n+\n+    WeakBucket prev = null;\n+    WeakBucket next = buckets[slot];\n+    while (next != bucket)\n+      {\n+         if (next == null)\n+            throw new InternalError(\"WeakIdentityHashMap in inconsistent state\");\n+         prev = next; \n+         next = prev.next;\n+      }\n+    if (prev == null)\n+      buckets[slot] = bucket.next;\n+    else \n+      prev.next = bucket.next;\n+\n+    size--;\n+  }\n+\n+  /**\n+   * Returns the size of this hash map.  Note that the size() may shrink\n+   * spontaneously, if the some of the keys were only weakly reachable.\n+   * @return the number of entries in this hash map.\n+   */\n+  public int size()\n+  {\n+    cleanQueue();\n+    return size;\n+  }\n+\n+  /**\n+   * Tells if the map is empty.  Note that the result may change\n+   * spontanously, if all of the keys were only weakly reachable.\n+   * @return true, iff the map is empty.\n+   */\n+  public boolean isEmpty()\n+  {\n+    cleanQueue();\n+    return size == 0;\n+  }\n+\n+  /**\n+   * Tells if the map contains the given key.  Note that the result\n+   * may change spontanously, if the key was only weakly\n+   * reachable.\n+   * @param key the key to look for\n+   * @return true, iff the map contains an entry for the given key.\n+   */\n+  public boolean containsKey(Object key)\n+  {\n+    cleanQueue();\n+    return internalGet(key) != null;\n+  }\n+\n+  /**\n+   * Gets the value the key is mapped to.\n+   * @return the value the key was mapped to.  It returns null if\n+   *         the key wasn't in this map, or if the mapped value was\n+   *         explicitly set to null.\n+   */\n+  public Object get(Object key)\n+  {\n+    cleanQueue();\n+    WeakBucket.WeakEntry entry = internalGet(key);\n+    return entry == null ? null : entry.getValue();\n+  }\n+\n+  /**\n+   * Adds a new key/value mapping to this map.\n+   * @param key the key, may be null\n+   * @param value the value, may be null\n+   * @return the value the key was mapped to previously.  It returns\n+   *         null if the key wasn't in this map, or if the mapped value\n+   *         was explicitly set to null.\n+   */\n+  public Object put(Object key, Object value)\n+  {\n+    cleanQueue();\n+    WeakBucket.WeakEntry entry = internalGet(key);\n+    if (entry != null)\n+      return entry.setValue(value);\n+\n+    modCount++;\n+    if (size >= threshold)\n+      rehash();\n+\n+    internalAdd(key, value);\n+    return null;\n+  }\n+\n+  /**\n+   * Removes the key and the corresponding value from this map.\n+   * @param key the key. This may be null.\n+   * @return the value the key was mapped to previously.  It returns\n+   *         null if the key wasn't in this map, or if the mapped value was\n+   *         explicitly set to null.\n+   */\n+  public Object remove(Object key)\n+  {\n+    cleanQueue();\n+    WeakBucket.WeakEntry entry = internalGet(key);\n+    if (entry == null)\n+      return null;\n+\n+    modCount++;\n+    internalRemove(entry.getBucket());\n+    return entry.getValue();\n+  }\n+\n+  /**\n+   * Returns a set representation of the entries in this map.  This\n+   * set will not have strong references to the keys, so they can be\n+   * silently removed.  The returned set has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.\n+   * @return a set representation of the entries.\n+   */\n+  public Set entrySet()\n+  {\n+    cleanQueue();\n+    return theEntrySet;\n+  }\n+\n+  /**\n+   * Clears all entries from this map.\n+   */\n+  public void clear()\n+  {\n+    super.clear();\n+  }\n+\n+  /**\n+   * Returns true if the map contains at least one key which points to\n+   * the specified object as a value.  Note that the result\n+   * may change spontanously, if its key was only weakly reachable.\n+   * @param value the value to search for\n+   * @return true if it is found in the set.\n+   */\n+  public boolean containsValue(Object value)\n+  {\n+    cleanQueue();\n+    return super.containsValue(value);\n+  }\n+\n+  /**\n+   * Returns a set representation of the keys in this map.  This\n+   * set will not have strong references to the keys, so they can be\n+   * silently removed.  The returned set has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.\n+   * @return a set representation of the keys.\n+   */\n+  public Set keySet()\n+  {\n+    cleanQueue();\n+    return super.keySet();\n+  }\n+\n+  /**\n+   * Puts all of the mappings from the given map into this one. If the\n+   * key already exists in this map, its value is replaced.\n+   * @param m the map to copy in\n+   */\n+  public void putAll(Map m)\n+  {\n+    super.putAll(m);\n+  }\n+\n+  /**\n+   * Returns a collection representation of the values in this map.  This\n+   * collection will not have strong references to the keys, so mappings\n+   * can be silently removed.  The returned collection has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.\n+   * @return a collection representation of the values.\n+   */\n+  public Collection values()\n+  {\n+    cleanQueue();\n+    return super.values();\n+  }\n+} // class WeakIdentityHashMap"}, {"sha": "9ac9b53d1a9c7a20d8ab558acf21cad8528c4f2f", "filename": "libjava/classpath/gnu/regexp/RE.java", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRE.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -374,6 +374,9 @@ protected void initialize(Object patternObj, int cflags, RESyntax syntax, int my\n       //\n       // OPEN QUESTION: \n       //  what is proper interpretation of '{' at start of string?\n+      //\n+      // This method used to check \"repeat.empty.token\" to avoid such regexp\n+      // as \"(a*){2,}\", but now \"repeat.empty.token\" is allowed.\n \n       else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ (unit.bk || quot))) {\n \tint newIndex = getMinMax(pattern,index,minMax,syntax);\n@@ -386,8 +389,6 @@ else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RE\n             throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,newIndex);\n           if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n             throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,newIndex);\n-          if ((currentToken.getMinimumLength() == 0) && (minMax.second == Integer.MAX_VALUE))\n-            throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,newIndex);\n           index = newIndex;\n           currentToken = setRepeated(currentToken,minMax.first,minMax.second,index); \n         }\n@@ -550,13 +551,50 @@ else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk ||\n \tint nested = 0;\n \n \twhile ( ((nextIndex = getCharUnit(pattern,endIndex,unit,false)) > 0)\n-\t\t&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot))) )\n+\t\t&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot))) ) {\n \t  if ((endIndex = nextIndex) >= pLength)\n \t    throw new REException(getLocalizedMessage(\"subexpr.no.end\"),REException.REG_ESUBREG,nextIndex);\n+\t  else if ((unit.ch == '[') && !(unit.bk || quot)) {\n+\t    // I hate to do something similar to the LIST OPERATOR matters\n+\t    // above, but ...\n+\t    int listIndex = nextIndex;\n+\t    if (listIndex < pLength && pattern[listIndex] == '^') listIndex++;\n+\t    if (listIndex < pLength && pattern[listIndex] == ']') listIndex++;\n+\t    int listEndIndex = -1;\n+\t    int listNest = 0;\n+\t    while (listIndex < pLength && listEndIndex < 0) {\n+\t      switch(pattern[listIndex++]) {\n+\t\tcase '\\\\':\n+\t\t  listIndex++;\n+\t\t  break;\n+\t\tcase '[':\n+\t\t  // Sun's API document says that regexp like \"[a-d[m-p]]\"\n+\t\t  // is legal. Even something like \"[[[^]]]]\" is accepted.\n+\t\t  listNest++;\n+\t\t  if (listIndex < pLength && pattern[listIndex] == '^') listIndex++;\n+\t\t  if (listIndex < pLength && pattern[listIndex] == ']') listIndex++;\n+\t\t  break;\n+\t\tcase ']':\n+\t\t  if (listNest == 0)\n+\t\t    listEndIndex = listIndex;\n+\t\t  listNest--;\n+\t\t  break;\n+\t      }\n+\t    }\n+\t    if (listEndIndex >= 0) {\n+\t      nextIndex = listEndIndex;\n+\t      if ((endIndex = nextIndex) >= pLength)\n+\t        throw new REException(getLocalizedMessage(\"subexpr.no.end\"),REException.REG_ESUBREG,nextIndex);\n+\t      else\n+\t        continue;\n+\t    }\n+\t    throw new REException(getLocalizedMessage(\"subexpr.no.end\"),REException.REG_ESUBREG,nextIndex);\n+\t  }\n \t  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot)))\n \t    nested++;\n \t  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot)))\n \t    nested--;\n+\t}\n \n \t// endIndex is now position at a ')','\\)' \n \t// nextIndex is end of string or position after ')' or '\\)'\n@@ -616,6 +654,9 @@ else if ((unit.ch == '.') && !(unit.bk || quot)) {\n \n       // ZERO-OR-MORE REPEAT OPERATOR\n       //  *\n+      //\n+      // This method used to check \"repeat.empty.token\" to avoid such regexp\n+      // as \"(a*)*\", but now \"repeat.empty.token\" is allowed.\n \n       else if ((unit.ch == '*') && !(unit.bk || quot)) {\n \tif (currentToken == null)\n@@ -624,14 +665,15 @@ else if ((unit.ch == '*') && !(unit.bk || quot)) {\n           throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,index);\n \tif (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n \t  throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,index);\n-\tif (currentToken.getMinimumLength() == 0)\n-\t  throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,index);\n \tcurrentToken = setRepeated(currentToken,0,Integer.MAX_VALUE,index);\n       }\n \n       // ONE-OR-MORE REPEAT OPERATOR / POSSESSIVE MATCHING OPERATOR\n       //  + | \\+ depending on RE_BK_PLUS_QM\n       //  not available if RE_LIMITED_OPS is set\n+      //\n+      // This method used to check \"repeat.empty.token\" to avoid such regexp\n+      // as \"(a*)+\", but now \"repeat.empty.token\" is allowed.\n \n       else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ (unit.bk || quot))) {\n \tif (currentToken == null)\n@@ -648,8 +690,6 @@ else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.ge\n \t}\n \telse if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n \t  throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,index);\n-\telse if (currentToken.getMinimumLength() == 0)\n-\t  throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,index);\n \telse\n \t  currentToken = setRepeated(currentToken,1,Integer.MAX_VALUE,index);\n       }"}, {"sha": "6291a3c39609e294b2d9a1f9dedac71976153a28", "filename": "libjava/classpath/gnu/regexp/RETokenRepeated.java", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRETokenRepeated.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRETokenRepeated.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fregexp%2FRETokenRepeated.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -108,6 +108,7 @@ boolean match(CharIndexed input, REMatch mymatch) {\n \tREMatch doables;\n \tREMatch doablesLast;\n \tREMatch recurrent;\n+\tint lastIndex = mymatch.index;\n \n \tdo {\n \t    // Check for stingy match for each possibility.\n@@ -151,6 +152,15 @@ boolean match(CharIndexed input, REMatch mymatch) {\n \t    ++numRepeats;\n \t    \n \t    positions.addElement(newMatch);\n+\n+\t    // doables.index == lastIndex means an empty string\n+\t    // was the longest that matched this token.\n+\t    // We break here, otherwise we will fall into an endless loop.\n+\t    if (doables.index == lastIndex) {\n+\t\tif (numRepeats < min) numRepeats = min;\n+\t\tbreak;\n+\t    }\t\t\n+\t    lastIndex = doables.index;\n \t} while (numRepeats < max);\n \t\n \t// If there aren't enough repeats, then fail\n@@ -165,7 +175,16 @@ boolean match(CharIndexed input, REMatch mymatch) {\n \tREMatch allResultsLast = null;\n \n \tREMatch results = null;\n-\twhile (--posIndex >= min) {\n+\tint indexCount = posIndex - min;\n+\tif (indexCount <= 0) {\n+\t    // This case occurs when we exited the previous do loop before\n+\t    // numRepeats >= min because an empty string matched the token.\n+\t    // In this case, an empty string can match as many times as\n+\t    // desired.\n+\t    indexCount = 1;\n+\t}\n+\twhile (indexCount-- > 0) {\n+\t    --posIndex;\n \t    newMatch = (REMatch) positions.elementAt(posIndex);\n \t    results = matchRest(input, newMatch);\n \t    if (results != null) {"}, {"sha": "e7c4d5a3f643353feece4122a5cd36ae37508882", "filename": "libjava/classpath/gnu/xml/aelfred2/SAXDriver.java", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -655,21 +655,6 @@ void startDocument()\n     attributesList.clear();\n   }\n \n-  void xmlDecl(String version,\n-               String encoding,\n-               boolean standalone,\n-               String inputEncoding)\n-    throws SAXException\n-  {\n-    if (contentHandler instanceof ContentHandler2)\n-      {\n-        ((ContentHandler2) contentHandler).xmlDecl(version,\n-                                                   encoding,\n-                                                   standalone,\n-                                                   inputEncoding);\n-      }\n-  }\n-\n   void skippedEntity(String name)\n     throws SAXException\n   {"}, {"sha": "ab2ed16f94688de93776e20cdbc1a1a41b3a4dd7", "filename": "libjava/classpath/gnu/xml/aelfred2/XmlParser.java", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -841,9 +841,6 @@ else if (!\"no\".equals(standalone))\n       {\n         inputEncoding = encodingName;\n       }\n-    handler.xmlDecl(version, encodingName, docIsStandalone,\n-                    inputEncoding);\n-    \n     return encodingName;\n   }\n "}, {"sha": "026e2754ef951ff9d00472288060105333015c27", "filename": "libjava/classpath/gnu/xml/dom/Consumer.java", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FConsumer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FConsumer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FConsumer.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -301,22 +301,6 @@ public void startDocument () throws SAXException\n             doc.setBuilding(true);\n \t}\n \n-        /**\n-         * Required by DOM Level 3 to report document parameters\n-         */\n-        public void xmlDecl(String version,\n-                            String encoding,\n-                            boolean standalone,\n-                            String inputEncoding)\n-          throws SAXException\n-        {\n-          super.xmlDecl(version, encoding, standalone, inputEncoding);\n-\n-          DomDocument doc = (DomDocument) getDocument();\n-          doc.setXmlEncoding(encoding);\n-          doc.setInputEncoding(inputEncoding);\n-        }\n-\n \tpublic void endDocument ()\n \tthrows SAXException\n \t{"}, {"sha": "900d03ac3dcea866bf60d6b38c807641bfe8afac", "filename": "libjava/classpath/gnu/xml/dom/DomDocument.java", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomDocument.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1313,6 +1313,31 @@ public DOMConfiguration getDomConfig()\n     return config;\n   }\n \n+  public boolean isEqualNode(Node arg)\n+  {\n+    if (!super.isEqualNode(arg))\n+      return false;\n+    Document d = (Document) arg;\n+    String dversion = d.getXmlVersion();\n+    if (dversion == null || !dversion.equals(version))\n+      return false;\n+    boolean dstandalone = d.getXmlStandalone();\n+    if (dstandalone != standalone)\n+      return false;\n+    String dencoding = d.getXmlEncoding();\n+    if (dencoding == null || dencoding.equalsIgnoreCase(\"UTF-8\"))\n+      {\n+        if (encoding != null && !encoding.equalsIgnoreCase(\"UTF-8\"))\n+          return false;\n+      }\n+    else\n+      {\n+        if (!dencoding.equals(encoding))\n+          return false;\n+      }\n+    return true;\n+  }\n+\n   public void normalizeDocument()\n   {\n     boolean save = building;"}, {"sha": "f55b084cc944039dcfb395aa6d1001e5598e85e6", "filename": "libjava/classpath/gnu/xml/dom/DomElement.java", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomElement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomElement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomElement.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -519,5 +519,38 @@ public void setIdAttributeNS(String namespaceURI, String localName,\n     Attr attr = (Attr) attrs.getNamedItemNS(namespaceURI, localName);\n     setIdAttributeNode(attr, isId);\n   }\n+\n+  public boolean isEqualNode(Node arg)\n+  {\n+    if (!super.isEqualNode(arg))\n+      return false;\n+    getAttributes();\n+    NamedNodeMap argAttrs = arg.getAttributes();\n+    int len = argAttrs.getLength();\n+    if (argAttrs == null || (len != attributes.length))\n+      return false;\n+    for (int i = 0; i < len; i++)\n+      {\n+        Node argCtx = argAttrs.item(i);\n+        // Don't compare namespace nodes\n+        if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI\n+            .equals(argCtx.getNamespaceURI()))\n+          continue;\n+        // Find corresponding attribute node\n+        DomNode ctx = attributes.first;\n+        for (; ctx != null; ctx = ctx.next)\n+          {\n+            if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI\n+                .equals(ctx.getNamespaceURI()))\n+              continue;\n+            if (!ctx.isEqualNode(argCtx))\n+              continue;\n+            break;\n+          }\n+        if (ctx == null)\n+          return false; // not found\n+      }\n+    return true;\n+  }\n   \n }"}, {"sha": "e3f08e4b4b78f1a1045182014f6716c84ddcd9ee", "filename": "libjava/classpath/gnu/xml/dom/DomNamedNodeMap.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNamedNodeMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNamedNodeMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNamedNodeMap.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -319,7 +319,7 @@ Node removeNamedItem(String uri, String name, boolean ns)\n         if (ns)\n           {\n             String tln = ctx.getLocalName();\n-            if (tln.equals(name))\n+            if (name != null && name.equals(tln))\n               {\n                 String tu = ctx.getNamespaceURI();\n                 if ((tu == null && uri == null) ||"}, {"sha": "93f7c6f64f3818f84a9e5d985b5470b5a94140a7", "filename": "libjava/classpath/gnu/xml/dom/DomNode.java", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2FDomNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -38,6 +38,7 @@\n package gnu.xml.dom;\n \n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n \n@@ -149,7 +150,7 @@\n   boolean readonly;\n \n   // event registrations\n-  private ListenerRecord[] listeners;\n+  private HashSet listeners;\n   private int nListeners;\n \n   // DOM Level 3 userData dictionary.\n@@ -167,19 +168,6 @@\n    */\n   public void compact()\n   {\n-    if (listeners != null && listeners.length != nListeners)\n-      {\n-        if (nListeners == 0)\n-          {\n-            listeners = null;\n-          }\n-        else\n-          {\n-            ListenerRecord[] l = new ListenerRecord[nListeners];\n-            System.arraycopy(listeners, 0, l, 0, nListeners);\n-            listeners = l;\n-          }\n-      }\n   }\n \n   /**\n@@ -201,6 +189,7 @@ protected DomNode(short nodeType, DomDocument owner)\n           }\n       }\n     this.owner = owner;\n+    this.listeners = new HashSet();\n   }\n   \n \n@@ -372,6 +361,16 @@ private void checkMisc(DomNode child)\n             return;\n           }\n         break;\n+      case DOCUMENT_TYPE_NODE:\n+        if (!owner.building)\n+          break;\n+        switch (childNodeType)\n+          {\n+          case COMMENT_NODE:\n+          case PROCESSING_INSTRUCTION_NODE:\n+            return;\n+          }\n+        break;\n       }\n     if (owner.checkingWellformedness)\n       {\n@@ -960,12 +959,6 @@ public int getLength()\n    */\n   public void trimToSize()\n   {\n-    if (listeners != null && listeners.length != nListeners)\n-      {\n-        ListenerRecord[] newKids = new ListenerRecord[length];\n-        System.arraycopy(listeners, 0, newKids, 0, nListeners);\n-        listeners = newKids;\n-      }\n   }\n \n   /**\n@@ -1175,7 +1168,7 @@ public Object clone()\n         node.next = null;\n         \n         node.readonly = false;\n-        node.listeners = null;\n+        node.listeners = new HashSet();\n         node.nListeners = 0;\n         return node;\n \n@@ -1264,16 +1257,17 @@ public int getLength()\n       elementName = name;\n       matchAnyURI = \"*\".equals(uri);\n       matchAnyName = \"*\".equals(name);\n-      \n+\n       DomNode.this.addEventListener(\"DOMNodeInserted\", this, true);\n       DomNode.this.addEventListener(\"DOMNodeRemoved\", this, true);\n     }\n \n     void detach()\n     {\n-      current.detach();\n+      if (current != null)\n+        current.detach();\n       current = null;\n-      \n+\n       DomNode.this.removeEventListener(\"DOMNodeInserted\", this, true);\n       DomNode.this.removeEventListener(\"DOMNodeRemoved\", this, true);\n     }\n@@ -1336,6 +1330,8 @@ public void handleEvent(Event e)\n           return;\n         }\n       \n+      if (current != null)\n+\tcurrent.detach();\n       current = null;\n     }\n \n@@ -1354,16 +1350,19 @@ public Node item(int index)\n           lastIndex--;\n         }\n         Node ret = current.previousNode ();\n+\tcurrent.detach();\n         current = null;\n         return ret;\n       } \n       \n       // somewhere after last node\n       while (++lastIndex != index)\n         current.nextNode ();\n-        Node ret = current.nextNode ();\n-        current = null;\n-        return ret;\n+\n+      Node ret = current.nextNode ();\n+      current.detach();\n+      current = null;\n+      return ret;\n     }\n     \n     public int getLength()\n@@ -1375,7 +1374,7 @@ public int getLength()\n         {\n           retval++;\n         }\n-      current = null;\n+      iter.detach();\n       return retval;\n     }\n     \n@@ -1403,13 +1402,18 @@ public int getLength()\n       this.useCapture = useCapture;\n     }\n \n-    boolean equals(ListenerRecord rec)\n+    public boolean equals(Object o)\n     {\n+      ListenerRecord rec = (ListenerRecord)o;\n       return listener == rec.listener\n         && useCapture == rec.useCapture\n         && type == rec.type;\n     }\n     \n+    public int hashCode()\n+    {\n+\treturn listener.hashCode() ^ type.hashCode();\n+    }\n   }\n \n   /**\n@@ -1464,30 +1468,12 @@ public final void addEventListener(String type,\n                                      EventListener listener,\n                                      boolean useCapture)\n   {\n-    if (listeners == null)\n-      {\n-        listeners = new ListenerRecord[1];\n-      }\n-    else if (nListeners == listeners.length)\n-      {\n-        ListenerRecord[] newListeners =\n-          new ListenerRecord[listeners.length + NKIDS_DELTA];\n-        System.arraycopy(listeners, 0, newListeners, 0, nListeners);\n-        listeners = newListeners;\n-      }\n-\n     // prune duplicates\n     ListenerRecord record;\n \n     record = new ListenerRecord(type, listener, useCapture);\n-    for (int i = 0; i < nListeners; i++)\n-      {\n-        if (record.equals(listeners[i]))\n-          {\n-            return;\n-          }\n-      }\n-    listeners [nListeners++] = record;\n+    listeners.add(record);\n+    nListeners = listeners.size();\n   }\n \n   // XXX this exception should be discarded from DOM\n@@ -1672,11 +1658,14 @@ private void notifyNode(DomEvent e,\n                           ListenerRecord[] notificationSet)\n   {\n     int count = 0;\n+    Iterator iter;\n+\n+    iter = current.listeners.iterator();\n \n     // do any of this set of listeners get notified?\n-    for (int i = 0; i < current.nListeners; i++)\n+    while (iter.hasNext())\n       {\n-        ListenerRecord rec = current.listeners[i];\n+        ListenerRecord rec = (ListenerRecord)iter.next();\n \n         if (rec.useCapture != capture)\n           {\n@@ -1697,25 +1686,29 @@ private void notifyNode(DomEvent e,\n           }\n         notificationSet[count++] = rec;\n       }\n+    iter = null;\n \n     // Notify just those listeners\n     e.currentNode = current; \n     for (int i = 0; i < count; i++)\n       {\n         try\n           {\n+\t    iter = current.listeners.iterator();\n             // Late in the DOM CR process (3rd or 4th CR?) the\n             // removeEventListener spec became asymmetric with respect\n             // to addEventListener ... effect is now immediate.\n-            for (int j = 0; j < current.nListeners; j++)\n+\t    while (iter.hasNext())\n               {\n-                if (current.listeners[j].equals(notificationSet[i]))\n+\t\tListenerRecord rec = (ListenerRecord)iter.next();\n+\n+                if (rec.equals(notificationSet[i]))\n                   {\n                     notificationSet[i].listener.handleEvent(e);\n                     break;\n                   }\n               }\n-            \n+            iter = null;\n           }\n         catch (Exception x)\n           {\n@@ -1733,36 +1726,8 @@ public final void removeEventListener(String type,\n                                         EventListener listener,\n                                         boolean useCapture)\n   {\n-    for (int i = 0; i < nListeners; i++)\n-      {\n-        if (listeners[i].listener != listener)\n-          {\n-            continue;\n-          }\n-        if (listeners[i].useCapture != useCapture)\n-          {\n-            continue;\n-          }\n-        if (!listeners[i].type.equals(type))\n-          {\n-            continue;\n-          }\n-\n-        if (nListeners == 1)\n-          {\n-            listeners = null;\n-            nListeners = 0;\n-          }\n-        else\n-          {\n-            for (int j = i + 1; j < nListeners; j++)\n-              {\n-                listeners[i++] = listeners[j++];\n-              }\n-            listeners[--nListeners] = null;\n-          }\n-        break;\n-      }\n+    listeners.remove(new ListenerRecord(type, listener, useCapture));\n+    nListeners = listeners.size();\n     // no exceptions reported\n   }\n \n@@ -1779,10 +1744,15 @@ public final void normalize()\n     readonly = false;\n     for (DomNode ctx = first; ctx != null; ctx = ctx.next)\n       {\n+        boolean saved2 = ctx.readonly;\n+        ctx.readonly = false;\n         switch (ctx.nodeType)\n           {\n           case TEXT_NODE:\n-            while (ctx.next != null && ctx.next.nodeType == TEXT_NODE)\n+          case CDATA_SECTION_NODE:\n+            while (ctx.next != null &&\n+                   (ctx.next.nodeType == TEXT_NODE ||\n+                    ctx.next.nodeType == CDATA_SECTION_NODE))\n               {\n                 Text text = (Text) ctx;\n                 text.appendData(ctx.next.getNodeValue());\n@@ -1794,7 +1764,11 @@ public final void normalize()\n             int len = attrs.getLength();\n             for (int i = 0; i < len; i++)\n               {\n-                attrs.item(i).normalize();\n+                DomNode attr = (DomNode) attrs.item(i);\n+                boolean saved3 = attr.readonly;\n+                attr.readonly = false;\n+                attr.normalize();\n+                attr.readonly = saved3;\n               }\n             // Fall through\n           case DOCUMENT_NODE:\n@@ -1804,6 +1778,7 @@ public final void normalize()\n             ctx.normalize();\n             break;\n           }\n+        ctx.readonly = saved2;\n       }\n     readonly = saved;\n   }\n@@ -2017,39 +1992,56 @@ public String lookupNamespaceURI(String prefix)\n   public boolean isEqualNode(Node arg)\n   {\n     if (this == arg)\n-      {\n-        return true;\n-      }\n+      return true;\n     if (arg == null)\n+      return false;\n+    if (nodeType != arg.getNodeType())\n+      return false;\n+    switch (nodeType)\n       {\n-        return false;\n-      }\n-    if (nodeType != arg.getNodeType() ||\n-        !equal(getNodeName(), arg.getNodeName()) ||\n-        !equal(getLocalName(), arg.getLocalName()) ||\n-        !equal(getNamespaceURI(), arg.getNamespaceURI()) ||\n-        !equal(getPrefix(), arg.getPrefix()) ||\n-        !equal(getNodeValue(), arg.getNodeValue()))\n-      {\n-        return false;\n+      case ELEMENT_NODE:\n+      case ATTRIBUTE_NODE:\n+        if (!equal(getLocalName(), arg.getLocalName()) ||\n+            !equal(getNamespaceURI(), arg.getNamespaceURI()))\n+          return false;\n+        break;\n+      case PROCESSING_INSTRUCTION_NODE:\n+        if (!equal(getNodeName(), arg.getNodeName()) ||\n+            !equal(getNodeValue(), arg.getNodeValue()))\n+          return false;\n+        break;\n+      case COMMENT_NODE:\n+      case TEXT_NODE:\n+      case CDATA_SECTION_NODE:\n+        if (!equal(getNodeValue(), arg.getNodeValue()))\n+          return false;\n+        break;\n       }\n     // Children\n     Node argCtx = arg.getFirstChild();\n     getFirstChild(); // because of DomAttr lazy children\n-    for (DomNode ctx = first; ctx != null; ctx = ctx.next)\n+    DomNode ctx = first;\n+    for (; ctx != null && argCtx != null; ctx = ctx.next)\n       {\n-        if (!ctx.isEqualNode(argCtx))\n+        if (nodeType == DOCUMENT_NODE)\n           {\n-            return false;\n+            // Ignore whitespace outside document element\n+            while (ctx != null && ctx.nodeType == TEXT_NODE)\n+              ctx = ctx.next;\n+            while (argCtx != null && ctx.getNodeType() == TEXT_NODE)\n+              argCtx = argCtx.getNextSibling();\n+            if (ctx == null && argCtx != null)\n+              return false;\n+            else if (argCtx == null && ctx != null)\n+              return false;\n           }\n+        if (!ctx.isEqualNode(argCtx))\n+          return false;\n         argCtx = argCtx.getNextSibling();\n       }\n-    if (argCtx != null)\n-      {\n-        return false;\n-      }\n+    if (ctx != null || argCtx != null)\n+      return false;\n     \n-    // TODO Attr NamedNodeMap\n     // TODO DocumentType\n     return true;\n   }\n@@ -2185,5 +2177,14 @@ String nodeTypeToString(short nodeType)\n       }\n   }\n \n+  public void list(java.io.PrintStream out, int indent)\n+  {\n+    for (int i = 0; i < indent; i++)\n+      out.print(\" \");\n+    out.println(toString());\n+    for (DomNode ctx = first; ctx != null; ctx = ctx.next)\n+      ctx.list(out, indent + 1);\n+  }\n+\n }\n "}, {"sha": "7ac4cc749fc5ff32b47296763f2d712d819e8f73", "filename": "libjava/classpath/gnu/xml/dom/ls/DomLSParser.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FDomLSParser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FDomLSParser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FDomLSParser.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -260,6 +260,7 @@ private Document doParse(LSInput input)\n     eventSink.coalescing = coalescing;\n     // get and configure reader\n     XMLReader reader = getXMLReader();\n+    eventSink.reader = reader;\n     try\n       {\n         reader.setContentHandler(eventSink);"}, {"sha": "aad5ac76e701e2e6f0eaae5c62b7f0ca098dca98", "filename": "libjava/classpath/gnu/xml/dom/ls/SAXEventSink.java", "status": "modified", "additions": 104, "deletions": 78, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FSAXEventSink.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FSAXEventSink.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fdom%2Fls%2FSAXEventSink.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -37,6 +37,7 @@\n \n package gnu.xml.dom.ls;\n \n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n@@ -45,38 +46,55 @@\n import org.w3c.dom.DocumentType;\n import org.w3c.dom.Element;\n import org.w3c.dom.Entity;\n+import org.w3c.dom.EntityReference;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.Text;\n import org.xml.sax.Attributes;\n+import org.xml.sax.ContentHandler;\n import org.xml.sax.DTDHandler;\n import org.xml.sax.Locator;\n import org.xml.sax.SAXException;\n+import org.xml.sax.SAXNotRecognizedException;\n+import org.xml.sax.SAXNotSupportedException;\n+import org.xml.sax.XMLReader;\n import org.xml.sax.ext.Attributes2;\n import org.xml.sax.ext.DeclHandler;\n import org.xml.sax.ext.LexicalHandler;\n-import gnu.xml.aelfred2.ContentHandler2;\n+import org.xml.sax.ext.Locator2;\n import gnu.xml.dom.DomAttr;\n import gnu.xml.dom.DomDocument;\n import gnu.xml.dom.DomDoctype;\n+import gnu.xml.dom.DomNode;\n \n /**\n  * A SAX content and lexical handler used to construct a DOM document.\n  *\n  * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n  */\n class SAXEventSink\n-  implements ContentHandler2, LexicalHandler, DTDHandler, DeclHandler\n+  implements ContentHandler, LexicalHandler, DTDHandler, DeclHandler\n {\n \n   private static final String XMLNS_URI = XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n   private static final String XMLNS_PREFIX = XMLConstants.XMLNS_ATTRIBUTE;\n+  private static final HashSet PREDEFINED_ENTITIES = new HashSet();\n+  static\n+  {\n+    PREDEFINED_ENTITIES.add(\"amp\");\n+    PREDEFINED_ENTITIES.add(\"lt\");\n+    PREDEFINED_ENTITIES.add(\"gt\");\n+    PREDEFINED_ENTITIES.add(\"quot\");\n+    PREDEFINED_ENTITIES.add(\"apos\");\n+  }\n \n   boolean namespaceAware;\n   boolean ignoreWhitespace;\n   boolean expandEntityReferences;\n   boolean ignoreComments;\n   boolean coalescing;\n+\n+  XMLReader reader; // reference back to the parser to get features\n   \n   DomDocument doc; // document being constructed\n   Node ctx; // current context (parent node)\n@@ -110,20 +128,42 @@ public void startDocument()\n     doc.setStrictErrorChecking(false);\n     doc.setBuilding(true);\n     ctx = doc;\n-  }\n \n-  public void xmlDecl(String version, String encoding, boolean standalone,\n-                      String inputEncoding)\n-    throws SAXException\n-  {\n-    if (interrupted)\n+    final String FEATURES = \"http://xml.org/sax/features/\";\n+    final String PROPERTIES = \"http://xml.org/sax/properties/\";\n+    final String GNU_PROPERTIES = \"http://gnu.org/sax/properties/\";\n+\n+    boolean standalone = reader.getFeature(FEATURES + \"is-standalone\");\n+    doc.setXmlStandalone(standalone);\n+    try\n+      {\n+        String version = (String) reader.getProperty(PROPERTIES +\n+                                                     \"document-xml-version\");\n+        doc.setXmlVersion(version);\n+      }\n+    catch (SAXNotRecognizedException e)\n+      {\n+      }\n+    catch (SAXNotSupportedException e)\n+      {\n+      }\n+    if (locator != null && locator instanceof Locator2)\n+      {\n+        String encoding = ((Locator2) locator).getEncoding();\n+        doc.setInputEncoding(encoding);\n+      }\n+    try\n+      {\n+        String encoding = (String) reader.getProperty(GNU_PROPERTIES +\n+                                                      \"document-xml-encoding\");\n+        doc.setXmlEncoding(encoding);\n+      }\n+    catch (SAXNotRecognizedException e)\n+      {\n+      }\n+    catch (SAXNotSupportedException e)\n       {\n-        return;\n       }\n-    doc.setXmlVersion(version);\n-    doc.setXmlEncoding(encoding);\n-    doc.setXmlStandalone(standalone);\n-    doc.setInputEncoding(inputEncoding);\n   }\n \n   public void endDocument()\n@@ -265,7 +305,7 @@ public void endElement(String uri, String localName, String qName)\n   public void characters(char[] c, int off, int len)\n     throws SAXException\n   {\n-    if (interrupted)\n+    if (interrupted || len < 1)\n       {\n         return;\n       }\n@@ -301,11 +341,8 @@ public void processingInstruction(String target, String data)\n       {\n         return;\n       }\n-    if (!inDTD)\n-      {\n-        Node pi = createProcessingInstruction(target, data);\n-        ctx.appendChild(pi);\n-      }\n+    Node pi = createProcessingInstruction(target, data);\n+    ctx.appendChild(pi);\n   }\n \n   protected Node createProcessingInstruction(String target, String data)\n@@ -354,26 +391,18 @@ public void endDTD()\n   public void startEntity(String name)\n     throws SAXException\n   {\n+    if (interrupted)\n+      return;\n     DocumentType doctype = doc.getDoctype();\n     if (doctype == null)\n       {\n         throw new SAXException(\"SAX parser error: \" +\n                                \"reference to entity in undeclared doctype\");\n       }\n     if (\"[dtd]\".equals(name) || name.charAt(0) == '%')\n-      {\n-        // Ignore DTD and parameter entities\n-        ctx = doctype;\n-        return;\n-      }\n-    if (\"lt\".equals(name) ||\n-        \"gt\".equals(name) ||\n-        \"amp\".equals(name) ||\n-        \"apos\".equals(name) ||\n-        \"quot\".equals(name))\n-      {\n-        return;\n-      }\n+      return;\n+    if (PREDEFINED_ENTITIES.contains(name))\n+      return;\n     // Get entity\n     NamedNodeMap entities = doctype.getEntities();\n     Entity entity = (Entity) entities.getNamedItem(name);\n@@ -382,59 +411,47 @@ public void startEntity(String name)\n         throw new SAXException(\"SAX parser error: \" +\n                                \"reference to undeclared entity: \" + name);\n       }\n-    pushEntity(entity);\n+    EntityReference ref = doc.createEntityReference(name);\n+    // DomDocument populates with the entity replacement text, remove this\n+    Node child = ref.getFirstChild();\n+    while (child != null)\n+      {\n+        Node nextChild = child.getNextSibling();\n+        ref.removeChild(child);\n+        child = nextChild;\n+      }\n+    ctx.appendChild(ref);\n+    ctx = ref;\n   }\n \n   public void endEntity(String name)\n     throws SAXException\n   {\n+    if (interrupted)\n+      return;\n     if (\"[dtd]\".equals(name) || name.charAt(0) == '%')\n-      {\n-        // Ignore DTD and parameter entities\n-        return;\n-      }\n-    if (\"lt\".equals(name) ||\n-        \"gt\".equals(name) ||\n-        \"amp\".equals(name) ||\n-        \"apos\".equals(name) ||\n-        \"quot\".equals(name))\n-      {\n-        return;\n-      }\n-    // Get entity\n-    Entity entity = popEntity();\n-    // TODO resolve external entities to ensure that entity has content\n+      return;\n+    if (PREDEFINED_ENTITIES.contains(name))\n+      return;\n+    // Get entity reference\n+    EntityReference ref = (EntityReference) ctx;\n+    if (!ref.getNodeName().equals(name))\n+      throw new SAXException(\"expecting end of \"+ref.getNodeName()+\" entity\");\n+    ctx = ctx.getParentNode();\n+    if (ref instanceof DomNode)\n+      ((DomNode) ref).makeReadonly();\n     if (expandEntityReferences)\n       {\n-        // Get entity content\n-        for (Node child = entity.getFirstChild(); child != null;\n-             child = child.getNextSibling())\n+        // Move entity content from reference node onto context\n+        Node child = ref.getFirstChild();\n+        while (child != null)\n           {\n+            Node nextChild = child.getNextSibling();\n             ctx.appendChild(child);\n+            child = nextChild;\n           }\n+        ctx.removeChild(ref);\n       }\n-    else\n-      {\n-        Node entityReference = doc.createEntityReference(name);\n-        ctx.appendChild(entityReference);\n-      }\n-  }\n-\n-  void pushEntity(Node entity)\n-  {\n-    if (entityCtx == null)\n-      {\n-        entityCtx = new LinkedList();\n-      }\n-    entityCtx.addLast(ctx);\n-    ctx = entity;\n-  }\n-\n-  Entity popEntity()\n-  {\n-    Entity ret = (Entity) ctx;\n-    ctx = (Node) entityCtx.removeLast();\n-    return ret;\n   }\n \n   public void startCDATA()\n@@ -456,11 +473,8 @@ public void comment(char[] c, int off, int len)\n       {\n         return;\n       }\n-    if (!inDTD)\n-      {\n-        Node comment = createComment(c, off, len);\n-        ctx.appendChild(comment);\n-      }\n+    Node comment = createComment(c, off, len);\n+    ctx.appendChild(comment);\n   }\n \n   protected Node createComment(char[] c, int off, int len)\n@@ -477,6 +491,8 @@ public void notationDecl(String name, String publicId, String systemId)\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"notation decl outside DTD\");\n     DomDoctype doctype = (DomDoctype) ctx;\n     doctype.declareNotation(name, publicId, systemId);\n   }\n@@ -489,6 +505,8 @@ public void unparsedEntityDecl(String name, String publicId, String systemId,\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"unparsed entity decl outside DTD\");\n     DomDoctype doctype = (DomDoctype) ctx;\n     Entity entity = doctype.declareEntity(name, publicId, systemId,\n                                           notationName);\n@@ -503,6 +521,8 @@ public void elementDecl(String name, String model)\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"element decl outside DTD\");\n     // Ignore fake element declarations generated by ValidationConsumer.\n     // If an element is not really declared in the DTD it will not be\n     // declared in the document model.\n@@ -522,6 +542,8 @@ public void attributeDecl(String eName, String aName, String type,\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"attribute decl outside DTD\");\n     DomDoctype doctype = (DomDoctype) ctx;\n     doctype.attributeDecl(eName, aName, type, mode, value);\n   }\n@@ -533,6 +555,8 @@ public void internalEntityDecl(String name, String value)\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"internal entity decl outside DTD\");\n     DomDoctype doctype = (DomDoctype) ctx;\n     Entity entity = doctype.declareEntity(name, null, null, null);\n     if (entity != null)\n@@ -549,6 +573,8 @@ public void externalEntityDecl(String name, String publicId, String systemId)\n       {\n         return;\n       }\n+    if (!inDTD)\n+      throw new SAXException(\"external entity decl outside DTD\");\n     DomDoctype doctype = (DomDoctype) ctx;\n     Entity entity = doctype.declareEntity(name, publicId, systemId, null);\n   }"}, {"sha": "bdbf9281880817547f283ccca1eb0e880f8d7255", "filename": "libjava/classpath/gnu/xml/pipeline/DomConsumer.java", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FDomConsumer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FDomConsumer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FDomConsumer.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -37,7 +37,6 @@\n \n package gnu.xml.pipeline;\n \n-import gnu.xml.aelfred2.ContentHandler2;\n import gnu.xml.util.DomParser;\n \n import org.xml.sax.Attributes;\n@@ -330,7 +329,7 @@ final public Object getProperty (String id)\n      * accepted illegal input data). </p>\n      */\n     public static class Handler\n-\timplements ContentHandler2, LexicalHandler,\n+\timplements ContentHandler, LexicalHandler,\n \t    DTDHandler, DeclHandler\n     {\n \tprotected DomConsumer\t\tconsumer;\n@@ -430,20 +429,6 @@ public void startDocument ()\n \t    top = document;\n \t}\n \n-        // ContentHandler2\n-        public void xmlDecl(String version,\n-                            String encoding,\n-                            boolean standalone,\n-                            String inputEncoding)\n-          throws SAXException\n-        {\n-          if (document != null)\n-            {\n-              document.setXmlVersion(version);\n-              document.setXmlStandalone(standalone);\n-            }\n-        }\n-\n \t// SAX1\n \tpublic void endDocument ()\n \tthrows SAXException"}, {"sha": "a14fb340f1278634f875467806ffd75d96ca4927", "filename": "libjava/classpath/gnu/xml/pipeline/EventFilter.java", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FEventFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FEventFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fpipeline%2FEventFilter.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -44,8 +44,6 @@\n import org.xml.sax.ext.*;\n import org.xml.sax.helpers.XMLFilterImpl;\n \n-import gnu.xml.aelfred2.ContentHandler2;\n-\n /**\n  * A customizable event consumer, used to assemble various kinds of filters\n  * using SAX handlers and an optional second consumer.  It can be constructed\n@@ -138,7 +136,7 @@\n  * @author David Brownell\n  */\n public class EventFilter\n-    implements EventConsumer, ContentHandler2, DTDHandler,\n+    implements EventConsumer, ContentHandler, DTDHandler,\n \t    LexicalHandler, DeclHandler\n {\n     // SAX handlers\n@@ -600,17 +598,6 @@ public void startDocument () throws SAXException\n \t    docNext.startDocument ();\n     }\n \n-    public void xmlDecl(String version, String encoding, boolean standalone,\n-                        String inputEncoding)\n-      throws SAXException\n-    {\n-      if (docNext != null && docNext instanceof ContentHandler2)\n-        {\n-          ((ContentHandler2) docNext).xmlDecl(version, encoding, standalone,\n-                                              inputEncoding);\n-        }\n-    }\n-\n     /** <b>SAX2:</b> passes this callback to the next consumer, if any */\n     public void skippedEntity (String name) throws SAXException\n     {"}, {"sha": "f8287e823fd9ffd455efbf307ac31b37bf7bc1c6", "filename": "libjava/classpath/gnu/xml/stream/BufferedReader.java", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FBufferedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FBufferedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FBufferedReader.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,198 @@\n+/* BufferedReader.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+/**\n+ * A mark-capable buffered reader.\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+class BufferedReader\n+  extends Reader\n+{\n+\n+  static final int DEFAULT_BUFFER_SIZE = 4096;\n+\n+  final Reader in;\n+  char[] buf;\n+  int pos, count, markpos, marklimit, bufferSize;\n+\n+  BufferedReader(Reader in)\n+  {\n+    this(in, DEFAULT_BUFFER_SIZE);\n+  }\n+         \n+  BufferedReader(Reader in, int bufferSize)\n+  {\n+    if (bufferSize < 1)\n+      throw new IllegalArgumentException();\n+    this.in = in;\n+    this.bufferSize = bufferSize;\n+    buf = new char[bufferSize];\n+    pos = count = bufferSize;\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    buf = null;\n+    pos = count = 0;\n+    markpos = -1;\n+    in.close();\n+  }\n+\n+  public void mark(int readlimit)\n+    throws IOException\n+  {\n+    marklimit = readlimit;\n+    markpos = pos;\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    if (pos >= count && !refill())\n+      return -1;\n+    return (int) buf[pos++];\n+  }\n+\n+  public int read(char[] b)\n+    throws IOException\n+  {\n+    return read(b, 0, b.length);\n+  }\n+\n+  public int read(char[] b, int off, int len)\n+    throws IOException\n+  {\n+    if (off < 0 || len < 0 || b.length - off < len)\n+      throw new IndexOutOfBoundsException();\n+    \n+    if (len == 0)\n+      return 0;\n+    \n+    if (pos >= count && !refill())\n+      return -1;\n+                \n+    int ret = Math.min(count - pos, len);\n+    System.arraycopy(buf, pos, b, off, ret);\n+    pos += ret;\n+    off += ret;\n+    len -= ret;\n+    \n+    while (len > 0 && refill())\n+      {\n+        int remain = Math.min(count - pos, len);\n+        System.arraycopy(buf, pos, b, off, remain);\n+        pos += remain;\n+        off += remain;\n+        len -= remain;\n+        ret += remain;\n+      }\n+    \n+    return ret;\n+  }\n+\n+  public void reset()\n+    throws IOException\n+  {\n+    if (markpos == -1)\n+      throw new IOException(buf == null ? \"Stream closed.\" : \"Invalid mark.\");\n+    pos = markpos;\n+  }\n+\n+  public long skip(long n)\n+    throws IOException\n+  {\n+    if (buf == null)\n+      throw new IOException(\"Stream closed.\");\n+    final long origN = n;\n+    while (n > 0L)\n+      {\n+        if (pos >= count && !refill())\n+          break;\n+        int numread = (int) Math.min((long) (count - pos), n);\n+        pos += numread;\n+        n -= numread;\n+      }\n+    return origN - n;\n+  }\n+\n+  private boolean refill()\n+    throws IOException\n+  {\n+    if (buf == null)\n+      throw new IOException(\"Stream closed.\");\n+\n+    int markcount = count - markpos;\n+    if (markpos == -1 || markcount >= marklimit)\n+      {\n+        markpos = -1;\n+        pos = count = 0;\n+      }\n+    else\n+      {\n+        char[] newbuf = buf;\n+        if (markpos < bufferSize)\n+          { \n+            newbuf = new char[count - markpos + bufferSize];\n+          }\n+        System.arraycopy(buf, markpos, newbuf, 0, markcount);\n+        buf = newbuf;\n+        count = markcount;\n+        pos -= markpos;\n+        markpos = 0;\n+      }\n+\n+    int numread = in.read(buf, count, bufferSize);\n+    if (numread <= 0)\n+      return false;\n+\n+    count += numread;\n+    return true;\n+  }\n+\n+}"}, {"sha": "1d214ce52c12744d6894442ec63ad878d897be76", "filename": "libjava/classpath/gnu/xml/stream/CRLFReader.java", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FCRLFReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FCRLFReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FCRLFReader.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,180 @@\n+/* CRLFReader.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+/**\n+ * Filtered reader that normalizes CRLF pairs into LFs.\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+class CRLFReader\n+  extends Reader\n+{\n+\n+  /**\n+   * The CR octet.\n+   */\n+  public static final int CR = 13;\n+\n+  /**\n+   * The LF octet.\n+   */\n+  public static final int LF = 10;\n+\n+  private boolean doReset;\n+\n+  protected Reader in;\n+\n+  /**\n+   * Constructor.\n+   */\n+  protected CRLFReader(Reader in)\n+  {\n+    if (!in.markSupported())\n+      in = new BufferedReader(in);\n+    this.in = in;\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    int c = in.read();\n+    if (c == 13) // CR\n+      {\n+        in.mark(1);\n+        int d = in.read();\n+        if (d == 10) // LF\n+          c = d;\n+        else\n+          in.reset();\n+      }\n+    return c;\n+  }\n+\n+  public int read(char[] b)\n+    throws IOException\n+  {\n+    return read(b, 0, b.length);\n+  }\n+\n+  public int read(char[] b, int off, int len)\n+    throws IOException\n+  {\n+    in.mark(len + 1);\n+    int l = in.read(b, off, len);\n+    if (l > 0)\n+      {\n+        int i = indexOfCRLF(b, off, l);\n+        if (doReset)\n+          {\n+            in.reset();\n+            if (i != -1)\n+              {\n+                l = in.read(b, off, (i + 1) - off); // read to CR\n+                in.read(); // skip LF\n+                b[i] = '\\n'; // fix CR as LF\n+              }\n+            else\n+              l = in.read(b, off, len); // CR(s) but no LF\n+          } \n+      }\n+    return l;\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return in.markSupported();\n+  }\n+\n+  public void mark(int limit)\n+    throws IOException\n+  {\n+    in.mark(limit);\n+  }\n+\n+  public void reset()\n+    throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  public long skip(long n)\n+    throws IOException\n+  {\n+    return in.skip(n);\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    in.close();\n+  }\n+\n+  private int indexOfCRLF(char[] b, int off, int len)\n+    throws IOException\n+  {\n+    doReset = false;\n+    int lm1 = len - 1;\n+    for (int i = off; i < len; i++)\n+      {\n+        if (b[i] == '\\r') // CR\n+          {\n+            int d;\n+            if (i == lm1)\n+              {\n+                d = in.read();\n+                doReset = true;\n+              }\n+            else\n+              d = b[i + 1];\n+            if (d == '\\n') // LF\n+              {\n+                doReset = true;\n+                return i;\n+              }\n+          }\n+      }\n+    return -1;\n+  }\n+\n+}\n+"}, {"sha": "54c8b36244bda365d8f589b020ecddbdb9ceb093", "filename": "libjava/classpath/gnu/xml/stream/SAXParser.java", "status": "added", "additions": 966, "deletions": 0, "changes": 966, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParser.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,966 @@\n+/* SAXParser.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.net.URL;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.xml.XMLConstants;\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.Location;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLReporter;\n+import javax.xml.stream.XMLResolver;\n+import javax.xml.stream.XMLStreamConstants;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.DTDHandler;\n+import org.xml.sax.EntityResolver;\n+import org.xml.sax.ErrorHandler;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.Parser;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXNotRecognizedException;\n+import org.xml.sax.SAXNotSupportedException;\n+import org.xml.sax.SAXParseException;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.ext.Attributes2;\n+import org.xml.sax.ext.DeclHandler;\n+import org.xml.sax.ext.EntityResolver2;\n+import org.xml.sax.ext.LexicalHandler;\n+import org.xml.sax.ext.Locator2;\n+\n+/**\n+ * JAXP SAX parser using an underlying StAX parser.\n+ * This parser supports the following additional SAX features and\n+ * properties:\n+ * <table>\n+ * <tr><th colspan='4'>Features</th></tr>\n+ * <tr><td>http://gnu.org/sax/features/xml-base</td>\n+ * <td colspan='2'>read/write</td>\n+ * <td>Indicates or sets whether XML Base processing is enabled</td></tr>\n+ * <tr><th colspan='4'>Properties</th></tr>\n+ * <tr><td>http://gnu.org/sax/properties/base-uri</td>\n+ * <td>read-only</td><td>String</td>\n+ * <td>Returns the base URI of the current event</td></tr>\n+ * <tr><td>http://gnu.org/sax/properties/document-xml-encoding</td>\n+ * <td>read-only</td><td>String</td>\n+ * <td>Returns the encoding specified in the XML declaration</td></tr>\n+ * </table>\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+public class SAXParser\n+  extends javax.xml.parsers.SAXParser\n+  implements XMLReader, Attributes2, Locator2, XMLReporter,\n+             XMLParser.XMLResolver2\n+{\n+\n+  ContentHandler contentHandler;\n+  DeclHandler declHandler;\n+  DTDHandler dtdHandler;\n+  EntityResolver entityResolver;\n+  ErrorHandler errorHandler;\n+  LexicalHandler lexicalHandler;\n+\n+  boolean validating = false;\n+  boolean namespaceAware = true;\n+  boolean xIncludeAware = false;\n+  boolean stringInterning = true;\n+  boolean coalescing = true;\n+  boolean replaceERefs = true;\n+  boolean externalEntities = true;\n+  boolean supportDTD = true;\n+  boolean baseAware = true;\n+\n+  XMLParser parser;\n+  XMLStreamReader reader;\n+  String encoding;\n+  String xmlVersion;\n+  boolean xmlStandalone;\n+  String xmlEncoding;\n+  String baseURI;\n+\n+  public SAXParser()\n+  {\n+  }\n+\n+  SAXParser(boolean validating, boolean namespaceAware, boolean xIncludeAware)\n+  {\n+    this.validating = validating;\n+    this.namespaceAware = namespaceAware;\n+    this.xIncludeAware = xIncludeAware;\n+  }\n+\n+  // -- SAXParser --\n+  \n+  public Parser getParser()\n+    throws SAXException\n+  {\n+    return null;\n+  }\n+  \n+  public XMLReader getXMLReader()\n+    throws SAXException\n+  {\n+    return this;\n+  }\n+\n+  public boolean isNamespaceAware()\n+  {\n+    return namespaceAware;\n+  }\n+\n+  public boolean isValidating()\n+  {\n+    return validating;\n+  }\n+\n+  public void setProperty(String name, Object value)\n+    throws SAXNotRecognizedException, SAXNotSupportedException\n+  {\n+    if (parser != null)\n+      throw new IllegalStateException(\"parsing in progress\");\n+    final String FEATURES = \"http://xml.org/sax/features/\";\n+    final String PROPERTIES = \"http://xml.org/sax/properties/\";\n+    final String GNU_FEATURES = \"http://gnu.org/sax/features/\";\n+    if ((FEATURES + \"namespaces\").equals(name))\n+      namespaceAware = Boolean.TRUE.equals(value);\n+    else if ((FEATURES + \"namespace-prefixes\").equals(name))\n+      {\n+        // NOOP\n+      }\n+    else if ((FEATURES + \"string-interning\").equals(name))\n+      stringInterning = Boolean.TRUE.equals(value);\n+    else if ((FEATURES + \"use-attributes2\").equals(name))\n+      {\n+        // NOOP\n+      }\n+    else if ((FEATURES + \"validation\").equals(name))\n+      validating = Boolean.TRUE.equals(value);\n+    else if ((FEATURES + \"external-general-entities\").equals(name))\n+      externalEntities = Boolean.TRUE.equals(value);\n+    else if ((FEATURES + \"external-parameter-entities\").equals(name))\n+      externalEntities = Boolean.TRUE.equals(value);\n+    else if ((PROPERTIES + \"declaration-handler\").equals(name))\n+      declHandler = (DeclHandler) value;\n+    else if ((PROPERTIES + \"lexical-handler\").equals(name))\n+      lexicalHandler = (LexicalHandler) value;\n+    else if ((GNU_FEATURES + \"xml-base\").equals(name))\n+      baseAware = Boolean.TRUE.equals(value);\n+    else\n+      throw new SAXNotSupportedException(name);\n+  }\n+\n+  public Object getProperty(String name)\n+    throws SAXNotRecognizedException, SAXNotSupportedException\n+  {\n+    final String FEATURES = \"http://xml.org/sax/features/\";\n+    final String PROPERTIES = \"http://xml.org/sax/properties/\";\n+    final String GNU_FEATURES = \"http://gnu.org/sax/features/\";\n+    final String GNU_PROPERTIES = \"http://gnu.org/sax/properties/\";\n+    if ((GNU_FEATURES + \"base-uri\").equals(name))\n+      return baseURI;\n+    if ((FEATURES + \"is-standalone\").equals(name))\n+      return xmlStandalone ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"namespaces\").equals(name))\n+      return namespaceAware ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"namespace-prefixes\").equals(name))\n+      return Boolean.TRUE;\n+    if ((FEATURES + \"string-interning\").equals(name))\n+      return stringInterning ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"use-attributes2\").equals(name))\n+      return Boolean.TRUE;\n+    if ((FEATURES + \"use-locator2\").equals(name))\n+      return Boolean.TRUE;\n+    if ((FEATURES + \"use-entity-resolver2\").equals(name))\n+      return Boolean.FALSE;\n+    if ((FEATURES + \"validation\").equals(name))\n+      return validating ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"external-general-entities\").equals(name))\n+      return externalEntities ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"external-parameter-entities\").equals(name))\n+      return externalEntities ? Boolean.TRUE : Boolean.FALSE;\n+    if ((FEATURES + \"xml-1.1\").equals(name))\n+      return Boolean.TRUE;\n+    if ((PROPERTIES + \"declaration-handler\").equals(name))\n+      return declHandler;\n+    if ((PROPERTIES + \"document-xml-version\").equals(name))\n+      return xmlVersion;\n+    if ((PROPERTIES + \"lexical-handler\").equals(name))\n+      return lexicalHandler;\n+    if ((GNU_FEATURES + \"xml-base\").equals(name))\n+      return baseAware ? Boolean.TRUE : Boolean.FALSE;\n+    if ((GNU_PROPERTIES + \"document-xml-encoding\").equals(name))\n+      return xmlEncoding;\n+    throw new SAXNotSupportedException(name);\n+  }\n+\n+  public boolean isXIncludeAware()\n+  {\n+    return xIncludeAware;\n+  }\n+\n+  public void reset()\n+  {\n+    parser = null;\n+    encoding = null;\n+    xmlVersion = null;\n+    xmlStandalone = false;\n+  }\n+\n+  // -- XMLReader --\n+\n+  public boolean getFeature(String name)\n+    throws SAXNotRecognizedException, SAXNotSupportedException\n+  {\n+    Object ret = getProperty(name);\n+    if (ret instanceof Boolean)\n+      return ((Boolean) ret).booleanValue();\n+    throw new SAXNotSupportedException(name);\n+  }\n+\n+  public void setFeature(String name, boolean value)\n+    throws SAXNotRecognizedException, SAXNotSupportedException\n+  {\n+    setProperty(name, value ? Boolean.TRUE : Boolean.FALSE);\n+  }\n+\n+  public void setEntityResolver(EntityResolver resolver)\n+  {\n+    entityResolver = resolver;\n+  }\n+\n+  public EntityResolver getEntityResolver()\n+  {\n+    return entityResolver;\n+  }\n+\n+  public void setDTDHandler(DTDHandler handler)\n+  {\n+    dtdHandler = handler;\n+  }\n+\n+  public DTDHandler getDTDHandler()\n+  {\n+    return dtdHandler;\n+  }\n+\n+  public void setContentHandler(ContentHandler handler)\n+  {\n+    contentHandler = handler;\n+  }\n+\n+  public ContentHandler getContentHandler()\n+  {\n+    return contentHandler;\n+  }\n+\n+  public void setErrorHandler(ErrorHandler handler)\n+  {\n+    errorHandler = handler;\n+  }\n+\n+  public ErrorHandler getErrorHandler()\n+  {\n+    return errorHandler;\n+  }\n+\n+  public synchronized void parse(InputSource input)\n+    throws IOException, SAXException\n+  {\n+    reset();\n+    String systemId = input.getSystemId();\n+    InputStream in = input.getByteStream();\n+    boolean opened = false;\n+    if (in != null)\n+      parser = new XMLParser(in, systemId,\n+                             validating,\n+                             namespaceAware,\n+                             coalescing,\n+                             replaceERefs,\n+                             externalEntities,\n+                             supportDTD,\n+                             baseAware,\n+                             stringInterning,\n+                             this,\n+                             this);\n+    else\n+      {\n+        Reader r = input.getCharacterStream();\n+        if (r != null)\n+          parser = new XMLParser(r, systemId,\n+                                 validating,\n+                                 namespaceAware,\n+                                 coalescing,\n+                                 replaceERefs,\n+                                 externalEntities,\n+                                 supportDTD,\n+                                 baseAware,\n+                                 stringInterning,\n+                                 this,\n+                                 this);\n+      }\n+    if (parser == null)\n+      {\n+        if (systemId == null)\n+          throw new SAXException(\"No stream or system ID specified\");\n+        systemId = XMLParser.absolutize(null, systemId);\n+        in = new URL(systemId).openStream();\n+        opened = true;\n+        parser = new XMLParser(in, systemId,\n+                               validating,\n+                               namespaceAware,\n+                               coalescing,\n+                               replaceERefs,\n+                               externalEntities,\n+                               supportDTD,\n+                               baseAware,\n+                               stringInterning,\n+                               this,\n+                               this);\n+      }\n+    reader = parser;\n+    baseURI = systemId;\n+    \n+    if (xIncludeAware)\n+      reader = new XIncludeFilter(parser, systemId, namespaceAware,\n+                                  validating, true);\n+    \n+    if (contentHandler != null)\n+      contentHandler.setDocumentLocator(this);\n+    boolean startDocumentDone = false;\n+    try\n+      {\n+        while (parser.hasNext())\n+          {\n+            int event = parser.next();\n+            if (baseAware)\n+              baseURI = parser.getXMLBase();\n+            switch (event)\n+              {\n+              case XMLStreamConstants.CHARACTERS:\n+                if (contentHandler != null)\n+                  {\n+                    char[] b = reader.getTextCharacters();\n+                    contentHandler.characters(b, 0, b.length);\n+                  }\n+                break;\n+              case XMLStreamConstants.SPACE:\n+                if (contentHandler != null)\n+                  {\n+                    char[] b = reader.getTextCharacters();\n+                    if (isIgnorableWhitespace(parser, b, false))\n+                      contentHandler.ignorableWhitespace(b, 0, b.length);\n+                    else\n+                      contentHandler.characters(b, 0, b.length);\n+                  }\n+                break;\n+              case XMLStreamConstants.CDATA:\n+                if (lexicalHandler != null)\n+                  lexicalHandler.startCDATA();\n+                if (contentHandler != null)\n+                  {\n+                    char[] b = reader.getTextCharacters();\n+                    if (isIgnorableWhitespace(parser, b, true))\n+                      contentHandler.ignorableWhitespace(b, 0, b.length);\n+                    else\n+                      contentHandler.characters(b, 0, b.length);\n+                  }\n+                if (lexicalHandler != null)\n+                  lexicalHandler.endCDATA();\n+                break;\n+              case XMLStreamConstants.START_ELEMENT:\n+                if (contentHandler != null)\n+                  {\n+                    QName name = reader.getName();\n+                    String uri = name.getNamespaceURI();\n+                    String localName = name.getLocalPart();\n+                    String prefix = name.getPrefix();\n+                    String qName = localName;\n+                    if (!\"\".equals(prefix))\n+                      qName = prefix + \":\" + localName;\n+                    if (!namespaceAware)\n+                      {\n+                        uri = \"\";\n+                        localName = \"\";\n+                      }\n+                    else\n+                      {\n+                        int nc = reader.getNamespaceCount();\n+                        for (int i = 0; i < nc; i++)\n+                          {\n+                            String nsuri = reader.getNamespaceURI(i);\n+                            String nsprefix = reader.getNamespacePrefix(i);\n+                            if (\"xml\".equals(nsprefix))\n+                              continue;\n+                            contentHandler.startPrefixMapping(nsprefix, nsuri);\n+                          }\n+                      }\n+                    contentHandler.startElement(uri, localName, qName, this);\n+                  }\n+                break;\n+              case XMLStreamConstants.END_ELEMENT:\n+                if (contentHandler != null)\n+                  {\n+                    QName name = reader.getName();\n+                    String uri = name.getNamespaceURI();\n+                    String localName = name.getLocalPart();\n+                    String prefix = name.getPrefix();\n+                    String qName = localName;\n+                    if (!\"\".equals(prefix))\n+                      qName = prefix + \":\" + localName;\n+                    if (!namespaceAware)\n+                      {\n+                        uri = \"\";\n+                        localName = \"\";\n+                      }\n+                    contentHandler.endElement(uri, localName, qName);\n+                    if (namespaceAware)\n+                      {\n+                        int nc = reader.getNamespaceCount();\n+                        for (int i = 0; i < nc; i++)\n+                          {\n+                            String nsprefix = reader.getNamespacePrefix(i);\n+                            if (\"xml\".equals(nsprefix))\n+                              continue;\n+                            contentHandler.endPrefixMapping(nsprefix);\n+                          }\n+                      }\n+                  }\n+                break;\n+              case XMLStreamConstants.COMMENT:\n+                if (lexicalHandler != null)\n+                  {\n+                    char[] b = reader.getTextCharacters();\n+                    lexicalHandler.comment(b, 0, b.length);\n+                  }\n+                break;\n+              case XMLStreamConstants.PROCESSING_INSTRUCTION:\n+                if (contentHandler != null)\n+                  {\n+                    String target = reader.getPITarget();\n+                    String data = reader.getPIData();\n+                    if (data == null)\n+                      data = \"\";\n+                    contentHandler.processingInstruction(target, data);\n+                  }\n+                break;\n+              case XMLStreamConstants.START_ENTITY:\n+                if (lexicalHandler != null)\n+                  {\n+                    String name = reader.getText();\n+                    lexicalHandler.startEntity(name);\n+                  }\n+                break;\n+              case XMLStreamConstants.END_ENTITY:\n+                if (lexicalHandler != null)\n+                  {\n+                    String name = reader.getText();\n+                    lexicalHandler.endEntity(name);\n+                  }\n+                break;\n+              case XMLStreamConstants.START_DOCUMENT:\n+                encoding = reader.getEncoding();\n+                xmlVersion = reader.getVersion();\n+                xmlStandalone = reader.isStandalone();\n+                xmlEncoding = reader.getCharacterEncodingScheme();\n+                if (contentHandler != null)\n+                  contentHandler.startDocument();\n+                startDocumentDone = true;\n+                break;\n+              case XMLStreamConstants.END_DOCUMENT:\n+                if (contentHandler != null)\n+                  contentHandler.endDocument();\n+                break;\n+              case XMLStreamConstants.DTD:\n+                XMLParser.Doctype doctype = parser.doctype;\n+                if (lexicalHandler != null)\n+                  {\n+                    String rootName = doctype.rootName;\n+                    String publicId = doctype.publicId;\n+                    String systemId2 = doctype.systemId;\n+                    lexicalHandler.startDTD(rootName, publicId, systemId2);\n+                  }\n+                for (Iterator i = doctype.entryIterator(); i.hasNext(); )\n+                  {\n+                    String entry = (String) i.next();\n+                    char c = entry.charAt(0);\n+                    String name = entry.substring(1);\n+                    if ('E' == c)\n+                      {\n+                        // Element decl\n+                        if (declHandler != null)\n+                          {\n+                            XMLParser.ContentModel model =\n+                              doctype.getElementModel(name);\n+                            declHandler.elementDecl(name, model.text);\n+                          }\n+                      }\n+                    else if ('A' == c)\n+                      {\n+                        // Attlist decl\n+                        if (declHandler != null)\n+                          {\n+                            for (Iterator j = doctype.attlistIterator(name);\n+                                 j.hasNext(); )\n+                              {\n+                                Map.Entry att = (Map.Entry) j.next();\n+                                String aname = (String) att.getKey();\n+                                XMLParser.AttributeDecl decl =\n+                                  (XMLParser.AttributeDecl) att.getValue();\n+                                String type = decl.type;\n+                                String value = decl.value;\n+                                String mode = null;\n+                                switch (decl.valueType)\n+                                  {\n+                                  case XMLParser.ATTRIBUTE_DEFAULT_FIXED:\n+                                    mode = \"#FIXED\";\n+                                    break;\n+                                  case XMLParser.ATTRIBUTE_DEFAULT_REQUIRED:\n+                                    mode = \"#REQUIRED\";\n+                                    break;\n+                                  case XMLParser.ATTRIBUTE_DEFAULT_IMPLIED:\n+                                    mode = \"#IMPLIED\";\n+                                    break;\n+                                  }\n+                                declHandler.attributeDecl(name, aname,\n+                                                          type, mode, value);\n+                              }\n+                          }\n+                      }\n+                    else if ('e' == c)\n+                      {\n+                        // Entity decl\n+                        Object entity = doctype.getEntity(name);\n+                        if (entity instanceof String)\n+                          {\n+                            if (declHandler != null)\n+                              declHandler.internalEntityDecl(name,\n+                                                             (String) entity);\n+                          }\n+                        else\n+                          {\n+                            XMLParser.ExternalIds ids =\n+                              (XMLParser.ExternalIds) entity;\n+                            if (ids.notationName != null)\n+                              {\n+                                if (dtdHandler != null)\n+                                  {\n+                                    String pub = ids.publicId;\n+                                    String url = ids.systemId;\n+                                    String not = ids.notationName;\n+                                    dtdHandler.unparsedEntityDecl(name,\n+                                                                  pub,\n+                                                                  url,\n+                                                                  not);\n+                                  }\n+                              }\n+                            else\n+                              {\n+                                if (declHandler != null)\n+                                  {\n+                                    String pub = ids.publicId;\n+                                    String url = ids.systemId;\n+                                    declHandler.externalEntityDecl(name,\n+                                                                   pub,\n+                                                                   url);\n+                                  }\n+                              }\n+                          }\n+                      }\n+                    else if ('n' == c)\n+                      {\n+                        // Notation decl\n+                        if (dtdHandler != null)\n+                          {\n+                            XMLParser.ExternalIds ids =\n+                              doctype.getNotation(name);\n+                            String pub = ids.publicId;\n+                            String url = ids.systemId;\n+                            dtdHandler.notationDecl(name, pub, url);\n+                          }\n+                      }\n+                    else if ('c' == c)\n+                      {\n+                        // Comment\n+                        if (lexicalHandler != null)\n+                          {\n+                            String comment = doctype.getComment(name);\n+                            char[] b = comment.toCharArray();\n+                            lexicalHandler.comment(b, 0, b.length);\n+                          }\n+                      }\n+                    else if ('p' == c)\n+                      {\n+                        // Processing instruction\n+                        if (contentHandler != null)\n+                          {\n+                            String[] pi = doctype.getPI(name);\n+                            String target = pi[0];\n+                            String data = pi[1];\n+                            if (data == null)\n+                              data = \"\";\n+                            contentHandler.processingInstruction(target, data);\n+                          }\n+                      }\n+                  }\n+                if (lexicalHandler != null)\n+                  lexicalHandler.endDTD();\n+              }\n+          }\n+      }\n+    catch (XMLStreamException e)\n+      {\n+        if (!startDocumentDone && contentHandler != null)\n+          contentHandler.startDocument();\n+        SAXParseException e2 = new SAXParseException(e.getMessage(), this);\n+        e2.initCause(e);\n+        if (errorHandler != null)\n+          errorHandler.fatalError(e2);\n+        if (contentHandler != null)\n+          contentHandler.endDocument();\n+        throw e2;\n+      }\n+    finally\n+      {\n+        if (opened)\n+          in.close();\n+        reset();\n+      }\n+  }\n+\n+  /**\n+   * Indicates whether the specified characters are ignorable whitespace.\n+   */\n+  private boolean isIgnorableWhitespace(XMLParser reader, char[] b,\n+                                        boolean testCharacters)\n+    throws XMLStreamException\n+  {\n+    XMLParser.Doctype doctype = reader.doctype;\n+    if (doctype == null)\n+      return false;\n+    String currentElement = reader.getCurrentElement();\n+    // check for xml:space\n+    int ac = reader.getAttributeCount();\n+    for (int i = 0; i < ac; i++)\n+      {\n+        QName aname = reader.getAttributeQName(i);\n+        if (\"space\".equals(aname.getLocalPart()) &&\n+            XMLConstants.XML_NS_URI.equals(aname.getNamespaceURI()))\n+          {\n+            if (\"preserve\".equals(reader.getAttributeValue(i)))\n+              return false;\n+          }\n+      }\n+    XMLParser.ContentModel model = doctype.getElementModel(currentElement);\n+    if (model == null || model.type != XMLParser.ContentModel.ELEMENT)\n+      return false;\n+    if (model.external && xmlStandalone)\n+      return false;\n+    boolean white = true;\n+    if (testCharacters)\n+      {\n+        for (int i = 0; i < b.length; i++)\n+          {\n+            if (b[i] != ' ' && b[i] != '\\t' && b[i] != '\\n' && b[i] != '\\r')\n+              {\n+                white = false;\n+                break;\n+              }\n+          }\n+      }\n+    return white;\n+  }\n+\n+  public void parse(String systemId)\n+    throws IOException, SAXException\n+  {\n+    parse(new InputSource(systemId));\n+  }\n+\n+  // -- Attributes2 --\n+\n+  public int getIndex(String qName)\n+  {\n+    int len = reader.getAttributeCount();\n+    for (int i = 0; i < len; i++)\n+      {\n+        QName q = reader.getAttributeQName(i);\n+        String localName = q.getLocalPart();\n+        String prefix = q.getPrefix();\n+        String qn = (\"\".equals(prefix)) ? localName : prefix + \":\" + localName;\n+        if (qName.equals(qn))\n+          return i;\n+      }\n+    return -1;\n+  }\n+\n+  public int getIndex(String uri, String localName)\n+  {\n+    int len = reader.getAttributeCount();\n+    for (int i = 0; i < len; i++)\n+      {\n+        QName q = reader.getAttributeQName(i);\n+        String ln = q.getLocalPart();\n+        String u = q.getNamespaceURI();\n+        if (u == null && uri != null)\n+          continue;\n+        if (u != null && !u.equals(uri))\n+          continue;\n+        if (ln.equals(localName))\n+          return i;\n+      }\n+    return -1;\n+  }\n+\n+  public int getLength()\n+  {\n+    return reader.getAttributeCount();\n+  }\n+\n+  public String getLocalName(int index)\n+  {\n+    return reader.getAttributeName(index);\n+  }\n+\n+  public String getQName(int index)\n+  {\n+    QName q = reader.getAttributeQName(index);\n+    String localName = q.getLocalPart();\n+    String prefix = q.getPrefix();\n+    return (\"\".equals(prefix)) ? localName : prefix + \":\" + localName;\n+  }\n+\n+  public String getType(int index)\n+  {\n+    String ret = reader.getAttributeType(index);\n+    // SAX doesn't permit ENUMERATION?\n+    return (\"ENUMERATION\".equals(ret)) ? \"NMTOKEN\" : ret;\n+  }\n+\n+  public String getType(String qName)\n+  {\n+    int index = getIndex(qName);\n+    return (index == -1) ? null : getType(index);\n+  }\n+\n+  public String getType(String uri, String localName)\n+  {\n+    int index = getIndex(uri, localName);\n+    return (index == -1) ? null : getType(index);\n+  }\n+\n+  public String getURI(int index)\n+  {\n+    String ret = reader.getAttributeNamespace(index);\n+    return (ret == null) ? \"\" : ret;\n+  }\n+\n+  public String getValue(int index)\n+  {\n+    return reader.getAttributeValue(index);\n+  }\n+\n+  public String getValue(String qName)\n+  {\n+    int index = getIndex(qName);\n+    return (index == -1) ? null : getValue(index);\n+  }\n+\n+  public String getValue(String uri, String localName)\n+  {\n+    int index = getIndex(uri, localName);\n+    return (index == -1) ? null : getValue(index);\n+  }\n+\n+  public boolean isDeclared(int index)\n+  {\n+    return parser.isAttributeDeclared(index);\n+  }\n+\n+  public boolean isDeclared(String qName)\n+  {\n+    int index = getIndex(qName);\n+    return (index == -1) ? false : isDeclared(index);\n+  }\n+\n+  public boolean isDeclared(String uri, String localName)\n+  {\n+    int index = getIndex(uri, localName);\n+    return (index == -1) ? false : isDeclared(index);\n+  }\n+\n+  public boolean isSpecified(int index)\n+  {\n+    return reader.isAttributeSpecified(index);\n+  }\n+\n+  public boolean isSpecified(String qName)\n+  {\n+    int index = getIndex(qName);\n+    return (index == -1) ? false : isSpecified(index);\n+  }\n+\n+  public boolean isSpecified(String uri, String localName)\n+  {\n+    int index = getIndex(uri, localName);\n+    return (index == -1) ? false : isSpecified(index);\n+  }\n+\n+  // -- Locator2 --\n+  \n+  public int getColumnNumber()\n+  {\n+    Location l = reader.getLocation();\n+    return l.getColumnNumber();\n+  }\n+\n+  public int getLineNumber()\n+  {\n+    Location l = reader.getLocation();\n+    return l.getLineNumber();\n+  }\n+\n+  public String getPublicId()\n+  {\n+    return null;\n+  }\n+\n+  public String getSystemId()\n+  {\n+    Location l = reader.getLocation();\n+    return l.getLocationURI();\n+  }\n+  \n+  public String getEncoding()\n+  {\n+    return encoding;\n+  }\n+\n+  public String getXMLVersion()\n+  {\n+    return xmlVersion;\n+  }\n+\n+  // -- XMLResolver --\n+  \n+  public InputStream resolve(String uri)\n+    throws XMLStreamException\n+  {\n+    return resolve(null, uri);\n+  }\n+\n+  public InputStream resolve(String publicId, String systemId)\n+    throws XMLStreamException\n+  {\n+    if (entityResolver != null)\n+      {\n+        try\n+          {\n+            InputSource input =\n+              entityResolver.resolveEntity(publicId, systemId);\n+            if (input != null)\n+              return input.getByteStream();\n+          }\n+        catch (SAXException e)\n+          {\n+            XMLStreamException e2 = new XMLStreamException(e.getMessage());\n+            e2.initCause(e);\n+            throw e2;\n+          }\n+        catch (IOException e)\n+          {\n+            XMLStreamException e2 = new XMLStreamException(e.getMessage());\n+            e2.initCause(e);\n+            throw e2;\n+          }\n+      }\n+    return null;\n+  }\n+\n+  public XMLEventReader resolveAsXMLEventReader(String uri)\n+    throws XMLStreamException\n+  {\n+    // unused\n+    return null;\n+  }\n+\n+  public XMLStreamReader resolveAsXMLStreamReader(String uri)\n+    throws XMLStreamException\n+  {\n+    // unused\n+    return null;\n+  }\n+\n+  // -- XMLReporter --\n+\n+  public void report(String message, String errorType,\n+                     Object relatedInformation, Location location)\n+    throws XMLStreamException\n+  {\n+    if (errorHandler != null)\n+      {\n+        try\n+          {\n+            errorHandler.warning(new SAXParseException(message, this));\n+          }\n+        catch (SAXException e)\n+          {\n+            XMLStreamException e2 = new XMLStreamException(e.getMessage());\n+            e2.initCause(e);\n+            throw e2;\n+          }\n+      }\n+  }\n+\n+  public static void main(String[] args)\n+    throws Exception\n+  {\n+    SAXParser parser = new SAXParser();\n+    InputSource input = new InputSource(args[0]);\n+    parser.parse(input, new org.xml.sax.helpers.DefaultHandler());\n+    \n+  }\n+  \n+}"}, {"sha": "a2ccea1e69462bb8e2f34d6bb0975d749078c779", "filename": "libjava/classpath/gnu/xml/stream/SAXParserFactory.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParserFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParserFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FSAXParserFactory.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,104 @@\n+/* SAXParserFactory.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXNotRecognizedException;\n+import org.xml.sax.SAXNotSupportedException;\n+\n+/**\n+ * SAX parser factory providing a SAX compatibility layer on top of StAX.\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+public class SAXParserFactory\n+  extends javax.xml.parsers.SAXParserFactory\n+{\n+\n+  static final Set FEATURE_NAMES = new HashSet();\n+  static\n+  {\n+    FEATURE_NAMES.add(\"http://xml.org/sax/features/namespaces\");\n+    FEATURE_NAMES.add(\"http://xml.org/sax/features/string-interning\");\n+    FEATURE_NAMES.add(\"http://xml.org/sax/features/validation\");\n+  }\n+\n+  Map features = new HashMap();\n+\n+  public javax.xml.parsers.SAXParser newSAXParser()\n+    throws ParserConfigurationException, SAXException\n+  {\n+    boolean validating = isValidating();\n+    boolean namespaceAware = isNamespaceAware();\n+    boolean xIncludeAware = isXIncludeAware();\n+    SAXParser ret = new SAXParser(validating, namespaceAware, xIncludeAware);\n+    for (Iterator i = features.entrySet().iterator(); i.hasNext(); )\n+      {\n+        Map.Entry entry = (Map.Entry) i.next();\n+        String name = (String) entry.getKey();\n+        Boolean value = (Boolean) entry.getValue();\n+        ret.setFeature(name, value.booleanValue());\n+      }\n+    return ret;\n+  }\n+\n+  public void setFeature(String name, boolean value)\n+    throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException\n+  {\n+    if (!FEATURE_NAMES.contains(name))\n+      throw new SAXNotSupportedException(name);\n+    features.put(name, value ? Boolean.TRUE : Boolean.FALSE);\n+  }\n+\n+  public boolean getFeature(String name) \n+    throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException  \n+  {\n+    if (!FEATURE_NAMES.contains(name))\n+      throw new SAXNotSupportedException(name);\n+    Boolean value = (Boolean) features.get(name);\n+    return (value == null) ? false : value.booleanValue();\n+  }\n+  \n+}"}, {"sha": "c38516c30f857516432d990c42c0abd6adf7c77b", "filename": "libjava/classpath/gnu/xml/stream/UnicodeReader.java", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FUnicodeReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FUnicodeReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FUnicodeReader.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,201 @@\n+/* UnicodeReader.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+/**\n+ * A reader that converts UTF-16 characters to Unicode code points.\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+class UnicodeReader\n+{\n+\n+  final Reader in;\n+\n+  UnicodeReader(Reader in)\n+  {\n+    this.in = in;\n+  }\n+\n+  public void mark(int limit)\n+    throws IOException\n+  {\n+    in.mark(limit * 2);\n+  }\n+\n+  public void reset()\n+    throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    int ret = in.read();\n+    if (ret == -1)\n+      return ret;\n+    if (ret >= 0xd800 && ret < 0xdc00)\n+      {\n+        // Unicode surrogate?\n+        int low = in.read();\n+        if (low >= 0xdc00 && low < 0xe000)\n+          ret = Character.toCodePoint((char) ret, (char) low);\n+        else\n+          throw new IOException(\"unpaired surrogate: U+\" +\n+                                Integer.toHexString(ret));\n+      }\n+    else if (ret >= 0xdc00 && ret < 0xe000)\n+      throw new IOException(\"unpaired surrogate: U+\" +\n+                            Integer.toHexString(ret));\n+    return ret;\n+  }\n+\n+  public int read(int[] buf, int off, int len)\n+    throws IOException\n+  {\n+    if (len == 0)\n+      return 0;\n+    char[] b2 = new char[len];\n+    int ret = in.read(b2, 0, len);\n+    if (ret <= 0)\n+      return ret;\n+    int l = ret - 1;\n+    int i = 0, j = off;\n+    for (; i < l; i++)\n+      {\n+        char c = b2[i];\n+        if (c >= 0xd800 && c < 0xdc00)\n+          {\n+            // Unicode surrogate?\n+            char d = b2[i + 1];\n+            if (d >= 0xdc00 && d < 0xe000)\n+              {\n+                buf[j++] = Character.toCodePoint(c, d);\n+                i++;\n+                continue;\n+              }\n+            else\n+              throw new IOException(\"unpaired surrogate: U+\" +\n+                                    Integer.toHexString(c));\n+          }\n+        else if (c >= 0xdc00 && c < 0xe000)\n+          throw new IOException(\"unpaired surrogate: U+\" +\n+                                Integer.toHexString(c));\n+        buf[j++] = (int) c;\n+      }\n+    if (i == l)\n+      {\n+        // last char\n+        char c = b2[l];\n+        if (c >= 0xd800 && c < 0xdc00)\n+          {\n+            int low = in.read();\n+            if (low >= 0xdc00 && low < 0xe000)\n+              {\n+                buf[j++] = Character.toCodePoint(c, (char) low);\n+                return j;\n+              }\n+            else\n+              throw new IOException(\"unpaired surrogate: U+\" +\n+                                    Integer.toHexString(c));\n+          }\n+        else if (c >= 0xdc00 && c < 0xe000)\n+          throw new IOException(\"unpaired surrogate: U+\" +\n+                                Integer.toHexString(c));\n+        buf[j++] = (int) c;\n+      }\n+    return j;\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    in.close();\n+  }\n+\n+  public static int[] toCodePointArray(String text)\n+    throws IOException\n+  {\n+    char[] b2 = text.toCharArray();\n+    int[] buf = new int[b2.length];\n+    if (b2.length > 0)\n+      {\n+        int l = b2.length - 1;\n+        int i = 0, j = 0;\n+        for (; i < l; i++)\n+          {\n+            char c = b2[i];\n+            if (c >= 0xd800 && c < 0xdc00)\n+              {\n+                // Unicode surrogate?\n+                char d = b2[i + 1];\n+                if (d >= 0xdc00 && d < 0xe000)\n+                  {\n+                    buf[j++] = Character.toCodePoint(c, d);\n+                    i++;\n+                    continue;\n+                  }\n+                else\n+                  throw new IOException(\"unpaired surrogate: U+\" +\n+                                        Integer.toHexString(c));\n+              }\n+            else if (c >= 0xdc00 && c < 0xe000)\n+              throw new IOException(\"unpaired surrogate: U+\" +\n+                                    Integer.toHexString(c));\n+            buf[j++] = (int) c;\n+          }\n+        if (i == l)\n+          {\n+            // last char\n+            buf[j++] = (int) b2[l];\n+            if (j < buf.length)\n+              {\n+                int[] buf2 = new int[j];\n+                System.arraycopy(buf, 0, buf2, 0, j);\n+                buf = buf2;\n+              }\n+          }\n+      }\n+    return buf;\n+  }\n+  \n+}"}, {"sha": "e151ac69d3cd0cec099109aa494e5ae06de8f6ff", "filename": "libjava/classpath/gnu/xml/stream/XIncludeFilter.java", "status": "added", "additions": 932, "deletions": 0, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXIncludeFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXIncludeFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXIncludeFilter.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,932 @@\n+/* XIncludeFilter.java -- \n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.stream;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.HashSet;\n+import java.util.NoSuchElementException;\n+import java.util.StringTokenizer;\n+import javax.xml.namespace.QName;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLStreamConstants;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.stream.util.ReaderDelegate;\n+\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.DOMImplementation;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.ProcessingInstruction;\n+import org.w3c.dom.TypeInfo;\n+import org.w3c.dom.traversal.DocumentTraversal;\n+import org.w3c.dom.traversal.NodeFilter;\n+import org.w3c.dom.traversal.TreeWalker;\n+import org.w3c.dom.xpath.XPathEvaluator;\n+import org.w3c.dom.xpath.XPathNSResolver;\n+import org.w3c.dom.xpath.XPathResult;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * StAX filter for performing XInclude processing.\n+ *\n+ * @see http://www.w3.org/TR/xinclude/\n+ * @see http://www.w3.org/TR/xptr-framework/\n+ * @see http://www.w3.org/TR/xptr-element/\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+class XIncludeFilter\n+  extends ReaderDelegate\n+{\n+\n+  static final String XINCLUDE_NS_URI = \"http://www.w3.org/2001/XInclude\";\n+  static final int SHOW_FLAGS =\n+    NodeFilter.SHOW_CDATA_SECTION |\n+    NodeFilter.SHOW_COMMENT |\n+    NodeFilter.SHOW_ELEMENT |\n+    NodeFilter.SHOW_ENTITY_REFERENCE |\n+    NodeFilter.SHOW_PROCESSING_INSTRUCTION |\n+    NodeFilter.SHOW_TEXT;\n+\n+  final String systemId;\n+  final boolean namespaceAware;\n+  final boolean validating;\n+  final boolean expandERefs;\n+  String href;\n+  int event;\n+  boolean included;\n+  XPathResult result;\n+  int snapshotIndex;\n+  Node current;\n+  TreeWalker walker;\n+  HashSet seen = new HashSet();\n+  boolean backtracking;\n+  boolean lookahead;\n+  \n+  Reader includedText;\n+  char[] buf;\n+  int len = -1;\n+  boolean inInclude, inFallback, seenFallback;\n+\n+  DocumentBuilder builder;\n+\n+  XIncludeFilter(XMLStreamReader reader, String systemId,\n+                 boolean namespaceAware, boolean validating,\n+                 boolean expandERefs)\n+  {\n+    super(reader);\n+    this.systemId = XMLParser.absolutize(null, systemId);\n+    this.namespaceAware = namespaceAware;\n+    this.validating = validating;\n+    this.expandERefs = expandERefs;\n+  }\n+\n+  public int getAttributeCount()\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        return (attrs == null) ? 0 : attrs.getLength();\n+      }\n+    return super.getAttributeCount();\n+  }\n+\n+  public String getAttributeName(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.item(index);\n+        return attr.getLocalName();\n+      }\n+    return super.getAttributeName(index);\n+  }\n+\n+  public String getAttributeNamespace(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.item(index);\n+        return attr.getNamespaceURI();\n+      }\n+    return super.getAttributeNamespace(index);\n+  }\n+\n+  public String getAttributePrefix(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.item(index);\n+        return attr.getPrefix();\n+      }\n+    return super.getAttributePrefix(index);\n+  }\n+\n+  public QName getAttributeQName(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.item(index);\n+        String localName = attr.getLocalName();\n+        String uri = attr.getNamespaceURI();\n+        String prefix = attr.getPrefix();\n+        return new QName(uri, localName, prefix);\n+      }\n+    return super.getAttributeQName(index);\n+  }\n+\n+  public String getAttributeType(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Attr attr = (Attr) attrs.item(index);\n+        TypeInfo ti = attr.getSchemaTypeInfo();\n+        return (ti == null) ? \"CDATA\" : ti.getTypeName();\n+      }\n+    return super.getAttributeType(index);\n+  }\n+\n+  public boolean isAttributeSpecified(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+          return false;\n+        Attr attr = (Attr) attrs.item(index);\n+        return attr.getSpecified();\n+      }\n+    return super.isAttributeSpecified(index);\n+  }\n+\n+  public String getAttributeValue(int index)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.item(index);\n+        return attr.getNodeValue();\n+      }\n+    return super.getAttributeValue(index);\n+  }\n+\n+  public String getAttributeValue(String uri, String localName)\n+  {\n+    if (current != null)\n+      {\n+        NamedNodeMap attrs = current.getAttributes();\n+        if (attrs == null)\n+         return null;\n+        Node attr = attrs.getNamedItemNS(uri, localName);\n+        return (attr == null) ? null : attr.getNodeValue();\n+      }\n+    return super.getAttributeValue(uri, localName);\n+  }\n+\n+  public String getElementText()\n+    throws XMLStreamException\n+  {\n+    if (current != null)\n+      return current.getTextContent();\n+    return super.getElementText();\n+  }\n+\n+  public int getEventType()\n+  {\n+    return event;\n+  }\n+\n+  public String getLocalName()\n+  {\n+    if (current != null)\n+      return current.getLocalName();\n+    return super.getLocalName();\n+  }\n+\n+  public QName getName()\n+  {\n+    if (current != null)\n+      {\n+        String localName = current.getLocalName();\n+        String uri = current.getNamespaceURI();\n+        String prefix = current.getPrefix();\n+        return new QName(uri, localName, prefix);\n+      }\n+    return super.getName();\n+  }\n+\n+  public String getNamespaceURI()\n+  {\n+    if (current != null)\n+      return current.getNamespaceURI();\n+    return super.getNamespaceURI();\n+  }\n+\n+  // TODO namespaces\n+\n+  public String getPIData()\n+  {\n+    if (current != null)\n+      return ((ProcessingInstruction) current).getData();\n+    return super.getPIData();\n+  }\n+\n+  public String getPITarget()\n+  {\n+    if (current != null)\n+      return ((ProcessingInstruction) current).getTarget();\n+    return super.getPITarget();\n+  }\n+\n+  public String getPrefix()\n+  {\n+    if (current != null)\n+      return current.getPrefix();\n+    return super.getPrefix();\n+  }\n+\n+  public String getText()\n+  {\n+    if (current != null)\n+      return current.getNodeValue();\n+    if (walker != null)\n+      {\n+        Node n = walker.getCurrentNode();\n+        if (n != null)\n+          return n.getTextContent();\n+      }\n+    if (buf != null)\n+      return new String(buf, 0, len);\n+    return super.getText();\n+  }\n+\n+  public char[] getTextCharacters()\n+  {\n+    if (current != null)\n+      {\n+        buf = current.getNodeValue().toCharArray();\n+        len = buf.length;\n+      }\n+    if (buf != null)\n+      return buf;\n+    return super.getTextCharacters();\n+  }\n+\n+  public int getTextCharacters(int sourceStart, char[] target,\n+                               int targetStart, int length)\n+    throws XMLStreamException\n+  {\n+    if (current != null)\n+      {\n+        buf = current.getNodeValue().toCharArray();\n+        len = buf.length;\n+      }\n+    if (buf != null)\n+      {\n+        int max = Math.min(len - sourceStart, length);\n+        if (max > 0)\n+          System.arraycopy(buf, sourceStart, target, targetStart, max);\n+        return max;\n+      }\n+    return super.getTextCharacters(sourceStart, target, targetStart, length);\n+  }\n+\n+  public int getTextLength()\n+  {\n+    if (current != null)\n+      {\n+        buf = current.getNodeValue().toCharArray();\n+        len = buf.length;\n+      }\n+    if (buf != null)\n+      return len;\n+    return super.getTextLength();\n+  }\n+\n+  public int getTextStart()\n+  {\n+    if (current != null)\n+      {\n+        buf = current.getNodeValue().toCharArray();\n+        len = buf.length;\n+      }\n+    if (buf != null)\n+      return 0;\n+    return super.getTextStart();\n+  }\n+\n+  public boolean hasNext()\n+    throws XMLStreamException\n+  {\n+    if (!lookahead)\n+      {\n+        try\n+          {\n+            next();\n+          }\n+        catch (NoSuchElementException e)\n+          {\n+            event = -1;\n+          }\n+        lookahead = true;\n+      }\n+    return (event != -1);\n+  }\n+\n+  public int next()\n+    throws XMLStreamException\n+  {\n+    if (lookahead)\n+      {\n+        lookahead = false;\n+        return event;\n+      }\n+    buf = null;\n+    len = 0;\n+    if (walker != null)\n+      {\n+        Node c = walker.getCurrentNode();\n+        Node n = null;\n+        if (c.getNodeType() == Node.ELEMENT_NODE)\n+          {\n+            boolean isStartElement = !seen.contains(c);\n+            if (isStartElement)\n+              {\n+                seen.add(c);\n+                current = c;\n+                event = XMLStreamConstants.START_ELEMENT;\n+                return event;\n+              }\n+            else if (backtracking)\n+              {\n+                n = walker.nextSibling();\n+                if (n != null)\n+                  backtracking = false;\n+              }\n+            else\n+              {\n+                n = walker.firstChild();\n+                if (n == null)\n+                  n = walker.nextSibling();\n+              }\n+          }\n+        else\n+          {\n+            n = walker.firstChild();\n+            if (n == null)\n+              n = walker.nextSibling();\n+          }\n+        if (n == null)\n+          {\n+            current = walker.parentNode();\n+            if (current != null && current.getNodeType() == Node.ELEMENT_NODE)\n+              {\n+                // end-element\n+                backtracking = true;\n+                event = XMLStreamConstants.END_ELEMENT;\n+                return event;\n+              }\n+            else\n+              {\n+                walker = null;\n+                current = null;\n+              }\n+          }\n+        else\n+          {\n+            current = n;\n+            switch (n.getNodeType())\n+              {\n+              case Node.ELEMENT_NODE:\n+                return next();\n+              case Node.TEXT_NODE:\n+                String text = n.getNodeValue();\n+                buf = text.toCharArray();\n+                len = buf.length;\n+                event = isSpace(buf, len) ?\n+                  XMLStreamConstants.SPACE :\n+                  XMLStreamConstants.CHARACTERS;\n+                return event;\n+              case Node.CDATA_SECTION_NODE:\n+                event = XMLStreamConstants.CDATA;\n+                return event;\n+              case Node.COMMENT_NODE:\n+                event = XMLStreamConstants.COMMENT;\n+                return event;\n+              case Node.PROCESSING_INSTRUCTION_NODE:\n+                event = XMLStreamConstants.PROCESSING_INSTRUCTION;\n+                return event;\n+              case Node.ENTITY_REFERENCE_NODE:\n+                event = XMLStreamConstants.ENTITY_REFERENCE;\n+                return event;\n+              default:\n+                throw new IllegalStateException();\n+              }\n+          }\n+      }\n+    if (result != null)\n+      {\n+        switch (result.getResultType())\n+          {\n+          case XPathResult.BOOLEAN_TYPE:\n+            boolean bval = result.getBooleanValue();\n+            String btext = bval ? \"true\" : \"false\";\n+            buf = btext.toCharArray();\n+            len = buf.length;\n+            result = null;\n+            event = XMLStreamConstants.CHARACTERS;\n+            return event;\n+          case XPathResult.NUMBER_TYPE:\n+            double nval = result.getNumberValue();\n+            String ntext = new Double(nval).toString();\n+            buf = ntext.toCharArray();\n+            len = buf.length;\n+            result = null;\n+            event = XMLStreamConstants.CHARACTERS;\n+            return event;\n+          case XPathResult.STRING_TYPE:\n+            String stext = result.getStringValue();\n+            buf = stext.toCharArray();\n+            len = buf.length;\n+            result = null;\n+            event = isSpace(buf, len) ?\n+              XMLStreamConstants.SPACE :\n+              XMLStreamConstants.CHARACTERS;\n+            return event;\n+          case XPathResult.ANY_UNORDERED_NODE_TYPE:\n+          case XPathResult.FIRST_ORDERED_NODE_TYPE:\n+            Node n1 = result.getSingleNodeValue();\n+            Document d1 = getDocument(n1);\n+            walker = getDocumentTraversal(d1)\n+              .createTreeWalker(n1, SHOW_FLAGS, null, expandERefs);\n+            result = null;\n+            return next();\n+          case XPathResult.ORDERED_NODE_ITERATOR_TYPE:\n+          case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\n+            Node n2 = result.iterateNext();\n+            if (n2 == null)\n+              {\n+                result = null;\n+                return next();\n+              }\n+            Document d2 = getDocument(n2);\n+            walker = getDocumentTraversal(d2)\n+              .createTreeWalker(n2, SHOW_FLAGS, null, expandERefs);\n+            return next();\n+          case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:\n+          case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:\n+            Node n3 = result.snapshotItem(snapshotIndex++);\n+            if (n3 == null)\n+              {\n+                result = null;\n+                return next();\n+              }\n+            Document d3 = getDocument(n3);\n+            walker = getDocumentTraversal(d3)\n+              .createTreeWalker(n3, SHOW_FLAGS, null, expandERefs);\n+            return next();\n+          default:\n+            throw new IllegalStateException();\n+          }\n+      }\n+    if (includedText != null)\n+      {\n+        // fill buffer\n+        if (buf == null)\n+          buf = new char[2048];\n+        try\n+          {\n+            len = includedText.read(buf, 0, buf.length);\n+            if (len == -1)\n+              {\n+                includedText = null;\n+                buf = null;\n+                return next();\n+              }\n+            // chars or space?\n+            return (event = isSpace(buf, len) ?\n+                    XMLStreamConstants.SPACE :\n+                    XMLStreamConstants.CHARACTERS);\n+          }\n+        catch (IOException e)\n+          {\n+            XMLStreamException e2 = new XMLStreamException(e.getMessage());\n+            e2.initCause(e);\n+            throw e2;\n+          }\n+      }\n+    event = super.next();\n+    switch (event)\n+      {\n+      case XMLStreamConstants.START_ELEMENT:\n+        String uri = getNamespaceURI();\n+        if (XINCLUDE_NS_URI.equals(uri))\n+          {\n+            String localName = getLocalName();\n+            if (\"include\".equals(localName))\n+              {\n+                href = getAttributeValue(null, \"href\");\n+                String parse = getAttributeValue(null, \"parse\");\n+                String xpointer = getAttributeValue(null, \"xpointer\");\n+                String encoding = getAttributeValue(null, \"encoding\");\n+                String accept = getAttributeValue(null, \"accept\");\n+                String acceptLanguage = getAttributeValue(null,\n+                                                          \"accept-language\");\n+                if (includeResource(href, parse, xpointer, encoding,\n+                                    accept, acceptLanguage))\n+                  {\n+                    // Skip to xi:include end-element event\n+                    int depth = 0;\n+                    while (depth >= 0)\n+                      {\n+                        event = super.next();\n+                        switch (event)\n+                          {\n+                          case XMLStreamConstants.START_ELEMENT:\n+                            depth++;\n+                            break;\n+                          case XMLStreamConstants.END_ELEMENT:\n+                            depth--;\n+                          }\n+                      }\n+                  }\n+                else\n+                  inInclude = true;\n+              }\n+            else if (inInclude && \"fallback\".equals(localName))\n+              {\n+                if (!seenFallback)\n+                  inFallback = seenFallback = true;\n+                else\n+                  throw new XMLStreamException(\"duplicate xi:fallback element\");\n+              }\n+            else if (inInclude)\n+              {\n+                throw new XMLStreamException(\"illegal xi element '\" +\n+                                             localName + \"'\");\n+              }\n+            return next();\n+          }\n+        break;\n+      case XMLStreamConstants.END_ELEMENT:\n+        String uri2 = getNamespaceURI();\n+        if (XINCLUDE_NS_URI.equals(uri2))\n+          {\n+            String localName = getLocalName();\n+            if (\"include\".equals(localName))\n+              {\n+                if (!seenFallback && included)\n+                  {\n+                    String msg = \"Unable to read \" + href +\n+                      \" and no xi:fallback element present\";\n+                    throw new XMLStreamException(msg);\n+                  }\n+                included = false;\n+                href = null;\n+                inInclude = inFallback = seenFallback = false;\n+              }\n+            else if (\"fallback\".equals(localName))\n+              inFallback = false;\n+            return next();\n+          }\n+        break;\n+      }\n+    if (inInclude && !inFallback)\n+      return next();\n+    return event;\n+  }\n+\n+  boolean isSpace(char[] text, int len)\n+  {\n+    boolean space = true;\n+    for (int i = 0; i < len; i++)\n+      {\n+        char c = text[i];\n+        if (c != ' ' && c != '\\t' && c != '\\n' && c != '\\r')\n+          {\n+            space = false;\n+            break;\n+          }\n+      }\n+    return space;\n+  }\n+\n+  String getBaseURI()\n+  {\n+    String base = (String) getParent().getProperty(\"gnu.xml.stream.baseURI\");\n+    return (base == null) ? systemId : base;\n+  }\n+  \n+  boolean includeResource(String href, String parse, String xpointer,\n+                          String encoding, String accept,\n+                          String acceptLanguage)\n+  {\n+    included = false;\n+    try\n+      {\n+        if (xpointer != null)\n+          throw new XMLStreamException(\"xpointer attribute not yet supported\");\n+        String base = getBaseURI();\n+        if (href == null || \"\".equals(href))\n+          href = base;\n+        else\n+          href = XMLParser.absolutize(base, href);\n+        if (parse == null || \"xml\".equals(parse))\n+          {\n+            seen.clear();\n+            result = null;\n+            snapshotIndex = 0;\n+            walker = null;\n+            current = null;\n+            backtracking = false;\n+            \n+            URLConnection connection = getURLConnection(href, accept,\n+                                                        acceptLanguage);\n+            InputStream in = connection.getInputStream();\n+            Document doc = getDocumentBuilder().parse(in, href);\n+            DocumentTraversal dt = getDocumentTraversal(doc);\n+            if (xpointer == null)\n+              {\n+                result = null;\n+                Node item = doc.getDocumentElement();\n+                walker = dt.createTreeWalker(item, SHOW_FLAGS, null,\n+                                             expandERefs);\n+              }\n+            else\n+              {\n+                result = null;\n+                snapshotIndex = 0;\n+                walker = null;\n+                // shorthand or scheme-based?\n+                int lpi = xpointer.indexOf('(');\n+                int rpi = xpointer.indexOf(')', lpi);\n+                if (lpi != -1 && rpi != -1)\n+                  {\n+                    String scheme = xpointer.substring(0, lpi);\n+                    if (\"element\".equals(scheme))\n+                      {\n+                        // element() scheme\n+                        String elementSchemeData =\n+                          xpointer.substring(lpi + 1, rpi);\n+                        Node item = doc;\n+                        int si = elementSchemeData.indexOf('/');\n+                        if (si == -1)\n+                          {\n+                            if (elementSchemeData.length() > 0)\n+                              item = doc.getElementById(elementSchemeData);\n+                          }\n+                        else\n+                          {\n+                            if (si > 0)\n+                              {\n+                                String context =\n+                                  elementSchemeData.substring(0, si);\n+                                item = doc.getElementById(context);\n+                                elementSchemeData =\n+                                  elementSchemeData.substring(si + 1);\n+                              }\n+                            StringTokenizer st =\n+                              new StringTokenizer(elementSchemeData, \"/\");\n+                            while (st.hasMoreTokens() && item != null)\n+                              {\n+                                int n = Integer.parseInt(st.nextToken());\n+                                Node ctx = item.getFirstChild();\n+                                int count = 1;\n+                                while (ctx != null && count++ < n)\n+                                  ctx = ctx.getNextSibling();\n+                                item = ctx;\n+                              }\n+                          }\n+                        walker = dt.createTreeWalker(item, SHOW_FLAGS, null,\n+                                                     expandERefs);\n+                        included = true;\n+                      }\n+                    else if (\"xpointer\".equals(scheme))\n+                      {\n+                        xpointer = xpointer.substring(lpi + 1, rpi);\n+                        XPathEvaluator eval = getXPathEvaluator(doc);\n+                        XPathNSResolver resolver = eval.createNSResolver(doc);\n+                        result =\n+                          (XPathResult) eval.evaluate(xpointer, doc,\n+                                                      resolver,\n+                                                      XPathResult.ANY_TYPE,\n+                                                      null);\n+                        // TODO xpointer() scheme functions\n+                        included = true;\n+                      }\n+                    else\n+                      {\n+                        String msg = \"Unknown XPointer scheme: \" + scheme;\n+                        throw new XMLStreamException(msg);\n+                      }\n+                  }\n+                else\n+                  {\n+                    Node item = doc.getElementById(xpointer);\n+                    walker = dt.createTreeWalker(item, SHOW_FLAGS, null,\n+                                                 expandERefs);\n+                    included = true;\n+                  }\n+              }\n+          }\n+        else if (\"text\".equals(parse))\n+          {\n+            URLConnection connection = getURLConnection(href, accept,\n+                                                        acceptLanguage);\n+            InputStream in = connection.getInputStream();\n+            if (encoding == null)\n+              {\n+                encoding = connection.getContentEncoding();\n+                if (encoding == null)\n+                  {\n+                    String contentType = connection.getContentType();\n+                    if (contentType != null)\n+                      encoding = getParameter(contentType, \"charset\");\n+                  }\n+              }\n+            if (encoding == null)\n+              includedText = new InputStreamReader(in, \"UTF-8\");\n+            else\n+              includedText = new InputStreamReader(in, encoding);\n+            included = true;\n+          }\n+        else\n+          throw new XMLStreamException(\"value of 'parse' attribute must be \"+\n+                                       \"'xml' or 'text'\");\n+        return true;\n+      }\n+    catch (IOException e)\n+      {\n+        return false;\n+      }\n+    catch (XMLStreamException e)\n+      {\n+        return false;\n+      }\n+    catch (SAXException e)\n+      {\n+        return false;\n+      }\n+  }\n+\n+  URLConnection getURLConnection(String href, String accept,\n+                                 String acceptLanguage)\n+    throws IOException\n+  {\n+    URL url = new URL(href);\n+    URLConnection connection = url.openConnection();\n+    if (connection instanceof HttpURLConnection)\n+      {\n+        HttpURLConnection http = (HttpURLConnection) connection;\n+        http.setInstanceFollowRedirects(true);\n+        if (accept != null)\n+          http.setRequestProperty(\"Accept\", accept);\n+        if (acceptLanguage != null)\n+          http.setRequestProperty(\"Accept-Language\", acceptLanguage);\n+      }\n+    return connection;\n+  }\n+\n+  Document getDocument(Node node)\n+  {\n+    if (node.getNodeType() == Node.DOCUMENT_NODE)\n+      return (Document) node;\n+    return node.getOwnerDocument();\n+  }\n+\n+  DocumentBuilder getDocumentBuilder()\n+    throws XMLStreamException\n+  {\n+    if (builder == null)\n+      {\n+        try\n+          {\n+            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n+            f.setXIncludeAware(true);\n+            f.setNamespaceAware(namespaceAware);\n+            f.setValidating(validating);\n+            builder = f.newDocumentBuilder();\n+          }\n+        catch (ParserConfigurationException e)\n+          {\n+            XMLStreamException e2 = new XMLStreamException(e.getMessage());\n+            e2.initCause(e);\n+            throw e2;\n+          }\n+      }\n+    builder.reset();\n+    return builder;\n+  }\n+\n+  DocumentTraversal getDocumentTraversal(Document doc)\n+    throws XMLStreamException\n+  {\n+    DOMImplementation dom = doc.getImplementation();\n+    if (!dom.hasFeature(\"Traversal\", \"2.0\"))\n+      throw new XMLStreamException(\"Traversal not supported\");\n+    return (DocumentTraversal) doc;\n+  }\n+\n+  XPathEvaluator getXPathEvaluator(Document doc)\n+    throws XMLStreamException\n+  {\n+    DOMImplementation dom = doc.getImplementation();\n+    if (!dom.hasFeature(\"XPath\", \"3.0\"))\n+      throw new XMLStreamException(\"XPath not supported\");\n+    return (XPathEvaluator) doc;\n+  }\n+\n+  static String getParameter(String contentType, String name)\n+  {\n+    StringTokenizer st = new StringTokenizer(contentType, \" ;\");\n+    if (st.hasMoreTokens())\n+      st.nextToken();\n+    while (st.hasMoreTokens())\n+      {\n+        String token = st.nextToken();\n+        int ei = token.indexOf('=');\n+        if (ei != -1)\n+          {\n+            String key = token.substring(0, ei);\n+            if (key.equals(name))\n+              {\n+                String value = token.substring(ei + 1);\n+                int len = value.length();\n+                if (len > 1 &&\n+                    value.charAt(0) == '\"' &&\n+                    value.charAt(len - 1) == '\"')\n+                  value = value.substring(1, len - 1);\n+                else if (len > 1 &&\n+                         value.charAt(0) == '\\'' &&\n+                         value.charAt(len - 1) == '\\'')\n+                  value = value.substring(1, len - 1);\n+                return value;\n+              }\n+          }\n+      }\n+    return null;\n+  }\n+  \n+}"}, {"sha": "164774d8236ee327b520aad80054b20ef17fa159", "filename": "libjava/classpath/gnu/xml/stream/XMLInputFactoryImpl.java", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLInputFactoryImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLInputFactoryImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLInputFactoryImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -77,6 +77,9 @@\n   protected boolean replacingEntityReferences = true;\n   protected boolean externalEntities = true;\n   protected boolean supportDTD = true;\n+  protected boolean xIncludeAware = false;\n+  protected boolean baseAware = true;\n+  protected boolean stringInterning = true;\n \n   public XMLInputFactoryImpl()\n   {\n@@ -86,33 +89,80 @@ public XMLInputFactoryImpl()\n   public XMLStreamReader createXMLStreamReader(Reader reader)\n     throws XMLStreamException\n   {\n+    /*\n     return new XMLStreamReaderImpl(reader, null, null,\n                                    resolver, reporter,\n                                    validating, namespaceAware,\n                                    coalescing, replacingEntityReferences,\n                                    externalEntities, supportDTD);\n+                                   */\n+    XMLParser ret = new XMLParser(reader, null,\n+                                  validating,\n+                                  namespaceAware,\n+                                  coalescing,\n+                                  replacingEntityReferences,\n+                                  externalEntities,\n+                                  supportDTD,\n+                                  baseAware,\n+                                  stringInterning,\n+                                  reporter,\n+                                  resolver);\n+    if (xIncludeAware)\n+      return new XIncludeFilter(ret, null, namespaceAware, validating,\n+                                replacingEntityReferences);\n+    return ret;\n   }\n   \n   public XMLStreamReader createXMLStreamReader(Source source)\n     throws XMLStreamException\n   {\n     String systemId = source.getSystemId();\n     InputStream in = getInputStream(source);\n-    return new XMLStreamReaderImpl(in, null, systemId,\n+    /*return new XMLStreamReaderImpl(in, null, systemId,\n                                    resolver, reporter,\n                                    validating, namespaceAware,\n                                    coalescing, replacingEntityReferences,\n-                                   externalEntities, supportDTD);\n+                                   externalEntities, supportDTD);*/\n+    XMLParser ret = new XMLParser(in, systemId,\n+                                  validating,\n+                                  namespaceAware,\n+                                  coalescing,\n+                                  replacingEntityReferences,\n+                                  externalEntities,\n+                                  supportDTD,\n+                                  baseAware,\n+                                  stringInterning,\n+                                  reporter,\n+                                  resolver);\n+    if (xIncludeAware)\n+      return new XIncludeFilter(ret, systemId, namespaceAware, validating,\n+                                replacingEntityReferences);\n+    return ret;\n   }\n   \n   public XMLStreamReader createXMLStreamReader(InputStream in)\n     throws XMLStreamException\n   {\n-    return new XMLStreamReaderImpl(in, null, null,\n+    /*return new XMLStreamReaderImpl(in, null, null,\n                                    resolver, reporter,\n                                    validating, namespaceAware,\n                                    coalescing, replacingEntityReferences,\n-                                   externalEntities, supportDTD);\n+                                   externalEntities, supportDTD);*/\n+    XMLParser ret = new XMLParser(in, null,\n+                                  validating,\n+                                  namespaceAware,\n+                                  coalescing,\n+                                  replacingEntityReferences,\n+                                  externalEntities,\n+                                  supportDTD,\n+                                  baseAware,\n+                                  stringInterning,\n+                                  reporter,\n+                                  resolver);\n+    if (xIncludeAware)\n+      return new XIncludeFilter(ret, null, namespaceAware, validating,\n+                                replacingEntityReferences);\n+    return ret;\n   }\n   \n   public XMLStreamReader createXMLStreamReader(InputStream in, String encoding)\n@@ -210,6 +260,12 @@ else if (name.equals(RESOLVER))\n       resolver = (XMLResolver) value;\n     else if (name.equals(ALLOCATOR))\n       allocator = (XMLEventAllocator) value;\n+    else if (name.equals(\"gnu.xml.stream.stringInterning\"))\n+      stringInterning = ((Boolean) value).booleanValue();\n+    else if (name.equals(\"gnu.xml.stream.baseAware\"))\n+      baseAware = ((Boolean) value).booleanValue();\n+    else if (name.equals(\"gnu.xml.stream.xIncludeAware\"))\n+      xIncludeAware = ((Boolean) value).booleanValue();\n     else\n       throw new IllegalArgumentException(name);\n   }\n@@ -235,6 +291,12 @@ public Object getProperty(String name)\n       return resolver;\n     if (name.equals(ALLOCATOR))\n       return allocator;\n+    if (name.equals(\"gnu.xml.stream.stringInterning\"))\n+      return stringInterning ? Boolean.TRUE : Boolean.FALSE;\n+    if (name.equals(\"gnu.xml.stream.baseAware\"))\n+      return baseAware ? Boolean.TRUE : Boolean.FALSE;\n+    if (name.equals(\"gnu.xml.stream.xIncludeAware\"))\n+      return xIncludeAware ? Boolean.TRUE : Boolean.FALSE;\n     throw new IllegalArgumentException(name);\n   }\n \n@@ -248,7 +310,10 @@ public boolean isPropertySupported(String name)\n       name.equals(SUPPORT_DTD) ||\n       name.equals(REPORTER) ||\n       name.equals(RESOLVER) ||\n-      name.equals(ALLOCATOR);\n+      name.equals(ALLOCATOR) ||\n+      name.equals(\"gnu.xml.stream.stringInterning\") ||\n+      name.equals(\"gnu.xml.stream.baseAware\") ||\n+      name.equals(\"gnu.xml.stream.xIncludeAware\");\n   }\n   \n   public void setEventAllocator(XMLEventAllocator allocator)"}, {"sha": "6f10b9303dc7dae6064389b664cec484c88781e2", "filename": "libjava/classpath/gnu/xml/stream/XMLParser.java", "status": "added", "additions": 5266, "deletions": 0, "changes": 5266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLParser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLParser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLParser.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "6157296c6b83dd8eafef883c93111f965dd4bfed", "filename": "libjava/classpath/gnu/xml/stream/XMLStreamWriterImpl.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLStreamWriterImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLStreamWriterImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fstream%2FXMLStreamWriterImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -282,6 +282,8 @@ public void writeEmptyElement(String localName)\n   public void writeEndElement()\n     throws XMLStreamException\n   {\n+    if (elements.isEmpty())\n+      throw new IllegalStateException(\"no matching start element\");\n     try\n       {\n         endStartElement();"}, {"sha": "bc5bc30c9c17e55837a6dcc589f9290920f09988", "filename": "libjava/classpath/gnu/xml/transform/AttributeNode.java", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FAttributeNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FAttributeNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FAttributeNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* AttributeNode.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -75,13 +75,9 @@ TemplateNode clone(Stylesheet stylesheet)\n                                          namespace.clone(stylesheet),\n                                          source);\n     if (children != null)\n-      {\n-        ret.children = children.clone(stylesheet);\n-      }\n+      ret.children = children.clone(stylesheet);\n     if (next != null)\n-      {\n-        ret.next = next.clone(stylesheet);\n-      }\n+      ret.next = next.clone(stylesheet);\n     return ret;\n   }\n \n@@ -113,9 +109,7 @@ void doApply(Stylesheet stylesheet, QName mode,\n         // Use XPath string-value of fragment\n         namespaceValue = Expr.stringValue(fragment);\n         if (namespaceValue.length() == 0)\n-          {\n-            namespaceValue = null;\n-          }\n+          namespaceValue = null;\n       }\n     \n     String prefix = getPrefix(nameValue);\n@@ -124,9 +118,7 @@ void doApply(Stylesheet stylesheet, QName mode,\n         if (prefix != null)\n           {\n             if (XMLConstants.XML_NS_PREFIX.equals(prefix))\n-              {\n-                namespaceValue = XMLConstants.XML_NS_URI;\n-              }\n+              namespaceValue = XMLConstants.XML_NS_URI;\n             else\n               {\n                 // Resolve namespace for this prefix\n@@ -153,9 +145,7 @@ void doApply(Stylesheet stylesheet, QName mode,\n         // Resolve prefix for this namespace\n         prefix = source.lookupPrefix(namespaceValue);\n         if (prefix != null)\n-          {\n-            nameValue = prefix + \":\" + nameValue;\n-          }\n+          nameValue = prefix + \":\" + nameValue;\n         else\n           {\n             if (namespaceValue != null)\n@@ -196,27 +186,19 @@ void doApply(Stylesheet stylesheet, QName mode,\n         if (attrs != null)\n           {\n             if (namespace != null)\n-              {\n-                attrs.setNamedItemNS(attr);\n-              }\n+              attrs.setNamedItemNS(attr);\n             else\n-              {\n-                attrs.setNamedItem(attr);\n-              }\n+              attrs.setNamedItem(attr);\n           }\n         if (children != null)\n-          {\n-            children.apply(stylesheet, mode,\n-                           context, pos, len,\n-                           attr, null);\n-          }\n+          children.apply(stylesheet, mode,\n+                         context, pos, len,\n+                         attr, null);\n       }\n     if (next != null)\n-      {\n-        next.apply(stylesheet, mode,\n-                   context, pos, len,\n-                   parent, nextSibling);\n-      }\n+      next.apply(stylesheet, mode,\n+                 context, pos, len,\n+                 parent, nextSibling);\n   }\n \n   final String getPrefix(String name)\n@@ -241,13 +223,9 @@ final String inventPrefix(Node parent)\n   public boolean references(QName var)\n   {\n     if (name != null && name.references(var))\n-      {\n-        return true;\n-      }\n+      return true;\n     if (namespace != null && namespace.references(var))\n-      {\n-        return true;\n-      }\n+      return true;\n     return super.references(var);\n   }\n   "}, {"sha": "4ee08322317a12967666c70485caf5c66f92b007", "filename": "libjava/classpath/gnu/xml/transform/Bindings.java", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FBindings.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FBindings.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FBindings.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -78,6 +78,11 @@\n    */\n   final LinkedList withParameters;\n \n+  /**\n+   * Only search globals.\n+   */\n+  boolean global;\n+\n   Bindings(Stylesheet stylesheet)\n   {\n     this.stylesheet = stylesheet;\n@@ -136,6 +141,12 @@ void pop(int type)\n \n   public boolean containsKey(QName name, int type)\n   {\n+    if (global)\n+      {\n+        Map ctx1 = (Map) variables.getLast();\n+        Map ctx2 = (Map) parameters.getLast();\n+        return (ctx1.containsKey(name) || ctx2.containsKey(name));\n+      }\n     Iterator i = null;\n     switch (type)\n       {\n@@ -165,6 +176,17 @@ public boolean containsKey(QName name, int type)\n \n   public Object get(QName name, Node context, int pos, int len)\n   {\n+    if (global)\n+      {\n+        Map ctx = (Map) variables.getLast();\n+        Object ret = ctx.get(name);\n+        if (ret == null)\n+          {\n+            ctx = (Map) parameters.getLast();\n+            ret = ctx.get(name);\n+          }\n+        return ret;\n+      }\n     //System.err.println(\"bindings.get: \"+name);\n     //System.err.println(\"\\t\"+toString());\n     Object ret = null;"}, {"sha": "aa15981695e0c7e2e5264b8e6686bdbabab6e7aa", "filename": "libjava/classpath/gnu/xml/transform/ElementAvailableFunction.java", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementAvailableFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementAvailableFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementAvailableFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -144,25 +144,21 @@ public Object evaluate(Node context, int pos, int len)\n       {\n         return elements.contains(localName) ?\n           Boolean.TRUE : Boolean.FALSE;\n-        // TODO extension elements\n       }\n+    // TODO extension elements\n     return Boolean.FALSE;\n   }\n   \n   public Expr clone(Object context)\n   {\n     NamespaceContext n = nsctx;\n     if (context instanceof NamespaceContext)\n-      {\n-        n = (NamespaceContext) context;\n-      }\n+      n = (NamespaceContext) context;\n     ElementAvailableFunction f = new ElementAvailableFunction(n);\n     int len = args.size();\n     List args2 = new ArrayList(len);\n     for (int i = 0; i < len; i++)\n-      {\n-        args2.add(((Expr) args.get(i)).clone(context));\n-      }\n+      args2.add(((Expr) args.get(i)).clone(context));\n     f.setArguments(args2);\n     return f;\n   }\n@@ -172,12 +168,15 @@ public boolean references(QName var)\n     for (Iterator i = args.iterator(); i.hasNext(); )\n       {\n         if (((Expr) i.next()).references(var))\n-          {\n-            return true;\n-          }\n+          return true;\n       }\n     return false;\n   }\n \n+  public String toString()\n+  {\n+    return \"element-available(\" + args.get(0) + \")\";\n+  }\n+\n }\n "}, {"sha": "092c56a4b64b62ab097866df7940d2a18d3c5df8", "filename": "libjava/classpath/gnu/xml/transform/ElementNode.java", "status": "modified", "additions": 60, "deletions": 97, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FElementNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -82,14 +82,10 @@\n         elementExcludeResultPrefixes = new HashSet();\n         StringTokenizer st = new StringTokenizer(attr.getNodeValue());\n         while (st.hasMoreTokens())\n-          {\n-            elementExcludeResultPrefixes.add(st.nextToken());\n-          }\n+          elementExcludeResultPrefixes.add(st.nextToken());\n       }\n     else\n-      {\n-        elementExcludeResultPrefixes = Collections.EMPTY_SET;\n-      }\n+      elementExcludeResultPrefixes = Collections.EMPTY_SET;\n   }\n \n   TemplateNode clone(Stylesheet stylesheet)\n@@ -99,19 +95,15 @@ TemplateNode clone(Stylesheet stylesheet)\n                                        namespace.clone(stylesheet),\n                                        uas, source);\n     if (children != null)\n-      {\n-        ret.children = children.clone(stylesheet);\n-      }\n+      ret.children = children.clone(stylesheet);\n     if (next != null)\n-      {\n-        ret.next = next.clone(stylesheet);\n-      }\n+      ret.next = next.clone(stylesheet);\n     return ret;\n   }\n \n   void doApply(Stylesheet stylesheet, QName mode,\n-             Node context, int pos, int len,\n-             Node parent, Node nextSibling)\n+               Node context, int pos, int len,\n+               Node parent, Node nextSibling)\n     throws TransformerException\n   {\n     Document doc = (parent instanceof Document) ? (Document) parent :\n@@ -137,96 +129,70 @@ void doApply(Stylesheet stylesheet, QName mode,\n         // Use XPath string-value of fragment\n         namespaceValue = Expr.stringValue(fragment);\n         if (namespaceValue.length() == 0)\n-          {\n-            namespaceValue = null;\n-          }\n-      }\n-    \n-    String prefix = getPrefix(nameValue);\n-    if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix))\n-      {\n-        int ci = nameValue.indexOf(':');\n-        nameValue = nameValue.substring(ci + 1);\n+          namespaceValue = null;\n       }\n     else\n-      {\n-        // Namespace aliasing\n-        if (prefix == null)\n-          {\n-            prefix = \"#default\";\n-          }\n-        String resultPrefix =\n-          (String) stylesheet.namespaceAliases.get(prefix);\n-        if (resultPrefix != null)\n-          {\n-            if (\"#default\".equals(resultPrefix))\n-              {\n-                resultPrefix = null;\n-              }\n-            namespaceValue = source.lookupNamespaceURI(resultPrefix);\n-          }\n-        if (prefix == \"#default\")\n+      {    \n+        String prefix = getPrefix(nameValue);\n+        if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix))\n           {\n-            prefix = null;\n+            int ci = nameValue.indexOf(':');\n+            nameValue = nameValue.substring(ci + 1);\n           }\n-        // Look up ordinary namespace for this prefix\n-        if (namespaceValue == null)\n+        else\n           {\n-            if (XMLConstants.XML_NS_PREFIX.equals(prefix))\n+            // Namespace aliasing\n+            if (prefix == null)\n+              prefix = \"#default\";\n+            String resultPrefix =\n+              (String) stylesheet.namespaceAliases.get(prefix);\n+            if (resultPrefix != null)\n               {\n-                namespaceValue = XMLConstants.XML_NS_URI;\n+                if (\"#default\".equals(resultPrefix))\n+                  resultPrefix = null;\n+                namespaceValue = source.lookupNamespaceURI(resultPrefix);\n               }\n-            else\n+            if (prefix == \"#default\")\n+              prefix = null;\n+            // Look up ordinary namespace for this prefix\n+            if (namespaceValue == null)\n               {\n-                // Resolve namespace for this prefix\n-                namespaceValue = source.lookupNamespaceURI(prefix);\n+                if (XMLConstants.XML_NS_PREFIX.equals(prefix))\n+                  namespaceValue = XMLConstants.XML_NS_URI;\n+                else\n+                  {\n+                    // Resolve namespace for this prefix\n+                    namespaceValue = source.lookupNamespaceURI(prefix);\n+                  }\n               }\n           }\n-        /*if (prefix == null)\n-          {\n-            // Resolve prefix for this namespace\n-            prefix = parent.lookupPrefix(namespaceValue);\n-            if (prefix != null)\n-              {\n-                nameValue = prefix + \":\" + nameValue;\n-              }\n-          }*/\n       }\n+    \n     // Create element\n     Element element = (namespaceValue != null) ?\n       doc.createElementNS(namespaceValue, nameValue) :\n-          doc.createElement(nameValue);\n+      doc.createElement(nameValue);\n     if (nextSibling != null)\n-      {\n-        parent.insertBefore(element, nextSibling);\n-      }\n+      parent.insertBefore(element, nextSibling);\n     else\n-      {\n-        parent.appendChild(element);\n-      }\n+      parent.appendChild(element);\n     stylesheet.addNamespaceNodes(source, element, doc,\n                                  elementExcludeResultPrefixes);\n     if (uas != null)\n       {\n         StringTokenizer st = new StringTokenizer(uas, \" \");\n         while (st.hasMoreTokens())\n-          {\n-            addAttributeSet(stylesheet, mode, context, pos, len,\n-                            element, null, st.nextToken());\n-          }\n+          addAttributeSet(stylesheet, mode, context, pos, len,\n+                          element, null, st.nextToken());\n       }\n     if (children != null)\n-      {\n-        children.apply(stylesheet, mode,\n-                       context, pos, len,\n-                       element, null);\n-      }\n+      children.apply(stylesheet, mode,\n+                     context, pos, len,\n+                     element, null);\n     if (next != null)\n-      {\n-        next.apply(stylesheet, mode,\n-                   context, pos, len,\n-                   parent, nextSibling);\n-      }\n+      next.apply(stylesheet, mode,\n+                 context, pos, len,\n+                 parent, nextSibling);\n   }\n \n   final String getPrefix(String name)\n@@ -240,41 +206,33 @@ void addAttributeSet(Stylesheet stylesheet, QName mode,\n                        Node parent, Node nextSibling, String attributeSet)\n     throws TransformerException\n   {\n+    stylesheet.bindings.global = true;\n     for (Iterator i = stylesheet.attributeSets.iterator(); i.hasNext(); )\n       {\n         AttributeSet as = (AttributeSet) i.next();\n         if (!as.name.equals(attributeSet))\n-          {\n-            continue;\n-          }\n+          continue;\n         if (as.uas != null)\n           {\n             StringTokenizer st = new StringTokenizer(as.uas, \" \");\n             while (st.hasMoreTokens())\n-              {\n-                addAttributeSet(stylesheet, mode, context, pos, len,\n-                                parent, nextSibling, st.nextToken());\n-              }\n+              addAttributeSet(stylesheet, mode, context, pos, len,\n+                              parent, nextSibling, st.nextToken());\n           }\n         if (as.children != null)\n-          {\n-            as.children.apply(stylesheet, mode,\n-                              context, pos, len,\n-                              parent, nextSibling);\n-          }\n+          as.children.apply(stylesheet, mode,\n+                            context, pos, len,\n+                            parent, nextSibling);\n       }\n+    stylesheet.bindings.global = false;\n   }\n \n   public boolean references(QName var)\n   {\n     if (name != null && name.references(var))\n-      {\n-        return true;\n-      }\n+      return true;\n     if (namespace != null && namespace.references(var))\n-      {\n-        return true;\n-      }\n+      return true;\n     return super.references(var);\n   }\n   \n@@ -283,6 +241,11 @@ public String toString()\n     StringBuffer buf = new StringBuffer(getClass().getName());\n     buf.append('[');\n     buf.append(\"name=\");\n+    if (namespace != null)\n+      {\n+        buf.append(\",namespace=\");\n+        buf.append(namespace);\n+      }\n     buf.append(name);\n     if (uas != null)\n       {"}, {"sha": "ab86401d0e4981798535575eb6a19dca321ca2c4", "filename": "libjava/classpath/gnu/xml/transform/FunctionAvailableFunction.java", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FFunctionAvailableFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FFunctionAvailableFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FFunctionAvailableFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -147,28 +147,29 @@ public Object evaluate(Node context, int pos, int len)\n     uri = nsctx.getNamespaceURI(prefix);\n     if (uri == null)\n       {\n-        return xsltFunctions.contains(localName) ||\n-          xpathFunctions.contains(localName) ?\n+        return (xpathFunctions.contains(localName)  ||\n+                xsltFunctions.contains(localName)) ?\n           Boolean.TRUE : Boolean.FALSE;\n-        // TODO extension functions\n       }\n+    else if (Stylesheet.XSL_NS.equals(uri))\n+      {\n+        return xsltFunctions.contains(localName) ?\n+          Boolean.TRUE : Boolean.FALSE;\n+      }\n+    // TODO extension functions\n     return Boolean.FALSE;\n   }\n   \n   public Expr clone(Object context)\n   {\n     NamespaceContext n = nsctx;\n     if (context instanceof NamespaceContext)\n-      {\n-        n = (NamespaceContext) context;\n-      }\n+      n = (NamespaceContext) context;\n     FunctionAvailableFunction f = new FunctionAvailableFunction(n);\n     int len = args.size();\n     List args2 = new ArrayList(len);\n     for (int i = 0; i < len; i++)\n-      {\n-        args2.add(((Expr) args.get(i)).clone(context));\n-      }\n+      args2.add(((Expr) args.get(i)).clone(context));\n     f.setArguments(args2);\n     return f;\n   }\n@@ -178,12 +179,15 @@ public boolean references(QName var)\n     for (Iterator i = args.iterator(); i.hasNext(); )\n       {\n         if (((Expr) i.next()).references(var))\n-          {\n-            return true;\n-          }\n+          return true;\n       }\n     return false;\n   }\n \n+  public String toString()\n+  {\n+    return \"function-available(\" + args.get(0) + \")\";\n+  }\n+\n }\n "}, {"sha": "453c22c5e0d5736d4956fadb2630a1ef9675bd16", "filename": "libjava/classpath/gnu/xml/transform/LiteralNode.java", "status": "modified", "additions": 20, "deletions": 44, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FLiteralNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FLiteralNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FLiteralNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* LiteralNode.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -77,38 +77,28 @@\n             elementExcludeResultPrefixes = new HashSet();\n             StringTokenizer st = new StringTokenizer(attr.getNodeValue());\n             while (st.hasMoreTokens())\n-              {\n-                elementExcludeResultPrefixes.add(st.nextToken());\n-              }\n+              elementExcludeResultPrefixes.add(st.nextToken());\n           }\n         else\n-          {\n-            elementExcludeResultPrefixes = Collections.EMPTY_SET;\n-          }\n+          elementExcludeResultPrefixes = Collections.EMPTY_SET;\n       }\n     else\n-      {\n-        elementExcludeResultPrefixes = null;\n-      }\n+      elementExcludeResultPrefixes = null;\n   }\n \n   TemplateNode clone(Stylesheet stylesheet)\n   {\n     TemplateNode ret = new LiteralNode(source);\n     if (children != null)\n-      {\n-        ret.children = children.clone(stylesheet);\n-      }\n+      ret.children = children.clone(stylesheet);\n     if (next != null)\n-      {\n-        ret.next = next.clone(stylesheet);\n-      }\n+      ret.next = next.clone(stylesheet);\n     return ret;\n   }\n \n   void doApply(Stylesheet stylesheet, QName mode,\n-             Node context, int pos, int len,\n-             Node parent, Node nextSibling)\n+               Node context, int pos, int len,\n+               Node parent, Node nextSibling)\n     throws TransformerException\n   {\n     Node result = null;\n@@ -127,17 +117,13 @@ void doApply(Stylesheet stylesheet, QName mode,\n           {\n             String prefix = source.getPrefix();\n             if (prefix == null)\n-              {\n-                prefix = \"#default\";\n-              }\n+              prefix = \"#default\";\n             String resultPrefix =\n               (String) stylesheet.namespaceAliases.get(prefix);\n             if (resultPrefix != null)\n               {\n                 if (\"#default\".equals(resultPrefix))\n-                  {\n-                    resultPrefix = null;\n-                  }\n+                  resultPrefix = null;\n                 String uri = source.lookupNamespaceURI(resultPrefix);\n                 String name = source.getNodeName();\n                 // Create a new element node in the result document\n@@ -189,33 +175,23 @@ void doApply(Stylesheet stylesheet, QName mode,\n             result = result2;\n           }\n         if (nextSibling != null)\n-          {\n-            parent.insertBefore(result, nextSibling);\n-          }\n+          parent.insertBefore(result, nextSibling);\n         else\n-          {\n-            parent.appendChild(result);\n-          }\n+          parent.appendChild(result);\n         if (nodeType == Node.ELEMENT_NODE)\n-          {\n-            stylesheet.addNamespaceNodes(source, result, doc,\n-                                         elementExcludeResultPrefixes);\n-          }\n+          stylesheet.addNamespaceNodes(source, result, doc,\n+                                       elementExcludeResultPrefixes);\n         // children\n         if (children != null)\n-          {\n-            children.apply(stylesheet, mode,\n-                           context, pos, len,\n-                           result, null);\n-          }\n+          children.apply(stylesheet, mode,\n+                         context, pos, len,\n+                         result, null);\n       }\n     // next sibling\n     if (next != null)\n-      {\n-        next.apply(stylesheet, mode,\n-                   context, pos, len,\n-                   parent, nextSibling);\n-      }\n+      next.apply(stylesheet, mode,\n+                 context, pos, len,\n+                 parent, nextSibling);\n   }\n \n   public String toString()"}, {"sha": "e8e07c6da29654264aa080120cabe95cf118084d", "filename": "libjava/classpath/gnu/xml/transform/MessageNode.java", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FMessageNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FMessageNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FMessageNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* MessageNode.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n package gnu.xml.transform;\n \n+import java.util.logging.Logger;\n import javax.xml.namespace.QName;\n import javax.xml.transform.TransformerException;\n import org.w3c.dom.Document;\n@@ -53,6 +54,8 @@\n   extends TemplateNode\n {\n \n+  static final Logger logger = Logger.getLogger(\"gnu.xml.transform\");\n+\n   final boolean terminate;\n \n   MessageNode(boolean terminate)\n@@ -64,13 +67,9 @@ TemplateNode clone(Stylesheet stylesheet)\n   {\n     TemplateNode ret = new MessageNode(terminate);\n     if (children != null)\n-      {\n-        ret.children = children.clone(stylesheet);\n-      }\n+      ret.children = children.clone(stylesheet);\n     if (next != null)\n-      {\n-        ret.next = next.clone(stylesheet);\n-      }\n+      ret.next = next.clone(stylesheet);\n     return ret;\n   }\n \n@@ -86,16 +85,12 @@ void doApply(Stylesheet stylesheet, QName mode,\n         DocumentFragment fragment = doc.createDocumentFragment();\n         children.apply(stylesheet, mode, context, pos, len, fragment, null);\n         String message = Expr.stringValue(fragment);\n-        System.err.println(message);\n+        logger.info(message);\n         if (terminate)\n-          {\n-            stylesheet.terminated = true;\n-          }\n+          stylesheet.terminated = true;\n       }\n     if (next != null && !terminate)\n-      {\n-        next.apply(stylesheet, mode, context, pos, len, parent, nextSibling);\n-      }\n+      next.apply(stylesheet, mode, context, pos, len, parent, nextSibling);\n   }\n   \n }"}, {"sha": "b3c233cd7a525ddc449e2be75e2e2ed33c72f324", "filename": "libjava/classpath/gnu/xml/transform/NamespaceProxy.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FNamespaceProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FNamespaceProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FNamespaceProxy.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,77 @@\n+/* NamespaceProxy.java -- \n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.xml.transform;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import javax.xml.namespace.NamespaceContext;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * A namespace context using a DOM node to resolve the namespace.\n+ *\n+ * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n+ */\n+class NamespaceProxy\n+  implements NamespaceContext\n+{\n+\n+  private final Node node;\n+\n+  NamespaceProxy(Node node)\n+  {\n+    this.node = node;\n+  }\n+  \n+  public String getNamespaceURI(String prefix)\n+  {\n+    return (node == null) ? null : node.lookupNamespaceURI(prefix);\n+  }\n+\n+  public String getPrefix(String namespaceURI)\n+  {\n+    return (node == null) ? null : node.lookupPrefix(namespaceURI);\n+  }\n+\n+  public Iterator getPrefixes(String namespaceURI)\n+  {\n+    // TODO\n+    return Collections.singleton(getPrefix(namespaceURI)).iterator();\n+  }\n+\n+}"}, {"sha": "fb8b1a601bcb7fe0df849bb2a37c31ee23705d96", "filename": "libjava/classpath/gnu/xml/transform/StreamSerializer.java", "status": "modified", "additions": 280, "deletions": 194, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStreamSerializer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStreamSerializer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStreamSerializer.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* StreamSerializer.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -49,6 +49,8 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.Map;\n import javax.xml.XMLConstants;\n import org.w3c.dom.Attr;\n@@ -149,16 +151,25 @@\n     HTML_BOOLEAN_ATTRIBUTES.put(\"script\", set);\n   }\n \n+  // HTML namespace URIs\n+  static final HashSet HTML_URIS = new HashSet();\n+  static {\n+    HTML_URIS.add(\"http://www.w3.org/1999/xhtml\");\n+  }\n+\n   protected final String encoding;\n   final Charset charset;\n   final CharsetEncoder encoder;\n   final int mode;\n-  final Map namespaces;\n+  final LinkedList namespaces;\n   protected String eol;\n   Collection cdataSectionElements = Collections.EMPTY_SET;\n \n   protected boolean discardDefaultContent;\n   protected boolean xmlDeclaration = true;\n+  \n+  // has a META element with the encoding been added?\n+  private boolean htmlEncoded;\n \n   public StreamSerializer()\n   {\n@@ -174,14 +185,12 @@ public StreamSerializer(int mode, String encoding, String eol)\n   {\n     this.mode = mode;\n     if (encoding == null)\n-      {\n-        encoding = \"UTF-8\";\n-      }\n+      encoding = (mode == Stylesheet.OUTPUT_HTML) ? \"ISO-8859-1\" : \"UTF-8\";\n     this.encoding = encoding.intern();\n     charset = Charset.forName(this.encoding);\n     encoder = charset.newEncoder();\n     this.eol = (eol != null) ? eol : System.getProperty(\"line.separator\");\n-    namespaces = new HashMap();\n+    namespaces = new LinkedList();\n   }\n \n   void setCdataSectionElements(Collection c)\n@@ -212,18 +221,14 @@ private void doSerialize(final Node node, final OutputStream out,\n     throws IOException\n   {\n     if (out == null)\n-      {\n-        throw new NullPointerException(\"no output stream\");\n-      }\n+      throw new NullPointerException(\"no output stream\");\n+    htmlEncoded = false;\n     String value, prefix;\n     Node children;\n     String uri = node.getNamespaceURI();\n-    boolean defined = false;\n     short nt = node.getNodeType();\n     if (convertToCdata && nt == Node.TEXT_NODE)\n-      {\n-        nt = Node.CDATA_SECTION_NODE;\n-      }\n+      nt = Node.CDATA_SECTION_NODE;\n     switch (nt)\n       {\n       case Node.ATTRIBUTE_NODE:\n@@ -233,27 +238,28 @@ private void doSerialize(final Node node, final OutputStream out,\n             (prefix != null && prefix.startsWith(\"xmlns:\")))\n           {\n             String nsuri = node.getNodeValue();\n-            if (isDefined(nsuri))\n-              {\n-                break;\n-              }\n+            if (isDefined(nsuri, prefix))\n+              break;\n             String name = node.getLocalName();\n             if (name == null)\n               {\n+                // Namespace-unaware\n                 name = node.getNodeName();\n+                int ci = name.indexOf(':');\n+                if (ci != -1)\n+                  name = name.substring(ci + 1);\n               }\n             define(nsuri, name);\n           }\n-        else if (uri != null && !isDefined(uri))\n+        else if (uri != null && !isDefined(uri, prefix))\n           {\n             prefix = define(uri, prefix);\n             String nsname = (prefix == null) ? \"xmlns\" : \"xmlns:\" + prefix;\n             out.write(SPACE);\n             out.write(encodeText(nsname));\n             out.write(EQ);\n-            String nsvalue = \"'\" + encode(uri, true, true) + \"'\";\n+            String nsvalue = \"\\\"\" + encode(uri, true, true) + \"\\\"\";\n             out.write(nsvalue.getBytes(encoding));\n-            defined = true;\n           }\n         out.write(SPACE);\n         String a_nodeName = node.getNodeName();\n@@ -262,27 +268,26 @@ else if (uri != null && !isDefined(uri))\n         if (mode == Stylesheet.OUTPUT_HTML &&\n             a_nodeName.equals(a_nodeValue) &&\n             isHTMLBoolean((Attr) node, a_nodeName))\n-          {\n-            break;\n-          }\n+          break;\n         out.write(EQ);\n-        value = \"'\" + encode(a_nodeValue, true, true) + \"'\";\n+        value = \"\\\"\" + encode(a_nodeValue, true, true) + \"\\\"\";\n         out.write(encodeText(value));\n         break;\n       case Node.ELEMENT_NODE:\n+        pushNamespaceContext();\n         value = node.getNodeName();\n         out.write(BRA);\n         out.write(encodeText(value));\n-        if (uri != null && !isDefined(uri))\n+        prefix = node.getPrefix();\n+        if (uri != null && !isDefined(uri, prefix))\n           {\n-            prefix = define(uri, node.getPrefix());\n+            prefix = define(uri, prefix);\n             String nsname = (prefix == null) ? \"xmlns\" : \"xmlns:\" + prefix;\n             out.write(SPACE);\n             out.write(encodeText(nsname));\n             out.write(EQ);\n-            String nsvalue = \"'\" + encode(uri, true, true) + \"'\";\n+            String nsvalue = \"\\\"\" + encode(uri, true, true) + \"\\\"\";\n             out.write(encodeText(nsvalue));\n-            defined = true;\n           }\n         NamedNodeMap attrs = node.getAttributes();\n         if (attrs != null)\n@@ -296,9 +301,7 @@ else if (uri != null && !isDefined(uri))\n                     // NOOP\n                   }\n                 else\n-                  {\n-                    serialize(attr, out, false);\n-                  }\n+                  serialize(attr, out, false);\n               }\n           }\n         convertToCdata = cdataSectionElements.contains(value);\n@@ -317,27 +320,35 @@ else if (uri != null && !isDefined(uri))\n             out.write(encodeText(value));\n             out.write(KET);\n           }\n+        popNamespaceContext();\n         break;\n       case Node.TEXT_NODE:\n         value = node.getNodeValue();\n         if (!\"yes\".equals(node.getUserData(\"disable-output-escaping\")))\n-          {\n-            value = encode(value, false, false);\n-          }\n+          value = encode(value, false, false);\n         out.write(encodeText(value));\n         break;\n       case Node.CDATA_SECTION_NODE:\n-        value = \"<![CDATA[\" + node.getNodeValue() + \"]]>\";\n-        out.write(encodeText(value));\n+        value = node.getNodeValue();\n+        // Where any instanceof of ]]> occur, split into multiple CDATA\n+        // sections\n+        int bbk = value.indexOf(\"]]>\");\n+        while (bbk != -1)\n+          {\n+            String head = value.substring(0, bbk + 2);\n+            out.write(encodeText(\"<![CDATA[\" + head + \"]]>\"));\n+            value = value.substring(bbk + 2);\n+            bbk = value.indexOf(\"]]>\");\n+          }\n+        // Write final tail value\n+        out.write(encodeText(\"<![CDATA[\" + value + \"]]>\"));\n         break;\n       case Node.COMMENT_NODE:\n         value = \"<!--\" + node.getNodeValue() + \"-->\";\n         out.write(encodeText(value));\n         Node cp = node.getParentNode();\n         if (cp != null && cp.getNodeType() == Node.DOCUMENT_NODE)\n-          {\n-            out.write(encodeText(eol));\n-          }\n+          out.write(encodeText(eol));\n         break;\n       case Node.DOCUMENT_NODE:\n       case Node.DOCUMENT_FRAGMENT_NODE:\n@@ -355,29 +366,23 @@ else if (uri != null && !isDefined(uri))\n                   (Document) node : null;\n                 String version = (doc != null) ? doc.getXmlVersion() : null;\n                 if (version == null)\n-                  {\n-                    version = (String) node.getUserData(\"version\");\n-                  }\n+                  version = (String) node.getUserData(\"version\");\n                 if (version == null)\n-                  {\n-                    version = \"1.0\";\n-                  }\n+                  version = \"1.0\";\n                 out.write(BRA);\n                 out.write(0x3f);\n-                out.write(\"xml version='\".getBytes(\"US-ASCII\"));\n+                out.write(\"xml version=\\\"\".getBytes(\"US-ASCII\"));\n                 out.write(version.getBytes(\"US-ASCII\"));\n-                out.write(APOS);\n+                out.write(0x22);\n                 if (!(\"UTF-8\".equalsIgnoreCase(encoding)))\n                   {\n-                    out.write(\" encoding='\".getBytes(\"US-ASCII\"));\n+                    out.write(\" encoding=\\\"\".getBytes(\"US-ASCII\"));\n                     out.write(encoding.getBytes(\"US-ASCII\"));\n-                    out.write(APOS);\n+                    out.write(0x22);\n                   }\n                 if ((doc != null && doc.getXmlStandalone()) ||\n                     \"yes\".equals(node.getUserData(\"standalone\")))\n-                  {\n-                    out.write(\" standalone='yes'\".getBytes(\"US-ASCII\"));\n-                  }\n+                  out.write(\" standalone=\\\"yes\\\"\".getBytes(\"US-ASCII\"));\n                 out.write(0x3f);\n                 out.write(KET);\n                 out.write(encodeText(eol));\n@@ -387,12 +392,10 @@ else if (uri != null && !isDefined(uri))\n           }\n         else if (mode == Stylesheet.OUTPUT_HTML)\n           {\n-            // Ensure that encoding is accessible\n+            // Ensure that encoding is accessible if head element is present\n             String mediaType = (String) node.getUserData(\"media-type\");\n             if (mediaType == null)\n-              {\n-                mediaType = \"text/html\";\n-              }\n+              mediaType = \"text/html\";\n             String contentType = mediaType + \"; charset=\" +\n               ((encoding.indexOf(' ') != -1) ?\n                 \"\\\"\" + encoding + \"\\\"\" :\n@@ -403,133 +406,87 @@ else if (mode == Stylesheet.OUTPUT_HTML)\n             for (Node ctx = node.getFirstChild(); ctx != null;\n                  ctx = ctx.getNextSibling())\n               {\n-                if (ctx.getNodeType() == Node.ELEMENT_NODE)\n+                if (ctx.getNodeType() == Node.ELEMENT_NODE &&\n+                    isHTMLElement(ctx, \"html\"))\n                   {\n                     html = ctx;\n                     break;\n                   }\n               }\n-            if (html == null)\n-              {\n-                html = doc.createElement(\"html\");\n-                node.appendChild(html);\n-              }\n-            Node head = null;\n-            for (Node ctx = html.getFirstChild(); ctx != null;\n-                 ctx = ctx.getNextSibling())\n+            if (html != null)\n               {\n-                if (ctx.getNodeType() == Node.ELEMENT_NODE)\n-                  {\n-                    String name = ctx.getLocalName();\n-                    if (name == null)\n-                      {\n-                        name = ctx.getNodeName();\n-                      }\n-                    if (\"head\".equalsIgnoreCase(name))\n-                      {\n-                        head = ctx;\n-                        break;\n-                      }\n-                  }\n-              }\n-            if (head == null)\n-              {\n-                head = doc.createElement(\"head\");\n-                Node c1 = null;\n+                Node head = null;\n                 for (Node ctx = html.getFirstChild(); ctx != null;\n                      ctx = ctx.getNextSibling())\n                   {\n-                    if (ctx.getNodeType() == Node.ELEMENT_NODE)\n+                    if (isHTMLElement(ctx, \"head\"))\n                       {\n-                        c1 = ctx;\n+                        head = ctx;\n                         break;\n                       }\n                   }\n-                if (c1 != null)\n-                  {\n-                    html.insertBefore(head, c1);\n-                  }\n-                else\n-                  {\n-                    html.appendChild(head);\n-                  }\n-              }\n-            Node meta = null;\n-            Node metaContent = null;\n-            for (Node ctx = head.getFirstChild(); ctx != null;\n-                 ctx = ctx.getNextSibling())\n-              {\n-                if (ctx.getNodeType() == Node.ELEMENT_NODE)\n+                if (head != null)\n                   {\n-                    String name = ctx.getLocalName();\n-                    if (name == null)\n-                      {\n-                        name = ctx.getNodeName();\n-                      }\n-                    if (\"meta\".equalsIgnoreCase(name))\n+                    Node meta = null;\n+                    Node metaContent = null;\n+                    for (Node ctx = head.getFirstChild(); ctx != null;\n+                         ctx = ctx.getNextSibling())\n                       {\n-                        NamedNodeMap metaAttrs = ctx.getAttributes();\n-                        int len = metaAttrs.getLength();\n-                        String httpEquiv = null;\n-                        Node content = null;\n-                        for (int i = 0; i < len; i++)\n+                        if (isHTMLElement(ctx, \"meta\"))\n                           {\n-                            Node attr = metaAttrs.item(i);\n-                            String attrName = attr.getNodeName();\n-                            if (\"http-equiv\".equalsIgnoreCase(attrName))\n+                            NamedNodeMap metaAttrs = ctx.getAttributes();\n+                            int len = metaAttrs.getLength();\n+                            String httpEquiv = null;\n+                            Node content = null;\n+                            for (int i = 0; i < len; i++)\n                               {\n-                                httpEquiv = attr.getNodeValue();\n+                                Node attr = metaAttrs.item(i);\n+                                String attrName = attr.getNodeName();\n+                                if (\"http-equiv\".equalsIgnoreCase(attrName))\n+                                  httpEquiv = attr.getNodeValue();\n+                                else if (\"content\".equalsIgnoreCase(attrName))\n+                                  content = attr;\n                               }\n-                            else if (\"content\".equalsIgnoreCase(attrName))\n+                            if (\"Content-Type\".equalsIgnoreCase(httpEquiv))\n                               {\n-                                content = attr;\n+                                meta = ctx;\n+                                metaContent = content;\n+                                break;\n                               }\n                           }\n-                        if (\"Content-Type\".equalsIgnoreCase(httpEquiv))\n-                          {\n-                            meta = ctx;\n-                            metaContent = content;\n-                            break;\n-                          }\n                       }\n+                    if (meta == null)\n+                      {\n+                        meta = doc.createElement(\"meta\");\n+                        // Insert first\n+                        Node first = head.getFirstChild();\n+                        if (first == null)\n+                          head.appendChild(meta);\n+                        else\n+                          head.insertBefore(meta, first);\n+                        Node metaHttpEquiv = doc.createAttribute(\"http-equiv\");\n+                        meta.getAttributes().setNamedItem(metaHttpEquiv);\n+                        metaHttpEquiv.setNodeValue(\"Content-Type\");\n+                      }\n+                    if (metaContent == null)\n+                      {\n+                        metaContent = doc.createAttribute(\"content\");\n+                        meta.getAttributes().setNamedItem(metaContent);\n+                      }\n+                    metaContent.setNodeValue(contentType);\n+                    htmlEncoded = true;\n                   }\n               }\n-            if (meta == null)\n-              {\n-                meta = doc.createElement(\"meta\");\n-                // Insert first\n-                Node first = head.getFirstChild();\n-                if (first == null)\n-                  {\n-                    head.appendChild(meta);\n-                  }\n-                else\n-                  {\n-                    head.insertBefore(meta, first);\n-                  }\n-                Node metaHttpEquiv = doc.createAttribute(\"http-equiv\");\n-                meta.getAttributes().setNamedItem(metaHttpEquiv);\n-                metaHttpEquiv.setNodeValue(\"Content-Type\");\n-              }\n-            if (metaContent == null)\n-              {\n-                metaContent = doc.createAttribute(\"content\");\n-                meta.getAttributes().setNamedItem(metaContent);\n-              }\n-            metaContent.setNodeValue(contentType);\n-            // phew\n           }\n         children = node.getFirstChild();\n         if (children != null)\n-          {\n-            serialize(children, out, convertToCdata);\n-          }\n+          serialize(children, out, convertToCdata);\n         break;\n       case Node.DOCUMENT_TYPE_NODE:\n         DocumentType doctype = (DocumentType) node;\n         out.write(BRA);\n         out.write(BANG);\n-\tout.write(encodeText(\"DOCTYPE \"));\n+        out.write(encodeText(\"DOCTYPE \"));\n         value = doctype.getNodeName();\n         out.write(encodeText(value));\n         String publicId = doctype.getPublicId();\n@@ -569,60 +526,102 @@ else if (\"content\".equalsIgnoreCase(attrName))\n             out.write(encodeText(eol));\n           }\n         break;\n+      default:\n+        System.err.println(\"Unhandled node type: \"+nt);\n       }\n-    if (defined)\n+  }\n+\n+  boolean isHTMLElement(Node node, String name)\n+  {\n+    if (node.getNodeType() != Node.ELEMENT_NODE)\n+      return false;\n+    String localName = node.getLocalName();\n+    if (localName == null)\n+      localName = node.getNodeName();\n+    if (!name.equalsIgnoreCase(localName))\n+      return false;\n+    String uri = node.getNamespaceURI();\n+    return (uri == null || HTML_URIS.contains(uri));\n+  }\n+\n+  boolean isDefined(String uri, String prefix)\n+  {\n+    if (XMLConstants.XML_NS_URI.equals(uri))\n+      return \"xml\".equals(prefix);\n+    if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri))\n+      return \"xmlns\".equals(prefix);\n+    if (prefix == null)\n+      prefix = \"\";\n+    for (Iterator i = namespaces.iterator(); i.hasNext(); )\n       {\n-        undefine(uri);\n+        Map ctx = (Map) i.next();\n+        String val = (String) ctx.get(uri);\n+        if (val != null && val.equals(prefix))\n+          return true;\n       }\n+    return false;\n   }\n \n-  boolean isDefined(String uri)\n+  void pushNamespaceContext()\n   {\n-    return XMLConstants.XML_NS_URI.equals(uri) ||\n-      XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri) ||\n-      namespaces.containsKey(uri);\n+    namespaces.addFirst(new HashMap());\n   }\n \n   String define(String uri, String prefix)\n   {\n-    while (namespaces.containsValue(prefix))\n+    if (namespaces.isEmpty())\n+      return prefix;\n+    HashMap ctx = (HashMap) namespaces.getFirst();\n+    while (ctx.containsValue(prefix))\n       {\n         // Fabricate new prefix\n         prefix = prefix + \"_\";\n       }\n-    namespaces.put(uri, prefix);\n+    ctx.put(uri, prefix);\n     return prefix;\n   }\n \n-  void undefine(String uri)\n+  void popNamespaceContext()\n   {\n-    namespaces.remove(uri);\n+    namespaces.removeFirst();\n   }\n \n   final byte[] encodeText(String text)\n     throws IOException\n   {\n     encoder.reset();\n-    if (!encoder.canEncode(text))\n+    boolean htmlNeedingEncoding =\n+      (mode == Stylesheet.OUTPUT_HTML && !htmlEncoded);\n+    if (!encoder.canEncode(text) || htmlNeedingEncoding)\n       {\n         // Check each character\n         StringBuffer buf = new StringBuffer();\n         int len = text.length();\n         for (int i = 0; i < len; i++)\n           {\n             char c = text.charAt(i);\n-            if (encoder.canEncode(c))\n-              {\n-                buf.append(c);\n-              }\n-            else\n+            if (!encoder.canEncode(c))\n               {\n                 // Replace with character entity reference\n                 String hex = Integer.toHexString((int) c);\n                 buf.append(\"&#x\");\n                 buf.append(hex);\n                 buf.append(';');\n               }\n+            else if (htmlNeedingEncoding)\n+              {\n+                String entityName = getHTMLCharacterEntity(c);\n+                if (entityName != null)\n+                  {\n+                    buf.append('&');\n+                    buf.append(entityName);\n+                    buf.append(';');\n+                  }\n+                else\n+                  buf.append(c);\n+              }\n+            else\n+              buf.append(c);\n           }\n         text = buf.toString();\n       }\n@@ -656,17 +655,13 @@ String encode(String text, boolean encodeCtl, boolean inAttr)\n         if (c == '<')\n           {\n             if (buf == null)\n-              {\n-                buf = new StringBuffer(text.substring(0, i));\n-              }\n+              buf = new StringBuffer(text.substring(0, i));\n             buf.append(\"&lt;\");\n           }\n         else if (c == '>')\n           {\n             if (buf == null)\n-              {\n-                buf = new StringBuffer(text.substring(0, i));\n-              }\n+              buf = new StringBuffer(text.substring(0, i));\n             buf.append(\"&gt;\");\n           }\n         else if (c == '&')\n@@ -675,25 +670,19 @@ else if (c == '&')\n                 text.charAt(i + 1) == '{')\n               {\n                 if (buf != null)\n-                  {\n-                    buf.append(c);\n-                  }\n+                  buf.append(c);\n               }\n             else\n               {\n                 if (buf == null)\n-                  {\n-                    buf = new StringBuffer(text.substring(0, i));\n-                  }\n+                  buf = new StringBuffer(text.substring(0, i));\n                 buf.append(\"&amp;\");\n               }\n           }\n         else if (c == '\\'' && inAttr)\n           {\n             if (buf == null)\n-              {\n-                buf = new StringBuffer(text.substring(0, i));\n-              }\n+              buf = new StringBuffer(text.substring(0, i));\n             if (mode == Stylesheet.OUTPUT_HTML)\n               // HTML does not define &apos;, use character entity ref\n               buf.append(\"&#x27;\");\n@@ -703,33 +692,25 @@ else if (c == '\\'' && inAttr)\n         else if (c == '\"' && inAttr)\n           {\n             if (buf == null)\n-              {\n-                buf = new StringBuffer(text.substring(0, i));\n-              }\n+              buf = new StringBuffer(text.substring(0, i));\n             buf.append(\"&quot;\");\n           }\n         else if (encodeCtl)\n           {\n             if (c < 0x20)\n               {\n                 if (buf == null)\n-                  {\n-                    buf = new StringBuffer(text.substring(0, i));\n-                  }\n+                  buf = new StringBuffer(text.substring(0, i));\n                 buf.append('&');\n                 buf.append('#');\n                 buf.append((int) c);\n                 buf.append(';');\n               }\n             else if (buf != null)\n-              {\n-                buf.append(c);\n-              }\n+              buf.append(c);\n           }\n         else if (buf != null)\n-          {\n-            buf.append(c);\n-          }\n+          buf.append(c);\n       }\n     return (buf == null) ? text : buf.toString();\n   }\n@@ -763,4 +744,109 @@ boolean isHTMLBoolean(Attr attr, String attrName)\n     return (attributes != null && attributes.contains(attrName));\n   }\n \n+  static String getHTMLCharacterEntity(char c)\n+  {\n+    // Hardcode these here to avoid loading the HTML DTD\n+    switch (c)\n+      {\n+      case 160: return \"nbsp\";\n+      case 161: return \"iexcl\";\n+      case 162: return \"cent\";\n+      case 163: return \"pound\";\n+      case 164: return \"curren\";\n+      case 165: return \"yen\";\n+      case 166: return \"brvbar\";\n+      case 167: return \"sect\";\n+      case 168: return \"uml\";\n+      case 169: return \"copy\";\n+      case 170: return \"ordf\";\n+      case 171: return \"laquo\";\n+      case 172: return \"not\";\n+      case 173: return \"shy\";\n+      case 174: return \"reg\";\n+      case 175: return \"macr\";\n+      case 176: return \"deg\";\n+      case 177: return \"plusmn\";\n+      case 178: return \"sup2\";\n+      case 179: return \"sup3\";\n+      case 180: return \"acute\";\n+      case 181: return \"micro\";\n+      case 182: return \"para\";\n+      case 183: return \"middot\";\n+      case 184: return \"cedil\";\n+      case 185: return \"sup1\";\n+      case 186: return \"ordm\";\n+      case 187: return \"raquo\";\n+      case 188: return \"frac14\";\n+      case 189: return \"frac12\";\n+      case 190: return \"frac34\";\n+      case 191: return \"iquest\";\n+      case 192: return \"Agrave\";\n+      case 193: return \"Aacute\";\n+      case 194: return \"Acirc\";\n+      case 195: return \"Atilde\";\n+      case 196: return \"Auml\";\n+      case 197: return \"Aring\";\n+      case 198: return \"AElig\";\n+      case 199: return \"Ccedil\";\n+      case 200: return \"Egrave\";\n+      case 201: return \"Eacute\";\n+      case 202: return \"Ecirc\";\n+      case 203: return \"Euml\";\n+      case 204: return \"Igrave\";\n+      case 205: return \"Iacute\";\n+      case 206: return \"Icirc\";\n+      case 207: return \"Iuml\";\n+      case 208: return \"ETH\";\n+      case 209: return \"Ntilde\";\n+      case 210: return \"Ograve\";\n+      case 211: return \"Oacute\";\n+      case 212: return \"Ocirc\";\n+      case 213: return \"Otilde\";\n+      case 214: return \"Ouml\";\n+      case 215: return \"times\";\n+      case 216: return \"Oslash\";\n+      case 217: return \"Ugrave\";\n+      case 218: return \"Uacute\";\n+      case 219: return \"Ucirc\";\n+      case 220: return \"Uuml\";\n+      case 221: return \"Yacute\";\n+      case 222: return \"THORN\";\n+      case 223: return \"szlig\";\n+      case 224: return \"agrave\";\n+      case 225: return \"aacute\";\n+      case 226: return \"acirc\";\n+      case 227: return \"atilde\";\n+      case 228: return \"auml\";\n+      case 229: return \"aring\";\n+      case 230: return \"aelig\";\n+      case 231: return \"ccedil\";\n+      case 232: return \"egrave\";\n+      case 233: return \"eacute\";\n+      case 234: return \"ecirc\";\n+      case 235: return \"euml\";\n+      case 236: return \"igrave\";\n+      case 237: return \"iacute\";\n+      case 238: return \"icirc\";\n+      case 239: return \"iuml\";\n+      case 240: return \"eth\";\n+      case 241: return \"ntilde\";\n+      case 242: return \"ograve\";\n+      case 243: return \"oacute\";\n+      case 244: return \"ocirc\";\n+      case 245: return \"otilde\";\n+      case 246: return \"ouml\";\n+      case 247: return \"divide\";\n+      case 248: return \"oslash\";\n+      case 249: return \"ugrave\";\n+      case 250: return \"uacute\";\n+      case 251: return \"ucirc\";\n+      case 252: return \"uuml\";\n+      case 253: return \"yacute\";\n+      case 254: return \"thorn\";\n+      case 255: return \"yuml\";\n+      default: return null;\n+      }\n+  }\n+\n }"}, {"sha": "c6391b9c52164231a4dc1c4832c5d9caa5e9e7e3", "filename": "libjava/classpath/gnu/xml/transform/StrippingInstruction.java", "status": "renamed", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStrippingInstruction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStrippingInstruction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStrippingInstruction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n-/* ContentHandler2.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+/* StrippingInstruction.java -- \n+   Copyright (C) 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,31 +35,39 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-package gnu.xml.aelfred2;\n+package gnu.xml.transform;\n \n-import org.xml.sax.ContentHandler;\n-import org.xml.sax.SAXException;\n+import gnu.xml.xpath.NameTest;\n \n /**\n- * Extension to the SAX ContentHandler interface to report parsing events\n- * and parameters required by DOM Level 3 but not supported by SAX.\n+ * An entry in a strip-space or preserve-space list.\n  *\n  * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n  */\n-public interface ContentHandler2\n-  extends ContentHandler\n+class StrippingInstruction\n {\n \n+  final NameTest element;\n+  final int precedence;\n+  \n+  StrippingInstruction(NameTest element, int precedence)\n+  {\n+    this.element = element;\n+    this.precedence = precedence;\n+  }\n+\n   /**\n-   * Reports the XML declaration.\n-   * @param version the value of the version attribute in the XML\n-   * declaration\n-   * @param encoding the encoding specified in the XML declaration, if any\n-   * @param standalone the standalone attribute from the XML declaration\n-   * @param inputEncoding the encoding of the XML input\n+   * Returns the <i>default priority</i> of the element name test.\n+   * @see http://www.w3.org/TR/xslt#dt-default-priority\n    */\n-  void xmlDecl(String version, String encoding, boolean standalone,\n-               String inputEncoding)\n-    throws SAXException;\n+  float getPriority()\n+  {\n+    if (element.matchesAny())\n+      return -0.5f;\n+    else if (element.matchesAnyLocalName())\n+      return -0.25f;\n+    else\n+      return 0.0f;\n+  }\n   \n }", "previous_filename": "libjava/classpath/gnu/xml/aelfred2/ContentHandler2.java"}, {"sha": "51accaa3b9ab5a587026cf14d62eb7e9484ceb93", "filename": "libjava/classpath/gnu/xml/transform/Stylesheet.java", "status": "modified", "additions": 150, "deletions": 225, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStylesheet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStylesheet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FStylesheet.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* Stylesheet.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -88,6 +88,8 @@\n {\n \n   static final String XSL_NS = \"http://www.w3.org/1999/XSL/Transform\";\n+  private static final NameTest STYLESHEET_PRESERVE_TEXT =\n+    new NameTest(new QName(XSL_NS, \"text\"), false, false);\n   \n   static final int OUTPUT_XML = 0;\n   static final int OUTPUT_HTML = 1;\n@@ -208,6 +210,7 @@\n     preserveSpace = new LinkedHashSet();\n     outputCdataSectionElements = new LinkedHashSet();\n     xpath = (XPathImpl) factory.xpathFactory.newXPath();\n+    xpath.setNamespaceContext(this);\n     if (parent == null)\n       {\n         bindings = new Bindings(this);\n@@ -218,7 +221,6 @@\n         keys = new LinkedList();\n         decimalFormats = new LinkedHashMap();\n         initDefaultDecimalFormat();\n-        xpath.setNamespaceContext(this);\n         xpath.setXPathFunctionResolver(this);\n       }\n     else\n@@ -241,7 +243,6 @@\n         templates = root.templates;\n         keys = root.keys;\n         decimalFormats = root.decimalFormats;\n-        xpath.setNamespaceContext(root);\n         xpath.setXPathFunctionResolver(root);\n       }\n     xpath.setXPathVariableResolver(bindings);\n@@ -276,9 +277,7 @@ Stylesheet getRootStylesheet()\n   {\n     Stylesheet stylesheet = this;\n     while (stylesheet.parent != null)\n-      {\n-        stylesheet = stylesheet.parent;\n-      }\n+      stylesheet = stylesheet.parent;\n     return stylesheet;\n   }\n   \n@@ -408,9 +407,7 @@ TemplateNode getTemplate(QName mode, Node context, boolean applyImports)\n     throws TransformerException\n   {\n     if (debug)\n-      {\n-        System.err.println(\"getTemplate: mode=\"+mode+\" context=\"+context);\n-      }\n+      System.err.println(\"getTemplate: mode=\"+mode+\" context=\"+context);\n     Set candidates = new TreeSet();\n     for (Iterator j = templates.iterator(); j.hasNext(); )\n       {\n@@ -425,25 +422,19 @@ TemplateNode getTemplate(QName mode, Node context, boolean applyImports)\n                 throw new TransformerException(msg);\n               }\n             if (!currentTemplate.imports(t))\n-              {\n-                isMatch = false;\n-              }\n+              isMatch = false;\n           }\n         //System.err.println(\"\\t\"+context+\" \"+t+\"=\"+isMatch);\n         if (isMatch)\n-          {\n-            candidates.add(t);\n-          }\n+          candidates.add(t);\n       }\n     //System.err.println(\"\\tcandidates=\"+candidates);\n     if (candidates.isEmpty())\n       {\n         // Apply built-in template\n         // Current template is unchanged\n         if (debug)\n-          {\n-            System.err.println(\"\\tbuiltInTemplate context=\"+context);\n-          }\n+          System.err.println(\"\\tbuiltInTemplate context=\"+context);\n         switch (context.getNodeType())\n           {\n           case Node.ELEMENT_NODE:\n@@ -453,6 +444,7 @@ TemplateNode getTemplate(QName mode, Node context, boolean applyImports)\n           case Node.COMMENT_NODE:\n             return builtInNodeTemplate;\n           case Node.TEXT_NODE:\n+          case Node.CDATA_SECTION_NODE:\n           case Node.ATTRIBUTE_NODE:\n             return builtInTextTemplate;\n           default:\n@@ -465,35 +457,25 @@ TemplateNode getTemplate(QName mode, Node context, boolean applyImports)\n         // Set current template\n         currentTemplate = t;\n         if (debug)\n-          {\n-            System.err.println(\"\\ttemplate=\"+t+\" context=\"+context);\n-          }\n+          System.err.println(\"\\ttemplate=\"+t+\" context=\"+context);\n         return t.node;\n       }\n   }\n \n   TemplateNode getTemplate(QName mode, QName name)\n     throws TransformerException\n   {\n-    //System.err.println(\"getTemplate: mode=\"+mode+\" name=\"+name);\n     Set candidates = new TreeSet();\n     for (Iterator j = templates.iterator(); j.hasNext(); )\n       {\n         Template t = (Template) j.next();\n         boolean isMatch = t.matches(name);\n-        //System.err.println(\"\\t\"+name+\" \"+t+\"=\"+isMatch);\n         if (isMatch)\n-          {\n-            candidates.add(t);\n-          }\n+          candidates.add(t);\n       }\n     if (candidates.isEmpty())\n-      {\n-        return null;\n-        //throw new TransformerException(\"template '\" + name + \"' not found\");\n-      }\n+      return null;\n     Template t = (Template) candidates.iterator().next();\n-    //System.err.println(\"\\ttemplate=\"+t+\" context=\"+context);\n     return t.node;\n   }\n \n@@ -538,52 +520,38 @@ final void parseOutput(Node node, NamedNodeMap attrs)\n     output = node;\n     String method = getAttribute(attrs, \"method\");\n     if (\"xml\".equals(method) || method == null)\n-      {\n-        outputMethod = OUTPUT_XML;\n-      }\n+      outputMethod = OUTPUT_XML;\n     else if (\"html\".equals(method))\n-      {\n-        outputMethod = OUTPUT_HTML;\n-      }\n+      outputMethod = OUTPUT_HTML;\n     else if (\"text\".equals(method))\n-      {\n-        outputMethod = OUTPUT_TEXT;\n-      }\n+      outputMethod = OUTPUT_TEXT;\n     else\n       {\n         String msg = \"unsupported output method: \" + method;\n         DOMSourceLocator l = new DOMSourceLocator(node);\n         throw new TransformerConfigurationException(msg, l);\n       }\n-    outputPublicId = getAttribute(attrs, \"public-id\");\n-    outputSystemId = getAttribute(attrs, \"system-id\");\n+    outputPublicId = getAttribute(attrs, \"doctype-public\");\n+    outputSystemId = getAttribute(attrs, \"doctype-system\");\n     outputEncoding = getAttribute(attrs, \"encoding\");\n     String indent = getAttribute(attrs, \"indent\");\n     if (indent != null)\n-      {\n-        outputIndent = \"yes\".equals(indent);\n-      }\n+      outputIndent = \"yes\".equals(indent);\n     outputVersion = getAttribute(attrs, \"version\");\n     String omitXmlDecl = getAttribute(attrs, \"omit-xml-declaration\");\n     if (omitXmlDecl != null)\n-      {\n-        outputOmitXmlDeclaration = \"yes\".equals(omitXmlDecl);\n-      }\n+      outputOmitXmlDeclaration = \"yes\".equals(omitXmlDecl);\n     String standalone = getAttribute(attrs, \"standalone\");\n     if (standalone != null)\n-      {\n-        outputStandalone = \"yes\".equals(standalone);\n-      }\n+      outputStandalone = \"yes\".equals(standalone);\n     outputMediaType = getAttribute(attrs, \"media-type\");\n     String cdataSectionElements =\n       getAttribute(attrs, \"cdata-section-elements\");\n     if (cdataSectionElements != null)\n       {\n         StringTokenizer st = new StringTokenizer(cdataSectionElements, \" \");\n         while (st.hasMoreTokens())\n-          {\n-            outputCdataSectionElements.add(st.nextToken());\n-          }\n+          outputCdataSectionElements.add(st.nextToken());\n       }\n   }\n \n@@ -728,9 +696,7 @@ void doParse(Node node, boolean root)\n                 parse(node.getFirstChild(), false);\n               }\n             else if (\"template\".equals(name))\n-              {\n-                templates.add(parseTemplate(node, attrs));\n-              }\n+              templates.add(parseTemplate(node, attrs));\n             else if (\"param\".equals(name) ||\n                      \"variable\".equals(name))\n               {\n@@ -779,9 +745,7 @@ else if (\"include\".equals(name) || \"import\".equals(name))\n                 factory.newStylesheet(source, precedence + delta, this);\n               }\n             else if (\"output\".equals(name))\n-              {\n-                parseOutput(node, attrs);\n-              }\n+              parseOutput(node, attrs);\n             else if (\"preserve-space\".equals(name))\n               {\n                 String elements =\n@@ -790,7 +754,9 @@ else if (\"preserve-space\".equals(name))\n                                                          \" \\t\\n\\r\");\n                 while (st.hasMoreTokens())\n                   {\n-                    preserveSpace.add(parseNameTest(st.nextToken()));\n+                    NameTest element = parseNameTest(st.nextToken());\n+                    preserveSpace.add(new StrippingInstruction(element,\n+                                                               precedence));\n                   }\n               }\n             else if (\"strip-space\".equals(name))\n@@ -801,25 +767,19 @@ else if (\"strip-space\".equals(name))\n                                                          \" \\t\\n\\r\");\n                 while (st.hasMoreTokens())\n                   {\n-                    stripSpace.add(parseNameTest(st.nextToken()));\n+                    NameTest element = parseNameTest(st.nextToken());\n+                    stripSpace.add(new StrippingInstruction(element, \n+                                                            precedence));\n                   }\n               }\n             else if (\"key\".equals(name))\n-              {\n-                parseKey(node, attrs);\n-              }\n+              parseKey(node, attrs);\n             else if (\"decimal-format\".equals(name))\n-              {\n-                parseDecimalFormat(node, attrs);\n-              }\n+              parseDecimalFormat(node, attrs);\n             else if (\"namespace-alias\".equals(name))\n-              {\n-                parseNamespaceAlias(node, attrs);\n-              }\n+              parseNamespaceAlias(node, attrs);\n             else if (\"attribute-set\".equals(name))\n-              {\n-                parseAttributeSet(node, attrs);\n-              }\n+              parseAttributeSet(node, attrs);\n           }\n         else if (root)\n           {\n@@ -867,12 +827,10 @@ else if (root)\n   final NameTest parseNameTest(String token)\n   {\n     if (\"*\".equals(token))\n-      {\n-        return new NameTest(null, true, true);\n-      }\n+      return new NameTest(null, true, true);\n     else if (token.endsWith(\":*\"))\n       {\n-        QName qName = getQName(token.substring(0, token.length() - 2));\n+        QName qName = getQName(token);\n         return new NameTest(qName, true, false);\n       }\n     else\n@@ -984,7 +942,13 @@ else if (c == '}')\n     return ret;\n   }\n \n-  boolean isPreserved(Text text)\n+  /**\n+   * Whitespace stripping.\n+   * @param text the text node\n+   * @param source true if a source node, false if a stylesheet text node\n+   * @see http://www.w3.org/TR/xslt#strip\n+   */\n+  boolean isPreserved(Text text, boolean source)\n     throws TransformerConfigurationException\n   {\n     // Check characters in text\n@@ -996,39 +960,73 @@ boolean isPreserved(Text text)\n           {\n             char c = value.charAt(i);\n             if (c != 0x20 && c != 0x09 && c != 0x0a && c != 0x0d)\n-              {\n-                return true;\n-              }\n+              return true;\n           }\n       }\n     // Check parent node\n     Node ctx = text.getParentNode();\n-    if (!preserveSpace.isEmpty())\n+    if (source)\n       {\n-        for (Iterator i = preserveSpace.iterator(); i.hasNext(); )\n+        // Source document text node\n+        boolean preserve = true;\n+        float psPriority = 0.0f, ssPriority = 0.0f;\n+        if (!stripSpace.isEmpty())\n           {\n-            NameTest preserveTest = (NameTest) i.next();\n-            if (preserveTest.matches(ctx, 1, 1))\n+            // Conflict resolution\n+            StrippingInstruction ssi = null, psi = null;\n+            for (Iterator i = stripSpace.iterator(); i.hasNext(); )\n+              {\n+                StrippingInstruction si = (StrippingInstruction) i.next();\n+                if (si.element.matches(ctx, 1, 1))\n+                  {\n+                    if (ssi != null)\n+                      {\n+                        if (si.precedence < ssi.precedence)\n+                          continue;\n+                        float p = si.getPriority();\n+                        if (p < ssPriority)\n+                          continue;\n+                      }\n+                    ssi = si;\n+                  }\n+              }\n+            for (Iterator i = preserveSpace.iterator(); i.hasNext(); )\n               {\n-                boolean override = false;\n-                if (!stripSpace.isEmpty())\n+                StrippingInstruction si = (StrippingInstruction) i.next();\n+                if (si.element.matches(ctx, 1, 1))\n                   {\n-                    for (Iterator j = stripSpace.iterator(); j.hasNext(); )\n+                    if (psi != null)\n                       {\n-                        NameTest stripTest = (NameTest) j.next();\n-                        if (stripTest.matches(ctx, 1, 1))\n-                          {\n-                            override = true;\n-                            break;\n-                          }\n+                        if (si.precedence < psi.precedence)\n+                          continue;\n+                        float p = si.getPriority();\n+                        if (p < psPriority)\n+                          continue;\n                       }\n+                    psi = si;\n                   }\n-                if (!override)\n+              }\n+            if (ssi != null)\n+              {\n+                if (psi != null)\n                   {\n-                    return true;\n+                    if (psi.precedence < ssi.precedence)\n+                      preserve = false;\n+                    else if (psPriority < ssPriority)\n+                      preserve = false;\n                   }\n+                else\n+                  preserve = false;\n               }\n           }\n+        if (preserve)\n+          return true;\n+      }\n+    else\n+      {\n+        // Stylesheet text node\n+        if (STYLESHEET_PRESERVE_TEXT.matches(ctx, 1, 1))\n+          return true;\n       }\n     // Check whether any ancestor specified xml:space\n     while (ctx != null)\n@@ -1038,24 +1036,14 @@ boolean isPreserved(Text text)\n             Element element = (Element) ctx;\n             String xmlSpace = element.getAttribute(\"xml:space\");\n             if (\"default\".equals(xmlSpace))\n-              {\n-                break;\n-              }\n+              break;\n             else if (\"preserve\".equals(xmlSpace))\n-              {\n-                return true;\n-              }\n+              return true;\n             else if (xmlSpace.length() > 0)\n               {\n                 String msg = \"Illegal value for xml:space: \" + xmlSpace;\n                 throw new TransformerConfigurationException(msg);\n               }\n-            else if (\"text\".equals(ctx.getLocalName()) &&\n-                     XSL_NS.equals(ctx.getNamespaceURI()))\n-              {\n-                // xsl:text implies xml:space='preserve'\n-                return true;\n-              }\n           }\n         ctx = ctx.getParentNode();\n       }\n@@ -1071,45 +1059,27 @@ public XPathFunction resolveFunction(QName name, int arity)\n         if (\"document\".equals(localName) && (arity == 1 || arity == 2))\n           {\n             if (current == null)\n-              {\n                 throw new RuntimeException(\"current is null\");\n-              }\n             return new DocumentFunction(getRootStylesheet(), current);\n           }\n         else if (\"key\".equals(localName) && (arity == 2))\n-          {\n-            return new KeyFunction(getRootStylesheet());\n-          }\n+          return new KeyFunction(getRootStylesheet());\n         else if (\"format-number\".equals(localName) &&\n                  (arity == 2 || arity == 3))\n-          {\n-            return new FormatNumberFunction(getRootStylesheet());\n-          }\n+          return new FormatNumberFunction(getRootStylesheet());\n         else if (\"current\".equals(localName) && (arity == 0))\n-          {\n-            return new CurrentFunction(getRootStylesheet());\n-          }\n+          return new CurrentFunction(getRootStylesheet());\n         else if (\"unparsed-entity-uri\".equals(localName) && (arity == 1))\n-          {\n-            return new UnparsedEntityUriFunction();\n-          }\n+          return new UnparsedEntityUriFunction();\n         else if (\"generate-id\".equals(localName) &&\n                  (arity == 1 || arity == 0))\n-          {\n-            return new GenerateIdFunction();\n-          }\n+          return new GenerateIdFunction();\n         else if (\"system-property\".equals(localName) && (arity == 1))\n-          {\n-            return new SystemPropertyFunction();\n-          }\n+          return new SystemPropertyFunction();\n         else if (\"element-available\".equals(localName) && (arity == 1))\n-          {\n-            return new ElementAvailableFunction(this);\n-          }\n+          return new ElementAvailableFunction(new NamespaceProxy(current));\n         else if (\"function-available\".equals(localName) && (arity == 1))\n-          {\n-            return new FunctionAvailableFunction(this);\n-          }\n+          return new FunctionAvailableFunction(new NamespaceProxy(current));\n       }\n     return null;\n   }\n@@ -1127,9 +1097,7 @@ final TemplateNode parseApplyTemplates(Node node)\n     QName mode = (m == null) ? null : getQName(m);\n     String s = getAttribute(attrs, \"select\");\n     if (s == null)\n-      {\n-        s = \"child::node()\";\n-      }\n+      s = \"child::node()\";\n     Node children = node.getFirstChild();\n     List sortKeys = parseSortKeys(children);\n     List withParams = parseWithParams(children);\n@@ -1411,13 +1379,9 @@ final TemplateNode parse(Node node)\n         if (tnode != null)\n           {\n             if (first == null)\n-              {\n-                first = tnode;\n-              }\n+              first = tnode;\n             if (previous != null)\n-              {\n-                previous.next = tnode;\n-              }\n+              previous.next = tnode;\n             previous = tnode;\n           }\n         node = next;\n@@ -1438,25 +1402,15 @@ private final TemplateNode doParse(Node node)\n           {\n             String name = node.getLocalName();\n             if (\"apply-templates\".equals(name))\n-              {\n-                return parseApplyTemplates(node);\n-              }\n+              return parseApplyTemplates(node);\n             else if (\"call-template\".equals(name))\n-              {\n-                return parseCallTemplate(node);\n-              }\n+              return parseCallTemplate(node);\n             else if (\"value-of\".equals(name))\n-              {\n-                return parseValueOf(node);\n-              }\n+              return parseValueOf(node);\n             else if (\"for-each\".equals(name))\n-              {\n-                return parseForEach(node);\n-              }\n+              return parseForEach(node);\n             else if (\"if\".equals(name))\n-              {\n-                return parseIf(node);\n-              }\n+              return parseIf(node);\n             else if (\"choose\".equals(name))\n               {\n                 Node children = node.getFirstChild();\n@@ -1465,9 +1419,7 @@ else if (\"choose\".equals(name))\n                 return ret;\n               }\n             else if (\"when\".equals(name))\n-              {\n-                return parseWhen(node);\n-              }\n+              return parseWhen(node);\n             else if (\"otherwise\".equals(name))\n               {\n                 Node children = node.getFirstChild();\n@@ -1476,25 +1428,15 @@ else if (\"otherwise\".equals(name))\n                 return ret;\n               }\n             else if (\"element\".equals(name))\n-              {\n-                return parseElement(node);\n-              }\n+              return parseElement(node);\n             else if (\"attribute\".equals(name))\n-              {\n-                return parseAttribute(node);\n-              }\n+              return parseAttribute(node);\n             else if (\"text\".equals(name))\n-              {\n-                return parseText(node);\n-              }\n+              return parseText(node);\n             else if (\"copy\".equals(name))\n-              {\n-                return parseCopy(node);\n-              }\n+              return parseCopy(node);\n             else if (\"processing-instruction\".equals(name))\n-              {\n-                return parseProcessingInstruction(node);\n-              }\n+              return parseProcessingInstruction(node);\n             else if (\"comment\".equals(name))\n               {\n                 Node children = node.getFirstChild();\n@@ -1503,9 +1445,7 @@ else if (\"comment\".equals(name))\n                 return ret;\n               }\n             else if (\"number\".equals(name))\n-              {\n-                return parseNumber(node);\n-              }\n+              return parseNumber(node);\n             else if (\"param\".equals(name) ||\n                      \"variable\".equals(name))\n               {\n@@ -1538,13 +1478,9 @@ else if (\"param\".equals(name) ||\n                 return ret;\n               }\n             else if (\"copy-of\".equals(name))\n-              {\n-                return parseCopyOf(node);\n-              }\n+              return parseCopyOf(node);\n             else if (\"message\".equals(name))\n-              {\n-                return parseMessage(node);\n-              }\n+              return parseMessage(node);\n             else if (\"apply-imports\".equals(name))\n               {\n                 Node children = node.getFirstChild();\n@@ -1562,22 +1498,30 @@ else if (\"apply-imports\".equals(name))\n         String prefix = node.getPrefix();\n         if (extensionElementPrefixes.contains(prefix))\n           {\n-            // Pass over extension elements\n+            // Check for xsl:fallback\n+            for (Node ctx = node.getFirstChild(); ctx != null;\n+                 ctx = ctx.getNextSibling())\n+              {\n+                String ctxUri = ctx.getNamespaceURI();\n+                if (XSL_NS.equals(ctxUri) &&\n+                    \"fallback\".equals(ctx.getLocalName()))\n+                  {\n+                    ctx = ctx.getFirstChild();\n+                    return (ctx == null) ? null : parse(ctx);\n+                  }\n+              }\n+            // Otherwise pass over extension element\n             return null;\n           }\n         switch (node.getNodeType())\n           {\n           case Node.TEXT_NODE:\n+          case Node.CDATA_SECTION_NODE:\n             // Determine whether to strip whitespace\n             Text text = (Text) node;\n-            if (!isPreserved(text))\n+            if (!isPreserved(text, false))\n               {\n                 // Strip\n-                /*String data = text.getData().trim();\n-                if (data.length() > 0)\n-                  {\n-                    text.setData(data);\n-                  } // else */\n                 text.getParentNode().removeChild(text);\n                 return null;\n               }\n@@ -1623,9 +1567,7 @@ else if (\"apply-imports\".equals(name))\n                     String aname = attr.getNodeName();\n                     if (Stylesheet.XSL_NS.equals(ans) &&\n                         \"use-attribute-sets\".equals(attr.getLocalName()))\n-                      {\n-                        continue;\n-                      }\n+                      continue;\n                     String value = attr.getNodeValue();\n                     TemplateNode grandchild =\n                       parseAttributeValueTemplate(value, node);\n@@ -1640,8 +1582,9 @@ else if (\"apply-imports\".equals(name))\n                   }\n                 String ename = node.getNodeName();\n                 TemplateNode n = parseAttributeValueTemplate(ename, node);\n-                TemplateNode ns = (namespaceUri == null) ? null :\n-                  parseAttributeValueTemplate(namespaceUri, node);\n+                //TemplateNode ns = (namespaceUri == null) ? null :\n+                //  parseAttributeValueTemplate(namespaceUri, node);\n+                TemplateNode ns = null;\n                 ElementNode ret = new ElementNode(n, ns, useAttributeSets,\n                                                   node);\n                 ret.children = child;\n@@ -1676,9 +1619,7 @@ final List parseSortKeys(Node node)\n             NamedNodeMap attrs = node.getAttributes();\n             String s = getAttribute(attrs, \"select\");\n             if (s == null)\n-              {\n-                s = \".\";\n-              }\n+              s = \".\";\n             Expr select = (Expr) xpath.compile(s);\n             String l = getAttribute(attrs, \"lang\");\n             TemplateNode lang = (l == null) ? null :\n@@ -1728,9 +1669,7 @@ final List parseWithParams(Node node)\n                 ret.add(new WithParam(name, expr));\n               }\n             else\n-              {\n-                ret.add(new WithParam(name, content));\n-              }\n+              ret.add(new WithParam(name, content));\n           }\n         node = node.getNextSibling();\n       }\n@@ -1757,27 +1696,19 @@ final void addNamespaceNodes(Node source, Node target, Document doc,\n               {\n                 String prefix = attr.getLocalName();\n                 if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix))\n-                  {\n-                    prefix = \"#default\";\n-                  }\n+                  prefix = \"#default\";\n                 String ns = attr.getNodeValue();\n                 // Should the namespace be excluded?\n                 if (XSL_NS.equals(ns) ||\n                     extensionElementPrefixes.contains(prefix) ||\n                     elementExcludeResultPrefixes.contains(prefix) ||\n                     excludeResultPrefixes.contains(prefix))\n-                  {\n-                    continue;\n-                  }\n+                  continue;\n                 // Is the namespace already defined on the target?\n                 if (prefix == \"#default\")\n-                  {\n-                    prefix = null;\n-                  }\n+                  prefix = null;\n                 if (target.lookupNamespaceURI(prefix) != null)\n-                  {\n-                    continue;\n-                  }\n+                  continue;\n                 attr = attr.cloneNode(true);\n                 attr = doc.adoptNode(attr);\n                 target.getAttributes().setNamedItemNS(attr);\n@@ -1786,23 +1717,17 @@ final void addNamespaceNodes(Node source, Node target, Document doc,\n       }\n     Node parent = source.getParentNode();\n     if (parent != null)\n-      {\n-        addNamespaceNodes(parent, target, doc, elementExcludeResultPrefixes);\n-      }\n+      addNamespaceNodes(parent, target, doc, elementExcludeResultPrefixes);\n   }\n \n   static final String getAttribute(NamedNodeMap attrs, String name)\n   {\n     Node attr = attrs.getNamedItem(name);\n     if (attr == null)\n-      {\n-        return null;\n-      }\n+      return null;\n     String ret = attr.getNodeValue();\n     if (ret.length() == 0)\n-      {\n-        return null;\n-      }\n+      return null;\n     return ret;\n   }\n "}, {"sha": "16e3363f8c67779ca45ac82baf644a82c5132301", "filename": "libjava/classpath/gnu/xml/transform/TransformerFactoryImpl.java", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerFactoryImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerFactoryImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerFactoryImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* TransformerFactoryImpl.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,7 +37,11 @@\n \n package gnu.xml.transform;\n \n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.net.URL;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n@@ -73,7 +77,7 @@\n {\n \n   final XPathFactory xpathFactory;\n-\tfinal XSLURIResolver resolver;\n+  final XSLURIResolver resolver;\n   ErrorListener userListener;\n   URIResolver userResolver;\n \n@@ -341,5 +345,46 @@ public ErrorListener getErrorListener()\n   {\n     return userListener;\n   }\n+\n+  /**\n+   * Syntax: TransformerFactoryImpl [<stylesheet> [<input> [<output>]]]\n+   */\n+  public static void main(String[] args)\n+    throws Exception\n+  {\n+    InputStream stylesheet = null, in = null;\n+    OutputStream out = null;\n+    try\n+      {\n+        if (args.length > 0)\n+          {\n+            stylesheet = new FileInputStream(args[0]);\n+            if (args.length > 1)\n+              {\n+                in = new FileInputStream(args[1]);\n+                if (args.length > 2)\n+                  out = new FileOutputStream(args[2]);\n+              }\n+          }\n+        if (in == null)\n+          in = System.in;\n+        if (out == null)\n+          out = System.out;\n+        TransformerFactory f = new TransformerFactoryImpl();\n+        Transformer t = (stylesheet != null) ?\n+          f.newTransformer(new StreamSource(stylesheet)) :\n+          f.newTransformer();\n+        t.transform(new StreamSource(in), new StreamResult(out));\n+      }\n+    finally\n+      {\n+        if (stylesheet != null)\n+          stylesheet.close();\n+        if (in != null && in instanceof FileInputStream)\n+          in.close();\n+        if (out != null && out instanceof FileOutputStream)\n+          out.close();\n+      }\n+  }\n   \n }"}, {"sha": "b7ff668843bf2d57f27f4966ceae33eb4b07b620", "filename": "libjava/classpath/gnu/xml/transform/TransformerImpl.java", "status": "modified", "additions": 121, "deletions": 119, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FTransformerImpl.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* TransformerImpl.java -- \n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2005,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -128,8 +128,6 @@ public void transform(Source xmlSource, Result outputTarget)\n       {\n         // Suppress mutation events\n         ((DomDocument) doc).setBuilding(true);\n-        // TODO find a better/more generic way of doing this than\n-        // casting\n       }\n     // Get the result tree\n     Node parent = null, nextSibling = null;\n@@ -147,8 +145,6 @@ public void transform(Source xmlSource, Result outputTarget)\n             DomDocument drdoc = (DomDocument) rdoc;\n             drdoc.setBuilding(true);\n             drdoc.setCheckWellformedness(false);\n-            // TODO find a better/more generic way of doing this than\n-            // casting\n           }\n       }\n     boolean created = false;\n@@ -184,9 +180,7 @@ public void transform(Source xmlSource, Result outputTarget)\n           {\n             // Done transforming, reset document\n             if (doc instanceof DomDocument)\n-              {\n-                ((DomDocument) doc).setBuilding(false);\n-              }\n+              ((DomDocument) doc).setBuilding(false);\n             throw e;\n           }\n       }\n@@ -214,17 +208,11 @@ public void transform(Source xmlSource, Result outputTarget)\n               }\n             Document sourceDoc = context.getOwnerDocument();\n             if (sourceDoc != resultDoc)\n-              {\n-                clone = resultDoc.adoptNode(clone);\n-              }\n+              clone = resultDoc.adoptNode(clone);\n             if (nextSibling != null)\n-              {\n-                parent.insertBefore(clone, nextSibling);\n-              }\n+              parent.insertBefore(clone, nextSibling);\n             else\n-              {\n-                parent.appendChild(clone);\n-              }\n+              parent.appendChild(clone);\n           }\n         else\n           {\n@@ -256,15 +244,18 @@ public void transform(Source xmlSource, Result outputTarget)\n         DomDocument resultDoc = (DomDocument) parent;\n         Node root = resultDoc.getDocumentElement();\n         // Add doctype if specified\n-        if ((publicId != null || systemId != null) &&\n-            root != null)\n+        if (publicId != null || systemId != null)\n           {\n-            // We must know the name of the root element to\n-            // create the document type\n-            resultDoc.appendChild(new DomDoctype(resultDoc,\n-                                                 root.getNodeName(),\n-                                                 publicId,\n-                                                 systemId));\n+            if (root != null)\n+              {\n+                // We must know the name of the root element to\n+                // create the document type\n+                DocumentType doctype = new DomDoctype(resultDoc,\n+                                                      root.getNodeName(),\n+                                                      publicId,\n+                                                      systemId);\n+                resultDoc.insertBefore(doctype, root);\n+              }\n           }\n         resultDoc.setBuilding(false);\n         resultDoc.setCheckWellformedness(true);\n@@ -279,43 +270,25 @@ else if (publicId != null || systemId != null)\n               (Document) parent :\n               parent.getOwnerDocument();\n             DOMImplementation impl = resultDoc.getImplementation();\n-            DocumentType doctype =\n-              impl.createDocumentType(resultDoc.getNodeName(),\n-                                      publicId,\n-                                      systemId);\n-            // Try to insert doctype before first element\n-            Node ctx = parent.getFirstChild();\n-            for (; ctx != null &&\n-                 ctx.getNodeType() != Node.ELEMENT_NODE;\n-                 ctx = ctx.getNextSibling())\n+            Node root = resultDoc.getDocumentElement();\n+            if (root != null)\n               {\n-              }\n-            if (ctx != null)\n-              {\n-                parent.insertBefore(doctype, ctx);\n-              }\n-            else\n-              {\n-                parent.appendChild(doctype);\n+                DocumentType doctype =\n+                  impl.createDocumentType(root.getNodeName(),\n+                                          publicId,\n+                                          systemId);\n+                resultDoc.insertBefore(doctype, root);\n               }\n           }\n       }\n     if (version != null)\n-      {\n-        parent.setUserData(\"version\", version, stylesheet);\n-      }\n+      parent.setUserData(\"version\", version, stylesheet);\n     if (omitXmlDeclaration)\n-      {\n-        parent.setUserData(\"omit-xml-declaration\", \"yes\", stylesheet);\n-      }\n+      parent.setUserData(\"omit-xml-declaration\", \"yes\", stylesheet);\n     if (standalone)\n-      {\n-        parent.setUserData(\"standalone\", \"yes\", stylesheet);\n-      }\n+      parent.setUserData(\"standalone\", \"yes\", stylesheet);\n     if (mediaType != null)\n-      {\n-        parent.setUserData(\"media-type\", mediaType, stylesheet);\n-      }\n+      parent.setUserData(\"media-type\", mediaType, stylesheet);\n     if (cdataSectionElements != null)\n       {\n         List list = new LinkedList();\n@@ -390,13 +363,9 @@ else if (outputTarget instanceof StreamResult)\n         if (ex != null)\n           {\n             if (errorListener != null)\n-              {\n-                errorListener.error(new TransformerException(ex));\n-              }\n+              errorListener.error(new TransformerException(ex));\n             else\n-              {\n-                ex.printStackTrace(System.err);\n-              }\n+              ex.printStackTrace(System.err);\n           }\n       }\n     else if (outputTarget instanceof SAXResult)\n@@ -407,75 +376,126 @@ else if (outputTarget instanceof SAXResult)\n             ContentHandler ch = sr.getHandler();\n             LexicalHandler lh = sr.getLexicalHandler();\n             if (lh == null && ch instanceof LexicalHandler)\n-              {\n-                lh = (LexicalHandler) ch;\n-              }\n+              lh = (LexicalHandler) ch;\n             SAXSerializer serializer = new SAXSerializer();\n             serializer.serialize(parent, ch, lh);\n           }\n         catch (SAXException e)\n           {\n             if (errorListener != null)\n-              {\n-                errorListener.error(new TransformerException(e));\n-              }\n+              errorListener.error(new TransformerException(e));\n             else\n-              {\n-                e.printStackTrace(System.err);\n-              }\n+              e.printStackTrace(System.err);\n           }\n       }\n   }\n \n   /**\n    * Strip whitespace from the source tree.\n    */\n-  void strip(Node node)\n+  boolean strip(Node node)\n     throws TransformerConfigurationException\n   {\n     short nt = node.getNodeType();\n     if (nt == Node.ENTITY_REFERENCE_NODE)\n       {\n         // Replace entity reference with its content\n         Node parent = node.getParentNode();\n+        Node nextSibling = node.getNextSibling();\n         Node child = node.getFirstChild();\n-        if (child != null)\n-          {\n-            strip(child);\n-          }\n         while (child != null)\n           {\n             Node next = child.getNextSibling();\n             node.removeChild(child);\n-            parent.insertBefore(child, node);\n+            if (nextSibling != null)\n+              parent.insertBefore(child, nextSibling);\n+            else\n+              parent.appendChild(child);\n             child = next;\n           }\n-        parent.removeChild(node);\n+        return true;\n       }\n     if (nt == Node.TEXT_NODE || nt == Node.CDATA_SECTION_NODE)\n       {\n-        if (!stylesheet.isPreserved((Text) node))\n+        // Denormalize text into whitespace and non-whitespace nodes\n+        String text = node.getNodeValue();\n+        String[] tokens = tokenizeWhitespace(text);\n+        if (tokens.length > 1)\n           {\n-            node.getParentNode().removeChild(node);\n-          }\n-        else\n-          {\n-            String text = node.getNodeValue();\n-            String stripped = text.trim();\n-            if (!text.equals(stripped))\n+            node.setNodeValue(tokens[0]);\n+            Node parent = node.getParentNode();\n+            Node nextSibling = node.getNextSibling();\n+            Document doc = node.getOwnerDocument();\n+            for (int i = 1; i < tokens.length; i++)\n               {\n-                node.setNodeValue(stripped);\n+                Node newChild = (nt == Node.CDATA_SECTION_NODE) ?\n+                  doc.createCDATASection(tokens[i]) :\n+                  doc.createTextNode(tokens[i]);\n+                if (nextSibling != null)\n+                  parent.insertBefore(newChild, nextSibling);\n+                else\n+                  parent.appendChild(newChild);\n               }\n           }\n+        return !stylesheet.isPreserved((Text) node, true);\n       }\n     else\n       {\n-        for (Node child = node.getFirstChild(); child != null;\n-             child = child.getNextSibling())\n+        Node child = node.getFirstChild();\n+        while (child != null)\n           {\n-            strip(child);\n+            boolean remove = strip(child);\n+            Node next = child.getNextSibling();\n+            if (remove)\n+              node.removeChild(child);\n+            child = next;\n           }\n       }\n+    return false;\n+  }\n+\n+  /**\n+   * Tokenize the specified text into contiguous whitespace-only and\n+   * non-whitespace chunks.\n+   */\n+  private static String[] tokenizeWhitespace(String text)\n+  {\n+    int len = text.length();\n+    int start = 0, end = len - 1;\n+    // Find index of text start\n+    for (int i = 0; i < len; i++)\n+      {\n+        char c = text.charAt(i);\n+        boolean whitespace = (c == ' ' || c == '\\n' || c == '\\t' || c == '\\r');\n+        if (whitespace)\n+          start++;\n+        else\n+          break;\n+      }\n+    if (start == end) // all whitespace\n+      return new String[] { text };\n+    // Find index of text end\n+    for (int i = end; i > start; i--)\n+      {\n+        char c = text.charAt(i);\n+        boolean whitespace = (c == ' ' || c == '\\n' || c == '\\t' || c == '\\r');\n+        if (whitespace)\n+          end--;\n+        else\n+          break;\n+      }\n+    if (start == 0 && end == len - 1) // all non-whitespace\n+      return new String[] { text };\n+    // whitespace, then text, then whitespace\n+    String[] ret = (start > 0 && end < len - 1) ?\n+      new String[3] : new String[2];\n+    int i = 0;\n+    if (start > 0)\n+      ret[i++] = text.substring(0, start);\n+    ret[i++] = text.substring(start, end + 1);\n+    if (end < len - 1)\n+      ret[i++] = text.substring(end + 1);\n+    return ret;\n   }\n \n   /**\n@@ -487,16 +507,15 @@ void writeStreamResult(Node node, StreamResult sr, int outputMethod,\n     throws IOException\n   {\n     OutputStream out = null;\n+    boolean created = false;\n     try\n       {\n         out = sr.getOutputStream();\n         if (out == null)\n           {\n             Writer writer = sr.getWriter();\n             if (writer != null)\n-              {\n-                out = new WriterOutputStream(writer);\n-              }\n+              out = new WriterOutputStream(writer);\n           }\n         if (out == null)\n           {\n@@ -523,6 +542,7 @@ void writeStreamResult(Node node, StreamResult sr, int outputMethod,\n                 URL url = new URL(systemId);\n                 out = new FileOutputStream(url.getPath());\n               }\n+            created = true;\n           }\n         out = new BufferedOutputStream(out);\n         StreamSerializer serializer =\n@@ -539,10 +559,8 @@ void writeStreamResult(Node node, StreamResult sr, int outputMethod,\n       {\n         try\n           {\n-            if (out != null)\n-              {\n-                out.close();\n-              }\n+            if (out != null && created)\n+              out.close();\n           }\n         catch (IOException e)\n           {\n@@ -564,17 +582,13 @@ void copyChildren(Document dstDoc, Node src, Node dst)\n   public void setParameter(String name, Object value)\n   {\n     if (stylesheet != null)\n-      {\n-        stylesheet.bindings.set(new QName(null, name), value, Bindings.PARAM);\n-      }\n+      stylesheet.bindings.set(new QName(null, name), value, Bindings.PARAM);\n   }\n \n   public Object getParameter(String name)\n   {\n     if (stylesheet != null)\n-      {\n-        return stylesheet.bindings.get(new QName(null, name), null, 1, 1);\n-      }\n+      return stylesheet.bindings.get(new QName(null, name), null, 1, 1);\n     return null;\n   }\n \n@@ -601,13 +615,9 @@ public void setOutputProperties(Properties oformat)\n     throws IllegalArgumentException\n   {\n     if (oformat == null)\n-      {\n-        outputProperties.clear();\n-      }\n+      outputProperties.clear();\n     else\n-      {\n-        outputProperties.putAll(oformat);\n-      }\n+      outputProperties.putAll(oformat);\n   }\n \n   public Properties getOutputProperties()\n@@ -689,9 +699,7 @@ void reindent(Document doc, Node node, int offset)\n                 StringBuffer buf = new StringBuffer();\n                 buf.append('\\n');\n                 for (int i = 0; i < offset + 1; i++)\n-                  {\n-                    buf.append(INDENT_WHITESPACE);\n-                  }\n+                  buf.append(INDENT_WHITESPACE);\n                 String ws = buf.toString();\n                 for (Iterator i = children.iterator(); i.hasNext(); )\n                   {\n@@ -703,9 +711,7 @@ void reindent(Document doc, Node node, int offset)\n                 buf.append('\\n');\n                 ws = buf.toString();\n                 for (int i = 0; i < offset; i++)\n-                  {\n-                    buf.append(INDENT_WHITESPACE);\n-                  }\n+                  buf.append(INDENT_WHITESPACE);\n                 node.appendChild(doc.createTextNode(ws));\n               }\n           }\n@@ -749,9 +755,7 @@ void convertCdataSectionElements(Document doc, Node node, List list)\n     while (ctx != null)\n       {\n         if (ctx.hasChildNodes())\n-          {\n-            convertCdataSectionElements(doc, ctx, list);\n-          }\n+          convertCdataSectionElements(doc, ctx, list);\n         ctx = ctx.getNextSibling();\n       }\n   }\n@@ -761,9 +765,7 @@ boolean match(QName qname, Node node)\n     String ln1 = qname.getLocalPart();\n     String ln2 = node.getLocalName();\n     if (ln2 == null)\n-      {\n-        return ln1.equals(node.getNodeName());\n-      }\n+      return ln1.equals(node.getNodeName());\n     else\n       {\n         String uri1 = qname.getNamespaceURI();"}, {"sha": "24c229ea3b32dcd9757f5a39355c1c40f632bc19", "filename": "libjava/classpath/gnu/xml/transform/ValueOfNode.java", "status": "modified", "additions": 17, "deletions": 39, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FValueOfNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FValueOfNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Ftransform%2FValueOfNode.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* ValueOfNode.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -69,26 +69,18 @@ TemplateNode clone(Stylesheet stylesheet)\n     TemplateNode ret = new ValueOfNode(select.clone(stylesheet),\n                                        disableOutputEscaping);\n     if (children != null)\n-      {\n-        ret.children = children.clone(stylesheet);\n-      }\n+      ret.children = children.clone(stylesheet);\n     if (next != null)\n-      {\n-        ret.next = next.clone(stylesheet);\n-      }\n+      ret.next = next.clone(stylesheet);\n     return ret;\n   }\n \n   void doApply(Stylesheet stylesheet, QName mode,\n-             Node context, int pos, int len,\n-             Node parent, Node nextSibling)\n+               Node context, int pos, int len,\n+               Node parent, Node nextSibling)\n     throws TransformerException\n   {\n     Object ret = select.evaluate(context, pos, len);\n-    /*if (stylesheet.debug)\n-      {\n-        System.err.println(\"value-of: \" + select + \" -> \" + ret);\n-      }*/\n     String value;\n     if (ret instanceof Collection)\n       {\n@@ -100,47 +92,35 @@ void doApply(Stylesheet stylesheet, QName mode,\n           }\n         value = buf.toString();\n       }\n+    else if (ret == null)\n+      value = \"\";\n     else\n-      {\n-        value = Expr._string(context, ret);\n-      }\n+      value = Expr._string(context, ret);\n     if (stylesheet.debug)\n-      {\n-        System.err.println(\"value-of: \"+context+\" \"+ select + \" -> \"+ value);\n-      }\n+      System.err.println(\"value-of: \"+context+\" \"+ select + \" -> \"+ value);\n     if (value != null && value.length() > 0)\n       {\n         Document doc = (parent instanceof Document) ?\n           (Document) parent : parent.getOwnerDocument();\n         Text textNode = doc.createTextNode(value);\n         if (disableOutputEscaping)\n-          {\n-            textNode.setUserData(\"disable-output-escaping\", \"yes\", stylesheet);\n-          }\n+          textNode.setUserData(\"disable-output-escaping\", \"yes\", stylesheet);\n         if (nextSibling != null)\n-          {\n-            parent.insertBefore(textNode, nextSibling);\n-          }\n+          parent.insertBefore(textNode, nextSibling);\n         else\n-          {\n-            parent.appendChild(textNode);\n-          }\n+          parent.appendChild(textNode);\n       }\n     // value-of doesn't process children\n     if (next != null)\n-      {\n-        next.apply(stylesheet, mode,\n-                   context, pos, len,\n-                   parent, nextSibling);\n-      }\n+      next.apply(stylesheet, mode,\n+                 context, pos, len,\n+                 parent, nextSibling);\n   }\n \n   public boolean references(QName var)\n   {\n     if (select != null && select.references(var))\n-      {\n-        return true;\n-      }\n+      return true;\n     return super.references(var);\n   }\n   \n@@ -151,9 +131,7 @@ public String toString()\n     buf.append(\"select=\");\n     buf.append(select);\n     if (disableOutputEscaping)\n-      {\n-        buf.append(\",disableOutputEscaping\");\n-      }\n+      buf.append(\",disableOutputEscaping\");\n     buf.append(']');\n     return buf.toString();\n   }"}, {"sha": "76fd49eeff5870ff576320c1926fece6aa68019e", "filename": "libjava/classpath/gnu/xml/xpath/Expr.java", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FExpr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FExpr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FExpr.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* Expr.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -233,9 +233,11 @@ public static Collection _id(Node context, Object object)\n    */\n   public static String _local_name(Node context, Collection nodeSet)\n   {\n-    Node node = (nodeSet == null || nodeSet.size() == 0) ? context :\n-      firstNode(nodeSet);\n-    return node.getLocalName();\n+    if (nodeSet == null || nodeSet.isEmpty())\n+      return \"\";\n+    Node node = firstNode(nodeSet);\n+    String ret = node.getLocalName();\n+    return (ret == null) ? \"\" : ret;\n   }\n \n   /**\n@@ -248,9 +250,11 @@ public static String _local_name(Node context, Collection nodeSet)\n    */\n   public static String _namespace_uri(Node context, Collection nodeSet)\n   {\n-    Node node = (nodeSet == null || nodeSet.size() == 0) ? context :\n-      firstNode(nodeSet);\n-    return node.getNamespaceURI();\n+    if (nodeSet == null || nodeSet.isEmpty())\n+      return \"\";\n+    Node node = firstNode(nodeSet);\n+    String ret = node.getNamespaceURI();\n+    return (ret == null) ? \"\" : ret;\n   }\n   \n   /**\n@@ -271,17 +275,18 @@ public static String _namespace_uri(Node context, Collection nodeSet)\n    */\n   public static String _name(Node context, Collection nodeSet)\n   {\n-    Node node = (nodeSet == null || nodeSet.size() == 0) ? context :\n-      firstNode(nodeSet);\n+    if (nodeSet == null || nodeSet.isEmpty())\n+      return \"\";\n+    Node node = firstNode(nodeSet);\n+    String ret = null;\n     switch (node.getNodeType())\n       {\n       case Node.ATTRIBUTE_NODE:\n       case Node.ELEMENT_NODE:\n       case Node.PROCESSING_INSTRUCTION_NODE:\n-        return node.getNodeName();\n-      default:\n-        return \"\";\n+        ret = node.getNodeName();\n       }\n+    return (ret == null) ? \"\" : ret;\n   }\n \n   /**\n@@ -371,7 +376,10 @@ public static boolean _boolean(Node context, Object object)\n       }\n     if (object instanceof Double)\n       {\n-        return ((Double) object).doubleValue() != 0.0;\n+        Double value = (Double) object;\n+        if (value.isNaN())\n+          return false;\n+        return value.doubleValue() != 0.0;\n       }\n     if (object instanceof String)\n       {\n@@ -473,4 +481,15 @@ static String stringValue(Node node, boolean elementMode)\n       }\n   }\n \n+  static int intValue(Object val)\n+  {\n+    if (val instanceof Double)\n+      {\n+        Double d = (Double) val;\n+        return d.isNaN() ? 0 : d.intValue();\n+      }\n+    else\n+      return (int) Math.ceil(_number(null, val));\n+  }\n+\n }"}, {"sha": "84fb6d4828846bac53c5ff42d332d1b96854087c", "filename": "libjava/classpath/gnu/xml/xpath/LocalNameFunction.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FLocalNameFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FLocalNameFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FLocalNameFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* LocalNameFunction.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,7 @@\n package gnu.xml.xpath;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import javax.xml.namespace.QName;\n import org.w3c.dom.Node;\n@@ -70,7 +71,8 @@\n \n   public Object evaluate(Node context, int pos, int len)\n   {\n-    Object val = (arg == null) ? null : arg.evaluate(context, pos, len);\n+    Object val = (arg == null) ? Collections.singleton(context) :\n+        arg.evaluate(context, pos, len);\n     return _local_name(context, (Collection) val);\n   }\n "}, {"sha": "ea49741fa57406291830c7a1791433e1e66d1990", "filename": "libjava/classpath/gnu/xml/xpath/NameFunction.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* NameFunction.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,7 @@\n package gnu.xml.xpath;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import javax.xml.namespace.QName;\n import org.w3c.dom.Node;\n@@ -78,7 +79,8 @@\n \n   public Object evaluate(Node context, int pos, int len)\n   {\n-    Object val = (arg == null) ? null : arg.evaluate(context, pos, len);\n+    Object val = (arg == null) ? Collections.singleton(context) :\n+        arg.evaluate(context, pos, len);\n     return _name(context, (Collection) val);\n   }\n "}, {"sha": "1710103903de728f6fee1e7d6b55c2a715cca54e", "filename": "libjava/classpath/gnu/xml/xpath/NameTest.java", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameTest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameTest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNameTest.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* NameTest.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -91,29 +91,32 @@ public boolean matches(Node node, int pos, int len)\n         return false;\n       }\n     if (any)\n-      {\n-        return true;\n-      }\n+      return true;\n     String uri = qName.getNamespaceURI();\n     String nodeUri = node.getNamespaceURI();\n-    String nodeLocalName = node.getLocalName();\n-    if (nodeLocalName != null && !equal(uri, nodeUri))\n-      {\n-        return false;\n-      }\n+    if (!equal(uri, nodeUri))\n+      return false;\n     if (anyLocalName)\n-      {\n-        return true;\n-      }\n+      return true;\n     String localName = qName.getLocalPart();\n-    if (nodeLocalName != null)\n+    String nodeLocalName = getLocalName(node);\n+    return (localName.equals(nodeLocalName));\n+  }\n+\n+  static String getLocalName(Node node)\n+  {\n+    String localName = node.getLocalName();\n+    if (localName == null)\n       {\n-        nodeLocalName = node.getNodeName();\n+        localName = node.getNodeName();\n+        int ci = localName.indexOf(':');\n+        if (ci != -1)\n+          localName = localName.substring(ci + 1);\n       }\n-    return (localName.equals(nodeLocalName));\n+    return localName;\n   }\n \n-  final boolean equal(String s1, String s2)\n+  static boolean equal(String s1, String s2)\n   {\n     return (((s1 == null || s1.length() == 0) &&\n              (s2 == null || s2.length() == 0)) ||\n@@ -133,9 +136,7 @@ public boolean references(QName var)\n   public String toString ()\n   {\n     if (any)\n-      {\n-        return \"*\";\n-      }\n+      return \"*\";\n     return qName.toString();\n   }\n   "}, {"sha": "d93b76d9de8335fe3c205d681975c34537d98fb9", "filename": "libjava/classpath/gnu/xml/xpath/NamespaceTest.java", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceTest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceTest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceTest.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -81,28 +81,22 @@ public boolean matches(Node node, int pos, int len)\n         if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri) ||\n             XMLConstants.XMLNS_ATTRIBUTE.equals(node.getPrefix()) ||\n             XMLConstants.XMLNS_ATTRIBUTE.equals(node.getNodeName()))\n-          {\n-            break;\n-          }\n+          break;\n         // Fall through\n       default:\n         // Only process namespace attributes\n         return false;\n       }\n     if (any)\n-      {\n-        return true;\n-      }\n+      return true;\n+    String uri = qName.getNamespaceURI();\n+    String nodeUri = node.getNamespaceURI();\n+    if (!NameTest.equal(uri, nodeUri))\n+      return false;\n     if (anyLocalName)\n-      {\n-        return true;\n-      }\n+      return true;\n     String localName = qName.getLocalPart();\n-    String nodeLocalName = node.getLocalName();\n-    if (nodeLocalName == null)\n-      {\n-        nodeLocalName = node.getNodeName();\n-      }\n+    String nodeLocalName = NameTest.getLocalName(node);\n     return (localName.equals(nodeLocalName));\n   }\n \n@@ -119,9 +113,7 @@ public boolean references(QName var)\n   public String toString ()\n   {\n     if (any)\n-      {\n-        return \"*\";\n-      }\n+      return \"*\";\n     return qName.toString();\n   }\n   "}, {"sha": "3ae46f7ee71d3c4b7b0a4bbc86ec605a85ddce6b", "filename": "libjava/classpath/gnu/xml/xpath/NamespaceUriFunction.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceUriFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceUriFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNamespaceUriFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* NamespaceUriFunction.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,7 @@\n package gnu.xml.xpath;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import javax.xml.namespace.QName;\n import org.w3c.dom.Node;\n@@ -70,7 +71,8 @@\n \n   public Object evaluate(Node context, int pos, int len)\n   {\n-    Object val = (arg == null) ? null : arg.evaluate(context, pos, len);\n+    Object val = (arg == null) ? Collections.singleton(context) :\n+        arg.evaluate(context, pos, len);\n     return _namespace_uri(context, (Collection) val);\n   }\n "}, {"sha": "09e92d0d9a2bd93e766026d70a5eb5b45464c399", "filename": "libjava/classpath/gnu/xml/xpath/NodeTypeTest.java", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNodeTypeTest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNodeTypeTest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FNodeTypeTest.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* NodeTypeTest.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,6 +39,7 @@\n \n import javax.xml.namespace.QName;\n import org.w3c.dom.Node;\n+import org.w3c.dom.ProcessingInstruction;\n \n /**\n  * Tests whether a node is of a given type.\n@@ -83,17 +84,20 @@ public boolean matches(Node node, int pos, int len)\n       case Node.TEXT_NODE:\n       case Node.CDATA_SECTION_NODE:\n       case Node.COMMENT_NODE:\n+        if (type > 0)\n+          {\n+            if (nodeType != type)\n+              return false;\n+          }\n+        return true;\n       case Node.PROCESSING_INSTRUCTION_NODE:\n         if (type > 0)\n           {\n             if (nodeType != type)\n-              {\n-                return false;\n-              }\n-            if (data != null && !data.equals(node.getNodeValue()))\n-              {\n-                return false;\n-              }\n+              return false;\n+            if (data != null &&\n+                !data.equals(((ProcessingInstruction) node).getTarget()))\n+              return false;\n           }\n         return true;\n       default:"}, {"sha": "93408e48b231210d800fb9b181e89eb3758c3b49", "filename": "libjava/classpath/gnu/xml/xpath/Selector.java", "status": "modified", "additions": 64, "deletions": 93, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSelector.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* Selector.java -- \n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -85,11 +85,13 @@\n   public Selector(int axis, List tests)\n   {\n     this.axis = axis;\n-    this.tests = new Test[tests.size()];\n-    tests.toArray(this.tests);\n-    if (axis == NAMESPACE &&\n-        this.tests.length > 0 &&\n-        this.tests[0] instanceof NameTest)\n+    int len = tests.size();\n+    this.tests = new Test[(len == 0) ? 1 : len];\n+    if (len > 0)\n+      tests.toArray(this.tests);\n+    else\n+      this.tests[0] = new NameTest(null, true, true);\n+    if (axis == NAMESPACE && this.tests[0] instanceof NameTest)\n       {\n         NameTest nt = (NameTest) this.tests[0];\n         this.tests[0] = new NamespaceTest(nt.qName, nt.anyLocalName, nt.any);\n@@ -111,16 +113,12 @@ public boolean matches(Node context)\n       {\n       case CHILD:\n         if (nodeType == Node.ATTRIBUTE_NODE)\n-          {\n-            return false;\n-          }\n+          return false;\n         break;\n       case ATTRIBUTE:\n       case NAMESPACE:\n         if (nodeType != Node.ATTRIBUTE_NODE)\n-          {\n-            return false;\n-          }\n+          return false;\n         break;\n       case DESCENDANT_OR_SELF:\n         return true;\n@@ -132,13 +130,13 @@ public boolean matches(Node context)\n       {\n         int pos = getContextPosition(context);\n         int len = getContextSize(context);\n+        if (len == 0)\n+          System.err.println(\"WARNING: context size is 0\");\n         for (int j = 0; j < tlen && len > 0; j++)\n           {\n             Test test = tests[j];\n             if (!test.matches(context, pos, len))\n-              {\n-                return false;\n-              }\n+              return false;\n           }\n       }\n     return true;\n@@ -149,33 +147,32 @@ private int getContextPosition(Node ctx)\n     int pos = 1;\n     for (ctx = ctx.getPreviousSibling(); ctx != null;\n          ctx = ctx.getPreviousSibling())\n-      {\n-        pos++;\n-      }\n+      pos++;\n     return pos;\n   }\n \n   private int getContextSize(Node ctx)\n   {\n     if (ctx.getNodeType() == Node.ATTRIBUTE_NODE)\n       {\n-        Node parent = ((Attr) ctx).getOwnerElement();\n-        return parent.getAttributes().getLength();\n-      }\n-    Node parent = ctx.getParentNode();\n-    if (parent != null)\n-      {\n-        return parent.getChildNodes().getLength();\n+        Node owner = ((Attr) ctx).getOwnerElement();\n+        return owner.getAttributes().getLength();\n       }\n-    return 1;\n+    int count = 1;\n+    Node sib = ctx.getPreviousSibling();\n+    for (; sib != null; sib = sib.getPreviousSibling())\n+      count++;\n+    sib = ctx.getNextSibling();\n+    for (; sib != null; sib = sib.getNextSibling())\n+      count++;\n+    return count;\n   }\n \n   public Object evaluate(Node context, int pos, int len)\n   {\n     Set acc = new LinkedHashSet();\n     addCandidates(context, acc);\n     List candidates = new ArrayList(acc);\n-    //Collections.sort(candidates, documentOrderComparator);\n     List ret = filterCandidates(candidates, false);\n     return ret;\n   }\n@@ -184,11 +181,8 @@ Collection evaluate(Node context, Collection ns)\n   {\n     Set acc = new LinkedHashSet();\n     for (Iterator i = ns.iterator(); i.hasNext(); )\n-      {\n-        addCandidates((Node) i.next(), acc);\n-      }\n+      addCandidates((Node) i.next(), acc);\n     List candidates = new ArrayList(acc);\n-    //Collections.sort(candidates, documentOrderComparator);\n     List ret = filterCandidates(candidates, true);\n     return ret;\n   }\n@@ -230,17 +224,7 @@ List filterCandidates(List candidates, boolean cascade)\n                       }\n                   }\n                 if (test.matches(node, i + 1, len))\n-                  {\n-                    successful.add(node);\n-                  }\n-                /*\n-                   System.err.println(\"Testing \"+node);\n-                   int p = getContextPosition(node);\n-                   int l = getContextSize(node);\n-                   if (test.matches(node, p, l))\n-                   {\n-                   successful.add(node);\n-                   }*/\n+                  successful.add(node);\n               }\n             candidates = successful;\n             len = candidates.size();\n@@ -305,9 +289,7 @@ void addChildNodes(Node context, Collection acc, boolean recurse)\n       {\n         acc.add(child);\n         if (recurse)\n-          {\n-            addChildNodes(child, acc, recurse);\n-          }\n+          addChildNodes(child, acc, recurse);\n         child = child.getNextSibling();\n       }\n   }\n@@ -320,55 +302,62 @@ void addParentNode(Node context, Collection acc, boolean recurse)\n       {\n         acc.add(parent);\n         if (recurse)\n-          {\n-            addParentNode(parent, acc, recurse);\n-          }\n+          addParentNode(parent, acc, recurse);\n       }\n   }\n \n   void addFollowingNodes(Node context, Collection acc, boolean recurse)\n   {\n-    Node cur = context.getNextSibling();\n+    if (context != null && recurse)\n+      addChildNodes(context, acc, true);\n+    Node cur = (context.getNodeType() == Node.ATTRIBUTE_NODE) ? null :\n+      context.getNextSibling();\n     while (cur != null)\n       {\n         acc.add(cur);\n         if (recurse)\n-          {\n-            addChildNodes(cur, acc, true);\n-          }\n+          addChildNodes(cur, acc, true);\n         cur = cur.getNextSibling();\n       }\n     if (recurse)\n       {\n-        context = (context.getNodeType() == Node.ATTRIBUTE_NODE) ?\n-          ((Attr) context).getOwnerElement() : context.getParentNode();\n-        if (context != null)\n+        while (context != null)\n           {\n-            addFollowingNodes(context, acc, recurse);\n+            context = (context.getNodeType() == Node.ATTRIBUTE_NODE) ?\n+              ((Attr) context).getOwnerElement() : context.getParentNode();\n+            if (context != null)\n+              {\n+                cur = context.getNextSibling();\n+                while (cur != null)\n+                  {\n+                    acc.add(cur);\n+                    if (recurse)\n+                      addChildNodes(cur, acc, true);\n+                    cur = cur.getNextSibling();\n+                  }\n+              }\n           }\n       }\n   }\n \n   void addPrecedingNodes(Node context, Collection acc, boolean recurse)\n   {\n-    Node cur = context.getPreviousSibling();\n+    Node cur = (context.getNodeType() == Node.ATTRIBUTE_NODE) ? null :\n+      context.getPreviousSibling();\n     while (cur != null)\n       {\n         acc.add(cur);\n         if (recurse)\n-          {\n-            addChildNodes(cur, acc, true);\n-          }\n+          addChildNodes(cur, acc, true);\n         cur = cur.getPreviousSibling();\n       }\n     if (recurse)\n       {\n-        context = (context.getNodeType() == Node.ATTRIBUTE_NODE) ?\n-          ((Attr) context).getOwnerElement() : context.getParentNode();\n-        if (context != null)\n-          {\n-            addPrecedingNodes(context, acc, recurse);\n-          }\n+        cur = context;\n+        cur = (cur.getNodeType() == Node.ATTRIBUTE_NODE) ?\n+          ((Attr) cur).getOwnerElement() : cur.getParentNode();\n+        if (cur != null)\n+          addPrecedingNodes(cur, acc, recurse);\n       }\n   }\n \n@@ -399,9 +388,7 @@ void addNamespaceAttributes(Node context, Collection acc)\n           {\n             Node attr = attrs.item(i);\n             if (isNamespaceAttribute(attr))\n-              {\n-                acc.add(attr);\n-              }\n+              acc.add(attr);\n           }\n       }\n   }\n@@ -419,9 +406,7 @@ public Expr clone(Object context)\n     int len = tests.length;\n     List tests2 = new ArrayList(len);\n     for (int i = 0; i < len; i++)\n-      {\n-        tests2.add(tests[i].clone(context));\n-      }\n+      tests2.add(tests[i].clone(context));\n     return new Selector(axis, tests2);\n   }\n \n@@ -430,9 +415,7 @@ public boolean references(QName var)\n     for (int i = 0; i < tests.length; i++)\n       {\n         if (tests[i].references(var))\n-          {\n-            return true;\n-          }\n+          return true;\n       }\n     return false;\n   }\n@@ -451,13 +434,9 @@ public String toString()\n       case ATTRIBUTE:\n         if (tests.length == 0 ||\n             (tests[0] instanceof NameTest))\n-          {\n-            buf.append('@');\n-          }\n+          buf.append('@');\n         else\n-          {\n-            buf.append(\"attribute::\");\n-          }\n+          buf.append(\"attribute::\");\n         break;\n       case CHILD:\n         //buf.append(\"child::\");\n@@ -481,9 +460,7 @@ public String toString()\n         if (tests.length == 0 ||\n             (tests[0] instanceof NodeTypeTest &&\n              ((NodeTypeTest) tests[0]).type == 0))\n-          {\n-            return \"..\";\n-          }\n+          return \"..\";\n         buf.append(\"parent::\");\n         break;\n       case PRECEDING:\n@@ -496,22 +473,16 @@ public String toString()\n         if (tests.length == 0 ||\n             (tests[0] instanceof NodeTypeTest &&\n              ((NodeTypeTest) tests[0]).type == 0))\n-          {\n-            return \".\";\n-          }\n+          return \".\";\n         buf.append(\"self::\");\n         break;\n       }\n     if (tests.length == 0)\n-      {\n-        buf.append('*');\n-      }\n+      buf.append(\"[error]\");\n     else\n       {\n         for (int i = 0; i < tests.length; i++)\n-          {\n-            buf.append(tests[i]);\n-          }\n+          buf.append(tests[i]);\n       }\n     return buf.toString();\n   }"}, {"sha": "e926f6c7aeb61faa79ba3cf1487377054efb99d0", "filename": "libjava/classpath/gnu/xml/xpath/SubstringFunction.java", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSubstringFunction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSubstringFunction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fxml%2Fxpath%2FSubstringFunction.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -78,31 +78,20 @@ public Object evaluate(Node context, int pos, int len)\n     Object val1 = arg1.evaluate(context, pos, len);\n     Object val2 = arg2.evaluate(context, pos, len);\n     String s = _string(context, val1);\n-    int p = (val2 instanceof Double) ?\n-      ((Double) val2).intValue() :\n-        (int) Math.round(_number(context, val2));\n-    p--;\n+    int p = Expr.intValue(val2) - 1;\n     if (p < 0)\n-      {\n-        p = 0;\n-      }\n+      p = 0;\n \n     int l = s.length() - p;\n     if (l <= 0)\n-      {\n-        return \"\";\n-      }\n+      return \"\";\n \n     if (arg3 != null)\n       {\n         Object val3 = arg3.evaluate(context, pos, len);\n-        int v3 = (val3 instanceof Double) ?\n-          ((Double) val3).intValue() :\n-            (int) Math.round(_number(context, val3));\n+        int v3 = Expr.intValue(val3);\n         if (v3 < l) \n-          {\n-            l = v3;\n-          }\n+          l = v3;\n       }\n \n     return s.substring(p, p + l);"}, {"sha": "eeae36a942e6656384f60683b2951a94e31ba0a5", "filename": "libjava/classpath/include/Makefile.am", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2FMakefile.am?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,11 +1,12 @@\n ## GCJ LOCAL: headers are installed specially.\n ##include_HEADERS = jni.h jni_md.h jawt.h jawt_md.h\n \n-DISTCLEANFILES = jni_md.h\n+DISTCLEANFILES = jni_md.h config-int.h\n \n ARG_JNI_JAVAH = -jni\n ARG_CLASSPATH_JAVAH = -bootclasspath\n JAVAH = $(USER_JAVAH) $(ARG_JNI_JAVAH) $(ARG_CLASSPATH_JAVAH) ../lib:$(USER_CLASSLIB)\n+CLASSDIR = lib\n \n SOUND_H_FILES = \\\n $(top_srcdir)/include/gnu_javax_sound_midi_alsa_AlsaPortDevice.h \\\n@@ -143,25 +144,25 @@ if CREATE_JNI_HEADERS\n \n all-local: $(H_FILES)\n \n-$(top_srcdir)/include/gnu_xml_libxmlj_dom_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/dom/%.class\n+$(top_srcdir)/include/gnu_xml_libxmlj_dom_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/dom/%.class\n \t$(JAVAH) -o $@ gnu.xml.libxmlj.dom.$*\n \n-$(top_srcdir)/include/gnu_xml_libxmlj_sax_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/sax/%.class\n+$(top_srcdir)/include/gnu_xml_libxmlj_sax_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/sax/%.class\n \t$(JAVAH) -o $@ gnu.xml.libxmlj.sax.$*\n \n-$(top_srcdir)/include/gnu_xml_libxmlj_transform_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/transform/%.class\n+$(top_srcdir)/include/gnu_xml_libxmlj_transform_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/transform/%.class\n \t$(JAVAH) -o $@ gnu.xml.libxmlj.transform.$*\n \n-$(top_srcdir)/include/gnu_java_awt_peer_gtk_%.h: $(top_builddir)/lib/gnu/java/awt/peer/gtk/%.class\n+$(top_srcdir)/include/gnu_java_awt_peer_gtk_%.h: $(top_builddir)/$(CLASSDIR)/gnu/java/awt/peer/gtk/%.class\n \t$(JAVAH) -o $@ gnu.java.awt.peer.gtk.$*\n \n-$(top_srcdir)/include/gnu_java_awt_peer_qt_%.h: $(top_builddir)/lib/gnu/java/awt/peer/qt/%.class\n+$(top_srcdir)/include/gnu_java_awt_peer_qt_%.h: $(top_builddir)/$(CLASSDIR)/gnu/java/awt/peer/qt/%.class\n \t$(JAVAH) -o $@ gnu.java.awt.peer.qt.$*\n \n-$(top_srcdir)/include/gnu_javax_sound_midi_alsa_%.h: $(top_builddir)/lib/gnu/javax/sound/midi/alsa/%.class\n+$(top_srcdir)/include/gnu_javax_sound_midi_alsa_%.h: $(top_builddir)/$(CLASSDIR)/gnu/javax/sound/midi/alsa/%.class\n \t$(JAVAH) -o $@ gnu.javax.sound.midi.alsa.$*\n \n-$(top_srcdir)/include/gnu_javax_sound_midi_dssi_%.h: $(top_builddir)/lib/gnu/javax/sound/midi/dssi/%.class\n+$(top_srcdir)/include/gnu_javax_sound_midi_dssi_%.h: $(top_builddir)/$(CLASSDIR)/gnu/javax/sound/midi/dssi/%.class\n \t$(JAVAH) -o $@ gnu.javax.sound.midi.dssi.$*\n \n $(top_srcdir)/include/gnu_java_net_PlainDatagramSocketImpl.h: $(top_srcdir)/gnu/java/net/PlainDatagramSocketImpl.java"}, {"sha": "d7aed96a19a469a8ffd9e17ab38368788e2bd960", "filename": "libjava/classpath/include/Makefile.in", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2FMakefile.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -42,10 +42,11 @@ DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n \t$(top_srcdir)/m4/acattribute.m4 $(top_srcdir)/m4/accross.m4 \\\n-\t$(top_srcdir)/m4/acinclude.m4 $(top_srcdir)/m4/iconv.m4 \\\n-\t$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \\\n-\t$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/pkg.m4 \\\n-\t$(top_srcdir)/configure.ac\n+\t$(top_srcdir)/m4/acinclude.m4 \\\n+\t$(top_srcdir)/m4/ax_create_stdint_h.m4 \\\n+\t$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \\\n+\t$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \\\n+\t$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n@@ -141,6 +142,7 @@ JAY = @JAY@\n JAY_SKELETON = @JAY_SKELETON@\n JIKES = @JIKES@\n JIKESENCODING = @JIKESENCODING@\n+JIKESWARNINGS = @JIKESWARNINGS@\n KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n@@ -245,10 +247,11 @@ target_cpu = @target_cpu@\n target_os = @target_os@\n target_vendor = @target_vendor@\n vm_classes = @vm_classes@\n-DISTCLEANFILES = jni_md.h\n+DISTCLEANFILES = jni_md.h config-int.h\n ARG_JNI_JAVAH = -jni\n ARG_CLASSPATH_JAVAH = -bootclasspath\n JAVAH = $(USER_JAVAH) $(ARG_JNI_JAVAH) $(ARG_CLASSPATH_JAVAH) ../lib:$(USER_CLASSLIB)\n+CLASSDIR = lib\n SOUND_H_FILES = \\\n $(top_srcdir)/include/gnu_javax_sound_midi_alsa_AlsaPortDevice.h \\\n $(top_srcdir)/include/gnu_javax_sound_midi_alsa_AlsaMidiSequencerDevice.h \\\n@@ -565,25 +568,25 @@ uninstall-am: uninstall-info-am\n \n @CREATE_JNI_HEADERS_TRUE@all-local: $(H_FILES)\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_dom_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/dom/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_dom_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/dom/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.xml.libxmlj.dom.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_sax_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/sax/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_sax_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/sax/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.xml.libxmlj.sax.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_transform_%.h: $(top_builddir)/lib/gnu/xml/libxmlj/transform/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_xml_libxmlj_transform_%.h: $(top_builddir)/$(CLASSDIR)/gnu/xml/libxmlj/transform/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.xml.libxmlj.transform.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_java_awt_peer_gtk_%.h: $(top_builddir)/lib/gnu/java/awt/peer/gtk/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_java_awt_peer_gtk_%.h: $(top_builddir)/$(CLASSDIR)/gnu/java/awt/peer/gtk/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.java.awt.peer.gtk.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_java_awt_peer_qt_%.h: $(top_builddir)/lib/gnu/java/awt/peer/qt/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_java_awt_peer_qt_%.h: $(top_builddir)/$(CLASSDIR)/gnu/java/awt/peer/qt/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.java.awt.peer.qt.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_javax_sound_midi_alsa_%.h: $(top_builddir)/lib/gnu/javax/sound/midi/alsa/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_javax_sound_midi_alsa_%.h: $(top_builddir)/$(CLASSDIR)/gnu/javax/sound/midi/alsa/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.javax.sound.midi.alsa.$*\n \n-@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_javax_sound_midi_dssi_%.h: $(top_builddir)/lib/gnu/javax/sound/midi/dssi/%.class\n+@CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_javax_sound_midi_dssi_%.h: $(top_builddir)/$(CLASSDIR)/gnu/javax/sound/midi/dssi/%.class\n @CREATE_JNI_HEADERS_TRUE@\t$(JAVAH) -o $@ gnu.javax.sound.midi.dssi.$*\n \n @CREATE_JNI_HEADERS_TRUE@$(top_srcdir)/include/gnu_java_net_PlainDatagramSocketImpl.h: $(top_srcdir)/gnu/java/net/PlainDatagramSocketImpl.java"}, {"sha": "388ee497ecbaca4abbcfc74a0fad8c65b7fb530b", "filename": "libjava/classpath/include/config.h.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fconfig.h.in?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -87,6 +87,9 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have the `isnan' function. */\n+#undef HAVE_ISNAN\n+\n /* Define to 1 if you have the `listen' function. */\n #undef HAVE_LISTEN\n \n@@ -253,6 +256,21 @@\n    otherwise */\n #undef PORTABLE_NATIVE_SYNC\n \n+/* The size of a `char', as computed by sizeof. */\n+#undef SIZEOF_CHAR\n+\n+/* The size of a `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of a `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of a `short', as computed by sizeof. */\n+#undef SIZEOF_SHORT\n+\n+/* The size of a `void*', as computed by sizeof. */\n+#undef SIZEOF_VOIDP\n+\n /* The number of bytes in type void * */\n #undef SIZEOF_VOID_P\n "}, {"sha": "8a87738f2c0c65c73744e23854df4efc43f7c033", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GdkGraphics.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphics.h?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -15,11 +15,11 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_initState__Lgnu_ja\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_initStateUnlocked (JNIEnv *env, jobject, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_initState__II (JNIEnv *env, jobject, jint, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_initFromImage (JNIEnv *env, jobject, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_copyState (JNIEnv *env, jobject, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_nativeCopyState (JNIEnv *env, jobject, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_connectSignals (JNIEnv *env, jobject, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_clearRect (JNIEnv *env, jobject, jint, jint, jint, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_copyArea (JNIEnv *env, jobject, jint, jint, jint, jint, jint, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_dispose (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_nativeDispose (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_drawLine (JNIEnv *env, jobject, jint, jint, jint, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_drawArc (JNIEnv *env, jobject, jint, jint, jint, jint, jint, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_fillArc (JNIEnv *env, jobject, jint, jint, jint, jint, jint, jint);"}, {"sha": "9cb20b7dc762c3964efc52a6e8416579630e6d66", "filename": "libjava/classpath/include/gnu_java_net_PlainDatagramSocketImpl.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainDatagramSocketImpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainDatagramSocketImpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainDatagramSocketImpl.h?ref=bcb36c3e02e3bd2843aad1b9888513dfb5d6e337", "patch": "@@ -1,29 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-\n-#ifndef __gnu_java_net_PlainDatagramSocketImpl__\n-#define __gnu_java_net_PlainDatagramSocketImpl__\n-\n-#include <jni.h>\n-\n-#ifdef __cplusplus\n-extern \"C\"\n-{\n-#endif\n-\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_bind (JNIEnv *env, jobject, jint, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_create (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_sendto (JNIEnv *env, jobject, jobject, jint, jbyteArray, jint, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_receive0 (JNIEnv *env, jobject, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_setOption (JNIEnv *env, jobject, jint, jobject);\n-JNIEXPORT jobject JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_getOption (JNIEnv *env, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_close (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_join (JNIEnv *env, jobject, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainDatagramSocketImpl_leave (JNIEnv *env, jobject, jobject);\n-#undef gnu_java_net_PlainDatagramSocketImpl_IP_TTL\n-#define gnu_java_net_PlainDatagramSocketImpl_IP_TTL 7777L\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* __gnu_java_net_PlainDatagramSocketImpl__ */"}, {"sha": "1de21d610c732cf81fe65282877fe111516d72ce", "filename": "libjava/classpath/include/gnu_java_net_PlainSocketImpl.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainSocketImpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb36c3e02e3bd2843aad1b9888513dfb5d6e337/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainSocketImpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_PlainSocketImpl.h?ref=bcb36c3e02e3bd2843aad1b9888513dfb5d6e337", "patch": "@@ -1,31 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-\n-#ifndef __gnu_java_net_PlainSocketImpl__\n-#define __gnu_java_net_PlainSocketImpl__\n-\n-#include <jni.h>\n-\n-#ifdef __cplusplus\n-extern \"C\"\n-{\n-#endif\n-\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_setOption (JNIEnv *env, jobject, jint, jobject);\n-JNIEXPORT jobject JNICALL Java_gnu_java_net_PlainSocketImpl_getOption (JNIEnv *env, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_shutdownInput (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_shutdownOutput (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_create (JNIEnv *env, jobject, jboolean);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_connect (JNIEnv *env, jobject, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_bind (JNIEnv *env, jobject, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_listen (JNIEnv *env, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_accept (JNIEnv *env, jobject, jobject);\n-JNIEXPORT jint JNICALL Java_gnu_java_net_PlainSocketImpl_available (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_close (JNIEnv *env, jobject);\n-JNIEXPORT jint JNICALL Java_gnu_java_net_PlainSocketImpl_read (JNIEnv *env, jobject, jbyteArray, jint, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_net_PlainSocketImpl_write (JNIEnv *env, jobject, jbyteArray, jint, jint);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* __gnu_java_net_PlainSocketImpl__ */"}, {"sha": "616c753001193ca5a0b19f5624b2504c91d0abbb", "filename": "libjava/classpath/include/gnu_java_net_VMPlainDatagramSocketImpl.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainDatagramSocketImpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainDatagramSocketImpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainDatagramSocketImpl.h?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,95 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class gnu_java_net_VMPlainDatagramSocketImpl */\n+\n+#ifndef _Included_gnu_java_net_VMPlainDatagramSocketImpl\n+#define _Included_gnu_java_net_VMPlainDatagramSocketImpl\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#undef gnu_java_net_VMPlainDatagramSocketImpl_IP_TTL\n+#define gnu_java_net_VMPlainDatagramSocketImpl_IP_TTL 7777L\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    bind\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;ILjava/net/InetAddress;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_bind\n+  (JNIEnv *, jclass, jobject, jint, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    create\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_create\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    connect\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;Ljava/net/InetAddress;I)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_connect\n+  (JNIEnv *, jclass, jobject, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    nativeSendTo\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;Ljava/net/InetAddress;I[BII)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_nativeSendTo\n+  (JNIEnv *, jclass, jobject, jobject, jint, jbyteArray, jint, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    nativeReceive\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;[BII[B[I[I)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_nativeReceive\n+  (JNIEnv *, jclass, jobject, jbyteArray, jint, jint, jbyteArray, jintArray, jintArray);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    setOption\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;ILjava/lang/Object;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_setOption\n+  (JNIEnv *, jclass, jobject, jint, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    getOption\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;I)Ljava/lang/Object;\n+ */\n+JNIEXPORT jobject JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_getOption\n+  (JNIEnv *, jclass, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    close\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_close\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    join\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;Ljava/net/InetAddress;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_join\n+  (JNIEnv *, jclass, jobject, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainDatagramSocketImpl\n+ * Method:    leave\n+ * Signature: (Lgnu/java/net/PlainDatagramSocketImpl;Ljava/net/InetAddress;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainDatagramSocketImpl_leave\n+  (JNIEnv *, jclass, jobject, jobject);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"}, {"sha": "1e22aefbd896ba5895bf1688b10e8eb63cfc1447", "filename": "libjava/classpath/include/gnu_java_net_VMPlainSocketImpl.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainSocketImpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainSocketImpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_net_VMPlainSocketImpl.h?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,117 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class gnu_java_net_VMPlainSocketImpl */\n+\n+#ifndef _Included_gnu_java_net_VMPlainSocketImpl\n+#define _Included_gnu_java_net_VMPlainSocketImpl\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    setOption\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;ILjava/lang/Object;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_setOption\n+  (JNIEnv *, jclass, jobject, jint, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    getOption\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;I)Ljava/lang/Object;\n+ */\n+JNIEXPORT jobject JNICALL Java_gnu_java_net_VMPlainSocketImpl_getOption\n+  (JNIEnv *, jclass, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    create\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_create\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    connect\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;Ljava/net/InetAddress;I)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_connect\n+  (JNIEnv *, jclass, jobject, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    bind\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;Ljava/net/InetAddress;I)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_bind\n+  (JNIEnv *, jclass, jobject, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    listen\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;I)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_listen\n+  (JNIEnv *, jclass, jobject, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    accept\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;Ljava/net/SocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_accept\n+  (JNIEnv *, jclass, jobject, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    available\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;)I\n+ */\n+JNIEXPORT jint JNICALL Java_gnu_java_net_VMPlainSocketImpl_available\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    close\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_close\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    read\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;[BII)I\n+ */\n+JNIEXPORT jint JNICALL Java_gnu_java_net_VMPlainSocketImpl_read\n+  (JNIEnv *, jclass, jobject, jbyteArray, jint, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    write\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;[BII)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_write\n+  (JNIEnv *, jclass, jobject, jbyteArray, jint, jint);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    shutdownInput\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_shutdownInput\n+  (JNIEnv *, jclass, jobject);\n+\n+/*\n+ * Class:     gnu_java_net_VMPlainSocketImpl\n+ * Method:    shutdownOutput\n+ * Signature: (Lgnu/java/net/PlainSocketImpl;)V\n+ */\n+JNIEXPORT void JNICALL Java_gnu_java_net_VMPlainSocketImpl_shutdownOutput\n+  (JNIEnv *, jclass, jobject);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"}, {"sha": "7c8c582a96b5a633dd1989e7b072f8c77b6edb7f", "filename": "libjava/classpath/java/awt/BorderLayout.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FBorderLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FBorderLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FBorderLayout.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -415,7 +415,7 @@ public Dimension preferredLayoutSize(Container target)\n    */\n   public Dimension maximumLayoutSize(Container target)\n   {\n-    return calcSize(target, MAX);\n+    return new Dimension (Integer.MAX_VALUE, Integer.MAX_VALUE);\n   }\n \n   /**"}, {"sha": "bd22ea3c984a4501fd93401e1bf5a4a9eb051e7a", "filename": "libjava/classpath/java/awt/Component.java", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1038,14 +1038,10 @@ public void setBackground(Color c)\n     if ((c != null) && c.equals(background))\n       return;\n \n-    // If c is null, inherit from closest ancestor whose bg is set.\n-    if (c == null && parent != null)\n-      c = parent.getBackground();\n-    if (peer != null && c != null)\n-      peer.setBackground(c);\n-    \n     Color previous = background;\n     background = c;\n+    if (peer != null && c != null)\n+      peer.setBackground(c);\n     firePropertyChange(\"background\", previous, c);\n   }\n \n@@ -2642,7 +2638,7 @@ public synchronized void addMouseMotionListener(MouseMotionListener listener)\n   {\n     mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener, listener);\n     if (mouseMotionListener != null)\n-      enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n+      enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);\n   }\n \n   /**\n@@ -2775,10 +2771,19 @@ public synchronized InputMethodListener[] getInputMethodListeners()\n   }\n \n   /**\n-   * Returns all registered EventListers of the given listenerType.\n+   * Returns all registered {@link EventListener}s of the given \n+   * <code>listenerType</code>.\n    *\n-   * @param listenerType the class of listeners to filter\n-   * @return an array of registered listeners\n+   * @param listenerType the class of listeners to filter (<code>null</code> \n+   *                     not permitted).\n+   *                     \n+   * @return An array of registered listeners.\n+   * \n+   * @throws ClassCastException if <code>listenerType</code> does not implement\n+   *                            the {@link EventListener} interface.\n+   * @throws NullPointerException if <code>listenerType</code> is \n+   *                              <code>null</code>.\n+   *                            \n    * @see #getComponentListeners()\n    * @see #getFocusListeners()\n    * @see #getHierarchyListeners()\n@@ -4786,7 +4791,12 @@ else if (e instanceof ActionEvent)\n   void dispatchEventImpl(AWTEvent e)\n   {\n     Event oldEvent = translateEvent (e);\n-\n+    // This boolean tells us not to process focus events when the focus\n+    // opposite component is the same as the focus component.\n+    boolean ignoreFocus = \n+      (e instanceof FocusEvent && \n+       ((FocusEvent)e).getComponent() == ((FocusEvent)e).getOppositeComponent());\n+    \n     if (oldEvent != null)\n       postEvent (oldEvent);\n \n@@ -4817,7 +4827,8 @@ void dispatchEventImpl(AWTEvent e)\n                 break;\n               }\n           }\n-        if (e.id != PaintEvent.PAINT && e.id != PaintEvent.UPDATE)\n+        if (e.id != PaintEvent.PAINT && e.id != PaintEvent.UPDATE\n+            && !ignoreFocus)\n           processEvent(e);\n       }\n \n@@ -4853,11 +4864,12 @@ boolean eventTypeEnabled (int type)\n       case MouseEvent.MOUSE_EXITED:\n       case MouseEvent.MOUSE_PRESSED:\n       case MouseEvent.MOUSE_RELEASED:\n-      case MouseEvent.MOUSE_MOVED:\n-      case MouseEvent.MOUSE_DRAGGED:\n         return (mouseListener != null\n-                || mouseMotionListener != null\n                 || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0);\n+      case MouseEvent.MOUSE_MOVED:\n+      case MouseEvent.MOUSE_DRAGGED:\n+        return (mouseMotionListener != null\n+                || (eventMask & AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0);\n         \n       case FocusEvent.FOCUS_GAINED:\n       case FocusEvent.FOCUS_LOST:"}, {"sha": "67f0ed184d4dae67f5be107c7ca34c5f676bab6a", "filename": "libjava/classpath/java/awt/Container.java", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -449,9 +449,6 @@ public void remove(int index)\n                                                    ContainerEvent.COMPONENT_REMOVED,\n                                                    r);\n             getToolkit().getSystemEventQueue().postEvent(ce);\n-\n-            // Repaint this container.\n-            repaint();\n           }\n       }\n   }\n@@ -896,13 +893,21 @@ public synchronized ContainerListener[] getContainerListeners()\n   }\n \n   /**\n-   * Returns an array of all the objects currently registered as FooListeners\n-   * upon this Container. FooListeners are registered using the addFooListener\n-   * method.\n-   *\n-   * @exception ClassCastException If listenerType doesn't specify a class or\n-   * interface that implements @see java.util.EventListener.\n+   * Returns all registered {@link EventListener}s of the given \n+   * <code>listenerType</code>.\n    *\n+   * @param listenerType the class of listeners to filter (<code>null</code> \n+   *                     not permitted).\n+   *                     \n+   * @return An array of registered listeners.\n+   * \n+   * @throws ClassCastException if <code>listenerType</code> does not implement\n+   *                            the {@link EventListener} interface.\n+   * @throws NullPointerException if <code>listenerType</code> is \n+   *                              <code>null</code>.\n+   *                            \n+   * @see #getContainerListeners()\n+   * \n    * @since 1.3\n    */\n   public EventListener[] getListeners(Class listenerType)\n@@ -1094,7 +1099,7 @@ Component findComponentForMouseEventAt(int x, int y)\n       {\n         if (!contains(x, y))\n           return null;\n-\n+          \n         for (int i = 0; i < ncomponents; ++i)\n           {\n             // Ignore invisible children...\n@@ -1117,7 +1122,8 @@ else if (component[i].contains(x2, y2))\n           }\n \n         //don't return transparent components with no MouseListeners\n-        if (this.getMouseListeners().length == 0)\n+        if (getMouseListeners().length == 0\n+            && getMouseMotionListeners().length == 0)\n           return null;\n         return this;\n       }\n@@ -1625,30 +1631,19 @@ private void visitChild(Graphics gfx, GfxVisitor visitor,\n                           Component comp)\n   {\n     Rectangle bounds = comp.getBounds();\n-    Rectangle oldClip = gfx.getClipBounds();\n-    if (oldClip == null)\n-      oldClip = bounds;\n-\n-    Rectangle clip = oldClip.intersection(bounds);\n \n-    if (clip.isEmpty()) return;\n+    if(!gfx.hitClip(bounds.x,bounds.y, bounds.width, bounds.height))\n+      return;\n \n-    boolean clipped = false;\n-    boolean translated = false;\n+    Graphics g2 = gfx.create(bounds.x, bounds.y, bounds.width,\n+                             bounds.height);\n     try\n       {\n-        gfx.setClip(clip.x, clip.y, clip.width, clip.height);\n-        clipped = true;\n-        gfx.translate(bounds.x, bounds.y);\n-        translated = true;\n-        visitor.visit(comp, gfx);\n+        visitor.visit(comp, g2);\n       }\n     finally\n       {\n-        if (translated)\n-          gfx.translate (-bounds.x, -bounds.y);\n-        if (clipped)\n-          gfx.setClip (oldClip.x, oldClip.y, oldClip.width, oldClip.height);\n+        g2.dispose();\n       }\n   }\n \n@@ -2148,12 +2143,18 @@ Component acquireComponentForMouseEvent(MouseEvent me)\n         break;\n       }\n \n-    if (me.getID() == MouseEvent.MOUSE_PRESSED && modifiers > 0\n+    if (me.getID() == MouseEvent.MOUSE_RELEASED\n+        || me.getID() == MouseEvent.MOUSE_PRESSED && modifiers > 0\n         || me.getID() == MouseEvent.MOUSE_DRAGGED)\n       {\n         // If any of the following events occur while a button is held down,\n         // they should be dispatched to the same component to which the\n         // original MOUSE_PRESSED event was dispatched:\n+        //   - MOUSE_RELEASED: This is important for correct dragging\n+        //     behaviour, otherwise the release goes to an arbitrary component\n+        //     outside of the dragged component. OTOH, if there is no mouse\n+        //     drag while the mouse is pressed, the component under the mouse\n+        //     is the same as the previously pressed component anyway.\n         //   - MOUSE_PRESSED: another button pressed while the first is held\n         //     down\n         //   - MOUSE_DRAGGED"}, {"sha": "714e080d7b29925a10f88aa4686a68be47030f09", "filename": "libjava/classpath/java/awt/GridBagLayout.java", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FGridBagLayout.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -341,11 +341,14 @@ protected void ArrangeGrid (Container parent)\n       GridBagLayoutInfo info = getLayoutInfo (parent, PREFERREDSIZE);\n       if (info.cols == 0 && info.rows == 0)\n         return;\n-      layoutInfo = info;\n \n       // DEBUG\n-      //dumpLayoutInfo (layoutInfo);\n-    \n+      //dumpLayoutInfo (info);\n+\n+      // Calling setBounds on these components causes this layout to\n+      // be invalidated, clearing the layout information cache,\n+      // layoutInfo.  So we wait until after this for loop to set\n+      // layoutInfo.\n       for(int i = 0; i < components.length; i++)\n \t{\n           Component component = components [i];\n@@ -357,11 +360,11 @@ protected void ArrangeGrid (Container parent)\n           GridBagConstraints constraints =\n               lookupInternalConstraints(component);\n \n-          int cellx = sumIntArray(layoutInfo.colWidths, constraints.gridx);\n-          int celly = sumIntArray(layoutInfo.rowHeights, constraints.gridy);\n-          int cellw = sumIntArray(layoutInfo.colWidths,\n+          int cellx = sumIntArray(info.colWidths, constraints.gridx);\n+          int celly = sumIntArray(info.rowHeights, constraints.gridy);\n+          int cellw = sumIntArray(info.colWidths,\n                                   constraints.gridx + constraints.gridwidth) - cellx;\n-          int cellh = sumIntArray(layoutInfo.rowHeights,\n+          int cellh = sumIntArray(info.rowHeights,\n                                   constraints.gridy + constraints.gridheight) - celly;\n \n           Insets insets = constraints.insets;\n@@ -438,11 +441,14 @@ protected void ArrangeGrid (Container parent)\n               break;\n \t    }\n \n-          component.setBounds(layoutInfo.pos_x + x, layoutInfo.pos_y + y, dim.width, dim.height);\n+          component.setBounds(info.pos_x + x, info.pos_y + y, dim.width, dim.height);\n \t}\n \n       // DEBUG\n-      //dumpLayoutInfo (layoutInfo);\n+      //dumpLayoutInfo (info);\n+\n+      // Cache layout information.\n+      layoutInfo = getLayoutInfo (parent, PREFERREDSIZE);\n     }\n \n     /**"}, {"sha": "32bf4d6cf37b5f3b868bac5df1647cf267948877", "filename": "libjava/classpath/java/awt/datatransfer/DataFlavor.java", "status": "modified", "additions": 817, "deletions": 887, "changes": 1704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,5 +1,5 @@\n /* DataFlavor.java -- A type of data to transfer via the clipboard.\n-   Copyright (C) 1999, 2001, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -49,6 +49,7 @@\n import java.io.UnsupportedEncodingException;\n import java.nio.ByteBuffer;\n import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n import java.rmi.Remote;\n \n /**\n@@ -63,956 +64,828 @@ public class DataFlavor implements java.io.Externalizable, Cloneable\n \n   // FIXME: Serialization: Need to write methods for.\n \n-/**\n- * This is the data flavor used for tranferring plain text.  The MIME\n- * type is \"text/plain; charset=unicode\".  The representation class\n- * is <code>java.io.InputStream</code>.\n- *\n- * @deprecated The charset unicode is platform specific and InputStream\n- * deals with bytes not chars. Use <code>getRederForText()</code>.\n- */\n-public static final DataFlavor plainTextFlavor;\n-\n-/**\n- * This is the data flavor used for transferring Java strings.  The\n- * MIME type is \"application/x-java-serialized-object\" and the \n- * representation class is <code>java.lang.String</code>.\n- */\n-public static final DataFlavor stringFlavor;\n-\n-/**\n- * This is a data flavor used for transferring lists of files.  The\n- * representation type is a <code>java.util.List</code>, with each element of \n- * the list being a <code>java.io.File</code>.\n- */\n-public static final DataFlavor javaFileListFlavor;\n-\n-/**\n- * This is an image flavor used for transferring images.  The\n- * representation type is a <code>java.awt.Image</code>.\n- */\n-public static final DataFlavor imageFlavor;\n-\n-/**\n- * This is the MIME type used for transferring a serialized object.\n- * The representation class is the type of object be deserialized.\n- */\n-public static final String javaSerializedObjectMimeType =\n-  \"application/x-java-serialized-object\";\n-\n-/**\n- * This is the MIME type used to transfer a Java object reference within\n- * the same JVM.  The representation class is the class of the object\n- * being transferred.\n- */\n-public static final String javaJVMLocalObjectMimeType =\n-  \"application/x-java-jvm-local-objectref\";\n-\n-/**\n- * This is the MIME type used to transfer a link to a remote object.\n- * The representation class is the type of object being linked to.\n- */\n-public static final String javaRemoteObjectMimeType =\n-  \"application/x-java-remote-object\";\n-\n-static\n-{\n-  plainTextFlavor\n-      = new DataFlavor(java.io.InputStream.class,\n-\t\t       \"text/plain; charset=unicode\",\n-\t\t       \"plain unicode text\");\n-\n-  stringFlavor\n-      = new DataFlavor(java.lang.String.class,\n-\t\t       \"Java Unicode String\");\n-\n-  javaFileListFlavor\n-      = new DataFlavor(java.util.List.class,\n-\t\t       \"application/x-java-file-list; class=java.util.List\",\n-\t\t       \"Java File List\");\n-\n-  imageFlavor\n-      = new DataFlavor(java.awt.Image.class,\n-                       \"Java Image\");\n-}\n-\n-/*************************************************************************/\n+  /**\n+   * This is the data flavor used for tranferring plain text.  The MIME\n+   * type is \"text/plain; charset=unicode\".  The representation class\n+   * is <code>java.io.InputStream</code>.\n+   *\n+   * @deprecated The charset unicode is platform specific and InputStream\n+   * deals with bytes not chars. Use <code>getRederForText()</code>.\n+   */\n+  public static final DataFlavor plainTextFlavor = \n+    new DataFlavor(java.io.InputStream.class,\n+                   \"text/plain; charset=unicode\",\n+                   \"plain unicode text\");\n \n-/*\n- * Instance Variables\n- */\n+  /**\n+   * This is the data flavor used for transferring Java strings.  The\n+   * MIME type is \"application/x-java-serialized-object\" and the \n+   * representation class is <code>java.lang.String</code>.\n+   */\n+  public static final DataFlavor stringFlavor = \n+    new DataFlavor(java.lang.String.class, \"Java Unicode String\");\n \n-// The MIME type for this flavor\n-private final String mimeType;\n+  /**\n+   * This is a data flavor used for transferring lists of files.  The\n+   * representation type is a <code>java.util.List</code>, with each \n+   * element of the list being a <code>java.io.File</code>.\n+   */\n+  public static final DataFlavor javaFileListFlavor = \n+    new DataFlavor(java.util.List.class,\n+                   \"application/x-java-file-list; class=java.util.List\",\n+                   \"Java File List\");\n \n-// The representation class for this flavor\n-private final Class representationClass;\n+  /**\n+   * This is an image flavor used for transferring images.  The\n+   * representation type is a <code>java.awt.Image</code>.\n+   */\n+  public static final DataFlavor imageFlavor = \n+    new DataFlavor(java.awt.Image.class, \"Java Image\");\n \n-// The human readable name of this flavor\n-private String humanPresentableName;\n+  /**\n+   * This is the MIME type used for transferring a serialized object.\n+   * The representation class is the type of object be deserialized.\n+   */\n+  public static final String javaSerializedObjectMimeType =\n+    \"application/x-java-serialized-object\";\n \n-/*************************************************************************/\n+  /**\n+   * This is the MIME type used to transfer a Java object reference within\n+   * the same JVM.  The representation class is the class of the object\n+   * being transferred.\n+   */\n+  public static final String javaJVMLocalObjectMimeType =\n+    \"application/x-java-jvm-local-objectref\";\n \n-/*\n- * Static Methods\n- */\n+  /**\n+   * This is the MIME type used to transfer a link to a remote object.\n+   * The representation class is the type of object being linked to.\n+   */\n+  public static final String javaRemoteObjectMimeType =\n+    \"application/x-java-remote-object\";\n \n-/**\n- * This method attempts to load the named class.  The following class\n- * loaders are searched in order: the bootstrap class loader, the\n- * system class loader, the context class loader (if it exists), and\n- * the specified fallback class loader.\n- *\n- * @param className The name of the class to load.\n- * @param classLoader The class loader to use if all others fail, which\n- * may be <code>null</code>.\n- *\n- * @exception ClassNotFoundException If the class cannot be loaded.\n- */\n-protected static final Class\n-tryToLoadClass(String className, ClassLoader classLoader)\n-               throws ClassNotFoundException\n-{\n-  try\n-    {\n-      return(Class.forName(className));\n-    }\n-  catch(Exception e) { ; }\n-  // Commented out for Java 1.1\n   /*\n-  try\n-    {\n-      return(className.getClass().getClassLoader().findClass(className));\n-    }\n-  catch(Exception e) { ; }\n-\n-  try\n-    {\n-      return(ClassLoader.getSystemClassLoader().findClass(className));\n-    }\n-  catch(Exception e) { ; }\n-  */\n+   * Instance Variables\n+   */\n+  \n+  // The MIME type for this flavor\n+  private final String mimeType;\n+  \n+  // The representation class for this flavor\n+  private final Class representationClass;\n+  \n+  // The human readable name of this flavor\n+  private String humanPresentableName;\n \n-  // FIXME: What is the context class loader?\n   /*\n-  try\n+   * Static Methods\n+   */\n+  \n+  /**\n+   * This method attempts to load the named class.  The following class\n+   * loaders are searched in order: the bootstrap class loader, the\n+   * system class loader, the context class loader (if it exists), and\n+   * the specified fallback class loader.\n+   *\n+   * @param className The name of the class to load.\n+   * @param classLoader The class loader to use if all others fail, which\n+   * may be <code>null</code>.\n+   *\n+   * @exception ClassNotFoundException If the class cannot be loaded.\n+   */\n+  protected static final Class tryToLoadClass(String className,\n+                                             ClassLoader classLoader)\n+    throws ClassNotFoundException\n+  {\n+    try\n+      {\n+        return(Class.forName(className));\n+      }\n+    catch(Exception e) { ; }\n+    // Commented out for Java 1.1\n+    /*\n+    try\n+      {\n+        return(className.getClass().getClassLoader().findClass(className));\n+      }\n+    catch(Exception e) { ; }\n+  \n+    try\n+      {\n+        return(ClassLoader.getSystemClassLoader().findClass(className));\n+      }\n+    catch(Exception e) { ; }\n+    */\n+  \n+    // FIXME: What is the context class loader?\n+    /*\n+    try\n+      {\n+      }\n+    catch(Exception e) { ; }\n+    */\n+  \n+    if (classLoader != null)\n+      return(classLoader.loadClass(className));\n+    else\n+      throw new ClassNotFoundException(className);\n+  }\n+  \n+  private static Class getRepresentationClassFromMime(String mimeString,\n+                                                      ClassLoader classLoader)\n     {\n+      String classname = getParameter(\"class\", mimeString);\n+      if (classname != null)\n+        {\n+          try\n+            {\n+              return tryToLoadClass(classname, classLoader);\n+            }\n+          catch(Exception e)\n+            {\n+              throw new IllegalArgumentException(\"classname: \" + e.getMessage());\n+            }\n+        }\n+      else\n+        return java.io.InputStream.class;\n     }\n-  catch(Exception e) { ; }\n-  */\n-\n-  if (classLoader != null)\n-    return(classLoader.loadClass(className));\n-  else\n-    throw new ClassNotFoundException(className);\n-}\n-\n-/*************************************************************************/\n+  \n+  /**\n+   * Returns the value of the named MIME type parameter, or <code>null</code>\n+   * if the parameter does not exist. Given the parameter name and the mime\n+   * string.\n+   *\n+   * @param paramName The name of the parameter.\n+   * @param mimeString The mime string from where the name should be found.\n+   *\n+   * @return The value of the parameter or null.\n+   */\n+  private static String getParameter(String paramName, String mimeString)\n+  {\n+    int idx = mimeString.indexOf(paramName + \"=\");\n+    if (idx == -1)\n+      return(null);\n+  \n+    String value = mimeString.substring(idx + paramName.length() + 1);\n+  \n+    idx = value.indexOf(\" \");\n+    if (idx == -1)\n+      return(value);\n+    else\n+      return(value.substring(0, idx));\n+  }\n+  \n+  /**\n+   * XXX - Currently returns <code>plainTextFlavor</code>.\n+   */\n+  public static final DataFlavor getTextPlainUnicodeFlavor()\n+  {\n+    return plainTextFlavor;\n+  }\n+  \n+  /**\n+   * Selects the best supported text flavor on this implementation.\n+   * Returns <code>null</code> when none of the given flavors is liked.\n+   *\n+   * The <code>DataFlavor</code> returned the first data flavor in the\n+   * array that has either a representation class which is (a subclass of)\n+   * <code>Reader</code> or <code>String</code>, or has a representation\n+   * class which is (a subclass of) <code>InputStream</code> and has a\n+   * primary MIME type of \"text\" and has an supported encoding.\n+   */\n+  public static final DataFlavor \n+    selectBestTextFlavor(DataFlavor[] availableFlavors)\n+  {\n+    for(int i = 0; i < availableFlavors.length; i++)\n+      {\n+        DataFlavor df = availableFlavors[i];\n+        Class c = df.representationClass;\n+  \n+        // A Reader or String is good.\n+        if ((Reader.class.isAssignableFrom(c))\n+           || (String.class.isAssignableFrom(c)))\n+      return df;\n+  \n+        // A InputStream is good if the mime primary type is \"text\"\n+        if ((InputStream.class.isAssignableFrom(c))\n+           && (\"text\".equals(df.getPrimaryType())))\n+          {\n+            String encoding = availableFlavors[i].getParameter(\"charset\");\n+            if (encoding == null)\n+              encoding = \"us-ascii\";\n+            Reader r = null;\n+            try\n+              {\n+                // Try to construct a dummy reader with the found encoding\n+                r = new InputStreamReader\n+                      (new ByteArrayInputStream(new byte[0]), encoding);\n+              }\n+            catch(UnsupportedEncodingException uee) { /* ignore */ }\n+\n+            if (r != null)\n+              return df;\n+          }\n+      }\n+  \n+    // Nothing found\n+    return null;\n+  }\n \n-/*\n- * Constructors\n- */\n \n-/**\n- * Empty public constructor needed for externalization.\n- * Should not be used for normal instantiation.\n- */\n-public\n-DataFlavor()\n-{\n+  /*\n+   * Constructors\n+   */\n+  \n+  /**\n+   * Empty public constructor needed for externalization.\n+   * Should not be used for normal instantiation.\n+   */\n+  public DataFlavor()\n+  {\n     mimeType = null;\n     representationClass = null;\n     humanPresentableName = null;\n-}\n-\n-/*************************************************************************/\n+  }\n \n-/**\n- * Private constructor.\n- */\n-private\n-DataFlavor(Class representationClass,\n-\t   String mimeType,\n-\t   String humanPresentableName)\n-{\n+  /**\n+   * Private constructor.\n+   */\n+  private DataFlavor(Class representationClass,\n+                    String mimeType,\n+                    String humanPresentableName)\n+  {\n     this.representationClass = representationClass;\n     this.mimeType = mimeType;\n     if (humanPresentableName != null)\n-\tthis.humanPresentableName = humanPresentableName;\n+      this.humanPresentableName = humanPresentableName;\n     else\n-\tthis.humanPresentableName = mimeType;\n-}\n-\n-/*************************************************************************/\n+      this.humanPresentableName = mimeType;\n+  }\n \n-/**\n- * Initializes a new instance of <code>DataFlavor</code>.  The class\n- * and human readable name are specified, the MIME type will be\n- * \"application/x-java-serialized-object\". If the human readable name\n- * is not specified (<code>null</code>) then the human readable name\n- * will be the same as the MIME type.\n- *\n- * @param representationClass The representation class for this object.\n- * @param humanPresentableName The display name of the object.\n- */\n-public\n-DataFlavor(Class representationClass, String humanPresentableName)\n-{\n+  /**\n+   * Initializes a new instance of <code>DataFlavor</code>.  The class\n+   * and human readable name are specified, the MIME type will be\n+   * \"application/x-java-serialized-object\". If the human readable name\n+   * is not specified (<code>null</code>) then the human readable name\n+   * will be the same as the MIME type.\n+   *\n+   * @param representationClass The representation class for this object.\n+   * @param humanPresentableName The display name of the object.\n+   */\n+  public DataFlavor(Class representationClass, String humanPresentableName)\n+  {\n     this(representationClass,\n-       \"application/x-java-serialized-object\"\n-       + \"; class=\"\n-       + representationClass.getName(),\n-       humanPresentableName);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Initializes a new instance of <code>DataFlavor</code> with the\n- * specified MIME type and description.  If the MIME type has a\n- * \"class=&lt;rep class&gt;\" parameter then the representation class will\n- * be the class name specified. Otherwise the class defaults to\n- * <code>java.io.InputStream</code>. If the human readable name\n- * is not specified (<code>null</code>) then the human readable name\n- * will be the same as the MIME type.\n- *\n- * @param mimeType The MIME type for this flavor.\n- * @param humanPresentableName The display name of this flavor.\n- * @param classLoader The class loader for finding classes if the default\n- * class loaders do not work.\n- *\n- * @exception IllegalArgumentException If the representation class\n- * specified cannot be loaded.\n- * @exception ClassNotFoundException If the class is not loaded.\n- */\n-public\n-DataFlavor(String mimeType, String humanPresentableName, \n-           ClassLoader classLoader) throws ClassNotFoundException\n-{\n-  this(getRepresentationClassFromMime(mimeType, classLoader),\n-       mimeType, humanPresentableName);\n-}\n-\n-private static Class\n-getRepresentationClassFromMime(String mimeString, ClassLoader classLoader)\n-{\n-  String classname = getParameter(\"class\", mimeString);\n-  if (classname != null)\n-    {\n-      try\n-        {\n-          return tryToLoadClass(classname, classLoader);\n-        }\n-      catch(Exception e)\n-        {\n-          throw new IllegalArgumentException(\"classname: \" + e.getMessage());\n-        }\n-    }\n-  else\n-    {\n-      return java.io.InputStream.class;\n-    }\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Initializes a new instance of <code>DataFlavor</code> with the\n- * specified MIME type and description.  If the MIME type has a\n- * \"class=&lt;rep class&gt;\" parameter then the representation class will\n- * be the class name specified. Otherwise the class defaults to\n- * <code>java.io.InputStream</code>. If the human readable name\n- * is not specified (<code>null</code>) then the human readable name\n- * will be the same as the MIME type. This is the same as calling\n- * <code>new DataFlavor(mimeType, humanPresentableName, null)</code>.\n- *\n- * @param mimeType The MIME type for this flavor.\n- * @param humanPresentableName The display name of this flavor.\n- *\n- * @exception IllegalArgumentException If the representation class\n- * specified cannot be loaded.\n- */\n-public\n-DataFlavor(String mimeType, String humanPresentableName)\n-{\n-  this (getRepresentationClassFromMime (mimeType, null),\n-\tmimeType, humanPresentableName);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Initializes a new instance of <code>DataFlavor</code> with the specified\n- * MIME type.  This type can have a \"class=\" parameter to specify the\n- * representation class, and then the class must exist or an exception will\n- * be thrown. If there is no \"class=\" parameter then the representation class\n- * will be <code>java.io.InputStream</code>. This is the same as calling\n- * <code>new DataFlavor(mimeType, null)</code>.\n- *\n- * @param mimeType The MIME type for this flavor.\n- *\n- * @exception IllegalArgumentException If a class is not specified in\n- * the MIME type.\n- * @exception ClassNotFoundException If the class cannot be loaded.\n- */\n-public\n-DataFlavor(String mimeType) throws ClassNotFoundException\n-{\n-  this(mimeType, null);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the MIME type of this flavor.\n- *\n- * @return The MIME type for this flavor.\n- */\n-public String\n-getMimeType()\n-{\n-  return(mimeType);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the representation class for this flavor.\n- *\n- * @return The representation class for this flavor.\n- */\n-public Class\n-getRepresentationClass()\n-{\n-  return(representationClass);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the human presentable name for this flavor.\n- *\n- * @return The human presentable name for this flavor.\n- */\n-public String\n-getHumanPresentableName()\n-{\n-  return(humanPresentableName);\n-} \n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the primary MIME type for this flavor.\n- *\n- * @return The primary MIME type for this flavor.\n- */\n-public String\n-getPrimaryType()\n-{\n-  int idx = mimeType.indexOf(\"/\");\n-  if (idx == -1)\n-    return(mimeType);\n-\n-  return(mimeType.substring(0, idx));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the MIME subtype for this flavor.\n- *\n- * @return The MIME subtype for this flavor.\n- */\n-public String\n-getSubType()\n-{\n-  int start = mimeType.indexOf(\"/\");\n-  if (start == -1)\n-    return \"\";\n-\n-  int end = mimeType.indexOf(\";\", start + 1);\n-  if (end == -1)\n-    return mimeType.substring(start + 1);\n-  else\n-    return mimeType.substring(start + 1, end);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the value of the named MIME type parameter, or <code>null</code>\n- * if the parameter does not exist. Given the parameter name and the mime\n- * string.\n- *\n- * @param paramName The name of the parameter.\n- * @param mimeString The mime string from where the name should be found.\n- *\n- * @return The value of the parameter or null.\n- */\n-private static String\n-getParameter(String paramName, String mimeString)\n-{\n-  int idx = mimeString.indexOf(paramName + \"=\");\n-  if (idx == -1)\n-    return(null);\n-\n-  String value = mimeString.substring(idx + paramName.length() + 1);\n-\n-  idx = value.indexOf(\" \");\n-  if (idx == -1)\n-    return(value);\n-  else\n-    return(value.substring(0, idx));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Returns the value of the named MIME type parameter, or <code>null</code>\n- * if the parameter does not exist.\n- *\n- * @param paramName The name of the paramter.\n- *\n- * @return The value of the parameter.\n- */\n-public String\n-getParameter(String paramName)\n-{\n-  if (\"humanPresentableName\".equals(paramName))\n-    return getHumanPresentableName();\n-\n-  return getParameter(paramName, mimeType);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Sets the human presentable name to the specified value.\n- *\n- * @param humanPresentableName The new display name.\n- */\n-public void\n-setHumanPresentableName(String humanPresentableName)\n-{\n-  this.humanPresentableName = humanPresentableName;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests the MIME type of this object for equality against the specified\n- * MIME type. Ignores parameters.\n- *\n- * @param mimeType The MIME type to test against.\n- *\n- * @return <code>true</code> if the MIME type is equal to this object's\n- * MIME type (ignoring parameters), <code>false</code> otherwise.\n- *\n- * @exception NullPointerException If mimeType is null.\n- */\n-public boolean\n-isMimeTypeEqual(String mimeType)\n-{\n-  String mime = getMimeType();\n-  int i = mime.indexOf(\";\");\n-  if (i != -1)\n-    mime = mime.substring(0, i);\n-\n-  i = mimeType.indexOf(\";\");\n-  if (i != -1)\n-    mimeType = mimeType.substring(0, i);\n-\n-  return mime.equals(mimeType);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests the MIME type of this object for equality against the specified\n- * data flavor's MIME type\n- *\n- * @param flavor The flavor to test against.\n- *\n- * @return <code>true</code> if the flavor's MIME type is equal to this \n- * object's MIME type, <code>false</code> otherwise.\n- */\n-public final boolean\n-isMimeTypeEqual(DataFlavor flavor)\n-{\n-  return(isMimeTypeEqual(flavor.getMimeType()));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether or not this flavor represents a serialized object.\n- *\n- * @return <code>true</code> if this flavor represents a serialized\n- * object, <code>false</code> otherwise.\n- */\n-public boolean\n-isMimeTypeSerializedObject()\n-{\n-  return(mimeType.startsWith(javaSerializedObjectMimeType));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether or not this flavor has a representation class of\n- * <code>java.io.InputStream</code>.\n- *\n- * @return <code>true</code> if the representation class of this flavor\n- * is <code>java.io.InputStream</code>, <code>false</code> otherwise.\n- */\n-public boolean\n-isRepresentationClassInputStream()\n-{\n-  return(representationClass.getName().equals(\"java.io.InputStream\"));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether the representation class for this flavor is\n- * serializable.\n- *\n- * @return <code>true</code> if the representation class is serializable,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-isRepresentationClassSerializable()\n-{\n-  Class[] interfaces = representationClass.getInterfaces();\n-\n-  int i = 0;\n-  while (i < interfaces.length)\n-    {\n-      if (interfaces[i].getName().equals(\"java.io.Serializable\"))\n-        return(true);\n-      ++i;\n-    }\n-\n-  return(false);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether the representation class for his flavor is remote.\n- *\n- * @return <code>true</code> if the representation class is remote,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-isRepresentationClassRemote()\n-{\n-  return Remote.class.isAssignableFrom (representationClass);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether or not this flavor represents a serialized object.\n- *\n- * @return <code>true</code> if this flavor represents a serialized\n- * object, <code>false</code> otherwise.\n- */\n-public boolean\n-isFlavorSerializedObjectType()\n-{\n-  // FIXME: What is the diff between this and isMimeTypeSerializedObject?\n-  return(mimeType.startsWith(javaSerializedObjectMimeType));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether or not this flavor represents a remote object.\n- *\n- * @return <code>true</code> if this flavor represents a remote object,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-isFlavorRemoteObjectType()\n-{\n-  return(mimeType.startsWith(javaRemoteObjectMimeType));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Tests whether or not this flavor represents a list of files.\n- *\n- * @return <code>true</code> if this flavor represents a list of files,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-isFlavorJavaFileListType()\n-{\n-  if (this.mimeType.equals(javaFileListFlavor.mimeType) &&\n-      this.representationClass.equals(javaFileListFlavor.representationClass))\n-    return(true);\n-\n-  return(false);\n-}\n-\n-/*************************************************************************/\n+         \"application/x-java-serialized-object\"\n+         + \"; class=\"\n+         + representationClass.getName(),\n+         humanPresentableName);\n+  }\n \n-/**\n- * Returns a copy of this object.\n- *\n- * @return A copy of this object.\n- *\n- * @exception CloneNotSupportedException If the object's class does not support\n- * the Cloneable interface. Subclasses that override the clone method can also\n- * throw this exception to indicate that an instance cannot be cloned.\n- */\n-public Object clone () throws CloneNotSupportedException\n-{\n-  try\n-    {\n-      return(super.clone());\n-    }\n-  catch(Exception e)\n-    {\n-      return(null);\n-    }\n-}\n+  /**\n+   * Initializes a new instance of <code>DataFlavor</code> with the\n+   * specified MIME type and description.  If the MIME type has a\n+   * \"class=&lt;rep class&gt;\" parameter then the representation class will\n+   * be the class name specified. Otherwise the class defaults to\n+   * <code>java.io.InputStream</code>. If the human readable name\n+   * is not specified (<code>null</code>) then the human readable name\n+   * will be the same as the MIME type.\n+   *\n+   * @param mimeType The MIME type for this flavor.\n+   * @param humanPresentableName The display name of this flavor.\n+   * @param classLoader The class loader for finding classes if the default\n+   * class loaders do not work.\n+   *\n+   * @exception IllegalArgumentException If the representation class\n+   * specified cannot be loaded.\n+   * @exception ClassNotFoundException If the class is not loaded.\n+   */\n+  public DataFlavor(String mimeType, String humanPresentableName, \n+                   ClassLoader classLoader)\n+    throws ClassNotFoundException\n+  {\n+    this(getRepresentationClassFromMime(mimeType, classLoader),\n+         mimeType, humanPresentableName);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Initializes a new instance of <code>DataFlavor</code> with the\n+   * specified MIME type and description.  If the MIME type has a\n+   * \"class=&lt;rep class&gt;\" parameter then the representation class will\n+   * be the class name specified. Otherwise the class defaults to\n+   * <code>java.io.InputStream</code>. If the human readable name\n+   * is not specified (<code>null</code>) then the human readable name\n+   * will be the same as the MIME type. This is the same as calling\n+   * <code>new DataFlavor(mimeType, humanPresentableName, null)</code>.\n+   *\n+   * @param mimeType The MIME type for this flavor.\n+   * @param humanPresentableName The display name of this flavor.\n+   *\n+   * @exception IllegalArgumentException If the representation class\n+   * specified cannot be loaded.\n+   */\n+  public DataFlavor(String mimeType, String humanPresentableName)\n+  {\n+    this(getRepresentationClassFromMime (mimeType, null),\n+        mimeType, humanPresentableName);\n+  }\n \n-/**\n- * This method test the specified <code>DataFlavor</code> for equality\n- * against this object.  This will be true if the MIME type and\n- * representation type are the equal.\n- *\n- * @param flavor The <code>DataFlavor</code> to test against.\n- *\n- * @return <code>true</code> if the flavor is equal to this object,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-equals(DataFlavor flavor)\n-{\n-  if (flavor == null)\n-    return(false);\n+  /**\n+   * Initializes a new instance of <code>DataFlavor</code> with the specified\n+   * MIME type.  This type can have a \"class=\" parameter to specify the\n+   * representation class, and then the class must exist or an exception will\n+   * be thrown. If there is no \"class=\" parameter then the representation class\n+   * will be <code>java.io.InputStream</code>. This is the same as calling\n+   * <code>new DataFlavor(mimeType, null)</code>.\n+   *\n+   * @param mimeType The MIME type for this flavor.\n+   *\n+   * @exception IllegalArgumentException If a class is not specified in\n+   * the MIME type.\n+   * @exception ClassNotFoundException If the class cannot be loaded.\n+   */\n+  public DataFlavor(String mimeType) throws ClassNotFoundException\n+  {\n+    this(mimeType, null);\n+  }\n \n-  if (!this.mimeType.toLowerCase().equals(flavor.mimeType.toLowerCase()))\n-    return(false);\n+  /**\n+   * Returns the MIME type of this flavor.\n+   *\n+   * @return The MIME type for this flavor.\n+   */\n+  public String getMimeType()\n+  {\n+    return(mimeType);\n+  }\n \n-  if (!this.representationClass.equals(flavor.representationClass))\n-    return(false);\n+  /**\n+   * Returns the representation class for this flavor.\n+   *\n+   * @return The representation class for this flavor.\n+   */\n+  public Class getRepresentationClass()\n+  {\n+    return(representationClass);\n+  }\n \n-  return(true);\n-}\n+  /**\n+   * Returns the human presentable name for this flavor.\n+   *\n+   * @return The human presentable name for this flavor.\n+   */\n+  public String getHumanPresentableName()\n+  {\n+    return(humanPresentableName);\n+  } \n \n-/*************************************************************************/\n+  /**\n+   * Returns the primary MIME type for this flavor.\n+   *\n+   * @return The primary MIME type for this flavor.\n+   */\n+  public String getPrimaryType()\n+  {\n+    int idx = mimeType.indexOf(\"/\");\n+    if (idx == -1)\n+      return(mimeType);\n+  \n+    return(mimeType.substring(0, idx));\n+  }\n \n-/**\n- * This method test the specified <code>Object</code> for equality\n- * against this object.  This will be true if the following conditions\n- * are met:\n- * <p>\n- * <ul>\n- * <li>The object is not <code>null</code>.</li>\n- * <li>The object is an instance of <code>DataFlavor</code>.</li>\n- * <li>The object's MIME type and representation class are equal to\n- * this object's.</li>\n- * </ul>\n- *\n- * @param obj The <code>Object</code> to test against.\n- *\n- * @return <code>true</code> if the flavor is equal to this object,\n- * <code>false</code> otherwise.\n- */\n-public boolean\n-equals(Object obj)\n-{\n-  if (!(obj instanceof DataFlavor))\n-    return(false);\n+  /**\n+   * Returns the MIME subtype for this flavor.\n+   *\n+   * @return The MIME subtype for this flavor.\n+   */\n+  public String getSubType()\n+  {\n+    int start = mimeType.indexOf(\"/\");\n+    if (start == -1)\n+      return \"\";\n+  \n+    int end = mimeType.indexOf(\";\", start + 1);\n+    if (end == -1)\n+      return mimeType.substring(start + 1);\n+    else\n+      return mimeType.substring(start + 1, end);\n+  }\n \n-  return(equals((DataFlavor)obj));\n-}\n+  /**\n+   * Returns the value of the named MIME type parameter, or <code>null</code>\n+   * if the parameter does not exist.\n+   *\n+   * @param paramName The name of the paramter.\n+   *\n+   * @return The value of the parameter.\n+   */\n+  public String getParameter(String paramName)\n+  {\n+    if (\"humanPresentableName\".equals(paramName))\n+      return getHumanPresentableName();\n+  \n+    return getParameter(paramName, mimeType);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Sets the human presentable name to the specified value.\n+   *\n+   * @param humanPresentableName The new display name.\n+   */\n+  public void setHumanPresentableName(String humanPresentableName)\n+  {\n+    this.humanPresentableName = humanPresentableName;\n+  }\n \n-/**\n- * Tests whether or not the specified string is equal to the MIME type\n- * of this object.\n- *\n- * @param str The string to test against.\n- *\n- * @return <code>true</code> if the string is equal to this object's MIME\n- * type, <code>false</code> otherwise.\n- *\n- * @deprecated Not compatible with <code>hashCode()</code>.\n- *             Use <code>isMimeTypeEqual()</code>\n- */\n-public boolean\n-equals(String str)\n-{\n-  return(isMimeTypeEqual(str));\n-}\n+  /**\n+   * Tests the MIME type of this object for equality against the specified\n+   * MIME type. Ignores parameters.\n+   *\n+   * @param mimeType The MIME type to test against.\n+   *\n+   * @return <code>true</code> if the MIME type is equal to this object's\n+   * MIME type (ignoring parameters), <code>false</code> otherwise.\n+   *\n+   * @exception NullPointerException If mimeType is null.\n+   */\n+  public boolean isMimeTypeEqual(String mimeType)\n+  {\n+    String mime = getMimeType();\n+    int i = mime.indexOf(\";\");\n+    if (i != -1)\n+      mime = mime.substring(0, i);\n+  \n+    i = mimeType.indexOf(\";\");\n+    if (i != -1)\n+      mimeType = mimeType.substring(0, i);\n+  \n+    return mime.equals(mimeType);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Tests the MIME type of this object for equality against the specified\n+   * data flavor's MIME type\n+   *\n+   * @param flavor The flavor to test against.\n+   *\n+   * @return <code>true</code> if the flavor's MIME type is equal to this \n+   * object's MIME type, <code>false</code> otherwise.\n+   */\n+  public final boolean isMimeTypeEqual(DataFlavor flavor)\n+  {\n+    return isMimeTypeEqual(flavor.getMimeType());\n+  }\n \n-/**\n- * Returns the hash code for this data flavor.\n- * The hash code is based on the (lower case) mime type and the\n- * representation class.\n- */\n-public int\n-hashCode()\n-{\n-  return(mimeType.toLowerCase().hashCode()^representationClass.hashCode());\n-}\n+  /**\n+   * Tests whether or not this flavor represents a serialized object.\n+   *\n+   * @return <code>true</code> if this flavor represents a serialized\n+   * object, <code>false</code> otherwise.\n+   */\n+  public boolean isMimeTypeSerializedObject()\n+  {\n+    return mimeType.startsWith(javaSerializedObjectMimeType);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Tests whether or not this flavor has a representation class of\n+   * <code>java.io.InputStream</code>.\n+   *\n+   * @return <code>true</code> if the representation class of this flavor\n+   * is <code>java.io.InputStream</code>, <code>false</code> otherwise.\n+   */\n+  public boolean isRepresentationClassInputStream()\n+  {\n+    return representationClass.getName().equals(\"java.io.InputStream\");\n+  }\n \n-/**\n- * Returns <code>true</code> when the given <code>DataFlavor</code>\n- * matches this one.\n- */\n-public boolean\n-match(DataFlavor dataFlavor)\n-{\n-  // XXX - How is this different from equals?\n-  return(equals(dataFlavor));\n-}\n+  /**\n+   * Tests whether the representation class for this flavor is\n+   * serializable.\n+   *\n+   * @return <code>true</code> if the representation class is serializable,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean isRepresentationClassSerializable()\n+  {\n+    Class[] interfaces = representationClass.getInterfaces();\n+  \n+    int i = 0;\n+    while (i < interfaces.length)\n+      {\n+        if (interfaces[i].getName().equals(\"java.io.Serializable\"))\n+          return true;\n+        ++i;\n+      }\n+  \n+    return false;\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Tests whether the representation class for his flavor is remote.\n+   *\n+   * @return <code>true</code> if the representation class is remote,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean isRepresentationClassRemote()\n+  {\n+    return Remote.class.isAssignableFrom (representationClass);\n+  }\n \n-/**\n- * This method exists for backward compatibility.  It simply returns\n- * the same name/value pair passed in.\n- *\n- * @param name The parameter name.\n- * @param value The parameter value.\n- *\n- * @return The name/value pair.\n- *\n- * @deprecated\n- */\n-protected String\n-normalizeMimeTypeParameter(String name, String value)\n-{\n-  return(name + \"=\" + value);\n-}\n+  /**\n+   * Tests whether or not this flavor represents a serialized object.\n+   *\n+   * @return <code>true</code> if this flavor represents a serialized\n+   * object, <code>false</code> otherwise.\n+   */\n+  public boolean isFlavorSerializedObjectType()\n+  {\n+    // FIXME: What is the diff between this and isMimeTypeSerializedObject?\n+    return(mimeType.startsWith(javaSerializedObjectMimeType));\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Tests whether or not this flavor represents a remote object.\n+   *\n+   * @return <code>true</code> if this flavor represents a remote object,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean isFlavorRemoteObjectType()\n+  {\n+    return(mimeType.startsWith(javaRemoteObjectMimeType));\n+  }\n \n-/**\n- * This method exists for backward compatibility.  It simply returns\n- * the MIME type string unchanged.\n- *\n- * @param type The MIME type.\n- * \n- * @return The MIME type.\n- *\n- * @deprecated\n- */\n-protected String\n-normalizeMimeType(String type)\n-{\n-  return(type);\n-}\n+  /**\n+   * Tests whether or not this flavor represents a list of files.\n+   *\n+   * @return <code>true</code> if this flavor represents a list of files,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean isFlavorJavaFileListType()\n+  {\n+    if (mimeType.equals(javaFileListFlavor.mimeType)\n+        && representationClass.equals(javaFileListFlavor.representationClass))\n+      return true;\n+  \n+    return false ;\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Returns a copy of this object.\n+   *\n+   * @return A copy of this object.\n+   *\n+   * @exception CloneNotSupportedException If the object's class does not support\n+   * the Cloneable interface. Subclasses that override the clone method can also\n+   * throw this exception to indicate that an instance cannot be cloned.\n+   */\n+  public Object clone () throws CloneNotSupportedException\n+  {\n+    // FIXME - This cannot be right.\n+    try\n+      {\n+        return super.clone();\n+      }\n+    catch(Exception e)\n+      {\n+        return null;\n+      }\n+  }\n \n-/**\n- * Serialize this class.\n- *\n- * @param stream The <code>ObjectOutput</code> stream to serialize to.\n- *\n- * @exception IOException If an error occurs.\n- */\n-public void\n-writeExternal(ObjectOutput stream) throws IOException\n-{\n-  // FIXME: Implement me\n-}\n+  /**\n+   * This method test the specified <code>DataFlavor</code> for equality\n+   * against this object.  This will be true if the MIME type and\n+   * representation type are the equal.\n+   *\n+   * @param flavor The <code>DataFlavor</code> to test against.\n+   *\n+   * @return <code>true</code> if the flavor is equal to this object,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean equals(DataFlavor flavor)\n+  {\n+    if (flavor == null)\n+      return false;\n+  \n+    if (! this.mimeType.toLowerCase().equals(flavor.mimeType.toLowerCase()))\n+      return false;\n+  \n+    if (! this.representationClass.equals(flavor.representationClass))\n+      return false;\n+  \n+    return true;\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * This method test the specified <code>Object</code> for equality\n+   * against this object.  This will be true if the following conditions\n+   * are met:\n+   * <p>\n+   * <ul>\n+   * <li>The object is not <code>null</code>.</li>\n+   * <li>The object is an instance of <code>DataFlavor</code>.</li>\n+   * <li>The object's MIME type and representation class are equal to\n+   * this object's.</li>\n+   * </ul>\n+   *\n+   * @param obj The <code>Object</code> to test against.\n+   *\n+   * @return <code>true</code> if the flavor is equal to this object,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean equals(Object obj)\n+  {\n+    if (! (obj instanceof DataFlavor))\n+      return false;\n+  \n+    return equals((DataFlavor) obj);\n+  }\n \n-/**\n- * De-serialize this class.\n- *\n- * @param stream The <code>ObjectInput</code> stream to deserialize from.\n- *\n- * @exception IOException If an error ocurs.\n- * @exception ClassNotFoundException If the class for an object being restored\n- * cannot be found.\n- */\n-public void\n-readExternal(ObjectInput stream) throws IOException, ClassNotFoundException\n-{\n-  // FIXME: Implement me\n-}\n+  /**\n+   * Tests whether or not the specified string is equal to the MIME type\n+   * of this object.\n+   *\n+   * @param str The string to test against.\n+   *\n+   * @return <code>true</code> if the string is equal to this object's MIME\n+   * type, <code>false</code> otherwise.\n+   *\n+   * @deprecated Not compatible with <code>hashCode()</code>.\n+   *             Use <code>isMimeTypeEqual()</code>\n+   */\n+  public boolean equals(String str)\n+  {\n+    return isMimeTypeEqual(str);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Returns the hash code for this data flavor.\n+   * The hash code is based on the (lower case) mime type and the\n+   * representation class.\n+   */\n+  public int hashCode()\n+  {\n+    return mimeType.toLowerCase().hashCode() ^ representationClass.hashCode();\n+  }\n \n-/**\n- * Returns a string representation of this DataFlavor. Including the\n- * representation class name, MIME type and human presentable name.\n- */\n-public String\n-toString()\n-{\n-  return(getClass().getName()\n-\t + \"[representationClass=\" + getRepresentationClass().getName()\n-         + \",mimeType=\" + getMimeType()\n-         + \",humanPresentableName=\" + getHumanPresentableName()\n-\t + \"]\");\n-}\n+  /**\n+   * Returns <code>true</code> when the given <code>DataFlavor</code>\n+   * matches this one.\n+   */\n+  public boolean match(DataFlavor dataFlavor)\n+  {\n+    // XXX - How is this different from equals?\n+    return equals(dataFlavor);\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * This method exists for backward compatibility.  It simply returns\n+   * the same name/value pair passed in.\n+   *\n+   * @param name The parameter name.\n+   * @param value The parameter value.\n+   *\n+   * @return The name/value pair.\n+   *\n+   * @deprecated\n+   */\n+  protected String normalizeMimeTypeParameter(String name, String value)\n+  {\n+    return name + \"=\" + value;\n+  }\n \n-/**\n- * XXX - Currently returns <code>plainTextFlavor</code>.\n- */\n-public static final DataFlavor\n-getTextPlainUnicodeFlavor()\n-{\n-  return(plainTextFlavor);\n-}\n+  /**\n+   * This method exists for backward compatibility.  It simply returns\n+   * the MIME type string unchanged.\n+   *\n+   * @param type The MIME type.\n+   * \n+   * @return The MIME type.\n+   *\n+   * @deprecated\n+   */\n+  protected String normalizeMimeType(String type)\n+  {\n+    return type;\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Serialize this class.\n+   *\n+   * @param stream The <code>ObjectOutput</code> stream to serialize to.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public void writeExternal(ObjectOutput stream) throws IOException\n+  {\n+    // FIXME: Implement me\n+  }\n \n-/**\n- * XXX - Currently returns <code>java.io.InputStream</code>.\n- *\n- * @since 1.3\n- */\n-public final Class\n-getDefaultRepresentationClass()\n-{\n-  return(java.io.InputStream.class);\n-}\n-/*************************************************************************/\n \n-/**\n- * XXX - Currently returns <code>java.io.InputStream</code>.\n- */\n-public final String\n-getDefaultRepresentationClassAsString()\n-{\n-  return(getDefaultRepresentationClass().getName());\n-}\n+  /**\n+   * De-serialize this class.\n+   *\n+   * @param stream The <code>ObjectInput</code> stream to deserialize from.\n+   *\n+   * @exception IOException If an error ocurs.\n+   * @exception ClassNotFoundException If the class for an object being restored\n+   * cannot be found.\n+   */\n+  public void readExternal(ObjectInput stream) \n+    throws IOException, ClassNotFoundException\n+  {\n+    // FIXME: Implement me\n+  }\n \n-/*************************************************************************/\n+  /**\n+   * Returns a string representation of this DataFlavor. Including the\n+   * representation class name, MIME type and human presentable name.\n+   */\n+  public String toString()\n+  {\n+    return (getClass().getName()\n+           + \"[representationClass=\" + getRepresentationClass().getName()\n+           + \",mimeType=\" + getMimeType()\n+           + \",humanPresentableName=\" + getHumanPresentableName()\n+           + \"]\");\n+  }\n \n-/**\n- * Selects the best supported text flavor on this implementation.\n- * Returns <code>null</code> when none of the given flavors is liked.\n- *\n- * The <code>DataFlavor</code> returned the first data flavor in the\n- * array that has either a representation class which is (a subclass of)\n- * <code>Reader</code> or <code>String</code>, or has a representation\n- * class which is (a subclass of) <code>InputStream</code> and has a\n- * primary MIME type of \"text\" and has an supported encoding.\n- */\n-public static final DataFlavor\n-selectBestTextFlavor(DataFlavor[] availableFlavors)\n-{\n-  for(int i=0; i<availableFlavors.length; i++)\n-    {\n-      DataFlavor df = availableFlavors[i];\n-      Class c = df.representationClass;\n+  /**\n+   * XXX - Currently returns <code>java.io.InputStream</code>.\n+   *\n+   * @since 1.3\n+   */\n+  public final Class getDefaultRepresentationClass()\n+  {\n+    return java.io.InputStream.class;\n+  }\n \n-      // A Reader or String is good.\n-      if ((Reader.class.isAssignableFrom(c))\n-\t  || (String.class.isAssignableFrom(c)))\n-\t{\n-\t  return df;\n-\t}\n+  /**\n+   * XXX - Currently returns <code>java.io.InputStream</code>.\n+   */\n+  public final String getDefaultRepresentationClassAsString()\n+  {\n+    return getDefaultRepresentationClass().getName();\n+  }\n \n-      // A InputStream is good if the mime primary type is \"text\"\n-      if ((InputStream.class.isAssignableFrom(c))\n-\t  && (\"text\".equals(df.getPrimaryType())))\n+  /**\n+   * Creates a <code>Reader</code> for a given <code>Transferable</code>.\n+   *\n+   * If the representation class is a (subclass of) <code>Reader</code>\n+   * then an instance of the representation class is returned. If the\n+   * representatation class is a <code>String</code> then a\n+   * <code>StringReader</code> is returned. And if the representation class\n+   * is a (subclass of) <code>InputStream</code> and the primary MIME type\n+   * is \"text\" then a <code>InputStreamReader</code> for the correct charset\n+   * encoding is returned.\n+   *\n+   * @param transferable The <code>Transferable</code> for which a text\n+   *                     <code>Reader</code> is requested.\n+   *\n+   * @exception IllegalArgumentException If the representation class is not one\n+   * of the seven listed above or the Transferable has null data.\n+   * @exception NullPointerException If the Transferable is null.\n+   * @exception UnsupportedFlavorException when the transferable doesn't\n+   * support this <code>DataFlavor</code>. Or if the representable class\n+   * isn't a (subclass of) <code>Reader</code>, <code>String</code>,\n+   * <code>InputStream</code> and/or the primary MIME type isn't \"text\".\n+   * @exception IOException when any IOException occurs.\n+   * @exception UnsupportedEncodingException if the \"charset\" isn't supported\n+   * on this platform.\n+   */\n+  public Reader getReaderForText(Transferable transferable)\n+    throws UnsupportedFlavorException, IOException\n+  {\n+      if (!transferable.isDataFlavorSupported(this))\n+          throw new UnsupportedFlavorException(this);\n+  \n+      if (Reader.class.isAssignableFrom(representationClass))\n+          return (Reader)transferable.getTransferData(this);\n+  \n+      if (String.class.isAssignableFrom(representationClass))\n+          return new StringReader((String)transferable.getTransferData(this));\n+  \n+      if (InputStream.class.isAssignableFrom(representationClass)\n+          && \"text\".equals(getPrimaryType()))\n         {\n-          String encoding = availableFlavors[i].getParameter(\"charset\");\n+          InputStream in = (InputStream)transferable.getTransferData(this);\n+          String encoding = getParameter(\"charset\");\n           if (encoding == null)\n-            encoding = \"us-ascii\";\n-          Reader r = null;\n-          try\n-            {\n-              // Try to construct a dummy reader with the found encoding\n-              r = new InputStreamReader\n-                    (new ByteArrayInputStream(new byte[0]), encoding);\n-            }\n-          catch(UnsupportedEncodingException uee) { /* ignore */ }\n-          if (r != null)\n-            return df;\n+              encoding = \"us-ascii\";\n+          return new InputStreamReader(in, encoding);\n         }\n-    }\n-\n-  // Nothing found\n-  return(null);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n- * Creates a <code>Reader</code> for a given <code>Transferable</code>.\n- *\n- * If the representation class is a (subclass of) <code>Reader</code>\n- * then an instance of the representation class is returned. If the\n- * representatation class is a <code>String</code> then a\n- * <code>StringReader</code> is returned. And if the representation class\n- * is a (subclass of) <code>InputStream</code> and the primary MIME type\n- * is \"text\" then a <code>InputStreamReader</code> for the correct charset\n- * encoding is returned.\n- *\n- * @param transferable The <code>Transferable</code> for which a text\n- *                     <code>Reader</code> is requested.\n- *\n- * @exception IllegalArgumentException If the representation class is not one\n- * of the seven listed above or the Transferable has null data.\n- * @exception NullPointerException If the Transferable is null.\n- * @exception UnsupportedFlavorException when the transferable doesn't\n- * support this <code>DataFlavor</code>. Or if the representable class\n- * isn't a (subclass of) <code>Reader</code>, <code>String</code>,\n- * <code>InputStream</code> and/or the primary MIME type isn't \"text\".\n- * @exception IOException when any IOException occurs.\n- * @exception UnsupportedEncodingException if the \"charset\" isn't supported\n- * on this platform.\n- */\n-public Reader getReaderForText(Transferable transferable)\n-  throws UnsupportedFlavorException, IOException\n-{\n-    if (!transferable.isDataFlavorSupported(this))\n-        throw new UnsupportedFlavorException(this);\n-\n-    if (Reader.class.isAssignableFrom(representationClass))\n-        return((Reader)transferable.getTransferData(this));\n-\n-    if (String.class.isAssignableFrom(representationClass))\n-        return(new StringReader((String)transferable.getTransferData(this)));\n-\n-    if (InputStream.class.isAssignableFrom(representationClass)\n-        && \"text\".equals(getPrimaryType()))\n-      {\n-        InputStream in = (InputStream)transferable.getTransferData(this);\n-        String encoding = getParameter(\"charset\");\n-        if (encoding == null)\n-            encoding = \"us-ascii\";\n-        return(new InputStreamReader(in, encoding));\n-      }\n-\n-    throw new UnsupportedFlavorException(this);\n-}\n+  \n+      throw new UnsupportedFlavorException(this);\n+  }\n \n   /**\n    * Returns whether the representation class for this DataFlavor is\n    * @see java.nio.ByteBuffer or a subclass thereof.\n    *\n    * @since 1.4\n    */\n-  public boolean isRepresentationClassByteBuffer ()\n+  public boolean isRepresentationClassByteBuffer()\n   {\n-    return ByteBuffer.class.isAssignableFrom (representationClass);\n+    return ByteBuffer.class.isAssignableFrom(representationClass);\n   }\n \n   /**\n@@ -1021,9 +894,9 @@ public boolean isRepresentationClassByteBuffer ()\n    *\n    * @since 1.4\n    */\n-  public boolean isRepresentationClassCharBuffer ()\n+  public boolean isRepresentationClassCharBuffer()\n   {\n-    return CharBuffer.class.isAssignableFrom (representationClass);\n+    return CharBuffer.class.isAssignableFrom(representationClass);\n   }\n \n   /**\n@@ -1032,10 +905,67 @@ public boolean isRepresentationClassCharBuffer ()\n    *\n    * @since 1.4\n    */\n-  public boolean isRepresentationClassReader ()\n+  public boolean isRepresentationClassReader()\n   {\n-    return Reader.class.isAssignableFrom (representationClass);\n+    return Reader.class.isAssignableFrom(representationClass);\n+  }\n+  \n+  /**\n+   * Returns whether this <code>DataFlavor</code> is a valid text flavor for\n+   * this implementation of the Java platform. Only flavors equivalent to\n+   * <code>DataFlavor.stringFlavor</code> and <code>DataFlavor</code>s with\n+   * a primary MIME type of \"text\" can be valid text flavors.\n+   * <p>\n+   * If this flavor supports the charset parameter, it must be equivalent to\n+   * <code>DataFlavor.stringFlavor</code>, or its representation must be\n+   * <code>java.io.Reader</code>, <code>java.lang.String</code>,\n+   * <code>java.nio.CharBuffer</code>, <code>java.io.InputStream</code> or \n+   * <code>java.nio.ByteBuffer</code>,\n+   * If the representation is <code>java.io.InputStream</code> or \n+   * <code>java.nio.ByteBuffer</code>, then this flavor's <code>charset</code> \n+   * parameter must be supported by this implementation of the Java platform. \n+   * If a charset is not specified, then the platform default charset, which \n+   * is always supported, is assumed.\n+   * <p>\n+   * If this flavor does not support the charset parameter, its\n+   * representation must be <code>java.io.InputStream</code>,\n+   * <code>java.nio.ByteBuffer</code>.\n+   * <p>\n+   * See <code>selectBestTextFlavor</code> for a list of text flavors which\n+   * support the charset parameter.\n+   *\n+   * @return <code>true</code> if this <code>DataFlavor</code> is a valid\n+   *         text flavor as described above; <code>false</code> otherwise\n+   * @see #selectBestTextFlavor\n+   * @since 1.4\n+   */\n+  public boolean isFlavorTextType() {\n+    // FIXME: I'm not 100% sure if this implementation does the same like sun's does    \n+    if(equals(DataFlavor.stringFlavor) || getPrimaryType().equals(\"text\"))\n+      {\n+        String charset = getParameter(\"charset\");\n+        Class c = getRepresentationClass();\n+        if(charset != null) \n+          {            \n+            if(Reader.class.isAssignableFrom(c) \n+                || CharBuffer.class.isAssignableFrom(c) \n+                || String.class.isAssignableFrom(c)) \n+              {\n+                return true;\n+              }\n+            else if(InputStream.class.isAssignableFrom(c)\n+                    || ByteBuffer.class.isAssignableFrom(c))\n+              {\n+                return Charset.isSupported(charset);\n+              }\n+          }\n+        else if(InputStream.class.isAssignableFrom(c)\n+            || ByteBuffer.class.isAssignableFrom(c))\n+          {\n+            return true;\n+          }\n+      }\n+    return false;\n   }\n-\n } // class DataFlavor\n "}, {"sha": "7b4d2fbd38f86306d19ee6e94686833aab8e26f5", "filename": "libjava/classpath/java/awt/datatransfer/SystemFlavorMap.java", "status": "modified", "additions": 276, "deletions": 16, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -38,9 +38,11 @@\n \n package java.awt.datatransfer;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.WeakHashMap;\n \n /**\n   * This class maps between native platform type names and DataFlavors.\n@@ -54,10 +56,28 @@\n public final class SystemFlavorMap implements FlavorMap, FlavorTable\n {\n   /**\n-   * The default (instance) flavor map.\n+   * The map which maps the thread's <code>ClassLoaders</code> to \n+   * <code>SystemFlavorMaps</code>.\n    */\n-  private static FlavorMap defaultFlavorMap;\n-\n+  private static final Map systemFlavorMaps = new WeakHashMap();\n+  \n+  /**\n+   * Constant which is used to prefix encode Java MIME types.\n+   */\n+  private static final String GNU_JAVA_MIME_PREFIX = \"gnu.java:\";\n+  \n+  /**\n+   * This map maps native <code>String</code>s to lists of \n+   * <code>DataFlavor</code>s\n+   */\n+  private HashMap nativeToFlavorMap = new HashMap();\n+  \n+  /**\n+   * This map maps <code>DataFlavor</code>s to lists of native \n+   * <code>String</code>s\n+   */\n+  private HashMap flavorToNativeMap = new HashMap();\n+  \n   /**\n    * Private constructor.\n    */\n@@ -98,47 +118,118 @@ public Map getFlavorsForNatives (String[] natives)\n   }\n \n   /**\n-   * Returns the default (instance) (System)FlavorMap.\n+   * Returns the (System)FlavorMap for the current thread's\n+   * ClassLoader.\n    */\n   public static FlavorMap getDefaultFlavorMap ()\n   {\n-    if (defaultFlavorMap == null)\n-      defaultFlavorMap = new SystemFlavorMap ();\n-\n-    return defaultFlavorMap;\n+    ClassLoader classLoader = Thread.currentThread()\n+        .getContextClassLoader();\n+    \n+    //if ContextClassLoader not set, use system default \n+    if (classLoader == null)\n+      {\n+        classLoader = ClassLoader.getSystemClassLoader();\n+      }\n+    \n+    synchronized(systemFlavorMaps)\n+      {\n+        FlavorMap map = (FlavorMap) \n+            systemFlavorMaps.get(classLoader);\n+        if (map == null) \n+          {\n+            map = new SystemFlavorMap();\n+            systemFlavorMaps.put(classLoader, map);\n+          }\n+        return map;\n+      }\n   }\n \n   /**\n-   * Returns the native type name for the given java mime type.\n+   * Encodes a MIME type for use as a <code>String</code> native. The format\n+   * of an encoded representation of a MIME type is implementation-dependent.\n+   * The only restrictions are:\n+   * <ul>\n+   * <li>The encoded representation is <code>null</code> if and only if the\n+   * MIME type <code>String</code> is <code>null</code>.</li>\n+   * <li>The encoded representations for two non-<code>null</code> MIME type\n+   * <code>String</code>s are equal if and only if these <code>String</code>s\n+   * are equal according to <code>String.equals(Object)</code>.</li>\n+   * </ul>\n+   * <p>\n+   * The present implementation of this method returns the specified MIME\n+   * type <code>String</code> prefixed with <code>gnu.java:</code>.\n+   *\n+   * @param mime the MIME type to encode\n+   * @return the encoded <code>String</code>, or <code>null</code> if\n+   *         mimeType is <code>null</code>\n    */\n   public static String encodeJavaMIMEType (String mime)\n   {\n-    return null;\n+    if (mime != null)\n+      return GNU_JAVA_MIME_PREFIX + mime;\n+    else\n+      return null;\n   }\n \n   /**\n-   * Returns the native type name for the given data flavor.\n+   * Encodes a <code>DataFlavor</code> for use as a <code>String</code>\n+   * native. The format of an encoded <code>DataFlavor</code> is \n+   * implementation-dependent. The only restrictions are:\n+   * <ul>\n+   * <li>The encoded representation is <code>null</code> if and only if the\n+   * specified <code>DataFlavor</code> is <code>null</code> or its MIME type\n+   * <code>String</code> is <code>null</code>.</li>\n+   * <li>The encoded representations for two non-<code>null</code>\n+   * <code>DataFlavor</code>s with non-<code>null</code> MIME type\n+   * <code>String</code>s are equal if and only if the MIME type\n+   * <code>String</code>s of these <code>DataFlavor</code>s are equal\n+   * according to <code>String.equals(Object)</code>.</li>\n+   * </ul>\n+   * <p>\n+   * The present implementation of this method returns the MIME type\n+   * <code>String</code> of the specified <code>DataFlavor</code> prefixed\n+   * with <code>gnu.java:</code>.\n+   *\n+   * @param df the <code>DataFlavor</code> to encode\n+   * @return the encoded <code>String</code>, or <code>null</code> if\n+   *         flav is <code>null</code> or has a <code>null</code> MIME type\n    */\n   public static String encodeDataFlavor (DataFlavor df)\n   {\n-    return null;\n+    if (df != null)\n+      {\n+        return encodeJavaMIMEType(df.getMimeType());\n+      }\n+    else\n+      return null;\n   }\n \n   /**\n    * Returns true if the native type name can be represented as\n-   * a java mime type.\n+   * a java mime type. Returns <code>false</code> if parameter is\n+   * <code>null</code>.\n    */\n   public static boolean isJavaMIMEType (String name)\n   {\n-    return false;\n+    return (name != null && name.startsWith(GNU_JAVA_MIME_PREFIX));\n   }\n \n   /**\n-   * Returns the java mime type for the given the native type name.\n+   * Decodes a <code>String</code> native for use as a Java MIME type.\n+   *\n+   * @param name the <code>String</code> to decode\n+   * @return the decoded Java MIME type, or <code>null</code> if nat \n+   *         is not an encoded <code>String</code> native\n    */\n   public static String decodeJavaMIMEType (String name)\n   {\n-    return null;\n+    if (isJavaMIMEType(name))\n+      {\n+        return name.substring(GNU_JAVA_MIME_PREFIX.length());\n+      }\n+    else \n+      return null;\n   }\n \n   /**\n@@ -156,6 +247,20 @@ public static DataFlavor decodeDataFlavor (String name)\n       return null;\n   }\n \n+  /** \n+   * Returns a List of <code>DataFlavors</code> to which the specified \n+   * <code>String</code> native can be translated by the data transfer \n+   * subsystem. The <code>List</code> will be sorted from best \n+   * <code>DataFlavor</code> to worst. That is, the first <code>DataFlavor \n+   * </code> will best reflect data in the specified native to a Java \n+   * application. \n+   * <p>\n+   * If the specified native is previously unknown to the data transfer \n+   * subsystem, and that native has been properly encoded, then invoking \n+   * this method will establish a mapping in both directions between the \n+   * specified native and a DataFlavor whose MIME type is a decoded \n+   * version of the native.\n+   */ \n   public List getFlavorsForNative (String nat)\n   {\n     throw new Error (\"Not implemented\");\n@@ -165,5 +270,160 @@ public List getNativesForFlavor (DataFlavor flav)\n   {\n     throw new Error (\"Not implemented\");\n   }\n+  \n+  /**\n+   * Adds a mapping from a single <code>String</code> native to a single\n+   * <code>DataFlavor</code>. Unlike <code>getFlavorsForNative</code>, the\n+   * mapping will only be established in one direction, and the native will\n+   * not be encoded. To establish a two-way mapping, call\n+   * <code>addUnencodedNativeForFlavor</code> as well. The new mapping will\n+   * be of lower priority than any existing mapping.\n+   * This method has no effect if a mapping from the specified\n+   * <code>String</code> native to the specified or equal\n+   * <code>DataFlavor</code> already exists.\n+   *\n+   * @param nativeStr the <code>String</code> native key for the mapping\n+   * @param flavor the <code>DataFlavor</code> value for the mapping\n+   * @throws NullPointerException if nat or flav is <code>null</code>\n+   *\n+   * @see #addUnencodedNativeForFlavor\n+   * @since 1.4\n+   */\n+  public synchronized void addFlavorForUnencodedNative(String nativeStr, \n+                                                       DataFlavor flavor)\n+  {\n+    if ((nativeStr == null) || (flavor == null))\n+      throw new NullPointerException();\n+    List flavors = (List) nativeToFlavorMap.get(nativeStr);\n+    if (flavors == null) \n+      {\n+        flavors = new ArrayList();\n+        nativeToFlavorMap.put(nativeStr, flavors);\n+      }\n+    else\n+      {\n+        if (! flavors.contains(flavor))\n+          flavors.add(flavor);\n+      }\n+  }\n+  \n+  /**\n+   * Adds a mapping from the specified <code>DataFlavor</code> (and all\n+   * <code>DataFlavor</code>s equal to the specified <code>DataFlavor</code>)\n+   * to the specified <code>String</code> native.\n+   * Unlike <code>getNativesForFlavor</code>, the mapping will only be\n+   * established in one direction, and the native will not be encoded. To\n+   * establish a two-way mapping, call\n+   * <code>addFlavorForUnencodedNative</code> as well. The new mapping will \n+   * be of lower priority than any existing mapping.\n+   * This method has no effect if a mapping from the specified or equal\n+   * <code>DataFlavor</code> to the specified <code>String</code> native\n+   * already exists.\n+   *\n+   * @param flavor the <code>DataFlavor</code> key for the mapping\n+   * @param nativeStr the <code>String</code> native value for the mapping\n+   * @throws NullPointerException if flav or nat is <code>null</code>\n+   *\n+   * @see #addFlavorForUnencodedNative\n+   * @since 1.4\n+   */\n+  public synchronized void addUnencodedNativeForFlavor(DataFlavor flavor,\n+                                                       String nativeStr) \n+  {\n+    if ((nativeStr == null) || (flavor == null))\n+      throw new NullPointerException();\n+    List natives = (List) flavorToNativeMap.get(flavor);\n+    if (natives == null) \n+      {\n+        natives = new ArrayList();\n+        flavorToNativeMap.put(flavor, natives);\n+      }\n+    else\n+      {\n+        if (! natives.contains(nativeStr))\n+          natives.add(nativeStr);\n+      }\n+  }\n+  \n+  /**\n+   * Discards the current mappings for the specified <code>DataFlavor</code>\n+   * and all <code>DataFlavor</code>s equal to the specified\n+   * <code>DataFlavor</code>, and creates new mappings to the \n+   * specified <code>String</code> natives.\n+   * Unlike <code>getNativesForFlavor</code>, the mappings will only be\n+   * established in one direction, and the natives will not be encoded. To\n+   * establish two-way mappings, call <code>setFlavorsForNative</code>\n+   * as well. The first native in the array will represent the highest\n+   * priority mapping. Subsequent natives will represent mappings of\n+   * decreasing priority.\n+   * <p>\n+   * If the array contains several elements that reference equal\n+   * <code>String</code> natives, this method will establish new mappings\n+   * for the first of those elements and ignore the rest of them.\n+   * <p> \n+   * It is recommended that client code not reset mappings established by the\n+   * data transfer subsystem. This method should only be used for\n+   * application-level mappings.\n+   *\n+   * @param flavor the <code>DataFlavor</code> key for the mappings\n+   * @param natives the <code>String</code> native values for the mappings\n+   * @throws NullPointerException if flav or natives is <code>null</code>\n+   *         or if natives contains <code>null</code> elements\n+   *\n+   * @see #setFlavorsForNative\n+   * @since 1.4\n+   */\n+  public synchronized void setNativesForFlavor(DataFlavor flavor,\n+                                               String[] natives) \n+  {\n+    if ((natives == null) || (flavor == null))\n+      throw new NullPointerException();\n+    \n+    flavorToNativeMap.remove(flavor);\n+    for (int i = 0; i < natives.length; i++) \n+      {\n+        addUnencodedNativeForFlavor(flavor, natives[i]);\n+      }\n+  }\n+  \n+  /**\n+   * Discards the current mappings for the specified <code>String</code>\n+   * native, and creates new mappings to the specified\n+   * <code>DataFlavor</code>s. Unlike <code>getFlavorsForNative</code>, the\n+   * mappings will only be established in one direction, and the natives need\n+   * not be encoded. To establish two-way mappings, call\n+   * <code>setNativesForFlavor</code> as well. The first\n+   * <code>DataFlavor</code> in the array will represent the highest priority\n+   * mapping. Subsequent <code>DataFlavor</code>s will represent mappings of\n+   * decreasing priority.\n+   * <p>\n+   * If the array contains several elements that reference equal\n+   * <code>DataFlavor</code>s, this method will establish new mappings\n+   * for the first of those elements and ignore the rest of them.\n+   * <p>\n+   * It is recommended that client code not reset mappings established by the\n+   * data transfer subsystem. This method should only be used for\n+   * application-level mappings.\n+   *\n+   * @param nativeStr the <code>String</code> native key for the mappings\n+   * @param flavors the <code>DataFlavor</code> values for the mappings\n+   * @throws NullPointerException if nat or flavors is <code>null</code>\n+   *         or if flavors contains <code>null</code> elements\n+   *\n+   * @see #setNativesForFlavor\n+   * @since 1.4\n+   */\n+  public synchronized void setFlavorsForNative(String nativeStr,\n+                                               DataFlavor[] flavors) \n+  {\n+    if ((nativeStr == null) || (flavors == null))\n+      throw new NullPointerException();\n+    \n+    nativeToFlavorMap.remove(nativeStr);\n+    for (int i = 0; i < flavors.length; i++) \n+      {\n+        addFlavorForUnencodedNative(nativeStr, flavors[i]);\n+      }\n+  }\n \n } // class SystemFlavorMap"}, {"sha": "9dd1ae564f794c3f24f870079ced132745337d79", "filename": "libjava/classpath/java/beans/DefaultPersistenceDelegate.java", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FDefaultPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FDefaultPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FDefaultPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,194 @@\n+/* DefaultPersistenceDelegate.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/** <p><code>DefaultPersistenceDelegate</code> is a {@link PersistenceDelegate}\n+ * implementation that can be used to serialize objects which adhere to the\n+ * Java Beans naming convention.</p>\n+ * \n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ * @since 1.4\n+ */\n+public class DefaultPersistenceDelegate extends PersistenceDelegate\n+{\n+\n+  private String[] constructorPropertyNames;\n+\n+  /** Using this constructor the object to be serialized will be instantiated\n+   * with the default non-argument constructor.\n+   */\n+  public DefaultPersistenceDelegate()\n+  {\n+  }\n+\n+  /** This constructor allows to specify which Bean properties appear\n+   * in the constructor.\n+   * \n+   * <p>The implementation reads the mentioned properties from the Bean\n+   * instance and applies it in the given order to a corresponding\n+   * constructor.</p>\n+   * \n+   * @param constructorPropertyNames The properties the Bean's constructor\n+   * should be given to.\n+   */\n+  public DefaultPersistenceDelegate(String[] constructorPropertyNames)\n+  {\n+    this.constructorPropertyNames = constructorPropertyNames;\n+  }\n+\n+  protected boolean mutatesTo(Object oldInstance, Object newInstance)\n+  {\n+    try\n+      {\n+\n+        return (constructorPropertyNames != null\n+               && constructorPropertyNames.length > 0\n+               && oldInstance.getClass()\n+               .getDeclaredMethod(\"equals\",\n+                                  new Class[] { Object.class }) != null)\n+                                  ? oldInstance.equals(newInstance)\n+                                  : super.mutatesTo(oldInstance, newInstance);\n+      }\n+    catch (NoSuchMethodException nsme)\n+      {\n+        return super.mutatesTo(oldInstance, newInstance);\n+      }\n+  }\n+\n+  protected Expression instantiate(Object oldInstance, Encoder out)\n+  {\n+    Object[] args = null;\n+\n+    try\n+      {\n+        // If there are property names in the array, then we create\n+        // a corresponding argument array and store every\n+        // argument in it. To retrieve an argument object we have\n+        // dig up the right property in the bean class' BeanInfo\n+        // object.\n+        // This is so costly in terms of execution time I better\n+        // not think twice about it ...\n+        if (constructorPropertyNames != null)\n+          {\n+            args = new Object[constructorPropertyNames.length];\n+\n+            // Look up the properties of oldInstance's class to find matches for\n+            // the\n+            // names given in the constructor.\n+            PropertyDescriptor[] propertyDescs = Introspector.getBeanInfo(\n+                                                                          oldInstance.getClass()).getPropertyDescriptors();\n+\n+            for (int i = 0; i < constructorPropertyNames.length; i++)\n+              {\n+                // Scan the property descriptions for a matching name.\n+                for (int j = 0; j < propertyDescs.length; j++)\n+                  {\n+                    if (propertyDescs[i].getName().equals(\n+                                                          constructorPropertyNames[i]))\n+                      {\n+                        Method readMethod = propertyDescs[i].getReadMethod();\n+\n+                        args[i] = readMethod.invoke(oldInstance, null);\n+                      }\n+                  }\n+              }\n+          }\n+\n+      }\n+    catch (IllegalAccessException iae)\n+      {\n+        out.getExceptionListener().exceptionThrown(iae);\n+      }\n+    catch (IllegalArgumentException iarge)\n+      {\n+        out.getExceptionListener().exceptionThrown(iarge);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        out.getExceptionListener().exceptionThrown(ite);\n+      }\n+    catch (IntrospectionException ie)\n+      {\n+        out.getExceptionListener().exceptionThrown(ie);\n+      }\n+\n+    return new Expression(oldInstance, oldInstance.getClass(), \"new\", args);\n+  }\n+\n+  protected void initialize(Class type, Object oldInstance, Object newInstance,\n+                            Encoder out)\n+  {\n+    try\n+      {\n+        PropertyDescriptor[] propertyDescs = Introspector.getBeanInfo(\n+                                                                      oldInstance.getClass()).getPropertyDescriptors();\n+\n+        for (int i = 0; i < propertyDescs.length; i++)\n+          {\n+            Method readMethod = propertyDescs[i].getReadMethod();\n+            Method writeMethod = propertyDescs[i].getWriteMethod();\n+\n+            if (readMethod != null && writeMethod != null)\n+              {\n+                Object oldValue = readMethod.invoke(oldInstance, null);\n+\n+                if (oldValue != null)\n+                  out.writeStatement(new Statement(oldInstance,\n+                                                   writeMethod.getName(),\n+                                                   new Object[] { oldValue }));\n+              }\n+          }\n+      }\n+    catch (IntrospectionException ie)\n+      {\n+        out.getExceptionListener().exceptionThrown(ie);\n+      }\n+    catch (IllegalAccessException iae)\n+      {\n+        out.getExceptionListener().exceptionThrown(iae);\n+      }\n+    catch (InvocationTargetException ite)\n+      {\n+        out.getExceptionListener().exceptionThrown(ite);\n+      }\n+  }\n+}"}, {"sha": "9b96aaa8ea67a92b88a14340e593eddc118cdb21", "filename": "libjava/classpath/java/beans/Encoder.java", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FEncoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FEncoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FEncoder.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -0,0 +1,463 @@\n+/* Encoder.java\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import gnu.java.beans.encoder.ArrayPersistenceDelegate;\n+import gnu.java.beans.encoder.ClassPersistenceDelegate;\n+import gnu.java.beans.encoder.CollectionPersistenceDelegate;\n+import gnu.java.beans.encoder.MapPersistenceDelegate;\n+import gnu.java.beans.encoder.PrimitivePersistenceDelegate;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.Vector;\n+\n+/**\n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ * @since 1.4\n+ */\n+public class Encoder\n+{\n+\n+  /**\n+   * An internal DefaultPersistenceDelegate instance that is used for every\n+   * class that does not a have a special special PersistenceDelegate.\n+   */\n+  private static PersistenceDelegate defaultPersistenceDelegate;\n+\n+  private static PersistenceDelegate fakePersistenceDelegate;\n+\n+  /**\n+   * Stores the relation Class->PersistenceDelegate.\n+   */\n+  private static HashMap delegates = new HashMap();\n+\n+  /**\n+   * Stores the relation oldInstance->newInstance\n+   */\n+  private IdentityHashMap candidates = new IdentityHashMap();\n+\n+  private ExceptionListener exceptionListener;\n+\n+  /**\n+   * A simple number that is used to restrict the access to writeExpression and\n+   * writeStatement. The rule is that both methods should only be used when an\n+   * object is written to the stream (= writeObject). Therefore accessCounter is\n+   * incremented just before the call to writeObject and decremented afterwards.\n+   * Then writeStatement and writeExpression allow execution only if\n+   * accessCounter is bigger than zero.\n+   */\n+  private int accessCounter = 0;\n+\n+  public Encoder()\n+  {\n+    setupDefaultPersistenceDelegates();\n+\n+    setExceptionListener(null);\n+  }\n+\n+  /**\n+   * Sets up a bunch of {@link PersistenceDelegate} instances which are needed\n+   * for the basic working of a {@link Encoder}s.\n+   */\n+  private static void setupDefaultPersistenceDelegates()\n+  {\n+    synchronized (delegates)\n+      {\n+        if (defaultPersistenceDelegate != null)\n+          return;\n+\n+        delegates.put(Class.class, new ClassPersistenceDelegate());\n+\n+        PersistenceDelegate pd = new PrimitivePersistenceDelegate();\n+        delegates.put(Boolean.class, pd);\n+        delegates.put(Byte.class, pd);\n+        delegates.put(Short.class, pd);\n+        delegates.put(Integer.class, pd);\n+        delegates.put(Long.class, pd);\n+        delegates.put(Float.class, pd);\n+        delegates.put(Double.class, pd);\n+\n+        delegates.put(Object[].class, new ArrayPersistenceDelegate());\n+\n+        pd = new CollectionPersistenceDelegate();\n+        delegates.put(ArrayList.class, pd);\n+        delegates.put(LinkedList.class, pd);\n+        delegates.put(Vector.class, pd);\n+        delegates.put(HashSet.class, pd);\n+        delegates.put(LinkedHashSet.class, pd);\n+        delegates.put(TreeSet.class, pd);\n+        \n+        pd = new MapPersistenceDelegate();\n+        delegates.put(HashMap.class, pd);\n+        delegates.put(TreeMap.class, pd);\n+        delegates.put(java.util.Hashtable.class, pd);\n+        delegates.put(java.util.IdentityHashMap.class, pd);\n+        \n+        delegates.put(java.util.LinkedHashMap.class, pd);\n+        delegates.put(java.util.Properties.class, pd);\n+\n+        delegates.put(java.awt.RenderingHints.class, pd);\n+        delegates.put(java.util.WeakHashMap.class, pd);\n+        delegates.put(javax.swing.UIDefaults.class, pd);\n+        \n+        // TODO: These classes need to be implemented first\n+        //delegates.put(java.security.AuthProvider.class, pd);\n+        //delegates.put(java.util.concurrent.ConcurrentHashMap.class, pd);\n+        //delegates.put(java.util.EnumMap.class, pd);\n+        //delegates.put(javax.management.openmbean.TabularDataSupport.class, pd);\n+        \n+        defaultPersistenceDelegate = new DefaultPersistenceDelegate();\n+        delegates.put(Object.class, defaultPersistenceDelegate);\n+\n+        // Creates a PersistenceDelegate implementation which is\n+        // returned for 'null'. In practice this instance is\n+        // not used in any way and is just here to be compatible\n+        // with the reference implementation which returns a\n+        // similar instance when calling getPersistenceDelegate(null) .\n+        fakePersistenceDelegate = new PersistenceDelegate()\n+        {\n+          protected Expression instantiate(Object o, Encoder e)\n+          {\n+            return null;\n+          }\n+        };\n+\n+      }\n+  }\n+\n+  protected void writeObject(Object o)\n+  {\n+    // 'null' has no PersistenceDelegate and will not\n+    // create an Expression which has to be cloned.\n+    // However subclasses should be aware that writeObject\n+    // may be called with a 'null' argument and should\n+    // write the proper representation of it.\n+    if (o == null)\n+      return;\n+\n+    PersistenceDelegate pd = getPersistenceDelegate(o.getClass());\n+\n+    accessCounter++;\n+    pd.writeObject(o, this);\n+    accessCounter--;\n+    \n+  }\n+\n+  /**\n+   * Sets the {@link ExceptionListener} instance to be used for reporting\n+   * recorable exceptions in the instantiation and initialization sequence. If\n+   * the argument is <code>null</code> a default instance will be used that\n+   * prints the thrown exception to <code>System.err</code>.\n+   */\n+  public void setExceptionListener(ExceptionListener listener)\n+  {\n+    exceptionListener = (listener != null) ? listener : new ExceptionListener()\n+    {\n+      public void exceptionThrown(Exception e)\n+      {\n+        System.err.println(\"exception thrown: \" + e);\n+        e.printStackTrace();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Returns the currently active {@link ExceptionListener} instance.\n+   */\n+  public ExceptionListener getExceptionListener()\n+  {\n+    return exceptionListener;\n+  }\n+\n+  public PersistenceDelegate getPersistenceDelegate(Class type)\n+  {\n+    // This is not specified but the JDK behaves like this.\n+    if (type == null)\n+      return fakePersistenceDelegate;\n+\n+    // Treats all array classes in the same way and assigns\n+    // them a shared PersistenceDelegate implementation tailored\n+    // for array instantation and initialization.\n+    if (type.isArray())\n+      return (PersistenceDelegate) delegates.get(Object[].class);\n+\n+    PersistenceDelegate pd = (PersistenceDelegate) delegates.get(type);\n+\n+    return (pd != null) ? pd : (PersistenceDelegate) defaultPersistenceDelegate;\n+  }\n+\n+  /**\n+   * Sets the {@link PersistenceDelegate} instance for the given class.\n+   * <p>\n+   * Note: Throws a <code>NullPointerException</code> if the argument is\n+   * <code>null</code>.\n+   * </p>\n+   * <p>\n+   * Note: Silently ignores PersistenceDelegates for Array types and primitive\n+   * wrapper classes.\n+   * </p>\n+   * <p>\n+   * Note: Although this method is not declared <code>static</code> changes to\n+   * the {@link PersistenceDelegate}s affect <strong>all</strong>\n+   * {@link Encoder} instances. <strong>In this implementation</strong> the\n+   * access is thread safe.\n+   * </p>\n+   */\n+  public void setPersistenceDelegate(Class type, PersistenceDelegate delegate)\n+  {\n+    // If the argument is null this will cause a NullPointerException\n+    // which is expected behavior.\n+\n+    // This makes custom PDs for array, primitive types and their wrappers\n+    // impossible but this is how the JDK behaves.\n+    if (type.isArray() || type.isPrimitive() || type == Boolean.class\n+        || type == Byte.class || type == Short.class || type == Integer.class\n+        || type == Long.class || type == Float.class || type == Double.class)\n+      return;\n+\n+    synchronized (delegates)\n+      {\n+        delegates.put(type, delegate);\n+      }\n+\n+  }\n+\n+  public Object remove(Object oldInstance)\n+  {\n+    return candidates.remove(oldInstance);\n+  }\n+\n+  /**\n+   * Returns the replacement object which has been created by the encoder during\n+   * the instantiation sequence or <code>null</code> if the object has not\n+   * been processed yet.\n+   * <p>\n+   * Note: The <code>String</code> class acts as an endpoint for the\n+   * inherently recursive algorithm of the {@link Encoder}. Therefore instances\n+   * of <code>String</code> will always be returned by this method. In other\n+   * words the assertion: <code>\n+   * assert (anyEncoder.get(anyString) == anyString)\n+   * </code<\n+   * will always hold.</p>\n+   *\n+   * <p>Note: If <code>null</code> is requested, the result will\n+   * always be <code>null</code>.</p>\n+   */\n+  public Object get(Object oldInstance)\n+  {\n+    // String instances are handled in a special way.\n+    // No one knows why this is not officially specified\n+    // because this is a rather important design decision.\n+    return (oldInstance == null) ? null : \n+             (oldInstance.getClass() == String.class) ?\n+               oldInstance : candidates.get(oldInstance);\n+  }\n+\n+  /**\n+   * <p>\n+   * Note: If you call this method not from within an object instantiation and\n+   * initialization sequence it will be silently ignored.\n+   * </p>\n+   */\n+  public void writeStatement(Statement stmt)\n+  {\n+    // Silently ignore out of bounds calls.\n+    if (accessCounter <= 0)\n+      return;\n+\n+    Object target = stmt.getTarget();\n+\n+    Object newTarget = get(target);\n+    if (newTarget == null)\n+      {\n+        writeObject(target);\n+        newTarget = get(target);\n+      }\n+\n+    Object[] args = stmt.getArguments();\n+    Object[] newArgs = new Object[args.length];\n+\n+    for (int i = 0; i < args.length; i++)\n+      {\n+        newArgs[i] = get(args[i]);\n+        if (newArgs[i] == null || isImmutableType(args[i].getClass()))\n+          {\n+            writeObject(args[i]);\n+            newArgs[i] = get(args[i]);\n+          }\n+      }\n+\n+    Statement newStmt = new Statement(newTarget, stmt.getMethodName(), newArgs);\n+\n+    try\n+      {\n+        newStmt.execute();\n+      }\n+    catch (Exception e)\n+      {\n+        exceptionListener.exceptionThrown(e);\n+      }\n+\n+  }\n+\n+  /**\n+   * <p>\n+   * Note: If you call this method not from within an object instantiation and\n+   * initialization sequence it will be silently ignored.\n+   * </p>\n+   */\n+  public void writeExpression(Expression expr)\n+  {\n+    // Silently ignore out of bounds calls.\n+    if (accessCounter <= 0)\n+      return;\n+\n+    Object target = expr.getTarget();\n+    Object value = null;\n+    Object newValue = null;\n+\n+    try\n+      {\n+        value = expr.getValue();\n+      }\n+    catch (Exception e)\n+      {\n+        exceptionListener.exceptionThrown(e);\n+        return;\n+      }\n+    \n+    \n+    newValue = get(value);\n+\n+    if (newValue == null)\n+      {\n+        Object newTarget = get(target);\n+        if (newTarget == null)\n+          {\n+            writeObject(target);\n+            newTarget = get(target);\n+\n+            // May happen if exception was thrown.\n+            if (newTarget == null)\n+              {\n+                return;\n+              }\n+          }\n+\n+        Object[] args = expr.getArguments();\n+        Object[] newArgs = new Object[args.length];\n+\n+        for (int i = 0; i < args.length; i++)\n+          {\n+            newArgs[i] = get(args[i]);\n+            if (newArgs[i] == null || isImmutableType(args[i].getClass()))\n+              {\n+                writeObject(args[i]);\n+                newArgs[i] = get(args[i]);\n+              }\n+          }\n+        \n+        Expression newExpr = new Expression(newTarget, expr.getMethodName(),\n+                                            newArgs);\n+        \n+        // Fakes the result of Class.forName(<primitiveType>) to make it possible\n+        // to hand such a type to the encoding process.\n+        if (value instanceof Class && ((Class) value).isPrimitive())\n+          newExpr.setValue(value);\n+        \n+        // Instantiates the new object.\n+        try\n+          {\n+            newValue = newExpr.getValue();\n+\n+            candidates.put(value, newValue);\n+          }\n+        catch (Exception e)\n+          {\n+            exceptionListener.exceptionThrown(e);\n+            \n+            return;\n+          }\n+        \n+        writeObject(value);\n+\n+      }\n+    else if(value.getClass() == String.class || value.getClass() == Class.class)\n+      {\n+        writeObject(value);\n+      }\n+\n+  }\n+\n+  /** Returns whether the given class is an immutable\n+   * type which has to be handled differently when serializing it.\n+   * \n+   * <p>Immutable objects always have to be instantiated instead of\n+   * modifying an existing instance.</p>\n+   * \n+   * @param type The class to test.\n+   * @return Whether the first argument is an immutable type.\n+   */\n+  boolean isImmutableType(Class type)\n+  {\n+    return type == String.class || type == Class.class\n+      || type == Integer.class || type == Boolean.class\n+      || type == Byte.class || type == Short.class\n+      || type == Long.class || type == Float.class\n+      || type == Double.class;\n+  }\n+  \n+  /** Sets the stream candidate for a given object.\n+   * \n+   * @param oldObject The object given to the encoder.\n+   * @param newObject The object the encoder generated.\n+   */\n+  void putCandidate(Object oldObject, Object newObject)\n+  {\n+    candidates.put(oldObject, newObject);\n+  }\n+  \n+}"}, {"sha": "381a453031e61e23d0ce3311634ef1a603315166", "filename": "libjava/classpath/java/beans/EventSetDescriptor.java", "status": "modified", "additions": 747, "deletions": 426, "changes": 1173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FEventSetDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FEventSetDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FEventSetDescriptor.java?ref=2127637945ea6b763966398130e0770fa993c860", "patch": "@@ -1,39 +1,39 @@\n /* java.beans.EventSetDescriptor\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+ Copyright (C) 1998, 2006 Free Software Foundation, Inc.\n \n-This file is part of GNU Classpath.\n+ This file is part of GNU Classpath.\n \n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n  \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n \n \n package java.beans;\n@@ -45,398 +45,719 @@\n import java.util.Vector;\n \n /**\n- ** EventSetDescriptor describes the hookup between an event source\n- ** class and an event listener class.\n- **\n- ** EventSets have several attributes: the listener class, the events\n- ** that can be fired to the listener (methods in the listener class), and\n- ** an add and remove listener method from the event firer's class.<P>\n- **\n- ** The methods have these constraints on them:<P>\n- ** <UL>\n- ** <LI>event firing methods: must have <CODE>void</CODE> return value.  Any\n- ** parameters and exceptions are allowed.  May be public, protected or\n- ** package-protected. (Don't ask me why that is, I'm just following the spec.\n- ** The only place it is even mentioned is in the Java Beans white paper, and\n- ** there it is only implied.)</LI>\n- ** <LI>add listener method: must have <CODE>void</CODE> return value.  Must\n- ** take exactly one argument, of the listener class's type.  May fire either\n- ** zero exceptions, or one exception of type <CODE>java.util.TooManyListenersException</CODE>.\n- ** Must be public.</LI>\n- ** <LI>remove listener method: must have <CODE>void</CODE> return value.\n- ** Must take exactly one argument, of the listener class's type.  May not\n- ** fire any exceptions.  Must be public.</LI>\n- ** </UL>\n- **\n- ** A final constraint is that event listener classes must extend from EventListener.<P>\n- **\n- ** There are also various design patterns associated with some of the methods\n- ** of construction. Those are explained in more detail in the appropriate\n- ** constructors.<P>\n- **\n- ** <STRONG>Documentation Convention:</STRONG> for proper\n- ** Internalization of Beans inside an RAD tool, sometimes there\n- ** are two names for a property or method: a programmatic, or\n- ** locale-independent name, which can be used anywhere, and a\n- ** localized, display name, for ease of use.  In the\n- ** documentation I will specify different String values as\n- ** either <EM>programmatic</EM> or <EM>localized</EM> to\n- ** make this distinction clear.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 31 May 1998\n- **/\n-\n-public class EventSetDescriptor extends FeatureDescriptor {\n-\tprivate Method addListenerMethod;\n-\tprivate Method removeListenerMethod;\n-\tprivate Class listenerType;\n-\tprivate MethodDescriptor[] listenerMethodDescriptors;\n-\tprivate Method[] listenerMethods;\n-\n-\tprivate boolean unicast;\n-\tprivate boolean inDefaultEventSet = true;\n-\n-\t/** Create a new EventSetDescriptor.\n-\t ** This version of the constructor enforces the rules imposed on the methods\n-\t ** described at the top of this class, as well as searching for:<P>\n-\t ** <OL>\n-\t ** <LI>The event-firing method must be non-private with signature\n-\t ** <CODE>void &lt;listenerMethodName&gt;(&lt;eventSetName&gt;Event)</CODE>\n-\t ** (where <CODE>&lt;eventSetName&gt;</CODE> has its first character capitalized\n-\t ** by the constructor and the Event is a descendant of\n-\t ** <CODE>java.util.EventObject</CODE>) in class <CODE>listenerType</CODE>\n-\t ** (any exceptions may be thrown).\n-\t ** <B>Implementation note:</B> Note that there could conceivably be multiple\n-\t ** methods with this type of signature (example: java.util.MouseEvent vs.\n-\t ** my.very.own.MouseEvent).  In this implementation, all methods fitting the\n-\t ** description will be put into the <CODE>EventSetDescriptor</CODE>, even\n-\t ** though the spec says only one should be chosen (they probably weren't thinking as\n-\t ** pathologically as I was).  I don't like arbitrarily choosing things.\n-\t ** If your class has only one such signature, as most do, you'll have no problems.</LI>\n-\t ** <LI>The add and remove methods must be public and named\n-\t ** <CODE>void add&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</CODE> and\n-\t ** <CODE>void remove&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</CODE> in\n-\t ** in class <CODE>eventSourceClass</CODE>, where\n-\t ** <CODE>&lt;eventSetName&gt;</CODE> will have its first letter capitalized.\n-\t ** Standard exception rules (see class description) apply.</LI>\n-\t ** </OL>\n-\t ** @param eventSourceClass the class containing the add/remove listener methods.\n-\t ** @param eventSetName the programmatic name of the event set, generally starting\n-\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).  This will be used\n-\t ** to generate the name of the event object as well as the names of the add and\n-\t ** remove methods.\n-\t ** @param listenerType the class containing the event firing method.\n-\t ** @param listenerMethodName the name of the event firing method.\n-\t ** @exception IntrospectionException if listenerType is not an EventListener,\n-\t **                                   or if methods are not found or are invalid.\n-\t **/\n-\tpublic EventSetDescriptor(Class  eventSourceClass,\n-\t\t\t\t  String eventSetName,\n-\t\t\t\t  Class  listenerType,\n-\t\t\t\t  String listenerMethodName) throws IntrospectionException {\n-\t\tsetName(eventSetName);\n-\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n-\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n-\t\t}\n-\n-\t\tString[] names = new String[1];\n-\t\tnames[0] = listenerMethodName;\n-\n-\t\ttry {\n-\t\t\teventSetName = Character.toUpperCase(eventSetName.charAt(0)) + eventSetName.substring(1);\n-\t\t} catch(StringIndexOutOfBoundsException e) {\n-\t\t\teventSetName = \"\";\n-\t\t}\n-\n-\t\tfindMethods(eventSourceClass,listenerType,names,\"add\"+eventSetName+\"Listener\",\"remove\"+eventSetName+\"Listener\",eventSetName+\"Event\");\n-\t\tthis.listenerType = listenerType;\n-\t\tcheckAddListenerUnicast();\n-\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n-\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n-\t\t}\n-\t}\n-\n-\t/** Create a new EventSetDescriptor.\n-\t ** This form of the constructor allows you to specify the names of the methods and adds\n-\t ** no new constraints on top of the rules already described at the top of the class.<P>\n-\t ** \n-\t ** @param eventSourceClass the class containing the add and remove listener methods.\n-\t ** @param eventSetName the programmatic name of the event set, generally starting\n-\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n-\t ** @param listenerType the class containing the event firing methods.\n-\t ** @param listenerMethodNames the names of the even firing methods.\n-\t ** @param addListenerMethodName the name of the add listener method.\n-\t ** @param removeListenerMethodName the name of the remove listener method.\n-\t ** @exception IntrospectionException if listenerType is not an EventListener\n-\t **                                   or if methods are not found or are invalid.\n-\t **/\n-\tpublic EventSetDescriptor(Class eventSourceClass,\n-\t\t\t\t   String eventSetName,\n-\t\t\t\t   Class listenerType,\n-\t\t\t\t   String[] listenerMethodNames,\n-\t\t\t\t   String addListenerMethodName,\n-\t\t\t\t   String removeListenerMethodName) throws IntrospectionException {\n-\t\tsetName(eventSetName);\n-\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n-\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n-\t\t}\n-\n-\t\tfindMethods(eventSourceClass,listenerType,listenerMethodNames,addListenerMethodName,removeListenerMethodName,null);\n-\t\tthis.listenerType = listenerType;\n-\t\tcheckAddListenerUnicast();\n-\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n-\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n-\t\t}\n-\t}\n-\n-\t/** Create a new EventSetDescriptor.\n-\t ** This form of constructor allows you to explicitly say which methods do what, and\n-\t ** no reflection is done by the EventSetDescriptor.  The methods are, however,\n-\t ** checked to ensure that they follow the rules set forth at the top of the class.\n-\t ** @param eventSetName the programmatic name of the event set, generally starting\n-\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n-\t ** @param listenerType the class containing the listenerMethods.\n-\t ** @param listenerMethods the event firing methods.\n-\t ** @param addListenerMethod the add listener method.\n-\t ** @param removeListenerMethod the remove listener method.\n-\t ** @exception IntrospectionException if the listenerType is not an EventListener,\n-\t **                                   or any of the methods are invalid.\n-\t **/\n-\tpublic EventSetDescriptor(String eventSetName,\n-\t\t\t\t   Class listenerType,\n-\t\t\t\t   Method[] listenerMethods,\n-\t\t\t\t   Method addListenerMethod,\n-\t\t\t\t   Method removeListenerMethod) throws IntrospectionException {\n-\t\tsetName(eventSetName);\n-\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n-\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n-\t\t}\n-\n-\t        this.listenerMethods = listenerMethods;\n-\t\tthis.addListenerMethod = addListenerMethod;\n-\t\tthis.removeListenerMethod = removeListenerMethod;\n-\t\tthis.listenerType = listenerType;\n-\t\tcheckMethods();\n-\t\tcheckAddListenerUnicast();\n-\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n-\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n-\t\t}\n-\t}\n-\n-\t/** Create a new EventSetDescriptor.\n-\t ** This form of constructor allows you to explicitly say which methods do what, and\n-\t ** no reflection is done by the EventSetDescriptor.  The methods are, however,\n-\t ** checked to ensure that they follow the rules set forth at the top of the class.\n-\t ** @param eventSetName the programmatic name of the event set, generally starting\n-\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n-\t ** @param listenerType the class containing the listenerMethods.\n-\t ** @param listenerMethodDescriptors the event firing methods.\n-\t ** @param addListenerMethod the add listener method.\n-\t ** @param removeListenerMethod the remove listener method.\n-\t ** @exception IntrospectionException if the listenerType is not an EventListener,\n-\t **                                   or any of the methods are invalid.\n-\t **/\n-\tpublic EventSetDescriptor(String eventSetName,\n-\t\t\t\t   Class listenerType,\n-\t\t\t\t   MethodDescriptor[] listenerMethodDescriptors,\n-\t\t\t\t   Method addListenerMethod,\n-\t\t\t\t   Method removeListenerMethod) throws IntrospectionException {\n-\t\tsetName(eventSetName);\n-\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n-\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n-\t\t}\n-\n-\t\tthis.listenerMethodDescriptors = listenerMethodDescriptors;\n-\t\tthis.listenerMethods = new Method[listenerMethodDescriptors.length];\n-\t\tfor(int i=0;i<this.listenerMethodDescriptors.length;i++) {\n-\t\t\tthis.listenerMethods[i] = this.listenerMethodDescriptors[i].getMethod();\n-\t\t}\n-\n-\t\tthis.addListenerMethod = addListenerMethod;\n-\t\tthis.removeListenerMethod = removeListenerMethod;\n-\t\tthis.listenerType = listenerType;\n-\t\tcheckMethods();\n-\t\tcheckAddListenerUnicast();\n-\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n-\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n-\t\t}\n-\t}\n-\n-\t/** Get the class that contains the event firing methods. **/\n-\tpublic Class getListenerType() {\n-\t\treturn listenerType;\n-\t}\n-\n-\t/** Get the event firing methods. **/\n-\tpublic Method[] getListenerMethods() {\n-\t\treturn listenerMethods;\n-\t}\n-\n-\t/** Get the event firing methods as MethodDescriptors. **/\n-\tpublic MethodDescriptor[] getListenerMethodDescriptors() {\n-\t\tif(listenerMethodDescriptors == null) {\n-\t\t\tlistenerMethodDescriptors = new MethodDescriptor[listenerMethods.length];\n-\t\t\tfor(int i=0;i<listenerMethods.length;i++) {\n-\t\t\t\tlistenerMethodDescriptors[i] = new MethodDescriptor(listenerMethods[i]);\n-\t\t\t}\n-\t\t}\n-\t\treturn listenerMethodDescriptors;\n-\t}\n-\n-\t/** Get the add listener method. **/\n-\tpublic Method getAddListenerMethod() {\n-\t\treturn addListenerMethod;\n-\t}\n-\n-\t/** Get the remove listener method. **/\n-\tpublic Method getRemoveListenerMethod() {\n-\t\treturn removeListenerMethod;\n-\t}\n-\n-\t/** Set whether or not multiple listeners may be added.\n-\t ** @param unicast whether or not multiple listeners may be added.\n-\t **/\n-\tpublic void setUnicast(boolean unicast) {\n-\t\tthis.unicast = unicast;\n-\t}\n-\n-\t/** Get whether or not multiple listeners may be added.  (Defaults to false.) **/\n-\tpublic boolean isUnicast() {\n-\t\treturn unicast;\n-\t}\n-\n-\t/** Set whether or not this is in the default event set.\n-\t ** @param inDefaultEventSet whether this is in the default event set.\n-\t **/\n-\tpublic void setInDefaultEventSet(boolean inDefaultEventSet) {\n-\t\tthis.inDefaultEventSet = inDefaultEventSet;\n-\t}\n-\n-\t/** Get whether or not this is in the default event set.  (Defaults to true.)**/\n-\tpublic boolean isInDefaultEventSet() {\n-\t\treturn inDefaultEventSet;\n-\t}\n-\n-\tprivate void checkAddListenerUnicast() throws IntrospectionException {\n-\t\tClass[] addListenerExceptions = this.addListenerMethod.getExceptionTypes();\n-\t\tif(addListenerExceptions.length > 1) {\n-\t\t\tthrow new IntrospectionException(\"Listener add method throws too many exceptions.\");\n-\t\t} else if(addListenerExceptions.length == 1\n-\t\t\t  && !java.util.TooManyListenersException.class.isAssignableFrom(addListenerExceptions[0])) {\n-\t\t\tthrow new IntrospectionException(\"Listener add method throws too many exceptions.\");\n-\t\t}\n-\t}\n-\n-\tprivate void checkMethods() throws IntrospectionException {\n-\t\tif(!addListenerMethod.getDeclaringClass().isAssignableFrom(removeListenerMethod.getDeclaringClass())\n-\t\t   && !removeListenerMethod.getDeclaringClass().isAssignableFrom(addListenerMethod.getDeclaringClass())) {\n-\t\t\tthrow new IntrospectionException(\"add and remove listener methods do not come from the same class.  This is bad.\");\n-\t\t}\n-\t\tif(!addListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n-                   || addListenerMethod.getParameterTypes().length != 1\n-\t\t   || !listenerType.equals(addListenerMethod.getParameterTypes()[0])\n-\t\t   || !Modifier.isPublic(addListenerMethod.getModifiers())) {\n-\t\t\tthrow new IntrospectionException(\"Add Listener Method invalid.\");\n-\t\t}\n-\t\tif(!removeListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n-                   || removeListenerMethod.getParameterTypes().length != 1\n-\t\t   || !listenerType.equals(removeListenerMethod.getParameterTypes()[0])\n-\t\t   || removeListenerMethod.getExceptionTypes().length > 0\n-\t\t   || !Modifier.isPublic(removeListenerMethod.getModifiers())) {\n-\t\t\tthrow new IntrospectionException(\"Remove Listener Method invalid.\");\n-\t\t}\n-\n-\t\tfor(int i=0;i<listenerMethods.length;i++) {\n-\t\t\tif(!listenerMethods[i].getReturnType().equals(java.lang.Void.TYPE)\n-\t\t\t   || Modifier.isPrivate(listenerMethods[i].getModifiers())) {\n-\t\t\t\tthrow new IntrospectionException(\"Event Method \" + listenerMethods[i].getName() + \" non-void or private.\");\n-\t\t\t}\n-\t\t\tif(!listenerMethods[i].getDeclaringClass().isAssignableFrom(listenerType)) {\n-\t\t\t\tthrow new IntrospectionException(\"Event Method \" + listenerMethods[i].getName() + \" not from class \" + listenerType.getName());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void findMethods(Class eventSourceClass,\n-\t\tClass listenerType,\n-\t\tString listenerMethodNames[],\n-\t\tString addListenerMethodName,\n-\t\tString removeListenerMethodName,\n-\t\tString absurdEventClassCheckName) throws IntrospectionException {\n-\n-\t\t/* Find add listener method and remove listener method. */\n-\t\tClass[] listenerArgList = new Class[1];\n-\t\tlistenerArgList[0] = listenerType;\n-\t\ttry {\n-\t\t\tthis.addListenerMethod = eventSourceClass.getMethod(addListenerMethodName,listenerArgList);\n-\t\t} catch(SecurityException E) {\n-\t\t\tthrow new IntrospectionException(\"SecurityException trying to access method \" + addListenerMethodName + \".\");\n-\t\t} catch(NoSuchMethodException E) {\n-\t\t\tthrow new IntrospectionException(\"Could not find method \" + addListenerMethodName + \".\");\n-\t\t}\n-\n-\t\tif(this.addListenerMethod == null || !this.addListenerMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n-\t\t\tthrow new IntrospectionException(\"Add listener method does not exist, is not public, or is not void.\");\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tthis.removeListenerMethod = eventSourceClass.getMethod(removeListenerMethodName,listenerArgList);\n-\t\t} catch(SecurityException E) {\n-\t\t\tthrow new IntrospectionException(\"SecurityException trying to access method \" + removeListenerMethodName + \".\");\n-\t\t} catch(NoSuchMethodException E) {\n-\t\t\tthrow new IntrospectionException(\"Could not find method \" + removeListenerMethodName + \".\");\n-\t\t}\n-\t\tif(this.removeListenerMethod == null || !this.removeListenerMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n-\t\t\tthrow new IntrospectionException(\"Remove listener method does not exist, is not public, or is not void.\");\n-\t\t}\n-\n-\t\t/* Find the listener methods. */\n-\t\tMethod[] methods;\n-\t\ttry {\n-\t\t\tmethods = ClassHelper.getAllMethods(listenerType);\n-\t\t} catch(SecurityException E) {\n-\t\t\tthrow new IntrospectionException(\"Security: You cannot access fields in this class.\");\n-\t\t}\n-\n-\t\tVector chosenMethods = new Vector();\n-\t\tboolean[] listenerMethodFound = new boolean[listenerMethodNames.length];\n-\t\tfor(int i=0;i<methods.length;i++) {\n-\t\t\tif(Modifier.isPrivate(methods[i].getModifiers())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tMethod currentMethod = methods[i];\n-\t\t\tClass retval = currentMethod.getReturnType();\n-\t\t\tif(retval.equals(java.lang.Void.TYPE)) {\n-\t\t\t\tfor(int j=0;j<listenerMethodNames.length;j++) {\n-\t\t\t\t\tif(currentMethod.getName().equals(listenerMethodNames[j])\n-\t\t\t\t\t   && (absurdEventClassCheckName == null\n-\t\t\t\t\t       || (currentMethod.getParameterTypes().length == 1\n-\t\t\t\t\t           && ((currentMethod.getParameterTypes()[0]).getName().equals(absurdEventClassCheckName)\n-\t\t\t\t\t               || (currentMethod.getParameterTypes()[0]).getName().endsWith(\".\"+absurdEventClassCheckName)\n-\t\t\t\t\t              )\n-\t\t\t\t\t          )\n-\t\t\t\t\t      )\n-\t\t\t\t\t  ) {\n-\t\t\t\t\t\tchosenMethods.addElement(currentMethod);\n-\t\t\t\t\t\tlistenerMethodFound[j] = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t/* Make sure we found all the methods we were looking for. */\n-\t\tfor(int i=0;i<listenerMethodFound.length;i++) {\n-\t\t\tif(!listenerMethodFound[i]) {\n-\t\t\t\tthrow new IntrospectionException(\"Could not find event method \" + listenerMethodNames[i]);\n-\t\t\t}\n-\t\t}\n-\n-\t\t/* Now that we've chosen the listener methods we want, store them. */\n-\t\tthis.listenerMethods = new Method[chosenMethods.size()];\n-\t\tfor(int i=0;i<chosenMethods.size();i++) {\n-\t\t\tthis.listenerMethods[i] = (Method)chosenMethods.elementAt(i);\n-\t\t}\n-\t}\n+ * EventSetDescriptor describes the hookup between an event source class and\n+ * an event listener class.\n+ * \n+ * <p>EventSets have several attributes: the listener class,\n+ * the events that can be fired to the listener (methods in the listener\n+ * class), and an add and remove listener method from the event firer's\n+ * class.\n+ * </p>\n+ * \n+ * <p>\n+ * The methods have these constraints on them:\n+ * <ul>\n+ * <li>event firing methods: must have <code>void</code> return value. Any\n+ * parameters and exceptions are allowed. May be public, protected or\n+ * package-protected. (Don't ask me why that is, I'm just following the spec.\n+ * The only place it is even mentioned is in the Java Beans white paper, and\n+ * there it is only implied.)</li>\n+ * \n+ * <li>add listener method: must have <code>void</code> return value. Must\n+ * take exactly one argument, of the listener class's type. May fire either\n+ * zero exceptions, or one exception of type\n+ * <code>java.util.TooManyListenersException</code>.\n+ * Must be public.</li>\n+ * \n+ * <li>remove listener method: must have <code>void</code> return value. Must\n+ * take exactly one argument, of the listener class's type. May not fire any\n+ * exceptions. Must be public.</li>\n+ * </ul>\n+ * \n+ * <p>\n+ * A final constraint is that event listener classes must extend from\n+ * EventListener.\n+ * </p>\n+ * \n+ * <p>\n+ * There are also various design patterns associated with some of the methods\n+ * of construction. Those are explained in more detail in the appropriate\n+ * constructors.\n+ * </p>\n+ * \n+ * <p>\n+ * <strong>Documentation Convention:</strong> for proper Internalization of\n+ * Beans inside an RAD tool, sometimes there are two names for a property or\n+ * method: a programmatic, or locale-independent name, which can be used\n+ * anywhere, and a localized, display name, for ease of use. In the\n+ * documentation I will specify different String values as either\n+ * <em>programmatic</em> or <em>localized</em> to make this distinction clear.\n+ * \n+ * @author John Keiser\n+ * @author Robert Schuster (robertschuster@fsfe.org)\n+ * @since 1.1\n+ */\n+\n+public class EventSetDescriptor extends FeatureDescriptor\n+{\n+  private Method addListenerMethod;\n+\n+  private Method removeListenerMethod;\n+\n+  private Class listenerType;\n+\n+  private MethodDescriptor[] listenerMethodDescriptors;\n+\n+  private Method[] listenerMethods;\n+\n+  private Method getListenerMethod;\n+\n+  private boolean unicast;\n+\n+  private boolean inDefaultEventSet = true;\n+\n+  /**\n+   * Creates a new <code>EventSetDescriptor</code<.\n+   * \n+   * <p>\n+   * This version of the constructor enforces the rules imposed on the methods\n+   * described at the top of this class, as well as searching for:\n+   * </p>\n+   * \n+   * <ol>\n+   * <li>\n+   * The event-firing method must be non-private with signature <code>void\n+   * &lt;listenerMethodName&gt;(&lt;eventSetName&gt;Event)</code> (where\n+   * <code>&lt;eventSetName&gt;</code> has its first character capitalized\n+   * by the constructor and the Event is a descendant of\n+   * {@link java.util.EventObject}) in class <code>listenerType</code>\n+   * (any exceptions may be thrown). <b>Implementation note:</b> Note that\n+   * there could conceivably be multiple methods with this type of signature\n+   * (example: <code>java.util.MouseEvent</code> vs.\n+   * <code>my.very.own.MouseEvent</code>). In this implementation, all\n+   * methods fitting the description will be put into the\n+   * <code>EventSetDescriptor</code>, even though the spec says only one\n+   * should be chosen (they probably weren't thinking as pathologically as I\n+   * was). I don't like arbitrarily choosing things. If your class has only one\n+   * such signature, as most do, you'll have no problems.</li>\n+   * \n+   * <li>The add and remove methods must be public and named <code>void\n+   * add&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</code> and\n+   * <code>void remove&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</code>\n+   * in in class <code>eventSourceClass</code>, where\n+   * <code>&lt;eventSetName&gt;</code> will have its first letter capitalized.\n+   * Standard exception rules (see class description) apply.</li>\n+   * </ol>\n+   * \n+   * @param eventSourceClass\n+   *          the class containing the add/remove listener methods.\n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu). This will\n+   *          be used to generate the name of the event object as well as the\n+   *          names of the add and remove methods.\n+   * @param listenerType\n+   *          the class containing the event firing method.\n+   * @param listenerMethodName\n+   *          the name of the event firing method.\n+   * @exception IntrospectionException\n+   *              if listenerType is not an EventListener, or if methods are not\n+   *              found or are invalid.\n+   */\n+  public EventSetDescriptor(Class eventSourceClass, String eventSetName,\n+                            Class listenerType, String listenerMethodName)\n+      throws IntrospectionException\n+  {\n+    setName(eventSetName);\n+    if (!java.util.EventListener.class.isAssignableFrom(listenerType))\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener type is not an EventListener.\");\n+      }\n+\n+    String[] names = new String[1];\n+    names[0] = listenerMethodName;\n+\n+    try\n+      {\n+        eventSetName = Character.toUpperCase(eventSetName.charAt(0))\n+                       + eventSetName.substring(1);\n+      }\n+    catch (StringIndexOutOfBoundsException e)\n+      {\n+        eventSetName = \"\";\n+      }\n+\n+    findMethods(eventSourceClass, listenerType, names,\n+                \"add\" + eventSetName + \"Listener\",\n+                \"remove\" + eventSetName + \"Listener\", eventSetName + \"Event\");\n+    this.listenerType = listenerType;\n+    checkAddListenerUnicast();\n+    if (this.removeListenerMethod.getExceptionTypes().length > 0)\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener remove method throws exceptions.\");\n+      }\n+  }\n+\n+  /**\n+   * Creates a new <code>EventSetDescriptor</code>.\n+   * \n+   * <p>This form of the constructor allows you to specify the names of the\n+   * methods and adds no new constraints on top of the rules already described\n+   * at the top of the class.\n+   * </p>\n+   * \n+   * @param eventSourceClass\n+   *          the class containing the add and remove listener methods.\n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu).\n+   * @param listenerType\n+   *          the class containing the event firing methods.\n+   * @param listenerMethodNames\n+   *          the names of the even firing methods.\n+   * @param addListenerMethodName\n+   *          the name of the add listener method.\n+   * @param removeListenerMethodName\n+   *          the name of the remove listener method.\n+   * @exception IntrospectionException\n+   *              if listenerType is not an EventListener or if methods are not\n+   *              found or are invalid.\n+   */\n+  public EventSetDescriptor(Class eventSourceClass, String eventSetName,\n+                            Class listenerType, String[] listenerMethodNames,\n+                            String addListenerMethodName,\n+                            String removeListenerMethodName)\n+      throws IntrospectionException\n+  {\n+    setName(eventSetName);\n+    if (!java.util.EventListener.class.isAssignableFrom(listenerType))\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener type is not an EventListener.\");\n+      }\n+\n+    findMethods(eventSourceClass, listenerType, listenerMethodNames,\n+                addListenerMethodName, removeListenerMethodName, null);\n+    this.listenerType = listenerType;\n+    checkAddListenerUnicast();\n+    if (this.removeListenerMethod.getExceptionTypes().length > 0)\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener remove method throws exceptions.\");\n+      }\n+  }\n+\n+  /**\n+   * Creates a new <code>EventSetDescriptor</code>.\n+   * \n+   * <p>\n+   * This variant of the constructor allows you to specify the names of the\n+   * methods and adds no new constraints on top of the rules already described\n+   * at the top of the class.\n+   * </p>\n+   * <p>\n+   * A valid GetListener method is public, flags no exceptions and has one\n+   * argument which is of type <code>Class</code>\n+   * {@link java.awt.Component#getListeners(Class)} is such a method.\n+   * </p>\n+   * <p>\n+   * Note: The validity of the return value of the GetListener method is not\n+   * checked.\n+   * </p>\n+   * \n+   * @param eventSourceClass\n+   *          the class containing the add and remove listener methods.\n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu).\n+   * @param listenerType\n+   *          the class containing the event firing methods.\n+   * @param listenerMethodNames\n+   *          the names of the even firing methods.\n+   * @param addListenerMethodName\n+   *          the name of the add listener method.\n+   * @param removeListenerMethodName\n+   *          the name of the remove listener method.\n+   * @param getListenerMethodName\n+   *          Name of a method which returns the array of listeners.\n+   * @exception IntrospectionException\n+   *              if listenerType is not an EventListener or if methods are not\n+   *              found or are invalid.\n+   * @since 1.4\n+   */\n+  public EventSetDescriptor(Class eventSourceClass, String eventSetName,\n+                            Class listenerType, String[] listenerMethodNames,\n+                            String addListenerMethodName,\n+                            String removeListenerMethodName,\n+                            String getListenerMethodName)\n+      throws IntrospectionException\n+  {\n+    this(eventSourceClass, eventSetName, listenerType, listenerMethodNames,\n+         addListenerMethodName, removeListenerMethodName);\n+\n+    Method newGetListenerMethod = null;\n+\n+    try\n+      {\n+        newGetListenerMethod \n+          = eventSourceClass.getMethod(getListenerMethodName,\n+                                       new Class[] { Class.class });\n+      }\n+    catch (NoSuchMethodException nsme)\n+      {\n+        throw (IntrospectionException) \n+          new IntrospectionException(\"No method named \" + getListenerMethodName\n+                                      + \" in class \" + listenerType\n+                                      + \" which can be used as\"\n+                                      + \" getListenerMethod.\").initCause(nsme);\n+      }\n+\n+    // Note: This does not check the return value (which\n+    // should be EventListener[]) but the JDK does not either.\n+\n+    getListenerMethod = newGetListenerMethod;\n+\n+  }\n+\n+  /**\n+   * Creates a new <code>EventSetDescriptor.</code>\n+   * \n+   * <p>\n+   * This variant of the constructor allows you to specify the names of the\n+   * methods and adds no new constraints on top of the rules already described\n+   * at the top of the class.\n+   * </p>\n+   * <p>\n+   * A valid GetListener method is public, flags no exceptions and has one\n+   * argument which is of type <code>Class</code>\n+   * {@link java.awt.Component#getListeners(Class)} is such a method.\n+   * </p>\n+   * <p>\n+   * Note: The validity of the return value of the GetListener method is not\n+   * checked.\n+   * </p>\n+   * \n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu).\n+   * @param listenerType\n+   *          the class containing the listenerMethods.\n+   * @param listenerMethods\n+   *          the event firing methods.\n+   * @param addListenerMethod\n+   *          the add listener method.\n+   * @param removeListenerMethod\n+   *          the remove listener method.\n+   * @param getListenerMethod\n+   *          The method which returns an array of the listeners.\n+   * @exception IntrospectionException\n+   *              if the listenerType is not an EventListener, or any of the\n+   *              methods are invalid.\n+   * @since 1.4\n+   */\n+  public EventSetDescriptor(String eventSetName, Class listenerType,\n+                            Method[] listenerMethods, Method addListenerMethod,\n+                            Method removeListenerMethod,\n+                            Method getListenerMethod)\n+      throws IntrospectionException\n+  {\n+    this(eventSetName, listenerType, listenerMethods, addListenerMethod,\n+         removeListenerMethod);\n+\n+    // Do no checks if the getListenerMethod is null.\n+    if (getListenerMethod.getParameterTypes().length != 1\n+        || getListenerMethod.getParameterTypes()[0] != Class.class\n+        || getListenerMethod.getExceptionTypes().length > 0\n+        || !Modifier.isPublic(getListenerMethod.getModifiers()))\n+      throw new IntrospectionException(\"GetListener method is invalid.\");\n+\n+    // Note: This does not check the return value (which\n+    // should be EventListener[]) but the JDK does not either.\n+\n+    this.getListenerMethod = getListenerMethod;\n+  }\n+\n+  /**\n+   * Creates a new <code>EventSetDescriptor</code>.\n+   * \n+   * <p>This form of constructor allows you to explicitly say which methods\n+   * do what, and no reflection is done by the <code>EventSetDescriptor</code>.\n+   * The methods are, however, checked to ensure that they follow the rules\n+   * set forth at the top of the class.\n+   * \n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu).\n+   * @param listenerType\n+   *          the class containing the listenerMethods.\n+   * @param listenerMethods\n+   *          the event firing methods.\n+   * @param addListenerMethod\n+   *          the add listener method.\n+   * @param removeListenerMethod\n+   *          the remove listener method.\n+   * @exception IntrospectionException\n+   *              if the listenerType is not an EventListener, or any of the\n+   *              methods are invalid.\n+   */\n+  public EventSetDescriptor(String eventSetName, Class listenerType,\n+                            Method[] listenerMethods, Method addListenerMethod,\n+                            Method removeListenerMethod)\n+      throws IntrospectionException\n+  {\n+    setName(eventSetName);\n+    if (!java.util.EventListener.class.isAssignableFrom(listenerType))\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener type is not an EventListener.\");\n+      }\n+\n+    this.listenerMethods = listenerMethods;\n+    this.addListenerMethod = addListenerMethod;\n+    this.removeListenerMethod = removeListenerMethod;\n+    this.listenerType = listenerType;\n+    checkMethods();\n+    checkAddListenerUnicast();\n+    if (this.removeListenerMethod.getExceptionTypes().length > 0)\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener remove method throws exceptions.\");\n+      }\n+  }\n+\n+  /** Creates a new <code>EventSetDescriptor</code>.\n+   * \n+   * <p>This form of constructor allows you to explicitly say which methods do\n+   * what, and no reflection is done by the <code>EventSetDescriptor</code>.\n+   * The methods are, however, checked to ensure that they follow the rules\n+   * set forth at the top of the class.\n+   * \n+   * @param eventSetName\n+   *          the programmatic name of the event set, generally starting with a\n+   *          lowercase letter (i.e. fooManChu instead of FooManChu).\n+   * @param listenerType\n+   *          the class containing the listenerMethods.\n+   * @param listenerMethodDescriptors\n+   *          the event firing methods.\n+   * @param addListenerMethod\n+   *          the add listener method.\n+   * @param removeListenerMethod\n+   *          the remove listener method.\n+   * @exception IntrospectionException\n+   *              if the listenerType is not an EventListener, or any of the\n+   *              methods are invalid.\n+   */\n+  public EventSetDescriptor(String eventSetName, Class listenerType,\n+                            MethodDescriptor[] listenerMethodDescriptors,\n+                            Method addListenerMethod,\n+                            Method removeListenerMethod)\n+      throws IntrospectionException\n+  {\n+    setName(eventSetName);\n+    if (!java.util.EventListener.class.isAssignableFrom(listenerType))\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener type is not an EventListener.\");\n+      }\n+\n+    this.listenerMethodDescriptors = listenerMethodDescriptors;\n+    this.listenerMethods = new Method[listenerMethodDescriptors.length];\n+    for (int i = 0; i < this.listenerMethodDescriptors.length; i++)\n+      {\n+        this.listenerMethods[i]\n+           = this.listenerMethodDescriptors[i].getMethod();\n+      }\n+\n+    this.addListenerMethod = addListenerMethod;\n+    this.removeListenerMethod = removeListenerMethod;\n+    this.listenerType = listenerType;\n+    checkMethods();\n+    checkAddListenerUnicast();\n+    if (this.removeListenerMethod.getExceptionTypes().length > 0)\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener remove method throws exceptions.\");\n+      }\n+  }\n+\n+  /** Returns the class that contains the event firing methods.\n+   */\n+  public Class getListenerType()\n+  {\n+    return listenerType;\n+  }\n+\n+  /** Returns the event firing methods.\n+   */\n+  public Method[] getListenerMethods()\n+  {\n+    return listenerMethods;\n+  }\n+\n+  /** Returns the event firing methods as {@link MethodDescriptor}.\n+   */\n+  public MethodDescriptor[] getListenerMethodDescriptors()\n+  {\n+    if (listenerMethodDescriptors == null)\n+      {\n+        listenerMethodDescriptors\n+          = new MethodDescriptor[listenerMethods.length];\n+        \n+        for (int i = 0; i < listenerMethods.length; i++)\n+          {\n+            listenerMethodDescriptors[i]\n+              = new MethodDescriptor(listenerMethods[i]);\n+          }\n+      }\n+    \n+    return listenerMethodDescriptors;\n+  }\n+\n+  /** Returns the add listener method.\n+   */\n+  public Method getAddListenerMethod()\n+  {\n+    return addListenerMethod;\n+  }\n+\n+  /* Returns the remove listener method.\n+   */\n+  public Method getRemoveListenerMethod()\n+  {\n+    return removeListenerMethod;\n+  }\n+\n+  /**\n+   * Returns the method that retrieves the listeners or <code>null</code> if\n+   * it does not exist.\n+   */\n+  public Method getGetListenerMethod()\n+  {\n+    return getListenerMethod;\n+  }\n+\n+  /** Sets whether or not multiple listeners may be added.\n+   * \n+   * @param unicast\n+   *          whether or not multiple listeners may be added.\n+   */\n+  public void setUnicast(boolean unicast)\n+  {\n+    this.unicast = unicast;\n+  }\n+\n+  /** Returns whether or not multiple listeners may be added.\n+   * (Defaults to false.)\n+   */\n+  public boolean isUnicast()\n+  {\n+    return unicast;\n+  }\n+\n+  /** Sets whether or not this is in the default event set.\n+   * \n+   * @param inDefaultEventSet\n+   *          whether this is in the default event set.\n+   */\n+  public void setInDefaultEventSet(boolean inDefaultEventSet)\n+  {\n+    this.inDefaultEventSet = inDefaultEventSet;\n+  }\n+\n+  /** Returns whether or not this is in the default event set.\n+   * (Defaults to true.)\n+   */\n+  public boolean isInDefaultEventSet()\n+  {\n+    return inDefaultEventSet;\n+  }\n+\n+  private void checkAddListenerUnicast() throws IntrospectionException\n+  {\n+    Class[] addListenerExceptions = this.addListenerMethod.getExceptionTypes();\n+    if (addListenerExceptions.length > 1)\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener add method throws too many exceptions.\");\n+      }\n+    else if (addListenerExceptions.length == 1\n+             && !java.util.TooManyListenersException.class\n+                .isAssignableFrom(addListenerExceptions[0]))\n+      {\n+        throw new IntrospectionException(\n+                  \"Listener add method throws too many exceptions.\");\n+      }\n+  }\n+\n+  private void checkMethods() throws IntrospectionException\n+  {\n+    if (!addListenerMethod.getDeclaringClass()\n+        .isAssignableFrom(removeListenerMethod.getDeclaringClass())\n+        && !removeListenerMethod.getDeclaringClass()\n+        .isAssignableFrom(addListenerMethod.getDeclaringClass()))\n+      {\n+        throw new IntrospectionException(\n+                  \"add and remove listener methods do not come from the\"\n+                  + \" same class.  This is bad.\");\n+      }\n+    if (!addListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n+        || addListenerMethod.getParameterTypes().length != 1\n+        || !listenerType.equals(addListenerMethod.getParameterTypes()[0])\n+        || !Modifier.isPublic(addListenerMethod.getModifiers()))\n+      {\n+        throw new IntrospectionException(\"Add Listener Method invalid.\");\n+      }\n+    if (!removeListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n+        || removeListenerMethod.getParameterTypes().length != 1\n+        || !listenerType.equals(removeListenerMethod.getParameterTypes()[0])\n+        || removeListenerMethod.getExceptionTypes().length > 0\n+        || !Modifier.isPublic(removeListenerMethod.getModifiers()))\n+      {\n+        throw new IntrospectionException(\"Remove Listener Method invalid.\");\n+      }\n+\n+    for (int i = 0; i < listenerMethods.length; i++)\n+      {\n+        if (!listenerMethods[i].getReturnType().equals(java.lang.Void.TYPE)\n+            || Modifier.isPrivate(listenerMethods[i].getModifiers()))\n+          {\n+            throw new IntrospectionException(\"Event Method \"\n+                                             + listenerMethods[i].getName()\n+                                             + \" non-void or private.\");\n+          }\n+        if (!listenerMethods[i].getDeclaringClass()\n+            .isAssignableFrom(listenerType))\n+          {\n+            throw new IntrospectionException(\"Event Method \"\n+                                             + listenerMethods[i].getName()\n+                                             + \" not from class \"\n+                                             + listenerType.getName());\n+          }\n+      }\n+  }\n+\n+  private void findMethods(Class eventSourceClass, Class listenerType,\n+                           String listenerMethodNames[],\n+                           String addListenerMethodName,\n+                           String removeListenerMethodName,\n+                           String absurdEventClassCheckName)\n+      throws IntrospectionException\n+  {\n+\n+    /* Find add listener method and remove listener method. */\n+    Class[] listenerArgList = new Class[1];\n+    listenerArgList[0] = listenerType;\n+    try\n+      {\n+        this.addListenerMethod\n+          = eventSourceClass.getMethod(addListenerMethodName,\n+                                       listenerArgList);\n+      }\n+    catch (SecurityException E)\n+      {\n+        throw new IntrospectionException(\n+                  \"SecurityException trying to access method \"\n+                  + addListenerMethodName + \".\");\n+      }\n+    catch (NoSuchMethodException E)\n+      {\n+        throw new IntrospectionException(\"Could not find method \"\n+                                         + addListenerMethodName + \".\");\n+      }\n+\n+    if (this.addListenerMethod == null\n+        || !this.addListenerMethod.getReturnType().equals(java.lang.Void.TYPE))\n+      {\n+        throw new IntrospectionException(\n+                  \"Add listener method does not exist, is not public,\"\n+                  + \" or is not void.\");\n+      }\n+\n+    try\n+      {\n+        this.removeListenerMethod\n+          = eventSourceClass.getMethod(removeListenerMethodName,\n+                                       listenerArgList);\n+      }\n+    catch (SecurityException E)\n+      {\n+        throw new IntrospectionException(\n+                  \"SecurityException trying to access method \"\n+                  + removeListenerMethodName + \".\");\n+      }\n+    catch (NoSuchMethodException E)\n+      {\n+        throw new IntrospectionException(\"Could not find method \"\n+                                         + removeListenerMethodName + \".\");\n+      }\n+    if (this.removeListenerMethod == null\n+        || !this.removeListenerMethod.getReturnType()\n+           .equals(java.lang.Void.TYPE))\n+      {\n+        throw new IntrospectionException(\n+                  \"Remove listener method does not exist, is not public,\"\n+                  + \" or is not void.\");\n+      }\n+\n+    /* Find the listener methods. */\n+    Method[] methods;\n+    try\n+      {\n+        methods = ClassHelper.getAllMethods(listenerType);\n+      }\n+    catch (SecurityException E)\n+      {\n+        throw new IntrospectionException(\n+                  \"Security: You cannot access fields in this class.\");\n+      }\n+\n+    Vector chosenMethods = new Vector();\n+    boolean[] listenerMethodFound = new boolean[listenerMethodNames.length];\n+    for (int i = 0; i < methods.length; i++)\n+      {\n+        if (Modifier.isPrivate(methods[i].getModifiers()))\n+          {\n+            continue;\n+          }\n+        Method currentMethod = methods[i];\n+        Class retval = currentMethod.getReturnType();\n+        if (retval.equals(java.lang.Void.TYPE))\n+          {\n+            for (int j = 0; j < listenerMethodNames.length; j++)\n+              {\n+                if (currentMethod.getName().equals(listenerMethodNames[j])\n+                    && (absurdEventClassCheckName == null\n+                    || (currentMethod.getParameterTypes().length == 1\n+                    && ((currentMethod.getParameterTypes()[0])\n+                        .getName().equals(absurdEventClassCheckName)\n+                    || (currentMethod.getParameterTypes()[0])\n+                       .getName().endsWith(\".\" + absurdEventClassCheckName)))))\n+                  {\n+                    chosenMethods.addElement(currentMethod);\n+                    listenerMethodFound[j] = true;\n+                  }\n+              }\n+          }\n+      }\n+\n+    /* Make sure we found all the methods we were looking for. */\n+    for (int i = 0; i < listenerMethodFound.length; i++)\n+      {\n+        if (!listenerMethodFound[i])\n+          {\n+            throw new IntrospectionException(\"Could not find event method \"\n+                                             + listenerMethodNames[i]);\n+          }\n+      }\n+\n+    /* Now that we've chosen the listener methods we want, store them. */\n+    this.listenerMethods = new Method[chosenMethods.size()];\n+    for (int i = 0; i < chosenMethods.size(); i++)\n+      {\n+        this.listenerMethods[i] = (Method) chosenMethods.elementAt(i);\n+      }\n+  }\n+  \n }"}, {"sha": "b327864d95f23e73bf572b70e50b230751dd968d", "filename": "libjava/classpath/java/beans/Expression.java", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FExpression.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FExpression.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FExpression.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "1a7306d14db99460f2fe9c38a9b268616d50e038", "filename": "libjava/classpath/java/beans/IndexedPropertyChangeEvent.java", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FIndexedPropertyChangeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FIndexedPropertyChangeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FIndexedPropertyChangeEvent.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "23c3cde5e3d699a76bd4bc4ad5242f950a3aeac7", "filename": "libjava/classpath/java/beans/Introspector.java", "status": "modified", "additions": 150, "deletions": 54, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FIntrospector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FIntrospector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FIntrospector.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b33cbcbed06fde2ebb80192790f223e1fac75e45", "filename": "libjava/classpath/java/beans/PersistenceDelegate.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FPersistenceDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FPersistenceDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FPersistenceDelegate.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "991390b563142a976bc19fa701f75f5e2c8a51b6", "filename": "libjava/classpath/java/beans/PropertyChangeSupport.java", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FPropertyChangeSupport.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "62a5ad7b6f806739f965c45a5a7a9cb18e0fbb35", "filename": "libjava/classpath/java/beans/Statement.java", "status": "modified", "additions": 86, "deletions": 79, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FStatement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FStatement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FStatement.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "f9cbe63963d4d4944261f402f5da1726692e054a", "filename": "libjava/classpath/java/beans/XMLEncoder.java", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FXMLEncoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fbeans%2FXMLEncoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fbeans%2FXMLEncoder.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "43e8e5ded6c83033aece473aeeb6dc24145c6d9c", "filename": "libjava/classpath/java/io/File.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FFile.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "ef8fd4542db9631dc6cbaf7ebb0c15c548ebdcfc", "filename": "libjava/classpath/java/io/InputStreamReader.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FInputStreamReader.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "750c6989f25e1052edad2d6a1b282e1284b19613", "filename": "libjava/classpath/java/io/ObjectInputStream.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FObjectInputStream.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "961d5e3099fb370a8ceec9cc57b257bea3b6f720", "filename": "libjava/classpath/java/io/ObjectOutputStream.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FObjectOutputStream.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "203e4a5abaaa2c3d4d0838df36881eacd4125a47", "filename": "libjava/classpath/java/io/ObjectStreamClass.java", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FObjectStreamClass.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "572683834be1e0703989a56c1f6ce064aec24c80", "filename": "libjava/classpath/java/io/OutputStreamWriter.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FOutputStreamWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FOutputStreamWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FOutputStreamWriter.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "99af25583b0e897426a3b6df7825970865b96656", "filename": "libjava/classpath/java/io/PrintStream.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FPrintStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FPrintStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FPrintStream.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "84ee5dec01ed65bca07798746d62c8a73b300612", "filename": "libjava/classpath/java/io/RandomAccessFile.java", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FRandomAccessFile.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b4695ab3d09094958ea6a833621715ecc6541a2e", "filename": "libjava/classpath/java/io/StreamTokenizer.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FStreamTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fio%2FStreamTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FStreamTokenizer.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3c88ff805c7ac77da368ec5452b3c4fbd476ac34", "filename": "libjava/classpath/java/lang/Character.java", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FCharacter.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "c4235e6808c97a4afd65a5ead9513d7610de4c1b", "filename": "libjava/classpath/java/lang/Class.java", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FClass.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "03c560689210cd3838315812f6065fe55030e74f", "filename": "libjava/classpath/java/lang/Double.java", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FDouble.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "dcd5b221197e3e1c8777b29bb95a97e6174ae15b", "filename": "libjava/classpath/java/lang/Float.java", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FFloat.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b9c7624ef44531d0ca4a06153688d640caed577a", "filename": "libjava/classpath/java/lang/InheritableThreadLocal.java", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FInheritableThreadLocal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FInheritableThreadLocal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FInheritableThreadLocal.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "30ee1be086fdec412c2f7fea5d2522c9885cf18b", "filename": "libjava/classpath/java/lang/SecurityManager.java", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FSecurityManager.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "cf4d1c76f4dc6300f80c68bf8b5ae42ab032a1e9", "filename": "libjava/classpath/java/lang/StackTraceElement.java", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FStackTraceElement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FStackTraceElement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FStackTraceElement.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "231afc77b9228ddabf80c56e222feb174c4e52e0", "filename": "libjava/classpath/java/lang/String.java", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FString.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9afde5bfd0337867220fb1420271f9920e129ba7", "filename": "libjava/classpath/java/lang/Thread.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FThread.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "aceb2557a54a93fb98455d16b2076b483cf9f054", "filename": "libjava/classpath/java/lang/ThreadLocal.java", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FThreadLocal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Flang%2FThreadLocal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Flang%2FThreadLocal.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d8837c006b5d82c281bd64f5cafa078b3682a5a0", "filename": "libjava/classpath/java/net/DatagramSocket.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FDatagramSocket.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "7277331bb26eb708447121296471f13e450133d4", "filename": "libjava/classpath/java/net/InetAddress.java", "status": "modified", "additions": 5, "deletions": 134, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "168c67a19ee6ffca81860fc5077dec21a8104e4b", "filename": "libjava/classpath/java/net/URL.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3637703a32ca76fa3c37a938be9744a62fc11b31", "filename": "libjava/classpath/java/nio/charset/Charset.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2FCharset.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2FCharset.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2FCharset.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "496ccf92789b0b86c322ea8676263b96be621783", "filename": "libjava/classpath/java/nio/charset/spi/CharsetProvider.java", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnio%2Fcharset%2Fspi%2FCharsetProvider.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8a6af645be1ea3c15c13edf91fbf120388f57c41", "filename": "libjava/classpath/java/security/MessageDigest.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fsecurity%2FMessageDigest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fsecurity%2FMessageDigest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fsecurity%2FMessageDigest.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d26d049c524be9df13c412ef96b6610bdd5f2ef8", "filename": "libjava/classpath/java/security/Security.java", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fsecurity%2FSecurity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Fsecurity%2FSecurity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fsecurity%2FSecurity.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "57b9a88dfa7a1221e1429f440feb830f47dc08c6", "filename": "libjava/classpath/java/text/Bidi.java", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Ftext%2FBidi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Ftext%2FBidi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Ftext%2FBidi.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "a9ec7767f94668ce5807a9c281671831873f0426", "filename": "libjava/classpath/java/text/DecimalFormat.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Ftext%2FDecimalFormat.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b4ab882addf07f40adb46bc8c483d1d5699deadf", "filename": "libjava/classpath/java/util/AbstractMap.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FAbstractMap.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "50b5638ede0faf304b188a973705a909fff492df", "filename": "libjava/classpath/java/util/ArrayList.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FArrayList.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "dc37bad8a93252260fee80725d70930c5e2ab7ad", "filename": "libjava/classpath/java/util/Collections.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "76b0d5c15bd1a40a5331032b03ee276ef81a613f", "filename": "libjava/classpath/java/util/Hashtable.java", "status": "modified", "additions": 166, "deletions": 66, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FHashtable.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "eb208f5a93d5a44122b98c484031b11c25bb44dd", "filename": "libjava/classpath/java/util/Properties.java", "status": "modified", "additions": 56, "deletions": 170, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FProperties.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "21298c75ec71a2ea0fee4cba5b64bd28bcb8bc4e", "filename": "libjava/classpath/java/util/StringTokenizer.java", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FStringTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FStringTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FStringTokenizer.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2ed982ac32d87e71696eaa6cd0f87f5719c6517e", "filename": "libjava/classpath/java/util/WeakHashMap.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FWeakHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2FWeakHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FWeakHashMap.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8f5769be1b9483a014873d810507b4f3bf855e4b", "filename": "libjava/classpath/java/util/logging/XMLFormatter.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2Flogging%2FXMLFormatter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2Flogging%2FXMLFormatter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2Flogging%2FXMLFormatter.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d39f1cfb04de985f179bda6872449c53c2fddc09", "filename": "libjava/classpath/java/util/regex/Pattern.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2Fregex%2FPattern.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjava%2Futil%2Fregex%2FPattern.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2Fregex%2FPattern.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "dff7edcf152882d13f0427817bfff9e172abfb8d", "filename": "libjava/classpath/javax/crypto/CipherInputStream.java", "status": "modified", "additions": 99, "deletions": 114, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fcrypto%2FCipherInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fcrypto%2FCipherInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fcrypto%2FCipherInputStream.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "5c4a65e4088b5ff719e2d78f5a0ddd721c4b740d", "filename": "libjava/classpath/javax/management/Attribute.java", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fmanagement%2FAttribute.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fmanagement%2FAttribute.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fmanagement%2FAttribute.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "1251b00bb3512ef5bacb53b1e33dfd3dbafcc4a6", "filename": "libjava/classpath/javax/print/AttributeException.java", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FAttributeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FAttributeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2FAttributeException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "879f10807d7a66d7f5cc9541894cb748a47b36f5", "filename": "libjava/classpath/javax/print/FlavorException.java", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FFlavorException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FFlavorException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2FFlavorException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "6fd46b506252d12b285611e1a025d3d02decee71", "filename": "libjava/classpath/javax/print/PrintException.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FPrintException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FPrintException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2FPrintException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9b22bdf2ff675d5a904e123f0ea9f32dc981f87c", "filename": "libjava/classpath/javax/print/URIException.java", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FURIException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2FURIException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2FURIException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "aca4c0188ec804f7290b73cbbc226145e1be96f6", "filename": "libjava/classpath/javax/print/attribute/ResolutionSyntax.java", "status": "modified", "additions": 79, "deletions": 26, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FResolutionSyntax.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FResolutionSyntax.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FResolutionSyntax.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "4c0dd2f19a9bb3599f2c2ff7adc3e1ac8204258b", "filename": "libjava/classpath/javax/print/attribute/SetOfIntegerSyntax.java", "status": "modified", "additions": 115, "deletions": 50, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSetOfIntegerSyntax.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSetOfIntegerSyntax.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSetOfIntegerSyntax.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0b5c10070f1f78658bd11cb6f114428bffe1c40a", "filename": "libjava/classpath/javax/print/attribute/Size2DSyntax.java", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSize2DSyntax.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSize2DSyntax.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FSize2DSyntax.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2daab6ec32579b0f7f6448894bd70d22886caec0", "filename": "libjava/classpath/javax/print/attribute/TextSyntax.java", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FTextSyntax.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FTextSyntax.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2FTextSyntax.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "cc834f680a281692b2d9154f603d7c10342649ad", "filename": "libjava/classpath/javax/print/attribute/standard/Chromaticity.java", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FChromaticity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FChromaticity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FChromaticity.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bca932dd735ef3315aae93ee07e7bcbacd046a4e", "filename": "libjava/classpath/javax/print/attribute/standard/ColorSupported.java", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FColorSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FColorSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FColorSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d29ffa0fcaf7253f64295704d8f882cafcc89f3a", "filename": "libjava/classpath/javax/print/attribute/standard/Compression.java", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCompression.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCompression.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCompression.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "78ca6c6cc63a914ff65ac00dc20c459d3c7df6c5", "filename": "libjava/classpath/javax/print/attribute/standard/Copies.java", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopies.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopies.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopies.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "fec426becd4b10b67532c0204a4f359b1c825174", "filename": "libjava/classpath/javax/print/attribute/standard/CopiesSupported.java", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopiesSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopiesSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FCopiesSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "36b740ef30f8ee70530ffd4c92b76abd16dc2e73", "filename": "libjava/classpath/javax/print/attribute/standard/DateTimeAtCompleted.java", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCompleted.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCompleted.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCompleted.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b463c40ac88d3f5450d34c52fccd09cf2141bd12", "filename": "libjava/classpath/javax/print/attribute/standard/DateTimeAtCreation.java", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCreation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCreation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtCreation.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "42dee8048ebc088ccb89ef35fc414cd863c63f97", "filename": "libjava/classpath/javax/print/attribute/standard/DateTimeAtProcessing.java", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtProcessing.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtProcessing.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDateTimeAtProcessing.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "1a4e79dd8f83afbd43d1ebd90e5b26570c337b63", "filename": "libjava/classpath/javax/print/attribute/standard/Destination.java", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDestination.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDestination.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDestination.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d1428ed8b799c7940a388a1ed125538006201655", "filename": "libjava/classpath/javax/print/attribute/standard/DocumentName.java", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDocumentName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDocumentName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FDocumentName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "02e292f58b4eabc227ba41b4108e96d555dc2a00", "filename": "libjava/classpath/javax/print/attribute/standard/Fidelity.java", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFidelity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFidelity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFidelity.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "6d474a6ead182df5797e98e9b728cc58cc78e2f6", "filename": "libjava/classpath/javax/print/attribute/standard/Finishings.java", "status": "modified", "additions": 205, "deletions": 21, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFinishings.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFinishings.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FFinishings.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "768600f80655cc4fedd61b711a8321733dc66a4b", "filename": "libjava/classpath/javax/print/attribute/standard/JobHoldUntil.java", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobHoldUntil.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobHoldUntil.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobHoldUntil.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0da3e59cf24c317c7be919c2005ea8ae11d88804", "filename": "libjava/classpath/javax/print/attribute/standard/JobImpressions.java", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressions.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "82da507a0444b5217c86d0aef2c4eb39d1a81bea", "filename": "libjava/classpath/javax/print/attribute/standard/JobImpressionsCompleted.java", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsCompleted.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsCompleted.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsCompleted.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bd10457513cec5f368b30d965f7b7ae8934a6088", "filename": "libjava/classpath/javax/print/attribute/standard/JobImpressionsSupported.java", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobImpressionsSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b380aa17ce950e4f6a6a9213e9e40d32913ac6b6", "filename": "libjava/classpath/javax/print/attribute/standard/JobKOctets.java", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctets.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctets.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctets.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "762369565e2f51902e90e917e795b2488b4e25c1", "filename": "libjava/classpath/javax/print/attribute/standard/JobKOctetsProcessed.java", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsProcessed.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsProcessed.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsProcessed.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8a4cbfc8c16d57cd0d300fa02147465c00c2e784", "filename": "libjava/classpath/javax/print/attribute/standard/JobKOctetsSupported.java", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobKOctetsSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "75e072c54a6ac2459dd1703790a964342ec24e80", "filename": "libjava/classpath/javax/print/attribute/standard/JobMediaSheets.java", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheets.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheets.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheets.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "85b9ab0481e6ad2e9ea0e93993bd3a4385e6d9a8", "filename": "libjava/classpath/javax/print/attribute/standard/JobMediaSheetsCompleted.java", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsCompleted.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsCompleted.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsCompleted.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "cb06af6fabe60eab2f594d39fbbe86e6d9363cbb", "filename": "libjava/classpath/javax/print/attribute/standard/JobMediaSheetsSupported.java", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMediaSheetsSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8eaae357c8810cbbc7e131f69bc7e0b8a457f529", "filename": "libjava/classpath/javax/print/attribute/standard/JobMessageFromOperator.java", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMessageFromOperator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMessageFromOperator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobMessageFromOperator.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "c848a63d35e07749bea01a7bef014da5f5437aa3", "filename": "libjava/classpath/javax/print/attribute/standard/JobName.java", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2d6e79df65434b7f33ad1edb08e05235b9d9aae9", "filename": "libjava/classpath/javax/print/attribute/standard/JobOriginatingUserName.java", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobOriginatingUserName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobOriginatingUserName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobOriginatingUserName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bcfb239ed9bba63a2a5c305f53aeb09dc5ca4bba", "filename": "libjava/classpath/javax/print/attribute/standard/JobPriority.java", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPriority.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPriority.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPriority.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0db7107b304d829c6bbc2c29cbdd984e45627ea3", "filename": "libjava/classpath/javax/print/attribute/standard/JobPrioritySupported.java", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPrioritySupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPrioritySupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobPrioritySupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d61acfee99ca01797c9abc10b319068ae39cf463", "filename": "libjava/classpath/javax/print/attribute/standard/JobSheets.java", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobSheets.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobSheets.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobSheets.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bd09e1fb1d29bde84ec78509c140df25665603dd", "filename": "libjava/classpath/javax/print/attribute/standard/JobState.java", "status": "modified", "additions": 97, "deletions": 10, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobState.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bd831cda51f965f58ff8a86de3e9751b0a5a754d", "filename": "libjava/classpath/javax/print/attribute/standard/JobStateReason.java", "status": "modified", "additions": 194, "deletions": 3, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReason.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReason.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReason.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9dbca0cd57b921b284ce336c088170e91e7f8588", "filename": "libjava/classpath/javax/print/attribute/standard/JobStateReasons.java", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReasons.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReasons.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FJobStateReasons.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "202a3f3f091d59d6ab9cd08f42f40c39193ed60e", "filename": "libjava/classpath/javax/print/attribute/standard/Media.java", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMedia.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMedia.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMedia.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2fa7cea097016b87a0385a9d17162a24c2d06e9e", "filename": "libjava/classpath/javax/print/attribute/standard/MediaName.java", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9a1342cb43f3cf04a8d0ffd86043bc04e6eca787", "filename": "libjava/classpath/javax/print/attribute/standard/MediaPrintableArea.java", "status": "modified", "additions": 190, "deletions": 25, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaPrintableArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaPrintableArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaPrintableArea.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "00bcb34954f0294978c2f2405d9d65d2c4335ccc", "filename": "libjava/classpath/javax/print/attribute/standard/MediaSize.java", "status": "modified", "additions": 715, "deletions": 4, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSize.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSize.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSize.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "e29b1ae34c725f1adaf1f30dd8b453911e60c2c8", "filename": "libjava/classpath/javax/print/attribute/standard/MediaSizeName.java", "status": "modified", "additions": 363, "deletions": 1, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSizeName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSizeName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaSizeName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "23811a0a407698f79aef5269f8ff98fc7a93b258", "filename": "libjava/classpath/javax/print/attribute/standard/MediaTray.java", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaTray.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaTray.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMediaTray.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "1ed0c913830a6021e723c11c2b0c41b304f60687", "filename": "libjava/classpath/javax/print/attribute/standard/MultipleDocumentHandling.java", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMultipleDocumentHandling.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMultipleDocumentHandling.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FMultipleDocumentHandling.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b9363eb91017cbd579ea25c2c4907f411a994bc0", "filename": "libjava/classpath/javax/print/attribute/standard/NumberOfDocuments.java", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfDocuments.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfDocuments.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfDocuments.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d3c0952fcae12d03d43b4253b11ebeaf84e55905", "filename": "libjava/classpath/javax/print/attribute/standard/NumberOfInterveningJobs.java", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfInterveningJobs.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfInterveningJobs.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberOfInterveningJobs.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "aa2324040af7d64aee8094a13fb3162e1e903134", "filename": "libjava/classpath/javax/print/attribute/standard/NumberUp.java", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUp.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "71392a9ef5291f7ec9ae37ece451da3fcd150f7f", "filename": "libjava/classpath/javax/print/attribute/standard/NumberUpSupported.java", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUpSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUpSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FNumberUpSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "1f9f0bf6f7e0f3f4904d6bd203d954973a95beb9", "filename": "libjava/classpath/javax/print/attribute/standard/OrientationRequested.java", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOrientationRequested.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOrientationRequested.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOrientationRequested.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "917064f54465c27e1ce6da0513fc8b22141eccaf", "filename": "libjava/classpath/javax/print/attribute/standard/OutputDeviceAssigned.java", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOutputDeviceAssigned.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOutputDeviceAssigned.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FOutputDeviceAssigned.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d3be3e5522a10e55698c5f2c7cac2917fd1c9bf6", "filename": "libjava/classpath/javax/print/attribute/standard/PDLOverrideSupported.java", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPDLOverrideSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPDLOverrideSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPDLOverrideSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3aa1b562549582b51bff8a3e45775e33244dfe4b", "filename": "libjava/classpath/javax/print/attribute/standard/PageRanges.java", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPageRanges.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPageRanges.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPageRanges.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "c06fb9746af9cf19991ef3ec88926af17ccbacd7", "filename": "libjava/classpath/javax/print/attribute/standard/PagesPerMinute.java", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinute.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinute.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinute.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "80a397e6381328274c30b79ad2e82db9c73eaa18", "filename": "libjava/classpath/javax/print/attribute/standard/PagesPerMinuteColor.java", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinuteColor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinuteColor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPagesPerMinuteColor.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3a479abfac4a16d1baf41d5138ae8b419f973e95", "filename": "libjava/classpath/javax/print/attribute/standard/PresentationDirection.java", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPresentationDirection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPresentationDirection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPresentationDirection.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2f1a105ce5470880cb95d2be33b284d844a6a737", "filename": "libjava/classpath/javax/print/attribute/standard/PrintQuality.java", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrintQuality.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrintQuality.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrintQuality.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2cd496cf0c7ed40cca192de5ee752c426f89bf46", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterInfo.java", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterInfo.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "51f96c11d6bdecf369ff8e1a3ab3d35520be27a3", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterIsAcceptingJobs.java", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterIsAcceptingJobs.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterIsAcceptingJobs.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterIsAcceptingJobs.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "35b61e4e5d11da3af8de9ad90988d6a93c31a80b", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterLocation.java", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterLocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterLocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterLocation.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "7010746a522f11fb96cac7fea52719a267af60ec", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterMakeAndModel.java", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMakeAndModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMakeAndModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMakeAndModel.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b4f5d88bd45a12f0551e46ad97082b22bf76a5a0", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterMessageFromOperator.java", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMessageFromOperator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMessageFromOperator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMessageFromOperator.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "28abd4e3fb6835004f75649d419927fcc960366a", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterMoreInfo.java", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfo.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "df0232e167d1f63f4e164b69bc11053bd54b4247", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterMoreInfoManufacturer.java", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfoManufacturer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfoManufacturer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterMoreInfoManufacturer.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "5b7da605969a9de0ee30b53d7023c3b66246d61c", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterName.java", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "f4cde0f5e72e4e30b193e0727b1a602f10d6b77d", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterResolution.java", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterResolution.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterResolution.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterResolution.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "6fd4c3f4643a1113318628ecc3dbae556ecf69bc", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterState.java", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterState.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3a13585441bc626cd2eb0bcf3ac5c0199981748f", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterStateReason.java", "status": "modified", "additions": 195, "deletions": 4, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReason.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReason.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReason.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "67f160d42fca6c26e42eb1bf5ded0e64ff38b697", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterStateReasons.java", "status": "modified", "additions": 135, "deletions": 4, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReasons.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReasons.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterStateReasons.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0deca90bed2b6468001b742d999eec48dcdd63da", "filename": "libjava/classpath/javax/print/attribute/standard/PrinterURI.java", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterURI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterURI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FPrinterURI.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8ff46a954590a1df46a2692148c32aa2aa77e780", "filename": "libjava/classpath/javax/print/attribute/standard/QueuedJobCount.java", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FQueuedJobCount.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FQueuedJobCount.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FQueuedJobCount.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8a00218b8b715c6c6fe2af077d2421dae1ea2c6c", "filename": "libjava/classpath/javax/print/attribute/standard/ReferenceUriSchemesSupported.java", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FReferenceUriSchemesSupported.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FReferenceUriSchemesSupported.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FReferenceUriSchemesSupported.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8b947036c456d36f1a90856fc182be124229b995", "filename": "libjava/classpath/javax/print/attribute/standard/RequestingUserName.java", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FRequestingUserName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FRequestingUserName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FRequestingUserName.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "5569816de8ea01b0135e807243cf4981b6bb9f5d", "filename": "libjava/classpath/javax/print/attribute/standard/Severity.java", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSeverity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSeverity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSeverity.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "5343bc6df1b5b4c5a65ed0965fc0dfbf43d6e26c", "filename": "libjava/classpath/javax/print/attribute/standard/SheetCollate.java", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSheetCollate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSheetCollate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSheetCollate.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "816365aedea4485f40f439678d93041cc35ee96b", "filename": "libjava/classpath/javax/print/attribute/standard/Sides.java", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSides.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSides.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2FSides.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "4248acfcedcf7c7efe92e716ac1cf298cabc4ce2", "filename": "libjava/classpath/javax/print/attribute/standard/package.html", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2Fpackage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2Fpackage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fprint%2Fattribute%2Fstandard%2Fpackage.html?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "32f739a31067e654717d06d63366cc3d8cd17ead", "filename": "libjava/classpath/javax/security/auth/login/AccountException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "c2b61c6e0282d1d45c16cdfea02f6080334a855d", "filename": "libjava/classpath/javax/security/auth/login/AccountExpiredException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountExpiredException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bcb8b4f8dfcae5cf94161a5e7a1398a519489dca", "filename": "libjava/classpath/javax/security/auth/login/AccountLockedException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountLockedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountLockedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountLockedException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "a052fbf68763841a45bc42e52c9dcf5de740c4bc", "filename": "libjava/classpath/javax/security/auth/login/AccountNotFoundException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountNotFoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountNotFoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FAccountNotFoundException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "980adde9e51b3563c8cfba1540719a945f397dac", "filename": "libjava/classpath/javax/security/auth/login/CredentialException.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9827a3d86d32a41eb96f838f03b611073f158b5a", "filename": "libjava/classpath/javax/security/auth/login/CredentialExpiredException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialExpiredException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "08ac115e34963537344b65f86050c6c74d4e233f", "filename": "libjava/classpath/javax/security/auth/login/CredentialNotFoundException.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialNotFoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialNotFoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FCredentialNotFoundException.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "740e67b8baa7c1edefe4538a84f0129b94b6374e", "filename": "libjava/classpath/javax/security/auth/login/LoginContext.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fsecurity%2Fauth%2Flogin%2FLoginContext.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "bd3167e1e93b0f77d58db320c4439c84c10786d3", "filename": "libjava/classpath/javax/swing/AbstractAction.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractAction.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "408dea934f8f640e6786eec2565d3bd0543309aa", "filename": "libjava/classpath/javax/swing/BoxLayout.java", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FBoxLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FBoxLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FBoxLayout.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "747eba54db4a0e4334766ec63ba7b2f785b8b2c4", "filename": "libjava/classpath/javax/swing/JComponent.java", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3560ffd57d40481b062ad7644999f3401b2923b0", "filename": "libjava/classpath/javax/swing/JEditorPane.java", "status": "modified", "additions": 139, "deletions": 8, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "3a9d6a01f38acd782f2bd400bd1d43c692c66e2b", "filename": "libjava/classpath/javax/swing/JFileChooser.java", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "761955d6dd91d81b0e4af959e1c7187163eb7d91", "filename": "libjava/classpath/javax/swing/JFormattedTextField.java", "status": "modified", "additions": 354, "deletions": 73, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "948988c24a7ad410180db424c7b163f81ec32121", "filename": "libjava/classpath/javax/swing/JInternalFrame.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJInternalFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJInternalFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJInternalFrame.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "dc8b10d2178d2cd236d8051b64e993a35e55eddf", "filename": "libjava/classpath/javax/swing/JLayeredPane.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "d0e1090b8c900597b3832ef5f73b74b02eb7d9cf", "filename": "libjava/classpath/javax/swing/JList.java", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "b2cfbd14ae857233e6d913037065e4292a4c712e", "filename": "libjava/classpath/javax/swing/JMenuItem.java", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "abca3e7ae02ede330991a0227933fb777707a12b", "filename": "libjava/classpath/javax/swing/JProgressBar.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "8a7d4c07fa75992a3cf67d5762c05dc3d4b860d4", "filename": "libjava/classpath/javax/swing/JTabbedPane.java", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0875306a0127e00101137aa9ba98c16890ed6da3", "filename": "libjava/classpath/javax/swing/JTable.java", "status": "modified", "additions": 111, "deletions": 25, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "9b50febe3617bac4164e36ac107d3112867da696", "filename": "libjava/classpath/javax/swing/JTextArea.java", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextArea.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "c4903106131eafa56e1e201a6fc11f405b4796aa", "filename": "libjava/classpath/javax/swing/JTextField.java", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextField.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "7c95d7682c55625f08ca9921e1b51282b4bb807d", "filename": "libjava/classpath/javax/swing/JTextPane.java", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "cfcb2291b2cbb2e1b8e0d4aa3a08abd4e45951a0", "filename": "libjava/classpath/javax/swing/JTree.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "debb5742e2c6af927c174fb2a4238b11a170eb8e", "filename": "libjava/classpath/javax/swing/JViewport.java", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "358a811b36270ee497c4fa2a1e9ce21268359279", "filename": "libjava/classpath/javax/swing/LookAndFeel.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FLookAndFeel.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "203ee3c9b0cc63bcc62d9ab96ffd3a37501d1790", "filename": "libjava/classpath/javax/swing/Popup.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FPopup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FPopup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FPopup.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "0be81053dc538a698694269ed4fe2fe2f69f3388", "filename": "libjava/classpath/javax/swing/RepaintManager.java", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "2d859b7448eb3c51b969e49f99a36669ba50243b", "filename": "libjava/classpath/javax/swing/SwingUtilities.java", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "830feee83326ab0eaa851eb2864cc647d4a697e3", "filename": "libjava/classpath/javax/swing/TransferHandler.java", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "00d9700d0d25c8c53acec724cd1c4535c7253b48", "filename": "libjava/classpath/javax/swing/UIDefaults.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java?ref=2127637945ea6b763966398130e0770fa993c860"}, {"sha": "79fd26c56dfd9a897726adfa7738b77c90ba5b27", "filename": "libjava/classpath/javax/swing/ViewportLayout.java", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FViewportLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2127637945ea6b763966398130e0770fa993c860/libjava%2Fclasspath%2Fjavax%2Fswing%2FViewportLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FViewportLayout.java?ref=2127637945ea6b763966398130e0770fa993c860"}]}