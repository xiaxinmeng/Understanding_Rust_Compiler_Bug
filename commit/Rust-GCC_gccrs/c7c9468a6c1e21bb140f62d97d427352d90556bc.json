{"sha": "c7c9468a6c1e21bb140f62d97d427352d90556bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjOTQ2OGE2YzFlMjFiYjE0MGY2MmQ5N2Q0MjczNTJkOTA1NTZiYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-07T07:43:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-07T07:43:27Z"}, "message": "Commit right version\n\nFrom-SVN: r256321", "tree": {"sha": "44dc5f52c8be41f5924da440c1dee731fca84f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44dc5f52c8be41f5924da440c1dee731fca84f99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7c9468a6c1e21bb140f62d97d427352d90556bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c9468a6c1e21bb140f62d97d427352d90556bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c9468a6c1e21bb140f62d97d427352d90556bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c9468a6c1e21bb140f62d97d427352d90556bc/comments", "author": null, "committer": null, "parents": [{"sha": "11ef0b22d68cd13e2c0f00ff5331b6ae875f3533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11ef0b22d68cd13e2c0f00ff5331b6ae875f3533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11ef0b22d68cd13e2c0f00ff5331b6ae875f3533"}], "stats": {"total": 63, "additions": 45, "deletions": 18}, "files": [{"sha": "6979403a4f492791d6f61cec2cc784841e40c7b2", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c9468a6c1e21bb140f62d97d427352d90556bc/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c9468a6c1e21bb140f62d97d427352d90556bc/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=c7c9468a6c1e21bb140f62d97d427352d90556bc", "patch": "@@ -698,9 +698,10 @@ builtin_access::builtin_access (gcall *call, builtin_memref &dst,\n \n \t  /* For string functions, adjust the size range of the source\n \t     reference by the inverse boundaries of the offset (because\n-\t     the higher  the offset into the string the shorter its\n+\t     the higher the offset into the string the shorter its\n \t     length).  */\n-\t  if (srcref->offrange[1] < srcref->sizrange[0])\n+\t  if (srcref->offrange[1] >= 0\n+\t      && srcref->offrange[1] < srcref->sizrange[0])\n \t    srcref->sizrange[0] -= srcref->offrange[1];\n \t  else\n \t    srcref->sizrange[0] = 0;\n@@ -1134,30 +1135,53 @@ builtin_access::overlap ()\n   if (!dstref->base || !srcref->base)\n     return false;\n \n-  /* If the base object is an array adjust the lower bound of the offset\n-     to be non-negative.  */\n+  /* Set the access offsets.  */\n+  acs.dstoff[0] = dstref->offrange[0];\n+  acs.dstoff[1] = dstref->offrange[1];\n+\n+  /* If the base object is an array adjust the bounds of the offset\n+     to be non-negative and within the bounds of the array if possible.  */\n   if (dstref->base\n       && TREE_CODE (TREE_TYPE (dstref->base)) == ARRAY_TYPE)\n-    acs.dstoff[0] = wi::smax (dstref->offrange[0], 0);\n-  else\n-    acs.dstoff[0] = dstref->offrange[0];\n+    {\n+      if (acs.dstoff[0] < 0 && acs.dstoff[1] >= 0)\n+\tacs.dstoff[0] = 0;\n \n-  acs.dstoff[1] = dstref->offrange[1];\n+      if (acs.dstoff[1] < acs.dstoff[0])\n+\t{\n+\t  if (tree size = TYPE_SIZE_UNIT (TREE_TYPE (dstref->base)))\n+\t    acs.dstoff[1] = wi::umin (acs.dstoff[1], wi::to_offset (size));\n+\t  else\n+\t    acs.dstoff[1] = wi::umin (acs.dstoff[1], maxobjsize);\n+\t}\n+    }\n+\n+  acs.srcoff[0] = srcref->offrange[0];\n+  acs.srcoff[1] = srcref->offrange[1];\n \n   if (srcref->base\n       && TREE_CODE (TREE_TYPE (srcref->base)) == ARRAY_TYPE)\n-    acs.srcoff[0] = wi::smax (srcref->offrange[0], 0);\n-  else\n-    acs.srcoff[0] = srcref->offrange[0];\n+    {\n+      if (acs.srcoff[0] < 0 && acs.srcoff[1] >= 0)\n+\tacs.srcoff[0] = 0;\n \n-  acs.srcoff[1] = srcref->offrange[1];\n+      if (tree size = TYPE_SIZE_UNIT (TREE_TYPE (srcref->base)))\n+\tacs.srcoff[1] = wi::umin (acs.srcoff[1], wi::to_offset (size));\n+      else if (acs.srcoff[1] < acs.srcoff[0])\n+\tacs.srcoff[1] = wi::umin (acs.srcoff[1], maxobjsize);\n+    }\n \n-  /* When the lower bound of the offset is less that the upper bound\n-     disregard it and use the inverse of the maximum object size\n-     instead.  The upper bound is the result of a negative offset\n-     being represented as a large positive value.  */\n+  /* When the upper bound of the offset is less than the lower bound\n+     the former is the result of a negative offset being represented\n+     as a large positive value or vice versa.  The resulting range is\n+     a union of two subranges: [MIN, UB] and [LB, MAX].  Since such\n+     a union is not representable using the current data structure\n+     replace it with the full range of offsets.  */\n   if (acs.dstoff[1] < acs.dstoff[0])\n-    acs.dstoff[0] = -maxobjsize;\n+    {\n+      acs.dstoff[0] = -maxobjsize - 1;\n+      acs.dstoff[1] = maxobjsize;\n+    }\n \n   /* Validate the offset and size of each reference on its own first.\n      This is independent of whether or not the base objects are the\n@@ -1173,7 +1197,10 @@ builtin_access::overlap ()\n \n   /* Repeat the same as above but for the source offsets.  */\n   if (acs.srcoff[1] < acs.srcoff[0])\n-    acs.srcoff[0] = -maxobjsize;\n+    {\n+      acs.srcoff[0] = -maxobjsize - 1;\n+      acs.srcoff[1] = maxobjsize;\n+    }\n \n   maxoff = acs.srcoff[0] + srcref->sizrange[0];\n   if (maxobjsize < maxoff)"}]}