{"sha": "02263a8a370f650d31f71376e1a899443c76fc82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyNjNhOGEzNzBmNjUwZDMxZjcxMzc2ZTFhODk5NDQzYzc2ZmM4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-09T13:45:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-09T13:45:20Z"}, "message": "i386.c (ia32_use_dfa_pipeline_interface): New function.\n\n        * i386.c (ia32_use_dfa_pipeline_interface): New function.  Use\n        the DFA interface for Pentium processors.\n        (TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE): DEFINE.\n        (attr_pent_pair, ix86_pent_find_pair): Remove.\n        (ix86_sched_reorder_pentium): Remove.\n        (ix86_sched_reorder): Remove reordering for Pentium.\n        * i386.md (Pentium scheduling): Rewrite using DFA description.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r53329", "tree": {"sha": "71b66607d6fc163734b1994b2515065833905aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b66607d6fc163734b1994b2515065833905aee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02263a8a370f650d31f71376e1a899443c76fc82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02263a8a370f650d31f71376e1a899443c76fc82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02263a8a370f650d31f71376e1a899443c76fc82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02263a8a370f650d31f71376e1a899443c76fc82/comments", "author": null, "committer": null, "parents": [{"sha": "a08cbd59a60d1428c46dcbcb00f7c2dc5a0681d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08cbd59a60d1428c46dcbcb00f7c2dc5a0681d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08cbd59a60d1428c46dcbcb00f7c2dc5a0681d7"}], "stats": {"total": 501, "additions": 203, "deletions": 298}, "files": [{"sha": "bb9bed7f689d881760acfb555dc3e2353f2621ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02263a8a370f650d31f71376e1a899443c76fc82", "patch": "@@ -1,3 +1,14 @@\n+Thu May  9 07:46:18 2002  Jan Hubicka <jh@suse.cz>\n+\t\t\t  Jeffrey A Law  (law@redhat.com)\n+\n+\t* i386.c (ia32_use_dfa_pipeline_interface): New function.  Use\n+\tthe DFA interface for Pentium processors.\n+\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE): DEFINE.\n+\t(attr_pent_pair, ix86_pent_find_pair): Remove.\n+\t(ix86_sched_reorder_pentium): Remove.\n+\t(ix86_sched_reorder): Remove reordering for Pentium.\n+\t* i386.md (Pentium scheduling): Rewrite using DFA description.\n+\n Thu May  9 14:55:39 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* cfganal.c (can_fallthru): Fix fast path."}, {"sha": "b3c76712732293363ce533cc979c868e861ce6b8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 141, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=02263a8a370f650d31f71376e1a899443c76fc82", "patch": "@@ -44,6 +44,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"langhooks.h\"\n \n+static int ia32_use_dfa_pipeline_interface PARAMS ((void));\n+\n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE ia32_use_dfa_pipeline_interface\n+\n+static int\n+ia32_use_dfa_pipeline_interface ()\n+{\n+  if (ix86_cpu == PROCESSOR_PENTIUM)\n+    return 1;\n+  return 0;\n+}\n+\n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n #endif\n@@ -659,12 +672,9 @@ static int ix86_flags_dependant PARAMS ((rtx, rtx, enum attr_type));\n static int ix86_agi_dependant PARAMS ((rtx, rtx, enum attr_type));\n static int ix86_safe_length PARAMS ((rtx));\n static enum attr_memory ix86_safe_memory PARAMS ((rtx));\n-static enum attr_pent_pair ix86_safe_pent_pair PARAMS ((rtx));\n static enum attr_ppro_uops ix86_safe_ppro_uops PARAMS ((rtx));\n static void ix86_dump_ppro_packet PARAMS ((FILE *));\n static void ix86_reorder_insn PARAMS ((rtx *, rtx *));\n-static rtx * ix86_pent_find_pair PARAMS ((rtx *, rtx *, enum attr_pent_pair,\n-\t\t\t\t\t rtx));\n static void ix86_init_machine_status PARAMS ((struct function *));\n static void ix86_mark_machine_status PARAMS ((struct function *));\n static void ix86_free_machine_status PARAMS ((struct function *));\n@@ -675,7 +685,6 @@ static void ix86_emit_save_regs PARAMS ((void));\n static void ix86_emit_save_regs_using_mov PARAMS ((rtx, HOST_WIDE_INT));\n static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int, int));\n static void ix86_set_move_mem_attrs_1 PARAMS ((rtx, rtx, rtx, rtx, rtx));\n-static void ix86_sched_reorder_pentium PARAMS ((rtx *, rtx *));\n static void ix86_sched_reorder_ppro PARAMS ((rtx *, rtx *));\n static HOST_WIDE_INT ix86_GOT_alias_set PARAMS ((void));\n static void ix86_adjust_counter PARAMS ((rtx, HOST_WIDE_INT));\n@@ -10311,16 +10320,6 @@ ix86_safe_memory (insn)\n     return MEMORY_UNKNOWN;\n }\n \n-static enum attr_pent_pair\n-ix86_safe_pent_pair (insn)\n-     rtx insn;\n-{\n-  if (recog_memoized (insn) >= 0)\n-    return get_attr_pent_pair (insn);\n-  else\n-    return PENT_PAIR_NP;\n-}\n-\n static enum attr_ppro_uops\n ix86_safe_ppro_uops (insn)\n      rtx insn;\n@@ -10374,129 +10373,6 @@ ix86_reorder_insn (insnp, slot)\n     }\n }\n \n-/* Find an instruction with given pairability and minimal amount of cycles\n-   lost by the fact that the CPU waits for both pipelines to finish before\n-   reading next instructions.  Also take care that both instructions together\n-   can not exceed 7 bytes.  */\n-\n-static rtx *\n-ix86_pent_find_pair (e_ready, ready, type, first)\n-     rtx *e_ready;\n-     rtx *ready;\n-     enum attr_pent_pair type;\n-     rtx first;\n-{\n-  int mincycles, cycles;\n-  enum attr_pent_pair tmp;\n-  enum attr_memory memory;\n-  rtx *insnp, *bestinsnp = NULL;\n-\n-  if (ix86_safe_length (first) > 7 + ix86_safe_length_prefix (first))\n-    return NULL;\n-\n-  memory = ix86_safe_memory (first);\n-  cycles = result_ready_cost (first);\n-  mincycles = INT_MAX;\n-\n-  for (insnp = e_ready; insnp >= ready && mincycles; --insnp)\n-    if ((tmp = ix86_safe_pent_pair (*insnp)) == type\n-\t&& ix86_safe_length (*insnp) <= 7 + ix86_safe_length_prefix (*insnp))\n-      {\n-\tenum attr_memory second_memory;\n-\tint secondcycles, currentcycles;\n-\n-\tsecond_memory = ix86_safe_memory (*insnp);\n-\tsecondcycles = result_ready_cost (*insnp);\n-\tcurrentcycles = abs (cycles - secondcycles);\n-\n-\tif (secondcycles >= 1 && cycles >= 1)\n-\t  {\n-\t    /* Two read/modify/write instructions together takes two\n-\t       cycles longer.  */\n-\t    if (memory == MEMORY_BOTH && second_memory == MEMORY_BOTH)\n-\t      currentcycles += 2;\n-\n-\t    /* Read modify/write instruction followed by read/modify\n-\t       takes one cycle longer.  */\n-\t    if (memory == MEMORY_BOTH && second_memory == MEMORY_LOAD\n-\t        && tmp != PENT_PAIR_UV\n-\t        && ix86_safe_pent_pair (first) != PENT_PAIR_UV)\n-\t      currentcycles += 1;\n-\t  }\n-\tif (currentcycles < mincycles)\n-\t  bestinsnp = insnp, mincycles = currentcycles;\n-      }\n-\n-  return bestinsnp;\n-}\n-\n-/* Subroutines of ix86_sched_reorder.  */\n-\n-static void\n-ix86_sched_reorder_pentium (ready, e_ready)\n-     rtx *ready;\n-     rtx *e_ready;\n-{\n-  enum attr_pent_pair pair1, pair2;\n-  rtx *insnp;\n-\n-  /* This wouldn't be necessary if Haifa knew that static insn ordering\n-     is important to which pipe an insn is issued to.  So we have to make\n-     some minor rearrangements.  */\n-\n-  pair1 = ix86_safe_pent_pair (*e_ready);\n-\n-  /* If the first insn is non-pairable, let it be.  */\n-  if (pair1 == PENT_PAIR_NP)\n-    return;\n-\n-  pair2 = PENT_PAIR_NP;\n-  insnp = 0;\n-\n-  /* If the first insn is UV or PV pairable, search for a PU\n-     insn to go with.  */\n-  if (pair1 == PENT_PAIR_UV || pair1 == PENT_PAIR_PV)\n-    {\n-      insnp = ix86_pent_find_pair (e_ready-1, ready,\n-\t\t\t\t   PENT_PAIR_PU, *e_ready);\n-      if (insnp)\n-\tpair2 = PENT_PAIR_PU;\n-    }\n-\n-  /* If the first insn is PU or UV pairable, search for a PV\n-     insn to go with.  */\n-  if (pair2 == PENT_PAIR_NP\n-      && (pair1 == PENT_PAIR_PU || pair1 == PENT_PAIR_UV))\n-    {\n-      insnp = ix86_pent_find_pair (e_ready-1, ready,\n-\t\t\t\t   PENT_PAIR_PV, *e_ready);\n-      if (insnp)\n-\tpair2 = PENT_PAIR_PV;\n-    }\n-\n-  /* If the first insn is pairable, search for a UV\n-     insn to go with.  */\n-  if (pair2 == PENT_PAIR_NP)\n-    {\n-      insnp = ix86_pent_find_pair (e_ready-1, ready,\n-\t\t\t\t   PENT_PAIR_UV, *e_ready);\n-      if (insnp)\n-\tpair2 = PENT_PAIR_UV;\n-    }\n-\n-  if (pair2 == PENT_PAIR_NP)\n-    return;\n-\n-  /* Found something!  Decide if we need to swap the order.  */\n-  if (pair1 == PENT_PAIR_PV || pair2 == PENT_PAIR_PU\n-      || (pair1 == PENT_PAIR_UV && pair2 == PENT_PAIR_UV\n-\t  && ix86_safe_memory (*e_ready) == MEMORY_BOTH\n-\t  && ix86_safe_memory (*insnp) == MEMORY_LOAD))\n-    ix86_reorder_insn (insnp, e_ready);\n-  else\n-    ix86_reorder_insn (insnp, e_ready - 1);\n-}\n-\n static void\n ix86_sched_reorder_ppro (ready, e_ready)\n      rtx *ready;\n@@ -10603,10 +10479,6 @@ ix86_sched_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n     default:\n       break;\n \n-    case PROCESSOR_PENTIUM:\n-      ix86_sched_reorder_pentium (ready, e_ready);\n-      break;\n-\n     case PROCESSOR_PENTIUMPRO:\n       ix86_sched_reorder_ppro (ready, e_ready);\n       break;"}, {"sha": "1fc139f46869783b4716e5983df93878228fb948", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 179, "deletions": 157, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02263a8a370f650d31f71376e1a899443c76fc82/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=02263a8a370f650d31f71376e1a899443c76fc82", "patch": "@@ -365,226 +365,248 @@\n \t]\n \t(const_string \"np\")))\n \n-;; Rough readiness numbers.  Fine tuning happens in i386.c.\n-;;\n-;; u\tdescribes pipe U\n-;; v\tdescribes pipe V\n-;; uv\tdescribes either pipe U or V for those that can issue to either\n-;; np\tdescribes not paring\n-;; fpu\tdescribes fpu\n-;; fpm\tdescribes fp insns of different types are not pipelined.\n-;;\n-;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n+(define_automaton \"pentium,pentium_fpu\")\n \n-(define_function_unit \"pent_np\" 1 0\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"imul\"))\n-  11 11)\n-\n-(define_function_unit \"pent_mul\" 1 1\n+;; Pentium do have U and V pipes.  Instruction to both pipes\n+;; are alwyas issued together, much like on VLIW.\n+;;\n+;;                    predecode\n+;;                   /         \\\n+;;               decodeu     decodev\n+;;             /    |           |\n+;;           fpu executeu    executev\n+;;            |     |           |\n+;;           fpu  retire     retire\n+;;            |\n+;;           fpu\n+;; We add dummy \"port\" pipes allocated only first cycle of\n+;; instruction to specify this behaviour.\n+\n+(define_cpu_unit \"pentium-portu,pentium-portv\" \"pentium\")\n+(define_cpu_unit \"pentium-u,pentium-v\" \"pentium\")\n+(absence_set \"pentium-portu\" \"pentium-u,pentium-v\")\n+(presence_set \"pentium-portv\" \"pentium-portu\")\n+\n+;; Floating point instructions can overlap with new issue of integer\n+;; instructions.  We model only first cycle of FP pipeline, as it is\n+;; fully pipelined.\n+(define_cpu_unit \"pentium-fp\" \"pentium_fpu\")\n+\n+;; There is non-pipelined multiplier unit used for complex operations.\n+(define_cpu_unit \"pentium-fmul\" \"pentium_fpu\")\n+\n+;; Pentium preserves memory ordering, so when load-execute-store\n+;; instruction is executed together with other instruction loading\n+;; data, the execution of the other instruction is delayed to very\n+;; last cycle of first instruction, when data are bypassed.\n+;; We model this by allocating \"memory\" unit when store is pending\n+;; and using conflicting load units together.\n+\n+(define_cpu_unit \"pentium-memory\" \"pentium\")\n+(define_cpu_unit \"pentium-load0\" \"pentium\")\n+(define_cpu_unit \"pentium-load1\" \"pentium\")\n+(absence_set \"pentium-load0,pentium-load1\" \"pentium-memory\")\n+\n+(define_reservation \"pentium-load\" \"(pentium-load0 | pentium-load1)\")\n+(define_reservation \"pentium-np\" \"(pentium-u + pentium-v)\")\n+(define_reservation \"pentium-uv\" \"(pentium-u | pentium-v)\")\n+(define_reservation \"pentium-portuv\" \"(pentium-portu | pentium-portv)\")\n+(define_reservation \"pentium-firstu\" \"(pentium-u + pentium-portu)\")\n+(define_reservation \"pentium-firstv\" \"(pentium-v + pentium-portuv)\")\n+(define_reservation \"pentium-firstuv\" \"(pentium-uv + pentium-portuv)\")\n+(define_reservation \"pentium-firstuload\" \"(pentium-load + pentium-firstu)\")\n+(define_reservation \"pentium-firstvload\" \"(pentium-load + pentium-firstv)\")\n+(define_reservation \"pentium-firstuvload\" \"(pentium-load + pentium-firstuv)\n+\t\t\t\t\t   | (pentium-firstv,pentium-v,\n+\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n+(define_reservation \"pentium-firstuboth\" \"(pentium-load + pentium-firstu\n+\t\t\t\t\t   + pentium-memory)\")\n+(define_reservation \"pentium-firstvboth\" \"(pentium-load + pentium-firstu\n+\t\t\t\t\t   + pentium-memory)\")\n+(define_reservation \"pentium-firstuvboth\" \"(pentium-load + pentium-firstuv\n+\t\t\t\t\t    + pentium-memory)\n+\t\t\t\t\t   | (pentium-firstv,pentium-v,\n+\t\t\t\t\t      (pentium-load+pentium-firstv))\")\n+\n+;; Few common long latency instructions\n+(define_insn_reservation \"pent_mul\" 11\n   (and (eq_attr \"cpu\" \"pentium\")\n        (eq_attr \"type\" \"imul\"))\n-  11 11)\n+  \"pentium-np*11\")\n \n-;; Rep movs takes minimally 12 cycles.\n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_str\" 12\n   (and (eq_attr \"cpu\" \"pentium\")\n        (eq_attr \"type\" \"str\"))\n-  12 12)\n+  \"pentium-np*12\")\n \n-; ??? IDIV for SI takes 46 cycles, for HI 30, for QI 22\n-(define_function_unit \"pent_np\" 1 0\n+;; Integer division and some other long latency instruction block all\n+;; units, including the FP pipe.  There is no value in modeling the\n+;; latency of these instructions and not modeling the latency\n+;; decreases the size of the DFA.\n+(define_insn_reservation \"pent_block\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n        (eq_attr \"type\" \"idiv\"))\n-  46 46)\n+  \"pentium-np+pentium-fp\")\n \n-; Fp reg-reg moves takes 1 cycle. Loads takes 1 cycle for SF/DF mode,\n-; 3 cycles for XFmode.  Stores takes 2 cycles for SF/DF and 3 for XF.\n-; fldz and fld1 takes 2 cycles.  Only reg-reg moves are pairable.\n-; The integer <-> fp conversion is not modeled correctly. Fild behaves\n-; like normal fp operation and fist takes 6 cycles.\n+(define_insn_reservation \"pent_cld\" 2\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"cld\"))\n+  \"pentium-np*2\")\n \n-(define_function_unit \"fpu\" 1 0\n+;;  Moves usually have one cycle penalty, but there are exceptions.\n+(define_insn_reservation \"pent_fmov\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n-\t    (and (eq_attr \"memory\" \"load,store\")\n-\t\t (eq_attr \"mode\" \"XF\"))))\n-  3 3)\n+\t    (eq_attr \"memory\" \"none,load\")))\n+  \"(pentium-fp+pentium-np)\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_fpmovxf\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n \t    (and (eq_attr \"memory\" \"load,store\")\n \t\t (eq_attr \"mode\" \"XF\"))))\n-  3 3)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"fmov\")\n-            (ior (match_operand 1 \"immediate_operand\" \"\")\n-\t         (eq_attr \"memory\" \"store\"))))\n-  2 2)\n+  \"(pentium-fp+pentium-np)*3\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_fpstore\" 2\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n-            (ior (match_operand 1 \"immediate_operand\" \"\")\n-\t         (eq_attr \"memory\" \"store\"))))\n-  2 2)\n+\t    (ior (match_operand 1 \"immediate_operand\" \"\")\n+\t\t (eq_attr \"memory\" \"store\"))))\n+  \"(pentium-fp+pentium-np)*2\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_imov\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"cld\"))\n-  2 2)\n-\n-(define_function_unit \"fpu\" 1 0\n+       (eq_attr \"type\" \"imov\"))\n+  \"pentium-firstuv\")\n+\n+;; Push and pop instructions have 1 cycle latency and special\n+;; hardware bypass allows them to be paired with other push,pop\n+;; and call instructions.\n+(define_bypass 0 \"pent_push,pent_pop\" \"pent_push,pent_pop,pent_call\")\n+(define_insn_reservation \"pent_push\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"fmov\")\n-\t    (eq_attr \"memory\" \"none,load\")))\n-  1 1)\n+       (and (eq_attr \"type\" \"push\")\n+\t    (eq_attr \"memory\" \"store\")))\n+  \"pentium-firstuv\")\n \n-; Read/Modify/Write instructions usually take 3 cycles.\n-(define_function_unit \"pent_u\" 1 0\n+(define_insn_reservation \"pent_pop\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,alu1,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"pu\")\n-\t\t (eq_attr \"memory\" \"both\"))))\n-  3 3)\n+       (eq_attr \"type\" \"pop\"))\n+  \"pentium-firstuv\")\n \n-(define_function_unit \"pent_uv\" 2 0\n+;; Call and branch instruction can execute in either pipe, but\n+;; they are only pairable when in the v pipe.\n+(define_insn_reservation \"pent_call\" 10\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,alu1,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"!np\")\n-\t\t (eq_attr \"memory\" \"both\"))))\n-  3 3)\n+       (eq_attr \"type\" \"call,callv\"))\n+  \"pentium-firstv,pentium-v*9\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_branch\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,alu1,negnot,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"np\")\n-\t\t (eq_attr \"memory\" \"both\"))))\n-  3 3)\n-\n-; Read/Modify or Modify/Write instructions usually take 2 cycles.\n-(define_function_unit \"pent_u\" 1 0\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"pu\")\n-\t\t (eq_attr \"memory\" \"load,store\"))))\n-  2 2)\n+       (eq_attr \"type\" \"ibr\"))\n+  \"pentium-firstv\")\n \n-(define_function_unit \"pent_uv\" 2 0\n+;; Floating point instruction dispatch in U pipe, but continue\n+;; in FP pipeline allowing other isntructions to be executed.\n+(define_insn_reservation \"pent_fp\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"!np\")\n-\t\t (eq_attr \"memory\" \"load,store\"))))\n-  2 2)\n+       (eq_attr \"type\" \"fop,fistp\"))\n+  \"(pentium-firstu+pentium-fp),nothing,nothing\")\n \n-(define_function_unit \"pent_np\" 1 0\n+;; First two cycles of fmul are not pipelined.\n+(define_insn_reservation \"pent_fmul\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"np\")\n-\t\t (eq_attr \"memory\" \"load,store\"))))\n-  2 2)\n+       (eq_attr \"type\" \"fmul\"))\n+  \"(pentium-firstuv+pentium-fp+pentium-fmul),pentium-fmul,nothing\")\n \n-; Insns w/o memory operands and move instructions usually take one cycle.\n-(define_function_unit \"pent_u\" 1 0\n+;; Long latency FP instructions overlap with integer instructions,\n+;; but only last 2 cycles with FP ones.\n+(define_insn_reservation \"pent_fdiv\" 39\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"pent_pair\" \"pu\"))\n-  1 1)\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"(pentium-np+pentium-fp+pentium-fmul),\n+   (pentium-fp+pentium-fmul)*36,pentium-fmul*2\")\n \n-(define_function_unit \"pent_v\" 1 0\n+(define_insn_reservation \"pent_fpspc\" 70\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"pent_pair\" \"pv\"))\n-  1 1)\n+       (eq_attr \"type\" \"fpspc\"))\n+  \"(pentium-np+pentium-fp+pentium-fmul),\n+   (pentium-fp+pentium-fmul)*67,pentium-fmul*2\")\n \n-(define_function_unit \"pent_uv\" 2 0\n+;; Integer instructions.  Load/execute/store takes 3 cycles,\n+;; load/execute 2 cycles and execute only one cycle.\n+(define_insn_reservation \"pent_uv_both\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"pent_pair\" \"!np\"))\n-  1 1)\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstuvboth,pentium-uv+pentium-memory,pentium-uv\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_u_both\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"pent_pair\" \"np\"))\n-  1 1)\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstuboth,pentium-u+pentium-memory,pentium-u\")\n \n-; Pairable insns only conflict with other non-pairable insns.\n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_v_both\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,alu1,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"!np\")\n-\t\t (eq_attr \"memory\" \"both\"))))\n-  3 3\n-  [(eq_attr \"pent_pair\" \"np\")])\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-firstvboth,pentium-v+pentium-memory,pentium-v\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_np_both\" 3\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (and (eq_attr \"type\" \"alu,alu1,ishift\")\n-\t    (and (eq_attr \"pent_pair\" \"!np\")\n-\t\t (eq_attr \"memory\" \"load,store\"))))\n-  2 2\n-  [(eq_attr \"pent_pair\" \"np\")])\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"both\")))\n+  \"pentium-np,pentium-np,pentium-np\")\n \n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_uv_load\" 2\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"pent_pair\" \"!np\"))\n-  1 1\n-  [(eq_attr \"pent_pair\" \"np\")])\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstuvload,pentium-uv\")\n \n-; Floating point instructions usually blocks cycle longer when combined with\n-; integer instructions, because of the inpaired fxch instruction.\n-(define_function_unit \"pent_np\" 1 0\n+(define_insn_reservation \"pent_u_load\" 2\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fmov,fop,fsgn,fmul,fpspc,fcmov,fcmp,fistp\"))\n-  2 2\n-  [(eq_attr \"type\" \"!fmov,fop,fsgn,fmul,fpspc,fcmov,fcmp,fistp\")])\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstuload,pentium-u\")\n \n-(define_function_unit \"fpu\" 1 0\n+(define_insn_reservation \"pent_v_load\" 2\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fcmp,fxch,fsgn\"))\n-  1 1)\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-firstvload,pentium-v\")\n \n-; Addition takes 3 cycles; assume other random cruft does as well.\n-; ??? Trivial fp operations such as fabs or fchs takes only one cycle.\n-(define_function_unit \"fpu\" 1 0\n+(define_insn_reservation \"pent_np_load\" 2\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fop,fistp\"))\n-  3 1)\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  \"pentium-np,pentium-np\")\n \n-; Multiplication takes 3 cycles and is only half pipelined.\n-(define_function_unit \"fpu\" 1 0\n+(define_insn_reservation \"pent_uv\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fmul\"))\n-  3 1)\n-\n-(define_function_unit \"pent_mul\" 1 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fmul\"))\n-  2 2)\n+       (and (eq_attr \"pent_pair\" \"uv\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstuv\")\n \n-; ??? This is correct only for fdiv and sqrt -- sin/cos take 65-100 cycles. \n-; They can overlap with integer insns.  Only the last two cycles can overlap\n-; with other fp insns.  Only fsin/fcos can overlap with multiplies.\n-; Only last two cycles of fsin/fcos can overlap with other instructions.\n-(define_function_unit \"fpu\" 1 0\n+(define_insn_reservation \"pent_u\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  39 37)\n+       (and (eq_attr \"pent_pair\" \"pu\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstu\")\n \n-(define_function_unit \"pent_mul\" 1 1\n+(define_insn_reservation \"pent_v\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  39 39)\n+       (and (eq_attr \"pent_pair\" \"pv\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-firstv\")\n \n-(define_function_unit \"fpu\" 1 0\n+(define_insn_reservation \"pent_np\" 1\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fpspc\"))\n-  70 68)\n+       (and (eq_attr \"pent_pair\" \"np\")\n+\t    (eq_attr \"memory\" \"none\")))\n+  \"pentium-np\")\n \n-(define_function_unit \"pent_mul\" 1 1\n-  (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fpspc\"))\n-  70 70)\n \f\n ;; Pentium Pro/PII Scheduling\n ;;"}]}