{"sha": "0694b47c7fffbe0a942f5558e102c5c3a16d18eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY5NGI0N2M3ZmZmYmUwYTk0MmY1NTU4ZTEwMmM1YzNhMTZkMThlYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T21:25:34Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-01T21:25:34Z"}, "message": "Initial revision\n\nFrom-SVN: r94", "tree": {"sha": "57564425e4a6aad7b59c2dfa0cfe1dd8c4c67d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57564425e4a6aad7b59c2dfa0cfe1dd8c4c67d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0694b47c7fffbe0a942f5558e102c5c3a16d18eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0694b47c7fffbe0a942f5558e102c5c3a16d18eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0694b47c7fffbe0a942f5558e102c5c3a16d18eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0694b47c7fffbe0a942f5558e102c5c3a16d18eb/comments", "author": null, "committer": null, "parents": [{"sha": "160e8c6bcefedbb0ea8721fb4fc1eef4f336f441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160e8c6bcefedbb0ea8721fb4fc1eef4f336f441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160e8c6bcefedbb0ea8721fb4fc1eef4f336f441"}], "stats": {"total": 192, "additions": 192, "deletions": 0}, "files": [{"sha": "1310ace37f2278ccd4e3787fedb0e64f5f2de685", "filename": "gcc/real.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0694b47c7fffbe0a942f5558e102c5c3a16d18eb/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0694b47c7fffbe0a942f5558e102c5c3a16d18eb/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=0694b47c7fffbe0a942f5558e102c5c3a16d18eb", "patch": "@@ -0,0 +1,192 @@\n+/* Front-end tree definitions for GNU compiler.\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef REAL_H_INCLUDED\n+#define REAL_H_INCLUDED\n+\n+/* Define codes for all the float formats that we know of.  */\n+#define UNKNOWN_FLOAT_FORMAT 0\n+#define IEEE_FLOAT_FORMAT 1\n+#define VAX_FLOAT_FORMAT 2\n+\n+/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n+\n+#ifndef TARGET_FLOAT_FORMAT\n+#define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n+#endif\n+\n+#ifndef HOST_FLOAT_FORMAT\n+#define\tHOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n+#endif\n+\n+#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+#define REAL_INFINITY\n+#endif\n+\n+#ifdef REAL_ARITHMETIC\n+/* Defining REAL_IS_NOT_DOUBLE breaks certain initializations\n+   when REAL_ARITHMETIC etc. are not defined.  */\n+\n+/* Now see if the host and target machines use the same format. \n+   If not, define REAL_IS_NOT_DOUBLE (even if we end up representing\n+   reals as doubles because we have no better way in this cross compiler.)\n+   This turns off various optimizations that can happen when we know the\n+   compiler's float format matches the target's float format.\n+   */\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+#define\tREAL_IS_NOT_DOUBLE\n+#ifndef REAL_VALUE_TYPE\n+#define REAL_VALUE_TYPE \\\n+  struct real_value { long i[sizeof (double) / sizeof (long)]; }\n+#endif /* no REAL_VALUE_TYPE */\n+#endif /* formats differ */\n+#endif /* 0 */\n+\n+/* If we are not cross-compiling, use a `double' to represent the\n+   floating-point value.  Otherwise, use some other type\n+   (probably a struct containing an array of longs).  */\n+#ifndef REAL_VALUE_TYPE\n+#define REAL_VALUE_TYPE double\n+#else\n+#define REAL_IS_NOT_DOUBLE\n+#endif\n+\n+/* Compare two floating-point values for equality.  */\n+#ifndef REAL_VALUES_EQUAL\n+#define REAL_VALUES_EQUAL(x,y) ((x) == (y))\n+#endif\n+\n+/* Compare two floating-point values for less than.  */\n+#ifndef REAL_VALUES_LESS\n+#define REAL_VALUES_LESS(x,y) ((x) < (y))\n+#endif\n+\n+/* Convert a floating-point value to integer by truncating.  */\n+#ifndef REAL_VALUE_FIX_TRUNCATE\n+#define REAL_VALUE_FIX_TRUNCATE(x) ((int) (x))\n+#endif\n+\n+/* Convert a floating-point value to unsigned integer by truncating.  */\n+#ifndef REAL_VALUE_UNSIGNED_FIX_TRUNCATE\n+#define REAL_VALUE_UNSIGNED_FIX_TRUNCATE(x) ((unsigned int) (x))\n+#endif\n+\n+/* Convert a floating-point value to integer, using any rounding mode.  */\n+#ifndef REAL_VALUE_FIX\n+#define REAL_VALUE_FIX(x) ((int) (x))\n+#endif\n+\n+/* Convert a floating-point value to unsigned integer, using any rounding\n+   mode.  */\n+#ifndef REAL_VALUE_UNSIGNED_FIX\n+#define REAL_VALUE_UNSIGNED_FIX(x) ((unsigned int) (x))\n+#endif\n+\n+/* Scale X by Y powers of 2.  */\n+#ifndef REAL_VALUE_LDEXP\n+#define REAL_VALUE_LDEXP(x,y) ldexp (x, y)\n+extern double ldexp ();\n+#endif\n+\n+/* Convert the string X to a floating-point value.  */\n+#ifndef REAL_VALUE_ATOF\n+#define REAL_VALUE_ATOF(x) atof (x)\n+#if defined (MIPSEL) || defined (MIPSEB)\n+/* MIPS compiler can't handle parens around the function name.\n+   This problem *does not* appear to be connected with any\n+   macro definition for atof.  It does not seem there is one.  */\n+extern double atof ();\n+#else\n+extern double (atof) ();\n+#endif\n+#endif\n+\n+/* Negate the floating-point value X.  */\n+#ifndef REAL_VALUE_NEGATE\n+#define REAL_VALUE_NEGATE(x) (- (x))\n+#endif\n+\n+/* Truncate the floating-point value X to mode MODE.  This is correct only\n+   for the most common case where the host and target have objects of the same\n+   size and where `float' is SFmode.  */\n+\n+#ifndef REAL_VALUE_TRUNCATE\n+#define REAL_VALUE_TRUNCATE(mode, x) \\\n+ (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (SFmode) ? (float) (x) : (x))\n+#endif\n+\n+/* Determine whether a floating-point value X is infinite. */\n+#ifndef REAL_VALUE_ISINF\n+#define REAL_VALUE_ISINF(x) (target_isinf (x))\n+#endif\n+\n+/* Determine whether a floating-point value X is minus 0. */\n+#ifndef REAL_VALUE_MINUS_ZERO\n+#define REAL_VALUE_MINUS_ZERO(x) (target_minus_zero (x))\n+#endif\n+\f\n+/* Constant real values 0, 1, 2, and -1.  */\n+\n+extern REAL_VALUE_TYPE dconst0;\n+extern REAL_VALUE_TYPE dconst1;\n+extern REAL_VALUE_TYPE dconst2;\n+extern REAL_VALUE_TYPE dconstm1;\n+\n+/* Union type used for extracting real values from CONST_DOUBLEs\n+   or putting them in.  */\n+\n+union real_extract \n+{\n+  REAL_VALUE_TYPE d;\n+  int i[sizeof (REAL_VALUE_TYPE) / sizeof (int)];\n+};\n+\n+/* For a CONST_DOUBLE:\n+   The usual two ints that hold the value.\n+   For a DImode, that is all there are;\n+    and CONST_DOUBLE_LOW is the low-order word and ..._HIGH the high-order.\n+   For a float, the number of ints varies,\n+    and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n+    So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n+#define CONST_DOUBLE_LOW(r) XINT (r, 2)\n+#define CONST_DOUBLE_HIGH(r) XINT (r, 3)\n+\n+/* Link for chain of all CONST_DOUBLEs in use in current function.  */\n+#define CONST_DOUBLE_CHAIN(r) XEXP (r, 1)\n+/* The MEM which represents this CONST_DOUBLE's value in memory,\n+   or const0_rtx if no MEM has been made for it yet,\n+   or cc0_rtx if it is not on the chain.  */\n+#define CONST_DOUBLE_MEM(r) XEXP (r, 0)\n+\n+/* Function to return a real value (not a tree node)\n+   from a given integer constant.  */\n+REAL_VALUE_TYPE real_value_from_int_cst ();\n+\n+/* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n+\n+#define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\n+do { union real_extract u;\t\t\t\t\\\n+     bcopy (&CONST_DOUBLE_LOW ((from)), &u, sizeof u);\t\\\n+     to = u.d; } while (0)\n+\n+/* Return a CONST_DOUBLE with value R and mode M.  */\n+\n+#define CONST_DOUBLE_FROM_REAL_VALUE(r,m) immed_real_const_1 (r, m)\n+\n+#endif /* Not REAL_H_INCLUDED */"}]}