{"sha": "b490c40dbcf2315591d68a4eba4c9d90c5fa5273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5MGM0MGRiY2YyMzE1NTkxZDY4YTRlYmE0YzlkOTBjNWZhNTI3Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T02:10:22Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T02:10:22Z"}, "message": "(stmt): Allow all_iter_stmt.\n\n(expr -> statement expression): Push and pop iterator stack.\n(stmt -> expr): Use iterator_expand.\n(all_iter_stmt): New rule.\n\nFrom-SVN: r3580", "tree": {"sha": "443e1de589b4b7084fcd5f5902c6ac5e455460b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/443e1de589b4b7084fcd5f5902c6ac5e455460b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b490c40dbcf2315591d68a4eba4c9d90c5fa5273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b490c40dbcf2315591d68a4eba4c9d90c5fa5273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b490c40dbcf2315591d68a4eba4c9d90c5fa5273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b490c40dbcf2315591d68a4eba4c9d90c5fa5273/comments", "author": null, "committer": null, "parents": [{"sha": "519d591f03527d0bd0b33ead719ea1e2d4e2f45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519d591f03527d0bd0b33ead719ea1e2d4e2f45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519d591f03527d0bd0b33ead719ea1e2d4e2f45a"}], "stats": {"total": 60, "additions": 59, "deletions": 1}, "files": [{"sha": "12c00d4bc85051b2ef2a334ebe3dfb6802845fc9", "filename": "gcc/c-parse.in", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b490c40dbcf2315591d68a4eba4c9d90c5fa5273/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b490c40dbcf2315591d68a4eba4c9d90c5fa5273/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=b490c40dbcf2315591d68a4eba4c9d90c5fa5273", "patch": "@@ -682,12 +682,14 @@ end ifobjc\n \t\t     there is a way to turn off the entire subtree of blocks\n \t\t     that are contained in it.  */\n \t\t  keep_next_level ();\n+\t\t  push_iterator_stack ();\n \t\t  push_label_level ();\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n \t\t{ tree rtl_exp;\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C forbids braced-groups within expressions\");\n+\t\t  pop_iterator_stack ();\n \t\t  pop_label_level ();\n \t\t  rtl_exp = expand_end_stmt_expr ($<ttype>2);\n \t\t  /* The statements have side effects, so the group does.  */\n@@ -1541,10 +1543,11 @@ stmt_or_label:\n stmt:\n \t  compstmt\n \t\t{ stmt_count++; }\n+        | all_iter_stmt \n \t| expr ';'\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_expr_stmt ($1);\n+\t\t  iterator_expand ($1);\n \t\t  clear_momentary (); }\n \t| simple_if ELSE\n \t\t{ expand_start_else ();\n@@ -1715,6 +1718,61 @@ stmt:\n \t| ';'\n \t;\n \n+all_iter_stmt:\n+\t  all_iter_stmt_simple\n+/*\t| all_iter_stmt_with_decl */\n+\t;\n+\n+all_iter_stmt_simple:\n+\t  FOR '(' primary ')' \n+\t  {\n+\t    /* The value returned by this action is  */\n+\t    /*      1 if everything is OK */ \n+\t    /*      0 in case of error or already bound iterator */\n+\n+\t    $<itype>$ = 0;\n+\t    if (TREE_CODE ($3) != VAR_DECL)\n+\t      error (\"invalid `for (ITERATOR)' syntax\");\n+\t    if (! ITERATOR_P ($3))\n+\t      error (\"`%s' is not an iterator\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n+\t    else if (ITERATOR_BOUND_P ($3))\n+\t      error (\"`for (%s)' inside expansion of same iterator\"\n+\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n+\t    else\n+\t      {\n+\t\t$<itype>$ = 1;\n+\t\titerator_for_loop_start ($3);\n+\t      }\n+\t  }\n+\t  lineno_labeled_stmt\n+\t  {\n+\t    if ($<itype>5)\n+\t      iterator_for_loop_end ($3);\n+\t  }\n+\n+/*  This really should allow any kind of declaration,\n+    for generality.  Fix it before turning it back on.\n+\n+all_iter_stmt_with_decl:\n+\t  FOR '(' ITERATOR pushlevel setspecs iterator_spec ')' \n+\t  {\n+*/\t    /* The value returned by this action is  */\n+\t    /*      1 if everything is OK */ \n+\t    /*      0 in case of error or already bound iterator */\n+/*\n+\t    iterator_for_loop_start ($6);\n+\t  }\n+\t  lineno_labeled_stmt\n+\t  {\n+\t    iterator_for_loop_end ($6);\n+\t    emit_line_note (input_filename, lineno);\n+\t    expand_end_bindings (getdecls (), 1, 0);\n+\t    $<ttype>$ = poplevel (1, 1, 0);\n+\t    pop_momentary ();\t    \n+\t  }\n+*/\n+\n /* Any kind of label, including jump labels and case labels.\n    ANSI C accepts labels only before statements, but we allow them\n    also at the end of a compound statement.  */"}]}