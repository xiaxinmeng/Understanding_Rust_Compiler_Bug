{"sha": "1a1c441dbe5933ebf9180831236aa5be7d70a434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWExYzQ0MWRiZTU5MzNlYmY5MTgwODMxMjM2YWE1YmU3ZDcwYTQzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:27:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:27:15Z"}, "message": "Rework VEC_PERM_EXPR folding\n\nThis patch reworks the VEC_PERM_EXPR folding so that more of it\nworks for variable-length vectors.  E.g. it means that we can\nnow recognise variable-length permutes that reduce to a single\nvector, or cases in which a variable-length permute only needs\none input.  There should be no functional change for fixed-length\nvectors.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* selftest.h (selftest::vec_perm_indices_c_tests): Declare.\n\t* selftest-run-tests.c (selftest::run_tests): Call it.\n\t* vector-builder.h (vector_builder::operator ==): New function.\n\t(vector_builder::operator !=): Likewise.\n\t* vec-perm-indices.h (vec_perm_indices::series_p): Declare.\n\t(vec_perm_indices::all_from_input_p): New function.\n\t* vec-perm-indices.c (vec_perm_indices::series_p): Likewise.\n\t(test_vec_perm_12, selftest::vec_perm_indices_c_tests): Likewise.\n\t* fold-const.c (fold_ternary_loc): Use tree_to_vec_perm_builder\n\tinstead of reading the VECTOR_CST directly.  Detect whether both\n\tvector inputs are the same before constructing the vec_perm_indices,\n\tand update the number of inputs argument accordingly.  Use the\n\tutility functions added above.  Only construct sel2 if we need to.\n\nFrom-SVN: r256098", "tree": {"sha": "1666d763225f1b16cafb34b101ec4e31817f8679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1666d763225f1b16cafb34b101ec4e31817f8679"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a1c441dbe5933ebf9180831236aa5be7d70a434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1c441dbe5933ebf9180831236aa5be7d70a434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a1c441dbe5933ebf9180831236aa5be7d70a434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1c441dbe5933ebf9180831236aa5be7d70a434/comments", "author": null, "committer": null, "parents": [{"sha": "d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59"}], "stats": {"total": 268, "additions": 192, "deletions": 76}, "files": [{"sha": "9e3face038b38f382527ebfb43d1eed989429ac1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -1,3 +1,19 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* selftest.h (selftest::vec_perm_indices_c_tests): Declare.\n+\t* selftest-run-tests.c (selftest::run_tests): Call it.\n+\t* vector-builder.h (vector_builder::operator ==): New function.\n+\t(vector_builder::operator !=): Likewise.\n+\t* vec-perm-indices.h (vec_perm_indices::series_p): Declare.\n+\t(vec_perm_indices::all_from_input_p): New function.\n+\t* vec-perm-indices.c (vec_perm_indices::series_p): Likewise.\n+\t(test_vec_perm_12, selftest::vec_perm_indices_c_tests): Likewise.\n+\t* fold-const.c (fold_ternary_loc): Use tree_to_vec_perm_builder\n+\tinstead of reading the VECTOR_CST directly.  Detect whether both\n+\tvector inputs are the same before constructing the vec_perm_indices,\n+\tand update the number of inputs argument accordingly.  Use the\n+\tutility functions added above.  Only construct sel2 if we need to.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs.c (expand_vec_perm_var): Use an explicit encoding for"}, {"sha": "f28970b2a8755e8187d3dace1d0e6c6ccb6b839c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 42, "deletions": 76, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -11705,99 +11705,65 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n     case VEC_PERM_EXPR:\n       if (TREE_CODE (arg2) == VECTOR_CST)\n \t{\n-\t  unsigned int nelts = VECTOR_CST_NELTS (arg2), i, mask, mask2;\n-\t  bool need_mask_canon = false;\n-\t  bool need_mask_canon2 = false;\n-\t  bool all_in_vec0 = true;\n-\t  bool all_in_vec1 = true;\n-\t  bool maybe_identity = true;\n-\t  bool single_arg = (op0 == op1);\n-\t  bool changed = false;\n-\n-\t  mask2 = 2 * nelts - 1;\n-\t  mask = single_arg ? (nelts - 1) : mask2;\n-\t  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n-\t  vec_perm_builder sel (nelts, nelts, 1);\n-\t  vec_perm_builder sel2 (nelts, nelts, 1);\n-\t  for (i = 0; i < nelts; i++)\n-\t    {\n-\t      tree val = VECTOR_CST_ELT (arg2, i);\n-\t      if (TREE_CODE (val) != INTEGER_CST)\n-\t\treturn NULL_TREE;\n-\n-\t      /* Make sure that the perm value is in an acceptable\n-\t\t range.  */\n-\t      wi::tree_to_wide_ref t = wi::to_wide (val);\n-\t      need_mask_canon |= wi::gtu_p (t, mask);\n-\t      need_mask_canon2 |= wi::gtu_p (t, mask2);\n-\t      unsigned int elt = t.to_uhwi () & mask;\n-\t      unsigned int elt2 = t.to_uhwi () & mask2;\n-\n-\t      if (elt < nelts)\n-\t\tall_in_vec1 = false;\n-\t      else\n-\t\tall_in_vec0 = false;\n-\n-\t      if ((elt & (nelts - 1)) != i)\n-\t\tmaybe_identity = false;\n+\t  /* Build a vector of integers from the tree mask.  */\n+\t  vec_perm_builder builder;\n+\t  if (!tree_to_vec_perm_builder (&builder, arg2))\n+\t    return NULL_TREE;\n \n-\t      sel.quick_push (elt);\n-\t      sel2.quick_push (elt2);\n-\t    }\n+\t  /* Create a vec_perm_indices for the integer vector.  */\n+\t  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n+\t  bool single_arg = (op0 == op1);\n+\t  vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n \n-\t  if (maybe_identity)\n-\t    {\n-\t      if (all_in_vec0)\n-\t\treturn op0;\n-\t      if (all_in_vec1)\n-\t\treturn op1;\n-\t    }\n+\t  /* Check for cases that fold to OP0 or OP1 in their original\n+\t     element order.  */\n+\t  if (sel.series_p (0, 1, 0, 1))\n+\t    return op0;\n+\t  if (sel.series_p (0, 1, nelts, 1))\n+\t    return op1;\n \n-\t  if (all_in_vec0)\n-\t    op1 = op0;\n-\t  else if (all_in_vec1)\n+\t  if (!single_arg)\n \t    {\n-\t      op0 = op1;\n-\t      for (i = 0; i < nelts; i++)\n-\t\tsel[i] -= nelts;\n-\t      need_mask_canon = true;\n+\t      if (sel.all_from_input_p (0))\n+\t\top1 = op0;\n+\t      else if (sel.all_from_input_p (1))\n+\t\t{\n+\t\t  op0 = op1;\n+\t\t  sel.rotate_inputs (1);\n+\t\t}\n \t    }\n \n-\t  vec_perm_indices indices (sel, 2, nelts);\n \t  if ((TREE_CODE (op0) == VECTOR_CST\n \t       || TREE_CODE (op0) == CONSTRUCTOR)\n \t      && (TREE_CODE (op1) == VECTOR_CST\n \t\t  || TREE_CODE (op1) == CONSTRUCTOR))\n \t    {\n-\t      tree t = fold_vec_perm (type, op0, op1, indices);\n+\t      tree t = fold_vec_perm (type, op0, op1, sel);\n \t      if (t != NULL_TREE)\n \t\treturn t;\n \t    }\n \n-\t  if (op0 == op1 && !single_arg)\n-\t    changed = true;\n-\n-\t  /* Some targets are deficient and fail to expand a single\n-\t     argument permutation while still allowing an equivalent\n-\t     2-argument version.  */\n-\t  if (need_mask_canon && arg2 == op2\n-\t      && !can_vec_perm_const_p (TYPE_MODE (type), indices, false)\n-\t      && can_vec_perm_const_p (TYPE_MODE (type),\n-\t\t\t\t       vec_perm_indices (sel2, 2, nelts),\n-\t\t\t\t       false))\n-\t    {\n-\t      need_mask_canon = need_mask_canon2;\n-\t      sel.truncate (0);\n-\t      sel.splice (sel2);\n-\t    }\n+\t  bool changed = (op0 == op1 && !single_arg);\n \n-\t  if (need_mask_canon && arg2 == op2)\n+\t  /* Generate a canonical form of the selector.  */\n+\t  if (arg2 == op2 && sel.encoding () != builder)\n \t    {\n-\t      tree eltype = TREE_TYPE (TREE_TYPE (arg2));\n-\t      tree_vector_builder tsel (TREE_TYPE (arg2), nelts, 1);\n-\t      for (i = 0; i < nelts; i++)\n-\t\ttsel.quick_push (build_int_cst (eltype, sel[i]));\n-\t      op2 = tsel.build ();\n+\t      /* Some targets are deficient and fail to expand a single\n+\t\t argument permutation while still allowing an equivalent\n+\t\t 2-argument version.  */\n+\t      if (sel.ninputs () == 2\n+\t\t  || can_vec_perm_const_p (TYPE_MODE (type), sel, false))\n+\t\top2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel);\n+\t      else\n+\t\t{\n+\t\t  vec_perm_indices sel2 (builder, 2, nelts);\n+\t\t  if (can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n+\t\t    op2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel2);\n+\t\t  else\n+\t\t    /* Not directly supported with either encoding,\n+\t\t       so use the preferred form.  */\n+\t\t    op2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel);\n+\t\t}\n \t      changed = true;\n \t    }\n "}, {"sha": "6af0f02ccbbe574091d4d67691a10c2fde19d56c", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -73,6 +73,7 @@ selftest::run_tests ()\n \n   /* Mid-level data structures.  */\n   input_c_tests ();\n+  vec_perm_indices_c_tests ();\n   tree_c_tests ();\n   gimple_c_tests ();\n   rtl_tests_c_tests ();"}, {"sha": "23ca66557c1a19d90b3fd64053c4df25f20a5992", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -215,6 +215,7 @@ extern void vec_c_tests ();\n extern void wide_int_cc_tests ();\n extern void predict_c_tests ();\n extern void simplify_rtx_c_tests ();\n+extern void vec_perm_indices_c_tests ();\n \n extern int num_passes;\n "}, {"sha": "3eb9c41cad0e4648c65e93f5e052cdd02d497e24", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"memmodel.h\"\n #include \"emit-rtl.h\"\n+#include \"selftest.h\"\n \n /* Switch to a new permutation vector that selects between NINPUTS vector\n    inputs that have NELTS_PER_INPUT elements each.  Take the elements of the\n@@ -85,6 +86,54 @@ vec_perm_indices::rotate_inputs (int delta)\n     m_encoding[i] = clamp (m_encoding[i] + element_delta);\n }\n \n+/* Return true if index OUT_BASE + I * OUT_STEP selects input\n+   element IN_BASE + I * IN_STEP.  */\n+\n+bool\n+vec_perm_indices::series_p (unsigned int out_base, unsigned int out_step,\n+\t\t\t    element_type in_base, element_type in_step) const\n+{\n+  /* Check the base value.  */\n+  if (clamp (m_encoding.elt (out_base)) != clamp (in_base))\n+    return false;\n+\n+  unsigned int full_nelts = m_encoding.full_nelts ();\n+  unsigned int npatterns = m_encoding.npatterns ();\n+\n+  /* Calculate which multiple of OUT_STEP elements we need to get\n+     back to the same pattern.  */\n+  unsigned int cycle_length = least_common_multiple (out_step, npatterns);\n+\n+  /* Check the steps.  */\n+  in_step = clamp (in_step);\n+  out_base += out_step;\n+  unsigned int limit = 0;\n+  for (;;)\n+    {\n+      /* Succeed if we've checked all the elements in the vector.  */\n+      if (out_base >= full_nelts)\n+\treturn true;\n+\n+      if (out_base >= npatterns)\n+\t{\n+\t  /* We've got to the end of the \"foreground\" values.  Check\n+\t     2 elements from each pattern in the \"background\" values.  */\n+\t  if (limit == 0)\n+\t    limit = out_base + cycle_length * 2;\n+\t  else if (out_base >= limit)\n+\t    return true;\n+\t}\n+\n+      element_type v0 = m_encoding.elt (out_base - out_step);\n+      element_type v1 = m_encoding.elt (out_base);\n+      if (clamp (v1 - v0) != in_step)\n+\treturn false;\n+\n+      out_base += out_step;\n+    }\n+  return true;\n+}\n+\n /* Return true if all elements of the permutation vector are in the range\n    [START, START + SIZE).  */\n \n@@ -180,3 +229,52 @@ vec_perm_indices_to_rtx (machine_mode mode, const vec_perm_indices &indices)\n     RTVEC_ELT (v, i) = gen_int_mode (indices[i], GET_MODE_INNER (mode));\n   return gen_rtx_CONST_VECTOR (mode, v);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Test a 12-element vector.  */\n+\n+static void\n+test_vec_perm_12 (void)\n+{\n+  vec_perm_builder builder (12, 12, 1);\n+  for (unsigned int i = 0; i < 4; ++i)\n+    {\n+      builder.quick_push (i * 5);\n+      builder.quick_push (3 + i);\n+      builder.quick_push (2 + 3 * i);\n+    }\n+  vec_perm_indices indices (builder, 1, 12);\n+  ASSERT_TRUE (indices.series_p (0, 3, 0, 5));\n+  ASSERT_FALSE (indices.series_p (0, 3, 3, 5));\n+  ASSERT_FALSE (indices.series_p (0, 3, 0, 8));\n+  ASSERT_TRUE (indices.series_p (1, 3, 3, 1));\n+  ASSERT_TRUE (indices.series_p (2, 3, 2, 3));\n+\n+  ASSERT_TRUE (indices.series_p (0, 4, 0, 4));\n+  ASSERT_FALSE (indices.series_p (1, 4, 3, 4));\n+\n+  ASSERT_TRUE (indices.series_p (0, 6, 0, 10));\n+  ASSERT_FALSE (indices.series_p (0, 6, 0, 100));\n+\n+  ASSERT_FALSE (indices.series_p (1, 10, 3, 7));\n+  ASSERT_TRUE (indices.series_p (1, 10, 3, 8));\n+\n+  ASSERT_TRUE (indices.series_p (0, 12, 0, 10));\n+  ASSERT_TRUE (indices.series_p (0, 12, 0, 11));\n+  ASSERT_TRUE (indices.series_p (0, 12, 0, 100));\n+}\n+\n+/* Run selftests for this file.  */\n+\n+void\n+vec_perm_indices_c_tests ()\n+{\n+  test_vec_perm_12 ();\n+}\n+\n+} // namespace selftest\n+\n+#endif"}, {"sha": "52b65a51e4b1830582e8fb36d1c19b038efd8161", "filename": "gcc/vec-perm-indices.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -77,7 +77,9 @@ class vec_perm_indices\n \n   element_type clamp (element_type) const;\n   element_type operator[] (unsigned int i) const;\n+  bool series_p (unsigned int, unsigned int, element_type, element_type) const;\n   bool all_in_range_p (element_type, element_type) const;\n+  bool all_from_input_p (unsigned int) const;\n \n private:\n   vec_perm_indices (const vec_perm_indices &);\n@@ -134,4 +136,13 @@ vec_perm_indices::operator[] (unsigned int i) const\n   return clamp (m_encoding.elt (i));\n }\n \n+/* Return true if the permutation vector only selects elements from\n+   input I.  */\n+\n+inline bool\n+vec_perm_indices::all_from_input_p (unsigned int i) const\n+{\n+  return all_in_range_p (i * m_nelts_per_input, m_nelts_per_input);\n+}\n+\n #endif"}, {"sha": "74e0b7655adc1c50b2c33fd8e9dc98692bd10718", "filename": "gcc/vector-builder.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1c441dbe5933ebf9180831236aa5be7d70a434/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=1a1c441dbe5933ebf9180831236aa5be7d70a434", "patch": "@@ -97,6 +97,9 @@ class vector_builder : public auto_vec<T, 32>\n   bool encoded_full_vector_p () const;\n   T elt (unsigned int) const;\n \n+  bool operator == (const Derived &) const;\n+  bool operator != (const Derived &x) const { return !operator == (x); }\n+\n   void finalize ();\n \n protected:\n@@ -168,6 +171,26 @@ vector_builder<T, Derived>::new_vector (unsigned int full_nelts,\n   this->truncate (0);\n }\n \n+/* Return true if this vector and OTHER have the same elements and\n+   are encoded in the same way.  */\n+\n+template<typename T, typename Derived>\n+bool\n+vector_builder<T, Derived>::operator == (const Derived &other) const\n+{\n+  if (m_full_nelts != other.m_full_nelts\n+      || m_npatterns != other.m_npatterns\n+      || m_nelts_per_pattern != other.m_nelts_per_pattern)\n+    return false;\n+\n+  unsigned int nelts = encoded_nelts ();\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    if (!derived ()->equal_p ((*this)[i], other[i]))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Return the value of vector element I, which might or might not be\n    encoded explicitly.  */\n "}]}