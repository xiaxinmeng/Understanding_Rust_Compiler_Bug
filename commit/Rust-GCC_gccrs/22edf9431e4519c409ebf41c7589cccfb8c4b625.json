{"sha": "22edf9431e4519c409ebf41c7589cccfb8c4b625", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlZGY5NDMxZTQ1MTljNDA5ZWJmNDFjNzU4OWNjY2ZiOGM0YjYyNQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-12-29T16:44:41Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-12-29T16:44:41Z"}, "message": "PR c++/88337 - Implement P1327R1: Allow dynamic_cast in constexpr.\n\nThis patch implements\n<http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1327r1.html>.\n\nWhen build_dynamic_cast realizes that a dynamic_cast needs a run-time check, it\ngenerates a call to __dynamic_cast -- see dyncast.cc in libsupc++ for its\ndefinition.  The gist of my approach is to evaluate such a call at compile time.\n\n\t* constexpr.c (cxx_dynamic_cast_fn_p): New function.\n\t(extract_obj_from_addr_offset): New function.\n\t(get_component_with_type): New function.\n\t(cxx_eval_dynamic_cast_fn): New function.\n\t(cxx_eval_call_expression): Call cxx_eval_dynamic_cast_fn for a call\n\tto __dynamic_cast.\n\t(potential_constant_expression_1): Don't give up on\n\tcxx_dynamic_cast_fn_p.\n\t* rtti.c (build_dynamic_cast_1): When creating a call to\n\t__dynamic_cast, use the location of the original expression.\n\n\t* g++.dg/cpp2a/constexpr-dynamic1.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic10.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic11.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic12.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic13.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic14.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic15.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic16.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic17.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic2.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic3.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic4.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic5.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic6.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic7.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic8.C: New test.\n\t* g++.dg/cpp2a/constexpr-dynamic9.C: New test.\n\nFrom-SVN: r279755", "tree": {"sha": "c4cb09adb7774b0c2c01d580d49c46ea9d4a394e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4cb09adb7774b0c2c01d580d49c46ea9d4a394e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22edf9431e4519c409ebf41c7589cccfb8c4b625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22edf9431e4519c409ebf41c7589cccfb8c4b625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22edf9431e4519c409ebf41c7589cccfb8c4b625", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22edf9431e4519c409ebf41c7589cccfb8c4b625/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ec067548fa994158819db0a62a8b5356d452c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec067548fa994158819db0a62a8b5356d452c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec067548fa994158819db0a62a8b5356d452c2c"}], "stats": {"total": 887, "additions": 886, "deletions": 1}, "files": [{"sha": "37d776c2aee95d0c9331b50c18c8ab84567b42be", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -1,3 +1,17 @@\n+2019-12-29  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/88337 - Implement P1327R1: Allow dynamic_cast in constexpr.\n+\t* constexpr.c (cxx_dynamic_cast_fn_p): New function.\n+\t(extract_obj_from_addr_offset): New function.\n+\t(get_component_with_type): New function.\n+\t(cxx_eval_dynamic_cast_fn): New function.\n+\t(cxx_eval_call_expression): Call cxx_eval_dynamic_cast_fn for a call\n+\tto __dynamic_cast.\n+\t(potential_constant_expression_1): Don't give up on\n+\tcxx_dynamic_cast_fn_p.\n+\t* rtti.c (build_dynamic_cast_1): When creating a call to\n+\t__dynamic_cast, use the location of the original expression.\n+\n 2019-12-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/92438"}, {"sha": "31ad6d56d2632d95c0ef5387015b842e139715f8", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 237, "deletions": 1, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -1699,6 +1699,238 @@ is_std_allocator_allocate (tree fndecl)\n   return decl_in_std_namespace_p (decl);\n }\n \n+/* Return true if FNDECL is __dynamic_cast.  */\n+\n+static inline bool\n+cxx_dynamic_cast_fn_p (tree fndecl)\n+{\n+  return (cxx_dialect >= cxx2a\n+\t  && id_equal (DECL_NAME (fndecl), \"__dynamic_cast\")\n+\t  && CP_DECL_CONTEXT (fndecl) == global_namespace);\n+}\n+\n+/* Often, we have an expression in the form of address + offset, e.g.\n+   \"&_ZTV1A + 16\".  Extract the object from it, i.e. \"_ZTV1A\".  */\n+\n+static tree\n+extract_obj_from_addr_offset (tree expr)\n+{\n+  if (TREE_CODE (expr) == POINTER_PLUS_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  STRIP_NOPS (expr);\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  return expr;\n+}\n+\n+/* Given a PATH like\n+\n+     g.D.2181.D.2154.D.2102.D.2093\n+\n+   find a component with type TYPE.  Return NULL_TREE if not found, and\n+   error_mark_node if the component is not accessible.  If STOP is non-null,\n+   this function will return NULL_TREE if STOP is found before TYPE.  */\n+\n+static tree\n+get_component_with_type (tree path, tree type, tree stop)\n+{\n+  while (true)\n+    {\n+      if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (path), type))\n+\t/* Found it.  */\n+\treturn path;\n+      else if (stop\n+\t       && (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (path),\n+\t\t\t\t\t\t\t      stop)))\n+\treturn NULL_TREE;\n+      else if (TREE_CODE (path) == COMPONENT_REF\n+\t       && DECL_FIELD_IS_BASE (TREE_OPERAND (path, 1)))\n+\t{\n+\t  /* We need to check that the component we're accessing is in fact\n+\t     accessible.  */\n+\t  if (TREE_PRIVATE (TREE_OPERAND (path, 1))\n+\t      || TREE_PROTECTED (TREE_OPERAND (path, 1)))\n+\t    return error_mark_node;\n+\t  path = TREE_OPERAND (path, 0);\n+\t}\n+      else\n+\treturn NULL_TREE;\n+    }\n+}\n+\n+/* Evaluate a call to __dynamic_cast (permitted by P1327R1).\n+\n+   The declaration of __dynamic_cast is:\n+\n+   void* __dynamic_cast (const void* __src_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const __class_type_info* __dst_type,\n+\t\t\t ptrdiff_t __src2dst);\n+\n+   where src2dst has the following possible values\n+\n+   >-1: src_type is a unique public non-virtual base of dst_type\n+\tdst_ptr + src2dst == src_ptr\n+   -1: unspecified relationship\n+   -2: src_type is not a public base of dst_type\n+   -3: src_type is a multiple public non-virtual base of dst_type\n+\n+  Since literal types can't have virtual bases, we only expect hint >=0,\n+  -2, or -3.  */\n+\n+static tree\n+cxx_eval_dynamic_cast_fn (const constexpr_ctx *ctx, tree call,\n+\t\t\t  bool *non_constant_p, bool *overflow_p)\n+{\n+  /* T will be something like\n+      __dynamic_cast ((B*) b, &_ZTI1B, &_ZTI1D, 8)\n+     dismantle it.  */\n+  gcc_assert (call_expr_nargs (call) == 4);\n+  tsubst_flags_t complain = ctx->quiet ? tf_none : tf_warning_or_error;\n+  tree obj = CALL_EXPR_ARG (call, 0);\n+  tree type = CALL_EXPR_ARG (call, 2);\n+  HOST_WIDE_INT hint = int_cst_value (CALL_EXPR_ARG (call, 3));\n+  location_t loc = cp_expr_loc_or_input_loc (call);\n+\n+  /* Get the target type of the dynamic_cast.  */\n+  gcc_assert (TREE_CODE (type) == ADDR_EXPR);\n+  type = TREE_OPERAND (type, 0);\n+  type = TREE_TYPE (DECL_NAME (type));\n+\n+  /* TYPE can only be either T* or T&.  We can't know which of these it\n+     is by looking at TYPE, but OBJ will be \"(T*) x\" in the first case,\n+     and something like \"(T*)(T&)(T*) x\" in the second case.  */\n+  bool reference_p = false;\n+  while (CONVERT_EXPR_P (obj) || TREE_CODE (obj) == SAVE_EXPR)\n+    {\n+      reference_p |= TYPE_REF_P (TREE_TYPE (obj));\n+      obj = TREE_OPERAND (obj, 0);\n+    }\n+\n+  /* Evaluate the object so that we know its dynamic type.  */\n+  obj = cxx_eval_constant_expression (ctx, obj, /*lval*/false, non_constant_p,\n+\t\t\t\t      overflow_p);\n+  if (*non_constant_p)\n+    return call;\n+\n+  /* We expect OBJ to be in form of &d.D.2102 when HINT == 0,\n+     but when HINT is > 0, it can also be something like\n+     &d.D.2102 + 18446744073709551608, which includes the BINFO_OFFSET.  */\n+  obj = extract_obj_from_addr_offset (obj);\n+  const tree objtype = TREE_TYPE (obj);\n+  /* If OBJ doesn't refer to a base field, we're done.  */\n+  if (tree t = (TREE_CODE (obj) == COMPONENT_REF\n+\t\t? TREE_OPERAND (obj, 1) : obj))\n+    if (TREE_CODE (t) != FIELD_DECL || !DECL_FIELD_IS_BASE (t))\n+      return integer_zero_node;\n+\n+  /* [class.cdtor] When a dynamic_cast is used in a constructor ...\n+     or in a destructor ... if the operand of the dynamic_cast refers\n+     to the object under construction or destruction, this object is\n+     considered to be a most derived object that has the type of the\n+     constructor or destructor's class.  */\n+  tree vtable = build_vfield_ref (obj, TREE_TYPE (obj));\n+  vtable = cxx_eval_constant_expression (ctx, vtable, /*lval*/false,\n+\t\t\t\t\t non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return call;\n+  /* VTABLE will be &_ZTV1A + 16 or similar, get _ZTV1A.  */\n+  vtable = extract_obj_from_addr_offset (vtable);\n+  const tree mdtype = DECL_CONTEXT (vtable);\n+\n+  /* Given dynamic_cast<T>(v),\n+\n+     [expr.dynamic.cast] If C is the class type to which T points or refers,\n+     the runtime check logically executes as follows:\n+\n+     If, in the most derived object pointed (referred) to by v, v points\n+     (refers) to a public base class subobject of a C object, and if only\n+     one object of type C is derived from the subobject pointed (referred)\n+     to by v the result points (refers) to that C object.\n+\n+     In this case, HINT >= 0 or -3.  */\n+  if (hint >= 0 || hint == -3)\n+    {\n+      /* Look for a component with type TYPE.  */\n+      tree t = get_component_with_type (obj, type, mdtype);\n+      /* If not accessible, give an error.  */\n+      if (t == error_mark_node)\n+\t{\n+\t  if (reference_p)\n+\t    {\n+\t      if (!ctx->quiet)\n+\t\t{\n+\t\t  error_at (loc, \"reference %<dynamic_cast%> failed\");\n+\t\t  inform (loc, \"static type %qT of its operand is a \"\n+\t\t\t  \"non-public base class of dynamic type %qT\",\n+\t\t\t  objtype, type);\n+\n+\t\t}\n+\t      *non_constant_p = true;\n+\t    }\n+\t  return integer_zero_node;\n+\t}\n+      else if (t)\n+\t/* The result points to the TYPE object.  */\n+\treturn cp_build_addr_expr (t, complain);\n+      /* Else, TYPE was not found, because the HINT turned out to be wrong.\n+\t Fall through to the normal processing.  */\n+    }\n+\n+  /* Otherwise, if v points (refers) to a public base class subobject of the\n+     most derived object, and the type of the most derived object has a base\n+     class, of type C, that is unambiguous and public, the result points\n+     (refers) to the C subobject of the most derived object.\n+\n+     But it can also be an invalid case.  */\n+      \n+  /* Get the most derived object.  */\n+  obj = get_component_with_type (obj, mdtype, NULL_TREE);\n+  if (obj == error_mark_node)\n+    {\n+      if (reference_p)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    {\n+\t      error_at (loc, \"reference %<dynamic_cast%> failed\");\n+\t      inform (loc, \"static type %qT of its operand is a non-public\"\n+\t\t      \" base class of dynamic type %qT\", objtype, mdtype);\n+\t    }\n+\t  *non_constant_p = true;\n+\t}\n+      return integer_zero_node;\n+    }\n+  else\n+    gcc_assert (obj);\n+\n+  /* Check that the type of the most derived object has a base class\n+     of type TYPE that is unambiguous and public.  */\n+  base_kind b_kind;\n+  tree binfo = lookup_base (mdtype, type, ba_check, &b_kind, tf_none);\n+  if (!binfo || binfo == error_mark_node)\n+    {\n+      if (reference_p)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    {\n+\t      error_at (loc, \"reference %<dynamic_cast%> failed\");\n+\t      if (b_kind == bk_ambig)\n+\t\tinform (loc, \"%qT is an ambiguous base class of dynamic \"\n+\t\t\t\"type %qT of its operand\", type, mdtype);\n+\t      else\n+\t\tinform (loc, \"dynamic type %qT of its operand does not \"\n+\t\t\t\"have an unambiguous public base class %qT\",\n+\t\t\tmdtype, type);\n+\t    }\n+\t  *non_constant_p = true;\n+\t}\n+      return integer_zero_node;\n+    }\n+  /* If so, return the TYPE subobject of the most derived object.  */\n+  obj = convert_to_base_statically (obj, binfo);\n+  return cp_build_addr_expr (obj, complain);\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Evaluate the call expression tree T in the context of OLD_CALL expression\n    evaluation.  */\n@@ -1864,6 +2096,9 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (arg1);\n \t  return arg1;\n \t}\n+      else if (cxx_dynamic_cast_fn_p (fun))\n+\treturn cxx_eval_dynamic_cast_fn (ctx, t, non_constant_p, overflow_p);\n+\n       if (!ctx->quiet)\n \t{\n \t  if (!lambda_static_thunk_p (fun))\n@@ -6740,7 +6975,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t    && (!cxx_placement_new_fn (fun)\n \t\t\t|| TREE_CODE (t) != CALL_EXPR\n \t\t\t|| current_function_decl == NULL_TREE\n-\t\t\t|| !is_std_construct_at (current_function_decl)))\n+\t\t\t|| !is_std_construct_at (current_function_decl))\n+\t\t    && !cxx_dynamic_cast_fn_p (fun))\n \t\t  {\n \t\t    if (flags & tf_error)\n \t\t      {"}, {"sha": "9a242dc64e4f20e3e6a6bad024ac8e1c48d0ad88", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -777,6 +777,7 @@ build_dynamic_cast_1 (location_t loc, tree type, tree expr,\n \t      dynamic_cast_node = dcast_fn;\n \t    }\n \t  result = build_cxx_call (dcast_fn, 4, elems, complain);\n+\t  SET_EXPR_LOCATION (result, loc);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {"}, {"sha": "5db30163e91b52aac8a83b85f8005b06179b1d36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -1,3 +1,24 @@\n+2019-12-29  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/88337 - Implement P1327R1: Allow dynamic_cast in constexpr.\n+\t* g++.dg/cpp2a/constexpr-dynamic1.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic10.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic11.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic12.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic13.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic14.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic15.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic16.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic17.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic2.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic3.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic4.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic5.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic6.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic7.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic8.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dynamic9.C: New test.\n+\n 2019-12-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/93078"}, {"sha": "e8ba63d9609c1fda105cee71c64450d4e698e965", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic1.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic1.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,40 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Downcast.\n+\n+struct B {\n+  virtual void baz () {}\n+};\n+ \n+struct D : B { };\n+\n+constexpr bool\n+fn ()\n+{\n+  bool ok = true;\n+  B b;\n+  B *b1 = &b;\n+  if (D *pd = dynamic_cast<D*>(b1))\n+    ok = false;\n+\n+  D d;\n+  B *b2 = &d;\n+  if (D *pd = dynamic_cast<D*>(b2))\n+    /*OK*/;\n+  else\n+   ok = false;\n+    \n+  return ok;\n+}\n+\n+static_assert(fn ());\n+\n+constexpr D d;\n+constexpr B b;\n+constexpr B *b1 = const_cast<B*>(&b);\n+constexpr B *b2 = const_cast<D*>(&d);\n+static_assert(dynamic_cast<D*>(b2) == &d);\n+static_assert(&dynamic_cast<D&>(*b2) == &d);\n+static_assert(dynamic_cast<const B*>(&d) == &d);\n+static_assert(&dynamic_cast<const B&>(d) == &d);"}, {"sha": "c226292a07d49a0b34dcae22ae8713ca8c8df2e4", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic10.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic10.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Virtual base.\n+\n+struct C { virtual void a(); };\n+struct B { virtual void b(); };\n+struct A : virtual B, C { virtual void c(); }; // { dg-error \".struct A. has virtual base classes\" }\n+\n+constexpr A a; // { dg-error \"call\" }\n+\n+constexpr bool b1 = (dynamic_cast<C&>((B&)a), false);"}, {"sha": "6069fbfd01ce158c3ec83fb5e988234d6b305e9b", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic11.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic11.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// dynamic_cast in a constructor.\n+// [class.cdtor]#6: \"If the operand of the dynamic_cast refers to the object\n+// under construction or destruction and the static type of the operand is not\n+// a pointer to or object of the constructor or destructor's own class or one\n+// of its bases, the dynamic_cast results in undefined behavior.\n+\n+struct V {\n+  virtual void f();\n+};\n+\n+struct A : V { };\n+\n+struct B : V {\n+  constexpr B(V*, A*);\n+};\n+\n+struct D : A, B {\n+  constexpr D() : B((A*)this, this) { } // { dg-message \"in 'constexpr' expansion of\" }\n+};\n+\n+constexpr B::B(V* v, A* a)\n+{\n+  // well-defined: v of type V*, V base of B results in B*\n+  B* b = dynamic_cast<B*>(v);\n+  if (b != nullptr)\n+    __builtin_abort ();\n+\n+  B& br = dynamic_cast<B&>(*v); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"dynamic type .A. of its operand does not have an unambiguous public base class .B.\" \"\" { target *-*-* } .-1 }\n+}\n+\n+constexpr D d; // { dg-message \"in 'constexpr' expansion of\" }"}, {"sha": "0ce9beb8d72b60cfea50a234618ff11d1039eb50", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic12.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic12.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// dynamic_cast in a destructor.\n+\n+struct A2 { virtual void a2(); };\n+\n+struct A : A2 { virtual void a(); };\n+\n+struct C2 { virtual void c2(); };\n+\n+struct B : A, C2 {\n+  constexpr ~B();\n+};\n+\n+constexpr B::~B()\n+{\n+  A *a = dynamic_cast<A*>((C2*)this);\n+  if (a != (A*) this)\n+    __builtin_abort ();\n+  A& ar = dynamic_cast<A&>((C2&)*this);\n+  if (&ar != &(A&)*this)\n+    __builtin_abort ();\n+}\n+\n+struct D : B { virtual void d(); };\n+\n+constexpr D d;"}, {"sha": "203067a2581edae677f1b0fbed8feec12bb4e8ad", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic13.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic13.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,86 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Adopted from g++.old-deja/g++.other/dyncast1.C.\n+\n+// 1. downcast\n+// 1.1. single inheritance case\n+\n+struct A { virtual void a(); };\n+struct AA : A {};\n+struct B : A {};\n+struct BB : B {};\n+class C : B {};\n+struct D : C {};\n+\n+struct CC : B {};\n+class DD : CC {};\n+\n+class CCC : protected B {};\n+class DDD : protected CCC {};\n+\n+constexpr D d;\n+static_assert (dynamic_cast<D*> ((A*)&d) == nullptr);\n+static_assert (dynamic_cast<D*> ((B*)&d) == nullptr);\n+static_assert (&d == dynamic_cast<D*> ((C*)&d));\n+static_assert (dynamic_cast<C*> ((B*)&d) == nullptr);\n+\n+constexpr DD dd;\n+static_assert (dynamic_cast<DD*> ((A*)&dd) == nullptr);\n+static_assert (dynamic_cast<DD*> ((B*)&dd) == nullptr);\n+\n+constexpr DDD ddd;\n+static_assert (dynamic_cast<DDD*> ((A*)&ddd) == nullptr);\n+static_assert (dynamic_cast<DDD*> ((B*)&ddd) == nullptr);\n+static_assert (dynamic_cast<CCC*> ((B*)&ddd) == nullptr);\n+\n+// 1.2. multiple inheritance case\n+// 1.2.1. all bases are public\n+ \n+struct E : D, CC {};\n+struct EE : CC, D {}; //Will search in reverse order.\n+\n+constexpr E e;\n+static_assert (dynamic_cast<E*> ((A*)(D*)&e) == nullptr);\n+static_assert (dynamic_cast<E*> ((B*)(D*)&e) == nullptr);\n+static_assert (&e == dynamic_cast<E*> ((C*)(D*)&e));\n+static_assert (&e == dynamic_cast<E*> ((B*)(CC*)&e));\n+static_assert ((CC*)&e == dynamic_cast<CC*> ((B*)(CC*)&e));\n+\n+constexpr EE ee;\n+static_assert (dynamic_cast<EE*> ((A*)(D*)&ee) == nullptr);\n+static_assert (dynamic_cast<EE*> ((B*)(D*)&ee) == nullptr);\n+static_assert (&ee == dynamic_cast<EE*> ((C*)(D*)&ee));\n+static_assert (&ee == dynamic_cast<EE*> ((B*)(CC*)&ee));\n+static_assert ((CC*)&ee == dynamic_cast<CC*> ((B*)(CC*)&ee));\n+\n+// 1.2.2 one or more branches are nonpublic\n+\n+struct X : private BB, E {};\n+struct Y : AA, private B {};\n+\n+class XX : BB, E {};\n+\n+constexpr X x;\n+static_assert (&x == dynamic_cast<X*>((B*)(CC*)(E*)&x));\n+\n+constexpr XX xx;\n+static_assert (dynamic_cast<XX*>((B*)(CC*)(E*)&xx) == nullptr);\t\n+\n+constexpr Y y;\n+static_assert (dynamic_cast<Y*>((B*)&y) == nullptr);\n+static_assert (dynamic_cast<Y*>((A*)(B*)&y) == nullptr);\n+\n+// 2. crosscast\n+\n+struct J { virtual void j(); };\n+struct K : CC, private J {}; \n+class KK : J, CC{};\n+\t\t\n+static_assert (dynamic_cast<CC*> ((B*)(D*)&e) == nullptr);\n+static_assert ((CC*)&e == dynamic_cast<CC*> ((C*)(D*)&e));\n+\n+constexpr K k;\n+static_assert (dynamic_cast<J*> ((B*)&k) == nullptr);\n+constexpr KK kk;\n+static_assert (dynamic_cast<J*> ((CC*)&kk) == nullptr);"}, {"sha": "f739c6df94b815e4b470699ec86572dff248fe8b", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic14.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic14.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,105 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Adopted from g++.old-deja/g++.other/dyncast1.C.\n+// But use reference dynamic_cast.\n+\n+// 1. downcast\n+// 1.1. single inheritance case\n+\n+struct A { virtual void a(); };\n+struct AA : A {};\n+struct B : A {};\n+struct BB : B {};\n+class C : B {};\n+struct D : C {};\n+\n+struct CC : B {};\n+class DD : CC {};\n+\n+class CCC : protected B {};\n+class DDD : protected CCC {};\n+\n+constexpr D d;\n+constexpr bool b01 = (dynamic_cast<D&> ((A&)d), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const A. of its operand is a non-public base class of dynamic type .D.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b02 = (dynamic_cast<D&> ((B&)d), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .D.\" \"\" { target *-*-* } .-1 }\n+static_assert (&d == &dynamic_cast<const D&> ((C&)d));\n+constexpr bool b03 = (dynamic_cast<C&> ((B&)d), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .D.\" \"\" { target *-*-* } .-1 }\n+\n+constexpr DD dd;\n+constexpr bool b04 = (dynamic_cast<DD&> ((A&)dd), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const A. of its operand is a non-public base class of dynamic type .DD.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b05 = (dynamic_cast<DD&> ((B&)dd), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .DD.\" \"\" { target *-*-* } .-1 }\n+\n+constexpr DDD ddd;\n+constexpr bool b06 = (dynamic_cast<DDD&> ((A&)ddd), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const A. of its operand is a non-public base class of dynamic type .DDD.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b07 = (dynamic_cast<DDD&> ((B&)ddd), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .DDD.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b08 = (dynamic_cast<CCC&> ((B&)ddd), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .DDD.\" \"\" { target *-*-* } .-1 }\n+\n+// 1.2. multiple inheritance case\n+// 1.2.1. all bases are public\n+ \n+struct E : D, CC {};\n+struct EE : CC, D {}; //Will search in reverse order.\n+\n+constexpr E e;\n+constexpr bool b09 = (dynamic_cast<E&> ((A&)(D&)e), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .A. of its operand is a non-public base class of dynamic type .E.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b10 = (dynamic_cast<E&> ((B&)(D&)e), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .B. of its operand is a non-public base class of dynamic type .E.\" \"\" { target *-*-* } .-1 }\n+static_assert (&e == &dynamic_cast<E&> ((C&)(D&)e));\n+static_assert (&e == &dynamic_cast<E&> ((B&)(CC&)e));\n+static_assert (&(CC&)e == &dynamic_cast<CC&> ((B&)(CC&)e));\n+\n+constexpr EE ee;\n+constexpr bool b11 = (dynamic_cast<EE&> ((A&)(D&)ee), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .A. of its operand is a non-public base class of dynamic type .EE.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b12 = (dynamic_cast<EE&> ((B&)(D&)ee), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .B. of its operand is a non-public base class of dynamic type .EE.\" \"\" { target *-*-* } .-1 }\n+static_assert (&ee == &dynamic_cast<EE&> ((C&)(D&)ee));\n+static_assert (&ee == &dynamic_cast<EE&> ((B&)(CC&)ee));\n+static_assert (&(CC&)ee == &dynamic_cast<CC&> ((B&)(CC&)ee));\n+\n+// 1.2.2 one or more branches are nonpublic\n+\n+struct X : private BB, E {};\n+struct Y : AA, private B {};\n+\n+class XX : BB, E {};\n+\n+constexpr X x;\n+static_assert (&x == &dynamic_cast<X&>((B&)(CC&)(E&)x));\n+\n+constexpr XX xx;\n+constexpr bool b13 = (dynamic_cast<XX&>((B&)(CC&)(E&)xx), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .B. of its operand is a non-public base class of dynamic type .XX.\" \"\" { target *-*-* } .-1 }\n+\n+constexpr Y y;\n+constexpr bool b14 = (dynamic_cast<Y&>((B&)y), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const B. of its operand is a non-public base class of dynamic type .Y.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b15 = (dynamic_cast<Y&>((A&)(B&)y), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .A. of its operand is a non-public base class of dynamic type .Y.\" \"\" { target *-*-* } .-1 }\n+\n+// 2. crosscast\n+\n+struct J { virtual void j(); };\n+struct K : CC, private J {}; \n+class KK : J, CC{};\n+\t\t\n+constexpr bool b16 = (dynamic_cast<CC&> ((B&)(D&)e), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .B. of its operand is a non-public base class of dynamic type .CC.\" \"\" { target *-*-* } .-1 }\n+static_assert (&(CC&)e == &dynamic_cast<CC&> ((C&)(D&)e));\n+\n+constexpr K k;\n+constexpr bool b17 = (dynamic_cast<J&> ((B&)k), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"dynamic type .K. of its operand does not have an unambiguous public base class .J.\" \"\" { target *-*-* } .-1 }\n+constexpr KK kk;\n+constexpr bool b18 = (dynamic_cast<J&> ((CC&)kk), true); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const CC. of its operand is a non-public base class of dynamic type .KK.\" \"\" { target *-*-* } .-1 }"}, {"sha": "fcf507289c4de37b7d6e3222a900c0e04521ecd1", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic15.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic15.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+// Test HINT = -3 (SRC is a multiple public non-virtual base of DST).\n+\n+struct A { virtual void a() {} };\n+struct C : A { };\n+struct D : A { };\n+struct B : C, D { };\n+\n+constexpr B b;\n+static_assert (&dynamic_cast<B&>((A&)(C&)b) == &b);\n+static_assert (&dynamic_cast<B&>((A&)(D&)b) == &b);\n+static_assert (dynamic_cast<B*>((A*)(C*)&b) == &b);\n+static_assert (dynamic_cast<B*>((A*)(D*)&b) == &b);"}, {"sha": "f0394d130a3286eaf5323c2414aae2f4ae4291df", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic16.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic16.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+// Here the hint turns out to be wrong: A is a public base of B2, but the\n+// dynamic_cast operand is not that subobject, but rather a sibling base of\n+// B2.\n+\n+struct A { virtual void f(); };\n+struct B1: A { };\n+struct B2: A { };\n+struct C: B1, B2 { };\n+\n+constexpr C c;\n+constexpr A *ap = (B1*)&c;\n+constexpr A &ar = (B1&)c;\n+constexpr auto p = dynamic_cast<B2*>(ap);\n+static_assert (p != nullptr);\n+constexpr auto p2 = dynamic_cast<B2&>(ar);\n+static_assert(dynamic_cast<B2*>(ap) == (B2*)&c);\n+static_assert(dynamic_cast<B2*>((B1*)&c) == (B2*)&c);\n+static_assert(&dynamic_cast<B2&>((B1&)c) == &(B2&)c);"}, {"sha": "6b443d249ec7e4ac083dc14d67fc2aba6efd434a", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic17.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic17.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// dynamic_cast in a constructor.\n+// [class.cdtor]#6: \"If the operand of the dynamic_cast refers to the object\n+// under construction or destruction and the static type of the operand is not\n+// a pointer to or object of the constructor or destructor's own class or one\n+// of its bases, the dynamic_cast results in undefined behavior.\n+// See <https://gcc.gnu.org/ml/gcc-patches/2019-12/msg01521.html>.\n+\n+struct V {\n+  virtual void f();\n+};\n+\n+struct A : V { };\n+\n+struct B : V {\n+  constexpr B(V*, A*);\n+};\n+\n+struct D : B, A {\n+  constexpr D() : B((A*)this, this) { } // { dg-message \"in 'constexpr' expansion of\" }\n+};\n+\n+constexpr B::B(V* v, A* a)\n+{\n+  dynamic_cast<B*>(a);\n+}\n+\n+constexpr D d; // { dg-error \"accessing uninitialized member\" }\n+// { dg-message \"in 'constexpr' expansion of\" \"\" { target *-*-* } .-1 }"}, {"sha": "aae03f691ca41bec49c371696062fd786077257d", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic2.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic2.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,41 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Downcast, with hint > 0.\n+\n+struct B {\n+  virtual void baz () {}\n+};\n+\n+struct B2 {\n+  virtual void baz2 () {}\n+};\n+ \n+struct D : B, B2 { };\n+\n+constexpr bool\n+fn ()\n+{\n+  // try &/&&, add address test\n+  bool ok = true;\n+  B2 b;\n+  B2 *b1 = &b;\n+  if (D *pd = dynamic_cast<D*>(b1))\n+    ok = false;\n+\n+  D d;\n+  B2 *b2 = &d;\n+  if (D *pd = dynamic_cast<D*>(b2))\n+    /*OK*/;\n+  else\n+   ok = false;\n+    \n+  return ok;\n+}\n+\n+static_assert(fn ());\n+\n+constexpr D d;\n+constexpr B2 *b = const_cast<D*>(&d);\n+static_assert(dynamic_cast<D*>(b) == &d);\n+static_assert(&dynamic_cast<D&>(*b) == &d);"}, {"sha": "c3e09808e3200fb315c473cd9c7423aa8e784e2c", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic3.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic3.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Sidecast.\n+\n+struct A {\n+  virtual void afn () {}\n+};\n+ \n+struct B {\n+  virtual void bfn () {}\n+};\n+\n+struct D : A, B { };\n+\n+constexpr bool\n+fn ()\n+{\n+  bool ok = true;\n+  D d;\n+  A *a = &d;\n+  if (B *bp = dynamic_cast<B*>(a))\n+    /*OK*/;\n+  else\n+    ok = false;\n+\n+  A &ar = d;\n+  B &br = dynamic_cast<B&>(ar);\n+\n+  return ok;\n+}\n+\n+static_assert(fn ());"}, {"sha": "3adc524379d7e2d53e6250809fca1755e7a83413", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic4.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic4.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,55 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// From clang's constant-expression-cxx2a.cpp.\n+\n+struct A2 { virtual void a2(); };\n+struct A : A2 { virtual void a(); };\n+struct B : A {}; \n+struct C2 { virtual void c2(); };\n+struct C : A, C2 { A *c = dynamic_cast<A*>(static_cast<C2*>(this)); };\n+struct D { virtual void d(); };\n+struct E { virtual void e(); };\n+struct F : B, C, D, private E { void *f = dynamic_cast<void*>(static_cast<D*>(this)); };\n+struct Padding { virtual void padding(); };\n+struct G : Padding, F {}; \n+\n+constexpr G g;\n+\n+// During construction of C, A is unambiguous subobject of dynamic type C.\n+static_assert(g.c == (C*)&g);\n+// ... but in the complete object, the same is not true, so the runtime fails.\n+static_assert(dynamic_cast<const A*>(static_cast<const C2*>(&g)) == nullptr);\n+\n+// dynamic_cast<void*> produces a pointer to the object of the dynamic type.\n+static_assert(g.f == (void*)(F*)&g);\n+static_assert(dynamic_cast<const void*>(static_cast<const D*>(&g)) == &g);\n+\n+constexpr int d_a = (dynamic_cast<const A&>(static_cast<const D&>(g)), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \".A. is an ambiguous base class of dynamic type .G.\" \"\" { target *-*-* } .-1 }\n+\n+// Can navigate from A2 to its A...\n+static_assert(&dynamic_cast<A&>((A2&)(B&)g) == &(A&)(B&)g);\n+// ... and from B to its A ...\n+static_assert(&dynamic_cast<A&>((B&)g) == &(A&)(B&)g);\n+// ... but not from D.\n+static_assert(&dynamic_cast<A&>((D&)g) == &(A&)(B&)g); // { dg-error \"non-constant condition for static assertion|reference .dynamic_cast. failed\" }\n+// { dg-message \".A. is an ambiguous base class of dynamic type .G.\" \"\" { target *-*-* } .-1 }\n+\n+// Can cast from A2 to sibling class D.\n+static_assert(&dynamic_cast<D&>((A2&)(B&)g) == &(D&)g);\n+\n+// Cannot cast from private base E to derived class F.\n+constexpr int e_f = (dynamic_cast<F&>((E&)g), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const E. of its operand is a non-public base class of dynamic type .G.\" \"\" { target *-*-* } .-1 }\n+\n+// Cannot cast from B to private sibling E.\n+constexpr int b_e = (dynamic_cast<E&>((B&)g), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"dynamic type .G. of its operand does not have an unambiguous public base class .E.\" \"\" { target *-*-* } .-1 }\n+\n+struct Unrelated { virtual void unrelated(); };\n+\n+constexpr int b_unrelated = (dynamic_cast<Unrelated&>((B&)g), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"dynamic type .G. of its operand does not have an unambiguous public base class .Unrelated.\" \"\" { target *-*-* } .-1 }\n+constexpr int e_unrelated = (dynamic_cast<Unrelated&>((E&)g), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const E. of its operand is a non-public base class of dynamic type .G.\" \"\" { target *-*-* } .-1 }"}, {"sha": "743b3018d2f3954f16f8f483663a630197e76eb3", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic5.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Multiple levels.\n+\n+struct A { virtual void a(); };\n+struct B : A { virtual void b(); };\n+struct C : B { virtual void c(); };\n+struct D : C { virtual void d(); };\n+struct E : D { virtual void e(); };\n+struct F : E { virtual void f(); };\n+\n+constexpr F f;\n+\n+// F->C->A->B == F->C->B\n+static_assert (&dynamic_cast<B&>((A&)(C&)f) == &(B&)(C&)f);\n+// F->A->E == F->E\n+static_assert (&dynamic_cast<E&>((A&)f) == &(E&)f);\n+// F->E->D->C->B->A->C == F->C\n+static_assert (&dynamic_cast<C&>((A&)(B&)(C&)(D&)(E&)f) == &(C&)f);\n+// F->B->F == F\n+static_assert (&dynamic_cast<F&>((B&)f) == &f);"}, {"sha": "23434734e26bf46e383a908db80270c747ce6027", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic6.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic6.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Private base.\n+\n+struct P1 { virtual void p1(); };\n+struct P2 { virtual void p2(); };\n+struct B : private P1 { virtual void b(); };\n+struct C { virtual void c(); };\n+struct A : B, C, private P2 { virtual void a(); };\n+\n+constexpr A a;\n+\n+// P1 is a non-public base of A.\n+constexpr bool b1 = (dynamic_cast<B&>((P1&)a), false); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P1. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+\n+// Don't error here.\n+static_assert (dynamic_cast<B*>((P1*)&a) == nullptr);\n+\n+constexpr bool b2 = (dynamic_cast<C&>((P2&)a), false); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P2. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+\n+static_assert (dynamic_cast<C*>((P1*)&a) == nullptr);\n+static_assert (dynamic_cast<C*>((P2*)&a) == nullptr);"}, {"sha": "d71497aae6d20ec25a6c3e16f252bb2889880446", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic7.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic7.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Protected base.\n+\n+struct P1 { virtual void p1(); };\n+struct P2 { virtual void p2(); };\n+struct B : protected P1 { virtual void b(); };\n+struct C { virtual void c(); };\n+struct A : B, C, protected P2 { virtual void a(); };\n+\n+constexpr A a;\n+\n+// P1 is a non-public base of A.\n+constexpr bool b1 = (dynamic_cast<B&>((P1&)a), false); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P1. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+\n+// Don't error here.\n+static_assert (dynamic_cast<B*>((P1*)&a) == nullptr);\n+\n+constexpr bool b2 = (dynamic_cast<C&>((P2&)a), false); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P2. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+\n+static_assert (dynamic_cast<C*>((P1*)&a) == nullptr);\n+static_assert (dynamic_cast<C*>((P2*)&a) == nullptr);"}, {"sha": "8056f30bb993676e1c73d6a8c87cc8b774dc677c", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic8.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic8.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Unrelated type.\n+\n+struct B { virtual void b(); };\n+struct P1 { virtual void p1(); };\n+struct P2 { virtual void p2(); };\n+struct A : public B, private P1, protected P2 { virtual void a(); };\n+\n+constexpr A a;\n+\n+struct U { virtual void u(); };\n+\n+constexpr bool b1 = (dynamic_cast<U&>((B&)a), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"dynamic type .A. of its operand does not have an unambiguous public base class .U.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b2 = (dynamic_cast<U&>((P1&)a), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P1. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+constexpr bool b3 = (dynamic_cast<U&>((P2&)a), 0); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \"static type .const P2. of its operand is a non-public base class of dynamic type .A.\" \"\" { target *-*-* } .-1 }\n+\n+static_assert (dynamic_cast<U*>((B*)&a) == nullptr);\n+static_assert (dynamic_cast<U*>((P1*)&a) == nullptr);\n+static_assert (dynamic_cast<U*>((P2*)&a) == nullptr);"}, {"sha": "d8cbb2f2f0dbef7e9c2c8a4b81c7ced016788460", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dynamic9.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22edf9431e4519c409ebf41c7589cccfb8c4b625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dynamic9.C?ref=22edf9431e4519c409ebf41c7589cccfb8c4b625", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/88337 - Implement P1327R1: Allow dynamic_cast/typeid in constexpr.\n+// { dg-do compile { target c++2a } }\n+\n+// Ambiguous base.\n+\n+struct A { virtual void a(); };\n+struct B : A { virtual void b(); };\n+struct C : A { virtual void c(); };\n+struct D { virtual void a(); };\n+struct E : B, C, D { virtual void d(); };\n+\n+constexpr E e;\n+\n+constexpr bool b1 = (dynamic_cast<A&>((D&)e), false); // { dg-error \"reference .dynamic_cast. failed\" }\n+// { dg-message \".A. is an ambiguous base class of dynamic type .E. of its operand\" \"\" { target *-*-* } .-1 }\n+\n+static_assert (dynamic_cast<A*>((D*)&e) == nullptr);"}]}