{"sha": "dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkNDhkNzZmNzZmOGUyZTBhOTczZTkzZjBkOTZmMThiZDgyNzQ3Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-02-02T00:14:41Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-02-02T00:14:41Z"}, "message": "c-decl.c, [...]: Revert bitfield patch.\n\n\t* c-decl.c, tree.c, tree.h, objc/objc-act.c: Revert bitfield\n\tpatch.\n\t* gcc.dg/bitfld-1.c: Update.\n\t* gcc.dg/bitfld-2.c: Update.\n\t* gcc.c-torture/execute/bitfld-1.x: New.\n\nFrom-SVN: r49420", "tree": {"sha": "a1c4390a7d9e71c0473bdd89244fde668272cb52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1c4390a7d9e71c0473bdd89244fde668272cb52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/comments", "author": null, "committer": null, "parents": [{"sha": "4a23409e6f5915715f8831b28f3b72b3ce69c3bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a23409e6f5915715f8831b28f3b72b3ce69c3bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a23409e6f5915715f8831b28f3b72b3ce69c3bc"}], "stats": {"total": 305, "additions": 139, "deletions": 166}, "files": [{"sha": "4086e1d2ff9c1fdf08c3cf23c2daf710c2bd1972", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -1,3 +1,8 @@\n+2002-02-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-decl.c, tree.c, tree.h, objc/objc-act.c: Revert bitfield\n+\tpatch.\n+\n 2002-02-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.h (CPP_CPUCOMMON_SPEC): Add missing | separators."}, {"sha": "073db1c7a94b7b9cb197b23bdb8a8e4c6c9161fb", "filename": "gcc/c-decl.c", "status": "modified", "additions": 114, "deletions": 137, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -53,6 +53,7 @@ enum decl_context\n   FUNCDEF,\t\t\t/* Function definition */\n   PARM,\t\t\t\t/* Declaration of parm before function body */\n   FIELD,\t\t\t/* Declaration inside struct or union */\n+  BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n \f\n@@ -275,13 +276,12 @@ static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree,\n \t\t\t\t\t\t struct binding_level *, int));\n static tree lookup_tag_reverse\t\tPARAMS ((tree));\n static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n-\t\t\t\t\t\t int, tree));\n+\t\t\t\t\t\t int));\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n static tree c_make_fname_decl           PARAMS ((tree, int));\n static void c_expand_body               PARAMS ((tree, int, int));\n static void warn_if_shadowing\t\tPARAMS ((tree, tree));\n-static tree build_bitfield_integer_type\tPARAMS ((tree, tree, const char *));\n \f\n /* C-specific option variables.  */\n \n@@ -319,7 +319,7 @@ int flag_noniso_default_format_attributes = 1;\n    being traditional.  */\n int flag_allow_single_precision = 0;\n \n-/* Nonzero means to treat bit-fields as signed unless they say `unsigned'.  */\n+/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */\n \n int flag_signed_bitfields = 1;\n int explicit_flag_signed_bitfields = 0;\n@@ -3390,8 +3390,7 @@ groktypename (typename)\n \n   split_specs_attrs (TREE_PURPOSE (typename), &specs, &attrs);\n \n-  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0,\n-\t\t\t     NULL_TREE);\n+  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0);\n \n   /* Apply attributes.  */\n   decl_attributes (&typename, attrs, 0);\n@@ -3409,7 +3408,7 @@ groktypename_in_parm_context (typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t PARM, 0, NULL_TREE);\n+\t\t\t PARM, 0);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -3442,7 +3441,7 @@ start_decl (declarator, declspecs, initialized, attributes)\n     deprecated_state = DEPRECATED_SUPPRESS;\n \n   decl = grokdeclarator (declarator, declspecs,\n-\t\t\t NORMAL, initialized, NULL_TREE);\n+\t\t\t NORMAL, initialized);\n   \n   deprecated_state = DEPRECATED_NORMAL;\n \n@@ -3820,8 +3819,7 @@ push_parm_decl (parm)\n   immediate_size_expand = 0;\n \n   decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n-\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)),\n-\t\t\t PARM, 0, NULL_TREE);\n+\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)), PARM, 0);\n   decl_attributes (&decl, TREE_VALUE (parm), 0);\n \n #if 0\n@@ -3981,92 +3979,6 @@ complete_array_type (type, initial_value, do_default)\n   return value;\n }\n \f\n-/* A bit-field NAME should have an integer type whose precision\n-   accurately reflects its WIDTH.  If TYPE is good for that, return\n-   it, otherwise create and return the appropriate type.\n-\n-   This routine also performs sanity checks on the bit-field's type\n-   and width, and uses appropriate values if they are invalid.  */\n-static tree\n-build_bitfield_integer_type (type, width, orig_name)\n-     tree type, width;\n-     const char *orig_name;\n-{\n-  tree type_mv;\n-  unsigned int max_width;\n-  unsigned HOST_WIDE_INT w;\n-  const char *name = orig_name ? orig_name: _(\"<anonymous>\");\n-\n-  /* Necessary?  */\n-  STRIP_NOPS (width);\n-\n-  /* Detect and ignore out of range field width and process valid\n-     field widths.  */\n-  if (TREE_CODE (width) != INTEGER_CST)\n-    {\n-      error (\"bit-field `%s' width not an integer constant\", name);\n-      width = integer_one_node;\n-    }\n-  else\n-    {\n-      constant_expression_warning (width);\n-      if (tree_int_cst_sgn (width) < 0)\n-\t{\n-\t  error (\"negative width in bit-field `%s'\", name);\n-\t  width = integer_one_node;\n-\t}\n-      else if (integer_zerop (width) && orig_name)\n-\t{\n-\t  error (\"zero width for bit-field `%s'\", name);\n-\t  width = integer_one_node;\n-\t}\n-    }\n-\n-  /* Detect invalid bit-field type.  */\n-  if (TREE_CODE (type) != INTEGER_TYPE\n-      && TREE_CODE (type) != BOOLEAN_TYPE\n-      && TREE_CODE (type) != ENUMERAL_TYPE)\n-    {\n-      error (\"bit-field `%s' has invalid type\", name);\n-      type = unsigned_type_node;\n-    }\n-\n-  type_mv = TYPE_MAIN_VARIANT (type);\n-  if (pedantic\n-      && type_mv != integer_type_node\n-      && type_mv != unsigned_type_node\n-      && type_mv != c_bool_type_node\n-      /* Accept an enum that's equivalent to int or unsigned int.  */\n-      && (TREE_CODE (type) != ENUMERAL_TYPE\n-\t  || TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node)))\n-    pedwarn (\"type of bit-field `%s' is a GCC extension\", name);\n-\n-  if (type_mv == c_bool_type_node)\n-    max_width = CHAR_TYPE_SIZE;\n-  else\n-    max_width = TYPE_PRECISION (type);\n-\n-  if (0 < compare_tree_int (width, max_width))\n-    {\n-      error (\"width of `%s' exceeds its type\", name);\n-      w = max_width;\n-    }\n-  else\n-    w = tree_low_cst (width, 1);\n-\n-  if (TREE_CODE (type) == ENUMERAL_TYPE\n-      && (w < min_precision (TYPE_MIN_VALUE (type), TREE_UNSIGNED (type))\n-\t  || w < min_precision (TYPE_MAX_VALUE (type), TREE_UNSIGNED (type))))\n-    warning (\"`%s' is narrower than values of its type\", name);\n-\n-  /* The type of a bit-field should have precision the same as the\n-     bit-field's width.  */\n-  if (w != TYPE_PRECISION (type))\n-    type = build_nonstandard_integer_type (w, TREE_UNSIGNED (type));\n-\n-  return type;\n-}\n-\f\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -4086,9 +3998,8 @@ build_bitfield_integer_type (type, width, orig_name)\n      TYPENAME if for a typename (in a cast or sizeof).\n       Don't make a DECL node; just return the ..._TYPE node.\n      FIELD for a struct or union field; make a FIELD_DECL.\n+     BITFIELD for a field with specified width.\n    INITIALIZED is 1 if the decl has an initializer.\n-   WIDTH is non-NULL for bit-fields, and is an INTEGER_CST node representing\n-   the width of the bit-field.\n \n    In the TYPENAME case, DECLARATOR is really an absolute declarator.\n    It may also be so in the PARM case, for a prototype where the\n@@ -4098,12 +4009,11 @@ build_bitfield_integer_type (type, width, orig_name)\n    and `extern' are interpreted.  */\n \n static tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n+grokdeclarator (declarator, declspecs, decl_context, initialized)\n      tree declspecs;\n      tree declarator;\n      enum decl_context decl_context;\n      int initialized;\n-     tree width;\n {\n   int specbits = 0;\n   tree spec;\n@@ -4118,16 +4028,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n   int explicit_char = 0;\n   int defaulted_int = 0;\n   tree typedef_decl = 0;\n-  const char *name, *orig_name;\n+  const char *name;\n   tree typedef_type = 0;\n   int funcdef_flag = 0;\n   enum tree_code innermost_code = ERROR_MARK;\n+  int bitfield = 0;\n   int size_varies = 0;\n   tree decl_attr = NULL_TREE;\n   tree array_ptr_quals = NULL_TREE;\n   int array_parm_static = 0;\n   tree returned_attrs = NULL_TREE;\n-  bool bitfield = width != NULL_TREE;\n+\n+  if (decl_context == BITFIELD)\n+    bitfield = 1, decl_context = FIELD;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n@@ -4160,7 +4073,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n \tdefault:\n \t  abort ();\n \t}\n-    orig_name = name;\n     if (name == 0)\n       name = \"type name\";\n   }\n@@ -4377,9 +4289,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n     }\n \n   /* Decide whether an integer type is signed or not.\n-     Optionally treat bit-fields as signed by default.  */\n+     Optionally treat bitfields as signed by default.  */\n   if (specbits & 1 << (int) RID_UNSIGNED\n-      /* Traditionally, all bit-fields are unsigned.  */\n+      /* Traditionally, all bitfields are unsigned.  */\n       || (bitfield && flag_traditional\n \t  && (! explicit_flag_signed_bitfields || !flag_signed_bitfields))\n       || (bitfield && ! flag_signed_bitfields\n@@ -4452,11 +4364,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n \t}\n     }\n \n-  /* A bit-field needs its type to have precision equal to its width,\n-     rather than the precision of the specified standard type.  */\n-  if (bitfield)\n-    type = build_bitfield_integer_type (type, width, orig_name);\n-\n   /* Figure out the type qualifiers for the declaration.  There are\n      two ways a declaration can become qualified.  One is something\n      like `const int i' where the `const' is explicit.  Another is\n@@ -5106,6 +5013,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n     else if (decl_context == FIELD)\n       {\n \t/* Structure field.  It may not be a function.  */\n+\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    error (\"field `%s' declared as a function\", name);\n@@ -5129,29 +5037,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n-\tif (bitfield)\n-\t  {\n-\t    DECL_SIZE (decl) = bitsize_int (TYPE_PRECISION (type));\n-\t    DECL_BIT_FIELD (decl) = 1;\n-\t    SET_DECL_C_BIT_FIELD (decl);\n-\n-\t    /* Bit-field width 0 => force desired amount of alignment.  */\n-\t    if (TYPE_PRECISION (type) == 0)\n-\t      {\n-#ifdef EMPTY_FIELD_BOUNDARY\n-\t\tDECL_ALIGN (decl) = MAX (DECL_ALIGN (decl),\n-\t\t\t\t\t EMPTY_FIELD_BOUNDARY);\n-#endif\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\tif (PCC_BITFIELD_TYPE_MATTERS)\n-\t\t  {\n-\t\t    DECL_ALIGN (decl) = MAX (DECL_ALIGN (decl),\n-\t\t\t\t\t     TYPE_ALIGN (type));\n-\t\t    DECL_USER_ALIGN (decl) |= TYPE_USER_ALIGN (type);\n-\t\t  }\n-#endif\n-\t      }\n-\t  }\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \n \tif (size_varies)\n@@ -5654,7 +5539,7 @@ start_struct (code, name)\n \n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n    of a structure component, returning a FIELD_DECL node.\n-   WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.\n+   WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.\n \n    This is done during the parsing of the struct declaration.\n    The FIELD_DECL nodes are chained together and the lot of them\n@@ -5680,9 +5565,10 @@ grokfield (filename, line, declarator, declspecs, width)\n \t}\n     }\n \n-  value = grokdeclarator (declarator, declspecs, FIELD, 0, width);\n+  value = grokdeclarator (declarator, declspecs, width ? BITFIELD : FIELD, 0);\n \n   finish_decl (value, NULL_TREE, NULL_TREE);\n+  DECL_INITIAL (value) = width;\n \n   maybe_objc_check_decl (value);\n   return value;\n@@ -5734,7 +5620,10 @@ finish_struct (t, fieldlist, attributes)\n \t\t fieldlist ? _(\"named members\") : _(\"members\"));\n     }\n \n-  /* Install struct as DECL_CONTEXT of each field decl.  */\n+  /* Install struct as DECL_CONTEXT of each field decl.\n+     Also process specified field sizes,m which is found in the DECL_INITIAL.\n+     Store 0 there, except for \": 0\" fields (so we can find them\n+     and delete them, below).  */\n \n   saw_named_field = 0;\n   for (x = fieldlist; x; x = TREE_CHAIN (x))\n@@ -5770,7 +5659,93 @@ finish_struct (t, fieldlist, attributes)\n \terror (\"nested redefinition of `%s'\",\n \t       IDENTIFIER_POINTER (TYPE_NAME (t)));\n \n-      if (TREE_TYPE (x) != error_mark_node && !DECL_BIT_FIELD (x))\n+      /* Detect invalid bit-field size.  */\n+      if (DECL_INITIAL (x))\n+\tSTRIP_NOPS (DECL_INITIAL (x));\n+      if (DECL_INITIAL (x))\n+\t{\n+\t  if (TREE_CODE (DECL_INITIAL (x)) == INTEGER_CST)\n+\t    constant_expression_warning (DECL_INITIAL (x));\n+\t  else\n+\t    {\n+\t      error_with_decl (x,\n+\t\t\t       \"bit-field `%s' width not an integer constant\");\n+\t      DECL_INITIAL (x) = NULL;\n+\t    }\n+\t}\n+\n+      /* Detect invalid bit-field type.  */\n+      if (DECL_INITIAL (x)\n+\t  && TREE_CODE (TREE_TYPE (x)) != INTEGER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n+\t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n+\t{\n+\t  error_with_decl (x, \"bit-field `%s' has invalid type\");\n+\t  DECL_INITIAL (x) = NULL;\n+\t}\n+\n+      if (DECL_INITIAL (x) && pedantic\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != integer_type_node\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != unsigned_type_node\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != c_bool_type_node\n+\t  /* Accept an enum that's equivalent to int or unsigned int.  */\n+\t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n+\t       && (TYPE_PRECISION (TREE_TYPE (x))\n+\t\t   == TYPE_PRECISION (integer_type_node))))\n+\tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ISO C\");\n+\n+      /* Detect and ignore out of range field width and process valid\n+\t field widths.  */\n+      if (DECL_INITIAL (x))\n+\t{\n+\t  int max_width\n+\t    = (TYPE_MAIN_VARIANT (TREE_TYPE (x)) == c_bool_type_node\n+\t       ? CHAR_TYPE_SIZE : TYPE_PRECISION (TREE_TYPE (x)));\n+\n+\t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n+\t    error_with_decl (x, \"negative width in bit-field `%s'\");\n+\t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n+\t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n+\t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n+\t    error_with_decl (x, \"zero width for bit-field `%s'\");\n+\t  else\n+\t    {\n+\t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n+\t      unsigned HOST_WIDE_INT width\n+\t\t= tree_low_cst (DECL_INITIAL (x), 1);\n+\n+\t      if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n+\t\t  && (width < min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t     TREE_UNSIGNED (TREE_TYPE (x)))\n+\t\t      || (width\n+\t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n+\t\twarning_with_decl (x,\n+\t\t\t\t   \"`%s' is narrower than values of its type\");\n+\n+\t      DECL_SIZE (x) = bitsize_int (width);\n+\t      DECL_BIT_FIELD (x) = 1;\n+\t      SET_DECL_C_BIT_FIELD (x);\n+\n+\t      if (width == 0)\n+\t\t{\n+\t\t  /* field size 0 => force desired amount of alignment.  */\n+#ifdef EMPTY_FIELD_BOUNDARY\n+\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n+#endif\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+\t\t  if (PCC_BITFIELD_TYPE_MATTERS)\n+\t\t    {\n+\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (x)));\n+\t\t      DECL_USER_ALIGN (x) |= TYPE_USER_ALIGN (TREE_TYPE (x));\n+\t\t    }\n+#endif\n+\t\t}\n+\t    }\n+\t}\n+\n+      else if (TREE_TYPE (x) != error_mark_node)\n \t{\n \t  unsigned int min_align = (DECL_PACKED (x) ? BITS_PER_UNIT\n \t\t\t\t    : TYPE_ALIGN (TREE_TYPE (x)));\n@@ -5782,6 +5757,8 @@ finish_struct (t, fieldlist, attributes)\n \t    DECL_USER_ALIGN (x) |= TYPE_USER_ALIGN (TREE_TYPE (x));\n \t}\n \n+      DECL_INITIAL (x) = 0;\n+\n       /* Detect flexible array member in an invalid context.  */\n       if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n \t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n@@ -6206,7 +6183,7 @@ start_function (declspecs, declarator, attributes)\n   /* Don't expand any sizes in the return type of the function.  */\n   immediate_size_expand = 0;\n \n-  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL_TREE);\n+  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1);\n \n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */"}, {"sha": "0a57d65b2ef71070aa370ba3ad38b25413d804a6", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -2393,6 +2393,13 @@ objc_copy_list (list, head)\n   while (list)\n     {\n       tail = copy_node (list);\n+\n+      /* The following statement fixes a bug when inheriting instance\n+\t variables that are declared to be bitfields. finish_struct\n+\t expects to find the width of the bitfield in DECL_INITIAL.  */\n+      if (DECL_BIT_FIELD (tail) && DECL_INITIAL (tail) == 0)\n+\tDECL_INITIAL (tail) = DECL_SIZE (tail);\n+\n       newlist = chainon (newlist, tail);\n       list = TREE_CHAIN (list);\n     }"}, {"sha": "56d0268fd77eb309186639c1eccb60e383573492", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -1,3 +1,9 @@\n+2002-02-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/bitfld-1.c: Update.\n+\t* gcc.dg/bitfld-2.c: Update.\n+\t* gcc.c-torture/execute/bitfld-1.x: New.\n+\n 2002-02-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20020201-1.c: New test."}, {"sha": "2f397b96e51b8dd77baecd30d403a01dfab48caf", "filename": "gcc/testsuite/gcc.c-torture/execute/bitfld-1.x", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -0,0 +1,2 @@\n+set torture_execute_xfail \"*-*-*\"\n+return 0"}, {"sha": "ae2283cfb1fa8ccada5af8d621426c0b472e357a", "filename": "gcc/testsuite/gcc.dg/bitfld-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -22,7 +22,7 @@ struct bf1\n   unsigned int : 5;\n   double e: 1;\t\t\t/* { dg-error \"invalid type\" } */\n   float f: 1;\t\t\t/* { dg-error \"invalid type\" } */\n-  unsigned long g: 5;\t\t/* { dg-warning \"GCC extension\" } */\n+  unsigned long g: 5;\t\t/* { dg-warning \"GCC extension|ISO C\" } */\n   ui h: 5;\n   enum foo i: 2;\t\t/* { dg-error \"narrower\" } */\n   enum foo j: 3;"}, {"sha": "d3096a7caa8656f63161f61c4d1366b6a4bb716d", "filename": "gcc/testsuite/gcc.dg/bitfld-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -11,13 +11,13 @@ struct bf\n   int b: 2;\n };\n \n-struct bf p = {4, 0};\t\t/* { dg-warning \"truncated\" } */\n-struct bf q = {0, 2};\t\t/* { dg-warning \"overflow\" } */\n+struct bf p = {4, 0};\t\t/* { dg-warning \"truncated\" \"\" { xfail *-*-* } } */\n+struct bf q = {0, 2};\t\t/* { dg-warning \"overflow\" \"\" { xfail *-*-* } } */\n struct bf r = {3, -2};\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n \n void foo ()\n {\n-  p.a = 4, p.b = 0;\t\t/* { dg-warning \"truncated\" } */\n-  q.a = 0, q.b = 2;\t\t/* { dg-warning \"overflow\" } */\n+  p.a = 4, p.b = 0;\t\t/* { dg-warning \"truncated\" \"\" { xfail *-*-* } } */\n+  q.a = 0, q.b = 2;\t\t/* { dg-warning \"overflow\" \"\" { xfail *-*-* } } */\n   r.a = 3, r.b = -2;\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n }"}, {"sha": "86c0cd0036dd814e042003b88c8c2ae6a5c27148", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -3758,29 +3758,6 @@ build_index_type (maxval)\n     return itype;\n }\n \n-/* Builds a signed or unsigned integer type of precision PRECISION.\n-   Used for C bitfields whose precision does not match that of\n-   built-in target types.  */\n-tree\n-build_nonstandard_integer_type (precision, unsignedp)\n-     unsigned int precision;\n-     int unsignedp;\n-{\n-  tree itype = make_node (INTEGER_TYPE);\n-\n-  TYPE_PRECISION (itype) = precision;\n-\n-  if (unsignedp)\n-    fixup_unsigned_type (itype);\n-  else\n-    fixup_signed_type (itype);\n-\n-  if (host_integerp (TYPE_MAX_VALUE (itype), 1))\n-    return type_hash_canon (tree_low_cst (TYPE_MAX_VALUE (itype), 1), itype);\n-\n-  return itype;\n-}\n-\n /* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n    ENUMERAL_TYPE, BOOLEAN_TYPE, or CHAR_TYPE), with\n    low bound LOWVAL and high bound HIGHVAL."}, {"sha": "e7b634d81f23157c991bf445feb1ad79798518bb", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd48d76f76f8e2e0a973e93f0d96f18bd827476/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dfd48d76f76f8e2e0a973e93f0d96f18bd827476", "patch": "@@ -2862,7 +2862,6 @@ extern tree getdecls\t\t\t\tPARAMS ((void));\n /* Function to return the chain of structure tags in the current scope level.  */\n extern tree gettags\t\t\t\tPARAMS ((void));\n \n-extern tree build_nonstandard_integer_type\tPARAMS ((unsigned int, int));\n extern tree build_range_type PARAMS ((tree, tree, tree));\n \n /* In alias.c */"}]}