{"sha": "273874e925a544d96b8a9999d4c870c1f5191eeb", "node_id": "C_kwDOANBUbNoAKDI3Mzg3NGU5MjVhNTQ0ZDk2YjhhOTk5OWQ0Yzg3MGMxZjUxOTFlZWI", "commit": {"author": {"name": "Srinath Parvathaneni", "email": "srinath.parvathaneni@arm.com", "date": "2023-01-23T11:07:29Z"}, "committer": {"name": "Srinath Parvathaneni", "email": "srinath.parvathaneni@arm.com", "date": "2023-01-23T11:11:48Z"}, "message": "arm: Add support for dwarf debug directives and pseudo hard-register for PAC feature.\n\nThis patch teaches the DWARF support in gcc about RA_AUTH_CODE pseudo hard-register and also\nupdates the \".save\", \".cfi_register\", \".cfi_offset\", \".cfi_restore\" directives accordingly.\nThis patch also adds support to emit \".pacspval\" directive when \"pac ip, lr, sp\" instruction\nin generated in the assembly.\n\nRA_AUTH_CODE register number is 107 and it's dwarf register number is 143.\n\nApplying this patch on top of PACBTI series posted here\nhttps://gcc.gnu.org/pipermail/gcc-patches/2022-August/599658.html and when compiling the following\ntest.c with \"-march=armv8.1-m.main+mve+pacbti -mbranch-protection=pac-ret -mthumb -mfloat-abi=hard\nfasynchronous-unwind-tables -g -O0 -S\" command line options, the assembly output after this patch\nlooks like below:\n\n$cat test.c\n\nvoid fun1(int a);\nvoid fun(int a,...)\n{\n  fun1(a);\n}\n\nint main()\n{\n  fun (10);\n  return 0;\n}\n\n$ arm-none-eabi-gcc -march=armv8.1-m.main+mve+pacbti -mbranch-protection=pac-ret -mthumb -mfloat-abi=hard\n-fasynchronous-unwind-tables -g -O0 -S test.s\n\nAssembly output:\n...\nfun:\n...\n        .pacspval\n        pac     ip, lr, sp\n        .cfi_register 143, 12\n        push    {r3, r7, ip, lr}\n        .save {r3, r7, ra_auth_code, lr}\n...\n        .cfi_offset 143, -24\n...\n        .cfi_restore 143\n...\n        aut     ip, lr, sp\n        bx      lr\n...\nmain:\n...\n        .pacspval\n        pac     ip, lr, sp\n        .cfi_register 143, 12\n        push    {r3, r7, ip, lr}\n        .save {r3, r7, ra_auth_code, lr}\n...\n        .cfi_offset 143, -8\n...\n        .cfi_restore 143\n...\n        aut     ip, lr, sp\n        bx      lr\n...\n\ngcc/ChangeLog:\n\n2023-01-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* config/arm/aout.h (ra_auth_code): Add entry in enum.\n\t* config/arm/arm.cc (emit_multi_reg_push): Add RA_AUTH_CODE register\n\tto dwarf frame expression.\n\t(arm_emit_multi_reg_pop): Restore RA_AUTH_CODE register.\n\t(arm_expand_prologue): Update frame related information and reg notes\n\tfor pac/pacbit insn.\n\t(arm_regno_class): Check for pac pseudo reigster.\n\t(arm_dbx_register_number): Assign ra_auth_code register number in dwarf.\n\t(arm_init_machine_status): Set pacspval_needed to zero.\n\t(arm_debugger_regno): Check for PAC register.\n\t(arm_unwind_emit_sequence): Print .save directive with ra_auth_code\n\tregister.\n\t(arm_unwind_emit_set): Add entry for IP_REGNUM in switch case.\n\t(arm_unwind_emit): Update REG_CFA_REGISTER case._\n\t* config/arm/arm.h (FIRST_PSEUDO_REGISTER): Modify.\n\t(DWARF_PAC_REGNUM): Define.\n\t(IS_PAC_REGNUM): Likewise.\n\t(enum reg_class): Add PAC_REG entry.\n\t(machine_function): Add pacbti_needed state to structure.\n\t* config/arm/arm.md (RA_AUTH_CODE): Define.\n\ngcc/testsuite/ChangeLog:\n\n2023-01-11  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* g++.target/arm/pac-1.C: New test.\n\t* gcc.target/arm/pac-15.c: Likewise.", "tree": {"sha": "c5eb21c3cd24f4d7988deb717e661712e506abea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5eb21c3cd24f4d7988deb717e661712e506abea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/273874e925a544d96b8a9999d4c870c1f5191eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273874e925a544d96b8a9999d4c870c1f5191eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273874e925a544d96b8a9999d4c870c1f5191eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273874e925a544d96b8a9999d4c870c1f5191eeb/comments", "author": {"login": "sripar01", "id": 115715849, "node_id": "U_kgDOBuWvCQ", "avatar_url": "https://avatars.githubusercontent.com/u/115715849?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sripar01", "html_url": "https://github.com/sripar01", "followers_url": "https://api.github.com/users/sripar01/followers", "following_url": "https://api.github.com/users/sripar01/following{/other_user}", "gists_url": "https://api.github.com/users/sripar01/gists{/gist_id}", "starred_url": "https://api.github.com/users/sripar01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sripar01/subscriptions", "organizations_url": "https://api.github.com/users/sripar01/orgs", "repos_url": "https://api.github.com/users/sripar01/repos", "events_url": "https://api.github.com/users/sripar01/events{/privacy}", "received_events_url": "https://api.github.com/users/sripar01/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sripar01", "id": 115715849, "node_id": "U_kgDOBuWvCQ", "avatar_url": "https://avatars.githubusercontent.com/u/115715849?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sripar01", "html_url": "https://github.com/sripar01", "followers_url": "https://api.github.com/users/sripar01/followers", "following_url": "https://api.github.com/users/sripar01/following{/other_user}", "gists_url": "https://api.github.com/users/sripar01/gists{/gist_id}", "starred_url": "https://api.github.com/users/sripar01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sripar01/subscriptions", "organizations_url": "https://api.github.com/users/sripar01/orgs", "repos_url": "https://api.github.com/users/sripar01/repos", "events_url": "https://api.github.com/users/sripar01/events{/privacy}", "received_events_url": "https://api.github.com/users/sripar01/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a0dd2cc28ee2833dc5bf1d4fb6d746a8c55ca4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0dd2cc28ee2833dc5bf1d4fb6d746a8c55ca4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0dd2cc28ee2833dc5bf1d4fb6d746a8c55ca4d"}], "stats": {"total": 181, "additions": 160, "deletions": 21}, "files": [{"sha": "57c3b9b7b8b02f15e191ffcb9446f0edf27bbce6", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -74,7 +74,8 @@\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\t\t\\\n   \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\t\t\\\n   \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\t\t\\\n-  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\", \"p0\"\t\t\\\n+  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\", \"p0\",\t\t\\\n+  \"ra_auth_code\"\t\t\t\t\t\t\\\n }\n #endif\n "}, {"sha": "efc48349dd3508e6790c1a9f3bba5da689a986bc", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 72, "deletions": 14, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -22272,7 +22272,33 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n     {\n       if (mask & (1 << i))\n \t{\n-\t  reg = gen_rtx_REG (SImode, i);\n+\t  /* NOTE: Dwarf code emitter handle reg-reg copies correctly and in the\n+\t     following example reg-reg copy of SP to IP register is handled\n+\t     through .cfi_def_cfa_register directive and the .cfi_offset\n+\t     directive for IP register is skipped by dwarf code emitter.\n+\t     Example:\n+\t\tmov     ip, sp\n+\t\t.cfi_def_cfa_register 12\n+\t\tpush    {fp, ip, lr, pc}\n+\t\t.cfi_offset 11, -16\n+\t\t.cfi_offset 13, -12\n+\t\t.cfi_offset 14, -8\n+\n+\t     Where as Arm-specific .save directive handling is different to that\n+\t     of dwarf code emitter and it doesn't consider reg-reg copies while\n+\t     updating the register list.  When PACBTI is enabled we manually\n+\t     updated the .save directive register list to use \"ra_auth_code\"\n+\t     (pseduo register 143) instead of IP register as shown in following\n+\t     pseduo code.\n+\t     Example:\n+\t\tpacbti  ip, lr, sp\n+\t\t.cfi_register 143, 12\n+\t\tpush    {r3, r7, ip, lr}\n+\t\t.save {r3, r7, ra_auth_code, lr}\n+\t  */\n+\t  rtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\t  if (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t    dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n \n \t  XVECEXP (par, 0, 0)\n \t    = gen_rtx_SET (gen_frame_mem\n@@ -22290,7 +22316,7 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n \t  if (dwarf_regs_mask & (1 << i))\n \t    {\n \t      tmp = gen_rtx_SET (gen_frame_mem (SImode, stack_pointer_rtx),\n-\t\t\t\t reg);\n+\t\t\t\t dwarf_reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n@@ -22303,7 +22329,9 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n     {\n       if (mask & (1 << i))\n \t{\n-\t  reg = gen_rtx_REG (SImode, i);\n+\t  rtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\t  if (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t    dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n \n \t  XVECEXP (par, 0, j) = gen_rtx_USE (VOIDmode, reg);\n \n@@ -22314,7 +22342,7 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n \t\t\t       (SImode,\n \t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t       4 * j)),\n-\t\t\t       reg);\n+\t\t\t       dwarf_reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n@@ -22399,15 +22427,18 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n   for (j = 0, i = 0; j < num_regs; i++)\n     if (saved_regs_mask & (1 << i))\n       {\n-        reg = gen_rtx_REG (SImode, i);\n+\trtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\tif (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t  dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n         if ((num_regs == 1) && emit_update && !return_in_pc)\n           {\n             /* Emit single load with writeback.  */\n             tmp = gen_frame_mem (SImode,\n                                  gen_rtx_POST_INC (Pmode,\n                                                    stack_pointer_rtx));\n             tmp = emit_insn (gen_rtx_SET (reg, tmp));\n-            REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\t    REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE, dwarf_reg,\n+\t\t\t\t\t      dwarf);\n             return;\n           }\n \n@@ -22421,7 +22452,7 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n         /* We need to maintain a sequence for DWARF info too.  As dwarf info\n            should not have PC, skip PC.  */\n         if (i != PC_REGNUM)\n-          dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\t  dwarf = alloc_reg_note (REG_CFA_RESTORE, dwarf_reg, dwarf);\n \n         j++;\n       }\n@@ -23603,6 +23634,8 @@ arm_expand_prologue (void)\n \t\t\t\t\t      -fp_offset));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+\t  if (arm_current_function_pac_enabled_p ())\n+\t    cfun->machine->pacspval_needed = 1;\n \t}\n       else\n \t{\n@@ -23638,6 +23671,8 @@ arm_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  fp_offset = args_to_push;\n \t  args_to_push = 0;\n+\t  if (arm_current_function_pac_enabled_p ())\n+\t    cfun->machine->pacspval_needed = 1;\n \t}\n     }\n \n@@ -23647,9 +23682,13 @@ arm_expand_prologue (void)\n          one will be added before the push of the clobbered IP (if\n          necessary) by the bti pass.  */\n       if (aarch_bti_enabled () && !clobber_ip)\n-\temit_insn (gen_pacbti_nop ());\n+\tinsn = emit_insn (gen_pacbti_nop ());\n       else\n-\temit_insn (gen_pac_nop ());\n+\tinsn = emit_insn (gen_pac_nop ());\n+\n+      rtx dwarf = gen_rtx_SET (ip_rtx, gen_rtx_REG (SImode, RA_AUTH_CODE));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_REGISTER, dwarf);\n     }\n \n   if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n@@ -25731,6 +25770,9 @@ arm_regno_class (int regno)\n   if (IS_VPR_REGNUM (regno))\n     return VPR_REG;\n \n+  if (IS_PAC_REGNUM (regno))\n+    return PAC_REG;\n+\n   if (TARGET_THUMB1)\n     {\n       if (regno == STACK_POINTER_REGNUM)\n@@ -26891,6 +26933,7 @@ arm_init_machine_status (void)\n   machine->func_type = ARM_FT_UNKNOWN;\n #endif\n   machine->static_chain_stack_bytes = -1;\n+  machine->pacspval_needed = 0;\n   return machine;\n }\n \n@@ -29700,6 +29743,9 @@ arm_debugger_regno (unsigned int regno)\n   if (IS_IWMMXT_REGNUM (regno))\n     return 112 + regno - FIRST_IWMMXT_REGNUM;\n \n+  if (IS_PAC_REGNUM (regno))\n+    return DWARF_PAC_REGNUM;\n+\n   return DWARF_FRAME_REGISTERS;\n }\n \n@@ -29793,7 +29839,7 @@ arm_unwind_emit_sequence (FILE * out_file, rtx p)\n   gcc_assert (nregs);\n \n   reg = REGNO (SET_SRC (XVECEXP (p, 0, 1)));\n-  if (reg < 16)\n+  if (reg < 16 || IS_PAC_REGNUM (reg))\n     {\n       /* For -Os dummy registers can be pushed at the beginning to\n \t avoid separate stack pointer adjustment.  */\n@@ -29850,6 +29896,8 @@ arm_unwind_emit_sequence (FILE * out_file, rtx p)\n \t double precision register names.  */\n       if (IS_VFP_REGNUM (reg))\n \tasm_fprintf (out_file, \"d%d\", (reg - FIRST_VFP_REGNUM) / 2);\n+      else if (IS_PAC_REGNUM (reg))\n+\tasm_fprintf (asm_out_file, \"ra_auth_code\");\n       else\n \tasm_fprintf (out_file, \"%r\", reg);\n \n@@ -29944,7 +29992,7 @@ arm_unwind_emit_set (FILE * out_file, rtx p)\n \t  /* Move from sp to reg.  */\n \t  asm_fprintf (out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n \t}\n-     else if (GET_CODE (e1) == PLUS\n+      else if (GET_CODE (e1) == PLUS\n \t      && REG_P (XEXP (e1, 0))\n \t      && REGNO (XEXP (e1, 0)) == SP_REGNUM\n \t      && CONST_INT_P (XEXP (e1, 1)))\n@@ -29953,6 +30001,11 @@ arm_unwind_emit_set (FILE * out_file, rtx p)\n \t  asm_fprintf (out_file, \"\\t.movsp %r, #%d\\n\",\n \t\t       REGNO (e0), (int)INTVAL(XEXP (e1, 1)));\n \t}\n+      else if (REGNO (e0) == IP_REGNUM && arm_current_function_pac_enabled_p ())\n+\t{\n+\t  if (cfun->machine->pacspval_needed)\n+\t    asm_fprintf (out_file, \"\\t.pacspval\\n\");\n+\t}\n       else\n \tabort ();\n       break;\n@@ -30007,10 +30060,15 @@ arm_unwind_emit (FILE * out_file, rtx_insn *insn)\n \t    src = SET_SRC (pat);\n \t    dest = SET_DEST (pat);\n \n-\t    gcc_assert (src == stack_pointer_rtx);\n+\t    gcc_assert (src == stack_pointer_rtx\n+\t\t\t|| IS_PAC_REGNUM (REGNO (src)));\n \t    reg = REGNO (dest);\n-\t    asm_fprintf (out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n-\t\t\t reg + 0x90, reg);\n+\n+\t    if (IS_PAC_REGNUM (REGNO (src)))\n+\t      arm_unwind_emit_set (out_file, PATTERN (insn));\n+\t    else\n+\t      asm_fprintf (out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n+\t\t\t   reg + 0x90, reg);\n \t  }\n \t  handled_one = true;\n \t  break;"}, {"sha": "632728371d5cef364e47bf33bfa0faba738db871", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -816,7 +816,8 @@ extern const int arm_arch_cde_coproc_bits[];\n \ts16-s31\t      S\tVFP variable (aka d8-d15).\n \tvfpcc\t\tNot a real register.  Represents the VFP condition\n \t\t\tcode flags.\n-\tvpr\t\tUsed to represent MVE VPR predication.  */\n+\tvpr\t\tUsed to represent MVE VPR predication.\n+\tra_auth_code\tPseudo register to save PAC.  */\n \n /* The stack backtrace structure is as follows:\n   fp points to here:  |  save code pointer  |      [fp]\n@@ -857,7 +858,7 @@ extern const int arm_arch_cde_coproc_bits[];\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1,1\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -887,7 +888,7 @@ extern const int arm_arch_cde_coproc_bits[];\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1,1\t\t\\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -1063,10 +1064,12 @@ extern const int arm_arch_cde_coproc_bits[];\n    && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n \n /* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP\n-   + 1 APSRQ + 1 APSRGE + 1 VPR.  */\n+   + 1 APSRQ + 1 APSRGE + 1 VPR + 1 Pseudo register to save PAC.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n /* VFP (VFP3) adds 32 (64) + 1 VFPCC.  */\n-#define FIRST_PSEUDO_REGISTER   107\n+#define FIRST_PSEUDO_REGISTER   108\n+\n+#define DWARF_PAC_REGNUM 143\n \n #define DEBUGGER_REGNO(REGNO) arm_debugger_regno (REGNO)\n \n@@ -1253,12 +1256,15 @@ extern int arm_regs_in_sequence[];\n   CC_REGNUM, VFPCC_REGNUM,\t\t\t\\\n   FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM,\t\\\n   SP_REGNUM, PC_REGNUM, APSRQ_REGNUM,\t\t\\\n-  APSRGE_REGNUM, VPR_REGNUM\t\t\t\\\n+  APSRGE_REGNUM, VPR_REGNUM, RA_AUTH_CODE\t\\\n }\n \n #define IS_VPR_REGNUM(REGNUM) \\\n   ((REGNUM) == VPR_REGNUM)\n \n+#define IS_PAC_REGNUM(REGNUM) \\\n+  ((REGNUM) == RA_AUTH_CODE)\n+\n /* Use different register alloc ordering for Thumb.  */\n #define ADJUST_REG_ALLOC_ORDER arm_order_regs_for_local_alloc ()\n \n@@ -1297,6 +1303,7 @@ enum reg_class\n   SFP_REG,\n   AFP_REG,\n   VPR_REG,\n+  PAC_REG,\n   GENERAL_AND_VPR_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -1327,6 +1334,7 @@ enum reg_class\n   \"SFP_REG\",\t\t\\\n   \"AFP_REG\",\t\t\\\n   \"VPR_REG\",\t\t\\\n+  \"PAC_REG\",\t\t\\\n   \"GENERAL_AND_VPR_REGS\", \\\n   \"ALL_REGS\"\t\t\\\n }\n@@ -1356,6 +1364,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000040 }, /* SFP_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000080 }, /* AFP_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000400 }, /* VPR_REG.  */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000800 }, /* PAC_REG.  */\t\\\n   { 0x00005FFF, 0x00000000, 0x00000000, 0x00000400 }, /* GENERAL_AND_VPR_REGS.  */ \\\n   { 0xFFFF7FFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000040F }  /* ALL_REGS.  */\t\\\n }\n@@ -1621,6 +1630,9 @@ typedef struct GTY(()) machine_function\n   /* The number of bytes used to store the static chain register on the\n      stack, above the stack frame.  */\n   int static_chain_stack_bytes;\n+  /* Set to 1 when pointer authentication operation uses value of SP other\n+     than the incoming stack pointer value.  */\n+  int pacspval_needed;\n }\n machine_function;\n #endif"}, {"sha": "cbfc4543531452b0708a38bdf4abf5105b54f8b7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -42,6 +42,7 @@\n    (APSRQ_REGNUM    104)\t; Q bit pseudo register\n    (APSRGE_REGNUM   105)\t; GE bits pseudo register\n    (VPR_REGNUM      106)\t; Vector Predication Register - MVE register.\n+   (RA_AUTH_CODE    107)\t; Pseudo register to save PAC.\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode"}, {"sha": "f671a27b048c647eee973004d9aab6ec99769e38", "filename": "gcc/testsuite/g++.target/arm/pac-1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpac-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpac-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpac-1.C?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -0,0 +1,35 @@\n+/* Check that GCC does .save and .cfi_offset directives with RA_AUTH_CODE pseudo hard-register.  */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"avoid conflicting multilib options\" { *-*-* } { \"-marm\" \"-mcpu=*\" } } */\n+/* { dg-options \"-march=armv8.1-m.main+mve+pacbti -mbranch-protection=pac-ret -mthumb -mfloat-abi=hard -g -O0\" } */\n+\n+__attribute__((noinline)) void\n+fn1 (int a, int b, int c)\n+{\n+  if (a != b + c)\n+    __builtin_abort ();\n+  else\n+    throw b+c;\n+}\n+\n+int main ()\n+{\n+  int a = 120;\n+  try\n+    {\n+      fn1 (a, 40, 80);\n+    }\n+  catch (int x)\n+    {\n+      if (x != a)\n+        __builtin_abort ();\n+      else\n+\treturn 0;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times \"pac\tip, lr, sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\.cfi_register 143, 12\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\.save {r7, ra_auth_code, lr}\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.cfi_offset 143, -8\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\.save {r4, r7, ra_auth_code, lr}\" 1 } } */"}, {"sha": "e1054902955686a78536933580a603d5713794ef", "filename": "gcc/testsuite/gcc.target/arm/pac-15.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpac-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273874e925a544d96b8a9999d4c870c1f5191eeb/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpac-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpac-15.c?ref=273874e925a544d96b8a9999d4c870c1f5191eeb", "patch": "@@ -0,0 +1,32 @@\n+/* Check that GCC does .save and .cfi_offset directives with RA_AUTH_CODE pseudo hard-register.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target mbranch_protection_ok } */\n+/* { dg-skip-if \"avoid conflicting multilib options\" { *-*-* } { \"-marm\" \"-mcpu=*\" } } */\n+/* { dg-options \"-march=armv8.1-m.main+mve+pacbti -mbranch-protection=pac-ret -mthumb -mfloat-abi=hard -fasynchronous-unwind-tables -g -O0\" } */\n+\n+#include \"stdio.h\"\n+\n+__attribute__((noinline)) int\n+fn1 (int a)\n+{\n+  const char *fmt = \"branch-protection\";\n+  int fun1(int x,const char *fmt,int c,int d)\n+    {\n+      printf(\"string = %s\\n\",fmt);\n+      return x+c+d;\n+    }\n+  return fun1(a,fmt,10,10);\n+}\n+\n+int main (void)\n+{\n+  return fn1 (40);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\.pacspval\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pac\tip, lr, sp\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\.cfi_register 143, 12\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\.save {r7, ra_auth_code, lr}\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\.cfi_offset 143, -8\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\.save {r3, r7, ra_auth_code, lr}\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.cfi_offset 143, -12\" 1 } } */"}]}