{"sha": "162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyZTQ1OTFhYTNmMWE3Y2ZiNTE5OGJjNTA0ZGMxMTBiZWU1YTVjYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2009-10-29T09:44:36Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2009-10-29T09:44:36Z"}, "message": "arm.c (count_insns_for_constant): Rework to support counting for thumb2 immediates as well.\n\n\t* arm.c (count_insns_for_constant): Rework to support counting for\n\tthumb2 immediates as well.\n\t(find_best_start): Split out from arm_gen_constant.\n\t(arm_gen_constant): Rework to support XOR with immediate.\n\nFrom-SVN: r153698", "tree": {"sha": "77a7778bebc39605252c4068becd8c18f4cc4292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77a7778bebc39605252c4068becd8c18f4cc4292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca/comments", "author": null, "committer": null, "parents": [{"sha": "d48a31968cd46215e7353b7e0a840df9ed3c4fba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48a31968cd46215e7353b7e0a840df9ed3c4fba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d48a31968cd46215e7353b7e0a840df9ed3c4fba"}], "stats": {"total": 199, "additions": 120, "deletions": 79}, "files": [{"sha": "bbc792cbdd91908ea54f40335f7aa3d55b93d31e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "patch": "@@ -1,3 +1,10 @@\n+2009-10-29  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (count_insns_for_constant): Rework to support counting for\n+\tthumb2 immediates as well.\n+\t(find_best_start): Split out from arm_gen_constant.\n+\t(arm_gen_constant): Rework to support XOR with immediate.\n+\n 2009-10-29  Chao-ying Fu  <fu@mips.com>\n \n \t* config/mips/mips.c (mips_emit_unary, mips_force_unary): New"}, {"sha": "8090836feb009958141cf4ba3d64e4fe851ddab5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 113, "deletions": 79, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "patch": "@@ -2407,20 +2407,24 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n \t\t\t   1);\n }\n \n-/* Return the number of ARM instructions required to synthesize the given\n-   constant.  */\n+/* Return the number of instructions required to synthesize the given\n+   constant, if we start emitting them from bit-position I.  */\n static int\n count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n {\n   HOST_WIDE_INT temp1;\n+  int step_size = TARGET_ARM ? 2 : 1;\n   int num_insns = 0;\n+\n+  gcc_assert (TARGET_ARM || i == 0);\n+\n   do\n     {\n       int end;\n \n       if (i <= 0)\n \ti += 32;\n-      if (remainder & (3 << (i - 2)))\n+      if (remainder & (((1 << step_size) - 1) << (i - step_size)))\n \t{\n \t  end = i - 8;\n \t  if (end < 0)\n@@ -2429,13 +2433,77 @@ count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n \t\t\t\t    | ((i < end) ? (0xff >> (32 - end)) : 0));\n \t  remainder &= ~temp1;\n \t  num_insns++;\n-\t  i -= 6;\n+\t  i -= 8 - step_size;\n \t}\n-      i -= 2;\n+      i -= step_size;\n     } while (remainder);\n   return num_insns;\n }\n \n+static int\n+find_best_start (HOST_WIDE_INT remainder)\n+{\n+  int best_consecutive_zeros = 0;\n+  int i;\n+  int best_start = 0;\n+\n+  /* If we aren't targetting ARM, the best place to start is always at\n+     the bottom.  */\n+  if (! TARGET_ARM)\n+    return 0;\n+\n+  for (i = 0; i < 32; i += 2)\n+    {\n+      int consecutive_zeros = 0;\n+\n+      if (!(remainder & (3 << i)))\n+\t{\n+\t  while ((i < 32) && !(remainder & (3 << i)))\n+\t    {\n+\t      consecutive_zeros += 2;\n+\t      i += 2;\n+\t    }\n+\t  if (consecutive_zeros > best_consecutive_zeros)\n+\t    {\n+\t      best_consecutive_zeros = consecutive_zeros;\n+\t      best_start = i - consecutive_zeros;\n+\t    }\n+\t  i -= 2;\n+\t}\n+    }\n+\n+  /* So long as it won't require any more insns to do so, it's\n+     desirable to emit a small constant (in bits 0...9) in the last\n+     insn.  This way there is more chance that it can be combined with\n+     a later addressing insn to form a pre-indexed load or store\n+     operation.  Consider:\n+\n+\t   *((volatile int *)0xe0000100) = 1;\n+\t   *((volatile int *)0xe0000110) = 2;\n+\n+     We want this to wind up as:\n+\n+\t    mov rA, #0xe0000000\n+\t    mov rB, #1\n+\t    str rB, [rA, #0x100]\n+\t    mov rB, #2\n+\t    str rB, [rA, #0x110]\n+\n+     rather than having to synthesize both large constants from scratch.\n+\n+     Therefore, we calculate how many insns would be required to emit\n+     the constant starting from `best_start', and also starting from\n+     zero (i.e. with bit 31 first to be output).  If `best_start' doesn't\n+     yield a shorter sequence, we may as well use zero.  */\n+  if (best_start != 0\n+      && ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)\n+      && (count_insns_for_constant (remainder, 0) <=\n+\t  count_insns_for_constant (remainder, best_start)))\n+    best_start = 0;\n+\n+  return best_start;\n+}\n+\n /* Emit an instruction with the indicated PATTERN.  If COND is\n    non-NULL, conditionalize the execution of the instruction on COND\n    being true.  */\n@@ -2459,6 +2527,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n {\n   int can_invert = 0;\n   int can_negate = 0;\n+  int final_invert = 0;\n   int can_negate_initial = 0;\n   int can_shift = 0;\n   int i;\n@@ -2470,6 +2539,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n   int insns = 0;\n   unsigned HOST_WIDE_INT temp1, temp2;\n   unsigned HOST_WIDE_INT remainder = val & 0xffffffff;\n+  int step_size = TARGET_ARM ? 2 : 1;\n \n   /* Find out which operations are safe for a given CODE.  Also do a quick\n      check for degenerate cases; these can occur when DImode operations\n@@ -2543,14 +2613,15 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t  return 1;\n \t}\n \n-      /* We don't know how to handle other cases yet.  */\n-      gcc_assert (remainder == 0xffffffff);\n-\n-      if (generate)\n-\temit_constant_insn (cond,\n-\t\t\t    gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t\t gen_rtx_NOT (mode, source)));\n-      return 1;\n+      if (remainder == 0xffffffff)\n+\t{\n+\t  if (generate)\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t     gen_rtx_NOT (mode, source)));\n+\t  return 1;\n+\t}\n+      break;\n \n     case MINUS:\n       /* We treat MINUS as (val - source), since (source - val) is always\n@@ -3001,9 +3072,25 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \n   if ((code == AND)\n       || (code != IOR && can_invert && num_bits_set > 16))\n-    remainder = (~remainder) & 0xffffffff;\n+    remainder ^= 0xffffffff;\n   else if (code == PLUS && num_bits_set > 16)\n     remainder = (-remainder) & 0xffffffff;\n+\n+  /* For XOR, if more than half the bits are set and there's a sequence\n+     of more than 8 consecutive ones in the pattern then we can XOR by the\n+     inverted constant and then invert the final result; this may save an\n+     instruction and might also lead to the final mvn being merged with\n+     some other operation.  */\n+  else if (code == XOR && num_bits_set > 16\n+\t   && (count_insns_for_constant (remainder ^ 0xffffffff,\n+\t\t\t\t\t find_best_start\n+\t\t\t\t\t (remainder ^ 0xffffffff))\n+\t       < count_insns_for_constant (remainder,\n+\t\t\t\t\t   find_best_start (remainder))))\n+    {\n+      remainder ^= 0xffffffff;\n+      final_invert = 1;\n+    }\n   else\n     {\n       can_invert = 0;\n@@ -3022,63 +3109,8 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n   /* ??? Use thumb2 replicated constants when the high and low halfwords are\n      the same.  */\n   {\n-    int best_start = 0;\n-    if (!TARGET_THUMB2)\n-      {\n-\tint best_consecutive_zeros = 0;\n-\n-\tfor (i = 0; i < 32; i += 2)\n-\t  {\n-\t    int consecutive_zeros = 0;\n-\n-\t    if (!(remainder & (3 << i)))\n-\t      {\n-\t\twhile ((i < 32) && !(remainder & (3 << i)))\n-\t\t  {\n-\t\t    consecutive_zeros += 2;\n-\t\t    i += 2;\n-\t\t  }\n-\t\tif (consecutive_zeros > best_consecutive_zeros)\n-\t\t  {\n-\t\t    best_consecutive_zeros = consecutive_zeros;\n-\t\t    best_start = i - consecutive_zeros;\n-\t\t  }\n-\t\ti -= 2;\n-\t      }\n-\t  }\n-\n-\t/* So long as it won't require any more insns to do so, it's\n-\t   desirable to emit a small constant (in bits 0...9) in the last\n-\t   insn.  This way there is more chance that it can be combined with\n-\t   a later addressing insn to form a pre-indexed load or store\n-\t   operation.  Consider:\n-\n-\t\t   *((volatile int *)0xe0000100) = 1;\n-\t\t   *((volatile int *)0xe0000110) = 2;\n-\n-\t   We want this to wind up as:\n-\n-\t\t    mov rA, #0xe0000000\n-\t\t    mov rB, #1\n-\t\t    str rB, [rA, #0x100]\n-\t\t    mov rB, #2\n-\t\t    str rB, [rA, #0x110]\n-\n-\t   rather than having to synthesize both large constants from scratch.\n-\n-\t   Therefore, we calculate how many insns would be required to emit\n-\t   the constant starting from `best_start', and also starting from\n-\t   zero (i.e. with bit 31 first to be output).  If `best_start' doesn't\n-\t   yield a shorter sequence, we may as well use zero.  */\n-\tif (best_start != 0\n-\t    && ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)\n-\t    && (count_insns_for_constant (remainder, 0) <=\n-\t\tcount_insns_for_constant (remainder, best_start)))\n-\t  best_start = 0;\n-      }\n-\n     /* Now start emitting the insns.  */\n-    i = best_start;\n+    i = find_best_start (remainder);\n     do\n       {\n \tint end;\n@@ -3106,7 +3138,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    if (remainder && subtargets)\n+\t\t    if ((final_invert || remainder) && subtargets)\n \t\t      new_src = gen_reg_rtx (mode);\n \t\t    else\n \t\t      new_src = target;\n@@ -3141,21 +3173,23 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t      code = PLUS;\n \n \t    insns++;\n-\t    if (TARGET_ARM)\n-\t      i -= 6;\n-\t    else\n-\t      i -= 7;\n+\t    i -= 8 - step_size;\n \t  }\n \t/* Arm allows rotates by a multiple of two. Thumb-2 allows arbitrary\n \t   shifts.  */\n-\tif (TARGET_ARM)\n-\t  i -= 2;\n-\telse\n-\t  i--;\n+\ti -= step_size;\n       }\n     while (remainder);\n   }\n \n+  if (final_invert)\n+    {\n+      if (generate)\n+\temit_constant_insn (cond, gen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t       gen_rtx_NOT (mode, source)));\n+      insns++;\n+    }\n+\n   return insns;\n }\n "}]}