{"sha": "bc1c7e9300698df733202b646759ba4fe58ad295", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMxYzdlOTMwMDY5OGRmNzMzMjAyYjY0Njc1OWJhNGZlNThhZDI5NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T11:43:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T11:43:53Z"}, "message": "(expand_divmod): Clean up code and documentation, especially in areas\nrelated to when copies are made.\n\nFrom-SVN: r5098", "tree": {"sha": "62c04e02784081080bda3facaf9f04fd01a2ba85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c04e02784081080bda3facaf9f04fd01a2ba85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc1c7e9300698df733202b646759ba4fe58ad295", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1c7e9300698df733202b646759ba4fe58ad295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc1c7e9300698df733202b646759ba4fe58ad295", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1c7e9300698df733202b646759ba4fe58ad295/comments", "author": null, "committer": null, "parents": [{"sha": "a61c98cf7f4a669439b1a430d035c4748dcf632a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c98cf7f4a669439b1a430d035c4748dcf632a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61c98cf7f4a669439b1a430d035c4748dcf632a"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "3dcf6c7824b9dc6f46f964ab22cf1c1e4dd5a83a", "filename": "gcc/expmed.c", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1c7e9300698df733202b646759ba4fe58ad295/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1c7e9300698df733202b646759ba4fe58ad295/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=bc1c7e9300698df733202b646759ba4fe58ad295", "patch": "@@ -2255,27 +2255,21 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (op1 == const1_rtx)\n     return rem_flag ? const0_rtx : op0;\n \n-  /* Don't use the function value register as a target\n-     since we have to read it as well as write it,\n-     and function-inlining gets confused by this.  */\n-  if (target && REG_P (target) && REG_FUNCTION_VALUE_P (target))\n+  if (target\n+      /* Don't use the function value register as a target\n+\t since we have to read it as well as write it,\n+\t and function-inlining gets confused by this.  */\n+      && ((REG_P (target) && REG_FUNCTION_VALUE_P (target))\n+\t  /* Don't clobber an operand while doing a multi-step calculation.  */\n+\t  || (rem_flag\n+\t      && (reg_mentioned_p (target, op0)\n+\t\t  || (GET_CODE (op0) == MEM && GET_CODE (target) == MEM)))\n+\t  || reg_mentioned_p (target, op1)\n+\t  || (GET_CODE (op1) == MEM && GET_CODE (target) == MEM)))\n     target = 0;\n \n-  /* Don't clobber an operand while doing a multi-step calculation.  */\n-  if (target)\n-    if ((rem_flag && (reg_mentioned_p (target, op0)\n-\t\t      || (GET_CODE (op0) == MEM && GET_CODE (target) == MEM)))\n-\t|| reg_mentioned_p (target, op1)\n-\t|| (GET_CODE (op1) == MEM && GET_CODE (target) == MEM))\n-      target = 0;\n-\n-  can_clobber_op0 = (GET_CODE (op0) == REG && op0 == target);\n-\n-  if (GET_CODE (op1) == CONST_INT)\n-    log = exact_log2 (INTVAL (op1));\n-\n-  /* If log is >= 0, we are dividing by 2**log, and will do it by shifting,\n-     which is really floor-division.  Otherwise we will really do a divide,\n+  /* See if we are dividing by 2**log, and hence will do it by shifting,\n+     which is really floor-division, or if we will really do a divide,\n      and we assume that is trunc-division.\n \n      We must correct the dividend by adding or subtracting something\n@@ -2291,17 +2285,19 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      dividend is non-negative.  Performance measurements of the two\n      alternatives show that the branch-free code is slightly faster on the\n      IBM ROMP but slower on CISC processors (significantly slower on the\n-     VAX).  Accordingly, the jump code has been retained.\n+     VAX).  Accordingly, the jump code has been retained when BRANCH_COST\n+     is small.\n \n      On machines where the jump code is slower, the cost of a DIV or MOD\n      operation can be set small (less than twice that of an addition); in \n      that case, we pretend that we don't have a power of two and perform\n      a normal division or modulus operation.  */\n \n-  if ((code == TRUNC_MOD_EXPR || code == TRUNC_DIV_EXPR)\n-      && ! unsignedp\n-      && (rem_flag ? smod_pow2_cheap : sdiv_pow2_cheap))\n-    log = -1;\n+  if (GET_CODE (op1) == CONST_INT\n+      && ! ((code == TRUNC_MOD_EXPR || code == TRUNC_DIV_EXPR)\n+\t    && ! unsignedp\n+\t    && (rem_flag ? smod_pow2_cheap : sdiv_pow2_cheap)))\n+    log = exact_log2 (INTVAL (op1));\n \n   /* Get the mode in which to perform this computation.  Normally it will\n      be MODE, but sometimes we can't do the desired operation in MODE.\n@@ -2335,13 +2331,18 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  || optab2->handlers[(int) compute_mode].libfunc)\n \tbreak;\n \n-  /* If we still couldn't find a mode, use MODE; we'll probably abort in\n-     expand_binop.  */\n+  /* If we still couldn't find a mode, use MODE, but we'll probably abort\n+     in expand_binop.  */\n   if (compute_mode == VOIDmode)\n     compute_mode = mode;\n \n   size = GET_MODE_BITSIZE (compute_mode);\n \n+  /* If OP0 is a register that is used as the target, we can modify\n+     it in place; otherwise, we have to ensure we copy OP0 before\n+     modifying it.  */\n+  can_clobber_op0 = (GET_CODE (op0) == REG && op0 == target);\n+\n   /* Now convert to the best mode to use.  Show we made a copy of OP0\n      and hence we can clobber it (we cannot use a SUBREG to widen\n      something.  */\n@@ -2365,8 +2366,36 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (rem_flag)\n     can_clobber_op0 = 0;\n \n-  if (target == 0 || GET_MODE (target) != compute_mode)\n-    target = gen_reg_rtx (compute_mode);\n+  /* See if we will need to modify ADJUSTED_OP0.  Note that this code\n+     must agree with that in the switch below.  */\n+  if (((code == TRUNC_MOD_EXPR || code == TRUNC_DIV_EXPR)\n+       && log >= 0 && ! unsignedp)\n+      || ((code == FLOOR_MOD_EXPR || code == FLOOR_DIV_EXPR)\n+\t  && log < 0 && ! unsignedp)\n+      || code == CEIL_MOD_EXPR || code == CEIL_DIV_EXPR\n+      || code == ROUND_MOD_EXPR || code == ROUND_DIV_EXPR)\n+    {\n+      /* If we want the remainder, we may need to use OP0, so make sure\n+\t it and ADJUSTED_OP0 are in different registers.  If we want to\n+\t preserve subexpressions, make sure OP0 is in a register.\n+\n+\t If we don't want the remainder, we aren't going to use OP0 anymore.\n+\t However, if we cannot clobber OP0 (and hence ADJUSTED_OP0), we must\n+\t make a copy of it, hopefully to TARGET.\n+\n+\t This code is somewhat tricky.  Note that if REM_FLAG is nonzero,\n+\t CAN_CLOBBER_OP0 will be zero and we know that OP0 cannot\n+\t equal TARGET.  */\n+\n+      if (rem_flag && preserve_subexpressions_p ())\n+\top0 = force_reg (compute_mode, op0);\n+\n+      if (! can_clobber_op0)\n+\tadjusted_op0 = copy_to_suggested_reg (op0, target, compute_mode);\n+    }\n+\n+  /* Adjust ADJUSTED_OP0 as described above.  Unless CAN_CLOBBER_OP0\n+     is now non-zero, OP0 will retain it's original value.  */\n \n   switch (code)\n     {\n@@ -2378,37 +2407,33 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t     This can be computed without jumps by arithmetically shifting\n \t     OP0 right LOG-1 places and then shifting right logically\n \t     SIZE-LOG bits.  The resulting value is unconditionally added\n-\t     to OP0.  */\n+\t     to OP0.\n+\n+\t     If OP0 cannot be modified in place, copy it, possibly to\n+\t     TARGET.  Note that we will have previously only allowed\n+\t     it to be modified in place if it is a register, so that\n+\t     after this `if', ADJUSTED_OP0 is known to be a\n+\t     register.  */\n \t  if (log == 1 || BRANCH_COST >= 3)\n \t    {\n-\t      rtx temp = gen_reg_rtx (compute_mode);\n-\t      if (! can_clobber_op0)\n-\t\t/* Copy op0 to a reg, to play safe,\n-\t\t   since this is done in the other path.  */\n-\t\top0 = force_reg (compute_mode, op0);\n-\t      temp = copy_to_suggested_reg (adjusted_op0, temp, compute_mode);\n-\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n+\t      rtx temp;\n+\n+\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, adjusted_op0,\n \t\t\t\t   build_int_2 (log - 1, 0), NULL_RTX, 0);\n+\n+\t      /* We cannot allow TEMP to be ADJUSTED_OP0 here.  */\n \t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n \t\t\t\t   build_int_2 (size - log, 0),\n-\t\t\t\t   temp, 1);\n-\t      /* We supply 0 as the target to make a new pseudo\n-\t\t for the value; that helps loop.c optimize the result.  */\n+\t\t\t\t   temp != adjusted_op0 ? temp : NULL_RTX, 1);\n+\n \t      adjusted_op0 = expand_binop (compute_mode, add_optab,\n-\t\t\t\t\t   adjusted_op0, temp,\n-\t\t\t\t\t   0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t   adjusted_op0, temp, adjusted_op0,\n+\t\t\t\t\t   0, OPTAB_LIB_WIDEN);\n \t    }\n \t  else\n \t    {\n \t      rtx label = gen_label_rtx ();\n-\t      if (! can_clobber_op0)\n-\t\t{\n-\t\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n-\t\t\t\t\t\t\tcompute_mode);\n-\t\t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n-\t\t     which will screw up mem refs for autoincrements.  */\n-\t\t  op0 = force_reg (compute_mode, op0);\n-\t\t}\n+\n \t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n \t\t\t     NULL_RTX, compute_mode, 0, 0);\n \t      emit_jump_insn (gen_bge (label));\n@@ -2424,14 +2449,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       if (log < 0 && ! unsignedp)\n \t{\n \t  rtx label = gen_label_rtx ();\n-\t  if (! can_clobber_op0)\n-\t    {\n-\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n-\t\t\t\t\t\t    compute_mode);\n-\t      /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n-\t\t which will screw up mem refs for autoincrements.  */\n-\t      op0 = force_reg (compute_mode, op0);\n-\t    }\n+\n \t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n \t\t\t NULL_RTX, compute_mode, 0, 0);\n \t  emit_jump_insn (gen_bge (label));\n@@ -2444,14 +2462,6 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n     case CEIL_DIV_EXPR:\n     case CEIL_MOD_EXPR:\n-      if (! can_clobber_op0)\n-\t{\n-\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n-\t\t\t\t\t\tcompute_mode);\n-\t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n-\t     which will screw up mem refs for autoincrements.  */\n-\t  op0 = force_reg (compute_mode, op0);\n-\t}\n       if (log < 0)\n \t{\n \t  rtx label = 0;\n@@ -2468,24 +2478,15 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t    emit_label (label);\n \t}\n       else\n-\t{\n-\t  adjusted_op0 = expand_binop (compute_mode, add_optab,\n-\t\t\t\t       adjusted_op0, plus_constant (op1, -1),\n-\t\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t}\n+\tadjusted_op0 = expand_binop (compute_mode, add_optab,\n+\t\t\t\t     adjusted_op0, plus_constant (op1, -1),\n+\t\t\t\t     adjusted_op0, 0, OPTAB_LIB_WIDEN);\n+\n       mod_insn_no_good = 1;\n       break;\n \n     case ROUND_DIV_EXPR:\n     case ROUND_MOD_EXPR:\n-      if (! can_clobber_op0)\n-\t{\n-\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n-\t\t\t\t\t\tcompute_mode);\n-\t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n-\t     which will screw up mem refs for autoincrements.  */\n-\t  op0 = force_reg (compute_mode, op0);\n-\t}\n       if (log < 0)\n \t{\n \t  op1 = expand_shift (RSHIFT_EXPR, compute_mode, op1,\n@@ -2497,11 +2498,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t  /* Negate OP1 if OP0 < 0.  Do this by computing a temporary\n \t\t     that has all bits equal to the sign bit and exclusive\n \t\t     or-ing it with OP1.  */\n-\t\t  rtx temp = gen_reg_rtx (compute_mode);\n-\t\t  temp = copy_to_suggested_reg (adjusted_op0, temp, compute_mode);\n-\t\t  temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n-\t\t\t\t       build_int_2 (size - 1, 0),\n-\t\t\t\t       NULL_RTX, 0);\n+\t\t  rtx temp = expand_shift (RSHIFT_EXPR, compute_mode,\n+\t\t\t\t\t   adjusted_op0,\n+\t\t\t\t\t   build_int_2 (size - 1, 0),\n+\t\t\t\t\t   NULL_RTX, 0);\n \t\t  op1 = expand_binop (compute_mode, xor_optab, op1, temp, op1,\n \t\t\t\t      unsignedp, OPTAB_LIB_WIDEN);\n \t\t}\n@@ -2518,10 +2518,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  expand_inc (adjusted_op0, op1);\n \t}\n       else\n-\t{\n-\t  op1 = GEN_INT (((HOST_WIDE_INT) 1 << log) / 2);\n-\t  expand_inc (adjusted_op0, op1);\n-\t}\n+\texpand_inc (adjusted_op0, GEN_INT (((HOST_WIDE_INT) 1 << log) / 2));\n+\n       mod_insn_no_good = 1;\n       break;\n     }"}]}