{"sha": "cafba4956be9da85d61c193a9e8227156f010565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmYmE0OTU2YmU5ZGE4NWQ2MWMxOTNhOWU4MjI3MTU2ZjAxMDU2NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-25T04:24:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-25T04:24:36Z"}, "message": "gcse.c (find_avail_set): Follow chains of register-register copies.\n\n        * gcse.c (find_avail_set): Follow chains of register-register copies.\n        Use oprs_not_set_p to guarantee that the returned value can be\n        substituted.\n        (cprop_insn): Don't verify the return value of find_avail_set with\n        oprs_not_set_p.\n\nFrom-SVN: r28835", "tree": {"sha": "d1cae3dd4e961e5e5ac25a4a3a9447688cb7687b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1cae3dd4e961e5e5ac25a4a3a9447688cb7687b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cafba4956be9da85d61c193a9e8227156f010565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafba4956be9da85d61c193a9e8227156f010565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cafba4956be9da85d61c193a9e8227156f010565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafba4956be9da85d61c193a9e8227156f010565/comments", "author": null, "committer": null, "parents": [{"sha": "abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd535b681d7bba79c3f8bc85451822fe7e4f8d0"}], "stats": {"total": 99, "additions": 74, "deletions": 25}, "files": [{"sha": "9df927a19b231603f188fd8a8c0b915abeb1e9c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafba4956be9da85d61c193a9e8227156f010565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafba4956be9da85d61c193a9e8227156f010565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cafba4956be9da85d61c193a9e8227156f010565", "patch": "@@ -110,6 +110,12 @@ Tue Aug 24 09:32:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Tue Aug 24 12:35:20 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n+\t* gcse.c (find_avail_set): Follow chains of register-register copies.\n+\tUse oprs_not_set_p to guarantee that the returned value can be\n+\tsubstituted.\n+\t(cprop_insn): Don't verify the return value of find_avail_set with\n+\toprs_not_set_p.\n+\n \t* gcse.c (cprop_jump): New function, broken out of cprop_insn.\n \t(cprop_cc0_jump): New function.\n \t(cprop_insn): Break out new function cprop_jump and use it."}, {"sha": "f5fe9b9cd6f572b05a13b7946bdb4ade71f177c0", "filename": "gcc/gcse.c", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafba4956be9da85d61c193a9e8227156f010565/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafba4956be9da85d61c193a9e8227156f010565/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=cafba4956be9da85d61c193a9e8227156f010565", "patch": "@@ -3656,16 +3656,65 @@ find_avail_set (regno, insn)\n      int regno;\n      rtx insn;\n {\n-  struct expr *set = lookup_set (regno, NULL_RTX);\n+  /* SET1 contains the last set found that can be returned to the caller for\n+     use in a substitution.  */\n+  struct expr *set1 = 0;\n+ \n+  /* Loops are not possible here.  To get a loop we would need two sets\n+     available at the start of the block containing INSN.  ie we would\n+     need two sets like this available at the start of the block:\n+\n+       (set (reg X) (reg Y))\n+       (set (reg Y) (reg X))\n+\n+     This can not happen since the set of (reg Y) would have killed the\n+     set of (reg X) making it unavailable at the start of this block.  */\n+  while (1)\n+     {\n+      rtx src;\n+      struct expr *set = lookup_set (regno, NULL_RTX);\n+\n+      /* Find a set that is available at the start of the block\n+\t which contains INSN.  */\n+      while (set)\n+\t{\n+\t  if (TEST_BIT (cprop_avin[BLOCK_NUM (insn)], set->bitmap_index))\n+\t    break;\n+\t  set = next_set (regno, set);\n+\t}\n \n-  while (set)\n-    {\n-      if (TEST_BIT (cprop_avin[BLOCK_NUM (insn)], set->bitmap_index))\n+      /* If no available set was found we've reached the end of the\n+\t (possibly empty) copy chain.  */\n+      if (set == 0)\n+ \tbreak;\n+\n+      if (GET_CODE (set->expr) != SET)\n+\tabort ();\n+\n+      src = SET_SRC (set->expr);\n+\n+      /* We know the set is available.\n+\t Now check that SRC is ANTLOC (i.e. none of the source operands\n+\t have changed since the start of the block).  \n+\n+         If the source operand changed, we may still use it for the next\n+         iteration of this loop, but we may not use it for substitutions.  */\n+      if (CONSTANT_P (src) || oprs_not_set_p (src, insn))\n+\tset1 = set;\n+\n+      /* If the source of the set is anything except a register, then\n+\t we have reached the end of the copy chain.  */\n+      if (GET_CODE (src) != REG)\n \tbreak;\n-      set = next_set (regno, set);\n-    }\n \n-  return set;\n+      /* Follow the copy chain, ie start another iteration of the loop\n+\t and see if we have an available copy into SRC.  */\n+      regno = REGNO (src);\n+     }\n+\n+  /* SET1 holds the last set that was available and anticipatable at\n+     INSN.  */\n+  return set1;\n }\n \n /* Subroutine of cprop_insn that tries to propagate constants into\n@@ -3875,27 +3924,21 @@ cprop_insn (insn, alter_jumps)\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t       && REGNO (src) != regno)\n \t{\n-\t  /* We know the set is available.\n-\t     Now check that SET_SRC is ANTLOC (i.e. none of the source operands\n-\t     have changed since the start of the block).  */\n-\t  if (oprs_not_set_p (src, insn))\n+\t  if (try_replace_reg (reg_used->reg_rtx, src, insn))\n \t    {\n-\t      if (try_replace_reg (reg_used->reg_rtx, src, insn))\n+\t      changed = 1;\n+\t      copy_prop_count++;\n+\t      if (gcse_file != NULL)\n \t\t{\n-\t\t  changed = 1;\n-\t\t  copy_prop_count++;\n-\t\t  if (gcse_file != NULL)\n-\t\t    {\n-\t\t      fprintf (gcse_file, \"COPY-PROP: Replacing reg %d in insn %d with reg %d\\n\",\n-\t\t\t       regno, INSN_UID (insn), REGNO (src));\n-\t\t    }\n-\n-\t\t  /* The original insn setting reg_used may or may not now be\n-\t\t     deletable.  We leave the deletion to flow.  */\n-\t\t  /* FIXME: If it turns out that the insn isn't deletable,\n-\t\t     then we may have unnecessarily extended register lifetimes\n-\t\t     and made things worse.  */\n+\t\t  fprintf (gcse_file, \"COPY-PROP: Replacing reg %d in insn %d with reg %d\\n\",\n+\t\t\t   regno, INSN_UID (insn), REGNO (src));\n \t\t}\n+\n+\t      /* The original insn setting reg_used may or may not now be\n+\t\t deletable.  We leave the deletion to flow.  */\n+\t      /* FIXME: If it turns out that the insn isn't deletable,\n+\t\t then we may have unnecessarily extended register lifetimes\n+\t\t and made things worse.  */\n \t    }\n \t}\n     }"}]}