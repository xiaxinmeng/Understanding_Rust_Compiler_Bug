{"sha": "b2d16a23f1f032c1104db7bb015535b9735aa94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJkMTZhMjNmMWYwMzJjMTEwNGRiN2JiMDE1NTM1Yjk3MzVhYTk0YQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@kss-loka.si", "date": "2005-09-14T09:27:01Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-09-14T09:27:01Z"}, "message": "re PR middle-end/22480 (ICE in convert_move, at expr.c:390 with -ftree-vectorize)\n\n2005-09-14  Uros Bizjak  <uros@kss-loka.si>\n\n        PR middle-end/22480\n        * tree-vect-transform.c (vectorizable_operation): Return false for\n        scalar shift operations and for vector shift operations with\n        non-invariant shift arguments.  Use scalar tree operand op1 as\n        a shift operand when vector shift insn pattern uses scalar shift\n        operand.\n        * Makefile.in (tree-vect-transform.o): Depend on recog.h.\n\nFrom-SVN: r104264", "tree": {"sha": "d59e962d2c903927a3d0d8e3491f60047dbda90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d59e962d2c903927a3d0d8e3491f60047dbda90b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2d16a23f1f032c1104db7bb015535b9735aa94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d16a23f1f032c1104db7bb015535b9735aa94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d16a23f1f032c1104db7bb015535b9735aa94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d16a23f1f032c1104db7bb015535b9735aa94a/comments", "author": null, "committer": null, "parents": [{"sha": "816fa80a8f1dd56131f17538216c7115be986833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816fa80a8f1dd56131f17538216c7115be986833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816fa80a8f1dd56131f17538216c7115be986833"}], "stats": {"total": 92, "additions": 89, "deletions": 3}, "files": [{"sha": "191cdc20bca693744c1abfbca9411345b8d3af98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2d16a23f1f032c1104db7bb015535b9735aa94a", "patch": "@@ -1,3 +1,13 @@\n+2005-09-14  Uros Bizjak  <uros@kss-loka.si>\n+\n+\tPR middle-end/22480\n+\t* tree-vect-transform.c (vectorizable_operation): Return false for\n+\tscalar shift operations and for vector shift operations with\n+\tnon-invariant shift arguments.  Use scalar tree operand op1 as\n+\ta shift operand when vector shift insn pattern uses scalar shift\n+\toperand.\n+\t* Makefile.in (tree-vect-transform.o): Depend on recog.h.\n+\n 2005-09-14  Olivier Hainque  <hainque@adacore.com>\n \n \t* gimplify.c (gimplify_init_ctor_eval): Don't discard a zero-sized"}, {"sha": "fded53db71d48cae807c40159d2ae2b4eb47b834", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b2d16a23f1f032c1104db7bb015535b9735aa94a", "patch": "@@ -1959,7 +1959,7 @@ tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) tree-chrec.h\n tree-vect-transform.o: tree-vect-transform.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) \\\n+   coretypes.h $(TM_H) $(GGC_H) $(OPTABS_H) $(RECOG_H) $(TREE_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n    $(TIMEVAR_H) $(CFGLOOP_H) $(TARGET_H) tree-pass.h $(EXPR_H) \\\n    tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) langhooks.h toplev.h \\"}, {"sha": "271f36842c54df3201233c006402250e1b64bb17", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2d16a23f1f032c1104db7bb015535b9735aa94a", "patch": "@@ -1,3 +1,8 @@\n+2005-09-14  Uros Bizjak  <uros@kss-loka.si>\n+\n+\tPR middle-end/22480\n+\t* gcc.dg/vect/pr22480.c: New test.\n+\n 2005-09-13  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/19358"}, {"sha": "ddf657fb942341cada07d2a03db9bf3d448db731", "filename": "gcc/testsuite/gcc.dg/vect/pr22480.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr22480.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr22480.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr22480.c?ref=b2d16a23f1f032c1104db7bb015535b9735aa94a", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+void\n+test_1 (void)\n+{\n+  static unsigned int bm[16];\n+  int j;\n+  for (j = 0; j < 16; j++)\n+    bm[j] <<= 8;\n+}\n+\n+void\n+test_2 (int a)\n+{\n+  static unsigned int bm[16];\n+  int j;\n+  for (j = 0; j < 16; j++)\n+    bm[j] <<= a;\n+}\n+\n+void\n+test_3 (void)\n+{\n+ static unsigned bm[16];\n+ int am[16];\n+ int j;\n+ for (j = 0; j < 16;j++)\n+   bm[j] <<= am[j];\n+}"}, {"sha": "4084e5a973b65b1375990aaf629f0a43dd19c7d6", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d16a23f1f032c1104db7bb015535b9735aa94a/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=b2d16a23f1f032c1104db7bb015535b9735aa94a", "patch": "@@ -35,6 +35,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"recog.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n@@ -1409,6 +1410,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int op_type;\n   tree op;\n   optab optab;\n+  int icode;\n+  enum machine_mode optab_op2_mode;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n \n@@ -1464,7 +1467,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n-  if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+  icode = (int) optab->handlers[(int) vec_mode].insn_code;\n+  if (icode == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"op not supported by target.\");\n@@ -1486,6 +1490,25 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n+  if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (!VECTOR_MODE_P (vec_mode))\n+\treturn false;\n+\n+      /* Invariant argument is needed for a vector shift\n+\t by a scalar shift operand.  */\n+      optab_op2_mode = insn_data[icode].operand[2].mode;\n+      if (! (VECTOR_MODE_P (optab_op2_mode)\n+\t     || dt == vect_constant_def\n+\t     || dt == vect_invariant_def))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"operand mode requires invariant argument.\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n@@ -1508,7 +1531,25 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n-      vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL); \n+\n+      if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+\t{\n+\t  /* Vector shl and shr insn patterns can be defined with\n+\t     scalar operand 2 (shift operand).  In this case, use\n+\t     constant or loop invariant op1 directly, without\n+\t     extending it to vector mode first.  */\n+\n+\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n+\t  if (!VECTOR_MODE_P (optab_op2_mode))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"operand 1 using scalar mode.\");\n+\t      vec_oprnd1 = op1;\n+\t    }\n+\t}\n+\n+      if (!vec_oprnd1)\n+\tvec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL); \n     }\n \n   /* Arguments are ready. create the new vector stmt.  */"}]}