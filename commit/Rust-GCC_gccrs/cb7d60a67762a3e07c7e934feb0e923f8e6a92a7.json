{"sha": "cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3ZDYwYTY3NzYyYTNlMDdjN2U5MzRmZWIwZTkyM2Y4ZTZhOTJhNw==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2009-10-11T20:48:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-10-11T20:48:46Z"}, "message": "re PR target/33743 (unwinding through signal frames)\n\n\tPR target/33743\n\t* config/sparc/sol2.h (MD_UNWIND_SUPPORT): Define.\n\t* config/sparc/sol2-unwind.h: New file.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r152649", "tree": {"sha": "c8c665a3c52976156261d64fa054e91b88a92903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8c665a3c52976156261d64fa054e91b88a92903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d232178a93d0895482b4cb606f89830352e47db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d232178a93d0895482b4cb606f89830352e47db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d232178a93d0895482b4cb606f89830352e47db"}], "stats": {"total": 467, "additions": 467, "deletions": 0}, "files": [{"sha": "4ef144ed0b5601539fe39f404952dbe8ae39625a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "patch": "@@ -1,3 +1,10 @@\n+2009-10-11  Jose Ruiz  <ruiz@adacore.com>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/33743\n+\t* config/sparc/sol2.h (MD_UNWIND_SUPPORT): Define.\n+\t* config/sparc/sol2-unwind.h: New file.\n+\n 2009-10-11  Olivier Hainque  <hainque@adacore.com>\n             Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "c98dc4dc088e9276bb856466a89fa2ca5f008140", "filename": "gcc/config/sparc/sol2-unwind.h", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h?ref=cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "patch": "@@ -0,0 +1,458 @@\n+/* DWARF2 EH unwinding support for SPARC Solaris.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <ucontext.h>\n+\n+#if defined(__arch64__)\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+sparc64_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState *fs)\n+{\n+  void *pc = context->ra;\n+  void *this_cfa = context->cfa;\n+  void *new_cfa, *ra_location, *shifted_ra_location;\n+  int regs_off;\n+  int fpu_save_off;\n+  unsigned char fpu_save;\n+  int i;\n+\n+  /* This is the observed pattern for the sigacthandler in Solaris 8.  */\n+  unsigned int sigacthandler_sol8_pattern []\n+    = {0x9401400f, 0xca5aafa0, 0x913e2000, 0x892a3003,\n+       0xe0590005, 0x9fc40000, 0x9410001a, 0x80a6e008};\n+\n+  /* This is the observed pattern for the sigacthandler in Solaris 9.  */ \n+  unsigned int sigacthandler_sol9_pattern []\n+    = {0xa33e2000, 0x00000000, 0x892c7003, 0x90100011,\n+       0xe0590005, 0x9fc40000, 0x9410001a, 0x80a46008};\n+\n+  /* This is the observed pattern for the __sighndlr.  */\n+  unsigned int sighndlr_pattern []\n+    = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,\n+       0x9410001a, 0x81c7e008, 0x81e80000};\n+\n+  /* Deal with frame-less function from which a signal was raised.  */\n+  if (_Unwind_IsSignalFrame (context))\n+    {\n+      /* The CFA is by definition unmodified in this case.  */\n+      fs->regs.cfa_how = CFA_REG_OFFSET;\n+      fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+      fs->regs.cfa_offset = 0;\n+\n+      /* This is the canonical RA column.  */\n+      fs->retaddr_column = 15;\n+\n+      return _URC_NO_REASON;\n+    }\n+\n+  /* Look for the sigacthandler pattern.  The pattern changes slightly\n+     in different versions of the operating system, so we skip the\n+     comparison against pc-(4*6) for Solaris 9.  */\n+  if ((    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol8_pattern[0]\n+\t&& *(unsigned int *)(pc-(4*6)) == sigacthandler_sol8_pattern[1]\n+\t&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol8_pattern[2]\n+\t&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol8_pattern[3]\n+\t&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol8_pattern[4]\n+\t&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol8_pattern[5]\n+\t&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol8_pattern[6]\n+\t&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol8_pattern[7] ) ||\n+      (    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol9_pattern[0]\n+\t/* skip pc-(4*6) */\n+\t&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol9_pattern[2]\n+\t&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol9_pattern[3]\n+\t&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol9_pattern[4]\n+\t&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol9_pattern[5]\n+\t&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol9_pattern[6]\n+\t&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol9_pattern[7] ) )\n+    /* We need to move up two frames (the kernel frame and the handler\n+       frame).  Minimum stack frame size is 176 bytes (128 + 48): 128\n+       bytes for spilling register window (16 extended words for in\n+       and local registers), and 6 extended words to store at least\n+       6 arguments to callees, The kernel frame and the sigacthandler\n+       both have this minimal stack.  The ucontext_t structure is after\n+       this offset.  */\n+    regs_off = 176 + 176;\n+\n+  /* Look for the __sighndlr pattern.  */\n+  else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]\n+\t    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]\n+\t    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]\n+\t    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]\n+\t    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]\n+\t    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]\n+\t    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )\n+    {\n+      /* We have observed different calling frames among different\n+\t versions of the operating system, so that we need to\n+\t discriminate using the upper frame.  We look for the return\n+\t address of the caller frame (there is an offset of 15 double\n+\t words between the frame address and the place where this return\n+\t address is stored) in order to do some more pattern matching.  */\n+      unsigned int cuh_pattern\n+\t= *(unsigned int *)(*(unsigned long *)(this_cfa + 15*8) - 4);\n+\n+      if (cuh_pattern == 0x9410001a || cuh_pattern == 0x94100013)\n+\t/* This matches the call_user_handler pattern for Solaris 9 and\n+\t   for Solaris 8 running inside Solaris Containers respectively.\n+\t   We need to move up four frames (the kernel frame, the signal\n+\t   frame, the call_user_handler frame, the __sighndlr frame).\n+\t   Three of them have the minimum stack frame size (kernel,\n+\t   signal, and __sighndlr frames) of 176 bytes, and there is\n+\t   another with a stack frame of 304 bytes (the call_user_handler\n+\t   frame).  The ucontext_t structure is after this offset.  */\n+\tregs_off = 176 + 176 + 176 + 304;\n+      else\n+\t/* We need to move up three frames (the kernel frame, the\n+\t   sigacthandler frame, and the __sighndlr frame).  The kernel\n+\t   frame has a stack frame size of 176, the __sighndlr frames of\n+\t   304 bytes, and there is a stack frame of 176 bytes for the\n+\t   sigacthandler frame.  The ucontext_t structure is after this\n+\t   offset.  */\n+\tregs_off = 176 + 304 + 176;\n+    }\n+\n+  /* Exit if the pattern at the return address does not match the\n+     previous three patterns.  */\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  /* FPU information can be extracted from the ucontext_t structure \n+     that is the third argument for the signal handler, that is saved\n+     in the stack.  There are 64 bytes between the beginning of the\n+     ucontext_t argument of the signal handler and the uc_mcontext\n+     field.  There are 176 bytes between the beginning of uc_mcontext\n+     and the beginning of the fpregs field.  */\n+  fpu_save_off = regs_off + (8*10) + 176;\n+\n+  /* The fpregs field contains 32 extended words at the beginning that\n+     contain the fpu state.  Then there are 2 extended words and two\n+     bytes.  */\n+  fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (8*32) + (2*8) + 2);\n+\n+  /* We need to get the frame pointer for the kernel frame that\n+     executes when the signal is raised.  This frame is just the\n+     following to the application code that generated the signal, so\n+     that the later's stack pointer is the former's frame pointer.\n+     The stack pointer for the interrupted application code can be\n+     calculated from the ucontext_t structure (third argument for the\n+     signal handler) that is saved in the stack.  There are 10 words\n+     between the beginning of the  ucontext_t argument  of the signal\n+     handler and the uc_mcontext.gregs field that contains the\n+     registers saved by the signal handler.  */\n+  new_cfa = *(void **)(this_cfa + regs_off + (8*10) + (REG_SP*8));\n+  /* The frame address is %sp + STACK_BIAS in 64-bit mode. */\n+  new_cfa += 2047;\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = new_cfa - this_cfa;\n+\n+  /* Restore global and out registers (in this order) from the\n+     ucontext_t structure, uc_mcontext.gregs field.  */\n+  for (i = 1; i < 16; i++)\n+    {\n+      /* We never restore %sp as everything is purely CFA-based.  */\n+      if ((unsigned int) i == __builtin_dwarf_sp_column ())\n+\tcontinue;\n+\n+      /* First the global registers and then the out registers.  */\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= this_cfa + regs_off + (8*10) + ((REG_Y+i)*8) - new_cfa;\n+    }\n+\n+  /* Just above the stack pointer there are 16 extended words in which\n+     the register window (in and local registers) was saved.  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i + 16].loc.offset = i*8;\n+    }\n+\n+  /* Check whether we need to restore fpu registers.  */\n+  if (fpu_save)\n+    {\n+      for (i = 0; i < 64; i++)\n+\t{\n+\t  if (i > 32 && (i & 1))\n+\t    continue;\n+\n+\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + 32].loc.offset\n+\t    = this_cfa + fpu_save_off + (i*4) - new_cfa;\n+\t}\n+    }\n+\n+  /* State the rules to find the kernel's code \"return address\", which is\n+     the address of the active instruction when the signal was caught.\n+     On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n+     need to preventively subtract it from the purported return address.  */\n+  ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);\n+  shifted_ra_location = this_cfa + regs_off + (8*10) + (REG_Y*8);\n+  *(void **)shifted_ra_location = *(void **)ra_location - 8;\n+  fs->retaddr_column = 0;\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+#define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context\n+\n+static void\n+sparc64_frob_update_context (struct _Unwind_Context *context,\n+\t\t\t     _Unwind_FrameState *fs)\n+{\n+  /* The column of %sp contains the old CFA, not the old value of %sp.\n+     The CFA offset already comprises the stack bias so, when %sp is the\n+     CFA register, we must avoid counting the stack bias twice.  Do not\n+     do that for signal frames as the offset is artificial for them.  */\n+  if (fs->regs.cfa_reg == __builtin_dwarf_sp_column ()\n+      && fs->regs.cfa_how == CFA_REG_OFFSET\n+      && fs->regs.cfa_offset != 0\n+      && !fs->signal_frame)\n+    context->cfa -= 2047;\n+}\n+\n+#else\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR sparc_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+sparc_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  void *pc = context->ra;\n+  void *this_cfa = context->cfa;\n+  void *new_cfa, *ra_location, *shifted_ra_location;\n+  int regs_off;\n+  int fpu_save_off;\n+  unsigned char fpu_save;\n+  int i;\n+\n+  /* This is the observed pattern for the sigacthandler.  */\n+  unsigned int sigacthandler_pattern []\n+    = {0x9602400f, 0x92100019, 0x00000000, 0x912e2002,\n+       0xe002000a, 0x90100018, 0x9fc40000, 0x9410001a,\n+       0x80a62008};\n+\n+  /* This is the observed pattern for the __libthread_segvhdlr.  */\n+  unsigned int segvhdlr_pattern []\n+    = {0x94102000, 0xe007bfe4, 0x9010001c, 0x92100019,\n+       0x9fc40000, 0x9410001a, 0x81c7e008, 0x81e80000,\n+       0x80a26000};\n+\n+  /* This is the observed pattern for the __sighndlr.  */\n+  unsigned int sighndlr_pattern []\n+    = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,\n+       0x9410001a, 0x81c7e008, 0x81e80000};\n+\n+  /* Deal with frame-less function from which a signal was raised.  */\n+  if (_Unwind_IsSignalFrame (context))\n+    {\n+      /* The CFA is by definition unmodified in this case.  */\n+      fs->regs.cfa_how = CFA_REG_OFFSET;\n+      fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+      fs->regs.cfa_offset = 0;\n+\n+      /* This is the canonical RA column.  */\n+      fs->retaddr_column = 15;\n+\n+      return _URC_NO_REASON;\n+    }\n+\n+  /* Look for the sigacthandler pattern.  The pattern changes slightly\n+     in different versions of the operating system, so we skip the\n+     comparison against pc-(4*6).  */\n+  if (    *(unsigned int *)(pc-(4*8)) == sigacthandler_pattern[0]\n+       && *(unsigned int *)(pc-(4*7)) == sigacthandler_pattern[1]\n+       /* skip pc-(4*6) */\n+       && *(unsigned int *)(pc-(4*5)) == sigacthandler_pattern[3]\n+       && *(unsigned int *)(pc-(4*4)) == sigacthandler_pattern[4]\n+       && *(unsigned int *)(pc-(4*3)) == sigacthandler_pattern[5]\n+       && *(unsigned int *)(pc-(4*2)) == sigacthandler_pattern[6]\n+       && *(unsigned int *)(pc-(4*1)) == sigacthandler_pattern[7]\n+       && *(unsigned int *)(pc-(4*0)) == sigacthandler_pattern[8] )\n+    /* We need to move up two frames (the kernel frame and the handler\n+       frame).  Minimum stack frame size is 96 bytes (64 + 4 + 24): 64\n+       bytes for spilling register window (16 words for in and local\n+       registers), 4 bytes for a pointer to space for callees\n+       returning structs, and 24 bytes to store at least six argument\n+       to callees.  The ucontext_t structure is after this offset.  */\n+    regs_off = 96 + 96;\n+\n+  /* Look for the __libthread_segvhdlr pattern.  */\n+  else if (    *(unsigned int *)(pc-(4*6)) == segvhdlr_pattern[0]\n+\t    && *(unsigned int *)(pc-(4*5)) == segvhdlr_pattern[1]\n+\t    && *(unsigned int *)(pc-(4*4)) == segvhdlr_pattern[2]\n+\t    && *(unsigned int *)(pc-(4*3)) == segvhdlr_pattern[3]\n+\t    && *(unsigned int *)(pc-(4*2)) == segvhdlr_pattern[4]\n+\t    && *(unsigned int *)(pc-(4*1)) == segvhdlr_pattern[5]\n+\t    && *(unsigned int *)(pc-(4*0)) == segvhdlr_pattern[6]\n+\t    && *(unsigned int *)(pc+(4*1)) == segvhdlr_pattern[7]\n+\t    && *(unsigned int *)(pc+(4*2)) == segvhdlr_pattern[8] )\n+    /* We need to move up four frames (the kernel frame, the\n+       sigacthandler frame, the __sighndlr frame, and the\n+       __libthread_segvhdlr).  Two of them have the minimum\n+       stack frame size (kernel and __sighndlr frames) of 96 bytes,\n+       other has a stack frame of 216 bytes (the sigacthandler frame),\n+       and there is another with a stack frame of 128 bytes (the\n+       __libthread_segvhdlr).  The ucontext_t structure is after this\n+       offset.  */\n+    regs_off = 96 + 96 + 128 + 216;\n+\n+  /* Look for the __sighndlr pattern.  */\n+  else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]\n+\t    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]\n+\t    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]\n+\t    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]\n+\t    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]\n+\t    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]\n+\t    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )\n+    {\n+      /* We have observed different calling frames among different\n+\t versions of the operating system, so that we need to\n+\t discriminate using the upper frame.  We look for the return\n+\t address of the caller frame (there is an offset of 15 words\n+\t between the frame address and the place where this return\n+\t address is stored) in order to do some more pattern matching.  */\n+      unsigned int cuh_pattern\n+\t= *(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4);\n+\n+      if (cuh_pattern == 0xd407a04c)\n+\t/* This matches the call_user_handler pattern for Solaris 10.\n+\t   We need to move up three frames (the kernel frame, the\n+\t   call_user_handler frame, the __sighndlr frame).  Two of them\n+\t   have the minimum stack frame size (kernel and __sighndlr\n+\t   frames) of 96 bytes, and there is another with a stack frame\n+\t   of 160 bytes (the call_user_handler frame).  The ucontext_t\n+\t  structure is after this offset.  */\n+\tregs_off = 96 + 96 + 160;\n+      else if (cuh_pattern == 0x9410001a || cuh_pattern == 0x9410001b)\n+\t/* This matches the call_user_handler pattern for Solaris 9 and\n+\t   for Solaris 8 running inside Solaris Containers respectively.\n+\t   We need to move up four frames (the kernel frame, the signal\n+\t   frame, the call_user_handler frame, the __sighndlr frame).\n+\t   Three of them have the minimum stack frame size (kernel,\n+\t   signal, and __sighndlr frames) of 96 bytes, and there is\n+\t   another with a stack frame of 160 bytes (the call_user_handler\n+\t   frame).  The ucontext_t structure is after this offset.  */\n+\tregs_off = 96 + 96 + 96 + 160;\n+      else\n+\t/* We need to move up three frames (the kernel frame, the\n+\t   sigacthandler frame, and the __sighndlr frame).  Two of them\n+\t   have the minimum stack frame size (kernel and __sighndlr\n+\t   frames) of 96 bytes, and there is another with a stack frame\n+\t   of 216 bytes (the sigacthandler frame).  The ucontext_t \n+\t   structure is after this offset.  */\n+\tregs_off = 96 + 96 + 216;\n+    }\n+\n+  /* Exit if the pattern at the return address does not match the\n+     previous three patterns.  */\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  /* FPU information can be extracted from the ucontext_t structure\n+     that is the third argument for the signal handler, that is saved\n+     in the stack.  There are 10 words between the beginning of the\n+     ucontext_t argument of the signal handler and the uc_mcontext\n+     field.  There are 80 bytes between the beginning of uc_mcontext\n+     and the beginning of the fpregs field.  */\n+  fpu_save_off = regs_off + (4*10) + (4*20);\n+\n+  /* The fpregs field contains 32 words at the beginning that contain\n+     the fpu state.  Then there are 2 words and two bytes.  */\n+  fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (4*32) + (2*4) + 2);\n+\n+  /* We need to get the frame pointer for the kernel frame that\n+     executes when the signal is raised.  This frame is just the\n+     following to the application code that generated the signal, so\n+     that the later's stack pointer is the former's frame pointer.\n+     The stack pointer for the interrupted application code can be\n+     calculated from the ucontext_t structure (third argument for the\n+     signal handler) that is saved in the stack.  There are 10 words\n+     between the beginning of the  ucontext_t argument  of the signal\n+     handler and the uc_mcontext.gregs field that contains the\n+     registers saved by the signal handler.  */\n+  new_cfa = *(void **)(this_cfa + regs_off + (4*10) + (REG_SP*4));\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = new_cfa - this_cfa;\n+\n+  /* Restore global and out registers (in this order) from the\n+     ucontext_t structure, uc_mcontext.gregs field.  */\n+  for (i = 1; i < 16; i++)\n+    {\n+      /* We never restore %sp as everything is purely CFA-based.  */\n+      if ((unsigned int) i == __builtin_dwarf_sp_column ())\n+\tcontinue;\n+\n+      /* First the global registers and then the out registers */\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= this_cfa + regs_off + (4*10) + ((REG_Y+i)*4) - new_cfa;\n+    }\n+\n+  /* Just above the stack pointer there are 16 words in which the\n+     register window (in and local registers) was saved.  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i + 16].loc.offset = i*4;\n+    }\n+\n+  /* Check whether we need to restore fpu registers.  */\n+  if (fpu_save)\n+    {\n+      for (i = 0; i < 32; i++)\n+\t{\n+\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + 32].loc.offset\n+\t    = this_cfa + fpu_save_off + (i*4) - new_cfa;\n+\t}\n+    }\n+\n+  /* State the rules to find the kernel's code \"return address\", which is\n+     the address of the active instruction when the signal was caught.\n+     On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n+     need to preventively subtract it from the purported return address.  */\n+  ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);\n+  shifted_ra_location = this_cfa + regs_off + (4*10) + (REG_Y*4);\n+  *(void **)shifted_ra_location = *(void **)ra_location - 8;\n+  fs->retaddr_column = 0;\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+};\n+\n+#endif"}, {"sha": "a3f7647027b31c149099a83b22884f31328e6fd2", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7d60a67762a3e07c7e934feb0e923f8e6a92a7/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=cb7d60a67762a3e07c7e934feb0e923f8e6a92a7", "patch": "@@ -194,3 +194,5 @@ along with GCC; see the file COPYING3.  If not see\n \t       (SIZE), (ALIGN) / BITS_PER_UNIT);\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n+\n+#define MD_UNWIND_SUPPORT \"config/sparc/sol2-unwind.h\""}]}