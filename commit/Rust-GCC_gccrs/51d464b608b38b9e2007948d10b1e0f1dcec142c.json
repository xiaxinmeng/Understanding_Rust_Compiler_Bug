{"sha": "51d464b608b38b9e2007948d10b1e0f1dcec142c", "node_id": "C_kwDOANBUbNoAKDUxZDQ2NGI2MDhiMzhiOWUyMDA3OTQ4ZDEwYjFlMGYxZGNlYzE0MmM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-08T08:53:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-08T08:53:00Z"}, "message": "c++, match.pd: Evaluate in constant evaluation comparisons like &var1 + 12 == &var2 + 24 [PR89074]\n\nThe match.pd address_comparison simplification can only handle\nADDR_EXPR comparisons possibly converted to some other type (I wonder\nif we shouldn't restrict it in address_compare to casts to pointer\ntypes or pointer-sized integer types, I think we shouldn't optimize\n(short) (&var) == (short) (&var2) because we really don't know whether\nit will be true or false).  On GIMPLE, most of pointer to pointer\ncasts are useless and optimized away and further we have in\ngimple_fold_stmt_to_constant_1 an optimization that folds\n&something p+ const_int\ninto\n&MEM_REF[..., off]\nOn GENERIC, we don't do that and e.g. for constant evaluation it\ncould be pretty harmful if e.g. such pointers are dereferenced, because\nit can lose what exact field it was starting with etc., all it knows\nis the base and offset, type and alias set.\nInstead of teaching the match.pd address_compare about 3 extra variants\nwhere one or both compared operands are pointer_plus, this patch attempts\nto fold operands of comparisons similarly to gimple_fold_stmt_to_constant_1\nbefore calling fold_binary on it.\nThere is another thing though, while we do have (x p+ y) p+ z to\nx p+ (y + z) simplification which works on GIMPLE well because of the\nuseless pointer conversions, on GENERIC we can have pointer casts in between\nand at that point we can end up with large expressions like\n((type3) (((type2) ((type1) (&var + 2) + 2) + 2) + 2))\netc.  Pointer-plus doesn't really care what exact pointer type it has as\nlong as it is a pointer, so the following match.pd simplification for\nGENERIC only (it is useless for GIMPLE) also moves the cast so that nested\np+ can be simplified.\n\nNote, I've noticed we don't really diagnose going out of bounds with\npointer_plus (unlike e.g. with ARRAY_REF) during constant evaluation, I\nthink another patch for cxx_eval_binary_expression with POINTER_PLUS will be\nneeded.  But it isn't clear to me what exactly it should do in case of\nsubobjects.  If we start with address of a whole var, (&var), I guess we\nshould diagnose if the pointer_plus gets before start of the var (i.e.\n\"negative\") or 1 byte past the end of the var, but what if we start with\n&var.field or &var.field[3] ?  For &var.field, shall we diagnose out of\nbounds of field (except perhaps flexible members?) or the whole var?\nFor ARRAY_REFs, I assume we must at least strip all the outer ARRAY_REFs\nand so start with &var.field too, right?\n\n2022-01-08  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/89074\ngcc/\n\t* match.pd ((ptr) (x p+ y) p+ z -> (ptr) (x p+ (y + z))): New GENERIC\n\tsimplification.\ngcc/cp/\n\t* constexpr.c (cxx_maybe_fold_addr_pointer_plus): New function.\n\t(cxx_eval_binary_expression): Use it.\ngcc/testsuite/\n\t* g++.dg/cpp1y/constexpr-89074-2.C: New test.\n\t* g++.dg/cpp1z/constexpr-89074-1.C: New test.", "tree": {"sha": "a7286c76a4fd727574413dbd6f81b00265be7da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7286c76a4fd727574413dbd6f81b00265be7da0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51d464b608b38b9e2007948d10b1e0f1dcec142c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d464b608b38b9e2007948d10b1e0f1dcec142c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51d464b608b38b9e2007948d10b1e0f1dcec142c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d464b608b38b9e2007948d10b1e0f1dcec142c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "787d66eb6c53094161fb86e64ddf65f21389f63d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787d66eb6c53094161fb86e64ddf65f21389f63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787d66eb6c53094161fb86e64ddf65f21389f63d"}], "stats": {"total": 91, "additions": 91, "deletions": 0}, "files": [{"sha": "af6a4a729e9ebbabcf4065ef8548c4fd50c6327c", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=51d464b608b38b9e2007948d10b1e0f1dcec142c", "patch": "@@ -3290,6 +3290,38 @@ cxx_fold_pointer_plus_expression (const constexpr_ctx *ctx, tree t,\n   return NULL_TREE;\n }\n \n+/* Try to fold expressions like\n+   (struct S *) (&a[0].D.2378 + 12)\n+   into\n+   &MEM <struct T> [(void *)&a + 12B]\n+   This is something normally done by gimple_fold_stmt_to_constant_1\n+   on GIMPLE, but is undesirable on GENERIC if we are e.g. going to\n+   dereference the address because some details are lost.\n+   For pointer comparisons we want such folding though so that\n+   match.pd address_compare optimization works.  */\n+\n+static tree\n+cxx_maybe_fold_addr_pointer_plus (tree t)\n+{\n+  while (CONVERT_EXPR_P (t)\n+\t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0))))\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) != POINTER_PLUS_EXPR)\n+    return NULL_TREE;\n+  tree op0 = TREE_OPERAND (t, 0);\n+  tree op1 = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (op1) != INTEGER_CST)\n+    return NULL_TREE;\n+  while (CONVERT_EXPR_P (op0)\n+\t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0))))\n+    op0 = TREE_OPERAND (op0, 0);\n+  if (TREE_CODE (op0) != ADDR_EXPR)\n+    return NULL_TREE;\n+  op1 = fold_convert (ptr_type_node, op1);\n+  tree r = fold_build2 (MEM_REF, TREE_TYPE (TREE_TYPE (op0)), op0, op1);\n+  return build1_loc (EXPR_LOCATION (t), ADDR_EXPR, TREE_TYPE (op0), r);\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Like cxx_eval_unary_expression, except for binary expressions.  */\n \n@@ -3349,6 +3381,15 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n       else if (TREE_CODE (rhs) == PTRMEM_CST)\n \trhs = cplus_expand_constant (rhs);\n     }\n+  if (r == NULL_TREE\n+      && TREE_CODE_CLASS (code) == tcc_comparison\n+      && POINTER_TYPE_P (TREE_TYPE (lhs)))\n+    {\n+      if (tree lhso = cxx_maybe_fold_addr_pointer_plus (lhs))\n+\tlhs = fold_convert (TREE_TYPE (lhs), lhso);\n+      if (tree rhso = cxx_maybe_fold_addr_pointer_plus (rhs))\n+\trhs = fold_convert (TREE_TYPE (rhs), rhso);\n+    }\n   if (code == POINTER_PLUS_EXPR && !*non_constant_p\n       && integer_zerop (lhs) && !integer_zerop (rhs))\n     {"}, {"sha": "f5dcbf32bc7cb347f14a87fc27cd8a5bd4d0e371", "filename": "gcc/match.pd", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=51d464b608b38b9e2007948d10b1e0f1dcec142c", "patch": "@@ -2143,6 +2143,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n   (pointer_plus (pointer_plus:s @0 @1) @3)\n   (pointer_plus @0 (plus @1 @3)))\n+#if GENERIC\n+(simplify\n+  (pointer_plus (convert:s (pointer_plus:s @0 @1)) @3)\n+  (convert:type (pointer_plus @0 (plus @1 @3))))\n+#endif\n \n /* Pattern match\n      tem1 = (long) ptr1;"}, {"sha": "6a088ee1d1da219798399c0e04cd01cfd7287210", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89074-2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-2.C?ref=51d464b608b38b9e2007948d10b1e0f1dcec142c", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/89074\n+// { dg-do compile { target c++14 } }\n+\n+constexpr bool\n+foo ()\n+{\n+  int a[] = { 1, 2 };\n+  int b[] = { 3, 4 };\n+\n+  if (a + 0 == b + 0)\n+    return false;\n+\n+  if (a + 1 == b + 0)\n+    return false;\n+\n+  return true;\n+}\n+\n+static_assert (foo (), \"\");"}, {"sha": "ca91765ab202740f0e3ec611930610e9e17d28df", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-89074-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-89074-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d464b608b38b9e2007948d10b1e0f1dcec142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-89074-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-89074-1.C?ref=51d464b608b38b9e2007948d10b1e0f1dcec142c", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/89074\n+// { dg-do compile { target c++17 } }\n+\n+struct S { int s; };\n+struct T : public S { };\n+struct U : public T { };\n+\n+constexpr bool\n+foo ()\n+{\n+  U a[] = { 1, 2, 3, 4 };\n+  U b[] = { 5, 6, 7, 8 };\n+  T *c = (T *) a + 1;\n+  S *d = (S *) c + 2;\n+  S *e = (S *) b + 1;\n+\n+  if (a + 0 == b + 0)\n+    return false;\n+\n+  if (d == e)\n+    return false;\n+\n+  return true;\n+}\n+\n+static_assert (foo (), \"\");"}]}