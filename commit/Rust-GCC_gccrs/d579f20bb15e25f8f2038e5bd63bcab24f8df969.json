{"sha": "d579f20bb15e25f8f2038e5bd63bcab24f8df969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3OWYyMGJiMTVlMjVmOGYyMDM4ZTViZDYzYmNhYjI0ZjhkZjk2OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-07-28T16:12:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-07-28T16:12:03Z"}, "message": "tree-vrp.c (test_for_singularity): Extracted from ...\n\n        * tree-vrp.c (test_for_singularity): Extracted from  ...\n        (simplify_cond_using_ranges): Attempt to simplify a relational\n        test to NE_EXPR.  Dump information when a COND_EXPR is simplified.\n\n        * gcc.dg/tree-ssa/vrp17.c: Update expected output.\n        * gcc.dg/tree-ssa/vrp18.c: New test.\n\nFrom-SVN: r102489", "tree": {"sha": "4f30582e4a9ca2127fb82c5f528d9bbdb9dce62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f30582e4a9ca2127fb82c5f528d9bbdb9dce62d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d579f20bb15e25f8f2038e5bd63bcab24f8df969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d579f20bb15e25f8f2038e5bd63bcab24f8df969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d579f20bb15e25f8f2038e5bd63bcab24f8df969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d579f20bb15e25f8f2038e5bd63bcab24f8df969/comments", "author": null, "committer": null, "parents": [{"sha": "3353ebf08ac8c1d5ed1162eddb327b21a119ee34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3353ebf08ac8c1d5ed1162eddb327b21a119ee34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3353ebf08ac8c1d5ed1162eddb327b21a119ee34"}], "stats": {"total": 185, "additions": 144, "deletions": 41}, "files": [{"sha": "e9f5558d23d9fc6f644e978765ed75495e6d8f32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d579f20bb15e25f8f2038e5bd63bcab24f8df969", "patch": "@@ -1,3 +1,9 @@\n+2005-07-28  Jeff Law  <law@redhat.com>\n+\n+        * tree-vrp.c (test_for_singularity): Extracted from  ...\n+        (simplify_cond_using_ranges): Attempt to simplify a relational\n+        test to NE_EXPR.  Dump information when a COND_EXPR is simplified.\n+\n 2005-07-28  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/22506"}, {"sha": "d2382f357ec98482425f6578b2cf6849929f6526", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d579f20bb15e25f8f2038e5bd63bcab24f8df969", "patch": "@@ -1,3 +1,8 @@\n+2005-07-28  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp17.c: Update expected output.\n+\t* gcc.dg/tree-ssa/vrp18.c: New test.\n+\n 2005-07-28  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/vect-reduc-1char.c: Fix data to fit in char."}, {"sha": "217929d9c03592bf640a68583d24b835f937a2c8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c?ref=d579f20bb15e25f8f2038e5bd63bcab24f8df969", "patch": "@@ -27,6 +27,6 @@ gimplify_for_stmt (tree stmt)\n     abort ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"== 3\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp\" } } */\n "}, {"sha": "366c0795dff9136708874614765254602d29992b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp18.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c?ref=d579f20bb15e25f8f2038e5bd63bcab24f8df969", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+static int blocksize = 4096;\n+\n+int bar (int);\n+\n+void foo (void)\n+{\n+  int toread;\n+  int bytes;\n+  static char eof_reached = 0;\n+\n+  toread = blocksize;\n+  bytes = 1;\n+\n+  while (toread != 0)\n+    {\n+      bytes = bar (toread);\n+      if (bytes <= 0)\n+        {\n+          if (bytes < 0)\n+            continue;\n+          break;\n+        }\n+      toread -= bytes;\n+    }\n+\n+  if (bytes == 0)\n+    eof_reached = 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "be5f8b80b86a5c9582d6975f5a5936ef31742471", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 98, "deletions": 40, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579f20bb15e25f8f2038e5bd63bcab24f8df969/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d579f20bb15e25f8f2038e5bd63bcab24f8df969", "patch": "@@ -3616,6 +3616,66 @@ simplify_abs_using_ranges (tree stmt, tree rhs)\n     }\n }\n \n+/* We are comparing trees OP0 and OP1 using COND_CODE.  OP0 has\n+   a known value range VR.\n+\n+   If there is one and only one value which will satisfy the\n+   conditional, then return that value.  Else return NULL.  */\n+\n+static tree\n+test_for_singularity (enum tree_code cond_code, tree op0,\n+\t\t      tree op1, value_range_t *vr)\n+{\n+  tree min = NULL;\n+  tree max = NULL;\n+\n+  /* Extract minimum/maximum values which satisfy the\n+     the conditional as it was written.  */\n+  if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n+    {\n+      min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n+\n+      max = op1;\n+      if (cond_code == LT_EXPR)\n+\t{\n+\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n+\t  max = fold (build (MINUS_EXPR, TREE_TYPE (op0), max, one));\n+\t}\n+    }\n+  else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n+    {\n+      max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n+\n+      min = op1;\n+      if (cond_code == GT_EXPR)\n+\t{\n+\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n+\t  max = fold (build (PLUS_EXPR, TREE_TYPE (op0), max, one));\n+\t}\n+    }\n+\n+  /* Now refine the minimum and maximum values using any\n+     value range information we have for op0.  */\n+  if (min && max)\n+    {\n+      if (compare_values (vr->min, min) == -1)\n+\tmin = min;\n+      else\n+\tmin = vr->min;\n+      if (compare_values (vr->max, max) == 1)\n+\tmax = max;\n+      else\n+\tmax = vr->max;\n+\n+      /* If the new min/max values have converged to a\n+\t single value, then there is only one value which\n+\t can satisfy the condition, return that value.  */\n+      if (min == max && is_gimple_min_invariant (min))\n+\treturn min;\n+    }\n+  return NULL;\n+}\n+\n /* Simplify a conditional using a relational operator to an equality\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n@@ -3640,58 +3700,56 @@ simplify_cond_using_ranges (tree stmt)\n \t able to simplify this conditional. */\n       if (vr->type == VR_RANGE)\n \t{\n-\t  tree min = NULL;\n-\t  tree max = NULL;\n+\t  tree new = test_for_singularity (cond_code, op0, op1, vr);\n \n-\t  /* Extract minimum/maximum values which satisfy the\n-\t     the conditional as it was written.  */\n-\t  if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n+\t  if (new)\n \t    {\n-\t      min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n-\n-\t      max = op1;\n-\t      if (cond_code == LT_EXPR)\n+\t      if (dump_file)\n \t\t{\n-\t\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n-\t\t  max = fold (build (MINUS_EXPR, TREE_TYPE (op0), max, one));\n+\t\t  fprintf (dump_file, \"Simplified relational \");\n+\t\t  print_generic_expr (dump_file, cond, 0);\n+\t\t  fprintf (dump_file, \" into \");\n \t\t}\n-\t    }\n-\t  else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n-\t    {\n-\t      max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n \n-\t      min = op1;\n-\t      if (cond_code == GT_EXPR)\n+\t      COND_EXPR_COND (stmt)\n+\t\t= build (EQ_EXPR, boolean_type_node, op0, new);\n+\t      update_stmt (stmt);\n+\n+\t      if (dump_file)\n \t\t{\n-\t\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n-\t\t  max = fold (build (PLUS_EXPR, TREE_TYPE (op0), max, one));\n+\t\t  print_generic_expr (dump_file, COND_EXPR_COND (stmt), 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n+\t      return;\n+\n \t    }\n \n-\t  /* Now refine the minimum and maximum values using any\n-\t     value range information we have for op0.  */\n-\t  if (min && max)\n+\t  /* Try again after inverting the condition.  We only deal\n+\t     with integral types here, so no need to worry about\n+\t     issues with inverting FP comparisons.  */\n+\t  cond_code = invert_tree_comparison (cond_code, false);\n+\t  new = test_for_singularity (cond_code, op0, op1, vr);\n+\n+\t  if (new)\n \t    {\n-\t      if (compare_values (vr->min, min) == -1)\n-\t\tmin = min;\n-\t      else\n-\t\tmin = vr->min;\n-\t      if (compare_values (vr->max, max) == 1)\n-\t\tmax = max;\n-\t      else\n-\t\tmax = vr->max;\n-\n-\t      /* If the new min/max values have converged to a\n-\t\t single value, then there is only one value which\n-\t\t can satisfy the condition.  Rewrite the condition\n-\t\t to test for equality.  */\n-\t      if (min == max\n-\t\t  && is_gimple_min_invariant (min))\n+\t      if (dump_file)\n \t\t{\n-\t\t  COND_EXPR_COND (stmt)\n-\t\t    = build (EQ_EXPR, boolean_type_node, op0, min);\n-\t\t  update_stmt (stmt);\n+\t\t  fprintf (dump_file, \"Simplified relational \");\n+\t\t  print_generic_expr (dump_file, cond, 0);\n+\t\t  fprintf (dump_file, \" into \");\n \t\t}\n+\n+\t      COND_EXPR_COND (stmt)\n+\t\t= build (NE_EXPR, boolean_type_node, op0, new);\n+\t      update_stmt (stmt);\n+\n+\t      if (dump_file)\n+\t\t{\n+\t\t  print_generic_expr (dump_file, COND_EXPR_COND (stmt), 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return;\n+\n \t    }\n \t}\n     }"}]}