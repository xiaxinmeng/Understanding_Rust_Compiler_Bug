{"sha": "997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3ZTVhZjgyODlkYTI4YTIyYTBkNGE4YWFmY2RhOWI4M2I4OWJkMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-07-17T08:55:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-17T08:55:51Z"}, "message": "h8300.c (two_insn_adds_subs_operand): Improve code for detecting profitable adds/subs sequences.\n\n        * h8300.c (two_insn_adds_subs_operand): Improve code for detecting\n        profitable adds/subs sequences.\n\nFrom-SVN: r35081", "tree": {"sha": "c556a271670640935ae2ffd8815f447da0bec9d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c556a271670640935ae2ffd8815f447da0bec9d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997e5af8289da28a22a0d4a8aafcda9b83b89bd1/comments", "author": null, "committer": null, "parents": [{"sha": "3b15076f3646f5421c5476264b2534182553e8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b15076f3646f5421c5476264b2534182553e8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b15076f3646f5421c5476264b2534182553e8aa"}], "stats": {"total": 36, "additions": 30, "deletions": 6}, "files": [{"sha": "1e3ac965b9b771f042f96b4402b1697c1d085b82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997e5af8289da28a22a0d4a8aafcda9b83b89bd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997e5af8289da28a22a0d4a8aafcda9b83b89bd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "patch": "@@ -29,6 +29,9 @@ Mon Jul 17 02:37:06 2000  Marc Espie <espie@openbsd.org>\n \n 2000-07-17  Kazu Hirata  <kazu@hxi.com>\n \n+\t* h8300.c (two_insn_adds_subs_operand): Improve code for detecting\n+\tprofitable adds/subs sequences.\n+\n \t* fold-const.c: Fix comment typos.\n \n 2000-07-16  Laurynas Biveinis  <lauras@softhome.net>"}, {"sha": "ba46d04584e66e610ebda18a87589626ca5872de", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997e5af8289da28a22a0d4a8aafcda9b83b89bd1/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997e5af8289da28a22a0d4a8aafcda9b83b89bd1/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=997e5af8289da28a22a0d4a8aafcda9b83b89bd1", "patch": "@@ -626,25 +626,46 @@ call_insn_operand (op, mode)\n   return 0;\n }\n \n+/* Return 1 if a addition/subtraction of a constant integer can be\n+   transformed into two consecutive adds/subs that are faster than the\n+   straightforward way.  Otherwise, return 0. */\n+\n int\n two_insn_adds_subs_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n       HOST_WIDE_INT value = INTVAL (op);\n \n+      /* Force VALUE to be positive so that we do not have to consider\n+         the negative case.  */\n+      if (value < 0)\n+\tvalue = -value;\n       if (TARGET_H8300H || TARGET_H8300S)\n \t{\n-\t  if (value >= -8 && value < -4 && value != -7)\n-\t    return 1;\n-\t  if (value > 4 && value <= 8 && value != 7)\n-\t    return 1;\n+\t  /* A constant addition/subtraction takes 2 states in QImode,\n+\t     4 states in HImode, and 6 states in SImode.  Thus, the\n+\t     only case we can win is when SImode is used, in which\n+\t     case, two adds/subs is used, taking 4 states.  */\n+\t  if (mode == SImode\n+\t      && (value == 2 + 1\n+\t\t  || value == 4 + 1\n+\t\t  || value == 4 + 2\n+\t\t  || value == 4 + 4))\n+\t      return 1;\n \t}\n       else\n \t{\n-\t  if (value == -4 || value == -3 || value == 3 || value == 4)\n+\t  /* A constant addition/subtraction takes 2 states in\n+\t     QImode. It takes 6 states in HImode, requiring the\n+\t     constant to be loaded to a register first, and a lot more\n+\t     in SImode.  Thus the only case we can win is when either\n+\t     HImode or SImode is used.  */\n+\t  if (mode != QImode\n+\t      && (value == 2 + 1\n+\t\t  || value == 2 + 2))\n \t    return 1;\n \t}\n     }"}]}