{"sha": "d5029d45940e8c12b425b4d1a23081b4155caa61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwMjlkNDU5NDBlOGMxMmI0MjViNGQxYTIzMDgxYjQxNTVjYWE2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-18T11:56:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-18T11:56:26Z"}, "message": "Fix up duplicated duplicated words in comments\n\nAnother set of duplicated word fixes for things I've missed last time.\nThese include e.g. *.cc files I forgot about, or duplicated words at the start\nor end of line.\n\n2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n\n\t* asan.c (get_mem_refs_of_builtin_call): Fix up duplicated word issue\n\tin a comment.\n\t* config/arc/arc.c (frame_stack_add): Likewise.\n\t* gimple-loop-versioning.cc (loop_versioning::analyze_arbitrary_term):\n\tLikewise.\n\t* ipa-predicate.c (predicate::remap_after_inlining): Likewise.\n\t* tree-ssa-strlen.h (handle_printf_call): Likewise.\n\t* tree-ssa-strlen.c (is_strlen_related_p): Likewise.\n\t* optinfo-emit-json.cc (optrecord_json_writer::add_record): Likewise.\nanalyzer/\n\t* sm-malloc.cc (malloc_state_machine::on_stmt): Fix up duplicated word\n\tissue in a comment.\n\t* region-model.cc (region_model::make_region_for_unexpected_tree_code,\n\tregion_model::delete_region_and_descendents): Likewise.\n\t* engine.cc (class exploded_cluster): Likewise.\n\t* diagnostic-manager.cc (class path_builder): Likewise.\ncp/\n\t* constraint.cc (resolve_function_concept_check, subsumes_constraints,\n\tstrictly_subsumes): Fix up duplicated word issue in a comment.\n\t* coroutines.cc (build_init_or_final_await, captures_temporary):\n\tLikewise.\n\t* logic.cc (dnf_size_r, cnf_size_r): Likewise.\n\t* pt.c (append_type_to_template_for_access_check): Likewise.\nd/\n\t* expr.cc (ExprVisitor::visit (CatAssignExp *)): Fix up duplicated\n\tword issue in a comment.\n\t* d-target.cc (Target::FPTypeProperties<T>::max): Likewise.\nfortran/\n\t* class.c (generate_finalization_wrapper): Fix up duplicated word\n\tissue in a comment.\n\t* trans-types.c (gfc_get_nodesc_array_type): Likewise.", "tree": {"sha": "e04a027c2ab748c3ac851b7a6dcbadb4863a5c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04a027c2ab748c3ac851b7a6dcbadb4863a5c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5029d45940e8c12b425b4d1a23081b4155caa61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5029d45940e8c12b425b4d1a23081b4155caa61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5029d45940e8c12b425b4d1a23081b4155caa61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5029d45940e8c12b425b4d1a23081b4155caa61/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d91480dee934478063fe5945b73ff3c108e40a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91480dee934478063fe5945b73ff3c108e40a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91480dee934478063fe5945b73ff3c108e40a91"}], "stats": {"total": 92, "additions": 66, "deletions": 26}, "files": [{"sha": "283ad1dde8542c0b69b859c4f71ca4485e1cedb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1,3 +1,15 @@\n+2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* asan.c (get_mem_refs_of_builtin_call): Fix up duplicated word issue\n+\tin a comment.\n+\t* config/arc/arc.c (frame_stack_add): Likewise.\n+\t* gimple-loop-versioning.cc (loop_versioning::analyze_arbitrary_term):\n+\tLikewise.\n+\t* ipa-predicate.c (predicate::remap_after_inlining): Likewise.\n+\t* tree-ssa-strlen.h (handle_printf_call): Likewise.\n+\t* tree-ssa-strlen.c (is_strlen_related_p): Likewise.\n+\t* optinfo-emit-json.cc (optrecord_json_writer::add_record): Likewise.\n+\n 2020-03-18  Duan bo  <duanbo3@huawei.com>\n \n \tPR target/94201"}, {"sha": "a5c8b27c522ded9202b5c27afa11ac861cd4d747", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1,3 +1,12 @@\n+2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* sm-malloc.cc (malloc_state_machine::on_stmt): Fix up duplicated word\n+\tissue in a comment.\n+\t* region-model.cc (region_model::make_region_for_unexpected_tree_code,\n+\tregion_model::delete_region_and_descendents): Likewise.\n+\t* engine.cc (class exploded_cluster): Likewise.\n+\t* diagnostic-manager.cc (class path_builder): Likewise.\n+\n 2020-03-13  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/94099"}, {"sha": "9bd018a3aac7d59e92ad0c5da63ab40b0fb4177c", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -110,7 +110,7 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n \n /* State for building a checker_path from a particular exploded_path.\n    In particular, this precomputes reachability information: the set of\n-   source enodes for which a a path be found to the diagnostic enode.  */\n+   source enodes for which a path be found to the diagnostic enode.  */\n \n class path_builder\n {"}, {"sha": "a8037c6a3c7e9593d515b02646310e934d839502", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -2988,7 +2988,7 @@ exploded_path::dump () const\n    cluster, each supernode gets its own cluster.\n \n    Hence all enodes relating to a particular function with a particular\n-   callstring will be be in a cluster together; all enodes for the same\n+   callstring will be in a cluster together; all enodes for the same\n    function but with a different callstring will be in a different\n    cluster.  */\n "}, {"sha": "9cc6560ee72144719fa95b6238593ac49ae3bb3b", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -4871,7 +4871,7 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n     }\n }\n \n-/* If we see a tree code we we don't know how to handle, rather than\n+/* If we see a tree code we don't know how to handle, rather than\n    ICE or generate bogus results, create a dummy region, and notify\n    CTXT so that it can mark the new state as being not properly\n    modelled.  The exploded graph can then stop exploring that path,\n@@ -6607,7 +6607,7 @@ region_model::get_descendents (region_id rid, region_id_set *out,\n }\n \n /* Delete RID and all descendent regions.\n-   Find any pointers to such regions; convert convert them to\n+   Find any pointers to such regions; convert them to\n    poisoned values of kind PKIND.\n    Accumulate stats on purged entities into STATS.  */\n "}, {"sha": "38a2f1eea0c0c2b3c620919f92ae815ce9374749", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -655,7 +655,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    sm_ctxt->on_transition (node, stmt, arg, m_nonnull, m_freed);\n \n \t    /* Keep state \"null\" as-is, rather than transitioning to \"free\";\n-\t       we don't want want to complain about double-free of NULL.  */\n+\t       we don't want to complain about double-free of NULL.  */\n \n \t    /* freed -> stop, with warning.  */\n \t    sm_ctxt->warn_for_state (node, stmt, arg, m_freed,"}, {"sha": "cc8f9122e3d24eb8238612310ee6a50ee98c16e7", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -795,7 +795,7 @@ get_mem_refs_of_builtin_call (gcall *call,\n       handle_builtin_alloca (call, iter);\n       break;\n     /* And now the __atomic* and __sync builtins.\n-       These are handled differently from the classical memory memory\n+       These are handled differently from the classical memory\n        access builtins above.  */\n \n     case BUILT_IN_ATOMIC_LOAD_1:"}, {"sha": "922ccc5c9f970280090c778926970af96adb3f05", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -2607,7 +2607,7 @@ frame_stack_add (HOST_WIDE_INT offset)\n    register.\n \n    During compilation of a function the frame size is evaluated\n-   multiple times, it is not until the reload pass is complete the the\n+   multiple times, it is not until the reload pass is complete the\n    frame size is considered fixed (it is at this point that space for\n    all spills has been allocated).  However the frame_pointer_needed\n    variable is not set true until the register allocation pass, as a"}, {"sha": "938504b9c59f0fb0f28559b378cc00d8c41cfd71", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1,5 +1,12 @@\n 2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* constraint.cc (resolve_function_concept_check, subsumes_constraints,\n+\tstrictly_subsumes): Fix up duplicated word issue in a comment.\n+\t* coroutines.cc (build_init_or_final_await, captures_temporary):\n+\tLikewise.\n+\t* logic.cc (dnf_size_r, cnf_size_r): Likewise.\n+\t* pt.c (append_type_to_template_for_access_check): Likewise.\n+\n \tPR c++/91759\n \t* decl.c (grokfndecl): Restore old diagnostics about deduction\n \tguide declared in different scope if in_namespace is NULL_TREE."}, {"sha": "5e434be815f70eab34076ed92ac89ea533570256", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -316,7 +316,7 @@ resolve_function_concept_overload (tree ovl, tree args)\n   return cands;\n }\n \n-/* Determine if the the call expression CALL is a constraint check, and\n+/* Determine if the call expression CALL is a constraint check, and\n    return the concept declaration and arguments being checked. If CALL\n    does not denote a constraint check, return NULL.  */\n \n@@ -2958,7 +2958,7 @@ equivalently_constrained (tree d1, tree d2)\n                      Partial ordering of constraints\n ---------------------------------------------------------------------------*/\n \n-/* Returns true when the the constraints in A subsume those in B.  */\n+/* Returns true when the constraints in A subsume those in B.  */\n \n bool\n subsumes_constraints (tree a, tree b)\n@@ -2968,7 +2968,7 @@ subsumes_constraints (tree a, tree b)\n   return subsumes (a, b);\n }\n \n-/* Returns true when the the constraints in CI (with arguments\n+/* Returns true when the constraints in CI (with arguments\n    ARGS) strictly subsume the associated constraints of TMPL.  */\n \n bool"}, {"sha": "a943ba01de6363eafb2ecea662c69a9c00bf236d", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -2466,7 +2466,7 @@ build_init_or_final_await (location_t loc, bool is_final)\n     return error_mark_node;\n \n   /* So build the co_await for this */\n-  /* For initial/final suspends the call is is \"a\" per [expr.await] 3.2.  */\n+  /* For initial/final suspends the call is \"a\" per [expr.await] 3.2.  */\n   return build_co_await (loc, setup_call, (is_final ? FINAL_SUSPEND_POINT\n \t\t\t\t\t\t    : INITIAL_SUSPEND_POINT));\n }\n@@ -2547,7 +2547,7 @@ static tree\n captures_temporary (tree *stmt, int *do_subtree, void *d)\n {\n   /* Stop recursing if we see an await expression, the subtrees\n-     of that will be handled when it it processed.  */\n+     of that will be handled when it is processed.  */\n   if (TREE_CODE (*stmt) == CO_AWAIT_EXPR || TREE_CODE (*stmt) == CO_YIELD_EXPR)\n     {\n       *do_subtree = 0;"}, {"sha": "194b743192d478a3323bbc27f08f44f635d080f9", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -355,7 +355,7 @@ atomic_p (tree t)\n \n /* Recursively count the number of clauses produced when converting T\n    to DNF. Returns a pair containing the number of clauses and a bool\n-   value signifying that the the tree would be rewritten as a result of\n+   value signifying that the tree would be rewritten as a result of\n    distributing. In general, a conjunction for which this flag is set\n    is considered a disjunction for the purpose of counting.  */\n \n@@ -421,7 +421,7 @@ dnf_size_r (tree t)\n       /* Matches constraints of the form P /\\ Q, possibly resulting\n          in the distribution of one side over the other. When both\n          P and Q are disjunctions, the number of clauses are multiplied.\n-         When only one of P and Q is a disjunction, the the number of\n+\t When only one of P and Q is a disjunction, the number of\n          clauses are added. Otherwise, neither side is a disjunction and\n          no clauses are created.  */\n       if (disjunction_p (lhs))\n@@ -463,7 +463,7 @@ dnf_size_r (tree t)\n \n /* Recursively count the number of clauses produced when converting T\n    to CNF. Returns a pair containing the number of clauses and a bool\n-   value signifying that the the tree would be rewritten as a result of\n+   value signifying that the tree would be rewritten as a result of\n    distributing. In general, a disjunction for which this flag is set\n    is considered a conjunction for the purpose of counting.  */\n \n@@ -488,7 +488,7 @@ cnf_size_r (tree t)\n       /* Matches constraints of the form P \\/ Q, possibly resulting\n          in the distribution of one side over the other. When both\n          P and Q are conjunctions, the number of clauses are multiplied.\n-         When only one of P and Q is a conjunction, the the number of\n+\t When only one of P and Q is a conjunction, the number of\n          clauses are added. Otherwise, neither side is a conjunction and\n          no clauses are created.  */\n       if (disjunction_p (lhs))"}, {"sha": "03a8dfbd37cac2cceae2b754ce7e8816b1bac896", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -29078,7 +29078,7 @@ append_type_to_template_for_access_check_1 (tree t,\n }\n \n /* Append TYPE_DECL to the template TEMPL.\n-   TEMPL is either a class type, a FUNCTION_DECL or a a TEMPLATE_DECL.\n+   TEMPL is either a class type, a FUNCTION_DECL or a TEMPLATE_DECL.\n    At TEMPL instanciation time, TYPE_DECL will be checked to see\n    if it can be accessed through SCOPE.\n    LOCATION is the location of the usage point of TYPE_DECL."}, {"sha": "32856f17504631c587d6cd0c8c38f4ca8264500f", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1,3 +1,9 @@\n+2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* expr.cc (ExprVisitor::visit (CatAssignExp *)): Fix up duplicated\n+\tword issue in a comment.\n+\t* d-target.cc (Target::FPTypeProperties<T>::max): Likewise.\n+\n 2020-03-16  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \tPR d/92309"}, {"sha": "7e11bd64abb3ea7f73fb643d2a4b30e71241abd6", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -53,7 +53,7 @@ bool Target::cppExceptions;\n int Target::classinfosize;\n unsigned long long Target::maxStaticDataSize;\n \n-/* Floating-point constants for for .max, .min, and other properties.  */\n+/* Floating-point constants for .max, .min, and other properties.  */\n template <typename T> real_t Target::FPTypeProperties<T>::max;\n template <typename T> real_t Target::FPTypeProperties<T>::min_normal;\n template <typename T> real_t Target::FPTypeProperties<T>::nan;"}, {"sha": "fcf9bc5880af60892d4bac1b0c0ed80425cc816f", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -836,7 +836,7 @@ class ExprVisitor : public Visitor\n   }\n \n   /* Build a concat assignment expression.  The right operand is appended\n-     to the the left operand.  */\n+     to the left operand.  */\n \n   void visit (CatAssignExp *e)\n   {"}, {"sha": "db79f05d73f8878e82cbe9e03286e956633d44e8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1,3 +1,9 @@\n+2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* class.c (generate_finalization_wrapper): Fix up duplicated word\n+\tissue in a comment.\n+\t* trans-types.c (gfc_get_nodesc_array_type): Likewise.\n+\n 2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* array.c (gfc_check_iter_variable): Fix up duplicated word issue"}, {"sha": "9aa3eb7282c42d5bbea58243093098e1b6553f69", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1574,7 +1574,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n     }\n \n   /* No wrapper of the ancestor and no own FINAL subroutines and allocatable\n-     components: Return a NULL() expression; we defer this a bit to have have\n+     components: Return a NULL() expression; we defer this a bit to have\n      an interface declaration.  */\n   if ((!ancestor_wrapper || ancestor_wrapper->expr_type == EXPR_NULL)\n       && !derived->attr.alloc_comp"}, {"sha": "b7712dc74d167d1e35506c44fb0fdfb67ef1286e", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1595,7 +1595,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n   mpz_init_set_ui (stride, 1);\n   mpz_init (delta);\n \n-  /* We don't use build_array_type because this does not include include\n+  /* We don't use build_array_type because this does not include\n      lang-specific information (i.e. the bounds of the array) when checking\n      for duplicates.  */\n   if (as->rank)"}, {"sha": "ff6c561f9e2b43089ebc8807474572a315a0de1b", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -1070,7 +1070,7 @@ loop_versioning::analyze_arbitrary_term (address_info &address,\n \n      where nothing in the way \"x\" and \"y\" are set gives a hint as to\n      whether \"i\" iterates over the innermost dimension of the array.\n-     In these situations it seems reasonable to assume the the\n+     In these situations it seems reasonable to assume the\n      programmer has nested the loops appropriately (although of course\n      there are examples like GEMM in which this assumption doesn't hold\n      for all accesses in the loop)."}, {"sha": "27dabf2dc6ae9a647e9b95f6ceaba86bb919a544", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -497,7 +497,7 @@ predicate::remap_after_duplication (clause_t possible_truths)\n    is summary of function predicate P is from. OPERAND_MAP is array giving\n    callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clause of all\n    callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n-   predicate under which callee is executed.  OFFSET_MAP is an array of of\n+   predicate under which callee is executed.  OFFSET_MAP is an array of\n    offsets that need to be added to conditions, negative offset means that\n    conditions relying on values passed by reference have to be discarded\n    because they might not be preserved (and should be considered offset zero"}, {"sha": "6765c7d82ad497807547a6c6132c8533afdad7ca", "filename": "gcc/optinfo-emit-json.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -153,7 +153,7 @@ optrecord_json_writer::add_record (const optinfo *optinfo)\n \n /* Private methods of optrecord_json_writer.  */\n \n-/* Add record OBJ to the the innermost scope.  */\n+/* Add record OBJ to the innermost scope.  */\n \n void\n optrecord_json_writer::add_record (json::object *obj)"}, {"sha": "6dd37fb0b785b6b1616ef04cf771de58a4b6dc23", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -2911,7 +2911,7 @@ handle_builtin_strncat (built_in_function, gimple_stmt_iterator *gsi)\n \n /* Return true if LEN depends on a call to strlen(SRC) in an interesting\n    way.  LEN can either be an integer expression, or a pointer (to char).\n-   When it is the latter (such as in recursive calls to self) is is\n+   When it is the latter (such as in recursive calls to self) it is\n    assumed to be the argument in some call to strlen() whose relationship\n    to SRC is being ascertained.  */\n "}, {"sha": "a11c4d579a1747fa9d16316c1bf21c6660042e5d", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5029d45940e8c12b425b4d1a23081b4155caa61/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=d5029d45940e8c12b425b4d1a23081b4155caa61", "patch": "@@ -31,7 +31,7 @@ extern tree get_range (tree, wide_int[2], const vr_values * = NULL);\n struct c_strlen_data;\n extern void get_range_strlen_dynamic (tree , c_strlen_data *, const vr_values *);\n \n-/* APIs internal to strlen pass.  Defined in in gimple-ssa-sprintf.c.  */\n+/* APIs internal to strlen pass.  Defined in gimple-ssa-sprintf.c.  */\n extern bool handle_printf_call (gimple_stmt_iterator *,  const vr_values *);\n \n #endif   // GCC_TREE_SSA_STRLEN_H"}]}