{"sha": "d35364d13e14ba0eea541a77484c716f1cf82195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1MzY0ZDEzZTE0YmEwZWVhNTQxYTc3NDg0YzcxNmYxY2Y4MjE5NQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-12T23:46:05Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-12T23:46:05Z"}, "message": "Convert cpplib to use libiberty/hashtab.c.\n\n\t* cpplib.h (struct cpp_reader): Make hashtab and\n\tall_include_files of type 'struct htab *'.  Delete HASHSIZE\n\tand ALL_INCLUDE_HASHSIZE macros.\n\n\t* cpphash.h: Update prototypes.\n\t(struct hashnode): Remove next, prev, and bucket_hdr members.\n\tMake length a size_t.  Add hash member.\n\t(struct ihash): Remove next member.  Add hash member.  Make\n\tname a flexible array member.\n\n\t* cppfiles.c: Include hashtab.h.\n\t(include_hash): Delete.\n\t(IHASHSIZE): New macro.\n\t(hash_IHASH, eq_IHASH, _cpp_init_include_hash): New functions.\n\t(cpp_included): Do the hash lookup here.\n\t(_cpp_find_include_file): Rewrite.\n\t(cpp_read_file): Put the \"fake\" hash entry into the hash\n\ttable.  Honor the control_macro, if it turns out we've seen\n\tthe file before.  Don't push the buffer here.\n\t(_cpp_read_include_file): Push the buffer here.\n\t(OMODES): New macro.  Use it whenever we call open(2).\n\n\t* cpphash.c: Include hashtab.h.\n\t(hash_HASHNODE, eq_HASHNODE, del_HASHNODE, dump_hash_helper,\n\t_cpp_init_macro_hash, _cpp_dump_macro_hash, _cpp_make_hashnode,\n\t_cpp_lookup_slot): New functions.\n\t(HASHSIZE): new macro.\n\t(hashf, _cpp_install, _cpp_delete_macro): Delete.\n\t(_cpp_lookup): Use hashtab.h routines.\n\n\t* cppinit.c: Include hashtab.h.\n\t(cpp_reader_init): Call _cpp_init_macro_hash and\n\t_cpp_init_include_hash.  Don't allocate hashtab directly.\n\t(cpp_cleanup): Just call htab_delete on pfile->hashtab and\n\tpfile->all_include_files.\n\t(initialize_builtins): Use _cpp_make_hashnode and\n\thtab_find_slot to add hash entries.\n\t(cpp_finish): Just call _cpp_dump_macro_hash.\n\t* cpplib.c: Include hashtab.h.\n\t(do_define): Use _cpp_lookup_slot and _cpp_make_hashnode to\n\tcreate hash entries.\n\t(do_pragma_poison, do_assert): Likewise.\n\t(do_include): Don't push the buffer here.  Don't increment\n\tsystem_include_depth unless _cpp_read_include_file succeeds.\n\t(do_undef, do_unassert): Use _cpp_lookup_slot and htab_clear_slot\n\tor htab_remove_elt.\n\t(do_pragma_implementation): Use alloca to create copy.\n\n\t* Makefile.in: Update dependencies.\n\nFrom-SVN: r32497", "tree": {"sha": "a98d122ee7a482f328ecd041626122a0cd1beaa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a98d122ee7a482f328ecd041626122a0cd1beaa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d35364d13e14ba0eea541a77484c716f1cf82195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35364d13e14ba0eea541a77484c716f1cf82195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d35364d13e14ba0eea541a77484c716f1cf82195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35364d13e14ba0eea541a77484c716f1cf82195/comments", "author": null, "committer": null, "parents": [{"sha": "6973bf5482d8a5a150c3ee1424bf7e154e61dd51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6973bf5482d8a5a150c3ee1424bf7e154e61dd51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6973bf5482d8a5a150c3ee1424bf7e154e61dd51"}], "stats": {"total": 846, "additions": 454, "deletions": 392}, "files": [{"sha": "0851930f08f9f3678eadfe199df367037a622e43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -1,3 +1,57 @@\n+2000-03-12  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\tConvert cpplib to use libiberty/hashtab.c.\n+\n+\t* cpplib.h (struct cpp_reader): Make hashtab and\n+\tall_include_files of type 'struct htab *'.  Delete HASHSIZE\n+\tand ALL_INCLUDE_HASHSIZE macros.\n+\n+\t* cpphash.h: Update prototypes.\n+\t(struct hashnode): Remove next, prev, and bucket_hdr members.\n+\tMake length a size_t.  Add hash member.\n+\t(struct ihash): Remove next member.  Add hash member.  Make\n+\tname a flexible array member.\n+\n+\t* cppfiles.c: Include hashtab.h.\n+\t(include_hash): Delete.\n+\t(IHASHSIZE): New macro.\n+\t(hash_IHASH, eq_IHASH, _cpp_init_include_hash): New functions.\n+\t(cpp_included): Do the hash lookup here.\n+\t(_cpp_find_include_file): Rewrite.\n+\t(cpp_read_file): Put the \"fake\" hash entry into the hash\n+\ttable.  Honor the control_macro, if it turns out we've seen\n+\tthe file before.  Don't push the buffer here.\n+\t(_cpp_read_include_file): Push the buffer here.\n+\t(OMODES): New macro.  Use it whenever we call open(2).\n+\n+\t* cpphash.c: Include hashtab.h.\n+\t(hash_HASHNODE, eq_HASHNODE, del_HASHNODE, dump_hash_helper,\n+\t_cpp_init_macro_hash, _cpp_dump_macro_hash, _cpp_make_hashnode,\n+\t_cpp_lookup_slot): New functions.\n+\t(HASHSIZE): new macro.\n+\t(hashf, _cpp_install, _cpp_delete_macro): Delete.\n+\t(_cpp_lookup): Use hashtab.h routines.\n+\n+\t* cppinit.c: Include hashtab.h.\n+\t(cpp_reader_init): Call _cpp_init_macro_hash and\n+\t_cpp_init_include_hash.  Don't allocate hashtab directly.\n+\t(cpp_cleanup): Just call htab_delete on pfile->hashtab and\n+\tpfile->all_include_files.\n+\t(initialize_builtins): Use _cpp_make_hashnode and\n+\thtab_find_slot to add hash entries.\n+\t(cpp_finish): Just call _cpp_dump_macro_hash.\n+\t* cpplib.c: Include hashtab.h.\n+\t(do_define): Use _cpp_lookup_slot and _cpp_make_hashnode to\n+\tcreate hash entries.\n+\t(do_pragma_poison, do_assert): Likewise.\n+\t(do_include): Don't push the buffer here.  Don't increment\n+\tsystem_include_depth unless _cpp_read_include_file succeeds.\n+\t(do_undef, do_unassert): Use _cpp_lookup_slot and htab_clear_slot\n+\tor htab_remove_elt.\n+\t(do_pragma_implementation): Use alloca to create copy.\n+\n+\t* Makefile.in: Update dependencies.\n+\n 2000-03-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cppinit.c (cl_directive_handler): More K&R fixing."}, {"sha": "964a589a9523521f9fdade274912d2e2bc9b939a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -2029,6 +2029,7 @@ LIBCPP_OBJS =\tcpplib.o cpphash.o cpperror.o cppexp.o cppfiles.o \\\n \t\tprefix.o version.o mbchar.o @extra_cpp_objs@\n \n LIBCPP_DEPS = cpplib.h cpphash.h intl.h system.h\n+HASHTAB_H   = $(srcdir)/../include/hashtab.h\n \n # All the other archives built/used by this makefile are for targets.  This\n # one is strictly for the host.\n@@ -2042,17 +2043,17 @@ cppmain$(exeext): cppmain.o intl.o libcpp.a $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cppmain$(exeext) cppmain.o \\\n \tintl.o libcpp.a $(LIBS)\n \n-cppmain.o: cppmain.c $(CONFIG_H) cpplib.h intl.h system.h\n+cppmain.o:  cppmain.c  $(CONFIG_H) cpplib.h intl.h system.h\n \n-cppulp.o:  cppulp.c  $(CONFIG_H) system.h output.h\n-cpplib.o:  cpplib.c  $(CONFIG_H) $(LIBCPP_DEPS) mkdeps.h\n-cpphash.o: cpphash.c $(CONFIG_H) $(LIBCPP_DEPS) version.h\n+cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS)\n+cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n+cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) version.h\n+cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h\n \n-cppinit.o:  cppinit.c $(CONFIG_H) cpplib.h intl.h system.h \\\n-\t\tcpphash.h prefix.h output.h Makefile version.h mkdeps.h\n+cppinit.o:  cppinit.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h \\\n+\t\tprefix.h output.h Makefile version.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  $(PREPROCESSOR_DEFINES) \\\n \t  -c `echo $(srcdir)/cppinit.c | sed 's,^\\./,,'`"}, {"sha": "3354663309d6147be1c37c183045260509497c4a", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 153, "deletions": 167, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -28,9 +28,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n+#include \"hashtab.h\"\n #include \"intl.h\"\n \n-static IHASH *include_hash\tPARAMS ((cpp_reader *, const char *, int));\n static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n \t\t\t\t\t   struct file_name_list *));\n static struct file_name_map *read_name_map\n@@ -42,6 +42,10 @@ static long read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n \t\t\t\t\t int, size_t));\n static struct file_name_list *actual_directory\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n+\n+static unsigned int hash_IHASH\tPARAMS ((const void *));\n+static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n+\n static void init_input_buffer\tPARAMS ((cpp_reader *, int, struct stat *));\n static int file_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n@@ -50,50 +54,57 @@ static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n static void hack_vms_include_specification PARAMS ((char *));\n #endif\n \n+/* Initial size of include hash table.  */\n+#define IHASHSIZE 50\n+\n #ifndef INCLUDE_LEN_FUDGE\n #define INCLUDE_LEN_FUDGE 0\n #endif\n \n-/* Look up or add an entry to the table of all includes.  This table\n- is indexed by the name as it appears in the #include line.  The\n- ->next_this_file chain stores all different files with the same\n- #include name (there are at least three ways this can happen).  The\n- hash function could probably be improved a bit. */\n-\n-static IHASH *\n-include_hash (pfile, fname, add)\n-     cpp_reader *pfile;\n-     const char *fname;\n-     int add;\n+/* Open files in nonblocking mode, so we don't get stuck if someone\n+   clever has asked cpp to process /dev/rmt0.  _cpp_read_include_file\n+   will check that we have a real file to work with.  Also take care\n+   not to acquire a controlling terminal by mistake (this can't happen\n+   on sane systems, but paranoia is a virtue).  */\n+#define OMODES O_RDONLY|O_NONBLOCK|O_NOCTTY\n+\n+/* Calculate hash of an IHASH entry.  */\n+static unsigned int\n+hash_IHASH (x)\n+     const void *x;\n {\n-  unsigned int hash = 0;\n-  IHASH *l, *m;\n-  const char *f = fname;\n-\n-  while (*f)\n-    hash += *f++;\n+  IHASH *i = (IHASH *)x;\n+  unsigned int r = 0, len = 0;\n+  const U_CHAR *s = i->nshort;\n+\n+  if (i->hash != (unsigned long)-1)\n+    return i->hash;\n+\n+  do\n+    len++, r = r * 67 + (*s++ - 113);\n+  while (*s && *s != '.');\n+  i->hash = r + len;\n+  return r + len;\n+}\n \n-  l = pfile->all_include_files[hash % ALL_INCLUDE_HASHSIZE];\n-  m = 0;\n-  for (; l; m = l, l = l->next)\n-    if (!strcmp (l->nshort, fname))\n-      return l;\n+/* Compare an existing IHASH structure with a potential one.  */\n+static int\n+eq_IHASH (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  const U_CHAR *a = ((const IHASH *)x)->nshort;\n+  const U_CHAR *b = ((const IHASH *)y)->nshort;\n+  return !strcmp (a, b);\n+}\n \n-  if (!add)\n-    return 0;\n-  \n-  l = (IHASH *) xmalloc (sizeof (IHASH));\n-  l->next = NULL;\n-  l->next_this_file = NULL;\n-  l->foundhere = NULL;\n-  l->buf = NULL;\n-  l->limit = NULL;\n-  if (m)\n-    m->next = l;\n-  else\n-    pfile->all_include_files[hash % ALL_INCLUDE_HASHSIZE] = l;\n-  \n-  return l;\n+/* Init the hash table.  In here so it can see the hash and eq functions.  */\n+void\n+_cpp_init_include_hash (pfile)\n+     cpp_reader *pfile;\n+{\n+  pfile->all_include_files\n+    = htab_create (IHASHSIZE, hash_IHASH, eq_IHASH, free);\n }\n \n /* Return 0 if the file pointed to by IHASH has never been included before,\n@@ -152,9 +163,10 @@ cpp_included (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  IHASH *ptr;\n-\n-  ptr = include_hash (pfile, fname, 0);\n+  IHASH dummy, *ptr;\n+  dummy.nshort = fname;\n+  dummy.hash = -1;\n+  ptr = htab_find (pfile->all_include_files, (const void *)&dummy);\n   return (ptr != NULL);\n }\n \n@@ -164,10 +176,7 @@ file_cleanup (pbuf, pfile)\n      cpp_reader *pfile;\n {\n   if (pbuf->buf)\n-    {\n-      free ((PTR) pbuf->buf);\n-      pbuf->buf = 0;\n-    }\n+    free ((PTR) pbuf->buf);\n   if (pfile->system_include_depth)\n     pfile->system_include_depth--;\n   return 0;\n@@ -178,7 +187,7 @@ file_cleanup (pbuf, pfile)\n    (because it was included already and it's marked idempotent),\n    -1 if an error occurred, or a file descriptor open on the file.\n    *IHASH is set to point to the include hash entry for this file, and\n-   *BEFORE is 1 if the file was included before (but needs to be read\n+   *BEFORE is set to 1 if the file was included before (but needs to be read\n    again). */\n int\n _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n@@ -188,97 +197,82 @@ _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n      IHASH **ihash;\n      int *before;\n {\n-  struct file_name_list *l;\n-  IHASH *ih, *jh;\n-  int f, len;\n+  struct file_name_list *path;\n+  IHASH *ih, **slot;\n+  IHASH dummy;\n+  int f;\n   char *name;\n-  \n-  ih = include_hash (pfile, fname, 1);\n-  jh = redundant_include_p (pfile, ih,\n-\t\t\t    fname[0] == '/' ? ABSOLUTE_PATH : search_start);\n-\n-  if (jh != 0)\n-    {\n-      *before = 1;\n-      *ihash = jh;\n \n-      if (jh == (IHASH *)-1)\n-\treturn -2;\n-      else\n-\treturn open (jh->name, O_RDONLY, 0666);\n-    }\n+  dummy.hash = -1;\n+  dummy.nshort = fname;\n+  path = (fname[0] == '/') ? ABSOLUTE_PATH : search_start;\n+  slot = (IHASH **) htab_find_slot (pfile->all_include_files,\n+\t\t\t\t    (const void *)&dummy, 1);\n \n-  if (ih->foundhere)\n-    /* A file is already known by this name, but it's not the same file.\n-       Allocate another include_hash block and add it to the next_this_file\n-       chain. */\n+  if (*slot && (ih = redundant_include_p (pfile, *slot, path)))\n     {\n-      jh = (IHASH *) xmalloc (sizeof (IHASH));\n-      while (ih->next_this_file) ih = ih->next_this_file;\n-\n-      ih->next_this_file = jh;\n-      jh = ih;\n-      ih = ih->next_this_file;\n+      if (ih == (IHASH *)-1)\n+\treturn -2;\n \n-      ih->next = NULL;\n-      ih->next_this_file = NULL;\n-      ih->buf = NULL;\n-      ih->limit = NULL;\n+      *before = 1;\n+      *ihash = ih;\n+      return open (ih->name, OMODES);\n     }\n-  *before = 0;\n-  *ihash = ih;\n-  ih->name = NULL;\n-  ih->nshort = xstrdup (fname);\n-  ih->control_macro = NULL;\n-  \n-  /* If the pathname is absolute, just open it. */ \n-  if (fname[0] == '/')\n+\n+  if (path == ABSOLUTE_PATH)\n     {\n-      ih->foundhere = ABSOLUTE_PATH;\n-      ih->name = ih->nshort;\n-      return open (ih->name, O_RDONLY, 0666);\n+      name = (char *) fname;\n+      f = open (name, OMODES);\n     }\n-\n-  /* Search directory path, trying to open the file. */\n-\n-  len = strlen (fname);\n-  name = xmalloc (len + pfile->max_include_len + 2 + INCLUDE_LEN_FUDGE);\n-\n-  for (l = search_start; l; l = l->next)\n+  else\n     {\n-      memcpy (name, l->name, l->nlen);\n-      name[l->nlen] = '/';\n-      strcpy (&name[l->nlen+1], fname);\n-      _cpp_simplify_pathname (name);\n-      if (CPP_OPTIONS (pfile)->remap)\n-\tname = remap_filename (pfile, name, l);\n-\n-      f = open (name, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n-#ifdef EACCES\n-      if (f == -1 && errno == EACCES)\n+      /* Search directory path, trying to open the file.  */\n+      name = alloca (strlen (fname) + pfile->max_include_len\n+\t\t     + 2 + INCLUDE_LEN_FUDGE);\n+      do\n \t{\n-\t  cpp_error(pfile, \"included file `%s' exists but is not readable\",\n-\t\t    name);\n-\t  return -1;\n-\t}\n+\t  memcpy (name, path->name, path->nlen);\n+\t  name[path->nlen] = '/';\n+\t  strcpy (&name[path->nlen+1], fname);\n+\t  _cpp_simplify_pathname (name);\n+\t  if (CPP_OPTIONS (pfile)->remap)\n+\t    name = remap_filename (pfile, name, path);\n+\n+\t  f = open (name, OMODES);\n+#ifdef EACCES\n+\t  if (f == -1 && errno == EACCES)\n+\t    {\n+\t      cpp_error (pfile,\n+\t\t\t \"included file `%s' exists but is not readable\",\n+\t\t\t name);\n+\t      return -1;\n+\t    }\n #endif\n-\n-      if (f >= 0)\n-        {\n-\t  ih->foundhere = l;\n-\t  ih->name = xrealloc (name, strlen (name) + 1);\n-\t  return f;\n-        }\n+\t  if (f >= 0)\n+\t    break;\n+\t  path = path->next;\n+\t}\n+      while (path);\n     }\n-  \n-    if (jh)\n-      {\n-\tjh->next_this_file = NULL;\n-\tfree (ih);\n-      }\n-    free (name);\n-    *ihash = (IHASH *)-1;\n+  if (f == -1)\n     return -1;\n+\n+  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n+  strcpy ((char *)ih->name, name);\n+  ih->foundhere = path;\n+  if (path == ABSOLUTE_PATH)\n+    ih->nshort = ih->name;\n+  else\n+    ih->nshort = strstr (ih->name, fname);\n+  ih->control_macro = NULL;\n+  ih->hash = dummy.hash;\n+\n+  ih->next_this_file = *slot;\n+  *slot = ih;\n+\n+  *before = 0;\n+  *ihash = ih;\n+  return f;\n }\n \n /* The file_name_map structure holds a mapping of file names for a\n@@ -482,54 +476,41 @@ cpp_read_file (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  IHASH *ih_fake;\n+  IHASH *ih, **slot;\n+  IHASH dummy;\n   int f;\n \n-  if (fname == NULL || *fname == 0)\n+  if (fname == NULL)\n+    fname = \"\";\n+\n+  dummy.hash = -1;\n+  dummy.nshort = fname;\n+  slot = (IHASH **) htab_find_slot (pfile->all_include_files,\n+\t\t\t\t    (const void *) &dummy, 1);\n+  if (*slot && (ih = redundant_include_p (pfile, *slot, ABSOLUTE_PATH)))\n     {\n-      fname = \"\";\n-      f = 0;\n+      if (ih == (IHASH *)-1)\n+\treturn 1;  /* Already included.  */\n     }\n-\n-  /* Open the file in nonblocking mode, so we don't get stuck if\n-     someone clever has asked cpp to process /dev/rmt0.\n-     _cpp_read_include_file will check that we have a real file to\n-     work with.  Also take care not to acquire a controlling terminal\n-     by mistake (this can't happen on sane systems, but paranoia is a\n-     virtue).  */\n-  else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n+  else\n     {\n-      cpp_notice_from_errno (pfile, fname);\n-      return 0;\n+      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (fname));\n+      ih->control_macro = 0;\n+      ih->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+      ih->hash = dummy.hash;\n+      strcpy ((char *)ih->name, fname);\n+      ih->nshort = ih->name;\n+\n+      ih->next_this_file = *slot;\n+      *slot = ih;\n     }\n \n-  /* Push the buffer.  */\n-  if (!cpp_push_buffer (pfile, NULL, 0))\n-    goto failed_push;\n-  \n-  /* Gin up an include_hash structure for this file and feed it\n-     to finclude.  */\n-\n-  ih_fake = (IHASH *) xmalloc (sizeof (IHASH));\n-  ih_fake->next = 0;\n-  ih_fake->next_this_file = 0;\n-  ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n-  ih_fake->name = fname;\n-  ih_fake->control_macro = 0;\n-  ih_fake->buf = (char *)-1;\n-  ih_fake->limit = 0;\n-  if (!_cpp_read_include_file (pfile, f, ih_fake))\n-    goto failed_finclude;\n-\n-  return 1;\n+  if (*fname == '\\0')\n+    f = 0;\n+  else\n+    f = open (fname, OMODES);\n \n- failed_finclude:\n-  /* If finclude fails, it pops the buffer.  */\n-  free (ih_fake);\n- failed_push:\n-  if (f)\n-    close (f);\n-  return 0;\n+  return _cpp_read_include_file (pfile, f, ih);\n }\n \n /* Read the contents of FD into the buffer on the top of PFILE's stack.\n@@ -549,13 +530,16 @@ _cpp_read_include_file (pfile, fd, ihash)\n   long length;\n   cpp_buffer *fp;\n \n+  fp = cpp_push_buffer (pfile, NULL, 0);\n+\n+  if (fp == 0)\n+    goto push_fail;\n+\n   if (fstat (fd, &st) < 0)\n     goto perror_fail;\n   if (fcntl (fd, F_SETFL, 0) == -1)  /* turn off nonblocking mode */\n     goto perror_fail;\n \n-  fp = CPP_BUFFER (pfile);\n-\n   /* If fd points to a plain file, we know how big it is, so we can\n      allocate the buffer all at once.  If fd is a pipe or terminal, we\n      can't.  Most C source files are 4k or less, so we guess that.  If\n@@ -632,12 +616,14 @@ _cpp_read_include_file (pfile, fd, ihash)\n     fp->actual_dir = actual_directory (pfile, ihash->name);\n \n   pfile->input_stack_listing_current = 0;\n+  pfile->only_seen_white = 2;\n   return 1;\n \n  perror_fail:\n   cpp_error_from_errno (pfile, ihash->name);\n  fail:\n   cpp_pop_buffer (pfile);\n+ push_fail:\n   close (fd);\n   return 0;\n }\n@@ -1485,7 +1471,7 @@ hack_vms_include_specification (fullname)\n \n   if (check_filename_before_returning)\n     {\n-      f = open (fullname, O_RDONLY, 0666);\n+      f = open (fullname, OMODES);\n       if (f >= 0)\n \t{\n \t  /* The file name is OK as it is, so return it as is.  */"}, {"sha": "f993510c35b0e341174d496bb120f07bcf9c2251", "filename": "gcc/cpphash.c", "status": "modified", "additions": 135, "deletions": 105, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -27,10 +27,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n+#include \"hashtab.h\"\n #include \"version.h\"\n #undef abort\n \n-static unsigned int hashf\t  PARAMS ((const U_CHAR *, int));\n+static unsigned int hash_HASHNODE PARAMS ((const void *));\n+static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n+static void del_HASHNODE\t  PARAMS ((void *));\n+static int dump_hash_helper\t  PARAMS ((void *, void *));\n+\n static int comp_def_part\t PARAMS ((int, U_CHAR *, int, U_CHAR *,\n \t\t\t\t\t  int, int));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n@@ -45,6 +50,9 @@ static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n #define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n #define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n \n+/* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n+#define HASHSIZE 500\n+\n /* The arglist structure is built by create_definition to tell\n    collect_expansion where the argument names begin.  That\n    is, for a define like \"#define f(x,y,z) foo+x-bar*y\", the arglist\n@@ -92,55 +100,140 @@ struct argdata\n   int stringified_length;\n };\n \n-\n-/* Calculate hash function on a string.  */\n-\n+/* Calculate hash of a HASHNODE structure.  */\n static unsigned int\n-hashf (s, len)\n-     register const U_CHAR *s;\n-     register int len;\n+hash_HASHNODE (x)\n+     const void *x;\n {\n-  unsigned int n = len;\n-  unsigned int r = 0;\n+  HASHNODE *h = (HASHNODE *)x;\n+  const U_CHAR *s = h->name;\n+  unsigned int len = h->length;\n+  unsigned int n = len, r = 0;\n \n+  if (h->hash != (unsigned long)-1)\n+    return h->hash;\n+  \n   do\n     r = r * 67 + (*s++ - 113);\n   while (--n);\n+  h->hash = r + len;\n   return r + len;\n }\n \n-/* Find the most recent hash node for name \"name\" (ending with first\n-   non-identifier char) installed by cpp_install\n+/* Compare two HASHNODE structures.  */\n+static int\n+eq_HASHNODE (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  const HASHNODE *a = (const HASHNODE *)x;\n+  const HASHNODE *b = (const HASHNODE *)y;\n+\n+  return (a->length == b->length\n+\t  && !strncmp (a->name, b->name, a->length));\n+}\n+\n+/* Destroy a HASHNODE.  */\n+static void\n+del_HASHNODE (x)\n+     void *x;\n+{\n+  HASHNODE *h = (HASHNODE *)x;\n+  \n+  if (h->type == T_MACRO)\n+    _cpp_free_definition (h->value.defn);\n+  free ((void *) h->name);\n+  free (h);\n+}\n+\n+/* Allocate and initialize a HASHNODE structure.\n+   Caller must fill in the value field.  */\n+\n+HASHNODE *\n+_cpp_make_hashnode (name, len, type, hash)\n+     const U_CHAR *name;\n+     size_t len;\n+     enum node_type type;\n+     unsigned long hash;\n+{\n+  HASHNODE *hp = (HASHNODE *) xmalloc (sizeof (HASHNODE));\n+  U_CHAR *p = xmalloc (len + 1);\n+\n+  hp->type = type;\n+  hp->length = len;\n+  hp->name = p;\n+  hp->hash = hash;\n+\n+  memcpy (p, name, len);\n+  p[len] = 0;\n+\n+  return hp;\n+}\n+\n+/* Find the hash node for name \"name\", which ends at the first\n+   non-identifier char.\n \n    If LEN is >= 0, it is the length of the name.\n-   Otherwise, compute the length by scanning the entire name.  */\n+   Otherwise, compute the length now.  */\n \n HASHNODE *\n _cpp_lookup (pfile, name, len)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n      int len;\n {\n-  register const U_CHAR *bp;\n-  register HASHNODE *bucket;\n-  register unsigned int hash;\n+  const U_CHAR *bp;\n+  HASHNODE dummy;\n \n   if (len < 0)\n     {\n       for (bp = name; is_idchar (*bp); bp++);\n       len = bp - name;\n     }\n \n-  hash = hashf (name, len) % HASHSIZE;\n+  dummy.name = name;\n+  dummy.length = len;\n+  dummy.hash = -1;\n+\n+  return (HASHNODE *) htab_find (pfile->hashtab, (void *)&dummy);\n+}\n+\n+/* Find the hashtable slot for name \"name\".  Used to insert or delete.  */\n+HASHNODE **\n+_cpp_lookup_slot (pfile, name, len, insert, hash)\n+     cpp_reader *pfile;\n+     const U_CHAR *name;\n+     int len;\n+     int insert;\n+     unsigned long *hash;\n+{\n+  const U_CHAR *bp;\n+  HASHNODE dummy;\n+  HASHNODE **slot;\n \n-  bucket = pfile->hashtab[hash];\n-  while (bucket)\n+  if (len < 0)\n     {\n-      if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n-\treturn bucket;\n-      bucket = bucket->next;\n+      for (bp = name; is_idchar (*bp); bp++);\n+      len = bp - name;\n     }\n-  return (HASHNODE *) 0;\n+\n+  dummy.name = name;\n+  dummy.length = len;\n+  dummy.hash = -1;\n+\n+  slot = (HASHNODE **) htab_find_slot (pfile->hashtab, (void *)&dummy, insert);\n+  if (insert)\n+    *hash = dummy.hash;\n+  return slot;\n+}\n+\n+/* Init the hash table.  In here so it can see the hash and eq functions.  */\n+void\n+_cpp_init_macro_hash (pfile)\n+     cpp_reader *pfile;\n+{\n+  pfile->hashtab = htab_create (HASHSIZE, hash_HASHNODE,\n+\t\t\t\teq_HASHNODE, del_HASHNODE);\n }\n \n /* Free a DEFINITION structure.  Used by delete_macro, and by\n@@ -162,86 +255,6 @@ _cpp_free_definition (d)\n   free (d);\n }\n \n-/*\n- * Delete a hash node.  Some weirdness to free junk from macros.\n- * More such weirdness will have to be added if you define more hash\n- * types that need it.\n- */\n-\n-void\n-_cpp_delete_macro (hp)\n-     HASHNODE *hp;\n-{\n-  if (hp->prev != NULL)\n-    hp->prev->next = hp->next;\n-  if (hp->next != NULL)\n-    hp->next->prev = hp->prev;\n-\n-  /* make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards.  */\n-  if (hp == *hp->bucket_hdr)\n-    *hp->bucket_hdr = hp->next;\n-\n-  if (hp->type == T_MACRO)\n-    _cpp_free_definition (hp->value.defn);\n-\n-  free (hp);\n-}\n-\n-/* Install a name in the main hash table, even if it is already there.\n-   Name stops with first non alphanumeric, except leading '#'.\n-   Caller must check against redefinition if that is desired.\n-   delete_macro () removes things installed by cpp_install () in fifo order.\n-   this is important because of the `defined' special symbol used\n-   in #if, and also if pushdef/popdef directives are ever implemented.\n-\n-   If LEN is >= 0, it is the length of the name.\n-   Otherwise, compute the length by scanning the entire name.\n-\n-   If HASH is >= 0, it is the precomputed hash code.\n-   Otherwise, compute the hash code.  */\n-\n-HASHNODE *\n-_cpp_install (pfile, name, len, type, value)\n-     cpp_reader *pfile;\n-     const U_CHAR *name;\n-     int len;\n-     enum node_type type;\n-     const char *value;\n-{\n-  register HASHNODE *hp;\n-  register int i, bucket;\n-  register const U_CHAR *p;\n-  unsigned int hash;\n-\n-  if (len < 0)\n-    {\n-      p = name;\n-      while (is_idchar(*p))\n-\tp++;\n-      len = p - name;\n-    }\n-\n-  hash = hashf (name, len) % HASHSIZE;\n-\n-  i = sizeof (HASHNODE) + len + 1;\n-  hp = (HASHNODE *) xmalloc (i);\n-  bucket = hash;\n-  hp->bucket_hdr = &pfile->hashtab[bucket];\n-  hp->next = pfile->hashtab[bucket];\n-  pfile->hashtab[bucket] = hp;\n-  hp->prev = NULL;\n-  if (hp->next != NULL)\n-    hp->next->prev = hp;\n-  hp->type = type;\n-  hp->length = len;\n-  hp->value.cpval = value;\n-  hp->name = ((U_CHAR *) hp) + sizeof (HASHNODE);\n-  memcpy (hp->name, name, len);\n-  hp->name[len] = 0;\n-  return hp;\n-}\n-\n static int\n macro_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n@@ -255,7 +268,6 @@ macro_cleanup (pbuf, pfile)\n   return 0;\n }\n \n-\n /* Read a replacement list for a macro, and build the DEFINITION\n    structure.  ARGLIST specifies the formal parameters to look for in\n    the text of the definition.  If ARGLIST is null, this is an\n@@ -503,7 +515,6 @@ collect_expansion (pfile, arglist)\n       while (here > last && is_hspace (pfile->token_buffer [here-1]))\n \there--;\n       CPP_SET_WRITTEN (pfile, here);\n-  \n       CPP_NUL_TERMINATE (pfile);\n       len = CPP_WRITTEN (pfile) - start + 1;\n       /* space for no-concat markers at either end */\n@@ -1666,8 +1677,27 @@ _cpp_dump_definition (pfile, sym, len, defn)\n       if (*x == '\\r') x += 2, i -= 2;\n       if (i > 0) CPP_PUTS (pfile, x, i);\n     }\n-\n   if (pfile->lineno == 0)\n     CPP_PUTC (pfile, '\\n');\n   CPP_NUL_TERMINATE (pfile);\n }\n+\n+/* Dump out the hash table.  */\n+static int\n+dump_hash_helper (h, p)\n+     void *h;\n+     void *p;\n+{\n+  HASHNODE *hp = (HASHNODE *)h;\n+  cpp_reader *pfile = (cpp_reader *)p;\n+\n+  _cpp_dump_definition (pfile, hp->name, hp->length, hp->value.defn);\n+  return 1;\n+}\n+\n+void\n+_cpp_dump_macro_hash (pfile)\n+     cpp_reader *pfile;\n+{\n+  htab_traverse (pfile->hashtab, dump_hash_helper, pfile);\n+}"}, {"sha": "c842ea6e121babf3b5e83c04edb99a0e651511b4", "filename": "gcc/cpphash.h", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -132,15 +132,11 @@ union hashval\n typedef struct hashnode HASHNODE;\n struct hashnode\n {\n-  struct hashnode *next;\t/* double links for easy deletion */\n-  struct hashnode *prev;\n-  struct hashnode **bucket_hdr;\t/* also, a back pointer to this node's hash\n-\t\t\t\t   chain is kept, in case the node is the head\n-\t\t\t\t   of the chain and gets deleted. */\n-  enum node_type type;\t\t/* type of special token */\n-  int length;\t\t\t/* length of token, for quick comparison */\n-  U_CHAR *name;\t\t\t/* the actual name */\n+  const U_CHAR *name;\t\t/* the actual name */\n+  size_t length;\t\t/* length of token, for quick comparison */\n+  unsigned long hash;\t\t/* cached hash value */\n   union hashval value;\t\t/* pointer to expansion, or whatever */\n+  enum node_type type;\t\t/* type of special token */\n };\n \n /* List of directories to look for include files in. */\n@@ -169,20 +165,20 @@ struct file_name_list\n    #include statement) which is stored in *nshort.  */\n struct ihash\n {\n-  struct ihash *next;\n   /* Next file with the same short name but a\n      different (partial) pathname). */\n   struct ihash *next_this_file;\n \n   /* Location of the file in the include search path.\n      Used for include_next */\n   struct file_name_list *foundhere;\n-  const char *name;\t\t/* (partial) pathname of file */\n-  const char *nshort;\t\t/* name of file as referenced in #include */\n+\n+  unsigned long hash;\t\t/* save hash value for future reference */\n+  const char *nshort;\t\t/* name of file as referenced in #include;\n+\t\t\t\t   points into name[]  */\n   const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion -\n \t\t\t\t   see redundant_include_p */\n-  char *buf, *limit;\t\t/* for file content cache,\n-\t\t\t\t   not yet implemented */\n+  const char name[1];\t\t/* (partial) pathname of file */\n };\n typedef struct ihash IHASH;\n \n@@ -247,26 +243,31 @@ extern unsigned char _cpp_IStable[256];\n   (CPP_OPTIONS (PFILE)->pedantic && !CPP_BUFFER (pfile)->system_header_p)\n \n /* In cpphash.c */\n-extern HASHNODE *_cpp_install\t  PARAMS ((cpp_reader *, const U_CHAR *, int,\n-\t\t\t\t\t   enum node_type, const char *));\n-extern HASHNODE *_cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n-extern void _cpp_free_definition  PARAMS ((DEFINITION *));\n-extern void _cpp_delete_macro\t  PARAMS ((HASHNODE *));\n-\n-extern DEFINITION *_cpp_create_definition\n-\t\t\t\t  PARAMS ((cpp_reader *, int));\n-extern int _cpp_compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n-\t\t\t\t\t   DEFINITION *));\n-extern void _cpp_macroexpand\t  PARAMS ((cpp_reader *, HASHNODE *));\n-extern void _cpp_dump_definition  PARAMS ((cpp_reader *, const U_CHAR *, long,\n-\t\t\t\t\t   DEFINITION *));\n+extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n+\t\t\t\t\t\t enum node_type,\n+\t\t\t\t\t\t unsigned long));\n+extern HASHNODE *_cpp_lookup\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const U_CHAR *, int));\n+extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const U_CHAR *, int, int,\n+\t\t\t\t\t\t unsigned long *));\n+extern void _cpp_free_definition\tPARAMS ((DEFINITION *));\n+extern DEFINITION *_cpp_create_definition PARAMS ((cpp_reader *, int));\n+extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t\t long, DEFINITION *));\n+extern int _cpp_compare_defs\t\tPARAMS ((cpp_reader *, DEFINITION *,\n+\t\t\t\t\t\t DEFINITION *));\n+extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, HASHNODE *));\n+extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n+extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t\tstruct file_name_list *,\n \t\t\t\t\t\tIHASH **, int *));\n extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));"}, {"sha": "f6fd246c59c9e0e301a2aeb2a2d476812c0d15c3", "filename": "gcc/cppinit.c", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -28,6 +28,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"prefix.h\"\n #include \"intl.h\"\n #include \"version.h\"\n+#include \"hashtab.h\"\n #include \"mkdeps.h\"\n \n /* Predefined symbols, built-in macros, and the default include path. */\n@@ -554,7 +555,8 @@ cpp_reader_init (pfile)\n   pfile->token_buffer = (U_CHAR *) xmalloc (pfile->token_buffer_size);\n   CPP_SET_WRITTEN (pfile, 0);\n \n-  pfile->hashtab = (HASHNODE **) xcalloc (HASHSIZE, sizeof (HASHNODE *));\n+  _cpp_init_macro_hash (pfile);\n+  _cpp_init_include_hash (pfile);\n }\n \n /* Free resources used by PFILE.\n@@ -563,7 +565,6 @@ void\n cpp_cleanup (pfile)\n      cpp_reader *pfile;\n {\n-  int i;\n   while (CPP_BUFFER (pfile) != NULL)\n     cpp_pop_buffer (pfile);\n \n@@ -584,25 +585,8 @@ cpp_cleanup (pfile)\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n-  for (i = ALL_INCLUDE_HASHSIZE; --i >= 0; )\n-    {\n-      IHASH *imp, *next;\n-      for (imp = pfile->all_include_files[i]; imp; imp = next)\n-\t{\n-\t  next = imp->next;\n-\t  free ((PTR) imp->name);\n-\t  free ((PTR) imp->nshort);\n-\t  free (imp);\n-\t}\n-      pfile->all_include_files[i] = 0;\n-    }\n-\n-  for (i = HASHSIZE; --i >= 0;)\n-    {\n-      while (pfile->hashtab[i])\n-\t_cpp_delete_macro (pfile->hashtab[i]);\n-    }\n-  free (pfile->hashtab);\n+  htab_delete (pfile->hashtab);\n+  htab_delete (pfile->all_include_files);\n }\n \n \n@@ -654,14 +638,14 @@ static const struct builtin builtin_array[] =\n \n /* Subroutine of cpp_start_read; reads the builtins table above and\n    enters the macros into the hash table.  */\n-\n static void\n initialize_builtins (pfile)\n      cpp_reader *pfile;\n {\n   int len;\n   const struct builtin *b;\n   const char *val;\n+  HASHNODE *hp;\n   for(b = builtin_array; b->name; b++)\n     {\n       if ((b->flags & STDC) && CPP_TRADITIONAL (pfile))\n@@ -670,7 +654,10 @@ initialize_builtins (pfile)\n       val = (b->flags & ULP) ? user_label_prefix : b->value;\n       len = strlen (b->name);\n \n-      _cpp_install (pfile, b->name, len, b->type, val);\n+      hp = _cpp_make_hashnode (b->name, len, b->type, -1);\n+      hp->value.cpval = val;\n+      *(htab_find_slot (pfile->hashtab, (void *)hp, 1)) = hp;\n+\n       if ((b->flags & DUMP) && CPP_OPTIONS (pfile)->debug_output)\n \tdump_special_to_buffer (pfile, b->name);\n     }\n@@ -1015,20 +1002,7 @@ cpp_finish (pfile)\n     }\n \n   if (opts->dump_macros == dump_only)\n-    {\n-      int i;\n-      HASHNODE *h;\n-      for (i = HASHSIZE; --i >= 0;)\n-\t{\n-\t  for (h = pfile->hashtab[i]; h; h = h->next)\n-\t    if (h->type == T_MACRO)\n-\t      {\n-\t\t_cpp_dump_definition (pfile, h->name, h->length,\n-\t\t\t\t      h->value.defn);\n-\t\tCPP_PUTC (pfile, '\\n');\n-\t      }\n-\t}\n-    }\n+    _cpp_dump_macro_hash (pfile);\n }\n \n static void"}, {"sha": "91f86b7cb4a4aa8d0a547bc20b74753ce1af8256", "filename": "gcc/cpplib.c", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -24,6 +24,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"cpplib.h\"\n #include \"cpphash.h\"\n+#include \"hashtab.h\"\n #include \"intl.h\"\n #include \"mkdeps.h\"\n \n@@ -659,9 +660,10 @@ do_define (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  HASHNODE *hp;\n+  HASHNODE **slot;\n   DEFINITION *def;\n   long here;\n+  unsigned long hash;\n   int len, c;\n   int funlike = 0;\n   U_CHAR *sym;\n@@ -692,9 +694,11 @@ do_define (pfile, keyword)\n   if (def == 0)\n     return 0;\n \n-  if ((hp = _cpp_lookup (pfile, sym, len)) != NULL)\n+  slot = _cpp_lookup_slot (pfile, sym, len, 1, &hash);\n+  if (*slot)\n     {\n       int ok;\n+      HASHNODE *hp = *slot;\n \n       /* Redefining a macro is ok if the definitions are the same.  */\n       if (hp->type == T_MACRO)\n@@ -729,7 +733,11 @@ do_define (pfile, keyword)\n \t}\n     }\n   else\n-    _cpp_install (pfile, sym, len, T_MACRO, (char *) def);\n+    {\n+      HASHNODE *hp = _cpp_make_hashnode (sym, len, T_MACRO, hash);\n+      hp->value.defn = def;\n+      *slot = hp;\n+    }\n \n   if (CPP_OPTIONS (pfile)->debug_output\n       || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n@@ -1260,21 +1268,12 @@ do_include (pfile, keyword)\n   if (importing)\n     ihash->control_macro = (const U_CHAR *) \"\";\n   \n-  if (cpp_push_buffer (pfile, NULL, 0) == NULL)\n-    {\n-      close (fd);\n-      return 0;\n-    }\n-  \n-  if (angle_brackets)\n-    pfile->system_include_depth++;   /* Decremented in file_cleanup. */\n-\n   if (_cpp_read_include_file (pfile, fd, ihash))\n     {\n       output_line_command (pfile, enter_file);\n-      pfile->only_seen_white = 2;\n+      if (angle_brackets)\n+\tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n     }\n-\n   return 0;\n }\n \n@@ -1435,7 +1434,7 @@ do_undef (pfile, keyword)\n      const struct directive *keyword;\n {\n   int len;\n-  HASHNODE *hp;\n+  HASHNODE **slot;\n   U_CHAR *buf, *name, *limit;\n   int c;\n   long here = CPP_WRITTEN (pfile);\n@@ -1468,8 +1467,10 @@ do_undef (pfile, keyword)\n   }\n   CPP_SET_WRITTEN (pfile, here);\n \n-  while ((hp = _cpp_lookup (pfile, name, len)) != NULL)\n+  slot = _cpp_lookup_slot (pfile, name, len, 0, 0);\n+  if (slot)\n     {\n+      HASHNODE *hp = *slot;\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n@@ -1480,7 +1481,8 @@ do_undef (pfile, keyword)\n \t{\n \t  if (hp->type != T_MACRO)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n-\t  _cpp_delete_macro (hp);\n+\n+\t  htab_clear_slot (pfile->hashtab, (void **)slot);\n \t}\n     }\n \n@@ -1692,6 +1694,7 @@ do_pragma_implementation (pfile)\n   long written = CPP_WRITTEN (pfile);\n   U_CHAR *name;\n   U_CHAR *copy;\n+  size_t len;\n \n   token = get_directive_token (pfile);\n   if (token == CPP_VSPACE)\n@@ -1703,14 +1706,15 @@ do_pragma_implementation (pfile)\n     }\n \n   name = pfile->token_buffer + written + 1;\n-  copy = (U_CHAR *) xstrdup (name);\n-  copy[strlen(copy)] = '\\0';  /* trim trailing quote */\n-\n+  len = strlen (name);\n+  copy = (U_CHAR *) alloca (len);\n+  memcpy (copy, name, len - 1);\n+  copy[len] = '\\0';\t/* trim trailing quote */\n+  \n   if (cpp_included (pfile, copy))\n     cpp_warning (pfile,\n \t \"`#pragma implementation' for `%s' appears after file is included\",\n \t\t copy);\n-  free (copy);\n   return 0;\n }\n \n@@ -1721,11 +1725,13 @@ do_pragma_poison (pfile)\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n   U_CHAR *p;\n-  HASHNODE *hp;\n+  HASHNODE **slot;\n   long written;\n   size_t len;\n   enum cpp_token token;\n   int writeit;\n+  unsigned long hash;\n+\n   /* As a rule, don't include #pragma poison commands in output,  \n      unless the user asks for them.  */\n   writeit = (CPP_OPTIONS (pfile)->debug_output\n@@ -1747,8 +1753,10 @@ do_pragma_poison (pfile)\n \n       p = pfile->token_buffer + written;\n       len = strlen (p);\n-      if ((hp = _cpp_lookup (pfile, p, len)))\n+      slot = _cpp_lookup_slot (pfile, p, len, 1, &hash);\n+      if (*slot)\n \t{\n+\t  HASHNODE *hp = *slot;\n \t  if (hp->type != T_POISON)\n \t    {\n \t      cpp_warning (pfile, \"poisoning existing macro `%s'\", p);\n@@ -1759,7 +1767,11 @@ do_pragma_poison (pfile)\n \t    }\n \t}\n       else\n-\t_cpp_install (pfile, p, len, T_POISON, 0);\n+\t{\n+\t  HASHNODE *hp = _cpp_make_hashnode (p, len, T_POISON, hash);\n+\t  hp->value.cpval = 0;\n+\t  *slot = hp;\n+\t}\n       if (writeit)\n \tCPP_PUTC (pfile, ' ');\n     }\n@@ -3025,7 +3037,9 @@ do_assert (pfile, keyword)\n   U_CHAR *sym;\n   int ret, c;\n   HASHNODE *base, *this;\n-  int baselen, thislen;\n+  HASHNODE **bslot, **tslot;\n+  size_t blen, tlen;\n+  unsigned long bhash, thash;\n \n   if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->done_initializing)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#assert'\");\n@@ -3049,27 +3063,30 @@ do_assert (pfile, keyword)\n       goto error;\n     }\n \n-  thislen = strlen (sym);\n-  baselen = (U_CHAR *) strchr (sym, '(') - sym;\n-  this = _cpp_lookup (pfile, sym, thislen);\n-  if (this)\n+  tlen = strlen (sym);\n+  blen = (U_CHAR *) strchr (sym, '(') - sym;\n+  tslot = _cpp_lookup_slot (pfile, sym, tlen, 1, &thash);\n+  if (*tslot)\n     {\n       cpp_warning (pfile, \"`%s' re-asserted\", sym);\n       goto error;\n     }\n \n-  base = _cpp_lookup (pfile, sym, baselen);\n-  if (! base)\n-    base = _cpp_install (pfile, sym, baselen, T_ASSERT, 0);\n-  else if (base->type != T_ASSERT)\n-  {\n-    /* Token clash - but with what?! */\n-    cpp_ice (pfile, \"base->type != T_ASSERT in do_assert\");\n-    goto error;\n-  }\n-\n-  this = _cpp_install (pfile, sym, thislen, T_ASSERT,\n-\t\t      (char *)base->value.aschain);\n+  bslot = _cpp_lookup_slot (pfile, sym, blen, 1, &bhash);\n+  if (! *bslot)\n+    *bslot = base = _cpp_make_hashnode (sym, blen, T_ASSERT, bhash);\n+  else\n+    {\n+      base = *bslot;\n+      if (base->type != T_ASSERT)\n+\t{\n+\t  /* Token clash - but with what?! */\n+\t  cpp_ice (pfile, \"base->type != T_ASSERT in do_assert\");\n+\t  goto error;\n+\t}\n+    }\n+  *tslot = this = _cpp_make_hashnode (sym, tlen, T_ASSERT, thash);\n+  this->value.aschain = base->value.aschain;\n   base->value.aschain = this;\n   \n   pfile->limit = sym;\t\t/* Pop */\n@@ -3118,9 +3135,9 @@ do_unassert (pfile, keyword)\n       for (this = base->value.aschain; this; this = next)\n         {\n \t  next = this->value.aschain;\n-\t  _cpp_delete_macro (this);\n+\t  htab_remove_elt (pfile->hashtab, this);\n \t}\n-      _cpp_delete_macro (base);\n+      htab_remove_elt (pfile->hashtab, base);\n     }\n   else\n     {\n@@ -3135,10 +3152,11 @@ do_unassert (pfile, keyword)\n \tnext = next->value.aschain;\n \n       next->value.aschain = this->value.aschain;\n-      _cpp_delete_macro (this);\n+      htab_remove_elt (pfile->hashtab, this);\n \n       if (base->value.aschain == NULL)\n-\t_cpp_delete_macro (base);  /* Last answer for this predicate deleted. */\n+\t/* Last answer for this predicate deleted. */\n+\thtab_remove_elt (pfile->hashtab, base);\n     }\n   \n   pfile->limit = sym;\t\t/* Pop */"}, {"sha": "7906d0c05c0259100c83296ce385306829177aa5", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35364d13e14ba0eea541a77484c716f1cf82195/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=d35364d13e14ba0eea541a77484c716f1cf82195", "patch": "@@ -121,6 +121,7 @@ struct cpp_buffer\n };\n \n struct file_name_map_list;\n+struct htab;\n \n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n    efficiency, and partly to limit runaway recursion.  */\n@@ -155,12 +156,10 @@ struct cpp_reader\n   int buffer_stack_depth;\n \n   /* Hash table of macros and assertions.  See cpphash.c */\n-#define HASHSIZE 1403\n-  struct hashnode **hashtab;\n+  struct htab *hashtab;\n \n   /* Hash table of other included files.  See cppfiles.c */\n-#define ALL_INCLUDE_HASHSIZE 71\n-  struct ihash *all_include_files[ALL_INCLUDE_HASHSIZE];\n+  struct htab *all_include_files;\n \n   /* Chain of `actual directory' file_name_list entries,\n      for \"\" inclusion. */\n@@ -503,7 +502,6 @@ extern void output_line_command\t\tPARAMS ((cpp_reader *,\n extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n \n-\n #ifdef __cplusplus\n }\n #endif"}]}