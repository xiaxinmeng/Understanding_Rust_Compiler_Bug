{"sha": "2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlNTg2NTBmOTYyZTM3MWIwNmYwMGJkZWZkMGIwMWI1ZjdlM2Y2YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-06-30T14:56:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-06-30T14:56:37Z"}, "message": "cfgloopanal.c (check_irred): Move into ...\n\n\t* cfgloopanal.c (check_irred): Move into ...\n\t(mark_irreducible_loops): ... here; return true if ireducible\n\tloops was found.\n\t* ipa-pure-const.c: Include cfgloop.h and tree-scalar-evolution.h\n\t(analyze_function): Try to prove loop finiteness.\n\t* cfgloop.h (mark_irreducible_loops): Update prototype.\n\t* Makefile.in (ipa-pure-const.o): Add dependency on SCEV and CFGLOOP.\n\nFrom-SVN: r149101", "tree": {"sha": "b0873a32071a823e01701ec13011a3c5038ec083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0873a32071a823e01701ec13011a3c5038ec083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/comments", "author": null, "committer": null, "parents": [{"sha": "46db44ccaea515d561f7a63d0e07ee6ddbc1b869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46db44ccaea515d561f7a63d0e07ee6ddbc1b869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46db44ccaea515d561f7a63d0e07ee6ddbc1b869"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "4eb3f626c31dd54da9be00107ea611177d09b3b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -1,3 +1,13 @@\n+2009-06-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgloopanal.c (check_irred): Move into ...\n+\t(mark_irreducible_loops): ... here; return true if ireducible\n+\tloops was found.\n+\t* ipa-pure-const.c: Include cfgloop.h and tree-scalar-evolution.h\n+\t(analyze_function): Try to prove loop finiteness.\n+\t* cfgloop.h (mark_irreducible_loops): Update prototype.\n+\t* Makefile.in (ipa-pure-const.o): Add dependency on SCEV and CFGLOOP.\n+\n 2009-06-30  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* Makefile.in (PLUGIN_HEADERS): added ggc, tree-dump, pretty-print."}, {"sha": "18089fb02a45ca3bd9a866b748842c35d1ad807a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -2725,7 +2725,7 @@ ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) \\\n-   $(DIAGNOSTIC_H)\n+   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H)\n ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\"}, {"sha": "2bc965b577b551314f2609217e36598cb024a071", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -205,7 +205,7 @@ struct loop *alloc_loop (void);\n extern void flow_loop_free (struct loop *);\n int flow_loop_nodes_find (basic_block, struct loop *);\n void fix_loop_structure (bitmap changed_bbs);\n-void mark_irreducible_loops (void);\n+bool mark_irreducible_loops (void);\n void release_recorded_exits (void);\n void record_loop_exits (void);\n void rescan_loop_exit (edge, bool, bool);"}, {"sha": "36e0d152265fb91a44ea11ce67e6c9ee424215c0", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -52,26 +52,6 @@ just_once_each_iteration_p (const struct loop *loop, const_basic_block bb)\n   return true;\n }\n \n-/* Marks the edge E in graph G irreducible if it connects two vertices in the\n-   same scc.  */\n-\n-static void\n-check_irred (struct graph *g, struct graph_edge *e)\n-{\n-  edge real = (edge) e->data;\n-\n-  /* All edges should lead from a component with higher number to the\n-     one with lower one.  */\n-  gcc_assert (g->vertices[e->src].component >= g->vertices[e->dest].component);\n-\n-  if (g->vertices[e->src].component != g->vertices[e->dest].component)\n-    return;\n-\n-  real->flags |= EDGE_IRREDUCIBLE_LOOP;\n-  if (flow_bb_inside_loop_p (real->src->loop_father, real->dest))\n-    real->src->flags |= BB_IRREDUCIBLE_LOOP;\n-}\n-\n /* Marks blocks and edges that are part of non-recognized loops; i.e. we\n    throw away all latch edges and mark blocks inside any remaining cycle.\n    Everything is a bit complicated due to fact we do not want to do this\n@@ -84,17 +64,20 @@ check_irred (struct graph *g, struct graph_edge *e)\n #define LOOP_REPR(LOOP) ((LOOP)->num + last_basic_block)\n #define BB_REPR(BB) ((BB)->index + 1)\n \n-void\n+bool\n mark_irreducible_loops (void)\n {\n   basic_block act;\n+  struct graph_edge *ge;\n   edge e;\n   edge_iterator ei;\n   int src, dest;\n   unsigned depth;\n   struct graph *g;\n   int num = number_of_loops ();\n   struct loop *cloop;\n+  bool irred_loop_found = false;\n+  int i;\n \n   gcc_assert (current_loops != NULL);\n \n@@ -154,11 +137,30 @@ mark_irreducible_loops (void)\n   graphds_scc (g, NULL);\n \n   /* Mark the irreducible loops.  */\n-  for_each_edge (g, check_irred);\n+  for (i = 0; i < g->n_vertices; i++)\n+    for (ge = g->vertices[i].succ; ge; ge = ge->succ_next)\n+      {\n+\tedge real = (edge) ge->data;\n+\t/* edge E in graph G is irreducible if it connects two vertices in the\n+\t   same scc.  */\n+\n+\t/* All edges should lead from a component with higher number to the\n+\t   one with lower one.  */\n+\tgcc_assert (g->vertices[ge->src].component >= g->vertices[ge->dest].component);\n+\n+\tif (g->vertices[ge->src].component != g->vertices[ge->dest].component)\n+\t  continue;\n+\n+\treal->flags |= EDGE_IRREDUCIBLE_LOOP;\n+\tirred_loop_found = true;\n+\tif (flow_bb_inside_loop_p (real->src->loop_father, real->dest))\n+\t  real->src->flags |= BB_IRREDUCIBLE_LOOP;\n+      }\n \n   free_graph (g);\n \n   loops_state_set (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS);\n+  return irred_loop_found;\n }\n \n /* Counts number of insns inside LOOP.  */"}, {"sha": "8faa00c3b0e9209fb74dafcd9305ec395e8c6474", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n \n static struct pointer_set_t *visited_nodes;\n \n@@ -522,8 +524,33 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t indication of possible infinite loop side\n \t effect.  */\n       if (mark_dfs_back_edges ())\n-\tl->looping = true;\n-      \n+        {\n+\t  loop_optimizer_init (LOOPS_HAVE_PREHEADERS);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    flow_loops_dump (dump_file, NULL, 0);\n+\t  if (mark_irreducible_loops ())\n+\t    {\n+\t      if (dump_file)\n+\t        fprintf (dump_file, \"    has irreducible loops\\n\");\n+\t      l->looping = true;\n+\t    }\n+\t  else \n+\t    {\n+\t      loop_iterator li;\n+\t      struct loop *loop;\n+\t      scev_initialize ();\n+\t      FOR_EACH_LOOP (li, loop, 0)\n+\t\tif (!finite_loop_p (loop))\n+\t\t  {\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file, \"    can not prove finiteness of loop %i\\n\", loop->num);\n+\t\t    l->looping =true;\n+\t\t    break;\n+\t\t  }\n+\t      scev_finalize ();\n+\t    }\n+          loop_optimizer_finalize ();\n+\t}\n     }\n \n   if (TREE_READONLY (decl))"}, {"sha": "76c90a4fd5d1ed73963248447444e33dc3bad1db", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -70,7 +70,7 @@ DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n \t  \"The maximum number of instructions in a single function eligible for inlining\",\n-\t  400, 0, 0)\n+\t  150, 0, 0)\n \n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n@@ -82,17 +82,17 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining\",\n-\t  60, 0, 0)\n+\t  40, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n \t  \"max-inline-insns-recursive\",\n \t  \"The maximum number of instructions inline function can grow to via recursive inlining\",\n-\t  450, 0, 0)\n+\t  300, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,\n \t  \"max-inline-insns-recursive-auto\",\n \t  \"The maximum number of instructions non-inline function can grow to via recursive inlining\",\n-\t  450, 0, 0)\n+\t  200, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH,\n \t  \"max-inline-recursive-depth\",\n@@ -185,7 +185,7 @@ DEFPARAM(PARAM_IPCP_UNIT_GROWTH,\n DEFPARAM(PARAM_EARLY_INLINING_INSNS,\n \t \"early-inlining-insns\",\n \t \"maximal estimated growth of function body caused by early inlining of single call\",\n-\t 12, 0, 0)\n+\t 8, 0, 0)\n DEFPARAM(PARAM_LARGE_STACK_FRAME,\n \t \"large-stack-frame\",\n \t \"The size of stack frame to be considered large\","}, {"sha": "049dd1df93b79e81ffdf62007f15eb1a14c6ac00", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de58650f962e371b06f00bdefd0b01b5f7e3f6a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2de58650f962e371b06f00bdefd0b01b5f7e3f6a", "patch": "@@ -5131,8 +5131,17 @@ gimple_move_block_after (basic_block bb, basic_block after)\n /* Return true if basic_block can be duplicated.  */\n \n static bool\n-gimple_can_duplicate_bb_p (const_basic_block bb ATTRIBUTE_UNUSED)\n+gimple_can_duplicate_bb_p (const_basic_block bb)\n {\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\n+  /* RTL expander has quite artificial limitation to at most one RESX instruction\n+     per region.  It can be fixed by turning 1-1 map to 1-many map, but since the\n+     code needs to be rewritten to gimple level lowering and there is little reason\n+     for duplicating RESX instructions in order to optimize code performance, we\n+     just disallow it for the moment.  */\n+  if (!gsi_end_p (gsi) && gimple_code (gsi_stmt (gsi)) == GIMPLE_RESX)\n+    return false;\n   return true;\n }\n "}]}