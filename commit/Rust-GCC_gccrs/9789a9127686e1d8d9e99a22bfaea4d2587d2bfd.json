{"sha": "9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4OWE5MTI3Njg2ZTFkOGQ5ZTk5YTIyYmZhZWE0ZDI1ODdkMmJmZA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2013-11-06T11:33:52Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-11-06T11:33:52Z"}, "message": "preprocessor/58580 - preprocessor goes OOM with warning for zero literals\n\nIn this problem report, the compiler is fed a (bogus) translation unit\nin which some literals contain bytes whose value is zero.  The\npreprocessor detects that and proceeds to emit diagnostics for that\nking of bogus literals.  But then when the diagnostics machinery\nre-reads the input file again to display the bogus literals with a\ncaret, it attempts to calculate the length of each of the lines it got\nusing fgets.  The line length calculation is done using strlen.  But\nthat doesn't work well when the content of the line can have several\nzero bytes.  The result is that the read_line never sees the end of\nthe line because strlen repeatedly reports that the line ends before\nthe end-of-line character; so read_line thinks its buffer for reading\nthe line is too small; it thus increases the buffer, leading to a huge\nmemory consumption, pain and disaster.\n\nThe patch below introduces a new get_line function that returns the\nnext line of a file and return the length of that line even if the\nline contains zero bytes.  That get_line function has been adapted\nfrom the getline function from the GNU C Library because getline being\na GNU extension it is not necessarily supported on all platforms.\nread_line is then modified to return the length of the line along with\nthe line itself, as the line can now contain zero bytes.  Callers of\nread_line are adjusted consequently.\n\ndiagnostic_show_locus() is modified to consider that a line can have\ncharacters of value zero, and so just shows a white space when\ninstructed to display one of these characters.\n\ngcc/ChangeLog:\n\n\t* input.h (location_get_source_line): Take an additional line_size\n\tparameter.\n\t* input.c (get_line): New static function definition.\n\t(read_line): Take an additional line_length output parameter to be\n\tset to the size of the line.  Use the new get_line function do the\n\tactual line reading.\n\t(location_get_source_line): Take an additional output line_len\n\tparameter.  Update the use of read_line to pass it the line_len\n\tparameter.\n\t* diagnostic.c (adjust_line): Take an additional input parameter\n\tfor the length of the line, rather than calculating it with\n\tstrlen.\n\t(diagnostic_show_locus): Adjust the use of\n\tlocation_get_source_line and adjust_line with respect to their new\n\tsignature.  While displaying a line now, do not stop at the first\n\tnull byte.  Rather, display the zero byte as a space and keep\n\tgoing until we reach the size of the line.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/cpp/warning-zero-in-literals-1.c: New test file.\n\nFrom-SVN: r204453", "tree": {"sha": "9df93357bf3f4d53fa06f73941b2e247cae258ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9df93357bf3f4d53fa06f73941b2e247cae258ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/comments", "author": null, "committer": null, "parents": [{"sha": "6dce150ccfff7d992ff96323da74c2021ef64989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dce150ccfff7d992ff96323da74c2021ef64989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dce150ccfff7d992ff96323da74c2021ef64989"}], "stats": {"total": 161, "additions": 127, "deletions": 34}, "files": [{"sha": "9192b7809522e762fe3f845200b0317d4fea8423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "patch": "@@ -1,3 +1,24 @@\n+2013-11-06  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tpreprocessor/58580\n+\t* input.h (location_get_source_line): Take an additional line_size\n+\tparameter.\n+\t* input.c (get_line): New static function definition.\n+\t(read_line): Take an additional line_length output parameter to be\n+\tset to the size of the line.  Use the new get_line function do the\n+\tactual line reading.\n+\t(location_get_source_line): Take an additional output line_len\n+\tparameter.  Update the use of read_line to pass it the line_len\n+\tparameter.\n+\t* diagnostic.c (adjust_line): Take an additional input parameter\n+\tfor the length of the line, rather than calculating it with\n+\tstrlen.\n+\t(diagnostic_show_locus): Adjust the use of\n+\tlocation_get_source_line and adjust_line with respect to their new\n+\tsignature.  While displaying a line now, do not stop at the first\n+\tnull byte.  Rather, display the zero byte as a space and keep\n+\tgoing until we reach the size of the line.\n+\n 2013-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/i386/i386.c (ix86_expand_prologue): Optimize stack checking for"}, {"sha": "e0c5d9dc79aa4c9bb78da5da83f3bfb4a356bea4", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "patch": "@@ -259,12 +259,13 @@ diagnostic_build_prefix (diagnostic_context *context,\n    MAX_WIDTH by some margin, then adjust the start of the line such\n    that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n    margin is either 10 characters or the difference between the column\n-   and the length of the line, whatever is smaller.  */\n+   and the length of the line, whatever is smaller.  The length of\n+   LINE is given by LINE_WIDTH.  */\n static const char *\n-adjust_line (const char *line, int max_width, int *column_p)\n+adjust_line (const char *line, int line_width,\n+\t     int max_width, int *column_p)\n {\n   int right_margin = 10;\n-  int line_width = strlen (line);\n   int column = *column_p;\n \n   right_margin = MIN (line_width - column, right_margin);\n@@ -284,6 +285,7 @@ diagnostic_show_locus (diagnostic_context * context,\n \t\t       const diagnostic_info *diagnostic)\n {\n   const char *line;\n+  int line_width;\n   char *buffer;\n   expanded_location s;\n   int max_width;\n@@ -297,22 +299,25 @@ diagnostic_show_locus (diagnostic_context * context,\n \n   context->last_location = diagnostic->location;\n   s = expand_location_to_spelling_point (diagnostic->location);\n-  line = location_get_source_line (s);\n+  line = location_get_source_line (s, &line_width);\n   if (line == NULL)\n     return;\n \n   max_width = context->caret_max_width;\n-  line = adjust_line (line, max_width, &(s.column));\n+  line = adjust_line (line, line_width, max_width, &(s.column));\n \n   pp_newline (context->printer);\n   saved_prefix = pp_get_prefix (context->printer);\n   pp_set_prefix (context->printer, NULL);\n   pp_space (context->printer);\n-  while (max_width > 0 && *line != '\\0')\n+  while (max_width > 0 && line_width > 0)\n     {\n       char c = *line == '\\t' ? ' ' : *line;\n+      if (c == '\\0')\n+\tc = ' ';\n       pp_character (context->printer, c);\n       max_width--;\n+      line_width--;\n       line++;\n     }\n   pp_newline (context->printer);"}, {"sha": "cb3a0a09f33d9d5b7d579bcd62b7e03d065e91d9", "filename": "gcc/input.c", "status": "modified", "additions": 88, "deletions": 27, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "patch": "@@ -87,53 +87,114 @@ expand_location_1 (source_location loc,\n   return xloc;\n }\n \n-/* Reads one line from file into a static buffer.  */\n-static const char *\n-read_line (FILE *file)\n+/* This function reads a line that might contain bytes whose value is\n+   zero.  It returns the number of bytes read.  The 'end-of-line'\n+   character found at the end of the line is not contained in the\n+   returned buffer.  Note that this function has been adapted from\n+   getline() and _IO_getdelim() GNU C library functions.  It's been\n+   duplicated here because the getline() function is not necessarily\n+   present on all platforms.\n+\n+   LINEPTR points to a buffer that is to contain the line read.\n+\n+   N points to the size of the the LINEPTR buffer.\n+\n+   FP points to the file to consider.  */\n+\n+static ssize_t\n+get_line (char **lineptr, size_t *n, FILE *fp)\n {\n-  static char *string;\n-  static size_t string_len;\n-  size_t pos = 0;\n-  char *ptr;\n+  ssize_t cur_len = 0, len;\n+  char buf[16384];\n+\n+  if (lineptr == NULL || n == NULL)\n+    return -1;\n \n-  if (!string_len)\n+  if (*lineptr == NULL || *n == 0)\n     {\n-      string_len = 200;\n-      string = XNEWVEC (char, string_len);\n+      *n = 120;\n+      *lineptr = XNEWVEC (char, *n);\n     }\n \n-  while ((ptr = fgets (string + pos, string_len - pos, file)))\n-    {\n-      size_t len = strlen (string + pos);\n+  len = fread (buf, 1, sizeof buf, fp);\n+  if (ferror (fp))\n+    return -1;\n \n-      if (string[pos + len - 1] == '\\n')\n+  for (;;)\n+    {\n+      size_t needed;\n+      char *t = (char*) memchr (buf, '\\n', len);\n+      if (t != NULL) len = (t - buf);\n+      if (__builtin_expect (len >= SSIZE_MAX - cur_len, 0))\n+\treturn -1;\n+      needed = cur_len + len + 1;\n+      if (needed > *n)\n \t{\n-\t  string[pos + len - 1] = 0;\n-\t  return string;\n+\t  char *new_lineptr;\n+\t  if (needed < 2 * *n)\n+\t    needed = 2 * *n;\n+\t  new_lineptr = XRESIZEVEC (char, *lineptr, needed);\n+\t  *lineptr = new_lineptr;\n+\t  *n = needed;\n \t}\n-      pos += len;\n-      string = XRESIZEVEC (char, string, string_len * 2);\n-      string_len *= 2;\n+      memcpy (*lineptr + cur_len, buf, len);\n+      cur_len += len;\n+      if (t != NULL)\n+\tbreak;\n+      len = fread (buf, 1, sizeof buf, fp);\n+      if (ferror (fp))\n+\treturn -1;\n+      if (len == 0)\n+\tbreak;\n     }\n-      \n-  return pos ? string : NULL;\n+\n+  if (cur_len)\n+    (*lineptr)[cur_len] = '\\0';\n+  return cur_len;\n+}\n+\n+/* Reads one line from FILE into a static buffer.  If LINE_LENGTH is\n+ *non-null LINE_LENGTH, will be set by this function to the length of\n+ *the returned line.  Note that the returned line can contain several\n+ *zero bytes.  Also note that the returned string is allocated in\n+ *static storage that is going to be re-used by subsequent invocations\n+ *of read_line.  */\n+static const char *\n+read_line (FILE *file, int *line_length)\n+{\n+  static char *string;\n+  static size_t string_len;\n+  int len;\n+\n+  len = get_line (&string, &string_len, file);\n+  if (line_length)\n+    *line_length = len;\n+  return len ? string : NULL;\n }\n \n /* Return the physical source line that corresponds to xloc in a\n    buffer that is statically allocated.  The newline is replaced by\n-   the null character.  */\n+   the null character.  Note that the line can contain several null\n+   characters, so LINE_LEN, if non-null, points to the actual length\n+   of the line.  */\n \n const char *\n-location_get_source_line (expanded_location xloc)\n+location_get_source_line (expanded_location xloc,\n+\t\t\t  int *line_len)\n {\n-  const char *buffer;\n-  int lines = 1;\n+  const char *buffer = NULL, *ptr;\n+  int lines = 0, len = 0;\n   FILE *stream = xloc.file ? fopen (xloc.file, \"r\") : NULL;\n   if (!stream)\n     return NULL;\n \n-  while ((buffer = read_line (stream)) && lines < xloc.line)\n-    lines++;\n+  while ((ptr = read_line (stream, &len)) && lines < xloc.line)\n+    {\n+      buffer = ptr;\n+      lines++;\n+      if (line_len)\n+\t*line_len = len;\n+    }\n \n   fclose (stream);\n   return buffer;"}, {"sha": "128e28cd942475eeecfd4d376c010481af5051b9", "filename": "gcc/input.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "patch": "@@ -37,7 +37,8 @@ extern char builtins_location_check[(BUILTINS_LOCATION\n \t\t\t\t     < RESERVED_LOCATION_COUNT) ? 1 : -1];\n \n extern expanded_location expand_location (source_location);\n-extern const char *location_get_source_line (expanded_location xloc);\n+extern const char *location_get_source_line (expanded_location xloc,\n+\t\t\t\t\t     int *line_size);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);\n "}, {"sha": "b93ee34822adf42a908dd505e2abb8d667c96d87", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "patch": "@@ -1,3 +1,8 @@\n+2013-11-06  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tpreprocessor/58580\n+\t* c-c++-common/cpp/warning-zero-in-literals-1.c: New test file.\n+\n 2013-11-06  Christian Bruel  <christian.bruel@st.com>\n \n \t* gcc.target/sh/strlen.c: New test."}, {"sha": "ff2ed962ac96e47ae05b0b040f4e10b8e09637e2", "filename": "gcc/testsuite/c-c++-common/cpp/warning-zero-in-literals-1.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c?ref=9789a9127686e1d8d9e99a22bfaea4d2587d2bfd"}]}