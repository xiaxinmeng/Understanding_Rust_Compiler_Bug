{"sha": "09844a5f640d7e881f503859953925ae260a2be8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk4NDRhNWY2NDBkN2U4ODFmNTAzODU5OTUzOTI1YWUyNjBhMmJlOA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2016-10-26T12:54:30Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2016-10-26T12:54:30Z"}, "message": "fix pr78060 pr78061 pr78088\n\n\tPR tree-optimization/78060\n\tPR tree-optimization/78061\n\tPR tree-optimization/78088\n\t* tree-ssa-loop-split.c (easy_exit_values): New function.\n\t(tree_ssa_split_loops): Use it.\n\t(compute_new_first_bound): Change order of operations,\n\tfix invalid use of types.\n\ntestsuite/\n\t* g++.dg/pr78060.C: New test.\n\t* gfortran.dg/pr78061.f: New test.\n\t* g++.dg/pr78088.C: New test.\n\nFrom-SVN: r241551", "tree": {"sha": "66e612c83ccf90f62666ef2ec1bd1157716a86b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66e612c83ccf90f62666ef2ec1bd1157716a86b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09844a5f640d7e881f503859953925ae260a2be8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09844a5f640d7e881f503859953925ae260a2be8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09844a5f640d7e881f503859953925ae260a2be8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09844a5f640d7e881f503859953925ae260a2be8/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ef33d44629066e33ffdc46014374a3ef5c5f009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef33d44629066e33ffdc46014374a3ef5c5f009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef33d44629066e33ffdc46014374a3ef5c5f009"}], "stats": {"total": 130, "additions": 112, "deletions": 18}, "files": [{"sha": "0b537acb64dc6ffef6ff44c5ec969c6da4333052", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -1,3 +1,13 @@\n+2016-10-26  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/78060\n+\tPR tree-optimization/78061\n+\tPR tree-optimization/78088\n+\t* tree-ssa-loop-split.c (easy_exit_values): New function.\n+\t(tree_ssa_split_loops): Use it.\n+\t(compute_new_first_bound): Change order of operations,\n+\tfix invalid use of types.\n+\n 2016-10-26  Georg-Johann Lay  <avr@gjlay.de>\n \n \tgen-pass-instances.awk is sensitive to the order in which"}, {"sha": "a5049cf89cd2d645629aeade38238e3af39e16bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -1,3 +1,9 @@\n+2016-10-26  Michael Matz  <matz@suse.de>\n+\n+\t* g++.dg/pr78060.C: New test.\n+\t* gfortran.dg/pr78061.f: New test.\n+\t* g++.dg/pr78088.C: New test.\n+\n 2016-10-26  Fritz Reese <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_io_1.f90: New test."}, {"sha": "d6cc7b312e5c100156cf7a83c89b97313ebbd01f", "filename": "gcc/testsuite/g++.dg/pr78060.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78060.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78060.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78060.C?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -0,0 +1,14 @@\n+// PR tree-optimization/78060\n+// { dg-do compile }\n+// { dg-options \"-O3 -fsplit-loops\" }\n+class A {\n+public:\n+  template <typename T2> int &operator[](T2);\n+};\n+int a;\n+A b;\n+void fn1() {\n+  long c;\n+  for (int l; l < c; ++l)\n+    b[l] = l < 2 ?: a;\n+}"}, {"sha": "1a5c0636aa37711e2d07c52594c2ff039749a122", "filename": "gcc/testsuite/g++.dg/pr78088.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78088.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78088.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr78088.C?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -0,0 +1,19 @@\n+// PR tree-optimization/78088\n+// { dg-do compile }\n+// { dg-options \"-O3 -fsplit-loops\" }\n+class A {\n+public:\n+  int m_fn1();\n+};\n+struct B : A {\n+  void m_fn2();\n+};\n+void B::m_fn2() {\n+  long a;\n+  int b, c;\n+  for (;;) {\n+    c = 0;\n+    for (; c < a; ++c, ++b)\n+      b > 0 ? m_fn1() : 0;\n+  }\n+}"}, {"sha": "7e4dd3de8b5c331085b0ee0c505fa24be3cb9161", "filename": "gcc/testsuite/gfortran.dg/pr78061.f", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78061.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78061.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78061.f?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fsplit-loops\" }\n+      SUBROUTINE SSYMM(C)\n+      REAL C(LDC,*)\n+      LOGICAL LSAME\n+      LOGICAL UPPER\n+      IF (LSAME) THEN\n+          DO 170 J = 1,N\n+              DO 140 K = 1,J  \n+                  IF (UPPER) THEN\n+                      END IF\n+  140         CONTINUE\n+              DO 160 K = J + 1,N\n+                  C(I,J) = B(K)\n+  160         CONTINUE\n+  170     CONTINUE\n+      END IF\n+      END"}, {"sha": "dac68e6723a6be1146dfad526d953bba283c176a", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09844a5f640d7e881f503859953925ae260a2be8/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=09844a5f640d7e881f503859953925ae260a2be8", "patch": "@@ -190,13 +190,40 @@ find_or_create_guard_phi (struct loop *loop, tree guard_iv, affine_iv * /*iv*/)\n   return NULL;\n }\n \n+/* Returns true if the exit values of all loop phi nodes can be\n+   determined easily (i.e. that connect_loop_phis can determine them).  */\n+\n+static bool\n+easy_exit_values (struct loop *loop)\n+{\n+  edge exit = single_exit (loop);\n+  edge latch = loop_latch_edge (loop);\n+  gphi_iterator psi;\n+\n+  /* Currently we regard the exit values as easy if they are the same\n+     as the value over the backedge.  Which is the case if the definition\n+     of the backedge value dominates the exit edge.  */\n+  for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree next = PHI_ARG_DEF_FROM_EDGE (phi, latch);\n+      basic_block bb;\n+      if (TREE_CODE (next) == SSA_NAME\n+\t  && (bb = gimple_bb (SSA_NAME_DEF_STMT (next)))\n+\t  && !dominated_by_p (CDI_DOMINATORS, exit->src, bb))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* This function updates the SSA form after connect_loops made a new\n    edge NEW_E leading from LOOP1 exit to LOOP2 (via in intermediate\n    conditional).  I.e. the second loop can now be entered either\n    via the original entry or via NEW_E, so the entry values of LOOP2\n    phi nodes are either the original ones or those at the exit\n    of LOOP1.  Insert new phi nodes in LOOP2 pre-header reflecting\n-   this.  */\n+   this.  The loops need to fulfill easy_exit_values().  */\n \n static void\n connect_loop_phis (struct loop *loop1, struct loop *loop2, edge new_e)\n@@ -383,37 +410,37 @@ compute_new_first_bound (gimple_seq *stmts, struct tree_niter_desc *niter,\n \t\t\t    TREE_TYPE (controlbase),\n \t\t\t    controlbase, controlstep);\n \n-  /* Compute beg-guard_init.  */\n+  /* Compute end-beg.  */\n+  gimple_seq stmts2;\n+  tree end = force_gimple_operand (niter->bound, &stmts2,\n+\t\t\t\t\ttrue, NULL_TREE);\n+  gimple_seq_add_seq_without_update (stmts, stmts2);\n   if (POINTER_TYPE_P (TREE_TYPE (enddiff)))\n     {\n-      tree tem = gimple_convert (stmts, sizetype, guard_init);\n+      tree tem = gimple_convert (stmts, sizetype, enddiff);\n       tem = gimple_build (stmts, NEGATE_EXPR, sizetype, tem);\n       enddiff = gimple_build (stmts, POINTER_PLUS_EXPR,\n \t\t\t      TREE_TYPE (enddiff),\n-\t\t\t      enddiff, tem);\n+\t\t\t      end, tem);\n     }\n   else\n     enddiff = gimple_build (stmts, MINUS_EXPR, TREE_TYPE (enddiff),\n-\t\t\t    enddiff, guard_init);\n+\t\t\t    end, enddiff);\n \n-  /* Compute end-(beg-guard_init).  */\n-  gimple_seq stmts2;\n-  tree newbound = force_gimple_operand (niter->bound, &stmts2,\n-\t\t\t\t\ttrue, NULL_TREE);\n-  gimple_seq_add_seq_without_update (stmts, stmts2);\n-\n-  if (POINTER_TYPE_P (TREE_TYPE (enddiff))\n-      || POINTER_TYPE_P (TREE_TYPE (newbound)))\n+  /* Compute guard_init + (end-beg).  */\n+  tree newbound;\n+  enddiff = gimple_convert (stmts, TREE_TYPE (guard_init), enddiff);\n+  if (POINTER_TYPE_P (TREE_TYPE (guard_init)))\n     {\n       enddiff = gimple_convert (stmts, sizetype, enddiff);\n       enddiff = gimple_build (stmts, NEGATE_EXPR, sizetype, enddiff);\n       newbound = gimple_build (stmts, POINTER_PLUS_EXPR,\n-\t\t\t       TREE_TYPE (newbound),\n-\t\t\t       newbound, enddiff);\n+\t\t\t       TREE_TYPE (guard_init),\n+\t\t\t       guard_init, enddiff);\n     }\n   else\n-    newbound = gimple_build (stmts, MINUS_EXPR, TREE_TYPE (enddiff),\n-\t\t\t     newbound, enddiff);\n+    newbound = gimple_build (stmts, PLUS_EXPR, TREE_TYPE (guard_init),\n+\t\t\t     guard_init, enddiff);\n \n   /* Depending on the direction of the IVs the new bound for the first\n      loop is the minimum or maximum of old bound and border.\n@@ -449,7 +476,6 @@ compute_new_first_bound (gimple_seq *stmts, struct tree_niter_desc *niter,\n \t\t\t       build_int_cst (type2, addbound));\n     }\n \n-  newbound = gimple_convert (stmts, TREE_TYPE (border), newbound);\n   tree newend = gimple_build (stmts, minmax, TREE_TYPE (border),\n \t\t\t      border, newbound);\n   return newend;\n@@ -615,6 +641,7 @@ tree_ssa_split_loops (void)\n \t     original exit before.  */\n \t  && empty_block_p (loop->latch)\n \t  && !optimize_loop_for_size_p (loop)\n+\t  && easy_exit_values (loop)\n \t  && number_of_iterations_exit (loop, single_exit (loop), &niter,\n \t\t\t\t\tfalse, true)\n \t  && niter.cmp != ERROR_MARK"}]}