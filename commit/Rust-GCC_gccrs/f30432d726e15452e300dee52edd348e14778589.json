{"sha": "f30432d726e15452e300dee52edd348e14778589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwNDMyZDcyNmUxNTQ1MmUzMDBkZWU1MmVkZDM0OGUxNDc3ODU4OQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-10-12T02:33:51Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-10-12T02:33:51Z"}, "message": "75th Cygnus<->FSF merge\n\nFrom-SVN: r10438", "tree": {"sha": "c55b3eb88f5961c3b44da3a913de51995aba4868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55b3eb88f5961c3b44da3a913de51995aba4868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f30432d726e15452e300dee52edd348e14778589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30432d726e15452e300dee52edd348e14778589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f30432d726e15452e300dee52edd348e14778589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30432d726e15452e300dee52edd348e14778589/comments", "author": null, "committer": null, "parents": [{"sha": "c35836203ca446bb56832d320c406b79816280f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c35836203ca446bb56832d320c406b79816280f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c35836203ca446bb56832d320c406b79816280f8"}], "stats": {"total": 6478, "additions": 3973, "deletions": 2505}, "files": [{"sha": "c00f2937ff833d4129f58836f74a462ed1ad7240", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 861, "deletions": 25, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -1,21 +1,327 @@\n+Wed Oct 11 12:20:56 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (envelope_add_decl): New routine.  Fix so that\n+\tmethods are hidden in the same way that other members are.\n+\t(dfs_pushdecls): Cleanup and move functionality out of line,\n+\tinto envelope_add_decl. \n+\n+Tue Oct 10 15:46:01 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (mark_addressable): Only call assemble_external if we\n+\thave started the output file.\n+\n+Tue Oct 10 11:27:18 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (start_function): Fix earlier cv-quals change.\n+\n+Mon Oct  9 23:53:05 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (complex_direct_notype_declarator): Only push the class if\n+\twe are not already in the class.\n+\n+Mon Oct  9 11:22:03 1995  Doug Evans  <dje@canuck.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Call merge_machine_decl_attributes.\n+\tUpdate olddecl's attributes too.\n+\t(grokdeclarator): #if 0 out call to build_decl_attribute_variant.\n+\t* typeck.c (common_type): Call merge_machine_type_attributes.\n+\n+Fri Oct  6 14:44:27 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (mark_addressable): Add missing call to\n+\tassemble_external.\n+\n+Wed Oct  4 22:05:23 1995  Jeff Law  (law@hurl.cygnus.com\n+\n+\t* cp/decl.c (deplicate_decls): Merge in deferred output\n+\tstatus for variables.\n+\t* cp/tree.c (tree_copy_lang_decl_for_deferred_output): New\n+\tfunction to copy the g++ specific parts of a DECL node.\n+\t(tree_copy_lang_type_for_deferred_output): Similarly for\n+\tTYPE nodes.\n+\n+Wed Oct  4 15:06:39 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (store_parm_decls): Make sure the unwinder start comes\n+\tbefore the exception specification start.\n+\t* except.c (expand_exception_blocks): Make sure the unwinder end\n+\tcomes after the terminate protected catch clause region and after\n+\tthe end of the exception specification region.\n+\n+Wed Oct  4 12:47:02 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (real_yylex): Fix identifier case for linemode.\n+\t(handle_sysv_pragma): Don't abort when we see a pragma we don't\n+\trecognize.\n+\n+Tue Oct  3 14:09:46 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (store_parm_decls): Add a call to start_eh_unwinder.\n+\t* except.c (init_exception_processing): __throw doesn't take any\n+\targuments.\n+\t(expand_builtin_throw): Ditto.  Always use Pmode, instead of SImode\n+\tfor all pointers.  Use expand_builtin_return_addr to unwind the\n+\tfirst level off the stack.\n+\t(do_unwind): Always use Pmode, instead of SImode for all pointers.\n+\t(expand_exception_blocks): Add a call to end_eh_unwinder.\n+\t(start_eh_unwinder, end_eh_unwinder): New routines to build machine\n+\tindependent stack unwinders for function/method calls.\n+\t\n+Mon Oct  2 17:20:42 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* tree.c (unsave_expr_now): Make sure we process the argument list\n+\tof any called functions.  Fixes incorrect code generation for\n+\tcleanups.\n+\n+Mon Oct  2 13:04:16 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Save function if it\n+\tneeds it.  Cures core dump on things like (this->*(f()))().\n+\n+Sat Sep 23 22:51:25 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_function): Conform to gcc cv-quals convention (no\n+\texpression has a cv-qualified type) in RESULT_DECLs.\n+\t* method.c (make_thunk): Ditto.\n+\n+Fri Sep 22 10:21:13 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (pushtag): Add in the namespace name for the tag.\n+\n+Thu Sep 21 13:11:13 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (maybe_base_class_list, base_class_list, base_class,\n+\tbase_class_access_list): Make sure we see the typenames for base\n+\tclasses.\n+\t* lex.c (see_typename): Instead of failing to see a typename when\n+\tthere is no next token, perfer a typename, and get the next token.\n+\n+Wed Sep 20 12:35:27 1995  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* decl.c (init_decl_processing): Add __builtin_expect.\n+\n+Tue Sep 19 16:48:11 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Don't allow leftover conversions to\n+\tor from pointer to member functions, they must all be handled before\n+\tthis point.\n+\n+Fri Sep 15 17:14:47 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Fix wording of non-static member\n+\tbeing referenced as a static.\n+\n+Fri Sep 15 12:39:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_indirect_ref): Only bash pointer if we actually\n+\tcall build_expr_type_conversion.\n+\n+Thu Sep 14 18:24:56 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* cvt.c (build_expr_type_conversion): Handle conversion from\n+\treference.\n+\t* typeck.c (build_indirect_ref): Avoid infinite recursion.\n+\n+Thu Sep 14 17:23:28 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (expand_start_early_try_stmts): New routine to start a try\n+\tblock at the start of the function, for function-try-blocks.\n+\t* cp-tree.h (expand_start_early_try_stmts): Declare it.\n+\t* parse.y (function_try_block): Use it, instead of doing it here, as\n+\twe don't want to include rtl.h here, as that conflicts with RETURN\n+\tin the parser.\n+\n+Wed Sep 13 18:32:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* lex.c (reinit_parse_for_block): Support saving inline\n+\tfunction-try-blocks, uses peekyylex.\n+\t* parse.y (eat_saved_input): New rule, permit the parser to see that\n+\tEND_OF_SAVED_INPUT is ok, as it can see this when parsing the\n+\thandlers of a function-try-block.\n+\t(fndef): Use it.\n+\t(component_decl): Make sure TRY and RETURN can come after fn.def2.\n+\t* spew.c (peekyylex): New routine to peek at what will come next.\n+\n Wed Sep 13 16:52:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n+\t* typeck.c (comptypes): Tighten up comparisons of template type\n+ \tparms.\n+\n \t* decl.c (duplicate_decls): Turn off whining about virtual functions\n \tredeclared inline for now.\n \n+Wed Sep 13 11:13:40 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (store_in_parms): New routine to put things before we\n+\tput base inits.\n+\t* cp-tree.h (store_in_parms): Declare it.\n+\t* decl.c (store_parm_decls): Use it to makr sure the starting of the\n+\teh spec comes before base inits.\n+\t(finish_function): Use sequences instead of the obsolete\n+\treorder_insns.\n+\t* parse.y (fndef): Enhance readability and maintainability.  Update\n+\tto include function_try_block syntax.\n+\t(function_try_block): Add.\n+\n+Tue Sep 12 17:43:07 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* call.c (convert_harshness): Use comptypes, not ==, to check if\n+\tTYPE and PARMTYPE are equivalent on a function type.\n+\n Tue Sep 12 17:31:33 1995  Douglas Rupp  (drupp@cs.washington.edu)\n \n \t* Make-lang.in (cc1plus) : Removed unnecessary $(exeext).\n \n+Mon Sep 11 23:24:07 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Never allocate storage for thrown pointer\n+\tto objects.\n+\n+Mon Sep 11 19:36:45 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_start_catch_block): Pointers to objects come\n+\tback from catch matching already dereferenced, don't dereference\n+\tagain.\n+\n+Mon Sep 11 15:46:28 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Only decay the throw expression, don't do\n+\tany default conversions.  This is so that one can throw and catch\n+\tcharacters, and not have them match integers.\n+\n+Mon Sep 11 13:46:45 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* error.c (dump_aggr_type): Deal with anonymous unions that don't\n+\thave a TYPE_NAME.\n+\n Fri Sep  8 20:40:27 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* lex.c (handle_sysv_pragma): Deal with getting a comma from yylex.\n \n+Fri Sep  8 15:51:41 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_end_eh_spec): Handle empty EH specifications.\n+\n+Fri Sep  8 15:27:22 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (expand_start_eh_spec): Declare new routine.\n+\t(expand_end_eh_spec): Ditto.\n+\t* decl.c (store_parm_decls): Call expand_start_eh_spec to process\n+\texception specifications.\n+\t* except.c (expand_leftover_cleanups): Remove unused parameter.\n+\t(expand_end_catch_block): Ditto.\n+\t(expand_exception_blocks): Ditto.\n+\t(expand_start_eh_spec): New routine to mark the start of an\n+\texception specification region.\n+\t(expand_end_eh_spec): New routine to mark the end of an exception\n+\tspecification region.\n+\t(expand_exception_blocks): Call expand_end_eh_spec to process\n+\texception specifications.\n+\n Fri Sep  8 14:40:48 1995  Per Bothner  <bothner@kalessin.cygnus.com>\n \n \t* lex.c (do_identifier):  Use global binding in preference of\n \tdead for local variable.\n \n+Wed Sep  6 19:32:59 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (build_exception_variant): Remove used first argument.\n+\t* decl.c (duplicate_decls): Ditto.\n+\t(grokfndecl): Ditto.\n+\t(revert_static_member_fn): Ditto.\n+\t* decl2.c (grok_method_quals): Ditto.\n+\t* tree.c (build_exception_variant): Ditto.\n+\t* typeck.c (common_type): Ditto.\n+\t* decl2.c (grokclassfn): After changing the type, call\n+\tbuild_exception_variant, if necessary.\n+\n+Tue Sep  5 15:56:27 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Run cleanups for the throw expression.\n+\n+Wed Aug 30 15:24:38 1995  Stephen L. Favor  (sfavor@tigger.intecom.com)\n+\n+\t* except.c (expand_builtin_throw): Moved gen_label_rtx calls beyond\n+\tthe store_parm_decls call which does initialization in the emit_*\n+\tcode concerning label numbering.\n+\t\n+Thu Aug 31 09:01:07 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_internal_throw): Let the frontend be responsible\n+\tfor managing all frontend EH parameters, the backend routine only\n+\tneeds to deal with backend values.  type and value are no longer\n+\tpassed to __throw.\n+\t(init_exception_processing): Ditto.\n+\t(expand_start_all_catch): Ditto.\n+\t(expand_end_all_catch): Ditto.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(expand_end_catch_block): Ditto.\n+\t(expand_builtin_throw): Ditto.\n+\t(expand_throw): Ditto.\n+\t\n+Tue Aug 29 15:04:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cp-tree.h (DECL_REAL_CONTEXT): Give the real declaration context\n+\tfor a decl.\n+\t* decl.c (cp_finish_decl): Use it.\n+\n+Tue Aug 29 10:30:27 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_internal_throw): Oops, almost forgot type and\n+\tvalue are now trees.\n+\n+Mon Aug 28 17:57:45 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tFix the attribute handling to make sure they get noted before we\n+\tcreate the function's RTL, in case they can affect that.\n+\t* decl.c (grokfndecl): New arg ATTRLIST.  Run\n+\tcplus_decl_attributes before creating the decl's rtl.\n+\t(grokdeclarator): New arg ATTRLIST, passed down into grokfndecl.\n+\t(shadow_tag, groktypename, start_decl, start_method): Pass a\n+\tNULL_TREE to grokdeclarator's new last arg.\n+\t* decl2.c (grokfield): New arg ATTRLIST, passed into grokdeclarator.\n+\t(grokbitfield, grokoptypename): Pass a NULL_TREE to\n+\tgrokdeclarator's new last arg.\n+\t* except.c (expand_start_catch_block): Likewise.\n+\t* pt.c (process_template_parm, end_template_decl,\n+\tdo_function_instantiation): Likewise.\n+\t* cp-tree.h (grokfield): Add arg.\n+\t(grokdeclarator): Move the prototype from here...\n+\t* decl.h: ...to here.\n+\t* lex.c (cons_up_default_function): Pass NULL_TREE to grokfield\n+\tATTRLIST argument.\n+\t* parse.y: Create a list for the grokfield arg where appropriate,\n+\tand pass it down instead of calling cplus_decl_attributes.\n+\n+Mon Aug 28 15:07:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Always allow turning on exception handling.  Allow cross\n+\tcompilations to use EH.\n+\n+Thu Aug 24 17:39:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (saved_pc, saved_throw_type, saved_throw_value): Use\n+\ttrees, instead of rtxs, and don't depend on using special machine\n+\tdependent registers.\n+\t(expand_internal_throw): Ditto.\n+\t(init_exception_processing): Ditto.\n+\t(expand_start_all_catch): Ditto.\n+\t(expand_end_all_catch): Ditto.\n+\t(expand_start_catch_block): Ditto.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(expand_end_catch_block): Ditto.\n+\t(expand_builtin_throw): Ditto.\n+\t(expand_throw): Ditto.\n+\n+Wed Aug 23 17:25:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (build_expr_type_conversion): Handle conversions to\n+\treference types.\n+\n+Wed Aug 23 15:33:59 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (do_unwind): Work around backend bug with -fpic.\n+\n Tue Aug 22 17:20:07 1995  Per Bothner  <bothner@kalessin.cygnus.com>\n \n \t* decl2.c (flag_new_for_scope):  Add a new mode that follows ANSI\n@@ -33,7 +339,379 @@ Tue Aug 22 17:20:07 1995  Per Bothner  <bothner@kalessin.cygnus.com>\n \tand warn if conflicts.\n \t* parse.y (FOR):  Call note_level_for_for.\n \n-Wed Jul 19 11:49:57 1995  Gerald Baumgartner  <gb@alexander.cs.purdue.edu>\n+Mon Aug 21 10:28:31 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* decl2.c (import_export_inline): Class interface hackery does not\n+\tapply to synthesized methods.\n+\n+Sun Aug 20 16:29:00 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (virtual_context): Find the right context more often.\n+\tSolves a `recoverable compiler error, fixups for virtual function'\n+\tproblem.\n+\n+Sun Aug 20 13:53:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_start_all_catch): Ensure that we always transfer\n+\tcontrol to the right EH handler, by rethrowing the end label on the\n+\tregion, instead of hoping we are nested and falling through.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(end_protect): Since we now rethrow the end label, put a\n+\tnop after it, so that outer regions are recognized.\n+\t* init.c (build_vec_delete_1): New routine to handle most of vector\n+\tdeleting, all code moved here from build_vec_delete.\n+\t(build_array_eh_cleanup): Use build_vec_delete_1 to do all the real\n+\twork.\n+\t(expand_vec_init): If the array needs partial destructing, setup an\n+\tEH region to handle it.\n+\t(build_vec_delete): Move lots of code to build_vec_delete_1, use\n+\tbuild_vec_delete_1 to do the grunt work.\n+\t\n+Sat Aug 19 14:25:33 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tHandle decl attributes properly for function definitions without\n+\tprevious attribute-loaded declarations.\n+\t* decl.c (start_function): New arg ATTRS.  Add a call to\n+\tcplus_decl_attributes with it before we create the RTL.\n+\t* cp-tree.h (start_function): Update prototype.\n+\t* parse.y (fn.def1): Pass ATTRS into start_function instead of\n+\ttrying to call cplus_decl_attributes too late.  Pass a NULL_TREE\n+\tfor other use.\n+\t* decl2.c (finish_file): Pass NULL_TREE as fourth arg to\n+\tstart_function.\n+\t* method.c (synthesize_method): Likewise.\n+\t* except.c (expand_builtin_throw): Likewise for start on __throw.\n+\n+Sat Aug 19 13:36:08 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (set_rtti_entry): Turn on -fvtable-thunk -frtti support.\n+\tThis changes -fvtable-thunks vtable layout, so a recompile will be\n+\tnecessary, if you use -fvtable-thunks.\n+\t(get_vtable_entry): Use n, instead of i to be consistent with the\n+\trest of the compiler.\n+\t(get_vtable_entry_n): Ditto.\n+\t(add_virtual_function): Add a slot for the tdesc, if -fvtable-thunks\n+\tare being used.\n+\t(finish_struct_1): Ditto.\n+\t(skip_rtti_stuff): New routine to collapse similar code from many\n+\tdifferent parts of the compiler.  I think I got them all.\n+\t(modify_one_vtable): Use it.\n+\t(fixup_vtable_deltas1): Ditto.\n+\t(override_one_vtable): Ditto.\n+\t* decl2.c (mark_vtable_entries): Ditto.\n+\t* tree.c (debug_binfo): Ditto.\n+\t* search.c (expand_upcast_fixups): Ditto.\n+\t(get_abstract_virtuals_1): Ditto.  Use virtuals, instead of tmp to\n+\tconsistent with the rest of the compiler.\n+\t(get_abstract_virtuals): Ditto.\n+\t* cp-tree.h (skip_rtti_stuff): New routine, declare it.\n+\t* gc.c (build_headof): Support -fvtable-thunk and -frtti together.\n+\t(build_typeid): Ditto.\n+\t(build_classof): Remove old style way of doing rtti.  Remove support\n+\tfor `classof' and `headof'.\n+\t* gxx.gperf: Ditto.\n+\t* hash.h: Ditto.\n+\t* parse.y: Ditto.\n+\n+Fri Aug 18 17:31:58 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* decl.c (start_function): Clear ctor_label and dtor_label.\n+\n+\t* class.c (finish_struct_1): Fix handling of access decls.\n+\n+Tue Aug 15 19:21:54 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct): Only do minimal processing here, so it\n+\tcan be used for class template definitions, as well.\n+\t(finish_struct_1): New function with the rest of the code.\n+\n+Tue Aug 15 09:46:16 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (prepare_fresh_vtable): On second though, always build the\n+\toffset (see Aug 10 change), unless -fvtable-thunks is given.  It\n+\tdoes this by calling the new routine set_rtti_entry.\n+\t(finish_struct): Ditto.\n+\t(set_rtti_entry): New routine to update the rtti information at the\n+\tstart of the vtable.\n+\n+Mon Aug 14 12:21:22 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* error.c (dump_decl, case IDENTIFIER_NODE): Only work on a dtor\n+\tif it's declared in the C++ language spec.\n+\t(dump_function_decl): Likewise.\n+\t(dump_function_name): Likewise.\n+\t(ident_fndecl): Make sure we got something back from lookup_name.\n+\t* decl.c (start_function): Likewise.\n+\n+Fri Aug 11 16:52:15 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Don't call build_new when calling a\n+\tconstructor without an instance.\n+\n+Thu Aug 10 20:00:17 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (prepare_fresh_vtable): Always build the offset to the\n+\tcomplete object, as it doesn't cost much.  This allows dynamic_cast\n+\tto void * to work when -frtti isn't given.\n+\t(finish_struct): Ditto.\n+\n+Thu Aug 10 16:31:28 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (build_eh_type): Split out some functionality to new\n+\troutine named build_eh_type_type.\n+\t(build_eh_type_type): New routine.\n+\t(expand_start_catch_block): Use build_eh_type_type, as we never want\n+\tthe dynamic type of the catch parameter, just the static type.\n+\tFixes core dumps when -frtti is used and one catchs pointers to\n+\tclasses.\n+\n+Thu Aug 10 14:55:29 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_builtin_throw): Since we now use normal calling\n+\tconventions for __throw, we have to remove the first layer off the\n+\tstack, so that the next context we search for handlers is the outer\n+\tcontext instead of the context that had the call to __throw, if we\n+\tdon't immediately find the desired context.\n+\n+Tue Aug  8 17:44:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* tree.c (cp_expand_decl_cleanup): Returns int, not tree.\n+\t* cp-tree.h: Update.\n+\n+\t* parse.y (template_type_parm): Add support for `typename'.\n+\n+Tue Aug  8 12:06:31 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_internal_throw): New internal routine to throw a\n+\tvalue.\n+\t(expand_end_all_catch, expand_leftover_cleanups): All throwers\n+\tchanged to use `expand_internal_throw' instead of jumping to throw\n+\tlabel.\n+\t(expand_end_catch_block, expand_throw): Ditto.\n+\t(throw_label): Removed.\n+\t(expand_builtin_throw): Changed so that EH parameters are passed by\n+\tnormal function call conventions.  Completes Aug 4th work.\n+\n+Fri Aug  4 17:17:08 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (expand_builtin_throw): Declare it.\n+\t* decl2.c (finish_file): Call expand_builtin_throw.\n+\t* except.c (make_first_label): Remove.\n+\t(init_exception_processing): Don't use a LABEL_REF for throw_label,\n+\tinstead use a SYMBOL_REF, this is so that we don't use LABEL_REFs in\n+\tother functions that don't really appear in those functions.  This\n+\tsolves a problem where cc1plus consumed exponential amounts of\n+\tmemory when -Wall was used.\n+\t(expand_end_all_catch, expand_leftover_cleanups,\n+\texpand_end_catch_block, expand_throw): Change all uses of\n+\tthrow_label to match new style.\n+\t(do_unwind): Rename parameter to inner_throw_label, as it is now\n+\tdifferent from throw_label.  Also, assume that our caller will wrap\n+\tthe passed label with a LABEL_REF, if needed.\n+\t(expand_builtin_throw): Make external, change so that the generated\n+\tthrow is now a real function.\n+\t(expand_exception_blocks): Never generate throw code inside another\n+\tfunction.\n+\n+Fri Aug  4 12:20:02 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Move checking of mutable const objects\n+\tand mutable static objects down, as we might decide during parsing\n+\tto unset staticp or constp (for example, when const is part of the\n+\tobject being pointed to).\n+\n+Thu Aug  3 17:13:43 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (output_exception_table_entry): Enhance portability to\n+\tweird machines.\n+\t(emit_exception_table): Ditto.\n+\n+Thu Aug  3 16:41:38 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_ptrmemfunc): Handle casting of pointer to\n+\tnon-virtual member functions.\n+\n+Wed Aug  2 11:58:25 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_typeid): Strip cv qualifiers so that const T&, T&, T\n+\tand const T all match.\n+\n+Wed Aug  2 11:25:33 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (build_eh_type): Strip cv qualifiers so that const T&,\n+\tT&, T and const T all match.\n+\n+Tue Aug  1 14:20:16 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Fix up comments, cleanup code and eliminate\texceptNode,\n+\texceptStack, exceptstack, push_except_stmts, pop_except_stmts,\n+\tnew_except_stack, push_last_insn, pop_last_insn, insn_save_node and\n+\tInsnSave.  Also, numerous speed improvements, and correctness\n+\timprovements.  Double faulting in all situations should now be\n+\thandled correctly.\n+\t(expand_start_all_catch): Instead of having many terminate protected\n+\tregions, just have one.\n+\t(expand_start_catch_block): No longer have to protect\n+\tfalse_label_rtx, as it isn't used for EH region marking.\n+\t(expand_end_catch_block): Expand out EH cleanups here by using\n+\texpand_leftover_cleanups.\n+\t(expand_end_all_catch): Use sequences instead of playing with insn\n+\tlinks directly.\n+\t(expand_exception_blocks): Ditto.  Also protect all catch clauses\n+\twith one terminate region.\n+\n+Mon Jul 31 13:24:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* method.c (report_type_mismatch): Don't talk about an object\n+\tparameter for non-methods.\n+\n+Sun Jul 30 13:13:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct): Catch private and protected members of\n+\tanonymous unions here.\n+\t* decl2.c (finish_anon_union): And here.\n+\t* parse.y: Instead of here.\n+\n+\t* errfn.c (ARGSLIST): Support passing four args.\n+\t* error.c (cv_as_string): New function.\n+\t(cp_printers): Add it.\n+\t* call.c (build_method_call): Report 'const' at end of pseudo-decl.\n+\n+\t* method.c (report_type_mismatch): Deal with a bad_arg of 0.\n+\n+\t* init.c (expand_aggr_init): Handle volatile objects, too.\n+\n+Sat Jul 29 13:42:03 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (struct binding_level): Keep list of incomplete decls.\n+\t(print_binding_level): Use list_length to count them.\n+\t(pushdecl): Build up the list.\n+\t(hack_incomplete_structures): Walk it and prune completed decls.\n+\n+Fri Jul 28 15:26:44 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (comp_target_types): Don't check const and volatile for\n+\tfunction types.\n+\t(comp_ptr_ttypes_real): Ditto.\n+\n+Thu Jul 27 15:40:48 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (comp_target_types): Fix.\n+\n+Thu Jul 27 15:10:48 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (unsave_expr_now, build_unsave_expr,\n+\tcp_expand_decl_cleanup): Declare new routines.\n+\t* decl.c (cp_finish_decl, store_parm_decls,\n+\thack_incomplete_structures): Change all cals from\n+\texpand_decl_cleanup to cp_expand_decl_cleanup.\n+\t* gc.c (protect_value_from_gc): Ditto.\n+\t* expr.c (cplus_expand_expr): Handle UNSAVE_EXPRs.\n+\t* tree.c (unsave_expr): New routine to build an UNSAVE_EXPR.\n+\t(unsave_expr_now): Backend routine used by tree expander.\n+\t(cp_expand_decl_cleanup): Wrap second argument in an UNSAVE_EXPR to\n+\twork around a limitation in the backend.  The backend uses the\n+\tcleanups multiple times, on disjoint control flows, so we cannot\n+\tpass unsaved SAVE_EXPRs to the backend.\n+\t* tree.def (UNSAVE_EXPR): New tree code.\n+\t* typeck.c (c_expand_return): Move goto/return code up inside\n+\tconditional, as we don't always want to do this, we only want to do\n+\tthis when we don't otherwise finish with this control flow.\n+\n+Thu Jul 27 10:38:43 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (typespec): Only complain about typeof if we're not\n+\tgetting it from a system header.\n+\n+Thu Jul 27 10:26:23 1995  Doug Evans  <dje@canuck.cygnus.com>\n+\n+\tClean up prefix attribute handling.\n+\t* parse.y (reserved_declspecs): Link prefix attributes with declspecs.\n+\t(declmods): Likewise.\n+\t(all rules that reference typed_declspecs and declmods): Call\n+\tsplit_specs_attrs or strip_attrs to separate declspecs and attrs.\n+\t(lang_extdef): Delete resetting of prefix_attributes.\n+\t(template_def, notype_declarator rule): Use NULL_TREE for\n+\tprefix_attributes.\n+\t(condition): Use NULL_TREE for prefix_attributes.\n+\t(setattrs): Deleted.\n+\t(nomods_initdcl0): Set prefix_attributes to NULL_TREE.\n+\t(component_decl): Delete resetting of prefix_attributes.\n+\t(component_decl_1, notype_components rule): Use NULL_TREE for\n+\tprefix_attributes.\n+\t(simple_stmt): Delete resetting of prefix_attributes.\n+\n+Mon Jul 24 13:37:53 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (convert_harshness): Deal with reference conversions before\n+\tothers.  Actually do array->pointer decay.  Call comp_target_types\n+\twith pointer types rather than their targets.\n+\n+\t* typeck.c (comp_target_types): Avoid assigning D const * to B *.\n+\n+Mon Jul 24 08:54:46 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* pt.c (to_be_restored): Move decl to global scope.\n+\n+Sat Jul 22 12:22:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_decl): Put back clearing of DECL_IN_AGGR_P.\n+\n+Fri Jul 21 17:09:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Downgrade error about 'extern int A::i'\n+\tto pedwarn.\n+\n+\t* pt.c (instantiate_template): Also avoid instantiation if the\n+\tfunction has already been declared to be a specialization.\n+\n+\t* decl2.c (check_classfn): Ignore cname argument, and return the\n+\tmatching function.\n+\n+\t* decl.c (start_decl): Handle declarations of member functions\n+\toutside of the class (i.e. specialization declarations).\n+\n+Thu Jul 20 10:34:48 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct): Don't mess with the type of bitfields.\n+\n+\t* various.c: s/TYPE_POINTER_TO/build_pointer_type/.\n+\n+Thu Jul 20 01:43:10 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (expand_aggr_init): Assume LOOKUP_ONLYCONVERTING if init\n+\tis not a parameter list (TREE_LIST).\n+\t(expand_default_init): If LOOKUP_ONLYCONVERTING is set, then set\n+\tLOOKUP_NO_CONVERSION so that we don't allow two-level conversions,\n+\tbut don't set it otherwise.\n+\n+Wed Jul 19 20:32:01 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (expand_default_init): Don't allow two-level conversions\n+\tduring construction.\n+\n+Wed Jul 19 18:06:37 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_headof): The type of dyncasting to a pointer to cv\n+\tvoid, should be pointer to cv void.\n+\n+Wed Jul 19 17:25:43 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_dynamic_cast): Allow casting in const.\n+\n+Wed Jul 19 16:34:27 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_const_cast): If we are passed error_mark_node,\n+\treturn it.\n+\n+Wed Jul 19 15:24:48 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* class.c (push_nested_class): Make sure TYPE is non-nil.\n+\n+\t* cvt.c (type_promotes_to): Watch for error_mark_node on the\n+\tincoming TYPE.\n+\n+Wed Jul 19 13:23:12 1995  Gerald Baumgartner  <gb@alexander.cs.purdue.edu>\n \n \t* cp-tree.h (SIGTABLE_VT_OFF_NAME): Renamed from SIGTABLE_OFFSET_NAME.\n \t(SIGTABLE_VB_OFF_NAME): New macro.\n@@ -58,34 +736,192 @@ Wed Jul 19 11:49:57 1995  Gerald Baumgartner  <gb@alexander.cs.purdue.edu>\n \t* decl.c (init_decl_processing): Align sigtable_entry_type on word\n \tboundaries instead of double word boundaries to save space.\n \n+Tue Jul 18 16:58:37 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert): Always call build_cplus_new for a ctor.\n+\n+Tue Jul 18 14:24:53 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (opt.component_decl_list): Only forbid private/protected\n+\tin anonymous unions.  We need to make this know when the type is\n+\tdefined for an object, to not give the error.\n+\n+Mon Jul 17 14:22:44 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (opt.component_decl_list): Don't allow access control\n+\tas private or protected for union members.\n+\n+Sun Jul 16 14:01:00 1995  Jim Wilson  <wilson@chestnut.cygnus.com>\n+\n+\t* lex.c (check_newline): For 'p' case, move goto skipline line to\n+\tbefore end brace for 'pragma'.\n+\n+Fri Jul  7 13:55:58 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* g++.1: Tiny updates.\n+\n+Fri Jul  7 13:05:20 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (cp_finish_decl): Only destruct local static variables if\n+\tthey are constructed, and only construct the first time control\n+\tpasses completely through its declaration (if not initialized with a\n+\tconstant-expression).\n+\t(expand_static_init): Ditto.\n+\n+Wed Jul  5 14:05:04 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* typeck.c (comptypes, case OFFSET_REF): If either offset basetype\n+\tis a TEMPLATE_TYPE_PARM, give a match.\n+\n+Mon Jul  3 15:17:20 1995  Steve Chamberlain  <sac@slash.cygnus.com>\n+\n+\t* g++.c (sys/file.h): Remove change of Jun 28.\n+\n+Fri Jun 30 15:42:57 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* method.c (build_overload_value): Handle encoding of null pointer\n+\tconstants (or any pointer with a constant numeric value) for\n+\ttemplates.\n+\n Fri Jun 30 13:45:51 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* call.c (convert_harshness): Add QUAL_CODE when we're faced with\n \tconst vs non-const for void conversions.\n \n+Fri Jun 30 10:19:52 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_start_all_catch): Fix problem with finding an\n+\touter nested try block when there is no code to separate it from an\n+\tinner try block.\n+\n+Fri Jun 30 02:22:26 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (dfs_pushdecls): Consume 2 or 3 orders of magnitude less\n+\tmemory please when virtual bases are used.\n+\n+Thu Jun 29 19:03:47 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (build_vbase_path): Avoid testing things that cannot be\n+\tnull to see if they are null.\n+\t* cvt.c (convert_pointer_to_vbase): Remove code that doesn't work.\n+\t* decl.c (finish_function): Pass a type into the new\n+\tconvert_pointer_to_vbase instead of a binfo.\n+\t* search.c (convert_pointer_to_vbase): Rewritten to use get_vbase\n+\tand convert_pointer_to_real.\n+\t(expand_indirect_vtbls_init): Use convert_pointer_to_vbase instead\n+\tof the more cryptic call to get_vbase.\n+\n Thu Jun 29 09:35:05 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (BOOL_TYPE_SIZE): Fix broken SLOW_BYTE_ACCESS check.\n \n+Thu Jun 29 03:43:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (instantiate_template): Don't strip 'this' twice.\n+\n+\t* pt.c (coerce_template_parms): Allow null pointer constants.\n+\n+\t* decl.c (revert_static_member_fn): But only if DECL_ARGUMENTS is\n+\tset.\n+\n+Wed Jun 28 23:34:58 1995  Steve Chamberlain  <sac@slash.cygnus.com>\n+\n+\t* g++.c (pfatal_with_name):  Use my_strerror to get error\n+\tstring.\n+\t(sys/file.h): Include if HAVE_FILE_H defined.\n+\n+Wed Jun 28 18:39:03 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (revert_static_member_fn): Also remove 'this' from\n+\tDECL_ARGUMENTS.\n+\t* decl2.c (check_classfn): Don't revert this function until we get a\n+\tmatch.\n+\n+Wed Jun 28 14:07:27 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (component_decl): Clear PREFIX_ATTRIBUTES here.\n+\n+Wed Jun 28 11:05:13 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_file): Handle global vector news.\n+\t* init.c (build_new): Encode vector news so that later we will know\n+\thow many elements there are.\n+\n Mon Jun 26 13:38:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* expr.c (cplus_expand_expr): Don't mess with temp slots.\n \n+\t* decl2.c (warn_if_unknown_interface): Don't crash if tinst_for_decl\n+\treturns null.\n+\n+\t* decl2.c (check_classfn): Use revert_static_member_fn.\n+\t* decl.c (revert_static_member_fn): Diagnose static member functions\n+\tdeclared const or volatile.\n+\n+\t* decl2.c (grokfield): Check for missing default args here, too.\n+\t(check_default_args): Function to do the checking.\n+\t* decl.c (pushdecl): Use it.\n+\n+\t* decl.c (pushdecl): Don't warn about shadowing a member of `this'\n+\tif there is no `this'.\n+\n+Sun Jun 25 11:34:25 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Downgrade 'called before definition'\n+\tto a warning, as it ought to go away after Monterey.\n+\n+Sat Jun 24 14:18:42 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (coerce_template_parms): Don't do extra checking on pointer\n+\tto member arguments.\n+\n+\t* class.c (finish_struct): const and reference members don't prevent\n+\ta class from being an aggregate.\n+\n+\t* class.c (finish_struct): Signatures are always aggregates.\n+\n Fri Jun 23 17:20:29 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-        * pt.c (tsubst): Handle PROMOTE_PROTOTYPES.\n+\t* decl2.c (check_classfn): Improve error message.\n+\n+\t* pt.c (tsubst): Handle PROMOTE_PROTOTYPES.\n \n Thu Jun 22 01:50:42 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-\t* pt.c (tsubst, PARM_TYPE): Propagate DECL_ARTIFICIAL.\n+\t* typeck.c (comptypes): Don't ignore method quals.\n \n-Thu Jun 22 01:50:42 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\t* class.c (finish_struct): Non-abstract virtuals are always USED.\n+\n+\t* decl.c (build_ptrmemfunc_type): The underlying union type isn't\n+\tIS_AGGR_TYPE, either.\n+\t* class.c (finish_struct): Use CLASSTYPE_NON_AGGREGATE instead.\n+\t* cp-tree.h: Ditto.\n+\n+\t* cp-tree.h (lang_type): Add aggregate.\n+\t(CLASSTYPE_AGGREGATE): New macro.\n+\t(TYPE_NON_AGGREGATE_CLASS): Ditto.\n+\t* class.c (finish_struct): Determine whether a class is an\n+\taggregate.\n+\t* decl.c (cp_finish_decl): Check TYPE_NON_AGGREGATE_CLASS instead of\n+\tTYPE_NEEDS_CONSTRUCTING.\n+\t* typeck2.c (digest_init): Check TYPE_NON_AGGREGATE_CLASS for\n+\tsubobjects, too.\n+\n+\t* pt.c (tsubst, PARM_TYPE): Propagate DECL_ARTIFICIAL.\n \n \t* decl.c (start_function): For pre-parsed functions, layout all of\n \tthe parm decls again.\n \t(grokvardecl): TREE_PUBLIC depends on DECL_THIS_EXTERN, not\n \tDECL_EXTERNAL.\n \n+\t* pt.c (coerce_template_parms): Improve checking for invalid\n+\ttemplate parms.\n+\n+Wed Jun 21 12:01:16 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Forbid declaration of a static member\n+\twith the same name as its enclosing class.\n+\n Mon Jun 19 10:28:14 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* decl.c (finish_function): Clear current_class_decl.\n@@ -120,7 +956,7 @@ Thu Jun 15 15:00:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* decl.c (define_function): Don't set DECL_INTERFACE_KNOWN.\n \n \t* parse.y: Call cplus_decl_attributes with prefix_attributes where\n-        appropriate.\n+\tappropriate.\n \n Wed Jun 14 19:24:49 1995  Mike Stump  <mrs@cygnus.com>\n \n@@ -132,7 +968,7 @@ Wed Jun 14 19:24:49 1995  Mike Stump  <mrs@cygnus.com>\n Mon Jun 12 17:50:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* pt.c (instantiate_class_template): Add the new instantiation to\n-        template_classes.\n+\ttemplate_classes.\n \t(do_pending_expansions): Call instantiate_member_templates on all of\n \tthe classes in template_classes.\n \n@@ -300,7 +1136,7 @@ Fri Jun  2 11:05:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* class.c (popclass): Don't mess with current_class_decl,\n \tcurrent_vtable_decl, or C_C_D.\n \n-on May 29 12:45:10 1995  Paul Eggert  <eggert@twinsun.com>\n+Mon May 29 12:45:10 1995  Paul Eggert  <eggert@twinsun.com>\n \n \t* Make-lang.in (c++.mostlyclean): Remove $(DEMANGLER_PROG).\n \n@@ -491,7 +1327,7 @@ Mon May 15 12:47:56 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \taffects reference conversion.\n \n \t* init.c (emit_base_init): Build up an RTL_EXPR and add it to\n-        rtl_expr_chain.\n+\trtl_expr_chain.\n \t* decl.c, decl2.c: s/base_init_insns/base_init_expr/.\n \n Tue May 16 07:06:28 1995  Paul Eggert  <eggert@twinsun.com>\n@@ -597,7 +1433,7 @@ Thu Apr 27 16:56:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \tfolding.\n \n \t* decl.c (grokdeclarator): Prohibit pointers to void or reference\n-        members.\n+\tmembers.\n \n Thu Apr 27 09:49:07 1995  Mike Stump  <mrs@cygnus.com>\n \n@@ -1093,7 +1929,7 @@ Tue Mar 28 14:16:35 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \tif the types are the same.\n \n \t* decl.c (start_function): Handle extern inlines more like C++ says\n-        we should.\n+\twe should.\n \n \t* init.c (build_member_call): Hand constructor calls off to\n \tbuild_functional_cast.\n@@ -1331,7 +2167,7 @@ Wed Mar 15 13:56:16 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t(mark_vtable_entries): Call assemble_external on the vtable entries.\n \n \t* class.c (finish_struct): Set the vtable's size to NULL_TREE before\n-        calling layout_decl, so that it gets updated properly.\n+\tcalling layout_decl, so that it gets updated properly.\n \n \tFinally re-enable dynamic synthesis.  This time it works.\n \t* method.c (synthesize_method): Pass decl_function_context (fndecl)\n@@ -1779,7 +2615,7 @@ Thu Feb 16 03:28:49 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n Wed Feb 15 15:38:12 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* class.c (grow_method): Update method_vec after growing the class\n-        obstack.\n+\tobstack.\n \n Wed Feb 15 13:42:59 1995  Mike Stump  <mrs@cygnus.com>\n \n@@ -1858,7 +2694,7 @@ Sun Feb 12 03:57:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n Fri Feb 10 16:18:52 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* typeck.c (build_c_cast): Use non_lvalue to tack something on\n-        where necessary.\n+\twhere necessary.\n \n \t* decl.c (auto_function): Now a function.\n \t* except.c (init_exception_processing): terminate, unexpected,\n@@ -1894,7 +2730,7 @@ Fri Feb 10 00:52:04 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* tree.c (real_lvalue_p): Like lvalue_p, but class temps aren't\n \tconsidered lvalues.\n \t* cvt.c (convert_to_reference): Use real_lvalue_p instead of\n-        lvalue_p.\n+\tlvalue_p.\n \n \t* cvt.c (build_type_conversion_1): Don't call convert on aggregate\n \ttypes.\n@@ -2040,7 +2876,7 @@ Sun Feb  5 02:50:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n Fri Feb  3 14:58:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* decl.c (grok_reference_init): Convert initializer from\n-        reference.\n+\treference.\n \t* typeck.c (convert_for_initialization): Ditto.\n \n \t* decl.c (duplicate_decls): Propagate DECL_NESTED_TYPENAME.\n@@ -2228,12 +3064,12 @@ Fri Jan 20 01:17:59 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n Thu Jan 19 15:43:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* call.c (build_method_call): Don't mess with 'this' before calling\n-        compute_conversion_costs.\n+\tcompute_conversion_costs.\n \n Wed Jan 18 15:40:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* search.c (get_matching_virtual): Give line number for previous\n-        declaration.\n+\tdeclaration.\n \n \t* call.c (convert_harshness): Handle conversions to references\n \tbetter.\n@@ -2262,8 +3098,8 @@ Tue Jan 17 19:56:15 1995  Mike Stump  <mrs@cygnus.com>\n \n Wed Jan 17 18:20:57 1994  Fergus Henderson <fjh@munta.cs.mu.oz.au>\n \n-        * cp-tree.h : Make if (x=0) warn with wall\n-        * parse.y : Make if (x=0) warn with wall\n+\t* cp-tree.h : Make if (x=0) warn with wall\n+\t* parse.y : Make if (x=0) warn with wall\n \n Tue Jan 17 14:12:00 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n@@ -2274,7 +3110,7 @@ Tue Jan 17 14:12:00 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \ttypes are the same.\n \n \t* cvt.c (cp_convert): Just call truthvalue_conversion to convert to\n-        bool.\n+\tbool.\n \n Mon Jan 16 13:28:48 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n@@ -2437,7 +3273,7 @@ Tue Jan 10 18:07:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* spew.c (yylex): Also use DECL_NESTED_TYPENAME if got_object is set.\n \n \t* parse.y (primary): Unset got_object after all rules that use the\n-        'object' nonterminal.\n+\t'object' nonterminal.\n \t(object): Set got_object.\n \n \t* lex.h: Declare got_object.\n@@ -2509,7 +3345,7 @@ Mon Jan  9 03:44:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t_DEFN.\n \n \t* decl.c (pushdecl): Don't install an artificial TYPE_DECL in\n-        IDENTIFIER_LOCAL_VALUE if we already have a decl with that name.\n+\tIDENTIFIER_LOCAL_VALUE if we already have a decl with that name.\n \n \t* typeck.c (convert_for_assignment): Converting pointers to bool\n \tdoes not need a cast.\n@@ -2539,7 +3375,7 @@ Fri Jan  6 14:10:57 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t(convert_harshness): Non-lvalues do not convert to reference types.\n \n \t* class.c (finish_struct_methods): Still set\n-        TYPE_HAS_{INT,REAL}_CONVERSION.\n+\tTYPE_HAS_{INT,REAL}_CONVERSION.\n \n \t* call.c (can_convert): Don't use aggregate initialization.\n \n@@ -2574,7 +3410,7 @@ Wed Jan  4 16:44:19 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \tmethod vector.\n \t(finish_struct_methods): Use it.  Put all type conversion operators\n \tright after the constructors.  Perhaps we should sort the methods\n-        alphabetically?\n+\talphabetically?\n \n Mon Jan  2 14:42:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n@@ -2844,7 +3680,7 @@ Fri Dec  2 18:32:41 1994  Mike Stump  <mrs@cygnus.com>\n Fri Dec  2 17:04:27 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* gc.c (build_dynamic_cast): Change interface to libg++, ensure that\n-        the return type is the right type, and make references work.\n+\tthe return type is the right type, and make references work.\n \n Fri Dec  2 16:36:43 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n "}, {"sha": "2dd6cff76bbe484f1b4b2d5ff4f194ba00394cc4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 79, "deletions": 92, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -156,6 +156,55 @@ convert_harshness (type, parmtype, parm)\n   if (coder == ERROR_MARK)\n     return EVIL_RETURN (h);\n \n+  if (codel == REFERENCE_TYPE)\n+    {\n+      tree ttl, ttr;\n+      int constp = parm ? TREE_READONLY (parm) : TYPE_READONLY (parmtype);\n+      int volatilep = (parm ? TREE_THIS_VOLATILE (parm)\n+\t\t       : TYPE_VOLATILE (parmtype));\n+      register tree intype = TYPE_MAIN_VARIANT (parmtype);\n+      register enum tree_code form = TREE_CODE (intype);\n+      int penalty = 0;\n+\n+      ttl = TREE_TYPE (type);\n+\n+      /* Only allow const reference binding if we were given a parm to deal\n+         with, since it isn't really a conversion.  This is a hack to\n+         prevent build_type_conversion from finding this conversion, but\n+         still allow overloading to find it.  */\n+      if (! lvalue && ! (parm && TYPE_READONLY (ttl)))\n+\treturn EVIL_RETURN (h);\n+\n+      if (TYPE_READONLY (ttl) < constp\n+\t  || TYPE_VOLATILE (ttl) < volatilep)\n+\treturn EVIL_RETURN (h);\n+\n+      /* When passing a non-const argument into a const reference, dig it a\n+\t little, so a non-const reference is preferred over this one.  */\n+      penalty = ((TYPE_READONLY (ttl) > constp)\n+\t\t + (TYPE_VOLATILE (ttl) > volatilep));\n+\n+      ttl = TYPE_MAIN_VARIANT (ttl);\n+\n+      if (form == OFFSET_TYPE)\n+\t{\n+\t  intype = TREE_TYPE (intype);\n+\t  form = TREE_CODE (intype);\n+\t}\n+\n+      ttr = intype;\n+\n+      /* Maybe handle conversion to base here?  */\n+\n+      h = convert_harshness (ttl, ttr, NULL_TREE);\n+      if (penalty && h.code == 0)\n+\t{\n+\t  h.code = QUAL_CODE;\n+\t  h.int_penalty = penalty;\n+\t}\n+      return h;\n+    }\n+\n   if (codel == POINTER_TYPE && fntype_p (parmtype))\n     {\n       tree p1, p2;\n@@ -198,7 +247,7 @@ convert_harshness (type, parmtype, parm)\n \n       /* We allow the default conversion between function type\n \t and pointer-to-function type for free.  */\n-      if (type == parmtype)\n+      if (comptypes (type, parmtype, 1))\n \treturn h;\n \n       if (pedantic)\n@@ -421,10 +470,21 @@ convert_harshness (type, parmtype, parm)\n     }\n \n   /* Convert arrays which have not previously been converted.  */\n+#if 0\n   if (codel == ARRAY_TYPE)\n     codel = POINTER_TYPE;\n+#endif\n   if (coder == ARRAY_TYPE)\n-    coder = POINTER_TYPE;\n+    {\n+      coder = POINTER_TYPE;\n+      if (parm)\n+\t{\n+\t  parm = decay_conversion (parm);\n+\t  parmtype = TREE_TYPE (parm);\n+\t}\n+      else\n+\tparmtype = build_pointer_type (TREE_TYPE (parmtype));\n+    }\n \n   /* Conversions among pointers */\n   if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n@@ -462,7 +522,7 @@ convert_harshness (type, parmtype, parm)\n \t      ttr = unsigned_type (ttr);\n \t      penalty = 10;\n \t    }\n-\t  if (comp_target_types (ttl, ttr, 0) <= 0)\n+\t  if (comp_target_types (type, parmtype, 1) <= 0)\n \t    return EVIL_RETURN (h);\n \t}\n #else\n@@ -559,54 +619,6 @@ convert_harshness (type, parmtype, parm)\n       && IS_SIGNATURE_POINTER (type) && IS_SIGNATURE (TREE_TYPE (parmtype)))\n     return ZERO_RETURN (h);\n \n-  if (codel == REFERENCE_TYPE)\n-    {\n-      tree ttl, ttr;\n-      int constp = parm ? TREE_READONLY (parm) : TYPE_READONLY (parmtype);\n-      int volatilep = (parm ? TREE_THIS_VOLATILE (parm)\n-\t\t       : TYPE_VOLATILE (parmtype));\n-      register tree intype = TYPE_MAIN_VARIANT (parmtype);\n-      register enum tree_code form = TREE_CODE (intype);\n-      int penalty = 0;\n-\n-      ttl = TREE_TYPE (type);\n-\n-      /* Only allow const reference binding if we were given a parm to deal\n-         with, since it isn't really a conversion.  This is a hack to\n-         prevent build_type_conversion from finding this conversion, but\n-         still allow overloading to find it.  */\n-      if (! lvalue && ! (parm && TYPE_READONLY (ttl)))\n-\treturn EVIL_RETURN (h);\n-\n-      if (TYPE_READONLY (ttl) < constp\n-\t  || TYPE_VOLATILE (ttl) < volatilep)\n-\treturn EVIL_RETURN (h);\n-\n-      /* When passing a non-const argument into a const reference, dig it a\n-\t little, so a non-const reference is preferred over this one.  */\n-      penalty = ((TYPE_READONLY (ttl) > constp)\n-\t\t + (TYPE_VOLATILE (ttl) > volatilep));\n-\n-      ttl = TYPE_MAIN_VARIANT (ttl);\n-\n-      if (form == OFFSET_TYPE)\n-\t{\n-\t  intype = TREE_TYPE (intype);\n-\t  form = TREE_CODE (intype);\n-\t}\n-\n-      ttr = intype;\n-\n-      /* Maybe handle conversion to base here?  */\n-\n-      h = convert_harshness (ttl, ttr, NULL_TREE);\n-      if (penalty && h.code == 0)\n-\t{\n-\t  h.code = QUAL_CODE;\n-\t  h.int_penalty = penalty;\n-\t}\n-      return h;\n-    }\n   if (codel == RECORD_TYPE && coder == RECORD_TYPE)\n     {\n       int b_or_d = get_base_distance (type, parmtype, 0, 0);\n@@ -625,6 +637,9 @@ convert_harshness (type, parmtype, parm)\n   return EVIL_RETURN (h);\n }\n \n+/* A clone of build_type_conversion for checking user-defined conversions in\n+   overload resolution.  */\n+\n int\n user_harshness (type, parmtype, parm)\n      register tree type, parmtype;\n@@ -1766,7 +1781,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t{\n \t  basetype = SIGNATURE_TYPE (basetype);\n \t  instance_ptr = build_optr_ref (instance);\n-\t  instance_ptr = convert (TYPE_POINTER_TO (basetype), instance_ptr);\n+\t  instance_ptr = convert (build_pointer_type (basetype), instance_ptr);\n \t  basetype_path = TYPE_BINFO (basetype);\n \t}\n       else\n@@ -1788,7 +1803,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t within the scope of this function.  */\n       if (!(flags & LOOKUP_NONVIRTUAL) && TYPE_VIRTUAL_P (basetype))\n \tneed_vtbl = maybe_needed;\n-      instance_ptr = build1 (ADDR_EXPR, TYPE_POINTER_TO (basetype), instance);\n+      instance_ptr = build1 (ADDR_EXPR, build_pointer_type (basetype), instance);\n     }\n   else\n     {\n@@ -1883,7 +1898,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype = inst_ptr_basetype;\n \t  else\n \t    {\n-\t      instance_ptr = convert (TYPE_POINTER_TO (basetype), instance_ptr);\n+\t      instance_ptr = convert (build_pointer_type (basetype), instance_ptr);\n \t      if (instance_ptr == error_mark_node)\n \t\treturn error_mark_node;\n \t    }\n@@ -1999,40 +2014,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  parmtypes = tree_cons (NULL_TREE, integer_type_node, parmtypes);\n \t}\n \n-      if (flag_this_is_variable > 0)\n-\t{\n-\t  constp = 0;\n-\t  volatilep = 0;\n-\t  instance_ptr = build_int_2 (0, 0);\n-\t  TREE_TYPE (instance_ptr) = TYPE_POINTER_TO (basetype);\n-\t  parms = tree_cons (NULL_TREE, instance_ptr, parms);\n-\t}\n-      else\n-\t{\n-\t  constp = 0;\n-\t  volatilep = 0;\n-\t  instance_ptr = build_new (NULL_TREE, basetype, void_type_node, 0);\n-\t  if (instance_ptr == error_mark_node)\n-\t    return error_mark_node;\n-\t  instance_ptr = save_expr (instance_ptr);\n-\t  TREE_CALLS_NEW (instance_ptr) = 1;\n-\t  instance = build_indirect_ref (instance_ptr, NULL_PTR);\n-\n-#if 0\n-\t  /* This breaks initialization of a reference from a new\n-             expression of a different type.  And it doesn't appear to\n-             serve its original purpose any more, either.  jason 10/12/94 */\n-\t  /* If it's a default argument initialized from a ctor, what we get\n-\t     from instance_ptr will match the arglist for the FUNCTION_DECL\n-\t     of the constructor.  */\n-\t  if (parms && TREE_CODE (TREE_VALUE (parms)) == CALL_EXPR\n-\t      && TREE_OPERAND (TREE_VALUE (parms), 1)\n-\t      && TREE_CALLS_NEW (TREE_VALUE (TREE_OPERAND (TREE_VALUE (parms), 1))))\n-\t    parms = build_tree_list (NULL_TREE, instance_ptr);\n-\t  else\n-#endif\n-\t    parms = tree_cons (NULL_TREE, instance_ptr, parms);\n-\t}\n+      constp = 0;\n+      volatilep = 0;\n+      instance_ptr = build_int_2 (0, 0);\n+      TREE_TYPE (instance_ptr) = build_pointer_type (basetype);\n+      parms = tree_cons (NULL_TREE, instance_ptr, parms);\n     }\n \n   parmtypes = tree_cons (NULL_TREE, TREE_TYPE (instance_ptr), parmtypes);\n@@ -2385,9 +2371,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      else if (ever_seen > 1)\n \t\t{\n \t\t  TREE_CHAIN (last) = void_list_node;\n-\t\t  cp_error (\"no matching function for call to `%T::%D (%A)'\",\n-\t\t\t    TREE_TYPE (TREE_TYPE (instance_ptr)),\n-\t\t\t    name, TREE_CHAIN (parmtypes));\n+\t\t  cp_error (\"no matching function for call to `%T::%D (%A)%V'\",\n+\t\t\t    TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (instance_ptr))),\n+\t\t\t    name, TREE_CHAIN (parmtypes),\n+\t\t\t    TREE_TYPE (TREE_TYPE (instance_ptr)));\n \t\t  TREE_CHAIN (last) = NULL_TREE;\n \t\t  print_candidates (found_fns);\n \t\t}\n@@ -2486,7 +2473,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if (pedantic && DECL_THIS_INLINE (function) && ! DECL_ARTIFICIAL (function)\n        && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function))\n-    cp_pedwarn (\"inline function `%#D' called before definition\", function);\n+    cp_warning (\"inline function `%#D' called before definition\", function);\n \n   fntype = TREE_TYPE (function);\n   if (TREE_CODE (fntype) == POINTER_TYPE)"}, {"sha": "e2893044f755fbc2684cf46ce16985e7ae1625ac", "filename": "gcc/cp/class.c", "status": "modified", "additions": 561, "deletions": 493, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -188,6 +188,9 @@ build_vbase_path (code, type, expr, path, alias_this)\n   tree basetype;\n   tree offset = integer_zero_node;\n \n+  if (nonnull == 0 && (alias_this && flag_this_is_variable <= 0))\n+    nonnull = 1;\n+\n   /* We need additional logic to convert back to the unconverted type\n      (the static type of the complete object), and then convert back\n      to the type we want.  Until that is done, or until we can\n@@ -244,8 +247,8 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t\t\t  || !flag_assume_nonnull_objects)\n \t\t      && null_expr == NULL_TREE)\n \t\t    {\n-\t\t      null_expr = build1 (NOP_EXPR, TYPE_POINTER_TO (last_virtual), integer_zero_node);\n-\t\t      expr = build (COND_EXPR, TYPE_POINTER_TO (last_virtual),\n+\t\t      null_expr = build1 (NOP_EXPR, build_pointer_type (last_virtual), integer_zero_node);\n+\t\t      expr = build (COND_EXPR, build_pointer_type (last_virtual),\n \t\t\t\t    build (EQ_EXPR, boolean_type_node, expr,\n \t\t\t\t\t   integer_zero_node),\n \t\t\t\t    null_expr, nonnull_expr);\n@@ -286,12 +289,9 @@ build_vbase_path (code, type, expr, path, alias_this)\n   if (changed)\n     {\n       tree intype = TREE_TYPE (TREE_TYPE (expr));\n-      if (TYPE_MAIN_VARIANT (intype) == BINFO_TYPE (last))\n-\tbasetype = intype;\n-      else\n+      if (TYPE_MAIN_VARIANT (intype) != BINFO_TYPE (last))\n \t{\n \t  tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (intype), 0);\n-\t  basetype = last;\n \t  offset = BINFO_OFFSET (binfo);\n \t}\n     }\n@@ -319,7 +319,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t case of constructors need we worry, and in those cases,\n \t it will be zero, or initialized to some valid value to\n \t which we may add.  */\n-      if (nonnull == 0 && (alias_this == 0 || flag_this_is_variable > 0))\n+      if (nonnull == 0)\n \t{\n \t  if (null_expr)\n \t    TREE_TYPE (null_expr) = type;\n@@ -641,6 +641,36 @@ build_type_pathname (format, parent, type)\n   return id;\n }\n \n+/* Update the rtti info for this class.  */\n+static void\n+set_rtti_entry (virtuals, offset, type)\n+     tree virtuals, offset, type;\n+{\n+  if (! flag_vtable_thunks)\n+    TREE_VALUE (virtuals)\n+      = build_vtable_entry (offset,\n+\t\t\t    (flag_rtti\n+\t\t\t     ? build_t_desc (type, 0)\n+\t\t\t     : integer_zero_node));\n+  else\n+    {\n+      tree vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (vfn) = 1;\n+\n+      TREE_VALUE (virtuals)\n+\t= build_vtable_entry (integer_zero_node, vfn);\n+      /* The second slot is for the tdesc pointer when thunks are used.  */\n+      vfn = flag_rtti\n+\t     ? build_t_desc (type, 0)\n+\t     : integer_zero_node;\n+      vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, vfn);\n+      TREE_CONSTANT (vfn) = 1;\n+\n+      TREE_VALUE (TREE_CHAIN (virtuals))\n+\t= build_vtable_entry (integer_zero_node, vfn);\n+    }\n+}\n+\n /* Give TYPE a new virtual function table which is initialized\n    with a skeleton-copy of its original initialization.  The only\n    entry that changes is the `delta' entry, so we can really\n@@ -684,11 +714,9 @@ prepare_fresh_vtable (binfo, for_type)\n   else\n     offset = BINFO_OFFSET (binfo);\n \n-  /* Install the value for `headof' if that's what we're doing.  */\n-  if (flag_rtti)\n-    TREE_VALUE (BINFO_VIRTUALS (binfo))\n-      = build_vtable_entry (size_binop (MINUS_EXPR, integer_zero_node, offset),\n-\t\t\t    build_t_desc (for_type, 0));\n+  set_rtti_entry (BINFO_VIRTUALS (binfo),\n+\t\t  size_binop (MINUS_EXPR, integer_zero_node, offset),\n+\t\t  for_type);\n \n #ifdef GATHER_STATISTICS\n   n_vtables += 1;\n@@ -713,19 +741,19 @@ static tree\n get_vtable_entry (virtuals, base_fndecl)\n      tree virtuals, base_fndecl;\n {\n-  unsigned HOST_WIDE_INT i = (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n+  unsigned HOST_WIDE_INT n = (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n \t   ? (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))\n \t      & (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1))\n \t   : TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl)));\n \n #ifdef GATHER_STATISTICS\n-  n_vtable_searches += i;\n+  n_vtable_searches += n;\n #endif\n \n-  while (i > 0 && virtuals)\n+  while (n > 0 && virtuals)\n     {\n+      --n;\n       virtuals = TREE_CHAIN (virtuals);\n-      i -= 1;\n     }\n   return virtuals;\n }\n@@ -759,14 +787,14 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n /* Access the virtual function table entry i.  VIRTUALS is the virtual\n    function table's initializer.  */\n static tree\n-get_vtable_entry_n (virtuals, i)\n+get_vtable_entry_n (virtuals, n)\n      tree virtuals;\n-     unsigned HOST_WIDE_INT i;\n+     unsigned HOST_WIDE_INT n;\n {\n-  while (i > 0)\n+  while (n > 0)\n     {\n+      --n;\n       virtuals = TREE_CHAIN (virtuals);\n-      i -= 1;\n     }\n   return virtuals;\n }\n@@ -811,15 +839,20 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n \t{\n \t  /* CLASSTYPE_RTTI is only used as a Boolean (NULL or not). */\n \t  CLASSTYPE_RTTI (t) = integer_one_node;\n-#if 0\n-\t  *has_virtual = 1;\n-#endif\n         }\n \n+      /* If we are using thunks, use two slots at the front, one\n+\t for the offset pointer, one for the tdesc pointer.  */\n+      if (*has_virtual == 0 && flag_vtable_thunks)\n+\t{\n+\t  *has_virtual = 1;\n+\t}\n+\n       /* Build a new INT_CST for this DECL_VINDEX.  */\n       {\n \tstatic tree index_table[256];\n \ttree index;\n+\t/* We skip a slot for the offset/tdesc entry.  */\n \tint i = ++(*has_virtual);\n \n \tif (i >= 256 || index_table[i] == 0)\n@@ -2225,6 +2258,30 @@ get_class_offset (context, t, binfo, fndecl)\n   return offset;\n }\n \n+/* Skip RTTI information at the front of the virtual list.  */\n+unsigned HOST_WIDE_INT\n+skip_rtti_stuff (virtuals)\n+     tree *virtuals;\n+{\n+  int n;\n+\n+  n = 0;\n+  if (*virtuals)\n+    {\n+      /* We always reserve a slot for the offset/tdesc entry.  */\n+      ++n;\n+      *virtuals = TREE_CHAIN (*virtuals);\n+    }\n+  if (flag_vtable_thunks && *virtuals)\n+    {\n+      /* The second slot is reserved for the tdesc pointer when thunks\n+         are used.  */\n+      ++n;\n+      *virtuals = TREE_CHAIN (*virtuals);\n+    }\n+  return n;\n+}\n+\n static void\n modify_one_vtable (binfo, t, fndecl, pfn)\n      tree binfo, t, fndecl, pfn;\n@@ -2247,12 +2304,11 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t    prepare_fresh_vtable (binfo, t);\n \t}\n     }\n-  if (fndecl == NULL_TREE) return;\n+  if (fndecl == NULL_TREE)\n+    return;\n+\n+  n = skip_rtti_stuff (&virtuals);\n \n-  /* Skip RTTI fake object. */\n-  n = 1;\n-  if (virtuals)\n-    virtuals = TREE_CHAIN (virtuals);\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n@@ -2346,10 +2402,8 @@ fixup_vtable_deltas1 (binfo, t)\n   tree virtuals = BINFO_VIRTUALS (binfo);\n   unsigned HOST_WIDE_INT n;\n   \n-  /* Skip RTTI fake object. */\n-  n = 1;\n-  if (virtuals)\n-    virtuals = TREE_CHAIN (virtuals);\n+  n = skip_rtti_stuff (&virtuals);\n+\n   while (virtuals)\n     {\n       tree fndecl = TREE_VALUE (virtuals);\n@@ -2517,9 +2571,8 @@ override_one_vtable (binfo, old, t)\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     choose = NEITHER;\n \n-  /* Skip RTTI fake object. */\n-  virtuals = TREE_CHAIN (virtuals);\n-  old_virtuals = TREE_CHAIN (old_virtuals);\n+  skip_rtti_stuff (&virtuals);\n+  skip_rtti_stuff (&old_virtuals);\n \n   while (virtuals)\n     {\n@@ -2640,6 +2693,8 @@ merge_overrides (binfo, old, do_self, t)\n     }\n }\n \n+extern int interface_only, interface_unknown;\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -2700,22 +2755,19 @@ merge_overrides (binfo, old, do_self, t)\n    or otherwise in a type-consistent manner.  */\n \n tree\n-finish_struct (t, list_of_fieldlists, warn_anon)\n+finish_struct_1 (t, warn_anon)\n      tree t;\n-     tree list_of_fieldlists;\n      int warn_anon;\n {\n-  extern int interface_only, interface_unknown;\n-\n   int old;\n   int round_up_size = 1;\n \n+  tree name = TYPE_IDENTIFIER (t);\n   enum tree_code code = TREE_CODE (t);\n-  register tree x, last_x, method_vec;\n+  tree fields = TYPE_FIELDS (t);\n+  tree fn_fields = CLASSTYPE_METHODS (t);\n+  tree x, last_x, method_vec;\n   int needs_virtual_dtor;\n-  tree name = TYPE_NAME (t), fields, fn_fields, *tail;\n-  tree *tail_user_methods = &CLASSTYPE_METHODS (t);\n-  enum access_type access;\n   int all_virtual;\n   int has_virtual;\n   int max_has_virtual;\n@@ -2740,37 +2792,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   int nonprivate_method = 0;\n   tree t_binfo = TYPE_BINFO (t);\n   tree access_decls = NULL_TREE;\n+  int aggregate = 1;\n \n-  if (TREE_CODE (name) == TYPE_DECL)\n-    {\n-#if 0\t\t\t\t/* Maybe later.  -jason  */\n-      struct tinst_level *til = tinst_for_decl();\n-\n-      if (til)\n-\t{\n-\t  DECL_SOURCE_FILE (name) = til->file;\n-\t  if (DECL_SOURCE_LINE (name))\n-\t    DECL_SOURCE_LINE (name) = til->line;\n-\t}\n-      else\n-#endif\n-\t{\n-\t  extern int lineno;\n-\t  \n-\t  DECL_SOURCE_FILE (name) = input_filename;\n-\t  /* For TYPE_DECL that are not typedefs (those marked with a line\n-\t     number of zero, we don't want to mark them as real typedefs.\n-\t     If this fails one needs to make sure real typedefs have a\n-\t     previous line number, even if it is wrong, that way the below\n-\t     will fill in the right line number.  (mrs) */\n-\t  if (DECL_SOURCE_LINE (name))\n-\t    DECL_SOURCE_LINE (name) = lineno;\n-\t  CLASSTYPE_SOURCE_LINE (t) = lineno;\n-\t}\n-      name = DECL_NAME (name);\n-    }\n-\n-  if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (name))\n+  if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n     pedwarn (\"anonymous class type not used to declare any objects\");\n \n   if (TYPE_SIZE (t))\n@@ -2789,10 +2813,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t       dont_allow_type_definitions);\n     }\n \n-  /* Append the fields we need for constructing signature tables.  */\n-  if (IS_SIGNATURE (t))\n-    append_signature_fields (list_of_fieldlists);\n-\n   GNU_xref_decl (current_function_decl, t);\n \n   /* If this type was previously laid out as a forward reference,\n@@ -2838,8 +2858,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n       /* If using multiple inheritance, this may cause variants of our\n \t basetypes to be used (instead of their canonical forms).  */\n-      fields = layout_basetypes (t, BINFO_BASETYPES (t_binfo));\n-      last_x = tree_last (fields);\n+      tree vf = layout_basetypes (t, BINFO_BASETYPES (t_binfo));\n+      last_x = tree_last (vf);\n+      fields = chainon (vf, fields);\n \n       first_vfn_base_index = finish_base_struct (t, &base_info, t_binfo);\n       /* Remember where we got our vfield from */\n@@ -2856,6 +2877,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       no_const_asn_ref = base_info.no_const_asn_ref;\n       needs_virtual_dtor = base_info.needs_virtual_dtor;\n       n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n+      aggregate = 0;\n     }\n   else\n     {\n@@ -2864,7 +2886,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       max_has_virtual = has_virtual;\n       vfield = NULL_TREE;\n       vfields = NULL_TREE;\n-      fields = NULL_TREE;\n       last_x = NULL_TREE;\n       cant_have_default_ctor = 0;\n       cant_have_const_ctor = 0;\n@@ -2892,437 +2913,366 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   CLASSTYPE_VFIELDS (t) = vfields;\n   CLASSTYPE_VFIELD (t) = vfield;\n \n-  tail = &fn_fields;\n-  if (last_x && list_of_fieldlists)\n-    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n-\n   if (IS_SIGNATURE (t))\n     all_virtual = 0;\n   else if (flag_all_virtual == 1 && TYPE_OVERLOADS_METHOD_CALL_EXPR (t))\n     all_virtual = 1;\n   else\n     all_virtual = 0;\n \n-  /* For signatures, we made all methods `public' in the parser and\n-     reported an error if a access specifier was used.  */\n-  if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n+  for (x = CLASSTYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n-      nonprivate_method = 1;\n-      if (list_of_fieldlists\n-\t  && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n-\tTREE_PURPOSE (list_of_fieldlists) = (tree)access_public;\n-    }\n-  else if (list_of_fieldlists\n-\t   && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n-    TREE_PURPOSE (list_of_fieldlists) = (tree)access_private;\n+      GNU_xref_member (current_class_name, x);\n \n-  while (list_of_fieldlists)\n-    {\n-      access = (enum access_type)TREE_PURPOSE (list_of_fieldlists);\n+      nonprivate_method |= ! TREE_PRIVATE (x);\n \n-      for (x = TREE_VALUE (list_of_fieldlists); x; x = TREE_CHAIN (x))\n-\t{\n-\t  TREE_PRIVATE (x) = access == access_private;\n-\t  TREE_PROTECTED (x) = access == access_protected;\n-\t  GNU_xref_member (current_class_name, x);\n-\n-          if (TREE_CODE (x) == TYPE_DECL)\n-            {\n-\t      /* Make sure we set this up.  In find_scoped_type, it explicitly\n-\t\t looks for a TYPE_DECL in the TYPE_FIELDS list.  If we don't\n-\t\t do this here, we'll miss including this TYPE_DECL in the\n-\t\t list.  */\n-\t      if (! fields)\n-\t\tfields = x;\n-\t      last_x = x;\n-\t      continue;\n-\t    }\n+      /* If this was an evil function, don't keep it in class.  */\n+      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n+\tcontinue;\n \n-\t  /* Check for inconsistent use of this name in the class body.\n-             Enums, types and static vars have already been checked.  */\n-\t  if (TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n-\t    {\n-\t      tree name = DECL_NAME (x);\n-\t      tree icv;\n+      DECL_CLASS_CONTEXT (x) = t;\n \n-\t      /* Don't get confused by access decls.  */\n-\t      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t\ticv = IDENTIFIER_CLASS_VALUE (name);\n-\t      else\n-\t\ticv = NULL_TREE;\n+      /* Do both of these, even though they're in the same union;\n+\t if the insn `r' member and the size `i' member are\n+\t different sizes, as on the alpha, the larger of the two\n+\t will end up with garbage in it.  */\n+      DECL_SAVED_INSNS (x) = NULL_RTX;\n+      DECL_FIELD_SIZE (x) = 0;\n \n-\t      if (icv\n-\t\t  /* Don't complain about constructors.  */\n-\t\t  && name != constructor_name (current_class_type)\n-\t\t  /* Or inherited names.  */\n-\t\t  && id_in_current_class (name)\n-\t\t  /* Or shadowed tags.  */\n-\t\t  && !(TREE_CODE (icv) == TYPE_DECL\n-\t\t       && DECL_CONTEXT (icv) == t))\n-\t\t{\n-\t\t  cp_error_at (\"declaration of identifier `%D' as `%+#D'\",\n-\t\t\t       name, x);\n-\t\t  cp_error_at (\"conflicts with other use in class as `%#D'\",\n-\t\t\t       icv);\n-\t\t}\n-\t    }\n-\n-\t  if (TREE_CODE (x) == FUNCTION_DECL)\n-\t    {\n-\t      nonprivate_method |= ! TREE_PRIVATE (x);\n-\n-\t      /* If this was an evil function, don't keep it in class.  */\n-\t      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n-\t\tcontinue;\n+      /* The name of the field is the original field name\n+\t Save this in auxiliary field for later overloading.  */\n+      if (DECL_VINDEX (x)\n+\t  || (all_virtual == 1 && ! DECL_CONSTRUCTOR_P (x)))\n+\t{\n+\t  pending_virtuals = add_virtual_function (pending_virtuals,\n+\t\t\t\t\t\t   &has_virtual, x, t);\n+\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n+\t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n+\t  else\n+\t    TREE_USED (x) = 1;\n+\t}\n+    }\n \n-\t      if (last_x)\n-\t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t      /* Link x onto end of fn_fields and CLASSTYPE_METHODS. */\n-\t      *tail = x;\n-\t      tail = &TREE_CHAIN (x);\n-\t      *tail_user_methods = x;\n-\t      tail_user_methods = &DECL_NEXT_METHOD (x);\n+  for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n+    {\n+      GNU_xref_member (current_class_name, x);\n \n-\t      DECL_CLASS_CONTEXT (x) = t;\n+      /* Handle access declarations.  */\n+      if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n+\t{\n+\t  tree fdecl = TREE_OPERAND (DECL_NAME (x), 1);\n+\t  enum access_type access\n+\t    = TREE_PRIVATE (x) ? access_private :\n+\t      TREE_PROTECTED (x) ? access_protected : access_public;\n \n-\t      /* Do both of these, even though they're in the same union;\n-\t\t if the insn `r' member and the size `i' member are\n-\t\t different sizes, as on the alpha, the larger of the two\n-\t\t will end up with garbage in it.  */\n-\t      DECL_SAVED_INSNS (x) = NULL_RTX;\n-\t      DECL_FIELD_SIZE (x) = 0;\n+\t  if (last_x)\n+\t    TREE_CHAIN (last_x) = TREE_CHAIN (x);\n+\t  else\n+\t    fields = TREE_CHAIN (x);\n \n-\t      /* The name of the field is the original field name\n-\t\t Save this in auxiliary field for later overloading.  */\n-\t      if (DECL_VINDEX (x)\n-\t\t  || (all_virtual == 1 && ! DECL_CONSTRUCTOR_P (x)))\n-\t\t{\n-                  pending_virtuals = add_virtual_function (pending_virtuals,\n-                                                           &has_virtual, x, t);\n-                  if (DECL_ABSTRACT_VIRTUAL_P (x))\n-                    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n-\t\t}\n-\t      continue;\n-\t    }\n+\t  access_decls = tree_cons ((tree) access, fdecl, access_decls);\n+\t  continue;\n+\t}\n \n-\t  /* Handle access declarations.  */\n-\t  if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n-\t    {\n-\t      tree fdecl = TREE_OPERAND (DECL_NAME (x), 1);\n+      last_x = x;\n \n-\t      if (last_x)\n-\t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t      access_decls = tree_cons ((tree) access, fdecl, access_decls);\n-\t      continue;\n-\t    }\n+      if (TREE_CODE (x) == TYPE_DECL)\n+\tcontinue;\n \n-\t  /* If we've gotten this far, it's a data member, possibly static,\n-\t     or an enumerator. */\n+      /* If we've gotten this far, it's a data member, possibly static,\n+\t or an enumerator. */\n \n-\t  DECL_FIELD_CONTEXT (x) = t;\n+      DECL_FIELD_CONTEXT (x) = t;\n \n-\t  /* ``A local class cannot have static data members.'' ARM 9.4 */\n-\t  if (current_function_decl && TREE_STATIC (x))\n-\t    cp_error_at (\"field `%D' in local class cannot be static\", x);\n+      /* ``A local class cannot have static data members.'' ARM 9.4 */\n+      if (current_function_decl && TREE_STATIC (x))\n+\tcp_error_at (\"field `%D' in local class cannot be static\", x);\n \n-\t  /* Perform error checking that did not get done in\n-             grokdeclarator.  */\n-\t  if (TREE_CODE (TREE_TYPE (x)) == FUNCTION_TYPE)\n-\t    {\n-\t      cp_error_at (\"field `%D' invalidly declared function type\",\n-\t\t\tx);\n-\t      TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE)\n-\t    {\n-\t      cp_error_at (\"field `%D' invalidly declared method type\", x);\n-\t\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (x)) == OFFSET_TYPE)\n-\t    {\n-\t      cp_error_at (\"field `%D' invalidly declared offset type\", x);\n-\t      TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n-\t    }\n+      /* Perform error checking that did not get done in\n+\t grokdeclarator.  */\n+      if (TREE_CODE (TREE_TYPE (x)) == FUNCTION_TYPE)\n+\t{\n+\t  cp_error_at (\"field `%D' invalidly declared function type\",\n+\t\t       x);\n+\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t}\n+      else if (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE)\n+\t{\n+\t  cp_error_at (\"field `%D' invalidly declared method type\", x);\n+\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t}\n+      else if (TREE_CODE (TREE_TYPE (x)) == OFFSET_TYPE)\n+\t{\n+\t  cp_error_at (\"field `%D' invalidly declared offset type\", x);\n+\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t}\n \n #if 0\n-\t  if (DECL_NAME (x) == constructor_name (t))\n-\t    cant_have_default_ctor = cant_synth_copy_ctor = 1;\n+      if (DECL_NAME (x) == constructor_name (t))\n+\tcant_have_default_ctor = cant_synth_copy_ctor = 1;\n #endif\n \n-\t  if (TREE_TYPE (x) == error_mark_node)\n-\t    continue;\n+      if (TREE_TYPE (x) == error_mark_node)\n+\tcontinue;\n \t  \n-\t  if (! fields)\n-\t    fields = x;\n-\t  last_x = x;\n-\n-\t  DECL_SAVED_INSNS (x) = NULL_RTX;\n-\t  DECL_FIELD_SIZE (x) = 0;\n+      DECL_SAVED_INSNS (x) = NULL_RTX;\n+      DECL_FIELD_SIZE (x) = 0;\n \n-\t  /* When this goes into scope, it will be a non-local reference.  */\n-\t  DECL_NONLOCAL (x) = 1;\n+      /* When this goes into scope, it will be a non-local reference.  */\n+      DECL_NONLOCAL (x) = 1;\n \n-\t  if (TREE_CODE (x) == CONST_DECL)\n-\t    continue;\n+      if (TREE_CODE (x) == CONST_DECL)\n+\tcontinue;\n \n-\t  if (TREE_CODE (x) == VAR_DECL)\n-\t    {\n-\t      if (TREE_CODE (t) == UNION_TYPE)\n-\t\t/* Unions cannot have static members.  */\n-\t\tcp_error_at (\"field `%D' declared static in union\", x);\n+      if (TREE_CODE (x) == VAR_DECL)\n+\t{\n+\t  if (TREE_CODE (t) == UNION_TYPE)\n+\t    /* Unions cannot have static members.  */\n+\t    cp_error_at (\"field `%D' declared static in union\", x);\n \t      \n-\t      continue;\n-\t    }\n+\t  continue;\n+\t}\n \n-\t  /* Now it can only be a FIELD_DECL.  */\n+      /* Now it can only be a FIELD_DECL.  */\n \n-\t  /* If this is of reference type, check if it needs an init.\n-\t     Also do a little ANSI jig if necessary.  */\n-\t  if (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE)\n-\t    {\n-\t      if (DECL_INITIAL (x) == NULL_TREE)\n-\t\tref_sans_init = 1;\n+      if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n+\taggregate = 0;\n \n-\t      /* ARM $12.6.2: [A member initializer list] (or, for an\n-\t\t aggregate, initialization by a brace-enclosed list) is the\n-\t\t only way to initialize nonstatic const and reference\n-\t\t members.  */\n-\t      cant_synth_asn_ref = 1;\n-\t      cant_have_default_ctor = 1;\n+      /* If this is of reference type, check if it needs an init.\n+\t Also do a little ANSI jig if necessary.  */\n+      if (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE)\n+ \t{\n+\t  if (DECL_INITIAL (x) == NULL_TREE)\n+\t    ref_sans_init = 1;\n \n-\t      if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n-\t\t{\n-\t\t  if (DECL_NAME (x))\n-\t\t    cp_warning_at (\"non-static reference `%#D' in class without a constructor\", x);\n-\t\t  else\n-\t\t    cp_warning_at (\"non-static reference in class without a constructor\", x);\n-\t\t}\n+\t  /* ARM $12.6.2: [A member initializer list] (or, for an\n+\t     aggregate, initialization by a brace-enclosed list) is the\n+\t     only way to initialize nonstatic const and reference\n+\t     members.  */\n+\t  cant_synth_asn_ref = 1;\n+\t  cant_have_default_ctor = 1;\n+\n+\t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n+\t    {\n+\t      if (DECL_NAME (x))\n+\t\tcp_warning_at (\"non-static reference `%#D' in class without a constructor\", x);\n+\t      else\n+\t\tcp_warning_at (\"non-static reference in class without a constructor\", x);\n \t    }\n+\t}\n \n-\t  /* If any field is const, the structure type is pseudo-const.  */\n-\t  if (TREE_READONLY (x))\n+      /* If any field is const, the structure type is pseudo-const.  */\n+      if (TREE_READONLY (x))\n+\t{\n+\t  C_TYPE_FIELDS_READONLY (t) = 1;\n+\t  if (DECL_INITIAL (x) == NULL_TREE)\n+\t    const_sans_init = 1;\n+\n+\t  /* ARM $12.6.2: [A member initializer list] (or, for an\n+\t     aggregate, initialization by a brace-enclosed list) is the\n+\t     only way to initialize nonstatic const and reference\n+\t     members.  */\n+\t  cant_synth_asn_ref = 1;\n+\t  cant_have_default_ctor = 1;\n+\n+\t  if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n+\t      && extra_warnings)\n+\t    {\n+\t      if (DECL_NAME (x))\n+\t\tcp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n+\t      else\n+\t\tcp_warning_at (\"non-static const member in class without a constructor\", x);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* A field that is pseudo-const makes the structure\n+\t     likewise.  */\n+\t  tree t1 = TREE_TYPE (x);\n+\t  while (TREE_CODE (t1) == ARRAY_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (IS_AGGR_TYPE (t1))\n \t    {\n-\t      C_TYPE_FIELDS_READONLY (t) = 1;\n-\t      if (DECL_INITIAL (x) == NULL_TREE)\n+\t      if (C_TYPE_FIELDS_READONLY (t1))\n+\t\tC_TYPE_FIELDS_READONLY (t) = 1;\n+\t      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (t1))\n \t\tconst_sans_init = 1;\n+\t    }\n+\t}\n \n-\t      /* ARM $12.6.2: [A member initializer list] (or, for an\n-\t\t aggregate, initialization by a brace-enclosed list) is the\n-\t\t only way to initialize nonstatic const and reference\n-\t\t members.  */\n-\t      cant_synth_asn_ref = 1;\n-\t      cant_have_default_ctor = 1;\n+      /* We set DECL_BIT_FIELD tentatively in grokbitfield.\n+\t If the type and width are valid, we'll keep it set.\n+\t Otherwise, the flag is cleared.  */\n+      if (DECL_BIT_FIELD (x))\n+\t{\n+\t  DECL_BIT_FIELD (x) = 0;\n+\t  /* Invalid bit-field size done by grokfield.  */\n+\t  /* Detect invalid bit-field type.  */\n+\t  if (DECL_INITIAL (x)\n+\t      && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n+\t    {\n+\t      cp_error_at (\"bit-field `%#D' with non-integral type\", x);\n+\t      DECL_INITIAL (x) = NULL;\n+\t    }\n \n-\t      if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n-\t\t  && extra_warnings)\n+\t  /* Detect and ignore out of range field width.  */\n+\t  if (DECL_INITIAL (x))\n+\t    {\n+\t      register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n+\n+\t      if (width < 0)\n \t\t{\n-\t\t  if (DECL_NAME (x))\n-\t\t    cp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n-\t\t  else\n-\t\t    cp_warning_at (\"non-static const member in class without a constructor\", x);\n+\t\t  DECL_INITIAL (x) = NULL;\n+\t\t  cp_error_at (\"negative width in bit-field `%D'\", x);\n \t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* A field that is pseudo-const makes the structure\n-\t\t likewise.  */\n-\t      tree t1 = TREE_TYPE (x);\n-\t      while (TREE_CODE (t1) == ARRAY_TYPE)\n-\t\tt1 = TREE_TYPE (t1);\n-\t      if (IS_AGGR_TYPE (t1))\n+\t      else if (width == 0 && DECL_NAME (x) != 0)\n \t\t{\n-\t\t  if (C_TYPE_FIELDS_READONLY (t1))\n-\t\t    C_TYPE_FIELDS_READONLY (t) = 1;\n-\t\t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (t1))\n-\t\t    const_sans_init = 1;\n+\t\t  DECL_INITIAL (x) = NULL;\n+\t\t  cp_error_at (\"zero width for bit-field `%D'\", x);\n \t\t}\n-\t    }\n-\n-\t  /* We set DECL_BIT_FIELD tentatively in grokbitfield.\n-\t     If the type and width are valid, we'll keep it set.\n-\t     Otherwise, the flag is cleared.  */\n-\t  if (DECL_BIT_FIELD (x))\n-\t    {\n-\t      DECL_BIT_FIELD (x) = 0;\n-\t      /* Invalid bit-field size done by grokfield.  */\n-\t      /* Detect invalid bit-field type.  */\n-\t      if (DECL_INITIAL (x)\n-\t\t  && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n+\t      else if (width\n+\t\t       > TYPE_PRECISION (long_long_unsigned_type_node))\n \t\t{\n-\t\t  cp_error_at (\"bit-field `%#D' with non-integral type\", x);\n+\t\t  /* The backend will dump if you try to use something\n+\t\t     too big; avoid that.  */\n \t\t  DECL_INITIAL (x) = NULL;\n+\t\t  sorry (\"bit-fields larger than %d bits\",\n+\t\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n+\t\t  cp_error_at (\"  in declaration of `%D'\", x);\n \t\t}\n-\n-\t      /* Detect and ignore out of range field width.  */\n-\t      if (DECL_INITIAL (x))\n+\t      else if (width > TYPE_PRECISION (TREE_TYPE (x))\n+\t\t       && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n \t\t{\n-\t\t  register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n-\n-\t\t  if (width < 0)\n-\t\t    {\n-\t\t      DECL_INITIAL (x) = NULL;\n-\t\t      cp_error_at (\"negative width in bit-field `%D'\", x);\n-\t\t    }\n-\t\t  else if (width == 0 && DECL_NAME (x) != 0)\n-\t\t    {\n-\t\t      DECL_INITIAL (x) = NULL;\n-\t\t      cp_error_at (\"zero width for bit-field `%D'\", x);\n-\t\t    }\n-\t\t  else if (width\n-\t\t\t   > TYPE_PRECISION (long_long_unsigned_type_node))\n-\t\t    {\n-\t\t      /* The backend will dump if you try to use something\n-\t\t\t too big; avoid that.  */\n-\t\t      DECL_INITIAL (x) = NULL;\n-\t\t      sorry (\"bit-fields larger than %d bits\",\n-\t\t\t     TYPE_PRECISION (long_long_unsigned_type_node));\n-\t\t      cp_error_at (\"  in declaration of `%D'\", x);\n-\t\t    }\n-\t\t  else if (width > TYPE_PRECISION (TREE_TYPE (x))\n-\t\t\t   && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n-\t\t    {\n-\t\t      cp_warning_at (\"width of `%D' exceeds its type\", x);\n-\t\t    }\n-\t\t  else if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t       && ((min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n-\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))) > width)\n-\t\t   || (min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n-\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (x))) > width)))\n-\t\t    {\n-\t\t      cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n-\t\t\t\t     x, TREE_TYPE (x));\n-\t\t    }\n+\t\t  cp_warning_at (\"width of `%D' exceeds its type\", x);\n \t\t}\n-\n-\t      /* Process valid field width.  */\n-\t      if (DECL_INITIAL (x))\n+\t      else if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n+\t\t       && ((min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))) > width)\n+\t\t\t   || (min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (x))) > width)))\n \t\t{\n-\t\t  register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n+\t\t  cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n+\t\t\t\t x, TREE_TYPE (x));\n+\t\t}\n+\t    }\n \n-\t\t  if (width == 0)\n-\t\t    {\n+\t  /* Process valid field width.  */\n+\t  if (DECL_INITIAL (x))\n+\t    {\n+\t      register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n+\n+\t      if (width == 0)\n+\t\t{\n #ifdef EMPTY_FIELD_BOUNDARY\n-\t\t      /* field size 0 => mark following field as \"aligned\" */\n-\t\t      if (TREE_CHAIN (x))\n-\t\t\tDECL_ALIGN (TREE_CHAIN (x))\n-\t\t\t  = MAX (DECL_ALIGN (TREE_CHAIN (x)), EMPTY_FIELD_BOUNDARY);\n-\t\t      /* field of size 0 at the end => round up the size.  */\n-\t\t      else\n-\t\t\tround_up_size = EMPTY_FIELD_BOUNDARY;\n+\t\t  /* field size 0 => mark following field as \"aligned\" */\n+\t\t  if (TREE_CHAIN (x))\n+\t\t    DECL_ALIGN (TREE_CHAIN (x))\n+\t\t      = MAX (DECL_ALIGN (TREE_CHAIN (x)), EMPTY_FIELD_BOUNDARY);\n+\t\t  /* field of size 0 at the end => round up the size.  */\n+\t\t  else\n+\t\t    round_up_size = EMPTY_FIELD_BOUNDARY;\n #endif\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (x)));\n+\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n+\t\t\t\t\tTYPE_ALIGN (TREE_TYPE (x)));\n #endif\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      DECL_INITIAL (x) = NULL_TREE;\n-\t\t      DECL_FIELD_SIZE (x) = width;\n-\t\t      DECL_BIT_FIELD (x) = 1;\n-\t\t      /* Traditionally a bit field is unsigned\n-\t\t\t even if declared signed.  */\n-\t\t      if (flag_traditional\n-\t\t\t  && TREE_CODE (TREE_TYPE (x)) == INTEGER_TYPE)\n-\t\t\tTREE_TYPE (x) = unsigned_type_node;\n-\t\t    }\n \t\t}\n \t      else\n-\t\t/* Non-bit-fields are aligned for their type.  */\n-\t\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (TREE_TYPE (x)));\n+\t\t{\n+\t\t  DECL_INITIAL (x) = NULL_TREE;\n+\t\t  DECL_FIELD_SIZE (x) = width;\n+\t\t  DECL_BIT_FIELD (x) = 1;\n+\t\t  /* Traditionally a bit field is unsigned\n+\t\t     even if declared signed.  */\n+\t\t  if (flag_traditional\n+\t\t      && TREE_CODE (TREE_TYPE (x)) == INTEGER_TYPE)\n+\t\t    TREE_TYPE (x) = unsigned_type_node;\n+\t\t}\n \t    }\n \t  else\n-\t    {\n-\t      tree type = TREE_TYPE (x);\n+\t    /* Non-bit-fields are aligned for their type.  */\n+\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (TREE_TYPE (x)));\n+\t}\n+      else\n+\t{\n+\t  tree type = TREE_TYPE (x);\n \n-\t      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t\ttype = TREE_TYPE (type);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    type = TREE_TYPE (type);\n \n-\t      if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x)\n-\t\t  && ! TYPE_PTRMEMFUNC_P (type))\n-\t\t{\n-\t\t  /* Never let anything with uninheritable virtuals\n-\t\t     make it through without complaint.  */\n-\t\t  if (CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-\t\t    abstract_virtuals_error (x, type);\n+\t  if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x)\n+\t      && ! TYPE_PTRMEMFUNC_P (type))\n+\t    {\n+\t      /* Never let anything with uninheritable virtuals\n+\t\t make it through without complaint.  */\n+\t      if (CLASSTYPE_ABSTRACT_VIRTUALS (type))\n+\t\tabstract_virtuals_error (x, type);\n \t\t      \n-\t\t  /* Don't let signatures make it through either.  */\n-\t\t  if (IS_SIGNATURE (type))\n-\t\t    signature_error (x, type);\n+\t      /* Don't let signatures make it through either.  */\n+\t      if (IS_SIGNATURE (type))\n+\t\tsignature_error (x, type);\n \t\t      \n-\t\t  if (code == UNION_TYPE)\n-\t\t    {\n-\t\t      char *fie = NULL;\n-\t\t      if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t\t\tfie = \"constructor\";\n-\t\t      else if (TYPE_NEEDS_DESTRUCTOR (type))\n-\t\t\tfie = \"destructor\";\n-\t\t      else if (TYPE_HAS_REAL_ASSIGNMENT (type))\n-\t\t\tfie = \"assignment operator\";\n-\t\t      if (fie)\n-\t\t\tcp_error_at (\"member `%#D' with %s not allowed in union\", x,\n-\t\t\t\t     fie);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n-\t\t      TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n-\t\t      TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n-\t\t      TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n-\t\t    }\n+\t      if (code == UNION_TYPE)\n+\t\t{\n+\t\t  char *fie = NULL;\n+\t\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t\t    fie = \"constructor\";\n+\t\t  else if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t\t    fie = \"destructor\";\n+\t\t  else if (TYPE_HAS_REAL_ASSIGNMENT (type))\n+\t\t    fie = \"assignment operator\";\n+\t\t  if (fie)\n+\t\t    cp_error_at (\"member `%#D' with %s not allowed in union\", x,\n+\t\t\t\t fie);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n+\t\t  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n+\t\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n+\t\t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n+\t\t}\n \n-\t\t  if (! TYPE_HAS_INIT_REF (type)\n-\t\t      || (TYPE_HAS_NONPUBLIC_CTOR (type)\n-\t\t\t  && ! is_friend (t, type)))\n-\t\t    cant_synth_copy_ctor = 1;\n-\t\t  else if (!TYPE_HAS_CONST_INIT_REF (type))\n-\t\t    cant_have_const_ctor = 1;\n-\n-\t\t  if (! TYPE_HAS_ASSIGN_REF (type)\n-\t\t      || (TYPE_HAS_NONPUBLIC_ASSIGN_REF (type)\n-\t\t\t  && ! is_friend (t, type)))\n-\t\t    cant_synth_asn_ref = 1;\n-\t\t  else if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n-\t\t    no_const_asn_ref = 1;\n-\n-\t\t  if (TYPE_HAS_CONSTRUCTOR (type)\n-\t\t      && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n-\t\t    {\n-\t\t      cant_have_default_ctor = 1;\n+\t      if (! TYPE_HAS_INIT_REF (type)\n+\t\t  || (TYPE_HAS_NONPUBLIC_CTOR (type)\n+\t\t      && ! is_friend (t, type)))\n+\t\tcant_synth_copy_ctor = 1;\n+\t      else if (!TYPE_HAS_CONST_INIT_REF (type))\n+\t\tcant_have_const_ctor = 1;\n+\n+\t      if (! TYPE_HAS_ASSIGN_REF (type)\n+\t\t  || (TYPE_HAS_NONPUBLIC_ASSIGN_REF (type)\n+\t\t      && ! is_friend (t, type)))\n+\t\tcant_synth_asn_ref = 1;\n+\t      else if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n+\t\tno_const_asn_ref = 1;\n+\n+\t      if (TYPE_HAS_CONSTRUCTOR (type)\n+\t\t  && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+\t\t{\n+\t\t  cant_have_default_ctor = 1;\n #if 0\n-\t\t      /* This is wrong for aggregates.  */\n-\t\t      if (! TYPE_HAS_CONSTRUCTOR (t))\n-\t\t\t{\n-\t\t\t  if (DECL_NAME (x))\n-\t\t\t    cp_pedwarn_at (\"member `%#D' with only non-default constructor\", x);\n-\t\t\t  else\n-\t\t\t    cp_pedwarn_at (\"member with only non-default constructor\", x);\n-\t\t\t  cp_pedwarn_at (\"in class without a constructor\",\n-\t\t\t\t\t x);\n-\t\t\t}\n-#endif\n+\t\t  /* This is wrong for aggregates.  */\n+\t\t  if (! TYPE_HAS_CONSTRUCTOR (t))\n+\t\t    {\n+\t\t      if (DECL_NAME (x))\n+\t\t\tcp_pedwarn_at (\"member `%#D' with only non-default constructor\", x);\n+\t\t      else\n+\t\t\tcp_pedwarn_at (\"member with only non-default constructor\", x);\n+\t\t      cp_pedwarn_at (\"in class without a constructor\",\n+\t\t\t\t     x);\n \t\t    }\n-\t\t}\n-\t      if (DECL_INITIAL (x) != NULL_TREE)\n-\t\t{\n-\t\t  /* `build_class_init_list' does not recognize\n-                     non-FIELD_DECLs.  */\n-\t\t  if (code == UNION_TYPE && any_default_members != 0)\n-\t\t    cp_error_at (\"multiple fields in union `%T' initialized\");\n-\t\t  any_default_members = 1;\n+#endif\n \t\t}\n \t    }\n-\t}\n-      list_of_fieldlists = TREE_CHAIN (list_of_fieldlists);\n-      /* link the tail while we have it! */\n-      if (last_x)\n-\t{\n-\t  TREE_CHAIN (last_x) = NULL_TREE;\n-\n-\t  if (list_of_fieldlists\n-\t      && TREE_VALUE (list_of_fieldlists)\n-\t      && TREE_CODE (TREE_VALUE (list_of_fieldlists)) != FUNCTION_DECL)\n-\t    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n+\t  if (DECL_INITIAL (x) != NULL_TREE)\n+\t    {\n+\t      /* `build_class_init_list' does not recognize\n+\t\t non-FIELD_DECLs.  */\n+\t      if (code == UNION_TYPE && any_default_members != 0)\n+\t\tcp_error_at (\"multiple fields in union `%T' initialized\");\n+\t      any_default_members = 1;\n+\t    }\n \t}\n     }\n \n@@ -3337,6 +3287,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   /* Synthesize any needed methods.  Note that methods will be synthesized\n      for anonymous unions; grok_x_components undoes that.  */\n \n+  if (! fn_fields)\n+    nonprivate_method = 1;\n+\n   if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n       && !IS_SIGNATURE (t))\n     {\n@@ -3349,8 +3302,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       else\n \t{\n \t  /* Link dtor onto end of fn_fields. */\n-\t  *tail = dtor;\n-\t  tail = &TREE_CHAIN (dtor);\n+\n+\t  TREE_CHAIN (dtor) = fn_fields;\n+\t  fn_fields = dtor;\n \n \t  if (DECL_VINDEX (dtor) == NULL_TREE\n \t      && (needs_virtual_dtor\n@@ -3364,23 +3318,20 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t}\n     }\n \n-  *tail = NULL_TREE;\n-  *tail_user_methods = NULL_TREE;\n-\n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n   if (flag_rtti && (max_has_virtual > 0 || needs_virtual_dtor) && \n \thas_virtual == 0)\n     has_virtual = 1;\n \n-  if (! fn_fields)\n-    nonprivate_method = 1;\n-\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| any_default_members);\n   TYPE_NEEDS_CONSTRUCTING (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| has_virtual || any_default_members || first_vfn_base_index >= 0);\n+  if (! IS_SIGNATURE (t))\n+    CLASSTYPE_NON_AGGREGATE (t)\n+      = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n \n   /* ARM $12.1: A default constructor will be generated for a class X\n      only if no constructor has been declared for class X.  So we\n@@ -3653,6 +3604,13 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\tif (TREE_CODE (uelt) != FIELD_DECL)\n \t\t  continue;\n \n+\t\tif (TREE_PRIVATE (uelt))\n+\t\t  cp_pedwarn_at (\"private member `%#D' in anonymous union\",\n+\t\t\t\t uelt);\n+\t\telse if (TREE_PROTECTED (uelt))\n+\t\t  cp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n+\t\t\t\t uelt);\n+\n \t\tDECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n \t\tDECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n \t      }\n@@ -3788,39 +3746,28 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       /* We must enter these virtuals into the table.  */\n       if (first_vfn_base_index < 0)\n \t{\n-\t  if (flag_rtti)\n-\t    pending_virtuals = tree_cons (NULL_TREE,\n-\t\tbuild_vtable_entry (integer_zero_node, build_t_desc (t, 0)),\n-\t        pending_virtuals);\n-\t  else \n-            pending_virtuals = tree_cons (NULL_TREE,\n-                build_vtable_entry (integer_zero_node, integer_zero_node),\n-                pending_virtuals);\n+\t  /* The first slot is for the rtti offset.  */\n+\t  pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n \n-#if 0\n-\t  /* The size is no longer used. */\n-\t  /* now we put the size of the vtable as first entry */\n-\t  pending_virtuals = tree_cons (NULL_TREE, the_null_vtable_entry,\n-\t\t\t\t\tpending_virtuals);\n-#endif\n+\t  /* The second slot is for the tdesc pointer when thunks are used.  */\n+\t  if (flag_vtable_thunks)\n+\t    pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n+\n+\t  set_rtti_entry (pending_virtuals, integer_zero_node, t);\n \t  build_vtable (NULL_TREE, t);\n \t}\n       else\n \t{\n+\t  tree offset;\n \t  /* Here we know enough to change the type of our virtual\n \t     function table, but we will wait until later this function.  */\n \n \t  if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n \t    build_vtable (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index), t);\n \n-\t  /* Update the rtti pointer for this class.  */\n-\t  if (flag_rtti)\n-\t    {\n-\t      tree offset = get_derived_offset (TYPE_BINFO (t), NULL_TREE);\n-\t      offset = size_binop (MINUS_EXPR, integer_zero_node, offset);\n-\t      TREE_VALUE (TYPE_BINFO_VIRTUALS (t))\n-\t\t= build_vtable_entry (offset, build_t_desc (t, 0));\n-\t    }\n+\t  offset = get_derived_offset (TYPE_BINFO (t), NULL_TREE);\n+\t  offset = size_binop (MINUS_EXPR, integer_zero_node, offset);\n+\t  set_rtti_entry (TYPE_BINFO_VIRTUALS (t), offset, t);\n \t}\n \n       /* If this type has basetypes with constructors, then those\n@@ -3918,29 +3865,10 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   finish_struct_bits (t, max_has_virtual);\n \n-  /* Promote each bit-field's type to int if it is narrower than that.\n-     There's more: complete the rtl for any static member objects which\n-     is of the same type we're working on.  */\n+  /* Complete the rtl for any static member objects of the type we're\n+     working on.  */\n   for (x = fields; x; x = TREE_CHAIN (x))\n     {\n-      if (DECL_BIT_FIELD (x)\n-\t  && (C_PROMOTING_INTEGER_TYPE_P (TREE_TYPE (x))\n-\t      || DECL_FIELD_SIZE (x) < TYPE_PRECISION (integer_type_node)))\n-\t{\n-\t  tree type = TREE_TYPE (x);\n-\n-\t  /* Preserve unsignedness if traditional or if not really getting\n-\t     any wider.  */\n-\t  if (TREE_UNSIGNED (type)\n-\t      && (flag_traditional\n-\t\t  ||\n-\t\t  (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)\n-\t\t   && DECL_FIELD_SIZE (x) == TYPE_PRECISION (integer_type_node))))\n-\t    TREE_TYPE (x) = unsigned_type_node;\n-\t  else\n-\t    TREE_TYPE (x) = integer_type_node;\n-\t}\n-\n       if (TREE_CODE (x) == VAR_DECL && TREE_STATIC (x)\n \t  && TREE_TYPE (x) == t)\n \t{\n@@ -4110,6 +4038,146 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   return t;\n }\n+\n+tree\n+finish_struct (t, list_of_fieldlists, warn_anon)\n+     tree t;\n+     tree list_of_fieldlists;\n+     int warn_anon;\n+{\n+  tree fields = NULL_TREE, fn_fields, *tail;\n+  tree *tail_user_methods = &CLASSTYPE_METHODS (t);\n+  tree name = TYPE_NAME (t);\n+  tree x, last_x = NULL_TREE;\n+  enum access_type access;\n+\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    {\n+      extern int lineno;\n+\t  \n+      DECL_SOURCE_FILE (name) = input_filename;\n+      /* For TYPE_DECL that are not typedefs (those marked with a line\n+\t number of zero, we don't want to mark them as real typedefs.\n+\t If this fails one needs to make sure real typedefs have a\n+\t previous line number, even if it is wrong, that way the below\n+\t will fill in the right line number.  (mrs) */\n+      if (DECL_SOURCE_LINE (name))\n+\tDECL_SOURCE_LINE (name) = lineno;\n+      CLASSTYPE_SOURCE_LINE (t) = lineno;\n+      name = DECL_NAME (name);\n+    }\n+\n+  /* Append the fields we need for constructing signature tables.  */\n+  if (IS_SIGNATURE (t))\n+    append_signature_fields (list_of_fieldlists);\n+\n+  tail = &fn_fields;\n+  if (last_x && list_of_fieldlists)\n+    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n+\n+  /* For signatures, we made all methods `public' in the parser and\n+     reported an error if a access specifier was used.  */\n+  if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n+    {\n+      if (list_of_fieldlists\n+\t  && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n+\tTREE_PURPOSE (list_of_fieldlists) = (tree)access_public;\n+    }\n+  else if (list_of_fieldlists\n+\t   && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n+    TREE_PURPOSE (list_of_fieldlists) = (tree)access_private;\n+\n+  while (list_of_fieldlists)\n+    {\n+      access = (enum access_type)TREE_PURPOSE (list_of_fieldlists);\n+\n+      for (x = TREE_VALUE (list_of_fieldlists); x; x = TREE_CHAIN (x))\n+\t{\n+\t  TREE_PRIVATE (x) = access == access_private;\n+\t  TREE_PROTECTED (x) = access == access_protected;\n+\n+\t  /* Check for inconsistent use of this name in the class body.\n+             Enums, types and static vars have already been checked.  */\n+\t  if (TREE_CODE (x) != TYPE_DECL\n+\t      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n+\t    {\n+\t      tree name = DECL_NAME (x);\n+\t      tree icv;\n+\n+\t      /* Don't get confused by access decls.  */\n+\t      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t\ticv = IDENTIFIER_CLASS_VALUE (name);\n+\t      else\n+\t\ticv = NULL_TREE;\n+\n+\t      if (icv\n+\t\t  /* Don't complain about constructors.  */\n+\t\t  && name != constructor_name (current_class_type)\n+\t\t  /* Or inherited names.  */\n+\t\t  && id_in_current_class (name)\n+\t\t  /* Or shadowed tags.  */\n+\t\t  && !(TREE_CODE (icv) == TYPE_DECL\n+\t\t       && DECL_CONTEXT (icv) == t))\n+\t\t{\n+\t\t  cp_error_at (\"declaration of identifier `%D' as `%+#D'\",\n+\t\t\t       name, x);\n+\t\t  cp_error_at (\"conflicts with other use in class as `%#D'\",\n+\t\t\t       icv);\n+\t\t}\n+\t    }\n+\n+\t  if (TREE_CODE (x) == FUNCTION_DECL)\n+\t    {\n+\t      if (last_x)\n+\t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n+\t      /* Link x onto end of fn_fields and CLASSTYPE_METHODS. */\n+\t      *tail = x;\n+\t      tail = &TREE_CHAIN (x);\n+\t      *tail_user_methods = x;\n+\t      tail_user_methods = &DECL_NEXT_METHOD (x);\n+\t      continue;\n+\t    }\n+\n+#if 0\n+\t  /* Handle access declarations.  */\n+\t  if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n+\t    {\n+\t      tree n = DECL_NAME (x);\n+\t      x = build_decl\n+\t\t(USING_DECL, DECL_NAME (TREE_OPERAND (n, 1)), TREE_TYPE (x));\n+\t      DECL_RESULT (x) = n;\n+\t    }\n+#endif\n+\n+\t  if (! fields)\n+\t    fields = x;\n+\t  last_x = x;\n+\t}\n+      list_of_fieldlists = TREE_CHAIN (list_of_fieldlists);\n+      /* link the tail while we have it! */\n+      if (last_x)\n+\t{\n+\t  TREE_CHAIN (last_x) = NULL_TREE;\n+\n+\t  if (list_of_fieldlists\n+\t      && TREE_VALUE (list_of_fieldlists)\n+\t      && TREE_CODE (TREE_VALUE (list_of_fieldlists)) != FUNCTION_DECL)\n+\t    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n+\t}\n+    }\n+\n+  *tail = NULL_TREE;\n+  *tail_user_methods = NULL_TREE;\n+  TYPE_FIELDS (t) = fields;\n+\n+  if (0 && processing_template_defn)\n+    {\n+      CLASSTYPE_METHOD_VEC (t) = finish_struct_methods (t, fn_fields, 1);\n+      return t;\n+    }\n+  else\n+    return finish_struct_1 (t, warn_anon);\n+}\n \f\n /* Return non-zero if the effective type of INSTANCE is static.\n    Used to determine whether the virtual function table is needed\n@@ -4452,7 +4520,7 @@ push_nested_class (type, modify)\n {\n   tree context;\n \n-  if (type == error_mark_node || ! IS_AGGR_TYPE (type))\n+  if (type == NULL_TREE || type == error_mark_node || ! IS_AGGR_TYPE (type))\n     return;\n   \n   context = DECL_CONTEXT (TYPE_NAME (type));"}, {"sha": "82b7954e29c0df10083d05ca2a9f7d7b02031837", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -35,6 +35,15 @@ DEFTREECODE (CP_OFFSET_REF, \"cp_offset_ref\", \"r\", 2)\n DEFTREECODE (DELETE_EXPR, \"dl_expr\", \"e\", 2)\n DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", \"e\", 2)\n \n+/* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n+   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n+   WITH_CLEANUP_EXPRs, CALL_EXPRs and RTL_EXPRs, that are protected\n+   from being evaluated more than once should be reset so that a new\n+   expand_expr call of this expr will cause those to be re-evaluated.\n+   This is useful when we want to reuse a tree in different places,\n+   but where we must re-expand.  */\n+DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", \"e\", 1)\n+\n /* Value is reference to particular overloaded class method.\n    Operand 0 is the class name (an IDENTIFIER_NODE);\n    operand 1 is the field (also an IDENTIFIER_NODE)."}, {"sha": "fe9855d8ca04a61ba87491448135e566348e5400", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -450,11 +450,12 @@ struct lang_type\n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n+      unsigned non_aggregate : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 20;\n+      unsigned dummy : 19;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -1054,6 +1055,9 @@ struct lang_decl\n    class where a virtual function instance is actually defined, and the\n    lexical scope of a friend function defined in a class body.  */\n #define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n+#define DECL_REAL_CONTEXT(NODE) \\\n+  ((TREE_CODE (NODE) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (NODE)) \\\n+   ? DECL_CLASS_CONTEXT (NODE) : DECL_CONTEXT (NODE))\n \n /* For a FUNCTION_DECL: the chain through which the next method\n    in the method chain is found.  We now use TREE_CHAIN to\n@@ -1068,7 +1072,7 @@ struct lang_decl\n #define DECL_NEXT_METHOD(NODE) (DECL_LANG_SPECIFIC(NODE)->next_method)\n \n /* In a VAR_DECL for a variable declared in a for statement,\n-   this is the shadowed (local) variable. */\n+   this is the shadowed variable. */\n #define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(NODE)\n \n /* Points back to the decl which caused this lang_decl to be allocated.  */\n@@ -1218,6 +1222,13 @@ extern int flag_new_for_scope;\n #define TYPE_NEEDS_CONSTRUCTING(NODE) (TYPE_LANG_FLAG_3(NODE))\n #endif\n \n+/* Nonzero means that an object of this type can not be initialized using\n+   an initializer list.  */\n+#define CLASSTYPE_NON_AGGREGATE(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->type_flags.non_aggregate)\n+#define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n+  (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n+\n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)\n@@ -1953,6 +1964,7 @@ extern int root_lang_context_p\t\t\tPROTO((void));\n extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n+extern unsigned HOST_WIDE_INT skip_rtti_stuff\tPROTO((tree *));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -2030,16 +2042,18 @@ extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int, int));\n extern void expand_static_init\t\t\tPROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n-extern tree grokdeclarator\t\t\t(); /* PROTO((tree, tree, enum decl_context, int, tree)); */\n+/* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree));\n extern tree grok_enum_decls\t\t\tPROTO((tree, tree));\n-extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n+extern int start_function\t\t\tPROTO((tree, tree, tree, tree, int));\n extern void store_parm_decls\t\t\tPROTO((void));\n+extern void expand_start_early_try_stmts\tPROTO((void));\n+extern void store_in_parms\t\t\tPROTO((struct rtx_def *));\n extern void store_return_init\t\t\tPROTO((tree, tree));\n extern void finish_function\t\t\tPROTO((int, int, int));\n extern tree start_method\t\t\tPROTO((tree, tree, tree));\n@@ -2059,8 +2073,8 @@ extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n-extern void check_classfn\t\t\tPROTO((tree, tree, tree));\n-extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n+extern tree check_classfn\t\t\tPROTO((tree, tree, tree));\n+extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n extern tree grokoptypename\t\t\tPROTO((tree, tree));\n@@ -2093,6 +2107,7 @@ extern tree do_toplevel_using_decl\t\tPROTO((tree));\n extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern tree current_namespace_id\t\tPROTO((tree));\n extern tree get_namespace_id\t\t\tPROTO((void));\n+extern void check_default_args\t\t\tPROTO((tree));\n \n /* in edsel.c */\n \n@@ -2113,12 +2128,16 @@ extern int might_have_exceptions_p\t\tPROTO((void));\n extern void emit_exception_table\t\tPROTO((void));\n extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n+extern void expand_builtin_throw\t\tPROTO((void));\n+extern void expand_start_eh_spec\t\tPROTO((void));\n+extern void expand_end_eh_spec\t\t\tPROTO((tree));\n \n /* in expr.c */\n /* skip cplus_expand_expr */\n extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern int decl_in_memory_p\t\t\tPROTO((tree));\n+extern tree unsave_expr_now\t\t\tPROTO((tree));\n \n /* in gc.c */\n extern int type_needs_gc_entry\t\t\tPROTO((tree));\n@@ -2232,6 +2251,7 @@ extern char *code_as_string\t\t\tPROTO((enum tree_code, int));\n extern char *language_as_string\t\t\tPROTO((enum languages, int));\n extern char *parm_as_string\t\t\tPROTO((int, int));\n extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *cv_as_string\t\t\tPROTO((tree, int));\n \n /* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n@@ -2367,13 +2387,15 @@ extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n extern int is_aggr_type_2\t\t\tPROTO((tree, tree));\n extern void message_2_types\t\t\tPROTO((void (*)(), char *, tree, tree));\n extern char *lang_printable_name\t\tPROTO((tree));\n-extern tree build_exception_variant\t\tPROTO((tree, tree, tree));\n+extern tree build_exception_variant\t\tPROTO((tree, tree));\n extern tree copy_to_permanent\t\t\tPROTO((tree));\n extern void print_lang_statistics\t\tPROTO((void));\n /* skip __eprintf */\n extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n extern tree break_out_target_exprs\t\tPROTO((tree));\n+extern tree build_unsave_expr\t\t\tPROTO((tree));\n+extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));\n@@ -2397,6 +2419,7 @@ extern tree signed_or_unsigned_type\t\tPROTO((int, tree));\n extern tree c_sizeof\t\t\t\tPROTO((tree));\n extern tree c_sizeof_nowarn\t\t\tPROTO((tree));\n extern tree c_alignof\t\t\t\tPROTO((tree));\n+extern tree decay_conversion\t\t\tPROTO((tree));\n extern tree default_conversion\t\t\tPROTO((tree));\n extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));\n extern tree build_component_ref_1\t\tPROTO((tree, tree, int));"}, {"sha": "56508c1cd30f7e58365aeeb51723e4cc6c17c75f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 35, "deletions": 73, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -180,6 +180,15 @@ cp_convert_to_pointer (type, expr)\n \t    return error_mark_node;\n \t}\n \n+      if (TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE\n+\t  || (TREE_CODE (type) == POINTER_TYPE\n+\t      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n+\t{\n+\t  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+\t\t    expr, intype, type);\n+\t  return error_mark_node;\n+\t}\n+\n       return build1 (NOP_EXPR, type, expr);\n     }\n \n@@ -904,7 +913,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \n   /* The type of the first argument will be filled in inside the loop.  */\n   parmlist = tree_cons (NULL_TREE, integer_zero_node, parmlist);\n-  parmtypes = tree_cons (NULL_TREE, TYPE_POINTER_TO (basetype), parmtypes);\n+  parmtypes = tree_cons (NULL_TREE, build_pointer_type (basetype), parmtypes);\n \n #if 0\n   method_name = build_decl_overload (name, parmtypes, 1);\n@@ -1164,32 +1173,6 @@ convert_pointer_to (binfo, expr)\n       type = binfo;\n   return convert_pointer_to_real (type, expr);\n }\n-\n-/* Same as above, but don't abort if we get an \"ambiguous\" baseclass.\n-   There's only one virtual baseclass we are looking for, and once\n-   we find one such virtual baseclass, we have found them all.  */\n-\n-tree\n-convert_pointer_to_vbase (binfo, expr)\n-     tree binfo;\n-     tree expr;\n-{\n-  tree intype = TREE_TYPE (TREE_TYPE (expr));\n-  tree binfos = TYPE_BINFO_BASETYPES (intype);\n-  int i;\n-\n-  for (i = TREE_VEC_LENGTH (binfos)-1; i >= 0; i--)\n-    {\n-      tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n-      if (BINFO_TYPE (binfo) == basetype)\n-\treturn convert_pointer_to (binfo, expr);\n-      if (binfo_member (BINFO_TYPE (binfo), CLASSTYPE_VBASECLASSES (basetype)))\n-\treturn convert_pointer_to_vbase (binfo, convert_pointer_to (basetype, expr));\n-    }\n-  my_friendly_abort (6);\n-  /* NOTREACHED */\n-  return NULL_TREE;\n-}\n \f\n /* Conversion...\n \n@@ -1374,44 +1357,7 @@ cp_convert (type, expr, convtype, flags)\n \treturn conversion;\n       else if (ctor)\n \t{\n-\t  if (current_function_decl)\n-\t    /* We can't pass 1 to the with_cleanup_p arg here, because that\n-\t       screws up passing classes by value.  */\n-\t    ctor = build_cplus_new (type, ctor, 0);\n-\t  else\n-\t    {\n-\t      register tree parm = TREE_OPERAND (ctor, 1);\n-\n-\t      /* Initializers for static variables and parameters\n-\t\t have to handle doing the initialization and\n-\t\t cleanup themselves.  */\n-\t      my_friendly_assert (TREE_CODE (ctor) == CALL_EXPR, 322);\n-#if 0\n-\t      /* The following assertion fails in cases where we\n-\t\t are initializing a static member variable of a\n-\t\t particular instance of a template class with a\n-\t\t call to a constructor of the given instance, as\n-\t\t in:\n-\t\t \n-\t\t TMPL<int> object = TMPL<int>();\n-\t\t \n-\t\t Curiously, the assertion does not fail if we do\n-\t\t the same thing for a static member of a\n-\t\t non-template class, as in:\n-\t\t \n-\t\t T object = T();\n-\t\t \n-\t\t I can't see why we should care here whether or not\n-\t\t the initializer expression involves a call to\n-\t\t `new', so for the time being, it seems best to\n-\t\t just avoid doing this assertion.  */\n-\t      my_friendly_assert (TREE_CALLS_NEW (TREE_VALUE (parm)),\n-\t\t\t\t  323);\n-#endif\n-\t      TREE_VALUE (parm) = NULL_TREE;\n-\t      ctor = build_indirect_ref (ctor, NULL_PTR);\n-\t      TREE_HAS_CONSTRUCTOR (ctor) = 1;\n-\t    }\n+\t  ctor = build_cplus_new (type, ctor, 0);\n \t  return ctor;\n \t}\n     }\n@@ -1524,7 +1470,14 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n \n    If (FOR_SURE & 1) is non-zero, then we allow this type conversion\n    to take place immediately.  Otherwise, we build a SAVE_EXPR\n-   which can be evaluated if the results are ever needed.  */\n+   which can be evaluated if the results are ever needed.\n+\n+   Changes to this functions should be mirrored in user_harshness.\n+\n+   FIXME: Ambiguity checking is wrong.  Should choose one by the implicit\n+   object parameter, or by the second standard conversion sequence if\n+   that doesn't do it.  This will probably wait for an overloading rewrite.\n+   (jason 8/9/95)  */\n \n tree\n build_type_conversion (code, xtype, expr, for_sure)\n@@ -1604,10 +1557,9 @@ build_expr_type_conversion (desires, expr, complain)\n   tree winner = NULL_TREE;\n \n   if (TREE_CODE (basetype) == OFFSET_TYPE)\n-    {\n-      expr = resolve_offset_ref (expr);\n-      basetype = TREE_TYPE (expr);\n-    }\n+    expr = resolve_offset_ref (expr);\n+  expr = convert_from_reference (expr);\n+  basetype = TREE_TYPE (expr);\n \n   if (! IS_AGGR_TYPE (basetype))\n     switch (TREE_CODE (basetype))\n@@ -1641,11 +1593,16 @@ build_expr_type_conversion (desires, expr, complain)\n   for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n     {\n       int win = 0;\n+      tree candidate;\n \n       if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n \tcontinue;\n \n-      switch (TREE_CODE (TREE_VALUE (conv)))\n+      candidate = TREE_VALUE (conv);\n+      if (TREE_CODE (candidate) == REFERENCE_TYPE)\n+\tcandidate = TREE_TYPE (candidate);\n+\n+      switch (TREE_CODE (candidate))\n \t{\n \tcase BOOLEAN_TYPE:\n \tcase INTEGER_TYPE:\n@@ -1817,8 +1774,13 @@ tree\n type_promotes_to (type)\n      tree type;\n {\n-  int constp = TYPE_READONLY (type);\n-  int volatilep = TYPE_VOLATILE (type);\n+  int constp, volatilep;\n+\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  constp = TYPE_READONLY (type);\n+  volatilep = TYPE_VOLATILE (type);\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* bool always promotes to int (not unsigned), even if it's the same"}, {"sha": "b0453b6f82e6d9faf03d887fce06d978f2309cd7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 233, "deletions": 208, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -548,9 +548,9 @@ struct binding_level\n     /* The binding level which this one is contained in (inherits from).  */\n     struct binding_level *level_chain;\n \n-    /* Number of decls in `names' that have incomplete \n+    /* List of decls in `names' that have incomplete\n        structure or union types.  */\n-    unsigned int n_incomplete;\n+    tree incomplete;\n \n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ANSI-conforming code, but might\n@@ -1488,7 +1488,7 @@ print_binding_level (lvl)\n   fprintf (stderr, \" blocks=\");\n   fprintf (stderr, HOST_PTR_PRINTF, lvl->blocks);\n   fprintf (stderr, \" n_incomplete=%d parm_flag=%d keep=%d\",\n-\t   lvl->n_incomplete, lvl->parm_flag, lvl->keep);\n+\t   list_length (lvl->incomplete), lvl->parm_flag, lvl->keep);\n   if (lvl->tag_transparent)\n     fprintf (stderr, \" tag-transparent\");\n   if (lvl->more_cleanups_ok)\n@@ -2138,6 +2138,7 @@ pushtag (name, type, globalize)\n \t\t  d = make_type_decl (name, type);\n #else\n \t\t  d = build_decl (TYPE_DECL, name, type);\n+\t\t  DECL_ASSEMBLER_NAME (d) = current_namespace_id (DECL_ASSEMBLER_NAME (d));\n #endif\n \t\t  SET_DECL_ARTIFICIAL (d);\n #ifdef DWARF_DEBUGGING_INFO\n@@ -2806,9 +2807,9 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  tree ctype = NULL_TREE;\n \t  ctype = DECL_CLASS_CONTEXT (newdecl);\n-\t  TREE_TYPE (newdecl) = build_exception_variant (ctype, newtype,\n+\t  TREE_TYPE (newdecl) = build_exception_variant (newtype,\n \t\t\t\t\t\t\t TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl)));\n-\t  TREE_TYPE (olddecl) = build_exception_variant (ctype, newtype,\n+\t  TREE_TYPE (olddecl) = build_exception_variant (newtype,\n \t\t\t\t\t\t\t TYPE_RAISES_EXCEPTIONS (oldtype));\n \n \t  if (! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 0))\n@@ -3172,6 +3173,8 @@ pushdecl (x)\n #endif\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n+\t      else if (TREE_CODE (t) == FUNCTION_DECL)\n+\t\tcheck_default_args (t);\n \n \t      return t;\n \t    }\n@@ -3395,6 +3398,7 @@ pushdecl (x)\n \t      if (oldlocal != NULL_TREE && TREE_CODE (oldlocal) == PARM_DECL)\n \t\twarnstring = \"declaration of `%s' shadows a parameter\";\n \t      else if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n+\t\t       && current_class_decl\n \t\t       && !TREE_STATIC (name))\n \t\twarnstring = \"declaration of `%s' shadows a member of `this'\";\n \t      else if (oldlocal != NULL_TREE)\n@@ -3408,43 +3412,17 @@ pushdecl (x)\n \t}\n \n       if (TREE_CODE (x) == FUNCTION_DECL)\n-\t{\n-\t  /* This is probably the wrong place to check this, but it has to\n-             come after the call to duplicate_decls.  */\n-\t  tree arg = TYPE_ARG_TYPES (TREE_TYPE (x));\n-\t  int saw_def = 0, i = 1;\n-\t  for (; arg && arg != void_list_node; arg = TREE_CHAIN (arg), ++i)\n-\t    {\n-\t      if (TREE_PURPOSE (arg))\n-\t\tsaw_def = 1;\n-\t      else if (saw_def)\n-\t\t{\n-\t\t  cp_error (\"default argument missing for parameter %d of `%#D'\",\n-\t\t\t    i, x);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Keep count of variables in this level with incomplete type.  */\n-      if (TREE_CODE (x) != TEMPLATE_DECL\n-\t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n-\t  && PROMOTES_TO_AGGR_TYPE (TREE_TYPE (x), ARRAY_TYPE))\n-\t{\n-\t  if (++b->n_incomplete == 0)\n-\t    error (\"too many incomplete variables at this point\");\n-\t}\n+\tcheck_default_args (x);\n \n       /* Keep count of variables in this level with incomplete type.  */\n-      /* RTTI TD entries are created while defining the type_info.  */\n       if (TREE_CODE (x) == VAR_DECL\n \t  && TREE_TYPE (x) != error_mark_node\n-\t  && TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n-\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))\n-\t{\n-\t  if (++b->n_incomplete == 0)\n-\t    error (\"too many incomplete variables at this point\");\n-\t}\n+\t  && ((TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n+\t       && PROMOTES_TO_AGGR_TYPE (TREE_TYPE (x), ARRAY_TYPE))\n+\t      /* RTTI TD entries are created while defining the type_info.  */\n+\t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n+\t\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))))\n+\tb->incomplete = tree_cons (NULL_TREE, x, b->incomplete);\n     }\n \n   /* Put decls on list in reverse order.\n@@ -5428,11 +5406,11 @@ init_decl_processing ()\n       __i_desc_type_node = make_lang_type (RECORD_TYPE);\n       __m_desc_type_node = make_lang_type (RECORD_TYPE);\n       __t_desc_array_type =\n-\tbuild_array_type (TYPE_POINTER_TO (__t_desc_type_node), NULL_TREE);\n+\tbuild_array_type (build_pointer_type (__t_desc_type_node), NULL_TREE);\n       __i_desc_array_type =\n-\tbuild_array_type (TYPE_POINTER_TO (__i_desc_type_node), NULL_TREE);\n+\tbuild_array_type (build_pointer_type (__i_desc_type_node), NULL_TREE);\n       __m_desc_array_type =\n-\tbuild_array_type (TYPE_POINTER_TO (__m_desc_type_node), NULL_TREE);\n+\tbuild_array_type (build_pointer_type (__m_desc_type_node), NULL_TREE);\n \n       fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n \t\t\t\t\t string_type_node);\n@@ -5442,7 +5420,7 @@ init_decl_processing ()\n \t\t\t\t\t unsigned_type_node);\n       fields[3] = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t\t get_identifier (\"points_to\"),\n-\t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n+\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n       fields[4] = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t\t get_identifier (\"ivars_count\"),\n \t\t\t\t\t integer_type_node);\n@@ -5476,7 +5454,7 @@ init_decl_processing ()\n       fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"offset\"),\n \t\t\t\t\t integer_type_node);\n       fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n-\t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n+\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n       finish_builtin_type (__i_desc_type_node, \"__i_desc\", fields, 2,\n \t\t\t   integer_type_node);\n \n@@ -5500,17 +5478,17 @@ init_decl_processing ()\n       fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"vindex\"),\n \t\t\t\t\t integer_type_node);\n       fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"vcontext\"),\n-\t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n+\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n       fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier (\"return_type\"),\n-\t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n+\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n       fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"address\"),\n \t\t\t\t\t build_pointer_type (default_function_type));\n       fields[5] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parm_count\"),\n \t\t\t\t\t short_integer_type_node);\n       fields[6] = build_lang_field_decl (FIELD_DECL, get_identifier (\"required_parms\"),\n \t\t\t\t\t short_integer_type_node);\n       fields[7] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parm_types\"),\n-\t\t\t\t\t build_pointer_type (build_array_type (TYPE_POINTER_TO (__t_desc_type_node), NULL_TREE)));\n+\t\t\t\t\t build_pointer_type (build_array_type (build_pointer_type (__t_desc_type_node), NULL_TREE)));\n       finish_builtin_type (__m_desc_type_node, \"__m_desc\", fields, 7,\n \t\t\t   integer_type_node);\n     }\n@@ -5751,7 +5729,7 @@ shadow_tag (declspecs)\n       if (TYPE_FIELDS (t))\n \t{\n \t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n-\t\t\t\t      NULL_TREE);\n+\t\t\t\t      NULL_TREE, NULL_TREE);\n \t  finish_anon_union (decl);\n \t}\n       else\n@@ -5792,7 +5770,7 @@ groktypename (typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t TYPENAME, 0, NULL_TREE);\n+\t\t\t TYPENAME, 0, NULL_TREE, NULL_TREE);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -5836,7 +5814,8 @@ start_decl (declarator, declspecs, initialized, raises)\n       used_extern_spec = 1;\n     }\n \n-  decl = grokdeclarator (declarator, declspecs, NORMAL, initialized, raises);\n+  decl = grokdeclarator (declarator, declspecs, NORMAL, initialized, raises,\n+\t\t\t NULL_TREE);\n   if (decl == NULL_TREE || decl == void_type_node)\n     return NULL_TREE;\n \n@@ -6011,13 +5990,25 @@ start_decl (declarator, declspecs, initialized, raises)\n \t  else if (duplicate_decls (decl, field))\n \t    decl = field;\n \t}\n-      \n-      /* If it was not explicitly declared `extern',\n-\t revoke any previous claims of DECL_EXTERNAL.  */\n-      if (DECL_THIS_EXTERN (decl) == 0)\n-\tDECL_EXTERNAL (decl) = 0;\n+      else\n+\t{\n+\t  tree field = check_classfn (context, NULL_TREE, decl);\n+\t  if (field && duplicate_decls (decl, field))\n+\t    decl = field;\n+\t}\n+\n+      /* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */\n       if (DECL_LANG_SPECIFIC (decl))\n \tDECL_IN_AGGR_P (decl) = 0;\n+      if (DECL_USE_TEMPLATE (decl) || CLASSTYPE_USE_TEMPLATE (context))\n+\tSET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\n+      /* Stupid stupid stupid stupid  (jason 7/21/95) */\n+      if (pedantic && DECL_EXTERNAL (decl)\n+\t  && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n+\tcp_pedwarn (\"declaration of `%#D' outside of class is not definition\",\n+\t\t    decl);\n+\n       pushclass (context, 2);\n     }\n \n@@ -6164,7 +6155,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n     }\n \n   TREE_TYPE (tmp_addr) = build_pointer_type (target_type);\n-  DECL_INITIAL (decl) = convert (TYPE_POINTER_TO (target_type), tmp_addr);\n+  DECL_INITIAL (decl) = convert (build_pointer_type (target_type), tmp_addr);\n   TREE_TYPE (DECL_INITIAL (decl)) = type;\n   if (TYPE_NEEDS_CONSTRUCTING (target_type))\n     {\n@@ -6272,7 +6263,7 @@ grok_reference_init (decl, type, init, cleanupp)\n \t      if (TREE_CODE (tmp) == TARGET_EXPR)\n \t\t{\n \t\t  *cleanupp = build_delete\n-\t\t    (TYPE_POINTER_TO (subtype),\n+\t\t    (build_pointer_type (subtype),\n \t\t     build_unary_op (ADDR_EXPR, TREE_OPERAND (tmp, 0), 0),\n \t\t     integer_two_node, LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n \t\t  TREE_OPERAND (tmp, 2) = error_mark_node;\n@@ -6515,7 +6506,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t    init = digest_init (type, init, (tree *) 0);\n \t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n-\t      if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n \t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\",\n \t\t\t    decl);\n@@ -6524,47 +6515,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      else\n \t\tgoto dont_use_constructor;\n \t    }\n-#if 0\n-\t  /* fix this in `build_functional_cast' instead.\n-\t     Here's the trigger code:\n-\n-\t\tstruct ostream\n-\t\t{\n-\t\t  ostream ();\n-\t\t  ostream (int, char *);\n-\t\t  ostream (char *);\n-\t\t  operator char *();\n-\t\t  ostream (void *);\n-\t\t  operator void *();\n-\t\t  operator << (int);\n-\t\t};\n-\t\tint buf_size = 1024;\n-\t\tstatic char buf[buf_size];\n-\t\tconst char *debug(int i) {\n-\t\t  char *b = &buf[0];\n-\t\t  ostream o = ostream(buf_size, b);\n-\t\t  o << i;\n-\t\t  return buf;\n-\t\t}\n-\t\t*/\n-\n-\t  else if (TREE_CODE (init) == TARGET_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (init, 1) == NEW_EXPR))\n-\t    {\n-\t      /* User wrote something like `foo x = foo (args)'  */\n-\t      my_friendly_assert (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL, 150);\n-\t      my_friendly_assert (DECL_NAME (TREE_OPERAND (init, 0)) == NULL_TREE, 151);\n-\n-\t      /* User wrote exactly `foo x = foo (args)'  */\n-\t      if (TYPE_MAIN_VARIANT (type) == TREE_TYPE (init))\n-\t\t{\n-\t\t  init = build (CALL_EXPR, TREE_TYPE (init),\n-\t\t\t\tTREE_OPERAND (TREE_OPERAND (init, 1), 0),\n-\t\t\t\tTREE_OPERAND (TREE_OPERAND (init, 1), 1), 0);\n-\t\t  TREE_SIDE_EFFECTS (init) = 1;\n-\t\t}\n-\t    }\n-#endif\n \t}\n       else\n \t{\n@@ -6859,11 +6809,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       else if (TREE_STATIC (decl) && type != error_mark_node)\n \t{\n \t  /* Cleanups for static variables are handled by `finish_file'.  */\n-\t  if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE)\n+\t  if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n+\t      || TYPE_NEEDS_DESTRUCTOR (type))\n \t    expand_static_init (decl, init);\n-\t  else if (TYPE_NEEDS_DESTRUCTOR (type))\n-\t    static_aggregates = perm_tree_cons (NULL_TREE, decl,\n-\t\t\t\t\t\tstatic_aggregates);\n \n \t  /* Make entry in appropriate vector.  */\n \t  if (flag_gc && type_needs_gc_entry (type))\n@@ -6898,7 +6846,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t{\n \t\t  /* XXX: Why don't we use decl here?  */\n \t\t  /* Ans: Because it was already expanded? */\n-\t\t  if (! expand_decl_cleanup (NULL_TREE, cleanup))\n+\t\t  if (! cp_expand_decl_cleanup (NULL_TREE, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      decl);\n \t\t  /* Cleanup used up here.  */\n@@ -6928,7 +6876,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      /* Store the cleanup, if there was one.  */\n \t      if (cleanup)\n \t\t{\n-\t\t  if (! expand_decl_cleanup (decl, cleanup))\n+\t\t  if (! cp_expand_decl_cleanup (decl, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      decl);\n \t\t}\n@@ -6942,7 +6890,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t due to initialization of qualified member variable.\n \t I.e., Foo::x = 10;  */\n       {\n-\ttree context = DECL_CONTEXT (decl);\n+\ttree context = DECL_REAL_CONTEXT (decl);\n \tif (context\n \t    && TREE_CODE_CLASS (TREE_CODE (context)) == 't'\n \t    && (TREE_CODE (decl) == VAR_DECL\n@@ -7036,13 +6984,14 @@ expand_static_init (decl, init)\n       old_cleanups = cleanups_this_call;\n       expand_assignment (temp, integer_one_node, 0, 0);\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n-\t  || TREE_CODE (init) == TREE_LIST)\n+\t  || (init && TREE_CODE (init) == TREE_LIST))\n \t{\n \t  expand_aggr_init (decl, init, 0, 0);\n \t  do_pending_stack_adjust ();\n \t}\n-      else\n+      else if (init)\n \texpand_assignment (decl, init, 0, 0);\n+\n       /* Cleanup any temporaries needed for the initial value.  */\n       expand_cleanups_to (old_cleanups);\n       expand_end_cond ();\n@@ -7200,12 +7149,12 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    not look, and -1 if we should not call `grokclassfn' at all.  */\n static tree\n grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n-\t    raises, check, publicp, inlinep)\n+\t    raises, attrlist, check, publicp, inlinep)\n      tree ctype, type;\n      tree declarator;\n      int virtualp;\n      enum overload_flags flags;\n-     tree quals, raises;\n+     tree quals, raises, attrlist;\n      int check, publicp, inlinep;\n {\n   tree cname, decl;\n@@ -7219,7 +7168,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \n   if (raises)\n     {\n-      type = build_exception_variant (ctype, type, raises);\n+      type = build_exception_variant (type, raises);\n       raises = TYPE_RAISES_EXCEPTIONS (type);\n     }\n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n@@ -7340,6 +7289,10 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t      /* avoid creating circularities.  */\n \t      DECL_CHAIN (decl) = NULL_TREE;\n \t    }\n+\n+\t  if (attrlist)\n+\t    cplus_decl_attributes (decl, TREE_PURPOSE (attrlist),\n+\t\t\t\t   TREE_VALUE (attrlist));\n \t  make_decl_rtl (decl, NULL_PTR, 1);\n \t}\n \n@@ -7390,7 +7343,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t\t      type = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes);\n \t\t      if (raises)\n \t\t\t{\n-\t\t\t  type = build_exception_variant (ctype, type, raises);\n+\t\t\t  type = build_exception_variant (type, raises);\n \t\t\t  raises = TYPE_RAISES_EXCEPTIONS (type);\n \t\t\t}\n \t\t      TREE_TYPE (decl) = type;\n@@ -7500,6 +7453,7 @@ build_ptrmemfunc_type (type)\n   push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n \n   u = make_lang_type (UNION_TYPE);\n+  IS_AGGR_TYPE (u) = 0;\n   fields[0] = build_lang_field_decl (FIELD_DECL, pfn_identifier, type);\n   fields[1] = build_lang_field_decl (FIELD_DECL, delta2_identifier,\n \t\t\t\t     delta_type_node);\n@@ -7592,12 +7546,12 @@ build_ptrmemfunc_type (type)\n enum return_types { return_normal, return_ctor, return_dtor, return_conversion };\n \n tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n+grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrlist)\n      tree declspecs;\n      tree declarator;\n      enum decl_context decl_context;\n      int initialized;\n-     tree raises;\n+     tree raises, attrlist;\n {\n   RID_BIT_TYPE specbits;\n   int nclasses = 0;\n@@ -8034,7 +7988,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       if (return_type == return_dtor)\n \ttype = void_type_node;\n       else if (return_type == return_ctor)\n-\ttype = TYPE_POINTER_TO (ctor_return_type);\n+\ttype = build_pointer_type (ctor_return_type);\n       else if (return_type == return_conversion)\n \ttype = ctor_return_type;\n       else if (current_class_type\n@@ -8077,7 +8031,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   else if (return_type == return_ctor)\n     {\n       error (\"return type specification for constructor invalid\");\n-      type = TYPE_POINTER_TO (ctor_return_type);\n+      type = build_pointer_type (ctor_return_type);\n     }\n   else if (return_type == return_conversion)\n     {\n@@ -8244,16 +8198,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n-      else if (constp)\n-\t{\n-\t  error (\"const `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n-\t}\n-      else if (staticp)\n-\t{\n-\t  error (\"static `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n-\t}\n #if 0\n       if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n \t{\n@@ -8400,7 +8344,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    SIGNATURE_GROKKING_TYPEDEF (current_class_type) = 1;\n   \n \t  loc_typedecl =\n-\t    grokdeclarator (declarator, declspecs, FIELD, 0, NULL_TREE);\n+\t    grokdeclarator (declarator, declspecs, FIELD, 0, NULL_TREE, NULL_TREE);\n \n \t  if (previous_declspec)\n \t    TREE_CHAIN (previous_declspec) = scanner;\n@@ -8819,7 +8763,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t      if (RIDBIT_ANY_SET (tmp_bits))\n \t\t\terror (\"return value type specifier for constructor ignored\");\n \t\t    }\n-\t\t    type = TYPE_POINTER_TO (ctype);\n+\t\t    type = build_pointer_type (ctype);\n \t\t    if (decl_context == FIELD &&\n \t\t\tIS_SIGNATURE (current_class_type))\n \t\t      {\n@@ -9234,6 +9178,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n \n+  if (RIDBIT_SETP (RID_MUTABLE, specbits))\n+    {\n+      if (constp)\n+\t{\n+\t  error (\"const `%s' cannot be declared `mutable'\", name);\n+\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t}\n+      else if (staticp)\n+\t{\n+\t  error (\"static `%s' cannot be declared `mutable'\", name);\n+\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t}\n+    }\n+\n   if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n     {\n       tree decl;\n@@ -9524,8 +9482,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t       || RIDBIT_SETP (RID_EXTERN, specbits)\n \t\t       || ! (funcdef_flag < 0 || inlinep));\n \t    decl = grokfndecl (ctype, type, declarator,\n-\t\t\t       virtualp, flags, quals,\n-\t\t\t       raises, friendp ? -1 : 0, publicp, inlinep);\n+\t\t\t       virtualp, flags, quals, raises, attrlist,\n+\t\t\t       friendp ? -1 : 0, publicp, inlinep);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t    decl = build_decl_attribute_variant (decl, decl_machine_attr);\n@@ -9540,8 +9498,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    /* All method decls are public, so tell grokfndecl to set\n \t       TREE_PUBLIC, also.  */\n \t    decl = grokfndecl (ctype, type, declarator,\n-\t\t\t       virtualp, flags, quals,\n-\t\t\t       raises, friendp ? -1 : 0, 1, 0);\n+\t\t\t       virtualp, flags, quals, raises, attrlist,\n+\t\t\t       friendp ? -1 : 0, 1, 0);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t  }\n@@ -9634,6 +9592,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    if (staticp || (constp && initialized))\n \t      {\n+\t\t/* ANSI C++ Apr '95 wp 9.2 */\n+\t\tif (staticp && declarator == current_class_name)\n+\t\t  cp_pedwarn (\"ANSI C++ forbids static member `%D' with same name as enclosing class\",\n+\t\t\t      declarator);\n+\n \t\t/* C++ allows static class members.\n \t\t   All other work for this is done by grokfield.\n \t\t   This VAR_DECL is built by build_lang_field_decl.\n@@ -9715,8 +9678,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t       && !RIDBIT_SETP (RID_INLINE, specbits)));\n \n \tdecl = grokfndecl (ctype, type, original_name,\n-\t\t\t   virtualp, flags, quals,\n-\t\t\t   raises,\n+\t\t\t   virtualp, flags, quals, raises, attrlist,\n \t\t\t   processing_template_decl ? 0 : friendp ? 2 : 1,\n \t\t\t   publicp, inlinep);\n \tif (decl == NULL_TREE)\n@@ -9789,8 +9751,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-\t        cp_error (\"static member `%D' re-declared as static\",\n-\t\t\t  decl);\n+\t        cp_pedwarn (\"static member `%D' re-declared as static\", decl);\n \t        staticp = 0;\n \t\tRIDBIT_RESET (RID_STATIC, specbits);\n \t      }\n@@ -9799,10 +9760,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tcp_error (\"static member `%D' declared `register'\", decl);\n \t\tRIDBIT_RESET (RID_REGISTER, specbits);\n \t      }\n-\t    if (RIDBIT_SETP (RID_EXTERN, specbits))\n+\t    if (RIDBIT_SETP (RID_EXTERN, specbits) && pedantic)\n \t      {\n-\t        cp_error (\"cannot explicitly declare member `%#D' to have extern linkage\",\n-\t\t\t  decl);\n+\t        cp_pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n+\t\t\t    decl);\n \t\tRIDBIT_RESET (RID_EXTERN, specbits);\n \t      }\n \t  }\n@@ -10005,7 +9966,8 @@ grokparms (first_parm, funcdef_flag)\n \t\t  /* @@ May need to fetch out a `raises' here.  */\n \t\t  decl = grokdeclarator (TREE_VALUE (decl),\n \t\t\t\t\t TREE_PURPOSE (decl),\n-\t\t\t\t\t PARM, init != NULL_TREE, NULL_TREE);\n+\t\t\t\t\t PARM, init != NULL_TREE,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n \t\t  if (! decl)\n \t\t    continue;\n \t\t  type = TREE_TYPE (decl);\n@@ -11130,8 +11092,8 @@ grok_enum_decls (type, decl)\n    @@ something we had previously.  */\n \n int\n-start_function (declspecs, declarator, raises, pre_parsed_p)\n-     tree declarator, declspecs, raises;\n+start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n+     tree declspecs, declarator, raises, attrs;\n      int pre_parsed_p;\n {\n   tree decl1, olddecl;\n@@ -11162,6 +11124,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   protect_list = NULL_TREE;\n   current_base_init_list = NULL_TREE;\n   current_member_init_list = NULL_TREE;\n+  ctor_label = dtor_label = NULL_TREE;\n \n   clear_temp_name ();\n \n@@ -11236,7 +11199,8 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n     }\n   else\n     {\n-      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, raises);\n+      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, raises,\n+\t\t\t      NULL_TREE);\n       /* If the declarator is not suitable for a function definition,\n \t cause a syntax error.  */\n       if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL) return 0;\n@@ -11311,7 +11275,10 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \tTREE_TYPE (decl1)\n \t  = build_function_type (void_type_node,\n \t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (decl1)));\n-      DECL_RESULT (decl1) = build_decl (RESULT_DECL, 0, TREE_TYPE (fntype));\n+      DECL_RESULT (decl1)\n+\t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (fntype)));\n+      TREE_READONLY (DECL_RESULT (decl1)) = TYPE_READONLY (TREE_TYPE (fntype));\n+      TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = TYPE_VOLATILE (TREE_TYPE (fntype));\n     }\n \n   if (TYPE_LANG_SPECIFIC (TREE_TYPE (fntype))\n@@ -11445,6 +11412,8 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \n   GNU_xref_function (decl1, current_function_parms);\n \n+  if (attrs)\n+    cplus_decl_attributes (decl1, NULL_TREE, attrs);\n   make_function_rtl (decl1);\n \n   /* Allocate further tree nodes temporarily during compilation\n@@ -11465,9 +11434,15 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \trestype = integer_type_node;\n     }\n   if (DECL_RESULT (decl1) == NULL_TREE)\n-    DECL_RESULT (decl1) = build_decl (RESULT_DECL, 0, restype);\n+    {\n+      DECL_RESULT (decl1)\n+\t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (restype));\n+      TREE_READONLY (DECL_RESULT (decl1)) = TYPE_READONLY (restype);\n+      TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = TYPE_VOLATILE (restype);\n+    }\n \n-  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1)))\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n+      && DECL_LANGUAGE (decl1) == lang_cplusplus)\n     {\n       dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       ctor_label = NULL_TREE;\n@@ -11487,6 +11462,30 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   return 1;\n }\n \f\n+void\n+expand_start_early_try_stmts ()\n+{\n+  rtx insns;\n+  start_sequence ();\n+  expand_start_try_stmts ();\n+  insns = get_insns ();\n+  end_sequence ();\n+  store_in_parms (insns);\n+}\n+\n+void\n+store_in_parms (insns)\n+     rtx insns;\n+{\n+  rtx last_parm_insn;\n+\n+  last_parm_insn = get_first_nonparm_insn ();\n+  if (last_parm_insn == NULL_RTX)\n+    emit_insns (insns);\n+  else\n+    emit_insns_before (insns, previous_insn (last_parm_insn));\n+}\n+\n /* Store the parameter declarations into the current function declaration.\n    This is called after parsing the parameter declarations, before\n    digesting the body of the function.\n@@ -11576,7 +11575,7 @@ store_parm_decls ()\n \t      if (cleanup)\n \t\t{\n \t\t  expand_decl (parm);\n-\t\t  if (! expand_decl_cleanup (parm, cleanup))\n+\t\t  if (! cp_expand_decl_cleanup (parm, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      parm);\n \t\t  parms_have_cleanups = 1;\n@@ -11626,7 +11625,7 @@ store_parm_decls ()\n   if (flag_gc)\n     {\n       maybe_gc_cleanup = build_tree_list (NULL_TREE, error_mark_node);\n-      if (! expand_decl_cleanup (NULL_TREE, maybe_gc_cleanup))\n+      if (! cp_expand_decl_cleanup (NULL_TREE, maybe_gc_cleanup))\n \tcp_error (\"parser lost in parsing declaration of `%D'\", fndecl);\n     }\n \n@@ -11648,6 +11647,26 @@ store_parm_decls ()\n \toutput_builtin_tdesc_entries ();\n #endif\n     }\n+\n+  /* Take care of exception handling things. */\n+  if (flag_handle_exceptions)\n+    {\n+      rtx insns;\n+      start_sequence ();\n+\n+      /* Mark the start of a stack unwinder if we need one.  */\n+      start_eh_unwinder ();\n+\n+      /* Do the starting of the exception specifications, if we have any.  */\n+      if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n+\texpand_start_eh_spec ();\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      if (insns)\n+\tstore_in_parms (insns);\n+    }\n }\n \n /* Bind a name and initialization to the return value of\n@@ -11722,7 +11741,7 @@ finish_function (lineno, call_poplevel, nested)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n-  rtx head, last_parm_insn, mark;\n+  rtx last_parm_insn, insns;\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n   tree decls = NULL_TREE;\n@@ -11784,12 +11803,9 @@ finish_function (lineno, call_poplevel, nested)\n \n \t  /* If this destructor is empty, then we don't need to check\n \t     whether `this' is NULL in some cases.  */\n-\t  mark = get_last_insn ();\n-\t  last_parm_insn = get_first_nonparm_insn ();\n-\n \t  if ((flag_this_is_variable & 1) == 0)\n \t    ok_to_optimize_dtor = 1;\n-\t  else if (mark == last_parm_insn)\n+\t  else if (get_last_insn () == get_first_nonparm_insn ())\n \t    ok_to_optimize_dtor\n \t      = (n_baseclasses == 0\n \t\t || (n_baseclasses == 1\n@@ -11854,8 +11870,8 @@ finish_function (lineno, call_poplevel, nested)\n \t\t{\n \t\t  if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n \t\t    {\n-\t\t      tree ptr = convert_pointer_to_vbase (vbases, current_class_decl);\n-\t\t      expand_expr_stmt (build_delete (TYPE_POINTER_TO (BINFO_TYPE (vbases)),\n+\t\t      tree ptr = convert_pointer_to_vbase (BINFO_TYPE (vbases), current_class_decl);\n+\t\t      expand_expr_stmt (build_delete (build_pointer_type (BINFO_TYPE (vbases)),\n \t\t\t\t\t\t      ptr, integer_zero_node,\n \t\t\t\t\t\t      LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_HAS_IN_CHARGE, 0));\n \t\t    }\n@@ -11879,7 +11895,7 @@ finish_function (lineno, call_poplevel, nested)\n \texprstmt =\n \t  build_method_call\n \t    (build_indirect_ref\n-\t     (build1 (NOP_EXPR, TYPE_POINTER_TO (current_class_type),\n+\t     (build1 (NOP_EXPR, build_pointer_type (current_class_type),\n \t\t      error_mark_node),\n \t      NULL_PTR),\n \t     ansi_opname[(int) DELETE_EXPR],\n@@ -11907,12 +11923,8 @@ finish_function (lineno, call_poplevel, nested)\n \n       /* Back to the top of destructor.  */\n       /* Dont execute destructor code if `this' is NULL.  */\n-      mark = get_last_insn ();\n-      last_parm_insn = get_first_nonparm_insn ();\n-      if (last_parm_insn == NULL_RTX)\n-\tlast_parm_insn = mark;\n-      else\n-\tlast_parm_insn = previous_insn (last_parm_insn);\n+\n+      start_sequence ();\n \n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n@@ -11926,8 +11938,18 @@ finish_function (lineno, call_poplevel, nested)\n \t\t\t\t  current_class_decl, integer_zero_node, 1);\n \t  expand_start_cond (cond, 0);\n \t}\n-      if (mark != get_last_insn ())\n-\treorder_insns (next_insn (mark), get_last_insn (), last_parm_insn);\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      last_parm_insn = get_first_nonparm_insn ();\n+      if (last_parm_insn == NULL_RTX)\n+\tlast_parm_insn = get_last_insn ();\n+      else\n+\tlast_parm_insn = previous_insn (last_parm_insn);\n+\n+      emit_insns_after (insns, last_parm_insn);\n+\n       if (! ok_to_optimize_dtor)\n \texpand_end_cond ();\n     }\n@@ -11981,11 +12003,7 @@ finish_function (lineno, call_poplevel, nested)\n \n       CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = abstract_virtuals;\n \n-      /* must keep the first insn safe.  */\n-      head = get_insns ();\n-\n-      /* this note will come up to the top with us.  */\n-      mark = get_last_insn ();\n+      start_sequence ();\n \n       if (flag_this_is_variable > 0)\n \t{\n@@ -12008,6 +12026,9 @@ finish_function (lineno, call_poplevel, nested)\n \t  base_init_expr = NULL_TREE;\n \t}\n \n+      insns = get_insns ();\n+      end_sequence ();\n+\n       /* This is where the body of the constructor begins.\n \t If there were no insns in this function body, then the\n \t last_parm_insn is also the last insn.\n@@ -12016,12 +12037,11 @@ finish_function (lineno, call_poplevel, nested)\n \t we don't hold on to it (across emit_base_init).  */\n       last_parm_insn = get_first_nonparm_insn ();\n       if (last_parm_insn == NULL_RTX)\n-\tlast_parm_insn = mark;\n+\tlast_parm_insn = get_last_insn ();\n       else\n \tlast_parm_insn = previous_insn (last_parm_insn);\n \n-      if (mark != get_last_insn ())\n-\treorder_insns (next_insn (mark), get_last_insn (), last_parm_insn);\n+      emit_insns_after (insns, last_parm_insn);\n \n       end_protect_partials ();\n \n@@ -12118,7 +12138,7 @@ finish_function (lineno, call_poplevel, nested)\n   expand_function_end (input_filename, lineno, 1);\n \n   if (flag_handle_exceptions)\n-    expand_exception_blocks();\n+    expand_exception_blocks ();\n \n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n@@ -12259,7 +12279,8 @@ tree\n start_method (declspecs, declarator, raises)\n      tree declarator, declspecs, raises;\n {\n-  tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0, raises);\n+  tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0, raises,\n+\t\t\t\tNULL_TREE);\n \n   /* Something too ugly to handle.  */\n   if (fndecl == NULL_TREE)\n@@ -12430,46 +12451,43 @@ void\n hack_incomplete_structures (type)\n      tree type;\n {\n-  tree decl;\n+  tree *list;\n \n-  if (current_binding_level->n_incomplete == 0)\n+  if (current_binding_level->incomplete == NULL_TREE)\n     return;\n \n   if (!type) /* Don't do this for class templates.  */\n     return;\n \n-  for (decl = current_binding_level->names; decl; decl = TREE_CHAIN (decl))\n-    if (TREE_TYPE (decl) == type\n-\t|| (TREE_TYPE (decl)\n-\t    && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t    && TREE_TYPE (TREE_TYPE (decl)) == type))\n-      {\n-\tif (TREE_CODE (decl) == TYPE_DECL)\n-\t  layout_type (TREE_TYPE (decl));\n-\telse\n-\t  {\n-\t    int toplevel = toplevel_bindings_p ();\n-\t    if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t\t&& TREE_TYPE (TREE_TYPE (decl)) == type)\n-\t      layout_type (TREE_TYPE (decl));\n-\t    layout_decl (decl, 0);\n-\t    rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n-\t    if (! toplevel)\n-\t      {\n-\t\ttree cleanup;\n-\t\texpand_decl (decl);\n-\t\tcleanup = maybe_build_cleanup (decl);\n-\t\texpand_decl_init (decl);\n-\t\tif (! expand_decl_cleanup (decl, cleanup))\n-\t\t  cp_error (\"parser lost in parsing declaration of `%D'\",\n-\t\t\t    decl);\n-\t      }\n-\t  }\n-\t/*\n-\tmy_friendly_assert (current_binding_level->n_incomplete > 0, 164);\n-\t*/\n-\t--current_binding_level->n_incomplete;\n-      }\n+  for (list = &current_binding_level->incomplete; *list; )\n+    {\n+      tree decl = TREE_VALUE (*list);\n+      if (decl && TREE_TYPE (decl) == type\n+\t  || (TREE_TYPE (decl)\n+\t      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t      && TREE_TYPE (TREE_TYPE (decl)) == type))\n+\t{\n+\t  int toplevel = toplevel_bindings_p ();\n+\t  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t      && TREE_TYPE (TREE_TYPE (decl)) == type)\n+\t    layout_type (TREE_TYPE (decl));\n+\t  layout_decl (decl, 0);\n+\t  rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n+\t  if (! toplevel)\n+\t    {\n+\t      tree cleanup;\n+\t      expand_decl (decl);\n+\t      cleanup = maybe_build_cleanup (decl);\n+\t      expand_decl_init (decl);\n+\t      if (! cp_expand_decl_cleanup (decl, cleanup))\n+\t\tcp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t  decl);\n+\t    }\n+\t  *list = TREE_CHAIN (*list);\n+\t}\n+      else\n+\tlist = &TREE_CHAIN (*list);\n+    }\n }\n \n /* Nonzero if presently building a cleanup.  Needed because\n@@ -12620,13 +12638,20 @@ revert_static_member_fn (decl, fn, argtypes)\n   tree function = fn ? *fn : TREE_TYPE (*decl);\n   tree args = argtypes ? *argtypes : TYPE_ARG_TYPES (function);\n \n+  if (TYPE_READONLY (TREE_TYPE (TREE_VALUE (args))))\n+    cp_error (\"static member function `%#D' declared const\", *decl);\n+  if (TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (args))))\n+    cp_error (\"static member function `%#D' declared volatile\", *decl);\n+\n   args = TREE_CHAIN (args);\n   tmp = build_function_type (TREE_TYPE (function), args);\n   tmp = build_type_variant (tmp, TYPE_READONLY (function),\n \t\t\t    TYPE_VOLATILE (function));\n-  tmp = build_exception_variant (TYPE_METHOD_BASETYPE (function), tmp,\n+  tmp = build_exception_variant (tmp,\n \t\t\t\t TYPE_RAISES_EXCEPTIONS (function));\n   TREE_TYPE (*decl) = tmp;\n+  if (DECL_ARGUMENTS (*decl))\n+    DECL_ARGUMENTS (*decl) = TREE_CHAIN (DECL_ARGUMENTS (*decl));\n   DECL_STATIC_FUNCTION_P (*decl) = 1;\n   if (fn)\n     *fn = tmp;"}, {"sha": "0824c13d6735d892d0ccf04cdc6d4a64809b07c5", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -30,6 +30,9 @@ enum decl_context\n   MEMFUNCDEF\t\t\t/* Member function definition */\n };\n \n+/* We need this in here to get the decl_context definition.  */\n+extern tree grokdeclarator\t\t\tPROTO((tree, tree, enum decl_context, int, tree, tree));\n+\n /* C++: Keep these around to reduce calls to `get_identifier'.\n    Identifiers for `this' in member functions and the auto-delete\n    parameter for destructors.  */"}, {"sha": "7a3f7d5e09429e7ae23a43669e5bcfd944337bb4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 108, "deletions": 67, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -38,7 +38,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"defaults.h\"\n \n-extern tree grokdeclarator ();\n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n static void grok_function_init ();\n@@ -677,7 +676,7 @@ grok_method_quals (ctype, function, quals)\n \t\t\t\t     ? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n \t\t\t\t     : TYPE_ARG_TYPES (fntype)));\n   if (raises)\n-    fntype = build_exception_variant (ctype, fntype, raises);\n+    fntype = build_exception_variant (fntype, raises);\n \n   TREE_TYPE (function) = fntype;\n   return ctype;\n@@ -719,8 +718,11 @@ warn_if_unknown_interface (decl)\n       int sl = lineno;\n       char *sf = input_filename;\n \n-      lineno = til->line;\n-      input_filename = til->file;\n+      if (til)\n+\t{\n+\t  lineno = til->line;\n+\t  input_filename = til->file;\n+\t}\n       cp_warning (\"template `%#D' instantiated in file without #pragma interface\",\n \t\t  decl);\n       lineno = sl;\n@@ -864,6 +866,8 @@ grokclassfn (ctype, cname, function, flags, quals)\n   tree arg_types;\n   tree parm;\n   tree qualtype;\n+  tree fntype = TREE_TYPE (function);\n+  tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n \n   if (fn_name == NULL_TREE)\n     {\n@@ -959,8 +963,13 @@ grokclassfn (ctype, cname, function, flags, quals)\n       /* This is the same chain as DECL_ARGUMENTS (...).  */\n       TREE_CHAIN (last_function_parms) = parm;\n \n-      TREE_TYPE (function) = build_cplus_method_type (qualtype, void_type_node,\n-\t\t\t\t\t\t      arg_types);\n+      fntype = build_cplus_method_type (qualtype, void_type_node,\n+\t\t\t\t\targ_types);\n+      if (raises)\n+\t{\n+\t  fntype = build_exception_variant (fntype, raises);\n+\t}\n+      TREE_TYPE (function) = fntype;\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n   else\n@@ -971,18 +980,22 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t{\n \t  arg_types = hash_tree_chain (integer_type_node,\n \t\t\t\t       TREE_CHAIN (arg_types));\n-\t  TREE_TYPE (function)\n-\t    = build_cplus_method_type (qualtype,\n-\t\t\t\t       TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t\t       arg_types);\n+\t  fntype = build_cplus_method_type (qualtype,\n+\t\t\t\t\t    TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t\t\t    arg_types);\n+\t  if (raises)\n+\t    {\n+\t      fntype = build_exception_variant (fntype, raises);\n+\t    }\n+\t  TREE_TYPE (function) = fntype;\n \t  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n \t}\n \n       these_arg_types = arg_types;\n \n       if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n \t/* Only true for static member functions.  */\n-\tthese_arg_types = hash_tree_chain (TYPE_POINTER_TO (qualtype),\n+\tthese_arg_types = hash_tree_chain (build_pointer_type (qualtype),\n \t\t\t\t\t   arg_types);\n \n       DECL_ASSEMBLER_NAME (function)\n@@ -1213,7 +1226,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n    really a member of the class (CTYPE) it is supposed to belong to.\n    CNAME is the same here as it is for grokclassfn above.  */\n \n-void\n+tree\n check_classfn (ctype, cname, function)\n      tree ctype, cname, function;\n {\n@@ -1229,8 +1242,7 @@ check_classfn (ctype, cname, function)\n       end = TREE_VEC_END (method_vec);\n \n       /* First suss out ctors and dtors.  */\n-      if (*methods\n-\t  && (fn_name == cname || fn_name == DECL_NAME (*methods)))\n+      if (*methods && fn_name == DECL_NAME (*methods))\n \tgoto got_it;\n \n       while (++methods != end)\n@@ -1242,14 +1254,14 @@ check_classfn (ctype, cname, function)\n \t      while (fndecl)\n \t\t{\n \t\t  if (DECL_ASSEMBLER_NAME (function) == DECL_ASSEMBLER_NAME (fndecl))\n-\t\t    return;\n+\t\t    return fndecl;\n #if 0\n \t\t  /* This should work, but causes libg++ to fail\n \t\t     make check-tFix. */\n \t\t  /* We have to do more extensive argument checking here, as\n \t\t     the name may have been changed by asm(\"new_name\"). */\n \t\t  if (decls_match (function, fndecl))\n-\t\t    return;\n+\t\t    return fndecl;\n #else\n \t\t  if (DECL_NAME (function) == DECL_NAME (fndecl))\n \t\t    {\n@@ -1265,7 +1277,12 @@ check_classfn (ctype, cname, function)\n \t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n \t\t\t  && compparms (p1, p2, 3))\n-\t\t\treturn;\n+\t\t\t{\n+\t\t\t  if (DECL_STATIC_FUNCTION_P (fndecl)\n+\t\t\t      && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n+\t\t\t    revert_static_member_fn (&function, NULL, NULL);\n+\t\t\t  return fndecl;\n+\t\t\t}\n \t\t    }\n #endif\n \t\t  fndecl = DECL_CHAIN (fndecl);\n@@ -1276,8 +1293,15 @@ check_classfn (ctype, cname, function)\n     }\n \n   if (methods != end)\n-    cp_error (\"argument list for `%#D' does not match any in class `%T'\",\n-\t      function, ctype);\n+    {\n+      tree fndecl = *methods;\n+      cp_error (\"prototype for `%#D' does not match any in class `%T'\",\n+\t\tfunction, ctype);\n+      cp_error_at (\"candidate%s: %+#D\", DECL_CHAIN (fndecl) ? \"s are\" : \" is\",\n+\t\t   fndecl);\n+      while (fndecl = DECL_CHAIN (fndecl), fndecl)\n+\tcp_error_at (\"                %#D\", fndecl);\n+    }\n   else\n     {\n       methods = 0;\n@@ -1288,6 +1312,7 @@ check_classfn (ctype, cname, function)\n   /* If we did not find the method in the class, add it to\n      avoid spurious errors.  */\n   add_method (ctype, methods, function);\n+  return NULL_TREE;\n }\n \n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n@@ -1311,8 +1336,8 @@ check_classfn (ctype, cname, function)\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (declarator, declspecs, raises, init, asmspec_tree)\n-     tree declarator, declspecs, raises, init, asmspec_tree;\n+grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n+     tree declarator, declspecs, raises, init, asmspec_tree, attrlist;\n {\n   register tree value;\n   char *asmspec = 0;\n@@ -1337,7 +1362,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       && TREE_CHAIN (init) == NULL_TREE)\n \tinit = NULL_TREE;\n \n-  value = grokdeclarator (declarator, declspecs, FIELD, init != 0, raises);\n+  value = grokdeclarator (declarator, declspecs, FIELD, init != 0,\n+\t\t\t  raises, attrlist);\n   if (! value)\n     return value; /* friend or constructor went bad.  */\n \n@@ -1509,6 +1535,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n     }\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n+      check_default_args (value);\n       if (DECL_CHAIN (value) != NULL_TREE)\n \t{\n \t  /* Need a fresh node here so that we don't get circularity\n@@ -1551,7 +1578,8 @@ tree\n grokbitfield (declarator, declspecs, width)\n      tree declarator, declspecs, width;\n {\n-  register tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL_TREE);\n+  register tree value = grokdeclarator (declarator, declspecs, BITFIELD,\n+\t\t\t\t\t0, NULL_TREE, NULL_TREE);\n \n   if (! value) return NULL_TREE; /* friends went bad.  */\n \n@@ -1754,7 +1782,7 @@ groktypefield (declspecs, parmlist)\n \n  found:\n   decl = grokdeclarator (build_parse_node (CALL_EXPR, type_id, parmlist, NULL_TREE),\n-\t\t\t declspecs, FIELD, 0, NULL_TREE);\n+\t\t\t declspecs, FIELD, 0, NULL_TREE, NULL_TREE);\n   if (decl == NULL_TREE)\n     return NULL_TREE;\n \n@@ -1797,7 +1825,8 @@ tree\n grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n-  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n+  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0,\n+\t\t\t   NULL_TREE, NULL_TREE);\n   return build_typename_overload (t);\n }\n \n@@ -2037,7 +2066,7 @@ constructor_name (thing)\n void\n setup_vtbl_ptr ()\n {\n-  extern rtx base_init_expr;\n+  extern tree base_init_expr;\n \n   if (base_init_expr == 0\n       && DECL_CONSTRUCTOR_P (current_function_decl))\n@@ -2199,6 +2228,11 @@ finish_anon_union (anon_union_decl)\n       if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n \n+      if (TREE_PRIVATE (field))\n+\tcp_pedwarn_at (\"private member `%#D' in anonymous union\", field);\n+      else if (TREE_PROTECTED (field))\n+\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n+\n       decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n       /* tell `pushdecl' that this is not tentative.  */\n       DECL_INITIAL (decl) = error_mark_node;\n@@ -2449,7 +2483,9 @@ static void\n mark_vtable_entries (decl)\n      tree decl;\n {\n-  tree entries = TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)));\n+  tree entries = CONSTRUCTOR_ELTS (DECL_INITIAL (decl));\n+\n+  skip_rtti_stuff (&entries);\n \n   for (; entries; entries = TREE_CHAIN (entries))\n     {\n@@ -2757,7 +2793,7 @@ import_export_inline (decl)\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n       tree ctype = DECL_CLASS_CONTEXT (decl);\n-      if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n+      if (CLASSTYPE_INTERFACE_KNOWN (ctype) && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  DECL_NOT_REALLY_EXTERN (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n@@ -2874,7 +2910,10 @@ finish_file ()\n     goto mess_up;\n \n   fnname = get_file_function_name ('D');\n-  start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n+  start_function (void_list_node,\n+\t\t  build_parse_node (CALL_EXPR, fnname, void_list_node,\n+\t\t\t\t    NULL_TREE),\n+\t\t  NULL_TREE, NULL_TREE, 0);\n   fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n   store_parm_decls ();\n \n@@ -2900,7 +2939,7 @@ finish_file ()\n \t  else\n \t    {\n \t      mark_addressable (decl);\n-\t      temp = build1 (ADDR_EXPR, TYPE_POINTER_TO (type), decl);\n+\t      temp = build1 (ADDR_EXPR, build_pointer_type (type), decl);\n \t    }\n \t  temp = build_delete (TREE_TYPE (temp), temp,\n \t\t\t       integer_two_node, LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n@@ -2931,7 +2970,10 @@ finish_file ()\n   if (needs_messing_up)\n     {\n       fnname = get_file_function_name ('I');\n-      start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n+      start_function (void_list_node,\n+\t\t      build_parse_node (CALL_EXPR, fnname,\n+\t\t\t\t\tvoid_list_node, NULL_TREE),\n+\t\t      NULL_TREE, NULL_TREE, 0);\n       fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n       store_parm_decls ();\n \n@@ -2973,40 +3015,6 @@ finish_file ()\n \t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n \t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n \n-#if 0\n-\t      if (init)\n-\t\t{\n-\t\t  if (TREE_CODE (init) == VAR_DECL)\n-\t\t    {\n-\t\t      /* This behavior results when there are\n-\t\t\t multiple declarations of an aggregate,\n-\t\t\t the last of which defines it.  */\n-\t\t      if (DECL_RTL (init) == DECL_RTL (decl))\n-\t\t\t{\n-\t\t\t  my_friendly_assert (DECL_INITIAL (decl) == error_mark_node\n-\t\t\t\t  || (TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR\n-\t\t\t\t      && CONSTRUCTOR_ELTS (DECL_INITIAL (decl)) == NULL_TREE),\n-\t\t\t\t\t      199);\n-\t\t\t  init = DECL_INITIAL (init);\n-\t\t\t  if (TREE_CODE (init) == CONSTRUCTOR\n-\t\t\t      && CONSTRUCTOR_ELTS (init) == NULL_TREE)\n-\t\t\t    init = NULL_TREE;\n-\t\t\t}\n-\t\t      else if (TREE_TYPE (decl) == TREE_TYPE (init))\n-\t\t\t{\n-#if 1\n-\t\t\t  my_friendly_abort (200);\n-#else\n-\t\t\t  /* point to real decl's rtl anyway.  */\n-\t\t\t  DECL_RTL (init) = DECL_RTL (decl);\n-\t\t\t  my_friendly_assert (DECL_INITIAL (decl) == error_mark_node,\n-\t\t\t\t\t      201);\n-\t\t\t  init = DECL_INITIAL (init);\n-#endif\t\t\t\t/* 1 */\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-#endif\t\t\t\t/* 0 */\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\texpand_aggr_init (decl, init, 0, 0);\n@@ -3030,7 +3038,16 @@ finish_file ()\n \t\t  /* a `new' expression at top level.  */\n \t\t  expand_expr (decl, const0_rtx, VOIDmode, 0);\n \t\t  free_temp_slots ();\n-\t\t  expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0, 0);\n+\t\t  if (TREE_CODE (init) == TREE_VEC)\n+\t\t    {\n+\t\t      expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t\t\t\t    TREE_VEC_ELT (init, 1),\n+\t\t\t\t\t\t    TREE_VEC_ELT (init, 2), 0),\n+\t\t\t\t   const0_rtx, VOIDmode, 0);\n+\t\t      free_temp_slots ();\n+\t\t    }\n+\t\t  else\n+\t\t    expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0, 0);\n \t\t}\n \t    }\n \t  else if (decl == error_mark_node)\n@@ -3053,6 +3070,8 @@ finish_file ()\n       assemble_constructor (IDENTIFIER_POINTER (fnname));\n     }\n \n+  expand_builtin_throw ();\n+\n   permanent_allocation (1);\n \n   /* Done with C language context needs.  */\n@@ -3460,11 +3479,33 @@ tree\n do_class_using_decl (decl)\n      tree decl;\n {\n-  return error_mark_node;\n+  tree type;\n+\n+  /* Ignore for now, unimplemented. */\n+  return NULL_TREE;\n }\n \n void\n do_using_directive (namespace)\n      tree namespace;\n {\n }\n+\n+void\n+check_default_args (x)\n+     tree x;\n+{\n+  tree arg = TYPE_ARG_TYPES (TREE_TYPE (x));\n+  int saw_def = 0, i = 0 - (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE);\n+  for (; arg && arg != void_list_node; arg = TREE_CHAIN (arg), ++i)\n+    {\n+      if (TREE_PURPOSE (arg))\n+\tsaw_def = 1;\n+      else if (saw_def)\n+\t{\n+\t  cp_error (\"default argument missing for parameter %P of `%#D'\",\n+\t\t    i, x);\n+\t  break;\n+\t}\n+    }\n+}"}, {"sha": "f36b0e1e1f9ae949c2bf6d858f3c79ac72a3a31a", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -43,11 +43,11 @@ extern int   cp_line_of PROTO((tree));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n \n-#define NARGS 3\n-#define arglist a1, a2, a3\n-#define arglist_dcl HOST_WIDE_INT a1, a2, a3;\n-#define ARGSINIT args[0] = a1; args[1] = a2; args[2] = a3;\n-#define ARGSLIST args[0], args[1], args[2]\n+#define NARGS 4\n+#define arglist a1, a2, a3, a4\n+#define arglist_dcl HOST_WIDE_INT a1, a2, a3, a4;\n+#define ARGSINIT args[0] = a1; args[1] = a2; args[2] = a3; args[3] = a4;\n+#define ARGSLIST args[0], args[1], args[2], args[3]\n \n static void\n cp_thing (errfn, atarg1, format, arglist)"}, {"sha": "4eb196e3add59fcd06bc8786e5c34f65016e13bd", "filename": "gcc/cp/error.c", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -35,6 +35,7 @@ typedef char* cp_printer ();\n #define O op_as_string\n #define P parm_as_string\n #define T type_as_string\n+#define V cv_as_string\n \n #define _ (cp_printer *) 0\n cp_printer * cp_printers[256] =\n@@ -45,7 +46,7 @@ cp_printer * cp_printers[256] =\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x20 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x30 */\n   _, A, _, C, D, E, _, _, _, _, _, _, L, _, _, O, /* 0x40 */\n-  P, _, _, _, T, _, _, _, _, _, _, _, _, _, _, _, /* 0x50 */\n+  P, _, _, _, T, _, V, _, _, _, _, _, _, _, _, _, /* 0x50 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x60 */\n   _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x70 */\n };\n@@ -56,6 +57,7 @@ cp_printer * cp_printers[256] =\n #undef O\n #undef P\n #undef T\n+#undef V\n #undef _\n \n #define obstack_chunk_alloc xmalloc\n@@ -269,18 +271,18 @@ dump_aggr_type (t, v)\n   \n   name = TYPE_NAME (t);\n \n-  if (DECL_CONTEXT (name))\n+  if (name && DECL_CONTEXT (name))\n     {\n       /* FUNCTION_DECL or RECORD_TYPE */\n       dump_decl (DECL_CONTEXT (name), 0);\n       OB_PUTC2 (':', ':');\n     }\n \n   /* kludge around weird behavior on g++.brendan/line1.C */\n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+  if (name && TREE_CODE (name) != IDENTIFIER_NODE)\n     name = DECL_NAME (name);\n \n-  if (ANON_AGGRNAME_P (name))\n+  if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       OB_PUTS (\"{anonymous\");\n       if (!v)\n@@ -512,6 +514,9 @@ ident_fndecl (t)\n {\n   tree n = lookup_name (t, 0);\n \n+  if (n == NULL_TREE)\n+    return NULL_TREE;\n+\n   if (TREE_CODE (n) == FUNCTION_DECL)\n     return n;\n   else if (TREE_CODE (n) == TREE_LIST\n@@ -643,26 +648,30 @@ dump_decl (t, v)\n       /* These special cases are duplicated here so that other functions\n \t can feed identifiers to cp_error and get them demangled properly. */\n     case IDENTIFIER_NODE:\n-      if (DESTRUCTOR_NAME_P (t))\n-\t{\n-\t  OB_PUTC ('~');\n-\t  dump_decl (DECL_NAME (ident_fndecl (t)), 0);\n-\t}\n-      else if (IDENTIFIER_TYPENAME_P (t))\n-\t{\n-\t  OB_PUTS (\"operator \");\n-\t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n-\t  dump_type (TREE_TYPE (t), 0);\n-\t  break;\n-\t}\n-      else if (IDENTIFIER_OPNAME_P (t))\n-\t{\n-\t  char *name_string = operator_name_string (t);\n-\t  OB_PUTS (\"operator \");\n-\t  OB_PUTCP (name_string);\n-\t}\n-      else\n-\tOB_PUTID (t);\n+      { tree f;\n+\tif (DESTRUCTOR_NAME_P (t)\n+\t    && (f = ident_fndecl (t))\n+\t    && DECL_LANGUAGE (f) == lang_cplusplus)\n+\t  {\n+\t    OB_PUTC ('~');\n+\t    dump_decl (DECL_NAME (f), 0);\n+\t  }\n+\telse if (IDENTIFIER_TYPENAME_P (t))\n+\t  {\n+\t    OB_PUTS (\"operator \");\n+\t    /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n+\t    dump_type (TREE_TYPE (t), 0);\n+\t    break;\n+\t  }\n+\telse if (IDENTIFIER_OPNAME_P (t))\n+\t  {\n+\t    char *name_string = operator_name_string (t);\n+\t    OB_PUTS (\"operator \");\n+\t    OB_PUTCP (name_string);\n+\t  }\n+\telse\n+\t  OB_PUTID (t);\n+      }\n       break;\n \n     case FUNCTION_DECL:\n@@ -785,7 +794,7 @@ dump_function_decl (t, v)\n \tparmtypes = TREE_CHAIN (parmtypes);\n     }\n \n-  if (DESTRUCTOR_NAME_P (name))\n+  if (DESTRUCTOR_NAME_P (name) && DECL_LANGUAGE (t) == lang_cplusplus)\n     parmtypes = TREE_CHAIN (parmtypes);\n   \n   dump_function_name (t);\n@@ -824,7 +833,8 @@ dump_function_name (t)\n \n   /* There ought to be a better way to find out whether or not something is\n      a destructor.  */\n-  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (t)))\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (t))\n+      && DECL_LANGUAGE (t) == lang_cplusplus)\n     {\n       OB_PUTC ('~');\n       dump_decl (name, 0);\n@@ -1456,3 +1466,17 @@ args_as_string (p, v)\n \n   return type_as_string (p, v);\n }\n+\n+char *\n+cv_as_string (p, v)\n+     tree p;\n+     int v;\n+{\n+  OB_INIT ();\n+\n+  dump_readonly_or_volatile (p, before);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}"}, {"sha": "51577f85afa5dfa1a3aaebee13bc0e225e026e6e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 606, "deletions": 607, "changes": 1213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -35,121 +35,11 @@ Boston, MA 02111-1307, USA.  */\n tree protect_list;\n \n extern void (*interim_eh_hook)\tPROTO((tree));\n+rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \n /* holds the fndecl for __builtin_return_address () */\n tree builtin_return_address_fndecl;\n-\n-/* Define at your own risk!  */\n-#ifndef CROSS_COMPILE\n-#ifdef sun\n-#ifdef sparc\n-#define TRY_NEW_EH\n-#endif\n-#endif\n-#ifdef _IBMR2\n-#ifndef __rs6000\n-#define __rs6000\n-#endif\n-#endif\n-#ifdef mips\n-#ifndef __mips\n-#define __mips\n-#endif\n-#endif\n-#ifdef __i386__\n-#ifndef __i386\n-#define __i386\n-#endif\n-#endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined (__arm) || defined (__alpha)\n-#define TRY_NEW_EH\n-#endif\n-#endif\n-\n-#ifndef TRY_NEW_EH\n-\n-static void\n-sorry_no_eh ()\n-{\n-  static int warned = 0;\n-  if (! warned)\n-    {\n-      sorry (\"exception handling not supported\");\n-      warned = 1;\n-    }\n-}\n-\n-void\n-expand_exception_blocks ()\n-{\n-}\n-\n-void\n-start_protect ()\n-{\n-}\n-\n-void\n-end_protect (finalization)\n-     tree finalization;\n-{\n-}\n-\n-void\n-expand_start_try_stmts ()\n-{\n-  sorry_no_eh ();\n-}\n-\n-void\n-expand_end_try_stmts ()\n-{\n-}\n-\n-void\n-expand_start_all_catch ()\n-{\n-}\n-\n-void\n-expand_end_all_catch ()\n-{\n-}\n-\n-void\n-expand_start_catch_block (declspecs, declarator)\n-     tree declspecs, declarator;\n-{\n-}\n-\n-void\n-expand_end_catch_block ()\n-{\n-}\n-\n-void\n-init_exception_processing ()\n-{\n-}\n-\n-void\n-expand_throw (exp)\n-     tree exp;\n-{\n-  sorry_no_eh ();\n-}\n-\n-#else\n-\n-/* Make 'label' the first numbered label of the current function */\n-void\n-make_first_label(label)\n-     rtx label;\n-{\n-  if (CODE_LABEL_NUMBER(label) < get_first_label_num())\n-    set_new_first_and_last_label_num (CODE_LABEL_NUMBER(label),\n-\t\t\t\t      max_label_num());\n-}\n+tree throw_fndecl;\n \n static int\n doing_eh (do_warn)\n@@ -171,16 +61,14 @@ doing_eh (do_warn)\n \n /*\n NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer\n-to supporting exception handling as per Stroustrup's 2nd edition.\n+to supporting exception handling as per ANSI C++ working draft.\n It is a complete rewrite of all the EH stuff that was here before\n \tShortcomings:\n-\t\t1. The type of the throw and catch must still match\n-\t\t   exactly (no support yet for matching base classes)\n-\t\t2. Throw specifications of functions still don't work.\n+\t\t1. Throw specifications of functions still don't work.\n \tCool Things:\n \t\t1. Destructors are called properly :-)\n \t\t2. No overhead for the non-exception thrown case.\n-\t\t3. Fixing shortcomings 1 and 2 is simple.\n+\t\t3. Fixing shortcoming 1 is simple.\n \t\t\t-Tad Hunt\t(tad@mail.csh.rit.edu)\n \n */\n@@ -189,10 +77,7 @@ It is a complete rewrite of all the EH stuff that was here before\n \n /* used to cache a call to __builtin_return_address () */\n static tree BuiltinReturnAddress;\n-\n-\n-\n-\n+     \n \n #include <stdio.h>\n \n@@ -206,9 +91,9 @@ output_exception_table_entry (file, start_label, end_label, eh_label)\n {\n   char label[100];\n \n-  assemble_integer (start_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n-  assemble_integer (end_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n-  assemble_integer (eh_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n+  assemble_integer (start_label, GET_MODE_SIZE (Pmode), 1);\n+  assemble_integer (end_label, GET_MODE_SIZE (Pmode), 1);\n+  assemble_integer (eh_label, GET_MODE_SIZE (Pmode), 1);\n   putc ('\\n', file);\t\t/* blank line */\n }\n    \n@@ -269,7 +154,7 @@ exception_section ()\n   if (flag_pic)\n     data_section ();\n   else\n-#if defined(__rs6000)\n+#if defined(TARGET_POWERPC) /* are we on a __rs6000? */\n     data_section ();\n #else\n     readonly_data_section ();\n@@ -336,24 +221,11 @@ exception_section ()\n \n      Since we don't want to generate the catch block inline with the\n      regular flow of the function, we need to have some way of doing\n-     so.  Luckily, we have a couple of routines \"get_last_insn ()\" and\n-     \"set_last_insn ()\" provided.  When the start of a catch block is\n-     encountered, we save a pointer to the last insn generated.  After\n-     the catch block is generated, we save a pointer to the first\n-     catch block insn and the last catch block insn with the routines\n-     \"NEXT_INSN ()\" and \"get_last_insn ()\".  We then set the last insn\n-     to be the last insn generated before the catch block, and set the\n-     NEXT_INSN (last_insn) to zero.\n-\n-     Since catch blocks might be nested inside other catch blocks, and\n-     we munge the chain of generated insns after the catch block is\n-     generated, we need to store the pointers to the last insn\n-     generated in a stack, so that when the end of a catch block is\n-     encountered, the last insn before the current catch block can be\n-     popped and set to be the last insn, and the first and last insns\n-     of the catch block just generated can be enqueue'd for output at\n-     a later time.\n-  \t\t\n+     so.  Luckily, we can use sequences to defer the catch sections.\n+     When the start of a catch block is encountered, we start the\n+     sequence.  After the catch block is generated, we end the\n+     sequence.\n+\n      Next we must insure that when the catch block is executed, all\n      finalizations for the matching try block have been completed.  If\n      any of those finalizations throw an exception, we must call\n@@ -379,17 +251,17 @@ extern rtx gen_nop\t\tPROTO(());\n    ====================================================================== */\n \n /* used to cache \"terminate ()\", \"unexpected ()\", \"set_terminate ()\", and\n-   \"set_unexpected ()\" after default_conversion. (lib-except.c) */\n-static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch;\n+   \"set_unexpected ()\" after default_conversion. (lib-except.c)  */\n+static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch, Throw;\n \n /* used to cache __find_first_exception_table_match ()\n    for throw (lib-except.c)  */\n static tree FirstExceptionMatch;\n \n-/* used to cache a call to __unwind_function () (lib-except.c) */\n+/* used to cache a call to __unwind_function () (lib-except.c)  */\n static tree Unwind;\n \n-/* holds a ready to emit call to \"terminate ()\". */\n+/* holds a ready to emit call to \"terminate ()\".  */\n static tree TerminateFunctionCall;\n \n /* ====================================================================== */\n@@ -398,7 +270,7 @@ static tree TerminateFunctionCall;\n \n /* data structures for my various quick and dirty stacks and queues\n    Eventually, most of this should go away, because I think it can be\n-   integrated with stuff already built into the compiler. */\n+   integrated with stuff already built into the compiler.  */\n \n /* =================================================================== */\n \n@@ -432,17 +304,6 @@ struct ehQueue {\n   struct ehNode *head;\n   struct ehNode *tail;\n };\n-\n-struct exceptNode {\n-  rtx catchstart;\n-  rtx catchend;\n-\n-  struct exceptNode *chain;\n-};\n-\n-struct exceptStack {\n-  struct exceptNode *top;\n- };\n /* ========================================================================= */\n \n \n@@ -453,36 +314,31 @@ struct exceptStack {\n    ========================================================================= */\n \n /* Holds the pc for doing \"throw\" */\n-rtx saved_pc;\n+tree saved_pc;\n /* Holds the type of the thing being thrown. */\n-rtx saved_throw_type;\n+tree saved_throw_type;\n /* Holds the value being thrown.  */\n-rtx saved_throw_value;\n+tree saved_throw_value;\n+\n+int throw_used;\n \n-rtx throw_label;\n+static rtx catch_clauses;\n+static first_catch_label;\n \n static struct ehStack ehstack;\n static struct ehQueue ehqueue;\n static struct ehQueue eh_table_output_queue;\n-static struct exceptStack exceptstack;\n static struct labelNode *false_label_stack = NULL;\n static struct labelNode *caught_return_label_stack = NULL;\n /* ========================================================================= */\n \n /* function prototypes */\n static struct ehEntry *pop_eh_entry\tPROTO((struct ehStack *stack));\n static void enqueue_eh_entry\t\tPROTO((struct ehQueue *queue, struct ehEntry *entry));\n-static void push_except_stmts\t\tPROTO((struct exceptStack *exceptstack,\n-\t\t\t\t\t rtx catchstart, rtx catchend));\n-static int pop_except_stmts\t\tPROTO((struct exceptStack *exceptstack,\n-\t\t\t\t\t rtx *catchstart, rtx *catchend));\n static rtx push_eh_entry\t\tPROTO((struct ehStack *stack));\n static struct ehEntry *dequeue_eh_entry\tPROTO((struct ehQueue *queue));\n static void new_eh_queue\t\tPROTO((struct ehQueue *queue));\n static void new_eh_stack\t\tPROTO((struct ehStack *stack));\n-static void new_except_stack\t\tPROTO((struct exceptStack *queue));\n-static void push_last_insn\t\tPROTO(());\n-static rtx pop_last_insn\t\tPROTO(());\n static void push_label_entry\t\tPROTO((struct labelNode **labelstack, rtx label));\n static rtx pop_label_entry\t\tPROTO((struct labelNode **labelstack));\n static rtx top_label_entry\t\tPROTO((struct labelNode **labelstack));\n@@ -532,43 +388,6 @@ top_label_entry (labelstack)\n   return (*labelstack)->label;\n }\n \n-static void\n-push_except_stmts (exceptstack, catchstart, catchend)\n-     struct exceptStack *exceptstack;\n-     rtx catchstart, catchend;\n-{\n-  struct exceptNode *newnode = (struct exceptNode*)\n-    xmalloc (sizeof (struct exceptNode));\n-\n-  newnode->catchstart = catchstart;\n-  newnode->catchend = catchend;\n-  newnode->chain = exceptstack->top;\n-\n-  exceptstack->top = newnode;\n-}\n-\n-static int\n-pop_except_stmts (exceptstack, catchstart, catchend)\n-     struct exceptStack *exceptstack;\n-     rtx *catchstart, *catchend;\n-{\n-  struct exceptNode *tempnode;\n-\n-  if (!exceptstack->top) {\n-    *catchstart = *catchend = NULL_RTX;\n-    return 0;\n-  }\n-\n-  tempnode = exceptstack->top;\n-  exceptstack->top = exceptstack->top->chain;\n-\n-  *catchstart = tempnode->catchstart;\n-  *catchend = tempnode->catchend;\n-  free (tempnode);\n-\n-  return 1;\n-}\n-\n /* Push to permanent obstack for rtl generation.\n    One level only!  */\n static struct obstack *saved_rtl_obstack;\n@@ -712,12 +531,34 @@ new_eh_stack (stack)\n   stack->top = NULL;\n }\n \n+/* cheesyness to save some typing. returns the return value rtx */\n+rtx\n+do_function_call (func, params, return_type)\n+     tree func, params, return_type;\n+{\n+  tree func_call;\n+  func_call = build_function_call (func, params);\n+  expand_call (func_call, NULL_RTX, 0);\n+  if (return_type != NULL_TREE)\n+    return hard_function_value (return_type, func_call);\n+  return NULL_RTX;\n+}\n+\n static void\n-new_except_stack (stack)\n-     struct exceptStack *stack;\n+expand_internal_throw (pc)\n+     rtx pc;\n {\n-  stack->top = NULL;\n+  tree params;\n+\n+  emit_move_insn (DECL_RTL (saved_pc), pc);\n+#ifdef JUMP_TO_THROW\n+  emit_indirect_jump (gen_rtx (SYMBOL_REF, Pmode, \"__throw\"));\n+#else\n+  do_function_call (Throw, NULL_TREE, NULL_TREE);\n+#endif\n+  throw_used = 1;\n }\n+\n /* ========================================================================= */\n \n void\n@@ -740,7 +581,6 @@ extern tree auto_function PROTO((tree, tree, enum built_in_function));\n \t\t- Initializing the ehqueue\n \t\t- Initializing the eh_table_output_queue\n \t\t- Initializing the ehstack\n-\t\t- Initializing the exceptstack\n */\n \n void\n@@ -752,6 +592,8 @@ init_exception_processing ()\n   tree catch_match_fndecl;\n   tree find_first_exception_match_fndecl;\n   tree unwind_fndecl;\n+  tree declspecs;\n+  tree d;\n \n   /* void (*)() */\n   tree PFV = build_pointer_type (build_function_type\n@@ -803,10 +645,19 @@ init_exception_processing ()\n   unwind_fndecl =\n     define_function (\"__unwind_function\",\n \t\t     build_function_type (void_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node, void_list_node)),\n+\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t     void_list_node)),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  throw_fndecl =\n+    define_function (\"__throw\",\n+\t\t     build_function_type (void_type_node, void_list_node),\n \t\t     NOT_BUILT_IN,\n \t\t     pushdecl,\n \t\t     0);\n+  DECL_EXTERNAL (throw_fndecl) = 0;\n+  TREE_PUBLIC (throw_fndecl) = 0;\n \n   Unexpected = default_conversion (unexpected_fndecl);\n   Terminate = default_conversion (terminate_fndecl);\n@@ -815,67 +666,48 @@ init_exception_processing ()\n   CatchMatch = default_conversion (catch_match_fndecl);\n   FirstExceptionMatch = default_conversion (find_first_exception_match_fndecl);\n   Unwind = default_conversion (unwind_fndecl);\n+  Throw = default_conversion (throw_fndecl);\n   BuiltinReturnAddress = default_conversion (builtin_return_address_fndecl);\n \n   TerminateFunctionCall = build_function_call (Terminate, NULL_TREE);\n \n   pop_lang_context ();\n-  throw_label = gen_label_rtx ();\n-#ifdef sparc\n-  saved_pc = gen_rtx (REG, Pmode, 16);\n-  saved_throw_type = gen_rtx (REG, Pmode, 17);\n-  saved_throw_value = gen_rtx (REG, Pmode, 18);\n-#endif\n-#ifdef __i386\n-  saved_pc = gen_rtx (REG, Pmode, 3);\n-  saved_throw_type = gen_rtx (REG, Pmode, 4);\n-  saved_throw_value = gen_rtx (REG, Pmode, 5);\n-#endif\n-#ifdef __rs6000\n-  saved_pc = gen_rtx (REG, Pmode, 13);\n-  saved_throw_type = gen_rtx (REG, Pmode, 14);\n-  saved_throw_value = gen_rtx (REG, Pmode, 15);\n-#endif\n-#ifdef __hppa\n-  saved_pc = gen_rtx (REG, Pmode, 5);\n-  saved_throw_type = gen_rtx (REG, Pmode, 6);\n-  saved_throw_value = gen_rtx (REG, Pmode, 7);\n-#endif\n-#ifdef __mc68000\n-  saved_pc = gen_rtx (REG, Pmode, 10);\n-  saved_throw_type = gen_rtx (REG, Pmode, 11);\n-  saved_throw_value = gen_rtx (REG, Pmode, 12);\n-#endif\n-#ifdef __mips\n-  saved_pc = gen_rtx (REG, Pmode, 16);\n-  saved_throw_type = gen_rtx (REG, Pmode, 17);\n-  saved_throw_value = gen_rtx (REG, Pmode, 18);\n-#endif\n-#ifdef __arm\n-  saved_pc = gen_rtx (REG, Pmode, 7);\n-  saved_throw_type = gen_rtx (REG, Pmode, 8);\n-  saved_throw_value = gen_rtx (REG, Pmode, 9);\n-#endif\n-#ifdef __alpha\n-  saved_pc = gen_rtx (REG, Pmode, 9);\n-  saved_throw_type = gen_rtx (REG, Pmode, 10);\n-  saved_throw_value = gen_rtx (REG, Pmode, 11);\n-#endif\n+\n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n   new_eh_stack (&ehstack);\n-  new_except_stack (&exceptstack);\n+\n+  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n+  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_pc\"));\n+  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  DECL_COMMON (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  saved_pc = lookup_name (get_identifier (\"__eh_pc\"), 0);\n+\n+  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n+  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_type\"));\n+  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  DECL_COMMON (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  saved_throw_type = lookup_name (get_identifier (\"__eh_type\"), 0);\n+\n+  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n+  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_value\"));\n+  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  DECL_COMMON (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  saved_throw_value = lookup_name (get_identifier (\"__eh_value\"), 0);\n }\n \n /* call this to begin a block of unwind protection (ie: when an object is\n    constructed) */\n void\n start_protect ()\n {\n-  if (doing_eh (0))\n-    {\n-      emit_label (push_eh_entry (&ehstack));\n-    }\n+  if (! doing_eh (0))\n+    return;\n+\n+  emit_label (push_eh_entry (&ehstack));\n }\n    \n /* call this to end a block of unwind protection.  the finalization tree is\n@@ -893,6 +725,12 @@ end_protect (finalization)\n   entry = pop_eh_entry (&ehstack);\n \n   emit_label (entry->end_label);\n+  /* Put in something that takes up space, as otherwise the end\n+     address for the EH region could have the exact same address as\n+     the outer region, causing us to miss the fact that resuming\n+     exception handling with this PC value would be inside the outer\n+     region.  */\n+  emit_insn (gen_nop ());\n \n   entry->finalization = finalization;\n \n@@ -903,10 +741,10 @@ end_protect (finalization)\n void\n expand_start_try_stmts ()\n {\n-  if (doing_eh (1))\n-    {\n-      start_protect ();\n-    }\n+  if (! doing_eh (1))\n+    return;\n+\n+  start_protect ();\n }\n \n void\n@@ -915,43 +753,6 @@ expand_end_try_stmts ()\n   end_protect (integer_zero_node);\n }\n \n-struct insn_save_node {\n-\trtx last;\n-\tstruct insn_save_node *chain;\n- };\n-\n-static struct insn_save_node *InsnSave = NULL;\n-\n-\n-/* Used to keep track of where the catch blocks start.  */\n-static void\n-push_last_insn ()\n-{\n-  struct insn_save_node *newnode = (struct insn_save_node*)\n-    xmalloc (sizeof (struct insn_save_node));\n-\n-  newnode->last = get_last_insn ();\n-  newnode->chain = InsnSave;\n-  InsnSave = newnode;\n-}\n-\n-/* Use to keep track of where the catch blocks start.  */\n-static rtx\n-pop_last_insn ()\n-{\n-  struct insn_save_node *tempnode;\n-  rtx temprtx;\n-\n-  if (!InsnSave) return NULL_RTX;\n-\n-  tempnode = InsnSave;\n-  temprtx = tempnode->last;\n-  InsnSave = InsnSave->chain;\n-\n-  free (tempnode);\n-\n-  return temprtx;\n-}\n \n /* call this to start processing of all the catch blocks. */\n void\n@@ -965,19 +766,24 @@ expand_start_all_catch ()\n \n   emit_line_note (input_filename, lineno);\n   label = gen_label_rtx ();\n-  /* The label for the exception handling block we will save.  */\n+\n+  /* The label for the exception handling block we will save.  This is\n+     Lresume, in the documention.  */\n   emit_label (label);\n   \n-  push_label_entry (&caught_return_label_stack, label);\n-\n-  /* Remember where we started. */\n-  push_last_insn ();\n-\n+  /* Put in something that takes up space, as otherwise the end\n+     address for the EH region could have the exact same address as\n+     the outer region, causing us to miss the fact that resuming\n+     exception handling with this PC value would be inside the outer\n+     region.  */\n   emit_insn (gen_nop ());\n \n-  /* Will this help us not stomp on it? */\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n+  push_label_entry (&caught_return_label_stack, label);\n+\n+  /* Start a new sequence for all the catch blocks.  We will add this\n+     to the gloabl sequence catch_clauses, when we have completed all\n+     the handlers in this handler-seq.  */\n+  start_sequence ();\n \n   while (1)\n     {\n@@ -990,151 +796,78 @@ expand_start_all_catch ()\n       if (entry->finalization == integer_zero_node)\n \tbreak;\n \n+      /* The below can be optimized away, and we could just fall into the\n+\t next EH handler, if we are certain they are nested.  */\n+      /* Code to throw out to outer context, if we fall off end of the\n+\t handler.  */\n+      expand_internal_throw (gen_rtx (LABEL_REF,\n+\t\t\t\t      Pmode,\n+\t\t\t\t      entry->end_label));\n       free (entry);\n     }\n-\n-  /* This goes when the below moves out of our way.  */\n-#if 1\n-  label = gen_label_rtx ();\n-  emit_jump (label);\n-#endif\n-  \n-  /* All this should be out of line, and saved back in the exception handler\n-     block area.  */\n-#if 1\n-  entry->start_label = entry->exception_handler_label;\n-  /* These are saved for the exception table.  */\n-  push_rtl_perm ();\n-  entry->end_label = gen_label_rtx ();\n-  entry->exception_handler_label = gen_label_rtx ();\n-  entry->finalization = TerminateFunctionCall;\n-  entry->context = current_function_decl;\n-  assemble_external (TREE_OPERAND (Terminate, 0));\n-  pop_rtl_from_perm ();\n-\n-  LABEL_PRESERVE_P (entry->start_label) = 1;\n-  LABEL_PRESERVE_P (entry->end_label) = 1;\n-  LABEL_PRESERVE_P (entry->exception_handler_label) = 1;\n-\n-  emit_label (entry->end_label);\n-\n-  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n-\n-  /* After running the finalization, continue on out to the next\n-     cleanup, if we have nothing better to do.  */\n-  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry->end_label));\n-  /* Will this help us not stomp on it? */\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n-  make_first_label(throw_label);\n-  emit_jump (throw_label);\n-  emit_label (entry->exception_handler_label);\n-  expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n-  emit_barrier ();\n-#endif\n-  emit_label (label);\n }\n \n /* call this to end processing of all the catch blocks. */\n void\n expand_end_all_catch ()\n {\n-  rtx catchstart, catchend, last;\n-  rtx label;\n+  rtx new_catch_clause;\n \n   if (! doing_eh (1))\n     return;\n \n   /* Code to throw out to outer context, if we fall off end of catch\n-     handlers.  */\n-  emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n-\t\t\t\t     Pmode,\n-\t\t\t\t     top_label_entry (&caught_return_label_stack)));\n-  make_first_label(throw_label);\n-  emit_jump (throw_label);\n-\n-  /* Find the start of the catch block.  */\n-  last = pop_last_insn ();\n-  catchstart = NEXT_INSN (last);\n-  catchend = get_last_insn ();\n-\n-  NEXT_INSN (last) = 0;\n-  set_last_insn (last);\n-\n+     handlers.  This is rethrow (Lresume, same id, same obj); in the\n+     documentation.  */\n+  expand_internal_throw (gen_rtx (LABEL_REF,\n+\t\t\t\t  Pmode,\n+\t\t\t\t  top_label_entry (&caught_return_label_stack)));\n+\n+  /* Now we have the complete catch sequence.  */\n+  new_catch_clause = get_insns ();\n+  end_sequence ();\n+  \n   /* this level of catch blocks is done, so set up the successful catch jump\n      label for the next layer of catch blocks. */\n   pop_label_entry (&caught_return_label_stack);\n \n-  push_except_stmts (&exceptstack, catchstart, catchend);\n+  /* Add the new sequence of catchs to the main one for this\n+     function.  */\n+  push_to_sequence (catch_clauses);\n+  emit_insns (new_catch_clause);\n+  catch_clauses = get_insns ();\n+  end_sequence ();\n   \n   /* Here we fall through into the continuation code.  */\n }\n \n-\n-/* this is called from expand_exception_blocks () to expand the toplevel\n-   finalizations for a function. */\n-void\n-expand_leftover_cleanups ()\n+/* Build a type value for use at runtime for a type that is matched\n+   against by the exception handling system.  */\n+static tree\n+build_eh_type_type (type)\n+     tree type;\n {\n-  struct ehEntry *entry;\n-  rtx first_label = NULL_RTX;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  /* Will this help us not stomp on it? */\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n-  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n+  char *typestring;\n+  tree exp;\n \n-  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n-    {\n-      if (! first_label)\n-\tfirst_label = entry->exception_handler_label;\n-      emit_label (entry->exception_handler_label);\n+  if (type == error_mark_node)\n+    return error_mark_node;\n \n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+  /* peel back references, so they match. */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n \n-      /* leftover try block, opps.  */\n-      if (entry->finalization == integer_zero_node)\n-\tabort ();\n+  /* Peel off cv qualifiers. */\n+  type = TYPE_MAIN_VARIANT (type);\n \n-      free (entry);\n-    }\n-  if (first_label)\n+  if (flag_rtti)\n     {\n-      rtx label;\n-      struct ehEntry entry;\n-      /* These are saved for the exception table.  */\n-      push_rtl_perm ();\n-      label = gen_label_rtx ();\n-      entry.start_label = first_label;\n-      entry.end_label = label;\n-      entry.exception_handler_label = gen_label_rtx ();\n-      entry.finalization = TerminateFunctionCall;\n-      entry.context = current_function_decl;\n-      assemble_external (TREE_OPERAND (Terminate, 0));\n-      pop_rtl_from_perm ();\n-\n-      LABEL_PRESERVE_P (entry.start_label) = 1;\n-      LABEL_PRESERVE_P (entry.end_label) = 1;\n-      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n-\n-      emit_label (label);\n-\n-      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n-\n-      /* After running the finalization, continue on out to the next\n-\t cleanup, if we have nothing better to do.  */\n-      emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry.end_label));\n-      /* Will this help us not stomp on it? */\n-      emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n-      emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n-      make_first_label(throw_label);\n-      emit_jump (throw_label);\n-      emit_label (entry.exception_handler_label);\n-      expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n-      emit_barrier ();\n+      return build1 (ADDR_EXPR, ptr_type_node, get_typeid (type));\n     }\n+\n+  typestring = build_overload_name (type, 1, 1);\n+  exp = combine_strings (build_string (strlen (typestring)+1, typestring));\n+  return build1 (ADDR_EXPR, ptr_type_node, exp);\n }\n \n /* Build a type value for use at runtime for a exp that is thrown or\n@@ -1143,23 +876,12 @@ static tree\n build_eh_type (exp)\n      tree exp;\n {\n-  char *typestring;\n-  tree type;\n-\n   if (flag_rtti)\n     {\n       exp = build_typeid (exp);\n       return build1 (ADDR_EXPR, ptr_type_node, exp);\n     }\n-  type = TREE_TYPE (exp);\n-\n-  /* peel back references, so they match. */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  typestring = build_overload_name (type, 1, 1);\n-  exp = combine_strings (build_string (strlen (typestring)+1, typestring));\n-  return build1 (ADDR_EXPR, ptr_type_node, exp);\n+  return build_eh_type_type (TREE_TYPE (exp));\n }\n \n /* call this to start a catch block. Typename is the typename, and identifier\n@@ -1182,9 +904,9 @@ expand_start_catch_block (declspecs, declarator)\n   /* Create a binding level for the parm.  */\n   expand_start_bindings (0);\n \n-  /* These are saved for the exception table.  */\n-  push_rtl_perm ();\n   false_label_rtx = gen_label_rtx ();\n+  /* This is saved for the exception table.  */\n+  push_rtl_perm ();\n   protect_label_rtx = gen_label_rtx ();\n   pop_rtl_from_perm ();\n   push_label_entry (&false_label_stack, false_label_rtx);\n@@ -1196,7 +918,8 @@ expand_start_catch_block (declspecs, declarator)\n       rtx call_rtx, return_value_rtx;\n       tree init_type;\n \n-      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n+      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1,\n+\t\t\t     NULL_TREE, NULL_TREE);\n \n       if (decl == NULL_TREE)\n \t{\n@@ -1206,14 +929,15 @@ expand_start_catch_block (declspecs, declarator)\n \n       /* Figure out the type that the initializer is. */\n       init_type = TREE_TYPE (decl);\n-      if (TREE_CODE (init_type) != REFERENCE_TYPE)\n+      if (TREE_CODE (init_type) != REFERENCE_TYPE\n+\t  && TREE_CODE (init_type) != POINTER_TYPE)\n \tinit_type = build_reference_type (init_type);\n \n-      exp = make_tree (ptr_type_node, saved_throw_value);\n+      exp = saved_throw_value;\n       exp = tree_cons (NULL_TREE,\n-\t\t       build_eh_type (decl),\n+\t\t       build_eh_type_type (TREE_TYPE (decl)),\n \t\t       tree_cons (NULL_TREE,\n-\t\t\t\t  make_tree (ptr_type_node, saved_throw_type),\n+\t\t\t\t  saved_throw_type,\n \t\t\t\t  tree_cons (NULL_TREE, exp, NULL_TREE)));\n       exp = build_function_call (CatchMatch, exp);\n       call_rtx = expand_call (exp, NULL_RTX, 0);\n@@ -1248,129 +972,141 @@ expand_start_catch_block (declspecs, declarator)\n }\n \n \n+/* this is called from expand_exception_blocks and\n+   expand_end_catch_block to expand the toplevel finalizations for a\n+   function.  We return the first label emitted, if any, otherwise\n+   return NULL_RTX.  */\n+static rtx\n+expand_leftover_cleanups ()\n+{\n+  struct ehEntry *entry;\n+  rtx first_label = NULL_RTX;\n+\n+  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n+    {\n+      if (! first_label)\n+\tfirst_label = entry->exception_handler_label;\n+      emit_label (entry->exception_handler_label);\n+\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n+      /* The below can be optimized away, and we could just fall into the\n+\t next EH handler, if we are certain they are nested.  */\n+      /* Code to throw out to outer context, if we fall off end of the\n+\t handler.  */\n+      expand_internal_throw (gen_rtx (LABEL_REF,\n+\t\t\t\t      Pmode,\n+\t\t\t\t      entry->end_label));\n+\n+      /* leftover try block, opps.  */\n+      if (entry->finalization == integer_zero_node)\n+\tabort ();\n+\n+      free (entry);\n+    }\n+\n+  return first_label;\n+}\n+\n /* Call this to end a catch block.  Its responsible for emitting the\n    code to handle jumping back to the correct place, and for emitting\n    the label to jump to if this catch block didn't match.  */\n void expand_end_catch_block ()\n {\n-  if (doing_eh (1))\n-    {\n-      rtx start_protect_label_rtx;\n-      rtx end_protect_label_rtx;\n-      tree decls;\n-      struct ehEntry entry;\n+  rtx start_protect_label_rtx;\n+  rtx end_protect_label_rtx;\n+  tree decls;\n+  struct ehEntry entry;\n \n-      /* label we jump to if we caught the exception */\n-      emit_jump (top_label_entry (&caught_return_label_stack));\n+  if (! doing_eh (1))\n+    return;\n \n-      /* Code to throw out to outer context, if we get a throw from within\n-\t our catch handler. */\n-      /* These are saved for the exception table.  */\n-      push_rtl_perm ();\n-      entry.exception_handler_label = gen_label_rtx ();\n-      pop_rtl_from_perm ();\n-      emit_label (entry.exception_handler_label);\n-      emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n-\t\t\t\t\t Pmode,\n-\t\t\t\t\t top_label_entry (&caught_return_label_stack)));\n-      make_first_label(throw_label);\n-      emit_jump (throw_label);\n-      /* No associated finalization.  */\n-      entry.finalization = NULL_TREE;\n-      entry.context = current_function_decl;\n+  /* fall to outside the try statement when done executing handler and\n+     we fall off end of handler.  This is jump Lresume in the\n+     documentation.  */\n+  emit_jump (top_label_entry (&caught_return_label_stack));\n \n-      /* Because we are reordered out of line, we have to protect this. */\n-      /* label for the start of the protection region.  */\n-      start_protect_label_rtx = pop_label_entry (&false_label_stack);\n+  /* We end the rethrow protection region as soon as we hit a label. */\n+  end_protect_label_rtx = expand_leftover_cleanups ();\n \n-      /* Cleanup the EH parameter.  */\n-      decls = getdecls ();\n-      expand_end_bindings (decls, decls != NULL_TREE, 0);\n+  /* Code to throw out to outer context, if we get a throw from within\n+     our catch handler. */\n+  /* These are saved for the exception table.  */\n+  push_rtl_perm ();\n+  entry.exception_handler_label = gen_label_rtx ();\n+  pop_rtl_from_perm ();\n+  /* This label is Lhandler in the documentation.  */\n+  emit_label (entry.exception_handler_label);\n+  expand_internal_throw (gen_rtx (LABEL_REF,\n+\t\t\t\t  Pmode,\n+\t\t\t\t  top_label_entry (&caught_return_label_stack)));\n+\n+  /* No associated finalization.  */\n+  entry.finalization = NULL_TREE;\n+  entry.context = current_function_decl;\n+\n+  if (end_protect_label_rtx == NULL_RTX)\n+    end_protect_label_rtx = entry.exception_handler_label;\n+\n+  /* Because we are emitted out of line, we have to protect this. */\n+  /* label for the start of the protection region.  */\n+  start_protect_label_rtx = pop_label_entry (&false_label_stack);\n+\n+  /* Cleanup the EH parameter.  */\n+  decls = getdecls ();\n+  expand_end_bindings (decls, decls != NULL_TREE, 0);\n       \n-      /* label we emit to jump to if this catch block didn't match. */\n-      emit_label (end_protect_label_rtx = pop_label_entry (&false_label_stack));\n+  /* label we emit to jump to if this catch block didn't match. */\n+  /* This the closing } in the `if (eq) {' of the documentation.  */\n+  emit_label (pop_label_entry (&false_label_stack));\n \n-      /* Because we are reordered out of line, we have to protect this. */\n-      entry.start_label = start_protect_label_rtx;\n-      entry.end_label = end_protect_label_rtx;\n+  /* Because we are reordered out of line, we have to protect this. */\n+  entry.start_label = start_protect_label_rtx;\n+  entry.end_label = end_protect_label_rtx;\n \n-      LABEL_PRESERVE_P (entry.start_label) = 1;\n-      LABEL_PRESERVE_P (entry.end_label) = 1;\n-      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n-\n-      /* These set up a call to throw the caught exception into the outer\n-       context.  */\n-      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n-    }\n-}\n+  LABEL_PRESERVE_P (entry.start_label) = 1;\n+  LABEL_PRESERVE_P (entry.end_label) = 1;\n+  LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n \n-/* cheesyness to save some typing. returns the return value rtx */\n-rtx\n-do_function_call (func, params, return_type)\n-     tree func, params, return_type;\n-{\n-  tree func_call;\n-  func_call = build_function_call (func, params);\n-  expand_call (func_call, NULL_RTX, 0);\n-  if (return_type != NULL_TREE)\n-    return hard_function_value (return_type, func_call);\n-  return NULL_RTX;\n+  /* These set up a call to throw the caught exception into the outer\n+     context.  */\n+  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n }\n \n /* unwind the stack. */\n static void\n-do_unwind (throw_label)\n-     rtx throw_label;\n+do_unwind (inner_throw_label)\n+     rtx inner_throw_label;\n {\n-#ifdef sparc\n-  extern FILE *asm_out_file;\n+#if defined(SPARC_STACK_ALIGN) /* was sparc */\n   tree fcall;\n   tree params;\n   rtx return_val_rtx;\n+  rtx temp;\n \n   /* call to  __builtin_return_address () */\n-  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n   /* In the return, the new pc is pc+8, as the value coming in is\n      really the address of the call insn, not the next insn.  */\n-  emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n-\t\t\t\t\t\t\t Pmode,\n-\t\t\t\t\t\t\t throw_label), -8));\n-  /* We use three values, PC, type, and value */\n-  easy_expand_asm (\"st %l0,[%fp]\");\n-  easy_expand_asm (\"st %l1,[%fp+4]\");\n-  easy_expand_asm (\"st %l2,[%fp+8]\");\n+  temp = gen_reg_rtx (Pmode);\n+  emit_move_insn (temp, inner_throw_label);\n+  emit_move_insn (return_val_rtx, plus_constant (temp, -8));\n   easy_expand_asm (\"ret\");\n   easy_expand_asm (\"restore\");\n   emit_barrier ();\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined(__alpha)\n-  extern FILE *asm_out_file;\n-  tree fcall;\n-  tree params;\n-  rtx return_val_rtx;\n+#if defined(ARM_FRAME_RTX)  /* was __arm */\n+  if (flag_omit_frame_pointer)\n+    sorry (\"this implementation of exception handling requires a frame pointer\");\n \n-  /* call to  __builtin_return_address () */\n-  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n-#if 0\n-  /* I would like to do this here, but doesn't seem to work. */\n-  emit_move_insn (return_val_rtx, gen_rtx (LABEL_REF,\n-\t\t\t\t\t   Pmode,\n-\t\t\t\t\t   throw_label));\n-  /* So, for now, just pass throw label to stack unwinder. */\n-#endif\n-  /* We use three values, PC, type, and value */\n-  params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n-\t\t\t\t\t    gen_rtx (LABEL_REF, Pmode, throw_label)), NULL_TREE);\n-  \n-  do_function_call (Unwind, params, NULL_TREE);\n-  assemble_external (TREE_OPERAND (Unwind, 0));\n-  emit_barrier ();\n+  emit_move_insn (stack_pointer_rtx,\n+\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -8)));\n+  emit_move_insn (hard_frame_pointer_rtx,\n+\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -12)));\n #endif\n-#if m88k\n+#if defined(TARGET_88000) /* was m88k */\n   rtx temp_frame = frame_pointer_rtx;\n \n   temp_frame = memory_address (Pmode, temp_frame);\n@@ -1393,17 +1129,30 @@ do_unwind (throw_label)\n \t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n #endif\n #endif\n-#ifdef __arm\n-  if (flag_omit_frame_pointer)\n-    sorry (\"this implementation of exception handling requires a frame pointer\");\n+#if !defined(TARGET_88000) && !defined(ARM_FRAME_RTX) && !defined(SPARC_STACK_ALIGN)\n+  tree fcall;\n+  tree params;\n+  rtx return_val_rtx;\n \n-  emit_move_insn (stack_pointer_rtx,\n-\t\t  gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -8)));\n-  emit_move_insn (hard_frame_pointer_rtx,\n-\t\t  gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -12)));\n+  /* call to  __builtin_return_address () */\n+  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  fcall = build_function_call (BuiltinReturnAddress, params);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n+#if 0\n+  /* I would like to do this here, but doesn't seem to work. */\n+  emit_move_insn (return_val_rtx, inner_throw_label);\n+  /* So, for now, just pass throw label to stack unwinder. */\n+#endif\n+  params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n+\t\t\t\t\t    inner_throw_label), NULL_TREE);\n+  \n+  do_function_call (Unwind, params, NULL_TREE);\n+  assemble_external (TREE_OPERAND (Unwind, 0));\n+  emit_barrier ();\n #endif\n }\n \n+\n /* is called from expand_exception_blocks () to generate the code in a function\n    to \"throw\" if anything in the function needs to perform a throw.\n \n@@ -1420,23 +1169,51 @@ do_unwind (throw_label)\n \t\tgoto throw;\n \n  */\n-static void\n+void\n expand_builtin_throw ()\n {\n   tree fcall;\n   tree params;\n   rtx return_val_rtx;\n-  rtx gotta_rethrow_it = gen_label_rtx ();\n-  rtx gotta_call_terminate = gen_label_rtx ();\n-  rtx unwind_and_throw = gen_label_rtx ();\n-  rtx goto_unwind_and_throw = gen_label_rtx ();\n+  rtx gotta_rethrow_it;\n+  rtx gotta_call_terminate;\n+  rtx unwind_and_throw;\n+  rtx goto_unwind_and_throw;\n+  rtx top_of_loop;\n+  rtx unwind_first;\n+  tree t;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+  if (! throw_used)\n+    return;\n \n-  make_first_label(throw_label);\n-  emit_label (throw_label);\n+  params = void_list_node;\n+  t = build_parse_node (CALL_EXPR, get_identifier (\"__throw\"), params, NULL_TREE);\n+  start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n+\t\t\t\t  void_list_node),\n+\t\t  t, NULL_TREE, NULL_TREE, 0);\n+  store_parm_decls ();\n+  pushlevel (0);\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+\n+  gotta_rethrow_it = gen_label_rtx ();\n+  gotta_call_terminate = gen_label_rtx ();\n+  unwind_and_throw = gen_label_rtx ();\n+  goto_unwind_and_throw = gen_label_rtx ();\n+  top_of_loop = gen_label_rtx ();\n+  unwind_first = gen_label_rtx ();\n+\n+  emit_jump (unwind_first);\n+\n+  emit_label (top_of_loop);\n \n   /* search for an exception handler for the saved_pc */\n   return_val_rtx = do_function_call (FirstExceptionMatch,\n-\t\t\t\t     tree_cons (NULL_TREE, make_tree (ptr_type_node, saved_pc), NULL_TREE),\n+\t\t\t\t     tree_cons (NULL_TREE, saved_pc, NULL_TREE),\n \t\t\t\t     ptr_type_node);\n   assemble_external (TREE_OPERAND (FirstExceptionMatch, 0));\n \n@@ -1454,14 +1231,14 @@ expand_builtin_throw ()\n   emit_label (gotta_rethrow_it);\n \n   /* call to  __builtin_return_address () */\n-#ifdef __arm\n+#if defined(ARM_FRAME_RTX)  /* was __arm */\n /* This replaces a 'call' to __builtin_return_address */\n   return_val_rtx = gen_reg_rtx (Pmode);\n-  emit_move_insn (return_val_rtx, gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -4)));\n+  emit_move_insn (return_val_rtx, gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n #else\n-  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n #endif\n \n   /* did __builtin_return_address () return a valid address? */\n@@ -1470,7 +1247,7 @@ expand_builtin_throw ()\n \n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n-#ifdef __arm\n+#if defined(ARM_FRAME_RTX)  /* was __arm */\n   /* On the ARM, '__builtin_return_address',  must have 4\n      subtracted from it. */\n   emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-4)));\n@@ -1480,63 +1257,234 @@ expand_builtin_throw ()\n      they will confuse BuiltinReturnAddress.  This does not apply to ARM6 and\n      later processors when running in 32 bit mode. */\n   if (!TARGET_6)\n-    emit_insn (gen_rtx (SET, SImode, return_val_rtx, gen_rtx (AND, SImode, return_val_rtx, GEN_INT (0x03fffffc))));\n+    emit_insn (gen_rtx (SET, Pmode, return_val_rtx, gen_rtx (AND, Pmode, return_val_rtx, GEN_INT (0x03fffffc))));\n #else\n-#ifndef sparc\n+#if !defined(SPARC_STACK_ALIGN) /* was sparc */\n   /* On the SPARC, __builtin_return_address is already -8, no need to\n      subtract any more from it. */\n   return_val_rtx = plus_constant (return_val_rtx, -1);\n #endif\n #endif\n \n   /* yes it did */\n-  emit_move_insn (saved_pc, return_val_rtx);\n-  do_unwind (throw_label);\n-  make_first_label(throw_label);\n-  emit_jump (throw_label);\n+  t = build_modify_expr (saved_pc, NOP_EXPR, make_tree (ptr_type_node, return_val_rtx));\n+  expand_expr (t, const0_rtx, VOIDmode, 0);\n+\n+  do_unwind (gen_rtx (LABEL_REF, Pmode, top_of_loop));\n+  emit_jump (top_of_loop);\n \n   /* no it didn't --> therefore we need to call terminate */\n   emit_label (gotta_call_terminate);\n   do_function_call (Terminate, NULL_TREE, NULL_TREE);\n   assemble_external (TREE_OPERAND (Terminate, 0));\n+\n+  {\n+    rtx ret_val, return_val_rtx;\n+    emit_label (unwind_first);\n+    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t  0, hard_frame_pointer_rtx);\n+\n+    /* Set it up so that we continue inside, at the top of the loop.  */\n+    emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, top_of_loop));\n+#ifdef NORMAL_RETURN_ADDR_OFFSET\n+  return_val_rtx = plus_constant (ret_val, -NORMAL_RETURN_ADDR_OFFSET);\n+    if (return_val_rtx != ret_val)\n+      emit_move_insn (ret_val, return_val_rtx);\n+#endif\n+\n+    /* Fall into epilogue to unwind prologue. */\n+  }\n+\n+  expand_end_bindings (getdecls(), 1, 0);\n+  poplevel (1, 0, 0);\n+  pop_momentary ();\n+\n+  finish_function (lineno, 0, 0);\n }\n \n \n+void\n+expand_start_eh_spec ()\n+{\n+  start_protect ();\n+}\n+\n+void\n+expand_end_eh_spec (raises)\n+     tree raises;\n+{\n+  tree expr, second_try;\n+  rtx check = gen_label_rtx ();\n+  rtx cont;\n+  rtx ret = gen_reg_rtx (Pmode);\n+  rtx flag = gen_reg_rtx (TYPE_MODE (integer_type_node));\n+  rtx end = gen_label_rtx ();\n+\n+  expr = make_node (RTL_EXPR);\n+  TREE_TYPE (expr) = void_type_node;\n+  RTL_EXPR_RTL (expr) = const0_rtx;\n+  TREE_SIDE_EFFECTS (expr) = 1;\n+  start_sequence_for_rtl_expr (expr);\n+  cont = gen_label_rtx ();\n+  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));\n+  emit_jump (check);\n+  emit_label (cont);\n+  jumpif (make_tree (integer_type_node, flag), end);\n+  do_function_call (Terminate, NULL_TREE, NULL_TREE);\n+  assemble_external (TREE_OPERAND (Terminate, 0));\n+  emit_barrier ();\n+  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n+  end_sequence ();\n+  \n+  second_try = expr;\n+\n+  expr = make_node (RTL_EXPR);\n+  TREE_TYPE (expr) = void_type_node;\n+  RTL_EXPR_RTL (expr) = const0_rtx;\n+  TREE_SIDE_EFFECTS (expr) = 1;\n+  start_sequence_for_rtl_expr (expr);\n+\n+  cont = gen_label_rtx ();\n+  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));\n+  emit_jump (check);\n+  emit_label (cont);\n+  jumpif (make_tree (integer_type_node, flag), end);\n+  start_protect ();\n+  do_function_call (Unexpected, NULL_TREE, NULL_TREE);\n+  assemble_external (TREE_OPERAND (Unexpected, 0));\n+  emit_barrier ();\n+  end_protect (second_try);\n+  \n+  emit_label (check);\n+  emit_move_insn (flag, const1_rtx);\n+  cont = gen_label_rtx ();\n+  while (raises)\n+    {\n+      tree exp;\n+      tree match_type = TREE_VALUE (raises);\n+      \n+      if (match_type)\n+\t{\n+\t  /* check TREE_VALUE (raises) here */\n+\t  exp = saved_throw_value;\n+\t  exp = tree_cons (NULL_TREE,\n+\t\t\t   build_eh_type_type (match_type),\n+\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t\t      saved_throw_type,\n+\t\t\t\t      tree_cons (NULL_TREE, exp, NULL_TREE)));\n+\t  exp = build_function_call (CatchMatch, exp);\n+\t  assemble_external (TREE_OPERAND (CatchMatch, 0));\n+\n+\t  jumpif (exp, cont);\n+\t}\n+\n+      raises = TREE_CHAIN (raises);\n+    }\n+  emit_move_insn (flag, const0_rtx);\n+  emit_label (cont);\n+  emit_indirect_jump (ret);\n+  emit_label (end);\n+  \n+  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n+  end_sequence ();\n+  \n+  end_protect (expr);\n+}\n+\n /* This is called to expand all the toplevel exception handling\n    finalization for a function.  It should only be called once per\n    function.  */\n void\n expand_exception_blocks ()\n {\n-  rtx catchstart, catchend;\n-  rtx last;\n   static rtx funcend;\n+  rtx insns;\n+\n+  start_sequence ();\n \n   funcend = gen_label_rtx ();\n   emit_jump (funcend);\n   /* expand_null_return (); */\n \n-  while (pop_except_stmts (&exceptstack, &catchstart, &catchend)) {\n-    last = get_last_insn ();\n-    NEXT_INSN (last) = catchstart;\n-    PREV_INSN (catchstart) = last;\n-    NEXT_INSN (catchend) = 0;\n-    set_last_insn (catchend);\n-  }\n+  start_sequence ();\n+\n+  /* Add all the catch clauses here.  */\n+  emit_insns (catch_clauses);\n+  catch_clauses = NULL_RTX;\n \n   expand_leftover_cleanups ();\n \n+  insns = get_insns ();\n+  end_sequence ();\n+  \n+  /* Do this after we expand leftover cleanups, so that the end_protect\n+     that expand_end_eh_spec does will match the right start_protect,\n+     and make sure it comes out before the terminate protected region.  */\n+  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n+    {\n+      expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));\n+      push_to_sequence (insns);\n+\n+      /* Now expand any new ones.  */\n+      expand_leftover_cleanups ();\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+    }\n+\n+  if (insns)\n+    {\n+      struct ehEntry entry;\n+\n+      /* These are saved for the exception table.  */\n+      push_rtl_perm ();\n+      entry.start_label = gen_label_rtx ();\n+      entry.end_label = gen_label_rtx ();\n+      entry.exception_handler_label = gen_label_rtx ();\n+      entry.finalization = TerminateFunctionCall;\n+      entry.context = current_function_decl;\n+      assemble_external (TREE_OPERAND (Terminate, 0));\n+      pop_rtl_from_perm ();\n+\n+      LABEL_PRESERVE_P (entry.start_label) = 1;\n+      LABEL_PRESERVE_P (entry.end_label) = 1;\n+      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n+\n+      emit_label (entry.start_label);\n+      emit_insns (insns);\n+\n+      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n+\n+      emit_label (entry.exception_handler_label);\n+      expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n+      emit_label (entry.end_label);\n+      emit_barrier ();\n+    }\n+\n   {\n-    static int have_done = 0;\n-    if (! have_done && TREE_PUBLIC (current_function_decl)\n-\t&& DECL_INTERFACE_KNOWN (current_function_decl)\n-\t&& ! DECL_EXTERNAL (current_function_decl))\n+    /* Mark the end of the stack unwinder.  */\n+    rtx unwind_insns;\n+    start_sequence ();\n+    end_eh_unwinder (funcend);\n+    expand_leftover_cleanups ();\n+    unwind_insns = get_insns ();\n+    end_sequence ();\n+    if (unwind_insns)\n       {\n-\thave_done = 1;\n-\texpand_builtin_throw ();\n+\tinsns = unwind_insns;\n+\temit_insns (insns);\n       }\n   }\n+\n   emit_label (funcend);\n+\n+  /* Only if we had previous insns do we want to emit the jump around\n+     them.  If there weren't any, then insns will remain NULL_RTX.  */\n+  if (insns)\n+    insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_insns (insns);\n }\n \n \n@@ -1567,42 +1515,45 @@ expand_throw (exp)\n   if (exp)\n     {\n       tree throw_type;\n-      rtx throw_type_rtx;\n-      rtx throw_value_rtx;\n+      tree e;\n \n       /* throw expression */\n       /* First, decay it. */\n-      exp = default_conversion (exp);\n+      exp = decay_conversion (exp);\n \n-      /* Make a copy of the thrown object.  WP 15.1.5  */\n-      exp = build_new (NULL_TREE, TREE_TYPE (exp),\n-\t\t       build_tree_list (NULL_TREE, exp),\n-\t\t       0);\n+      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n+\t{\n+\t  throw_type = build_eh_type (exp);\n+\t  exp = build_reinterpret_cast (ptr_type_node, exp);\n+\t}\n+      else\n+\t{\n+\t  /* Make a copy of the thrown object.  WP 15.1.5  */\n+\t  exp = build_new (NULL_TREE, TREE_TYPE (exp),\n+\t\t\t   build_tree_list (NULL_TREE, exp),\n+\t\t\t   0);\n \n-      if (exp == error_mark_node)\n-\terror (\"  in thrown expression\");\n+\t  if (exp == error_mark_node)\n+\t    error (\"  in thrown expression\");\n \n-      throw_type = build_eh_type (build_indirect_ref (exp, NULL_PTR));\n-      throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n+\t  throw_type = build_eh_type (build_indirect_ref (exp, NULL_PTR));\n+\t}\n \n-      throw_value_rtx = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n-      emit_move_insn (saved_throw_value, throw_value_rtx);\n-      emit_move_insn (saved_throw_type, throw_type_rtx);\n+      e = build_modify_expr (saved_throw_type, NOP_EXPR, throw_type);\n+      expand_expr (e, const0_rtx, VOIDmode, 0);\n+      e = build_modify_expr (saved_throw_value, NOP_EXPR, exp);\n+      e = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (e), e);\n+      expand_expr (e, const0_rtx, VOIDmode, 0);\n     }\n   else\n     {\n       /* rethrow current exception */\n       /* This part is easy, as we don't have to do anything else.  */\n     }\n \n-  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n-  make_first_label(throw_label);\n-  emit_jump (throw_label);\n+  expand_internal_throw (gen_rtx (LABEL_REF, Pmode, label));\n }\n \n-/* end of: my-cp-except.c */\n-#endif\n-\n void\n end_protect_partials () {\n   while (protect_list)\n@@ -1615,10 +1566,8 @@ end_protect_partials () {\n int\n might_have_exceptions_p ()\n {\n-#ifdef TRY_NEW_EH\n   if (eh_table_output_queue.head)\n     return 1;\n-#endif\n   return 0;\n }\n \n@@ -1628,7 +1577,6 @@ void\n emit_exception_table ()\n {\n   int count = 0;\n-#ifdef TRY_NEW_EH\n   extern FILE *asm_out_file;\n   struct ehEntry *entry;\n   tree eh_node_decl;\n@@ -1639,8 +1587,8 @@ emit_exception_table ()\n   exception_section ();\n \n   /* Beginning marker for table. */\n-  ASM_OUTPUT_ALIGN (asm_out_file, 2);\n-  ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_TABLE__\");\n+  assemble_align (GET_MODE_ALIGNMENT (Pmode));\n+  assemble_label (\"__EXCEPTION_TABLE__\");\n   output_exception_table_entry (asm_out_file,\n \t\t\t\tconst0_rtx, const0_rtx, const0_rtx);\n \n@@ -1658,22 +1606,18 @@ emit_exception_table ()\n   }\n \n   /* Ending marker for table. */\n-  ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_END__\");\n+  assemble_label (\"__EXCEPTION_END__\");\n   output_exception_table_entry (asm_out_file,\n \t\t\t\tconstm1_rtx, constm1_rtx, constm1_rtx);\n-\n-#endif /* TRY_NEW_EH */\n }\n \n void\n register_exception_table ()\n {\n-#ifdef TRY_NEW_EH\n   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__register_exceptions\"), 0,\n \t\t     VOIDmode, 1,\n \t\t     gen_rtx (SYMBOL_REF, Pmode, \"__EXCEPTION_TABLE__\"),\n \t\t     Pmode);\n-#endif /* TRY_NEW_EH */\n }\n \n /* Build a throw expression.  */\n@@ -1689,3 +1633,58 @@ build_throw (e)\n     }\n   return e;\n }\n+\n+start_eh_unwinder ()\n+{\n+  start_protect ();\n+}\n+\n+end_eh_unwinder (end)\n+     rtx end;\n+{\n+  tree expr;\n+  rtx return_val_rtx, ret_val, label;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+  expr = make_node (RTL_EXPR);\n+  TREE_TYPE (expr) = void_type_node;\n+  RTL_EXPR_RTL (expr) = const0_rtx;\n+  TREE_SIDE_EFFECTS (expr) = 1;\n+  start_sequence_for_rtl_expr (expr);\n+\n+  ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t0, hard_frame_pointer_rtx);\n+  return_val_rtx = copy_to_reg (ret_val);\n+#ifdef NORMAL_RETURN_ADDR_OFFSET\n+  return_val_rtx = plus_constant (return_val_rtx, NORMAL_RETURN_ADDR_OFFSET-1);\n+#else\n+  return_val_rtx = plus_constant (return_val_rtx, -1);\n+#endif\n+  emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);\n+  \n+#ifdef JUMP_TO_THROW\n+  emit_move_insn (ret_val, gen_rtx (SYMBOL_REF, Pmode, \"__throw\"));\n+#else\n+  label = gen_label_rtx ();\n+  emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, label));\n+#endif\n+\n+#ifdef NORMAL_RETURN_ADDR_OFFSET\n+  return_val_rtx = plus_constant (ret_val, -NORMAL_RETURN_ADDR_OFFSET);\n+  if (return_val_rtx != ret_val)\n+    emit_move_insn (ret_val, return_val_rtx);\n+#endif\n+  \n+  emit_jump (end);  \n+\n+#ifndef JUMP_TO_THROW\n+  emit_label (label);\n+  do_function_call (Throw, NULL_TREE, NULL_TREE);\n+#endif\n+  \n+  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n+  end_sequence ();\n+  end_protect (expr);\n+}"}, {"sha": "99a611e697123a7247889a102009cf0e4504f948", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -105,7 +105,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t    && TREE_CODE (TREE_OPERAND (func, 0)) == FUNCTION_DECL\n \t    && DECL_CONSTRUCTOR_P (TREE_OPERAND (func, 0)))\n \t  {\n-\t    type = TYPE_POINTER_TO (type);\n+\t    type = build_pointer_type (type);\n \t    /* Don't clobber a value that might be part of a default\n \t       parameter value.  */\n \t    mark_addressable (slot);\n@@ -226,6 +226,14 @@ cplus_expand_expr (exp, target, tmode, modifier)\n       expand_throw (TREE_OPERAND (exp, 0));\n       return NULL;\n \n+    case UNSAVE_EXPR:\n+      {\n+\trtx temp;\n+\ttemp = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n+\tTREE_OPERAND (exp, 0) = unsave_expr_now (TREE_OPERAND (exp, 0));\n+\treturn temp;\n+      }\n+\n     default:\n       break;\n     }"}, {"sha": "ae016fad08245dcb118db4e7b4b44170ecbea745", "filename": "gcc/cp/g++.1", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fg%2B%2B.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fg%2B%2B.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2B.1?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -8,7 +8,7 @@\n \\(**\n ..\n .SH NAME\n-g++ \\- GNU project C++ Compiler (v2.4)\n+g++ \\- GNU project C++ Compiler\n .SH SYNOPSIS\n .RB g++ \" [\" \\c\n .IR option \" | \" filename \" ].\\|.\\|.\n@@ -31,8 +31,12 @@ C++ source files use one of the suffixes `\\|\\c\n .B .C\\c\n \\&\\|', `\\|\\c\n .B .cc\\c\n-\\&\\|', or `\\|\\c\n+\\&\\|', `\\|\\c\n .B .cxx\\c\n+\\&\\|', `\\|\\c\n+.B .cpp\\c\n+\\&\\|', or `\\|\\c\n+.B .c++\\c\n \\&\\|'; preprocessed C++ files use the suffix `\\|\\c\n .B .ii\\c\n \\&\\|'."}, {"sha": "e5465e89b487e012f7ee75676c8ae6c303af6cc8", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -9,13 +9,9 @@ __asm, GCC_ASM_KEYWORD, NORID\n __asm__, GCC_ASM_KEYWORD, NORID\n __attribute, ATTRIBUTE, NORID\n __attribute__, ATTRIBUTE, NORID\n-__classof, CLASSOF, NORID\n-__classof__, CLASSOF, NORID\n __const, TYPE_QUAL, RID_CONST\n __const__, TYPE_QUAL, RID_CONST\n __extension__, EXTENSION, NORID\n-__headof, HEADOF, NORID\n-__headof__, HEADOF, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n __label__, LABEL, NORID\n@@ -40,7 +36,6 @@ case, CASE, NORID,\n catch, CATCH, NORID,\n char, TYPESPEC, RID_CHAR,\n class, AGGR, RID_CLASS,\n-classof, CLASSOF, NORID,\n compl, '~', NORID,\n const, TYPE_QUAL, RID_CONST,\n const_cast, CONST_CAST, NORID,\n@@ -59,7 +54,6 @@ float, TYPESPEC, RID_FLOAT,\n for, FOR, NORID,\n friend, SCSPEC, RID_FRIEND,\n goto, GOTO, NORID,\n-headof, HEADOF, NORID,\n if, IF, NORID,\n inline, SCSPEC, RID_INLINE,\n int, TYPESPEC, RID_INT,"}, {"sha": "015a33c002cc5daa56f9db55d22148e85428402d", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 304, "deletions": 59, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -924,28 +924,46 @@ will never be a problem.\n @node Templates, Access Control, Coding Conventions, Top\n @section Templates\n \n-g++ uses the simple approach to instantiating templates: it blindly\n-generates the code for each instantiation as needed.  For class\n-templates, g++ pushes the template parameters into the namespace for the\n-duration of the instantiation; for function templates, it's a simple\n-search and replace.\n+A template is represented by a @code{TEMPLATE_DECL}.  The specific\n+fields used are:\n \n-This approach does not support any of the template definition-time error\n-checking that is being bandied about by X3J16.  It makes no attempt to deal\n-with name binding in a consistent way.\n+@table @code\n+@item DECL_TEMPLATE_RESULT\n+The generic decl on which instantiations are based.  This looks just\n+like any other decl.\n \n-Instantiation of a class template is triggered by the use of a template\n-class anywhere but in a straight declaration like @code{class A<int>}.\n-This is wrong; in fact, it should not be triggered by typedefs or\n-declarations of pointers.  Now that explicit instantiation is supported,\n-this misfeature is not necessary.\n+@item DECL_TEMPLATE_PARMS\n+The parameters to this template.\n+@end table\n \n-Important functions:\n+The generic decl is parsed as much like any other decl as possible,\n+given the parameterization.  The template decl is not built up until the\n+generic decl has been completed.  For template classes, a template decl\n+is generated for each member function and static data member, as well.\n \n-@table @code\n-@item instantiate_class_template\n-This function \n-@end table\n+Template members of template classes are represented by a TEMPLATE_DECL\n+for the class' parameters around another TEMPLATE_DECL for the member's\n+parameters.\n+\n+All declarations that are instantiations or specializations of templates\n+refer to their template and parameters through DECL_TEMPLATE_INFO.\n+\n+How should I handle parsing member functions with the proper param\n+decls?  Set them up again or try to use the same ones?  Currently we do\n+the former.  We can probably do this without any extra machinery in\n+store_pending_inline, by deducing the parameters from the decl in\n+do_pending_inlines.  PRE_PARSED_TEMPLATE_DECL?\n+\n+If a base is a parm, we can't check anything about it.  If a base is not\n+a parm, we need to check it for name binding.  Do finish_base_struct if\n+no bases are parameterized (only if none, including indirect, are\n+parms).  Nah, don't bother trying to do any of this until instantiation\n+-- we only need to do name binding in advance.\n+\n+Always set up method vec and fields, inc. synthesized methods.  Really?\n+We can't know the types of the copy folks, or whether we need a\n+destructor, or can have a default ctor, until we know our bases and\n+fields.  Otherwise, we can assume and fix ourselves later.  Hopefully.\n \n @node Access Control, Error Reporting, Templates, Top\n @section Access Control\n@@ -1194,63 +1212,218 @@ the object was thrown.  This is so that there is always someplace for\n the exception object, and nothing can overwrite it, once we start\n throwing.  The only bad part, is that the stack remains large.\n \n+The below points out some things that work in g++'s exception handling.\n+\n+All completely constructed temps and local variables are cleaned up in\n+all unwinded scopes.  Completely constructed parts of partially\n+constructed objects are cleaned up.  This includes partially built\n+arrays.  Exception specifications are now handled.\n+\n The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n Only exact type matching or reference matching of throw types works when\n -fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm and\n-rs6000 machines.  Partial support is also in for alpha, hppa, m68k and\n-mips machines, but a stack unwinder called __unwind_function has to be\n-written, and added to libgcc2 for them.  See below for details on\n-__unwind_function.  All completely constructed temps and local variables\n-are cleaned up in all unwinded scopes.  Completed parts of partially\n-constructed objects are cleaned up with the exception that partially\n-built arrays are not cleaned up as required.  Don't expect exception\n-handling to work right if you optimize, in fact the compiler will\n-probably core dump.  If two EH regions are the exact same size, the\n-backend cannot tell which one is first.  It punts by picking the last\n-one, if they tie.  This is usually right.  We really should stick in a\n-nop, if they are the same size.\n-\n-When we invoke the copy constructor for an exception object because it\n-is passed by value, and if we take a hit (exception) inside the copy\n-constructor someplace, where do we go?  I have tentatively chosen to\n-not catch throws by the outer block at the same unwind level, if one\n-exists, but rather to allow the frame to unwind into the next series of\n-handlers, if any.  If this is the wrong way to do it, we will need to\n-protect the rest of the handler in some fashion.  Maybe just changing\n-the handler's handler to protect the whole series of handlers is the\n-right way to go.  This part is wrong.  We should call terminate if an\n-exception is thrown while doing things like trying to copy the exception\n-object.\n-\n-Exception specifications are handled syntax wise, but not semantic wise.\n-build_exception_variant should sort the incoming list, so that is\n+rs6000 machines.  Partial support is in for all other machines, but a\n+stack unwinder called __unwind_function has to be written, and added to\n+libgcc2 for them.  See below for details on __unwind_function.  Don't\n+expect exception handling to work right if you optimize, in fact the\n+compiler will probably core dump.  RTL_EXPRs for EH cond variables for\n+&& and || exprs should probably be wrapped in UNSAVE_EXPRs, and\n+RTL_EXPRs tweaked so that they can be unsaved, and the UNSAVE_EXPR code\n+should be in the backend, or alternatively, UNSAVE_EXPR should be ripped\n+out and exactly one finalization allowed to be expanded by the backend.\n+I talked with kenner about this, and we have to allow multiple\n+expansions.\n+\n+We only do pointer conversions on exception matching a la 15.3 p2 case\n+3: `A handler with type T, const T, T&, or const T& is a match for a\n+throw-expression with an object of type E if [3]T is a pointer type and\n+E is a pointer type that can be converted to T by a standard pointer\n+conversion (_conv.ptr_) not involving conversions to pointers to private\n+or protected base classes.' when -frtti is given.\n+\n+We don't call delete on new expressions that die because the ctor threw\n+an exception.  See except/18 for a test case.\n+\n+15.2 para 13: The exception being handled should be rethrown if control\n+reaches the end of a handler of the function-try-block of a constructor\n+or destructor, right now, it is not.\n+\n+15.2 para 12: If a return statement appears in a handler of\n+function-try-block of a constructor, the program is ill-formed, but this\n+isn't diagnosed.\n+\n+15.2 para 11: If the handlers of a function-try-block contain a jump\n+into the body of a constructor or destructor, the program is ill-formed,\n+but this isn't diagnosed.\n+\n+15.2 para 9: Check that the fully constructed base classes and members\n+of an object are destroyed before entering the handler of a\n+function-try-block of a constructor or destructor for that object.\n+\n+build_exception_variant should sort the incoming list, so that it\n implements set compares, not exact list equality.  Type smashing should\n smash exception specifications using set union.\n \n-Thrown objects are allocated on the heap, in the usual way, but they are\n-never deleted.  They should be deleted by the catch clauses.  If one\n-runs out of heap space, throwing an object will probably never work.\n-This could be relaxed some by passing an __in_chrg parameter to track\n-who has control over the exception object.\n+Thrown objects are usually allocated on the heap, in the usual way, but\n+they are never deleted.  They should be deleted by the catch clauses.\n+If one runs out of heap space, throwing an object will probably never\n+work.  This could be relaxed some by passing an __in_chrg parameter to\n+track who has control over the exception object.  Thrown objects are not\n+allocated on the heap when they are pointer to object types.\n \n When the backend returns a value, it can create new exception regions\n that need protecting.  The new region should rethrow the object in\n context of the last associated cleanup that ran to completion.\n \n+The structure of the code that is generated for C++ exception handling\n+code is shown below:\n+\n+@example\n+Ln:\t\t\t\t\tthrow value;\n+        copy value onto heap\n+        jump throw (Ln, id, address of copy of value on heap)\n+\n+                                        try {\n++Lstart:\tthe start of the main EH region\n+|...\t\t\t\t\t\t...\n++Lend:\t\tthe end of the main EH region\n+                                        } catch (T o) {\n+\t\t\t\t\t\t...1\n+                                        }\n+Lresume:\n+        nop\tused to make sure there is something before\n+                the next region ends, if there is one\n+...                                     ...\n+\n+        jump Ldone\n+[\n+Lmainhandler:    handler for the region Lstart-Lend\n+\tcleanup\n+] zero or more, depending upon automatic vars with dtors\n++Lpartial:\n+|        jump Lover\n++Lhere:\n+        rethrow (Lhere, same id, same obj);\n+Lterm:\t\thandler for the region Lpartial-Lhere\n+        call terminate\n+Lover:\n+[\n+ [\n+        call throw_type_match\n+        if (eq) {\n+ ] these lines disappear when there is no catch condition\n++Lsregion2:\n+|\t...1\n+|\tjump Lresume\n+|Lhandler:\thandler for the region Lsregion2-Leregion2\n+|\trethrow (Lresume, same id, same obj);\n++Leregion2\n+        }\n+] there are zero or more of these sections, depending upon how many\n+  catch clauses there are\n+----------------------------- expand_end_all_catch --------------------------\n+                here we have fallen off the end of all catch\n+                clauses, so we rethrow to outer\n+        rethrow (Lresume, same id, same obj);\n+----------------------------- expand_end_all_catch --------------------------\n+[\n+L1:     maybe throw routine\n+] depending upon if we have expanded it or not\n+Ldone:\n+        ret\n+\n+start_all_catch emits labels: Lresume, \n+\n+#end example\n+\n The __unwind_function takes a pointer to the throw handler, and is\n expected to pop the stack frame that was built to call it, as well as\n-the frame underneath and then jump to the throw handler.  It must not\n-change the three registers allocated for the pointer to the exception\n-object, the pointer to the type descriptor that identifies the type of\n-the exception object, and the pointer to the code that threw.  On hppa,\n-these are %r5, %r6, %r7.  On m68k these are a2, a3, a4.  On mips they\n-are s0, s1, s2.  On Alpha these are $9, $10, $11.  It takes about a day\n-to write this routine, if someone wants to volunteer to write this\n-routine for any architecture, exception support for that architecture\n-will be added to g++.  Please send in those code donations.\n+the frame underneath and then jump to the throw handler.  It must\n+restore all registers to their proper values as well as all other\n+machine state as determined by the context in which we are unwinding\n+into.  The way I normally start is to compile:\n+\n+        void *g;\n+        foo(void* a) { g = a; }\n+\n+with -S, and change the thing that alters the PC (return, or ret\n+usually) to not alter the PC, making sure to leave all other semantics\n+(like adjusting the stack pointer, or frame pointers) in.  After that,\n+replicate the prologue once more at the end, again, changing the PC\n+altering instructions, and finally, at the very end, jump to `g'.\n+\n+It takes about a week to write this routine, if someone wants to\n+volunteer to write this routine for any architecture, exception support\n+for that architecture will be added to g++.  Please send in those code\n+donations.  One other thing that needs to be done, is to double check\n+that __builtin_return_address (0) works.\n+\n+@subsection Specific Targets\n \n+For the alpha, the __unwind_function will be something resembling:\n+\n+@example\n+void\n+__unwind_function(void *ptr)\n+@{\n+  /* First frame */\n+  asm (\"ldq $15, 8($30)\"); /* get the saved frame ptr; 15 is fp, 30 is sp */\n+  asm (\"bis $15, $15, $30\"); /* reload sp with the fp we found */\n+\n+  /* Second frame */\n+  asm (\"ldq $15, 8($30)\"); /* fp */\n+  asm (\"bis $15, $15, $30\"); /* reload sp with the fp we found */\n+\n+  /* Return */\n+  asm (\"ret $31, ($16), 1\"); /* return to PTR, stored in a0 */\n+@}\n+@end example\n+\n+@noindent\n+However, there are a few problems preventing it from working.  First of\n+all, the gcc-internal function @code{__builtin_return_address} needs to\n+work given an argument of 0 for the alpha.  As it stands as of August\n+30th, 1995, the code for @code{BUILT_IN_RETURN_ADDRESS} in @file{expr.c}\n+will definitely not work on the alpha.  Instead, we need to define\n+the macros @code{DYNAMIC_CHAIN_ADDRESS} (maybe),\n+@code{RETURN_ADDR_IN_PREVIOUS_FRAME}, and definitely need a new\n+definition for @code{RETURN_ADDR_RTX}.\n+\n+In addition (and more importantly), we need a way to reliably find the\n+frame pointer on the alpha.  The use of the value 8 above to restore the\n+frame pointer (register 15) is incorrect.  On many systems, the frame\n+pointer is consistently offset to a specific point on the stack.  On the\n+alpha, however, the frame pointer is pushed last.  First the return\n+address is stored, then any other registers are saved (e.g., @code{s0}),\n+and finally the frame pointer is put in place.  So @code{fp} could have\n+an offset of 8, but if the calling function saved any registers at all,\n+they add to the offset.\n+\n+The only places the frame size is noted are with the @samp{.frame}\n+directive, for use by the debugger and the OSF exception handling model\n+(useless to us), and in the initial computation of the new value for\n+@code{sp}, the stack pointer.  For example, the function may start with:\n+\n+@example\n+lda $30,-32($30)\n+.frame $15,32,$26,0\n+@end example \n+\n+@noindent\n+The 32 above is exactly the value we need.  With this, we can be sure\n+that the frame pointer is stored 8 bytes less---in this case, at 24(sp)).\n+The drawback is that there is no way that I (Brendan) have found to let\n+us discover the size of a previous frame @emph{inside} the definition\n+of @code{__unwind_function}.\n+\n+So to accomplish exception handling support on the alpha, we need two\n+things: first, a way to figure out where the frame pointer was stored,\n+and second, a functional @code{__builtin_return_address} implementation\n+for except.c to be able to use it.\n+\n+@subsection Backend Exception Support\n \n The backend must be extended to fully support exceptions.  Right now\n there are a few hooks into the alpha exception handling backend that\n@@ -1285,6 +1458,78 @@ semantics.\n The above is not meant to be exhaustive, but does include all things I\n have thought of so far.  I am sure other limitations exist.\n \n+Below are some notes on the migration of the exception handling code\n+backend from the C++ frontend to the backend.\n+\n+NOTEs are to be used to denote the start of an exception region, and the\n+end of the region.  I presume that the interface used to generate these\n+notes in the backend would be two functions, start_exception_region and\n+end_exception_region (or something like that).  The frontends are\n+required to call them in pairs.  When marking the end of a region, an\n+argument can be passed to indicate the handler for the marked region.\n+This can be passed in many ways, currently a tree is used.  Another\n+possibility would be insns for the handler, or a label that denotes a\n+handler.  I have a feeling insns might be the the best way to pass it.\n+Semantics are, if an exception is thrown inside the region, control is\n+transfered unconditionally to the handler.  If control passes through\n+the handler, then the backend is to rethrow the exception, in the\n+context of the end of the original region.  The handler is protected by\n+the conventional mechanisms; it is the frontend's responsibility to\n+protect the handler, if special semantics are required.\n+\n+This is a very low level view, and it would be nice is the backend\n+supported a somewhat higher level view in addition to this view.  This\n+higher level could include source line number, name of the source file,\n+name of the language that threw the exception and possibly the name of\n+the exception.  Kenner may want to rope you into doing more than just\n+the basics required by C++.  You will have to resolve this.  He may want\n+you to do support for non-local gotos, first scan for exception handler,\n+if none is found, allow the debugger to be entered, without any cleanups\n+being done.  To do this, the backend would have to know the difference\n+between a cleanup-rethrower, and a real handler, if would also have to\n+have a way to know if a handler `matches' a thrown exception, and this\n+is frontend specific.\n+\n+The UNSAVE_EXPR tree code has to be migrated to the backend.  Exprs such\n+as TARGET_EXPRs, WITH_CLEANUP_EXPRs, CALL_EXPRs and RTL_EXPRs have to be\n+changed to support unsaving.  This is meant to be a complete list.\n+SAVE_EXPRs can be unsaved already.  expand_decl_cleanup should be\n+changed to unsave it's argument, if needed.  See\n+cp/tree.c:cp_expand_decl_cleanup, unsave_expr_now, unsave_expr, and\n+cp/expr.c:cplus_expand_expr(case UNSAVE_EXPR:) for the UNSAVE_EXPR code.\n+Now, as to why...  because kenner already tripped over the exact same\n+problem in Ada, we talked about it, he didn't like any of the solution,\n+but yet, didn't like no solution either.  He was willing to live with\n+the drawbacks of this solution.  The drawback is unsave_expr_now.  It\n+should have a callback into the frontend, to allow the unsaveing of\n+frontend special codes.  The callback goes in, inplace of the call to\n+my_friendly_abort.\n+\n+The stack unwinder is one of the hardest parts to do.  It is highly\n+machine dependent.  The form that kenner seems to like was a couple of\n+macros, that would do the machine dependent grunt work.  One preexisting\n+function that might be of some use is __builtin_return_address ().  One\n+macro he seemed to want was __builtin_return_address, and the other\n+would do the hard work of fixing up the registers, adjusting the stack\n+pointer, frame pointer, arg pointer and so on.\n+\n+The eh archive (~mrs/eh) might be good reading for understanding the Ada\n+perspective, and some of kenners mindset, and a detailed explanation\n+(Message-Id: <9308301130.AA10543@vlsi1.ultra.nyu.edu>) of the concepts\n+involved.\n+\n+Here is a guide to existing backend type code.  It is all in\n+cp/except.c.  Check out do_unwind, and expand_builtin_throw for current\n+code on how to figure out what handler matches an exception,\n+emit_exception_table for code on emitting the PC range table that is\n+built during compilation, expand_exception_blocks for code that emits\n+all the handlers at the end of a functions, end_protect to mark the end\n+of an exception region, start_protect to mark the start of an exception\n+region, lang_interim_eh is the master hook used by the backend into the\n+EH backend that now exists in the frontend, and expand_internal_throw to\n+raise an exception.\n+\n+\n @node Free Store, Concept Index, Exception Handling, Top\n @section Free Store\n "}, {"sha": "4848aba47754b714b46330edea48c86757662cd1", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -3,12 +3,12 @@\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 101\n+#define TOTAL_KEYWORDS 97\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 210\n-/* maximum key range = 207, duplicates = 0 */\n+#define MAX_HASH_VALUE 219\n+/* maximum key range = 216, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +20,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n-     211, 211, 211, 211, 211,   0, 211,  35,   1,  69,\n-      61,   0,  19,  65,  20, 100, 211,   5,  11,  52,\n-       3,  25,   6,   2,  31,  26,   4,  41,  24,  64,\n-      10,  24, 211, 211, 211, 211, 211, 211,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n+     220, 220, 220, 220, 220,   0, 220,  88,  16,  19,\n+      52,   0,   9,  72,   1,  77, 220,   0,   0,  38,\n+      13,  44,  38,  30,  27,  57,   1,  14,   0,   2,\n+       2,   7, 220, 220, 220, 220, 220, 220,\n     };\n   register int hval = len;\n \n@@ -65,144 +65,144 @@ is_reserved_word (str, len)\n     {\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n       {\"true\",  CXX_TRUE, NORID,},\n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"\",}, \n+      {\"while\",  WHILE, NORID,},\n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"\",}, {\"\",}, \n+      {\"try\",  TRY, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"typeof\",  TYPEOF, NORID,},\n       {\"not\",  '!', NORID,},\n-      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"new\",  NEW, NORID,},\n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n       {\"\",}, {\"\",}, \n-      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"case\",  CASE, NORID,},\n+      {\"__alignof__\",  ALIGNOF, NORID},\n       {\"\",}, \n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"\",}, \n-      {\"xor_eq\",  ASSIGN, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"\",}, {\"\",}, \n-      {\"__alignof__\",  ALIGNOF, NORID},\n       {\"__extension__\",  EXTENSION, NORID},\n-      {\"bool\",  TYPESPEC, RID_BOOL,},\n+      {\"\",}, {\"\",}, \n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"xor\",  '^', NORID,},\n       {\"\",}, \n-      {\"typeof\",  TYPEOF, NORID,},\n+      {\"__inline\",  SCSPEC, RID_INLINE},\n       {\"\",}, \n-      {\"try\",  TRY, NORID,},\n-      {\"or_eq\",  ASSIGN, NORID,},\n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n       {\"\",}, \n-      {\"__headof__\",  HEADOF, NORID},\n+      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"for\",  FOR, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"continue\",  CONTINUE, NORID,},\n       {\"\",}, \n+      {\"catch\",  CATCH, NORID,},\n       {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"\",}, \n+      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n+      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n+      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"throw\",  THROW, NORID,},\n+      {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"__const\",  TYPE_QUAL, RID_CONST},\n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n       {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"__alignof\",  ALIGNOF, NORID},\n-      {\"and_eq\",  ASSIGN, NORID,},\n-      {\"xor\",  '^', NORID,},\n+      {\"delete\",  DELETE, NORID,},\n+      {\"typeid\",  TYPEID, NORID,},\n+      {\"return\",  RETURN, NORID,},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"compl\",  '~', NORID,},\n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"\",}, \n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"\",}, \n       {\"static_cast\",  STATIC_CAST, NORID,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"namespace\",  NAMESPACE, NORID,},\n-      {\"__classof__\",  CLASSOF, NORID},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"false\",  CXX_FALSE, NORID,},\n       {\"sizeof\",  SIZEOF, NORID,},\n-      {\"__headof\",  HEADOF, NORID},\n-      {\"for\",  FOR, NORID,},\n-      {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"switch\",  SWITCH, NORID,},\n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n       {\"or\",  OROR, NORID,},\n-      {\"__typeof__\",  TYPEOF, NORID},\n-      {\"this\",  THIS, NORID,},\n-      {\"\",}, \n-      {\"bitor\",  '|', NORID,},\n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n-      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n-      {\"__classof\",  CLASSOF, NORID},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"delete\",  DELETE, NORID,},\n       {\"double\",  TYPESPEC, RID_DOUBLE,},\n       {\"\",}, \n-      {\"new\",  NEW, NORID,},\n-      {\"typeid\",  TYPEID, NORID,},\n-      {\"\",}, \n-      {\"case\",  CASE, NORID,},\n       {\"union\",  AGGR, RID_UNION,},\n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n-      {\"__typeof\",  TYPEOF, NORID},\n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"struct\",  AGGR, RID_RECORD,},\n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"or_eq\",  ASSIGN, NORID,},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"int\",  TYPESPEC, RID_INT,},\n+      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n+      {\"\",}, \n+      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"if\",  IF, NORID,},\n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"bitor\",  '|', NORID,},\n       {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"while\",  WHILE, NORID,},\n-      {\"return\",  RETURN, NORID,},\n+      {\"\",}, \n+      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"do\",  DO, NORID,},\n       {\"\",}, \n       {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n       {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n       {\"\",}, \n-      {\"do\",  DO, NORID,},\n-      {\"auto\",  SCSPEC, RID_AUTO,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"compl\",  '~', NORID,},\n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"using\",  USING, NORID,},\n       {\"\",}, \n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"const_cast\",  CONST_CAST, NORID,},\n       {\"\",}, \n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"break\",  BREAK, NORID,},\n+      {\"namespace\",  NAMESPACE, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"this\",  THIS, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"and_eq\",  ASSIGN, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"\",}, \n-      {\"throw\",  THROW, NORID,},\n-      {\"and\",  ANDAND, NORID,},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"bitand\",  '&', NORID,},\n-      {\"const\",  TYPE_QUAL, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"headof\",  HEADOF, NORID,},\n-      {\"int\",  TYPESPEC, RID_INT,},\n-      {\"enum\",  ENUM, NORID,},\n-      {\"\",}, \n-      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"class\",  AGGR, RID_CLASS,},\n+      {\"register\",  SCSPEC, RID_REGISTER,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"and\",  ANDAND, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"long\",  TYPESPEC, RID_LONG,},\n       {\"default\",  DEFAULT, NORID,},\n+      {\"operator\",  OPERATOR, NORID,},\n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"inline\",  SCSPEC, RID_INLINE,},\n       {\"\",}, \n-      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"using\",  USING, NORID,},\n-      {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"\",}, \n-      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"bitand\",  '&', NORID,},\n       {\"\",}, \n       {\"goto\",  GOTO, NORID,},\n-      {\"operator\",  OPERATOR, NORID,},\n-      {\"if\",  IF, NORID,},\n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n-      {\"\",}, {\"\",}, \n-      {\"class\",  AGGR, RID_CLASS,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"char\",  TYPESPEC, RID_CHAR,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"classof\",  CLASSOF, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"overload\",  OVERLOAD, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"catch\",  CATCH, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"register\",  SCSPEC, RID_REGISTER,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"const_cast\",  CONST_CAST, NORID,},\n-      {\"\",}, {\"\",}, \n       {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"\",}, \n+      {\"auto\",  SCSPEC, RID_AUTO,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"inline\",  SCSPEC, RID_INLINE,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, \n+      {\"overload\",  OVERLOAD, NORID,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "ccce6b787a040c809fc4b3447f4e21566f391298", "filename": "gcc/cp/init.c", "status": "modified", "additions": 228, "deletions": 179, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -729,7 +729,7 @@ expand_virtual_init (binfo, decl)\n   vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)), binfo));\n   assemble_external (vtbl);\n   TREE_USED (vtbl) = 1;\n-  vtbl = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (vtbl)), vtbl);\n+  vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n   decl = convert_pointer_to_real (vtype_binfo, decl);\n   vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL_PTR), vtype);\n   if (vtbl_ptr == error_mark_node)\n@@ -1075,6 +1075,8 @@ expand_member_init (exp, name, init)\n    INIT comes in two flavors: it is either a value which\n    is to be stored in EXP, or it is a parameter list\n    to go to a constructor, which will operate on EXP.\n+   If INIT is not a parameter list for a constructor, then set\n+   LOOKUP_ONLYCONVERTING.\n    If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of\n    the initializer, if FLAGS is 0, then it is the (init) form.\n    If `init' is a CONSTRUCTOR, then we emit a warning message,\n@@ -1113,19 +1115,23 @@ expand_aggr_init (exp, init, alias_this, flags)\n {\n   tree type = TREE_TYPE (exp);\n   int was_const = TREE_READONLY (exp);\n+  int was_volatile = TREE_THIS_VOLATILE (exp);\n \n   if (init == error_mark_node)\n     return;\n \n   TREE_READONLY (exp) = 0;\n+  TREE_THIS_VOLATILE (exp) = 0;\n+\n+  if (init && TREE_CODE (init) != TREE_LIST)\n+    flags |= LOOKUP_ONLYCONVERTING;\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Must arrange to initialize each element of EXP\n \t from elements of INIT.  */\n-      int was_const_elts = TYPE_READONLY (TREE_TYPE (type));\n       tree itype = init ? TREE_TYPE (init) : NULL_TREE;\n-      if (was_const_elts)\n+      if (TYPE_READONLY (TREE_TYPE (type)) || TYPE_VOLATILE (TREE_TYPE (type)))\n \t{\n \t  TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n \t  if (init)\n@@ -1151,6 +1157,7 @@ expand_aggr_init (exp, init, alias_this, flags)\n       expand_vec_init (exp, exp, array_type_nelts (type), init,\n \t\t       init && comptypes (TREE_TYPE (init), TREE_TYPE (exp), 1));\n       TREE_READONLY (exp) = was_const;\n+      TREE_THIS_VOLATILE (exp) = was_volatile;\n       TREE_TYPE (exp) = type;\n       if (init)\n \tTREE_TYPE (init) = itype;\n@@ -1172,6 +1179,7 @@ expand_aggr_init (exp, init, alias_this, flags)\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n \t\t      init, alias_this, LOOKUP_NORMAL|flags);\n   TREE_READONLY (exp) = was_const;\n+  TREE_THIS_VOLATILE (exp) = was_volatile;\n }\n \n static void\n@@ -1229,6 +1237,8 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n     }\n   else\n     {\n+      if (flags & LOOKUP_ONLYCONVERTING)\n+\tflags |= LOOKUP_NO_CONVERSION;\n       rval = build_method_call (exp, constructor_name_full (type),\n \t\t\t\tparms, binfo, flags);\n \n@@ -1786,12 +1796,12 @@ build_member_call (cname, name, parmlist)\n   if (dont_use_this)\n     {\n       basetype_path = TYPE_BINFO (type);\n-      decl = build1 (NOP_EXPR, TYPE_POINTER_TO (type), error_mark_node);\n+      decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n     }\n   else if (current_class_decl == 0)\n     {\n       dont_use_this = 1;\n-      decl = build1 (NOP_EXPR, TYPE_POINTER_TO (type), error_mark_node);\n+      decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n     }\n   else\n     {\n@@ -2192,7 +2202,8 @@ resolve_offset_ref (exp)\n     {\n       if (TREE_ADDRESSABLE (member) == 0)\n \t{\n-\t  cp_error_at (\"member `%D' is non-static in static member function context\", member);\n+\t  cp_error_at (\"member `%D' is non-static but referenced as a static member\",\n+\t\t       member);\n \t  error (\"at this point in file\");\n \t  TREE_ADDRESSABLE (member) = 1;\n \t}\n@@ -3037,7 +3048,7 @@ build_new (placement, decl, init, use_global_new)\n   if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n       && (TYPE_GETS_NEW (true_type) & (1 << has_array)))\n     rval = build_opfncall (code, LOOKUP_NORMAL,\n-\t\t\t   TYPE_POINTER_TO (true_type), size, placement);\n+\t\t\t   build_pointer_type (true_type), size, placement);\n   else if (placement)\n     {\n       rval = build_opfncall (code, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n@@ -3064,9 +3075,9 @@ build_new (placement, decl, init, use_global_new)\n       /* See comment above as to why this is disabled.  */\n       if (alignment)\n \t{\n-\t  rval = build (PLUS_EXPR, TYPE_POINTER_TO (true_type), rval,\n+\t  rval = build (PLUS_EXPR, build_pointer_type (true_type), rval,\n \t\t\talignment);\n-\t  rval = build (BIT_AND_EXPR, TYPE_POINTER_TO (true_type),\n+\t  rval = build (BIT_AND_EXPR, build_pointer_type (true_type),\n \t\t\trval, build1 (BIT_NOT_EXPR, integer_type_node,\n \t\t\t\t      alignment));\n \t}\n@@ -3100,7 +3111,7 @@ build_new (placement, decl, init, use_global_new)\n       rval = convert (string_type_node, rval); /* lets not add void* and ints */\n       rval = save_expr (build_binary_op (PLUS_EXPR, rval, extra, 1));\n       /* Store header info.  */\n-      cookie = build_indirect_ref (build (MINUS_EXPR, TYPE_POINTER_TO (BI_header_type),\n+      cookie = build_indirect_ref (build (MINUS_EXPR, build_pointer_type (BI_header_type),\n \t\t\t\t\t  rval, extra), NULL_PTR);\n       exp1 = build (MODIFY_EXPR, void_type_node,\n \t\t    build_component_ref (cookie, nc_nelts_field_id, 0, 0),\n@@ -3187,8 +3198,13 @@ build_new (placement, decl, init, use_global_new)\n \n \t  /* In case of static initialization, SAVE_EXPR is good enough.  */\n \t  rval = save_expr (rval);\n-\t  init = copy_to_permanent (init);\n \t  rval = copy_to_permanent (rval);\n+\t  init = copy_to_permanent (init);\n+\t  init = expand_vec_init (decl, rval,\n+\t\t\t\t  build_binary_op (MINUS_EXPR, nelts,\n+\t\t\t\t\t\t   integer_one_node, 1),\n+\t\t\t\t  init, 0);\n+\t  init = copy_to_permanent (init);\n \t  static_aggregates = perm_tree_cons (init, rval, static_aggregates);\n \t}\n       else\n@@ -3306,6 +3322,174 @@ build_new (placement, decl, init, use_global_new)\n   return rval;\n }\n \f\n+static tree\n+build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n+\t\t    use_global_delete)\n+     tree base, maxindex, type;\n+     tree auto_delete_vec, auto_delete;\n+     int use_global_delete;\n+{\n+  tree virtual_size;\n+  tree ptype = build_pointer_type (type);\n+  tree size_exp = size_in_bytes (type);\n+\n+  /* Temporary variables used by the loop.  */\n+  tree tbase, tbase_init;\n+\n+  /* This is the body of the loop that implements the deletion of a\n+     single element, and moves temp variables to next elements.  */\n+  tree body;\n+\n+  /* This is the LOOP_EXPR that governs the deletion of the elements.  */\n+  tree loop;\n+\n+  /* This is the thing that governs what to do after the loop has run.  */\n+  tree deallocate_expr = 0;\n+\n+  /* This is the BIND_EXPR which holds the outermost iterator of the\n+     loop.  It is convenient to set this variable up and test it before\n+     executing any other code in the loop.\n+     This is also the containing expression returned by this function.  */\n+  tree controller = NULL_TREE;\n+\n+  /* This is the BLOCK to record the symbol binding for debugging.  */\n+  tree block;\n+\n+  if (! IS_AGGR_TYPE (type) || ! TYPE_NEEDS_DESTRUCTOR (type))\n+    {\n+      loop = integer_zero_node;\n+      goto no_destructor;\n+    }\n+\n+  /* The below is short by BI_header_size */\n+  virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n+\n+  tbase = build_decl (VAR_DECL, NULL_TREE, ptype);\n+  tbase_init = build_modify_expr (tbase, NOP_EXPR,\n+\t\t\t\t  fold (build (PLUS_EXPR, ptype,\n+\t\t\t\t\t       base,\n+\t\t\t\t\t       virtual_size)));\n+  DECL_REGISTER (tbase) = 1;\n+  controller = build (BIND_EXPR, void_type_node, tbase, 0, 0);\n+  TREE_SIDE_EFFECTS (controller) = 1;\n+  block = build_block (tbase, 0, 0, 0, 0);\n+  add_block_current_level (block);\n+\n+  if (auto_delete != integer_zero_node\n+      && auto_delete != integer_two_node)\n+    {\n+      tree base_tbd = convert (ptype,\n+\t\t\t       build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\tconvert (ptr_type_node, base),\n+\t\t\t\t\t\tBI_header_size,\n+\t\t\t\t\t\t1));\n+      /* This is the real size */\n+      virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n+      body = build_tree_list (NULL_TREE,\n+\t\t\t      build_x_delete (ptype, base_tbd,\n+\t\t\t\t\t      2 | use_global_delete,\n+\t\t\t\t\t      virtual_size));\n+      body = build (COND_EXPR, void_type_node,\n+\t\t    build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t   auto_delete, integer_one_node),\n+\t\t    body, integer_zero_node);\n+    }\n+  else\n+    body = NULL_TREE;\n+\n+  body = tree_cons (NULL_TREE,\n+\t\t    build_delete (ptype, tbase, auto_delete,\n+\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n+\t\t    body);\n+\n+  body = tree_cons (NULL_TREE,\n+\t\t    build_modify_expr (tbase, NOP_EXPR, build (MINUS_EXPR, ptype, tbase, size_exp)),\n+\t\t    body);\n+\n+  body = tree_cons (NULL_TREE,\n+\t\t    build (EXIT_EXPR, void_type_node,\n+\t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n+\t\t    body);\n+\n+  loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n+\n+  loop = tree_cons (NULL_TREE, tbase_init,\n+\t\t    tree_cons (NULL_TREE, loop, NULL_TREE));\n+  loop = build_compound_expr (loop);\n+\n+ no_destructor:\n+  /* If the delete flag is one, or anything else with the low bit set,\n+     delete the storage.  */\n+  if (auto_delete_vec == integer_zero_node\n+      || auto_delete_vec == integer_two_node)\n+    deallocate_expr = integer_zero_node;\n+  else\n+    {\n+      tree base_tbd;\n+\n+      /* The below is short by BI_header_size */\n+      virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n+\n+      if (! TYPE_VEC_NEW_USES_COOKIE (type))\n+\t/* no header */\n+\tbase_tbd = base;\n+      else\n+\t{\n+\t  base_tbd = convert (ptype,\n+\t\t\t      build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t       convert (string_type_node, base),\n+\t\t\t\t\t       BI_header_size,\n+\t\t\t\t\t       1));\n+\t  /* True size with header. */\n+\t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n+\t}\n+      deallocate_expr = build_x_delete (ptype, base_tbd,\n+\t\t\t\t\t2 | use_global_delete,\n+\t\t\t\t\tvirtual_size);\n+      if (auto_delete_vec != integer_one_node)\n+\tdeallocate_expr = build (COND_EXPR, void_type_node,\n+\t\t\t\t build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t\tauto_delete_vec, integer_one_node),\n+\t\t\t\t deallocate_expr, integer_zero_node);\n+    }\n+\n+  if (loop && deallocate_expr != integer_zero_node)\n+    {\n+      body = tree_cons (NULL_TREE, loop,\n+\t\t\ttree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n+      body = build_compound_expr (body);\n+    }\n+  else\n+    body = loop;\n+\n+  /* Outermost wrapper: If pointer is null, punt.  */\n+  body = build (COND_EXPR, void_type_node,\n+\t\tbuild (NE_EXPR, boolean_type_node, base, integer_zero_node),\n+\t\tbody, integer_zero_node);\n+  body = build1 (NOP_EXPR, void_type_node, body);\n+\n+  if (controller)\n+    {\n+      TREE_OPERAND (controller, 1) = body;\n+      return controller;\n+    }\n+  else\n+    return convert (void_type_node, body);\n+}\n+\n+/* Build a tree to cleanup partially built arrays.\n+   BASE is that starting address of the array.\n+   COUNT is the count of objects that have been built, that need destroying.\n+   TYPE is the type of elements in the array.  */\n+static tree\n+build_array_eh_cleanup (base, count, type)\n+     tree base, count, type;\n+{\n+  tree expr = build_vec_delete_1 (base, count, type, integer_two_node,\n+\t\t\t\t  integer_zero_node, 0);\n+  return expr;\n+}\n+\n /* `expand_vec_init' performs initialization of a vector of aggregate\n    types.\n \n@@ -3350,12 +3534,12 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \n   /* Set to zero in case size is <= 0.  Optimizer will delete this if\n      it is not needed.  */\n-  rval = get_temp_regvar (TYPE_POINTER_TO (type),\n-\t\t\t  convert (TYPE_POINTER_TO (type), null_pointer_node));\n+  rval = get_temp_regvar (build_pointer_type (type),\n+\t\t\t  convert (build_pointer_type (type), null_pointer_node));\n   base = default_conversion (base);\n-  base = convert (TYPE_POINTER_TO (type), base);\n+  base = convert (build_pointer_type (type), base);\n   expand_assignment (rval, base, 0, 0);\n-  base = get_temp_regvar (TYPE_POINTER_TO (type), base);\n+  base = get_temp_regvar (build_pointer_type (type), base);\n \n   if (init != NULL_TREE\n       && TREE_CODE (init) == CONSTRUCTOR\n@@ -3364,7 +3548,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n       /* Initialization of array from {...}.  */\n       tree elts = CONSTRUCTOR_ELTS (init);\n       tree baseref = build1 (INDIRECT_REF, type, base);\n-      tree baseinc = build (PLUS_EXPR, TYPE_POINTER_TO (type), base, size);\n+      tree baseinc = build (PLUS_EXPR, build_pointer_type (type), base, size);\n       int host_i = TREE_INT_CST_LOW (maxindex);\n \n       if (IS_AGGR_TYPE (type))\n@@ -3441,6 +3625,8 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \n       expand_start_cond (build (GE_EXPR, boolean_type_node,\n \t\t\t\titerator, integer_zero_node), 0);\n+      if (TYPE_NEEDS_DESTRUCTOR (type))\n+\tstart_protect ();\n       expand_start_loop_continue_elsewhere (1);\n \n       if (from_array)\n@@ -3466,18 +3652,18 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t{\n \t  if (init != 0)\n \t    sorry (\"cannot initialize multi-dimensional array with initializer\");\n-\t  expand_vec_init (decl, build1 (NOP_EXPR, TYPE_POINTER_TO (TREE_TYPE (type)), base),\n+\t  expand_vec_init (decl, build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (type)), base),\n \t\t\t   array_type_nelts (type), 0, 0);\n \t}\n       else\n \texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0, 0);\n \n       expand_assignment (base,\n-\t\t\t build (PLUS_EXPR, TYPE_POINTER_TO (type), base, size),\n+\t\t\t build (PLUS_EXPR, build_pointer_type (type), base, size),\n \t\t\t 0, 0);\n       if (base2)\n \texpand_assignment (base2,\n-\t\t\t   build (PLUS_EXPR, TYPE_POINTER_TO (type), base2, size), 0, 0);\n+\t\t\t   build (PLUS_EXPR, build_pointer_type (type), base2, size), 0, 0);\n       expand_loop_continue_here ();\n       expand_exit_loop_if_false (0, build (NE_EXPR, boolean_type_node,\n \t\t\t\t\t   build (PREDECREMENT_EXPR, integer_type_node, iterator, integer_one_node), minus_one));\n@@ -3489,6 +3675,13 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    use_variable (DECL_RTL (base2));\n \t}\n       expand_end_loop ();\n+      if (TYPE_NEEDS_DESTRUCTOR (type))\n+\tend_protect (build_array_eh_cleanup (rval,\n+\t\t\t\t\t     build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t\t      maxindex,\n+\t\t\t\t\t\t\t      iterator,\n+\t\t\t\t\t\t\t      1),\n+\t\t\t\t\t     type));\n       expand_end_cond ();\n       if (obey_regdecls)\n \tuse_variable (DECL_RTL (iterator));\n@@ -3848,7 +4041,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  else\n \t    this_auto_delete = integer_zero_node;\n \n-\t  expr = build_delete (TYPE_POINTER_TO (BINFO_TYPE (base_binfo)), addr,\n+\t  expr = build_delete (build_pointer_type (BINFO_TYPE (base_binfo)), addr,\n \t\t\t       this_auto_delete, flags, 0);\n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n@@ -3862,10 +4055,10 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t    continue;\n \n \t  /* May be zero offset if other baseclasses are virtual.  */\n-\t  expr = fold (build (PLUS_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n+\t  expr = fold (build (PLUS_EXPR, build_pointer_type (BINFO_TYPE (base_binfo)),\n \t\t\t      addr, BINFO_OFFSET (base_binfo)));\n \n-\t  expr = build_delete (TYPE_POINTER_TO (BINFO_TYPE (base_binfo)), expr,\n+\t  expr = build_delete (build_pointer_type (BINFO_TYPE (base_binfo)), expr,\n \t\t\t       integer_zero_node,\n \t\t\t       flags, 0);\n \n@@ -3906,7 +4099,7 @@ build_vbase_delete (type, decl)\n \n   while (vbases)\n     {\n-      tree this_addr = convert_force (TYPE_POINTER_TO (BINFO_TYPE (vbases)),\n+      tree this_addr = convert_force (build_pointer_type (BINFO_TYPE (vbases)),\n \t\t\t\t      addr, 0);\n       result = tree_cons (NULL_TREE,\n \t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n@@ -3941,188 +4134,44 @@ build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n      tree auto_delete_vec, auto_delete;\n      int use_global_delete;\n {\n-  tree ptype, type, virtual_size;\n-\n-  /* Temporary variables used by the loop.  */\n-  tree tbase, size_exp, tbase_init;\n-\n-  /* This is the body of the loop that implements the deletion of a\n-     single element, and moves temp variables to next elements.  */\n-  tree body;\n-\n-  /* This is the LOOP_EXPR that governs the deletion of the elements.  */\n-  tree loop;\n-\n-  /* This is the thing that governs what to do after the loop has run.  */\n-  tree deallocate_expr = 0;\n-\n-  /* This is the BIND_EXPR which holds the outermost iterator of the\n-     loop.  It is convenient to set this variable up and test it before\n-     executing any other code in the loop.\n-     This is also the containing expression returned by this function.  */\n-  tree controller = NULL_TREE;\n-\n-  /* This is the BLOCK to record the symbol binding for debugging.  */\n-  tree block;\n+  tree type;\n \n   if (TREE_CODE (base) == OFFSET_REF)\n     base = resolve_offset_ref (base);\n \n-  ptype = TREE_TYPE (base);\n+  type = TREE_TYPE (base);\n \n   base = stabilize_reference (base);\n \n   /* Since we can use base many times, save_expr it. */\n   if (TREE_SIDE_EFFECTS (base))\n     base = save_expr (base);\n \n-  if (TREE_CODE (ptype) == POINTER_TYPE)\n+  if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       /* Step back one from start of vector, and read dimension.  */\n-      tree cookie_addr = build (MINUS_EXPR, TYPE_POINTER_TO (BI_header_type),\n+      tree cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n \t\t\t\tbase, BI_header_size);\n       tree cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n       maxindex = build_component_ref (cookie, nc_nelts_field_id, 0, 0);\n       do\n-\tptype = TREE_TYPE (ptype);\n-      while (TREE_CODE (ptype) == ARRAY_TYPE);\n+\ttype = TREE_TYPE (type);\n+      while (TREE_CODE (type) == ARRAY_TYPE);\n     }\n-  else if (TREE_CODE (ptype) == ARRAY_TYPE)\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* get the total number of things in the array, maxindex is a bad name */\n-      maxindex = array_type_nelts_total (ptype);\n-      while (TREE_CODE (ptype) == ARRAY_TYPE)\n-\tptype = TREE_TYPE (ptype);\n+      maxindex = array_type_nelts_total (type);\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+\ttype = TREE_TYPE (type);\n       base = build_unary_op (ADDR_EXPR, base, 1);\n     }\n   else\n     {\n       error (\"type to vector delete is neither pointer or array type\");\n       return error_mark_node;\n     }\n-  type = ptype;\n-  ptype = TYPE_POINTER_TO (type);\n-\n-  size_exp = size_in_bytes (type);\n-\n-  if (! IS_AGGR_TYPE (type) || ! TYPE_NEEDS_DESTRUCTOR (type))\n-    {\n-      loop = integer_zero_node;\n-      goto no_destructor;\n-    }\n \n-  /* The below is short by BI_header_size */\n-  virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n-\n-  tbase = build_decl (VAR_DECL, NULL_TREE, ptype);\n-  tbase_init = build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t  fold (build (PLUS_EXPR, ptype,\n-\t\t\t\t\t       base,\n-\t\t\t\t\t       virtual_size)));\n-  DECL_REGISTER (tbase) = 1;\n-  controller = build (BIND_EXPR, void_type_node, tbase, 0, 0);\n-  TREE_SIDE_EFFECTS (controller) = 1;\n-  block = build_block (tbase, 0, 0, 0, 0);\n-  add_block_current_level (block);\n-\n-  if (auto_delete != integer_zero_node\n-      && auto_delete != integer_two_node)\n-    {\n-      tree base_tbd = convert (ptype,\n-\t\t\t       build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\tconvert (ptr_type_node, base),\n-\t\t\t\t\t\tBI_header_size,\n-\t\t\t\t\t\t1));\n-      /* This is the real size */\n-      virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n-      body = build_tree_list (NULL_TREE,\n-\t\t\t      build_x_delete (ptype, base_tbd,\n-\t\t\t\t\t      2 | use_global_delete,\n-\t\t\t\t\t      virtual_size));\n-      body = build (COND_EXPR, void_type_node,\n-\t\t    build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t   auto_delete, integer_one_node),\n-\t\t    body, integer_zero_node);\n-    }\n-  else\n-    body = NULL_TREE;\n-\n-  body = tree_cons (NULL_TREE,\n-\t\t    build_delete (ptype, tbase, auto_delete,\n-\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n-\t\t    body);\n-\n-  body = tree_cons (NULL_TREE,\n-\t\t    build_modify_expr (tbase, NOP_EXPR, build (MINUS_EXPR, ptype, tbase, size_exp)),\n-\t\t    body);\n-\n-  body = tree_cons (NULL_TREE,\n-\t\t    build (EXIT_EXPR, void_type_node,\n-\t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n-\t\t    body);\n-\n-  loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n-\n-  loop = tree_cons (NULL_TREE, tbase_init,\n-\t\t    tree_cons (NULL_TREE, loop, NULL_TREE));\n-  loop = build_compound_expr (loop);\n-\n- no_destructor:\n-  /* If the delete flag is one, or anything else with the low bit set,\n-     delete the storage.  */\n-  if (auto_delete_vec == integer_zero_node\n-      || auto_delete_vec == integer_two_node)\n-    deallocate_expr = integer_zero_node;\n-  else\n-    {\n-      tree base_tbd;\n-\n-      /* The below is short by BI_header_size */\n-      virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n-\n-      if (! TYPE_VEC_NEW_USES_COOKIE (type))\n-\t/* no header */\n-\tbase_tbd = base;\n-      else\n-\t{\n-\t  base_tbd = convert (ptype,\n-\t\t\t      build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t       convert (string_type_node, base),\n-\t\t\t\t\t       BI_header_size,\n-\t\t\t\t\t       1));\n-\t  /* True size with header. */\n-\t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n-\t}\n-      deallocate_expr = build_x_delete (ptype, base_tbd,\n-\t\t\t\t\t2 | use_global_delete,\n-\t\t\t\t\tvirtual_size);\n-      if (auto_delete_vec != integer_one_node)\n-\tdeallocate_expr = build (COND_EXPR, void_type_node,\n-\t\t\t\t build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t\tauto_delete_vec, integer_one_node),\n-\t\t\t\t deallocate_expr, integer_zero_node);\n-    }\n-\n-  if (loop && deallocate_expr != integer_zero_node)\n-    {\n-      body = tree_cons (NULL_TREE, loop,\n-\t\t\ttree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n-      body = build_compound_expr (body);\n-    }\n-  else\n-    body = loop;\n-\n-  /* Outermost wrapper: If pointer is null, punt.  */\n-  body = build (COND_EXPR, void_type_node,\n-\t\tbuild (NE_EXPR, boolean_type_node, base, integer_zero_node),\n-\t\tbody, integer_zero_node);\n-  body = build1 (NOP_EXPR, void_type_node, body);\n-\n-  if (controller)\n-    {\n-      TREE_OPERAND (controller, 1) = body;\n-      return controller;\n-    }\n-  else\n-    return convert (void_type_node, body);\n+  return build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n+\t\t\t     use_global_delete);\n }"}, {"sha": "1861f9ea9778a453e31300abb669f6953a558b40", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -1559,8 +1559,8 @@ reinit_parse_for_method (yychar, decl)\n    output if something goes wrong.  This should really be cleaned up somehow,\n    without loss of clarity.  */\n void\n-reinit_parse_for_block (yychar, obstackp, is_template)\n-     int yychar;\n+reinit_parse_for_block (pyychar, obstackp, is_template)\n+     int pyychar;\n      struct obstack *obstackp;\n      int is_template;\n {\n@@ -1572,23 +1572,35 @@ reinit_parse_for_block (yychar, obstackp, is_template)\n   int look_for_semicolon = 0;\n   int look_for_lbrac = 0;\n \n-  if (yychar == '{')\n+  if (pyychar == '{')\n     obstack_1grow (obstackp, '{');\n-  else if (yychar == '=')\n+  else if (pyychar == '=')\n     look_for_semicolon = 1;\n-  else if (yychar != ':' && (yychar != RETURN || is_template))\n+  else if (pyychar == ':')\n     {\n-      yyerror (is_template\n-\t       ? \"parse error in template specification\"\n-\t       : \"parse error in method specification\");\n-      obstack_1grow (obstackp, '{');\n+      obstack_1grow (obstackp, pyychar);\n+      look_for_lbrac = 1;\n+      blev = 0;\n     }\n-  else\n+  else if (pyychar == RETURN && !is_template)\n+    {\n+      obstack_grow (obstackp, \"return\", 6);\n+      look_for_lbrac = 1;\n+      blev = 0;\n+    }\n+  else if (pyychar == TRY && !is_template)\n     {\n-      obstack_1grow (obstackp, yychar);\n+      obstack_grow (obstackp, \"try\", 3);\n       look_for_lbrac = 1;\n       blev = 0;\n     }\n+  else\n+    {\n+      yyerror (is_template\n+\t       ? \"parse error in template specification\"\n+\t       : \"parse error in method specification\");\n+      obstack_1grow (obstackp, '{');\n+    }\n \n   if (nextchar != EOF)\n     {\n@@ -1640,7 +1652,26 @@ reinit_parse_for_block (yychar, obstackp, is_template)\n \t    {\n \t      blev--;\n \t      if (blev == 0 && !look_for_semicolon)\n-\t\tgoto done;\n+\t\t{\n+\t\t  if (pyychar == TRY)\n+\t\t    {\n+\t\t      if (peekyylex () == CATCH)\n+\t\t\t{\n+\t\t\t  yylex ();\n+\t\t\t  obstack_grow (obstackp, \" catch \", 7);\n+\t\t\t  look_for_lbrac = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  yychar = '{';\n+\t\t\t  goto done;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      goto done;\n+\t\t    }\n+\t\t}\n \t    }\n \t  else if (c == '\\\\')\n \t    {\n@@ -1783,7 +1814,8 @@ cons_up_default_function (type, full_name, kind)\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n     \n-    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n+    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE,\n+\t\t    NULL_TREE, NULL_TREE);\n   }\n   \n   if (fn == void_type_node)\n@@ -2278,8 +2310,8 @@ check_newline ()\n \t\t}\n #endif\n #endif\n+\t      goto skipline;\n \t    }\n-\t  goto skipline;\n \t}\n       else if (c == 'd')\n \t{\n@@ -2817,6 +2849,9 @@ identifier_type (decl)\n void\n see_typename ()\n {\n+  looking_for_typename = 1;\n+  if (yychar < 0)\n+    if ((yychar = yylex()) < 0) yychar = 0;\n   looking_for_typename = 0;\n   if (yychar == IDENTIFIER)\n     {\n@@ -2920,8 +2955,6 @@ do_identifier (token)\n   if (TREE_CODE (id) == VAR_DECL && DECL_DEAD_FOR_LOCAL (id))\n     {\n       tree shadowed = DECL_SHADOWED_FOR_VAR (id);\n-      if (!shadowed)\n-\tshadowed = IDENTIFIER_GLOBAL_VALUE (DECL_NAME (id));\n       if (shadowed)\n \t{\n \t  if (!DECL_ERROR_REPORTED (id))\n@@ -3143,6 +3176,12 @@ real_yylex ()\n \t\t*p++ = c;\n \t\tc = getc (finput);\n \t      }\n+\n+\t    if (linemode && c == '\\n')\n+\t      {\n+\t\tput_back (c);\n+\t\tc = EOF;\n+\t      }\n \t  }\n \telse\n \t  {\n@@ -4668,7 +4707,10 @@ handle_sysv_pragma ()\n \t  handle_pragma_token (NULL_PTR, NULL_TREE);\n \t  return;\n \tdefault:\n-\t  abort ();\n+\t  handle_pragma_token (NULL_PTR, NULL_TREE);\n+\t  while (yylex () != END_OF_LINE)\n+\t    /* continue */;\n+\t  return;\n \t}\n     }\n }"}, {"sha": "a0e15275140203c1752b0408aa787705a2c57fdf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -165,29 +165,22 @@ report_type_mismatch (cp, parmtypes, name_kind)\n \t\tcp->function);\n       return;\n \n-    case -3:\n-      if (TYPE_READONLY (TREE_TYPE (TREE_VALUE (parmtypes))))\n-\tcp_error (\"call to const %s `%#D' with non-const object\", name_kind,\n-\t\t  cp->function);\n-      else\n-\tcp_error (\"call to non-const %s `%#D' with const object\", name_kind,\n-\t\t  cp->function);\n-      return;\n     case -2:\n       cp_error (\"too few arguments for %s `%#D'\", name_kind, cp->function);\n       return;\n     case -1:\n       cp_error (\"too many arguments for %s `%#D'\", name_kind, cp->function);\n       return;\n     case 0:\n-      if (TREE_CODE (TREE_TYPE (cp->function)) == METHOD_TYPE)\n-\t{\n-\t  /* Happens when we have an ambiguous base class.  */\n-\t  my_friendly_assert (get_binfo (DECL_CLASS_CONTEXT (cp->function),\n-\t\t\t     TREE_TYPE (TREE_TYPE (TREE_VALUE (parmtypes))), 1) == error_mark_node,\n-\t\t\t      241);\n-\t  return;\n-\t}\n+      if (TREE_CODE (TREE_TYPE (cp->function)) != METHOD_TYPE)\n+\tbreak;\n+    case -3:\n+      /* Happens when the implicit object parameter is rejected.  */\n+      my_friendly_assert (! TYPE_READONLY (TREE_TYPE (TREE_VALUE (parmtypes))),\n+\t\t\t  241);\n+      cp_error (\"call to non-const %s `%#D' with const object\",\n+\t\tname_kind, cp->function);\n+      return;\n     }\n \n   ttf = TYPE_ARG_TYPES (TREE_TYPE (cp->function));\n@@ -512,6 +505,12 @@ build_overload_value (type, value)\n \t  sorry (\"template instantiation with pointer to method that is too complex\");\n \t  return;\n \t}\n+      if (TREE_CODE (value) == INTEGER_CST)\n+\t{\n+\t  build_overload_int (value);\n+\t  numeric_output_need_bar = 1;\n+\t  return;\n+\t}\n       value = TREE_OPERAND (value, 0);\n       if (TREE_CODE (value) == VAR_DECL)\n \t{\n@@ -1803,7 +1802,9 @@ make_thunk (function, delta)\n     {\n       thunk = build_decl (THUNK_DECL, thunk_id, TREE_TYPE (func_decl));\n       DECL_RESULT (thunk)\n-\t= build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (vtable_entry_type));\n+\t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (vtable_entry_type)));\n+      TREE_READONLY (thunk) = TYPE_READONLY (TREE_TYPE (vtable_entry_type));\n+      TREE_THIS_VOLATILE (thunk) = TYPE_VOLATILE (TREE_TYPE (vtable_entry_type));\n       make_function_rtl (thunk);\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n@@ -2249,7 +2250,7 @@ synthesize_method (fndecl)\n   input_filename = DECL_SOURCE_FILE (fndecl);\n   interface_unknown = CLASSTYPE_INTERFACE_UNKNOWN (base);\n   interface_only = CLASSTYPE_INTERFACE_ONLY (base);\n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  start_function (NULL_TREE, fndecl, NULL_TREE, NULL_TREE, 1);\n   store_parm_decls ();\n \n   if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])"}, {"sha": "52ac015c3149a3592808214f91eaddbd18ba965f", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 207, "deletions": 172, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -131,7 +131,7 @@ empty_parms ()\n /* SCO include files test \"ASM\", so use something else. */\n %token SIZEOF ENUM /* STRUCT UNION */ IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n %token BREAK CONTINUE RETURN GOTO ASM_KEYWORD GCC_ASM_KEYWORD TYPEOF ALIGNOF\n-%token HEADOF CLASSOF SIGOF\n+%token SIGOF\n %token ATTRIBUTE EXTENSION LABEL\n \n /* the reserved words... C++ extensions */\n@@ -204,17 +204,17 @@ empty_parms ()\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n \n %type <ttype> structsp opt.component_decl_list component_decl_list\n-%type <ttype> component_decl components component_declarator\n-%type <ttype> notype_components notype_component_declarator\n+%type <ttype> component_decl component_decl_1 components notype_components\n+%type <ttype> component_declarator component_declarator0\n+%type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n-%type <ttype> notype_component_declarator0 component_decl_1\n %type <ttype> enumlist enumerator\n %type <ttype> type_id absdcl type_quals\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_type_id new_declarator direct_new_declarator\n %type <ttype> xexpr parmlist parms parm bad_parm full_parm\n %type <ttype> identifiers_or_typenames\n-%type <ttype> fcast_or_absdcl regcast_or_absdcl sub_cast_expr\n+%type <ttype> fcast_or_absdcl regcast_or_absdcl\n %type <ttype> expr_or_declarator complex_notype_declarator\n %type <ttype> notype_unqualified_id unqualified_id qualified_id\n %type <ttype> overqualified_id notype_qualified_id any_id\n@@ -227,13 +227,13 @@ empty_parms ()\n %token <ttype> PRE_PARSED_CLASS_DECL\n %type <ttype> fn.def1 /* Not really! */\n %type <ttype> fn.def2 return_id\n+%type <itype> ctor_initializer_opt\n %type <ttype> named_class_head named_class_head_sans_basetype\n %type <ttype> unnamed_class_head\n %type <ttype> class_head base_class_list\n %type <itype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n-%type <ttype> component_declarator0\n %type <ttype> operator_name\n %type <ttype> object aggr\n %type <itype> new delete\n@@ -273,7 +273,12 @@ empty_parms ()\n %{\n /* List of types and structure classes of the current declaration.  */\n static tree current_declspecs;\n-static tree prefix_attributes = NULL_TREE;\n+/* List of prefix attributes in effect.\n+   Prefix attributes are parsed by the reserved_declspecs and declmods\n+   rules.  They create a list that contains *both* declspecs and attrs.  */\n+/* ??? It is not clear yet that all cases where an attribute can now appear in\n+   a declspec list have been updated.  */\n+static tree prefix_attributes;\n \n /* When defining an aggregate, this is the most recent one being defined.  */\n static tree current_aggr;\n@@ -331,8 +336,7 @@ lang_extdef:\n \t  { if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n \t  { if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n-\t      pop_everything ();\n-\t    prefix_attributes = NULL_TREE; }\n+\t      pop_everything (); }\n \t;\n \n extdef:\n@@ -423,6 +427,10 @@ template_type_parm:\n \t\t}\n \t| aggr identifier\n \t\t{ $$ = build_tree_list ($1, $2); goto ttpa; }\n+\t| TYPENAME_KEYWORD\n+\t\t{ $$ = build_tree_list (class_type_node, NULL_TREE); }\n+\t| TYPENAME_KEYWORD identifier\n+\t\t{ $$ = build_tree_list (class_type_node, $2); }\n \t;\n \n template_parm:\n@@ -496,7 +504,7 @@ template_def:\n \t\t  momentary = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,\n \t\t\t\t  $3);\n-\t\t  cplus_decl_attributes (d, $5, prefix_attributes);\n+\t\t  cplus_decl_attributes (d, $5, /*prefix_attributes*/NULL_TREE);\n \t\t  cp_finish_decl (d, NULL_TREE, $4, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n@@ -507,15 +515,13 @@ template_def:\n \t  declarator exception_specification_opt maybeasm maybe_attribute\n \t  fn_tmpl_end\n \t\t{\n-\t\t  tree d;\n+\t\t  tree d, specs, attrs;\n \t\t  int momentary;\n \t\t  int def = ($7 != ';');\n-\n-\t\t  current_declspecs = $2;\n+\t\t  split_specs_attrs ($2, &specs, &attrs);\n \t\t  momentary = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>3, current_declspecs,\n-\t\t\t\t  0, $<ttype>4);\n-\t\t  cplus_decl_attributes (d, $6, prefix_attributes);\n+\t\t  d = start_decl ($<ttype>3, specs, 0, $<ttype>4);\n+\t\t  cplus_decl_attributes (d, $6, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, $5, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n@@ -528,9 +534,11 @@ template_def:\n \t\t}\n \t| template_header declmods notype_declarator fn_tmpl_end\n \t\t{\n+\t\t  tree d, specs, attrs;\n \t\t  int def = ($4 != ';');\n-\t\t  tree d = start_decl ($<ttype>3, $<ttype>2, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, prefix_attributes);\n+\t\t  split_specs_attrs ($2, &specs, &attrs);\n+\t\t  d = start_decl ($<ttype>3, specs, 0, NULL_TREE);\n+\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n@@ -555,9 +563,10 @@ datadef:\n \t\t{}\n \t/* Normal case to make fast: \"const i;\".  */\n \t| declmods notype_declarator ';'\n-\t\t{ tree d;\n-\t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, prefix_attributes);\n+\t\t{ tree d, specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n+\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t}\n \t| typed_declspecs initdecls ';'\n@@ -566,9 +575,10 @@ datadef:\n \t\t}\n \t/* Normal case: make this fast.  */\n \t| typed_declspecs declarator ';'\n-\t\t{ tree d;\n-\t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, prefix_attributes);\n+\t\t{ tree d, specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n+\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n@@ -577,7 +587,8 @@ datadef:\n \t| explicit_instantiation ';'\n \t| typed_declspecs ';'\n \t  {\n-\t    tree t = $<ttype>$;\n+\t    tree t, attrs;\n+\t    split_specs_attrs ($1, &t, &attrs);\n \t    shadow_tag (t);\n \t    if (TREE_CODE (t) == TREE_LIST\n \t\t&& TREE_PURPOSE (t) == NULL_TREE)\n@@ -599,42 +610,35 @@ datadef:\n \t| ';'\n \t;\n \n-fndef:\n-\t  fn.def1 base_init compstmt_or_error\n-\t\t{\n-\t\t  finish_function (lineno, 1, 0);\n-\t\t  /* finish_function performs these three statements:\n+ctor_initializer_opt:\n+\t  nodecls\n+\t\t{ $$ = 0; }\n+\t| base_init\n+\t\t{ $$ = 1; }\n+\t;\n \n-\t\t     expand_end_bindings (getdecls (), 1, 0);\n-\t\t     poplevel (1, 1, 0);\n+maybe_return_init:\n+\t  /* empty */\n+\t| return_init\n+\t| return_init ';'\n+\t;\n \n-\t\t     expand_end_bindings (0, 0, 0);\n-\t\t     poplevel (0, 0, 1);\n-\t\t     */\n+eat_saved_input:\n+\t  /* empty */\n+\t| END_OF_SAVED_INPUT\n+\t;\n+\n+fndef:\n+\t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n+\t\t{\n+\t\t  finish_function (lineno, (int)$3, 0);\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$);\n \t\t}\n-\t| fn.def1 return_init base_init compstmt_or_error\n+\t| fn.def1 maybe_return_init function_try_block\n \t\t{\n-\t\t  finish_function (lineno, 1, 0);\n-\t\t  /* finish_function performs these three statements:\n-\n-\t\t     expand_end_bindings (getdecls (), 1, 0);\n-\t\t     poplevel (1, 1, 0);\n-\n-\t\t     expand_end_bindings (0, 0, 0);\n-\t\t     poplevel (0, 0, 1);\n-\t\t     */\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$);\n \t\t}\n-\t| fn.def1 nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0, 0);\n-\t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n-\t| fn.def1 return_init ';' nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0, 0);\n-\t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n-\t| fn.def1 return_init nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0, 0);\n-\t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n+\t  eat_saved_input\n \t| typed_declspecs declarator error\n \t\t{}\n \t| declmods notype_declarator error\n@@ -645,49 +649,55 @@ fndef:\n \n fn.def1:\n \t  typed_declspecs declarator exception_specification_opt\n-\t\t{ if (! start_function ($$, $2, $3, 0))\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n \t| declmods notype_declarator exception_specification_opt\n-\t\t{ if (! start_function ($$, $2, $3, 0))\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  if (! start_function (specs, $2, $3, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n \t| notype_declarator exception_specification_opt\n-\t\t{ if (! start_function (NULL_TREE, $$, $2, 0))\n+\t\t{ if (! start_function (NULL_TREE, $$, $2, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n \t| PRE_PARSED_FUNCTION_DECL\n-\t\t{ start_function (NULL_TREE, TREE_VALUE ($$), NULL_TREE, 1);\n+\t\t{ start_function (NULL_TREE, TREE_VALUE ($$),\n+\t\t\t\t  NULL_TREE, NULL_TREE, 1);\n \t\t  reinit_parse_for_function (); }\n \t;\n \n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n \t  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1), $3, $5);\n-\t\t  $$ = start_method (TREE_CHAIN ($1), $$, $6);\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs), $3, $5);\n+\t\t  $$ = start_method (TREE_CHAIN (specs), $$, $6);\n \t\t rest_of_mdef:\n \t\t  if (! $$)\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n \t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n \t\t\t\t\t empty_parms (), $3);\n-\t\t  $$ = start_method (TREE_CHAIN ($1), $$, $4);\n+\t\t  $$ = start_method (TREE_CHAIN (specs), $$, $4);\n \t\t  goto rest_of_mdef;\n \t\t}\n \t| typed_declspecs declarator exception_specification_opt\n-\t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n \t| declmods notype_declarator exception_specification_opt\n-\t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n \t| notype_declarator exception_specification_opt\n \t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n \t;\n@@ -804,11 +814,13 @@ explicit_instantiation:\n \t  TEMPLATE specialization template_instantiation\n \t\t{ do_type_instantiation ($3 ? $3 : $2, NULL_TREE); }\n \t| TEMPLATE typed_declspecs declarator\n-\t\t{ do_function_instantiation ($2, $3, NULL_TREE); }\n+\t\t{ tree specs = strip_attrs ($2);\n+\t\t  do_function_instantiation (specs, $3, NULL_TREE); }\n \t| SCSPEC TEMPLATE specialization template_instantiation\n \t\t{ do_type_instantiation ($4 ? $4 : $3, $1); }\n \t| SCSPEC TEMPLATE typed_declspecs declarator\n-\t\t{ do_function_instantiation ($3, $4, $1); }\n+\t\t{ tree specs = strip_attrs ($3);\n+\t\t  do_function_instantiation (specs, $4, $1); }\n \t;\n \n template_type:\n@@ -969,7 +981,8 @@ condition:\n \t\t  current_declspecs = $1;\n \t\t  $<itype>6 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1, $3);\n-\t\t  cplus_decl_attributes ($<ttype>$, $5, prefix_attributes);\n+\t\t  cplus_decl_attributes ($<ttype>$, $5,\n+\t\t\t\t\t /*prefix_attributes*/ NULL_TREE);\n \t\t}\n \tinit\n \t\t{ \n@@ -1160,8 +1173,8 @@ regcast_or_absdcl:\n \t;\n \n cast_expr:\n-\t  sub_cast_expr\n-\t| regcast_or_absdcl sub_cast_expr  %prec UNARY\n+\t  unary_expr\n+\t| regcast_or_absdcl unary_expr  %prec UNARY\n \t\t{ $$ = reparse_absdcl_as_casts ($$, $2); }\n \t| regcast_or_absdcl '{' initlist maybecomma '}'  %prec UNARY\n \t\t{ \n@@ -1176,29 +1189,6 @@ cast_expr:\n \t\t}\n \t;\n \n-sub_cast_expr:\n-\t  unary_expr\n-\t| HEADOF '(' expr ')'\n-\t\t{ $$ = build_headof ($3); }\n-\t| CLASSOF '(' expr ')'\n-\t\t{ $$ = build_classof ($3); }\n-\t| CLASSOF '(' TYPENAME ')'\n-\t\t{ if (is_aggr_typedef ($3, 1))\n-\t\t    {\n-\t\t      tree type = IDENTIFIER_TYPE_VALUE ($3);\n-\t\t      if (! IS_SIGNATURE(type))\n-\t\t\t$$ = CLASSTYPE_RTTI (type);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  sorry (\"signature name as argument of `classof'\");\n-\t\t\t  $$ = error_mark_node;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = error_mark_node;\n-\t\t}\n-\t;\n-\n expr_no_commas:\n \t  cast_expr\n \t/* Handle general members.  */\n@@ -1736,10 +1726,6 @@ object:\t  primary '.'\n \t\t}\n \t;\n \n-setattrs: /* empty */\n-\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n-\t;\n-\n decl:\n \t/* Normal case: make this fast.  */\n \t  typespec declarator ';'\n@@ -1752,10 +1738,12 @@ decl:\n \t\t    note_got_semicolon ($1);\n \t\t}\n \t| typed_declspecs declarator ';'\n-\t\t{ tree d = $1;\n-\t\t  int yes = suspend_momentary ();\n-\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, prefix_attributes);\n+\t\t{ tree d, specs, attrs;\n+\t\t  int yes;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  yes = suspend_momentary ();\n+\t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n+\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  resume_momentary (yes);\n \t\t  note_list_got_semicolon ($1);\n@@ -1816,7 +1804,8 @@ type_id:\n \n /* Declspecs which contain at least one type specifier or typedef name.\n    (Just `const' or `volatile' is not enough.)\n-   A typedef'd name following these is taken as a name to be declared.  */\n+   A typedef'd name following these is taken as a name to be declared.\n+   In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n typed_declspecs:\n \t  typed_typespecs %prec EMPTY\n@@ -1852,15 +1841,16 @@ reserved_declspecs:\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n-\t| reserved_declspecs attributes setattrs\n-\t\t{ $$ = $1; }\n-\t| attributes setattrs\n-\t\t{ $$ = NULL_TREE; }\n+\t| reserved_declspecs attributes\n+\t\t{ $$ = decl_tree_cons ($2, NULL_TREE, $1); }\n+\t| attributes\n+\t\t{ $$ = decl_tree_cons ($1, NULL_TREE, NULL_TREE); }\n \t;\n \n /* List of just storage classes and type modifiers.\n    A declaration can start with just this, but then it cannot be used\n-   to redeclare a typedef-name.  */\n+   to redeclare a typedef-name.\n+   In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n declmods:\n \t  nonempty_type_quals %prec EMPTY\n@@ -1876,13 +1866,12 @@ declmods:\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$);\n \t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n-\t| declmods attributes setattrs\n-\t\t{ $$ = $1; }\n-\t| attributes setattrs\n-\t\t{ $$ = NULL_TREE; }\n+\t| declmods attributes\n+\t\t{ $$ = decl_tree_cons ($2, NULL_TREE, $1); }\n+\t| attributes\n+\t\t{ $$ = decl_tree_cons ($1, NULL_TREE, NULL_TREE); }\n \t;\n \n-\n /* Used instead of declspecs where storage classes are not allowed\n    (that is, for typenames and structure components).\n \n@@ -1916,11 +1905,11 @@ typespec: structsp\n \t| complete_type_name\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3);\n-\t\t  if (pedantic)\n+\t\t  if (pedantic && !in_system_header)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| TYPEOF '(' type_id ')'\n \t\t{ $$ = groktypename ($3);\n-\t\t  if (pedantic)\n+\t\t  if (pedantic && !in_system_header)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n@@ -1983,7 +1972,8 @@ maybeasm:\n \n initdcl0:\n \t  declarator exception_specification_opt maybeasm maybe_attribute '='\n-\t\t{ current_declspecs = $<ttype>0;\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  if (have_extern_spec && !used_extern_spec)\n@@ -2002,7 +1992,8 @@ initdcl0:\n \t\t  $$ = $<itype>5; }\n \t| declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n-\t\t  current_declspecs = $<ttype>0;\n+\t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  if (have_extern_spec && !used_extern_spec)\n@@ -2033,7 +2024,8 @@ initdcl:\n \n notype_initdcl0:\n \t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n-\t\t{ current_declspecs = $<ttype>0;\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n@@ -2043,7 +2035,8 @@ notype_initdcl0:\n \t\t  $$ = $<itype>5; }\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n-\t\t  current_declspecs = $<ttype>0;\n+\t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n@@ -2053,6 +2046,7 @@ notype_initdcl0:\n nomods_initdcl0:\n \t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ current_declspecs = NULL_TREE;\n+\t\t  prefix_attributes = NULL_TREE;\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n@@ -2063,6 +2057,7 @@ nomods_initdcl0:\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = NULL_TREE;\n+\t\t  prefix_attributes = NULL_TREE;\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n@@ -2333,23 +2328,22 @@ class_head: unnamed_class_head | named_class_head ;\n maybe_base_class_list:\n \t  %prec EMPTY /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| ':'  %prec EMPTY\n+\t| ':' see_typename %prec EMPTY\n \t\t{ yyungetc(':', 1); $$ = NULL_TREE; }\n-\t| ':' base_class_list  %prec EMPTY\n-\t\t{ $$ = $2; }\n+\t| ':' see_typename base_class_list  %prec EMPTY\n+\t\t{ $$ = $3; }\n \t;\n \n base_class_list:\n \t  base_class\n-\t| base_class_list ',' base_class\n-\t\t{ $$ = chainon ($$, $3); }\n+\t| base_class_list ',' see_typename base_class\n+\t\t{ $$ = chainon ($$, $4); }\n \t;\n \n base_class:\n \t  base_class.1\n \t\t{\n \t\t  tree type;\n-\t\t do_base_class1:\n \t\t  type = IDENTIFIER_TYPE_VALUE ($$);\n \t\t  if (! is_aggr_typedef ($$, 1))\n \t\t    $$ = NULL_TREE;\n@@ -2373,14 +2367,13 @@ base_class:\n \t\t  else\n \t\t    $$ = build_tree_list ((tree)access_default, $$);\n \t\t}\n-\t| base_class_access_list base_class.1\n+\t| base_class_access_list see_typename base_class.1\n \t\t{\n \t\t  tree type;\n-\t\t do_base_class2:\n-\t\t  type = IDENTIFIER_TYPE_VALUE ($2);\n+\t\t  type = IDENTIFIER_TYPE_VALUE ($3);\n \t\t  if (current_aggr == signature_type_node)\n \t\t    error (\"access and source specifiers not allowed in signature\");\n-\t\t  if (! is_aggr_typedef ($2, 1))\n+\t\t  if (! is_aggr_typedef ($3, 1))\n \t\t    $$ = NULL_TREE;\n \t\t  else if (current_aggr == signature_type_node\n \t\t\t   && (! type) && (! IS_SIGNATURE (type)))\n@@ -2392,15 +2385,15 @@ base_class:\n \t\t    {\n \t\t      sorry (\"signature inheritance, base type `%s' ignored\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t      $$ = build_tree_list ((tree)access_public, $2);\n+\t\t      $$ = build_tree_list ((tree)access_public, $3);\n \t\t    }\n \t\t  else if (type && IS_SIGNATURE (type))\n \t\t    {\n \t\t      error (\"signature name not allowed as base class\");\n \t\t      $$ = NULL_TREE;\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_tree_list ((tree) $$, $2);\n+\t\t    $$ = build_tree_list ((tree) $$, $3);\n \t\t}\n \t;\n \n@@ -2453,12 +2446,12 @@ base_class.1:\n \t;\n \n base_class_access_list:\n-\t  VISSPEC\n-\t| SCSPEC\n+\t  VISSPEC see_typename\n+\t| SCSPEC see_typename\n \t\t{ if ($<ttype>$ != ridpointers[(int)RID_VIRTUAL])\n \t\t    sorry (\"non-virtual access\");\n \t\t  $$ = access_default_virtual; }\n-\t| base_class_access_list VISSPEC\n+\t| base_class_access_list VISSPEC see_typename\n \t\t{ int err = 0;\n \t\t  if ($2 == access_protected)\n \t\t    {\n@@ -2484,7 +2477,7 @@ base_class_access_list:\n \t\t\t$$ = access_private_virtual;\n \t\t    }\n \t\t}\n-\t| base_class_access_list SCSPEC\n+\t| base_class_access_list SCSPEC see_typename\n \t\t{ if ($2 != ridpointers[(int)RID_VIRTUAL])\n \t\t    sorry (\"non-virtual access\");\n \t\t  if ($$ == access_public)\n@@ -2610,13 +2603,18 @@ component_decl_list:\n \n component_decl:\n \t  component_decl_1 ';'\n+\t\t{ }\n \t| component_decl_1 '}'\n \t\t{ error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0); }\n \t/* C++: handle constructors, destructors and inline functions */\n \t/* note that INLINE is like a TYPESPEC */\n \t| fn.def2 ':' /* base_init compstmt */\n \t\t{ $$ = finish_method ($$); }\n+\t| fn.def2 TRY /* base_init compstmt */\n+\t\t{ $$ = finish_method ($$); }\n+\t| fn.def2 RETURN /* base_init compstmt */\n+\t\t{ $$ = finish_method ($$); }\n \t| fn.def2 '{' /* nodecls compstmt */\n \t\t{ $$ = finish_method ($$); }\n \t| ';'\n@@ -2628,16 +2626,12 @@ component_decl_1:\n \t   speed; we need to call grok_x_components for enums, so the\n \t   speedup would be insignificant.  */\n \t  typed_declspecs components\n-\t\t{\n-\t\t  $$ = grok_x_components ($$, $2);\n-\t\t}\n+\t\t{ $$ = grok_x_components ($1, $2); }\n \t| declmods notype_components\n-\t\t{ \n-\t\t  $$ = grok_x_components ($$, $2);\n-\t\t}\n+\t\t{ $$ = grok_x_components ($1, $2); }\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, NULL_TREE)); }\n \t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n \t| error\n@@ -2652,20 +2646,25 @@ component_decl_1:\n \t   member? In other words, is \"bar\" an after_type_declarator or a\n \t   parmlist? */\n \t| typed_declspecs '(' parmlist ')' type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n \t\t\t\t\t $3, $5);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), $6, $9, $7);\n-\t\t  cplus_decl_attributes ($$, $8, prefix_attributes); }\n+\t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $6, $9, $7,\n+\t\t\t\t  build_tree_list ($8, attrs)); }\n \t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n \t\t\t\t\t empty_parms (), $3);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), $4, $7, $5);\n-\t\t  cplus_decl_attributes ($$, $6, prefix_attributes); }\n+\t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $4, $7, $5,\n+\t\t\t\t  build_tree_list ($6, attrs)); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n \t;\n \n /* The case of exactly one component is handled directly by component_decl. */\n+/* ??? Huh? ^^^ */\n components:\n \t  /* empty: possibly anonymous */\n \t\t{ $$ = NULL_TREE; }\n@@ -2708,43 +2707,53 @@ component_declarator:\n \n after_type_component_declarator0:\n \t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n-\t\t{ current_declspecs = $<ttype>0;\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n \t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n \t;\n \n notype_component_declarator0:\n \t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n-\t\t{ current_declspecs = $<ttype>0;\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n \t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ current_declspecs = $<ttype>0;\n+\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n+\t\t\t\t     &prefix_attributes);\n+\t\t  $<ttype>0 = current_declspecs;\n \t\t  $$ = grokbitfield (NULL_TREE, current_declspecs, $2);\n \t\t  cplus_decl_attributes ($$, $3, prefix_attributes); }\n \t;\n \n after_type_component_declarator:\n \t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n \t;\n \n notype_component_declarator:\n \t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n+\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n@@ -2926,8 +2935,12 @@ complex_direct_notype_declarator:\n \t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n \t| notype_qualified_id\n-\t\t{ push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n-\t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n+\t\t{ if (TREE_TYPE (OP0 ($$)) != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n \t;\n \n qualified_id:\n@@ -3193,8 +3206,7 @@ stmt:\n \n simple_stmt:\n \t  decl\n-\t\t{ finish_stmt ();\n-\t\t  prefix_attributes = NULL_TREE; }\n+\t\t{ finish_stmt (); }\n \t| expr ';'\n \t\t{\n \t\t  tree expr = $1;\n@@ -3435,6 +3447,23 @@ simple_stmt:\n \t| try_block\n \t;\n \n+function_try_block:\n+\t  TRY\n+\t\t{\n+\t\t  if (! current_function_parms_stored)\n+\t\t    store_parm_decls ();\n+\t\t  expand_start_early_try_stmts ();\n+\t\t}\n+\t  ctor_initializer_opt compstmt_or_error\n+\t\t{ expand_end_try_stmts ();\n+\t\t  expand_start_all_catch (); }\n+\t  handler_seq\n+\t\t{\n+\t\t  expand_end_all_catch ();\n+\t\t  finish_function (lineno, (int)$3, 0);\n+\t\t}\n+\t;\n+\n try_block:\n \t  TRY\n \t\t{ expand_start_try_stmts (); }\n@@ -3655,10 +3684,12 @@ parms_comma:\n named_parm:\n /*\n \t  typed_declspecs dont_see_typename '*' IDENTIFIER\n-\t\t{ $$ = build_tree_list ($$, build_parse_node (INDIRECT_REF, $4));\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, build_parse_node (INDIRECT_REF, $4));\n \t\t  see_typename (); }\n \t| typed_declspecs dont_see_typename '&' IDENTIFIER\n-\t\t{ $$ = build_tree_list ($$, build_parse_node (ADDR_EXPR, $4));\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, build_parse_node (ADDR_EXPR, $4));\n \t\t  see_typename (); }\n \t| TYPENAME IDENTIFIER\n \t\t{ $$ = build_tree_list (get_decl_list ($$), $2);  }\n@@ -3668,17 +3699,21 @@ named_parm:\n \t/* Here we expand typed_declspecs inline to avoid mis-parsing of\n \t   TYPESPEC IDENTIFIER.  */\n \t  typed_declspecs1 declarator\n-\t\t{ $$ = build_tree_list ($$, $2); }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, $2); }\n \t| typed_typespecs declarator\n \t\t{ $$ = build_tree_list ($$, $2); }\n \t| typespec declarator\n \t\t{ $$ = build_tree_list (get_decl_list ($$), $2); }\n \t| typed_declspecs1 absdcl\n-\t\t{ $$ = build_tree_list ($$, $2); }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, $2); }\n \t| typed_declspecs1 %prec EMPTY\n-\t\t{ $$ = build_tree_list ($$, NULL_TREE); }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, NULL_TREE); }\n \t| declmods notype_declarator\n-\t\t{ $$ = build_tree_list ($$, $2); }\n+\t\t{ tree specs = strip_attrs ($1);\n+\t\t  $$ = build_tree_list (specs, $2); }\n \t;\n \n full_parm:"}, {"sha": "3ce0224890212c44ff64582baf548c12c917d6c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -43,7 +43,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"defaults.h\"\n \n extern struct obstack permanent_obstack;\n-extern tree grokdeclarator ();\n \n extern int lineno;\n extern char *input_filename;\n@@ -102,7 +101,7 @@ process_template_parm (list, next)\n       my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n       /* is a const-param */\n       parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n-\t\t\t     PARM, 0, NULL_TREE);\n+\t\t\t     PARM, 0, NULL_TREE, NULL_TREE);\n       /* A template parameter is not modifiable.  */\n       TREE_READONLY (parm) = 1;\n       if (IS_AGGR_TYPE (TREE_TYPE (parm)))\n@@ -239,7 +238,7 @@ end_template_decl (d1, d2, is_class, defn)\n \t  my_friendly_assert (code == BIT_NOT_EXPR\n \t\t  || code == OP_IDENTIFIER\n \t\t  || code == SCOPE_REF, 264);\n-\t  d2 = grokdeclarator (d2, NULL_TREE, MEMFUNCDEF, 0, NULL_TREE);\n+\t  d2 = grokdeclarator (d2, NULL_TREE, MEMFUNCDEF, 0, NULL_TREE, NULL_TREE);\n \t  decl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (d2),\n \t\t\t\t  TREE_TYPE (d2));\n \t  DECL_TEMPLATE_RESULT (decl) = d2;\n@@ -407,12 +406,6 @@ coerce_template_parms (parms, arglist, in_decl)\n \t}\n       if (is_type)\n \tval = groktypename (arg);\n-      else if (TREE_CODE (arg) == STRING_CST)\n-\t{\n-\t  cp_error (\"string literal %E is not a valid template argument\", arg);\n-\t  error (\"because it is the address of an object with static linkage\");\n-\t  val = error_mark_node;\n-\t}\n       else\n \t{\n \t  tree t = tsubst (TREE_TYPE (parm), &TREE_VEC_ELT (vec, 0),\n@@ -431,14 +424,41 @@ coerce_template_parms (parms, arglist, in_decl)\n \t\t\targ);\n \t      val = error_mark_node;\n \t    }\n-\t  else if (TREE_CODE (val) == ADDR_EXPR)\n+\t  else if (POINTER_TYPE_P (TREE_TYPE (val))\n+\t\t   && ! integer_zerop (val)\n+\t\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (val))) != OFFSET_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (val))) != METHOD_TYPE)\n \t    {\n-\t      tree a = TREE_OPERAND (val, 0);\n-\t      if ((TREE_CODE (a) == VAR_DECL\n-\t\t   || TREE_CODE (a) == FUNCTION_DECL)\n-\t\t  && ! DECL_PUBLIC (a))\n+\t      t = val;\n+\t      STRIP_NOPS (t);\n+\t      if (TREE_CODE (t) == ADDR_EXPR)\n+\t\t{\n+\t\t  tree a = TREE_OPERAND (t, 0);\n+\t\t  STRIP_NOPS (a);\n+\t\t  if (TREE_CODE (a) == STRING_CST)\n+\t\t    {\n+\t\t      cp_error (\"string literal %E is not a valid template argument\", a);\n+\t\t      error (\"because it is the address of an object with static linkage\");\n+\t\t      val = error_mark_node;\n+\t\t    }\n+\t\t  else if (TREE_CODE (a) != VAR_DECL\n+\t\t\t   && TREE_CODE (a) != FUNCTION_DECL)\n+\t\t    goto bad;\n+\t\t  else if (! DECL_PUBLIC (a))\n+\t\t    {\n+\t\t      cp_error (\"address of non-extern `%E' cannot be used as template argument\", a);\n+\t\t      val = error_mark_node;\n+\t\t    }\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", a);\n+\t\tbad:\n+\t\t  cp_error (\"`%E' is not a valid template argument\", t);\n+\t\t  error (\"it must be %s%s with external linkage\",\n+\t\t\t TREE_CODE (TREE_TYPE (val)) == POINTER_TYPE\n+\t\t\t ? \"a pointer to \" : \"\",\n+\t\t\t TREE_CODE (TREE_TYPE (TREE_TYPE (val))) == FUNCTION_TYPE\n+\t\t\t ? \"a function\" : \"an object\");\n \t\t  val = error_mark_node;\n \t\t}\n \t    }\n@@ -1714,19 +1734,17 @@ instantiate_template (tmpl, targ_ptr)\n   if (TREE_CODE (TREE_TYPE (DECL_RESULT (tmpl))) == METHOD_TYPE\n       && DECL_STATIC_FUNCTION_P (fndecl))\n     {\n-      tree olddecl = DECL_RESULT (tmpl);\n       revert_static_member_fn (&DECL_RESULT (tmpl), NULL, NULL);\n       /* Chop off the this pointer that grokclassfn so kindly added\n \t for us (it didn't know yet if the fn was static or not).  */\n-      DECL_ARGUMENTS (olddecl) = TREE_CHAIN (DECL_ARGUMENTS (olddecl));\n       DECL_ARGUMENTS (fndecl) = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n     }\n      \n   t = DECL_TEMPLATE_INFO (tmpl);\n \n   /* If we have a preexisting version of this function, don't expand\n      the template version, use the other instead.  */\n-  if (TREE_STATIC (fndecl))\n+  if (TREE_STATIC (fndecl) || DECL_TEMPLATE_SPECIALIZATION (fndecl))\n     {\n       SET_DECL_TEMPLATE_SPECIALIZATION (fndecl);\n       p = (struct pending_inline *)0;\n@@ -1888,12 +1906,13 @@ overload_template_name (id, classlevel)\n #endif\n }\n \n+extern struct pending_input *to_be_restored;\n+\n /* NAME is the IDENTIFIER value of a PRE_PARSED_CLASS_DECL. */\n void\n end_template_instantiation (name)\n      tree name;\n {\n-  extern struct pending_input *to_be_restored;\n   tree t, decl;\n \n   processing_template_defn--;\n@@ -2502,7 +2521,8 @@ void\n do_function_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n {\n-  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, 0);\n+  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0,\n+\t\t\t      NULL_TREE, NULL_TREE);\n   tree name;\n   tree fn;\n   tree result = NULL_TREE;"}, {"sha": "0ac50a1369ddc41624405f981d307c4edc4ae8ca", "filename": "gcc/cp/search.c", "status": "modified", "additions": 177, "deletions": 240, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -428,6 +428,18 @@ get_vbase (parent, binfo, depth)\n   return rval;\n }\n \n+/* Convert EXPR to a virtual base class of type TYPE.  We know that\n+   EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that\n+   the type of what expr points to has a virtual base of type TYPE.  */\n+tree\n+convert_pointer_to_vbase (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  tree vb = get_vbase (type, TYPE_BINFO (TREE_TYPE (TREE_TYPE (expr))), NULL_PTR);\n+  return convert_pointer_to_real (vb, expr);\n+}\n+\n /* This is the newer recursive depth first search routine. */\n #if 0\t\t\t\t/* unused */\n /* Return non-zero if PARENT is directly derived from TYPE.  By directly\n@@ -2117,16 +2129,17 @@ get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n-      /* Get around first entry reserved for RTTI.  */\n-      tree tmp = TREE_CHAIN (BINFO_VIRTUALS (binfo));\n+      tree virtuals = BINFO_VIRTUALS (binfo);\n+\n+      skip_rtti_stuff (&virtuals);\n \n-      while (tmp)\n+      while (virtuals)\n \t{\n-\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (tmp));\n+\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));\n \t  tree base_fndecl = TREE_OPERAND (base_pfn, 0);\n \t  if (DECL_ABSTRACT_VIRTUAL_P (base_fndecl))\n \t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, abstract_virtuals);\n-\t  tmp = TREE_CHAIN (tmp);\n+\t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n   return abstract_virtuals;\n@@ -2139,7 +2152,7 @@ tree\n get_abstract_virtuals (type)\n      tree type;\n {\n-  tree vbases, tmp;\n+  tree vbases;\n   tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n \n   /* First get all from non-virtual bases. */\n@@ -2148,17 +2161,17 @@ get_abstract_virtuals (type)\n \t\t\t\t\t       \n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases; vbases = TREE_CHAIN (vbases))\n     {\n-      if (! BINFO_VIRTUALS (vbases))\n-\tcontinue;\n+      tree virtuals = BINFO_VIRTUALS (vbases);\n \n-      tmp = TREE_CHAIN (BINFO_VIRTUALS (vbases));\n-      while (tmp)\n+      skip_rtti_stuff (&virtuals);\n+\n+      while (virtuals)\n \t{\n-\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (tmp));\n+\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));\n \t  tree base_fndecl = TREE_OPERAND (base_pfn, 0);\n \t  if (DECL_ABSTRACT_VIRTUAL_P (base_fndecl))\n \t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, abstract_virtuals);\n-\t  tmp = TREE_CHAIN (tmp);\n+\t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n   return nreverse (abstract_virtuals);\n@@ -2293,7 +2306,7 @@ convert_pointer_to_single_level (to_type, expr)\n   last = get_binfo (to_type, TREE_TYPE (TREE_TYPE (expr)), 0);\n   BINFO_INHERITANCE_CHAIN (last) = binfo_of_derived;\n   BINFO_INHERITANCE_CHAIN (binfo_of_derived) = NULL_TREE;\n-  return build_vbase_path (PLUS_EXPR, TYPE_POINTER_TO (to_type), expr, last, 1);\n+  return build_vbase_path (PLUS_EXPR, build_pointer_type (to_type), expr, last, 1);\n }\n \n /* The main function which implements depth first search.\n@@ -2517,7 +2530,7 @@ dfs_find_vbases (binfo)\n \t  tree binfo = binfo_member (vbase, vbase_types);\n \n \t  CLASSTYPE_SEARCH_SLOT (vbase)\n-\t    = (char *) build (PLUS_EXPR, TYPE_POINTER_TO (vbase),\n+\t    = (char *) build (PLUS_EXPR, build_pointer_type (vbase),\n \t\t\t      vbase_decl_ptr, BINFO_OFFSET (binfo));\n \t}\n     }\n@@ -2549,7 +2562,7 @@ dfs_init_vbase_pointers (binfo)\n \n   this_vbase_ptr = vbase_decl_ptr_intermediate;\n \n-  if (TYPE_POINTER_TO (type) != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n+  if (build_pointer_type (type) != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n     my_friendly_abort (125);\n \n   while (fields && DECL_NAME (fields)\n@@ -2620,6 +2633,18 @@ virtual_context (fndecl, t, vbase)\n   tree path;\n   if (get_base_distance (DECL_CLASS_CONTEXT (fndecl), t, 0, &path) < 0)\n     {\n+      /* DECL_CLASS_CONTEXT can be ambiguous in t.  */\n+      if (get_base_distance (DECL_CLASS_CONTEXT (fndecl), vbase, 0, &path) >= 0)\n+\t{\n+\t  while (path)\n+\t    {\n+\t      /* Not sure if checking path == vbase is necessary here, but just in\n+\t\t case it is.  */\n+\t      if (TREE_VIA_VIRTUAL (path) || path == vbase)\n+\t\treturn binfo_member (BINFO_TYPE (path), CLASSTYPE_VBASECLASSES (t));\n+\t      path = BINFO_INHERITANCE_CHAIN (path);\n+\t    }\n+\t}\n       /* This shouldn't happen, I don't want errors! */\n       warning (\"recoverable compiler error, fixups for virtual function\");\n       return vbase;\n@@ -2666,10 +2691,8 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n       *vbase_offsets = delta;\n     }\n \n-  /* Skip RTTI fake object. */\n-  n = 1;\n-  if (virtuals)\n-    virtuals = TREE_CHAIN (virtuals);\n+  n = skip_rtti_stuff (&virtuals);\n+\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n@@ -2831,10 +2854,9 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t  else\n \t    {\n #if 1\n-\t      tree vb = get_vbase (TREE_TYPE (vbases), TYPE_BINFO (TREE_TYPE (vbase_decl)),\n-\t\t\t\t   NULL_PTR);\n-\t      addr = convert_pointer_to_real (vb, vbase_decl_ptr);\n+\t      addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vbase_decl_ptr);\n #else\n+\t      /* This should should never work better than the above.  (mrs) */\n \t      tree vbinfo = get_binfo (TREE_TYPE (vbases),\n \t\t\t\t       TREE_TYPE (vbase_decl),\n \t\t\t\t       0);\n@@ -3069,13 +3091,107 @@ note_debug_info_needed (type)\n \f\n /* Subroutines of push_class_decls ().  */\n \n+/* Add in a decl to the envelope.  */\n+static void\n+envelope_add_decl (type, decl, values)\n+     tree type, decl, *values;\n+{\n+  tree context, *tmp;\n+  tree name = DECL_NAME (decl);\n+  int dont_add = 0;\n+\n+  /* virtual base names are always unique. */\n+  if (VBASE_NAME_P (name))\n+    *values = NULL_TREE;\n+\n+  /* Possible ambiguity.  If its defining type(s)\n+     is (are all) derived from us, no problem.  */\n+  else if (*values && TREE_CODE (*values) != TREE_LIST)\n+    {\n+      tree value = *values;\n+      /* Only complain if we shadow something we can access.  */\n+      if (warn_shadow && TREE_CODE (decl) == FUNCTION_DECL\n+\t  && ((DECL_LANG_SPECIFIC (*values)\n+\t       && DECL_CLASS_CONTEXT (value) == current_class_type)\n+\t      || ! TREE_PRIVATE (value)))\n+\t/* Should figure out access control more accurately.  */\n+\t{\n+\t  cp_warning_at (\"member `%#D' is shadowed\", value);\n+\t  cp_warning_at (\"by member function `%#D'\", decl);\n+\t  warning (\"in this context\");\n+\t}\n+\n+      context = (TREE_CODE (value) == FUNCTION_DECL\n+\t\t && DECL_VIRTUAL_P (value))\n+\t? DECL_CLASS_CONTEXT (value)\n+\t  : DECL_CONTEXT (value);\n+\n+      if (context == type)\n+\t{\n+\t  if (TREE_CODE (value) == TYPE_DECL\n+\t      && DECL_ARTIFICIAL (value))\n+\t    *values = NULL_TREE;\n+\t  else\n+\t    dont_add = 1;\n+\t}\n+      else if (context && TYPE_DERIVES_FROM (context, type))\n+\t{\n+\t  /* Don't add in *values to list */\n+\t  *values = NULL_TREE;\n+\t}\n+      else\n+\t*values = build_tree_list (NULL_TREE, value);\n+    }\n+  else\n+    for (tmp = values; *tmp;)\n+      {\n+\ttree value = TREE_VALUE (*tmp);\n+\tmy_friendly_assert (TREE_CODE (value) != TREE_LIST, 999);\n+\tcontext = (TREE_CODE (value) == FUNCTION_DECL\n+\t\t   && DECL_VIRTUAL_P (value))\n+\t  ? DECL_CLASS_CONTEXT (value)\n+\t    : DECL_CONTEXT (value);\n+\n+\tif (context && TYPE_DERIVES_FROM (context, type))\n+\t  {\n+\t    /* remove *tmp from list */\n+\t    *tmp = TREE_CHAIN (*tmp);\n+\t  }\n+\telse\n+\t  tmp = &TREE_CHAIN (*tmp);\n+      }\n+\n+  if (! dont_add)\n+    {\n+      /* Put the new contents in our envelope.  */\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  *values = tree_cons (name, decl, *values);\n+\t  TREE_NONLOCAL_FLAG (*values) = 1;\n+\t  TREE_TYPE (*values) = unknown_type_node;\n+\t}\n+      else\n+\t{\n+\t  if (*values)\n+\t    {\n+\t      *values = tree_cons (NULL_TREE, decl, *values);\n+\t      /* Mark this as a potentially ambiguous member.  */\n+\t      /* Leaving TREE_TYPE blank is intentional.\n+\t\t We cannot use `error_mark_node' (lookup_name)\n+\t\t or `unknown_type_node' (all member functions use this).  */\n+\t      TREE_NONLOCAL_FLAG (*values) = 1;\n+\t    }\n+\t  else\n+\t    *values = decl;\n+\t}\n+    }\n+}\n+\n /* Add the instance variables which this class contributed to the\n-   current class binding contour.  When a redefinition occurs,\n-   if the redefinition is strictly within a single inheritance path,\n-   we just overwrite (in the case of a data field) or\n-   cons (in the case of a member function) the old declaration with\n-   the new.  If the fields are not within a single inheritance path,\n-   we must cons them in either case.\n+   current class binding contour.  When a redefinition occurs, if the\n+   redefinition is strictly within a single inheritance path, we just\n+   overwrite the old declaration with the new.  If the fields are not\n+   within a single inheritance path, we must cons them.\n \n    In order to know what decls are new (stemming from the current\n    invocation of push_class_decls) we enclose them in an \"envelope\",\n@@ -3114,123 +3230,25 @@ dfs_pushdecls (binfo)\n \t  continue;\n \t}\n \n-#if 0\n-      if (TREE_CODE (fields) != TYPE_DECL)\n-\t{\n-\t  DECL_PUBLIC (fields) = 0;\n-\t  DECL_PROTECTED (fields) = 0;\n-\t  DECL_PRIVATE (fields) = 0;\n-\t}\n-#endif\n-\n       if (DECL_NAME (fields))\n \t{\n-\t  tree class_value = IDENTIFIER_CLASS_VALUE (DECL_NAME (fields));\n-\n-\t  /* If the class value is an envelope of the kind described in\n-\t     the comment above, we try to rule out possible ambiguities.\n-\t     If we can't do that, keep a TREE_LIST with possibly ambiguous\n-\t     decls in there.  */\n-\t  if (class_value && TREE_CODE (class_value) == TREE_LIST\n-\t      && TREE_PURPOSE (class_value) != NULL_TREE\n-\t      && (TREE_CODE (TREE_PURPOSE (class_value))\n-\t\t  != IDENTIFIER_NODE))\n-\t    {\n-\t      tree value = TREE_PURPOSE (class_value);\n-\t      tree context;\n-\n-\t      /* Possible ambiguity.  If its defining type(s)\n-\t\t is (are all) derived from us, no problem.  */\n-\t      if (TREE_CODE (value) != TREE_LIST)\n-\t\t{\n-\t\t  context = (TREE_CODE (value) == FUNCTION_DECL\n-\t\t\t     && DECL_VIRTUAL_P (value))\n-\t\t    ? DECL_CLASS_CONTEXT (value)\n-\t\t      : DECL_CONTEXT (value);\n-\n-\t\t  if (context == type)\n-\t\t    {\n-\t\t      if (TREE_CODE (value) == TYPE_DECL\n-\t\t\t  && DECL_ARTIFICIAL (value))\n-\t\t\tvalue = fields;\n-\t\t      /* else the old value wins */\n-\t\t    }\n-\t\t  else if (context && TYPE_DERIVES_FROM (context, type))\n-\t\t    value = fields;\n-\t\t  else\n-\t\t    value = tree_cons (NULL_TREE, fields,\n-\t\t\t\t       build_tree_list (NULL_TREE, value));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* All children may derive from us, in which case\n-\t\t     there is no problem.  Otherwise, we have to\n-\t\t     keep lists around of what the ambiguities might be.  */\n-\t\t  tree values;\n-\t\t  int problem = 0;\n-\n-\t\t  for (values = value; values; values = TREE_CHAIN (values))\n-\t\t    {\n-\t\t      tree sub_values = TREE_VALUE (values);\n-\n-\t\t      if (TREE_CODE (sub_values) == TREE_LIST)\n-\t\t\t{\n-\t\t\t  for (; sub_values; sub_values = TREE_CHAIN (sub_values))\n-\t\t\t    {\n-\t\t\t      register tree list_mbr = TREE_VALUE (sub_values);\n-\n-\t\t\t      context = (TREE_CODE (list_mbr) == FUNCTION_DECL\n-\t\t\t\t\t && DECL_VIRTUAL_P (list_mbr))\n-\t\t\t\t? DECL_CLASS_CONTEXT (list_mbr)\n-\t\t\t\t  : DECL_CONTEXT (list_mbr);\n-\n-\t\t\t      if (! TYPE_DERIVES_FROM (context, type))\n-\t\t\t\t{\n-\t\t\t\t  value = tree_cons (NULL_TREE, TREE_VALUE (values), value);\n-\t\t\t\t  problem = 1;\n-\t\t\t\t  break;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  context = (TREE_CODE (sub_values) == FUNCTION_DECL\n-\t\t\t\t     && DECL_VIRTUAL_P (sub_values))\n-\t\t\t    ? DECL_CLASS_CONTEXT (sub_values)\n-\t\t\t      : DECL_CONTEXT (sub_values);\n-\n-\t\t\t  if (context && ! TYPE_DERIVES_FROM (context, type))\n-\t\t\t    {\n-\t\t\t      value = tree_cons (NULL_TREE, values, value);\n-\t\t\t      problem = 1;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  if (! problem) value = fields;\n-\t\t}\n-\n-\t      /* Mark this as a potentially ambiguous member.  */\n-\t      if (TREE_CODE (value) == TREE_LIST)\n-\t\t{\n-\t\t  /* Leaving TREE_TYPE blank is intentional.\n-\t\t     We cannot use `error_mark_node' (lookup_name)\n-\t\t     or `unknown_type_node' (all member functions use this).  */\n-\t\t  TREE_NONLOCAL_FLAG (value) = 1;\n-\t\t}\n-\n-\t      /* Put the new contents in our envelope.  */\n-\t      TREE_PURPOSE (class_value) = value;\n-\t    }\n-\t  else\n+\t  tree name = DECL_NAME (fields);\n+\t  tree class_value = IDENTIFIER_CLASS_VALUE (name);\n+\n+\t  /* If the class value is not an envelope of the kind described in\n+\t     the comment above, we create a new envelope.  */\n+\t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n+\t      || TREE_PURPOSE (class_value) == NULL_TREE\n+\t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n \t    {\n \t      /* See comment above for a description of envelopes.  */\n-\t      tree envelope = tree_cons (fields, class_value,\n-\t\t\t\t\t closed_envelopes);\n-\n-\t      closed_envelopes = envelope;\n-\t      IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) = envelope;\n+\t      closed_envelopes = tree_cons (NULL_TREE, class_value,\n+\t\t\t\t\t    closed_envelopes);\n+\t      IDENTIFIER_CLASS_VALUE (name) = closed_envelopes;\n+\t      class_value = IDENTIFIER_CLASS_VALUE (name);\n \t    }\n+\n+\t  envelope_add_decl (type, fields, &TREE_PURPOSE (class_value));\n \t}\n     }\n \n@@ -3241,78 +3259,32 @@ dfs_pushdecls (binfo)\n       methods = &TREE_VEC_ELT (method_vec, 1);\n       end = TREE_VEC_END (method_vec);\n \n-      /* This does not work for multiple inheritance yet.  */\n       while (methods != end)\n \t{\n \t  /* This will cause lookup_name to return a pointer\n-\t     to the tree_list of possible methods of this name.\n-\t     If the order is a problem, we can nreverse them.  */\n-\t  tree tmp;\n-\t  tree class_value = IDENTIFIER_CLASS_VALUE (DECL_NAME (*methods));\n-\n-\t  if (class_value && TREE_CODE (class_value) == TREE_LIST\n-\t      && TREE_PURPOSE (class_value) != NULL_TREE\n-\t      && TREE_CODE (TREE_PURPOSE (class_value)) != IDENTIFIER_NODE)\n-\t    {\n-\t      tree old = TREE_PURPOSE (class_value);\n-\n-\t      maybe_push_cache_obstack ();\n-\t      if (TREE_CODE (old) == TREE_LIST)\n-\t\ttmp = tree_cons (DECL_NAME (*methods), *methods, old);\n-\t      else\n-\t\t{\n-\t\t  /* Only complain if we shadow something we can access.  */\n-\t\t  if (old\n-\t\t      && warn_shadow\n-\t\t      && ((DECL_LANG_SPECIFIC (old)\n-\t\t\t   && DECL_CLASS_CONTEXT (old) == current_class_type)\n-\t\t\t  || ! TREE_PRIVATE (old)))\n-\t\t    /* Should figure out access control more accurately.  */\n-\t\t    {\n-\t\t      cp_warning_at (\"member `%#D' is shadowed\", old);\n-\t\t      cp_warning_at (\"by member function `%#D'\", *methods);\n-\t\t      warning (\"in this context\");\n-\t\t    }\n-\t\t  tmp = build_tree_list (DECL_NAME (*methods), *methods);\n-\t\t}\n-\t      pop_obstacks ();\n-\n-\t      TREE_TYPE (tmp) = unknown_type_node;\n-#if 0\n-\t      TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);\n-#endif\n-\t      TREE_NONLOCAL_FLAG (tmp) = 1;\n-\t      \n-\t      /* Put the new contents in our envelope.  */\n-\t      TREE_PURPOSE (class_value) = tmp;\n-\t    }\n-\t  else\n+\t     to the tree_list of possible methods of this name.  */\n+\t  tree name = DECL_NAME (*methods);\n+\t  tree class_value = IDENTIFIER_CLASS_VALUE (name);\n+\n+\t  /* If the class value is not an envelope of the kind described in\n+\t     the comment above, we create a new envelope.  */\n+\t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n+\t      || TREE_PURPOSE (class_value) == NULL_TREE\n+\t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n \t    {\n-\t      maybe_push_cache_obstack ();\n-\t      tmp = build_tree_list (DECL_NAME (*methods), *methods);\n-\t      pop_obstacks ();\n-\n-\t      TREE_TYPE (tmp) = unknown_type_node;\n-#if 0\n-\t      TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);\n-#endif\n-\t      TREE_NONLOCAL_FLAG (tmp) = 1;\n-\t      \n \t      /* See comment above for a description of envelopes.  */\n-\t      closed_envelopes = tree_cons (tmp, class_value,\n+\t      closed_envelopes = tree_cons (NULL_TREE, class_value,\n \t\t\t\t\t    closed_envelopes);\n-\t      IDENTIFIER_CLASS_VALUE (DECL_NAME (*methods)) = closed_envelopes;\n+\t      IDENTIFIER_CLASS_VALUE (name) = closed_envelopes;\n+\t      class_value = IDENTIFIER_CLASS_VALUE (name);\n \t    }\n-#if 0\n-\t  tmp = *methods;\n-\t  while (tmp != 0)\n-\t    {\n-\t      DECL_PUBLIC (tmp) = 0;\n-\t      DECL_PROTECTED (tmp) = 0;\n-\t      DECL_PRIVATE (tmp) = 0;\n-\t      tmp = DECL_CHAIN (tmp);\n-\t    }\n-#endif\n+\n+\t  /* Here we try to rule out possible ambiguities.\n+\t     If we can't do that, keep a TREE_LIST with possibly ambiguous\n+\t     decls in there.  */\n+\t  maybe_push_cache_obstack ();\n+\t  envelope_add_decl (type, *methods, &TREE_PURPOSE (class_value));\n+\t  pop_obstacks ();\n \n \t  methods++;\n \t}\n@@ -3370,41 +3342,6 @@ push_class_decls (type)\n   tree id;\n   struct obstack *ambient_obstack = current_obstack;\n \n-#if 0\n-  tree tags = CLASSTYPE_TAGS (type);\n-\n-  while (tags)\n-    {\n-      tree code_type_node;\n-      tree tag;\n-\n-      switch (TREE_CODE (TREE_VALUE (tags)))\n-\t{\n-\tcase ENUMERAL_TYPE:\n-\t  code_type_node = enum_type_node;\n-\t  break;\n-\tcase RECORD_TYPE:\n-\t  code_type_node = record_type_node;\n-\t  break;\n-\tcase CLASS_TYPE:\n-\t  code_type_node = class_type_node;\n-\t  break;\n-\tcase UNION_TYPE:\n-\t  code_type_node = union_type_node;\n-\t  break;\n-\tdefault:\n-\t  my_friendly_abort (297);\n-\t}\n-      tag = xref_tag (code_type_node, TREE_PURPOSE (tags),\n-\t\t      TYPE_BINFO_BASETYPE (TREE_VALUE (tags), 0), 0);\n-#if 0 /* not yet, should get fixed properly later */\n-      pushdecl (make_type_decl (TREE_PURPOSE (tags), TREE_VALUE (tags)));\n-#else\n-      pushdecl (build_decl (TYPE_DECL, TREE_PURPOSE (tags), TREE_VALUE (tags)));\n-#endif\n-    }\n-#endif\n-\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   id = TYPE_IDENTIFIER (type);"}, {"sha": "135dc6d77942b02b9ed03f7ad91f611220324372", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -942,12 +942,12 @@ build_signature_method_call (basetype, instance, function, parms)\n       deflt_call = build_function_call (pfn, parms);\n     }\n \n-  new_object_ptr = build (PLUS_EXPR, TYPE_POINTER_TO (basetype),\n+  new_object_ptr = build (PLUS_EXPR, build_pointer_type (basetype),\n \t\t\t  convert (ptrdiff_type_node, object_ptr),\n \t\t\t  convert (ptrdiff_type_node, delta));\n \n   parms = tree_cons (NULL_TREE,\n-\t\t     convert (TYPE_POINTER_TO (basetype), object_ptr),\n+\t\t     convert (build_pointer_type (basetype), object_ptr),\n \t\t     TREE_CHAIN (parms));\n   new_parms = tree_cons (NULL_TREE, new_object_ptr, TREE_CHAIN (parms));\n \n@@ -956,7 +956,7 @@ build_signature_method_call (basetype, instance, function, parms)\n     tree old_this = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))));\n \n     TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))) =\n-      build_type_variant (TYPE_POINTER_TO (basetype),\n+      build_type_variant (build_pointer_type (basetype),\n \t\t\t  TYPE_READONLY (old_this),\n \t\t\t  TYPE_VOLATILE (old_this));\n "}, {"sha": "4b30b955c4662b989f1bee44f68ada9531d2ba28", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -245,6 +245,13 @@ extern struct obstack *current_obstack, *saveable_obstack;\n tree got_scope;\n tree got_object;\n \n+int\n+peekyylex()\n+{\n+  scan_tokens (0);\n+  return nth_token (0)->yychar;\n+}\n+\n int\n yylex()\n {"}, {"sha": "7fb688ebd9044e67b10e62a3912a7c75d1840726", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 103, "deletions": 13, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -236,7 +236,7 @@ build_cplus_new (type, init, with_cleanup_p)\n     {\n       TREE_OPERAND (rval, 2) = error_mark_node;\n       rval = build (WITH_CLEANUP_EXPR, type, rval, 0,\n-\t\t    build_delete (TYPE_POINTER_TO (type),\n+\t\t    build_delete (build_pointer_type (type),\n \t\t\t\t  build_unary_op (ADDR_EXPR, slot, 0),\n \t\t\t\t  integer_two_node,\n \t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0));\n@@ -1318,7 +1318,7 @@ void\n debug_binfo (elem)\n      tree elem;\n {\n-  int i;\n+  unsigned HOST_WIDE_INT n;\n   tree virtuals;\n \n   fprintf (stderr, \"type \\\"%s\\\"; offset = %d\\n\",\n@@ -1332,20 +1332,17 @@ debug_binfo (elem)\n     fprintf (stderr, \"no vtable decl yet\\n\");\n   fprintf (stderr, \"virtuals:\\n\");\n   virtuals = BINFO_VIRTUALS (elem);\n-  if (virtuals != 0)\n-    {\n-      /* skip the rtti type descriptor entry */\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-  i = 1;\n+\n+  n = skip_rtti_stuff (&virtuals);\n+\n   while (virtuals)\n     {\n       tree fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n       fprintf (stderr, \"%s [%d =? %d]\\n\",\n \t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)),\n-\t       i, TREE_INT_CST_LOW (DECL_VINDEX (fndecl)));\n+\t       n, TREE_INT_CST_LOW (DECL_VINDEX (fndecl)));\n+      ++n;\n       virtuals = TREE_CHAIN (virtuals);\n-      i += 1;\n     }\n }\n \n@@ -1567,11 +1564,11 @@ id_cmp (p1, p2)\n   return (HOST_WIDE_INT)TREE_VALUE (*p1) - (HOST_WIDE_INT)TREE_VALUE (*p2);\n }\n \n-/* Build the FUNCTION_TYPE or METHOD_TYPE which may raise exceptions\n+/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */\n tree\n-build_exception_variant (ctype, type, raises)\n-     tree ctype, type;\n+build_exception_variant (type, raises)\n+     tree type;\n      tree raises;\n {\n   int i;\n@@ -1903,3 +1900,96 @@ break_out_target_exprs (t)\n {\n   return mapcar (t, bot_manip);\n }\n+\n+tree\n+unsave_expr (expr)\n+     tree expr;\n+{\n+  tree t;\n+\n+  t = build1 (UNSAVE_EXPR, TREE_TYPE (expr), expr);\n+  TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (expr);\n+  return t;\n+}\n+\n+/* Modify a tree in place so that all the evaluate only once things\n+   are cleared out.  Return the EXPR given.  */\n+tree\n+unsave_expr_now (expr)\n+     tree expr;\n+{\n+  enum tree_code code;\n+  register int i;\n+\n+  if (expr == NULL_TREE)\n+    return expr;\n+\n+  code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case SAVE_EXPR:\n+      SAVE_EXPR_RTL (expr) = NULL_RTX;\n+      break;\n+\n+    case TARGET_EXPR:\n+      sorry (\"TARGET_EXPR reused inside UNSAVE_EXPR\");\n+      break;\n+      \n+    case RTL_EXPR:\n+      warning (\"RTL_EXPR reused inside UNSAVE_EXPR\");\n+      RTL_EXPR_SEQUENCE (expr) = NULL_RTX;\n+      break;\n+\n+    case CALL_EXPR:\n+      CALL_EXPR_RTL (expr) = NULL_RTX;\n+      if (TREE_OPERAND (expr, 1)\n+\t  && TREE_CODE (TREE_OPERAND (expr, 1)) == TREE_LIST)\n+\t{\n+\t  tree exp = TREE_OPERAND (expr, 1);\n+\t  while (exp)\n+\t    {\n+\t      unsave_expr_now (TREE_VALUE (exp));\n+\t      exp = TREE_CHAIN (exp);\n+\t    }\n+\t}\n+      break;\n+      \n+    case WITH_CLEANUP_EXPR:\n+      warning (\"WITH_CLEANUP_EXPR reused inside UNSAVE_EXPR\");\n+      RTL_EXPR_RTL (expr) = NULL_RTX;\n+      break;\n+    }\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case 'c':  /* a constant */\n+    case 't':  /* a type node */\n+    case 'x':  /* something random, like an identifier or an ERROR_MARK.  */\n+    case 'd':  /* A decl node */\n+    case 'b':  /* A block node */\n+      return expr;\n+\n+    case 'e':  /* an expression */\n+    case 'r':  /* a reference */\n+    case 's':  /* an expression with side effects */\n+    case '<':  /* a comparison expression */\n+    case '2':  /* a binary arithmetic expression */\n+    case '1':  /* a unary arithmetic expression */\n+      for (i = tree_code_length[(int) code] - 1; i >= 0; i--)\n+\tunsave_expr_now (TREE_OPERAND (expr, i));\n+      return expr;\n+\n+    default:\n+      my_friendly_abort (999);\n+    }\n+}\n+\n+/* Since cleanup may have SAVE_EXPRs in it, we protect it with an\n+   UNSAVE_EXPR as the backend cannot yet handle SAVE_EXPRs in cleanups\n+   by itself.  */\n+int\n+cp_expand_decl_cleanup (decl, cleanup)\n+     tree decl, cleanup;\n+{\n+  return expand_decl_cleanup (decl, unsave_expr (cleanup));\n+}"}, {"sha": "d4bab51e84891479e64baeacc048a7bf28a63c65", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 108, "deletions": 55, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -440,20 +440,20 @@ common_type (t1, t2)\n \t  {\n \t    rval = build_function_type (valtype, p2);\n \t    if ((raises = TYPE_RAISES_EXCEPTIONS (t2)))\n-\t      rval = build_exception_variant (NULL_TREE, rval, raises);\n+\t      rval = build_exception_variant (rval, raises);\n \t    return build_type_attribute_variant (rval, attributes);\n \t  }\n \traises = TYPE_RAISES_EXCEPTIONS (t1);\n \tif (p2 == NULL_TREE || TREE_VALUE (p2) == void_type_node)\n \t  {\n \t    rval = build_function_type (valtype, p1);\n \t    if (raises)\n-\t      rval = build_exception_variant (NULL_TREE, rval, raises);\n+\t      rval = build_exception_variant (rval, raises);\n \t    return build_type_attribute_variant (rval, attributes);\n \t  }\n \n \trval = build_function_type (valtype, commonparms (p1, p2));\n-\trval = build_exception_variant (NULL_TREE, rval, raises);\n+\trval = build_exception_variant (rval, raises);\n \treturn build_type_attribute_variant (rval, attributes);\n       }\n \n@@ -498,7 +498,7 @@ common_type (t1, t2)\n \t  t2 = build_function_type (TREE_TYPE (t2), TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n \t  t3 = common_type (t1, t2);\n \t  t3 = build_cplus_method_type (basetype, TREE_TYPE (t3), TYPE_ARG_TYPES (t3));\n-\t  t1 = build_exception_variant (basetype, t3, raises);\n+\t  t1 = build_exception_variant (t3, raises);\n \t}\n       else\n         compiler_error (\"common_type called with uncommon method types\");\n@@ -672,9 +672,9 @@ comptypes (type1, type2, strict)\n       return 0;\n \n     case OFFSET_TYPE:\n-      val = (comptypes (TYPE_POINTER_TO (TYPE_OFFSET_BASETYPE (t1)),\n-\t\t\t TYPE_POINTER_TO (TYPE_OFFSET_BASETYPE (t2)), strict)\n-\t      && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict));\n+      val = (comptypes (build_pointer_type (TYPE_OFFSET_BASETYPE (t1)),\n+\t\t\tbuild_pointer_type (TYPE_OFFSET_BASETYPE (t2)), strict)\n+\t     && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict));\n       break;\n \n     case METHOD_TYPE:\n@@ -686,11 +686,9 @@ comptypes (type1, type2, strict)\n \t to something expecting a derived member (or member function),\n \t but not vice-versa!  */\n \n-      val = (comptypes (TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t2)),\n-\t\t\t TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t1)), strict)\n-\t      && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict)\n-\t      && compparms (TREE_CHAIN (TYPE_ARG_TYPES (t1)),\n-\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t2)), strict));\n+      val = (comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict)\n+\t     && compparms (TYPE_ARG_TYPES (t1),\n+\t\t\t   TYPE_ARG_TYPES (t2), strict));\n       break;\n \n     case POINTER_TYPE:\n@@ -742,7 +740,7 @@ comptypes (type1, type2, strict)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      return 1;\n+      return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2);\n \n     case UNINSTANTIATED_P_TYPE:\n       if (UPT_TEMPLATE (t1) != UPT_TEMPLATE (t2))\n@@ -813,7 +811,30 @@ comp_target_types (ttl, ttr, nptrs)\n \t    return comp_ptr_ttypes (ttl, ttr);\n \t}\n \n-      return comp_target_types (ttl, ttr, nptrs - 1);\n+      /* Const and volatile mean something different for function types,\n+\t so the usual checks are not appropriate.  */\n+      if (TREE_CODE (ttl) == FUNCTION_TYPE || TREE_CODE (ttl) == METHOD_TYPE)\n+\treturn comp_target_types (ttl, ttr, nptrs - 1);\n+\n+      /* Make sure that the cv-quals change only in the same direction as\n+\t the target type.  */\n+      {\n+\tint t;\n+\tint c = TYPE_READONLY (ttl) - TYPE_READONLY (ttr);\n+\tint v = TYPE_VOLATILE (ttl) - TYPE_VOLATILE (ttr);\n+\n+\tif ((c > 0 && v < 0) || (c < 0 && v > 0))\n+\t  return 0;\n+\n+\tif (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr))\n+\t  return (c + v < 0) ? -1 : 1;\n+\n+\tt = comp_target_types (ttl, ttr, nptrs - 1);\n+\tif ((t == 1 && c + v >= 0) || (t == -1 && c + v <= 0))\n+\t  return t;\n+\n+\treturn 0;\n+      }\n     }\n \n   if (TREE_CODE (ttr) == REFERENCE_TYPE)\n@@ -852,9 +873,9 @@ comp_target_types (ttl, ttr, nptrs)\n     {\n       if (nptrs < 0)\n \treturn 0;\n-      if (comptypes (TYPE_POINTER_TO (ttl), TYPE_POINTER_TO (ttr), 0))\n+      if (comptypes (build_pointer_type (ttl), build_pointer_type (ttr), 0))\n \treturn 1;\n-      if (comptypes (TYPE_POINTER_TO (ttr), TYPE_POINTER_TO (ttl), 0))\n+      if (comptypes (build_pointer_type (ttr), build_pointer_type (ttl), 0))\n \treturn -1;\n       return 0;\n     }\n@@ -1408,7 +1429,7 @@ decay_conversion (exp)\n \t\t\t      inner);\n \t      TREE_REFERENCE_EXPR (inner) = 1;\n \t    }\n-\t  return convert (TYPE_POINTER_TO (TREE_TYPE (type)), inner);\n+\t  return convert (build_pointer_type (TREE_TYPE (type)), inner);\n \t}\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n@@ -1845,11 +1866,15 @@ build_indirect_ref (ptr, errorstring)\n   if (ptr == current_class_decl)\n     return C_C_D;\n \n-  ptr = build_expr_type_conversion (WANT_POINTER, pointer, 1);\n-  if (ptr)\n+  if (IS_AGGR_TYPE (type))\n     {\n-      pointer = ptr;\n-      type = TREE_TYPE (pointer);\n+      ptr = build_expr_type_conversion (WANT_POINTER, pointer, 1);\n+\n+      if (ptr)\n+\t{\n+\t  pointer = ptr;\n+\t  type = TREE_TYPE (pointer);\n+\t}\n     }\n \n   if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n@@ -2144,7 +2169,7 @@ build_x_function_call (function, params, decl)\n \t      return error_mark_node;\n \t    }\n \t  /* Yow: call from a static member function.  */\n-\t  decl = build1 (NOP_EXPR, TYPE_POINTER_TO (current_class_type),\n+\t  decl = build1 (NOP_EXPR, build_pointer_type (current_class_type),\n \t\t\t error_mark_node);\n \t  decl = build_indirect_ref (decl, NULL_PTR);\n \t}\n@@ -2223,14 +2248,14 @@ build_x_function_call (function, params, decl)\n \n       /* Explicitly named method?  */\n       if (TREE_CODE (function) == FUNCTION_DECL)\n-\tctypeptr = TYPE_POINTER_TO (DECL_CLASS_CONTEXT (function));\n+\tctypeptr = build_pointer_type (DECL_CLASS_CONTEXT (function));\n       /* Expression with ptr-to-method type?  It could either be a plain\n \t usage, or it might be a case where the ptr-to-method is being\n \t passed in as an argument.  */\n       else if (TYPE_PTRMEMFUNC_P (fntype))\n \t{\n \t  tree rec = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (fntype)));\n-\t  ctypeptr = TYPE_POINTER_TO (rec);\n+\t  ctypeptr = build_pointer_type (rec);\n \t}\n       /* Unexpected node type?  */\n       else\n@@ -2273,25 +2298,27 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n-      tree fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n-      tree index = save_expr (build_component_ref (function,\n-\t\t\t\t\t\t   index_identifier,\n-\t\t\t\t\t\t   0, 0));\n-      tree e1 = build (GT_EXPR, boolean_type_node, index,\n-\t\t       convert (delta_type_node, integer_zero_node));\n-      tree delta = convert (ptrdiff_type_node,\n-\t\t\t    build_component_ref (function, delta_identifier, 0, 0));\n-      tree delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n-      tree e2;\n-      tree e3;\n-      tree aref, vtbl;\n-\n+      tree fntype, index, e1, delta, delta2, e2, e3, aref, vtbl;\n       tree instance;\n+\n       tree instance_ptr = *instance_ptrptr;\n \n       if (TREE_SIDE_EFFECTS (instance_ptr))\n \tinstance_ptr = save_expr (instance_ptr);\n \n+      if (TREE_SIDE_EFFECTS (function))\n+\tfunction = save_expr (function);\n+\n+      fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n+      index = save_expr (build_component_ref (function,\n+\t\t\t\t\t      index_identifier,\n+\t\t\t\t\t      0, 0));\n+      e1 = build (GT_EXPR, boolean_type_node, index,\n+\t\t  convert (delta_type_node, integer_zero_node));\n+      delta = convert (ptrdiff_type_node,\n+\t\t       build_component_ref (function, delta_identifier, 0, 0));\n+      delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n+\n       /* convert down to the right base, before using the instance. */\n       instance\n \t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n@@ -4409,11 +4436,11 @@ unary_complex_lvalue (code, arg)\n \t  targ = arg;\n \telse\n \t  targ = build_cplus_new (TREE_TYPE (arg), arg, 1);\n-\treturn build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (arg)), targ);\n+\treturn build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), targ);\n       }\n \n     if (TREE_CODE (arg) == SAVE_EXPR && TREE_CODE (targ) == INDIRECT_REF)\n-      return build (SAVE_EXPR, TYPE_POINTER_TO (TREE_TYPE (arg)),\n+      return build (SAVE_EXPR, build_pointer_type (TREE_TYPE (arg)),\n \t\t     TREE_OPERAND (targ, 0), current_function_decl, NULL);\n \n     /* We shouldn't wrap WITH_CLEANUP_EXPRs inside of SAVE_EXPRs, but in case\n@@ -4516,6 +4543,8 @@ mark_addressable (exp)\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_USED (x) = 1;\n \tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n+\tif (asm_out_file)\n+\t  assemble_external (x);\n \treturn 1;\n \n       default:\n@@ -4747,7 +4776,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t\tcp_pedwarn (\"`%T' and `%T' converted to `%T *' in conditional expression\",\n \t\t\t    type1, type2, result_type);\n \n-\t      result_type = TYPE_POINTER_TO (result_type);\n+\t      result_type = build_pointer_type (result_type);\n \t    }\n \t}\n       else\n@@ -5016,6 +5045,9 @@ tree build_const_cast (type, expr)\n   tree intype = TREE_TYPE (expr);\n   tree t1, t2;\n \n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n   if (TYPE_PTRMEMFUNC_P (intype))\n@@ -6353,6 +6385,23 @@ build_ptrmemfunc (type, pfn, force)\n       npfn = TREE_VALUE (CONSTRUCTOR_ELTS (npfn));\n       if (integer_zerop (nindex))\n \tpfn = integer_zero_node;\n+      else if (integer_zerop (fold (size_binop (PLUS_EXPR, nindex, integer_one_node))))\n+\t{\n+\t  tree e3;\n+\t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n+\t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+\t\t\t\t\tforce);\n+\t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n+\t  pfn = build1 (NOP_EXPR, type, npfn);\n+\t  TREE_CONSTANT (pfn) = TREE_CONSTANT (npfn);\n+\n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, nindex,\n+\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+\t  return e3;\n+\t}\n       else\n \t{\n \t  sorry (\"value casting of variable nonnull pointer to member functions not supported\");\n@@ -6623,7 +6672,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \n \t  if (ctt < 0)\n \t    cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n-\t\t\tttr, ttl);\n+\t\t\trhstype, type);\n \n \t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n \t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n@@ -7388,6 +7437,11 @@ c_expand_return (retval)\n \t{\n \t  store_expr (result, original_result_rtx, 0);\n \t  expand_cleanups_to (NULL_TREE);\n+\t  use_variable (DECL_RTL (result));\n+\t  if (ctor_label  && TREE_CODE (ctor_label) != ERROR_MARK)\n+\t    expand_goto (ctor_label);\n+\t  else\n+\t    expand_null_return ();\n \t}\n       else if (retval && retval != result)\n \t{\n@@ -7408,12 +7462,6 @@ c_expand_return (retval)\n \t}\n       else\n \texpand_return (result);\n-\n-      use_variable (DECL_RTL (result));\n-      if (ctor_label  && TREE_CODE (ctor_label) != ERROR_MARK)\n-\texpand_goto (ctor_label);\n-      else\n-\texpand_null_return ();\n     }\n   else\n     {\n@@ -7530,15 +7578,20 @@ comp_ptr_ttypes_real (to, from, constp)\n       if (TREE_CODE (to) != TREE_CODE (from))\n \treturn 0;\n \n-      if (TYPE_READONLY (from) > TYPE_READONLY (to)\n-\t  || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n-\treturn 0;\n+      /* Const and volatile mean something different for function types,\n+\t so the usual checks are not appropriate.  */\n+      if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n+\t{\n+\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n+\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\t    return 0;\n \n-      if (! constp\n-\t  && (TYPE_READONLY (to) > TYPE_READONLY (from)\n-\t      || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n-\treturn 0;\n-      constp &= TYPE_READONLY (to);\n+\t  if (! constp\n+\t      && (TYPE_READONLY (to) > TYPE_READONLY (from)\n+\t\t  || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n+\t    return 0;\n+\t  constp &= TYPE_READONLY (to);\n+\t}\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1);"}, {"sha": "653d6a54dc5dd47ed747d42608cf444d0bdc1b1e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30432d726e15452e300dee52edd348e14778589/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f30432d726e15452e300dee52edd348e14778589", "patch": "@@ -884,9 +884,15 @@ digest_init (type, init, tail)\n \n   if (code == ARRAY_TYPE || code == RECORD_TYPE || code == UNION_TYPE)\n     {\n-      if (raw_constructor)\n+      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type))\n+\t{\n+\t  cp_error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n+\t\t    type, init);\n+\t  return error_mark_node;\n+\t}\n+      else if (raw_constructor)\n \treturn process_init_constructor (type, init, (tree *)0);\n-      else if (TYPE_NEEDS_CONSTRUCTING (type))\n+      else if (TYPE_NON_AGGREGATE_CLASS (type))\n \t{\n \t  /* This can only be reached when caller is initializing\n \t     ARRAY_TYPE.  In that case, we don't want to convert"}]}