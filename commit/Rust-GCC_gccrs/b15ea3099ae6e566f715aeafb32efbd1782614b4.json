{"sha": "b15ea3099ae6e566f715aeafb32efbd1782614b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1ZWEzMDk5YWU2ZTU2NmY3MTVhZWFmYjMyZWZiZDE3ODI2MTRiNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-04-29T18:04:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-04-29T18:04:50Z"}, "message": "DR 1351 Represent the unevaluated exception specification of an implicitly declared or deleted function with a simple placeholder...\n\n\tDR 1351\n\tRepresent the unevaluated exception specification of an implicitly\n\tdeclared or deleted function with a simple placeholder, not a list\n\tof functions.\n\t* cp-tree.h (UNEVALUATED_NOEXCEPT_SPEC_P): New.\n\t* except.c (unevaluated_noexcept_spec): New.\n\t* class.c (deduce_noexcept_on_destructor): Use it.\n\t* decl.c (check_redeclaration_exception_specification): Call\n\tmaybe_instantiate_noexcept.\n\t(duplicate_decls): Call it before merge_types.\n\t(start_preparsed_function): Call maybe_instantiate_noexcept.\n\t* decl2.c (mark_used): Call maybe_instantiate_noexcept earlier.\n\t* init.c (get_nsdmi): Factor out of perform_member_init.\n\t* method.c (process_subob_fn): Call maybe_instantiate_noexcept.\n\t(walk_field_subobs): Consider NSDMI for EH spec.\n\t(get_defaulted_eh_spec): New.\n\t(implicitly_declare_fn): Use unevaluated_noexcept_spec.\n\t(defaulted_late_check): Defer EH checking in non-template classes.\n\t(after_nsdmi_defaulted_late_checks): New.\n\t* parser.c (cp_parser_class_specifier_1): Use it.\n\t(unparsed_classes): New macro.\n\t* parser.h (cp_unparsed_functions_entry_d): Add classes field.\n\t* pt.c (maybe_instantiate_noexcept): Use get_defaulted_eh_spec.\n\tRemove list-of-functions handling.\n\t* typeck2.c (merge_exception_specifiers): Remove list-of-functions\n\thandling and FN parameter.\n\t* typeck.c (merge_types): Adjust.\n\nFrom-SVN: r209907", "tree": {"sha": "2f6939ee0e72751f47ab06c75051dd73d1f3d903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f6939ee0e72751f47ab06c75051dd73d1f3d903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b15ea3099ae6e566f715aeafb32efbd1782614b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15ea3099ae6e566f715aeafb32efbd1782614b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15ea3099ae6e566f715aeafb32efbd1782614b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15ea3099ae6e566f715aeafb32efbd1782614b4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7cb0403f41978641d6e0954761fa0600bc2ad10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb0403f41978641d6e0954761fa0600bc2ad10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cb0403f41978641d6e0954761fa0600bc2ad10c"}], "stats": {"total": 378, "additions": 251, "deletions": 127}, "files": [{"sha": "b2018255b1830816b13b891c4f46b36f296be5c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1,3 +1,33 @@\n+2014-04-29  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 1351\n+\tRepresent the unevaluated exception specification of an implicitly\n+\tdeclared or deleted function with a simple placeholder, not a list\n+\tof functions.\n+\t* cp-tree.h (UNEVALUATED_NOEXCEPT_SPEC_P): New.\n+\t* except.c (unevaluated_noexcept_spec): New.\n+\t* class.c (deduce_noexcept_on_destructor): Use it.\n+\t* decl.c (check_redeclaration_exception_specification): Call\n+\tmaybe_instantiate_noexcept.\n+\t(duplicate_decls): Call it before merge_types.\n+\t(start_preparsed_function): Call maybe_instantiate_noexcept.\n+\t* decl2.c (mark_used): Call maybe_instantiate_noexcept earlier.\n+\t* init.c (get_nsdmi): Factor out of perform_member_init.\n+\t* method.c (process_subob_fn): Call maybe_instantiate_noexcept.\n+\t(walk_field_subobs): Consider NSDMI for EH spec.\n+\t(get_defaulted_eh_spec): New.\n+\t(implicitly_declare_fn): Use unevaluated_noexcept_spec.\n+\t(defaulted_late_check): Defer EH checking in non-template classes.\n+\t(after_nsdmi_defaulted_late_checks): New.\n+\t* parser.c (cp_parser_class_specifier_1): Use it.\n+\t(unparsed_classes): New macro.\n+\t* parser.h (cp_unparsed_functions_entry_d): Add classes field.\n+\t* pt.c (maybe_instantiate_noexcept): Use get_defaulted_eh_spec.\n+\tRemove list-of-functions handling.\n+\t* typeck2.c (merge_exception_specifiers): Remove list-of-functions\n+\thandling and FN parameter.\n+\t* typeck.c (merge_types): Adjust.\n+\n 2014-04-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/59120"}, {"sha": "5cac488ee95c44ef7f5703d0993420a12346ed85", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -4725,11 +4725,7 @@ deduce_noexcept_on_destructor (tree dtor)\n {\n   if (!TYPE_RAISES_EXCEPTIONS (TREE_TYPE (dtor)))\n     {\n-      tree ctx = DECL_CONTEXT (dtor);\n-      tree implicit_fn = implicitly_declare_fn (sfk_destructor, ctx,\n-\t\t\t\t\t\t/*const_p=*/false,\n-\t\t\t\t\t\tNULL, NULL);\n-      tree eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n+      tree eh_spec = unevaluated_noexcept_spec ();\n       TREE_TYPE (dtor) = build_exception_variant (TREE_TYPE (dtor), eh_spec);\n     }\n }"}, {"sha": "b4a72d6e30af20745957a4168efd4f3ceec509fa", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -212,9 +212,12 @@ DEFTREECODE (USING_STMT, \"using_stmt\", tcc_statement, 1)\n    parsing had occurred.  */\n DEFTREECODE (DEFAULT_ARG, \"default_arg\", tcc_exceptional, 0)\n \n-/* An uninstantiated noexcept-specification.  DEFERRED_NOEXCEPT_PATTERN is\n-   the pattern from the template, and DEFERRED_NOEXCEPT_ARGS are the\n-   template arguments to substitute into the pattern when needed.  */\n+/* An uninstantiated/unevaluated noexcept-specification.  For the\n+   uninstantiated case, DEFERRED_NOEXCEPT_PATTERN is the pattern from the\n+   template, and DEFERRED_NOEXCEPT_ARGS are the template arguments to\n+   substitute into the pattern when needed.  For the unevaluated case,\n+   those slots are NULL_TREE and we use get_defaulted_eh_spec to find\n+   the exception-specification.  */\n DEFTREECODE (DEFERRED_NOEXCEPT, \"deferred_noexcept\", tcc_exceptional, 0)\n \n /* A template-id, like foo<int>.  The first operand is the template."}, {"sha": "55ecc4e5b5f970f56c4b23485b843ae2fadafd1c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -579,8 +579,10 @@ struct GTY (()) tree_default_arg {\n   (((struct tree_deferred_noexcept *)DEFERRED_NOEXCEPT_CHECK (NODE))->args)\n #define DEFERRED_NOEXCEPT_SPEC_P(NODE)\t\t\t\t\\\n   ((NODE) && (TREE_PURPOSE (NODE))\t\t\t\t\\\n-  && (TREE_CODE (TREE_PURPOSE (NODE)) == DEFERRED_NOEXCEPT\t\\\n-      || is_overloaded_fn (TREE_PURPOSE (NODE))))\n+   && (TREE_CODE (TREE_PURPOSE (NODE)) == DEFERRED_NOEXCEPT))\n+#define UNEVALUATED_NOEXCEPT_SPEC_P(NODE)\t\t\t\t\\\n+  (DEFERRED_NOEXCEPT_SPEC_P (NODE)\t\t\t\t\t\\\n+   && DEFERRED_NOEXCEPT_PATTERN (TREE_PURPOSE (NODE)) == NULL_TREE)\n \n struct GTY (()) tree_deferred_noexcept {\n   struct tree_base base;\n@@ -4359,8 +4361,6 @@ extern int comparing_specializations;\n    sizeof can be nested.  */\n \n extern int cp_unevaluated_operand;\n-extern tree cp_convert_range_for (tree, tree, tree, bool);\n-extern bool parsing_nsdmi (void);\n \n /* in pt.c  */\n \n@@ -5420,6 +5420,7 @@ extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n+extern tree get_nsdmi\t\t\t\t(tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree throw_bad_array_new_length\t\t(void);\n@@ -5468,6 +5469,9 @@ extern tree make_thunk\t\t\t\t(tree, bool, tree, tree);\n extern void finish_thunk\t\t\t(tree);\n extern void use_thunk\t\t\t\t(tree, bool);\n extern bool trivial_fn_p\t\t\t(tree);\n+extern tree get_defaulted_eh_spec\t\t(tree);\n+extern tree unevaluated_noexcept_spec\t\t(void);\n+extern void after_nsdmi_defaulted_late_checks   (tree);\n extern bool maybe_explain_implicit_delete\t(tree);\n extern void explain_implicit_non_constexpr\t(tree);\n extern void deduce_inheriting_ctor\t\t(tree);\n@@ -5489,6 +5493,11 @@ extern tree implicitly_declare_fn               (special_function_kind, tree,\n /* In optimize.c */\n extern bool maybe_clone_body\t\t\t(tree);\n \n+/* In parser.c */\n+extern tree cp_convert_range_for (tree, tree, tree, bool);\n+extern bool parsing_nsdmi (void);\n+extern void inject_this_parameter (tree, cp_cv_quals);\n+\n /* in pt.c */\n extern bool check_template_shadow\t\t(tree);\n extern tree get_innermost_template_args\t\t(tree, int);\n@@ -6162,7 +6171,7 @@ extern tree build_x_arrow\t\t\t(location_t, tree,\n extern tree build_m_component_ref\t\t(tree, tree, tsubst_flags_t);\n extern tree build_functional_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, int);\n-extern tree merge_exception_specifiers\t\t(tree, tree, tree);\n+extern tree merge_exception_specifiers\t\t(tree, tree);\n \n /* in mangle.c */\n extern void init_mangle\t\t\t\t(void);"}, {"sha": "202db35d3c85504e4fa72df5941047d4023448b4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1167,15 +1167,18 @@ static void\n check_redeclaration_exception_specification (tree new_decl,\n \t\t\t\t\t     tree old_decl)\n {\n-  tree new_type;\n-  tree old_type;\n-  tree new_exceptions;\n-  tree old_exceptions;\n+  tree new_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (new_decl));\n+  tree old_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (old_decl));\n \n-  new_type = TREE_TYPE (new_decl);\n-  new_exceptions = TYPE_RAISES_EXCEPTIONS (new_type);\n-  old_type = TREE_TYPE (old_decl);\n-  old_exceptions = TYPE_RAISES_EXCEPTIONS (old_type);\n+  /* Two default specs are equivalent, don't force evaluation.  */\n+  if (UNEVALUATED_NOEXCEPT_SPEC_P (new_exceptions)\n+      && UNEVALUATED_NOEXCEPT_SPEC_P (old_exceptions))\n+    return;\n+\n+  maybe_instantiate_noexcept (new_decl);\n+  maybe_instantiate_noexcept (old_decl);\n+  new_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (new_decl));\n+  old_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (old_decl));\n \n   /* [except.spec]\n \n@@ -1915,13 +1918,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n   if (types_match)\n     {\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\tcheck_redeclaration_exception_specification (newdecl, olddecl);\n+\n       /* Automatically handles default parameters.  */\n       tree oldtype = TREE_TYPE (olddecl);\n       tree newtype;\n \n-      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\tmaybe_instantiate_noexcept (olddecl);\n-\n       /* For typedefs use the old type, as the new type's DECL_NAME points\n \t at newdecl, which will be ggc_freed.  */\n       if (TREE_CODE (newdecl) == TYPE_DECL)\n@@ -1952,10 +1955,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    }\n \t}\n \n-      /* Do this after calling `merge_types' so that default\n-\t parameters don't confuse us.  */\n-      else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\tcheck_redeclaration_exception_specification (newdecl, olddecl);\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n \n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -13435,6 +13434,9 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   if (!DECL_CLONED_FUNCTION_P (decl1))\n     determine_visibility (decl1);\n \n+  if (!processing_template_decl)\n+    maybe_instantiate_noexcept (decl1);\n+\n   begin_scope (sk_function_parms, decl1);\n \n   ++function_depth;"}, {"sha": "918ea2fc6d08d5eac4455ef9e0ba22f36669c254", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -4806,6 +4806,9 @@ mark_used (tree decl, tsubst_flags_t complain)\n   if (TREE_CODE (decl) == CONST_DECL)\n     used_types_insert (DECL_CONTEXT (decl));\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    maybe_instantiate_noexcept (decl);\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DELETED_FN (decl))\n     {\n@@ -4860,9 +4863,6 @@ mark_used (tree decl, tsubst_flags_t complain)\n       return true;\n     }\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    maybe_instantiate_noexcept (decl);\n-\n   /* Normally, we can wait until instantiation-time to synthesize DECL.\n      However, if DECL is a static data member initialized with a constant\n      or a constexpr function, we need it right now because a reference to"}, {"sha": "ead889c065824cb8cd3698d081c8b7d46290e8ce", "filename": "gcc/cp/except.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1342,6 +1342,18 @@ build_noexcept_spec (tree expr, int complain)\n     }\n }\n \n+/* Returns a noexcept-specifier to be evaluated later, for an\n+   implicitly-declared or explicitly defaulted special member function.  */\n+\n+tree\n+unevaluated_noexcept_spec (void)\n+{\n+  static tree spec;\n+  if (spec == NULL_TREE)\n+    spec = build_noexcept_spec (make_node (DEFERRED_NOEXCEPT), tf_none);\n+  return spec;\n+}\n+\n /* Returns a TRY_CATCH_EXPR that will put TRY_LIST and CATCH_LIST in the\n    TRY and CATCH locations.  CATCH_LIST must be a STATEMENT_LIST */\n "}, {"sha": "8b9405c54edb97a536abd794e7b289b03160c9f9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -521,6 +521,45 @@ perform_target_ctor (tree init)\n     }\n }\n \n+/* Return the non-static data initializer for FIELD_DECL MEMBER.  */\n+\n+tree\n+get_nsdmi (tree member, bool in_ctor)\n+{\n+  tree init;\n+  tree save_ccp = current_class_ptr;\n+  tree save_ccr = current_class_ref;\n+  if (!in_ctor)\n+    inject_this_parameter (DECL_CONTEXT (member), TYPE_UNQUALIFIED);\n+  if (DECL_LANG_SPECIFIC (member) && DECL_TEMPLATE_INFO (member))\n+    /* Do deferred instantiation of the NSDMI.  */\n+    init = (tsubst_copy_and_build\n+\t    (DECL_INITIAL (DECL_TI_TEMPLATE (member)),\n+\t     DECL_TI_ARGS (member),\n+\t     tf_warning_or_error, member, /*function_p=*/false,\n+\t     /*integral_constant_expression_p=*/false));\n+  else\n+    {\n+      init = DECL_INITIAL (member);\n+      if (init && TREE_CODE (init) == DEFAULT_ARG)\n+\t{\n+\t  error (\"constructor required before non-static data member \"\n+\t\t \"for %qD has been parsed\", member);\n+\t  DECL_INITIAL (member) = error_mark_node;\n+\t  init = NULL_TREE;\n+\t}\n+      /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n+\t so the aggregate init code below will see a CONSTRUCTOR.  */\n+      if (init && TREE_CODE (init) == TARGET_EXPR\n+\t  && !VOID_TYPE_P (TREE_TYPE (TARGET_EXPR_INITIAL (init))))\n+\tinit = TARGET_EXPR_INITIAL (init);\n+      init = break_out_target_exprs (init);\n+    }\n+  current_class_ptr = save_ccp;\n+  current_class_ref = save_ccr;\n+  return init;\n+}\n+\n /* Initialize MEMBER, a FIELD_DECL, with INIT, a TREE_LIST of\n    arguments.  If TREE_LIST is void_type_node, an empty initializer\n    list was given; if NULL_TREE no initializer was given.  */\n@@ -534,31 +573,7 @@ perform_member_init (tree member, tree init)\n   /* Use the non-static data member initializer if there was no\n      mem-initializer for this field.  */\n   if (init == NULL_TREE)\n-    {\n-      if (DECL_LANG_SPECIFIC (member) && DECL_TEMPLATE_INFO (member))\n-\t/* Do deferred instantiation of the NSDMI.  */\n-\tinit = (tsubst_copy_and_build\n-\t\t(DECL_INITIAL (DECL_TI_TEMPLATE (member)),\n-\t\t DECL_TI_ARGS (member),\n-\t\t tf_warning_or_error, member, /*function_p=*/false,\n-\t\t /*integral_constant_expression_p=*/false));\n-      else\n-\t{\n-\t  init = DECL_INITIAL (member);\n-\t  if (init && TREE_CODE (init) == DEFAULT_ARG)\n-\t    {\n-\t      error (\"constructor required before non-static data member \"\n-\t\t     \"for %qD has been parsed\", member);\n-\t      init = NULL_TREE;\n-\t    }\n-\t  /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n-\t     so the aggregate init code below will see a CONSTRUCTOR.  */\n-\t  if (init && TREE_CODE (init) == TARGET_EXPR\n-\t      && !VOID_TYPE_P (TREE_TYPE (TARGET_EXPR_INITIAL (init))))\n-\t    init = TARGET_EXPR_INITIAL (init);\n-\t  init = break_out_target_exprs (init);\n-\t}\n-    }\n+    init = get_nsdmi (member, /*ctor*/true);\n \n   if (init == error_mark_node)\n     return;"}, {"sha": "f8fc01ff531e129d0d886b5ed90e80661e8028f3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1003,8 +1003,9 @@ process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,\n \n   if (spec_p)\n     {\n+      maybe_instantiate_noexcept (fn);\n       tree raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-      *spec_p = merge_exception_specifiers (*spec_p, raises, fn);\n+      *spec_p = merge_exception_specifiers (*spec_p, raises);\n     }\n \n   if (!trivial_fn_p (fn))\n@@ -1090,17 +1091,14 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\tinform (0, \"initializer for %q+#D is invalid\", field);\n \t      if (trivial_p)\n \t\t*trivial_p = false;\n-#if 0\n \t      /* Core 1351: If the field has an NSDMI that could throw, the\n-\t\t default constructor is noexcept(false).  FIXME this is\n-\t\t broken by deferred parsing and 1360 saying we can't lazily\n-\t\t declare a non-trivial default constructor.  Also this\n-\t\t needs to do deferred instantiation.  Disable until the\n-\t\t conflict between 1351 and 1360 is resolved.  */\n-\t      if (spec_p && !expr_noexcept_p (DECL_INITIAL (field), complain))\n-\t\t*spec_p = noexcept_false_spec;\n-#endif\n-\n+\t\t default constructor is noexcept(false).  */\n+\t      if (spec_p)\n+\t\t{\n+\t\t  tree nsdmi = get_nsdmi (field, /*ctor*/false);\n+\t\t  if (!expr_noexcept_p (nsdmi, complain))\n+\t\t    *spec_p = noexcept_false_spec;\n+\t\t}\n \t      /* Don't do the normal processing.  */\n \t      continue;\n \t    }\n@@ -1438,6 +1436,26 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   --c_inhibit_evaluation_warnings;\n }\n \n+/* DECL is a defaulted function whose exception specification is now\n+   needed.  Return what it should be.  */\n+\n+tree\n+get_defaulted_eh_spec (tree decl)\n+{\n+  if (DECL_CLONED_FUNCTION_P (decl))\n+    decl = DECL_CLONED_FUNCTION (decl);\n+  special_function_kind sfk = special_function_p (decl);\n+  tree ctype = DECL_CONTEXT (decl);\n+  tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n+  tree parm_type = TREE_VALUE (parms);\n+  bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n+  tree spec = empty_except_spec;\n+  synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,\n+\t\t\t   NULL, false, DECL_INHERITED_CTOR_BASE (decl),\n+\t\t\t   parms);\n+  return spec;\n+}\n+\n /* DECL is a deleted function.  If it's implicitly deleted, explain why and\n    return true; else return false.  */\n \n@@ -1675,6 +1693,13 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       deleted_p = DECL_DELETED_FN (inherited_ctor);\n       constexpr_p = DECL_DECLARED_CONSTEXPR_P (inherited_ctor);\n     }\n+  else if (cxx_dialect >= cxx11)\n+    {\n+      raises = unevaluated_noexcept_spec ();\n+      synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n+\t\t\t       &deleted_p, &constexpr_p, false,\n+\t\t\t       inherited_base, inherited_parms);\n+    }\n   else\n     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n \t\t\t     &deleted_p, &constexpr_p, false,\n@@ -1826,25 +1851,33 @@ defaulted_late_check (tree fn)\n      is explicitly defaulted on its first declaration, (...) it is\n      implicitly considered to have the same exception-specification as if\n      it had been implicitly declared.  */\n-  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)))\n+  tree fn_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+  if (!fn_spec)\n     {\n-      maybe_instantiate_noexcept (fn);\n-      if (!comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)),\n-\t\t\t      eh_spec, ce_normal))\n+      if (DECL_DEFAULTED_IN_CLASS_P (fn))\n+\tTREE_TYPE (fn) = build_exception_variant (TREE_TYPE (fn), eh_spec);\n+    }\n+  else if (UNEVALUATED_NOEXCEPT_SPEC_P (fn_spec))\n+    /* Equivalent to the implicit spec.  */;\n+  else if (DECL_DEFAULTED_IN_CLASS_P (fn)\n+\t   && !CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n+    /* We can't compare an explicit exception-specification on a\n+       constructor defaulted in the class body to the implicit\n+       exception-specification until after we've parsed any NSDMI; see\n+       after_nsdmi_defaulted_late_checks.  */;\n+  else\n+    {\n+      tree eh_spec = get_defaulted_eh_spec (fn);\n+      if (!comp_except_specs (fn_spec, eh_spec, ce_normal))\n \t{\n \t  if (DECL_DEFAULTED_IN_CLASS_P (fn))\n-\t    {\n-\t      DECL_DELETED_FN (fn) = true;\n-\t      eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-\t    }\n+\t    DECL_DELETED_FN (fn) = true;\n \t  else\n \t    error (\"function %q+D defaulted on its redeclaration \"\n \t\t   \"with an exception-specification that differs from \"\n-\t\t   \"the implicit declaration %q#D\", fn, implicit_fn);\n+\t\t   \"the implicit exception-specification %qX\", fn, eh_spec);\n \t}\n     }\n-  if (DECL_DEFAULTED_IN_CLASS_P (fn))\n-    TREE_TYPE (fn) = build_exception_variant (TREE_TYPE (fn), eh_spec);\n \n   if (DECL_DEFAULTED_IN_CLASS_P (fn)\n       && DECL_DECLARED_CONSTEXPR_P (implicit_fn))\n@@ -1874,6 +1907,30 @@ defaulted_late_check (tree fn)\n     DECL_DELETED_FN (fn) = 1;\n }\n \n+/* OK, we've parsed the NSDMI for class T, now we can check any explicit\n+   exception-specifications on functions defaulted in the class body.  */\n+\n+void\n+after_nsdmi_defaulted_late_checks (tree t)\n+{\n+  if (uses_template_parms (t))\n+    return;\n+  if (t == error_mark_node)\n+    return;\n+  for (tree fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n+    if (!DECL_ARTIFICIAL (fn) && DECL_DEFAULTED_IN_CLASS_P (fn))\n+      {\n+\ttree fn_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+\tif (UNEVALUATED_NOEXCEPT_SPEC_P (fn_spec))\n+\t  continue;\n+\n+\ttree eh_spec = get_defaulted_eh_spec (fn);\n+\tif (!comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)),\n+\t\t\t\teh_spec, ce_normal))\n+\t  DECL_DELETED_FN (fn) = true;\n+      }\n+}\n+\n /* Returns true iff FN can be explicitly defaulted, and gives any\n    errors if defaulting FN is ill-formed.  */\n "}, {"sha": "5542dcd9ba38905aa4e719ad0b0e3420fcbcfa2d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1848,11 +1848,13 @@ cp_parser_context_new (cp_parser_context* next)\n   parser->unparsed_queues->last ().funs_with_definitions\n #define unparsed_nsdmis \\\n   parser->unparsed_queues->last ().nsdmis\n+#define unparsed_classes \\\n+  parser->unparsed_queues->last ().classes\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n {\n-  cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL};\n+  cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL, NULL};\n   vec_safe_push (parser->unparsed_queues, e);\n }\n \n@@ -17834,7 +17836,7 @@ cp_parser_virt_specifier_seq_opt (cp_parser* parser)\n /* Used by handling of trailing-return-types and NSDMI, in which 'this'\n    is in scope even though it isn't real.  */\n \n-static void\n+void\n inject_this_parameter (tree ctype, cp_cv_quals quals)\n {\n   tree this_parm;\n@@ -19505,6 +19507,13 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n       current_class_ref = save_ccr;\n       if (pushed_scope)\n \tpop_scope (pushed_scope);\n+\n+      /* Now do some post-NSDMI bookkeeping.  */\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_classes, ix, class_type)\n+\tafter_nsdmi_defaulted_late_checks (class_type);\n+      vec_safe_truncate (unparsed_classes, 0);\n+      after_nsdmi_defaulted_late_checks (type);\n+\n       /* Now parse the body of the functions.  */\n       if (flag_openmp)\n \t{\n@@ -19521,6 +19530,8 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t  cp_parser_late_parsing_for_member (parser, decl);\n       vec_safe_truncate (unparsed_funs_with_definitions, 0);\n     }\n+  else\n+    vec_safe_push (unparsed_classes, type);\n \n   /* Put back any saved access checks.  */\n   pop_deferring_access_checks ();"}, {"sha": "96a84534045b6ff782502751f26acbe1f7692c9a", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -149,7 +149,7 @@ typedef struct GTY(()) cp_default_arg_entry_d {\n } cp_default_arg_entry;\n \n \n-/* An entry in a stack for member functions of local classes.  */\n+/* An entry in a stack for member functions defined within their classes.  */\n \n typedef struct GTY(()) cp_unparsed_functions_entry_d {\n   /* Functions with default arguments that require post-processing.\n@@ -163,6 +163,10 @@ typedef struct GTY(()) cp_unparsed_functions_entry_d {\n   /* Non-static data members with initializers that require post-processing.\n      FIELD_DECLs appear in this list in declaration order.  */\n   vec<tree, va_gc> *nsdmis;\n+\n+  /* Nested classes go in this vector, so that we can do some final\n+     processing after parsing any NSDMIs.  */\n+  vec<tree, va_gc> *classes;\n } cp_unparsed_functions_entry;\n \n "}, {"sha": "48cc2a9e9cf8ad2db4e37521a1c9a89c832e6518", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -19470,14 +19470,16 @@ maybe_instantiate_noexcept (tree fn)\n   fntype = TREE_TYPE (fn);\n   spec = TYPE_RAISES_EXCEPTIONS (fntype);\n \n-  if (!DEFERRED_NOEXCEPT_SPEC_P (spec))\n+  if (!spec || !TREE_PURPOSE (spec))\n     return;\n \n   noex = TREE_PURPOSE (spec);\n \n   if (TREE_CODE (noex) == DEFERRED_NOEXCEPT)\n     {\n-      if (push_tinst_level (fn))\n+      if (DEFERRED_NOEXCEPT_PATTERN (noex) == NULL_TREE)\n+\tspec = get_defaulted_eh_spec (fn);\n+      else if (push_tinst_level (fn))\n \t{\n \t  push_access_scope (fn);\n \t  push_deferring_access_checks (dk_no_deferred);\n@@ -19496,24 +19498,9 @@ maybe_instantiate_noexcept (tree fn)\n \t}\n       else\n \tspec = noexcept_false_spec;\n-    }\n-  else\n-    {\n-      /* This is an implicitly declared function, so NOEX is a list of\n-\t other functions to evaluate and merge.  */\n-      tree elt;\n-      spec = noexcept_true_spec;\n-      for (elt = noex; elt; elt = OVL_NEXT (elt))\n-\t{\n-\t  tree fn = OVL_CURRENT (elt);\n-\t  tree subspec;\n-\t  maybe_instantiate_noexcept (fn);\n-\t  subspec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-\t  spec = merge_exception_specifiers (spec, subspec, NULL_TREE);\n-\t}\n-    }\n \n-  TREE_TYPE (fn) = build_exception_variant (fntype, spec);\n+      TREE_TYPE (fn) = build_exception_variant (fntype, spec);\n+    }\n \n   FOR_EACH_CLONE (clone, fn)\n     {\n@@ -19664,9 +19651,6 @@ instantiate_decl (tree d, int defer_ok,\n       SET_DECL_IMPLICIT_INSTANTIATION (d);\n     }\n \n-  if (TREE_CODE (d) == FUNCTION_DECL)\n-    maybe_instantiate_noexcept (d);\n-\n   /* Defer all other templates, unless we have been explicitly\n      forbidden from doing so.  */\n   if (/* If there is no definition, we cannot instantiate the"}, {"sha": "ae7fa776eb84023811b6ef4651bc9b9b5ba3ebf7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -840,8 +840,7 @@ merge_types (tree t1, tree t2)\n \t\t\t\t  type_memfn_quals (t1),\n \t\t\t\t  type_memfn_rqual (t1));\n \traises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n-\t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2),\n-\t\t\t\t\t     NULL_TREE);\n+\t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2));\n \tt1 = build_exception_variant (rval, raises);\n \tbreak;\n       }\n@@ -852,8 +851,7 @@ merge_types (tree t1, tree t2)\n \t   is just the main variant of this.  */\n \ttree basetype = class_of_this_parm (t2);\n \ttree raises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n-\t\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (t2),\n-\t\t\t\t\t\t  NULL_TREE);\n+\t\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (t2));\n \tcp_ref_qualifier rqual = type_memfn_rqual (t1);\n \ttree t3;\n "}, {"sha": "5bbc2efd5e6689ac9bf734c66b33db27945f0f60", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1989,10 +1989,10 @@ nothrow_spec_p_uninst (const_tree spec)\n }\n \n /* Combine the two exceptions specifier lists LIST and ADD, and return\n-   their union.  If FN is non-null, it's the source of ADD.  */\n+   their union.  */\n \n tree\n-merge_exception_specifiers (tree list, tree add, tree fn)\n+merge_exception_specifiers (tree list, tree add)\n {\n   tree noex, orig_list;\n \n@@ -2008,22 +2008,18 @@ merge_exception_specifiers (tree list, tree add, tree fn)\n   if (nothrow_spec_p_uninst (add))\n     return list;\n \n-  noex = TREE_PURPOSE (list);\n-  if (DEFERRED_NOEXCEPT_SPEC_P (add))\n-    {\n-      /* If ADD is a deferred noexcept, we must have been called from\n-\t process_subob_fn.  For implicitly declared functions, we build up\n-\t a list of functions to consider at instantiation time.  */\n-      if (noex && operand_equal_p (noex, boolean_true_node, 0))\n-\tnoex = NULL_TREE;\n-      gcc_assert (fn && (!noex || is_overloaded_fn (noex)));\n-      noex = build_overload (fn, noex);\n-    }\n-  else if (nothrow_spec_p_uninst (list))\n+  /* Two implicit noexcept specs (e.g. on a destructor) are equivalent.  */\n+  if (UNEVALUATED_NOEXCEPT_SPEC_P (add)\n+      && UNEVALUATED_NOEXCEPT_SPEC_P (list))\n+    return list;\n+  /* We should have instantiated other deferred noexcept specs by now.  */\n+  gcc_assert (!DEFERRED_NOEXCEPT_SPEC_P (add));\n+\n+  if (nothrow_spec_p_uninst (list))\n     return add;\n-  else\n-    gcc_checking_assert (!TREE_PURPOSE (add)\n-\t\t\t || cp_tree_equal (noex, TREE_PURPOSE (add)));\n+  noex = TREE_PURPOSE (list);\n+  gcc_checking_assert (!TREE_PURPOSE (add)\n+\t\t       || cp_tree_equal (noex, TREE_PURPOSE (add)));\n \n   /* Combine the dynamic-exception-specifiers, if any.  */\n   orig_list = list;"}, {"sha": "0f06343958b1275eec9292dcc972dceeea7b978e", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-defer6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1,8 +1,8 @@\n // { dg-do compile { target c++11 } }\n \n-struct A\t\t\t// { dg-error \"non-static data member\" }\n+struct A\n {\n-  int i = (A(), 42);\t\t// { dg-message \"required here\" }\n+  int i = (A(), 42);\t\t// { dg-error \"constructor required\" }\n };\n \n A a;"}, {"sha": "061af8b8c295299b9a85a7a5a74c6e3898bb7aa9", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-dr1397.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-dr1397.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-dr1397.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-dr1397.C?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -0,0 +1,7 @@\n+// DR 1397\n+// { dg-require-effective-target c++11 }\n+\n+struct A\n+{\n+  int i = sizeof(A{});\t\t// { dg-error \"\" }\n+};"}, {"sha": "9bc632c4bc7d89d00241a2f6b453c7c7189c6801", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-eh1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-eh1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15ea3099ae6e566f715aeafb32efbd1782614b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-eh1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-eh1.C?ref=b15ea3099ae6e566f715aeafb32efbd1782614b4", "patch": "@@ -1,5 +1,5 @@\n // Core issue 1351\n-// { dg-do run { xfail *-*-* } }\n+// { dg-do run }\n // { dg-require-effective-target c++11 }\n \n bool fail;"}]}