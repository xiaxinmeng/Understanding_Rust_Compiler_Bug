{"sha": "72b167732cdc740893b163efbc53de0a963176d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiMTY3NzMyY2RjNzQwODkzYjE2M2VmYmM1M2RlMGE5NjMxNzZkNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-01-26T22:00:28Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-01-26T22:00:28Z"}, "message": "re PR other/24829 (libobjc testsuite failures)\n\n\tPR other/24829\n\tPR target/24831\n\t* gthr-dce.h: Do not gthrw-ify pthread_once_init,\n\tpthread_key_delete.  From John David Anglin.  gthrw-ify\n\tpthread_getunique_np only if it it's not a macro.  Delete\n\tUNUSED macro.\n\t(__gthread_objc_condition_allocate, __gthread_objc_condition_deallocate,\n\t__gthread_objc_condition_wait, __gthread_objc_condition_broadcast,\n\t__gthread_objc_condition_signal, __gthread_key_delete): Add\n\t\"__attribute__ ((__unused__))\" to unused arguments.\n\t(__gthread_recursive_mutex_init_function): Add missing return.\n\t* gthr-dce.h, gthr-tpf.h, gthr-solaris.h, gthr-posix.h,\n\tgthr-posix95.h: Use macro-based approach for name redirection\n\ton targets missing weakref.\n\nFrom-SVN: r110278", "tree": {"sha": "85db8df0b86bd9d7411eb66fbd849450b99ac43d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85db8df0b86bd9d7411eb66fbd849450b99ac43d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b167732cdc740893b163efbc53de0a963176d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b167732cdc740893b163efbc53de0a963176d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b167732cdc740893b163efbc53de0a963176d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b167732cdc740893b163efbc53de0a963176d7/comments", "author": null, "committer": null, "parents": [{"sha": "f7c8e4fc33d6386550568da002faf7804396606b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c8e4fc33d6386550568da002faf7804396606b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7c8e4fc33d6386550568da002faf7804396606b"}], "stats": {"total": 641, "additions": 326, "deletions": 315}, "files": [{"sha": "68c169b1596e2097d0bc9b711620fa841faa63ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -1,3 +1,20 @@\n+2006-01-26 Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR other/24829\n+\tPR target/24831\n+\t* gthr-dce.h: Do not gthrw-ify pthread_once_init,\n+\tpthread_key_delete.  From John David Anglin.  gthrw-ify\n+\tpthread_getunique_np only if it it's not a macro.  Delete\n+\tUNUSED macro.\n+\t(__gthread_objc_condition_allocate, __gthread_objc_condition_deallocate,\n+\t__gthread_objc_condition_wait, __gthread_objc_condition_broadcast,\n+\t__gthread_objc_condition_signal, __gthread_key_delete): Add\n+\t\"__attribute__ ((__unused__))\" to unused arguments.\n+\t(__gthread_recursive_mutex_init_function): Add missing return.\n+\t* gthr-dce.h, gthr-tpf.h, gthr-solaris.h, gthr-posix.h,\n+\tgthr-posix95.h: Use macro-based approach for name redirection\n+\ton targets missing weakref.\n+\n 2006-01-26  Zack Weinberg  <zackw@panix.com>\n \n \t* genconditions.c (write_header): In generated code, #ifdef out"}, {"sha": "d876c659e06df27089e86862dfde425eb9f690fc", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 75, "deletions": 73, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -44,70 +44,67 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include <pthread.h>\n \n-#ifdef __cplusplus\n-#define UNUSED(x) x\n-#else\n-#define UNUSED(x) x __attribute__((unused))\n-#endif\n-\n typedef pthread_key_t __gthread_key_t;\n typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n-#define __GTHREAD_ONCE_INIT __gthrw_pthread_once_init\n+#define __GTHREAD_ONCE_INIT pthread_once_init\n \n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n-#define __GTHREAD_MUTEX_INIT_DEFAULT __gthrw_pthread_once_init\n+#define __GTHREAD_MUTEX_INIT_DEFAULT pthread_once_init\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n+# define __gthrw_(name) __gthrw_ ## name\n #else\n-# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n-# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n-# define __gthrw_string(x) #x\n-# define __gthrw(name) \\\n-  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+# define __gthrw(name)\n+# define __gthrw_(name) name\n #endif\n \n-__gthrw(pthread_once);\n-__gthrw(pthread_once_init);\n-__gthrw(pthread_keycreate);\n-__gthrw(pthread_key_delete);\n-__gthrw(pthread_getspecific);\n-__gthrw(pthread_setspecific);\n-__gthrw(pthread_create);\n-__gthrw(pthread_mutex_init);\n-__gthrw(pthread_mutex_lock);\n-__gthrw(pthread_mutex_trylock);\n-__gthrw(pthread_mutex_unlock);\n-__gthrw(pthread_mutexattr_create);\n-__gthrw(pthread_mutexattr_setkind_np);\n-__gthrw(pthread_mutexattr_delete);\n+__gthrw(pthread_once)\n+__gthrw(pthread_keycreate)\n+__gthrw(pthread_getspecific)\n+__gthrw(pthread_setspecific)\n+__gthrw(pthread_create)\n+__gthrw(pthread_mutex_init)\n+__gthrw(pthread_mutex_lock)\n+__gthrw(pthread_mutex_trylock)\n+__gthrw(pthread_mutex_unlock)\n+__gthrw(pthread_mutexattr_create)\n+__gthrw(pthread_mutexattr_setkind_np)\n+__gthrw(pthread_mutexattr_delete)\n \n #ifdef _LIBOBJC\n /* Objective-C.  */\n-__gthrw(pthread_cond_broadcast);\n-__gthrw(pthread_cond_destroy);\n-__gthrw(pthread_cond_init);\n-__gthrw(pthread_cond_signal);\n-__gthrw(pthread_cond_wait);\n-__gthrw(pthread_exit);\n-__gthrw(pthread_getunique_np);\n-__gthrw(pthread_mutex_destroy);\n-__gthrw(pthread_self);\n-__gthrw(pthread_yield);\n+__gthrw(pthread_cond_broadcast)\n+__gthrw(pthread_cond_destroy)\n+__gthrw(pthread_cond_init)\n+__gthrw(pthread_cond_signal)\n+__gthrw(pthread_cond_wait)\n+__gthrw(pthread_exit)\n+\n+#ifdef pthread_getunique_np\n+# define __gthrw_pthread_getunique_np pthread_getunique_np\n+#else\n+__gthrw(pthread_getunique_np)\n+# define __gthrw_pthread_getunique_np __gthrw_(pthread_getunique_np)\n+#endif\n+\n+__gthrw(pthread_mutex_destroy)\n+__gthrw(pthread_self)\n+__gthrw(pthread_yield)\n #endif\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n \n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr = (void *) &__gthrw_pthread_create;\n+  static void *const __gthread_active_ptr = (void *) &__gthrw_(pthread_create);\n   return __gthread_active_ptr != 0;\n }\n \n@@ -137,7 +134,7 @@ __gthread_objc_init_thread_system (void)\n {\n   if (__gthread_active_p ())\n     /* Initialize the thread storage key.  */\n-    return __gthrw_pthread_keycreate (&_objc_thread_storage, NULL);\n+    return __gthrw_(pthread_keycreate) (&_objc_thread_storage, NULL);\n   else\n     return -1;\n }\n@@ -164,7 +161,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(__gthrw_pthread_create (&new_thread_handle, pthread_attr_default,\n+  if (!(__gthrw_(pthread_create) (&new_thread_handle, pthread_attr_default,\n \t\t\t(void *) func, arg)))\n     {\n       /* ??? May not work! (64bit) */\n@@ -201,7 +198,7 @@ __gthread_objc_thread_set_priority (int priority)\n     }\n \n   /* Change the priority.  */\n-  if (pthread_setprio (__gthrw_pthread_self (), sys_priority) >= 0)\n+  if (pthread_setprio (__gthrw_(pthread_self) (), sys_priority) >= 0)\n     return 0;\n   else\n     /* Failed */\n@@ -216,7 +213,7 @@ __gthread_objc_thread_get_priority (void)\n \n   if (__gthread_active_p ())\n     {\n-      if ((sys_priority = pthread_getprio (__gthrw_pthread_self ())) >= 0)\n+      if ((sys_priority = pthread_getprio (__gthrw_(pthread_self) ())) >= 0)\n \t{\n \t  if (sys_priority >= PRI_FG_MIN_NP\n \t      && sys_priority <= PRI_FG_MAX_NP)\n@@ -239,7 +236,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    __gthrw_pthread_yield ();\n+    __gthrw_(pthread_yield) ();\n }\n \n /* Terminate the current thread.  */\n@@ -248,7 +245,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    __gthrw_pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_(pthread_exit) (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -260,7 +257,7 @@ __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t self = __gthrw_pthread_self ();\n+      pthread_t self = __gthrw_(pthread_self) ();\n \n       return (objc_thread_t) __gthrw_pthread_getunique_np (&self);\n     }\n@@ -273,7 +270,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -289,7 +286,7 @@ __gthread_objc_thread_get_data (void)\n \n   if (__gthread_active_p ())\n     {\n-      if (!(__gthrw_pthread_getspecific (_objc_thread_storage, &value)))\n+      if (!(__gthrw_(pthread_getspecific) (_objc_thread_storage, &value)))\n \treturn value;\n \n       return NULL;\n@@ -308,7 +305,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend,\n+      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend,\n \t\t\t      pthread_mutexattr_default))\n \t{\n \t  objc_free (mutex->backend);\n@@ -326,7 +323,7 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -341,7 +338,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend);\n+    return __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n }\n@@ -351,7 +348,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 1)\n+      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 1)\n     return -1;\n \n   return 0;\n@@ -362,7 +359,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+    return __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n }\n@@ -371,7 +368,8 @@ __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n \n /* Allocate a condition.  */\n static inline int\n-__gthread_objc_condition_allocate (objc_condition_t condition)\n+__gthread_objc_condition_allocate (objc_condition_t condition\n+\t\t\t\t   __attribute__ ((__unused__)))\n {\n   if (__gthread_active_p ())\n     /* Unimplemented.  */\n@@ -382,7 +380,8 @@ __gthread_objc_condition_allocate (objc_condition_t condition)\n \n /* Deallocate a condition.  */\n static inline int\n-__gthread_objc_condition_deallocate (objc_condition_t condition)\n+__gthread_objc_condition_deallocate (objc_condition_t condition\n+\t\t\t\t     __attribute__ ((__unused__)))\n {\n   if (__gthread_active_p ())\n     /* Unimplemented.  */\n@@ -393,7 +392,9 @@ __gthread_objc_condition_deallocate (objc_condition_t condition)\n \n /* Wait on the condition */\n static inline int\n-__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n+__gthread_objc_condition_wait (objc_condition_t condition\n+\t\t\t       __attribute__ ((__unused__)),\n+\t\t\t       objc_mutex_t mutex __attribute__ ((__unused__)))\n {\n   if (__gthread_active_p ())\n     /* Unimplemented.  */\n@@ -404,7 +405,8 @@ __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n \n /* Wake up all threads waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_broadcast (objc_condition_t condition)\n+__gthread_objc_condition_broadcast (objc_condition_t condition\n+\t\t\t\t    __attribute__ ((__unused__)))\n {\n   if (__gthread_active_p ())\n     /* Unimplemented.  */\n@@ -415,7 +417,8 @@ __gthread_objc_condition_broadcast (objc_condition_t condition)\n \n /* Wake up one thread waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_signal (objc_condition_t condition)\n+__gthread_objc_condition_signal (objc_condition_t condition\n+\t\t\t\t __attribute__ ((__unused__)))\n {\n   if (__gthread_active_p ())\n     /* Unimplemented.  */\n@@ -430,19 +433,19 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_once (once, func);\n+    return __gthrw_(pthread_once) (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return __gthrw_pthread_keycreate (key, dtor);\n+  return __gthrw_(pthread_keycreate) (key, dtor);\n }\n \n static inline int\n-__gthread_key_delete (UNUSED (__gthread_key_t key))\n+__gthread_key_delete (__gthread_key_t key __attribute__ ((__unused__)))\n {\n   /* Operation is not supported.  */\n   return -1;\n@@ -452,7 +455,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   void *ptr;\n-  if (__gthrw_pthread_getspecific (key, &ptr) == 0)\n+  if (__gthrw_(pthread_getspecific) (key, &ptr) == 0)\n     return ptr;\n   else\n     return 0;\n@@ -461,21 +464,21 @@ __gthread_getspecific (__gthread_key_t key)\n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return __gthrw_pthread_setspecific (key, (void *) ptr);\n+  return __gthrw_(pthread_setspecific) (key, (void *) ptr);\n }\n \n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    __gthrw_pthread_mutex_init (mutex, pthread_mutexattr_default);\n+    __gthrw_(pthread_mutex_init) (mutex, pthread_mutexattr_default);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_lock (mutex);\n+    return __gthrw_(pthread_mutex_lock) (mutex);\n   else\n     return 0;\n }\n@@ -484,7 +487,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_trylock (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (mutex);\n   else\n     return 0;\n }\n@@ -493,7 +496,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_unlock (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (mutex);\n   else\n     return 0;\n }\n@@ -506,15 +509,16 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n       pthread_mutexattr_t attr;\n       int r;\n \n-      r = __gthrw_pthread_mutexattr_create (&attr);\n+      r = __gthrw_(pthread_mutexattr_create) (&attr);\n       if (!r)\n-\tr = __gthrw_pthread_mutexattr_setkind_np (&attr, MUTEX_RECURSIVE_NP);\n+\tr = __gthrw_(pthread_mutexattr_setkind_np) (&attr, MUTEX_RECURSIVE_NP);\n       if (!r)\n-\tr = __gthrw_pthread_mutex_init (mutex, attr);\n+\tr = __gthrw_(pthread_mutex_init) (mutex, attr);\n       if (!r)\n-\tr = __gthrw_pthread_mutexattr_delete (&attr);\n+\tr = __gthrw_(pthread_mutexattr_delete) (&attr);\n       return r;\n     }\n+  return 0;\n }\n \n static inline int\n@@ -537,7 +541,5 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n \n #endif /* _LIBOBJC */\n \n-#undef UNUSED\n-\n #endif\n #endif /* ! GCC_GTHR_DCE_H */"}, {"sha": "38fc38137550bf46abd517395df17e0e9c08619c", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -60,55 +60,53 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n+# define __gthrw_(name) __gthrw_ ## name\n #else\n-# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n-# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n-# define __gthrw_string(x) #x\n-# define __gthrw(name) \\\n-  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+# define __gthrw(name)\n+# define __gthrw_(name) name\n #endif\n \n-__gthrw(pthread_once);\n-__gthrw(pthread_key_create);\n-__gthrw(pthread_key_delete);\n-__gthrw(pthread_getspecific);\n-__gthrw(pthread_setspecific);\n-__gthrw(pthread_create);\n-__gthrw(pthread_cancel);\n+__gthrw(pthread_once)\n+__gthrw(pthread_key_create)\n+__gthrw(pthread_key_delete)\n+__gthrw(pthread_getspecific)\n+__gthrw(pthread_setspecific)\n+__gthrw(pthread_create)\n+__gthrw(pthread_cancel)\n \n-__gthrw(pthread_mutex_lock);\n-__gthrw(pthread_mutex_trylock);\n-__gthrw(pthread_mutex_unlock);\n-__gthrw(pthread_mutexattr_init);\n-__gthrw(pthread_mutexattr_settype);\n-__gthrw(pthread_mutexattr_destroy);\n+__gthrw(pthread_mutex_lock)\n+__gthrw(pthread_mutex_trylock)\n+__gthrw(pthread_mutex_unlock)\n+__gthrw(pthread_mutexattr_init)\n+__gthrw(pthread_mutexattr_settype)\n+__gthrw(pthread_mutexattr_destroy)\n \n-__gthrw(pthread_mutex_init);\n+__gthrw(pthread_mutex_init)\n \n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n-__gthrw(pthread_cond_broadcast);\n-__gthrw(pthread_cond_destroy);\n-__gthrw(pthread_cond_init);\n-__gthrw(pthread_cond_signal);\n-__gthrw(pthread_cond_wait);\n-__gthrw(pthread_exit);\n-__gthrw(pthread_mutex_destroy);\n-__gthrw(pthread_self);\n+__gthrw(pthread_cond_broadcast)\n+__gthrw(pthread_cond_destroy)\n+__gthrw(pthread_cond_init)\n+__gthrw(pthread_cond_signal)\n+__gthrw(pthread_cond_wait)\n+__gthrw(pthread_exit)\n+__gthrw(pthread_mutex_destroy)\n+__gthrw(pthread_self)\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(sched_get_priority_max);\n-__gthrw(sched_get_priority_min);\n+__gthrw(sched_get_priority_max)\n+__gthrw(sched_get_priority_min)\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _POSIX_PRIORITY_SCHEDULING */\n-__gthrw(sched_yield);\n-__gthrw(pthread_attr_destroy);\n-__gthrw(pthread_attr_init);\n-__gthrw(pthread_attr_setdetachstate);\n+__gthrw(sched_yield)\n+__gthrw(pthread_attr_destroy)\n+__gthrw(pthread_attr_init)\n+__gthrw(pthread_attr_setdetachstate)\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(pthread_getschedparam);\n-__gthrw(pthread_setschedparam);\n+__gthrw(pthread_getschedparam)\n+__gthrw(pthread_setschedparam)\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _LIBOBJC || _LIBOBJC_WEAK */\n \n@@ -118,7 +116,7 @@ static inline int\n __gthread_active_p (void)\n {\n   static void *const __gthread_active_ptr \n-    = __extension__ (void *) &__gthrw_pthread_cancel;\n+    = __extension__ (void *) &__gthrw_(pthread_cancel);\n   return __gthread_active_ptr != 0;\n }\n \n@@ -157,13 +155,13 @@ __gthread_objc_init_thread_system (void)\n   if (__gthread_active_p ())\n     {\n       /* Initialize the thread storage key.  */\n-      if (__gthrw_pthread_key_create (&_objc_thread_storage, NULL) == 0)\n+      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)\n \t{\n \t  /* The normal default detach state for threads is\n \t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n \t   * when you think they should.  */\n-\t  if (__gthrw_pthread_attr_init (&_objc_thread_attribs) == 0\n-\t      && __gthrw_pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0\n+\t      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,\n \t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n \t    return 0;\n \t}\n@@ -177,8 +175,8 @@ static inline int\n __gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_key_delete (_objc_thread_storage) == 0\n-      && __gthrw_pthread_attr_destroy (&_objc_thread_attribs) == 0)\n+      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0\n+      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)\n     return 0;\n \n   return -1;\n@@ -196,7 +194,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(__gthrw_pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n+  if (!(__gthrw_(pthread_create) (&new_thread_handle, NULL, (void *) func, arg)))\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n@@ -214,17 +212,17 @@ __gthread_objc_thread_set_priority (int priority)\n     {\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-      pthread_t thread_id = __gthrw_pthread_self ();\n+      pthread_t thread_id = __gthrw_(pthread_self) ();\n       int policy;\n       struct sched_param params;\n       int priority_min, priority_max;\n \n-      if (__gthrw_pthread_getschedparam (thread_id, &policy, &params) == 0)\n+      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)\n \t{\n-\t  if ((priority_max = __gthrw_sched_get_priority_max (policy)) == -1)\n+\t  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)\n \t    return -1;\n \n-\t  if ((priority_min = __gthrw_sched_get_priority_min (policy)) == -1)\n+\t  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)\n \t    return -1;\n \n \t  if (priority > priority_max)\n@@ -238,7 +236,7 @@ __gthread_objc_thread_set_priority (int priority)\n \t   * this should be a pointer to policy but pthread.h is universally\n \t   * at odds with this.\n \t   */\n-\t  if (__gthrw_pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)\n \t    return 0;\n \t}\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n@@ -258,7 +256,7 @@ __gthread_objc_thread_get_priority (void)\n       int policy;\n       struct sched_param params;\n \n-      if (__gthrw_pthread_getschedparam (__gthrw_pthread_self (), &policy, &params) == 0)\n+      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)\n \treturn params.sched_priority;\n       else\n \treturn -1;\n@@ -274,7 +272,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    __gthrw_sched_yield ();\n+    __gthrw_(sched_yield) ();\n }\n \n /* Terminate the current thread.  */\n@@ -283,7 +281,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    __gthrw_pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_(pthread_exit) (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -294,7 +292,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) __gthrw_pthread_self ();\n+    return (objc_thread_t) __gthrw_(pthread_self) ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -304,7 +302,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -317,7 +315,7 @@ static inline void *\n __gthread_objc_thread_get_data (void)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_getspecific (_objc_thread_storage);\n+    return __gthrw_(pthread_getspecific) (_objc_thread_storage);\n   else\n     return thread_local_storage;\n }\n@@ -332,7 +330,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n+      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))\n \t{\n \t  objc_free (mutex->backend);\n \t  mutex->backend = NULL;\n@@ -353,18 +351,18 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n \n       /*\n        * Posix Threads specifically require that the thread be unlocked\n-       * for __gthrw_pthread_mutex_destroy to work.\n+       * for __gthrw_(pthread_mutex_destroy) to work.\n        */\n \n       do\n \t{\n-\t  count = __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+\t  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);\n \t  if (count < 0)\n \t    return -1;\n \t}\n       while (count);\n \n-      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -378,7 +376,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -391,7 +389,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -404,7 +402,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -422,7 +420,7 @@ __gthread_objc_condition_allocate (objc_condition_t condition)\n     {\n       condition->backend = objc_malloc (sizeof (pthread_cond_t));\n \n-      if (__gthrw_pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n+      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))\n \t{\n \t  objc_free (condition->backend);\n \t  condition->backend = NULL;\n@@ -439,7 +437,7 @@ __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      if (__gthrw_pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n+      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))\n \treturn -1;\n \n       objc_free (condition->backend);\n@@ -453,7 +451,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,\n \t\t\t      (pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n@@ -464,7 +462,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n+    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -474,7 +472,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_signal ((pthread_cond_t *) condition->backend);\n+    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -485,40 +483,40 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_once (once, func);\n+    return __gthrw_(pthread_once) (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return __gthrw_pthread_key_create (key, dtor);\n+  return __gthrw_(pthread_key_create) (key, dtor);\n }\n \n static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n-  return __gthrw_pthread_key_delete (key);\n+  return __gthrw_(pthread_key_delete) (key);\n }\n \n static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n-  return __gthrw_pthread_getspecific (key);\n+  return __gthrw_(pthread_getspecific) (key);\n }\n \n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return __gthrw_pthread_setspecific (key, ptr);\n+  return __gthrw_(pthread_setspecific) (key, ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_lock (mutex);\n+    return __gthrw_(pthread_mutex_lock) (mutex);\n   else\n     return 0;\n }\n@@ -527,7 +525,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_trylock (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (mutex);\n   else\n     return 0;\n }\n@@ -536,7 +534,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_unlock (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (mutex);\n   else\n     return 0;\n }\n@@ -550,13 +548,13 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n       pthread_mutexattr_t attr;\n       int r;\n \n-      r = __gthrw_pthread_mutexattr_init (&attr);\n+      r = __gthrw_(pthread_mutexattr_init) (&attr);\n       if (!r)\n-\tr = __gthrw_pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n+\tr = __gthrw_(pthread_mutexattr_settype) (&attr, PTHREAD_MUTEX_RECURSIVE);\n       if (!r)\n-\tr = __gthrw_pthread_mutex_init (mutex, &attr);\n+\tr = __gthrw_(pthread_mutex_init) (mutex, &attr);\n       if (!r)\n-\tr = __gthrw_pthread_mutexattr_destroy (&attr);\n+\tr = __gthrw_(pthread_mutexattr_destroy) (&attr);\n       return r;\n     }\n   return 0;"}, {"sha": "3a853eafd444e52915d47f388b9cbfa968aeb2e3", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 77, "deletions": 79, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -58,54 +58,52 @@ typedef struct {\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n+# define __gthrw_(name) __gthrw_ ## name\n #else\n-# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n-# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n-# define __gthrw_string(x) #x\n-# define __gthrw(name) \\\n-  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+# define __gthrw(name)\n+# define __gthrw_(name) name\n #endif\n \n-__gthrw(pthread_once);\n-__gthrw(pthread_key_create);\n-__gthrw(pthread_key_delete);\n-__gthrw(pthread_getspecific);\n-__gthrw(pthread_setspecific);\n-__gthrw(pthread_create);\n-__gthrw(pthread_cancel);\n-__gthrw(pthread_self);\n+__gthrw(pthread_once)\n+__gthrw(pthread_key_create)\n+__gthrw(pthread_key_delete)\n+__gthrw(pthread_getspecific)\n+__gthrw(pthread_setspecific)\n+__gthrw(pthread_create)\n+__gthrw(pthread_cancel)\n+__gthrw(pthread_self)\n \n-__gthrw(pthread_mutex_lock);\n-__gthrw(pthread_mutex_trylock);\n-__gthrw(pthread_mutex_unlock);\n-__gthrw(pthread_mutexattr_init);\n-__gthrw(pthread_mutexattr_destroy);\n+__gthrw(pthread_mutex_lock)\n+__gthrw(pthread_mutex_trylock)\n+__gthrw(pthread_mutex_unlock)\n+__gthrw(pthread_mutexattr_init)\n+__gthrw(pthread_mutexattr_destroy)\n \n-__gthrw(pthread_mutex_init);\n+__gthrw(pthread_mutex_init)\n \n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n-__gthrw(pthread_cond_broadcast);\n-__gthrw(pthread_cond_destroy);\n-__gthrw(pthread_cond_init);\n-__gthrw(pthread_cond_signal);\n-__gthrw(pthread_cond_wait);\n-__gthrw(pthread_exit);\n-__gthrw(pthread_mutex_destroy);\n+__gthrw(pthread_cond_broadcast)\n+__gthrw(pthread_cond_destroy)\n+__gthrw(pthread_cond_init)\n+__gthrw(pthread_cond_signal)\n+__gthrw(pthread_cond_wait)\n+__gthrw(pthread_exit)\n+__gthrw(pthread_mutex_destroy)\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(sched_get_priority_max);\n-__gthrw(sched_get_priority_min);\n+__gthrw(sched_get_priority_max)\n+__gthrw(sched_get_priority_min)\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _POSIX_PRIORITY_SCHEDULING */\n-__gthrw(sched_yield);\n-__gthrw(pthread_attr_destroy);\n-__gthrw(pthread_attr_init);\n-__gthrw(pthread_attr_setdetachstate);\n+__gthrw(sched_yield)\n+__gthrw(pthread_attr_destroy)\n+__gthrw(pthread_attr_init)\n+__gthrw(pthread_attr_setdetachstate)\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(pthread_getschedparam);\n-__gthrw(pthread_setschedparam);\n+__gthrw(pthread_getschedparam)\n+__gthrw(pthread_setschedparam)\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n #endif /* _LIBOBJC || _LIBOBJC_WEAK */\n \n@@ -115,7 +113,7 @@ static inline int\n __gthread_active_p (void)\n {\n   static void *const __gthread_active_ptr \n-    = __extension__ (void *) &__gthrw_pthread_cancel;\n+    = __extension__ (void *) &__gthrw_(pthread_cancel);\n   return __gthread_active_ptr != 0;\n }\n \n@@ -154,13 +152,13 @@ __gthread_objc_init_thread_system (void)\n   if (__gthread_active_p ())\n     {\n       /* Initialize the thread storage key.  */\n-      if (__gthrw_pthread_key_create (&_objc_thread_storage, NULL) == 0)\n+      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)\n \t{\n \t  /* The normal default detach state for threads is\n \t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n \t   * when you think they should.  */\n-\t  if (__gthrw_pthread_attr_init (&_objc_thread_attribs) == 0\n-\t      && __gthrw_pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0\n+\t      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,\n \t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n \t    return 0;\n \t}\n@@ -174,8 +172,8 @@ static inline int\n __gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_key_delete (_objc_thread_storage) == 0\n-      && __gthrw_pthread_attr_destroy (&_objc_thread_attribs) == 0)\n+      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0\n+      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)\n     return 0;\n \n   return -1;\n@@ -193,7 +191,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (!(__gthrw_pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n+  if (!(__gthrw_(pthread_create) (&new_thread_handle, NULL, (void *) func, arg)))\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n@@ -211,17 +209,17 @@ __gthread_objc_thread_set_priority (int priority)\n     {\n #ifdef _POSIX_PRIORITY_SCHEDULING\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-      pthread_t thread_id = __gthrw_pthread_self ();\n+      pthread_t thread_id = __gthrw_(pthread_self) ();\n       int policy;\n       struct sched_param params;\n       int priority_min, priority_max;\n \n-      if (__gthrw_pthread_getschedparam (thread_id, &policy, &params) == 0)\n+      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)\n \t{\n-\t  if ((priority_max = __gthrw_sched_get_priority_max (policy)) == -1)\n+\t  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)\n \t    return -1;\n \n-\t  if ((priority_min = __gthrw_sched_get_priority_min (policy)) == -1)\n+\t  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)\n \t    return -1;\n \n \t  if (priority > priority_max)\n@@ -235,7 +233,7 @@ __gthread_objc_thread_set_priority (int priority)\n \t   * this should be a pointer to policy but pthread.h is universally\n \t   * at odds with this.\n \t   */\n-\t  if (__gthrw_pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)\n \t    return 0;\n \t}\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n@@ -255,7 +253,7 @@ __gthread_objc_thread_get_priority (void)\n       int policy;\n       struct sched_param params;\n \n-      if (__gthrw_pthread_getschedparam (__gthrw_pthread_self (), &policy, &params) == 0)\n+      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)\n \treturn params.sched_priority;\n       else\n \treturn -1;\n@@ -271,7 +269,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    __gthrw_sched_yield ();\n+    __gthrw_(sched_yield) ();\n }\n \n /* Terminate the current thread.  */\n@@ -280,7 +278,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    __gthrw_pthread_exit (&__objc_thread_exit_status);\n+    __gthrw_(pthread_exit) (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -291,7 +289,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) __gthrw_pthread_self ();\n+    return (objc_thread_t) __gthrw_(pthread_self) ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -301,7 +299,7 @@ static inline int\n __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_setspecific (_objc_thread_storage, value);\n+    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -314,7 +312,7 @@ static inline void *\n __gthread_objc_thread_get_data (void)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_getspecific (_objc_thread_storage);\n+    return __gthrw_(pthread_getspecific) (_objc_thread_storage);\n   else\n     return thread_local_storage;\n }\n@@ -329,7 +327,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n     {\n       mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (__gthrw_pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n+      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))\n \t{\n \t  objc_free (mutex->backend);\n \t  mutex->backend = NULL;\n@@ -350,18 +348,18 @@ __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n \n       /*\n        * Posix Threads specifically require that the thread be unlocked\n-       * for __gthrw_pthread_mutex_destroy to work.\n+       * for __gthrw_(pthread_mutex_destroy) to work.\n        */\n \n       do\n \t{\n-\t  count = __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+\t  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);\n \t  if (count < 0)\n \t    return -1;\n \t}\n       while (count);\n \n-      if (__gthrw_pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n       objc_free (mutex->backend);\n@@ -375,7 +373,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -388,7 +386,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -401,7 +399,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n+      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -419,7 +417,7 @@ __gthread_objc_condition_allocate (objc_condition_t condition)\n     {\n       condition->backend = objc_malloc (sizeof (pthread_cond_t));\n \n-      if (__gthrw_pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n+      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))\n \t{\n \t  objc_free (condition->backend);\n \t  condition->backend = NULL;\n@@ -436,7 +434,7 @@ __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      if (__gthrw_pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n+      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))\n \treturn -1;\n \n       objc_free (condition->backend);\n@@ -450,7 +448,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,\n \t\t\t      (pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n@@ -461,7 +459,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n+    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -471,7 +469,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_cond_signal ((pthread_cond_t *) condition->backend);\n+    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n@@ -482,40 +480,40 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_once (once, func);\n+    return __gthrw_(pthread_once) (once, func);\n   else\n     return -1;\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n-  return __gthrw_pthread_key_create (key, dtor);\n+  return __gthrw_(pthread_key_create) (key, dtor);\n }\n \n static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n-  return __gthrw_pthread_key_delete (key);\n+  return __gthrw_(pthread_key_delete) (key);\n }\n \n static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n-  return __gthrw_pthread_getspecific (key);\n+  return __gthrw_(pthread_getspecific) (key);\n }\n \n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return __gthrw_pthread_setspecific (key, ptr);\n+  return __gthrw_(pthread_setspecific) (key, ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_lock (mutex);\n+    return __gthrw_(pthread_mutex_lock) (mutex);\n   else\n     return 0;\n }\n@@ -524,7 +522,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_trylock (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (mutex);\n   else\n     return 0;\n }\n@@ -533,7 +531,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_pthread_mutex_unlock (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (mutex);\n   else\n     return 0;\n }\n@@ -543,19 +541,19 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n {\n   mutex->depth = 0;\n   mutex->owner = (pthread_t) 0;\n-  return __gthrw_pthread_mutex_init (&mutex->actual, NULL);\n+  return __gthrw_(pthread_mutex_init) (&mutex->actual, NULL);\n }\n \n static inline int\n __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = __gthrw_pthread_self ();\n+      pthread_t me = __gthrw_(pthread_self) ();\n \n       if (mutex->owner != me)\n \t{\n-\t  __gthrw_pthread_mutex_lock (&mutex->actual);\n+\t  __gthrw_(pthread_mutex_lock) (&mutex->actual);\n \t  mutex->owner = me;\n \t}\n \n@@ -569,11 +567,11 @@ __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      pthread_t me = __gthrw_pthread_self ();\n+      pthread_t me = __gthrw_(pthread_self) ();\n \n       if (mutex->owner != me)\n \t{\n-\t  if (__gthrw_pthread_mutex_trylock (&mutex->actual))\n+\t  if (__gthrw_(pthread_mutex_trylock) (&mutex->actual))\n \t    return 1;\n \t  mutex->owner = me;\n \t}\n@@ -591,7 +589,7 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n       if (--mutex->depth == 0)\n \t{\n \t   mutex->owner = (pthread_t) 0;\n-\t   __gthrw_pthread_mutex_unlock (&mutex->actual);\n+\t   __gthrw_(pthread_mutex_unlock) (&mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "f0d5d1e0f0a3501d7e17be0402c0c00dfc2ade69", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -58,40 +58,38 @@ typedef struct {\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n+# define __gthrw_(name) __gthrw_ ## name\n #else\n-# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n-# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n-# define __gthrw_string(x) #x\n-# define __gthrw(name) \\\n-  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+# define __gthrw(name)\n+# define __gthrw_(name) name\n #endif\n \n-__gthrw(thr_keycreate);\n-__gthrw(thr_getspecific);\n-__gthrw(thr_setspecific);\n-__gthrw(thr_create);\n+__gthrw(thr_keycreate)\n+__gthrw(thr_getspecific)\n+__gthrw(thr_setspecific)\n+__gthrw(thr_create)\n \n-__gthrw(mutex_lock);\n-__gthrw(mutex_trylock);\n-__gthrw(mutex_unlock);\n+__gthrw(mutex_lock)\n+__gthrw(mutex_trylock)\n+__gthrw(mutex_unlock)\n \n #ifdef _LIBOBJC\n-__gthrw(thr_exit);\n-__gthrw(thr_keycreate);\n-__gthrw(thr_getprio);\n-__gthrw(thr_self);\n-__gthrw(thr_setprio);\n-__gthrw(thr_yield);\n-\n-__gthrw(cond_init);\n-__gthrw(cond_destroy);\n-__gthrw(cond_wait);\n-__gthrw(cond_broadcast);\n-__gthrw(cond_signal);\n-\n-__gthrw(mutex_init);\n-__gthrw(mutex_destroy);\n+__gthrw(thr_exit)\n+__gthrw(thr_keycreate)\n+__gthrw(thr_getprio)\n+__gthrw(thr_self)\n+__gthrw(thr_setprio)\n+__gthrw(thr_yield)\n+\n+__gthrw(cond_init)\n+__gthrw(cond_destroy)\n+__gthrw(cond_wait)\n+__gthrw(cond_broadcast)\n+__gthrw(cond_signal)\n+\n+__gthrw(mutex_init)\n+__gthrw(mutex_destroy)\n #endif\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n@@ -102,7 +100,7 @@ __gthrw(mutex_destroy);\n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr = (void *) &__gthrw_thr_create;\n+  static void *const __gthread_active_ptr = (void *) &__gthrw_(thr_create);\n   return __gthread_active_ptr != 0;\n }\n \n@@ -132,7 +130,7 @@ __gthread_objc_init_thread_system (void)\n {\n   /* Initialize the thread storage key.  */\n   if (__gthread_active_p ()\n-      && __gthrw_thr_keycreate (&_objc_thread_storage, NULL) == 0)\n+      && __gthrw_(thr_keycreate) (&_objc_thread_storage, NULL) == 0)\n     return 0;\n \n   return -1;\n@@ -160,7 +158,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if (__gthrw_thr_create (NULL, 0, (void *) func, arg,\n+  if (__gthrw_(thr_create) (NULL, 0, (void *) func, arg,\n \t\t  THR_DETACHED | THR_NEW_LWP,\n \t\t  &new_thread_id) == 0)\n     thread_id = *(objc_thread_t *) &new_thread_id;\n@@ -194,7 +192,7 @@ __gthread_objc_thread_set_priority (int priority)\n     }\n \n   /* Change priority */\n-  if (__gthrw_thr_setprio (__gthrw_thr_self (), sys_priority) == 0)\n+  if (__gthrw_(thr_setprio) (__gthrw_(thr_self) (), sys_priority) == 0)\n     return 0;\n   else\n     return -1;\n@@ -209,7 +207,7 @@ __gthread_objc_thread_get_priority (void)\n   if (!__gthread_active_p ())\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n \n-  if (__gthrw_thr_getprio (__gthrw_thr_self (), &sys_priority) == 0)\n+  if (__gthrw_(thr_getprio) (__gthrw_(thr_self) (), &sys_priority) == 0)\n     {\n       if (sys_priority >= 250)\n \treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n@@ -227,7 +225,7 @@ static inline void\n __gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    __gthrw_thr_yield ();\n+    __gthrw_(thr_yield) ();\n }\n \n /* Terminate the current thread.  */\n@@ -236,7 +234,7 @@ __gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    __gthrw_thr_exit (&__objc_thread_exit_status);\n+    __gthrw_(thr_exit) (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n@@ -247,7 +245,7 @@ static inline objc_thread_t\n __gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) __gthrw_thr_self ();\n+    return (objc_thread_t) __gthrw_(thr_self) ();\n   else\n     return (objc_thread_t) 1;\n }\n@@ -258,7 +256,7 @@ __gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n     {\n-      if (__gthrw_thr_setspecific (_objc_thread_storage, value) == 0)\n+      if (__gthrw_(thr_setspecific) (_objc_thread_storage, value) == 0)\n \treturn 0;\n       else\n \treturn -1;\n@@ -278,7 +276,7 @@ __gthread_objc_thread_get_data (void)\n \n   if (__gthread_active_p ())\n     {\n-      if (__gthrw_thr_getspecific (_objc_thread_storage, &value) == 0)\n+      if (__gthrw_(thr_getspecific) (_objc_thread_storage, &value) == 0)\n \treturn value;\n       else\n \treturn NULL;\n@@ -294,7 +292,7 @@ static inline int\n __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_mutex_init ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n+      && __gthrw_(mutex_init) ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n     return -1;\n \n   return 0;\n@@ -305,7 +303,7 @@ static inline int\n __gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    __gthrw_mutex_destroy ((mutex_t *) (&(mutex->backend)));\n+    __gthrw_(mutex_destroy) ((mutex_t *) (&(mutex->backend)));\n \n   return 0;\n }\n@@ -315,7 +313,7 @@ static inline int\n __gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_mutex_lock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_(mutex_lock) ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -326,7 +324,7 @@ static inline int\n __gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_mutex_trylock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_(mutex_trylock) ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -337,7 +335,7 @@ static inline int\n __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && __gthrw_mutex_unlock ((mutex_t *) (&(mutex->backend))) != 0)\n+      && __gthrw_(mutex_unlock) ((mutex_t *) (&(mutex->backend))) != 0)\n     return -1;\n \n   return 0;\n@@ -350,7 +348,7 @@ static inline int\n __gthread_objc_condition_allocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_cond_init ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n+    return __gthrw_(cond_init) ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n \t\t      NULL);\n   else\n     return 0;\n@@ -361,7 +359,7 @@ static inline int\n __gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_cond_destroy ((cond_t *) (&(condition->backend)));\n+    return __gthrw_(cond_destroy) ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -371,7 +369,7 @@ static inline int\n __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_cond_wait ((cond_t *) (&(condition->backend)),\n+    return __gthrw_(cond_wait) ((cond_t *) (&(condition->backend)),\n \t\t      (mutex_t *) (&(mutex->backend)));\n   else\n     return 0;\n@@ -382,7 +380,7 @@ static inline int\n __gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_cond_broadcast ((cond_t *) (&(condition->backend)));\n+    return __gthrw_(cond_broadcast) ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -392,7 +390,7 @@ static inline int\n __gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_cond_signal ((cond_t *) (&(condition->backend)));\n+    return __gthrw_(cond_signal) ((cond_t *) (&(condition->backend)));\n   else\n     return 0;\n }\n@@ -410,15 +408,15 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n \n   if (once->once == 0)\n     {\n-      int status = __gthrw_mutex_lock (&once->mutex);\n+      int status = __gthrw_(mutex_lock) (&once->mutex);\n       if (status != 0)\n \treturn status;\n       if (once->once == 0)\n \t{\n \t  (*func) ();\n \t  once->once++;\n \t}\n-      __gthrw_mutex_unlock (&once->mutex);\n+      __gthrw_(mutex_unlock) (&once->mutex);\n     }\n   return 0;\n }\n@@ -429,7 +427,7 @@ __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n   /* Solaris 2.5 contains thr_* routines no-op in libc, so test if we actually\n      got a reasonable key value, and if not, fail.  */\n   *key = (__gthread_key_t)-1;\n-  if (__gthrw_thr_keycreate (key, dtor) != 0 || *key == (__gthread_key_t)-1)\n+  if (__gthrw_(thr_keycreate) (key, dtor) != 0 || *key == (__gthread_key_t)-1)\n     return -1;\n   else\n     return 0;\n@@ -446,7 +444,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   void *ptr;\n-  if (__gthrw_thr_getspecific (key, &ptr) == 0)\n+  if (__gthrw_(thr_getspecific) (key, &ptr) == 0)\n     return ptr;\n   else\n     return 0;\n@@ -455,14 +453,14 @@ __gthread_getspecific (__gthread_key_t key)\n static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n-  return __gthrw_thr_setspecific (key, (void *) ptr);\n+  return __gthrw_(thr_setspecific) (key, (void *) ptr);\n }\n \n static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_mutex_lock (mutex);\n+    return __gthrw_(mutex_lock) (mutex);\n   else\n     return 0;\n }\n@@ -471,7 +469,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_mutex_trylock (mutex);\n+    return __gthrw_(mutex_trylock) (mutex);\n   else\n     return 0;\n }\n@@ -480,7 +478,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return __gthrw_mutex_unlock (mutex);\n+    return __gthrw_(mutex_unlock) (mutex);\n   else\n     return 0;\n }\n@@ -490,19 +488,19 @@ __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n {\n   mutex->depth = 0;\n   mutex->owner = (thread_t) 0;\n-  return __gthrw_mutex_init (&mutex->actual, USYNC_THREAD, 0);\n+  return __gthrw_(mutex_init) (&mutex->actual, USYNC_THREAD, 0);\n }\n \n static inline int\n __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = __gthrw_thr_self ();\n+      thread_t me = __gthrw_(thr_self) ();\n \n       if (mutex->owner != me)\n \t{\n-\t  __gthrw_mutex_lock (&mutex->actual);\n+\t  __gthrw_(mutex_lock) (&mutex->actual);\n \t  mutex->owner = me;\n \t}\n \n@@ -516,11 +514,11 @@ __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      thread_t me = __gthrw_thr_self ();\n+      thread_t me = __gthrw_(thr_self) ();\n \n       if (mutex->owner != me)\n \t{\n-\t  if (__gthrw_mutex_trylock (&mutex->actual))\n+\t  if (__gthrw_(mutex_trylock) (&mutex->actual))\n \t    return 1;\n \t  mutex->owner = me;\n \t}\n@@ -538,7 +536,7 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n       if (--mutex->depth == 0)\n \t{\n \t   mutex->owner = (thread_t) 0;\n-\t   __gthrw_mutex_unlock (&mutex->actual);\n+\t   __gthrw_(mutex_unlock) (&mutex->actual);\n \t}\n     }\n   return 0;"}, {"sha": "e6951e1a01d82b2abf98b60b319cd60d8346aa91", "filename": "gcc/gthr-tpf.h", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-tpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b167732cdc740893b163efbc53de0a963176d7/gcc%2Fgthr-tpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-tpf.h?ref=72b167732cdc740893b163efbc53de0a963176d7", "patch": "@@ -70,25 +70,23 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)))\n+  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n+# define __gthrw_(name) __gthrw_ ## name\n #else\n-# define __gthrw_asmname(cname) __gthrw_asmnamep (__USER_LABEL_PREFIX__, cname)\n-# define __gthrw_asmnamep(prefix, cname) __gthrw_string (prefix) cname\n-# define __gthrw_string(x) #x\n-# define __gthrw(name) \\\n-  extern __typeof(name) __gthrw_ ## name __asm (__gthrw_asmname (#name))\n+# define __gthrw(name)\n+# define __gthrw_(name) name\n #endif\n \n-__gthrw(pthread_once);\n-__gthrw(pthread_key_create);\n-__gthrw(pthread_key_delete);\n-__gthrw(pthread_getspecific);\n-__gthrw(pthread_setspecific);\n-__gthrw(pthread_create);\n+__gthrw(pthread_once)\n+__gthrw(pthread_key_create)\n+__gthrw(pthread_key_delete)\n+__gthrw(pthread_getspecific)\n+__gthrw(pthread_setspecific)\n+__gthrw(pthread_create)\n \n-__gthrw(pthread_mutex_lock);\n-__gthrw(pthread_mutex_trylock);\n-__gthrw(pthread_mutex_unlock);\n+__gthrw(pthread_mutex_lock)\n+__gthrw(pthread_mutex_trylock)\n+__gthrw(pthread_mutex_unlock)\n \n static inline int\n __gthread_active_p (void)\n@@ -100,7 +98,7 @@ static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_once (once, func);\n+    return __gthrw_(pthread_once) (once, func);\n   else\n     return -1;\n }\n@@ -109,7 +107,7 @@ static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_key_create (key, dtor);\n+    return __gthrw_(pthread_key_create) (key, dtor);\n   else\n     return -1;\n }\n@@ -118,7 +116,7 @@ static inline int\n __gthread_key_delete (__gthread_key_t key)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_key_delete (key);\n+    return __gthrw_(pthread_key_delete) (key);\n   else\n     return -1;\n }\n@@ -127,7 +125,7 @@ static inline void *\n __gthread_getspecific (__gthread_key_t key)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_getspecific (key);\n+    return __gthrw_(pthread_getspecific) (key);\n   else\n     return NULL;\n }\n@@ -136,7 +134,7 @@ static inline int\n __gthread_setspecific (__gthread_key_t key, const void *ptr)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_setspecific (key, ptr);\n+    return __gthrw_(pthread_setspecific) (key, ptr);\n   else\n     return -1;\n }\n@@ -145,7 +143,7 @@ static inline int\n __gthread_mutex_lock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_mutex_lock (mutex);\n+    return __gthrw_(pthread_mutex_lock) (mutex);\n   else\n     return 0;\n }\n@@ -154,7 +152,7 @@ static inline int\n __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_mutex_trylock (mutex);\n+    return __gthrw_(pthread_mutex_trylock) (mutex);\n   else\n     return 0;\n }\n@@ -163,7 +161,7 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__tpf_pthread_active ())\n-    return __gthrw_pthread_mutex_unlock (mutex);\n+    return __gthrw_(pthread_mutex_unlock) (mutex);\n   else\n     return 0;\n }"}]}