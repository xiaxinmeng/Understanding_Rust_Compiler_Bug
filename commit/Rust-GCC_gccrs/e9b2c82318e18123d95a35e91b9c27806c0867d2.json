{"sha": "e9b2c82318e18123d95a35e91b9c27806c0867d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliMmM4MjMxOGUxODEyM2Q5NWEzNWU5MWI5YzI3ODA2YzA4NjdkMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-11-04T17:54:57Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-11-04T17:54:57Z"}, "message": "re PR c/2820 (unnamed union inside unnamed struct changes rest of the struct)\n\n\tPR c/2820\n\t* c-typeck.c (lookup_field): Rework to return a chain down to\n\tthe looked-up field.\n\t(build_component_ref): Use the new lookup_field to handle\n\tnested anonymous entities correctly.\n\n\t* testsuite/gcc.c-torture/execute/anon-1.c: New test.\n\nFrom-SVN: r46774", "tree": {"sha": "a8c85dc018f0945da2df4a02254876ffb9af0704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c85dc018f0945da2df4a02254876ffb9af0704"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b2c82318e18123d95a35e91b9c27806c0867d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b2c82318e18123d95a35e91b9c27806c0867d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b2c82318e18123d95a35e91b9c27806c0867d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b2c82318e18123d95a35e91b9c27806c0867d2/comments", "author": null, "committer": null, "parents": [{"sha": "f28274740631a5af3c5e4f1828f83b93fc1ce14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f28274740631a5af3c5e4f1828f83b93fc1ce14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f28274740631a5af3c5e4f1828f83b93fc1ce14d"}], "stats": {"total": 135, "additions": 84, "deletions": 51}, "files": [{"sha": "f5809897ce0065a1410cd40a2978381e9f924825", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9b2c82318e18123d95a35e91b9c27806c0867d2", "patch": "@@ -1,3 +1,11 @@\n+2001-11-04  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\tPR c/2820\n+\t* c-typeck.c (lookup_field): Rework to return a chain down to\n+\tthe looked-up field.\n+\t(build_component_ref): Use the new lookup_field to handle\n+\tnested anonymous entities correctly.\n+\n Sun Nov  4 11:53:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* config/sparc/sparc.c (sparc_emit_set_const32, GEN_HIGHINT64):"}, {"sha": "34c7ba8495f8812075434806a05e20917f784ac8", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e9b2c82318e18123d95a35e91b9c27806c0867d2", "patch": "@@ -55,7 +55,7 @@ static int comp_target_types\t\tPARAMS ((tree, tree));\n static int function_types_compatible_p\tPARAMS ((tree, tree));\n static int type_lists_compatible_p\tPARAMS ((tree, tree));\n static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n-static tree lookup_field\t\tPARAMS ((tree, tree, tree *));\n+static tree lookup_field\t\tPARAMS ((tree, tree));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n static tree pointer_diff\t\tPARAMS ((tree, tree));\n@@ -990,17 +990,20 @@ default_conversion (exp)\n   return exp;\n }\n \f\n-/* Look up component name in the structure type definition.\n-\n-   If this component name is found indirectly within an anonymous union,\n-   store in *INDIRECT the component which directly contains\n-   that anonymous union.  Otherwise, set *INDIRECT to 0.  */\n+/* Look up COMPONENT in a structure or union DECL.\n+\n+   If the component name is not found, returns NULL_TREE.  Otherwise,\n+   the return value is a TREE_LIST, with each TREE_VALUE a FIELD_DECL\n+   stepping down the chain to the component, which is in the last\n+   TREE_VALUE of the list.  Normally the list is of length one, but if\n+   the component is embedded within (nested) anonymous structures or\n+   unions, the list steps down the chain to the component.  */\n      \n static tree\n-lookup_field (type, component, indirect)\n-     tree type, component;\n-     tree *indirect;\n+lookup_field (decl, component)\n+     tree decl, component;\n {\n+  tree type = TREE_TYPE (decl);\n   tree field;\n \n   /* If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers\n@@ -1026,18 +1029,15 @@ lookup_field (type, component, indirect)\n \t      /* Step through all anon unions in linear fashion.  */\n \t      while (DECL_NAME (field_array[bot]) == NULL_TREE)\n \t\t{\n-\t\t  tree anon = 0, junk;\n-\n \t\t  field = field_array[bot++];\n \t\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n \t\t      || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\t\t    anon = lookup_field (TREE_TYPE (field), component, &junk);\n-\n-\t\t  if (anon != NULL_TREE)\n \t\t    {\n-\t\t      *indirect = field;\n-\t\t      return anon;\n-\t\t    }\n+\t\t      tree anon = lookup_field (field, component);\n+\n+\t\t      if (anon)\n+\t\t\treturn tree_cons (NULL_TREE, field, anon);\n+\t\t    } \n \t\t}\n \n \t      /* Entire record is only anon unions.  */\n@@ -1059,35 +1059,31 @@ lookup_field (type, component, indirect)\n       if (DECL_NAME (field_array[bot]) == component)\n \tfield = field_array[bot];\n       else if (DECL_NAME (field) != component)\n-\tfield = 0;\n+\treturn NULL_TREE;\n     }\n   else\n     {\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t{\n-\t  if (DECL_NAME (field) == NULL_TREE)\n+\t  if (DECL_NAME (field) == NULL_TREE\n+\t      && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n \t    {\n-\t      tree junk;\n-\t      tree anon = 0;\n-\n-\t      if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\t\tanon = lookup_field (TREE_TYPE (field), component, &junk);\n+\t      tree anon = lookup_field (field, component);\n \n-\t      if (anon != NULL_TREE)\n-\t\t{\n-\t\t  *indirect = field;\n-\t\t  return anon;\n-\t\t}\n+\t      if (anon)\n+\t\treturn tree_cons (NULL_TREE, field, anon);\n \t    }\n \n \t  if (DECL_NAME (field) == component)\n \t    break;\n \t}\n+\n+      if (field == NULL_TREE)\n+\treturn NULL_TREE;\n     }\n \n-  *indirect = NULL_TREE;\n-  return field;\n+  return tree_cons (NULL_TREE, field, NULL_TREE);\n }\n \n /* Make an expression to refer to the COMPONENT field of\n@@ -1126,15 +1122,13 @@ build_component_ref (datum, component)\n \n   if (code == RECORD_TYPE || code == UNION_TYPE)\n     {\n-      tree indirect = 0;\n-\n       if (!COMPLETE_TYPE_P (type))\n \t{\n \t  incomplete_type_error (NULL_TREE, type);\n \t  return error_mark_node;\n \t}\n \n-      field = lookup_field (type, component, &indirect);\n+      field = lookup_field (datum, component);\n \n       if (!field)\n \t{\n@@ -1143,29 +1137,27 @@ build_component_ref (datum, component)\n \t\t IDENTIFIER_POINTER (component));\n \t  return error_mark_node;\n \t}\n-      if (TREE_TYPE (field) == error_mark_node)\n-\treturn error_mark_node;\n \n-      /* If FIELD was found buried within an anonymous union,\n-\t make one COMPONENT_REF to get that anonymous union,\n-\t then fall thru to make a second COMPONENT_REF to get FIELD.  */\n-      if (indirect != 0)\n+      /* Chain the COMPONENT_REFs if necessary down to the FIELD.\n+\t This might be better solved in future the way the C++ front\n+\t end does it - by giving the anonymous entities each a\n+\t separate name and type, and then have build_component_ref\n+\t recursively call itself.  We can't do that here.  */\n+      for (; field; field = TREE_CHAIN (field))\n \t{\n-\t  ref = build (COMPONENT_REF, TREE_TYPE (indirect), datum, indirect);\n-\t  if (TREE_READONLY (datum) || TREE_READONLY (indirect))\n+\t  tree subdatum = TREE_VALUE (field);\n+\n+\t  if (TREE_TYPE (subdatum) == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  ref = build (COMPONENT_REF, TREE_TYPE (subdatum), datum, subdatum);\n+\t  if (TREE_READONLY (datum) || TREE_READONLY (subdatum))\n \t    TREE_READONLY (ref) = 1;\n-\t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (indirect))\n+\t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (subdatum))\n \t    TREE_THIS_VOLATILE (ref) = 1;\n \t  datum = ref;\n \t}\n \n-      ref = build (COMPONENT_REF, TREE_TYPE (field), datum, field);\n-\n-      if (TREE_READONLY (datum) || TREE_READONLY (field))\n-\tTREE_READONLY (ref) = 1;\n-      if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (field))\n-\tTREE_THIS_VOLATILE (ref) = 1;\n-\n       return ref;\n     }\n   else if (code != ERROR_MARK)"}, {"sha": "985326e596d7f535c6edd129d1716df39f4e2dd0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9b2c82318e18123d95a35e91b9c27806c0867d2", "patch": "@@ -1,3 +1,7 @@\n+2001-11-04  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* gcc.c-torture/execute/anon-1.c: New test.\n+\n 2001-11-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* g++.old-deja/g++.bugs/900227_01.C: short and pointer are the"}, {"sha": "98a9ed71d46ba6244d81cbc5f9bbc9fcd5bc5cf8", "filename": "gcc/testsuite/gcc.c-torture/execute/anon-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fanon-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b2c82318e18123d95a35e91b9c27806c0867d2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fanon-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fanon-1.c?ref=e9b2c82318e18123d95a35e91b9c27806c0867d2", "patch": "@@ -0,0 +1,29 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* Source: Neil Booth, 4 Nov 2001, derived from PR 2820 - field lookup in\n+   nested anonymous entities was broken.  */\n+\n+struct\n+{\n+  int x;\n+  struct\n+  {\n+    int a;\n+    union\n+    {\n+      int b;\n+    };\n+  };\n+} foo;\n+\n+int\n+main(int argc, char *argv[])\n+{\n+  foo.b = 6;\n+  foo.a = 5;\n+\n+  if (foo.b != 6)\n+    abort ();\n+\n+  return 0;\n+}"}]}