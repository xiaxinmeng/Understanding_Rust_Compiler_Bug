{"sha": "bcf783f48cc448e1d961ce987396922fef9a37e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmNzgzZjQ4Y2M0NDhlMWQ5NjFjZTk4NzM5NjkyMmZlZjlhMzdlNw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@tofu.to.cygnus.com", "date": "1999-11-12T20:26:29Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "1999-11-12T20:26:29Z"}, "message": "i960.h (CAN_DEBUG_WITHOUT_FP): Don't define it.\n\nFri Nov 12 15:14:19 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>\n\n\t* i960.h (CAN_DEBUG_WITHOUT_FP): Don't define it.\n\t(FRAME_POINTER_REQUIRED): Don't worry about nonlocal goto.\n\t(ELIMINABLE_REGS, CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): New.\n\t(INITIAL_FRAME_POINTER_OFFSET): Remove it.\n\n\t* i960.c (i960_function_prologue): Don't allocate space for g8-g11\n \tsaved on the stack.  Output more accurate stack frame statistics\n\tinto assembler file.\n\nFrom-SVN: r30511", "tree": {"sha": "8803bb3ec51dddadf0965562b6760215089ebb4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8803bb3ec51dddadf0965562b6760215089ebb4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcf783f48cc448e1d961ce987396922fef9a37e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf783f48cc448e1d961ce987396922fef9a37e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf783f48cc448e1d961ce987396922fef9a37e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf783f48cc448e1d961ce987396922fef9a37e7/comments", "author": null, "committer": null, "parents": [{"sha": "3ca7341a227a02de35fd77aa49efbfcc1f6a1372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca7341a227a02de35fd77aa49efbfcc1f6a1372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca7341a227a02de35fd77aa49efbfcc1f6a1372"}], "stats": {"total": 76, "additions": 52, "deletions": 24}, "files": [{"sha": "865fd396251c27ae7be9156e535997199385a9e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcf783f48cc448e1d961ce987396922fef9a37e7", "patch": "@@ -1,3 +1,14 @@\n+Fri Nov 12 15:14:19 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>\n+\n+\t* i960.h (CAN_DEBUG_WITHOUT_FP): Don't define it.\n+\t(FRAME_POINTER_REQUIRED): Don't worry about nonlocal goto.\n+\t(ELIMINABLE_REGS, CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): New.\n+\t(INITIAL_FRAME_POINTER_OFFSET): Remove it.\n+\n+\t* i960.c (i960_function_prologue): Don't allocate space for g8-g11\n+ \tsaved on the stack.  Output more accurate stack frame statistics\n+\tinto assembler file.\n+\n 1999-11-12 11:47 -0800  Zack Weinberg  <zack@bitmover.com>\n \n \t* genextract.c (record_insn_name): New function."}, {"sha": "c7dc0088d49e71805b50acd6e412c4275dd0f0d5", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=bcf783f48cc448e1d961ce987396922fef9a37e7", "patch": "@@ -1333,8 +1333,9 @@ i960_function_prologue (file, size)\n      unsigned int size;\n {\n   register int i, j, nr;\n-  int n_iregs = 0;\n-  int rsize = 0;\n+  int n_saved_regs = 0;\n+  int n_remaining_saved_regs;\n+  int lvar_size;\n   int actual_fsize, offset;\n   int gnw, lnw;\n   struct reg_group *g, *l;\n@@ -1357,11 +1358,13 @@ i960_function_prologue (file, size)\n \tregs[i] = -1;\n         /* Count global registers that need saving.  */\n \tif (i < 16)\n-\t  n_iregs++;\n+\t  n_saved_regs++;\n       }\n     else\n       regs[i] = 0;\n \n+  n_remaining_saved_regs = n_saved_regs;\n+\n   epilogue_string[0] = '\\0';\n \n   if (profile_flag || profile_block_flag)\n@@ -1397,7 +1400,7 @@ i960_function_prologue (file, size)\n \t\t    (g->length == 2) ? \"l\" : \"\"),\n \t\t   reg_names[l->start_reg], reg_names[g->start_reg]);\n \t  strcat (epilogue_string, tmpstr);\n-\t  n_iregs -= g->length;\n+\t  n_remaining_saved_regs -= g->length;\n \t  for (i = 0; i < g->length; i++)\n \t    {\n \t      regs [i + g->start_reg] = 1;\n@@ -1415,11 +1418,7 @@ i960_function_prologue (file, size)\n \tlnw = i960_split_reg_group (l, lnw, g->length);\n     }\n \n-  /* N_iregs is now the number of global registers that haven't been saved\n-     yet.  */\n-\n-  rsize = (n_iregs * 4);\n-  actual_fsize = compute_frame_size (size) + rsize;\n+  actual_fsize = compute_frame_size (size);\n #if 0\n   /* ??? The 1.2.1 compiler does this also.  This is meant to round the frame\n      size up to the nearest multiple of 16.  I don't know whether this is\n@@ -1443,11 +1442,12 @@ i960_function_prologue (file, size)\n \n   /* Take hardware register save area created by the call instruction\n      into account, but store them before the argument block area.  */\n-  offset = 64 + actual_fsize - compute_frame_size (0) - rsize;\n+  lvar_size = actual_fsize - compute_frame_size (0) - n_saved_regs * 4;\n+  offset = 64 + lvar_size;\n   /* Save registers on stack if needed.  */\n   /* ??? Is it worth to use the same algorithm as one for saving\n      global registers in local registers? */\n-  for (i = 0, j = n_iregs; j > 0 && i < 16; i++)\n+  for (i = 0, j = n_remaining_saved_regs; j > 0 && i < 16; i++)\n     {\n       if (regs[i] != -1)\n \tcontinue;\n@@ -1480,17 +1480,17 @@ i960_function_prologue (file, size)\n       offset += nr * 4;\n     }\n \n-  if (actual_fsize == 0 && size == 0 && rsize == 0)\n+  if (actual_fsize == 0)\n     return;\n \n   fprintf (file, \"\\t#Prologue stats:\\n\");\n   fprintf (file, \"\\t#  Total Frame Size: %d bytes\\n\", actual_fsize);\n \n-  if (size)\n-    fprintf (file, \"\\t#  Local Variable Size: %d bytes\\n\", size);\n-  if (rsize)\n+  if (lvar_size)\n+    fprintf (file, \"\\t#  Local Variable Size: %d bytes\\n\", lvar_size);\n+  if (n_saved_regs)\n     fprintf (file, \"\\t#  Register Save Size: %d regs, %d bytes\\n\",\n-\t     n_iregs, rsize);\n+\t     n_saved_regs, n_saved_regs * 4);\n   fprintf (file, \"\\t#End Prologue#\\n\");\n }\n "}, {"sha": "5f293366425ad076f90ecc6738afb5a6d2f0649f", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf783f48cc448e1d961ce987396922fef9a37e7/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=bcf783f48cc448e1d961ce987396922fef9a37e7", "patch": "@@ -94,8 +94,13 @@ Boston, MA 02111-1307, USA.  */\n #define LIB_SPEC \"%{!nostdlib:-lcg %{p:-lprof}%{pg:-lgprof}\\\n \t  %{mka:-lfpg}%{msa:-lfpg}%{mca:-lfpg}%{mcf:-lfpg} -lgnu}\"\n \n-/* Show we can debug even without a frame pointer.  */\n-#define CAN_DEBUG_WITHOUT_FP\n+/* Defining the macro shows we can debug even without a frame pointer.\n+   Actually, we can debug without FP.  But defining the macro results in\n+   that -O means FP elimination.  Addressing through sp requires\n+   negative offset and more one word addressing in the most cases\n+   (offsets except for 0-4095 require one more word).  Therefore we've\n+   not defined the macro. */\n+/*#define CAN_DEBUG_WITHOUT_FP*/\n \n /* Do leaf procedure and tail call optimizations for -O2 and higher.  */\n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\\\n@@ -611,18 +616,30 @@ extern int hard_regno_mode_ok ();\n    elimination messes up nonlocal goto sequences.  I think this works for other\n    targets because they use indirect jumps for the return which disables fp\n    elimination.  */\n-#define FRAME_POINTER_REQUIRED \\\n-  (! leaf_function_p () || current_function_has_nonlocal_goto)\n+#define FRAME_POINTER_REQUIRED (! leaf_function_p ())\n \n-/* C statement to store the difference between the frame pointer\n-   and the stack pointer values immediately after the function prologue.\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.. */\n+\n+#define ELIMINABLE_REGS\t {{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.  */\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+/* Define the offset between two registers, one to be eliminated, and\n+   the other its replacement, at the start of a routine.\n \n    Since the stack grows upward on the i960, this must be a negative number.\n    This includes the 64 byte hardware register save area and the size of\n    the frame.  */\n \n-#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-  do { (VAR) = - (64 + compute_frame_size (get_frame_size ())); } while (0)\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  do { (OFFSET) = - (64 + compute_frame_size (get_frame_size ())); } while (0)\n \n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 14"}]}