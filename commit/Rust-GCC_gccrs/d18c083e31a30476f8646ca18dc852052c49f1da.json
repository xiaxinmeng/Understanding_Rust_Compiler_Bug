{"sha": "d18c083e31a30476f8646ca18dc852052c49f1da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4YzA4M2UzMWEzMDQ3NmY4NjQ2Y2ExOGRjODUyMDUyYzQ5ZjFkYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-31T22:18:02Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-31T22:18:02Z"}, "message": "54th Cygnus<->FSF merge\n\nFrom-SVN: r8844", "tree": {"sha": "f30232797516174a48b1d189ad943bf779e285bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f30232797516174a48b1d189ad943bf779e285bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18c083e31a30476f8646ca18dc852052c49f1da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18c083e31a30476f8646ca18dc852052c49f1da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18c083e31a30476f8646ca18dc852052c49f1da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18c083e31a30476f8646ca18dc852052c49f1da/comments", "author": null, "committer": null, "parents": [{"sha": "f0ee2ebc3ae6f7c7bcfb01464d849b448283f6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ee2ebc3ae6f7c7bcfb01464d849b448283f6e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ee2ebc3ae6f7c7bcfb01464d849b448283f6e6"}], "stats": {"total": 483, "additions": 340, "deletions": 143}, "files": [{"sha": "7422a388d1f286a3c2b08159252ddb400b35a0b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -3,6 +3,128 @@ Wed Jan 25 15:02:09 1995  David S. Miller  (davem@nadzieja.rutgers.edu)\n \t* class.c (instantiate_type): Change error message text.\n \t* typeck2.c (store_init_value): Likewise.\n \n+Tue Jan 31 13:28:56 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (get_typeid): Pawn off error messages to build_t_desc.\n+\t(build_t_desc): Inform the user here if they try and build\n+\twith -frtti and don't include <typeinfo.h>.\n+\n+\t* decl2.c (finish_prevtable_vardecl): Support rescanning.\n+\t(finish_file): Move finish_prevtable_vardecl up to before the global\n+\tinitializers are done as tdecls are initialized in the global\n+\tinitializer.  Also Pick up any new tdecls or vtables needed by\n+\tsynthesized methods.\n+\n+\t* class.c (finish_struct): Simplify.  We have to do rtti scanning at\n+\tend, so we might as well do all of it there.\n+\n+Tue Jan 31 05:35:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Fix -fthis-is-variable for 32-bit\n+\ttargets, too.\n+\n+Tue Jan 31 00:11:04 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_prevtable_vardecl): New routine, mostly split from\n+\tfinish_vtable_vardecl.  It has the first half functionality from\n+\tthat routine.\n+\t* decl2.c (finish_vtable_vardecl): Update to not include stuff not\n+\tin  finish_prevtable_vardecl.\n+\t* decl2.c (finish_file): Call finish_prevtable_vardecl.\n+\t* gc.c (build_generic_desc): Allow it to be called when not at the\n+\tglobal binding layer, but behave as if we were.\n+\t(build_t_desc): Rearrange a bit so that it really works and is\n+\teasier to follow.\n+\t* class.c (finish_struct): Don't decide on tdecls here, as we have\n+\tto wait until the end of the file in general to decide whether or\n+\tnot they come out.\n+\n+Mon Jan 30 01:00:40 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_delete): Check access to operator delete before\n+\tcalling the destructor.\n+\t* method.c (build_opfncall, DELETE_EXPR): build_method is allowed to\n+\treturn error_mark_node.\n+\t* call.c (build_method_call): Use the one-argument op delete even if\n+\tit's an error.\n+\n+\t* init.c (build_new): Fix -fthis-is-variable support.\n+\t* call.c (build_method_call): Ditto.\n+\n+\t* call.c (convert_harshness): Make conversion from a pointer to bool\n+\tworse than conversion to another pointer.\n+\n+Sat Jan 28 16:46:10 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_new): Check new return value if -fcheck-new.\n+\n+\t* lex.c (check_newline): Clear end_of_file when we're done, too.\n+\n+Sat Jan 28 10:38:39 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Make rtti TD tables follow\n+\tvtables whereever they go.\n+\n+\t* gc.c (build_t_desc): Remove old way of setting it up, as it wasn't\n+\tright.\n+\n+Sat Jan 28 09:10:44 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Now set the\n+\tinterface/implementation of vtables on the first virtual function,\n+\tif one exists, otherwise we use the old method.  This is a major win\n+\tin terms of cutting down the size of objects and executables in\n+\tterms of text space and data space.  Now most of the savings that\n+\t#pragma interface/implementation gives is automatic in a fair number\n+\tof cases.\n+\n+Sat Jan 28 04:57:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Discard the template parameters in a\n+\ttemplate constructor declaration so that the function is always\n+\tnamed constructor_name (ctype).\n+\n+\t* lex.c (check_newline): Use ungetc to put back the character before\n+\tcalling HANDLE_PRAGMA.\n+\n+Fri Jan 27 17:23:47 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (check_classfn): If the cname is T<int> and fn_name is T,\n+\tmake sure we still match them.\n+\n+Fri Jan 27 16:32:10 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y: Add END_OF_LINE token.\n+\n+\t* lex.c (check_newline): Set linemode when we see a # directive, and\n+\tunset it when we're done.  Turn all 'return's into 'goto skipline'.\n+\tFix all uses of '\\n', since we won't see it anymore.  Put back the\n+\tcharacter we read before checking for a sysv or target pragma.\n+\t(real_yylex): If we see an EOF in linemode, return END_OF_LINE.\n+\t(handle_sysv_pragma): Don't look at the input stream; quit when we\n+\tsee an END_OF_LINE token.\n+\n+\t* input.c (getch): Return EOF if we're in line mode and at the end\n+\tof a line.\n+\t(put_back): Don't put back an EOF.\n+\n+Thu Jan 26 19:26:34 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Do the newing of the exception object\n+\tbefore we load the type descriptor or the address so that we don't\n+\twipe any of the values out.\n+\n+Thu Jan 26 19:20:00 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (init_exception_processing): Don't use r12 on the rs6000.\n+\n+Tue Jan 24 16:36:31 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (grokparms): Don't try to build up a reference at this point.\n+\n+\t* typeck2.c (build_functional_cast): Don't assume that a NOP_EXPR\n+\twill suffice to convert from integer_zero_node.\n+\n Mon Jan 23 21:57:14 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* pt.c (tsubst): When we copy a node, don't forget to copy"}, {"sha": "ee3e8bfef948e99803e13aff2f86a1b556051b1c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -309,9 +309,16 @@ convert_harshness (type, parmtype, parm)\n \n   if (codel == BOOLEAN_TYPE)\n     {\n-      if (INTEGRAL_CODE_P (coder) || coder == REAL_TYPE\n-\t  || coder == POINTER_TYPE || coder == OFFSET_TYPE)\n+      if (INTEGRAL_CODE_P (coder) || coder == REAL_TYPE)\n \treturn STD_RETURN (h);\n+      else if (coder == POINTER_TYPE || coder == OFFSET_TYPE)\n+\t{\n+\t  /* Make this worse than any conversion to another pointer.\n+\t     FIXME this is how I think the language should work, but it may not\n+\t     end up being how the language is standardized (jason 1/30/95).  */\n+\t  h.distance = 32767;\n+\t  return STD_RETURN (h);\n+\t}\n       return EVIL_RETURN (h);\n     }\n \n@@ -1547,8 +1554,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       result = build_method_call (instance, name, parms, basetype_path,\n \t\t\t\t  (LOOKUP_SPECULATIVELY|flags)\n \t\t\t\t  &~LOOKUP_COMPLAIN);\n-      /* If it works, return it. */\n-      if (result && result != error_mark_node)\n+      /* If it finds a match, return it. */\n+      if (result)\n \treturn build_method_call (instance, name, parms, basetype_path, flags);\n       /* If it doesn't work, two argument delete must work */\n       TREE_CHAIN (parms) = save_last;\n@@ -1896,9 +1903,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t{\n \t  constp = 0;\n \t  volatilep = 0;\n-\t  parms = tree_cons (NULL_TREE,\n-\t\t\t     build1 (NOP_EXPR, TYPE_POINTER_TO (basetype),\n-\t\t\t\t     integer_zero_node), parms);\n+\t  instance_ptr = build_int_2 (0, 0);\n+\t  TREE_TYPE (instance_ptr) = TYPE_POINTER_TO (basetype);\n+\t  parms = tree_cons (NULL_TREE, instance_ptr, parms);\n \t}\n       else\n \t{"}, {"sha": "ec624b9e0d93ac8cd0cbae339f4ca86467a273ab", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -4062,47 +4062,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   TYPE_BEING_DEFINED (t) = 0;\n   hack_incomplete_structures (t);\n \n-  if (flag_rtti && TYPE_VIRTUAL_P (t) && CLASSTYPE_VTABLE_NEEDS_WRITING (t))\n-    {\n-      tree variants;\n-      tree tdecl, td;\n-\n-      /* Now instantiate its type descriptors.  */\n-      td = build_t_desc (t, 1);\n-      if (td == NULL_TREE)\n-\t{\n-\t  cp_error (\"failed to build type descriptor node of '%T', maybe typeinfo.h not included\", t);\n-\t  tdecl = NULL_TREE;\n-\t}\n-      else\n-        tdecl = TREE_OPERAND (td, 0);\n-\n-#if 0\n-      /* I see no need for building the following TD */\n-      variants = TYPE_POINTER_TO (t);\n-      build_type_variant (variants, 1, 0);\n-      while (variants)\n-\t{\n-\t  build_t_desc (variants, 1);\n-\t  variants = TYPE_NEXT_VARIANT (variants);\n-\t}\n-#endif\n-      variants = build_reference_type (t);\n-      build_type_variant (variants, 1, 0);\n-      while (variants)\n-\t{\n-\t  build_t_desc (variants, 1);\n-\t  variants = TYPE_NEXT_VARIANT (variants);\n-\t}\n-      if (tdecl != NULL_TREE)\n-        DECL_CONTEXT (tdecl) = t;\n-    }\n-#if 0\n-  /* Still need to instantiate this C struct's type descriptor.  */\n-  else if (flag_rtti && ! CLASSTYPE_RTTI (t))\n-    build_t_desc (t, 1);\n-#endif\n-\n #if 0\n   if (TYPE_NAME (t) && TYPE_IDENTIFIER (t))\n     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);"}, {"sha": "1cda932726567492aa23be3893ccfdde59da7a31", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -7239,9 +7239,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      return 0;\n \t    }\n \t  innermost_code = TREE_CODE (decl);\n-\t  decl = TREE_OPERAND (decl, 0);\n \t  if (decl_context == FIELD && ctype == NULL_TREE)\n \t    ctype = current_class_type;\n+\t  if (ctype\n+\t      && TREE_OPERAND (decl, 0) == constructor_name_full (ctype))\n+\t    TREE_OPERAND (decl, 0) = constructor_name (ctype);\n+\t  decl = TREE_OPERAND (decl, 0);\n \t  if (ctype != NULL_TREE\n \t      && decl != NULL_TREE && flags != DTOR_FLAG\n \t      && decl == constructor_name (ctype))\n@@ -7335,6 +7338,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t      }\n \n+\t    if (ctype\n+\t\t&& TREE_OPERAND (decl, 1) == constructor_name_full (ctype))\n+\t      TREE_OPERAND (decl, 1) = constructor_name (ctype);\n \t    decl = TREE_OPERAND (decl, 1);\n \t    if (ctype)\n \t      {\n@@ -7346,12 +7352,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\telse if (TREE_CODE (decl) == BIT_NOT_EXPR\n \t\t\t && TREE_CODE (TREE_OPERAND (decl, 0)) == IDENTIFIER_NODE\n-\t\t\t && constructor_name (ctype) == TREE_OPERAND (decl, 0))\n+\t\t\t && (constructor_name (ctype) == TREE_OPERAND (decl, 0)\n+\t\t\t     || constructor_name_full (ctype) == TREE_OPERAND (decl, 0)))\n \t\t  {\n \t\t    return_type = return_dtor;\n \t\t    ctor_return_type = ctype;\n \t\t    flags = DTOR_FLAG;\n-\t\t    decl = TREE_OPERAND (decl, 0);\n+\t\t    decl = TREE_OPERAND (decl, 0) = constructor_name (ctype);\n \t\t  }\n \t      }\n \t  }\n@@ -9552,9 +9559,15 @@ grokparms (first_parm, funcdef_flag)\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n \n-\t\t      init = convert_for_initialization\n-\t\t\t(NULL_TREE, type, init, LOOKUP_NORMAL,\n-\t\t\t \"argument passing\", 0, 0);\n+\t\t      /* Don't actually try to build up a reference here.  */\n+\t\t      {\n+\t\t\ttree t = type;\n+\t\t\tif (TREE_CODE (t) == REFERENCE_TYPE)\n+\t\t\t  t = TREE_TYPE (t);\n+\t\t\tinit = convert_for_initialization\n+\t\t\t  (NULL_TREE, t, init, LOOKUP_NORMAL,\n+\t\t\t   \"argument passing\", 0, 0);\n+\t\t      }\n \t\t    }\n #if 0 /* This is too early to check; trailing parms might be merged in by\n \t duplicate_decls.  */"}, {"sha": "abbcead747b37baa15442ed9f0011916cc306fd0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 75, "deletions": 32, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -351,6 +351,11 @@ int flag_access_control = 1;\n \n int flag_operator_names;\n \n+/* Nonzero if we want to check the return value of new and avoid calling\n+   constructors if it is a null pointer.  */\n+\n+int flag_check_new;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -395,7 +400,8 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"access-control\", &flag_access_control, 1},\n   {\"nonansi-builtins\", &flag_no_nonansi_builtin, 0},\n   {\"gnu-keywords\", &flag_no_gnu_keywords, 0},\n-  {\"operator-names\", &flag_operator_names, 1}\n+  {\"operator-names\", &flag_operator_names, 1},\n+  {\"check-new\", &flag_check_new, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -1154,7 +1160,8 @@ check_classfn (ctype, cname, function)\n       end = TREE_VEC_END (method_vec);\n \n       /* First suss out ctors and dtors.  */\n-      if (*methods && fn_name == cname)\n+      if (*methods\n+\t  && (fn_name == cname || fn_name == DECL_NAME (*methods)))\n \tgoto got_it;\n \n       while (++methods != end)\n@@ -2430,7 +2437,7 @@ mark_vtable_entries (decl)\n     }\n }\n \n-/* Set TREE_PUBLIC and/or TREE_EXTERN on the vtable DECL,\n+/* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n    based on TYPE and other static flags.\n \n    Note that anything public is tagged TREE_PUBLIC, whether\n@@ -2472,14 +2479,14 @@ import_export_template (type)\n }\n     \n static void\n-finish_vtable_vardecl (prev, vars)\n+finish_prevtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n   import_export_vtable (vars, ctype);\n \n-  if (flag_vtable_thunks && !CLASSTYPE_INTERFACE_KNOWN (ctype))\n+  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype))\n     {\n       tree method;\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n@@ -2489,6 +2496,7 @@ finish_vtable_vardecl (prev, vars)\n \t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n \t    {\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n+\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n \t      TREE_PUBLIC (vars) = 1;\n \t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n@@ -2502,20 +2510,50 @@ finish_vtable_vardecl (prev, vars)\n     {\n       extern tree the_null_vtable_entry;\n \n-      /* Stuff this virtual function table's size into\n-\t `pfn' slot of `the_null_vtable_entry'.  */\n-#if 0\n-      /* we do not put size as first entry any more */\n-      tree nelts = array_type_nelts (TREE_TYPE (vars));\n-      if (flag_vtable_thunks)\n-\tTREE_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))) = nelts;\n-      else\n-\tSET_FNADDR_FROM_VTABLE_ENTRY (the_null_vtable_entry, nelts);\n-#endif\n-\n       /* Kick out the type descriptor before writing out the vtable.  */\n       if (flag_rtti)\n-\trest_of_decl_compilation (TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (vars)))), 0), 0, 1, 1);\n+\t{\n+\t  build_t_desc (ctype, 1);\n+\t}\n+\n+      /* Write it out.  */\n+      mark_vtable_entries (vars);\n+    }\n+}\n+    \n+static void\n+finish_vtable_vardecl (prev, vars)\n+     tree prev, vars;\n+{\n+  tree ctype = DECL_CONTEXT (vars);\n+  import_export_template (ctype);\n+  import_export_vtable (vars, ctype);\n+\n+  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype))\n+    {\n+      tree method;\n+      for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n+\t   method = DECL_NEXT_METHOD (method))\n+\t{\n+\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method)\n+\t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n+\t    {\n+\t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n+\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n+\t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n+\t      TREE_PUBLIC (vars) = 1;\n+\t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n+\t      if (flag_rtti)\n+\t\tcp_warning (\"compiler error: rtti entry for `%T' decided too late\", ctype);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (write_virtuals >= 0\n+      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n+    {\n+      extern tree the_null_vtable_entry;\n \n       /* Write it out.  */\n       mark_vtable_entries (vars);\n@@ -2714,13 +2752,31 @@ finish_file ()\n \tneeds_messing_up |= TYPE_NEEDS_CONSTRUCTING (type);\n       vars = TREE_CHAIN (vars);\n     }\n-  if (needs_cleaning == 0)\n-    goto mess_up;\n \n   /* Otherwise, GDB can get confused, because in only knows\n      about source for LINENO-1 lines.  */\n   lineno -= 1;\n \n+  interface_unknown = 1;\n+  interface_only = 0;\n+\n+  /* Walk to mark the inline functions we need, then output them so\n+     that we can pick up any other tdecls that those routines need. */\n+  walk_vtables ((void (*)())0, finish_prevtable_vardecl);\n+  for (vars = saved_inlines; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+\n+      if (DECL_ARTIFICIAL (decl)\n+\t  && ! DECL_INITIAL (decl)\n+\t  && (TREE_USED (decl) || ! DECL_EXTERNAL (decl)))\n+\tsynthesize_method (decl);\n+    }\n+  walk_vtables ((void (*)())0, finish_prevtable_vardecl);\n+\n+  if (needs_cleaning == 0)\n+    goto mess_up;\n+\n   fnname = get_file_function_name ('D');\n   start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n   fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n@@ -2950,19 +3006,6 @@ finish_file ()\n   pushdecl (vars);\n #endif\n \n-  interface_unknown = 1;\n-  interface_only = 0;\n-\n-  for (vars = saved_inlines; vars; vars = TREE_CHAIN (vars))\n-    {\n-      tree decl = TREE_VALUE (vars);\n-\n-      if (DECL_ARTIFICIAL (decl)\n-\t  && ! DECL_INITIAL (decl)\n-\t  && (TREE_USED (decl) || ! DECL_EXTERNAL (decl)))\n-\tsynthesize_method (decl);\n-    }\n-\n   walk_vtables ((void (*)())0, finish_vtable_vardecl);\n   if (flag_handle_signatures)\n     walk_sigtables ((void (*)())0, finish_sigtable_vardecl);"}, {"sha": "218818d92afae8235220271168d9aff59bc74caf", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -1528,7 +1528,6 @@ expand_throw (exp)\n      exception, so that the matching routine knows to search out.  */\n   label = gen_label_rtx ();\n   emit_label (label);\n-  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n \n   if (exp)\n     {\n@@ -1543,7 +1542,6 @@ expand_throw (exp)\n \trtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n \trtx throw_value_rtx;\n \n-\temit_move_insn (saved_throw_type, throw_type_rtx);\n \texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, error_mark_node);\n \n \t/* Make a copy of the thrown object.  WP 15.1.5  */\n@@ -1553,6 +1551,7 @@ expand_throw (exp)\n \t  error (\"  in thrown expression\");\n \tthrow_value_rtx = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \temit_move_insn (saved_throw_value, throw_value_rtx);\n+\temit_move_insn (saved_throw_type, throw_type_rtx);\n       }\n     }\n   else\n@@ -1561,6 +1560,7 @@ expand_throw (exp)\n       /* This part is easy, as we dont' have to do anything else.  */\n     }\n \n+  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n   make_first_label(throw_label);\n   emit_jump (throw_label);\n }"}, {"sha": "fd8bf2b845b70d433b0de34cbbecb1c874c0c7c0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -2787,6 +2787,8 @@ build_builtin_call (type, node, arglist)\n \n    PLACEMENT is the `placement' list for user-defined operator new ().  */\n \n+extern int flag_check_new;\n+\n tree\n build_new (placement, decl, init, use_global_new)\n      tree placement;\n@@ -2795,6 +2797,7 @@ build_new (placement, decl, init, use_global_new)\n {\n   tree type, true_type, size, rval;\n   tree nelts;\n+  tree alloc_expr;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n \n@@ -3026,6 +3029,13 @@ build_new (placement, decl, init, use_global_new)\n       TREE_CALLS_NEW (rval) = 1;\n     }\n \n+  if (flag_check_new)\n+    {\n+      if (rval)\n+\trval = save_expr (rval);\n+      alloc_expr = rval;\n+    }\n+\n   /* if rval is NULL_TREE I don't have to allocate it, but are we totally\n      sure we have some extra bytes in that case for the BI_header_size\n      cookies? And how does that interact with the code below? (mrs) */\n@@ -3081,7 +3091,7 @@ build_new (placement, decl, init, use_global_new)\n       {\n \ttree tmp = rval;\n \t\n-\tif (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE)\n+\tif (tmp && TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE)\n \t  tmp = build_indirect_ref (tmp, NULL_PTR);\n       \n \tnewrval = build_method_call (tmp, constructor_name_full (true_type),\n@@ -3176,6 +3186,14 @@ build_new (placement, decl, init, use_global_new)\n \t}\n     }\n  done:\n+\n+  if (flag_check_new && alloc_expr && rval != alloc_expr)\n+    {\n+      tree ifexp = build_binary_op (NE_EXPR, alloc_expr, integer_zero_node, 1);\n+      rval = build_conditional_expr (ifexp, rval, convert (TREE_TYPE (rval),\n+\t\t\t\t\t\t\t   integer_zero_node));\n+    }\n+\n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n     {\n       /* The type of new int [3][3] is not int *, but int [3] * */\n@@ -3572,7 +3590,18 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t\t\t\t\t    auto_delete, integer_two_node));\n \t}\n       else\n-\tpassed_auto_delete = auto_delete;\n+\t{\n+\t  if (TYPE_GETS_REG_DELETE (type))\n+\t    {\n+\t      /* Only do access checking here; we'll be calling op delete\n+                 from the destructor.  */\n+\t      tree t = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n+\t\t\t\t       size_zero_node, NULL_TREE);\n+\t      if (t == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n+\t  passed_auto_delete = auto_delete;\n+\t}\n \n       if (flags & LOOKUP_PROTECT)\n \t{"}, {"sha": "378521ec67595172d22dda062717403014a05822", "filename": "gcc/cp/input.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -128,8 +128,8 @@ feed_input (str, len, delete)\n struct pending_input *to_be_restored; /* XXX */\n extern int end_of_file;\n \n-int\n-getch ()\n+static inline int\n+sub_getch ()\n {\n   if (putback_char != -1)\n     {\n@@ -172,8 +172,25 @@ void\n put_back (ch)\n      int ch;\n {\n-  my_friendly_assert (putback_char == -1, 224);\n-  putback_char = ch;\n+  if (ch != EOF)\n+    {\n+      my_friendly_assert (putback_char == -1, 224);\n+      putback_char = ch;\n+    }\n+}\n+\n+extern int linemode;\n+\n+int\n+getch ()\n+{\n+  int ch = sub_getch ();\n+  if (linemode && ch == '\\n')\n+    {\n+      put_back (ch);\n+      ch = EOF;\n+    }\n+  return ch;\n }\n \n inline"}, {"sha": "d61de50be6a15f6fde0d206d744e29856fba263a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -2319,6 +2319,8 @@ get_last_nonwhite_on_line ()\n    If the line is a #-directive, read the entire line and return a newline.\n    Otherwise, return the line's first non-whitespace character.  */\n \n+int linemode;\n+\n int\n check_newline ()\n {\n@@ -2340,6 +2342,9 @@ check_newline ()\n       return c;\n     }\n \n+  /* Don't read beyond this line.  */\n+  linemode = 1;\n+  \n   /* Read first nonwhite char after the `#'.  */\n \n   do\n@@ -2372,7 +2377,7 @@ check_newline ()\n \t\t  && getch () == 'b'\n \t\t  && getch () == 'l'\n \t\t  && getch () == 'e'\n-\t\t  && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t\t  && ((c = getch ()) == ' ' || c == '\\t'))\n \t\t{\n \t\t  extern tree pending_vtables;\n \n@@ -2392,14 +2397,14 @@ check_newline ()\n \t\t  if (nextchar < 0)\n \t\t    nextchar = getch ();\n \t\t  c = nextchar;\n-\t\t  if (c != '\\n')\n+\t\t  if (c != EOF)\n \t\t    warning (\"trailing characters ignored\");\n \t\t}\n \t      else if (c == 'u'\n \t\t       && getch () == 'n'\n \t\t       && getch () == 'i'\n \t\t       && getch () == 't'\n-\t\t       && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t\t       && ((c = getch ()) == ' ' || c == '\\t'))\n \t\t{\n \t\t  /* More follows: it must be a string constant (unit name).  */\n \t\t  token = real_yylex ();\n@@ -2413,7 +2418,7 @@ check_newline ()\n \t\t  if (nextchar < 0)\n \t\t    nextchar = getch ();\n \t\t  c = nextchar;\n-\t\t  if (c != '\\n')\n+\t\t  if (c != EOF)\n \t\t    warning (\"trailing characters ignored\");\n \t\t}\n \t      else if (c == 'i')\n@@ -2429,15 +2434,15 @@ check_newline ()\n \t\t      && getch () == 'a'\n \t\t      && getch () == 'c'\n \t\t      && getch () == 'e'\n-\t\t      && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t\t      && ((c = getch ()) == ' ' || c == '\\t' || c == EOF))\n \t\t    {\n \t\t      int warned_already = 0;\n \t\t      char *main_filename = input_filename;\n \n \t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n \t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n-\t\t      if (c != '\\n')\n+\t\t      if (c != EOF)\n \t\t\t{\n \t\t\t  put_back (c);\n \t\t\t  token = real_yylex ();\n@@ -2455,10 +2460,10 @@ check_newline ()\n \t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n \n-\t\t      while (c != '\\n')\n+\t\t      while (c != EOF)\n \t\t\t{\n \t\t\t  if (!warned_already && extra_warnings\n-\t\t\t      && c != ' ' && c != '\\t' && c != '\\n')\n+\t\t\t      && c != ' ' && c != '\\t')\n \t\t\t    {\n \t\t\t      warning (\"garbage after `#pragma interface' ignored\");\n \t\t\t      warned_already = 1;\n@@ -2506,15 +2511,15 @@ check_newline ()\n \t\t\t   && getch () == 'i'\n \t\t\t   && getch () == 'o'\n \t\t\t   && getch () == 'n'\n-\t\t\t   && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t\t\t   && ((c = getch ()) == ' ' || c == '\\t' || c == EOF))\n \t\t    {\n \t\t      int warned_already = 0;\n \t\t      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n \n \t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n \t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n-\t\t      if (c != '\\n')\n+\t\t      if (c != EOF)\n \t\t\t{\n \t\t\t  put_back (c);\n \t\t\t  token = real_yylex ();\n@@ -2532,10 +2537,10 @@ check_newline ()\n \t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n \n-\t\t      while (c != '\\n')\n+\t\t      while (c != EOF)\n \t\t\t{\n \t\t\t  if (!warned_already && extra_warnings\n-\t\t\t      && c != ' ' && c != '\\t' && c != '\\n')\n+\t\t\t      && c != ' ' && c != '\\t')\n \t\t\t    {\n \t\t\t      warning (\"garbage after `#pragma implementation' ignored\");\n \t\t\t      warned_already = 1;\n@@ -2591,11 +2596,19 @@ check_newline ()\n \t\t}\n #ifdef HANDLE_SYSV_PRAGMA\n \t      else\n-\t\treturn handle_sysv_pragma (finput, c);\n+\t\t{\n+\t\t  put_back (c);\n+\t\t  handle_sysv_pragma ();\n+\t\t}\n #else\n #ifdef HANDLE_PRAGMA\n+\t      /* FIXME: This will break if we're doing any of the C++ input\n+                 tricks.  */\n \t      else\n-\t        HANDLE_PRAGMA (finput);\n+\t\t{\n+\t\t  ungetc (c, finput);\n+\t\t  HANDLE_PRAGMA (finput);\n+\t\t}\n #endif\n #endif\n \t    }\n@@ -2608,7 +2621,7 @@ check_newline ()\n \t      && getch () == 'i'\n \t      && getch () == 'n'\n \t      && getch () == 'e'\n-\t      && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t      && ((c = getch ()) == ' ' || c == '\\t'))\n \t    {\n #ifdef DWARF_DEBUGGING_INFO\n \t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n@@ -2624,7 +2637,7 @@ check_newline ()\n \t      && getch () == 'd'\n \t      && getch () == 'e'\n \t      && getch () == 'f'\n-\t      && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n+\t      && ((c = getch ()) == ' ' || c == '\\t'))\n \t    {\n #ifdef DWARF_DEBUGGING_INFO\n \t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n@@ -2662,8 +2675,8 @@ check_newline ()\n \t\tc = getch ();\n \n \t      /* If no argument, ignore the line.  */\n-\t      if (c == '\\n')\n-\t\treturn c;\n+\t      if (c == EOF)\n+\t\tgoto skipline;\n \n \t      put_back (c);\n \t      token = real_yylex ();\n@@ -2715,8 +2728,8 @@ check_newline ()\n \n   /* If the # is the only nonwhite char on the line,\n      just ignore it.  Check the new newline.  */\n-  if (c == '\\n')\n-    return c;\n+  if (c == EOF)\n+    goto skipline;\n \n   /* Something follows the #; read a token.  */\n \n@@ -2736,11 +2749,11 @@ check_newline ()\n \n       int l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n       c = get_last_nonwhite_on_line ();\n-      if (c == '\\n')\n+      if (c == EOF)\n \t{\n \t  /* No more: store the line number and check following line.  */\n \t  lineno = l;\n-\t  return c;\n+\t  goto skipline;\n \t}\n       put_back (c);\n \n@@ -2799,7 +2812,7 @@ check_newline ()\n       extract_interface_info ();\n \n       c = get_last_nonwhite_on_line ();\n-      if (c != '\\n')\n+      if (c != EOF)\n \t{\n \t  put_back (c);\n \n@@ -2819,7 +2832,7 @@ check_newline ()\n \t      if (action)\n \t\t{\n \t\t  c = get_last_nonwhite_on_line ();\n-\t\t  if (c != '\\n')\n+\t\t  if (c != EOF)\n \t\t    {\n \t\t      put_back (c);\n \t\t      token = real_yylex ();\n@@ -2836,7 +2849,7 @@ check_newline ()\n \t      entering_system_header = 1;\n \n \t      c = get_last_nonwhite_on_line ();\n-\t      if (c != '\\n')\n+\t      if (c != EOF)\n \t\t{\n \t\t  put_back (c);\n \t\t  token = real_yylex ();\n@@ -2852,7 +2865,7 @@ check_newline ()\n \t      entering_c_header = 1;\n \n \t      c = get_last_nonwhite_on_line ();\n-\t      if (c != '\\n')\n+\t      if (c != EOF)\n \t\t{\n \t\t  put_back (c);\n \t\t  token = real_yylex ();\n@@ -2927,16 +2940,16 @@ check_newline ()\n \t}\n \n       /* If NEXTCHAR is not end of line, we don't care what it is.  */\n-      if (nextchar == '\\n')\n-\treturn '\\n';\n+      if (nextchar == EOF)\n+\tc = EOF;\n     }\n   else\n     error (\"invalid #-line\");\n \n   /* skip the rest of this line.  */\n  skipline:\n-  if (c == '\\n')\n-    return c;\n+  linemode = 0;\n+  end_of_file = 0;\n   while ((c = getch ()) != EOF && c != '\\n');\n   return c;\n }\n@@ -3343,6 +3356,8 @@ real_yylex ()\n       end_of_file = 1;\n       if (input_redirected ())\n \tvalue = END_OF_SAVED_INPUT;\n+      else if (linemode)\n+\tvalue = END_OF_LINE;\n       else if (do_pending_expansions ())\n \t/* this will set yychar for us */\n \treturn yychar;\n@@ -4906,21 +4921,10 @@ yyerror (string)\n /* This function has to be in this file, in order to get at\n    the token types.  */\n \n-int\n-handle_sysv_pragma (input, c)\n-     FILE *input;\n-     int c;\n+handle_sysv_pragma ()\n {\n   for (;;)\n     {\n-      while (c == ' ' || c == '\\t')\n-\tc = getc (input);\n-      if (c == '\\n' || c == EOF)\n-\t{\n-\t  handle_pragma_token (0, 0);\n-\t  return c;\n-\t}\n-      ungetc (c, input);\n       switch (yylex ())\n \t{\n \tcase IDENTIFIER:\n@@ -4929,13 +4933,12 @@ handle_sysv_pragma (input, c)\n \tcase CONSTANT:\n \t  handle_pragma_token (token_buffer, yylval.ttype);\n \t  break;\n+\tcase END_OF_LINE:\n+\t  handle_pragma_token (0, 0);\n+\t  return;\n \tdefault:\n \t  handle_pragma_token (token_buffer, 0);\n \t}\n-      if (nextchar >= 0)\n-\tc = nextchar, nextchar = -1;\n-      else\n-\tc = getc (input);\n     }\n }\n #endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "5a646a51d0d2e6e9498c4c3ac476d9aaf31ab09a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -1220,10 +1220,11 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t   fnname, tree_cons (NULL_TREE, xarg1,\n \t\t\t       build_tree_list (NULL_TREE, xarg2)),\n \t   NULL_TREE, flags);\n-\t/* This happens when the user mis-declares `operator delete'.\n-\t   Should now be impossible.  */\n+#if 0\n+\t/* This can happen when operator delete is protected.  */\n \tmy_friendly_assert (rval != error_mark_node, 250);\n \tTREE_TYPE (rval) = void_type_node;\n+#endif\n \treturn rval;\n       }\n       break;"}, {"sha": "6a4420ce18b290e06e852e940b61a3d6b1db63b8", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -277,6 +277,9 @@ empty_parms ()\n \n %type <strtype> .pushlevel\n \n+/* Used in lex.c for parsing pragmas.  */\n+%token END_OF_LINE\n+\n /* spew.c depends on this being the last token.  Define\n    any new tokens before this one!  */\n %token END_OF_SAVED_INPUT"}, {"sha": "5a52fd3a1a3ecfa5c81ef85daef7e6b01a81ea02", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c083e31a30476f8646ca18dc852052c49f1da/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d18c083e31a30476f8646ca18dc852052c49f1da", "patch": "@@ -1424,7 +1424,7 @@ build_functional_cast (exp, parms)\n     {\n       /* this must build a C cast */\n       if (parms == NULL_TREE)\n-\treturn build1 (NOP_EXPR, type, integer_zero_node);\n+\tparms = integer_zero_node;\n       else if (TREE_CHAIN (parms) != NULL_TREE)\n \t{\n \t  pedwarn (\"initializer list being treated as compound expression\");"}]}