{"sha": "a2b991617429aac42a11009c9881ad216fc7dee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiOTkxNjE3NDI5YWFjNDJhMTEwMDljOTg4MWFkMjE2ZmM3ZGVlMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-11-29T22:35:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-29T22:35:51Z"}, "message": "expr.c (expand_expr_unaligned): Add more code from full case that is needed when OP0 is in a register.\n\n\t* expr.c (expand_expr_unaligned): Add more code from full case\n\tthat is needed when OP0 is in a register.\n\nFrom-SVN: r30712", "tree": {"sha": "0c46ac2da4d822c818dc5ec89d58c0e7f32f03be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c46ac2da4d822c818dc5ec89d58c0e7f32f03be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2b991617429aac42a11009c9881ad216fc7dee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b991617429aac42a11009c9881ad216fc7dee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b991617429aac42a11009c9881ad216fc7dee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b991617429aac42a11009c9881ad216fc7dee1/comments", "author": null, "committer": null, "parents": [{"sha": "b3bd7820769028ac5e5c8b1c69d1c56646a53c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bd7820769028ac5e5c8b1c69d1c56646a53c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3bd7820769028ac5e5c8b1c69d1c56646a53c99"}], "stats": {"total": 69, "additions": 65, "deletions": 4}, "files": [{"sha": "beae01eba7504b6eb408748f1d70d38628a5f9b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b991617429aac42a11009c9881ad216fc7dee1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b991617429aac42a11009c9881ad216fc7dee1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2b991617429aac42a11009c9881ad216fc7dee1", "patch": "@@ -1,3 +1,8 @@\n+Mon Nov 29 16:56:42 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_expr_unaligned): Add more code from full case\n+\tthat is needed when OP0 is in a register.\n+\n Mon Nov 29 18:09:39 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* dwarfout.c (field_byte_offset): Size can be zero if there was"}, {"sha": "bc6c93fb2bb4ea79ccae9af79f1c3a48dc833f4d", "filename": "gcc/expr.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b991617429aac42a11009c9881ad216fc7dee1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b991617429aac42a11009c9881ad216fc7dee1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a2b991617429aac42a11009c9881ad216fc7dee1", "patch": "@@ -8643,10 +8643,66 @@ expand_expr_unaligned (exp, palign)\n \t\t\t\t TYPE_MODE (integer_type_node));\n \t  }\n \n-\t/* Get a reference to just this component.  */\n-\top0 = change_address (op0, mode1,\n-\t\t\t      plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t     (bitpos / BITS_PER_UNIT)));\n+\t/* In cases where an aligned union has an unaligned object\n+\t   as a field, we might be extracting a BLKmode value from\n+\t   an integer-mode (e.g., SImode) object.  Handle this case\n+\t   by doing the extract into an object as wide as the field\n+\t   (which we know to be the width of a basic mode), then\n+\t   storing into memory, and changing the mode to BLKmode.\n+\t   If we ultimately want the address (EXPAND_CONST_ADDRESS or\n+\t   EXPAND_INITIALIZER), then we must not copy to a temporary.  */\n+\tif (mode1 == VOIDmode\n+\t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t    || (SLOW_UNALIGNED_ACCESS\n+\t\t&& (TYPE_ALIGN (type) > alignment * BITS_PER_UNIT\n+\t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n+\t  {\n+\t    enum machine_mode ext_mode = mode_for_size (bitsize, MODE_INT, 1);\n+\n+\t    if (ext_mode == BLKmode)\n+\t      {\n+\t\t/* In this case, BITPOS must start at a byte boundary.  */\n+\t\tif (GET_CODE (op0) != MEM\n+\t\t    || bitpos % BITS_PER_UNIT != 0)\n+\t\t  abort ();\n+\n+\t\top0 = change_address (op0, VOIDmode,\n+\t\t\t\t      plus_constant (XEXP (op0, 0),\n+\t\t\t\t\t\t     bitpos / BITS_PER_UNIT));\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx new = assign_stack_temp (ext_mode,\n+\t\t\t\t\t     bitsize / BITS_PER_UNIT, 0);\n+\n+\t\top0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,\n+\t\t\t\t\t unsignedp, NULL_RTX, ext_mode,\n+\t\t\t\t\t ext_mode, alignment,\n+\t\t\t\t\t int_size_in_bytes (TREE_TYPE (tem)));\n+\n+\t\t/* If the result is a record type and BITSIZE is narrower than\n+\t\t   the mode of OP0, an integral mode, and this is a big endian\n+\t\t   machine, we must put the field into the high-order bits.  */\n+\t\tif (TREE_CODE (type) == RECORD_TYPE && BYTES_BIG_ENDIAN\n+\t\t    && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n+\t\t    && bitsize < GET_MODE_BITSIZE (GET_MODE (op0)))\n+\t\t  op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n+\t\t\t\t      size_int (GET_MODE_BITSIZE\n+\t\t\t\t\t\t(GET_MODE (op0))\n+\t\t\t\t\t\t- bitsize),\n+\t\t\t\t      op0, 1);\n+\n+\n+\t\temit_move_insn (new, op0);\n+\t\top0 = copy_rtx (new);\n+\t\tPUT_MODE (op0, BLKmode);\n+\t      }\n+\t  }\n+\telse\n+\t  /* Get a reference to just this component.  */\n+\t  op0 = change_address (op0, mode1,\n+\t\t\t\t  plus_constant (XEXP (op0, 0),\n+\t\t\t\t\t\t (bitpos / BITS_PER_UNIT)));\n \n \tMEM_ALIAS_SET (op0) = get_alias_set (exp);\n "}]}