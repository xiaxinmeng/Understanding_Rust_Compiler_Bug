{"sha": "be158fc97f7f4d43d60797f2af27c86753b0ffb5", "node_id": "C_kwDOANBUbNoAKGJlMTU4ZmM5N2Y3ZjRkNDNkNjA3OTdmMmFmMjdjODY3NTNiMGZmYjU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-28T12:09:15Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-28T12:09:15Z"}, "message": "Complete refactor of generic traits handling\n\nFrom PR #1086 I introduced a new setup_associated_types2 interface which\nis used to ensure we handle the complex associated types in libcore slices\nbut this interface was inconsistant as well as the get_projected_type.\n\nThis path refactors the code base to get rid of the old\nsetup_associated_types interface in favour of this new one. It also removes\nthe get_projected_type interface which was not going to work either.\n\nFixes #1105", "tree": {"sha": "3d0f3aaef56b6190bf19ef2722add0047afce145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0f3aaef56b6190bf19ef2722add0047afce145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be158fc97f7f4d43d60797f2af27c86753b0ffb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be158fc97f7f4d43d60797f2af27c86753b0ffb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be158fc97f7f4d43d60797f2af27c86753b0ffb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be158fc97f7f4d43d60797f2af27c86753b0ffb5/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "712ae2f173df0c2d9018bf5ce708ffbbaee10d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712ae2f173df0c2d9018bf5ce708ffbbaee10d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712ae2f173df0c2d9018bf5ce708ffbbaee10d64"}], "stats": {"total": 264, "additions": 67, "deletions": 197}, "files": [{"sha": "9dc6d14d629493bde846d51de413f86d2ea269d7", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -52,6 +52,7 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \n   rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+  fntype->monomorphize ();\n \n   // items can be forward compiled which means we may not need to invoke this\n   // code. We might also have already compiled this generic function as well."}, {"sha": "969c852d5164d06b08444eadb89e590cfbf70dac", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -127,6 +127,7 @@ CompileItem::visit (HIR::Function &function)\n \t{\n \t  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t  fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  fntype->monomorphize ();\n \t}\n     }\n "}, {"sha": "55a2fffe9dd6c25327f3d8aa869d0ffccd21bd6c", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -251,21 +251,6 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      rust_assert (ok);\t\t\t\t    // found\n \t      rust_assert (trait_item_ref->is_optional ()); // has definition\n \n-\t      Analysis::NodeMapping trait_mappings\n-\t\t= trait_item_ref->get_parent_trait_mappings ();\n-\n-\t      HirId associated_impl_id;\n-\t      ok = ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n-\t\ttrait_mappings.get_hirid (), receiver, &associated_impl_id);\n-\t      rust_assert (ok);\n-\n-\t      Resolver::AssociatedImplTrait *associated = nullptr;\n-\t      bool found_associated_trait_impl\n-\t\t= ctx->get_tyctx ()->lookup_associated_trait_impl (\n-\t\t  associated_impl_id, &associated);\n-\t      rust_assert (found_associated_trait_impl);\n-\t      associated->setup_associated_types ();\n-\n \t      return CompileTraitItem::Compile (\n \t\ttrait_item_ref->get_hir_trait_item (), ctx, lookup, true,\n \t\texpr_locus);"}, {"sha": "348b9f775e82bbaaa21d126429aa15fff5841ac7", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -326,18 +326,6 @@ class PathProbeType : public TypeCheckBase\n       }\n \n     TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n-    if (impl != nullptr && !is_reciever_generic ())\n-\n-      {\n-\tHirId impl_block_id = impl->get_mappings ().get_hirid ();\n-\tAssociatedImplTrait *lookup_associated = nullptr;\n-\tbool found_impl_trait\n-\t  = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t   &lookup_associated);\n-\t// see testsuite/rust/compile/torture/traits10.rs this can be false\n-\tif (found_impl_trait)\n-\t  lookup_associated->setup_associated_types ();\n-      }\n \n     // we can substitute the Self with the receiver here\n     if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)"}, {"sha": "6eec461e8a5ed522e3d3801562c38a12cb2265af", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -454,18 +454,11 @@ class AssociatedImplTrait\n \n   TyTy::BaseType *get_self () { return self; }\n \n-  void setup_associated_types ();\n-\n-  void setup_associated_types2 (const TyTy::BaseType *self,\n-\t\t\t\tconst TyTy::TypeBoundPredicate &bound);\n+  void setup_associated_types (const TyTy::BaseType *self,\n+\t\t\t       const TyTy::TypeBoundPredicate &bound);\n \n   void reset_associated_types ();\n \n-  TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n-\t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n-\t\t\t\t      HIR::GenericArgs &trait_generics,\n-\t\t\t\t      Location expr_locus);\n-\n private:\n   TraitReference *trait;\n   HIR::ImplBlock *impl;"}, {"sha": "e7fe0e0bb90d99637045383ab3a50e994f4b54dc", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -154,29 +154,7 @@ TraitItemReference::associated_type_reset () const\n }\n \n void\n-AssociatedImplTrait::setup_associated_types ()\n-{\n-  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n-    TraitItemReference *resolved_trait_item = nullptr;\n-    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n-\t\t\t\t\t&resolved_trait_item);\n-    if (!ok)\n-      return;\n-    if (resolved_trait_item->get_trait_item_type ()\n-\t!= TraitItemReference::TraitItemType::TYPE)\n-      return;\n-\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    resolved_trait_item->associated_type_set (lookup);\n-  });\n-  iter.go ();\n-}\n-\n-void\n-AssociatedImplTrait::setup_associated_types2 (\n+AssociatedImplTrait::setup_associated_types (\n   const TyTy::BaseType *self, const TyTy::TypeBoundPredicate &bound)\n {\n   // compute the constrained impl block generic arguments based on self and the\n@@ -390,46 +368,6 @@ TraitItemReference::is_object_safe () const\n   return false;\n }\n \n-TyTy::BaseType *\n-AssociatedImplTrait::get_projected_type (\n-  const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n-  HIR::GenericArgs &trait_generics, Location expr_locus)\n-{\n-  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n-\n-  // we can substitute the Self with the receiver here\n-  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-    {\n-      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-      TyTy::SubstitutionParamMapping *param = nullptr;\n-      for (auto &param_mapping : fn->get_substs ())\n-\t{\n-\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n-\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t    {\n-\t      param = &param_mapping;\n-\t      break;\n-\t    }\n-\t}\n-      rust_assert (param != nullptr);\n-\n-      std::vector<TyTy::SubstitutionArg> mappings;\n-      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-      TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n-\t\t\t\t\t       expr_locus);\n-      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n-    }\n-\n-  if (!trait_generics.is_empty ())\n-    {\n-      trait_item_tyty\n-\t= SubstMapper::Resolve (trait_item_tyty, expr_locus, &trait_generics);\n-    }\n-\n-  return trait_item_tyty;\n-}\n-\n // rust-hir-path-probe.h\n \n void"}, {"sha": "3823c570d25e1177cc8ce35821c92d660bcbc28f", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -67,41 +67,41 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n-  // we need resolve to the impl block\n-  NodeId impl_resolved_id = UNKNOWN_NODEID;\n-  bool ok = resolver->lookup_resolved_name (\n-    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-  rust_assert (ok);\n-\n-  HirId impl_block_id;\n-  ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t     impl_resolved_id, &impl_block_id);\n-  rust_assert (ok);\n-\n-  AssociatedImplTrait *lookup_associated = nullptr;\n-  bool found_impl_trait\n-    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n-  rust_assert (found_impl_trait);\n-\n+  // lookup the associated item from the specified bound\n   HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n-\n-  const TraitItemReference *trait_item_ref = nullptr;\n-  ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n-\t\t\t\t     &trait_item_ref);\n-  if (!ok)\n+  HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n     {\n       rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n       return;\n     }\n \n-  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n-\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n-\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+  // infer the root type\n+  infered = item.get_tyty_for_receiver (root);\n \n-  lookup_associated->setup_associated_types ();\n-  infered = lookup_associated->get_projected_type (\n-    trait_item_ref, root, item_seg.get_mappings ().get_hirid (), trait_generics,\n-    item_seg.get_locus ());\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool have_associated_impl = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  if (have_associated_impl)\n+    {\n+      HirId impl_block_id;\n+      bool ok\n+\t= mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t\timpl_resolved_id, &impl_block_id);\n+      rust_assert (ok);\n+\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t &lookup_associated);\n+      if (found_impl_trait)\n+\t{\n+\t  lookup_associated->setup_associated_types (root, specified_bound);\n+\t}\n+    }\n \n   // turbo-fish segment path::<ty>\n   if (item_seg.has_generic_args ())\n@@ -119,6 +119,7 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     }\n \n   // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = expr.get_segments ().size () <= 1;\n \n@@ -348,20 +349,6 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n \t  if (impl != nullptr)\n \t    {\n-\t      AssociatedImplTrait *lookup_associated = nullptr;\n-\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n-\n-\t      // setup associated mappings if possible we might be resolving a\n-\t      // path within a default implementation of a trait function\n-\t      // see: testsuite/rust/compile/torture/traits16.rs\n-\t      if (found_impl_trait)\n-\t\tlookup_associated->setup_associated_types ();\n-\n-\t      // we need a new ty_ref_id for this trait item\n-\t      tyseg = tyseg->clone ();\n-\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\n \t      // get the associated impl block\n \t      associated_impl_block = impl;\n \t    }"}, {"sha": "bd40344aa6c9de5039a5989fbe3569d68947fcd4", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -142,31 +142,35 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n+  // get the predicate for the bound\n+  auto specified_bound\n+    = get_predicate_from_bound (*qual_path_type.get_trait ().get ());\n+  if (specified_bound.is_error ())\n+    return;\n+\n+  // inherit the bound\n+  root->inherit_bounds ({specified_bound});\n+\n+  // lookup the associated item from the specified bound\n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n-  const TraitItemReference *trait_item_ref = nullptr;\n-  bool ok\n-    = trait_ref->lookup_trait_item (item_seg->get_ident_segment ().as_string (),\n-\t\t\t\t    &trait_item_ref);\n-  if (!ok)\n+  HIR::PathIdentSegment item_seg_identifier = item_seg->get_ident_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n     {\n       rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n       return;\n     }\n \n-  // this will be the placeholder from the trait but we may be able to project\n-  // it based on the impl block\n-  translated = trait_item_ref->get_tyty ();\n-\n-  // this is the associated generics we need to potentially apply\n-  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n-\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n-\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+  // infer the root type\n+  translated = item.get_tyty_for_receiver (root);\n \n   // we need resolve to the impl block\n   NodeId impl_resolved_id = UNKNOWN_NODEID;\n   bool have_associated_impl = resolver->lookup_resolved_name (\n     qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  AssociatedImplTrait *lookup_associated = nullptr;\n   if (have_associated_impl)\n     {\n       HirId impl_block_id;\n@@ -175,30 +179,16 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \t\t\t\t\timpl_resolved_id, &impl_block_id);\n       rust_assert (ok);\n \n-      AssociatedImplTrait *lookup_associated = nullptr;\n       bool found_impl_trait\n \t= context->lookup_associated_trait_impl (impl_block_id,\n \t\t\t\t\t\t &lookup_associated);\n-      rust_assert (found_impl_trait);\n-\n-      // project\n-      lookup_associated->setup_associated_types ();\n-      translated = lookup_associated->get_projected_type (\n-\ttrait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n-\ttrait_generics, item_seg->get_locus ());\n-    }\n-\n-  if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n-    {\n-      // lets grab the actual projection type\n-      TyTy::PlaceholderType *p\n-\t= static_cast<TyTy::PlaceholderType *> (translated);\n-      if (p->can_resolve ())\n+      if (found_impl_trait)\n \t{\n-\t  translated = p->resolve ();\n+\t  lookup_associated->setup_associated_types (root, specified_bound);\n \t}\n     }\n \n+  // turbo-fish segment path::<ty>\n   if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n     {\n       HIR::TypePathSegmentGeneric &generic_seg\n@@ -222,6 +212,7 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n     }\n \n   // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = path.get_segments ().empty ();\n   if (fully_resolved)\n@@ -448,22 +439,6 @@ TypeCheckType::resolve_segments (\n \t{\n \t  resolved_node_id\n \t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\n-\t  // lookup the associated-impl-trait\n-\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t  if (impl != nullptr && !reciever_is_generic)\n-\t    {\n-\t      AssociatedImplTrait *lookup_associated = nullptr;\n-\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n-\t      rust_assert (found_impl_trait);\n-\n-\t      lookup_associated->setup_associated_types ();\n-\n-\t      // we need a new ty_ref_id for this trait item\n-\t      tyseg = tyseg->clone ();\n-\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\t    }\n \t}\n \n       if (seg->is_generic_segment ())"}, {"sha": "7302b069923d462f5615fe68db86da8e0c278648", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be158fc97f7f4d43d60797f2af27c86753b0ffb5/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=be158fc97f7f4d43d60797f2af27c86753b0ffb5", "patch": "@@ -826,22 +826,23 @@ SubstitutionRef::monomorphize ()\n \t      bool found_impl_trait\n \t\t= context->lookup_associated_trait_impl (impl_block_id,\n \t\t\t\t\t\t\t &associated);\n-\t      rust_assert (found_impl_trait);\n-\n-\t      bool found_trait\n-\t\t= specified_bound_ref->is_equal (*bound_trait_ref);\n-\t      bool found_self\n-\t\t= associated->get_self ()->can_eq (binding, false);\n-\t      if (found_trait && found_self)\n+\t      if (found_impl_trait)\n \t\t{\n-\t\t  associated_impl_trait = associated;\n-\t\t  break;\n+\t\t  bool found_trait\n+\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t\t  bool found_self\n+\t\t    = associated->get_self ()->can_eq (binding, false);\n+\t\t  if (found_trait && found_self)\n+\t\t    {\n+\t\t      associated_impl_trait = associated;\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n \n \t  if (associated_impl_trait != nullptr)\n \t    {\n-\t      associated_impl_trait->setup_associated_types2 (binding, bound);\n+\t      associated_impl_trait->setup_associated_types (binding, bound);\n \t    }\n \t}\n     }\n@@ -2974,6 +2975,7 @@ TypeCheckCallExpr::visit (ADTType &type)\n void\n TypeCheckCallExpr::visit (FnType &type)\n {\n+  type.monomorphize ();\n   if (call.num_params () != type.num_params ())\n     {\n       if (type.is_varadic ())"}]}