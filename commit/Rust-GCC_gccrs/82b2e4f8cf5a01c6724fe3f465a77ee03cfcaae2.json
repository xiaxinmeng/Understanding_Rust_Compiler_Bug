{"sha": "82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "node_id": "C_kwDOANBUbNoAKDgyYjJlNGY4Y2Y1YTAxYzY3MjRmZTNmNDY1YTc3ZWUwM2NmY2FhZTI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-19T10:06:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-19T14:01:16Z"}, "message": "libstdc++: Implement monadic operations for std::optional (P0798R8)\n\nAnother new addition to the C++23 working draft.\n\nThe new member functions of std::optional are only defined for C++23,\nbut the new members of _Optional_payload_base are defined for C++20 so\nthat they can be used in non-propagating-cache in <ranges>. The\n_Optional_payload_base::_M_construct member can also be used in\nnon-propagating-cache now, because it's constexpr since r12-4389.\n\nThere will be an LWG issue about the feature test macro, suggesting that\nwe should just bump the value of __cpp_lib_optional instead. I haven't\ndone that here, but it can be changed once consensus is reached on the\nchange.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/optional (_Optional_payload_base::_Storage): Add\n\tconstructor taking a callable function to invoke.\n\t(_Optional_payload_base::_M_apply): New function.\n\t(__cpp_lib_monadic_optional): Define for C++23.\n\t(optional::and_then, optional::transform, optional::or_else):\n\tDefine for C++23.\n\t* include/std/ranges (__detail::__cached): Remove.\n\t(__detail::__non_propagating_cache): Remove use of __cached for\n\tcontained value. Use _Optional_payload_base::_M_construct and\n\t_Optional_payload_base::_M_apply to set the contained value.\n\t* include/std/version (__cpp_lib_monadic_optional): Define.\n\t* testsuite/20_util/optional/monadic/and_then.cc: New test.\n\t* testsuite/20_util/optional/monadic/or_else.cc: New test.\n\t* testsuite/20_util/optional/monadic/or_else_neg.cc: New test.\n\t* testsuite/20_util/optional/monadic/transform.cc: New test.\n\t* testsuite/20_util/optional/monadic/version.cc: New test.", "tree": {"sha": "ebc6317967464146890f1a47aae196445dd0bb31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebc6317967464146890f1a47aae196445dd0bb31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6920d5a1a2834e9c62d441b8f4c6186b01107d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6920d5a1a2834e9c62d441b8f4c6186b01107d13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6920d5a1a2834e9c62d441b8f4c6186b01107d13"}], "stats": {"total": 613, "additions": 573, "deletions": 40}, "files": [{"sha": "eac91d3c160c931567e3b3e2658563fbf4e82699", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 177, "deletions": 5, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -1,6 +1,7 @@\n // <optional> -*- C++ -*-\n \n // Copyright (C) 2013-2021 Free Software Foundation, Inc.\n+// Copyright The GNU Toolchain Authors.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -44,6 +45,10 @@\n #include <bits/utility.h> // in_place_t\n #if __cplusplus > 201703L\n # include <compare>\n+# include <bits/invoke.h> // std::__invoke\n+#endif\n+#if __cplusplus > 202002L\n+# include <concepts>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -81,6 +86,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Tag to disengage optional objects.\n   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };\n \n+  template<typename _Fn> struct _Optional_func { _Fn& _M_f; };\n+\n   /**\n    *  @brief Exception class thrown when a disengaged optional object is\n    *  dereferenced.\n@@ -211,6 +218,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    : _M_value(__il, std::forward<_Args>(__args)...)\n \t    { }\n \n+#if __cplusplus >= 202002L\n+\t  template<typename _Fn, typename _Arg>\n+\t    constexpr\n+\t    _Storage(_Optional_func<_Fn> __f, _Arg&& __arg)\n+\t    : _M_value(std::__invoke(std::forward<_Fn>(__f._M_f),\n+\t\t\t\t     std::forward<_Arg>(__arg)))\n+\t    { }\n+#endif\n+\n \t  _Empty_byte _M_empty;\n \t  _Up _M_value;\n \t};\n@@ -232,6 +248,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    : _M_value(__il, std::forward<_Args>(__args)...)\n \t    { }\n \n+#if __cplusplus >= 202002L\n+\t  template<typename _Fn, typename _Arg>\n+\t    constexpr\n+\t    _Storage(_Optional_func<_Fn> __f, _Arg&& __arg)\n+\t    : _M_value(std::__invoke(std::forward<_Fn>(__f._M_f),\n+\t\t\t\t     std::forward<_Arg>(__arg)))\n+\t    { }\n+#endif\n+\n \t  // User-provided destructor is needed when _Up has non-trivial dtor.\n \t  _GLIBCXX20_CONSTEXPR ~_Storage() { }\n \n@@ -260,6 +285,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_payload._M_value.~_Stored_type();\n       }\n \n+#if __cplusplus >= 202002L\n+      template<typename _Fn, typename _Up>\n+\tconstexpr void\n+\t_M_apply(_Optional_func<_Fn> __f, _Up&& __x)\n+\t{\n+\t  std::construct_at(std::__addressof(this->_M_payload),\n+\t\t\t    __f, std::forward<_Up>(__x));\n+\t  _M_engaged = true;\n+\t}\n+#endif\n+\n       // The _M_get() operations have _M_engaged as a precondition.\n       // They exist to access the contained value with the appropriate\n       // const-qualification, because _M_payload has had the const removed.\n@@ -637,6 +673,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n   class optional;\n \n+  template<typename _Tp>\n+    inline constexpr bool __is_optional_v = false;\n+  template<typename _Tp>\n+    inline constexpr bool __is_optional_v<optional<_Tp>> = true;\n+\n   template<typename _Tp, typename _Up>\n     using __converts_from_optional =\n       __or_<is_constructible<_Tp, const optional<_Up>&>,\n@@ -1002,7 +1043,143 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return static_cast<_Tp>(std::forward<_Up>(__u));\n \t}\n \n+#if __cplusplus > 202002L && __cpp_lib_concepts\n+#define __cpp_lib_monadic_optional 202110L\n+\n+      // [optional.monadic]\n+\n+      template<typename _Fn> requires invocable<_Fn, _Tp&>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &\n+\t{\n+\t  using _Up = remove_cvref_t<invoke_result_t<_Fn, _Tp&>>;\n+\t  static_assert(__is_optional_v<remove_cvref_t<_Up>>);\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), **this);\n+\t  else\n+\t    return _Up();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, const _Tp&>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &\n+\t{\n+\t  using _Up = remove_cvref_t<invoke_result_t<_Fn, const _Tp&>>;\n+\t  static_assert(__is_optional_v<_Up>);\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), **this);\n+\t  else\n+\t    return _Up();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, _Tp>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &&\n+\t{\n+\t  using _Up = remove_cvref_t<invoke_result_t<_Fn, _Tp>>;\n+\t  static_assert(__is_optional_v<remove_cvref_t<_Up>>);\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(**this));\n+\t  else\n+\t    return _Up();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, const _Tp>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = remove_cvref_t<invoke_result_t<_Fn, const _Tp>>;\n+\t  static_assert(__is_optional_v<remove_cvref_t<_Up>>);\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(**this));\n+\t  else\n+\t    return _Up();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, _Tp&>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &\n+\t{\n+\t  using _Up = invoke_result_t<_Fn, _Tp&>;\n+\t  if (has_value())\n+\t    return optional<_Up>(_Optional_func<_Fn>{__f}, **this);\n+\t  else\n+\t    return optional<_Up>();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, const _Tp&>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &\n+\t{\n+\t  using _Up = invoke_result_t<_Fn, const _Tp&>;\n+\t  if (has_value())\n+\t    return optional<_Up>(_Optional_func<_Fn>{__f}, **this);\n+\t  else\n+\t    return optional<_Up>();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, _Tp>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &&\n+\t{\n+\t  using _Up = invoke_result_t<_Fn, _Tp>;\n+\t  if (has_value())\n+\t    return optional<_Up>(_Optional_func<_Fn>{__f}, std::move(**this));\n+\t  else\n+\t    return optional<_Up>();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn, const _Tp>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = invoke_result_t<_Fn, const _Tp>;\n+\t  if (has_value())\n+\t    return optional<_Up>(_Optional_func<_Fn>{__f}, std::move(**this));\n+\t  else\n+\t    return optional<_Up>();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn> && copy_constructible<_Tp>\n+\tconstexpr optional\n+\tor_else(_Fn&& __f) const&\n+\t{\n+\t  using _Up = invoke_result_t<_Fn>;\n+\t  static_assert( is_same_v<remove_cvref_t<_Up>, optional> );\n+\n+\t  if (has_value())\n+\t    return *this;\n+\t  else\n+\t    return std::forward<_Fn>(__f)();\n+\t}\n+\n+      template<typename _Fn> requires invocable<_Fn> && move_constructible<_Tp>\n+\tconstexpr optional\n+\tor_else(_Fn&& __f) &&\n+\t{\n+\t  using _Up = invoke_result_t<_Fn>;\n+\t  static_assert( is_same_v<remove_cvref_t<_Up>, optional> );\n+\n+\t  if (has_value())\n+\t    return std::move(*this);\n+\t  else\n+\t    return std::forward<_Fn>(__f)();\n+\t}\n+#endif\n+\n       _GLIBCXX20_CONSTEXPR void reset() noexcept { this->_M_reset(); }\n+\n+    private:\n+#if __cplusplus >= 202002L\n+      template<typename _Up> friend class optional;\n+\n+      template<typename _Fn, typename _Value>\n+\texplicit constexpr\n+\toptional(_Optional_func<_Fn> __f, _Value&& __v)\n+\t{\n+\t  this->_M_payload._M_apply(__f, std::forward<_Value>(__v));\n+\t}\n+#endif\n     };\n \n   template<typename _Tp>\n@@ -1241,11 +1418,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return !__rhs || __lhs >= *__rhs; }\n \n #ifdef __cpp_lib_three_way_comparison\n-  template<typename _Tp>\n-    inline constexpr bool __is_optional_v = false;\n-  template<typename _Tp>\n-    inline constexpr bool __is_optional_v<optional<_Tp>> = true;\n-\n   template<typename _Tp, typename _Up>\n     requires (!__is_optional_v<_Up>)\n       && three_way_comparable_with<_Tp, _Up>"}, {"sha": "18bd087985c030cea4fbfa5681f7b6f38898943d", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -1159,34 +1159,10 @@ namespace views::__adaptor\n \t// (such as join_view::_M_inner).\n       };\n \n-    template<typename _Tp>\n-      struct __cached\n-      {\n-\tstruct _Deref_t { };\n-\tstatic constexpr _Deref_t __deref{};\n-\n-\t// Initialize _M_t directly from the result of dereferencing __i.\n-\t// This avoids any unwanted temporary materialization that would\n-\t// occur if *__i was bound to a reference before initializing _M_t.\n-\ttemplate<typename _Iter>\n-\t  constexpr explicit\n-\t  __cached(_Deref_t, _Iter&& __i)\n-\t  : _M_t(*__i)\n-\t  { }\n-\n-\ttemplate<typename... _Args>\n-\t  constexpr explicit\n-\t  __cached(_Args&&... __args)\n-\t  : _M_t(std::forward<_Args>(__args)...)\n-\t  { }\n-\n-\t_Tp _M_t;\n-      };\n-\n     template<typename _Tp>\n       requires is_object_v<_Tp>\n       struct __non_propagating_cache<_Tp>\n-      : protected _Optional_base<__cached<_Tp>>\n+      : protected _Optional_base<_Tp>\n       {\n \t__non_propagating_cache() = default;\n \n@@ -1218,9 +1194,7 @@ namespace views::__adaptor\n \toperator=(_Tp __val)\n \t{\n \t  this->_M_reset();\n-\t  std::construct_at(std::__addressof(this->_M_payload._M_payload),\n-\t\t\t    std::in_place, std::move(__val));\n-\t  this->_M_payload._M_engaged = true;\n+\t  this->_M_payload._M_construct(std::move(__val));\n \t  return *this;\n \t}\n \n@@ -1230,22 +1204,20 @@ namespace views::__adaptor\n \n \tconstexpr _Tp&\n \toperator*() noexcept\n-\t{ return this->_M_get()._M_t; }\n+\t{ return this->_M_get(); }\n \n \tconstexpr const _Tp&\n \toperator*() const noexcept\n-\t{ return this->_M_get()._M_t; }\n+\t{ return this->_M_get(); }\n \n \ttemplate<typename _Iter>\n \t  constexpr _Tp&\n \t  _M_emplace_deref(const _Iter& __i)\n \t  {\n \t    this->_M_reset();\n-\t    // Use the special constructor of __cached<_Tp> that does *__i.\n-\t    std::construct_at(std::__addressof(this->_M_payload._M_payload),\n-\t\t\t      std::in_place, __cached<_Tp>::__deref, __i);\n-\t    this->_M_payload._M_engaged = true;\n-\t    return **this;\n+\t    auto __f = [] (auto& __x) { return *__x; };\n+\t    this->_M_payload._M_apply(_Optional_func{__f}, __i);\n+\t    return this->_M_get();\n \t  }\n       };\n "}, {"sha": "0a7b28abee64095e0c455125d8bc4552c4ba0272", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -292,6 +292,9 @@\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_is_scoped_enum 202011L\n+#if __cpp_lib_concepts\n+# define __cpp_lib_monadic_optional 202110L\n+#endif\n #define __cpp_lib_move_only_function 202110L\n #define __cpp_lib_string_contains 202011L\n #if _GLIBCXX_USE_CXX11_ABI // Only supported with cxx11-abi"}, {"sha": "02dcafe6c580b0f474ad9028594da9ee45464fb4", "filename": "libstdc++-v3/testsuite/20_util/optional/monadic/and_then.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fand_then.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fand_then.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fand_then.cc?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -0,0 +1,120 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <optional>\n+\n+#ifndef __cpp_lib_monadic_optional\n+# error \"Feature test macro for monadic optional is missing in <optional>\"\n+#elif __cpp_lib_monadic_optional < 202110L\n+# error \"Feature test macro for monadic optional has wrong value in <optional>\"\n+#endif\n+\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_and_then()\n+{\n+  std::optional<int> o;\n+  auto r = o.and_then([](int) -> std::optional<short> { throw 1; });\n+  VERIFY( !r.has_value() );\n+  static_assert( std::is_same_v<decltype(r), std::optional<short>> );\n+\n+  o = 111;\n+  r = o.and_then([](int i) -> std::optional<short> { return {i/10}; });\n+  VERIFY( *r == 11 );\n+\n+  return true;\n+}\n+\n+static_assert( test_and_then() );\n+\n+enum { CalledLvalue = 1, CalledConst = 2, PassedLvalue = 4, PassedConst = 8 };\n+\n+struct F\n+{\n+  template<typename This, typename Value>\n+    static constexpr std::optional<int>\n+    called_as()\n+    {\n+      int res = 0;\n+      if constexpr (std::is_lvalue_reference_v<This>)\n+\tres |= CalledLvalue;\n+      if constexpr (std::is_const_v<std::remove_reference_t<This>>)\n+\tres |= CalledConst;\n+\n+      if constexpr (std::is_lvalue_reference_v<Value>)\n+\tres |= PassedLvalue;\n+      if constexpr (std::is_const_v<std::remove_reference_t<Value>>)\n+\tres |= PassedConst;\n+\n+      return {res};\n+    }\n+\n+  template<typename T>\n+    constexpr std::optional<int>\n+    operator()(T&&) &\n+    { return called_as<F&, T>(); }\n+\n+  template<typename T>\n+    constexpr std::optional<int>\n+    operator()(T&&) const &\n+    { return called_as<const F&, T>(); }\n+\n+  template<typename T>\n+    constexpr std::optional<int>\n+    operator()(T&&) &&\n+    { return called_as<F, T>(); }\n+\n+  template<typename T>\n+    constexpr std::optional<int>\n+    operator()(T&&) const &&\n+    { return called_as<const F, T>(); }\n+};\n+\n+constexpr bool\n+test_forwarding()\n+{\n+  std::optional<long> o = 1;\n+  F f;\n+\n+  VERIFY( *o.and_then(f) == (PassedLvalue|CalledLvalue) );\n+  VERIFY( *o.and_then(std::move(f)) == PassedLvalue );\n+  VERIFY( *std::move(o).and_then(f) == CalledLvalue );\n+  VERIFY( *std::move(o).and_then(std::move(f)) == 0 );\n+\n+  const auto& co = o;\n+\n+  VERIFY( *co.and_then(f) == (PassedLvalue|PassedConst|CalledLvalue) );\n+  VERIFY( *co.and_then(std::move(f)) == (PassedLvalue|PassedConst) );\n+  VERIFY( *std::move(co).and_then(f) == (PassedConst|CalledLvalue) );\n+  VERIFY( *std::move(co).and_then(std::move(f)) == PassedConst );\n+\n+  const auto& cf = f;\n+\n+  VERIFY( *o.and_then(cf) == (PassedLvalue|CalledLvalue|CalledConst) );\n+  VERIFY( *o.and_then(std::move(cf)) == (PassedLvalue|CalledConst) );\n+  VERIFY( *std::move(o).and_then(cf) == (CalledLvalue|CalledConst) );\n+  VERIFY( *std::move(o).and_then(std::move(cf)) == CalledConst );\n+\n+  VERIFY( *co.and_then(cf) == (PassedLvalue|PassedConst|CalledLvalue|CalledConst) );\n+  VERIFY( *co.and_then(std::move(cf)) == (PassedLvalue|PassedConst|CalledConst) );\n+  VERIFY( *std::move(co).and_then(cf) == (PassedConst|CalledLvalue|CalledConst) );\n+  VERIFY( *std::move(co).and_then(std::move(cf)) == (PassedConst|CalledConst) );\n+\n+  o = std::nullopt;\n+\n+  VERIFY( ! o.and_then(f).has_value() );\n+  VERIFY( ! co.and_then(f).has_value() );\n+  VERIFY( ! std::move(o).and_then(f).has_value() );\n+  VERIFY( ! std::move(co).and_then(f).has_value() );\n+\n+  return true;\n+}\n+\n+static_assert( test_forwarding() );\n+\n+int main()\n+{\n+  test_and_then();\n+  test_forwarding();\n+}"}, {"sha": "05081046c8087357d2fa7e197aa1c2f7407d6463", "filename": "libstdc++-v3/testsuite/20_util/optional/monadic/or_else.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else.cc?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -0,0 +1,103 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_or_else()\n+{\n+  std::optional<int> o;\n+  auto&& r = o.or_else([]() -> std::optional<int> { return {303}; });\n+  VERIFY( !o );\n+  VERIFY( *r == 303 );\n+  static_assert( std::is_same_v<decltype(r), std::optional<int>&&> );\n+\n+  o = 808;\n+  const std::optional<int> tr = 909;\n+  auto&& r2 = o.or_else([&]() -> const auto& { return tr; });\n+  static_assert( std::is_same_v<decltype(r2), std::optional<int>&&> );\n+  VERIFY( r2 == o );\n+\n+  return true;\n+}\n+\n+static_assert( test_or_else() );\n+\n+constexpr bool\n+test_move()\n+{\n+  struct X\n+  {\n+    constexpr X() { }\n+    constexpr X(const X&) { copied = true; }\n+    constexpr X(X&& x) { moved = true; x.gone = true; }\n+\n+    bool copied = false;\n+    bool moved = false;\n+    bool gone = false;\n+  };\n+\n+  std::optional<X> o(std::in_place);\n+\n+  auto f = []{ return std::optional<X>{}; };\n+  VERIFY( o.or_else(f)->copied );\n+  VERIFY( ! o->gone );\n+\n+  VERIFY( std::move(o).or_else(f)->moved );\n+  VERIFY( o->gone );\n+\n+  struct move_only\n+  {\n+    constexpr move_only() { }\n+    constexpr move_only(move_only&&) { }\n+  };\n+\n+  std::optional<move_only> mo;\n+  // doesn't require copy\n+  std::move(mo).or_else([] { return std::optional<move_only>{}; });\n+\n+  return true;\n+}\n+\n+static_assert( test_move() );\n+\n+constexpr bool\n+test_call()\n+{\n+  struct F\n+  {\n+    constexpr std::optional<int> operator()() & { return {1}; }\n+    constexpr std::optional<int> operator()() && { return {2}; }\n+    constexpr std::optional<int> operator()() const & { return {3}; };\n+    constexpr std::optional<int> operator()() const && { return {4}; }\n+  };\n+\n+  std::optional<int> o;\n+  F f;\n+\n+  VERIFY( *o.or_else(f) == 1 );\n+  VERIFY( *std::move(o).or_else(f) == 1 );\n+\n+  VERIFY( *o.or_else(std::move(f)) == 2 );\n+  VERIFY( *std::move(o).or_else(std::move(f)) == 2 );\n+\n+  const F& cf = f;\n+\n+  VERIFY( *o.or_else(cf) == 3 );\n+  VERIFY( *std::move(o).or_else(cf) == 3 );\n+\n+  VERIFY( *o.or_else(std::move(cf)) == 4 );\n+  VERIFY( *std::move(o).or_else(std::move(cf)) == 4 );\n+\n+  return true;\n+}\n+\n+static_assert( test_call() );\n+\n+int main()\n+{\n+  test_or_else();\n+  test_move();\n+  test_call();\n+}"}, {"sha": "16e94864f3b948b97d54c657e9ea29288bc38e5a", "filename": "libstdc++-v3/testsuite/20_util/optional/monadic/or_else_neg.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2For_else_neg.cc?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <optional>\n+\n+void\n+test01()\n+{\n+  std::optional<int> o;\n+  o.or_else([&] { return o; }); // OK\n+  o.or_else([] { return std::optional<short>(); }); // { dg-error \"here\" }\n+  o.or_else([] { return 1; }); // { dg-error \"here\" }\n+  std::move(o).or_else([] { return std::optional<short>(); }); // { dg-error \"here\" }\n+  std::move(o).or_else([] { return 1; }); // { dg-error \"here\" }\n+}\n+\n+// { dg-prune-output \"static assertion failed\" }\n+\n+void\n+test02()\n+{\n+  struct move_only\n+  {\n+    move_only() { }\n+    move_only(move_only&&) { }\n+  };\n+\n+  std::optional<move_only> mo;\n+  mo.or_else([]{ return std::optional<move_only>{}; }); // { dg-error \"no matching function\" }\n+}"}, {"sha": "d01ccb2e0f23cb7851cda20c935153ab5a6a1265", "filename": "libstdc++-v3/testsuite/20_util/optional/monadic/transform.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Ftransform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Ftransform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Ftransform.cc?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -0,0 +1,123 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_transform()\n+{\n+  std::optional<int> o;\n+  auto&& r = o.transform([](int) -> unsigned { throw 1; });\n+  static_assert( std::is_same_v<decltype(r), std::optional<unsigned>&&> );\n+  VERIFY( ! r.has_value() );\n+\n+  o = 10;\n+  auto&& r2 = o.transform([](int i) -> unsigned { return i + 2u; });\n+  static_assert( std::is_same_v<decltype(r2), std::optional<unsigned>&&> );\n+  VERIFY( *r2 == 12u );\n+\n+  return true;\n+}\n+\n+static_assert( test_transform() );\n+\n+enum { CalledLvalue = 1, CalledConst = 2, PassedLvalue = 4, PassedConst = 8 };\n+\n+struct F\n+{\n+  template<typename This, typename Value>\n+    static constexpr int\n+    called_as()\n+    {\n+      int res = 0;\n+      if constexpr (std::is_lvalue_reference_v<This>)\n+\tres |= CalledLvalue;\n+      if constexpr (std::is_const_v<std::remove_reference_t<This>>)\n+\tres |= CalledConst;\n+\n+      if constexpr (std::is_lvalue_reference_v<Value>)\n+\tres |= PassedLvalue;\n+      if constexpr (std::is_const_v<std::remove_reference_t<Value>>)\n+\tres |= PassedConst;\n+\n+      return res;\n+    }\n+\n+  template<typename T>\n+    constexpr int\n+    operator()(T&&) &\n+    { return called_as<F&, T>(); }\n+\n+  template<typename T>\n+    constexpr int\n+    operator()(T&&) const &\n+    { return called_as<const F&, T>(); }\n+\n+  template<typename T>\n+    constexpr int\n+    operator()(T&&) &&\n+    { return called_as<F, T>(); }\n+\n+  template<typename T>\n+    constexpr int\n+    operator()(T&&) const &&\n+    { return called_as<const F, T>(); }\n+};\n+\n+constexpr bool\n+test_forwarding()\n+{\n+  std::optional<long> o = 1;\n+  F f;\n+\n+  VERIFY( *o.transform(f) == (PassedLvalue|CalledLvalue) );\n+  VERIFY( *o.transform(std::move(f)) == PassedLvalue );\n+  VERIFY( *std::move(o).transform(f) == CalledLvalue );\n+  VERIFY( *std::move(o).transform(std::move(f)) == 0 );\n+\n+  const auto& co = o;\n+\n+  VERIFY( *co.transform(f) == (PassedLvalue|PassedConst|CalledLvalue) );\n+  VERIFY( *co.transform(std::move(f)) == (PassedLvalue|PassedConst) );\n+  VERIFY( *std::move(co).transform(f) == (PassedConst|CalledLvalue) );\n+  VERIFY( *std::move(co).transform(std::move(f)) == PassedConst );\n+\n+  const auto& cf = f;\n+\n+  VERIFY( *o.transform(cf) == (PassedLvalue|CalledLvalue|CalledConst) );\n+  VERIFY( *o.transform(std::move(cf)) == (PassedLvalue|CalledConst) );\n+  VERIFY( *std::move(o).transform(cf) == (CalledLvalue|CalledConst) );\n+  VERIFY( *std::move(o).transform(std::move(cf)) == CalledConst );\n+\n+  VERIFY( *co.transform(cf) == (PassedLvalue|PassedConst|CalledLvalue|CalledConst) );\n+  VERIFY( *co.transform(std::move(cf)) == (PassedLvalue|PassedConst|CalledConst) );\n+  VERIFY( *std::move(co).transform(cf) == (PassedConst|CalledLvalue|CalledConst) );\n+  VERIFY( *std::move(co).transform(std::move(cf)) == (PassedConst|CalledConst) );\n+\n+  o = std::nullopt;\n+\n+  VERIFY( ! o.transform(f).has_value() );\n+  VERIFY( ! co.transform(f).has_value() );\n+  VERIFY( ! std::move(o).transform(f).has_value() );\n+  VERIFY( ! std::move(co).transform(f).has_value() );\n+\n+  return true;\n+}\n+\n+static_assert( test_forwarding() );\n+\n+constexpr bool\n+test_copy_elision()\n+{\n+  return true;\n+}\n+\n+static_assert( test_copy_elision() );\n+\n+int main()\n+{\n+  test_transform();\n+  test_forwarding();\n+  test_copy_elision();\n+}"}, {"sha": "90b2a90a5df2268138ae21e5dfefd2b1e6cf42e6", "filename": "libstdc++-v3/testsuite/20_util/optional/monadic/version.cc", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmonadic%2Fversion.cc?ref=82b2e4f8cf5a01c6724fe3f465a77ee03cfcaae2", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do preprocess { target c++23 } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_monadic_optional\n+# error \"Feature test macro for monadic optional is missing in <version>\"\n+#elif __cpp_lib_monadic_optional < 202110L\n+# error \"Feature test macro for monadic optional has wrong value in <version>\"\n+#endif"}]}