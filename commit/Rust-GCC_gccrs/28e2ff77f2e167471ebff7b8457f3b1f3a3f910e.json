{"sha": "28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlMmZmNzdmMmUxNjc0NzFlYmZmN2I4NDU3ZjNiMWYzYTNmOTEwZQ==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@TechFak.Uni-Bielefeld.DE", "date": "2007-07-02T14:56:58Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2007-07-02T14:56:58Z"}, "message": "re PR boehm-gc/21940 (boehm-gc gctest fails on Solaris 10/x86)\n\n\tPR boehm-gc/21940\n\tPR boehm-gc/21942\n\t* configure.ac (GC_SOLARIS_THREADS): Don't define on *-*-solaris*.\n\tUse alternate thread library in /usr/lib/lwp.\n\t* configure: Regenerate.\n\t* dyn_load.c: Use GC_SOLARIS_PTHREADS.\n\t* include/gc_config_macros.h (GC_SOLARIS_THREADS): Don't define.\n\t* include/private/gcconfig.h: Handle 64-bit Solaris 2/x86.\n\t(GC_SOLARIS_THREADS): Don't define.\n\t* include/private/solaris_threads.h: Remove.\n\t* pthread_support.c (GC_thr_init) [GC_SOLARIS_PTHREADS]: Determine\n\tGC_nprocs via sysconf().\n\t* Makefile.am (libgcjgc_la_SOURCES): Remove solaris_pthreads.c and\n\tsolaris_threads.c.\n\t(gctest_LDADD): Use THREADLIBS instead of THREADDLLIBS.\n\t* Makefile.in: Regenerate.\t \n\t* solaris_pthreads.c: Remove.\n\t* solaris_threads.c: Remove.\n\nFrom-SVN: r126211", "tree": {"sha": "c070d60e2b0ce4ddf54fb60be91b6eb4e926d8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c070d60e2b0ce4ddf54fb60be91b6eb4e926d8f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/comments", "author": null, "committer": null, "parents": [{"sha": "a3b7729c66c3defccbed94534a7af6cd85d70efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b7729c66c3defccbed94534a7af6cd85d70efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b7729c66c3defccbed94534a7af6cd85d70efa"}], "stats": {"total": 1283, "additions": 79, "deletions": 1204}, "files": [{"sha": "91d5838638a68185e0bac8e5703d545204de92a2", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -1,3 +1,24 @@\n+2007-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n+\n+\tPR boehm-gc/21940\n+\tPR boehm-gc/21942\n+\t* configure.ac (GC_SOLARIS_THREADS): Don't define on *-*-solaris*.\n+\tUse alternate thread library in /usr/lib/lwp.\n+\t* configure: Regenerate.\n+\t* dyn_load.c: Use GC_SOLARIS_PTHREADS.\n+\t* include/gc_config_macros.h (GC_SOLARIS_THREADS): Don't define.\n+\t* include/private/gcconfig.h: Handle 64-bit Solaris 2/x86.\n+\t(GC_SOLARIS_THREADS): Don't define.\n+\t* include/private/solaris_threads.h: Remove.\n+\t* pthread_support.c (GC_thr_init) [GC_SOLARIS_PTHREADS]: Determine\n+\tGC_nprocs via sysconf().\n+\t* Makefile.am (libgcjgc_la_SOURCES): Remove solaris_pthreads.c and\n+\tsolaris_threads.c.\n+\t(gctest_LDADD): Use THREADLIBS instead of THREADDLLIBS.\n+\t* Makefile.in: Regenerate.\t \n+\t* solaris_pthreads.c: Remove.\n+\t* solaris_threads.c: Remove.\n+\n 2007-06-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* pthread_support.c (GC_get_thread_stack_base): Handle"}, {"sha": "567d5979e5ee5c17947d221c5d2e51aa93d7c7bf", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -21,7 +21,7 @@ libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n+specific.c stubborn.c typd_mlc.c \\\n backgraph.c win32_threads.c \\\n pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n $(asm_libgcjgc_sources)\n@@ -49,7 +49,7 @@ AM_CFLAGS = @GC_CFLAGS@\n \n check_PROGRAMS = gctest\n gctest_SOURCES = tests/test.c\n-gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n+gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc\n TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc\n TESTS = gctest"}, {"sha": "db1fa0f4af8bb5d82b5d8be500c55986ada60714", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -62,9 +62,8 @@ DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../compile $(srcdir)/../ltmain.sh \\\n-\t$(srcdir)/../config.guess $(srcdir)/../config.sub\n+\t$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \\\n+\t$(srcdir)/../config.sub\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n@@ -89,17 +88,15 @@ am_libgcjgc_la_OBJECTS = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n \tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n \theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n \tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n-\treal_malloc.lo reclaim.lo solaris_pthreads.lo \\\n-\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n+\treal_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \\\n \tbackgraph.lo win32_threads.lo pthread_support.lo \\\n \tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)\n am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n \tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n \theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n \tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n-\treal_malloc.lo reclaim.lo solaris_pthreads.lo \\\n-\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n+\treal_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \\\n \tbackgraph.lo win32_threads.lo pthread_support.lo \\\n \tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)\n@@ -108,7 +105,8 @@ libgcjgc_convenience_la_OBJECTS =  \\\n am__dirstamp = $(am__leading_dot)dirstamp\n am_gctest_OBJECTS = tests/test.$(OBJEXT)\n gctest_OBJECTS = $(am_gctest_OBJECTS)\n-gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1)\n+gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1) \\\n+\t$(am__DEPENDENCIES_1)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_builddir)/include\n depcomp =\n am__depfiles_maybe =\n@@ -276,7 +274,7 @@ libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n+specific.c stubborn.c typd_mlc.c \\\n backgraph.c win32_threads.c \\\n pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n $(asm_libgcjgc_sources)\n@@ -298,7 +296,7 @@ libgcjgc_convenience_la_DEPENDENCIES = @addobjs@\n AM_CXXFLAGS = @GC_CFLAGS@\n AM_CFLAGS = @GC_CFLAGS@\n gctest_SOURCES = tests/test.c\n-gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n+gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc\n TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc\n TESTS = gctest"}, {"sha": "d499f40a6c2d9a4aa7eb2be4094f63bc7bc0a80f", "filename": "boehm-gc/configure", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -14313,15 +14313,15 @@ _ACEOF\n       \t;;\n      *-*-solaris*)\n \n-cat >>confdefs.h <<\\_ACEOF\n-#define GC_SOLARIS_THREADS 1\n-_ACEOF\n-\n-\n cat >>confdefs.h <<\\_ACEOF\n #define GC_SOLARIS_PTHREADS 1\n _ACEOF\n \n+\t# Need to use alternate thread library, otherwise gctest hangs\n+\t# on Solaris 8.\n+\tmulti_os_directory=`$CC -print-multi-os-directory`\n+\tTHREADLIBS=\"-L/usr/lib/lwp/$multi_os_directory \\\n+\t\t    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt\"\n \t;;\n      *-*-irix*)\n "}, {"sha": "29331e607d63d60452dc0788e760a0e51607f560", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -173,8 +173,12 @@ case \"$THREADS\" in\n \tTHREADLIBS=-pthread\n       \t;;\n      *-*-solaris*)\n-\tAC_DEFINE(GC_SOLARIS_THREADS,1,[support for Solaris (thr_) threads])\n \tAC_DEFINE(GC_SOLARIS_PTHREADS,1,[support for Solaris pthreads])\n+\t# Need to use alternate thread library, otherwise gctest hangs\n+\t# on Solaris 8.\n+\tmulti_os_directory=`$CC -print-multi-os-directory`\n+\tTHREADLIBS=\"-L/usr/lib/lwp/$multi_os_directory \\\n+\t\t    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt\"\n \t;;\n      *-*-irix*)\n \tAC_DEFINE(GC_IRIX_THREADS,1,[support for Irix pthreads])"}, {"sha": "27c1b07387aa6c149147050578b901c1128765f0", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -225,7 +225,7 @@ static ptr_t GC_first_common()\n \n # if defined(SUNOS4) || defined(SUNOS5DL)\n /* Add dynamic library data sections to the root set.\t\t*/\n-# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)\n+# if !defined(PCR) && !defined(GC_SOLARIS_PTHREADS) && defined(THREADS)\n #   ifndef SRC_M3\n \t--> fix mutual exclusion with dlopen\n #   endif  /* We assume M3 programs don't call dlopen for now */"}, {"sha": "0964784332bdbff03b595fe4963d78c754c5242e", "filename": "boehm-gc/include/gc_config_macros.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Finclude%2Fgc_config_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Finclude%2Fgc_config_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config_macros.h?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -72,10 +72,6 @@\n # define GC_WIN32_THREADS\n #endif\n \n-#if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n-#   define GC_SOLARIS_THREADS\n-#endif\n-\n # define __GC\n # ifndef _WIN32_WCE\n #   include <stddef.h>"}, {"sha": "288eefb5caf86aa8c2ce683ac64ea52bd3098df1", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -153,6 +153,11 @@\n #    define SUNOS5\n #    define mach_type_known\n # endif\n+# if defined(sun) && defined(__amd64)\n+#    define X86_64\n+#    define SUNOS5\n+#    define mach_type_known\n+# endif\n # if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n #    define I386\n #    define OS2\n@@ -2041,6 +2046,36 @@\n \textern char etext[];\n #\tdefine SEARCH_FOR_DATA_START\n #   endif\n+#   ifdef SUNOS5\n+#\tdefine ELF_CLASS ELFCLASS64\n+#\tdefine OS_TYPE \"SUNOS5\"\n+        extern int _etext[], _end[];\n+  \textern ptr_t GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x1000, _etext)\n+#\tdefine DATAEND (_end)\n+/*\t# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  \t*/\n+/*      but reportedly breaks under 2.8.  It appears that the stack\t*/\n+/* \tbase is a property of the executable, so this should not break\t*/\n+/* \told executables.\t\t\t\t\t\t*/\n+/*  \tHEURISTIC2 probably works, but this appears to be preferable.\t*/\n+/* #       include <sys/vm.h> */\n+/* #\tdefine STACKBOTTOM USRSTACK */\n+#\tdefine HEURISTIC2\n+#\tdefine PROC_VDB\n+#\tdefine DYNAMIC_LOADING\n+#\tif !defined(USE_MMAP) && defined(REDIRECT_MALLOC)\n+#\t    define USE_MMAP\n+\t    /* Otherwise we now use calloc.  Mmap may result in the\t*/\n+\t    /* heap interleaved with thread stacks, which can result in\t*/\n+\t    /* excessive blacklisting.  Sbrk is unusable since it\t*/\n+\t    /* doesn't interact correctly with the system malloc.\t*/\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#   endif\n # endif\n \n #if defined(LINUX) && defined(USE_MMAP)\n@@ -2186,11 +2221,6 @@\n \t\t((word*)x)[1] = 0;\n # endif /* CLEAR_DOUBLE */\n \n-\t/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */\n-# if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n-#   define GC_SOLARIS_THREADS\n-# endif\n-\n # if defined(GC_IRIX_THREADS) && !defined(IRIX5)\n \t--> inconsistent configuration\n # endif"}, {"sha": "b1f62620bd7d4f690c3151a9ccf27a8de5113955", "filename": "boehm-gc/include/private/solaris_threads.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h?ref=a3b7729c66c3defccbed94534a7af6cd85d70efa", "patch": "@@ -1,37 +0,0 @@\n-#ifdef GC_SOLARIS_THREADS\n-\n-/* The set of all known threads.  We intercept thread creation and     */\n-/* joins.  We never actually create detached threads.  We allocate all */\n-/* new thread stacks ourselves.  These allow us to maintain this       */\n-/* data structure.                                                     */\n-/* Protected by GC_thr_lock.                                           */\n-/* Some of this should be declared volatile, but that's incosnsistent  */\n-/* with some library routine declarations.  In particular, the \t       */\n-/* definition of cond_t doesn't mention volatile!                      */\n-  typedef struct GC_Thread_Rep {\n-    struct GC_Thread_Rep * next;\n-    thread_t id;\n-    word flags;\n-#      define FINISHED 1       /* Thread has exited.   */\n-#      define DETACHED 2       /* Thread is intended to be detached.   */\n-#      define CLIENT_OWNS_STACK        4\n-                               /* Stack was supplied by client.        */\n-#      define SUSPNDED 8       /* Currently suspended.\t\t\t*/\n-    \t\t\t       /* SUSPENDED is used insystem header.\t*/\n-    ptr_t stack;\n-    size_t stack_size;\n-    cond_t join_cv;\n-    void * status;\n-  } * GC_thread;\n-  extern GC_thread GC_new_thread(thread_t id);\n-\n-  extern GC_bool GC_thr_initialized;\n-  extern volatile GC_thread GC_threads[];\n-  extern size_t GC_min_stack_sz;\n-  extern size_t GC_page_sz;\n-  extern void GC_thr_init(void);\n-  extern ptr_t GC_stack_alloc(size_t * stack_size);\n-  extern void GC_stack_free(ptr_t stack, size_t size);\n-\n-# endif /* GC_SOLARIS_THREADS */\n-"}, {"sha": "8210357766c5318e100343ad0033230066dd6f74", "filename": "boehm-gc/pthread_support.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e2ff77f2e167471ebff7b8457f3b1f3a3f910e/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=28e2ff77f2e167471ebff7b8457f3b1f3a3f910e", "patch": "@@ -883,7 +883,8 @@ void GC_thr_init()\n #       if defined(GC_HPUX_THREADS)\n \t  GC_nprocs = pthread_num_processors_np();\n #       endif\n-#\tif defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS)\n+#\tif defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS) \\\n+\t   || defined(GC_SOLARIS_PTHREADS)\n \t  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);\n \t  if (GC_nprocs <= 0) GC_nprocs = 1;\n #\tendif"}, {"sha": "d604b6ec51a4673108a236422187ea4aa32c9498", "filename": "boehm-gc/solaris_pthreads.c", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=a3b7729c66c3defccbed94534a7af6cd85d70efa", "patch": "@@ -1,179 +0,0 @@\n-/* \n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Support code for Solaris threads.  Provides functionality we wish Sun\n- * had provided.  Relies on some information we probably shouldn't rely on.\n- * Modified by Peter C. for Solaris Posix Threads.\n- */\n-\n-# include \"private/gc_priv.h\"\n-\n-# if defined(GC_SOLARIS_PTHREADS)\n-# include <pthread.h>\n-# include <thread.h>\n-# include <signal.h>\n-# include <fcntl.h>\n-# include <sys/types.h>\n-# include <sys/mman.h>\n-# include <sys/time.h>\n-# include <sys/resource.h>\n-# include <sys/stat.h>\n-# include <sys/syscall.h>\n-# include <sys/procfs.h>\n-# include <sys/lwp.h>\n-# include <sys/reg.h>\n-# define _CLASSIC_XOPEN_TYPES\n-# include <unistd.h>\n-# include <errno.h>\n-# include \"private/solaris_threads.h\"\n-# include <stdio.h>\n-\n-#undef pthread_join\n-#undef pthread_create\n-\n-pthread_cond_t GC_prom_join_cv;\t\t/* Broadcast when any thread terminates\t*/\n-pthread_cond_t GC_create_cv;\t\t/* Signalled when a new undetached\t*/\n-\t\t\t\t/* thread starts.\t\t\t*/\n-\t\t\t\t\n-extern GC_bool GC_multithreaded;\n-\n-/* We use the allocation lock to protect thread-related data structures. */\n-\n-/* We stop the world using /proc primitives.  This makes some\t*/\n-/* minimal assumptions about the threads implementation.\t*/\n-/* We don't play by the rules, since the rules make this\t*/\n-/* impossible (as of Solaris 2.3).  Also note that as of\t*/\n-/* Solaris 2.3 the various thread and lwp suspension\t\t*/\n-/* primitives failed to stop threads by the time the request\t*/\n-/* is completed.\t\t\t\t\t\t*/\n-\n-\n-\n-int GC_pthread_join(pthread_t wait_for, void **status)\n-{\n-\treturn GC_thr_join((thread_t)wait_for, NULL, status);\n-}\n-\n-\n-int\n-GC_pthread_create(pthread_t *new_thread,\n-          const pthread_attr_t *attr_in,\n-          void * (*thread_execp)(void *), void *arg)\n-{\n-    int result;\n-    GC_thread t;\n-    pthread_t my_new_thread;\n-    pthread_attr_t  attr;\n-    word my_flags = 0;\n-    int  flag;\n-    void * stack = 0;\n-    size_t stack_size = 0;\n-    int    n;\n-    struct sched_param schedparam;\n-   \n-    (void)pthread_attr_init(&attr);\n-    if (attr_in != 0) {\n-\t(void)pthread_attr_getstacksize(attr_in, &stack_size);\n-\t(void)pthread_attr_getstackaddr(attr_in, &stack);\n-    }\n-\n-    LOCK();\n-    if (!GC_is_initialized) {\n-\t    GC_init_inner();\n-    }\n-    GC_multithreaded++;\n-\t    \n-    if (stack == 0) {\n-     \tif (stack_size == 0)\n-\t\tstack_size = 1048576;\n-\t\t\t  /* ^-- 1 MB (this was GC_min_stack_sz, but that\n-\t\t\t   * violates the pthread_create documentation which\n-\t\t\t   * says the default value if none is supplied is\n-\t\t\t   * 1MB) */\n-\telse\n-\t\tstack_size += thr_min_stack();\n-\n-     \tstack = (void *)GC_stack_alloc(&stack_size);\n-     \tif (stack == 0) {\n-\t    GC_multithreaded--;\n-     \t    UNLOCK();\n-\t    errno = ENOMEM;\n-     \t    return -1;\n-     \t}\n-    } else {\n-    \tmy_flags |= CLIENT_OWNS_STACK;\n-    }\n-    (void)pthread_attr_setstacksize(&attr, stack_size);\n-    (void)pthread_attr_setstackaddr(&attr, stack);\n-    if (attr_in != 0) {\n-\t(void)pthread_attr_getscope(attr_in, &n);\n-\t(void)pthread_attr_setscope(&attr, n);\n-\t(void)pthread_attr_getschedparam(attr_in, &schedparam);\n-\t(void)pthread_attr_setschedparam(&attr, &schedparam);\n-\t(void)pthread_attr_getschedpolicy(attr_in, &n);\n-\t(void)pthread_attr_setschedpolicy(&attr, n);\n-\t(void)pthread_attr_getinheritsched(attr_in, &n);\n-\t(void)pthread_attr_setinheritsched(&attr, n);\n-\n-\t(void)pthread_attr_getdetachstate(attr_in, &flag);\n-\tif (flag == PTHREAD_CREATE_DETACHED) {\n-\t\tmy_flags |= DETACHED;\n-\t}\n-\t(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n-    }\n-    /*\n-     * thr_create can call malloc(), which if redirected will\n-     * attempt to acquire the allocation lock.\n-     * Unlock here to prevent deadlock.\n-     */\n-\n-\n-#if 0\n-#ifdef I386\n-    UNLOCK();\n-#endif\n-#endif\n-    result = \n-\t    pthread_create(&my_new_thread, &attr, thread_execp, arg);\n-#if 0\n-#ifdef I386\n-    LOCK();\n-#endif\n-#endif\n-    if (result == 0) {\n-        t = GC_new_thread(my_new_thread);\n-        t -> flags = my_flags;\n-        if (!(my_flags & DETACHED)) cond_init(&(t->join_cv), USYNC_THREAD, 0);\n-        t -> stack = stack;\n-        t -> stack_size = stack_size;\n-        if (new_thread != 0) *new_thread = my_new_thread;\n-        pthread_cond_signal(&GC_create_cv);\n-    } else {\n-\t    if (!(my_flags & CLIENT_OWNS_STACK)) {\n-\t\t    GC_stack_free(stack, stack_size);\n-\t    }        \n-\t    GC_multithreaded--;\n-    }\n-    UNLOCK();\n-    pthread_attr_destroy(&attr);\n-    return(result);\n-}\n-\n-# else\n-\n-#ifndef LINT\n-  int GC_no_sunOS_pthreads;\n-#endif\n-\n-# endif /* GC_SOLARIS_PTHREADS */\n-"}, {"sha": "386736d923b4c4cb13ad1289015432382b8ddc55", "filename": "boehm-gc/solaris_threads.c", "status": "removed", "additions": 0, "deletions": 959, "changes": 959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b7729c66c3defccbed94534a7af6cd85d70efa/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=a3b7729c66c3defccbed94534a7af6cd85d70efa", "patch": "@@ -1,959 +0,0 @@\n-/* \n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Support code for Solaris threads.  Provides functionality we wish Sun\n- * had provided.  Relies on some information we probably shouldn't rely on.\n- */\n-/* Boehm, September 14, 1994 4:44 pm PDT */\n-\n-# include \"private/gc_priv.h\"\n-\n-# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)\n-# include \"private/solaris_threads.h\"\n-# include <thread.h>\n-# include <synch.h>\n-# include <signal.h>\n-# include <fcntl.h>\n-# include <sys/types.h>\n-# include <sys/mman.h>\n-# include <sys/time.h>\n-# include <sys/resource.h>\n-# include <sys/stat.h>\n-# include <sys/syscall.h>\n-# include <sys/procfs.h>\n-# include <sys/lwp.h>\n-# include <sys/reg.h>\n-# define _CLASSIC_XOPEN_TYPES\n-# include <unistd.h>\n-# include <errno.h>\n-\n-#ifdef HANDLE_FORK\n-  --> Not yet supported.  Try porting the code from linux_threads.c.\n-#endif\n-\n-/*\n- * This is the default size of the LWP arrays. If there are more LWPs\n- * than this when a stop-the-world GC happens, set_max_lwps will be\n- * called to cope.\n- * This must be higher than the number of LWPs at startup time.\n- * The threads library creates a thread early on, so the min. is 3\n- */\n-# define DEFAULT_MAX_LWPS\t4\n-\n-#undef thr_join\n-#undef thr_create\n-#undef thr_suspend\n-#undef thr_continue\n-\n-cond_t GC_prom_join_cv;\t\t/* Broadcast when any thread terminates\t*/\n-cond_t GC_create_cv;\t\t/* Signalled when a new undetached\t*/\n-\t\t\t\t/* thread starts.\t\t\t*/\n-\t\t\t\t\n-\n-#ifdef MMAP_STACKS\n-static int GC_zfd;\n-#endif /* MMAP_STACKS */\n-\n-/* We use the allocation lock to protect thread-related data structures. */\n-\n-/* We stop the world using /proc primitives.  This makes some\t*/\n-/* minimal assumptions about the threads implementation.\t*/\n-/* We don't play by the rules, since the rules make this\t*/\n-/* impossible (as of Solaris 2.3).  Also note that as of\t*/\n-/* Solaris 2.3 the various thread and lwp suspension\t\t*/\n-/* primitives failed to stop threads by the time the request\t*/\n-/* is completed.\t\t\t\t\t\t*/\n-\n-\n-static sigset_t old_mask;\n-\n-/* Sleep for n milliseconds, n < 1000\t*/\n-void GC_msec_sleep(int n)\n-{\n-    struct timespec ts;\n-                            \n-    ts.tv_sec = 0;\n-    ts.tv_nsec = 1000000*n;\n-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {\n-\tABORT(\"nanosleep failed\");\n-    }\n-}\n-/* Turn off preemption;  gross but effective.  \t\t*/\n-/* Caller has allocation lock.\t\t\t\t*/\n-/* Actually this is not needed under Solaris 2.3 and\t*/\n-/* 2.4, but hopefully that'll change.\t\t\t*/\n-void preempt_off()\n-{\n-    sigset_t set;\n-\n-    (void)sigfillset(&set);\n-    sigdelset(&set, SIGABRT);\n-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &old_mask);\n-}\n-\n-void preempt_on()\n-{\n-    syscall(SYS_sigprocmask, SIG_SETMASK, &old_mask, NULL);\n-}\n-\n-int GC_main_proc_fd = -1;\n-\n-\n-struct lwp_cache_entry {\n-    lwpid_t lc_id;\n-    int lc_descr;\t/* /proc file descriptor.\t*/\n-}  GC_lwp_cache_default[DEFAULT_MAX_LWPS];\n-\n-static int max_lwps = DEFAULT_MAX_LWPS;\n-static struct lwp_cache_entry *GC_lwp_cache = GC_lwp_cache_default;\n-\n-static prgregset_t GC_lwp_registers_default[DEFAULT_MAX_LWPS];\n-static prgregset_t *GC_lwp_registers = GC_lwp_registers_default;\n-\n-/* Return a file descriptor for the /proc entry corresponding\t*/\n-/* to the given lwp.  The file descriptor may be stale if the\t*/\n-/* lwp exited and a new one was forked.\t\t\t\t*/\n-static int open_lwp(lwpid_t id)\n-{\n-    int result;\n-    static int next_victim = 0;\n-    register int i;\n-    \n-    for (i = 0; i < max_lwps; i++) {\n-    \tif (GC_lwp_cache[i].lc_id == id) return(GC_lwp_cache[i].lc_descr);\n-    }\n-    result = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);\n-    /*\n-     * If PIOCOPENLWP fails, try closing fds in the cache until it succeeds.\n-     */\n-    if (result < 0 && errno == EMFILE) {\n-\t    for (i = 0; i < max_lwps; i++) {\n-\t\tif (GC_lwp_cache[i].lc_id != 0) {\n-        \t\t(void)syscall(SYS_close, GC_lwp_cache[i].lc_descr);\n-\t\t\tresult = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);\n-\t\t\tif (result >= 0 || (result < 0 && errno != EMFILE))\n-\t\t\t\tbreak;\n-\t\t}\n-\t    }\n-    }\n-    if (result < 0) {\n-\tif (errno == EMFILE) {\n-\t\tABORT(\"Too many open files\");\n-\t}\n-        return(-1) /* exited? */;\n-    }\n-    if (GC_lwp_cache[next_victim].lc_id != 0)\n-        (void)syscall(SYS_close, GC_lwp_cache[next_victim].lc_descr);\n-    GC_lwp_cache[next_victim].lc_id = id;\n-    GC_lwp_cache[next_victim].lc_descr = result;\n-    if (++next_victim >= max_lwps)\n-\tnext_victim = 0;\n-    return(result);\n-}\n-\n-static void uncache_lwp(lwpid_t id)\n-{\n-    register int i;\n-    \n-    for (i = 0; i < max_lwps; i++) {\n-    \tif (GC_lwp_cache[i].lc_id == id) {\n-    \t    (void)syscall(SYS_close, GC_lwp_cache[id].lc_descr);\n-    \t    GC_lwp_cache[i].lc_id = 0;\n-    \t    break;\n-    \t}\n-    }\n-}\n-\t/* Sequence of current lwp ids\t*/\n-static lwpid_t GC_current_ids_default[DEFAULT_MAX_LWPS + 1];\n-static lwpid_t *GC_current_ids = GC_current_ids_default;\n-\n-\t/* Temporary used below (can be big if large number of LWPs) */\n-static lwpid_t last_ids_default[DEFAULT_MAX_LWPS + 1];\n-static lwpid_t *last_ids = last_ids_default;\n-\n-\n-#define ROUNDUP(n)    WORDS_TO_BYTES(ROUNDED_UP_WORDS(n))\n-\n-static void set_max_lwps(GC_word n)\n-{\n-    char *mem;\n-    char *oldmem;\n-    int required_bytes = ROUNDUP(n * sizeof(struct lwp_cache_entry))\n-\t+ ROUNDUP(n * sizeof(prgregset_t))\n-\t+ ROUNDUP((n + 1) * sizeof(lwpid_t))\n-\t+ ROUNDUP((n + 1) * sizeof(lwpid_t));\n-\n-    GC_expand_hp_inner(divHBLKSZ((word)required_bytes));\n-    oldmem = mem = GC_scratch_alloc(required_bytes);\n-    if (0 == mem) ABORT(\"No space for lwp data structures\");\n-\n-    /*\n-     * We can either flush the old lwp cache or copy it over. Do the latter.\n-     */\n-    memcpy(mem, GC_lwp_cache, max_lwps * sizeof(struct lwp_cache_entry));\n-    GC_lwp_cache = (struct lwp_cache_entry*)mem;\n-    mem += ROUNDUP(n * sizeof(struct lwp_cache_entry));\n-\n-    BZERO(GC_lwp_registers, max_lwps * sizeof(GC_lwp_registers[0]));\n-    GC_lwp_registers = (prgregset_t *)mem;\n-    mem += ROUNDUP(n * sizeof(prgregset_t));\n-\n-\n-    GC_current_ids = (lwpid_t *)mem;\n-    mem += ROUNDUP((n + 1) * sizeof(lwpid_t));\n-\n-    last_ids = (lwpid_t *)mem;\n-    mem += ROUNDUP((n + 1)* sizeof(lwpid_t));\n-\n-    if (mem > oldmem + required_bytes)\n-\tABORT(\"set_max_lwps buffer overflow\");\n-\n-    max_lwps = n;\n-}\n-\n-\n-/* Stop all lwps in process.  Assumes preemption is off.\t*/\n-/* Caller has allocation lock (and any other locks he may\t*/\n-/* need).\t\t\t\t\t\t\t*/\n-static void stop_all_lwps()\n-{\n-    int lwp_fd;\n-    char buf[30];\n-    prstatus_t status;\n-    register int i;\n-    GC_bool changed;\n-    lwpid_t me = _lwp_self();\n-\n-    if (GC_main_proc_fd == -1) {\n-    \tsprintf(buf, \"/proc/%d\", getpid());\n-    \tGC_main_proc_fd = syscall(SYS_open, buf, O_RDONLY);\n-        if (GC_main_proc_fd < 0) {\n-\t\tif (errno == EMFILE)\n-\t\t\tABORT(\"/proc open failed: too many open files\");\n-\t\tGC_printf1(\"/proc open failed: errno %d\", errno);\n-\t\tabort();\n-        }\n-    }\n-    BZERO(GC_lwp_registers, sizeof (prgregset_t) * max_lwps);\n-    for (i = 0; i < max_lwps; i++)\n-\tlast_ids[i] = 0;\n-    for (;;) {\n-        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)\n-    \t    ABORT(\"Main PIOCSTATUS failed\");\n-    \tif (status.pr_nlwp < 1)\n-    \t\tABORT(\"Invalid number of lwps returned by PIOCSTATUS\");\n-    \tif (status.pr_nlwp >= max_lwps) {\n-    \t\tset_max_lwps(status.pr_nlwp*2 + 10);\n-\t\t/*\n-\t\t * The data in the old GC_current_ids and\n-\t\t * GC_lwp_registers has been trashed. Cleaning out last_ids\n-\t\t * will make sure every LWP gets re-examined.\n-\t\t */\n-        \tfor (i = 0; i < max_lwps; i++)\n-\t\t\tlast_ids[i] = 0;\n-\t\tcontinue;\n-    \t}\n-        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCLWPIDS, GC_current_ids) < 0)\n-            ABORT(\"PIOCLWPIDS failed\");\n-        changed = FALSE;\n-        for (i = 0; GC_current_ids[i] != 0 && i < max_lwps; i++) {\n-            if (GC_current_ids[i] != last_ids[i]) {\n-                changed = TRUE;\n-                if (GC_current_ids[i] != me) {\n-\t\t    /* PIOCSTOP doesn't work without a writable\t\t*/\n-\t\t    /* descriptor.  And that makes the process\t\t*/\n-\t\t    /* undebuggable.\t\t\t\t\t*/\n-                    if (_lwp_suspend(GC_current_ids[i]) < 0) {\n-                        /* Could happen if the lwp exited */\n-                        uncache_lwp(GC_current_ids[i]);\n-                        GC_current_ids[i] = me; /* ignore */\n-                    }\n-                }\n-            }\n-        }\n-        /*\n-         * In the unlikely event something does a fork between the\n-\t * PIOCSTATUS and the PIOCLWPIDS. \n-         */\n-        if (i >= max_lwps)\n-\t\tcontinue;\n-        /* All lwps in GC_current_ids != me have been suspended.  Note\t*/\n-        /* that _lwp_suspend is idempotent.\t\t\t\t*/\n-        for (i = 0; GC_current_ids[i] != 0; i++) {\n-            if (GC_current_ids[i] != last_ids[i]) {\n-                if (GC_current_ids[i] != me) {\n-                    lwp_fd = open_lwp(GC_current_ids[i]);\n-\t\t    if (lwp_fd == -1)\n-\t\t    {\n-\t\t\t    GC_current_ids[i] = me;\n-\t\t\t    continue;\n-\t\t    }\n-\t\t    /* LWP should be stopped.  Empirically it sometimes\t*/\n-\t\t    /* isn't, and more frequently the PR_STOPPED flag\t*/\n-\t\t    /* is not set.  Wait for PR_STOPPED.\t\t*/\n-                    if (syscall(SYS_ioctl, lwp_fd,\n-                                PIOCSTATUS, &status) < 0) {\n-\t\t\t/* Possible if the descriptor was stale, or */\n-\t\t\t/* we encountered the 2.3 _lwp_suspend bug. */\n-\t\t\tuncache_lwp(GC_current_ids[i]);\n-                        GC_current_ids[i] = me; /* handle next time. */\n-                    } else {\n-                        while (!(status.pr_flags & PR_STOPPED)) {\n-                            GC_msec_sleep(1);\n-\t\t\t    if (syscall(SYS_ioctl, lwp_fd,\n-\t\t\t\t    \tPIOCSTATUS, &status) < 0) {\n-                            \tABORT(\"Repeated PIOCSTATUS failed\");\n-\t\t\t    }\n-\t\t\t    if (status.pr_flags & PR_STOPPED) break;\n-\t\t\t    \n-\t\t\t    GC_msec_sleep(20);\n-\t\t\t    if (syscall(SYS_ioctl, lwp_fd,\n-\t\t\t\t    \tPIOCSTATUS, &status) < 0) {\n-                            \tABORT(\"Repeated PIOCSTATUS failed\");\n-\t\t\t    }\n-                        }\n-                        if (status.pr_who !=  GC_current_ids[i]) {\n-\t\t\t\t/* can happen if thread was on death row */\n-\t\t\t\tuncache_lwp(GC_current_ids[i]);\n-\t\t\t\tGC_current_ids[i] = me; /* handle next time. */\n-\t\t\t\tcontinue;\t\n-                        }\n-                        /* Save registers where collector can */\n-\t\t\t/* find them.\t\t\t  */\n-\t\t\t    BCOPY(status.pr_reg, GC_lwp_registers[i],\n-\t\t\t\t  sizeof (prgregset_t));\n-                    }\n-                }\n-            }\n-        }\n-        if (!changed) break;\n-        for (i = 0; i < max_lwps; i++) last_ids[i] = GC_current_ids[i];\n-    }\n-}\n-\n-/* Restart all lwps in process.  Assumes preemption is off.\t*/\n-static void restart_all_lwps()\n-{\n-    int lwp_fd;\n-    register int i;\n-    GC_bool changed;\n-    lwpid_t me = _lwp_self();\n-#   define PARANOID\n-\n-    for (i = 0; GC_current_ids[i] != 0; i++) {\n-#\tifdef PARANOID\n-\t  if (GC_current_ids[i] != me) {\n-\t    int lwp_fd = open_lwp(GC_current_ids[i]);\n-\t    prstatus_t status;\n-\t    \n-\t    if (lwp_fd < 0) ABORT(\"open_lwp failed\");\n-\t    if (syscall(SYS_ioctl, lwp_fd,\n-\t\t\tPIOCSTATUS, &status) < 0) {\n-                ABORT(\"PIOCSTATUS failed in restart_all_lwps\");\n-\t    }\n-\t    if (memcmp(status.pr_reg, GC_lwp_registers[i],\n-\t\t       sizeof (prgregset_t)) != 0) {\n-\t\t    int j;\n-\n-\t\t    for(j = 0; j < NPRGREG; j++)\n-\t\t    {\n-\t\t\t    GC_printf3(\"%i: %x -> %x\\n\", j,\n-\t\t\t\t       GC_lwp_registers[i][j],\n-\t\t\t\t       status.pr_reg[j]);\n-\t\t    }\n-\t\tABORT(\"Register contents changed\");\n-\t    }\n-\t    if (!status.pr_flags & PR_STOPPED) {\n-\t    \tABORT(\"lwp no longer stopped\");\n-\t    }\n-#ifdef SPARC\n-\t    {\n-\t\t    gwindows_t windows;\n-\t      if (syscall(SYS_ioctl, lwp_fd,\n-\t\t\tPIOCGWIN, &windows) < 0) {\n-                ABORT(\"PIOCSTATUS failed in restart_all_lwps\");\n-\t      }\n-\t      if (windows.wbcnt > 0) ABORT(\"unsaved register windows\");\n-\t    }\n-#endif\n-\t  }\n-#\tendif /* PARANOID */\n-\tif (GC_current_ids[i] == me) continue;\n-        if (_lwp_continue(GC_current_ids[i]) < 0) {\n-            ABORT(\"Failed to restart lwp\");\n-        }\n-    }\n-    if (i >= max_lwps) ABORT(\"Too many lwps\");\n-}\n-\n-GC_bool GC_multithreaded = 0;\n-\n-void GC_stop_world()\n-{\n-    preempt_off();\n-    if (GC_multithreaded)\n-        stop_all_lwps();\n-}\n-\n-void GC_start_world()\n-{\n-    if (GC_multithreaded)\n-        restart_all_lwps();\n-    preempt_on();\n-}\n-\n-void GC_thr_init(void);\n-\n-GC_bool GC_thr_initialized = FALSE;\n-\n-size_t GC_min_stack_sz;\n-\n-\n-/*\n- * stack_head is stored at the top of free stacks\n- */\n-struct stack_head {\n-\tstruct stack_head\t*next;\n-\tptr_t\t\t\tbase;\n-\tthread_t\t\towner;\n-};\n-\n-# define N_FREE_LISTS 25\n-struct stack_head *GC_stack_free_lists[N_FREE_LISTS] = { 0 };\n-\t\t/* GC_stack_free_lists[i] is free list for stacks of \t*/\n-\t\t/* size GC_min_stack_sz*2**i.\t\t\t\t*/\n-\t\t/* Free lists are linked through stack_head stored\t*/\t\t\t/* at top of stack.\t\t\t\t\t*/\n-\n-/* Return a stack of size at least *stack_size.  *stack_size is\t*/\n-/* replaced by the actual stack size.\t\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-ptr_t GC_stack_alloc(size_t * stack_size)\n-{\n-    register size_t requested_sz = *stack_size;\n-    register size_t search_sz = GC_min_stack_sz;\n-    register int index = 0;\t/* = log2(search_sz/GC_min_stack_sz) */\n-    register ptr_t base;\n-    register struct stack_head *result;\n-    \n-    while (search_sz < requested_sz) {\n-        search_sz *= 2;\n-        index++;\n-    }\n-    if ((result = GC_stack_free_lists[index]) == 0\n-        && (result = GC_stack_free_lists[index+1]) != 0) {\n-        /* Try next size up. */\n-        search_sz *= 2; index++;\n-    }\n-    if (result != 0) {\n-        base =  GC_stack_free_lists[index]->base;\n-        GC_stack_free_lists[index] = GC_stack_free_lists[index]->next;\n-    } else {\n-#ifdef MMAP_STACKS\n-        base = (ptr_t)mmap(0, search_sz + GC_page_size,\n-\t\t\t     PROT_READ|PROT_WRITE, MAP_PRIVATE |MAP_NORESERVE,\n-\t\t\t     GC_zfd, 0);\n-\tif (base == (ptr_t)-1)\n-\t{\n-\t\t*stack_size = 0;\n-\t\treturn NULL;\n-\t}\n-\n-\tmprotect(base, GC_page_size, PROT_NONE);\n-\t/* Should this use divHBLKSZ(search_sz + GC_page_size) ? -- cf */\n-\tGC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));\n-\tbase += GC_page_size;\n-\n-#else\n-        base = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);\n-\tif (base == NULL)\n-\t{\n-\t\t*stack_size = 0;\n-\t\treturn NULL;\n-\t}\n-\n-        base = (ptr_t)(((word)base + GC_page_size) & ~(GC_page_size - 1));\n-        /* Protect hottest page to detect overflow. */\n-#\tifdef SOLARIS23_MPROTECT_BUG_FIXED\n-            mprotect(base, GC_page_size, PROT_NONE);\n-#\tendif\n-        GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));\n-\n-        base += GC_page_size;\n-#endif\n-    }\n-    *stack_size = search_sz;\n-    return(base);\n-}\n-\n-/* Caller holds  allocationlock.\t\t\t\t\t*/\n-void GC_stack_free(ptr_t stack, size_t size)\n-{\n-    register int index = 0;\n-    register size_t search_sz = GC_min_stack_sz;\n-    register struct stack_head *head;\n-    \n-#ifdef MMAP_STACKS\n-    /* Zero pointers */\n-    mmap(stack, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_FIXED,\n-\t GC_zfd, 0);\n-#endif\n-    while (search_sz < size) {\n-        search_sz *= 2;\n-        index++;\n-    }\n-    if (search_sz != size) ABORT(\"Bad stack size\");\n-\n-    head = (struct stack_head *)(stack + search_sz - sizeof(struct stack_head));\n-    head->next = GC_stack_free_lists[index];\n-    head->base = stack;\n-    GC_stack_free_lists[index] = head;\n-}\n-\n-void GC_my_stack_limits();\n-\n-/* Notify virtual dirty bit implementation that known empty parts of\t*/\n-/* stacks do not contain useful data.\t\t\t\t\t*/ \n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-void GC_old_stacks_are_fresh()\n-{\n-/* No point in doing this for MMAP stacks - and pointers are zero'd out */\n-/* by the mmap in GC_stack_free */\n-#ifndef MMAP_STACKS\n-    register int i;\n-    register struct stack_head *s;\n-    register ptr_t p;\n-    register size_t sz;\n-    register struct hblk * h;\n-    int dummy;\n-    \n-    for (i = 0, sz= GC_min_stack_sz; i < N_FREE_LISTS;\n-         i++, sz *= 2) {\n-         for (s = GC_stack_free_lists[i]; s != 0; s = s->next) {\n-             p = s->base;\n-             h = (struct hblk *)(((word)p + HBLKSIZE-1) & ~(HBLKSIZE-1));\n-             if ((ptr_t)h == p) {\n-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz));\n-             } else {\n-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz) - 1);\n-                 BZERO(p, (ptr_t)h - p);\n-             }\n-         }\n-    }\n-#endif /* MMAP_STACKS */\n-    GC_my_stack_limits();\n-}\n-\n-/* The set of all known threads.  We intercept thread creation and \t*/\n-/* joins.  We never actually create detached threads.  We allocate all \t*/\n-/* new thread stacks ourselves.  These allow us to maintain this\t*/\n-/* data structure.\t\t\t\t\t\t\t*/\n-\n-# define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n-volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n-\n-void GC_push_thread_structures GC_PROTO((void))\n-{\n-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n-}\n-\n-/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-GC_thread GC_new_thread(thread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    GC_thread result;\n-    static struct GC_Thread_Rep first_thread;\n-    static GC_bool first_thread_used = FALSE;\n-    \n-    if (!first_thread_used) {\n-    \tresult = &first_thread;\n-    \tfirst_thread_used = TRUE;\n-    \t/* Dont acquire allocation lock, since we may already hold it. */\n-    } else {\n-        result = (struct GC_Thread_Rep *)\n-        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n-    }\n-    if (result == 0) return(0);\n-    result -> id = id;\n-    result -> next = GC_threads[hv];\n-    GC_threads[hv] = result;\n-    /* result -> finished = 0; */\n-    (void) cond_init(&(result->join_cv), USYNC_THREAD, 0);\n-    return(result);\n-}\n-\n-/* Delete a thread from GC_threads.  We assume it is there.\t*/\n-/* (The code intentionally traps if it wasn't.)\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-void GC_delete_thread(thread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-    \n-    while (p -> id != id) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-}\n-\n-/* Return the GC_thread correpsonding to a given thread_t.\t*/\n-/* Returns 0 if it's not there.\t\t\t\t\t*/\n-/* Caller holds  allocation lock.\t\t\t\t*/\n-GC_thread GC_lookup_thread(thread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    \n-    while (p != 0 && p -> id != id) p = p -> next;\n-    return(p);\n-}\n-\n-/* Solaris 2/Intel uses an initial stack size limit slightly bigger than the\n-   SPARC default of 8 MB.  Account for this to warn only if the user has\n-   raised the limit beyond the default.\n-\n-   This is identical to DFLSSIZ defined in <sys/vm_machparam.h>.  This file\n-   is installed in /usr/platform/`uname -m`/include, which is not in the\n-   default include directory list, so copy the definition here.  */\n-#ifdef I386\n-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024 + ((USRSTACK) & 0x3FFFFF))\n-#else\n-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024)\n-#endif\n-\n-word GC_get_orig_stack_size() {\n-    struct rlimit rl;\n-    static int warned = 0;\n-    int result;\n-\n-    if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT(\"getrlimit failed\");\n-    result = (word)rl.rlim_cur & ~(HBLKSIZE-1);\n-    if (result > MAX_ORIG_STACK_SIZE) {\n-\tif (!warned) {\n-\t    WARN(\"Large stack limit(%ld): only scanning 8 MB\\n\", result);\n-\t    warned = 1;\n-\t}\n-\tresult = MAX_ORIG_STACK_SIZE;\n-    }\n-    return result;\n-}\n-\n-/* Notify dirty bit implementation of unused parts of my stack. */\n-/* Caller holds allocation lock.\t\t\t\t*/\n-void GC_my_stack_limits()\n-{\n-    int dummy;\n-    register ptr_t hottest = (ptr_t)((word)(&dummy) & ~(HBLKSIZE-1));\n-    register GC_thread me = GC_lookup_thread(thr_self());\n-    register size_t stack_size = me -> stack_size;\n-    register ptr_t stack;\n-    \n-    if (stack_size == 0) {\n-      /* original thread */\n-        /* Empirically, what should be the stack page with lowest\t*/\n-        /* address is actually inaccessible.\t\t\t\t*/\n-        stack_size = GC_get_orig_stack_size() - GC_page_size;\n-        stack = GC_stackbottom - stack_size + GC_page_size;\n-    } else {\n-        stack = me -> stack;\n-    }\n-    if (stack > hottest || stack + stack_size < hottest) {\n-    \tABORT(\"sp out of bounds\");\n-    }\n-    GC_is_fresh((struct hblk *)stack, divHBLKSZ(hottest - stack));\n-}\n-\n-\n-/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n-/* world is stopped.  Should not fail if it isn't.\t\t\t*/\n-void GC_push_all_stacks()\n-{\n-    register int i;\n-    register GC_thread p;\n-    register ptr_t sp = GC_approx_sp();\n-    register ptr_t bottom, top;\n-    struct rlimit rl;\n-    \n-#   define PUSH(bottom,top) \\\n-      if (GC_dirty_maintained) { \\\n-\tGC_push_selected((bottom), (top), GC_page_was_ever_dirty, \\\n-\t\t      GC_push_all_stack); \\\n-      } else { \\\n-        GC_push_all_stack((bottom), (top)); \\\n-      }\n-    GC_push_all_stack((ptr_t)GC_lwp_registers,\n-\t\t      (ptr_t)GC_lwp_registers\n-\t\t      + max_lwps * sizeof(GC_lwp_registers[0]));\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> stack_size != 0) {\n-            bottom = p -> stack;\n-            top = p -> stack + p -> stack_size;\n-        } else {\n-            /* The original stack. */\n-            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_size;\n-            top = GC_stackbottom;\n-        }\n-        if ((word)sp > (word)bottom && (word)sp < (word)top) bottom = sp;\n-        PUSH(bottom, top);\n-      }\n-    }\n-}\n-\n-\n-int GC_is_thread_stack(ptr_t addr)\n-{\n-    register int i;\n-    register GC_thread p;\n-    register ptr_t bottom, top;\n-    \n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> stack_size != 0) {\n-            if (p -> stack <= addr &&\n-\t\taddr < p -> stack + p -> stack_size)\n-\t\t    return 1;\n-\t}\n-      }\n-    }\n-    return 0;\n-}\n-\n-/* The only thread that ever really performs a thr_join.\t*/\n-void * GC_thr_daemon(void * dummy)\n-{\n-    void *status;\n-    thread_t departed;\n-    register GC_thread t;\n-    register int i;\n-    register int result;\n-    \n-    for(;;) {\n-      start:\n-        result = thr_join((thread_t)0, &departed, &status);\n-    \tLOCK();\n-    \tif (result != 0) {\n-    \t    /* No more threads; wait for create. */\n-    \t    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-    \t        for (t = GC_threads[i]; t != 0; t = t -> next) {\n-                    if (!(t -> flags & (DETACHED | FINISHED))) {\n-                      UNLOCK();\n-                      goto start; /* Thread started just before we */\n-                      \t\t  /* acquired the lock.\t\t   */\n-                    }\n-                }\n-            }\n-            cond_wait(&GC_create_cv, &GC_allocate_ml);\n-            UNLOCK();\n-    \t} else {\n-    \t    t = GC_lookup_thread(departed);\n-\t    GC_multithreaded--;\n-    \t    if (!(t -> flags & CLIENT_OWNS_STACK)) {\n-    \t    \tGC_stack_free(t -> stack, t -> stack_size);\n-    \t    }\n-    \t    if (t -> flags & DETACHED) {\n-    \t    \tGC_delete_thread(departed);\n-    \t    } else {\n-    \t        t -> status = status;\n-    \t    \tt -> flags |= FINISHED;\n-    \t    \tcond_signal(&(t -> join_cv));\n-    \t    \tcond_broadcast(&GC_prom_join_cv);\n-    \t    }\n-    \t    UNLOCK();\n-    \t}\n-    }\n-}\n-\n-/* We hold the allocation lock, or caller ensures that 2 instances\t*/\n-/* cannot be invoked concurrently.\t\t\t\t\t*/\n-void GC_thr_init(void)\n-{\n-    GC_thread t;\n-    thread_t tid;\n-    int ret;\n-\n-    if (GC_thr_initialized)\n-\t    return;\n-    GC_thr_initialized = TRUE;\n-    GC_min_stack_sz = ((thr_min_stack() + 32*1024 + HBLKSIZE-1)\n-    \t\t       & ~(HBLKSIZE - 1));\n-#ifdef MMAP_STACKS\n-    GC_zfd = open(\"/dev/zero\", O_RDONLY);\n-    if (GC_zfd == -1)\n-\t    ABORT(\"Can't open /dev/zero\");\n-#endif /* MMAP_STACKS */\n-    cond_init(&GC_prom_join_cv, USYNC_THREAD, 0);\n-    cond_init(&GC_create_cv, USYNC_THREAD, 0);\n-    /* Add the initial thread, so we can stop it.\t*/\n-      t = GC_new_thread(thr_self());\n-      t -> stack_size = 0;\n-      t -> flags = DETACHED | CLIENT_OWNS_STACK;\n-    ret = thr_create(0 /* stack */, 0 /* stack_size */, GC_thr_daemon,\n-    \t\t     0 /* arg */, THR_DETACHED | THR_DAEMON,\n-    \t\t     &tid /* thread_id */);\n-    if (ret != 0) {\n-\tGC_err_printf1(\"Thr_create returned %ld\\n\", ret);\n-    \tABORT(\"Cant fork daemon\");\n-    }\n-    thr_setprio(tid, 126);\n-}\n-\n-/* We acquire the allocation lock to prevent races with \t*/\n-/* stopping/starting world.\t\t\t\t\t*/\n-/* This is no more correct than the underlying Solaris 2.X\t*/\n-/* implementation.  Under 2.3 THIS IS BROKEN.\t\t\t*/\n-int GC_thr_suspend(thread_t target_thread)\n-{\n-    GC_thread t;\n-    int result;\n-    \n-    LOCK();\n-    result = thr_suspend(target_thread);\n-    if (result == 0) {\n-    \tt = GC_lookup_thread(target_thread);\n-    \tif (t == 0) ABORT(\"thread unknown to GC\");\n-        t -> flags |= SUSPNDED;\n-    }\n-    UNLOCK();\n-    return(result);\n-}\n-\n-int GC_thr_continue(thread_t target_thread)\n-{\n-    GC_thread t;\n-    int result;\n-    \n-    LOCK();\n-    result = thr_continue(target_thread);\n-    if (result == 0) {\n-    \tt = GC_lookup_thread(target_thread);\n-    \tif (t == 0) ABORT(\"thread unknown to GC\");\n-        t -> flags &= ~SUSPNDED;\n-    }\n-    UNLOCK();\n-    return(result);\n-}\n-\n-int GC_thr_join(thread_t wait_for, thread_t *departed, void **status)\n-{\n-    register GC_thread t;\n-    int result = 0;\n-    \n-    LOCK();\n-    if (wait_for == 0) {\n-        register int i;\n-        register GC_bool thread_exists;\n-    \n-    \tfor (;;) {\n-    \t  thread_exists = FALSE;\n-    \t  for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-    \t    for (t = GC_threads[i]; t != 0; t = t -> next) {\n-              if (!(t -> flags & DETACHED)) {\n-                if (t -> flags & FINISHED) {\n-                  goto found;\n-                }\n-                thread_exists = TRUE;\n-              }\n-            }\n-          }\n-          if (!thread_exists) {\n-              result = ESRCH;\n-    \t      goto out;\n-          }\n-          cond_wait(&GC_prom_join_cv, &GC_allocate_ml);\n-        }\n-    } else {\n-        t = GC_lookup_thread(wait_for);\n-    \tif (t == 0 || t -> flags & DETACHED) {\n-    \t    result = ESRCH;\n-    \t    goto out;\n-    \t}\n-    \tif (wait_for == thr_self()) {\n-    \t    result = EDEADLK;\n-    \t    goto out;\n-    \t}\n-    \twhile (!(t -> flags & FINISHED)) {\n-            cond_wait(&(t -> join_cv), &GC_allocate_ml);\n-    \t}\n-    \t\n-    }\n-  found:\n-    if (status) *status = t -> status;\n-    if (departed) *departed = t -> id;\n-    cond_destroy(&(t -> join_cv));\n-    GC_delete_thread(t -> id);\n-  out:\n-    UNLOCK();\n-    return(result);\n-}\n-\n-\n-int\n-GC_thr_create(void *stack_base, size_t stack_size,\n-              void *(*start_routine)(void *), void *arg, long flags,\n-              thread_t *new_thread)\n-{\n-    int result;\n-    GC_thread t;\n-    thread_t my_new_thread;\n-    word my_flags = 0;\n-    void * stack = stack_base;\n-   \n-    LOCK();\n-    if (!GC_is_initialized) GC_init_inner();\n-    GC_multithreaded++;\n-    if (stack == 0) {\n-     \tif (stack_size == 0) stack_size = 1024*1024;\n-     \tstack = (void *)GC_stack_alloc(&stack_size);\n-     \tif (stack == 0) {\n-\t    GC_multithreaded--;\n-     \t    UNLOCK();\n-     \t    return(ENOMEM);\n-     \t}\n-    } else {\n-    \tmy_flags |= CLIENT_OWNS_STACK;\n-    }\n-    if (flags & THR_DETACHED) my_flags |= DETACHED;\n-    if (flags & THR_SUSPENDED) my_flags |= SUSPNDED;\n-    result = thr_create(stack, stack_size, start_routine,\n-   \t\t        arg, flags & ~THR_DETACHED, &my_new_thread);\n-    if (result == 0) {\n-        t = GC_new_thread(my_new_thread);\n-        t -> flags = my_flags;\n-        if (!(my_flags & DETACHED)) cond_init(&(t -> join_cv), USYNC_THREAD, 0);\n-        t -> stack = stack;\n-        t -> stack_size = stack_size;\n-        if (new_thread != 0) *new_thread = my_new_thread;\n-        cond_signal(&GC_create_cv);\n-    } else {\n-\tGC_multithreaded--;\n-        if (!(my_flags & CLIENT_OWNS_STACK)) {\n-      \t    GC_stack_free(stack, stack_size);\n-\t}\n-    }        \n-    UNLOCK();  \n-    return(result);\n-}\n-\n-# else /* !GC_SOLARIS_THREADS */\n-\n-#ifndef LINT\n-  int GC_no_sunOS_threads;\n-#endif\n-#endif"}]}