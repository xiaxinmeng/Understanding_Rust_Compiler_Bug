{"sha": "89b1427f8693699d64050cc4daf5626f6b96b96a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODliMTQyN2Y4NjkzNjk5ZDY0MDUwY2M0ZGFmNTYyNmY2Yjk2Yjk2YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-30T10:29:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-30T10:29:58Z"}, "message": "re PR target/83210 (__builtin_mul_overflow() generates suboptimal code when exactly one argument is the constant 2)\n\n\tPR target/83210\n\t* internal-fn.c (expand_mul_overflow): Optimize unsigned\n\tmultiplication by power of 2 constant into two shifts + comparison.\n\n\t* gcc.target/i386/pr83210.c: New test.\n\nFrom-SVN: r255269", "tree": {"sha": "6eb12921ec5d8b6fd580bf01c82cbdc59ac2966c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6eb12921ec5d8b6fd580bf01c82cbdc59ac2966c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b1427f8693699d64050cc4daf5626f6b96b96a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b1427f8693699d64050cc4daf5626f6b96b96a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b1427f8693699d64050cc4daf5626f6b96b96a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b1427f8693699d64050cc4daf5626f6b96b96a/comments", "author": null, "committer": null, "parents": [{"sha": "7c080ade9d8198958a1a37854d5cc56f7b76b9f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c080ade9d8198958a1a37854d5cc56f7b76b9f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c080ade9d8198958a1a37854d5cc56f7b76b9f4"}], "stats": {"total": 109, "additions": 108, "deletions": 1}, "files": [{"sha": "776508a1bdce28cfbf58ac95eaee9feee2a1047d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89b1427f8693699d64050cc4daf5626f6b96b96a", "patch": "@@ -1,7 +1,13 @@\n+2017-11-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/83210\n+\t* internal-fn.c (expand_mul_overflow): Optimize unsigned\n+\tmultiplication by power of 2 constant into two shifts + comparison.\n+\n 2017-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/81616\n-\t* x86-tnue-costs.h (generic_cost): Revise for modern CPUs\n+\t* config/i386/x86-tune-costs.h (generic_cost): Revise for modern CPUs.\n \n 2017-11-30  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "7ddc5246e3ccda0bb8d9dd5ba555ed22c24e0ca6", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=89b1427f8693699d64050cc4daf5626f6b96b96a", "patch": "@@ -1462,6 +1462,49 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n   type = build_nonstandard_integer_type (GET_MODE_PRECISION (mode), uns);\n   sign = uns ? UNSIGNED : SIGNED;\n   icode = optab_handler (uns ? umulv4_optab : mulv4_optab, mode);\n+  if (uns\n+      && (integer_pow2p (arg0) || integer_pow2p (arg1))\n+      && (optimize_insn_for_speed_p () || icode == CODE_FOR_nothing))\n+    {\n+      /* Optimize unsigned multiplication by power of 2 constant\n+\t using 2 shifts, one for result, one to extract the shifted\n+\t out bits to see if they are all zero.\n+\t Don't do this if optimizing for size and we have umulv4_optab,\n+\t in that case assume multiplication will be shorter.\n+\t This is heuristics based on the single target that provides\n+\t umulv4 right now (i?86/x86_64), if further targets add it, this\n+\t might need to be revisited.\n+\t Cases where both operands are constant should be folded already\n+\t during GIMPLE, and cases where one operand is constant but not\n+\t power of 2 are questionable, either the WIDEN_MULT_EXPR case\n+\t below can be done without multiplication, just by shifts and adds,\n+\t or we'd need to divide the result (and hope it actually doesn't\n+\t really divide nor multiply) and compare the result of the division\n+\t with the original operand.  */\n+      rtx opn0 = op0;\n+      rtx opn1 = op1;\n+      tree argn0 = arg0;\n+      tree argn1 = arg1;\n+      if (integer_pow2p (arg0))\n+\t{\n+\t  std::swap (opn0, opn1);\n+\t  std::swap (argn0, argn1);\n+\t}\n+      int cnt = tree_log2 (argn1);\n+      if (cnt >= 0 && cnt < GET_MODE_PRECISION (mode))\n+\t{\n+\t  rtx upper = const0_rtx;\n+\t  res = expand_shift (LSHIFT_EXPR, mode, opn0, cnt, NULL_RTX, uns);\n+\t  if (cnt != 0)\n+\t    upper = expand_shift (RSHIFT_EXPR, mode, opn0,\n+\t\t\t\t  GET_MODE_PRECISION (mode) - cnt,\n+\t\t\t\t  NULL_RTX, uns);\n+\t  do_compare_rtx_and_jump (upper, const0_rtx, EQ, true, mode,\n+\t\t\t\t   NULL_RTX, NULL, done_label,\n+\t\t\t\t   profile_probability::very_likely ());\n+\t  goto do_error_label;\n+\t}\n+    }\n   if (icode != CODE_FOR_nothing)\n     {\n       struct expand_operand ops[4];"}, {"sha": "bda1bf5560d2f6530d1e4cefb280d0b5de29930f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89b1427f8693699d64050cc4daf5626f6b96b96a", "patch": "@@ -1,3 +1,8 @@\n+2017-11-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/83210\n+\t* gcc.target/i386/pr83210.c: New test.\n+\n 2017-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/81616"}, {"sha": "cf985d29daef156e9776e47de9326fb6c32dabb4", "filename": "gcc/testsuite/gcc.target/i386/pr83210.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83210.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b1427f8693699d64050cc4daf5626f6b96b96a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83210.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83210.c?ref=89b1427f8693699d64050cc4daf5626f6b96b96a", "patch": "@@ -0,0 +1,53 @@\n+/* PR target/83210 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not {\\mmul[lq]\\M} } } */\n+\n+void bar (void);\n+\n+unsigned\n+f1 (unsigned int x)\n+{\n+  unsigned res;\n+  if (__builtin_mul_overflow (x, 2, &res))\n+    bar ();\n+  return res;\n+}\n+\n+unsigned long\n+f2 (unsigned long x)\n+{\n+  unsigned long res;\n+  if (__builtin_mul_overflow (16, x, &res))\n+    bar ();\n+  return res;\n+}\n+\n+unsigned long long\n+f3 (unsigned long long x)\n+{\n+  unsigned long long res;\n+  if (__builtin_mul_overflow (x, (1ULL << (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ - 1)), &res))\n+    bar ();\n+  return res;\n+}\n+\n+#ifdef __SIZEOF_INT128__\n+unsigned __int128\n+f4 (unsigned __int128 x)\n+{\n+  unsigned __int128 res;\n+  if (__builtin_mul_overflow (x, (((unsigned __int128) 1) << (__SIZEOF_INT128__ * __CHAR_BIT__ / 2)), &res))\n+    bar ();\n+  return res;\n+}\n+\n+unsigned __int128\n+f5 (unsigned __int128 x)\n+{\n+  unsigned __int128 res;\n+  if (__builtin_mul_overflow (x, (((unsigned __int128) 1) << (__SIZEOF_INT128__ * __CHAR_BIT__ / 2 + 3)), &res))\n+    bar ();\n+  return res;\n+}\n+#endif"}]}