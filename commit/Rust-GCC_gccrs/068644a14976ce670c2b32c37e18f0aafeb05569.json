{"sha": "068644a14976ce670c2b32c37e18f0aafeb05569", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY4NjQ0YTE0OTc2Y2U2NzBjMmIzMmMzN2UxOGYwYWFmZWIwNTU2OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-14T16:59:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-14T17:04:18Z"}, "message": "c++: DECL_FRIEND_P cleanup\n\nDECL_FRIEND_P's meaning has changed over time.  It now (almost) means\nthe the friend function decl has not been met via an explicit decl.\nThis completes that transition, renaming it to DECL_UNIQUE_FRIEND_P,\nso one doesn't think it is the sole indicator of friendliness (plenty\nof friends do not have the flag set).  This allows reduction in the\ncomplexity of managing the field -- all in duplicate_decls now.\n\n\tgcc/cp/\n\t* cp-tree.h (struct lang_decl_fn): Adjust context comment.\n\t(DECL_FRIEND_P): Replace with ...\n\t(DECL_UNIQUE_FRIEND_P): ... this.  Only for FUNCTION_DECLs.\n\t(DECL_FRIEND_CONTEXT): Adjust.\n\t* class.c (add_implicitly_declared_members): Detect friendly\n\tspaceship from context.\n\t* constraint.cc (remove_constraints): Use a checking assert.\n\t(maybe_substitute_reqs_for): Use DECL_UNIQUE_FRIEND_P.\n\t* decl.c (check_no_redeclaration_friend_default_args):\n\tDECL_UNIQUE_FRIEND_P is signficant, not hiddenness.\n\t(duplicate_decls): Adjust DECL_UNIQUE_FRIEND_P clearing.\n\t(redeclaration_error_message): Use DECL_UNIQUE_FRIEND_P.\n\t(start_preparsed_function): Correct in-class friend processing.\n\tRefactor some initializers.\n\t(grokmethod): Directly check friend decl-spec.\n\t* decl2.c (grokfield): Check DECL_UNIQUE_FRIEND_P.\n\t* friend.c (do_friend): Set DECL_UNIQUE_FRIEND_P first, remove\n\textraneous conditions.  Don't re set it afterwards.\n\t* name-lookup.c (lookup_elaborated_type_1): Simplify revealing\n\tcode.\n\t(do_pushtag): Likewise.\n\t* pt.c (optimize_specialization_lookup_p): Check\n\tDECL_UNIQUE_FRIEND_P.\n\t(push_template_decl): Likewise.  Drop unneeded friend setting.\n\t(type_dependent_expression_p): Check DECL_UNIQUE_FRIEND_P.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_add_friend): Set DECL_UNIQUE_FRIEND_P.", "tree": {"sha": "b349fda340e8e82bbbf0e80205086754dcf2e5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b349fda340e8e82bbbf0e80205086754dcf2e5bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/068644a14976ce670c2b32c37e18f0aafeb05569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068644a14976ce670c2b32c37e18f0aafeb05569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068644a14976ce670c2b32c37e18f0aafeb05569", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068644a14976ce670c2b32c37e18f0aafeb05569/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06bec55e80d98419121f3998d98d969990a75b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bec55e80d98419121f3998d98d969990a75b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bec55e80d98419121f3998d98d969990a75b0b"}], "stats": {"total": 276, "additions": 99, "deletions": 177}, "files": [{"sha": "26f996b7f4bff5f02639646e58a562911ca29a24", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -3283,7 +3283,8 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n       {\n \ttree eq = implicitly_declare_fn (sfk_comparison, t, false, space,\n \t\t\t\t\t NULL_TREE);\n-\tif (DECL_FRIEND_P (space))\n+\tbool is_friend = DECL_CONTEXT (space) != t;\n+\tif (is_friend)\n \t  do_friend (NULL_TREE, DECL_NAME (eq), eq,\n \t\t     NULL_TREE, NO_SPECIAL, true);\n \telse\n@@ -3292,7 +3293,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \t    DECL_CHAIN (eq) = TYPE_FIELDS (t);\n \t    TYPE_FIELDS (t) = eq;\n \t  }\n-\tmaybe_add_class_template_decl_list (t, eq, DECL_FRIEND_P (space));\n+\tmaybe_add_class_template_decl_list (t, eq, is_friend);\n       }\n \n   while (*access_decls)"}, {"sha": "f4f5174eff3272c185ed0b626e141bfb79e91388", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -1201,7 +1201,7 @@ set_constraints (tree t, tree ci)\n void\n remove_constraints (tree t)\n {\n-  gcc_assert (DECL_P (t));\n+  gcc_checking_assert (DECL_P (t));\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n \n@@ -1217,11 +1217,16 @@ maybe_substitute_reqs_for (tree reqs, const_tree decl_)\n {\n   if (reqs == NULL_TREE)\n     return NULL_TREE;\n+\n   tree decl = CONST_CAST_TREE (decl_);\n   tree result = STRIP_TEMPLATE (decl);\n-  if (DECL_FRIEND_P (result))\n+\n+  if (DECL_UNIQUE_FRIEND_P (result))\n     {\n-      tree tmpl = decl == result ? DECL_TI_TEMPLATE (result) : decl;\n+      tree tmpl = decl;\n+      if (TREE_CODE (decl) != TEMPLATE_DECL)\n+\ttmpl = DECL_TI_TEMPLATE (result);\n+\n       tree gargs = generic_targs_for (tmpl);\n       processing_template_decl_sentinel s;\n       if (uses_template_parms (gargs))"}, {"sha": "5c06ac3789e1689379192169448b80462212a984", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -2736,12 +2736,14 @@ struct GTY(()) lang_decl_fn {\n      thunked to function decl.  */\n   tree befriending_classes;\n \n-  /* For a non-virtual FUNCTION_DECL, this is\n-     DECL_FRIEND_CONTEXT.  For a virtual FUNCTION_DECL for which\n+  /* For a virtual FUNCTION_DECL for which\n      DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n      this pointer and result pointer adjusting thunks are\n      chained here.  This pointer thunks to return pointer thunks\n-     will be chained on the return pointer thunk.  */\n+     will be chained on the return pointer thunk.\n+     For a DECL_CONSTUCTOR_P FUNCTION_DECL, this is the base from\n+     whence we inherit.  Otherwise, it is the class in which a\n+     (namespace-scope) friend is defined (if any).   */\n   tree context;\n \n   union lang_decl_u5\n@@ -3088,10 +3090,14 @@ struct GTY(()) lang_decl {\n   (DECL_LANG_SPECIFIC (VAR_OR_FUNCTION_DECL_CHECK (DECL)) \\\n    ->u.base.odr_used)\n \n-/* Nonzero for DECL means that this decl is just a friend declaration,\n-   and should not be added to the list of members for this class.  */\n-#define DECL_FRIEND_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (TYPE_FUNCTION_OR_TEMPLATE_DECL_CHECK (NODE)) \\\n+/* Nonzero for FUNCTION_DECL means that this is a friend that is\n+   either not pushed into a namespace/looked up in a class (because it\n+   is a dependent type, in an uninstantiated template), or it has\n+   /only/ been subject to hidden friend injection from one or more\n+   befriending classes.  Once another decl matches, the flag is\n+   cleared.  There are requirements on its default parms.  */\n+#define DECL_UNIQUE_FRIEND_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE)) \\\n    ->u.base.friend_or_tls)\n \n /* Nonzero if the thread-local variable was declared with __thread as\n@@ -3290,8 +3296,8 @@ struct GTY(()) lang_decl {\n \n    the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n #define DECL_FRIEND_CONTEXT(NODE)\t\t\t\t\\\n-  ((DECL_DECLARES_FUNCTION_P (NODE)\t\t\t\t\\\n-    && DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n+  ((DECL_DECLARES_FUNCTION_P (NODE) && !DECL_VIRTUAL_P (NODE)\t\\\n+    && !DECL_CONSTRUCTOR_P (NODE))\t\t\t\t\\\n    ? LANG_DECL_FN_CHECK (NODE)->context\t\t\t\t\\\n    : NULL_TREE)\n "}, {"sha": "2f1a2f0c554adfe8c41bce71bb982e88e6e026b3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 59, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -1340,18 +1340,17 @@ check_redeclaration_no_default_args (tree decl)\n    the function or function template in the translation unit.\"  */\n \n static void\n-check_no_redeclaration_friend_default_args (tree olddecl, tree newdecl,\n-\t\t\t\t\t    bool olddecl_hidden_p)\n+check_no_redeclaration_friend_default_args (tree olddecl, tree newdecl)\n {\n-  if (!olddecl_hidden_p && !DECL_FRIEND_P (newdecl))\n+  if (!DECL_UNIQUE_FRIEND_P (olddecl) && !DECL_UNIQUE_FRIEND_P (newdecl))\n     return;\n \n   for (tree t1 = FUNCTION_FIRST_USER_PARMTYPE (olddecl),\n \t t2 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);\n        t1 && t1 != void_list_node;\n        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-    if ((olddecl_hidden_p && TREE_PURPOSE (t1))\n-\t|| (DECL_FRIEND_P (newdecl) && TREE_PURPOSE (t2)))\n+    if ((DECL_UNIQUE_FRIEND_P (olddecl) && TREE_PURPOSE (t1))\n+\t|| (DECL_UNIQUE_FRIEND_P (newdecl) && TREE_PURPOSE (t2)))\n       {\n \tauto_diagnostic_group d;\n \tif (permerror (DECL_SOURCE_LOCATION (newdecl),\n@@ -1444,8 +1443,7 @@ tree\n duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n {\n   unsigned olddecl_uid = DECL_UID (olddecl);\n-  int olddecl_friend = 0, types_match = 0;\n-  int olddecl_hidden_friend = 0;\n+  int types_match = 0;\n   int new_defines_function = 0;\n   tree new_template_info;\n   location_t olddecl_loc = DECL_SOURCE_LOCATION (olddecl);\n@@ -1987,8 +1985,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t\t argument expression, that declaration... shall be the only\n \t\t declaration of the function or function template in the\n \t\t translation unit.\"  */\n-\t      check_no_redeclaration_friend_default_args\n-\t\t(olddecl, newdecl, was_hidden);\n+\t      check_no_redeclaration_friend_default_args (olddecl, newdecl);\n \t    }\n \t}\n     }\n@@ -2135,12 +2132,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n   else\n     DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);\n \n-  if (DECL_DECLARES_FUNCTION_P (olddecl))\n-    {\n-      olddecl_friend = DECL_FRIEND_P (STRIP_TEMPLATE (olddecl));\n-      olddecl_hidden_friend = olddecl_friend && was_hidden;\n-    }\n-\n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n       tree old_result = DECL_TEMPLATE_RESULT (olddecl);\n@@ -2167,8 +2158,10 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t\t declaration of the function or function template in the\n \t\t translation unit.\"  */\n \t      check_no_redeclaration_friend_default_args\n-\t\t(old_result, new_result, olddecl_hidden_friend);\n+\t\t(old_result, new_result);\n \t    }\n+\t  if (!DECL_UNIQUE_FRIEND_P (old_result))\n+\t    DECL_UNIQUE_FRIEND_P (new_result) = false;\n \n \t  check_default_args (newdecl);\n \n@@ -2366,6 +2359,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t      && !DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl))\n \t    DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl)\n \t      = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl);\n+\n+\t  if (!DECL_UNIQUE_FRIEND_P (olddecl))\n+\t    DECL_UNIQUE_FRIEND_P (newdecl) = false;\n \t}\n       else\n \t{\n@@ -2885,8 +2881,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n     }\n \n   DECL_UID (olddecl) = olddecl_uid;\n-  if (olddecl_friend)\n-    DECL_FRIEND_P (olddecl) = true;\n \n   /* NEWDECL contains the merged attribute lists.\n      Update OLDDECL to be the same.  */\n@@ -3062,7 +3056,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n            definition and shall be the only declaration of the\n            function template in the translation unit.  */\n       if ((cxx_dialect != cxx98)\n-          && TREE_CODE (ot) == FUNCTION_DECL && DECL_FRIEND_P (ot)\n+          && TREE_CODE (ot) == FUNCTION_DECL && DECL_UNIQUE_FRIEND_P (ot)\n \t  && !check_default_tmpl_args (nt, DECL_TEMPLATE_PARMS (newdecl),\n                                        /*is_primary=*/true,\n \t\t\t\t       /*is_partial=*/false,\n@@ -3073,7 +3067,8 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n       return NULL;\n     }\n   else if (VAR_P (newdecl)\n-\t   && CP_DECL_THREAD_LOCAL_P (newdecl) != CP_DECL_THREAD_LOCAL_P (olddecl)\n+\t   && (CP_DECL_THREAD_LOCAL_P (newdecl)\n+\t       != CP_DECL_THREAD_LOCAL_P (olddecl))\n \t   && (! DECL_LANG_SPECIFIC (olddecl)\n \t       || ! CP_DECL_THREADPRIVATE_P (olddecl)\n \t       || CP_DECL_THREAD_LOCAL_P (newdecl)))\n@@ -16110,36 +16105,21 @@ bool\n start_preparsed_function (tree decl1, tree attrs, int flags)\n {\n   tree ctype = NULL_TREE;\n-  tree fntype;\n-  tree restype;\n-  int doing_friend = 0;\n-  cp_binding_level *bl;\n-  tree current_function_parms;\n-  struct c_fileinfo *finfo\n-    = get_fileinfo (LOCATION_FILE (DECL_SOURCE_LOCATION (decl1)));\n-  bool honor_interface;\n+  bool doing_friend = false;\n \n   /* Sanity check.  */\n   gcc_assert (VOID_TYPE_P (TREE_VALUE (void_list_node)));\n   gcc_assert (TREE_CHAIN (void_list_node) == NULL_TREE);\n \n-  fntype = TREE_TYPE (decl1);\n+  tree fntype = TREE_TYPE (decl1);\n   if (TREE_CODE (fntype) == METHOD_TYPE)\n     ctype = TYPE_METHOD_BASETYPE (fntype);\n-\n-  /* ISO C++ 11.4/5.  A friend function defined in a class is in\n-     the (lexical) scope of the class in which it is defined.  */\n-  if (!ctype && DECL_FRIEND_P (decl1))\n+  else\n     {\n       ctype = DECL_FRIEND_CONTEXT (decl1);\n \n-      /* CTYPE could be null here if we're dealing with a template;\n-\t for example, `inline friend float foo()' inside a template\n-\t will have no CTYPE set.  */\n-      if (ctype && TREE_CODE (ctype) != RECORD_TYPE)\n-\tctype = NULL_TREE;\n-      else\n-\tdoing_friend = 1;\n+      if (ctype)\n+\tdoing_friend = true;\n     }\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n@@ -16206,7 +16186,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n      by push_nested_class.)  */\n   if (processing_template_decl)\n     {\n-      tree newdecl1 = push_template_decl (decl1, DECL_FRIEND_P (decl1));\n+      tree newdecl1 = push_template_decl (decl1, doing_friend);\n       if (newdecl1 == error_mark_node)\n \t{\n \t  if (ctype || DECL_STATIC_FUNCTION_P (decl1))\n@@ -16222,7 +16202,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   check_function_type (decl1, DECL_ARGUMENTS (decl1));\n \n   /* Build the return declaration for the function.  */\n-  restype = TREE_TYPE (fntype);\n+  tree restype = TREE_TYPE (fntype);\n \n   if (DECL_RESULT (decl1) == NULL_TREE)\n     {\n@@ -16312,7 +16292,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   /* Save the parm names or decls from this function's declarator\n      where store_parm_decls will find them.  */\n-  current_function_parms = DECL_ARGUMENTS (decl1);\n+  tree current_function_parms = DECL_ARGUMENTS (decl1);\n \n   /* Let the user know we're compiling this function.  */\n   announce_function (decl1);\n@@ -16329,7 +16309,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n      even when processing a template; this is how we get\n      CFUN set up, and our per-function variables initialized.\n      FIXME factor out the non-RTL stuff.  */\n-  bl = current_binding_level;\n+  cp_binding_level *bl = current_binding_level;\n   allocate_struct_function (decl1, processing_template_decl);\n \n   /* Initialize the language data structures.  Whenever we start\n@@ -16384,14 +16364,16 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t}\n     }\n \n-  honor_interface = (!DECL_TEMPLATE_INSTANTIATION (decl1)\n-\t\t     /* Implicitly-defined methods (like the\n-\t\t\tdestructor for a class in which no destructor\n-\t\t\tis explicitly declared) must not be defined\n-\t\t\tuntil their definition is needed.  So, we\n-\t\t\tignore interface specifications for\n-\t\t\tcompiler-generated functions.  */\n-\t\t     && !DECL_ARTIFICIAL (decl1));\n+  bool honor_interface = (!DECL_TEMPLATE_INSTANTIATION (decl1)\n+\t\t\t  /* Implicitly-defined methods (like the\n+\t\t\t     destructor for a class in which no destructor\n+\t\t\t     is explicitly declared) must not be defined\n+\t\t\t     until their definition is needed.  So, we\n+\t\t\t     ignore interface specifications for\n+\t\t\t     compiler-generated functions.  */\n+\t\t\t  && !DECL_ARTIFICIAL (decl1));\n+  struct c_fileinfo *finfo\n+    = get_fileinfo (LOCATION_FILE (DECL_SOURCE_LOCATION (decl1)));\n \n   if (processing_template_decl)\n     /* Don't mess with interface flags.  */;\n@@ -17311,18 +17293,17 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n   /* We process method specializations in finish_struct_1.  */\n   if (processing_template_decl && !DECL_TEMPLATE_SPECIALIZATION (fndecl))\n     {\n-      fndecl = push_template_decl (fndecl, DECL_FRIEND_P (fndecl));\n+      /* Avoid calling decl_spec_seq... until we have to.  */\n+      bool friendp = decl_spec_seq_has_spec_p (declspecs, ds_friend);\n+      fndecl = push_template_decl (fndecl, friendp);\n       if (fndecl == error_mark_node)\n \treturn fndecl;\n     }\n \n-  if (! DECL_FRIEND_P (fndecl))\n+  if (DECL_CHAIN (fndecl) && !decl_spec_seq_has_spec_p (declspecs, ds_friend))\n     {\n-      if (DECL_CHAIN (fndecl))\n-\t{\n-\t  fndecl = copy_node (fndecl);\n-\t  TREE_CHAIN (fndecl) = NULL_TREE;\n-\t}\n+      fndecl = copy_node (fndecl);\n+      TREE_CHAIN (fndecl) = NULL_TREE;\n     }\n \n   cp_finish_decl (fndecl, NULL_TREE, false, NULL_TREE, 0);"}, {"sha": "2f0d63701466180a78c66c796470b9d07e33f815", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -1021,7 +1021,7 @@ grokfield (const cp_declarator *declarator,\n \t\t      asmspec_tree, flags);\n \n       /* Pass friends back this way.  */\n-      if (DECL_FRIEND_P (value))\n+      if (DECL_UNIQUE_FRIEND_P (value))\n \treturn void_type_node;\n \n       DECL_IN_AGGR_P (value) = 1;"}, {"sha": "56fa96073d3aa4f0181c92e42da47f5c32f55f6b", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -481,8 +481,8 @@ do_friend (tree ctype, tree declarator, tree decl,\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (!ctype || MAYBE_CLASS_TYPE_P (ctype));\n \n-  /* Every decl that gets here is a friend of something.  */\n-  DECL_FRIEND_P (decl) = 1;\n+  /* Friend functions are unique, until proved otherwise.  */\n+  DECL_UNIQUE_FRIEND_P (decl) = 1;\n \n   if (DECL_OVERRIDE_P (decl) || DECL_FINAL_P (decl))\n     error (\"friend declaration %qD may not have virt-specifiers\",\n@@ -581,17 +581,11 @@ do_friend (tree ctype, tree declarator, tree decl,\n \terror (\"member %qD declared as friend before type %qT defined\",\n \t\t  decl, ctype);\n     }\n-  /* A global friend.\n-     @@ or possibly a friend from a base class ?!?  */\n-  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+  else\n     {\n+      /* Namespace-scope friend function.  */\n       int is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ();\n \n-      /* Friends must all go through the overload machinery,\n-\t even though they may not technically be overloaded.\n-\n-\t Note that because classes all wind up being top-level\n-\t in their scope, their friend wind up in top-level scope as well.  */\n       if (funcdef_flag)\n \tSET_DECL_FRIEND_CONTEXT (decl, current_class_type);\n \n@@ -653,7 +647,6 @@ do_friend (tree ctype, tree declarator, tree decl,\n       add_friend (current_class_type,\n \t\t  is_friend_template ? DECL_TI_TEMPLATE (decl) : decl,\n \t\t  /*complain=*/true);\n-      DECL_FRIEND_P (decl) = 1;\n     }\n \n   return decl;"}, {"sha": "e951fb7885bd1d4e5bcdefcd2444b105c90d4bbc", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 23, "deletions": 83, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -6719,18 +6719,18 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n \t     typedef struct C {} C;\n \t   correctly.  */\n \n-\ttree found = NULL_TREE;\n-\tbool reveal = false;\n \tif (tree type = iter->type)\n \t  {\n \t    if (qualify_lookup (type, LOOK_want::TYPE)\n \t\t&& (how != TAG_how::CURRENT_ONLY\n \t\t    || LOCAL_BINDING_P (iter)\n \t\t    || DECL_CONTEXT (type) == iter->scope->this_entity))\n \t      {\n-\t\tfound = type;\n \t\tif (how != TAG_how::HIDDEN_FRIEND)\n-\t\t  reveal = HIDDEN_TYPE_BINDING_P (iter);\n+\t\t  /* It is no longer a hidden binding.  */\n+\t\t  HIDDEN_TYPE_BINDING_P (iter) = false;\n+\n+\t\treturn type;\n \t      }\n \t  }\n \telse\n@@ -6739,32 +6739,12 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n \t\t&& (how != TAG_how::CURRENT_ONLY\n \t\t    || !INHERITED_VALUE_BINDING_P (iter)))\n \t      {\n-\t\tfound = iter->value;\n-\t\tif (how != TAG_how::HIDDEN_FRIEND)\n-\t\t  reveal = !iter->type && HIDDEN_TYPE_BINDING_P (iter);\n-\t      }\n-\t  }\n-\n-\tif (found)\n-\t  {\n-\t    if (reveal)\n-\t      {\n-\t\t/* It is no longer a hidden binding.  */\n-\t\tHIDDEN_TYPE_BINDING_P (iter) = false;\n-\n-\t\t/* Unanticipate the decl itself.  */\n-\t\tDECL_FRIEND_P (found) = false;\n+\t\tif (how != TAG_how::HIDDEN_FRIEND && !iter->type)\n+\t\t  /* It is no longer a hidden binding.  */\n+\t\t  HIDDEN_TYPE_BINDING_P (iter) = false;\n \n-\t\tgcc_checking_assert (TREE_CODE (found) != TEMPLATE_DECL);\n-\n-\t\tif (tree ti = TYPE_TEMPLATE_INFO (TREE_TYPE (found)))\n-\t\t  {\n-\t\t    tree tmpl = TI_TEMPLATE (ti);\n-\t\t    DECL_FRIEND_P (tmpl) = false;\n-\t\t  }\n+\t\treturn iter->value;\n \t      }\n-\n-\t    return found;\n \t  }\n       }\n \n@@ -6781,61 +6761,31 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n   if (tree *slot = find_namespace_slot (ns, name))\n     {\n       /* If this is the kind of thing we're looking for, we're done.  */\n-      tree found = NULL_TREE;\n-      bool reveal = false;\n-\n       if (tree type = MAYBE_STAT_TYPE (*slot))\n \t{\n-\t  found = type;\n \t  if (how != TAG_how::HIDDEN_FRIEND)\n-\t    {\n-\t      reveal = STAT_TYPE_HIDDEN_P (*slot);\n-\t      STAT_TYPE_HIDDEN_P (*slot) = false;\n-\t    }\n+\t    /* No longer hidden.  */\n+\t    STAT_TYPE_HIDDEN_P (*slot) = false;\n+\n+\t  return type;\n \t}\n       else if (tree decl = MAYBE_STAT_DECL (*slot))\n \t{\n \t  if (qualify_lookup (decl, LOOK_want::TYPE))\n \t    {\n-\t      found = decl;\n-\n-\t      if (how != TAG_how::HIDDEN_FRIEND  && STAT_HACK_P (*slot))\n+\t      if (how != TAG_how::HIDDEN_FRIEND && STAT_HACK_P (*slot)\n+\t\t  && STAT_DECL_HIDDEN_P (*slot))\n \t\t{\n-\t\t  reveal = STAT_DECL_HIDDEN_P (*slot);\n-\t\t  if (reveal)\n-\t\t    {\n-\t\t      if (STAT_TYPE (*slot))\n-\t\t\tSTAT_DECL_HIDDEN_P (*slot) = false;\n-\t\t      else\n-\t\t\t/* There is no type, just remove the stat\n-\t\t\t   hack.  */\n-\t\t\t*slot = decl;\n-\t\t    }\n+\t\t  if (STAT_TYPE (*slot))\n+\t\t    STAT_DECL_HIDDEN_P (*slot) = false;\n+\t\t  else\n+\t\t    /* There is no type, just remove the stat\n+\t\t       hack.  */\n+\t\t    *slot = decl;\n \t\t}\n-\t    }\n-\t}\n \n-      if (found)\n-\t{\n-\t  if (reveal)\n-\t    {\n-\t      /* Reveal the previously hidden thing.  */\n-\t      DECL_FRIEND_P (found) = false;\n-\n-\t      if (TREE_CODE (found) == TEMPLATE_DECL)\n-\t\t{\n-\t\t  tree res = DECL_TEMPLATE_RESULT (found);\n-\t\t  if (DECL_LANG_SPECIFIC (res))\n-\t\t    DECL_FRIEND_P (res) = false;\n-\t\t}\n-\t      else if (tree ti = TYPE_TEMPLATE_INFO (TREE_TYPE (found)))\n-\t\t{\n-\t\t  tree tmpl = TI_TEMPLATE (ti);\n-\t\t  DECL_FRIEND_P (tmpl) = false;\n-\t\t}\n+\t      return decl;\n \t    }\n-\n-\t  return found;\n \t}\n     }\n \n@@ -7017,18 +6967,8 @@ do_pushtag (tree name, tree type, TAG_how how)\n \n       tdef = create_implicit_typedef (name, type);\n       DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n-      bool is_friend = how == TAG_how::HIDDEN_FRIEND;\n-      if (is_friend)\n-\t{\n-\t  // FIXME: can go away\n-\t  /* This is a friend.  Make this TYPE_DECL node hidden from\n-\t     ordinary name lookup.  Its corresponding TEMPLATE_DECL\n-\t     will be marked in push_template_decl.  */\n-\t  retrofit_lang_decl (tdef);\n-\t  DECL_FRIEND_P (tdef) = 1;\n-\t}\n-\n-      decl = maybe_process_template_type_declaration (type, is_friend, b);\n+      decl = maybe_process_template_type_declaration\n+\t(type, how == TAG_how::HIDDEN_FRIEND, b);\n       if (decl == error_mark_node)\n \treturn decl;\n "}, {"sha": "503c0e722fad880669a56431cf16cacedcb5486a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -1181,7 +1181,7 @@ optimize_specialization_lookup_p (tree tmpl)\n \t     not have template information.  The optimized lookup relies\n \t     on having ARGS be the template arguments for both the class\n \t     and the function template.  */\n-\t  && !DECL_FRIEND_P (DECL_TEMPLATE_RESULT (tmpl)));\n+\t  && !DECL_UNIQUE_FRIEND_P (DECL_TEMPLATE_RESULT (tmpl)));\n }\n \n /* Make sure ARGS doesn't use any inappropriate typedefs; we should have\n@@ -5701,7 +5701,7 @@ push_template_decl (tree decl, bool is_friend)\n   /* No surprising friend functions.  */\n   gcc_checking_assert (is_friend\n \t\t       || !(TREE_CODE (decl) == FUNCTION_DECL\n-\t\t\t    && DECL_FRIEND_P (decl)));\n+\t\t\t    && DECL_UNIQUE_FRIEND_P (decl)));\n \n   if (is_friend)\n     /* For a friend, we want the context of the friend, not\n@@ -6022,10 +6022,6 @@ push_template_decl (tree decl, bool is_friend)\n       if (!ctx\n \t  && !(is_friend && template_class_depth (current_class_type) > 0))\n \t{\n-\t  /* Hide template friend classes that haven't been declared yet.  */\n-\t  if (is_friend && TREE_CODE (decl) == TYPE_DECL)\n-\t    DECL_FRIEND_P (tmpl) = 1;\n-\n \t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n \t  if (tmpl == error_mark_node)\n \t    return error_mark_node;\n@@ -13960,7 +13956,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n     if (!lambda_fntype)\n       set_constraints (r, ci);\n \n-  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))\n+  if (DECL_FRIEND_CONTEXT (t))\n     SET_DECL_FRIEND_CONTEXT (r,\n \t\t\t     tsubst (DECL_FRIEND_CONTEXT (t),\n \t\t\t\t     args, complain, in_decl));\n@@ -27049,7 +27045,7 @@ type_dependent_expression_p (tree expression)\n       && !(DECL_CLASS_SCOPE_P (expression)\n \t   && dependent_type_p (DECL_CONTEXT (expression)))\n       && !(DECL_LANG_SPECIFIC (expression)\n-\t   && DECL_FRIEND_P (expression)\n+\t   && DECL_UNIQUE_FRIEND_P (expression)\n \t   && (!DECL_FRIEND_CONTEXT (expression)\n \t       || dependent_type_p (DECL_FRIEND_CONTEXT (expression))))\n       && !DECL_LOCAL_DECL_P (expression))"}, {"sha": "d758df8b55604135ff6f64b9e6540fd3d343bc01", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068644a14976ce670c2b32c37e18f0aafeb05569/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068644a14976ce670c2b32c37e18f0aafeb05569/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=068644a14976ce670c2b32c37e18f0aafeb05569", "patch": "@@ -1649,7 +1649,7 @@ plugin_add_friend (cc1_plugin::connection * /* self */,\n     make_friend_class (type, TREE_TYPE (decl), true);\n   else\n     {\n-      DECL_FRIEND_P (decl) = true;\n+      DECL_UNIQUE_FRIEND_P (decl) = true;\n       add_friend (type, decl, true);\n     }\n "}]}