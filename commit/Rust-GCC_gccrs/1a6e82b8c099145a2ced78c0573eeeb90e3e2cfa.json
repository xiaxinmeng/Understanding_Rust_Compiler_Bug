{"sha": "1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2ZTgyYjhjMDk5MTQ1YTJjZWQ3OGMwNTczZWVlYjkwZTNlMmNmYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-10-13T18:56:48Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-10-13T18:56:48Z"}, "message": "i386.c (classify_argument): Use CEIL where applicable.\n\n\t* config/i386/i386.c (classify_argument): Use CEIL where applicable.\n\t(ix86_function_arg_advance): Ditto.\n\t(ix86_function_arg): Ditto.\n\t(ix86_gimplify_va_arg): Ditto.\n\t(ix86_class_max_nregs): Ditto.\n\t(inline_memory_move_cost): Ditto.\n\t(ix86_set_reg_reg_cost): Ditto.\n\t* config/i386/i386.h (HARD_REGNO_NREGS): Ditto.\n\nFrom-SVN: r228776", "tree": {"sha": "cb3c94a8e205516336ef93cf7c498c1bdc9f3bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb3c94a8e205516336ef93cf7c498c1bdc9f3bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5c2c8d7af79312d4df6dacbc8d58d027fd43ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c2c8d7af79312d4df6dacbc8d58d027fd43ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c2c8d7af79312d4df6dacbc8d58d027fd43ab2"}], "stats": {"total": 67, "additions": 39, "deletions": 28}, "files": [{"sha": "47119471d84d5f59bfa8cb9c06fd86bbb8fef2b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "patch": "@@ -1,9 +1,20 @@\n+2015-10-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (classify_argument): Use CEIL where applicable.\n+\t(ix86_function_arg_advance): Ditto.\n+\t(ix86_function_arg): Ditto.\n+\t(ix86_gimplify_va_arg): Ditto.\n+\t(ix86_class_max_nregs): Ditto.\n+\t(inline_memory_move_cost): Ditto.\n+\t(ix86_set_reg_reg_cost): Ditto.\n+\t* config/i386/i386.h (HARD_REGNO_NREGS): Ditto.\n+\n 2015-10-13  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR middle-end/67912\n \t* expmed.c (store_bit_field_1): Adjust mode of BLKmode inputs.\n \n-2015-10-12  Uros Bizjak  <ubizjak@gmail.com>\n+2015-10-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/sparc/sparc.h (SPARC_STACK_ALIGN): Implement using\n \tROUND_UP macro and UNITS_PER_WORD * 2."}, {"sha": "a2314e75ee67f143d0fdb7bed9c068a3bdd63c0b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "patch": "@@ -7925,8 +7925,7 @@ classify_argument (machine_mode mode, const_tree type,\n {\n   HOST_WIDE_INT bytes =\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n-  int words\n-    = (bytes + (bit_offset % 64) / 8 + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  int words = CEIL (bytes + (bit_offset % 64) / 8, UNITS_PER_WORD);\n \n   /* Variable sized entities are always passed/returned in memory.  */\n   if (bytes < 0)\n@@ -8791,7 +8790,7 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     bytes = int_size_in_bytes (type);\n   else\n     bytes = GET_MODE_SIZE (mode);\n-  words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  words = CEIL (bytes, UNITS_PER_WORD);\n \n   if (type)\n     mode = type_natural_mode (type, NULL, false);\n@@ -9124,7 +9123,7 @@ ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n     bytes = int_size_in_bytes (type);\n   else\n     bytes = GET_MODE_SIZE (mode);\n-  words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  words = CEIL (bytes, UNITS_PER_WORD);\n \n   /* To simplify the code below, represent vector types with a vector mode\n      even if MMX/SSE are not active.  */\n@@ -10271,7 +10270,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   if (indirect_p)\n     type = build_pointer_type (type);\n   size = int_size_in_bytes (type);\n-  rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  rsize = CEIL (size, UNITS_PER_WORD);\n \n   nat_mode = type_natural_mode (type, NULL, false);\n   switch (nat_mode)\n@@ -42971,7 +42970,7 @@ ix86_class_max_nregs (reg_class_t rclass, machine_mode mode)\n       else if (mode == XCmode)\n \treturn (TARGET_64BIT ? 4 : 6);\n       else\n-\treturn ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+\treturn CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n     }\n   else\n     {\n@@ -43130,8 +43129,7 @@ inline_memory_move_cost (machine_mode mode, enum reg_class regclass,\n \t  cost = ix86_cost->int_load[2];\n \telse\n \t  cost = ix86_cost->int_store[2];\n-\treturn (cost * (((int) GET_MODE_SIZE (mode)\n-\t\t        + UNITS_PER_WORD - 1) / UNITS_PER_WORD));\n+\treturn cost * CEIL ((int) GET_MODE_SIZE (mode), UNITS_PER_WORD);\n     }\n }\n \n@@ -43417,7 +43415,7 @@ ix86_set_reg_reg_cost (machine_mode mode)\n \n   /* Return the cost of moving between two registers of mode MODE,\n      assuming that the move will be in pieces of at most UNITS bytes.  */\n-  return COSTS_N_INSNS ((GET_MODE_SIZE (mode) + units - 1) / units);\n+  return COSTS_N_INSNS (CEIL (GET_MODE_SIZE (mode), units));\n }\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete"}, {"sha": "435312f0afca1efd586b960ce257f1155045762d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1a6e82b8c099145a2ced78c0573eeeb90e3e2cfa", "patch": "@@ -840,7 +840,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #endif\n #else\n #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n-   x86_field_alignment (FIELD, COMPUTED)\n+  x86_field_alignment ((FIELD), (COMPUTED))\n #endif\n \n /* If defined, a C expression to compute the alignment given to a\n@@ -928,7 +928,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    If this macro is not defined, then (ALIGN) will be used.  */\n \n #define MINIMUM_ALIGNMENT(EXP, MODE, ALIGN) \\\n-  ix86_minimum_alignment (EXP, MODE, ALIGN)\n+  ix86_minimum_alignment ((EXP), (MODE), (ALIGN))\n \n \n /* Set this nonzero if move instructions will actually fail to work\n@@ -1084,9 +1084,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n-      : (MODE) == XCmode\t\t\t\t\t\t\\\n-      ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n-      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n+      : ((MODE) == XCmode\t\t\t\t\t\t\\\n+\t ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\\\n+\t : CEIL (GET_MODE_SIZE (MODE), UNITS_PER_WORD))))\n \n #define HARD_REGNO_NREGS_HAS_PADDING(REGNO, MODE)\t\t\t\\\n   ((TARGET_128BIT_LONG_DOUBLE && !TARGET_64BIT)\t\t\t\t\\\n@@ -1188,7 +1188,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)  ix86_modes_tieable_p (MODE1, MODE2)\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ix86_modes_tieable_p ((MODE1), (MODE2))\n \n /* It is possible to write patterns to move flags; but until someone\n    does it,  */\n@@ -1462,7 +1463,7 @@ enum reg_class\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n+#define REGNO_REG_CLASS(REGNO) (regclass_map[(REGNO)])\n \n /* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n@@ -1602,7 +1603,7 @@ enum reg_class\n    and -8 for 64bit targets, we need to make sure all stack pointer adjustments\n    are in multiple of 4 for 32bit targets and 8 for 64bit targets.  */\n \n-#define PUSH_ROUNDING(BYTES) ROUND_UP (BYTES, UNITS_PER_WORD)\n+#define PUSH_ROUNDING(BYTES) ROUND_UP ((BYTES), UNITS_PER_WORD)\n \n /* If defined, the maximum amount of space required for outgoing arguments\n    will be computed and placed into the variable `crtl->outgoing_args_size'.\n@@ -1717,7 +1718,8 @@ typedef struct ix86_args {\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n-#define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  x86_function_profiler ((FILE), (LABELNO))\n \n #define MCOUNT_NAME \"_mcount\"\n \n@@ -2142,11 +2144,11 @@ extern int const x86_64_ms_sysv_extra_clobbered_registers[12];\n   gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n \n /* After the prologue, RA is at -4(AP) in the current frame.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t   \\\n-  ((COUNT) == 0\t\t\t\t\t\t\t\t   \\\n-   ? gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,\t   \\\n-\t\t\t\t\t-UNITS_PER_WORD))\t\t   \\\n-   : gen_rtx_MEM (Pmode, plus_constant (Pmode, FRAME, UNITS_PER_WORD)))\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n+  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n+   ? gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,\t\t\\\n+\t\t\t\t\t-UNITS_PER_WORD))\t\t\\\n+   : gen_rtx_MEM (Pmode, plus_constant (Pmode, (FRAME), UNITS_PER_WORD)))\n \n /* PC is dbx register 8; let's use that column for RA.  */\n #define DWARF_FRAME_RETURN_COLUMN \t(TARGET_64BIT ? 16 : 8)\n@@ -2242,7 +2244,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef ASM_OUTPUT_FUNCTION_LABEL\n #define ASM_OUTPUT_FUNCTION_LABEL(FILE, NAME, DECL) \\\n-  ix86_asm_output_function_label (FILE, NAME, DECL)\n+  ix86_asm_output_function_label ((FILE), (NAME), (DECL))\n \n /* Under some conditions we need jump tables in the text section,\n    because the assembler cannot handle label differences between\n@@ -2402,9 +2404,9 @@ enum avx_u128_state\n \n    Don't rename evex to non-evex sse registers.  */\n \n-#define HARD_REGNO_RENAME_OK(SRC, TARGET) (!STACK_REGNO_P (SRC) &&\t \\\n-\t\t\t\t\t   (EXT_REX_SSE_REGNO_P (SRC) == \\\n-\t\t\t\t\t    EXT_REX_SSE_REGNO_P (TARGET)))\n+#define HARD_REGNO_RENAME_OK(SRC, TARGET)\t\t\t\t\\\n+  (!STACK_REGNO_P (SRC)\t\t\t\t\t\t\t\\\n+   && EXT_REX_SSE_REGNO_P (SRC) == EXT_REX_SSE_REGNO_P (TARGET))\n \n \f\n #define FASTCALL_PREFIX '@'"}]}