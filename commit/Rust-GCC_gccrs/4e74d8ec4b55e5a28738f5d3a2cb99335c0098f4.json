{"sha": "4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3NGQ4ZWM0YjU1ZTVhMjg3MzhmNWQzYTJjYjk5MzM1YzAwOThmNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-03-11T18:57:23Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-03-11T18:57:23Z"}, "message": "Make long longs use normal CONST_DOUBLE in movdi, do not split too early\n\nFrom-SVN: r11513", "tree": {"sha": "b5fa20378e26ae7489158972aa94a5c3eecf201d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5fa20378e26ae7489158972aa94a5c3eecf201d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/comments", "author": null, "committer": null, "parents": [{"sha": "9740123d5c5e2fd32c7413dd9bdbdabdbb6b07b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9740123d5c5e2fd32c7413dd9bdbdabdbb6b07b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9740123d5c5e2fd32c7413dd9bdbdabdbb6b07b2"}], "stats": {"total": 304, "additions": 246, "deletions": 58}, "files": [{"sha": "34fdab7b23993b1515686550e834b115a7c6af82", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 102, "deletions": 10, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "patch": "@@ -524,6 +524,90 @@ reg_or_cint_operand (op, mode)\n      return GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode);\n }\n \n+/* Return the number of instructions it takes to form a constant in an\n+   integer register.  */\n+\n+static int\n+num_insns_constant_wide (value)\n+     HOST_WIDE_INT value;\n+{\n+  /* signed constant loadable with {cal|addi} */\n+  if (((unsigned HOST_WIDE_INT)value + 0x8000) < 0x10000)\n+    return 1;\n+\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  /* constant loadable with {cau|addis} */\n+  else if ((value & 0xffff) == 0)\n+    return 1;\n+\n+#else\n+  /* constant loadable with {cau|addis} */\n+  else if ((value & 0xffff) == 0 && (value & ~0xffffffff) == 0)\n+    return 1;\n+\n+  else if (TARGET_64BIT)\n+    {\n+      HOST_WIDE_INT low  = value & 0xffffffff;\n+      HOST_WIDE_INT high = value >> 32;\n+\n+      if (high == 0 && (low & 0x80000000) == 0)\n+\treturn 2;\n+\n+      else if (high == 0xffffffff && (low & 0x80000000) != 0)\n+\treturn 2;\n+\n+      else if (!low)\n+\treturn num_insns_constant_wide (high) + 1;\n+\n+      else\n+\treturn (num_insns_constant_wide (high)\n+\t\t+ num_insns_constant_low (low) + 1);\n+    }\n+#endif\n+\n+  else\n+    return 2;\n+}\n+\n+int\n+num_insns_constant (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != SImode && mode != DImode)\n+    abort ();\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return num_insns_constant_wide (INTVAL (op));\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE && TARGET_32BIT)\n+    return (num_insns_constant_wide (CONST_DOUBLE_LOW (op))\n+\t    + num_insns_constant_wide (CONST_DOUBLE_HIGH (op)));\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE && TARGET_64BIT)\n+    {\n+      HOST_WIDE_INT low  = CONST_DOUBLE_LOW (op);\n+      HOST_WIDE_INT high = CONST_DOUBLE_HIGH (op);\n+\n+      if (high == 0 && (low & 0x80000000) == 0)\n+\treturn num_insns_constant_wide (low);\n+\n+      else if (((high & 0xffffffff) == 0xffffffff)\n+\t       && ((low & 0x80000000) != 0))\n+\treturn num_insns_constant_wide (low);\n+\n+      else if (low == 0)\n+\treturn num_insns_constant_wide (high) + 1;\n+\n+      else\n+\treturn (num_insns_constant_wide (high)\n+\t\t+ num_insns_constant_wide (low) + 1);\n+    }\n+\n+  else\n+    abort ();\n+}\n+\n /* Return 1 if the operand is a CONST_DOUBLE and it can be put into a register\n    with one instruction per word.  We only do this if we can safely read\n    CONST_DOUBLE_{LOW,HIGH}.  */\n@@ -535,11 +619,11 @@ easy_fp_constant (op, mode)\n {\n   if (GET_CODE (op) != CONST_DOUBLE\n       || GET_MODE (op) != mode\n-      || GET_MODE_CLASS (mode) != MODE_FLOAT)\n+      || (GET_MODE_CLASS (mode) != MODE_FLOAT && mode != DImode))\n     return 0;\n \n   /* Consider all constants with -msoft-float to be easy */\n-  if (TARGET_SOFT_FLOAT)\n+  if (TARGET_SOFT_FLOAT && mode != DImode)\n     return 1;\n \n   if (mode == DFmode)\n@@ -550,19 +634,26 @@ easy_fp_constant (op, mode)\n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n \n-      return (((unsigned) (k[0] + 0x8000) < 0x10000 || (k[0] & 0xffff) == 0)\n-\t      && ((unsigned) (k[1] + 0x8000) < 0x10000 || (k[1] & 0xffff) == 0));\n+      return (num_insns_constant_wide ((HOST_WIDE_INT)k[0]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT)k[1]) == 1);\n     }\n-  else\n+\n+  else if (mode == SFmode)\n     {\n       long l;\n       REAL_VALUE_TYPE rv;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n-      return ((unsigned) (l + 0x8000) < 0x10000 || (l & 0xffff) == 0);\n+      return num_insns_constant_wide (l) == 1;\n     }\n+\n+  else if (mode == DImode && TARGET_32BIT)\n+    return num_insns_constant (op, DImode) == 2;\n+\n+  else\n+    abort ();\n }\n \n /* Return 1 if the operand is in volatile memory.  Note that during the\n@@ -821,6 +912,11 @@ input_operand (op, mode)\n       && easy_fp_constant (op, mode))\n     return 1;\n \n+  /* Allow any integer constant.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE))\n+    return 1;\n+\n   /* For floating-point or multi-word mode, the only remaining valid type\n      is a register.  */\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -833,10 +929,6 @@ input_operand (op, mode)\n   if (register_operand (op, mode))\n     return 1;\n \n-  /* For integer modes, any constant is ok.  */\n-  if (GET_CODE (op) == CONST_INT)\n-    return 1;\n-\n   /* A SYMBOL_REF referring to the TOC is valid.  */\n   if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (op))\n     return 1;"}, {"sha": "aa1e5f0af539a6557701f2773eff7f359634d1c7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "patch": "@@ -995,10 +995,14 @@ enum reg_class\n    Here VALUE is the CONST_DOUBLE rtx itself.\n \n    We flag for special constants when we can copy the constant into\n-   a general register in two insns for DF and one insn for SF.  */\n+   a general register in two insns for DF/DI and one insn for SF.\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? easy_fp_constant (VALUE, GET_MODE (VALUE)) : 0)\n+   'H' is used for DI constants that take 3 insns.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'G' ? easy_fp_constant (VALUE, GET_MODE (VALUE)) :\t\t\\\n+   (C) == 'H' ? (num_insns_constant (VALUE, DImode) == 3) :\t\t\\\n+   0)\n \n /* Optional extra constraints for this machine.\n \n@@ -2819,6 +2823,7 @@ extern int reg_or_short_operand ();\n extern int reg_or_neg_short_operand ();\n extern int reg_or_u_short_operand ();\n extern int reg_or_cint_operand ();\n+extern int num_insns_constant ();\n extern int easy_fp_constant ();\n extern int volatile_mem_operand ();\n extern int offsettable_addr_operand ();"}, {"sha": "5c47d6a36483ec091f23df836e1b8935c903ed69", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 136, "deletions": 45, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "patch": "@@ -5429,8 +5429,9 @@\n   if (GET_CODE (operands[0]) != REG)\n     operands[1] = force_reg (DImode, operands[1]);\n \n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      || GET_CODE (operands[1]) == CONST_INT)\n+  if (TARGET_64BIT\n+      && (GET_CODE (operands[1]) == CONST_DOUBLE\n+\t  || GET_CODE (operands[1]) == CONST_INT))\n     {\n       HOST_WIDE_INT low;\n       HOST_WIDE_INT high;\n@@ -5453,39 +5454,23 @@\n \t}\n #endif\n \n-      if (! TARGET_POWERPC64)\n-\t{\n-\t  emit_move_insn (gen_rtx (SUBREG, SImode, operands[0],\n-\t\t\t  WORDS_BIG_ENDIAN), GEN_INT (low));\n-\n-\t  emit_move_insn (gen_rtx (SUBREG, SImode, operands[0],\n-\t\t\t  ! WORDS_BIG_ENDIAN), GEN_INT (high));\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  if (high + 0x8000 >= 0x10000)\n-\t    {\n-\t      emit_move_insn (gen_rtx (SUBREG, SImode, operands[0], 1),\n-\t\t\t      GEN_INT (high));\n-\t      emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT(32)));\n-\t      if (low)\n-\t\t{\n-\t\t  HOST_WIDE_INT low_low = low & 0xffff;\n-\t\t  HOST_WIDE_INT low_high = low & (~ (HOST_WIDE_INT) 0xffff);\n-\t\t  if (low_high)\n-\t\t    emit_insn (gen_iordi3 (operands[0], operands[0],\n-\t\t\t\t\t   GEN_INT (low_high)));\n-\t\t  if (low_low)\n-\t\t    emit_insn (gen_iordi3 (operands[0], operands[0],\n-\t\t\t\t\t   GEN_INT (low_low)));\n-\t        }\n-\t    }\n-\t  else if (low)\n-\t    emit_move_insn (gen_rtx (SUBREG, SImode, operands[0], 1),\n-\t\t\t    GEN_INT (low));\n-\t  DONE;\n-        }\n+\tif (high)\n+\t  {\n+\t    emit_move_insn (operands[0], GEN_INT (high));\n+\t    emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT(32)));\n+\t    if (low)\n+\t      {\n+\t\tHOST_WIDE_INT low_low = low & 0xffff;\n+\t\tHOST_WIDE_INT low_high = low & (~ (HOST_WIDE_INT) 0xffff);\n+\t\tif (low_high)\n+\t\t  emit_insn (gen_iordi3 (operands[0], operands[0],\n+\t\t\t\t\t GEN_INT (low_high)));\n+\t\tif (low_low)\n+\t\t  emit_insn (gen_iordi3 (operands[0], operands[0],\n+\t\t\t\t\t GEN_INT (low_low)));\n+\t      }\n+\t      DONE;\n+\t  }\n     }\n \n       /* Stores between FPR and any non-FPR registers must go through a\n@@ -5506,10 +5491,11 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f\"))]\n-  \"! TARGET_POWERPC64 && (gpc_reg_operand (operands[0], DImode)\n-   || gpc_reg_operand (operands[1], DImode))\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m,r,r,r,r,r\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f,IJK,n,G,H,F\"))]\n+  \"TARGET_32BIT\n+   && (gpc_reg_operand (operands[0], DImode)\n+       || gpc_reg_operand (operands[1], DImode))\"\n   \"*\n {\n   switch (which_alternative)\n@@ -5540,16 +5526,121 @@\n       return \\\"lfd%U1%X1 %0,%1\\\";\n     case 5:\n       return \\\"stfd%U0%X0 %1,%0\\\";\n+    case 6:\n+    case 7:\n+    case 8:\n+    case 9:\n+    case 10:\n+      return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore\")\n-   (set_attr \"length\" \"8,8,8,*,*,*\")])\n+  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore,*,*,*,*,*\")\n+   (set_attr \"length\" \"8,8,8,*,*,*,8,12,8,12,16\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) <= 1\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 1))]\n+  \"\n+{\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) >= 2\"\n+  [(set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 6)))]\n+  \"\n+{\n+  HOST_WIDE_INT value = INTVAL (operands[1]);\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n+  operands[5] = GEN_INT (value & 0xffff0000);\n+  operands[6] = GEN_INT (value & 0x0000ffff);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) <= 2\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"\n+{\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n+  operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) == 3\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))]\n+  \"\n+{\n+  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n+  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n+  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  rtx low_reg  = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+\n+  if (((unsigned HOST_WIDE_INT) (low + 0x8000) < 0x10000)\n+      || (low & 0xffff) == 0)\n+    {\n+      operands[2] = high_reg;\n+      operands[3] = low_reg;\n+      operands[4] = GEN_INT (high & 0xffff0000);\n+      operands[5] = GEN_INT (low);\n+      operands[6] = GEN_INT (high & 0x0000ffff);\n+    }\n+  else\n+    {\n+      operands[2] = low_reg;\n+      operands[3] = high_reg;\n+      operands[4] = GEN_INT (low & 0xffff0000);\n+      operands[5] = GEN_INT (high);\n+      operands[6] = GEN_INT (low & 0x0000ffff);\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) >= 4\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 7)))]\n+  \"\n+{\n+  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n+  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n+\n+  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[4] = GEN_INT (high & 0xffff0000);\n+  operands[5] = GEN_INT (low  & 0xffff0000);\n+  operands[6] = GEN_INT (high & 0x0000ffff);\n+  operands[7] = GEN_INT (low  & 0x0000ffff);\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,f,f,m,r,*h,*h\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,J,n,R,f,m,f,*h,r,0\"))]\n-  \"TARGET_POWERPC64 && (gpc_reg_operand (operands[0], DImode)\n-   || gpc_reg_operand (operands[1], DImode))\"\n+\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,J,nF,R,f,m,f,*h,r,0\"))]\n+  \"TARGET_64BIT\n+   && (gpc_reg_operand (operands[0], DImode)\n+       || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n    mr %0,%1\n    ld%U1%X1 %0,%1\n@@ -5574,7 +5665,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_64BIT && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)"}]}