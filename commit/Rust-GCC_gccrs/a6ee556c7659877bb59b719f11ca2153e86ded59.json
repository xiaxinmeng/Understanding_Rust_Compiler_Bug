{"sha": "a6ee556c7659877bb59b719f11ca2153e86ded59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZlZTU1NmM3NjU5ODc3YmI1OWI3MTlmMTFjYTIxNTNlODZkZWQ1OQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-10T03:23:25Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-11T01:43:53Z"}, "message": "c++: Fix return type deduction with an abbreviated function template\n\nThis patch fixes two issues with return type deduction in the presence of an\nabbreviated function template.\n\nThe first issue (PR 69448) is that if a placeholder auto return type contains\nany modifiers such as & or *, then the abbreviated function template\ncompensation in splice_late_return_type does not get performed for the\nunderlying auto node, leading to incorrect return type deduction.  This happens\nbecause splice_late_return_type does not consider that a placeholder auto return\ntype might have modifiers.  To fix this it seems we need to look through\nmodifiers in the return type to obtain the location of the underlying auto node\nin order to replace it with the adjusted auto node.  To that end this patch\nrefactors the utility function find_type_usage to return a pointer to the\nmatched tree, and uses it to find and replace the underlying auto node.\n\nThe second issue (PR 80471) is that the AUTO_IS_DECLTYPE flag is not being\npreserved in splice_late_return_type when compensating for an abbreviated\nfunction template, leading to us treating a decltype(auto) return type as if it\nwas an auto return type.  Fixed by making make_auto_1 set the AUTO_IS_DECLTYPE\nflag whenever we're building a decltype(auto) node and adjusting callers\nappropriately.  The test for PR 80471 is adjusted to expect the correct\nbehavior.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/69448\n\tPR c++/80471\n\t* type-utils.h (find_type_usage): Refactor to take a tree * and to\n\treturn a tree *, and update documentation accordingly.\n\t* pt.c (make_auto_1): Set AUTO_IS_DECLTYPE when building a\n\tdecltype(auto) node.\n\t(make_constrained_decltype_auto): No need to explicitly set\n\tAUTO_IS_DECLTYPE anymore.\n\t(splice_late_return_type): Use find_type_usage to find and\n\treplace a possibly nested auto node instead of using is_auto.\n\tCheck test for is_auto into an assert when deciding whether\n\tto late_return_type.\n\t(type_uses_auto): Adjust the call to find_type_usage.\n\t* parser.c (cp_parser_decltype): No need to explicitly set\n\tAUTO_IS_DECLTYPE anymore.\n\nlibcc1/ChangeLog:\n\n\tPR c++/69448\n\tPR c++/80471\n\t* libcp1plugin.cc (plugin_get_expr_type): No need to explicitly set\n\tAUTO_IS_DECLTYPE anymore.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/69448\n\tPR c++/80471\n\t* g++.dg/concepts/abbrev3.C: New test.\n\t* g++.dg/cpp2a/concepts-pr80471.C: Adjust a static_assert to expect the\n\tcorrect behavior.\n\t* g++.dg/cpp0x/auto9.C: Adjust a dg-error directive.", "tree": {"sha": "68715d97e842e051dda449c38fea6fe51d98be16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68715d97e842e051dda449c38fea6fe51d98be16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ee556c7659877bb59b719f11ca2153e86ded59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee556c7659877bb59b719f11ca2153e86ded59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ee556c7659877bb59b719f11ca2153e86ded59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee556c7659877bb59b719f11ca2153e86ded59/comments", "author": null, "committer": null, "parents": [{"sha": "91f4fc40bcf666eb57d566198981dc8e8eff9ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f4fc40bcf666eb57d566198981dc8e8eff9ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f4fc40bcf666eb57d566198981dc8e8eff9ccb"}], "stats": {"total": 104, "additions": 72, "deletions": 32}, "files": [{"sha": "bf7bf5f71d1358c1be7839330e8c865f96630937", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -1,5 +1,21 @@\n 2020-02-12  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/69448\n+\tPR c++/80471\n+\t* type-utils.h (find_type_usage): Refactor to take a tree * and to\n+\treturn a tree *, and update documentation accordingly.\n+\t* pt.c (make_auto_1): Set AUTO_IS_DECLTYPE when building a\n+\tdecltype(auto) node.\n+\t(make_constrained_decltype_auto): No need to explicitly set\n+\tAUTO_IS_DECLTYPE anymore.\n+\t(splice_late_return_type): Use find_type_usage to find and\n+\treplace a possibly nested auto node instead of using is_auto.\n+\tCheck test for is_auto into an assert when deciding whether\n+\tto late_return_type.\n+\t(type_uses_auto): Adjust the call to find_type_usage.\n+\t* parser.c (cp_parser_decltype): No need to explicitly set\n+\tAUTO_IS_DECLTYPE anymore.\n+\n \t* error.c (dump_decl) [CONCEPT_DECL]: Use dump_simple_decl.\n \t(dump_simple_decl): Handle standard concept definitions as well as\n \tvariable concept definitions."}, {"sha": "640affd836850939c367e25fd9d742c87990b1e4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -14901,11 +14901,8 @@ cp_parser_decltype (cp_parser *parser)\n     }\n \n   if (!expr)\n-    {\n-      /* Build auto.  */\n-      expr = make_decltype_auto ();\n-      AUTO_IS_DECLTYPE (expr) = true;\n-    }\n+    /* Build auto.  */\n+    expr = make_decltype_auto ();\n   else\n     expr = finish_decltype_type (expr, id_expression_or_member_access_p,\n \t\t\t\t tf_warning_or_error);"}, {"sha": "c2d3a98b1c5641b492cf96c929993721fbfa543b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -27513,6 +27513,8 @@ make_auto_1 (tree name, bool set_canonical)\n     TYPE_CANONICAL (au) = canonical_type_parameter (au);\n   DECL_ARTIFICIAL (TYPE_NAME (au)) = 1;\n   SET_DECL_TEMPLATE_PARM_P (TYPE_NAME (au));\n+  if (name == decltype_auto_identifier)\n+    AUTO_IS_DECLTYPE (au) = true;\n \n   return au;\n }\n@@ -27590,8 +27592,6 @@ tree\n make_constrained_decltype_auto (tree con, tree args)\n {\n   tree type = make_auto_1 (decltype_auto_identifier, false);\n-  /* FIXME: I don't know why this isn't done in make_auto_1.  */\n-  AUTO_IS_DECLTYPE (type) = true;\n   return make_constrained_placeholder_type (type, con, args);\n }\n \n@@ -28904,17 +28904,20 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n tree\n splice_late_return_type (tree type, tree late_return_type)\n {\n-  if (is_auto (type))\n+  if (late_return_type)\n     {\n-      if (late_return_type)\n-\treturn late_return_type;\n+      gcc_assert (is_auto (type) || seen_error ());\n+      return late_return_type;\n+    }\n \n-      tree idx = get_template_parm_index (type);\n+  if (tree *auto_node = find_type_usage (&type, is_auto))\n+    {\n+      tree idx = get_template_parm_index (*auto_node);\n       if (TEMPLATE_PARM_LEVEL (idx) <= processing_template_decl)\n \t/* In an abbreviated function template we didn't know we were dealing\n \t   with a function template when we saw the auto return type, so update\n \t   it to have the correct level.  */\n-\treturn make_auto_1 (TYPE_IDENTIFIER (type), true);\n+\t*auto_node = make_auto_1 (TYPE_IDENTIFIER (*auto_node), true);\n     }\n   return type;\n }\n@@ -28960,8 +28963,10 @@ type_uses_auto (tree type)\n       else\n \treturn NULL_TREE;\n     }\n+  else if (tree *tp = find_type_usage (&type, is_auto))\n+    return *tp;\n   else\n-    return find_type_usage (type, is_auto);\n+    return NULL_TREE;\n }\n \n /* Report ill-formed occurrences of auto types in ARGUMENTS.  If"}, {"sha": "4ad0d822119a147430f9a4b39d235edc7a4a4664", "filename": "gcc/cp/type-utils.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Ftype-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Fcp%2Ftype-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftype-utils.h?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -20,36 +20,36 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CP_TYPE_UTILS_H\n #define GCC_CP_TYPE_UTILS_H\n \n-/* Returns the first tree within T that is directly matched by PRED.  T may be a\n-   type or PARM_DECL and is incrementally decomposed toward its type-specifier\n-   until a match is found.  NULL_TREE is returned if PRED does not match any\n-   part of T.\n+/* Returns a pointer to the first tree within *TP that is directly matched by\n+   PRED.  *TP may be a type or PARM_DECL and is incrementally decomposed toward\n+   its type-specifier until a match is found.  NULL is returned if PRED does not\n+   match any part of *TP.\n \n-   This is primarily intended for detecting whether T uses `auto' or a concept\n+   This is primarily intended for detecting whether *TP uses `auto' or a concept\n    identifier.  Since either of these can only appear as a type-specifier for\n    the declaration in question, only top-level qualifications are traversed;\n    find_type_usage does not look through the whole type.  */\n \n-inline tree\n-find_type_usage (tree t, bool (*pred) (const_tree))\n+inline tree *\n+find_type_usage (tree *tp, bool (*pred) (const_tree))\n {\n-  enum tree_code code;\n+  tree t = *tp;\n   if (pred (t))\n-    return t;\n+    return tp;\n \n-  code = TREE_CODE (t);\n+  enum tree_code code = TREE_CODE (t);\n \n   if (code == POINTER_TYPE || code == REFERENCE_TYPE\n       || code == PARM_DECL || code == OFFSET_TYPE\n       || code == FUNCTION_TYPE || code == METHOD_TYPE\n       || code == ARRAY_TYPE)\n-    return find_type_usage (TREE_TYPE (t), pred);\n+    return find_type_usage (&TREE_TYPE (t), pred);\n \n   if (TYPE_PTRMEMFUNC_P (t))\n     return find_type_usage\n-      (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t)), pred);\n+      (&TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t)), pred);\n \n-  return NULL_TREE;\n+  return NULL;\n }\n \n #endif // GCC_CP_TYPE_UTILS_H"}, {"sha": "81ebea01c17d3fcc279ec9e043a3d573a949a9a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -1,5 +1,12 @@\n 2020-02-12  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/69448\n+\tPR c++/80471\n+\t* g++.dg/concepts/abbrev3.C: New test.\n+\t* g++.dg/cpp2a/concepts-pr80471.C: Adjust a static_assert to expect the\n+\tcorrect behavior.\n+\t* g++.dg/cpp0x/auto9.C: Adjust a dg-error directive.\n+\n \t* g++.dg/cpp2a/concepts6.C: New test.\n \n 2020-02-10  David Malcolm  <dmalcolm@redhat.com>"}, {"sha": "ba2a648156e848194b706423f11b1941973bf7c7", "filename": "gcc/testsuite/g++.dg/concepts/abbrev3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev3.C?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/69448\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options \"-fconcepts\" }\n+\n+long x;\n+\n+auto& f(auto) { return x; }\n+auto* g(auto) { return &x; }\n+\n+long& r = f(1);\n+long* p = g(1);"}, {"sha": "a3f9be521d608b077440018f5e9b873f49a04a7e", "filename": "gcc/testsuite/g++.dg/cpp0x/auto9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -22,7 +22,7 @@ struct A\n struct A2\n {\n   operator auto () -> int;\t\t\t// { dg-error \"invalid use of|trailing return type\" }\n-  operator auto*() -> int;\t\t\t// { dg-error \"invalid use of|trailing return type\" }\n+  operator auto*() -> int;\t\t\t// { dg-error \"invalid use of|trailing return type|cannot be overloaded\" }\n };\n \n template <typename> struct B"}, {"sha": "6ea6164b41729d0752f40a8a681ec1ed16e5456b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr80471.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr80471.C?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -18,6 +18,6 @@ int main()\n {\n   int i;\n   static_assert(is_same< decltype(f(i)), int& >, \"\");\n-  static_assert(is_same< decltype(g(i)), int  >, \"\");\n+  static_assert(is_same< decltype(g(i)), int& >, \"\");\n   static_assert(is_same< decltype(z(i)), int& >, \"\");\n }"}, {"sha": "d80a0daab43f6ffbb428362009fbeab22837f559", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -1,3 +1,10 @@\n+2020-02-12  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/69448\n+\tPR c++/80471\n+\t* libcp1plugin.cc (plugin_get_expr_type): No need to explicitly set\n+\tAUTO_IS_DECLTYPE anymore.\n+\n 2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* libcp1plugin.cc (plugin_build_new_expr): Update build_new call."}, {"sha": "00449f43b52d4b81a89c4bb42e596b646180382e", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee556c7659877bb59b719f11ca2153e86ded59/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee556c7659877bb59b719f11ca2153e86ded59/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=a6ee556c7659877bb59b719f11ca2153e86ded59", "patch": "@@ -3343,10 +3343,7 @@ plugin_get_expr_type (cc1_plugin::connection *self,\n   if (op0)\n     type = TREE_TYPE (op0);\n   else\n-    {\n-      type = make_decltype_auto ();\n-      AUTO_IS_DECLTYPE (type) = true;\n-    }\n+    type = make_decltype_auto ();\n   return convert_out (ctx->preserve (type));\n }\n "}]}