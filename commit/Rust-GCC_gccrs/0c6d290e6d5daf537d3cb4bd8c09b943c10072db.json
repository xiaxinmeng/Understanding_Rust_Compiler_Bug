{"sha": "0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2ZDI5MGU2ZDVkYWY1MzdkM2NiNGJkOGMwOWI5NDNjMTAwNzJkYg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2010-11-13T23:04:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-11-13T23:04:26Z"}, "message": "tm.texi.in (OVERLAPPING_REGISTER_NAMES): Document new macro.\n\n\t* tm.texi.in (OVERLAPPING_REGISTER_NAMES): Document new macro.\n\t* tm.texi: Regenerated.\n\t* output.h (decode_reg_name_and_count): Declare.\n\t* varasm.c (decode_reg_name_and_count): New function.\n\t(decode_reg_name): Reimplement using decode_reg_name_and_count.\n\t* reginfo.c (fix_register): Use decode_reg_name_and_count and \n\titerate over all regs used.\n\t* stmt.c (expand_asm_operands): Likewise.\n\t* arm/aout.h (OVERLAPPING_REGISTER_NAMES): Define.\n\t(ADDITIONAL_REGISTER_NAMES): Remove aliases that overlap\n\tmultiple machine registers.\n\nFrom-SVN: r166722", "tree": {"sha": "4d5e92ee2775c360fc918228cb97e2a2af9270e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d5e92ee2775c360fc918228cb97e2a2af9270e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/comments", "author": null, "committer": null, "parents": [{"sha": "985c87c94e17bb6b69c06783ca9cc51bbcb6225c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985c87c94e17bb6b69c06783ca9cc51bbcb6225c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985c87c94e17bb6b69c06783ca9cc51bbcb6225c"}], "stats": {"total": 304, "additions": 211, "deletions": 93}, "files": [{"sha": "7f3b465dc6991d899bcda6c50fdb78d919fedb5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -1,3 +1,17 @@\n+2010-11-13  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* tm.texi.in (OVERLAPPING_REGISTER_NAMES): Document new macro.\n+\t* tm.texi: Regenerated.\n+\t* output.h (decode_reg_name_and_count): Declare.\n+\t* varasm.c (decode_reg_name_and_count): New function.\n+\t(decode_reg_name): Reimplement using decode_reg_name_and_count.\n+\t* reginfo.c (fix_register): Use decode_reg_name_and_count and \n+\titerate over all regs used.\n+\t* stmt.c (expand_asm_operands): Likewise.\n+\t* arm/aout.h (OVERLAPPING_REGISTER_NAMES): Define.\n+\t(ADDITIONAL_REGISTER_NAMES): Remove aliases that overlap\n+\tmultiple machine registers.\n+\n 2010-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* stor-layout.c (place_union_field): Do not put location information"}, {"sha": "b5f7109d86833fcc0a154762734d147530fa6947", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -163,31 +163,45 @@\n   {\"mvdx12\", 39},\t\t\t\t\\\n   {\"mvdx13\", 40},\t\t\t\t\\\n   {\"mvdx14\", 41},\t\t\t\t\\\n-  {\"mvdx15\", 42},\t\t\t\t\\\n-  {\"d0\", 63}, {\"q0\", 63},\t\t\t\\\n-  {\"d1\", 65},\t\t\t\t\t\\\n-  {\"d2\", 67}, {\"q1\", 67},\t\t\t\\\n-  {\"d3\", 69},\t\t\t\t\t\\\n-  {\"d4\", 71}, {\"q2\", 71},\t\t\t\\\n-  {\"d5\", 73},\t\t\t\t\t\\\n-  {\"d6\", 75}, {\"q3\", 75},\t\t\t\\\n-  {\"d7\", 77},\t\t\t\t\t\\\n-  {\"d8\", 79}, {\"q4\", 79},\t\t\t\\\n-  {\"d9\", 81},\t\t\t\t\t\\\n-  {\"d10\", 83}, {\"q5\", 83},\t\t\t\\\n-  {\"d11\", 85},\t\t\t\t\t\\\n-  {\"d12\", 87}, {\"q6\", 87},\t\t\t\\\n-  {\"d13\", 89},\t\t\t\t\t\\\n-  {\"d14\", 91}, {\"q7\", 91},\t\t\t\\\n-  {\"d15\", 93},\t\t\t\t\t\\\n-  {\"q8\", 95},\t\t\t\t\t\\\n-  {\"q9\", 99},\t\t\t\t\t\\\n-  {\"q10\", 103},\t\t\t\t\t\\\n-  {\"q11\", 107},\t\t\t\t\t\\\n-  {\"q12\", 111},\t\t\t\t\t\\\n-  {\"q13\", 115},\t\t\t\t\t\\\n-  {\"q14\", 119},\t\t\t\t\t\\\n-  {\"q15\", 123}\t\t\t\t\t\\\n+  {\"mvdx15\", 42}\t\t\t\t\\\n+}\n+#endif\n+\n+#ifndef OVERLAPPING_REGISTER_NAMES\n+#define OVERLAPPING_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"d0\", 63, 2},\t\t\t\t\\\n+  {\"d1\", 65, 2},\t\t\t\t\\\n+  {\"d2\", 67, 2},\t\t\t\t\\\n+  {\"d3\", 69, 2},\t\t\t\t\\\n+  {\"d4\", 71, 2},\t\t\t\t\\\n+  {\"d5\", 73, 2},\t\t\t\t\\\n+  {\"d6\", 75, 2},\t\t\t\t\\\n+  {\"d7\", 77, 2},\t\t\t\t\\\n+  {\"d8\", 79, 2},\t\t\t\t\\\n+  {\"d9\", 81, 2},\t\t\t\t\\\n+  {\"d10\", 83, 2},\t\t\t\t\\\n+  {\"d11\", 85, 2},\t\t\t\t\\\n+  {\"d12\", 87, 2},\t\t\t\t\\\n+  {\"d13\", 89, 2},\t\t\t\t\\\n+  {\"d14\", 91, 2},\t\t\t\t\\\n+  {\"d15\", 93, 2},\t\t\t\t\\\n+  {\"q0\", 63, 4},\t\t\t\t\\\n+  {\"q1\", 67, 4},\t\t\t\t\\\n+  {\"q2\", 71, 4},\t\t\t\t\\\n+  {\"q3\", 75, 4},\t\t\t\t\\\n+  {\"q4\", 79, 4},\t\t\t\t\\\n+  {\"q5\", 83, 4},\t\t\t\t\\\n+  {\"q6\", 87, 4},\t\t\t\t\\\n+  {\"q7\", 91, 4},\t\t\t\t\\\n+  {\"q8\", 95, 4},\t\t\t\t\\\n+  {\"q9\", 99, 4},\t\t\t\t\\\n+  {\"q10\", 103, 4},\t\t\t\t\\\n+  {\"q11\", 107, 4},\t\t\t\t\\\n+  {\"q12\", 111, 4},\t\t\t\t\\\n+  {\"q13\", 115, 4},\t\t\t\t\\\n+  {\"q14\", 119, 4},\t\t\t\t\\\n+  {\"q15\", 123, 4}\t\t\t\t\\\n }\n #endif\n "}, {"sha": "54465014613fce2870f3a128c17ee8ff85bbd20a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -8479,6 +8479,22 @@ registers, thus allowing the @code{asm} option in declarations to refer\n to registers using alternate names.\n @end defmac\n \n+@defmac OVERLAPPING_REGISTER_NAMES\n+If defined, a C initializer for an array of structures containing a\n+name, a register number and a count of the number of consecutive\n+machine registers the name overlaps.  This macro defines additional\n+names for hard registers, thus allowing the @code{asm} option in\n+declarations to refer to registers using alternate names.  Unlike\n+@code{ADDITIONAL_REGISTER_NAMES}, this macro should be used when the\n+register name implies multiple underlying registers.\n+\n+This macro should be used when it is important that a clobber in an\n+@code{asm} statement clobbers all the underlying values implied by the\n+register name.  For example, on ARM, clobbering the double-precision\n+VFP register ``d0'' implies clobbering both single-precision registers\n+``s0'' and ``s1''.\n+@end defmac\n+\n @defmac ASM_OUTPUT_OPCODE (@var{stream}, @var{ptr})\n Define this macro if you are using an unusual assembler that\n requires different names for the machine instructions."}, {"sha": "4b21c9295ff99e6d8dc83d9e74a97155f7dcde31", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -8453,6 +8453,22 @@ registers, thus allowing the @code{asm} option in declarations to refer\n to registers using alternate names.\n @end defmac\n \n+@defmac OVERLAPPING_REGISTER_NAMES\n+If defined, a C initializer for an array of structures containing a\n+name, a register number and a count of the number of consecutive\n+machine registers the name overlaps.  This macro defines additional\n+names for hard registers, thus allowing the @code{asm} option in\n+declarations to refer to registers using alternate names.  Unlike\n+@code{ADDITIONAL_REGISTER_NAMES}, this macro should be used when the\n+register name implies multiple underlying registers.\n+\n+This macro should be used when it is important that a clobber in an\n+@code{asm} statement clobbers all the underlying values implied by the\n+register name.  For example, on ARM, clobbering the double-precision\n+VFP register ``d0'' implies clobbering both single-precision registers\n+``s0'' and ``s1''.\n+@end defmac\n+\n @defmac ASM_OUTPUT_OPCODE (@var{stream}, @var{ptr})\n Define this macro if you are using an unusual assembler that\n requires different names for the machine instructions."}, {"sha": "07372a388a13477e5b39f1d3899d33542366d32c", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -177,6 +177,11 @@ extern enum tls_model decl_default_tls_model (const_tree);\n    Prefixes such as % are optional.  */\n extern int decode_reg_name (const char *);\n \n+/* Similar to decode_reg_name, but takes an extra parameter that is a\n+   pointer to the number of (internal) registers described by the\n+   external name.  */\n+extern int decode_reg_name_and_count (const char *, int *);\n+\n extern void assemble_alias (tree, tree);\n \n extern void default_assemble_visibility (tree, int);"}, {"sha": "86a20d31feb371b9cefb2ae7ec713222f227f5ca", "filename": "gcc/reginfo.c", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -755,64 +755,69 @@ void\n fix_register (const char *name, int fixed, int call_used)\n {\n   int i;\n+  int reg, nregs;\n \n   /* Decode the name and update the primary form of\n      the register info.  */\n \n-  if ((i = decode_reg_name (name)) >= 0)\n+  if ((reg = decode_reg_name_and_count (name, &nregs)) >= 0)\n     {\n-      if ((i == STACK_POINTER_REGNUM\n+      gcc_assert (nregs >= 1);\n+      for (i = reg; i < reg + nregs; i++)\n+\t{\n+\t  if ((i == STACK_POINTER_REGNUM\n #ifdef HARD_FRAME_POINTER_REGNUM\n-\t   || i == HARD_FRAME_POINTER_REGNUM\n+\t       || i == HARD_FRAME_POINTER_REGNUM\n #else\n-\t   || i == FRAME_POINTER_REGNUM\n+\t       || i == FRAME_POINTER_REGNUM\n #endif\n-\t   )\n-\t  && (fixed == 0 || call_used == 0))\n-\t{\n-\t  switch (fixed)\n+\t       )\n+\t      && (fixed == 0 || call_used == 0))\n \t    {\n-\t    case 0:\n-\t      switch (call_used)\n+\t      switch (fixed)\n \t\t{\n \t\tcase 0:\n-\t\t  error (\"can%'t use %qs as a call-saved register\", name);\n+\t\t  switch (call_used)\n+\t\t    {\n+\t\t    case 0:\n+\t\t      error (\"can%'t use %qs as a call-saved register\", name);\n+\t\t      break;\n+\n+\t\t    case 1:\n+\t\t      error (\"can%'t use %qs as a call-used register\", name);\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n \t\t  break;\n \n \t\tcase 1:\n-\t\t  error (\"can%'t use %qs as a call-used register\", name);\n+\t\t  switch (call_used)\n+\t\t    {\n+\t\t    case 1:\n+\t\t      error (\"can%'t use %qs as a fixed register\", name);\n+\t\t      break;\n+\n+\t\t    case 0:\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n \t\t  break;\n \n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      break;\n-\n-\t    case 1:\n-\t      switch (call_used)\n-\t\t{\n-\t\tcase 1:\n-\t\t  error (\"can%'t use %qs as a fixed register\", name);\n-\t\t  break;\n-\n-\t\tcase 0:\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n \t    }\n-\t}\n-      else\n-\t{\n-\t  fixed_regs[i] = fixed;\n-\t  call_used_regs[i] = call_used;\n+\t  else\n+\t    {\n+\t      fixed_regs[i] = fixed;\n+\t      call_used_regs[i] = call_used;\n #ifdef CALL_REALLY_USED_REGISTERS\n-\t  if (fixed == 0)\n-\t    call_really_used_regs[i] = call_used;\n+\t      if (fixed == 0)\n+\t\tcall_really_used_regs[i] = call_used;\n #endif\n+\t    }\n \t}\n     }\n   else"}, {"sha": "e24ed4ebb312b8ca4864ede10a2e464bb7fd91db", "filename": "gcc/stmt.c", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -687,28 +687,36 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n     {\n       const char *regname;\n+      int nregs;\n \n       if (TREE_VALUE (tail) == error_mark_node)\n \treturn;\n       regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n \n-      i = decode_reg_name (regname);\n-      if (i >= 0 || i == -4)\n+      i = decode_reg_name_and_count (regname, &nregs);\n+      if (i == -4)\n \t++nclobbers;\n       else if (i == -2)\n \terror (\"unknown register name %qs in %<asm%>\", regname);\n \n       /* Mark clobbered registers.  */\n       if (i >= 0)\n         {\n-\t  /* Clobbering the PIC register is an error.  */\n-\t  if (i == (int) PIC_OFFSET_TABLE_REGNUM)\n+\t  int reg;\n+\n+\t  for (reg = i; reg < i + nregs; reg++)\n \t    {\n-\t      error (\"PIC register %qs clobbered in %<asm%>\", regname);\n-\t      return;\n-\t    }\n+\t      ++nclobbers;\n+\n+\t      /* Clobbering the PIC register is an error.  */\n+\t      if (reg == (int) PIC_OFFSET_TABLE_REGNUM)\n+\t\t{\n+\t\t  error (\"PIC register clobbered by %qs in %<asm%>\", regname);\n+\t\t  return;\n+\t\t}\n \n-\t  SET_HARD_REG_BIT (clobbered_regs, i);\n+\t      SET_HARD_REG_BIT (clobbered_regs, reg);\n+\t    }\n \t}\n     }\n \n@@ -1033,7 +1041,8 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n       for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n \t{\n \t  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n-\t  int j = decode_reg_name (regname);\n+\t  int reg, nregs;\n+\t  int j = decode_reg_name_and_count (regname, &nregs);\n \t  rtx clobbered_reg;\n \n \t  if (j < 0)\n@@ -1055,30 +1064,39 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t      continue;\n \t    }\n \n-\t  /* Use QImode since that's guaranteed to clobber just one reg.  */\n-\t  clobbered_reg = gen_rtx_REG (QImode, j);\n-\n-\t  /* Do sanity check for overlap between clobbers and respectively\n-\t     input and outputs that hasn't been handled.  Such overlap\n-\t     should have been detected and reported above.  */\n-\t  if (!clobber_conflict_found)\n+\t  for (reg = j; reg < j + nregs; reg++)\n \t    {\n-\t      int opno;\n-\n-\t      /* We test the old body (obody) contents to avoid tripping\n-\t\t over the under-construction body.  */\n-\t      for (opno = 0; opno < noutputs; opno++)\n-\t\tif (reg_overlap_mentioned_p (clobbered_reg, output_rtx[opno]))\n-\t\t  internal_error (\"asm clobber conflict with output operand\");\n-\n-\t      for (opno = 0; opno < ninputs - ninout; opno++)\n-\t\tif (reg_overlap_mentioned_p (clobbered_reg,\n-\t\t\t\t\t     ASM_OPERANDS_INPUT (obody, opno)))\n-\t\t  internal_error (\"asm clobber conflict with input operand\");\n-\t    }\n+\t      /* Use QImode since that's guaranteed to clobber just\n+\t       * one reg.  */\n+\t      clobbered_reg = gen_rtx_REG (QImode, reg);\n+\n+\t      /* Do sanity check for overlap between clobbers and\n+\t\t respectively input and outputs that hasn't been\n+\t\t handled.  Such overlap should have been detected and\n+\t\t reported above.  */\n+\t      if (!clobber_conflict_found)\n+\t\t{\n+\t\t  int opno;\n+\n+\t\t  /* We test the old body (obody) contents to avoid\n+\t\t     tripping over the under-construction body.  */\n+\t\t  for (opno = 0; opno < noutputs; opno++)\n+\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n+\t\t\t\t\t\t output_rtx[opno]))\n+\t\t      internal_error\n+\t\t\t(\"asm clobber conflict with output operand\");\n+\n+\t\t  for (opno = 0; opno < ninputs - ninout; opno++)\n+\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n+\t\t\t\t\t\t ASM_OPERANDS_INPUT (obody,\n+\t\t\t\t\t\t\t\t     opno)))\n+\t\t      internal_error\n+\t\t\t(\"asm clobber conflict with input operand\");\n+\t\t}\n \n-\t  XVECEXP (body, 0, i++)\n-\t    = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n+\t      XVECEXP (body, 0, i++)\n+\t\t= gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n+\t    }\n \t}\n \n       if (nlabels > 0)"}, {"sha": "215e0edbd5927b37fa3121d988a66be9a0f1c66e", "filename": "gcc/varasm.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d290e6d5daf537d3cb4bd8c09b943c10072db/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0c6d290e6d5daf537d3cb4bd8c09b943c10072db", "patch": "@@ -764,8 +764,11 @@ set_user_assembler_name (tree decl, const char *name)\n    Prefixes such as % are optional.  */\n \n int\n-decode_reg_name (const char *asmspec)\n+decode_reg_name_and_count (const char *asmspec, int *pnregs)\n {\n+  /* Presume just one register is clobbered.  */\n+  *pnregs = 1;\n+\n   if (asmspec != 0)\n     {\n       int i;\n@@ -791,6 +794,25 @@ decode_reg_name (const char *asmspec)\n \t    && ! strcmp (asmspec, strip_reg_name (reg_names[i])))\n \t  return i;\n \n+#ifdef OVERLAPPING_REGISTER_NAMES\n+      {\n+\tstatic const struct\n+\t{\n+\t  const char *const name;\n+\t  const int number;\n+\t  const int nregs;\n+\t} table[] = OVERLAPPING_REGISTER_NAMES;\n+\n+\tfor (i = 0; i < (int) ARRAY_SIZE (table); i++)\n+\t  if (table[i].name[0]\n+\t      && ! strcmp (asmspec, table[i].name))\n+\t    {\n+\t      *pnregs = table[i].nregs;\n+\t      return table[i].number;\n+\t    }\n+      }\n+#endif /* OVERLAPPING_REGISTER_NAMES */\n+\n #ifdef ADDITIONAL_REGISTER_NAMES\n       {\n \tstatic const struct { const char *const name; const int number; } table[]\n@@ -814,6 +836,14 @@ decode_reg_name (const char *asmspec)\n \n   return -1;\n }\n+\n+int\n+decode_reg_name (const char *name)\n+{\n+  int count;\n+  return decode_reg_name_and_count (name, &count);\n+}\n+\n \f\n /* Return true if DECL's initializer is suitable for a BSS section.  */\n "}]}