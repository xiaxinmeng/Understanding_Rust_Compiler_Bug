{"sha": "760b18ad400092ea513d159b825b3617247dce8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYwYjE4YWQ0MDAwOTJlYTUxM2QxNTliODI1YjM2MTcyNDdkY2U4Yw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dseketel@redhat.com", "date": "2008-07-11T16:32:29Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2008-07-11T16:32:29Z"}, "message": "re PR c++/31754 (Improve column number accuracy in error messages)\n\n2008-07-11  Dodji Seketeli  <dseketel@redhat.com>\n\n\tPR c++/31754\n\t* cp-tree.h (struct cp_decl_specifier_seq): add a location field. It\n\tcarries the location of the primary type.\n\t* parser.c (cp_parser_check_type_definition): update documentation.\n\t(cp_parser_check_for_definition_in_return_type,\n\tcp_parser_check_for_invalid_template_id,\n\tcp_parser_set_decl_spec_type,\n\tcp_parser_check_for_definition_in_return_type,\n\tcp_parser_diagnose_invalid_type_name,\n\tcp_parser_new_expression, cp_parser_explicit_instantiation,\n\tcp_parser_type_specifier, cp_parser_simple_type_specifier,\n\tcp_parser_omp_for_loop, cp_parser_pragma): use location in error messages.\n\nFrom-SVN: r137721", "tree": {"sha": "1fe565658b383beee4cfa352a8dd8f952dd7c8ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe565658b383beee4cfa352a8dd8f952dd7c8ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/760b18ad400092ea513d159b825b3617247dce8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760b18ad400092ea513d159b825b3617247dce8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/760b18ad400092ea513d159b825b3617247dce8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760b18ad400092ea513d159b825b3617247dce8c/comments", "author": null, "committer": null, "parents": [{"sha": "ab2203551a5de8b2ce820426293bafde14330a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2203551a5de8b2ce820426293bafde14330a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab2203551a5de8b2ce820426293bafde14330a69"}], "stats": {"total": 193, "additions": 129, "deletions": 64}, "files": [{"sha": "c48fe96cb2fa980f3a449e03e260164937eb328b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,4 +1,19 @@\n-2008-07-11 Dodji Seketeli <dseketel@redhat.com>\n+2008-07-11  Dodji Seketeli  <dseketel@redhat.com>\n+\n+\tPR c++/31754\n+\t* cp-tree.h (struct cp_decl_specifier_seq): add a location field. It\n+\tcarries the location of the primary type.\n+\t* parser.c (cp_parser_check_type_definition): update documentation.\n+\t(cp_parser_check_for_definition_in_return_type,\n+\tcp_parser_check_for_invalid_template_id,\n+\tcp_parser_set_decl_spec_type,\n+\tcp_parser_check_for_definition_in_return_type,\n+\tcp_parser_diagnose_invalid_type_name,\n+\tcp_parser_new_expression, cp_parser_explicit_instantiation,\n+\tcp_parser_type_specifier, cp_parser_simple_type_specifier,\n+\tcp_parser_omp_for_loop, cp_parser_pragma): use location in error messages.\n+\n+2008-06-30 Dodji Seketeli <dseketel@redhat.com>\n \n \tPR c++/31754\n \t* pt.c, semantic.c:"}, {"sha": "b07effead05f3813b357c22454f8849f727b01a9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -3927,6 +3927,9 @@ typedef struct cp_decl_specifier_seq {\n      reflected here.  This field will be a TYPE, unless a typedef-name\n      was used, in which case it will be a TYPE_DECL.  */\n   tree type;\n+  /* The location of the primary type. Mainly used for error\n+     reporting.  */\n+  location_t type_location;\n   /* The attributes, if any, provided with the specifier sequence.  */\n   tree attributes;\n   /* If non-NULL, a built-in type that the user attempted to redefine"}, {"sha": "567f04eea96fe2fd0a769f46afe24d86374b6ef8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 69, "deletions": 37, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1950,7 +1950,7 @@ static bool cp_parser_declares_only_class_p\n static void cp_parser_set_storage_class\n   (cp_parser *, cp_decl_specifier_seq *, enum rid, location_t);\n static void cp_parser_set_decl_spec_type\n-  (cp_decl_specifier_seq *, tree, bool);\n+  (cp_decl_specifier_seq *, tree, location_t, bool);\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n static cp_token *cp_parser_require\n@@ -1998,9 +1998,9 @@ static bool cp_parser_simulate_error\n static bool cp_parser_check_type_definition\n   (cp_parser *);\n static void cp_parser_check_for_definition_in_return_type\n-  (cp_declarator *, tree);\n+  (cp_declarator *, tree, location_t type_location);\n static void cp_parser_check_for_invalid_template_id\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, location_t location);\n static bool cp_parser_non_integral_constant_expression\n   (cp_parser *, const char *);\n static void cp_parser_diagnose_invalid_type_name\n@@ -2214,11 +2214,12 @@ cp_parser_check_type_definition (cp_parser* parser)\n /* This function is called when the DECLARATOR is processed.  The TYPE\n    was a type defined in the decl-specifiers.  If it is invalid to\n    define a type in the decl-specifiers for DECLARATOR, an error is\n-   issued.  */\n+   issued. TYPE_LOCATION is the location of TYPE and is used\n+   for error reporting.  */\n \n static void\n cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n-\t\t\t\t\t       tree type)\n+\t\t\t\t\t       tree type, location_t type_location)\n {\n   /* [dcl.fct] forbids type definitions in return types.\n      Unfortunately, it's not easy to know whether or not we are\n@@ -2231,31 +2232,32 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n   if (declarator\n       && declarator->kind == cdk_function)\n     {\n-      error (\"new types may not be defined in a return type\");\n-      inform (\"(perhaps a semicolon is missing after the definition of %qT)\",\n-\t      type);\n+      error (\"%Hnew types may not be defined in a return type\", &type_location);\n+      inform (\"%H(perhaps a semicolon is missing after the definition of %qT)\",\n+\t      &type_location, type);\n     }\n }\n \n /* A type-specifier (TYPE) has been parsed which cannot be followed by\n    \"<\" in any valid C++ program.  If the next token is indeed \"<\",\n    issue a message warning the user about what appears to be an\n-   invalid attempt to form a template-id.  */\n+   invalid attempt to form a template-id. LOCATION is the location\n+   of the type-specifier (TYPE) */\n \n static void\n cp_parser_check_for_invalid_template_id (cp_parser* parser,\n-\t\t\t\t\t tree type)\n+\t\t\t\t\t tree type, location_t location)\n {\n   cp_token_position start = 0;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n     {\n       if (TYPE_P (type))\n-\terror (\"%qT is not a template\", type);\n+\terror (\"%H%qT is not a template\", &location, type);\n       else if (TREE_CODE (type) == IDENTIFIER_NODE)\n-\terror (\"%qE is not a template\", type);\n+\terror (\"%H%qE is not a template\", &location, type);\n       else\n-\terror (\"invalid template-id\");\n+\terror (\"%Hinvalid template-id\", &location);\n       /* Remember the location of the invalid \"<\".  */\n       if (cp_parser_uncommitted_to_tentative_parse_p (parser))\n \tstart = cp_lexer_token_position (parser->lexer, true);\n@@ -2301,32 +2303,34 @@ cp_parser_non_integral_constant_expression (cp_parser  *parser,\n    qualifying scope (or NULL, if none) for ID.  This function commits\n    to the current active tentative parse, if any.  (Otherwise, the\n    problematic construct might be encountered again later, resulting\n-   in duplicate error messages.)  */\n+   in duplicate error messages.) LOCATION is the location of ID.  */\n \n static void\n cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n \t\t\t\t      tree scope, tree id,\n-\t\t\t\t      location_t id_location)\n+\t\t\t\t      location_t location)\n {\n   tree decl, old_scope;\n   /* Try to lookup the identifier.  */\n   old_scope = parser->scope;\n   parser->scope = scope;\n-  decl = cp_parser_lookup_name_simple (parser, id, id_location);\n+  decl = cp_parser_lookup_name_simple (parser, id, location);\n   parser->scope = old_scope;\n   /* If the lookup found a template-name, it means that the user forgot\n   to specify an argument list. Emit a useful error message.  */\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    error (\"invalid use of template-name %qE without an argument list\", decl);\n+    error (\"%Hinvalid use of template-name %qE without an argument list\",\n+           &location, decl);\n   else if (TREE_CODE (id) == BIT_NOT_EXPR)\n-    error (\"invalid use of destructor %qD as a type\", id);\n+    error (\"%Hinvalid use of destructor %qD as a type\", &location, id);\n   else if (TREE_CODE (decl) == TYPE_DECL)\n     /* Something like 'unsigned A a;'  */\n-    error (\"invalid combination of multiple type-specifiers\");\n+    error (\"%Hinvalid combination of multiple type-specifiers\",\n+           &location);\n   else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n-      error (\"%qE does not name a type\", id);\n+      error (\"%H%qE does not name a type\", &location, id);\n       /* If we're in a template class, it's possible that the user was\n \t referring to a type from a base class.  For example:\n \n@@ -2358,8 +2362,8 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n \t\t    if (TREE_CODE (field) == TYPE_DECL\n \t\t\t&& DECL_NAME (field) == id)\n \t\t      {\n-\t\t\tinform (\"(perhaps %<typename %T::%E%> was intended)\",\n-\t\t\t\tBINFO_TYPE (b), id);\n+\t\t\tinform (\"%H(perhaps %<typename %T::%E%> was intended)\",\n+\t\t\t\t&location, BINFO_TYPE (b), id);\n \t\t\tbreak;\n \t\t      }\n \t\t  if (field)\n@@ -2373,10 +2377,11 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n   else if (parser->scope != error_mark_node)\n     {\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n-\terror (\"%qE in namespace %qE does not name a type\",\n-\t       id, parser->scope);\n+\terror (\"%H%qE in namespace %qE does not name a type\",\n+\t       &location, id, parser->scope);\n       else if (TYPE_P (parser->scope))\n-\terror (\"%qE in class %qT does not name a type\", id, parser->scope);\n+\terror (\"%H%qE in class %qT does not name a type\",\n+               &location, id, parser->scope);\n       else\n \tgcc_unreachable ();\n     }\n@@ -5576,7 +5581,8 @@ cp_parser_new_expression (cp_parser* parser)\n \t{\n \t  error (\"%Harray bound forbidden after parenthesized type-id\",\n \t\t &token->location);\n-\t  inform (\"try removing the parentheses around the type-id\");\n+\t  inform (\"%Htry removing the parentheses around the type-id\",\n+\t\t &token->location);\n \t  cp_parser_direct_new_declarator (parser);\n \t}\n       nelts = NULL_TREE;\n@@ -10599,6 +10605,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   int declares_class_or_enum;\n   cp_decl_specifier_seq decl_specifiers;\n   tree extension_specifier = NULL_TREE;\n+  cp_token *token;\n \n   /* Look for an (optional) storage-class-specifier or\n      function-specifier.  */\n@@ -10621,6 +10628,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n      control while processing explicit instantiation directives.  */\n   push_deferring_access_checks (dk_no_check);\n   /* Parse a decl-specifier-seq.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n   cp_parser_decl_specifier_seq (parser,\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t&decl_specifiers,\n@@ -10653,7 +10661,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t/*member_p=*/false);\n       if (declares_class_or_enum & 2)\n \tcp_parser_check_for_definition_in_return_type (declarator,\n-\t\t\t\t\t\t       decl_specifiers.type);\n+\t\t\t\t\t\t       decl_specifiers.type,\n+\t\t\t\t\t\t       decl_specifiers.type_location);\n       if (declarator != cp_error_declarator)\n \t{\n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n@@ -10825,6 +10834,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t  if (decl_specs)\n \t    cp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t\t  type_spec,\n+\t\t\t\t\t  token->location,\n \t\t\t\t\t  /*user_defined_p=*/true);\n \t  return type_spec;\n \t}\n@@ -10849,6 +10859,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t  if (decl_specs)\n \t    cp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t\t  type_spec,\n+\t\t\t\t\t  token->location,\n \t\t\t\t\t  /*user_defined_p=*/true);\n \t  return type_spec;\n \t}\n@@ -10870,6 +10881,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t      type_spec,\n+\t\t\t\t      token->location,\n \t\t\t\t      /*user_defined_p=*/true);\n       return type_spec;\n \n@@ -11045,6 +11057,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      token->location,\n \t\t\t\t      /*user_defined_p=*/true);\n \n       return type;\n@@ -11060,6 +11073,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      token->location,\n \t\t\t\t      /*user_defined_p=*/true);\n \n       return type;\n@@ -11081,6 +11095,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t      && token->keyword != RID_LONG))\n \tcp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t      type,\n+\t\t\t\t      token->location,\n \t\t\t\t      /*user_defined=*/false);\n       if (decl_specs)\n \tdecl_specs->any_specifiers_p = true;\n@@ -11091,7 +11106,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       /* There is no valid C++ program where a non-template type is\n \t followed by a \"<\".  That usually indicates that the user thought\n \t that the type was a template.  */\n-      cp_parser_check_for_invalid_template_id (parser, type);\n+      cp_parser_check_for_invalid_template_id (parser, type, token->location);\n \n       return TYPE_NAME (type);\n     }\n@@ -11120,6 +11135,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t\t\t\t\t/*type_p=*/false,\n \t\t\t\t\t\t/*is_declaration=*/false)\n \t   != NULL_TREE);\n+      token = cp_lexer_peek_token (parser->lexer);\n       /* If we have seen a nested-name-specifier, and the next token\n \t is `template', then we are using the template-id production.  */\n       if (parser->scope\n@@ -11154,6 +11170,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \ttype = NULL_TREE;\n       if (type && decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      token->location,\n \t\t\t\t      /*user_defined=*/true);\n     }\n \n@@ -11186,7 +11203,8 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  return qual_type;\n \t}\n \n-      cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type));\n+      cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type),\n+\t\t\t\t\t       token->location);\n     }\n \n   return type;\n@@ -11608,7 +11626,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n   /* A \"<\" cannot follow an elaborated type specifier.  If that\n      happens, the user was probably trying to form a template-id.  */\n-  cp_parser_check_for_invalid_template_id (parser, type);\n+  cp_parser_check_for_invalid_template_id (parser, type, token->location);\n \n   return type;\n }\n@@ -12413,7 +12431,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   if (declares_class_or_enum & 2)\n     cp_parser_check_for_definition_in_return_type (declarator,\n-\t\t\t\t\t\t   decl_specifiers->type);\n+\t\t\t\t\t\t   decl_specifiers->type,\n+\t\t\t\t\t\t   decl_specifiers->type_location);\n \n   /* Figure out what scope the entity declared by the DECLARATOR is\n      located in.  `grokdeclarator' sometimes changes the scope, so\n@@ -14875,6 +14894,7 @@ cp_parser_class_head (cp_parser* parser,\n       if (!cp_parser_parse_definitely (parser))\n \t{\n \t  invalid_nested_name_p = true;\n+\t  type_start_token = cp_lexer_peek_token (parser->lexer);\n \t  id = cp_parser_identifier (parser);\n \t  if (id == error_mark_node)\n \t    id = NULL_TREE;\n@@ -14918,7 +14938,10 @@ cp_parser_class_head (cp_parser* parser,\n       if (!cp_parser_parse_definitely (parser))\n \t{\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-\t    id = cp_parser_identifier (parser);\n+\t    {\n+\t      type_start_token = cp_lexer_peek_token (parser->lexer);\n+\t      id = cp_parser_identifier (parser);\n+\t    }\n \t  else\n \t    id = NULL_TREE;\n \t}\n@@ -14932,7 +14955,8 @@ cp_parser_class_head (cp_parser* parser,\n   pop_deferring_access_checks ();\n \n   if (id)\n-    cp_parser_check_for_invalid_template_id (parser, id);\n+    cp_parser_check_for_invalid_template_id (parser, id,\n+\t\t\t\t\t     type_start_token->location);\n \n   /* If it's not a `:' or a `{' then we can't really be looking at a\n      class-head, since a class-head only appears as part of a\n@@ -15521,7 +15545,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t      if (declares_class_or_enum & 2)\n \t\tcp_parser_check_for_definition_in_return_type\n-\t\t  (declarator, decl_specifiers.type);\n+\t\t\t\t\t    (declarator, decl_specifiers.type,\n+\t\t\t\t\t     decl_specifiers.type_location);\n \n \t      /* Look for an asm-specification.  */\n \t      asm_specification = cp_parser_asm_specification_opt (parser);\n@@ -18141,6 +18166,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n static void\n cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n \t\t\t      tree type_spec,\n+\t\t\t      location_t location,\n \t\t\t      bool user_defined_p)\n {\n   decl_specs->any_specifiers_p = true;\n@@ -18167,6 +18193,7 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n \t{\n \t  decl_specs->type = type_spec;\n \t  decl_specs->user_defined_type_p = false;\n+\t  decl_specs->type_location = location;\n \t}\n     }\n   else if (decl_specs->type)\n@@ -18176,6 +18203,7 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n       decl_specs->type = type_spec;\n       decl_specs->user_defined_type_p = user_defined_p;\n       decl_specs->redefined_builtin_type = NULL_TREE;\n+      decl_specs->type_location = location;\n     }\n }\n \n@@ -21105,7 +21133,10 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n       else\n \t{\n \t  if (!collapse_err)\n-\t    error (\"collapsed loops not perfectly nested\");\n+\t    {\n+\t      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t      error (\"%Hcollapsed loops not perfectly nested\", &loc);\n+\t    }\n \t  collapse_err = true;\n \t  cp_parser_statement_seq_opt (parser, NULL);\n \t  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n@@ -21593,8 +21624,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_taskwait (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%<#pragma omp taskwait%> may only be \"\n-\t\t \"used in compound statements\");\n+\t  error (\"%H%<#pragma omp taskwait%> may only be \"\n+\t\t \"used in compound statements\",\n+\t\t &pragma_tok->location);\n \t  break;\n \tdefault:\n \t  goto bad_stmt;"}, {"sha": "9833a0f828e6bc459c9f95de0efedd1cc218cabb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,6 +1,16 @@\n 2008-07-11 Dodji Seketeli <dseketel@redhat.com>\n \n-\t* g++.dg/parse/constructor1.C, g++.dg/parse/error*.C: update these\n+\t* g++.dg/other/semicolon.C: Tighten this test, making it column aware.\n+\t* g++.dg/parse/error15.C: update this because of more accurate column\n+\tnumbers in error reporting.\n+\t* g++.old-deja/g++.brendan/crash16.C: Tighten the test, making it\n+\tcolumn aware.\n+\t* g++.old-deja/g++.law/ctors5.C: Likewise.\n+\t* g++.old-deja/g++.other/crash25.C: Likewise.\n+\n+2008-06-30 Dodji Seketeli <dseketel@redhat.com>\n+\n+\t* g++.dg/parse/constructor1.C, g++.dg/parse/error*.C: Update these\n \t  tests to make them catch column number regressions. Make these tests\n \t  run with the -fshow-column option.\n \t* g++.dg/parse/error-column.C: new column number test."}, {"sha": "542d3b7b554a933af4e08bf94843935d4a38e026", "filename": "gcc/testsuite/g++.dg/other/semicolon.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsemicolon.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsemicolon.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsemicolon.C?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,9 +1,10 @@\n // PR c++/18368\n // Origin: Chris Lattner <sabre@nondot.org>\n // { dg-do compile }\n+// { dg-options \"-fshow-column\" }\n \n struct A\n {\n-  struct B { int i; }\n-  void foo();   // { dg-error \"two or more|return type\" }\n-};              // { dg-error \"semicolon is missing\" \"\" { target *-*-* } 8 }\n+  struct B { int i; } // { dg-error \"3: error: new types may not be defined in a return type|note: \\\\(perhaps a semicolon is missing\" }\n+  void foo();   // { dg-error \"12: error: two or more|return type\" }\n+};"}, {"sha": "5903a585e973957260c567d631410a4747751f01", "filename": "gcc/testsuite/g++.dg/parse/error15.C", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -10,28 +10,28 @@ namespace N\n   int K;\n }\n \n-N::A f2;              // { dg-error \"4: error: invalid use of template-name 'N::A' without an argument list\" }\n-N::INVALID f3;        // { dg-error \"4: error: 'INVALID' in namespace 'N' does not name a type\" }\n-N::C::INVALID f4;     // { dg-error \"7: error: 'INVALID' in class 'N::C' does not name a type\" }\n-N::K f6;              // { dg-error \"4: error: 'K' in namespace 'N' does not name a type\" }\n+N::A f2;              // { dg-error \"1: error: invalid use of template-name 'N::A' without an argument list\" }\n+N::INVALID f3;        // { dg-error \"1: error: 'INVALID' in namespace 'N' does not name a type\" }\n+N::C::INVALID f4;     // { dg-error \"1: error: 'INVALID' in class 'N::C' does not name a type\" }\n+N::K f6;              // { dg-error \"1: error: 'K' in namespace 'N' does not name a type\" }\n typename N::A f7;     // { dg-error \"1: error: using 'typename' outside of template|13: error: invalid use of template-name 'N::A' without an argument list|17: error: invalid type in declaration before ';' token\" }\n \n struct B\n {\n-  N::A f2;            // { dg-error \"6: error: invalid use of template-name 'N::A' without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"6: error: 'INVALID' in namespace 'N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"9: error: 'INVALID' in class 'N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"6: error: 'K' in namespace 'N' does not name a type\" }\n+  N::A f2;            // { dg-error \"3: error: invalid use of template-name 'N::A' without an argument list\" }\n+  N::INVALID f3;      // { dg-error \"3: error: 'INVALID' in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"3: error: 'INVALID' in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"3: error: 'K' in namespace 'N' does not name a type\" }\n   typename N::A f7;   // { dg-error \"3: error: using 'typename' outside of template|15: error: invalid use of template-name 'N::A' without an argument list\" }\n };\n \n template <int>\n struct C\n {\n-  N::A f2;            // { dg-error \"6: error: invalid use of template-name 'N::A' without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"6: error: 'INVALID' in namespace 'N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"9: error: 'INVALID' in class 'N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"6: error: 'K' in namespace 'N' does not name a type\" }\n+  N::A f2;            // { dg-error \"3: error: invalid use of template-name 'N::A' without an argument list\" }\n+  N::INVALID f3;      // { dg-error \"3: error: 'INVALID' in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"3: error: 'INVALID' in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"3: error: 'K' in namespace 'N' does not name a type\" }\n   typename N::A f7;   // { dg-error \"15: error: invalid use of template-name 'N::A' without an argument list\" }\n };\n "}, {"sha": "ddcae3c97cbedafa650678ff6e7517e695adfda8", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash16.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,12 +1,14 @@\n // { dg-do compile }\n+// { dg-options \"-fshow-column\" }\n // GROUPS passed old-abort\n-class Graph {\n+\n+class Graph { // { dg-error \"1: error: new types|1: note: \\\\(perhaps\" }\n public:\n       unsigned         char N;\n-      Graph(void) {} // { dg-error \"previously defined here\" }\n+      Graph(void) {} // { dg-error \"17: error: 'Graph\" }\n }\n \n-Graph::Graph(void)    // { dg-error \"return type|redefinition|semicolon\" }\n+Graph::Graph(void) // { dg-error \"18: error: return type|18: error: redefinition\" }\n {    N = 10;\n }\n "}, {"sha": "1f469cf5d4945c2d2bcc97386aa4233889dd2e7e", "filename": "gcc/testsuite/g++.old-deja/g++.law/ctors5.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,33 +1,34 @@\n // { dg-do assemble  }\n+// { dg-options \"-fshow-column\" }\n // GROUPS passed constructors\n // ctors file\n // Subject: bug in handling static const object of the enclosing class\n // Date: Tue, 1 Sep 92 10:38:44 EDT\n \n class X\n-{ // { dg-error \"X::X\" } implicit constructor\n+{ // { dg-error \"1: note:                 X::X\\\\(const X&\\\\)\" } implicit constructor\n   private:\n     int x;\n   public:\n     static const X x0;\n     X( int );\n };\n \n-class Y\n+class Y // { dg-error \"1: error: new types may not be defined in a return type|1: note: \\\\(perhaps a semicolon is missing after the definition of 'Y'\\\\)\" }\n {\n   private:\n     X xx;\n   public:\n     Y();\n }\n-X::X( int xi ) // { dg-error \"return type|X::X|semicolon\" }\n+X::X( int xi ) // { dg-error \"14: error: return type specification for constructor invalid|14: note: candidates are: X::X\\\\(int\\\\)\" }\n {\n     x = xi;\n }\n \n const X X::x0( 0 );\n \n-Y::Y() // { dg-error \"no match\" }\n+Y::Y() // { dg-error \"6: error: no matching function for call to 'X::X\\\\(\\\\)'\" }\n {\n     xx = X::x0;\n }"}, {"sha": "517bac2d5d6866f5570508dc4210b90bdb6ec00c", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash25.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760b18ad400092ea513d159b825b3617247dce8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C?ref=760b18ad400092ea513d159b825b3617247dce8c", "patch": "@@ -1,16 +1,17 @@\n // { dg-do assemble  }\n+// { dg-options \"-fshow-column\" }\n // Origin: Jakub Jelinek <jakub@redhat.com>\n \n-class X {\n+class X { // { dg-error \"1: error: new types may not be defined in a return type|1: note: \\\\(perhaps a semicolon is missing after the definition of 'X'\\\\)\" }\n public:\n   X();\n   virtual ~X();\n }\n \n-X::x()\t// { dg-error \"return type|member function|semicolon\" }\n+X::x()\t// { dg-error \"6: error: no 'X X::x\\\\(\\\\)' member function declared in class 'X'\" }\n {\n }\n \n-X::~x()\t// { dg-error \"expected class-name\" }\n+X::~x()\t// { dg-error \"6: error: expected class-name before '\\\\(' token\" }\n {\t\t\t\t\n }"}]}