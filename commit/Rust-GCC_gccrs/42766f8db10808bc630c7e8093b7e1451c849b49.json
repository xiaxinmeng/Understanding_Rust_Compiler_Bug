{"sha": "42766f8db10808bc630c7e8093b7e1451c849b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI3NjZmOGRiMTA4MDhiYzYzMGM3ZTgwOTNiN2UxNDUxYzg0OWI0OQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "drow@mvista.com", "date": "2002-11-22T20:01:07Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2002-11-22T20:01:07Z"}, "message": "libiberty.h (make_relative_prefix): Add prototype.\n\ninclude/\n\t* libiberty.h (make_relative_prefix): Add prototype.\nlibiberty/\n\t* Makefile.in: Add make-relative-prefix.c.\n\t* make-relative-prefix.c: New file.\n\t* functions.texi: Rebuilt.\ngcc/\n\t* gcc.c (make_relative_prefix, split_directories)\n\t(free_split_directories): Removed.\n\nFrom-SVN: r59385", "tree": {"sha": "cd0710e42a786802096e328c11e150db4dc4067a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0710e42a786802096e328c11e150db4dc4067a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42766f8db10808bc630c7e8093b7e1451c849b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42766f8db10808bc630c7e8093b7e1451c849b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42766f8db10808bc630c7e8093b7e1451c849b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42766f8db10808bc630c7e8093b7e1451c849b49/comments", "author": null, "committer": null, "parents": [{"sha": "80486e0671dada5e65fbc8baab06e9357281c9cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80486e0671dada5e65fbc8baab06e9357281c9cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80486e0671dada5e65fbc8baab06e9357281c9cd"}], "stats": {"total": 681, "additions": 432, "deletions": 249}, "files": [{"sha": "4500b2c24ed724cfda03a34868f078b179be2c35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -1,3 +1,8 @@\n+2002-11-22  Daniel Jacobowitz  <drow@mvista.com>\n+\n+\t* gcc.c (make_relative_prefix, split_directories)\n+\t(free_split_directories): Removed.\n+\n 2002-11-22  Daniel Jacobowitz  <drow@mvista.com>\n \n \t* configure.in: Set insn=nop for DWARF-2 tests on ARM."}, {"sha": "a193437c569c561b1d42efaba33843e449f9bbdf", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -267,11 +267,6 @@ static struct rusage rus, prus;\n struct path_prefix;\n \n static void init_spec\t\tPARAMS ((void));\n-#ifndef VMS\n-static char **split_directories\tPARAMS ((const char *, int *));\n-static void free_split_directories PARAMS ((char **));\n-static char *make_relative_prefix PARAMS ((const char *, const char *, const char *));\n-#endif /* VMS */\n static void store_arg\t\tPARAMS ((const char *, int, int));\n static char *load_specs\t\tPARAMS ((const char *));\n static void read_specs\t\tPARAMS ((const char *, int));\n@@ -2281,246 +2276,6 @@ putenv_from_prefixes (paths, env_var)\n   putenv (build_search_list (paths, env_var, 1));\n }\n \f\n-#ifndef VMS\n-\n-/* FIXME: the location independence code for VMS is hairier than this,\n-   and hasn't been written.  */\n-\n-/* Split a filename into component directories.  */\n-\n-static char **\n-split_directories (name, ptr_num_dirs)\n-     const char *name;\n-     int *ptr_num_dirs;\n-{\n-  int num_dirs = 0;\n-  char **dirs;\n-  const char *p, *q;\n-  int ch;\n-\n-  /* Count the number of directories.  Special case MSDOS disk names as part\n-     of the initial directory.  */\n-  p = name;\n-#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n-    {\n-      p += 3;\n-      num_dirs++;\n-    }\n-#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n-\n-  while ((ch = *p++) != '\\0')\n-    {\n-      if (IS_DIR_SEPARATOR (ch))\n-\t{\n-\t  num_dirs++;\n-\t  while (IS_DIR_SEPARATOR (*p))\n-\t    p++;\n-\t}\n-    }\n-\n-  dirs = (char **) xmalloc (sizeof (char *) * (num_dirs + 2));\n-\n-  /* Now copy the directory parts.  */\n-  num_dirs = 0;\n-  p = name;\n-#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n-    {\n-      dirs[num_dirs++] = save_string (p, 3);\n-      p += 3;\n-    }\n-#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n-\n-  q = p;\n-  while ((ch = *p++) != '\\0')\n-    {\n-      if (IS_DIR_SEPARATOR (ch))\n-\t{\n-\t  while (IS_DIR_SEPARATOR (*p))\n-\t    p++;\n-\n-\t  dirs[num_dirs++] = save_string (q, p - q);\n-\t  q = p;\n-\t}\n-    }\n-\n-  if (p - 1 - q > 0)\n-    dirs[num_dirs++] = save_string (q, p - 1 - q);\n-\n-  dirs[num_dirs] = NULL;\n-  if (ptr_num_dirs)\n-    *ptr_num_dirs = num_dirs;\n-\n-  return dirs;\n-}\n-\n-/* Release storage held by split directories.  */\n-\n-static void\n-free_split_directories (dirs)\n-     char **dirs;\n-{\n-  int i = 0;\n-\n-  while (dirs[i] != NULL)\n-    free (dirs[i++]);\n-\n-  free ((char *) dirs);\n-}\n-\n-/* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets\n-   to PREFIX starting with the directory portion of PROGNAME and a relative\n-   pathname of the difference between BIN_PREFIX and PREFIX.\n-\n-   For example, if BIN_PREFIX is /alpha/beta/gamma/gcc/delta, PREFIX is\n-   /alpha/beta/gamma/omega/, and PROGNAME is /red/green/blue/gcc, then this\n-   function will return /red/green/blue/../omega.\n-\n-   If no relative prefix can be found, return NULL.  */\n-\n-static char *\n-make_relative_prefix (progname, bin_prefix, prefix)\n-     const char *progname;\n-     const char *bin_prefix;\n-     const char *prefix;\n-{\n-  char **prog_dirs, **bin_dirs, **prefix_dirs;\n-  int prog_num, bin_num, prefix_num, std_loc_p;\n-  int i, n, common;\n-\n-  prog_dirs = split_directories (progname, &prog_num);\n-  bin_dirs = split_directories (bin_prefix, &bin_num);\n-\n-  /* If there is no full pathname, try to find the program by checking in each\n-     of the directories specified in the PATH environment variable.  */\n-  if (prog_num == 1)\n-    {\n-      char *temp;\n-\n-      GET_ENVIRONMENT (temp, \"PATH\");\n-      if (temp)\n-\t{\n-\t  char *startp, *endp, *nstore;\n-\t  size_t prefixlen = strlen (temp) + 1;\n-\t  if (prefixlen < 2)\n-\t    prefixlen = 2;\n-\n-\t  nstore = (char *) alloca (prefixlen + strlen (progname) + 1);\n-\n-\t  startp = endp = temp;\n-\t  while (1)\n-\t    {\n-\t      if (*endp == PATH_SEPARATOR || *endp == 0)\n-\t\t{\n-\t\t  if (endp == startp)\n-\t\t    {\n-\t\t      nstore[0] = '.';\n-\t\t      nstore[1] = DIR_SEPARATOR;\n-\t\t      nstore[2] = '\\0';\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      strncpy (nstore, startp, endp - startp);\n-\t\t      if (! IS_DIR_SEPARATOR (endp[-1]))\n-\t\t\t{\n-\t\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n-\t\t\t  nstore[endp - startp + 1] = 0;\n-\t\t\t}\n-\t\t      else\n-\t\t\tnstore[endp - startp] = 0;\n-\t\t    }\n-\t\t  strcat (nstore, progname);\n-\t\t  if (! access (nstore, X_OK)\n-#ifdef HAVE_HOST_EXECUTABLE_SUFFIX\n-                      || ! access (strcat (nstore, HOST_EXECUTABLE_SUFFIX), X_OK)\n-#endif\n-\t\t      )\n-\t\t    {\n-\t\t      free_split_directories (prog_dirs);\n-\t\t      progname = nstore;\n-\t\t      prog_dirs = split_directories (progname, &prog_num);\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (*endp == 0)\n-\t\t    break;\n-\t\t  endp = startp = endp + 1;\n-\t\t}\n-\t      else\n-\t\tendp++;\n-\t    }\n-\t}\n-    }\n-\n-  /* Remove the program name from comparison of directory names.  */\n-  prog_num--;\n-\n-  /* Determine if the compiler is installed in the standard location, and if\n-     so, we don't need to specify relative directories.  Also, if argv[0]\n-     doesn't contain any directory specifiers, there is not much we can do.  */\n-  std_loc_p = 0;\n-  if (prog_num == bin_num)\n-    {\n-      for (i = 0; i < bin_num; i++)\n-\t{\n-\t  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)\n-\t    break;\n-\t}\n-\n-      if (prog_num <= 0 || i == bin_num)\n-\t{\n-\t  std_loc_p = 1;\n-\t  free_split_directories (prog_dirs);\n-\t  free_split_directories (bin_dirs);\n-\t  prog_dirs = bin_dirs = (char **) 0;\n-\t  return NULL;\n-\t}\n-    }\n-\n-  prefix_dirs = split_directories (prefix, &prefix_num);\n-\n-  /* Find how many directories are in common between bin_prefix & prefix.  */\n-  n = (prefix_num < bin_num) ? prefix_num : bin_num;\n-  for (common = 0; common < n; common++)\n-    {\n-      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)\n-\tbreak;\n-    }\n-\n-  /* If there are no common directories, there can be no relative prefix.  */\n-  if (common == 0)\n-    {\n-      free_split_directories (prog_dirs);\n-      free_split_directories (bin_dirs);\n-      free_split_directories (prefix_dirs);\n-      return NULL;\n-    }\n-\n-  /* Build up the pathnames in argv[0].  */\n-  for (i = 0; i < prog_num; i++)\n-    obstack_grow (&obstack, prog_dirs[i], strlen (prog_dirs[i]));\n-\n-  /* Now build up the ..'s.  */\n-  for (i = common; i < n; i++)\n-    {\n-      obstack_grow (&obstack, DIR_UP, sizeof (DIR_UP) - 1);\n-      obstack_1grow (&obstack, DIR_SEPARATOR);\n-    }\n-\n-  /* Put in directories to move over to prefix.  */\n-  for (i = common; i < prefix_num; i++)\n-    obstack_grow (&obstack, prefix_dirs[i], strlen (prefix_dirs[i]));\n-\n-  free_split_directories (prog_dirs);\n-  free_split_directories (bin_dirs);\n-  free_split_directories (prefix_dirs);\n-\n-  obstack_1grow (&obstack, '\\0');\n-  return obstack_finish (&obstack);\n-}\n-#endif /* VMS */\n-\f\n /* Check whether NAME can be accessed in MODE.  This is like access,\n    except that it never considers directories to be executable.  */\n "}, {"sha": "ea9575351f56ce6c57c1594276a3a285155cb16e", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -1,3 +1,7 @@\n+2002-11-22  Daniel Jacobowitz  <drow@mvista.com>\n+\n+\t* libiberty.h (make_relative_prefix): Add prototype.\n+\n 2002-10-26  Roger Sayle  <roger@eyesopen.com>\n \n \t* partition.h:  Close the extern \"C\" scope when compiling with C++."}, {"sha": "c02e035e3afc5c9fe61880de4e068e93c96a839d", "filename": "include/libiberty.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -145,6 +145,12 @@ extern char * getpwd PARAMS ((void));\n \n extern long get_run_time PARAMS ((void));\n \n+/* Generate a relocated path to some installation directory.  Allocates\n+   return value using malloc.  */\n+\n+extern char *make_relative_prefix PARAMS ((const char *, const char *,\n+\t\t\t\t\t   const char *));\n+\n /* Choose a temporary directory to use for scratch files.  */\n \n extern char *choose_temp_base PARAMS ((void)) ATTRIBUTE_MALLOC;"}, {"sha": "57ff7da31b5c0b6724fdd6cb2af14c25e6bde98c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -1,3 +1,9 @@\n+2002-11-22  Daniel Jacobowitz  <drow@mvista.com>\n+\n+\t* Makefile.in: Add make-relative-prefix.c.\n+\t* make-relative-prefix.c: New file.\n+\t* functions.texi: Rebuilt.\n+\n 2002-11-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* md5.c (md5_process_block): Avoid `function-like macro \"F{G,H,I}\" must be"}, {"sha": "cdf14a4311b11589ab2d431f996fe63086a81f82", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -135,6 +135,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \thashtab.c hex.c\t\t\t\t\t\t\t\\\n \tindex.c insque.c\t\t\t\t\t\t\\\n \tlbasename.c\t\t\t\t\t\t\t\\\n+\tmake-relative-prefix.c\t\t\t\t\t\t\\\n \tmake-temp-file.c md5.c memchr.c memcmp.c memcpy.c memmove.c\t\\\n \t memset.c mkstemps.c\t\t\t\t\t\t\\\n \tobjalloc.c obstack.c\t\t\t\t\t\t\\\n@@ -159,6 +160,7 @@ REQUIRED_OFILES = regex.o cplus-dem.o cp-demangle.o md5.o\t\t\\\n \tgetopt.o getopt1.o getpwd.o getruntime.o\t\t\t\\\n \thashtab.o hex.o\t\t\t\t\t\t\t\\\n \tlbasename.o\t\t\t\t\t\t\t\\\n+\tmake-relative-prefix.o\t\t\t\t\t\t\\\n \tmake-temp-file.o\t\t\t\t\t\t\\\n \tobjalloc.o obstack.o\t\t\t\t\t\t\\\n \tpartition.o pexecute.o\t\t\t\t\t\t\\\n@@ -432,6 +434,7 @@ hashtab.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/hashtab.h \\\n hex.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n lbasename.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n \t$(INCDIR)/safe-ctype.h\n+make-relative-prefix.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n make-temp-file.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n md5.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/md5.h\n memchr.o: $(INCDIR)/ansidecl.h"}, {"sha": "7d9c181d219549150720c631b3b452a84d911adb", "filename": "libiberty/functions.texi", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -276,7 +276,7 @@ itself.\n \n @end deftypefn\n \n-@c getruntime.c:78\n+@c getruntime.c:82\n @deftypefn Replacement long get_run_time (void)\n \n Returns the time used so far, in microseconds.  If possible, this is\n@@ -322,11 +322,12 @@ between calls to @code{getpwd}.\n \n Initializes the array mapping the current character set to\n corresponding hex values.  This function must be called before any\n-call to @code{hex_p} or @code{hex_value}.\n+call to @code{hex_p} or @code{hex_value}.  If you fail to call it, a\n+default ASCII-based table will normally be used on ASCII systems.\n \n @end deftypefn\n \n-@c hex.c:33\n+@c hex.c:34\n @deftypefn Extension int hex_p (int @var{c})\n \n Evaluates to non-zero if the given character is a valid hex character,\n@@ -335,7 +336,7 @@ or zero if it is not.  Note that the value you pass will be cast to\n \n @end deftypefn\n \n-@c hex.c:41\n+@c hex.c:42\n @deftypefn Extension int hex_value (int @var{c})\n \n Returns the numeric equivalent of the given character when interpreted\n@@ -391,6 +392,22 @@ and a path ending in @code{/} returns the empty string after it.\n \n @end deftypefn\n \n+@c make-relative-prefix.c:24\n+@deftypefn Extension {const char*} make_relative_prefix (const char *@var{progname}, const char *@var{bin_prefix}, const char *@var{prefix})\n+\n+Given three strings @var{progname}, @var{bin_prefix}, @var{prefix}, return a string\n+that gets to @var{prefix} starting with the directory portion of @var{progname} and\n+a relative pathname of the difference between @var{bin_prefix} and @var{prefix}.\n+\n+For example, if @var{bin_prefix} is @code{/alpha/beta/gamma/gcc/delta}, @var{prefix}\n+is @code{/alpha/beta/gamma/omega/}, and @var{progname} is @code{/red/green/blue/gcc},\n+then this function will return @code{/red/green/blue/../../omega/}.\n+\n+The return value is normally allocated via @code{malloc}.  If no relative prefix\n+can be found, return @code{NULL}.\n+\n+@end deftypefn\n+\n @c make-temp-file.c:138\n @deftypefn Replacement char* make_temp_file (const char *@var{suffix})\n "}, {"sha": "ae1ac54295a86764f5d69e87cea5a85e73b7c825", "filename": "libiberty/make-relative-prefix.c", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2Fmake-relative-prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42766f8db10808bc630c7e8093b7e1451c849b49/libiberty%2Fmake-relative-prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-relative-prefix.c?ref=42766f8db10808bc630c7e8093b7e1451c849b49", "patch": "@@ -0,0 +1,387 @@\n+/* Relative (relocatable) prefix support.\n+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of libiberty.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/*\n+\n+@deftypefn Extension {const char*} make_relative_prefix (const char *@var{progname}, const char *@var{bin_prefix}, const char *@var{prefix})\n+\n+Given three strings @var{progname}, @var{bin_prefix}, @var{prefix}, return a string\n+that gets to @var{prefix} starting with the directory portion of @var{progname} and\n+a relative pathname of the difference between @var{bin_prefix} and @var{prefix}.\n+\n+For example, if @var{bin_prefix} is @code{/alpha/beta/gamma/gcc/delta}, @var{prefix}\n+is @code{/alpha/beta/gamma/omega/}, and @var{progname} is @code{/red/green/blue/gcc},\n+then this function will return @code{/red/green/blue/../../omega/}.\n+\n+The return value is normally allocated via @code{malloc}.  If no relative prefix\n+can be found, return @code{NULL}.\n+\n+@end deftypefn\n+\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#include <string.h>\n+\n+#include \"ansidecl.h\"\n+#include \"libiberty.h\"\n+\n+#ifndef R_OK\n+#define R_OK 4\n+#define W_OK 2\n+#define X_OK 1\n+#endif\n+\n+#ifndef DIR_SEPARATOR\n+#  define DIR_SEPARATOR '/'\n+#endif\n+\n+#if defined (_WIN32) || defined (__MSDOS__) \\\n+    || defined (__DJGPP__) || defined (__OS2__)\n+#  define HAVE_DOS_BASED_FILE_SYSTEM\n+#  define HOST_EXECUTABLE_SUFFIX \".exe\"\n+#  ifndef DIR_SEPARATOR_2 \n+#    define DIR_SEPARATOR_2 '\\\\'\n+#  endif\n+#  define PATH_SEPARATOR ';'\n+#else\n+#  define PATH_SEPARATOR ':'\n+#endif\n+\n+#ifndef DIR_SEPARATOR_2\n+#  define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n+#else\n+#  define IS_DIR_SEPARATOR(ch) \\\n+\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n+#endif\n+\n+#define DIR_UP \"..\"\n+\n+static char *save_string PARAMS ((const char *, int));\n+static char **split_directories\tPARAMS ((const char *, int *));\n+static void free_split_directories PARAMS ((char **));\n+\n+static char *\n+save_string (s, len)\n+     const char *s;\n+     int len;\n+{\n+  char *result = malloc (len + 1);\n+\n+  memcpy (result, s, len);\n+  result[len] = 0;\n+  return result;\n+}\n+\n+/* Split a filename into component directories.  */\n+\n+static char **\n+split_directories (name, ptr_num_dirs)\n+     const char *name;\n+     int *ptr_num_dirs;\n+{\n+  int num_dirs = 0;\n+  char **dirs;\n+  const char *p, *q;\n+  int ch;\n+\n+  /* Count the number of directories.  Special case MSDOS disk names as part\n+     of the initial directory.  */\n+  p = name;\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n+    {\n+      p += 3;\n+      num_dirs++;\n+    }\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+  while ((ch = *p++) != '\\0')\n+    {\n+      if (IS_DIR_SEPARATOR (ch))\n+\t{\n+\t  num_dirs++;\n+\t  while (IS_DIR_SEPARATOR (*p))\n+\t    p++;\n+\t}\n+    }\n+\n+  dirs = (char **) malloc (sizeof (char *) * (num_dirs + 2));\n+  if (dirs == NULL)\n+    return NULL;\n+\n+  /* Now copy the directory parts.  */\n+  num_dirs = 0;\n+  p = name;\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n+    {\n+      dirs[num_dirs++] = save_string (p, 3);\n+      if (dirs[num_dirs - 1] == NULL)\n+\t{\n+\t  free (dirs);\n+\t  return NULL;\n+\t}\n+      p += 3;\n+    }\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+  q = p;\n+  while ((ch = *p++) != '\\0')\n+    {\n+      if (IS_DIR_SEPARATOR (ch))\n+\t{\n+\t  while (IS_DIR_SEPARATOR (*p))\n+\t    p++;\n+\n+\t  dirs[num_dirs++] = save_string (q, p - q);\n+\t  if (dirs[num_dirs - 1] == NULL)\n+\t    {\n+\t      dirs[num_dirs] = NULL;\n+\t      free_split_directories (dirs);\n+\t      return NULL;\n+\t    }\n+\t  q = p;\n+\t}\n+    }\n+\n+  if (p - 1 - q > 0)\n+    dirs[num_dirs++] = save_string (q, p - 1 - q);\n+  dirs[num_dirs] = NULL;\n+\n+  if (dirs[num_dirs - 1] == NULL)\n+    {\n+      free_split_directories (dirs);\n+      return NULL;\n+    }\n+\n+  if (ptr_num_dirs)\n+    *ptr_num_dirs = num_dirs;\n+  return dirs;\n+}\n+\n+/* Release storage held by split directories.  */\n+\n+static void\n+free_split_directories (dirs)\n+     char **dirs;\n+{\n+  int i = 0;\n+\n+  while (dirs[i] != NULL)\n+    free (dirs[i++]);\n+\n+  free ((char *) dirs);\n+}\n+\n+/* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets\n+   to PREFIX starting with the directory portion of PROGNAME and a relative\n+   pathname of the difference between BIN_PREFIX and PREFIX.\n+\n+   For example, if BIN_PREFIX is /alpha/beta/gamma/gcc/delta, PREFIX is\n+   /alpha/beta/gamma/omega/, and PROGNAME is /red/green/blue/gcc, then this\n+   function will return /red/green/blue/../../omega/.\n+\n+   If no relative prefix can be found, return NULL.  */\n+\n+char *\n+make_relative_prefix (progname, bin_prefix, prefix)\n+     const char *progname;\n+     const char *bin_prefix;\n+     const char *prefix;\n+{\n+  char **prog_dirs, **bin_dirs, **prefix_dirs;\n+  int prog_num, bin_num, prefix_num;\n+  int i, n, common;\n+  int needed_len;\n+  char *ret, *ptr;\n+\n+  if (progname == NULL || bin_prefix == NULL || prefix == NULL)\n+    return NULL;\n+\n+  prog_dirs = split_directories (progname, &prog_num);\n+  bin_dirs = split_directories (bin_prefix, &bin_num);\n+  if (bin_dirs == NULL || prog_dirs == NULL)\n+    return NULL;\n+\n+  /* If there is no full pathname, try to find the program by checking in each\n+     of the directories specified in the PATH environment variable.  */\n+  if (prog_num == 1)\n+    {\n+      char *temp;\n+\n+      temp = getenv (\"PATH\");\n+      if (temp)\n+\t{\n+\t  char *startp, *endp, *nstore;\n+\t  size_t prefixlen = strlen (temp) + 1;\n+\t  if (prefixlen < 2)\n+\t    prefixlen = 2;\n+\n+\t  nstore = (char *) alloca (prefixlen + strlen (progname) + 1);\n+\n+\t  startp = endp = temp;\n+\t  while (1)\n+\t    {\n+\t      if (*endp == PATH_SEPARATOR || *endp == 0)\n+\t\t{\n+\t\t  if (endp == startp)\n+\t\t    {\n+\t\t      nstore[0] = '.';\n+\t\t      nstore[1] = DIR_SEPARATOR;\n+\t\t      nstore[2] = '\\0';\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      strncpy (nstore, startp, endp - startp);\n+\t\t      if (! IS_DIR_SEPARATOR (endp[-1]))\n+\t\t\t{\n+\t\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n+\t\t\t  nstore[endp - startp + 1] = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\tnstore[endp - startp] = 0;\n+\t\t    }\n+\t\t  strcat (nstore, progname);\n+\t\t  if (! access (nstore, X_OK)\n+#ifdef HAVE_HOST_EXECUTABLE_SUFFIX\n+                      || ! access (strcat (nstore, HOST_EXECUTABLE_SUFFIX), X_OK)\n+#endif\n+\t\t      )\n+\t\t    {\n+\t\t      free_split_directories (prog_dirs);\n+\t\t      progname = nstore;\n+\t\t      prog_dirs = split_directories (progname, &prog_num);\n+\t\t      if (prog_dirs == NULL)\n+\t\t\t{\n+\t\t\t  free_split_directories (bin_dirs);\n+\t\t\t  return NULL;\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (*endp == 0)\n+\t\t    break;\n+\t\t  endp = startp = endp + 1;\n+\t\t}\n+\t      else\n+\t\tendp++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Remove the program name from comparison of directory names.  */\n+  prog_num--;\n+\n+  /* If we are still installed in the standard location, we don't need to\n+     specify relative directories.  Also, if argv[0] still doesn't contain\n+     any directory specifiers after the search above, then there is not much\n+     we can do.  */\n+  if (prog_num == bin_num)\n+    {\n+      for (i = 0; i < bin_num; i++)\n+\t{\n+\t  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)\n+\t    break;\n+\t}\n+\n+      if (prog_num <= 0 || i == bin_num)\n+\t{\n+\t  free_split_directories (prog_dirs);\n+\t  free_split_directories (bin_dirs);\n+\t  prog_dirs = bin_dirs = (char **) 0;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  prefix_dirs = split_directories (prefix, &prefix_num);\n+  if (prefix_dirs == NULL)\n+    {\n+      free_split_directories (prog_dirs);\n+      free_split_directories (bin_dirs);\n+      return NULL;\n+    }\n+\n+  /* Find how many directories are in common between bin_prefix & prefix.  */\n+  n = (prefix_num < bin_num) ? prefix_num : bin_num;\n+  for (common = 0; common < n; common++)\n+    {\n+      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)\n+\tbreak;\n+    }\n+\n+  /* If there are no common directories, there can be no relative prefix.  */\n+  if (common == 0)\n+    {\n+      free_split_directories (prog_dirs);\n+      free_split_directories (bin_dirs);\n+      free_split_directories (prefix_dirs);\n+      return NULL;\n+    }\n+\n+  /* Two passes: first figure out the size of the result string, and\n+     then construct it.  */\n+  needed_len = 0;\n+  for (i = 0; i < prog_num; i++)\n+    needed_len += strlen (prog_dirs[i]);\n+  needed_len += sizeof (DIR_UP) * (bin_num - common);\n+  for (i = common; i < prefix_num; i++)\n+    needed_len += strlen (prefix_dirs[i]);\n+  needed_len += 1; /* Trailing NUL.  */\n+\n+  ret = (char *) malloc (needed_len);\n+  if (ret == NULL)\n+    return NULL;\n+\n+  /* Build up the pathnames in argv[0].  */\n+  for (i = 0; i < prog_num; i++)\n+    strcat (ret, prog_dirs[i]);\n+\n+  /* Now build up the ..'s.  */\n+  ptr = ret + strlen(ret);\n+  for (i = common; i < bin_num; i++)\n+    {\n+      strcpy (ptr, DIR_UP);\n+      ptr += sizeof (DIR_UP) - 1;\n+      *(ptr++) = DIR_SEPARATOR;\n+    }\n+  *ptr = '\\0';\n+\n+  /* Put in directories to move over to prefix.  */\n+  for (i = common; i < prefix_num; i++)\n+    strcat (ret, prefix_dirs[i]);\n+\n+  free_split_directories (prog_dirs);\n+  free_split_directories (bin_dirs);\n+  free_split_directories (prefix_dirs);\n+\n+  return ret;\n+}"}]}