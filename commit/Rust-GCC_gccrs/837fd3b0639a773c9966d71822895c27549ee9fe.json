{"sha": "837fd3b0639a773c9966d71822895c27549ee9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM3ZmQzYjA2MzlhNzczYzk5NjZkNzE4MjI4OTVjMjc1NDllZTlmZQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-03-06T10:36:21Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-03-06T10:36:21Z"}, "message": "invoke.texi (AVR Options): -mmcu=: Document the XMEGA cores.\n\n\t* doc/invoke.texi (AVR Options): -mmcu=: Document the XMEGA cores.\n\tExplain RAMPD, RAMPX, RAMPDY, RAMPZ usage by avr-gcc.\n\tSome more notes on EIND usage and reorder EIND subsection.\n\nFrom-SVN: r184985", "tree": {"sha": "ea9bd1e509e796c2d4fdb095e455ea6ddc4b1ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea9bd1e509e796c2d4fdb095e455ea6ddc4b1ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/837fd3b0639a773c9966d71822895c27549ee9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/837fd3b0639a773c9966d71822895c27549ee9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/837fd3b0639a773c9966d71822895c27549ee9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/837fd3b0639a773c9966d71822895c27549ee9fe/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17a27c59df1a6d4d0a13f8ef0acaa0cc9a6644eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a27c59df1a6d4d0a13f8ef0acaa0cc9a6644eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a27c59df1a6d4d0a13f8ef0acaa0cc9a6644eb"}], "stats": {"total": 141, "additions": 118, "deletions": 23}, "files": [{"sha": "6578c590072255e8916526ce7cf027d0b6693b58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837fd3b0639a773c9966d71822895c27549ee9fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837fd3b0639a773c9966d71822895c27549ee9fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=837fd3b0639a773c9966d71822895c27549ee9fe", "patch": "@@ -1,3 +1,9 @@\n+2012-03-06  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* doc/invoke.texi (AVR Options): -mmcu=: Document the XMEGA cores.\n+\tExplain RAMPD, RAMPX, RAMPDY, RAMPZ usage by avr-gcc.\n+\tSome more notes on EIND usage and reorder EIND subsection.\n+\n 2012-03-06  Tristan Gingold  <gingold@adacore.com>\n \n \t* config/vms/vms.c (VMS_CRTL_LDBL): Rename from VMS_CRTL_PRNTF."}, {"sha": "d10156b1292a555406e0add87cf1fd4a524880b6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 112, "deletions": 23, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/837fd3b0639a773c9966d71822895c27549ee9fe/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/837fd3b0639a773c9966d71822895c27549ee9fe/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=837fd3b0639a773c9966d71822895c27549ee9fe", "patch": "@@ -10993,6 +10993,32 @@ memory and with the @code{MOVW} instruction.\n of program memory.\n @*@var{mcu}@tie{}= @code{atmega2560}, @code{atmega2561}.\n \n+@item avrxmega2\n+``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB\n+of program memory.\n+@*@var{mcu}@tie{}= @code{atxmega16a4}, @code{atxmega16d4},\n+@dots{}\n+\n+@item avrxmega4\n+``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB\n+of program memory.\n+@*@var{mcu}@tie{}= @code{atxmega64a3}, @code{atxmega64d3}.\n+\n+@item avrxmega5\n+``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB\n+of program memory and more than 64@tie{}KiB of RAM.\n+@*@var{mcu}@tie{}= @code{atxmega64a1}, @code{atxmega64a1u}.\n+\n+@item avrxmega6\n+``XMEGA'' devices with more than 128@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{atxmega128a3}, @code{atxmega192d3},\n+@dots{}\n+\n+@item avrxmega7\n+``XMEGA'' devices with more than 128@tie{}KiB of program memory and\n+more than 64@tie{}KiB of RAM.\n+@*@var{mcu}@tie{}= @code{atxmega128a1}, @code{atxmega128a1u}.\n+\n @end table\n \n \n@@ -11081,7 +11107,7 @@ byte of SP is always zero.\n @end table\n \n @subsubsection @code{EIND} and Devices with more than 128 Ki Bytes of Flash\n-\n+@cindex @code{EIND}\n Pointers in the implementation are 16@tie{}bits wide.\n The address of a function or label is represented as word address so\n that indirect jumps and calls can target any code address in the\n@@ -11100,12 +11126,6 @@ the compiler and are subject to some limitations:\n @item\n The compiler never sets @code{EIND}.\n \n-@item\n-The startup code from libgcc never sets @code{EIND}.\n-Notice that startup code is a blend of code from libgcc and avr-libc.\n-For the impact of avr-libc on @code{EIND}, see the\n-@w{@uref{http://nongnu.org/avr-libc/user-manual,avr-libc user manual}}.\n-\n @item\n The compiler uses @code{EIND} implicitely in @code{EICALL}/@code{EIJMP}\n instructions or might read @code{EIND} directly in order to emulate an\n@@ -11117,18 +11137,47 @@ code or during the application. In particular, @code{EIND} is not\n saved/restored in function or interrupt service routine\n prologue/epilogue.\n \n-@item\n-It is legitimate for user-specific startup code to set up @code{EIND}\n-early, for example by means of initialization code located in\n-section @code{.init3}. Such code runs prior to general startup code\n-that initializes RAM and calls constructors.\n-\n @item\n For indirect calls to functions and computed goto, the linker will\n generate @emph{stubs}. Stubs are jump pads sometimes also called\n @emph{trampolines}. Thus, the indirect call/jump will jump to such a stub.\n The stub contains a direct jump to the desired address.\n \n+@item\n+The default linker script is arranged for code with @code{EIND = 0}.\n+If code is supposed to work for a setup with @code{EIND != 0}, a custom\n+linker script has to be used in order to place the sections whose\n+name start with @code{.trampolines} into the segment where @code{EIND}\n+points to.\n+\n+@item\n+The startup code from libgcc never sets @code{EIND}.\n+Notice that startup code is a blend of code from libgcc and AVR-Libc.\n+For the impact of AVR-Libc on @code{EIND}, see the\n+@w{@uref{http://nongnu.org/avr-libc/user-manual,AVR-Libc user manual}}.\n+\n+@item\n+It is legitimate for user-specific startup code to set up @code{EIND}\n+early, for example by means of initialization code located in\n+section @code{.init3}. Such code runs prior to general startup code\n+that initializes RAM and calls constructors, but after the bit\n+of startup code from AVR-Libc that sets @code{EIND} to the segment\n+where the vector table is located.\n+@example\n+#include <avr/io.h>\n+\n+static void\n+__attribute__ ((section (\".init3\"), naked, used, no_instrument_function))\n+init3_set_eind (void)\n+@{\n+    __asm volatile (\"ldi r24, pm_hh8(__trampolines_start)\" \"\\n\\t\"\n+                    \"out %i0, r24\" :: \"n\" (&EIND) : \"r24\", \"memory\");\n+@}\n+@end example\n+\n+@noindent\n+The @code{__trampolines_start} symbol is defined in the linker script.\n+\n @item\n Stubs will be generated automatically by the linker if\n the following two conditions are met:\n@@ -11158,13 +11207,6 @@ tables you can specify the @option{-fno-jump-tables} command-line option.\n @item If the tools hit a @code{gs()} modifier explained above.\n @end itemize\n \n-@item\n-The default linker script is arranged for code with @code{EIND = 0}.\n-If code is supposed to work for a setup with @code{EIND != 0}, a custom\n-linker script has to be used in order to place the sections whose\n-name start with @code{.trampolines} into the segment where @code{EIND}\n-points to.\n-\n @item\n Jumping to non-symbolic addresses like so is @emph{not} supported:\n \n@@ -11193,6 +11235,48 @@ and the application be linked with @code{-Wl,--defsym,func_4=0x4}.\n Alternatively, @code{func_4} can be defined in the linker script.\n @end itemize\n \n+@subsubsection Handling of the @code{RAMPD}, @code{RAMPX}, @code{RAMPY} and @code{RAMPZ} Special Function Registers\n+@cindex @code{RAMPD}\n+@cindex @code{RAMPX}\n+@cindex @code{RAMPY}\n+@cindex @code{RAMPZ}\n+Some AVR devices support memories larger than the 64@tie{}KiB range\n+that can be accessed with 16-bit pointers.  To access memory locations\n+outside this 64@tie{}KiB range, the contentent of a @code{RAMP}\n+register is used as high part of the address:\n+The @code{X}, @code{Y}, @code{Z} address register is concatenated\n+with the @code{RAMPX}, @code{RAMPY}, @code{RAMPZ} special function\n+register, respectively, to get a wide address. Similarly,\n+@code{RAMPD} is used together with direct addressing.\n+\n+@itemize\n+@item\n+The startup code initializes the @code{RAMP} special function\n+registers with zero.\n+\n+@item\n+If a @ref{AVR Named Address Spaces,named address space} other than\n+generic or @code{__flash} is used, then @code{RAMPZ} will be set\n+as needed before the operation.\n+\n+@item\n+If the device supports RAM larger than 64@tie{KiB} and the compiler\n+needs to change @code{RAMPZ} to accomplish an operation, @code{RAMPZ}\n+will be reset to zero after the operation.\n+\n+@item\n+If the device comes with a specific @code{RAMP} register, the ISR\n+prologue/epilogue will save/restore that SFR and initialize it with\n+zero in case the ISR code might (implicitly) use it.\n+\n+@item\n+RAM larger than 64@tie{KiB} is not supported by avr-gcc.\n+If you use inline assembler to read from locations outside the\n+16-bit address range and change one of the @code{RAMP} registers,\n+you must reset it to zero after the access.\n+\n+@end itemize\n+\n @subsubsection AVR Built-in Macros\n \n avr-gcc defines several built-in macros so that the user code can test\n@@ -11217,10 +11301,8 @@ the device name as from the AVR user manual. The difference between\n @var{Device} in the built-in macro and @var{device} in\n @code{-mmcu=@var{device}} is that the latter is always lowercase.\n \n-@item __AVR_HAVE_RAMPZ__\n @item __AVR_HAVE_ELPM__\n-The device has the @code{RAMPZ} special function register and thus the\n-@code{ELPM} instruction.\n+The device has the the @code{ELPM} instruction.\n \n @item __AVR_HAVE_ELPMX__\n The device has the @code{ELPM R@var{n},Z} and @code{ELPM\n@@ -11258,6 +11340,13 @@ with up to 128@tie{}KiB of program memory.\n The stack pointer (SP) is respectively 8 or 16 bits wide.\n The definition of these macros is affected by @code{-mtiny-stack}.\n \n+@item __AVR_HAVE_RAMPD__\n+@item __AVR_HAVE_RAMPX__\n+@item __AVR_HAVE_RAMPY__\n+@item __AVR_HAVE_RAMPZ__\n+The device has the @code{RAMPD}, @code{RAMPX}, @code{RAMPY},\n+@code{RAMPZ} special function register, respectively.\n+\n @item __NO_INTERRUPTS__\n This macro reflects the @code{-mno-interrupts} command line option.\n "}]}