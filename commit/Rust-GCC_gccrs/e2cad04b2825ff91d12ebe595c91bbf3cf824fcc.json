{"sha": "e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjYWQwNGIyODI1ZmY5MWQxMmViZTU5NWM5MWJiZjNjZjgyNGZjYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-30T21:59:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-30T21:59:08Z"}, "message": "Make-lang.in (fortran/f95-lang.o): Update dependencies.\n\n        * Make-lang.in (fortran/f95-lang.o): Update dependencies.\n        (fortran/trans-decl.o, fortran/trans-types.o): Likewise.\n        * gfortran.h (gfc_integer_info): Add c_char, c_short, c_int,\n        c_long, c_long_long.\n        (gfc_logical_info): Add c_bool.\n        (gfc_real_info): Add mode_precision, c_float, c_double, c_long_double.\n        * trans-array.c (gfc_array_allocate): Use TYPE_PRECISION\n        rather than gfc_int[48]_type_node for allocate choice.\n        * trans-decl.c (gfc_build_intrinsic_function_decls): Cache\n        local copies of some kind type nodes.\n        (gfc_build_builtin_function_decls): Likewise.\n        * trans-expr.c (gfc_conv_power_op): Likewise.\n        * trans-intrinsic.c (gfc_conv_intrinsic_index,\n        gfc_conv_intrinsic_scan, gfc_conv_intrinsic_verify,\n        gfc_conv_intrinsic_trim, gfc_conv_intrinsic_repeat): Likewise.\n        * trans-stmt.c (gfc_trans_pause, gfc_trans_stop,\n        gfc_trans_character_select, gfc_trans_allocate): Likewise.\n        * trans-io.c (gfc_pint4_type_node): Move into ...\n        (gfc_build_io_library_fndecls): ... here.  Cache local copies of\n        some kind type nodes.\n        * trans-types.c (gfc_type_nodes): Remove.\n        (gfc_character1_type_node, gfc_strlen_type_node): New.\n        (gfc_integer_types, gfc_logical_types): New.\n        (gfc_real_types, gfc_complex_types): New.\n        (gfc_init_kinds): Fill in real mode_precision.\n        (gfc_build_int_type, gfc_build_real_type): New.\n        (gfc_build_complex_type, gfc_build_logical_type): New.\n        (c_size_t_size): New.\n        (gfc_init_types): Loop over kinds.\n        (gfc_get_int_type, gfc_get_real_type): Use gfc_validate_kind.\n        (gfc_get_complex_type, gfc_get_logical_type): Likewise.\n        (gfc_get_character_type_len): Likewise.\n        (gfc_type_for_size): Loop over kinds; use a reduced set of\n        unsigned type nodes.\n        (gfc_type_for_mode): Loop over kinds.\n        (gfc_signed_or_unsigned_type): Use gfc_type_for_size.\n        (gfc_unsigned_type, gfc_signed_type): Use gfc_signed_or_unsigned_type.\n        * trans-types.h (F95_INT1_TYPE, F95_INT2_TYPE, F95_INT4_TYPE,\n        F95_INT8_TYPE, F95_INT16_TYPE, F95_REAL4_TYPE, F95_REAL8_TYPE,\n        F95_REAl16_TYPE, F95_COMPLEX4_TYPE, F95_COMPLEX8_TYPE,\n        F95_COMPLEX16_TYPE, F95_LOGICAL1_TYPE, F95_LOGICAL2_TYPE,\n        F95_LOGICAL4_TYPE, F95_LOGICAL8_TYPE, F95_LOGICAL16_TYPE,\n        F95_CHARACTER1_TYPE, NUM_F95_TYPES, gfc_type_nodes,\n        gfc_int1_type_node, gfc_int2_type_node, gfc_int4_type_node,\n        gfc_int8_type_node, gfc_int16_type_node, gfc_real4_type_node,\n        gfc_real8_type_node, gfc_real16_type_node, gfc_complex4_type_node,\n        gfc_complex8_type_node, gfc_complex16_type_node,\n        gfc_logical1_type_node, gfc_logical2_type_node,\n        gfc_logical4_type_node, gfc_logical8_type_node,\n        gfc_logical16_type_node, gfc_strlen_kind): Remove.\n        (gfc_character1_type_node): Turn in to a variable.\n        (gfc_strlen_type_node): Likewise.\n\nFrom-SVN: r86806", "tree": {"sha": "0e8df03448ca96d577287911ff34a7551a2dbfcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e8df03448ca96d577287911ff34a7551a2dbfcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/comments", "author": null, "committer": null, "parents": [{"sha": "bc482be4939cf93e6ddb948a42c751824e0a2d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc482be4939cf93e6ddb948a42c751824e0a2d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc482be4939cf93e6ddb948a42c751824e0a2d3e"}], "stats": {"total": 779, "additions": 367, "deletions": 412}, "files": [{"sha": "6f368c234c158bc3235cd4d08ee69617afa7f537", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -1,3 +1,58 @@\n+2004-08-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* Make-lang.in (fortran/f95-lang.o): Update dependencies.\n+\t(fortran/trans-decl.o, fortran/trans-types.o): Likewise.\n+\t* gfortran.h (gfc_integer_info): Add c_char, c_short, c_int,\n+\tc_long, c_long_long.\n+\t(gfc_logical_info): Add c_bool.\n+\t(gfc_real_info): Add mode_precision, c_float, c_double, c_long_double.\n+\t* trans-array.c (gfc_array_allocate): Use TYPE_PRECISION\n+\trather than gfc_int[48]_type_node for allocate choice.\n+\t* trans-decl.c (gfc_build_intrinsic_function_decls): Cache\n+\tlocal copies of some kind type nodes.\n+\t(gfc_build_builtin_function_decls): Likewise.\n+\t* trans-expr.c (gfc_conv_power_op): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_index,\n+\tgfc_conv_intrinsic_scan, gfc_conv_intrinsic_verify,\n+\tgfc_conv_intrinsic_trim, gfc_conv_intrinsic_repeat): Likewise.\n+\t* trans-stmt.c (gfc_trans_pause, gfc_trans_stop,\n+\tgfc_trans_character_select, gfc_trans_allocate): Likewise.\n+\t* trans-io.c (gfc_pint4_type_node): Move into ...\n+\t(gfc_build_io_library_fndecls): ... here.  Cache local copies of\n+\tsome kind type nodes.\n+\t* trans-types.c (gfc_type_nodes): Remove.\n+\t(gfc_character1_type_node, gfc_strlen_type_node): New.\n+\t(gfc_integer_types, gfc_logical_types): New.\n+\t(gfc_real_types, gfc_complex_types): New.\n+\t(gfc_init_kinds): Fill in real mode_precision.\n+\t(gfc_build_int_type, gfc_build_real_type): New.\n+\t(gfc_build_complex_type, gfc_build_logical_type): New.\n+\t(c_size_t_size): New.\n+\t(gfc_init_types): Loop over kinds.\n+\t(gfc_get_int_type, gfc_get_real_type): Use gfc_validate_kind.\n+\t(gfc_get_complex_type, gfc_get_logical_type): Likewise.\n+\t(gfc_get_character_type_len): Likewise.\n+\t(gfc_type_for_size): Loop over kinds; use a reduced set of\n+\tunsigned type nodes.\n+\t(gfc_type_for_mode): Loop over kinds.\n+\t(gfc_signed_or_unsigned_type): Use gfc_type_for_size.\n+\t(gfc_unsigned_type, gfc_signed_type): Use gfc_signed_or_unsigned_type.\n+\t* trans-types.h (F95_INT1_TYPE, F95_INT2_TYPE, F95_INT4_TYPE,\n+\tF95_INT8_TYPE, F95_INT16_TYPE, F95_REAL4_TYPE, F95_REAL8_TYPE,\n+\tF95_REAl16_TYPE, F95_COMPLEX4_TYPE, F95_COMPLEX8_TYPE,\n+\tF95_COMPLEX16_TYPE, F95_LOGICAL1_TYPE, F95_LOGICAL2_TYPE,\n+\tF95_LOGICAL4_TYPE, F95_LOGICAL8_TYPE, F95_LOGICAL16_TYPE,\n+\tF95_CHARACTER1_TYPE, NUM_F95_TYPES, gfc_type_nodes,\n+\tgfc_int1_type_node, gfc_int2_type_node, gfc_int4_type_node,\n+\tgfc_int8_type_node, gfc_int16_type_node, gfc_real4_type_node,\n+\tgfc_real8_type_node, gfc_real16_type_node, gfc_complex4_type_node,\n+\tgfc_complex8_type_node, gfc_complex16_type_node,\n+\tgfc_logical1_type_node, gfc_logical2_type_node,\n+\tgfc_logical4_type_node, gfc_logical8_type_node,\n+\tgfc_logical16_type_node, gfc_strlen_kind): Remove.\n+\t(gfc_character1_type_node): Turn in to a variable.\n+\t(gfc_strlen_type_node): Likewise.\n+\n 2004-08-30  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.h (gfc_namespace): Add new field is_block_data."}, {"sha": "1649f328eea22ad5bebd754ce99865262f767632", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -278,14 +278,17 @@ $(F95_PARSER_OBJS): fortran/gfortran.h fortran/intrinsic.h fortran/match.h \\\n GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/intrinsic.h fortran/trans-array.h \\\n     fortran/trans-const.h fortran/trans-const.h fortran/trans.h \\\n     fortran/trans-stmt.h fortran/trans-types.h \\\n-    $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) coretypes.h\n+    $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) coretypes.h $(GGC_H)\n \n fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n-  gt-fortran-f95-lang.h gtype-fortran.h cgraph.h\n+  gt-fortran-f95-lang.h gtype-fortran.h cgraph.h $(TARGET_H)\n fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS)\n-fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h cgraph.h\n-fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h\n+fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n+  cgraph.h $(TARGET_H) function.h errors.h $(FLAGS_H) tree-gimple.h \\\n+  tree-dump.h\n+fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n+  real.h toplev.h $(TARGET_H)\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS)"}, {"sha": "3ae3978a5e7dff6b5cdc282c378a58a9721339fa", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -1090,12 +1090,18 @@ gfc_expr;\n \n typedef struct\n {\n-  int kind, radix, digits, bit_size;\n-\n-  int range;\n-  mpz_t huge;\n-\n-  mpz_t min_int, max_int;\t/* Values really representable by the target */\n+  /* Values really representable by the target.  */\n+  mpz_t huge, min_int, max_int;\n+\n+  int kind, radix, digits, bit_size, range;\n+\n+  /* True if the C type of the given name maps to this precision.\n+     Note that more than one bit can be set.  */\n+  unsigned int c_char : 1;\n+  unsigned int c_short : 1;\n+  unsigned int c_int : 1;\n+  unsigned int c_long : 1;\n+  unsigned int c_long_long : 1;\n }\n gfc_integer_info;\n \n@@ -1106,6 +1112,8 @@ typedef struct\n {\n   int kind, bit_size;\n \n+  /* True if the C++ type bool, C99 type _Bool, maps to this precision.  */\n+  unsigned int c_bool : 1;\n }\n gfc_logical_info;\n \n@@ -1114,10 +1122,18 @@ extern gfc_logical_info gfc_logical_kinds[];\n \n typedef struct\n {\n+  mpfr_t epsilon, huge, tiny;\n   int kind, radix, digits, min_exponent, max_exponent;\n-\n   int range, precision;\n-  mpfr_t epsilon, huge, tiny;\n+\n+  /* The precision of the type as reported by GET_MODE_PRECISION.  */\n+  int mode_precision;\n+\n+  /* True if the C type of the given name maps to this precision.\n+     Note that more than one bit can be set.  */\n+  unsigned int c_float : 1;\n+  unsigned int c_double : 1;\n+  unsigned int c_long_double : 1;\n }\n gfc_real_info;\n "}, {"sha": "1aa1a67e315f687b5f1128cb0af1818e4f7e8485", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -2784,9 +2784,9 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n   pointer = gfc_build_addr_expr (NULL, tmp);\n   pointer = gfc_evaluate_now (pointer, &se->pre);\n \n-  if (gfc_array_index_type == gfc_int4_type_node)\n+  if (TYPE_PRECISION (gfc_array_index_type) == 32)\n     allocate = gfor_fndecl_allocate;\n-  else if (gfc_array_index_type == gfc_int8_type_node)\n+  else if (TYPE_PRECISION (gfc_array_index_type) == 64)\n     allocate = gfor_fndecl_allocate64;\n   else\n     abort ();"}, {"sha": "7ceebcce93cad990f320f7ea62d12c813e16c03b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -1559,6 +1559,14 @@ gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n static void\n gfc_build_intrinsic_function_decls (void)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n+  tree gfc_int8_type_node = gfc_get_int_type (8);\n+  tree gfc_logical4_type_node = gfc_get_logical_type (4);\n+  tree gfc_real4_type_node = gfc_get_real_type (4);\n+  tree gfc_real8_type_node = gfc_get_real_type (8);\n+  tree gfc_complex4_type_node = gfc_get_complex_type (4);\n+  tree gfc_complex8_type_node = gfc_get_complex_type (8);\n+\n   /* String functions.  */\n   gfor_fndecl_copy_string =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"copy_string\")),\n@@ -1738,6 +1746,10 @@ gfc_build_intrinsic_function_decls (void)\n void\n gfc_build_builtin_function_decls (void)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n+  tree gfc_int8_type_node = gfc_get_int_type (8);\n+  tree gfc_logical4_type_node = gfc_get_logical_type (4);\n+\n   gfor_fndecl_internal_malloc =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"internal_malloc\")),\n \t\t\t\t     pvoid_type_node, 1, gfc_int4_type_node);"}, {"sha": "3884c012970e09f9cd6e00940e38a754b9190fa8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -553,6 +553,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n static void\n gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_int4_type_node;\n   int kind;\n   int ikind;\n   gfc_se lse;\n@@ -573,6 +574,8 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))\n       return;        \n \n+  gfc_int4_type_node = gfc_get_int_type (4);\n+\n   kind = expr->op1->ts.kind;\n   switch (expr->op2->ts.type)\n     {"}, {"sha": "bdb307f60ff5ae3971ae8e6c0e64fe6990dbad47", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -1945,6 +1945,7 @@ gfc_conv_intrinsic_len_trim (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_index (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_logical4_type_node = gfc_get_logical_type (4);\n   tree args;\n   tree back;\n   tree type;\n@@ -2245,6 +2246,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n static void\n gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_logical4_type_node = gfc_get_logical_type (4);\n   tree args;\n   tree back;\n   tree type;\n@@ -2277,6 +2279,7 @@ gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_logical4_type_node = gfc_get_logical_type (4);\n   tree args;\n   tree back;\n   tree type;\n@@ -2529,6 +2532,7 @@ gfc_conv_intrinsic_sr_kind (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n   tree var;\n   tree len;\n   tree addr;\n@@ -2570,6 +2574,7 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n   tree tmp;\n   tree len;\n   tree args;"}, {"sha": "56023b6fc69803addc433d7bafef2719e1d9cd8e", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -39,8 +39,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"trans-const.h\"\n \n \n-static GTY(()) tree gfc_pint4_type_node;\n-\n /* Members of the ioparm structure.  */\n \n static GTY(()) tree ioparm_unit;\n@@ -160,13 +158,16 @@ static enum { READ, WRITE, IOLENGTH } last_dt;\n void\n gfc_build_io_library_fndecls (void)\n {\n+  tree gfc_int4_type_node;\n+  tree gfc_pint4_type_node;\n   tree ioparm_type;\n \n+  gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_pint4_type_node = build_pointer_type (gfc_int4_type_node);\n \n-/* Build the st_parameter structure.  Information associated with I/O\n-   calls are transferred here.  This must match the one defined in the\n-   library exactly. */\n+  /* Build the st_parameter structure.  Information associated with I/O\n+     calls are transferred here.  This must match the one defined in the\n+     library exactly. */\n \n   ioparm_type = make_node (RECORD_TYPE);\n   TYPE_NAME (ioparm_type) = get_identifier (\"_gfc_ioparm\");"}, {"sha": "0a43401fe597c2942daf68553e28a5c068da5311", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -275,6 +275,7 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n tree\n gfc_trans_pause (gfc_code * code)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_se se;\n   tree args;\n   tree tmp;\n@@ -314,6 +315,7 @@ gfc_trans_pause (gfc_code * code)\n tree\n gfc_trans_stop (gfc_code * code)\n {\n+  tree gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_se se;\n   tree args;\n   tree tmp;\n@@ -991,6 +993,8 @@ gfc_trans_character_select (gfc_code *code)\n \n   if (select_struct == NULL)\n     {\n+      tree gfc_int4_type_node = gfc_get_int_type (4);\n+\n       select_struct = make_node (RECORD_TYPE);\n       TYPE_NAME (select_struct) = get_identifier (\"_jump_struct\");\n \n@@ -3016,6 +3020,8 @@ gfc_trans_allocate (gfc_code * code)\n \n   if (code->expr)\n     {\n+      tree gfc_int4_type_node = gfc_get_int_type (4);\n+\n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n       pstat = gfc_build_addr_expr (NULL, stat);\n "}, {"sha": "faa8ecfed378fb907155ce01774b5791f918c583", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 245, "deletions": 344, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -50,15 +50,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static tree gfc_get_derived_type (gfc_symbol * derived);\n \n-tree gfc_type_nodes[NUM_F95_TYPES];\n-\n tree gfc_array_index_type;\n tree pvoid_type_node;\n tree ppvoid_type_node;\n tree pchar_type_node;\n+tree gfc_character1_type_node;\n+tree gfc_strlen_type_node;\n \n-static GTY(()) tree gfc_desc_dim_type = NULL;\n-\n+static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n@@ -67,9 +66,13 @@ static GTY(()) tree gfc_max_array_element_size;\n #define MAX_INT_KINDS 5\n gfc_integer_info gfc_integer_kinds[MAX_INT_KINDS + 1];\n gfc_logical_info gfc_logical_kinds[MAX_INT_KINDS + 1];\n+static GTY(()) tree gfc_integer_types[MAX_INT_KINDS + 1];\n+static GTY(()) tree gfc_logical_types[MAX_INT_KINDS + 1];\n \n #define MAX_REAL_KINDS 4\n gfc_real_info gfc_real_kinds[MAX_REAL_KINDS + 1];\n+static GTY(()) tree gfc_real_types[MAX_REAL_KINDS + 1];\n+static GTY(()) tree gfc_complex_types[MAX_REAL_KINDS + 1];\n \n /* The integer kind to use for array indices.  This will be set to the\n    proper value based on target information from the backend.  */\n@@ -178,6 +181,7 @@ gfc_init_kinds (void)\n       gfc_real_kinds[r_index].digits = fmt->p;\n       gfc_real_kinds[r_index].min_exponent = fmt->emin;\n       gfc_real_kinds[r_index].max_exponent = fmt->emax;\n+      gfc_real_kinds[r_index].mode_precision = GET_MODE_PRECISION (mode);\n       r_index += 1;\n     }\n \n@@ -324,6 +328,127 @@ gfc_validate_kind (bt type, int kind, bool may_fail)\n }\n \n \n+/* Four subroutines of gfc_init_types.  Create type nodes for the given kind.\n+   Reuse common type nodes where possible.  Recognize if the kind matches up\n+   with a C type.  This will be used later in determining which routines may\n+   be scarfed from libm.  */\n+\n+static tree\n+gfc_build_int_type (gfc_integer_info *info)\n+{\n+  int mode_precision = info->bit_size;\n+\n+  if (mode_precision == CHAR_TYPE_SIZE)\n+    info->c_char = 1;\n+  if (mode_precision == SHORT_TYPE_SIZE)\n+    info->c_short = 1;\n+  if (mode_precision == INT_TYPE_SIZE)\n+    info->c_int = 1;\n+  if (mode_precision == LONG_TYPE_SIZE)\n+    info->c_long = 1;\n+  if (mode_precision == LONG_LONG_TYPE_SIZE)\n+    info->c_long_long = 1;\n+\n+  if (TYPE_PRECISION (intQI_type_node) == mode_precision)\n+    return intQI_type_node;\n+  if (TYPE_PRECISION (intHI_type_node) == mode_precision)\n+    return intHI_type_node;\n+  if (TYPE_PRECISION (intSI_type_node) == mode_precision)\n+    return intSI_type_node;\n+  if (TYPE_PRECISION (intDI_type_node) == mode_precision)\n+    return intDI_type_node;\n+  if (TYPE_PRECISION (intTI_type_node) == mode_precision)\n+    return intTI_type_node;\n+\n+  return make_signed_type (mode_precision);\n+}\n+\n+static tree\n+gfc_build_real_type (gfc_real_info *info)\n+{\n+  int mode_precision = info->mode_precision;\n+  tree new_type;\n+\n+  if (mode_precision == FLOAT_TYPE_SIZE)\n+    info->c_float = 1;\n+  if (mode_precision == DOUBLE_TYPE_SIZE)\n+    info->c_double = 1;\n+  if (mode_precision == LONG_DOUBLE_TYPE_SIZE)\n+    info->c_long_double = 1;\n+\n+  if (TYPE_PRECISION (float_type_node) == mode_precision)\n+    return float_type_node;\n+  if (TYPE_PRECISION (double_type_node) == mode_precision)\n+    return double_type_node;\n+  if (TYPE_PRECISION (long_double_type_node) == mode_precision)\n+    return long_double_type_node;\n+\n+  new_type = make_node (REAL_TYPE);\n+  TYPE_PRECISION (new_type) = mode_precision;\n+  layout_type (new_type);\n+  return new_type;\n+}\n+\n+static tree\n+gfc_build_complex_type (tree scalar_type)\n+{\n+  tree new_type;\n+\n+  if (scalar_type == NULL)\n+    return NULL;\n+  if (scalar_type == float_type_node)\n+    return complex_float_type_node;\n+  if (scalar_type == double_type_node)\n+    return complex_double_type_node;\n+  if (scalar_type == long_double_type_node)\n+    return complex_long_double_type_node;\n+\n+  new_type = make_node (COMPLEX_TYPE);\n+  TREE_TYPE (new_type) = scalar_type;\n+  layout_type (new_type);\n+  return new_type;\n+}\n+\n+static tree\n+gfc_build_logical_type (gfc_logical_info *info)\n+{\n+  int bit_size = info->bit_size;\n+  tree new_type;\n+\n+  if (bit_size == BOOL_TYPE_SIZE)\n+    {\n+      info->c_bool = 1;\n+      return boolean_type_node;\n+    }\n+\n+  new_type = make_unsigned_type (bit_size);\n+  TREE_SET_CODE (new_type, BOOLEAN_TYPE);\n+  TYPE_MAX_VALUE (new_type) = build_int_cst (new_type, 1);\n+  TYPE_PRECISION (new_type) = 1;\n+\n+  return new_type;\n+}\n+\n+#if 0\n+/* Return the bit size of the C \"size_t\".  */\n+\n+static unsigned int\n+c_size_t_size (void)\n+{\n+#ifdef SIZE_TYPE  \n+  if (strcmp (SIZE_TYPE, \"unsigned int\") == 0)\n+    return INT_TYPE_SIZE;\n+  if (strcmp (SIZE_TYPE, \"long unsigned int\") == 0)\n+    return LONG_TYPE_SIZE;\n+  if (strcmp (SIZE_TYPE, \"short unsigned int\") == 0)\n+    return SHORT_TYPE_SIZE;\n+  abort ();\n+#else\n+  return LONG_TYPE_SIZE;\n+#endif\n+}\n+#endif\n+\n /* Create the backend type nodes. We map them to their\n    equivalent C type, at least for now.  We also give\n    names to the types here, and we push them in the\n@@ -332,69 +457,49 @@ gfc_validate_kind (bt type, int kind, bool may_fail)\n void\n gfc_init_types (void)\n {\n+  char name_buf[16];\n+  int index;\n+  tree type;\n   unsigned n;\n   unsigned HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT lo;\n \n-  /* Name the types.  */\n+  /* Create and name the types.  */\n #define PUSH_TYPE(name, node) \\\n   pushdecl (build_decl (TYPE_DECL, get_identifier (name), node))\n \n-  gfc_int1_type_node = signed_char_type_node;\n-  PUSH_TYPE (\"int1\", gfc_int1_type_node);\n-  gfc_int2_type_node = short_integer_type_node;\n-  PUSH_TYPE (\"int2\", gfc_int2_type_node);\n-  gfc_int4_type_node = gfc_type_for_size (32, 0 /*unsigned */ );\n-  PUSH_TYPE (\"int4\", gfc_int4_type_node);\n-  gfc_int8_type_node = gfc_type_for_size (64, 0 /*unsigned */ );\n-  PUSH_TYPE (\"int8\", gfc_int8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-  gfc_int16_type_node = gfc_type_for_size (128, 0 /*unsigned */ );\n-  PUSH_TYPE (\"int16\", gfc_int16_type_node);\n-#endif\n-\n-  gfc_real4_type_node = float_type_node;\n-  PUSH_TYPE (\"real4\", gfc_real4_type_node);\n-  gfc_real8_type_node = double_type_node;\n-  PUSH_TYPE (\"real8\", gfc_real8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-  /* Hmm, this will not work. Ref. g77 */\n-  gfc_real16_type_node = long_double_type_node;\n-  PUSH_TYPE (\"real16\", gfc_real16_type_node);\n-#endif\n+  for (index = 0; gfc_integer_kinds[index].kind != 0; ++index)\n+    {\n+      type = gfc_build_int_type (&gfc_integer_kinds[index]);\n+      gfc_integer_types[index] = type;\n+      snprintf (name_buf, sizeof(name_buf), \"int%d\",\n+\t\tgfc_integer_kinds[index].kind);\n+      PUSH_TYPE (name_buf, type);\n+    }\n \n-  gfc_complex4_type_node = complex_float_type_node;\n-  PUSH_TYPE (\"complex4\", gfc_complex4_type_node);\n-  gfc_complex8_type_node = complex_double_type_node;\n-  PUSH_TYPE (\"complex8\", gfc_complex8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-  /* Hmm, this will not work. Ref. g77 */\n-  gfc_complex16_type_node = complex_long_double_type_node;\n-  PUSH_TYPE (\"complex16\", gfc_complex16_type_node);\n-#endif\n+  for (index = 0; gfc_logical_kinds[index].kind != 0; ++index)\n+    {\n+      type = gfc_build_logical_type (&gfc_logical_kinds[index]);\n+      gfc_logical_types[index] = type;\n+      snprintf (name_buf, sizeof(name_buf), \"logical%d\",\n+\t\tgfc_logical_kinds[index].kind);\n+      PUSH_TYPE (name_buf, type);\n+    }\n \n-  gfc_logical1_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (gfc_logical1_type_node) = 8;\n-  fixup_unsigned_type (gfc_logical1_type_node);\n-  PUSH_TYPE (\"logical1\", gfc_logical1_type_node);\n-  gfc_logical2_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (gfc_logical2_type_node) = 16;\n-  fixup_unsigned_type (gfc_logical2_type_node);\n-  PUSH_TYPE (\"logical2\", gfc_logical2_type_node);\n-  gfc_logical4_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (gfc_logical4_type_node) = 32;\n-  fixup_unsigned_type (gfc_logical4_type_node);\n-  PUSH_TYPE (\"logical4\", gfc_logical4_type_node);\n-  gfc_logical8_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (gfc_logical8_type_node) = 64;\n-  fixup_unsigned_type (gfc_logical8_type_node);\n-  PUSH_TYPE (\"logical8\", gfc_logical8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-  gfc_logical16_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (gfc_logical16_type_node) = 128;\n-  fixup_unsigned_type (gfc_logical16_type_node);\n-  PUSH_TYPE (\"logical16\", gfc_logical16_type_node);\n-#endif\n+  for (index = 0; gfc_real_kinds[index].kind != 0; index++)\n+    {\n+      type = gfc_build_real_type (&gfc_real_kinds[index]);\n+      gfc_real_types[index] = type;\n+      snprintf (name_buf, sizeof(name_buf), \"real%d\",\n+\t\tgfc_real_kinds[index].kind);\n+      PUSH_TYPE (name_buf, type);\n+\n+      type = gfc_build_complex_type (type);\n+      gfc_complex_types[index] = type;\n+      snprintf (name_buf, sizeof(name_buf), \"complex%d\",\n+\t\tgfc_real_kinds[index].kind);\n+      PUSH_TYPE (name_buf, type);\n+    }\n \n   gfc_character1_type_node = build_type_variant (signed_char_type_node, 0, 0);\n   PUSH_TYPE (\"char\", gfc_character1_type_node);\n@@ -407,6 +512,7 @@ gfc_init_types (void)\n     PUSH_TYPE (\"c_integer\", integer_type_node);\n   if (!TYPE_NAME (char_type_node))\n     PUSH_TYPE (\"c_char\", char_type_node);\n+\n #undef PUSH_TYPE\n \n   pvoid_type_node = build_pointer_type (void_type_node);\n@@ -419,139 +525,66 @@ gfc_init_types (void)\n      by the number of bits available to store this field in the array\n      descriptor.  */\n \n-  n = TREE_INT_CST_LOW (TYPE_SIZE (gfc_array_index_type))\n-      - GFC_DTYPE_SIZE_SHIFT;\n-\n-  if (n > sizeof (HOST_WIDE_INT) * 8)\n-    {\n-      lo = ~(unsigned HOST_WIDE_INT) 0;\n-      hi = lo >> (sizeof (HOST_WIDE_INT) * 16 - n);\n-    }\n+  n = TYPE_PRECISION (gfc_array_index_type) - GFC_DTYPE_SIZE_SHIFT;\n+  lo = ~ (unsigned HOST_WIDE_INT) 0;\n+  if (n > HOST_BITS_PER_WIDE_INT)\n+    hi = lo >> (2*HOST_BITS_PER_WIDE_INT - n);\n   else\n-    {\n-      hi = 0;\n-      lo = (~(unsigned HOST_WIDE_INT) 0) >> (sizeof (HOST_WIDE_INT) * 8 - n);\n-    }\n+    hi = 0, lo >>= HOST_BITS_PER_WIDE_INT - n;\n   gfc_max_array_element_size\n     = build_int_cst_wide (long_unsigned_type_node, lo, hi);\n \n   size_type_node = gfc_array_index_type;\n-  boolean_type_node = gfc_get_logical_type (gfc_default_logical_kind);\n \n+  boolean_type_node = gfc_get_logical_type (gfc_default_logical_kind);\n   boolean_true_node = build_int_cst (boolean_type_node, 1);\n   boolean_false_node = build_int_cst (boolean_type_node, 0);\n+\n+  /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n+  gfc_strlen_type_node = gfc_get_int_type (4);\n }\n \n-/* Get a type node for an integer kind.  */\n+/* Get the type node for the given type and kind.  */\n \n tree\n gfc_get_int_type (int kind)\n {\n-  switch (kind)\n-    {\n-    case 1:\n-      return (gfc_int1_type_node);\n-    case 2:\n-      return (gfc_int2_type_node);\n-    case 4:\n-      return (gfc_int4_type_node);\n-    case 8:\n-      return (gfc_int8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-    case 16:\n-      return (95 _int16_type_node);\n-#endif\n-    default:\n-      fatal_error (\"integer kind=%d not available\", kind);\n-    }\n+  int index = gfc_validate_kind (BT_INTEGER, kind, false);\n+  return gfc_integer_types[index];\n }\n \n-/* Get a type node for a real kind.  */\n-\n tree\n gfc_get_real_type (int kind)\n {\n-  switch (kind)\n-    {\n-    case 4:\n-      return (gfc_real4_type_node);\n-    case 8:\n-      return (gfc_real8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-    case 16:\n-      return (gfc_real16_type_node);\n-#endif\n-    default:\n-      fatal_error (\"real kind=%d not available\", kind);\n-    }\n+  int index = gfc_validate_kind (BT_REAL, kind, false);\n+  return gfc_real_types[index];\n }\n \n-/* Get a type node for a complex kind.  */\n-\n tree\n gfc_get_complex_type (int kind)\n {\n-\n-  switch (kind)\n-    {\n-    case 4:\n-      return (gfc_complex4_type_node);\n-    case 8:\n-      return (gfc_complex8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-    case 16:\n-      return (gfc_complex16_type_node);\n-#endif\n-    default:\n-      fatal_error (\"complex kind=%d not available\", kind);\n-    }\n+  int index = gfc_validate_kind (BT_COMPLEX, kind, false);\n+  return gfc_complex_types[index];\n }\n \n-/* Get a type node for a logical kind.  */\n-\n tree\n gfc_get_logical_type (int kind)\n {\n-  switch (kind)\n-    {\n-    case 1:\n-      return (gfc_logical1_type_node);\n-    case 2:\n-      return (gfc_logical2_type_node);\n-    case 4:\n-      return (gfc_logical4_type_node);\n-    case 8:\n-      return (gfc_logical8_type_node);\n-#if (GFC_USE_TYPES16 && (HOST_BITS_PER_WIDE_INT >= 64))\n-    case 16:\n-      return (gfc_logical16_type_node);\n-#endif\n-    default:\n-      fatal_error (\"logical kind=%d not available\", kind);\n-    }\n+  int index = gfc_validate_kind (BT_LOGICAL, kind, false);\n+  return gfc_logical_types[index];\n }\n \f\n /* Create a character type with the given kind and length.  */\n \n tree\n gfc_get_character_type_len (int kind, tree len)\n {\n-  tree base;\n-  tree bounds;\n-  tree type;\n-\n-  switch (kind)\n-    {\n-    case 1:\n-      base = gfc_character1_type_node;\n-      break;\n+  tree bounds, type;\n \n-    default:\n-      fatal_error (\"character kind=%d not available\", kind);\n-    }\n+  gfc_validate_kind (BT_CHARACTER, kind, false);\n \n   bounds = build_range_type (gfc_array_index_type, gfc_index_one_node, len);\n-  type = build_array_type (base, bounds);\n+  type = build_array_type (gfc_character1_type_node, bounds);\n   TYPE_STRING_FLAG (type) = 1;\n \n   return type;\n@@ -1534,156 +1567,94 @@ gfc_get_function_type (gfc_symbol * sym)\n   return type;\n }\n \f\n-/* Routines for getting integer type nodes.  */\n-\n+/* Language hooks for middle-end access to type nodes.  */\n \n /* Return an integer type with BITS bits of precision,\n    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n \n tree\n gfc_type_for_size (unsigned bits, int unsignedp)\n {\n-  if (bits == TYPE_PRECISION (integer_type_node))\n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-\n-  if (bits == TYPE_PRECISION (short_integer_type_node))\n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (long_integer_type_node))\n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (long_long_integer_type_node))\n-    return (unsignedp ? long_long_unsigned_type_node\n-\t    : long_long_integer_type_node);\n-/*TODO: We currently don't initialise this...\n-  if (bits == TYPE_PRECISION (widest_integer_literal_type_node))\n-    return (unsignedp ? widest_unsigned_literal_type_node\n-            : widest_integer_literal_type_node);*/\n-\n-  if (bits <= TYPE_PRECISION (intQI_type_node))\n-    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n-\n-  if (bits <= TYPE_PRECISION (intHI_type_node))\n-    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-\n-  if (bits <= TYPE_PRECISION (intSI_type_node))\n-    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-\n-  if (bits <= TYPE_PRECISION (intDI_type_node))\n-    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+  if (!unsignedp)\n+    {\n+      int i;\n+      for (i = 0; i <= MAX_INT_KINDS; ++i)\n+\t{\n+\t  tree type = gfc_integer_types[i];\n+\t  if (type && bits == TYPE_PRECISION (type))\n+\t    return type;\n+\t}\n+    }\n+  else\n+    {\n+      if (bits == TYPE_PRECISION (unsigned_intQI_type_node))\n+        return unsigned_intQI_type_node;\n+      if (bits == TYPE_PRECISION (unsigned_intHI_type_node))\n+\treturn unsigned_intHI_type_node;\n+      if (bits == TYPE_PRECISION (unsigned_intSI_type_node))\n+\treturn unsigned_intSI_type_node;\n+      if (bits == TYPE_PRECISION (unsigned_intDI_type_node))\n+\treturn unsigned_intDI_type_node;\n+      if (bits == TYPE_PRECISION (unsigned_intTI_type_node))\n+\treturn unsigned_intTI_type_node;\n+    }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n-/* Return a data type that has machine mode MODE.\n-   If the mode is an integer,\n-   then UNSIGNEDP selects between signed and unsigned types.  */\n+/* Return a data type that has machine mode MODE.  If the mode is an\n+   integer, then UNSIGNEDP selects between signed and unsigned types.  */\n \n tree\n gfc_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n-  if (mode == TYPE_MODE (integer_type_node))\n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-  if (mode == TYPE_MODE (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-\n-  if (mode == TYPE_MODE (short_integer_type_node))\n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-\n-  if (mode == TYPE_MODE (long_integer_type_node))\n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-  if (mode == TYPE_MODE (long_long_integer_type_node))\n-    return unsignedp ? long_long_unsigned_type_node :\n-      long_long_integer_type_node;\n-\n-/*TODO: see above\n-  if (mode == TYPE_MODE (widest_integer_literal_type_node))\n-    return unsignedp ? widest_unsigned_literal_type_node\n-                     : widest_integer_literal_type_node;\n-*/\n-\n-  if (mode == QImode)\n-    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n-\n-  if (mode == HImode)\n-    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-\n-  if (mode == SImode)\n-    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-\n-  if (mode == DImode)\n-    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  if (mode == TYPE_MODE (intTI_type_node))\n-    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n-#endif\n-\n-  if (mode == TYPE_MODE (float_type_node))\n-    return float_type_node;\n-\n-  if (mode == TYPE_MODE (double_type_node))\n-    return double_type_node;\n-\n-  if (mode == TYPE_MODE (long_double_type_node))\n-    return long_double_type_node;\n-\n-  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n-    return build_pointer_type (char_type_node);\n-\n-  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n-    return build_pointer_type (integer_type_node);\n-\n-  if (VECTOR_MODE_P (mode))\n+  int i;\n+  tree *base;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    base = gfc_real_types;\n+  else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+    base = gfc_complex_types;\n+  else if (SCALAR_INT_MODE_P (mode))\n+    return gfc_type_for_size (GET_MODE_PRECISION (mode), unsignedp);\n+  else if (VECTOR_MODE_P (mode))\n     {\n       enum machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = gfc_type_for_mode (inner_mode, unsignedp);\n       if (inner_type != NULL_TREE)\n         return build_vector_type_for_mode (inner_type, mode);\n+      return NULL_TREE;\n     }\n+  else\n+    abort ();\n \n-  return 0;\n+  for (i = 0; i <= MAX_REAL_KINDS; ++i)\n+    {\n+      tree type = base[i];\n+      if (type && mode == TYPE_MODE (type))\n+\treturn type;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return a type the same as TYPE except unsigned or\n+   signed according to UNSIGNEDP.  */\n+\n+tree\n+gfc_signed_or_unsigned_type (int unsignedp, tree type)\n+{\n+  if (TREE_CODE (type) != INTEGER_TYPE || TYPE_UNSIGNED (type) == unsignedp)\n+    return type;\n+  else\n+    return gfc_type_for_size (TYPE_PRECISION (type), unsignedp);\n }\n \n /* Return an unsigned type the same as TYPE in other respects.  */\n \n tree\n gfc_unsigned_type (tree type)\n {\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-\n-  if (type1 == signed_char_type_node || type1 == char_type_node)\n-    return unsigned_char_type_node;\n-  if (type1 == integer_type_node)\n-    return unsigned_type_node;\n-  if (type1 == short_integer_type_node)\n-    return short_unsigned_type_node;\n-  if (type1 == long_integer_type_node)\n-    return long_unsigned_type_node;\n-  if (type1 == long_long_integer_type_node)\n-    return long_long_unsigned_type_node;\n-/*TODO :see others\n-  if (type1 == widest_integer_literal_type_node)\n-    return widest_unsigned_literal_type_node;\n-*/\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  if (type1 == intTI_type_node)\n-    return unsigned_intTI_type_node;\n-#endif\n-  if (type1 == intDI_type_node)\n-    return unsigned_intDI_type_node;\n-  if (type1 == intSI_type_node)\n-    return unsigned_intSI_type_node;\n-  if (type1 == intHI_type_node)\n-    return unsigned_intHI_type_node;\n-  if (type1 == intQI_type_node)\n-    return unsigned_intQI_type_node;\n-\n   return gfc_signed_or_unsigned_type (1, type);\n }\n \n@@ -1692,77 +1663,7 @@ gfc_unsigned_type (tree type)\n tree\n gfc_signed_type (tree type)\n {\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-\n-  if (type1 == unsigned_char_type_node || type1 == char_type_node)\n-    return signed_char_type_node;\n-  if (type1 == unsigned_type_node)\n-    return integer_type_node;\n-  if (type1 == short_unsigned_type_node)\n-    return short_integer_type_node;\n-  if (type1 == long_unsigned_type_node)\n-    return long_integer_type_node;\n-  if (type1 == long_long_unsigned_type_node)\n-    return long_long_integer_type_node;\n-/*TODO: see others\n-  if (type1 == widest_unsigned_literal_type_node)\n-    return widest_integer_literal_type_node;\n-*/\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  if (type1 == unsigned_intTI_type_node)\n-    return intTI_type_node;\n-#endif\n-  if (type1 == unsigned_intDI_type_node)\n-    return intDI_type_node;\n-  if (type1 == unsigned_intSI_type_node)\n-    return intSI_type_node;\n-  if (type1 == unsigned_intHI_type_node)\n-    return intHI_type_node;\n-  if (type1 == unsigned_intQI_type_node)\n-    return intQI_type_node;\n-\n   return gfc_signed_or_unsigned_type (0, type);\n }\n \n-/* Return a type the same as TYPE except unsigned or\n-   signed according to UNSIGNEDP.  */\n-\n-tree\n-gfc_signed_or_unsigned_type (int unsignedp, tree type)\n-{\n-  if (!INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n-    return type;\n-\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (short_integer_type_node))\n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_integer_type_node))\n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_long_integer_type_node))\n-    return (unsignedp ? long_long_unsigned_type_node\n-\t    : long_long_integer_type_node);\n-/*TODO: see others\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (widest_integer_literal_type_node))\n-    return (unsignedp ? widest_unsigned_literal_type_node\n-            : widest_integer_literal_type_node);\n-*/\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (intTI_type_node))\n-    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n-#endif\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (intDI_type_node))\n-    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (intSI_type_node))\n-    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (intHI_type_node))\n-    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (intQI_type_node))\n-    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n-\n-  return type;\n-}\n-\n #include \"gt-fortran-trans-types.h\""}, {"sha": "0bb131e719f6fcef890769b36cf62201730be4c5", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 49, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cad04b2825ff91d12ebe595c91bbf3cf824fcc/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=e2cad04b2825ff91d12ebe595c91bbf3cf824fcc", "patch": "@@ -24,28 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GFC_BACKEND_H\n #define GFC_BACKEND_H\n \n-enum\n-{\n-  F95_INT1_TYPE,\n-  F95_INT2_TYPE,\n-  F95_INT4_TYPE,\n-  F95_INT8_TYPE,\n-  F95_INT16_TYPE,\n-  F95_REAL4_TYPE,\n-  F95_REAL8_TYPE,\n-  F95_REAl16_TYPE,\n-  F95_COMPLEX4_TYPE,\n-  F95_COMPLEX8_TYPE,\n-  F95_COMPLEX16_TYPE,\n-  F95_LOGICAL1_TYPE,\n-  F95_LOGICAL2_TYPE,\n-  F95_LOGICAL4_TYPE,\n-  F95_LOGICAL8_TYPE,\n-  F95_LOGICAL16_TYPE,\n-  F95_CHARACTER1_TYPE,\n-  NUM_F95_TYPES\n-};\n-\n #define GFC_DTYPE_RANK_MASK 0x07\n #define GFC_DTYPE_TYPE_SHIFT 3\n #define GFC_DTYPE_TYPE_MASK 0x38\n@@ -62,37 +40,12 @@ enum\n   GFC_DTYPE_CHARACTER\n };\n \n-extern GTY(()) tree gfc_type_nodes[NUM_F95_TYPES];\n-\n extern GTY(()) tree gfc_array_index_type;\n+extern GTY(()) tree gfc_character1_type_node;\n extern GTY(()) tree ppvoid_type_node;\n extern GTY(()) tree pvoid_type_node;\n extern GTY(()) tree pchar_type_node;\n-\n-#define gfc_int1_type_node  gfc_type_nodes[F95_INT1_TYPE]\n-#define gfc_int2_type_node  gfc_type_nodes[F95_INT2_TYPE]\n-#define gfc_int4_type_node  gfc_type_nodes[F95_INT4_TYPE]\n-#define gfc_int8_type_node  gfc_type_nodes[F95_INT8_TYPE]\n-#define gfc_int16_type_node gfc_type_nodes[F95_INT16_TYPE]\n-\n-#define gfc_real4_type_node  gfc_type_nodes[F95_REAL4_TYPE]\n-#define gfc_real8_type_node  gfc_type_nodes[F95_REAL8_TYPE]\n-#define gfc_real16_type_node gfc_type_nodes[F95_REAL16_TYPE]\n-\n-#define gfc_complex4_type_node  gfc_type_nodes[F95_COMPLEX4_TYPE]\n-#define gfc_complex8_type_node  gfc_type_nodes[F95_COMPLEX8_TYPE]\n-#define gfc_complex16_type_node gfc_type_nodes[F95_COMPLEX16_TYPE]\n-\n-#define gfc_logical1_type_node  gfc_type_nodes[F95_LOGICAL1_TYPE]\n-#define gfc_logical2_type_node  gfc_type_nodes[F95_LOGICAL2_TYPE]\n-#define gfc_logical4_type_node  gfc_type_nodes[F95_LOGICAL4_TYPE]\n-#define gfc_logical8_type_node  gfc_type_nodes[F95_LOGICAL8_TYPE]\n-#define gfc_logical16_type_node gfc_type_nodes[F95_LOGICAL16_TYPE]\n-\n-#define gfc_character1_type_node gfc_type_nodes[F95_CHARACTER1_TYPE]\n-\n-#define gfc_strlen_kind 4\n-#define gfc_strlen_type_node gfc_int4_type_node\n+extern GTY(()) tree gfc_strlen_type_node;\n \n /* These C-specific types are used while building builtin function decls.\n    For now it doesn't really matter what these are defined to as we don't"}]}