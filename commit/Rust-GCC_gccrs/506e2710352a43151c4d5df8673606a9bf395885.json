{"sha": "506e2710352a43151c4d5df8673606a9bf395885", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2ZTI3MTAzNTJhNDMxNTFjNGQ1ZGY4NjczNjA2YTliZjM5NTg4NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-24T23:12:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-24T23:12:30Z"}, "message": "c-decl.c (c_in_iteration_stmt, [...]): Remove.\n\n\t* c-decl.c (c_in_iteration_stmt, c_in_case_stmt): Remove.\n\t(c_break_label, c_cont_label): New.\n\t(start_function): Update initializations.\n\t(c_push_function_context): Update saves.\n\t(c_pop_function_context): Update restores.\n\t* c-parse.in: Update expected conflicts.\n\t(stmt_count, compstmt_count): Remove.  Remove all updates.\n\t(if_prefix, simple_if, do_stmt_start): Remove.\n\t(lineno_labeled_stmt): Remove.\n\t(lineno_labels): New.\n\t(c99_block_lineno_labeled_stmt): Use it.\n\t(lineno_stmt, lineno_label): Don't clear EXPR_LOCUS before calling\n\tannotate_with_locus.\n\t(select_or_iter_stmt): Replace by ...\n\t(condition, if_statement_1, if_statement_2, if_statement,\n\tstart_break, start_continue, while_statement, do_statement,\n\tfor_cond_expr, for_incr_expr, for_statement, switch_statement): New.\n\t(stmt): Split out ...\n\t(stmt_nocomp): ... this.  Use c_finish_bc_stmt, c_finish_goto_label,\n\tc_finish_goto_ptr.\n\t* c-semantics.c (add_stmt): Don't add line numbers to labels.\n\t* c-tree.h: Update prototypes.\n\t(struct language_function): Remove x_in_iteration_stmt, x_in_case_stmt;\n\tadd x_break_label, x_cont_label, x_switch_stack.\n\t(c_switch_stack): Declare.\n\t* c-typeck.c (c_finish_goto_label, c_finish_goto_ptr): New.\n\t(c_finish_return): Return the statement.\n\t(c_switch_stack): Rename from switch_stack; export.\n\t(if_elt, if_stack, if_stack_space, if_stack_pointer): Remove.\n\t(c_begin_if_stmt, c_finish_if_cond, c_finish_then, c_begin_else,\n\tc_finish_else): Remove.\n\t(c_finish_if_stmt): Rewrite to perform the entire operation.\n\t(c_begin_while_stmt, c_finish_while_stmt_cond, c_finish_while_stmt,\n\tc_begin_for_stmt, c_finish_for_stmt_init, c_finish_for_stmt_cond,\n\tc_finish_for_stmt_incr, c_finish_for_stmt): Remove.\n\t(c_finish_loop): New.\n\t(c_finish_bc_stmt): New.\n\t(c_finish_expr_stmt): Return the statement.  Split out...\n\t(c_process_expr_stmt): ... this.  Don't add locus to error marks.\n\t* gimplify.c (gimplify_cond_expr): Accept NULL type statements.\n\t* tree-gimple.c (is_gimple_stmt): Likewise.\n\t* tree-pretty-print.c (dump_generic_node <COND_EXPR>): Likewise.\n\t(print_struct_decl): Delete empty compound statement.\n\t* objc/objc-act.c (objc_build_throw_stmt): Return the statement.\n\t* objc/objc-act.h: Update decl.\n\nFrom-SVN: r83620", "tree": {"sha": "1fab0ddb0ef43b779ede7dfbfbd2254c84c942e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fab0ddb0ef43b779ede7dfbfbd2254c84c942e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/506e2710352a43151c4d5df8673606a9bf395885", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506e2710352a43151c4d5df8673606a9bf395885", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506e2710352a43151c4d5df8673606a9bf395885", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506e2710352a43151c4d5df8673606a9bf395885/comments", "author": null, "committer": null, "parents": [{"sha": "6e6e49b10f94aaf10b6e9224e07130ab2d818f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6e49b10f94aaf10b6e9224e07130ab2d818f14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6e49b10f94aaf10b6e9224e07130ab2d818f14"}], "stats": {"total": 855, "additions": 450, "deletions": 405}, "files": [{"sha": "16ad75d409a613bb02fed8ccec656f1681abf34d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -1,3 +1,51 @@\n+2004-06-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c (c_in_iteration_stmt, c_in_case_stmt): Remove.\n+\t(c_break_label, c_cont_label): New.\n+\t(start_function): Update initializations.\n+\t(c_push_function_context): Update saves.\n+\t(c_pop_function_context): Update restores.\n+\t* c-parse.in: Update expected conflicts.\n+\t(stmt_count, compstmt_count): Remove.  Remove all updates.\n+\t(if_prefix, simple_if, do_stmt_start): Remove.\n+\t(lineno_labeled_stmt): Remove.\n+\t(lineno_labels): New.\n+\t(c99_block_lineno_labeled_stmt): Use it.\n+\t(lineno_stmt, lineno_label): Don't clear EXPR_LOCUS before calling\n+\tannotate_with_locus.\n+\t(select_or_iter_stmt): Replace by ...\n+\t(condition, if_statement_1, if_statement_2, if_statement,\n+\tstart_break, start_continue, while_statement, do_statement,\n+\tfor_cond_expr, for_incr_expr, for_statement, switch_statement): New.\n+\t(stmt): Split out ...\n+\t(stmt_nocomp): ... this.  Use c_finish_bc_stmt, c_finish_goto_label,\n+\tc_finish_goto_ptr.\n+\t* c-semantics.c (add_stmt): Don't add line numbers to labels.\n+\t* c-tree.h: Update prototypes.\n+\t(struct language_function): Remove x_in_iteration_stmt, x_in_case_stmt;\n+\tadd x_break_label, x_cont_label, x_switch_stack.\n+\t(c_switch_stack): Declare.\n+\t* c-typeck.c (c_finish_goto_label, c_finish_goto_ptr): New.\n+\t(c_finish_return): Return the statement.\n+\t(c_switch_stack): Rename from switch_stack; export.\n+\t(if_elt, if_stack, if_stack_space, if_stack_pointer): Remove.\n+\t(c_begin_if_stmt, c_finish_if_cond, c_finish_then, c_begin_else,\n+\tc_finish_else): Remove.\n+\t(c_finish_if_stmt): Rewrite to perform the entire operation.\n+\t(c_begin_while_stmt, c_finish_while_stmt_cond, c_finish_while_stmt,\n+\tc_begin_for_stmt, c_finish_for_stmt_init, c_finish_for_stmt_cond,\n+\tc_finish_for_stmt_incr, c_finish_for_stmt): Remove.\n+\t(c_finish_loop): New.\n+\t(c_finish_bc_stmt): New.\n+\t(c_finish_expr_stmt): Return the statement.  Split out...\n+\t(c_process_expr_stmt): ... this.  Don't add locus to error marks.\n+\t* gimplify.c (gimplify_cond_expr): Accept NULL type statements.\n+\t* tree-gimple.c (is_gimple_stmt): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node <COND_EXPR>): Likewise.\n+\t(print_struct_decl): Delete empty compound statement.\n+\t* objc/objc-act.c (objc_build_throw_stmt): Return the statement.\n+\t* objc/objc-act.h: Update decl.\n+\n 2004-06-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* tree-pretty-print.c (dump_generic_node, case TYPE_DECL):"}, {"sha": "7aeba0896c265d57215493cc3af0ee0c8c36baaa", "filename": "gcc/c-decl.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -109,8 +109,8 @@ static location_t current_function_prototype_locus;\n static GTY(()) struct stmt_tree_s c_stmt_tree;\n \n /* State saving variables.  */\n-int c_in_iteration_stmt;\n-int c_in_case_stmt;\n+tree c_break_label;\n+tree c_cont_label;\n \n /* Linked list of TRANSLATION_UNIT_DECLS for the translation units\n    included in this invocation.  Note that the current translation\n@@ -5592,8 +5592,12 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   current_function_returns_abnormally = 0;\n   warn_about_return_type = 0;\n   current_extern_inline = 0;\n-  c_in_iteration_stmt = 0;\n-  c_in_case_stmt = 0;\n+  c_switch_stack = NULL;\n+\n+  /* Indicate no valid break/continue context by setting these variables\n+     to some non-null, non-label value.  We'll notice and emit the proper\n+     error message in c_finish_bc_stmt.  */\n+  c_break_label = c_cont_label = size_zero_node;\n \n   /* Don't expand any sizes in the return type of the function.  */\n   immediate_size_expand = 0;\n@@ -6410,8 +6414,9 @@ c_push_function_context (struct function *f)\n   f->language = p;\n \n   p->base.x_stmt_tree = c_stmt_tree;\n-  p->x_in_iteration_stmt = c_in_iteration_stmt;\n-  p->x_in_case_stmt = c_in_case_stmt;\n+  p->x_break_label = c_break_label;\n+  p->x_cont_label = c_cont_label;\n+  p->x_switch_stack = c_switch_stack;\n   p->returns_value = current_function_returns_value;\n   p->returns_null = current_function_returns_null;\n   p->returns_abnormally = current_function_returns_abnormally;\n@@ -6437,8 +6442,9 @@ c_pop_function_context (struct function *f)\n     }\n \n   c_stmt_tree = p->base.x_stmt_tree;\n-  c_in_iteration_stmt = p->x_in_iteration_stmt;\n-  c_in_case_stmt = p->x_in_case_stmt;\n+  c_break_label = p->x_break_label;\n+  c_cont_label = p->x_cont_label;\n+  c_switch_stack = p->x_switch_stack;\n   current_function_returns_value = p->returns_value;\n   current_function_returns_null = p->returns_null;\n   current_function_returns_abnormally = p->returns_abnormally;"}, {"sha": "a96241a3e5cc1fe4de1ea7aaa12c347e01146ca4", "filename": "gcc/c-parse.in", "status": "modified", "additions": 163, "deletions": 172, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -29,7 +29,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    written by AT&T, but I have never seen it.  */\n \n @@ifc\n-%expect 10 /* shift/reduce conflicts, and no reduce/reduce conflicts.  */\n+%expect 13 /* shift/reduce conflicts, and no reduce/reduce conflicts.  */\n @@end_ifc\n \n %{\n@@ -210,9 +210,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> any_word\n \n %type <ttype> compstmt compstmt_start compstmt_primary_start\n-%type <ttype> do_stmt_start stmt label\n+%type <ttype> stmt label stmt_nocomp start_break start_continue\n \n %type <ttype> c99_block_start c99_block_lineno_labeled_stmt\n+%type <ttype> if_statement_1 if_statement_2\n %type <ttype> declarator\n %type <ttype> notype_declarator after_type_declarator\n %type <ttype> parm_declarator\n@@ -227,7 +228,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> struct_head union_head enum_head\n %type <ttype> typename absdcl absdcl1 absdcl1_ea absdcl1_noea\n %type <ttype> direct_absdcl1 absdcl_maybe_attribute\n-%type <ttype> xexpr parms parm firstparm identifiers\n+%type <ttype> condition xexpr for_cond_expr for_incr_expr\n+%type <ttype> parms parm firstparm identifiers\n \n %type <ttype> parmlist parmlist_1 parmlist_2\n %type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n@@ -254,11 +256,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n @@end_ifobjc\n \f\n %{\n-/* Number of statements (loosely speaking) and compound statements\n-   seen so far.  */\n-static int stmt_count;\n-static int compstmt_count;\n-\n /* List of types and structure classes of the current declaration.  */\n static GTY(()) tree current_declspecs;\n static GTY(()) tree prefix_attributes;\n@@ -2032,8 +2029,7 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt_start: '{' { compstmt_count++;\n-                      $$ = c_begin_compound_stmt (true); }\n+compstmt_start: '{' { $$ = c_begin_compound_stmt (true); }\n         ;\n \n compstmt_nostart: '}'\n@@ -2053,7 +2049,6 @@ compstmt_primary_start:\n \t\t\t     \"only inside a function\");\n \t\t      YYERROR;\n \t\t    }\n-\t\t  compstmt_count++;\n \t\t  $$ = c_begin_stmt_expr ();\n \t\t}\n         ;\n@@ -2062,47 +2057,6 @@ compstmt: compstmt_start compstmt_nostart\n \t\t{ $$ = c_end_compound_stmt ($1, true); }\n \t;\n \n-if_prefix:\n-\t  /* We must build the if statement node before parsing its\n-\t     condition so that we get its location pointing to the\n-\t     line containing the \"if\", and not the line containing\n-\t     the close-parenthesis.  */\n-          IF\n-                { c_begin_if_stmt (); }\n-            '(' expr ')'\n-\t\t{ c_finish_if_cond ($4, compstmt_count, ++stmt_count); }\n-        ;\n-\n-simple_if:\n-\t  if_prefix c99_block_lineno_labeled_stmt\n-                { c_finish_then ($2); }\n-\t/* Make sure c_finish_if_stmt is run for each call to\n-\t   c_begin_if_stmt.  Otherwise a crash is likely.  */\n-\t| if_prefix error\n-\t;\n-\n-/* This is a subroutine of stmt.\n-   It is used twice, once for valid DO statements\n-   and once for catching errors in parsing the end test.  */\n-do_stmt_start:\n-\t  DO\n-\t\t{ stmt_count++;\n-\t\t  compstmt_count++;\n-\t\t  c_in_iteration_stmt++;\n-\t\t  $<ttype>$\n-\t\t    = add_stmt (build_stmt (DO_STMT, NULL_TREE,\n-\t\t\t\t\t    NULL_TREE));\n-\t\t  /* In the event that a parse error prevents\n-\t\t     parsing the complete do-statement, set the\n-\t\t     condition now.  Otherwise, we can get crashes at\n-\t\t     RTL-generation time.  */\n-\t\t  DO_COND ($<ttype>$) = error_mark_node; }\n-\t  c99_block_lineno_labeled_stmt WHILE\n-\t\t{ $$ = $<ttype>2;\n-\t\t  DO_BODY ($$) = $3;\n-\t\t  c_in_iteration_stmt--; }\n-\t;\n-\n /* The forced readahead in here is because we might be at the end of a\n    line, and the line and file won't be bumped until yylex absorbs the\n    first token on the next line.  */\n@@ -2113,14 +2067,14 @@ save_location:\n \t\t  $$ = input_location; }\n \t;\n \n-lineno_labeled_stmt:\n-\t  lineno_stmt\n-\t| lineno_label lineno_labeled_stmt\n+lineno_labels:\n+\t  /* empty */\n+\t| lineno_labels lineno_label\n \t;\n \n-/* Like lineno_labeled_stmt, but a block in C99.  */\n+/* A labeled statement.  In C99 it also generates an implicit block.  */\n c99_block_lineno_labeled_stmt:\n-\t  c99_block_start lineno_labeled_stmt\n+\t  c99_block_start lineno_labels lineno_stmt\n                 { $$ = c_end_compound_stmt ($1, flag_isoc99); }\n \t;\n \n@@ -2138,74 +2092,91 @@ lineno_stmt:\n \t\t     because (recursively) all of the component statments\n \t\t     should already have line numbers assigned.  */\n \t\t  if ($2 && EXPR_P ($2))\n-\t\t    {\n-\t\t      SET_EXPR_LOCUS ($2, NULL);\n-\t\t      annotate_with_locus ($2, $1);\n-\t\t    }\n+\t\t    annotate_with_locus ($2, $1);\n \t\t}\n \t;\n \n lineno_label:\n \t  save_location label\n-\t\t{ if ($2)\n-\t\t    {\n-\t\t      SET_EXPR_LOCUS ($2, NULL);\n-\t\t      annotate_with_locus ($2, $1);\n-\t\t    }\n-\t\t}\n+\t\t{ if ($2) annotate_with_locus ($2, $1); }\n \t;\n \n-select_or_iter_stmt:\n-\t  simple_if ELSE\n-\t\t{ c_begin_else (stmt_count); }\n-\t  c99_block_lineno_labeled_stmt\n-                { c_finish_else ($4); c_finish_if_stmt (stmt_count); }\n-\t| simple_if %prec IF\n-\t\t{ c_finish_if_stmt (stmt_count); }\n-\t| simple_if ELSE error\n-\t\t{ c_finish_if_stmt (stmt_count + 1); }\n-       /* We must build the WHILE_STMT node before parsing its\n-\t  condition so that EXPR_LOCUS refers to the line\n-\t  containing the \"while\", and not the line containing\n-\t  the close-parenthesis.\n-\n-\t  c_begin_while_stmt returns the WHILE_STMT node, which\n-\t  we later pass to c_finish_while_stmt_cond to fill\n-\t  in the condition and other tidbits.  */\n-\t| WHILE\n-                { stmt_count++;\n-\t\t  $<ttype>$ = c_begin_while_stmt (); }\n-\t  '(' expr ')'\n-                { c_in_iteration_stmt++;\n-\t\t  c_finish_while_stmt_cond ($4, $<ttype>2); }\n-\t  c99_block_lineno_labeled_stmt\n-                { c_in_iteration_stmt--;\n-\t\t  c_finish_while_stmt ($7, $<ttype>2); }\n-\t| do_stmt_start\n-\t  '(' expr ')' ';'\n-                { DO_COND ($1) = lang_hooks.truthvalue_conversion ($3); }\n-\t| do_stmt_start error\n-\t\t{ }\n-\t| FOR\n-\t\t{ $<ttype>$ = c_begin_for_stmt (); }\n-\t  '(' for_init_stmt\n-\t\t{ stmt_count++;\n-\t\t  c_finish_for_stmt_init ($<ttype>2); }\n-\t  xexpr ';'\n-                { c_finish_for_stmt_cond ($6, $<ttype>2); }\n-\t  xexpr ')'\n-                { c_in_iteration_stmt++;\n-\t\t  c_finish_for_stmt_incr ($9, $<ttype>2); }\n-\t  c99_block_lineno_labeled_stmt\n-                { c_finish_for_stmt ($12, $<ttype>2);\n-\t\t  c_in_iteration_stmt--; }\n-\t| SWITCH '(' expr ')'\n-\t\t{ stmt_count++;\n-\t\t  $<ttype>$ = c_start_case ($3);\n-\t\t  c_in_case_stmt++; }\n-\t  c99_block_lineno_labeled_stmt\n-                { c_finish_case ($6);\n-\t\t  c_in_case_stmt--; }\n+condition: save_location expr\n+\t\t{ $$ = lang_hooks.truthvalue_conversion ($2);\n+\t\t  if (EXPR_P ($$))\n+\t\t    annotate_with_locus ($$, $1); }\n+\t;\n+\n+/* Implement -Wparenthesis by special casing IF statement directly nested\n+   within IF statement.  This requires some amount of duplication of the\n+   productions under c99_block_lineno_labeled_stmt in order to work out.\n+   But it's still likely more maintainable than lots of state outside the\n+   parser...  */\n+\n+if_statement_1:\n+\tc99_block_start lineno_labels if_statement\n+\t\t{ $$ = c_end_compound_stmt ($1, flag_isoc99); }\n+\t;\n+\n+if_statement_2:\n+\t  c99_block_start lineno_labels ';'\n+\t\t{ if (extra_warnings)\n+\t\t    add_stmt (build (NOP_EXPR, NULL_TREE, NULL_TREE));\n+\t\t  $$ = c_end_compound_stmt ($1, flag_isoc99); }\n+\t| c99_block_lineno_labeled_stmt\n+\t;\n+\n+if_statement:\n+\t  IF c99_block_start save_location '(' condition ')'\n+\t    if_statement_1 ELSE if_statement_2\n+\t\t{ c_finish_if_stmt ($3, $5, $7, $9, true);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t| IF c99_block_start save_location '(' condition ')'\n+\t    if_statement_2 ELSE if_statement_2\n+\t\t{ c_finish_if_stmt ($3, $5, $7, $9, false);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t| IF c99_block_start save_location '(' condition ')'\n+\t    if_statement_1\t\t\t\t%prec IF\n+\t\t{ c_finish_if_stmt ($3, $5, $7, NULL, true);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t| IF c99_block_start save_location '(' condition ')'\n+\t    if_statement_2\t\t\t\t%prec IF\n+\t\t{ c_finish_if_stmt ($3, $5, $7, NULL, false);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t;\n+\n+start_break: /* empty */\n+\t\t{ $$ = c_break_label; c_break_label = NULL; }\n+\t;\n+\n+start_continue: /* empty */\n+\t\t{ $$ = c_cont_label; c_cont_label = NULL; }\n+\t;\n+\n+while_statement:\n+\tWHILE c99_block_start save_location '(' condition ')'\n+\tstart_break start_continue c99_block_lineno_labeled_stmt\n+\t\t{ c_finish_loop ($3, $5, NULL, $9, c_break_label,\n+\t\t\t\t c_cont_label, true);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99));\n+\t\t  c_break_label = $7; c_cont_label = $8; }\n+\t;\n+\n+do_statement:\n+\tDO c99_block_start save_location start_break start_continue\n+\tc99_block_lineno_labeled_stmt WHILE\n+\t\t{ $<ttype>$ = c_break_label; c_break_label = $4; }\n+\t\t{ $<ttype>$ = c_cont_label; c_cont_label = $5; }\n+\t'(' condition ')' ';'\n+                { c_finish_loop ($3, $11, NULL, $6, $<ttype>8,\n+\t\t\t\t $<ttype>9, false);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t;\n+\n+xexpr:\n+\t/* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| expr\n \t;\n \n for_init_stmt:\n@@ -2215,64 +2186,82 @@ for_init_stmt:\n \t\t{ check_for_loop_decls (); }\n \t;\n \n-xexpr:\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| expr\n+for_cond_expr: save_location xexpr\n+\t\t{ if ($2)\n+\t\t    {\n+\t\t      $$ = lang_hooks.truthvalue_conversion ($2);\n+\t\t      if (EXPR_P ($$))\n+\t\t\tannotate_with_locus ($$, $1);\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = NULL;\n+\t\t}\n \t;\n \n-/* Parse a single real statement, not including any labels.  */\n-stmt:\n-\t  compstmt\n-\t\t{ stmt_count++; add_stmt ($1); }\n-\t| expr ';'\n-\t\t{ stmt_count++; c_finish_expr_stmt ($1); }\n-\t| c99_block_start select_or_iter_stmt\n-                { add_stmt (c_end_compound_stmt ($1, flag_isoc99)); }\n+for_incr_expr: xexpr\n+\t\t{ $$ = c_process_expr_stmt ($1); }\n+\t;\n+\n+for_statement:\n+\tFOR c99_block_start '(' for_init_stmt\n+\tsave_location for_cond_expr ';' for_incr_expr ')'\n+\tstart_break start_continue c99_block_lineno_labeled_stmt\n+\t\t{ c_finish_loop ($5, $6, $8, $12, c_break_label,\n+\t\t\t\t c_cont_label, true);\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99));\n+\t\t  c_break_label = $10; c_cont_label = $11; }\n+\t;\n+\n+switch_statement:\n+\tSWITCH c99_block_start '(' expr ')'\n+\t\t{ $<ttype>$ = c_start_case ($4); }\n+\tstart_break c99_block_lineno_labeled_stmt\n+                { c_finish_case ($8);\n+\t\t  if (c_break_label)\n+\t\t    add_stmt (build (LABEL_EXPR, void_type_node,\n+\t\t\t\t     c_break_label));\n+\t\t  c_break_label = $7;\n+\t\t  add_stmt (c_end_compound_stmt ($2, flag_isoc99)); }\n+\t;\n+\n+/* Parse a single real statement, not including any labels or compounds.  */\n+stmt_nocomp:\n+\t  expr ';'\n+\t\t{ $$ = c_finish_expr_stmt ($1); }\n+\t| if_statement\n+\t\t{ $$ = NULL_TREE; }\n+\t| while_statement\n+\t\t{ $$ = NULL_TREE; }\n+\t| do_statement\n+\t\t{ $$ = NULL_TREE; }\n+\t| for_statement\n+\t\t{ $$ = NULL_TREE; }\n+\t| switch_statement\n+\t\t{ $$ = NULL_TREE; }\n \t| BREAK ';'\n-\t        { stmt_count++;\n-\t\t  if (!(c_in_iteration_stmt || c_in_case_stmt))\n-\t\t    error (\"break statement not within loop or switch\");\n-\t\t  else\n-\t\t    add_stmt (build_break_stmt ()); }\n+\t        { $$ = c_finish_bc_stmt (&c_break_label, true); }\n \t| CONTINUE ';'\n-                { stmt_count++;\n-\t\t  if (!c_in_iteration_stmt)\n-\t\t    error (\"continue statement not within a loop\");\n-\t\t  else\n-\t\t    add_stmt (build_continue_stmt ()); }\n+                { $$ = c_finish_bc_stmt (&c_cont_label, false); }\n \t| RETURN ';'\n-                { stmt_count++; c_finish_return (NULL_TREE); }\n+                { $$ = c_finish_return (NULL_TREE); }\n \t| RETURN expr ';'\n-                { stmt_count++; c_finish_return ($2); }\n+                { $$ = c_finish_return ($2); }\n \t| asm_stmt\n \t| GOTO identifier ';'\n-\t\t{ tree decl;\n-\t\t  stmt_count++;\n-\t\t  decl = lookup_label ($2);\n-\t\t  if (decl != 0)\n-\t\t    {\n-\t\t      TREE_USED (decl) = 1;\n-\t\t      add_stmt (build_stmt (GOTO_EXPR, decl));\n-\t\t    }\n-\t\t}\n+\t\t{ $$ = c_finish_goto_label ($2); }\n \t| GOTO '*' expr ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n-\t\t  stmt_count++;\n-\t\t  $3 = convert (ptr_type_node, $3);\n-\t\t  add_stmt (build_stmt (GOTO_EXPR, $3)); }\n+\t\t{ $$ = c_finish_goto_ptr ($3); }\n \t| ';'\n-\t\t{ }\n+\t\t{ $$ = NULL_TREE; }\n @@ifobjc\n \t| AT_THROW expr ';'\n-\t\t{ stmt_count++; objc_build_throw_stmt ($2); }\n+\t\t{ $$ = objc_build_throw_stmt ($2); }\n \t| AT_THROW ';'\n-\t\t{ stmt_count++; objc_build_throw_stmt (NULL_TREE); }\n+\t\t{ $$ = objc_build_throw_stmt (NULL_TREE); }\n \t| objc_try_catch_stmt\n-\t\t{ }\n-\t| AT_SYNCHRONIZED '(' expr ')' save_location compstmt\n-\t\t{ stmt_count++; objc_build_synchronized ($5, $3, $6); }\n+\t\t{ $$ = NULL_TREE; }\n+\t| AT_SYNCHRONIZED save_location '(' expr ')' compstmt\n+\t\t{ objc_build_synchronized ($2, $4, $6); $$ = NULL_TREE; }\n \t;\n \n objc_catch_prefix:\n@@ -2294,7 +2283,7 @@ objc_opt_catch_list:\n \n objc_try_catch_clause:\n \tAT_TRY save_location compstmt\n-\t\t{ stmt_count++; objc_begin_try_stmt ($2, $3); }\n+\t\t{ objc_begin_try_stmt ($2, $3); }\n \tobjc_opt_catch_list\n \t;\n \n@@ -2311,22 +2300,25 @@ objc_try_catch_stmt:\n @@end_ifobjc\n \t;\n \n+/* Parse a single or compound real statement, not including any labels.  */\n+stmt:\n+\t  compstmt\n+\t\t{ add_stmt ($1); $$ = NULL_TREE; }\n+\t| stmt_nocomp\n+\t;\n+\n /* Any kind of label, including jump labels and case labels.\n    ANSI C accepts labels only before statements, but we allow them\n    also at the end of a compound statement.  */\n \n label:\t  CASE expr_no_commas ':'\n-                { stmt_count++;\n-\t\t  $$ = do_case ($2, NULL_TREE); }\n+                { $$ = do_case ($2, NULL_TREE); }\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { stmt_count++;\n-\t\t  $$ = do_case ($2, $4); }\n+                { $$ = do_case ($2, $4); }\n \t| DEFAULT ':'\n-                { stmt_count++;\n-\t\t  $$ = do_case (NULL_TREE, NULL_TREE); }\n+                { $$ = do_case (NULL_TREE, NULL_TREE); }\n \t| identifier save_location ':' maybe_attribute\n \t\t{ tree label = define_label ($2, $1);\n-\t\t  stmt_count++;\n \t\t  if (label)\n \t\t    {\n \t\t      decl_attributes (&label, $4, 0);\n@@ -2367,8 +2359,7 @@ asmdef:\n asm_stmt:\n \tASM_KEYWORD maybe_volatile stop_string_translation\n \t        '(' asm_argument ')' start_string_translation ';'\n-\t\t{ stmt_count++;\n-\t\t  $$ = build_asm_stmt ($2, $5); }\n+\t\t{ $$ = build_asm_stmt ($2, $5); }\n \t;\n \n asm_argument:"}, {"sha": "9512947216cfc3482d9c6698fb47c142be3d11ee", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -128,7 +128,9 @@ pop_stmt_list (tree t)\n tree\n add_stmt (tree t)\n {\n-  if (EXPR_P (t) || STATEMENT_CODE_P (TREE_CODE (t)))\n+  enum tree_code code = TREE_CODE (t);\n+\n+  if ((EXPR_P (t) || STATEMENT_CODE_P (code)) && code != LABEL_EXPR)\n     {\n       if (!EXPR_LOCUS (t))\n \tannotate_with_locus (t, input_location);"}, {"sha": "4d99c409f3bca3ecc875d2e8c2e0ec5509deb4dc", "filename": "gcc/c-tree.h", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -126,13 +126,14 @@ struct lang_type GTY(())\n struct language_function GTY(())\n {\n   struct c_language_function base;\n+  tree x_break_label;\n+  tree x_cont_label;\n+  struct c_switch * GTY((skip)) x_switch_stack;\n   int returns_value;\n   int returns_null;\n   int returns_abnormally;\n   int warn_about_return_type;\n   int extern_inline;\n-  int x_in_iteration_stmt;\n-  int x_in_case_stmt;\n };\n \n \f\n@@ -143,8 +144,8 @@ extern void c_parse_init (void);\n extern void gen_aux_info_record (tree, int, int, int);\n \n /* in c-decl.c */\n-extern int c_in_iteration_stmt;\n-extern int c_in_case_stmt;\n+extern tree c_break_label;\n+extern tree c_cont_label;\n \n extern int global_bindings_p (void);\n extern void push_scope (void);\n@@ -212,6 +213,7 @@ extern bool c_warn_unused_global_decl (tree);\n #define c_sizeof_nowarn(T)  c_sizeof_or_alignof_type (T, SIZEOF_EXPR, 0)\n \n /* in c-typeck.c */\n+extern struct c_switch *c_switch_stack;\n \n extern tree require_complete_type (tree);\n extern int same_translation_unit_p (tree, tree);\n@@ -254,24 +256,16 @@ extern tree c_convert_parm_for_inlining (tree, tree, tree, int);\n extern int c_types_compatible_p (tree, tree);\n extern tree c_begin_compound_stmt (bool);\n extern tree c_end_compound_stmt (tree, bool);\n-extern void c_begin_if_stmt (void);\n-extern void c_finish_if_cond (tree, int, int);\n-extern void c_finish_then (tree);\n-extern void c_begin_else (int);\n-extern void c_finish_else (tree);\n-extern void c_finish_if_stmt (int);\n-extern tree c_begin_while_stmt (void);\n-extern void c_finish_while_stmt_cond (tree, tree);\n-extern void c_finish_while_stmt (tree, tree);\n-extern tree c_begin_for_stmt (void);\n-extern void c_finish_for_stmt_init (tree);\n-extern void c_finish_for_stmt_cond (tree, tree);\n-extern void c_finish_for_stmt_incr (tree, tree);\n-extern void c_finish_for_stmt (tree, tree);\n+extern void c_finish_if_stmt (location_t, tree, tree, tree, bool);\n+extern void c_finish_loop (location_t, tree, tree, tree, tree, tree, bool);\n extern tree c_begin_stmt_expr (void);\n extern tree c_finish_stmt_expr (tree);\n-extern void c_finish_expr_stmt (tree);\n-extern void c_finish_return (tree);\n+extern tree c_process_expr_stmt (tree);\n+extern tree c_finish_expr_stmt (tree);\n+extern tree c_finish_return (tree);\n+extern tree c_finish_bc_stmt (tree *, bool);\n+extern tree c_finish_goto_label (tree);\n+extern tree c_finish_goto_ptr (tree);\n extern tree build_offsetof (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if"}, {"sha": "ededd617a23ad49cac95e59ee1edc6fe6c1d91da", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 192, "deletions": 188, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -6249,10 +6249,34 @@ c_expand_asm_operands (tree string, tree outputs, tree inputs,\n   emit_queue ();\n }\n \f\n+/* Generate a goto statement to LABEL.  */\n+\n+tree\n+c_finish_goto_label (tree label)\n+{\n+  tree decl = lookup_label (label);\n+  if (!decl)\n+    return NULL_TREE;\n+\n+  TREE_USED (decl) = 1;\n+  return add_stmt (build (GOTO_EXPR, void_type_node, decl));\n+}\n+\n+/* Generate a computed goto statement to EXPR.  */\n+\n+tree\n+c_finish_goto_ptr (tree expr)\n+{\n+  if (pedantic)\n+    pedwarn (\"ISO C forbids `goto *expr;'\");\n+  expr = convert (ptr_type_node, expr);\n+  return add_stmt (build (GOTO_EXPR, void_type_node, expr));\n+}\n+\n /* Generate a C `return' statement.  RETVAL is the expression for what\n    to return, or a null pointer for `return;' with no value.  */\n \n-void\n+tree\n c_finish_return (tree retval)\n {\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n@@ -6282,7 +6306,7 @@ c_finish_return (tree retval)\n \n       current_function_returns_value = 1;\n       if (t == error_mark_node)\n-\treturn;\n+\treturn NULL_TREE;\n \n       inner = t = convert (TREE_TYPE (res), t);\n \n@@ -6340,7 +6364,7 @@ c_finish_return (tree retval)\n       retval = build (MODIFY_EXPR, TREE_TYPE (res), res, t);\n     }\n \n-  add_stmt (build_stmt (RETURN_EXPR, retval));\n+  return add_stmt (build_stmt (RETURN_EXPR, retval));\n }\n \f\n struct c_switch {\n@@ -6362,7 +6386,7 @@ struct c_switch {\n    during the processing of the body of a function, and we never\n    collect at that point.  */\n \n-static struct c_switch *switch_stack;\n+struct c_switch *c_switch_stack;\n \n /* Start a C switch statement, testing expression EXP.  Return the new\n    SWITCH_STMT.  */\n@@ -6403,10 +6427,10 @@ c_start_case (tree exp)\n   cs = xmalloc (sizeof (*cs));\n   cs->switch_stmt = build_stmt (SWITCH_STMT, exp, NULL_TREE, orig_type);\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n-  cs->next = switch_stack;\n-  switch_stack = cs;\n+  cs->next = c_switch_stack;\n+  c_switch_stack = cs;\n \n-  return add_stmt (switch_stack->switch_stmt);\n+  return add_stmt (cs->switch_stmt);\n }\n \n /* Process a case label.  */\n@@ -6416,10 +6440,10 @@ do_case (tree low_value, tree high_value)\n {\n   tree label = NULL_TREE;\n \n-  if (switch_stack)\n+  if (c_switch_stack)\n     {\n-      label = c_add_case_label (switch_stack->cases,\n-\t\t\t\tSWITCH_COND (switch_stack->switch_stmt),\n+      label = c_add_case_label (c_switch_stack->cases,\n+\t\t\t\tSWITCH_COND (c_switch_stack->switch_stmt),\n \t\t\t\tlow_value, high_value);\n       if (label == error_mark_node)\n \tlabel = NULL_TREE;\n@@ -6437,214 +6461,179 @@ do_case (tree low_value, tree high_value)\n void\n c_finish_case (tree body)\n {\n-  struct c_switch *cs = switch_stack;\n+  struct c_switch *cs = c_switch_stack;\n \n   SWITCH_BODY (cs->switch_stmt) = body;\n \n   /* Emit warnings as needed.  */\n   c_do_switch_warnings (cs->cases, cs->switch_stmt);\n \n   /* Pop the stack.  */\n-  switch_stack = switch_stack->next;\n+  c_switch_stack = cs->next;\n   splay_tree_delete (cs->cases);\n   free (cs);\n }\n \f\n-/* Keep a stack of if statements.  We record the number of compound\n-   statements seen up to the if keyword, as well as the line number\n-   and file of the if.  If a potentially ambiguous else is seen, that\n-   fact is recorded; the warning is issued when we can be sure that\n-   the enclosing if statement does not have an else branch.  */\n-typedef struct\n-{\n-  tree if_stmt;\n-  location_t empty_locus;\n-  int compstmt_count;\n-  int stmt_count;\n-  unsigned int needs_warning : 1;\n-  unsigned int saw_else : 1;\n-} if_elt;\n-\n-static if_elt *if_stack;\n-\n-/* Amount of space in the if statement stack.  */\n-static int if_stack_space = 0;\n-\n-/* Stack pointer.  */\n-static int if_stack_pointer = 0;\n-\n-/* Begin an if-statement.  */\n+/* Emit an if statement.  IF_LOCUS is the location of the 'if'.  COND,\n+   THEN_BLOCK and ELSE_BLOCK are expressions to be used; ELSE_BLOCK\n+   may be null.  NESTED_IF is true if THEN_BLOCK contains another IF\n+   statement, and was not surrounded with parenthesis.  */\n \n void\n-c_begin_if_stmt (void)\n+c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n+\t\t  tree else_block, bool nested_if)\n {\n-  tree r;\n-  if_elt *elt;\n+  tree stmt;\n \n-  /* Make sure there is enough space on the stack.  */\n-  if (if_stack_space == 0)\n+  /* Diagnose an ambiguous else if if-then-else is nested inside if-then.  */\n+  if (warn_parentheses && nested_if && else_block == NULL)\n     {\n-      if_stack_space = 10;\n-      if_stack = xmalloc (10 * sizeof (if_elt));\n-    }\n-  else if (if_stack_space == if_stack_pointer)\n-    {\n-      if_stack_space += 10;\n-      if_stack = xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n-    }\n-\n-  r = add_stmt (build_stmt (COND_EXPR, NULL_TREE, NULL_TREE, NULL_TREE));\n-\n-  /* Record this if statement.  */\n-  elt = &if_stack[if_stack_pointer++];\n-  memset (elt, 0, sizeof (*elt));\n-  elt->if_stmt = r;\n-}\n-\n-/* Record the start of an if-then, and record the start of it\n-   for ambiguous else detection.\n+      tree inner_if = then_block;\n \n-   COND is the condition for the if-then statement.\n-\n-   IF_STMT is the statement node that has already been created for\n-   this if-then statement.  It is created before parsing the\n-   condition to keep line number information accurate.  */\n-\n-void\n-c_finish_if_cond (tree cond, int compstmt_count, int stmt_count)\n-{\n-  if_elt *elt = &if_stack[if_stack_pointer - 1];\n-  elt->compstmt_count = compstmt_count;\n-  elt->stmt_count = stmt_count;\n-  COND_EXPR_COND (elt->if_stmt) = lang_hooks.truthvalue_conversion (cond);\n-}\n-\n-/* Called after the then-clause for an if-statement is processed.  */\n-\n-void\n-c_finish_then (tree then_stmt)\n-{\n-  if_elt *elt = &if_stack[if_stack_pointer - 1];\n-  COND_EXPR_THEN (elt->if_stmt) = then_stmt;\n-  elt->empty_locus = input_location;\n-}\n-\n-/* Called between the then-clause and the else-clause\n-   of an if-then-else.  */\n-\n-void\n-c_begin_else (int stmt_count)\n-{\n-  if_elt *elt = &if_stack[if_stack_pointer - 1];\n-\n-  /* An ambiguous else warning must be generated for the enclosing if\n-     statement, unless we see an else branch for that one, too.  */\n-  if (warn_parentheses\n-      && if_stack_pointer > 1\n-      && (elt[0].compstmt_count == elt[-1].compstmt_count))\n-    elt[-1].needs_warning = 1;\n-\n-  /* Even if a nested if statement had an else branch, it can't be\n-     ambiguous if this one also has an else.  So don't warn in that\n-     case.  Also don't warn for any if statements nested in this else.  */\n-  elt->needs_warning = 0;\n-  elt->compstmt_count--;\n-  elt->saw_else = 1;\n-  elt->stmt_count = stmt_count;\n-}\n-\n-/* Called after the else-clause for an if-statement is processed.  */\n-\n-void\n-c_finish_else (tree else_stmt)\n-{\n-  if_elt *elt = &if_stack[if_stack_pointer - 1];\n-  COND_EXPR_ELSE (elt->if_stmt) = else_stmt;\n-  elt->empty_locus = input_location;\n-}\n-\n-/* Record the end of an if-then.  Optionally warn if a nested\n-   if statement had an ambiguous else clause.  */\n-\n-void\n-c_finish_if_stmt (int stmt_count)\n-{\n-  if_elt *elt = &if_stack[--if_stack_pointer];\n+      /* We know from the grammer productions that there is an IF nested\n+\t within THEN_BLOCK.  Due to labels and c99 conditional declarations,\n+\t it might not be exactly THEN_BLOCK, but should be the last\n+\t non-container statement within.  */\n+      while (1)\n+\tswitch (TREE_CODE (inner_if))\n+\t  {\n+\t  case COND_EXPR:\n+\t    goto found;\n+\t  case BIND_EXPR:\n+\t    inner_if = BIND_EXPR_BODY (inner_if);\n+\t    break;\n+\t  case STATEMENT_LIST:\n+\t    inner_if = expr_last (then_block);\n+\t    break;\n+\t  case TRY_FINALLY_EXPR:\n+\t  case TRY_CATCH_EXPR:\n+\t    inner_if = TREE_OPERAND (inner_if, 0);\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+    found:\n \n-  if (elt->needs_warning)\n-    warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n-\t     EXPR_LOCUS (elt->if_stmt));\n+      if (COND_EXPR_ELSE (inner_if))\n+\t warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n+\t\t  &if_locus);\n+    }\n \n-  if (extra_warnings && stmt_count == elt->stmt_count)\n+  /* Diagnose \";\" via the special empty statement node that we create.  */\n+  if (extra_warnings)\n     {\n-      if (elt->saw_else)\n-\twarning (\"%Hempty body in an else-statement\", &elt->empty_locus);\n-      else\n-\twarning (\"%Hempty body in an if-statement\", &elt->empty_locus);\n+      if (TREE_CODE (then_block) == NOP_EXPR && !TREE_TYPE (then_block))\n+\t{\n+\t  if (!else_block)\n+\t    warning (\"%Hempty body in an if-statement\",\n+\t\t     EXPR_LOCUS (then_block));\n+\t  then_block = alloc_stmt_list ();\n+\t}\n+      if (else_block\n+\t  && TREE_CODE (else_block) == NOP_EXPR\n+\t  && !TREE_TYPE (else_block))\n+\t{\n+\t  warning (\"%Hempty body in an else-statement\",\n+\t\t   EXPR_LOCUS (else_block));\n+\t  else_block = alloc_stmt_list ();\n+\t}\n     }\n-}\n-\f\n-/* Begin a while statement.  Returns a newly created WHILE_STMT if\n-   appropriate.  */\n \n-tree\n-c_begin_while_stmt (void)\n-{\n-  tree r;\n-  r = add_stmt (build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE));\n-  return r;\n+  stmt = build3 (COND_EXPR, NULL_TREE, cond, then_block, else_block);\n+  annotate_with_locus (stmt, if_locus);\n+  add_stmt (stmt);\n }\n \n-void\n-c_finish_while_stmt_cond (tree cond, tree while_stmt)\n-{\n-  WHILE_COND (while_stmt) = (*lang_hooks.truthvalue_conversion) (cond);\n-}\n+/* Emit a general-purpose loop construct.  START_LOCUS is the location of\n+   the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST\n+   is false for DO loops.  INCR is the FOR increment expression.  BODY is\n+   the statement controled by the loop.  BLAB is the break label.  CLAB is\n+   the continue label.  Everything is allowed to be NULL.  */\n \n void\n-c_finish_while_stmt (tree body, tree while_stmt)\n+c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n+\t       tree blab, tree clab, bool cond_is_first)\n {\n-  WHILE_BODY (while_stmt) = body;\n+  tree entry = NULL, exit = NULL, t;\n+\n+  /* Force zeros to NULL so that we don't test them.  */\n+  if (cond && integer_zerop (cond))\n+    cond = NULL;\n+\n+  /* Detect do { ... } while (0) and don't generate loop construct.  */\n+  if (cond_is_first || cond)\n+    {\n+      tree top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+ \n+      /* If we have an exit condition, then we build an IF with gotos either\n+         out of the loop, or to the top of it.  If there's no exit condition,\n+         then we just build a jump back to the top.  */\n+      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n+ \n+      if (cond)\n+        {\n+          /* Canonicalize the loop condition to the end.  This means\n+             generating a branch to the loop condition.  Reuse the\n+             continue label, if possible.  */\n+          if (cond_is_first)\n+            {\n+              if (incr || !clab)\n+                {\n+                  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+                  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+                }\n+              else\n+                t = build1 (GOTO_EXPR, void_type_node, clab);\n+\t      annotate_with_locus (t, start_locus);\n+              add_stmt (t);\n+            }\n+ \n+\t  t = build_and_jump (&blab);\n+          exit = build (COND_EXPR, void_type_node, cond, exit, t);\n+          exit = fold (exit);\n+\t  if (cond_is_first)\n+            annotate_with_locus (exit, start_locus);\n+\t  else\n+            annotate_with_locus (exit, input_location);\n+        }\n+ \n+      add_stmt (top);\n+    }\n+ \n+  if (body)\n+    add_stmt (body);\n+  if (clab)\n+    add_stmt (build1 (LABEL_EXPR, void_type_node, clab));\n+  if (incr)\n+    add_stmt (incr);\n+  if (entry)\n+    add_stmt (entry);\n+  if (exit)\n+    add_stmt (exit);\n+  if (blab)\n+    add_stmt (build1 (LABEL_EXPR, void_type_node, blab));\n }\n-\f\n-/* Create a for statement.  */\n \n tree\n-c_begin_for_stmt (void)\n+c_finish_bc_stmt (tree *label_p, bool is_break)\n {\n-  tree r;\n-  r = add_stmt (build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n-\t\t\t    NULL_TREE, NULL_TREE));\n-  FOR_INIT_STMT (r) = push_stmt_list ();\n-  return r;\n-}\n-\n-void\n-c_finish_for_stmt_init (tree for_stmt)\n-{\n-  FOR_INIT_STMT (for_stmt) = pop_stmt_list (FOR_INIT_STMT (for_stmt));\n-}\n+  tree label = *label_p;\n \n-void\n-c_finish_for_stmt_cond (tree cond, tree for_stmt)\n-{\n-  if (cond)\n-    FOR_COND (for_stmt) = lang_hooks.truthvalue_conversion (cond);\n-}\n+  if (!label)\n+    *label_p = label = create_artificial_label ();\n+  else if (TREE_CODE (label) != LABEL_DECL)\n+    {\n+      if (is_break)\n+\terror (\"break statement not within loop or switch\");\n+      else\n+        error (\"continue statement not within a loop\");\n+      return NULL_TREE;\n+    }\n \n-void\n-c_finish_for_stmt_incr (tree expr, tree for_stmt)\n-{\n-  FOR_EXPR (for_stmt) = expr;\n+  return add_stmt (build (GOTO_EXPR, void_type_node, label));\n }\n \n-void\n-c_finish_for_stmt (tree body, tree for_stmt)\n-{\n-  FOR_BODY (for_stmt) = body;\n-}\n-\f\n-/* A helper routine for c_finish_expr_stmt and c_finish_stmt_expr.  */\n+/* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */\n \n static void\n emit_side_effect_warnings (tree expr)\n@@ -6661,13 +6650,14 @@ emit_side_effect_warnings (tree expr)\n     warn_if_unused_value (expr, input_location);\n }\n \n-/* Emit an expression as a statement.  */\n+/* Process an expression as if it were a complete statement.  Emit\n+   diagnostics, but do not call ADD_STMT.  */\n \n-void\n-c_finish_expr_stmt (tree expr)\n+tree\n+c_process_expr_stmt (tree expr)\n {\n   if (!expr)\n-    return;\n+    return NULL_TREE;\n \n   /* Do default conversion if safe and possibly important,\n      in case within ({...}).  */\n@@ -6696,7 +6686,21 @@ c_finish_expr_stmt (tree expr)\n   if (DECL_P (expr) || TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n     expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n \n-  add_stmt (expr);\n+  if (EXPR_P (expr))\n+    annotate_with_locus (expr, input_location);\n+\n+  return expr;\n+}\n+\n+/* Emit an expression as a statement.  */\n+\n+tree\n+c_finish_expr_stmt (tree expr)\n+{\n+  if (expr)\n+    return add_stmt (c_process_expr_stmt (expr));\n+  else\n+    return NULL;\n }\n \n /* Do the opposite and emit a statement as an expression.  To begin,"}, {"sha": "a050b2080c342c27df2a384c86de5a540c2adb13", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -2511,12 +2511,16 @@ static enum gimplify_status\n gimplify_cond_expr (tree *expr_p, tree *pre_p, tree target)\n {\n   tree expr = *expr_p;\n-  tree tmp;\n+  tree tmp, type;\n   enum gimplify_status ret;\n \n+  type = TREE_TYPE (expr);\n+  if (!type)\n+    TREE_TYPE (expr) = void_type_node;\n+\n   /* If this COND_EXPR has a value, copy the values into a temporary within\n      the arms.  */\n-  if (! VOID_TYPE_P (TREE_TYPE (expr)))\n+  else if (! VOID_TYPE_P (type))\n     {\n       if (target)\n \t{"}, {"sha": "2ecd03000f4239714a59e146bad7c1ab7a8324ec", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -3188,10 +3188,12 @@ objc_finish_try_stmt (void)\n   free (c);\n }\n \n-void\n+tree\n objc_build_throw_stmt (tree throw_expr)\n {\n-  tree func_params;\n+  tree args;\n+\n+  objc_init_exceptions ();\n \n   if (throw_expr == NULL)\n     {\n@@ -3201,7 +3203,7 @@ objc_build_throw_stmt (tree throw_expr)\n           || cur_try_context->current_catch == NULL)\n \t{\n \t  error (\"%<@throw%> (rethrow) used outside of a @catch block\");\n-\t  return;\n+\t  return NULL_TREE;\n \t}\n \n       /* Otherwise the object is still sitting in the EXC_PTR_EXPR\n@@ -3211,10 +3213,8 @@ objc_build_throw_stmt (tree throw_expr)\n \n   /* A throw is just a call to the runtime throw function with the\n      object as a parameter.  */\n-  func_params = tree_cons (NULL, throw_expr, NULL);\n-  add_stmt (build_function_call (objc_exception_throw_decl, func_params));\n-\n-  objc_init_exceptions ();\n+  args = tree_cons (NULL, throw_expr, NULL);\n+  return add_stmt (build_function_call (objc_exception_throw_decl, args));\n }\n \n void"}, {"sha": "2472bfe711fc4106b4a296bc75b137e0f84ddaa1", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -39,7 +39,7 @@ void finish_method_def (void);\n tree start_protocol (enum tree_code, tree, tree);\n void finish_protocol (tree);\n \n-void objc_build_throw_stmt (tree);\n+tree objc_build_throw_stmt (tree);\n void objc_begin_try_stmt (location_t, tree);\n void objc_begin_catch_clause (tree);\n void objc_finish_catch_clause (void);"}, {"sha": "f90e9acc488f4ccaeab8d13df0166b349a4759be", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -348,7 +348,7 @@ is_gimple_stmt (tree t)\n     case BIND_EXPR:\n     case COND_EXPR:\n       /* These are only valid if they're void.  */\n-      return VOID_TYPE_P (TREE_TYPE (t));\n+      return TREE_TYPE (t) == NULL || VOID_TYPE_P (TREE_TYPE (t));\n \n     case SWITCH_EXPR:\n     case GOTO_EXPR:"}, {"sha": "5fe5a4f677a0af575877f748dccffbb6c5b29c88", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506e2710352a43151c4d5df8673606a9bf395885/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=506e2710352a43151c4d5df8673606a9bf395885", "patch": "@@ -767,7 +767,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case COND_EXPR:\n-      if (TREE_TYPE (node) == void_type_node)\n+      if (TREE_TYPE (node) == NULL || TREE_TYPE (node) == void_type_node)\n \t{\n \t  pp_string (buffer, \"if (\");\n \t  dump_generic_node (buffer, COND_EXPR_COND (node), spc, flags, false);\n@@ -1543,10 +1543,6 @@ print_struct_decl (pretty_printer *buffer, tree node, int spc, int flags)\n \t    print_declaration (buffer, tmp, spc+2, flags);\n \t    pp_newline (buffer);\n \t  }\n-\telse\n-\t  {\n-\n-\t  }\n \ttmp = TREE_CHAIN (tmp);\n       }\n   }"}]}