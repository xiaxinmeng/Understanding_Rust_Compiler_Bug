{"sha": "4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVjM2I4ZDYyYjFiNmFlNzlkNTViNzFiNDIzZGNiMDQxMjk4ODRjNg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-15T14:18:49Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:31Z"}, "message": "Added more expr cfg stripping\n\nFixed compile errors\n\nFixed compile errors relating to block expr visibility changes", "tree": {"sha": "e3b1d7ff3ac504d718c66af7b881d6757c9f8314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3b1d7ff3ac504d718c66af7b881d6757c9f8314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25de39b1f0e307b0ff6de485d9ac5648e9295f3d"}], "stats": {"total": 465, "additions": 409, "deletions": 56}, "files": [{"sha": "5aa2905aa0291fbc84fd9d014860cd40eea3d3cd", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "patch": "@@ -615,7 +615,7 @@ void\n TypeResolution::visit (AST::BlockExpr &expr)\n {\n   scope.Push ();\n-  for (auto &stmt : expr.statements)\n+  for (auto &stmt : expr.get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -792,7 +792,7 @@ TypeResolution::visit (AST::Function &function)\n     }\n \n   // walk the expression body\n-  for (auto &stmt : function.get_definition ()->statements)\n+  for (auto &stmt : function.get_definition ()->get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }"}, {"sha": "66ffe164b22a2ad09fab19436ba8ca974ae44c93", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "patch": "@@ -2565,7 +2565,6 @@ class ClosureExprInner : public ClosureExpr\n // A block AST node\n class BlockExpr : public ExprWithBlock\n {\n-public:\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_statements;\n@@ -2575,13 +2574,14 @@ class BlockExpr : public ExprWithBlock\n \n   Location locus;\n \n+public:\n   std::string as_string () const override;\n \n   // Returns whether the block contains statements.\n   bool has_statements () const { return !statements.empty (); }\n \n-  // Returns whether the block contains an expression\n-  bool has_expr () const { return expr != nullptr; }\n+  // Returns whether the block contains a final expression.\n+  bool has_tail_expr () const { return expr != nullptr; }\n \n   BlockExpr (std::vector<std::unique_ptr<Stmt> > block_statements,\n \t     std::unique_ptr<ExprWithoutBlock> block_expr,\n@@ -2651,6 +2651,22 @@ class BlockExpr : public ExprWithBlock\n   }\n   bool is_marked_for_strip () const override { return expr == nullptr && statements.empty (); }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n+  const std::vector<std::unique_ptr<Stmt> > &get_statements () const { return statements; }\n+  std::vector<std::unique_ptr<Stmt> > &get_statements () { return statements; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithoutBlock> &get_tail_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  // Removes the tail expression from the block.\n+  void strip_tail_expr () { expr = nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2729,10 +2745,17 @@ class ClosureExprInnerTyped : public ClosureExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  /* Invalid if inner expr is null, so base stripping on that. Technically, type should also not be null. */\n+  /* Invalid if inner expr is null, so base stripping on that. Technically, \n+   * type should also not be null. */\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition_block () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2858,6 +2881,12 @@ class BreakExpr : public ExprWithoutBlock\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_break_expr () {\n+    rust_assert (break_expr != nullptr);\n+    return break_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2938,6 +2967,18 @@ class RangeFromToExpr : public RangeExpr\n   void mark_for_strip () override { from = nullptr; to = nullptr; }\n   bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_from_expr () {\n+    rust_assert (from != nullptr);\n+    return from;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_to_expr () {\n+    rust_assert (to != nullptr);\n+    return to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2993,6 +3034,12 @@ class RangeFromExpr : public RangeExpr\n   void mark_for_strip () override { from = nullptr; }\n   bool is_marked_for_strip () const override { return from == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_from_expr () {\n+    rust_assert (from != nullptr);\n+    return from;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3049,6 +3096,12 @@ class RangeToExpr : public RangeExpr\n   void mark_for_strip () override { to = nullptr; }\n   bool is_marked_for_strip () const override { return to == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_to_expr () {\n+    rust_assert (to != nullptr);\n+    return to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3142,6 +3195,18 @@ class RangeFromToInclExpr : public RangeExpr\n   void mark_for_strip () override { from = nullptr; to = nullptr; }\n   bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_from_expr () {\n+    rust_assert (from != nullptr);\n+    return from;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_to_expr () {\n+    rust_assert (to != nullptr);\n+    return to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3198,6 +3263,12 @@ class RangeToInclExpr : public RangeExpr\n   void mark_for_strip () override { to = nullptr; }\n   bool is_marked_for_strip () const override { return to == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_to_expr () {\n+    rust_assert (to != nullptr);\n+    return to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "17d9cde6dfe1f32cb2919a37e6fd19b8f348dd15", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "patch": "@@ -701,7 +701,7 @@ Compilation::visit (AST::BlockExpr &expr)\n \t\t      start_location, end_location);\n \n   scope.PushBlock (code_block);\n-  for (auto &stmt : expr.statements)\n+  for (auto &stmt : expr.get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -1039,10 +1039,10 @@ Compilation::visit (AST::Function &function)\n   Bblock *enclosingScope = NULL;\n   Location start_location = function.get_locus ();\n   Location end_location;\n-  if (function.get_definition ()->statements.size () > 0)\n+  if (function.get_definition ()->get_statements ().size () > 0)\n     {\n       end_location\n-\t= function.get_definition ()->statements.back ()->get_locus_slow ();\n+\t= function.get_definition ()->get_statements ().back ()->get_locus_slow ();\n     }\n \n   auto code_block = backend->block (fndecl, enclosingScope, vars,\n@@ -1063,7 +1063,7 @@ Compilation::visit (AST::Function &function)\n   scope.PushCurrentFunction (function.get_function_name (), fndecl, returnType,\n \t\t\t     retDecl);\n \n-  for (auto &stmt : function.get_definition ()->statements)\n+  for (auto &stmt : function.get_definition ()->get_statements ())\n     stmt->accept_vis (*this);\n \n   scope.PopBlock ();"}, {"sha": "417f51b2e51e2db7b7448aca4d32f1f6426f983c", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 328, "deletions": 46, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "patch": "@@ -2,6 +2,7 @@\n #include \"rust-ast-full.h\"\n // is full really required?\n #include \"rust-ast-visitor.h\"\n+#include \"rust-diagnostics.h\"\n \n namespace Rust {\n     // Visitor used to expand attributes.\n@@ -139,7 +140,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_borrowed_expr()->accept_vis(*this);\n+            auto& borrowed_expr = expr.get_borrowed_expr();\n+            borrowed_expr->accept_vis(*this);\n+            if (borrowed_expr->is_marked_for_strip()) \n+                rust_error_at(borrowed_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::DereferenceExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -152,7 +157,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_dereferenced_expr()->accept_vis(*this);\n+            auto& dereferenced_expr = expr.get_dereferenced_expr();\n+            dereferenced_expr->accept_vis(*this);\n+            if (dereferenced_expr->is_marked_for_strip()) \n+                rust_error_at(dereferenced_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ErrorPropagationExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -165,7 +174,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_propagating_expr()->accept_vis(*this);\n+            auto& propagating_expr = expr.get_propagating_expr();\n+            propagating_expr->accept_vis(*this);\n+            if (propagating_expr->is_marked_for_strip()) \n+                rust_error_at(propagating_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::NegationExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -178,7 +191,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_negated_expr()->accept_vis(*this);\n+            auto& negated_expr = expr.get_negated_expr();\n+            negated_expr->accept_vis(*this);\n+            if (negated_expr->is_marked_for_strip()) \n+                rust_error_at(negated_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ArithmeticOrLogicalExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -192,8 +209,12 @@ namespace Rust {\n             expr.get_right_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n-            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+            if (expr.get_left_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_left_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before binary op exprs\");\n+            if (expr.get_right_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_right_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ComparisonExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -207,8 +228,12 @@ namespace Rust {\n             expr.get_right_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n-            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+            if (expr.get_left_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_left_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before binary op exprs\");\n+            if (expr.get_right_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_right_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::LazyBooleanExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -222,19 +247,25 @@ namespace Rust {\n             expr.get_right_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n-            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+            if (expr.get_left_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_left_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before binary op exprs\");\n+            if (expr.get_right_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_right_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::TypeCastExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n-             * two direct descendant expressions, can strip ones below that */\n+             * direct descendant expression, can strip ones below that */\n \n             /* should have no possibility for outer attrs as would be parsed \n              * with outer expr */\n             expr.get_casted_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_casted_expr()->is_marked_for_strip());\n+            if (expr.get_casted_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_casted_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before cast exprs\");\n         }\n         void visit(AST::AssignmentExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -248,8 +279,12 @@ namespace Rust {\n             expr.get_right_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n-            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+            if (expr.get_left_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_left_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before binary op exprs\");\n+            if (expr.get_right_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_right_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::CompoundAssignmentExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -263,8 +298,12 @@ namespace Rust {\n             expr.get_right_expr()->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n-            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+            if (expr.get_left_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_left_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before binary op exprs\");\n+            if (expr.get_right_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_right_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::GroupedExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -285,7 +324,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_expr_in_parens()->accept_vis(*this);\n+            auto& inner_expr = expr.get_expr_in_parens();\n+            inner_expr->accept_vis(*this);\n+            if (inner_expr->is_marked_for_strip()) \n+                rust_error_at(inner_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ArrayElemsValues& elems) override {\n             /* apparently outer attributes are allowed in \"elements of array \n@@ -310,8 +353,17 @@ namespace Rust {\n              * such, not implementing. TODO clear up the ambiguity here */\n \n             // only intend stripping for internal sub-expressions\n-            elems.get_elem_to_copy()->accept_vis(*this);\n-            elems.get_num_copies()->accept_vis(*this);\n+            auto& copied_expr = elems.get_elem_to_copy();\n+            copied_expr->accept_vis(*this);\n+            if (copied_expr->is_marked_for_strip()) \n+                rust_error_at(copied_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            auto& copy_count = elems.get_num_copies();\n+            copy_count->accept_vis(*this);\n+            if (copy_count->is_marked_for_strip()) \n+                rust_error_at(copy_count->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ArrayExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -336,14 +388,29 @@ namespace Rust {\n         }\n         void visit(AST::ArrayIndexExpr& expr) override {\n             /* it is unclear whether outer attributes are supposed to be \n-             * allowed, but conceptually it wouldn't make much sense, so \n-             * assuming no. TODO */\n+             * allowed, but conceptually it wouldn't make much sense, but \n+             * having expansion code anyway. TODO */\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n \n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            expr.get_array_expr()->accept_vis(*this);\n-            expr.get_index_expr()->accept_vis(*this);\n+            auto& array_expr = expr.get_array_expr();\n+            array_expr->accept_vis(*this);\n+            if (array_expr->is_marked_for_strip()) \n+                rust_error_at(array_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            auto& index_expr = expr.get_index_expr();\n+            index_expr->accept_vis(*this);\n+            if (index_expr->is_marked_for_strip()) \n+                rust_error_at(index_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::TupleExpr& expr) override {\n             /* according to spec, outer attributes are allowed on \"elements of \n@@ -390,7 +457,11 @@ namespace Rust {\n             /* wouldn't strip this directly (as outer attrs should be \n              * associated with this level), but any sub-expressions would be \n              * stripped. Thus, no need to erase when strip check called. */\n-            expr.get_tuple_expr()->accept_vis(*this);\n+            auto& tuple_expr = expr.get_tuple_expr();\n+            tuple_expr->accept_vis(*this);\n+            if (tuple_expr->is_marked_for_strip()) \n+                rust_error_at(tuple_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::StructExprStruct& expr) override {\n             // initial strip test based on outer attrs\n@@ -414,12 +485,20 @@ namespace Rust {\n         void visit(AST::StructExprFieldIdentifierValue& field) override {\n             /* as no attrs possible (at moment, at least), only sub-expression\n              * stripping is possible */\n-            field.get_value()->accept_vis(*this);\n+            auto& value = field.get_value();\n+            value->accept_vis(*this);\n+            if (value->is_marked_for_strip()) \n+                rust_error_at(value->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::StructExprFieldIndexValue& field) override {\n             /* as no attrs possible (at moment, at least), only sub-expression\n              * stripping is possible */\n-            field.get_value()->accept_vis(*this);\n+            auto& value = field.get_value();\n+            value->accept_vis(*this);\n+            if (value->is_marked_for_strip()) \n+                rust_error_at(value->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::StructExprStructFields& expr) override {\n             // initial strip test based on outer attrs\n@@ -448,8 +527,13 @@ namespace Rust {\n \n             /* struct base presumably can't be stripped, as the '..' is before\n              * the expression. as such, can only strip sub-expressions. */\n-            if (expr.has_struct_base())\n-                expr.get_struct_base().get_base_struct()->accept_vis(*this);\n+            if (expr.has_struct_base()) {\n+                auto& base_struct_expr = expr.get_struct_base().get_base_struct();\n+                base_struct_expr->accept_vis(*this);\n+                if (base_struct_expr->is_marked_for_strip()) \n+                    rust_error_at(base_struct_expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+            }\n         }\n         void visit(AST::StructExprStructBase& expr) override {\n             // initial strip test based on outer attrs\n@@ -470,7 +554,11 @@ namespace Rust {\n             /* struct base presumably can't be stripped, as the '..' is before\n              * the expression. as such, can only strip sub-expressions. */\n             rust_assert(!expr.get_struct_base().is_invalid());\n-            expr.get_struct_base().get_base_struct()->accept_vis(*this);\n+            auto& base_struct_expr = expr.get_struct_base().get_base_struct();\n+            base_struct_expr->accept_vis(*this);\n+            if (base_struct_expr->is_marked_for_strip()) \n+                rust_error_at(base_struct_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::StructExprTuple& expr) override {\n             // initial strip test based on outer attrs\n@@ -517,12 +605,20 @@ namespace Rust {\n         void visit(AST::EnumExprFieldIdentifierValue& field) override {\n             /* as no attrs possible (at moment, at least), only sub-expression\n              * stripping is possible */\n-            field.get_value()->accept_vis(*this);\n+            auto& value = field.get_value();\n+            value->accept_vis(*this);\n+            if (value->is_marked_for_strip()) \n+                rust_error_at(value->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::EnumExprFieldIndexValue& field) override {\n             /* as no attrs possible (at moment, at least), only sub-expression\n              * stripping is possible */\n-            field.get_value()->accept_vis(*this);\n+            auto& value = field.get_value();\n+            value->accept_vis(*this);\n+            if (value->is_marked_for_strip()) \n+                rust_error_at(value->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::EnumExprStruct& expr) override {\n             // initial strip test based on outer attrs\n@@ -582,7 +678,11 @@ namespace Rust {\n             /* should not be outer attrs on \"function\" expression - outer attrs \n              * should be associated with call expr as a whole. only sub-expr \n              * expansion is possible. */\n-            expr.get_function_expr()->accept_vis(*this);\n+            auto& function = expr.get_function_expr();\n+            function->accept_vis(*this);\n+            if (function->is_marked_for_strip()) \n+                rust_error_at(function->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n \n             /* spec says outer attributes are specifically allowed for elements \n              * of call expressions, so full stripping possible */\n@@ -610,7 +710,11 @@ namespace Rust {\n             /* should not be outer attrs on \"receiver\" expression - outer attrs \n              * should be associated with call expr as a whole. only sub-expr \n              * expansion is possible. */\n-            expr.get_receiver_expr()->accept_vis(*this);\n+            auto& receiver = expr.get_receiver_expr();\n+            receiver->accept_vis(*this);\n+            if (receiver->is_marked_for_strip()) \n+                rust_error_at(receiver->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n \n             // no outer attrs on paths possible\n \n@@ -638,9 +742,13 @@ namespace Rust {\n             }\n \n             /* should not be outer attrs on \"receiver\" expression - outer attrs \n-             * should be associated with call expr as a whole. only sub-expr \n+             * should be associated with field expr as a whole. only sub-expr \n              * expansion is possible. */\n-            expr.get_receiver_expr()->accept_vis(*this);\n+            auto& receiver = expr.get_receiver_expr();\n+            receiver->accept_vis(*this);\n+            if (receiver->is_marked_for_strip()) \n+                rust_error_at(receiver->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ClosureExprInner& expr) override {\n             // initial strip test based on outer attrs\n@@ -661,19 +769,193 @@ namespace Rust {\n                 else\n                     i++;\n             }\n+\n+            // can't strip expression itself, but can strip sub-expressions\n+            auto& definition_expr = expr.get_definition_expr();\n+            definition_expr->accept_vis(*this);\n+            if (definition_expr->is_marked_for_strip()) \n+                rust_error_at(definition_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::BlockExpr& expr) override {\n-            \n-        }\n-        void visit(AST::ClosureExprInnerTyped& expr) override {}\n-        void visit(AST::ContinueExpr& expr) override {}\n-        void visit(AST::BreakExpr& expr) override {}\n-        void visit(AST::RangeFromToExpr& expr) override {}\n-        void visit(AST::RangeFromExpr& expr) override {}\n-        void visit(AST::RangeToExpr& expr) override {}\n-        void visit(AST::RangeFullExpr& expr) override {}\n-        void visit(AST::RangeFromToInclExpr& expr) override {}\n-        void visit(AST::RangeToInclExpr& expr) override {}\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says there are inner \n+             * attributes, not just outer attributes of inner stmts */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip all statements\n+            auto& stmts = expr.get_statements();\n+            for (int i = 0; i < stmts.size();) {\n+                auto& stmt = stmts[i];\n+\n+                // mark for stripping if required\n+                stmt->accept_vis(*this);\n+\n+                if (stmt->is_marked_for_strip())\n+                    stmts.erase(stmts.begin() + i);\n+                else\n+                    i++;\n+            }\n+\n+            // strip tail expression if exists - can actually fully remove it\n+            if (expr.has_tail_expr()) {\n+                auto& tail_expr = expr.get_tail_expr();\n+\n+                tail_expr->accept_vis(*this);\n+\n+                if (tail_expr->is_marked_for_strip())\n+                    expr.strip_tail_expr();\n+            }\n+        }\n+        void visit(AST::ClosureExprInnerTyped& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip closure parameters if required - this is specifically\n+             * allowed by spec */\n+            auto& params = expr.get_params();\n+            for (int i = 0; i < params.size();) {\n+                auto& param_attrs = params[i].get_outer_attrs();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg(param_attrs))\n+                    params.erase(params.begin() + i);\n+                else\n+                    i++;\n+            }\n+\n+            // can't strip expression itself, but can strip sub-expressions\n+            auto& definition_block = expr.get_definition_block();\n+            definition_block->accept_vis(*this);\n+            if (definition_block->is_marked_for_strip()) \n+                rust_error_at(definition_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::ContinueExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::BreakExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* spec does not say that you can have outer attributes on \n+             * expression, so assuming you can't. stripping for sub-expressions\n+             * is the only thing that can be done */\n+            if (expr.has_break_expr()) {\n+                auto& break_expr = expr.get_break_expr();\n+\n+                break_expr->accept_vis(*this);\n+\n+                if (break_expr->is_marked_for_strip()) \n+                    rust_error_at(break_expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+            }\n+        }\n+        void visit(AST::RangeFromToExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_from_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_to_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            if (expr.get_from_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_from_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before range exprs\");\n+            if (expr.get_to_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_to_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::RangeFromExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * direct descendant expression, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            auto& from_expr = expr.get_from_expr();\n+\n+            from_expr->accept_vis(*this);\n+\n+            if (from_expr->is_marked_for_strip())\n+                rust_error_at(from_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before range exprs\");\n+        }\n+        void visit(AST::RangeToExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * direct descendant expression, can strip ones below that */\n+\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            auto& to_expr = expr.get_to_expr();\n+\n+            to_expr->accept_vis(*this);\n+\n+            if (to_expr->is_marked_for_strip())\n+                rust_error_at(to_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::RangeFullExpr& expr) override {\n+            // outer attributes never allowed before these, so no stripping \n+        }\n+        void visit(AST::RangeFromToInclExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_from_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_to_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            if (expr.get_from_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_from_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes are never allowed before range exprs\");\n+            if (expr.get_to_expr()->is_marked_for_strip())\n+                rust_error_at(expr.get_to_expr()->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::RangeToInclExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * direct descendant expression, can strip ones below that */\n+\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            auto& to_expr = expr.get_to_expr();\n+\n+            to_expr->accept_vis(*this);\n+\n+            if (to_expr->is_marked_for_strip())\n+                rust_error_at(to_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+        }\n         void visit(AST::ReturnExpr& expr) override {}\n         void visit(AST::UnsafeBlockExpr& expr) override {}\n         void visit(AST::LoopExpr& expr) override {}"}]}