{"sha": "2f5f7a08c81a77bb421bd1d8f7003128ae55a928", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1ZjdhMDhjODFhNzdiYjQyMWJkMWQ4ZjcwMDMxMjhhZTU1YTkyOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:39Z"}, "message": "Initial revision\n\nFrom-SVN: r26254", "tree": {"sha": "71ffa6a4df9a0561173146fd544c23298b39b5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71ffa6a4df9a0561173146fd544c23298b39b5d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f5f7a08c81a77bb421bd1d8f7003128ae55a928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5f7a08c81a77bb421bd1d8f7003128ae55a928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f5f7a08c81a77bb421bd1d8f7003128ae55a928", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5f7a08c81a77bb421bd1d8f7003128ae55a928/comments", "author": null, "committer": null, "parents": [{"sha": "18a4bc4eabb5ca133152afc8a152497e3b273a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a4bc4eabb5ca133152afc8a152497e3b273a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a4bc4eabb5ca133152afc8a152497e3b273a91"}], "stats": {"total": 809, "additions": 809, "deletions": 0}, "files": [{"sha": "4c76af81968ba0fc2c9a6973033aa2401e06ecce", "filename": "boehm-gc/misc.c", "status": "added", "additions": 809, "deletions": 0, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5f7a08c81a77bb421bd1d8f7003128ae55a928/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5f7a08c81a77bb421bd1d8f7003128ae55a928/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=2f5f7a08c81a77bb421bd1d8f7003128ae55a928", "patch": "@@ -0,0 +1,809 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, July 31, 1995 5:02 pm PDT */\n+\n+\n+#include <stdio.h>\n+#include <signal.h>\n+\n+#define I_HIDE_POINTERS\t/* To make GC_call_with_alloc_lock visible */\n+#include \"gc_priv.h\"\n+\n+#ifdef SOLARIS_THREADS\n+# include <sys/syscall.h>\n+#endif\n+#ifdef MSWIN32\n+# include <windows.h>\n+#endif\n+\n+# ifdef THREADS\n+#   ifdef PCR\n+#     include \"il/PCR_IL.h\"\n+      PCR_Th_ML GC_allocate_ml;\n+#   else\n+#     ifdef SRC_M3\n+\t/* Critical section counter is defined in the M3 runtime \t*/\n+\t/* That's all we use.\t\t\t\t\t\t*/\n+#     else\n+#\tifdef SOLARIS_THREADS\n+\t  mutex_t GC_allocate_ml;\t/* Implicitly initialized.\t*/\n+#\telse\n+#          ifdef WIN32_THREADS\n+\t      GC_API CRITICAL_SECTION GC_allocate_ml;\n+#          else\n+#             if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#\t\tifdef UNDEFINED\n+\t\t    pthread_mutex_t GC_allocate_ml = PTHREAD_MUTEX_INITIALIZER;\n+#\t\tendif\n+\t        pthread_t GC_lock_holder = NO_THREAD;\n+#\t      else\n+\t        --> declare allocator lock here\n+#\t      endif\n+#\t   endif\n+#\tendif\n+#     endif\n+#   endif\n+# endif\n+\n+GC_FAR struct _GC_arrays GC_arrays /* = { 0 } */;\n+\n+\n+GC_bool GC_debugging_started = FALSE;\n+\t/* defined here so we don't have to load debug_malloc.o */\n+\n+void (*GC_check_heap)() = (void (*)())0;\n+\n+void (*GC_start_call_back)() = (void (*)())0;\n+\n+ptr_t GC_stackbottom = 0;\n+\n+GC_bool GC_dont_gc = 0;\n+\n+GC_bool GC_quiet = 0;\n+\n+/*ARGSUSED*/\n+GC_PTR GC_default_oom_fn GC_PROTO((size_t bytes_requested))\n+{\n+    return(0);\n+}\n+\n+GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested)) = GC_default_oom_fn;\n+\n+extern signed_word GC_mem_found;\n+\n+# ifdef MERGE_SIZES\n+    /* Set things up so that GC_size_map[i] >= words(i),\t\t*/\n+    /* but not too much bigger\t\t\t\t\t\t*/\n+    /* and so that size_map contains relatively few distinct entries \t*/\n+    /* This is stolen from Russ Atkinson's Cedar quantization\t\t*/\n+    /* alogrithm (but we precompute it).\t\t\t\t*/\n+\n+\n+    void GC_init_size_map()\n+    {\n+\tregister unsigned i;\n+\n+\t/* Map size 0 to 1.  This avoids problems at lower levels. */\n+\t  GC_size_map[0] = 1;\n+\t/* One word objects don't have to be 2 word aligned.\t   */\n+\t  for (i = 1; i < sizeof(word); i++) {\n+\t      GC_size_map[i] = 1;\n+\t  }\n+\t  GC_size_map[sizeof(word)] = ROUNDED_UP_WORDS(sizeof(word));\n+\tfor (i = sizeof(word) + 1; i <= 8 * sizeof(word); i++) {\n+#           ifdef ALIGN_DOUBLE\n+\t      GC_size_map[i] = (ROUNDED_UP_WORDS(i) + 1) & (~1);\n+#           else\n+\t      GC_size_map[i] = ROUNDED_UP_WORDS(i);\n+#           endif\n+\t}\n+\tfor (i = 8*sizeof(word) + 1; i <= 16 * sizeof(word); i++) {\n+\t      GC_size_map[i] = (ROUNDED_UP_WORDS(i) + 1) & (~1);\n+\t}\n+\t/* We leave the rest of the array to be filled in on demand. */\n+    }\n+    \n+    /* Fill in additional entries in GC_size_map, including the ith one */\n+    /* We assume the ith entry is currently 0.\t\t\t\t*/\n+    /* Note that a filled in section of the array ending at n always    */\n+    /* has length at least n/4.\t\t\t\t\t\t*/\n+    void GC_extend_size_map(i)\n+    word i;\n+    {\n+        word orig_word_sz = ROUNDED_UP_WORDS(i);\n+        word word_sz = orig_word_sz;\n+    \tregister word byte_sz = WORDS_TO_BYTES(word_sz);\n+    \t\t\t\t/* The size we try to preserve.\t\t*/\n+    \t\t\t\t/* Close to to i, unless this would\t*/\n+    \t\t\t\t/* introduce too many distinct sizes.\t*/\n+    \tword smaller_than_i = byte_sz - (byte_sz >> 3);\n+    \tword much_smaller_than_i = byte_sz - (byte_sz >> 2);\n+    \tregister word low_limit;\t/* The lowest indexed entry we \t*/\n+    \t\t\t\t\t/* initialize.\t\t\t*/\n+    \tregister word j;\n+    \t\n+    \tif (GC_size_map[smaller_than_i] == 0) {\n+    \t    low_limit = much_smaller_than_i;\n+    \t    while (GC_size_map[low_limit] != 0) low_limit++;\n+    \t} else {\n+    \t    low_limit = smaller_than_i + 1;\n+    \t    while (GC_size_map[low_limit] != 0) low_limit++;\n+    \t    word_sz = ROUNDED_UP_WORDS(low_limit);\n+    \t    word_sz += word_sz >> 3;\n+    \t    if (word_sz < orig_word_sz) word_sz = orig_word_sz;\n+    \t}\n+#\tifdef ALIGN_DOUBLE\n+\t    word_sz += 1;\n+\t    word_sz &= ~1;\n+#\tendif\n+\tif (word_sz > MAXOBJSZ) {\n+\t    word_sz = MAXOBJSZ;\n+\t}\n+\t/* If we can fit the same number of larger objects in a block,\t*/\n+\t/* do so.\t\t\t\t\t\t\t*/ \n+\t{\n+\t    size_t number_of_objs = BODY_SZ/word_sz;\n+\t    word_sz = BODY_SZ/number_of_objs;\n+#\t    ifdef ALIGN_DOUBLE\n+\t\tword_sz &= ~1;\n+#\t    endif\n+\t}\n+    \tbyte_sz = WORDS_TO_BYTES(word_sz);\n+#\tifdef ADD_BYTE_AT_END\n+\t    /* We need one extra byte; don't fill in GC_size_map[byte_sz] */\n+\t    byte_sz--;\n+#\tendif\n+\n+    \tfor (j = low_limit; j <= byte_sz; j++) GC_size_map[j] = word_sz;  \n+    }\n+# endif\n+\n+\n+/*\n+ * The following is a gross hack to deal with a problem that can occur\n+ * on machines that are sloppy about stack frame sizes, notably SPARC.\n+ * Bogus pointers may be written to the stack and not cleared for\n+ * a LONG time, because they always fall into holes in stack frames\n+ * that are not written.  We partially address this by clearing\n+ * sections of the stack whenever we get control.\n+ */\n+word GC_stack_last_cleared = 0;\t/* GC_no when we last did this */\n+# ifdef THREADS\n+#   define CLEAR_SIZE 2048\n+# else\n+#   define CLEAR_SIZE 213\n+# endif\n+# define DEGRADE_RATE 50\n+\n+word GC_min_sp;\t\t/* Coolest stack pointer value from which we've */\n+\t\t\t/* already cleared the stack.\t\t\t*/\n+\t\t\t\n+# ifdef STACK_GROWS_DOWN\n+#   define COOLER_THAN >\n+#   define HOTTER_THAN <\n+#   define MAKE_COOLER(x,y) if ((word)(x)+(y) > (word)(x)) {(x) += (y);} \\\n+\t\t\t    else {(x) = (word)ONES;}\n+#   define MAKE_HOTTER(x,y) (x) -= (y)\n+# else\n+#   define COOLER_THAN <\n+#   define HOTTER_THAN >\n+#   define MAKE_COOLER(x,y) if ((word)(x)-(y) < (word)(x)) {(x) -= (y);} else {(x) = 0;}\n+#   define MAKE_HOTTER(x,y) (x) += (y)\n+# endif\n+\n+word GC_high_water;\n+\t\t\t/* \"hottest\" stack pointer value we have seen\t*/\n+\t\t\t/* recently.  Degrades over time.\t\t*/\n+\n+word GC_words_allocd_at_reset;\n+\n+#if defined(ASM_CLEAR_CODE) && !defined(THREADS)\n+  extern ptr_t GC_clear_stack_inner();\n+#endif  \n+\n+#if !defined(ASM_CLEAR_CODE) && !defined(THREADS)\n+/* Clear the stack up to about limit.  Return arg. */\n+/*ARGSUSED*/\n+ptr_t GC_clear_stack_inner(arg, limit)\n+ptr_t arg;\n+word limit;\n+{\n+    word dummy[CLEAR_SIZE];\n+    \n+    BZERO(dummy, CLEAR_SIZE*sizeof(word));\n+    if ((word)(dummy) COOLER_THAN limit) {\n+        (void) GC_clear_stack_inner(arg, limit);\n+    }\n+    /* Make sure the recursive call is not a tail call, and the bzero\t*/\n+    /* call is not recognized as dead code.\t\t\t\t*/\n+    GC_noop1((word)dummy);\n+    return(arg);\n+}\n+#endif\n+\n+/* Clear some of the inaccessible part of the stack.  Returns its\t*/\n+/* argument, so it can be used in a tail call position, hence clearing  */\n+/* another frame.\t\t\t\t\t\t\t*/\n+ptr_t GC_clear_stack(arg)\n+ptr_t arg;\n+{\n+    register word sp = (word)GC_approx_sp();  /* Hotter than actual sp */\n+#   ifdef THREADS\n+        word dummy[CLEAR_SIZE];\n+#   else\n+    \tregister word limit;\n+#   endif\n+    \n+#   define SLOP 400\n+\t/* Extra bytes we clear every time.  This clears our own\t*/\n+\t/* activation record, and should cause more frequent\t\t*/\n+\t/* clearing near the cold end of the stack, a good thing.\t*/\n+#   define GC_SLOP 4000\n+\t/* We make GC_high_water this much hotter than we really saw   \t*/\n+\t/* saw it, to cover for GC noise etc. above our current frame.\t*/\n+#   define CLEAR_THRESHOLD 100000\n+\t/* We restart the clearing process after this many bytes of\t*/\n+\t/* allocation.  Otherwise very heavily recursive programs\t*/\n+\t/* with sparse stacks may result in heaps that grow almost\t*/\n+\t/* without bounds.  As the heap gets larger, collection \t*/\n+\t/* frequency decreases, thus clearing frequency would decrease, */\n+\t/* thus more junk remains accessible, thus the heap gets\t*/\n+\t/* larger ...\t\t\t\t\t\t\t*/\n+# ifdef THREADS\n+    BZERO(dummy, CLEAR_SIZE*sizeof(word));\n+# else\n+    if (GC_gc_no > GC_stack_last_cleared) {\n+        /* Start things over, so we clear the entire stack again */\n+        if (GC_stack_last_cleared == 0) GC_high_water = (word) GC_stackbottom;\n+        GC_min_sp = GC_high_water;\n+        GC_stack_last_cleared = GC_gc_no;\n+        GC_words_allocd_at_reset = GC_words_allocd;\n+    }\n+    /* Adjust GC_high_water */\n+        MAKE_COOLER(GC_high_water, WORDS_TO_BYTES(DEGRADE_RATE) + GC_SLOP);\n+        if (sp HOTTER_THAN GC_high_water) {\n+            GC_high_water = sp;\n+        }\n+        MAKE_HOTTER(GC_high_water, GC_SLOP);\n+    limit = GC_min_sp;\n+    MAKE_HOTTER(limit, SLOP);\n+    if (sp COOLER_THAN limit) {\n+        limit &= ~0xf;\t/* Make it sufficiently aligned for assembly\t*/\n+        \t\t/* implementations of GC_clear_stack_inner.\t*/\n+        GC_min_sp = sp;\n+        return(GC_clear_stack_inner(arg, limit));\n+    } else if (WORDS_TO_BYTES(GC_words_allocd - GC_words_allocd_at_reset)\n+    \t       > CLEAR_THRESHOLD) {\n+    \t/* Restart clearing process, but limit how much clearing we do. */\n+    \tGC_min_sp = sp;\n+    \tMAKE_HOTTER(GC_min_sp, CLEAR_THRESHOLD/4);\n+    \tif (GC_min_sp HOTTER_THAN GC_high_water) GC_min_sp = GC_high_water;\n+    \tGC_words_allocd_at_reset = GC_words_allocd;\n+    }  \n+# endif\n+  return(arg);\n+}\n+\n+\n+/* Return a pointer to the base address of p, given a pointer to a\t*/\n+/* an address within an object.  Return 0 o.w.\t\t\t\t*/\n+# ifdef __STDC__\n+    GC_PTR GC_base(GC_PTR p)\n+# else\n+    GC_PTR GC_base(p)\n+    GC_PTR p;\n+# endif\n+{\n+    register word r;\n+    register struct hblk *h;\n+    register bottom_index *bi;\n+    register hdr *candidate_hdr;\n+    register word limit;\n+    \n+    r = (word)p;\n+    if (!GC_is_initialized) return 0;\n+    h = HBLKPTR(r);\n+    GET_BI(r, bi);\n+    candidate_hdr = HDR_FROM_BI(bi, r);\n+    if (candidate_hdr == 0) return(0);\n+    /* If it's a pointer to the middle of a large object, move it\t*/\n+    /* to the beginning.\t\t\t\t\t\t*/\n+\twhile (IS_FORWARDING_ADDR_OR_NIL(candidate_hdr)) {\n+\t   h = FORWARDED_ADDR(h,candidate_hdr);\n+\t   r = (word)h + HDR_BYTES;\n+\t   candidate_hdr = HDR(h);\n+\t}\n+    if (candidate_hdr -> hb_map == GC_invalid_map) return(0);\n+    /* Make sure r points to the beginning of the object */\n+\tr &= ~(WORDS_TO_BYTES(1) - 1);\n+        {\n+\t    register int offset = (char *)r - (char *)(HBLKPTR(r));\n+\t    register signed_word sz = candidate_hdr -> hb_sz;\n+\t    \n+#\t    ifdef ALL_INTERIOR_POINTERS\n+\t      register map_entry_type map_entry;\n+\t      \n+\t      map_entry = MAP_ENTRY((candidate_hdr -> hb_map), offset);\n+\t      if (map_entry == OBJ_INVALID) {\n+            \treturn(0);\n+              }\n+              r -= WORDS_TO_BYTES(map_entry);\n+              limit = r + WORDS_TO_BYTES(sz);\n+#\t    else\n+\t      register int correction;\n+\t      \n+\t      offset = BYTES_TO_WORDS(offset - HDR_BYTES);\n+\t      correction = offset % sz;\n+\t      r -= (WORDS_TO_BYTES(correction));\n+\t      limit = r + WORDS_TO_BYTES(sz);\n+\t      if (limit > (word)(h + 1)\n+\t        && sz <= BYTES_TO_WORDS(HBLKSIZE) - HDR_WORDS) {\n+\t        return(0);\n+\t      }\n+#\t    endif\n+\t    if ((word)p >= limit) return(0);\n+\t}\n+    return((GC_PTR)r);\n+}\n+\n+\n+/* Return the size of an object, given a pointer to its base.\t\t*/\n+/* (For small obects this also happens to work from interior pointers,\t*/\n+/* but that shouldn't be relied upon.)\t\t\t\t\t*/\n+# ifdef __STDC__\n+    size_t GC_size(GC_PTR p)\n+# else\n+    size_t GC_size(p)\n+    GC_PTR p;\n+# endif\n+{\n+    register int sz;\n+    register hdr * hhdr = HDR(p);\n+    \n+    sz = WORDS_TO_BYTES(hhdr -> hb_sz);\n+    if (sz < 0) {\n+        return(-sz);\n+    } else {\n+        return(sz);\n+    }\n+}\n+\n+size_t GC_get_heap_size GC_PROTO(())\n+{\n+    return ((size_t) GC_heapsize);\n+}\n+\n+size_t GC_get_bytes_since_gc GC_PROTO(())\n+{\n+    return ((size_t) WORDS_TO_BYTES(GC_words_allocd));\n+}\n+\n+GC_bool GC_is_initialized = FALSE;\n+\n+void GC_init()\n+{\n+    DCL_LOCK_STATE;\n+    \n+    DISABLE_SIGNALS();\n+    LOCK();\n+    GC_init_inner();\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+\n+}\n+\n+#ifdef MSWIN32\n+    extern void GC_init_win32();\n+#endif\n+\n+extern void GC_setpagesize();\n+\n+void GC_init_inner()\n+{\n+#   ifndef THREADS\n+        word dummy;\n+#   endif\n+    \n+    if (GC_is_initialized) return;\n+    GC_setpagesize();\n+    GC_exclude_static_roots(beginGC_arrays, endGC_arrays);\n+#   ifdef MSWIN32\n+ \tGC_init_win32();\n+#   endif\n+#   if defined(LINUX) && defined(POWERPC)\n+\tGC_init_linuxppc();\n+#   endif\n+#   ifdef SOLARIS_THREADS\n+\tGC_thr_init();\n+\t/* We need dirty bits in order to find live stack sections.\t*/\n+        GC_dirty_init();\n+#   endif\n+#   if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+\tGC_thr_init();\n+#   endif\n+#   if !defined(THREADS) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n+       || defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+      if (GC_stackbottom == 0) {\n+\tGC_stackbottom = GC_get_stack_base();\n+      }\n+#   endif\n+    if  (sizeof (ptr_t) != sizeof(word)) {\n+        ABORT(\"sizeof (ptr_t) != sizeof(word)\\n\");\n+    }\n+    if  (sizeof (signed_word) != sizeof(word)) {\n+        ABORT(\"sizeof (signed_word) != sizeof(word)\\n\");\n+    }\n+    if  (sizeof (struct hblk) != HBLKSIZE) {\n+        ABORT(\"sizeof (struct hblk) != HBLKSIZE\\n\");\n+    }\n+#   ifndef THREADS\n+#     if defined(STACK_GROWS_UP) && defined(STACK_GROWS_DOWN)\n+  \tABORT(\n+  \t  \"Only one of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd\\n\");\n+#     endif\n+#     if !defined(STACK_GROWS_UP) && !defined(STACK_GROWS_DOWN)\n+  \tABORT(\n+  \t  \"One of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd\\n\");\n+#     endif\n+#     ifdef STACK_GROWS_DOWN\n+        if ((word)(&dummy) > (word)GC_stackbottom) {\n+          GC_err_printf0(\n+          \t\"STACK_GROWS_DOWN is defd, but stack appears to grow up\\n\");\n+#\t  ifndef UTS4  /* Compiler bug workaround */\n+            GC_err_printf2(\"sp = 0x%lx, GC_stackbottom = 0x%lx\\n\",\n+          \t   \t   (unsigned long) (&dummy),\n+          \t   \t   (unsigned long) GC_stackbottom);\n+#\t  endif\n+          ABORT(\"stack direction 3\\n\");\n+        }\n+#     else\n+        if ((word)(&dummy) < (word)GC_stackbottom) {\n+          GC_err_printf0(\n+          \t\"STACK_GROWS_UP is defd, but stack appears to grow down\\n\");\n+          GC_err_printf2(\"sp = 0x%lx, GC_stackbottom = 0x%lx\\n\",\n+          \t       \t (unsigned long) (&dummy),\n+          \t     \t (unsigned long) GC_stackbottom);\n+          ABORT(\"stack direction 4\");\n+        }\n+#     endif\n+#   endif\n+#   if !defined(_AUX_SOURCE) || defined(__GNUC__)\n+      if ((word)(-1) < (word)0) {\n+    \tGC_err_printf0(\"The type word should be an unsigned integer type\\n\");\n+    \tGC_err_printf0(\"It appears to be signed\\n\");\n+    \tABORT(\"word\");\n+      }\n+#   endif\n+    if ((signed_word)(-1) >= (signed_word)0) {\n+    \tGC_err_printf0(\n+    \t\t\"The type signed_word should be a signed integer type\\n\");\n+    \tGC_err_printf0(\"It appears to be unsigned\\n\");\n+    \tABORT(\"signed_word\");\n+    }\n+    \n+    /* Add initial guess of root sets.  Do this first, since sbrk(0)\t*/\n+    /* might be used.\t\t\t\t\t\t\t*/\n+      GC_register_data_segments();\n+    GC_init_headers();\n+    GC_bl_init();\n+    GC_mark_init();\n+    if (!GC_expand_hp_inner((word)MINHINCR)) {\n+        GC_err_printf0(\"Can't start up: not enough memory\\n\");\n+        EXIT();\n+    }\n+    /* Preallocate large object map.  It's otherwise inconvenient to \t*/\n+    /* deal with failure.\t\t\t\t\t\t*/\n+      if (!GC_add_map_entry((word)0)) {\n+        GC_err_printf0(\"Can't start up: not enough memory\\n\");\n+        EXIT();\n+      }\n+    GC_register_displacement_inner(0L);\n+#   ifdef MERGE_SIZES\n+      GC_init_size_map();\n+#   endif\n+#   ifdef PCR\n+      if (PCR_IL_Lock(PCR_Bool_false, PCR_allSigsBlocked, PCR_waitForever)\n+          != PCR_ERes_okay) {\n+          ABORT(\"Can't lock load state\\n\");\n+      } else if (PCR_IL_Unlock() != PCR_ERes_okay) {\n+          ABORT(\"Can't unlock load state\\n\");\n+      }\n+      PCR_IL_Unlock();\n+      GC_pcr_install();\n+#   endif\n+    /* Get black list set up */\n+      GC_gcollect_inner();\n+#   ifdef STUBBORN_ALLOC\n+    \tGC_stubborn_init();\n+#   endif\n+    GC_is_initialized = TRUE;\n+    /* Convince lint that some things are used */\n+#   ifdef LINT\n+      {\n+          extern char * GC_copyright[];\n+          extern int GC_read();\n+          extern void GC_register_finalizer_no_order();\n+          \n+          GC_noop(GC_copyright, GC_find_header,\n+                  GC_push_one, GC_call_with_alloc_lock, GC_read,\n+                  GC_dont_expand,\n+#\t\t  ifndef NO_DEBUGGING\n+\t\t    GC_dump,\n+#\t\t  endif\n+                  GC_register_finalizer_no_order);\n+      }\n+#   endif\n+}\n+\n+void GC_enable_incremental GC_PROTO(())\n+{\n+    DCL_LOCK_STATE;\n+    \n+# ifndef FIND_LEAK\n+    DISABLE_SIGNALS();\n+    LOCK();\n+    if (GC_incremental) goto out;\n+    GC_setpagesize();\n+#   ifdef MSWIN32\n+      {\n+        extern GC_bool GC_is_win32s();\n+\n+\t/* VirtualProtect is not functional under win32s.\t*/\n+\tif (GC_is_win32s()) goto out;\n+      }\n+#   endif /* MSWIN32 */\n+#   ifndef SOLARIS_THREADS\n+        GC_dirty_init();\n+#   endif\n+    if (!GC_is_initialized) {\n+        GC_init_inner();\n+    }\n+    if (GC_dont_gc) {\n+        /* Can't easily do it. */\n+        UNLOCK();\n+    \tENABLE_SIGNALS();\n+    \treturn;\n+    }\n+    if (GC_words_allocd > 0) {\n+    \t/* There may be unmarked reachable objects\t*/\n+    \tGC_gcollect_inner();\n+    }   /* else we're OK in assuming everything's\t*/\n+    \t/* clean since nothing can point to an\t  \t*/\n+    \t/* unmarked object.\t\t\t  \t*/\n+    GC_read_dirty();\n+    GC_incremental = TRUE;\n+out:\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+# endif\n+}\n+\n+\n+#ifdef MSWIN32\n+# define LOG_FILE \"gc.log\"\n+\n+  HANDLE GC_stdout = 0, GC_stderr;\n+  int GC_tmp;\n+  DWORD GC_junk;\n+\n+  void GC_set_files()\n+  {\n+    if (!GC_stdout) {\n+        GC_stdout = CreateFile(LOG_FILE, GENERIC_WRITE,\n+        \t\t       FILE_SHARE_READ | FILE_SHARE_WRITE,\n+        \t\t       NULL, CREATE_ALWAYS, FILE_FLAG_WRITE_THROUGH,\n+        \t\t       NULL); \n+    \tif (INVALID_HANDLE_VALUE == GC_stdout) ABORT(\"Open of log file failed\");\n+    }\n+    if (GC_stderr == 0) {\n+\tGC_stderr = GC_stdout;\n+    }\n+  }\n+\n+#endif\n+\n+#if defined(OS2) || defined(MACOS)\n+FILE * GC_stdout = NULL;\n+FILE * GC_stderr = NULL;\n+int GC_tmp;  /* Should really be local ... */\n+\n+  void GC_set_files()\n+  {\n+      if (GC_stdout == NULL) {\n+\tGC_stdout = stdout;\n+    }\n+    if (GC_stderr == NULL) {\n+\tGC_stderr = stderr;\n+    }\n+  }\n+#endif\n+\n+#if !defined(OS2) && !defined(MACOS) && !defined(MSWIN32)\n+  int GC_stdout = 1;\n+  int GC_stderr = 2;\n+# if !defined(AMIGA)\n+#   include <unistd.h>\n+# endif\n+#endif\n+\n+#if !defined(MSWIN32)  && !defined(OS2) && !defined(MACOS)\n+int GC_write(fd, buf, len)\n+int fd;\n+char *buf;\n+size_t len;\n+{\n+     register int bytes_written = 0;\n+     register int result;\n+     \n+     while (bytes_written < len) {\n+#\tifdef SOLARIS_THREADS\n+\t    result = syscall(SYS_write, fd, buf + bytes_written,\n+\t    \t\t\t  \t    len - bytes_written);\n+#\telse\n+     \t    result = write(fd, buf + bytes_written, len - bytes_written);\n+#\tendif\n+\tif (-1 == result) return(result);\n+\tbytes_written += result;\n+    }\n+    return(bytes_written);\n+}\n+#endif /* UN*X */\n+\n+#ifdef MSWIN32\n+#   define WRITE(f, buf, len) (GC_set_files(), \\\n+\t\t\t       GC_tmp = WriteFile((f), (buf), \\\n+\t\t\t       \t\t\t  (len), &GC_junk, NULL),\\\n+\t\t\t       (GC_tmp? 1 : -1))\n+#else\n+#   if defined(OS2) || defined(MACOS)\n+#   define WRITE(f, buf, len) (GC_set_files(), \\\n+\t\t\t       GC_tmp = fwrite((buf), 1, (len), (f)), \\\n+\t\t\t       fflush(f), GC_tmp)\n+#   else\n+#     define WRITE(f, buf, len) GC_write((f), (buf), (len))\n+#   endif\n+#endif\n+\n+/* A version of printf that is unlikely to call malloc, and is thus safer */\n+/* to call from the collector in case malloc has been bound to GC_malloc. */\n+/* Assumes that no more than 1023 characters are written at once.\t  */\n+/* Assumes that all arguments have been converted to something of the\t  */\n+/* same size as long, and that the format conversions expect something\t  */\n+/* of that size.\t\t\t\t\t\t\t  */\n+void GC_printf(format, a, b, c, d, e, f)\n+char * format;\n+long a, b, c, d, e, f;\n+{\n+    char buf[1025];\n+    \n+    if (GC_quiet) return;\n+    buf[1024] = 0x15;\n+    (void) sprintf(buf, format, a, b, c, d, e, f);\n+    if (buf[1024] != 0x15) ABORT(\"GC_printf clobbered stack\");\n+    if (WRITE(GC_stdout, buf, strlen(buf)) < 0) ABORT(\"write to stdout failed\");\n+}\n+\n+void GC_err_printf(format, a, b, c, d, e, f)\n+char * format;\n+long a, b, c, d, e, f;\n+{\n+    char buf[1025];\n+    \n+    buf[1024] = 0x15;\n+    (void) sprintf(buf, format, a, b, c, d, e, f);\n+    if (buf[1024] != 0x15) ABORT(\"GC_err_printf clobbered stack\");\n+    if (WRITE(GC_stderr, buf, strlen(buf)) < 0) ABORT(\"write to stderr failed\");\n+}\n+\n+void GC_err_puts(s)\n+char *s;\n+{\n+    if (WRITE(GC_stderr, s, strlen(s)) < 0) ABORT(\"write to stderr failed\");\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_default_warn_proc(char *msg, GC_word arg)\n+# else\n+    void GC_default_warn_proc(msg, arg)\n+    char *msg;\n+    GC_word arg;\n+# endif\n+{\n+    GC_err_printf1(msg, (unsigned long)arg);\n+}\n+\n+GC_warn_proc GC_current_warn_proc = GC_default_warn_proc;\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    GC_warn_proc GC_set_warn_proc(GC_warn_proc p)\n+# else\n+    GC_warn_proc GC_set_warn_proc(p)\n+    GC_warn_proc p;\n+# endif\n+{\n+    GC_warn_proc result;\n+\n+    LOCK();\n+    result = GC_current_warn_proc;\n+    GC_current_warn_proc = p;\n+    UNLOCK();\n+    return(result);\n+}\n+\n+\n+#ifndef PCR\n+void GC_abort(msg)\n+char * msg;\n+{\n+    GC_err_printf1(\"%s\\n\", msg);\n+    (void) abort();\n+}\n+#endif\n+\n+#ifdef NEED_CALLINFO\n+\n+void GC_print_callers (info)\n+struct callinfo info[NFRAMES];\n+{\n+    register int i,j;\n+    \n+#   if NFRAMES == 1\n+      GC_err_printf0(\"\\tCaller at allocation:\\n\");\n+#   else\n+      GC_err_printf0(\"\\tCall chain at allocation:\\n\");\n+#   endif\n+    for (i = 0; i < NFRAMES; i++) {\n+     \tif (info[i].ci_pc == 0) break;\n+#\tif NARGS > 0\n+     \t  GC_err_printf0(\"\\t\\targs: \");\n+     \t  for (j = 0; j < NARGS; j++) {\n+     \t    if (j != 0) GC_err_printf0(\", \");\n+     \t    GC_err_printf2(\"%d (0x%X)\", ~(info[i].ci_arg[j]),\n+     \t    \t\t\t\t~(info[i].ci_arg[j]));\n+     \t  }\n+\t  GC_err_printf0(\"\\n\");\n+# \tendif\n+     \tGC_err_printf1(\"\\t\\t##PC##= 0x%X\\n\", info[i].ci_pc);\n+    }\n+}\n+\n+#endif /* SAVE_CALL_CHAIN */\n+\n+# ifdef SRC_M3\n+void GC_enable()\n+{\n+    GC_dont_gc--;\n+}\n+\n+void GC_disable()\n+{\n+    GC_dont_gc++;\n+}\n+# endif\n+\n+#if !defined(NO_DEBUGGING)\n+\n+void GC_dump()\n+{\n+    GC_printf0(\"***Static roots:\\n\");\n+    GC_print_static_roots();\n+    GC_printf0(\"\\n***Heap sections:\\n\");\n+    GC_print_heap_sects();\n+    GC_printf0(\"\\n***Free blocks:\\n\");\n+    GC_print_hblkfreelist();\n+    GC_printf0(\"\\n***Blocks in use:\\n\");\n+    GC_print_block_list();\n+}\n+\n+# endif /* NO_DEBUGGING */"}]}