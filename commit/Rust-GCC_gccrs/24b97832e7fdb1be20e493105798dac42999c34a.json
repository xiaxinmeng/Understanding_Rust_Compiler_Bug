{"sha": "24b97832e7fdb1be20e493105798dac42999c34a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiOTc4MzJlN2ZkYjFiZTIwZTQ5MzEwNTc5OGRhYzQyOTk5YzM0YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-05-11T01:02:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-05-11T01:02:40Z"}, "message": "basic-block.h (enum profile_status): Break out of struct control_flow_graph.\n\n./:\t* basic-block.h (enum profile_status): Break out of struct\n\tcontrol_flow_graph.\n\t* cgraph.h (struct inline_summary): Break out of struct\n\tcgraph_local_info.\n\t* cgraphunit.c (enum cgraph_order_sort_kind): New enum, broken out\n\tof struct cgraph_order_sort.\n\t* combine.c (enum undo_kind): New enum, broken out of struct\n\tundo.\n\t* cse.c (struct branch_path): Break out of struct\n\tcse_basic_block_data.\n\t* except.h (enum eh_region_type): Break out of struct eh_region.\n\t* gcc.c (enum add_del): Break out of struct modify_target.\n\t* genrecog.c (enum decision_type): Break out of struct\n\tdecision_test.\n\t* ggc-page.c (struct ggc_pch_ondisk): Break out of struct\n\tggc_pch_data.\n\t* matrix-reorg.c (struct free_info): Break out of struct\n\tmatrix_info.\n\t* regmove.c (enum match_use): New enum, broken out of struct\n\tmatch.\n\t* sched-int.h (enum post_call_group): New enum, broken out of\n\tstruct deps.\n\t(struct deps_reg): Break out of struct deps.\n\t* target.h (struct asm_int_op): Break out of struct gcc_target.\n\t* tree-eh.c (struct goto_queue_node): Break out of struct\n\tleh_tf_state.\n\t* tree-inline.h (enum copy_body_cge_which): Break out of\n\tcopy_body_data.\n\t* tree-pass.h (enum opt_pass_type): Break out of struct opt_pass.\n\n\t* c-decl.c (in_struct, struct_types): New static variables.\n\t(pushtag): Add loc parameter.  Change all callers.\n\t(lookup_tag): Add ploc parameter.  Change all callers.\n\t(check_compound_literal_type): New function.\n\t(parser_xref_tag): Add loc parameter.  Change all callers.  If\n\t-Wc++-compat, warn about struct/union/enum types defined within a\n\tstruct or union.\n\t(start_struct): Add enclosing_in_struct, enclosing_struct_types,\n\tand loc parameters.  Change all callers.  Change error calls to\n\terror_at, using loc.  For a redefinition, if the location of the\n\toriginal definition is known, report it.  Set in_struct and\n\tstruct_types.  If -Wc++-compat warn if in sizeof, typeof, or\n\talignof.\n\t(finish_struct): Add new parameters enclosing_in_struct and\n\tenclosing_struct_types.  Change all callers.  Set\n\tC_TYPE_DEFINED_IN_STRUCT for all struct/union/enum types defined\n\tin the struct.  If in a struct, add this struct to struct_types.\n\t(start_enum): Add loc parameter.  Change all callers.  Use\n\terror_at for errors, using loc.  For a redefinition, if the\n\tlocation of the original definition is known, report it.  If in a\n\tstruct, add this enum type to struct_types.  If -Wc++-compat warn\n\tif in sizeof, typeof, or alignof.\n\t* c-parser.c (disable_extension_diagnostics): Disable\n\t-Wc++-compat.\n\t(enable_extension_diagnostics): Reenable -Wc++-compat if\n\tappropriate.\n\t(c_parser_enum_specifier): Get enum location for start_enum.\n\t(c_parser_struct_or_union_specifier): Get struct location for\n\tstart_struct.  Save in_struct and struct_types status between\n\tstart_struct and finish_struct.\n\t(c_parser_cast_expression): Get location of cast.\n\t(c_parser_alignof_expression): Get location of type.\n\t(c_parser_postfix_expression): Likewise.\n\t(c_parser_postfix_expression_after_paren_type): Add type_loc\n\tparameter.  Change all callers.  Call\n\tcheck_compound_literal_type.  Use type_loc for error about\n\tvariable size type.\n\t* c-typeck.c (build_external_ref): If -Wc++-compat, warn about a\n\tuse of an enum constant from an enum type defined in a struct or\n\tunion.\n\t(c_cast_expr): Add loc parameter.  Change all callers.  If\n\t-Wc++-compat, warn about defining a type in a cast.\n\t* c-tree.h (C_TYPE_DEFINED_IN_STRUCT): Define.\n\t(start_enum, start_struct, finish_struct): Update declarations.\n\t(parser_xref_tag, c_cast_expr): Update declarations.\n\t(check_compound_literal_type): Declare.\nfortran/:\n\t* gfortran.h (enum gfc_omp_sched_kind): New enum, broken out of\n\tgfc_omp_clauses.\n\t(enum gfc_omp_default_sharing): Likewise.\n\t* module.c (enum gfc_rsym_state): New enum, broken out of\n\tpointer_info.\n\t(enum gfc_wsym_state): Likewise.\n\t* parse.c (enum state_order): New enum, broken out of st_state.\nobjc/:\n\t* objc-act.c (objc_building_struct): New static variable.\n\t(objc_in_struct, objc_struct_types): New static variables.\n\t(objc_start_struct, objc_finish_struct): New static functions.\n\t(generate_struct_by_value_array): Call objc_start_struct instead\n\tof start_struct, and call objc_finish_struct instead of\n\tfinish_struct.\n\t(objc_build_struct, build_objc_symtab_template): Likewise.\n\t(build_module_descriptor): Likewise.\n\t(build_next_objc_exception_stuff): Likewise.\n\t(build_protocol_template): Likewise.\n\t(build_method_prototype_list_template): Likewise.\n\t(build_method_prototype_template): Likewise.\n\t(build_category_template, build_selector_template): Likewise.\n\t(build_class_template, build_super_template): Likewise.\n\t(build_ivar_template, build_ivar_list_template): Likewise.\n\t(build_method_list_template): Likewise.\n\t(build_method_template): Likewise.\nobjcp/:\n\t* objcp-decl.h (start_struct): Add three new, ignored, macro\n\tparameters.\n\t(finish_struct): Add two new, ignored, macro parameters.\ntestsuite/:\n\t* gcc.dg/Wcxx-compat-7.c: New testcase.\n\t* gcc.dg/Wcxx-compat-8.c: New testcase.\n\t* gcc.dg/c99-tag-1.c: Recognize new \"originally defined here\"\n\tnotes\n\t* gcc.dg/pr17188-1.c: Likewise.\n\t* gcc.dg/pr39084.c: Likewise.\n\nFrom-SVN: r147358", "tree": {"sha": "6b70d6a26b24127001f8d3a73561028aafd73246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b70d6a26b24127001f8d3a73561028aafd73246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24b97832e7fdb1be20e493105798dac42999c34a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24b97832e7fdb1be20e493105798dac42999c34a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24b97832e7fdb1be20e493105798dac42999c34a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24b97832e7fdb1be20e493105798dac42999c34a/comments", "author": null, "committer": null, "parents": [{"sha": "76a5dd01ebb7570ee186acf68fb7943101495536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a5dd01ebb7570ee186acf68fb7943101495536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a5dd01ebb7570ee186acf68fb7943101495536"}], "stats": {"total": 976, "additions": 741, "deletions": 235}, "files": [{"sha": "e1c13f5884bd67cecdbb78c901e85ce8bbfa55f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,3 +1,82 @@\n+2009-05-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* basic-block.h (enum profile_status): Break out of struct\n+\tcontrol_flow_graph.\n+\t* cgraph.h (struct inline_summary): Break out of struct\n+\tcgraph_local_info.\n+\t* cgraphunit.c (enum cgraph_order_sort_kind): New enum, broken out\n+\tof struct cgraph_order_sort.\n+\t* combine.c (enum undo_kind): New enum, broken out of struct\n+\tundo.\n+\t* cse.c (struct branch_path): Break out of struct\n+\tcse_basic_block_data.\n+\t* except.h (enum eh_region_type): Break out of struct eh_region.\n+\t* gcc.c (enum add_del): Break out of struct modify_target.\n+\t* genrecog.c (enum decision_type): Break out of struct\n+\tdecision_test.\n+\t* ggc-page.c (struct ggc_pch_ondisk): Break out of struct\n+\tggc_pch_data.\n+\t* matrix-reorg.c (struct free_info): Break out of struct\n+\tmatrix_info.\n+\t* regmove.c (enum match_use): New enum, broken out of struct\n+\tmatch.\n+\t* sched-int.h (enum post_call_group): New enum, broken out of\n+\tstruct deps.\n+\t(struct deps_reg): Break out of struct deps.\n+\t* target.h (struct asm_int_op): Break out of struct gcc_target.\n+\t* tree-eh.c (struct goto_queue_node): Break out of struct\n+\tleh_tf_state.\n+\t* tree-inline.h (enum copy_body_cge_which): Break out of\n+\tcopy_body_data.\n+\t* tree-pass.h (enum opt_pass_type): Break out of struct opt_pass.\n+\n+\t* c-decl.c (in_struct, struct_types): New static variables.\n+\t(pushtag): Add loc parameter.  Change all callers.\n+\t(lookup_tag): Add ploc parameter.  Change all callers.\n+\t(check_compound_literal_type): New function.\n+\t(parser_xref_tag): Add loc parameter.  Change all callers.  If\n+\t-Wc++-compat, warn about struct/union/enum types defined within a\n+\tstruct or union.\n+\t(start_struct): Add enclosing_in_struct, enclosing_struct_types,\n+\tand loc parameters.  Change all callers.  Change error calls to\n+\terror_at, using loc.  For a redefinition, if the location of the\n+\toriginal definition is known, report it.  Set in_struct and\n+\tstruct_types.  If -Wc++-compat warn if in sizeof, typeof, or\n+\talignof.\n+\t(finish_struct): Add new parameters enclosing_in_struct and\n+\tenclosing_struct_types.  Change all callers.  Set\n+\tC_TYPE_DEFINED_IN_STRUCT for all struct/union/enum types defined\n+\tin the struct.  If in a struct, add this struct to struct_types.\n+\t(start_enum): Add loc parameter.  Change all callers.  Use\n+\terror_at for errors, using loc.  For a redefinition, if the\n+\tlocation of the original definition is known, report it.  If in a\n+\tstruct, add this enum type to struct_types.  If -Wc++-compat warn\n+\tif in sizeof, typeof, or alignof.\n+\t* c-parser.c (disable_extension_diagnostics): Disable\n+\t-Wc++-compat.\n+\t(enable_extension_diagnostics): Reenable -Wc++-compat if\n+\tappropriate.\n+\t(c_parser_enum_specifier): Get enum location for start_enum.\n+\t(c_parser_struct_or_union_specifier): Get struct location for\n+\tstart_struct.  Save in_struct and struct_types status between\n+\tstart_struct and finish_struct.\n+\t(c_parser_cast_expression): Get location of cast.\n+\t(c_parser_alignof_expression): Get location of type.\n+\t(c_parser_postfix_expression): Likewise.\n+\t(c_parser_postfix_expression_after_paren_type): Add type_loc\n+\tparameter.  Change all callers.  Call\n+\tcheck_compound_literal_type.  Use type_loc for error about\n+\tvariable size type.\n+\t* c-typeck.c (build_external_ref): If -Wc++-compat, warn about a\n+\tuse of an enum constant from an enum type defined in a struct or\n+\tunion.\n+\t(c_cast_expr): Add loc parameter.  Change all callers.  If\n+\t-Wc++-compat, warn about defining a type in a cast.\n+\t* c-tree.h (C_TYPE_DEFINED_IN_STRUCT): Define.\n+\t(start_enum, start_struct, finish_struct): Update declarations.\n+\t(parser_xref_tag, c_cast_expr): Update declarations.\n+\t(check_compound_literal_type): Declare.\n+\n 2009-05-11  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/rs6000-c.c (altivec_categorize_keyword): Update"}, {"sha": "41d9f9514cbeb76f0197a55e4b501195db699a8d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,6 +1,6 @@\n /* Define control and data flow tables, and regsets.\n    Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -356,6 +356,14 @@ enum dom_state\n   DOM_OK\t\t/* Everything is ok.  */\n };\n \n+/* What sort of profiling information we have.  */\n+enum profile_status\n+{\n+  PROFILE_ABSENT,\n+  PROFILE_GUESSED,\n+  PROFILE_READ\n+};\n+\n /* A structure to group all the per-function control flow graph data.\n    The x_* prefixing is necessary because otherwise references to the\n    fields of this struct are interpreted as the defines for backward\n@@ -382,11 +390,7 @@ struct GTY(()) control_flow_graph {\n      only used for the gimple CFG.  */\n   VEC(basic_block,gc) *x_label_to_block_map;\n \n-  enum profile_status {\n-    PROFILE_ABSENT,\n-    PROFILE_GUESSED,\n-    PROFILE_READ\n-  } x_profile_status;\n+  enum profile_status x_profile_status;\n \n   /* Whether the dominators and the postdominators are available.  */\n   enum dom_state x_dom_computed[2];"}, {"sha": "a9929c1a85c2aad7c55c219823996c55d61d7b19", "filename": "gcc/c-decl.c", "status": "modified", "additions": 159, "deletions": 29, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -126,6 +126,15 @@ static GTY(()) struct stmt_tree_s c_stmt_tree;\n tree c_break_label;\n tree c_cont_label;\n \n+/* True if we are currently parsing the fields of a struct or\n+   union.  */\n+\n+static bool in_struct;\n+\n+/* A list of types defined in the current struct or union.  */\n+\n+static VEC(tree,heap) *struct_types;\n+\n /* Linked list of TRANSLATION_UNIT_DECLS for the translation units\n    included in this invocation.  Note that the current translation\n    unit is not included in this list.  */\n@@ -1086,13 +1095,12 @@ pop_file_scope (void)\n    In that case, the TYPE_SIZE will be zero.  */\n \n static void\n-pushtag (tree name, tree type)\n+pushtag (tree name, tree type, location_t loc)\n {\n   /* Record the identifier as the type's name if it has none.  */\n   if (name && !TYPE_NAME (type))\n     TYPE_NAME (type) = name;\n-  bind (name, type, current_scope, /*invisible=*/false, /*nested=*/false,\n-\tUNKNOWN_LOCATION);\n+  bind (name, type, current_scope, /*invisible=*/false, /*nested=*/false, loc);\n \n   /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the\n      tagged type we just added to the current scope.  This fake\n@@ -2725,10 +2733,13 @@ define_label (location_t location, tree name)\n    If THISLEVEL_ONLY is nonzero, searches only the current_scope.\n    CODE says which kind of type the caller wants;\n    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n+   If PLOC is not NULL and this returns non-null, it sets *PLOC to the\n+   location where the tag was defined.\n    If the wrong kind of type is found, an error is reported.  */\n \n static tree\n-lookup_tag (enum tree_code code, tree name, int thislevel_only)\n+lookup_tag (enum tree_code code, tree name, int thislevel_only,\n+\t    location_t *ploc)\n {\n   struct c_binding *b = I_TAG_BINDING (name);\n   int thislevel = 0;\n@@ -2765,6 +2776,10 @@ lookup_tag (enum tree_code code, tree name, int thislevel_only)\n       if (thislevel)\n \tpending_xref_error ();\n     }\n+\n+  if (ploc != NULL)\n+    *ploc = b->locus;\n+\n   return b->decl;\n }\n \n@@ -3037,12 +3052,12 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t  else\n \t    {\n \t      pending_invalid_xref = 0;\n-\t      t = lookup_tag (code, name, 1);\n+\t      t = lookup_tag (code, name, 1, NULL);\n \n \t      if (t == 0)\n \t\t{\n \t\t  t = make_node (code);\n-\t\t  pushtag (name, t);\n+\t\t  pushtag (name, t, input_location);\n \t\t}\n \t    }\n \t}\n@@ -3897,6 +3912,17 @@ build_compound_literal (tree type, tree init, bool non_const)\n \n   return complit;\n }\n+\n+/* Check the type of a compound literal.  Here we just check that it\n+   is valid for C++.  */\n+\n+void\n+check_compound_literal_type (struct c_type_name *type_name, location_t loc)\n+{\n+  if (warn_cxx_compat && type_name->specs->tag_defined_p)\n+    warning_at (loc, OPT_Wc___compat,\n+\t\t\"defining a type in a compound literal is invalid in C++\");\n+}\n \f\n /* Determine whether TYPE is a structure with a flexible array member,\n    or a union containing such a structure (possibly recursively).  */\n@@ -5555,18 +5581,19 @@ get_parm_info (bool ellipsis)\n    Return a c_typespec structure for the type specifier.  */\n \n struct c_typespec\n-parser_xref_tag (enum tree_code code, tree name)\n+parser_xref_tag (enum tree_code code, tree name, location_t loc)\n {\n   struct c_typespec ret;\n   tree ref;\n+  location_t refloc;\n \n   ret.expr = NULL_TREE;\n   ret.expr_const_operands = true;\n \n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n \n-  ref = lookup_tag (code, name, 0);\n+  ref = lookup_tag (code, name, 0, &refloc);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -5581,6 +5608,35 @@ parser_xref_tag (enum tree_code code, tree name)\n   ret.kind = (ref ? ctsk_tagref : ctsk_tagfirstref);\n   if (ref && TREE_CODE (ref) == code)\n     {\n+      if (C_TYPE_DEFINED_IN_STRUCT (ref)\n+\t  && loc != UNKNOWN_LOCATION\n+\t  && warn_cxx_compat)\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case ENUMERAL_TYPE:\n+\t      warning_at (loc, OPT_Wc___compat,\n+\t\t\t  (\"enum type defined in struct or union \"\n+\t\t\t   \"is not visible in C++\"));\n+\t      inform (refloc, \"enum type defined here\");\n+\t      break;\n+\t    case RECORD_TYPE:\n+\t      warning_at (loc, OPT_Wc___compat,\n+\t\t\t  (\"struct defined in struct or union \"\n+\t\t\t   \"is not visible in C++\"));\n+\t      inform (refloc, \"struct defined here\");\n+\t      break;\n+\t    case UNION_TYPE:\n+\t      warning_at (loc, OPT_Wc___compat,\n+\t\t\t  (\"union defined in struct or union \"\n+\t\t\t   \"is not visible in C++\"));\n+\t      inform (refloc, \"union defined here\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable();\n+\t    }\n+\t}\n+\n       ret.spec = ref;\n       return ret;\n     }\n@@ -5604,7 +5660,7 @@ parser_xref_tag (enum tree_code code, tree name)\n       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n     }\n \n-  pushtag (name, ref);\n+  pushtag (name, ref, loc);\n \n   ret.spec = ref;\n   return ret;\n@@ -5617,40 +5673,53 @@ parser_xref_tag (enum tree_code code, tree name)\n tree\n xref_tag (enum tree_code code, tree name)\n {\n-  return parser_xref_tag (code, name).spec;\n+  return parser_xref_tag (code, name, UNKNOWN_LOCATION).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n    at least as a forward reference.\n-   CODE says which kind of tag NAME ought to be.  */\n+   CODE says which kind of tag NAME ought to be.\n+\n+   This stores the current value of the file static IN_STRUCT in\n+   *ENCLOSING_IN_STRUCT, and sets IN_STRUCT to true.  Similarly, this\n+   sets STRUCT_TYPES in *ENCLOSING_STRUCT_TYPES, and sets STRUCT_TYPES\n+   to an empty vector.  The old values are restored in\n+   finish_struct.  */\n \n tree\n-start_struct (enum tree_code code, tree name)\n+start_struct (enum tree_code code, tree name, bool *enclosing_in_struct,\n+\t      VEC(tree,heap) **enclosing_struct_types, location_t loc)\n {\n   /* If there is already a tag defined at this scope\n      (as a forward reference), just return it.  */\n \n-  tree ref = 0;\n+  tree ref = NULL_TREE;\n+  location_t refloc = UNKNOWN_LOCATION;\n \n-  if (name != 0)\n-    ref = lookup_tag (code, name, 1);\n+  if (name != NULL_TREE)\n+    ref = lookup_tag (code, name, 1, &refloc);\n   if (ref && TREE_CODE (ref) == code)\n     {\n       if (TYPE_SIZE (ref))\n \t{\n \t  if (code == UNION_TYPE)\n-\t    error (\"redefinition of %<union %E%>\", name);\n+\t    error_at (loc, \"redefinition of %<union %E%>\", name);\n \t  else\n-\t    error (\"redefinition of %<struct %E%>\", name);\n+\t    error_at (loc, \"redefinition of %<struct %E%>\", name);\n+\t  if (refloc != UNKNOWN_LOCATION)\n+\t    inform (refloc, \"originally defined here\");\n \t  /* Don't create structures using a name already in use.  */\n \t  ref = NULL_TREE;\n \t}\n       else if (C_TYPE_BEING_DEFINED (ref))\n \t{\n \t  if (code == UNION_TYPE)\n-\t    error (\"nested redefinition of %<union %E%>\", name);\n+\t    error_at (loc, \"nested redefinition of %<union %E%>\", name);\n \t  else\n-\t    error (\"nested redefinition of %<struct %E%>\", name);\n+\t    error_at (loc, \"nested redefinition of %<struct %E%>\", name);\n+\t  /* Don't bother to report \"originally defined here\" for a\n+\t     nested redefinition; the original definition should be\n+\t     obvious.  */\n \t  /* Don't create structures that contain themselves.  */\n \t  ref = NULL_TREE;\n \t}\n@@ -5661,11 +5730,28 @@ start_struct (enum tree_code code, tree name)\n   if (ref == NULL_TREE || TREE_CODE (ref) != code)\n     {\n       ref = make_node (code);\n-      pushtag (name, ref);\n+      pushtag (name, ref, loc);\n     }\n \n   C_TYPE_BEING_DEFINED (ref) = 1;\n   TYPE_PACKED (ref) = flag_pack_struct;\n+\n+  *enclosing_in_struct = in_struct;\n+  *enclosing_struct_types = struct_types;\n+  in_struct = true;\n+  struct_types = VEC_alloc(tree, heap, 0);\n+\n+  /* FIXME: This will issue a warning for a use of a type defined\n+     within a statement expr used within sizeof, et. al.  This is not\n+     terribly serious as C++ doesn't permit statement exprs within\n+     sizeof anyhow.  */\n+  if (warn_cxx_compat && (in_sizeof || in_typeof || in_alignof))\n+    warning_at (loc, OPT_Wc___compat,\n+\t\t\"defining type in %qs expression is invalid in C++\",\n+\t\t(in_sizeof\n+\t\t ? \"sizeof\"\n+\t\t : (in_typeof ? \"typeof\" : \"alignof\")));\n+\n   return ref;\n }\n \n@@ -5803,14 +5889,22 @@ detect_field_duplicates (tree fieldlist)\n \n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n-   ATTRIBUTES are attributes to be applied to the structure.  */\n+   ATTRIBUTES are attributes to be applied to the structure.\n+\n+   ENCLOSING_IN_STRUCT is the value of IN_STRUCT, and\n+   ENCLOSING_STRUCT_TYPES is the value of STRUCT_TYPES, when the\n+   struct was started.  This sets the C_TYPE_DEFINED_IN_STRUCT flag\n+   for any type defined in the current struct.  */\n \n tree\n-finish_struct (tree t, tree fieldlist, tree attributes)\n+finish_struct (tree t, tree fieldlist, tree attributes,\n+\t       bool enclosing_in_struct,\n+\t       VEC(tree,heap) *enclosing_struct_types)\n {\n   tree x;\n   bool toplevel = file_scope == current_scope;\n   int saw_named_field;\n+  unsigned int ix;\n \n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n@@ -6063,6 +6157,24 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n   if (cur_stmt_list && variably_modified_type_p (t, NULL_TREE))\n     add_stmt (build_stmt (DECL_EXPR, build_decl (TYPE_DECL, NULL, t)));\n \n+  /* Set the C_TYPE_DEFINED_IN_STRUCT flag for each type defined in\n+     the current struct.  We do this now at the end of the struct\n+     because the flag is used to issue visibility warnings when using\n+     -Wc++-compat, and we only want to issue those warnings if the\n+     type is referenced outside of the struct declaration.  */\n+  for (ix = 0; VEC_iterate (tree, struct_types, ix, x); ++ix)\n+    C_TYPE_DEFINED_IN_STRUCT (x) = 1;\n+\n+  VEC_free (tree, heap, struct_types);\n+\n+  in_struct = enclosing_in_struct;\n+  struct_types = enclosing_struct_types;\n+\n+  /* If this struct is defined inside a struct, add it to\n+     STRUCT_TYPES.  */\n+  if (in_struct && !in_sizeof && !in_typeof && !in_alignof)\n+    VEC_safe_push (tree, heap, struct_types, t);\n+\n   return t;\n }\n \n@@ -6083,32 +6195,35 @@ layout_array_type (tree t)\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (struct c_enum_contents *the_enum, tree name)\n+start_enum (struct c_enum_contents *the_enum, tree name, location_t loc)\n {\n-  tree enumtype = 0;\n+  tree enumtype = NULL_TREE;\n+  location_t enumloc = UNKNOWN_LOCATION;\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n \n-  if (name != 0)\n-    enumtype = lookup_tag (ENUMERAL_TYPE, name, 1);\n+  if (name != NULL_TREE)\n+    enumtype = lookup_tag (ENUMERAL_TYPE, name, 1, &enumloc);\n \n   if (enumtype == 0 || TREE_CODE (enumtype) != ENUMERAL_TYPE)\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n-      pushtag (name, enumtype);\n+      pushtag (name, enumtype, loc);\n     }\n \n   if (C_TYPE_BEING_DEFINED (enumtype))\n-    error (\"nested redefinition of %<enum %E%>\", name);\n+    error_at (loc, \"nested redefinition of %<enum %E%>\", name);\n \n   C_TYPE_BEING_DEFINED (enumtype) = 1;\n \n   if (TYPE_VALUES (enumtype) != 0)\n     {\n       /* This enum is a named one that has been declared already.  */\n-      error (\"redeclaration of %<enum %E%>\", name);\n+      error_at (loc, \"redeclaration of %<enum %E%>\", name);\n+      if (enumloc != UNKNOWN_LOCATION)\n+\tinform (enumloc, \"originally defined here\");\n \n       /* Completely replace its old definition.\n \t The old enumerators remain defined, however.  */\n@@ -6121,6 +6236,16 @@ start_enum (struct c_enum_contents *the_enum, tree name)\n   if (flag_short_enums)\n     TYPE_PACKED (enumtype) = 1;\n \n+  /* FIXME: This will issue a warning for a use of a type defined\n+     within sizeof in a statement expr.  This is not terribly serious\n+     as C++ doesn't permit statement exprs within sizeof anyhow.  */\n+  if (warn_cxx_compat && (in_sizeof || in_typeof || in_alignof))\n+    warning_at (loc, OPT_Wc___compat,\n+\t\t\"defining type in %qs expression is invalid in C++\",\n+\t\t(in_sizeof\n+\t\t ? \"sizeof\"\n+\t\t : (in_typeof ? \"typeof\" : \"alignof\")));\n+\n   return enumtype;\n }\n \n@@ -6260,6 +6385,11 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (enumtype, toplevel);\n \n+  /* If this enum is defined inside a struct, add it to\n+     STRUCT_TYPES.  */\n+  if (in_struct && !in_sizeof && !in_typeof && !in_alignof)\n+    VEC_safe_push (tree, heap, struct_types, enumtype);\n+\n   return enumtype;\n }\n "}, {"sha": "beda817c202f49975a6e4498a0ecf9497bebdd36", "filename": "gcc/c-parser.c", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -820,12 +820,14 @@ disable_extension_diagnostics (void)\n \t     | (warn_pointer_arith << 1)\n \t     | (warn_traditional << 2)\n \t     | (flag_iso << 3)\n-\t     | (warn_long_long << 4));\n+\t     | (warn_long_long << 4)\n+\t     | (warn_cxx_compat << 5));\n   cpp_opts->pedantic = pedantic = 0;\n   warn_pointer_arith = 0;\n   cpp_opts->warn_traditional = warn_traditional = 0;\n   flag_iso = 0;\n   cpp_opts->warn_long_long = warn_long_long = 0;\n+  warn_cxx_compat = 0;\n   return ret;\n }\n \n@@ -840,6 +842,7 @@ restore_extension_diagnostics (int flags)\n   cpp_opts->warn_traditional = warn_traditional = (flags >> 2) & 1;\n   flag_iso = (flags >> 3) & 1;\n   cpp_opts->warn_long_long = warn_long_long = (flags >> 4) & 1;\n+  warn_cxx_compat = (flags >> 5) & 1;\n }\n \n /* Possibly kinds of declarator to parse.  */\n@@ -910,7 +913,8 @@ static struct c_expr c_parser_sizeof_expression (c_parser *);\n static struct c_expr c_parser_alignof_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n-\t\t\t\t\t\t\t\t   struct c_type_name *);\n+\t\t\t\t\t\t\t\t   struct c_type_name *,\n+\t\t\t\t\t\t\t\t   location_t);\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n \t\t\t\t\t\t\t\tstruct c_expr);\n static struct c_expr c_parser_expression (c_parser *);\n@@ -1620,8 +1624,10 @@ c_parser_enum_specifier (c_parser *parser)\n   struct c_typespec ret;\n   tree attrs;\n   tree ident = NULL_TREE;\n+  location_t enum_loc;\n   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n+  enum_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   attrs = c_parser_attributes (parser);\n   /* Set the location in case we create a decl now.  */\n@@ -1630,13 +1636,14 @@ c_parser_enum_specifier (c_parser *parser)\n     {\n       ident = c_parser_peek_token (parser)->value;\n       ident_loc = c_parser_peek_token (parser)->location;\n+      enum_loc = ident_loc;\n       c_parser_consume_token (parser);\n     }\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n       /* Parse an enum definition.  */\n       struct c_enum_contents the_enum;\n-      tree type = start_enum (&the_enum, ident);\n+      tree type = start_enum (&the_enum, ident, enum_loc);\n       tree postfix_attrs;\n       /* We chain the enumerators in reverse order, then put them in\n \t forward order at the end.  */\n@@ -1715,7 +1722,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (ENUMERAL_TYPE, ident);\n+  ret = parser_xref_tag (ENUMERAL_TYPE, ident, ident_loc);\n   /* In ISO C, enumerated types can be referred to only if already\n      defined.  */\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n@@ -1772,6 +1779,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n   struct c_typespec ret;\n   tree attrs;\n   tree ident = NULL_TREE;\n+  location_t struct_loc;\n+  location_t ident_loc = UNKNOWN_LOCATION;\n   enum tree_code code;\n   switch (c_parser_peek_token (parser)->keyword)\n     {\n@@ -1784,20 +1793,26 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     default:\n       gcc_unreachable ();\n     }\n+  struct_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   attrs = c_parser_attributes (parser);\n   /* Set the location in case we create a decl now.  */\n   c_parser_set_source_position_from_token (c_parser_peek_token (parser));\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       ident = c_parser_peek_token (parser)->value;\n+      ident_loc = c_parser_peek_token (parser)->location;\n+      struct_loc = ident_loc;\n       c_parser_consume_token (parser);\n     }\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n       /* Parse a struct or union definition.  Start the scope of the\n \t tag before parsing components.  */\n-      tree type = start_struct (code, ident);\n+      bool in_struct;\n+      VEC(tree,heap) *struct_types;\n+      tree type = start_struct (code, ident, &in_struct, &struct_types,\n+\t\t\t\tstruct_loc);\n       tree postfix_attrs;\n       /* We chain the components in reverse order, then put them in\n \t forward order at the end.  Each struct-declaration may\n@@ -1887,7 +1902,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t}\n       postfix_attrs = c_parser_attributes (parser);\n       ret.spec = finish_struct (type, nreverse (contents),\n-\t\t\t\tchainon (attrs, postfix_attrs));\n+\t\t\t\tchainon (attrs, postfix_attrs),\n+\t\t\t\tin_struct, struct_types);\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n@@ -1902,7 +1918,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (code, ident);\n+  ret = parser_xref_tag (code, ident, ident_loc);\n   return ret;\n }\n \n@@ -4843,10 +4859,12 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n       && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n     {\n+      location_t loc;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       struct c_expr expr;\n       c_parser_consume_token (parser);\n+      loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n       if (type_name == NULL)\n@@ -4861,11 +4879,11 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       used_types_insert (type_name->specs->type);\n \n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-\treturn c_parser_postfix_expression_after_paren_type (parser,\n-\t\t\t\t\t\t\t     type_name);\n+\treturn c_parser_postfix_expression_after_paren_type (parser, type_name,\n+\t\t\t\t\t\t\t     loc);\n       expr = c_parser_cast_expression (parser, NULL);\n       expr = default_function_array_conversion (expr);\n-      ret.value = c_cast_expr (type_name, expr.value);\n+      ret.value = c_cast_expr (type_name, expr.value, loc);\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       return ret;\n@@ -5036,7 +5054,8 @@ c_parser_sizeof_expression (c_parser *parser)\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n \t  expr = c_parser_postfix_expression_after_paren_type (parser,\n-\t\t\t\t\t\t\t       type_name);\n+\t\t\t\t\t\t\t       type_name,\n+\t\t\t\t\t\t\t       expr_loc);\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n@@ -5073,9 +5092,11 @@ c_parser_alignof_expression (c_parser *parser)\n     {\n       /* Either __alignof__ ( type-name ) or __alignof__\n \t unary-expression starting with a compound literal.  */\n+      location_t loc;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       c_parser_consume_token (parser);\n+      loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n       if (type_name == NULL)\n@@ -5091,7 +5112,8 @@ c_parser_alignof_expression (c_parser *parser)\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n \t  expr = c_parser_postfix_expression_after_paren_type (parser,\n-\t\t\t\t\t\t\t       type_name);\n+\t\t\t\t\t\t\t       type_name,\n+\t\t\t\t\t\t\t       loc);\n \t  goto alignof_expr;\n \t}\n       /* alignof ( type-name ).  */\n@@ -5262,8 +5284,10 @@ c_parser_postfix_expression (c_parser *parser)\n \t     than going directly to\n \t     c_parser_postfix_expression_after_paren_type from\n \t     elsewhere?  */\n+\t  location_t loc;\n \t  struct c_type_name *type_name;\n \t  c_parser_consume_token (parser);\n+\t  loc = c_parser_peek_token (parser)->location;\n \t  type_name = c_parser_type_name (parser);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n@@ -5273,7 +5297,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t    }\n \t  else\n \t    expr = c_parser_postfix_expression_after_paren_type (parser,\n-\t\t\t\t\t\t\t\t type_name);\n+\t\t\t\t\t\t\t\t type_name,\n+\t\t\t\t\t\t\t\t loc);\n \t}\n       else\n \t{\n@@ -5591,11 +5616,14 @@ c_parser_postfix_expression (c_parser *parser)\n    possible to tell until after the type name whether a cast\n    expression has a cast or a compound literal, or whether the operand\n    of sizeof is a parenthesized type name or starts with a compound\n-   literal.  */\n+   literal.  TYPE_LOC is the location where TYPE_NAME starts--the\n+   location of the first token after the parentheses around the type\n+   name.  */\n \n static struct c_expr\n c_parser_postfix_expression_after_paren_type (c_parser *parser,\n-\t\t\t\t\t      struct c_type_name *type_name)\n+\t\t\t\t\t      struct c_type_name *type_name,\n+\t\t\t\t\t      location_t type_loc)\n {\n   tree type;\n   struct c_expr init;\n@@ -5604,12 +5632,13 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   location_t start_loc;\n   tree type_expr = NULL_TREE;\n   bool type_expr_const = true;\n+  check_compound_literal_type (type_name, type_loc);\n   start_init (NULL_TREE, NULL, 0);\n   type = groktypename (type_name, &type_expr, &type_expr_const);\n   start_loc = c_parser_peek_token (parser)->location;\n   if (type != error_mark_node && C_TYPE_VARIABLE_SIZE (type))\n     {\n-      error_at (start_loc, \"compound literal has variable size\");\n+      error_at (type_loc, \"compound literal has variable size\");\n       type = error_mark_node;\n     }\n   init = c_parser_braced_init (parser, type, false);"}, {"sha": "6062d59982d3666b50857237ada5c7e05a634f98", "filename": "gcc/c-tree.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -73,6 +73,10 @@ struct GTY(()) lang_type {\n #define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n #define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n \n+/* Record whether a type is defined inside a struct or union type.\n+   This is used for -Wc++-compat. */\n+#define C_TYPE_DEFINED_IN_STRUCT(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n+\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n@@ -514,7 +518,7 @@ extern void c_maybe_initialize_eh (void);\n extern void finish_decl (tree, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n-extern tree finish_struct (tree, tree, tree);\n+extern tree finish_struct (tree, tree, tree, bool, VEC(tree,heap) *);\n extern struct c_arg_info *get_parm_info (bool);\n extern tree grokfield (location_t, struct c_declarator *,\n \t\t       struct c_declspecs *, tree, tree *);\n@@ -532,15 +536,16 @@ extern tree c_builtin_function (tree);\n extern tree c_builtin_function_ext_scope (tree);\n extern void shadow_tag (const struct c_declspecs *);\n extern void shadow_tag_warned (const struct c_declspecs *, int);\n-extern tree start_enum (struct c_enum_contents *, tree);\n+extern tree start_enum (struct c_enum_contents *, tree, location_t);\n extern int  start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree);\n-extern tree start_struct (enum tree_code, tree);\n+extern tree start_struct (enum tree_code, tree, bool *, VEC(tree,heap) **,\n+\t\t\t  location_t);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n extern tree xref_tag (enum tree_code, tree);\n-extern struct c_typespec parser_xref_tag (enum tree_code, tree);\n+extern struct c_typespec parser_xref_tag (enum tree_code, tree, location_t);\n extern int c_expand_decl (tree);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *);\n@@ -604,7 +609,7 @@ extern struct c_expr parser_build_binary_op (location_t,\n \t\t\t\t\t     struct c_expr);\n extern tree build_conditional_expr (tree, bool, tree, tree);\n extern tree build_compound_expr (tree, tree);\n-extern tree c_cast_expr (struct c_type_name *, tree);\n+extern tree c_cast_expr (struct c_type_name *, tree, location_t);\n extern tree build_c_cast (tree, tree);\n extern void store_init_value (tree, tree, tree);\n extern void error_init (const char *);\n@@ -619,6 +624,7 @@ extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n extern void process_init_element (struct c_expr, bool);\n extern tree build_compound_literal (tree, tree, bool);\n+extern void check_compound_literal_type (struct c_type_name *, location_t);\n extern tree c_start_case (tree);\n extern void c_finish_case (tree);\n extern tree build_asm_expr (tree, tree, tree, tree, bool);"}, {"sha": "f1dc7a34c59af230ceefdcd23131737e5a9f5c4a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -2246,6 +2246,17 @@ build_external_ref (tree id, int fun, location_t loc, tree *type)\n   if (TREE_CODE (ref) == CONST_DECL)\n     {\n       used_types_insert (TREE_TYPE (ref));\n+\n+      if (warn_cxx_compat\n+\t  && TREE_CODE (TREE_TYPE (ref)) == ENUMERAL_TYPE\n+\t  && C_TYPE_DEFINED_IN_STRUCT (TREE_TYPE (ref)))\n+\t{\n+\t  warning_at (loc, OPT_Wc___compat,\n+\t\t      (\"enum constant defined in struct or union \"\n+\t\t       \"is not visible in C++\"));\n+\t  inform (DECL_SOURCE_LOCATION (ref), \"enum constant defined here\");\n+\t}\n+\n       ref = DECL_INITIAL (ref);\n       TREE_CONSTANT (ref) = 1;\n     }\n@@ -4262,7 +4273,7 @@ build_c_cast (tree type, tree expr)\n \n /* Interpret a cast of expression EXPR to type TYPE.  */\n tree\n-c_cast_expr (struct c_type_name *type_name, tree expr)\n+c_cast_expr (struct c_type_name *type_name, tree expr, location_t loc)\n {\n   tree type;\n   tree type_expr = NULL_TREE;\n@@ -4283,6 +4294,15 @@ c_cast_expr (struct c_type_name *type_name, tree expr)\n       ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret), type_expr, ret);\n       C_MAYBE_CONST_EXPR_NON_CONST (ret) = !type_expr_const;\n     }\n+\n+  if (CAN_HAVE_LOCATION_P (ret) && !EXPR_HAS_LOCATION (ret))\n+    SET_EXPR_LOCATION (ret, loc);\n+\n+  /* C++ does not permits types to be defined in a cast.  */\n+  if (warn_cxx_compat && type_name->specs->tag_defined_p)\n+    warning_at (loc, OPT_Wc___compat,\n+\t\t\"defining a type in a cast is invalid in C++\");\n+\n   return ret;\n }\n \f"}, {"sha": "58ae06852cf2fa65bbb16e1faee17154b526ce48", "filename": "gcc/cgraph.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n@@ -48,17 +48,22 @@ enum availability\n \n extern const char * const cgraph_availability_names[];\n \n+/* Function inlining information.  */\n+\n+struct GTY(()) inline_summary\n+{\n+  /* Estimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_self_stack_size;\n+\n+  /* Size of the function before inlining.  */\n+  int self_insns;\n+};\n+\n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n \n struct GTY(()) cgraph_local_info {\n-  struct inline_summary {\n-    /* Estimated stack frame consumption by the function.  */\n-    HOST_WIDE_INT estimated_self_stack_size;\n-\n-    /* Size of the function before inlining.  */\n-    int self_insns;\n-  } inline_summary;\n+  struct inline_summary inline_summary;\n \n   /* Set when function function is visible in current compilation unit only\n      and its address is never taken.  */"}, {"sha": "a73eabc44e3c851a3685ea1adec209f30f08bff1", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1162,9 +1162,17 @@ cgraph_expand_all_functions (void)\n \n /* This is used to sort the node types by the cgraph order number.  */\n \n+enum cgraph_order_sort_kind\n+{\n+  ORDER_UNDEFINED = 0,\n+  ORDER_FUNCTION,\n+  ORDER_VAR,\n+  ORDER_ASM\n+};\n+\n struct cgraph_order_sort\n {\n-  enum { ORDER_UNDEFINED = 0, ORDER_FUNCTION, ORDER_VAR, ORDER_ASM } kind;\n+  enum cgraph_order_sort_kind kind;\n   union\n   {\n     struct cgraph_node *f;"}, {"sha": "0c06b2d102c20e7d7399e3ff549ab0b2d63ec530", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -342,10 +342,12 @@ static int nonzero_sign_valid;\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.  */\n \n+enum undo_kind { UNDO_RTX, UNDO_INT, UNDO_MODE };\n+\n struct undo\n {\n   struct undo *next;\n-  enum { UNDO_RTX, UNDO_INT, UNDO_MODE } kind;\n+  enum undo_kind kind;\n   union { rtx r; int i; enum machine_mode m; } old_contents;\n   union { rtx *r; int *i; } where;\n };"}, {"sha": "a697ed428e01311fc39f4d0605d19af98e45ed18", "filename": "gcc/cse.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -517,6 +517,14 @@ static struct table_elt *free_element_chain;\n static int constant_pool_entries_cost;\n static int constant_pool_entries_regcost;\n \n+/* Trace a patch through the CFG.  */\n+\n+struct branch_path\n+{\n+  /* The basic block for this path entry.  */\n+  basic_block bb;\n+};\n+\n /* This data describes a block that will be processed by\n    cse_extended_basic_block.  */\n \n@@ -527,11 +535,7 @@ struct cse_basic_block_data\n   /* Size of current branch path, if any.  */\n   int path_size;\n   /* Current path, indicating which basic_blocks will be processed.  */\n-  struct branch_path\n-    {\n-      /* The basic block for this path entry.  */\n-      basic_block bb;\n-    } *path;\n+  struct branch_path *path;\n };\n \n \n@@ -7058,4 +7062,3 @@ struct rtl_opt_pass pass_cse_after_global_opts =\n   TODO_verify_flow                      /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "70506d3a8c577caac982a930e6583b5bef7105a4", "filename": "gcc/except.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,6 +1,6 @@\n /* Exception Handling interface routines.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2007, 2008  Free Software Foundation, Inc.\n+   2007, 2008, 2009  Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n This file is part of GCC.\n@@ -24,6 +24,18 @@ along with GCC; see the file COPYING3.  If not see\n \n struct function;\n \n+/* The type of an exception region.  */\n+enum eh_region_type\n+{\n+  ERT_UNKNOWN = 0,\n+  ERT_CLEANUP,\n+  ERT_TRY,\n+  ERT_CATCH,\n+  ERT_ALLOWED_EXCEPTIONS,\n+  ERT_MUST_NOT_THROW,\n+  ERT_THROW\n+};\n+\n /* Describes one exception region.  */\n struct GTY(()) eh_region\n {\n@@ -45,16 +57,7 @@ struct GTY(()) eh_region\n   bitmap aka;\n \n   /* Each region does exactly one thing.  */\n-  enum eh_region_type\n-  {\n-    ERT_UNKNOWN = 0,\n-    ERT_CLEANUP,\n-    ERT_TRY,\n-    ERT_CATCH,\n-    ERT_ALLOWED_EXCEPTIONS,\n-    ERT_MUST_NOT_THROW,\n-    ERT_THROW\n-  } type;\n+  enum eh_region_type type;\n \n   /* Holds the action to perform based on the preceding type.  */\n   union eh_region_u {"}, {"sha": "97f56b20141da3bbdf1357eccb48d9f68a6f9190", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,3 +1,13 @@\n+2009-05-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gfortran.h (enum gfc_omp_sched_kind): New enum, broken out of\n+\tgfc_omp_clauses.\n+\t(enum gfc_omp_default_sharing): Likewise.\n+\t* module.c (enum gfc_rsym_state): New enum, broken out of\n+\tpointer_info.\n+\t(enum gfc_wsym_state): Likewise.\n+\t* parse.c (enum state_order): New enum, broken out of st_state.\n+\n 2009-05-10  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40018"}, {"sha": "fad49c4e7cd773d477d37922432aed5f6ab4d5ab", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -931,29 +931,34 @@ enum\n \n /* Because a symbol can belong to multiple namelists, they must be\n    linked externally to the symbol itself.  */\n+\n+enum gfc_omp_sched_kind\n+{\n+  OMP_SCHED_NONE,\n+  OMP_SCHED_STATIC,\n+  OMP_SCHED_DYNAMIC,\n+  OMP_SCHED_GUIDED,\n+  OMP_SCHED_RUNTIME,\n+  OMP_SCHED_AUTO\n+};\n+\n+enum gfc_omp_default_sharing\n+{\n+  OMP_DEFAULT_UNKNOWN,\n+  OMP_DEFAULT_NONE,\n+  OMP_DEFAULT_PRIVATE,\n+  OMP_DEFAULT_SHARED,\n+  OMP_DEFAULT_FIRSTPRIVATE\n+};\n+\n typedef struct gfc_omp_clauses\n {\n   struct gfc_expr *if_expr;\n   struct gfc_expr *num_threads;\n   gfc_namelist *lists[OMP_LIST_NUM];\n-  enum\n-    {\n-      OMP_SCHED_NONE,\n-      OMP_SCHED_STATIC,\n-      OMP_SCHED_DYNAMIC,\n-      OMP_SCHED_GUIDED,\n-      OMP_SCHED_RUNTIME,\n-      OMP_SCHED_AUTO\n-    } sched_kind;\n+  enum gfc_omp_sched_kind sched_kind;\n   struct gfc_expr *chunk_size;\n-  enum\n-    {\n-      OMP_DEFAULT_UNKNOWN,\n-      OMP_DEFAULT_NONE,\n-      OMP_DEFAULT_PRIVATE,\n-      OMP_DEFAULT_SHARED,\n-      OMP_DEFAULT_FIRSTPRIVATE\n-    } default_sharing;\n+  enum gfc_omp_default_sharing default_sharing;\n   int collapse;\n   bool nowait, ordered, untied;\n }"}, {"sha": "4221c04573cad2d971c909ce052998a866be45ff", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -119,6 +119,20 @@ fixup_t;\n \n /* Structure for holding extra info needed for pointers being read.  */\n \n+enum gfc_rsym_state\n+{\n+  UNUSED,\n+  NEEDED,\n+  USED\n+};\n+\n+enum gfc_wsym_state\n+{\n+  UNREFERENCED = 0,\n+  NEEDS_WRITE,\n+  WRITTEN\n+};\n+\n typedef struct pointer_info\n {\n   BBT_HEADER (pointer_info);\n@@ -138,9 +152,7 @@ typedef struct pointer_info\n     {\n       gfc_symbol *sym;\n       char true_name[GFC_MAX_SYMBOL_LEN + 1], module[GFC_MAX_SYMBOL_LEN + 1];\n-      enum\n-      { UNUSED, NEEDED, USED }\n-      state;\n+      enum gfc_rsym_state state;\n       int ns, referenced, renamed;\n       module_locus where;\n       fixup_t *stfixup;\n@@ -152,9 +164,7 @@ typedef struct pointer_info\n     struct\n     {\n       gfc_symbol *sym;\n-      enum\n-      { UNREFERENCED = 0, NEEDS_WRITE, WRITTEN }\n-      state;\n+      enum gfc_wsym_state state;\n     }\n     wsym;\n   }"}, {"sha": "d387f543c94e27a8201f9b1f597f01ddc3c70367", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1580,13 +1580,20 @@ unexpected_statement (gfc_statement st)\n \n */\n \n+enum state_order\n+{\n+  ORDER_START,\n+  ORDER_USE,\n+  ORDER_IMPORT,\n+  ORDER_IMPLICIT_NONE,\n+  ORDER_IMPLICIT,\n+  ORDER_SPEC,\n+  ORDER_EXEC\n+};\n+\n typedef struct\n {\n-  enum\n-  { ORDER_START, ORDER_USE, ORDER_IMPORT, ORDER_IMPLICIT_NONE,\n-    ORDER_IMPLICIT, ORDER_SPEC, ORDER_EXEC\n-  }\n-  state;\n+  enum state_order state;\n   gfc_statement last_statement;\n   locus where;\n }"}, {"sha": "9168a3423d033b0dc7ec49143ffe6607e5a6b4d5", "filename": "gcc/gcc.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -268,10 +268,12 @@ static const char *cross_compile = \"0\";\n    switch.  The only case we support now is simply appending or deleting a\n    string to or from the end of the first part of the configuration name.  */\n \n+enum add_del {ADD, DELETE};\n+\n static const struct modify_target\n {\n   const char *const sw;\n-  const enum add_del {ADD, DELETE} add_del;\n+  const enum add_del add_del;\n   const char *const str;\n }\n modify_target[] = MODIFY_TARGET_NAME;"}, {"sha": "9abb13fd75c4fe9a046fab32d876cde02cd06f6e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -71,6 +71,17 @@ struct decision_head\n   struct decision *last;\n };\n \n+/* These types are roughly in the order in which we'd like to test them.  */\n+enum decision_type\n+{\n+  DT_num_insns,\n+  DT_mode, DT_code, DT_veclen,\n+  DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,\n+  DT_const_int,\n+  DT_veclen_ge, DT_dup, DT_pred, DT_c_test,\n+  DT_accept_op, DT_accept_insn\n+};\n+\n /* A single test.  The two accept types aren't tests per-se, but\n    their equality (or lack thereof) does affect tree merging so\n    it is convenient to keep them here.  */\n@@ -80,16 +91,7 @@ struct decision_test\n   /* A linked list through the tests attached to a node.  */\n   struct decision_test *next;\n \n-  /* These types are roughly in the order in which we'd like to test them.  */\n-  enum decision_type\n-    {\n-      DT_num_insns,\n-      DT_mode, DT_code, DT_veclen,\n-      DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,\n-      DT_const_int,\n-      DT_veclen_ge, DT_dup, DT_pred, DT_c_test,\n-      DT_accept_op, DT_accept_insn\n-    } type;\n+  enum decision_type type;\n \n   union\n   {"}, {"sha": "41cbd44c58521c4dab7486ae3178fcdfe54071ff", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,5 +1,5 @@\n /* \"Bag-of-pages\" garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2063,12 +2063,14 @@ ggc_print_statistics (void)\n #endif\n }\n \f\n+struct ggc_pch_ondisk\n+{\n+  unsigned totals[NUM_ORDERS];\n+};\n+\n struct ggc_pch_data\n {\n-  struct ggc_pch_ondisk\n-  {\n-    unsigned totals[NUM_ORDERS];\n-  } d;\n+  struct ggc_pch_ondisk d;\n   size_t base[NUM_ORDERS];\n   size_t written[NUM_ORDERS];\n };"}, {"sha": "7b8de0b890914effbb7adc76b1d42f065d9ee6b2", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -243,6 +243,14 @@ typedef struct access_site_info *access_site_info_p;\n DEF_VEC_P (access_site_info_p);\n DEF_VEC_ALLOC_P (access_site_info_p, heap);\n \n+/* Calls to free when flattening a matrix.  */\n+\n+struct free_info\n+{\n+  gimple stmt;\n+  tree func;\n+};\n+\n /* Information about matrix to flatten.  */\n struct matrix_info\n {\n@@ -275,11 +283,7 @@ struct matrix_info\n   tree allocation_function_decl;\n \n   /* The calls to free for each level of indirection.  */\n-  struct free_info\n-  {\n-    gimple stmt;\n-    tree func;\n-  } *free_stmts;\n+  struct free_info *free_stmts;\n \n   /* An array which holds for each dimension its size. where\n      dimension 0 is the outer most (one that contains all the others)."}, {"sha": "a1f0f242b4c8700db301c2db7965be9ac565a07f", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,3 +1,23 @@\n+2009-05-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_building_struct): New static variable.\n+\t(objc_in_struct, objc_struct_types): New static variables.\n+\t(objc_start_struct, objc_finish_struct): New static functions.\n+\t(generate_struct_by_value_array): Call objc_start_struct instead\n+\tof start_struct, and call objc_finish_struct instead of\n+\tfinish_struct.\n+\t(objc_build_struct, build_objc_symtab_template): Likewise.\n+\t(build_module_descriptor): Likewise.\n+\t(build_next_objc_exception_stuff): Likewise.\n+\t(build_protocol_template): Likewise.\n+\t(build_method_prototype_list_template): Likewise.\n+\t(build_method_prototype_template): Likewise.\n+\t(build_category_template, build_selector_template): Likewise.\n+\t(build_class_template, build_super_template): Likewise.\n+\t(build_ivar_template, build_ivar_list_template): Likewise.\n+\t(build_method_list_template): Likewise.\n+\t(build_method_template): Likewise.\n+\n 2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* objc-act.c: Include intl.h."}, {"sha": "9bf7d3f09128188113af114495df6a7d6a2ee90d", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -416,6 +416,35 @@ FILE *gen_declaration_file;\n \n static int generating_instance_variables = 0;\n \n+/* For building an objc struct.  These may not be used when this file\n+   is compiled as part of obj-c++.  */\n+\n+static bool objc_building_struct;\n+static bool objc_in_struct ATTRIBUTE_UNUSED;\n+static VEC(tree,heap) *objc_struct_types ATTRIBUTE_UNUSED;\n+\n+/* Start building a struct for objc.  */\n+\n+static tree\n+objc_start_struct (tree name)\n+{\n+  gcc_assert (!objc_building_struct);\n+  objc_building_struct = true;\n+  return start_struct (RECORD_TYPE, name, &objc_in_struct, &objc_struct_types,\n+\t\t       UNKNOWN_LOCATION);\n+}\n+\n+/* Finish building a struct for objc.  */\n+\n+static tree\n+objc_finish_struct (tree type, tree fieldlist)\n+{\n+  gcc_assert (objc_building_struct);\n+  objc_building_struct = false;\n+  return finish_struct (type, fieldlist, NULL_TREE, objc_in_struct,\n+\t\t\tobjc_struct_types);\n+}\n+\n /* Some platforms pass small structures through registers versus\n    through an invisible pointer.  Determine at what size structure is\n    the transition point between the two possibilities.  */\n@@ -435,7 +464,7 @@ generate_struct_by_value_array (void)\n       char buffer[5];\n \n       /* Create an unnamed struct that has `i' character components */\n-      type = start_struct (RECORD_TYPE, NULL_TREE);\n+      type = objc_start_struct (NULL_TREE);\n \n       strcpy (buffer, \"c1\");\n       field_decl = create_field_decl (char_type_node,\n@@ -449,7 +478,7 @@ generate_struct_by_value_array (void)\n \t\t\t\t\t  buffer);\n \t  chainon (field_decl_chain, field_decl);\n \t}\n-      finish_struct (type, field_decl_chain, NULL_TREE);\n+      objc_finish_struct (type, field_decl_chain);\n \n       aggregate_in_mem[i] = aggregate_value_p (type, 0);\n       if (!aggregate_in_mem[i])\n@@ -789,7 +818,7 @@ static tree\n objc_build_struct (tree klass, tree fields, tree super_name)\n {\n   tree name = CLASS_NAME (klass);\n-  tree s = start_struct (RECORD_TYPE, name);\n+  tree s = objc_start_struct (name);\n   tree super = (super_name ? xref_tag (RECORD_TYPE, super_name) : NULL_TREE);\n   tree t, objc_info = NULL_TREE;\n \n@@ -850,7 +879,7 @@ objc_build_struct (tree klass, tree fields, tree super_name)\n   INIT_TYPE_OBJC_INFO (s);\n   TYPE_OBJC_INTERFACE (s) = klass;\n \n-  s = finish_struct (s, fields, NULL_TREE);\n+  s = objc_finish_struct (s, fields);\n \n   for (t = TYPE_NEXT_VARIANT (s); t;\n        t = TYPE_NEXT_VARIANT (t), objc_info = TREE_CHAIN (objc_info))\n@@ -2058,8 +2087,7 @@ build_objc_symtab_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n-  objc_symtab_template\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_SYMTAB));\n+  objc_symtab_template = objc_start_struct (get_identifier (UTAG_SYMTAB));\n \n   /* long sel_ref_cnt; */\n   field_decl = create_field_decl (long_integer_type_node, \"sel_ref_cnt\");\n@@ -2093,7 +2121,7 @@ build_objc_symtab_template (void)\n       chainon (field_decl_chain, field_decl);\n     }\n \n-  finish_struct (objc_symtab_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_symtab_template, field_decl_chain);\n }\n \n /* Create the initial value for the `defs' field of _objc_symtab.\n@@ -2293,8 +2321,7 @@ build_module_descriptor (void)\n   push_lang_context (lang_name_c); /* extern \"C\" */\n #endif\n \n-  objc_module_template\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_MODULE));\n+  objc_module_template = objc_start_struct (get_identifier (UTAG_MODULE));\n \n   /* long version; */\n   field_decl = create_field_decl (long_integer_type_node, \"version\");\n@@ -2316,7 +2343,7 @@ build_module_descriptor (void)\n \t\t\t \"symtab\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_module_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_module_template, field_decl_chain);\n \n   /* Create an instance of \"_objc_module\".  */\n   UOBJC_MODULES_decl = start_var_decl (objc_module_template, \"_OBJC_MODULES\");\n@@ -3994,7 +4021,7 @@ build_next_objc_exception_stuff (void)\n   tree field_decl, field_decl_chain, index, temp_type;\n \n   objc_exception_data_template\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n+    = objc_start_struct (get_identifier (UTAG_EXCDATA));\n \n   /* int buf[OBJC_JBLEN]; */\n \n@@ -4010,7 +4037,7 @@ build_next_objc_exception_stuff (void)\n \t\t\t\t  \"pointers\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_exception_data_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_exception_data_template, field_decl_chain);\n \n   /* int _setjmp(...); */\n   /* If the user includes <setjmp.h>, this shall be superseded by\n@@ -4157,8 +4184,7 @@ build_protocol_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n-  objc_protocol_template = start_struct (RECORD_TYPE,\n-\t\t\t\t\t get_identifier (UTAG_PROTOCOL));\n+  objc_protocol_template = objc_start_struct (get_identifier (UTAG_PROTOCOL));\n \n   /* struct _objc_class *isa; */\n   field_decl = create_field_decl (build_pointer_type\n@@ -4188,7 +4214,7 @@ build_protocol_template (void)\n \t\t\t\t  \"class_methods\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_protocol_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_protocol_template, field_decl_chain);\n }\n \n static tree\n@@ -4238,7 +4264,7 @@ build_method_prototype_list_template (tree list_type, int size)\n \n   /* Generate an unnamed struct definition.  */\n \n-  objc_ivar_list_record = start_struct (RECORD_TYPE, NULL_TREE);\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n \n   /* int method_count; */\n   field_decl = create_field_decl (integer_type_node, \"method_count\");\n@@ -4252,7 +4278,7 @@ build_method_prototype_list_template (tree list_type, int size)\n \t\t\t\t  \"method_list\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_ivar_list_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_ivar_list_record, field_decl_chain);\n \n   return objc_ivar_list_record;\n }\n@@ -4263,8 +4289,7 @@ build_method_prototype_template (void)\n   tree proto_record;\n   tree field_decl, field_decl_chain;\n \n-  proto_record\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_METHOD_PROTOTYPE));\n+  proto_record = objc_start_struct (get_identifier (UTAG_METHOD_PROTOTYPE));\n \n   /* SEL _cmd; */\n   field_decl = create_field_decl (objc_selector_type, \"_cmd\");\n@@ -4274,7 +4299,7 @@ build_method_prototype_template (void)\n   field_decl = create_field_decl (string_type_node, \"method_types\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (proto_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (proto_record, field_decl_chain);\n \n   return proto_record;\n }\n@@ -4759,8 +4784,7 @@ build_category_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n-  objc_category_template = start_struct (RECORD_TYPE,\n-\t\t\t\t\t get_identifier (UTAG_CATEGORY));\n+  objc_category_template = objc_start_struct (get_identifier (UTAG_CATEGORY));\n \n   /* char *category_name; */\n   field_decl = create_field_decl (string_type_node, \"category_name\");\n@@ -4787,7 +4811,7 @@ build_category_template (void)\n \t\t\t\t  \"protocol_list\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_category_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_category_template, field_decl_chain);\n }\n \n /* struct _objc_selector {\n@@ -4798,11 +4822,9 @@ build_category_template (void)\n static void\n build_selector_template (void)\n {\n-\n   tree field_decl, field_decl_chain;\n \n-  objc_selector_template\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_SELECTOR));\n+  objc_selector_template = objc_start_struct (get_identifier (UTAG_SELECTOR));\n \n   /* SEL sel_id; */\n   field_decl = create_field_decl (objc_selector_type, \"sel_id\");\n@@ -4812,7 +4834,7 @@ build_selector_template (void)\n   field_decl = create_field_decl (string_type_node, \"sel_type\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_selector_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_selector_template, field_decl_chain);\n }\n \n /* struct _objc_class {\n@@ -4848,8 +4870,7 @@ build_class_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n-  objc_class_template\n-    = start_struct (RECORD_TYPE, get_identifier (UTAG_CLASS));\n+  objc_class_template = objc_start_struct (get_identifier (UTAG_CLASS));\n \n   /* struct _objc_class *isa; */\n   field_decl = create_field_decl (build_pointer_type (objc_class_template),\n@@ -4942,7 +4963,7 @@ build_class_template (void)\n \t\t\t\t  \"gc_object_type\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_class_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_class_template, field_decl_chain);\n }\n \n /* Generate appropriate forward declarations for an implementation.  */\n@@ -5043,7 +5064,7 @@ build_super_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n-  objc_super_template = start_struct (RECORD_TYPE, get_identifier (UTAG_SUPER));\n+  objc_super_template = objc_start_struct (get_identifier (UTAG_SUPER));\n \n   /* struct _objc_object *self; */\n   field_decl = create_field_decl (objc_object_type, \"self\");\n@@ -5054,7 +5075,7 @@ build_super_template (void)\n \t\t\t\t  \"super_class\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_super_template, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_super_template, field_decl_chain);\n }\n \n /* struct _objc_ivar {\n@@ -5070,7 +5091,7 @@ build_ivar_template (void)\n   tree field_decl, field_decl_chain;\n \n   objc_ivar_id = get_identifier (UTAG_IVAR);\n-  objc_ivar_record = start_struct (RECORD_TYPE, objc_ivar_id);\n+  objc_ivar_record = objc_start_struct (objc_ivar_id);\n \n   /* char *ivar_name; */\n   field_decl = create_field_decl (string_type_node, \"ivar_name\");\n@@ -5084,7 +5105,7 @@ build_ivar_template (void)\n   field_decl = create_field_decl (integer_type_node, \"ivar_offset\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_ivar_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_ivar_record, field_decl_chain);\n \n   return objc_ivar_record;\n }\n@@ -5100,7 +5121,7 @@ build_ivar_list_template (tree list_type, int size)\n   tree objc_ivar_list_record;\n   tree field_decl, field_decl_chain;\n \n-  objc_ivar_list_record = start_struct (RECORD_TYPE, NULL_TREE);\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n \n   /* int ivar_count; */\n   field_decl = create_field_decl (integer_type_node, \"ivar_count\");\n@@ -5114,7 +5135,7 @@ build_ivar_list_template (tree list_type, int size)\n \t\t\t\t  \"ivar_list\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_ivar_list_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_ivar_list_record, field_decl_chain);\n \n   return objc_ivar_list_record;\n }\n@@ -5131,7 +5152,7 @@ build_method_list_template (tree list_type, int size)\n   tree objc_ivar_list_record;\n   tree field_decl, field_decl_chain;\n \n-  objc_ivar_list_record = start_struct (RECORD_TYPE, NULL_TREE);\n+  objc_ivar_list_record = objc_start_struct (NULL_TREE);\n \n   /* struct _objc__method_prototype_list *method_next; */\n   field_decl = create_field_decl (objc_method_proto_list_ptr,\n@@ -5150,7 +5171,7 @@ build_method_list_template (tree list_type, int size)\n \t\t\t\t  \"method_list\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (objc_ivar_list_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (objc_ivar_list_record, field_decl_chain);\n \n   return objc_ivar_list_record;\n }\n@@ -5338,7 +5359,7 @@ build_method_template (void)\n   tree _SLT_record;\n   tree field_decl, field_decl_chain;\n \n-  _SLT_record = start_struct (RECORD_TYPE, get_identifier (UTAG_METHOD));\n+  _SLT_record = objc_start_struct (get_identifier (UTAG_METHOD));\n \n   /* SEL _cmd; */\n   field_decl = create_field_decl (objc_selector_type, \"_cmd\");\n@@ -5353,7 +5374,7 @@ build_method_template (void)\n \t\t\t\t  \"_imp\");\n   chainon (field_decl_chain, field_decl);\n \n-  finish_struct (_SLT_record, field_decl_chain, NULL_TREE);\n+  objc_finish_struct (_SLT_record, field_decl_chain);\n \n   return _SLT_record;\n }"}, {"sha": "4a4067d3bd7fea6a2330e2ef9895793fb94f6bcf", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,3 +1,9 @@\n+2009-05-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objcp-decl.h (start_struct): Add three new, ignored, macro\n+\tparameters.\n+\t(finish_struct): Add two new, ignored, macro parameters.\n+\n 2009-04-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* ChangeLog: Add copyright and license notices."}, {"sha": "3f6c4321e7fab095f85a9abe50ff78c8c1d2e03b", "filename": "gcc/objcp/objcp-decl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjcp%2Fobjcp-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fobjcp%2Fobjcp-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,6 +1,6 @@\n /* Process the ObjC-specific declarations and variables for \n    the Objective-C++ compiler.\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n This file is part of GCC.\n@@ -37,9 +37,9 @@ extern tree objcp_end_compound_stmt (tree, int);\n    invoke the original C++ functions if needed).  */\n #ifdef OBJCP_REMAP_FUNCTIONS\n \n-#define start_struct(code, name) \\\n+#define start_struct(code, name, in_struct, struct_types, loc) \\\n \tobjcp_start_struct (code, name)\n-#define finish_struct(t, fieldlist, attributes) \\\n+#define finish_struct(t, fieldlist, attributes, in_struct, struct_types) \\\n \tobjcp_finish_struct (t, fieldlist, attributes)\n #define finish_function() \\\n \tobjcp_finish_function ()"}, {"sha": "ff38ff849efd8d001cee07c1e6f00cce70e1e65a", "filename": "gcc/regmove.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -50,9 +50,16 @@ static void optimize_reg_copy_2 (rtx, rtx, rtx);\n static void optimize_reg_copy_3 (rtx, rtx, rtx);\n static void copy_src_to_dest (rtx, rtx, rtx);\n \n+enum match_use\n+{\n+  READ,\n+  WRITE,\n+  READWRITE\n+};\n+\n struct match {\n   int with[MAX_RECOG_OPERANDS];\n-  enum { READ, WRITE, READWRITE } use[MAX_RECOG_OPERANDS];\n+  enum match_use use[MAX_RECOG_OPERANDS];\n   int commutative[MAX_RECOG_OPERANDS];\n   int early_clobber[MAX_RECOG_OPERANDS];\n };"}, {"sha": "1b6a0345a01443c4d83fbcb90b1f0f268b4a72c2", "filename": "gcc/sched-int.h", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,7 +1,8 @@\n /* Instruction scheduling pass.  This file contains definitions used\n    internally in the scheduler.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -425,6 +426,24 @@ enum reg_pending_barrier_mode\n   TRUE_BARRIER\n };\n \n+/* Whether a register movement is associated with a call.  */\n+enum post_call_group\n+{\n+  not_post_call,\n+  post_call,\n+  post_call_initial\n+};\n+\n+/* Insns which affect pseudo-registers.  */\n+struct deps_reg\n+{\n+  rtx uses;\n+  rtx sets;\n+  rtx clobbers;\n+  int uses_length;\n+  int clobbers_length;\n+};\n+\n /* Describe state of dependencies used during sched_analyze phase.  */\n struct deps\n {\n@@ -488,7 +507,7 @@ struct deps\n \n   /* Used to keep post-call pseudo/hard reg movements together with\n      the call.  */\n-  enum { not_post_call, post_call, post_call_initial } in_post_call_group_p;\n+  enum post_call_group in_post_call_group_p;\n \n   /* The maximum register number for the following arrays.  Before reload\n      this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n@@ -498,14 +517,7 @@ struct deps\n      N within the current basic block; or zero, if there is no\n      such insn.  Needed for new registers which may be introduced\n      by splitting insns.  */\n-  struct deps_reg\n-    {\n-      rtx uses;\n-      rtx sets;\n-      rtx clobbers;\n-      int uses_length;\n-      int clobbers_length;\n-    } *reg_last;\n+  struct deps_reg *reg_last;\n \n   /* Element N is set for each register that has any nonzero element\n      in reg_last[N].{uses,sets,clobbers}.  */"}, {"sha": "b6935264e910f4fe08bd834fc71239feef75fc4a", "filename": "gcc/target.h", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -91,6 +91,18 @@ struct _dep;\n /* This is defined in ddg.h .  */\n struct ddg;\n \n+/* Assembler instructions for creating various kinds of integer object.  */\n+\n+struct asm_int_op\n+{\n+  const char *hi;\n+  const char *si;\n+  const char *di;\n+  const char *ti;\n+};\n+\n+/* The target structure.  This holds all the backend hooks.  */\n+\n struct gcc_target\n {\n   /* Functions that output assembler for the target.  */\n@@ -101,13 +113,7 @@ struct gcc_target\n \n     /* Assembler instructions for creating various kinds of integer object.  */\n     const char *byte_op;\n-    struct asm_int_op\n-    {\n-      const char *hi;\n-      const char *si;\n-      const char *di;\n-      const char *ti;\n-    } aligned_op, unaligned_op;\n+    struct asm_int_op aligned_op, unaligned_op;\n \n     /* Try to output the assembler code for an integer object whose\n        value is given by X.  SIZE is the size of the object in bytes and"}, {"sha": "ca5cf9f7cc969e595e30b0b8d218b3614163ab6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,3 +1,12 @@\n+2009-05-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wcxx-compat-7.c: New testcase.\n+\t* gcc.dg/Wcxx-compat-8.c: New testcase.\n+\t* gcc.dg/c99-tag-1.c: Recognize new \"originally defined here\"\n+\tnotes\n+\t* gcc.dg/pr17188-1.c: Likewise.\n+\t* gcc.dg/pr39084.c: Likewise.\n+\n 2009-05-10  Michael Matz  <matz@suse.de>\n \n \tPR target/40031"}, {"sha": "bccbd1107b6c3c2b972a3f16272ace95c922f393", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-7.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-7.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+\n+struct s1\n+{\n+  enum e1\t/* { dg-message \"note: enum type defined here\" } */\n+  {\n+    A,\t\t/* { dg-message \"note: enum constant defined here\" } */\n+    B\n+  } f1;\n+  struct s2\t/* { dg-message \"note: struct defined here\" } */\n+  {\n+    struct s3\t/* { dg-message \"note: struct defined here\" } */\n+    {\n+      enum e1 f3;\n+      struct s1 *p1;\n+      struct s2 *p2;\n+      struct s3 *p3;\n+    } f2;\n+    union u1\t/* { dg-message \"note: union defined here\" } */\n+    {\n+      int f4;\n+    } f5;\n+    struct s3 f6;\n+  } f7;\n+  struct s2 f8;\n+  enum e1 f9;\n+};\n+\n+struct s1 v1;\n+enum e1 v2;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */\n+struct s2 v3;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */\n+struct s3 v4;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */\n+union u1 v5;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */\n+int i = A;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */"}, {"sha": "a7343ba91e6e1c038c33c6142c2a95501f06abd6", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-8.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-8.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+\n+struct s1\n+{\n+  enum e1\t/* { dg-message \"note: enum type defined here\" } */\n+  {\n+    A = sizeof (struct s2 { int i; }),\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+    B\n+  } f1;\n+};\n+struct s2 v1;\t/* Don't issue another warning about s2.  */\n+enum e1 v2;\t/* { dg-warning \"not visible in C\\[+\\]\\[+\\]\" } */\n+\n+enum e2\n+{\n+  C = sizeof (struct s3 { int i; }),\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  D = __alignof__ (struct s4 { int i; }), /* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  E\n+};\n+\n+struct s3 v3;\n+int v4 = C;\n+\n+__typeof__ (struct s5 { int i; }) v5; /* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+int\n+f1 (struct s1 *p)\n+{\n+  return ((struct s6 { int j; } *) p)->j;  /* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+}\n+\n+int\n+f2 (struct s1 *p)\n+{\n+  return (__extension__ (struct s7 { int j; } *)p)->j;\n+}\n+\n+int\n+f3 ()\n+{\n+  return (struct s8 { int i; }) { 0 }.i;  /* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+}"}, {"sha": "dd525317d03e4573d7d815bc681e4fe172771c7f", "filename": "gcc/testsuite/gcc.dg/c99-tag-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-1.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -24,7 +24,7 @@ foo (void)\n   /* A specific type shall have its content defined at most once.  But we\n      may redeclare the tag in different scopes.  */\n   {\n-    struct s0 { int i; };\n+    struct s0 { int i; }; /* { dg-message \"note: originally defined here\" } */\n     {\n       struct s0 { long l; };\n     }\n@@ -33,7 +33,7 @@ foo (void)\n     }\n     struct s0 { int i; }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n     /* { dg-error \"rede\" \"struct redef\" { target *-*-* } 34 } */\n-    union u0 { int i; };\n+    union u0 { int i; }; /* { dg-message \"note: originally defined here\" } */\n     {\n       union u0 { long l; };\n     }\n@@ -42,7 +42,7 @@ foo (void)\n     }\n     union u0 { int i; }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n     /* { dg-error \"rede\" \"union redef\" { target *-*-* } 43 } */\n-    enum e0 { E0A };\n+    enum e0 { E0A }; /* { dg-message \"note: originally defined here\" } */\n     {\n       enum e0 { E0B };\n     }"}, {"sha": "522a14f7d75f89eff8ba4e73aa78e8a1980d39c1", "filename": "gcc/testsuite/gcc.dg/pr17188-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr17188-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr17188-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr17188-1.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -5,20 +5,20 @@\n /* { dg-do compile } */\n /* { dg-options \"\" } */\n \n-struct s0 { };\n+struct s0 { }; /* { dg-message \"note: originally defined here\" } */\n struct s0;\n struct s0 { }; /* { dg-error \"redefinition of 'struct s0'\" } */\n \n-struct s1 { };\n+struct s1 { }; /* { dg-message \"note: originally defined here\" } */\n struct s1 { }; /* { dg-error \"redefinition of 'struct s1'\" } */\n \n-struct s2 { int a : 1; };\n+struct s2 { int a : 1; }; /* { dg-message \"note: originally defined here\" } */\n struct s2 { int a : 1; }; /* { dg-error \"redefinition of 'struct s2'\" } */\n \n-struct s3 { };\n+struct s3 { }; /* { dg-message \"note: originally defined here\" } */\n struct s3 { int a : 1; }; /* { dg-error \"redefinition of 'struct s3'\" } */\n \n-struct s4 { int a : 1; };\n+struct s4 { int a : 1; }; /* { dg-message \"note: originally defined here\" } */\n struct s4 { }; /* { dg-error \"redefinition of 'struct s4'\" } */\n \n struct s5 { int a : 1; };"}, {"sha": "ff731492154bc4c47acda49ab09fb4ae0cb15688", "filename": "gcc/testsuite/gcc.dg/pr39084.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39084.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39084.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39084.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n \n-struct color { int i; };\n+struct color { int i; }; /* { dg-message \"note: originally defined here\" } */\n static const struct color col;\n struct color * f(void)\n {"}, {"sha": "204bf7e336b4d722cd953911c97331b380558a7b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -344,6 +344,26 @@ outside_finally_tree (treemple start, gimple target)\n    The eh region creation is straight-forward, but frobbing all the gotos\n    and such into shape isn't.  */\n \n+/* The GOTO_QUEUE is is an array of GIMPLE_GOTO and GIMPLE_RETURN\n+   statements that are seen to escape this GIMPLE_TRY_FINALLY node.\n+   The idea is to record a gimple statement for everything except for\n+   the conditionals, which get their labels recorded. Since labels are\n+   of type 'tree', we need this node to store both gimple and tree\n+   objects.  REPL_STMT is the sequence used to replace the goto/return\n+   statement.  CONT_STMT is used to store the statement that allows\n+   the return/goto to jump to the original destination. */\n+\n+struct goto_queue_node\n+{\n+  treemple stmt;\n+  gimple_seq repl_stmt;\n+  gimple cont_stmt;\n+  int index;\n+  /* This is used when index >= 0 to indicate that stmt is a label (as\n+     opposed to a goto stmt).  */\n+  int is_label;\n+};\n+\n /* State of the world while lowering.  */\n \n struct leh_state\n@@ -377,23 +397,8 @@ struct leh_tf_state\n   /* The exception region created for it.  */\n   struct eh_region *region;\n \n-  /* The GOTO_QUEUE is is an array of GIMPLE_GOTO and GIMPLE_RETURN statements\n-     that are seen to escape this GIMPLE_TRY_FINALLY node.\n-     The idea is to record a gimple statement for everything except for \n-     the conditionals, which get their labels recorded. Since labels are of\n-     type 'tree', we need this node to store both gimple and tree objects.\n-     REPL_STMT is the sequence used to replace the goto/return statement.\n-     CONT_STMT is used to store the statement that allows the return/goto to\n-     jump to the original destination. */\n-  struct goto_queue_node {\n-    treemple stmt;\n-    gimple_seq repl_stmt;\n-    gimple cont_stmt;\n-    int index;\n-    /* this is used when index >= 0 to indicate that stmt is a label(as\n-       opposed to a goto stmt) */\n-    int is_label;\n-  } *goto_queue;\n+  /* The goto queue.  */\n+  struct goto_queue_node *goto_queue;\n   size_t goto_queue_size;\n   size_t goto_queue_active;\n "}, {"sha": "1214c95dd0b755ab2f8bd79d34f28f7ac0b93586", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -1,5 +1,6 @@\n /* Tree inlining hooks and declarations.\n-   Copyright 2001, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright 2001, 2003, 2004, 2005, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -24,6 +25,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n \n \n+/* Indicate the desired behavior wrt call graph edges.  We can either\n+   duplicate the edge (inlining, cloning), move the edge (versioning,\n+   parallelization), or move the edges of the clones (saving).  */\n+\n+enum copy_body_cge_which\n+{\n+  CB_CGE_DUPLICATE,\n+  CB_CGE_MOVE,\n+  CB_CGE_MOVE_CLONES\n+};\n+\n /* Data required for function body duplication.  */\n \n typedef struct copy_body_data\n@@ -75,14 +87,8 @@ typedef struct copy_body_data\n      than enumerating the different cases, we categorize the behavior\n      in the various situations.  */\n \n-  /* Indicate the desired behavior wrt call graph edges.  We can either\n-     duplicate the edge (inlining, cloning), move the edge (versioning,\n-     parallelization), or move the edges of the clones (saving).  */\n-  enum copy_body_cge_which {\n-    CB_CGE_DUPLICATE,\n-    CB_CGE_MOVE,\n-    CB_CGE_MOVE_CLONES\n-  } transform_call_graph_edges;\n+  /* What to do with call graph edges.  */\n+  enum copy_body_cge_which transform_call_graph_edges;\n \n   /* True if a new CFG should be created.  False for inlining, true for\n      everything else.  */"}, {"sha": "464de5e0cdb0cc00012c0f6fc898d2f30b110939", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b97832e7fdb1be20e493105798dac42999c34a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=24b97832e7fdb1be20e493105798dac42999c34a", "patch": "@@ -94,17 +94,22 @@ extern const char *dump_file_name;\n /* Return the dump_file_info for the given phase.  */\n extern struct dump_file_info *get_dump_file_info (int);\n \n+/* Optimization pass type.  */\n+enum opt_pass_type\n+{\n+  GIMPLE_PASS,\n+  RTL_PASS,\n+  SIMPLE_IPA_PASS,\n+  IPA_PASS\n+};\n+\n /* Describe one pass; this is the common part shared across different pass\n    types.  */\n struct opt_pass\n {\n   /* Optimization pass type.  */\n-  enum opt_pass_type {\n-    GIMPLE_PASS,\n-    RTL_PASS,\n-    SIMPLE_IPA_PASS,\n-    IPA_PASS\n-  } type;\n+  enum opt_pass_type type;\n+\n   /* Terse name of the pass used as a fragment of the dump file\n      name.  If the name starts with a star, no dump happens. */\n   const char *name;"}]}