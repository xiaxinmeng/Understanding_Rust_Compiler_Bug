{"sha": "9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "node_id": "C_kwDOANBUbNoAKDlmNjVlZWNkYmVmNjAyNzcyMmU5M2FhZGYzZmE2YjNjYzM0MmViNGY", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-09-28T16:20:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-09-28T20:43:07Z"}, "message": "c++: Add DECL_NTTP_OBJECT_P lang flag\n\nVAR_DECLs for NTTPs need to be handled specially by module streaming,\nin the same manner to type info decls.  This reworks their handling to\nallow that work to drop in.  We use DECL_LANG_FLAG_5 to indicate such\ndecls (I didn't notice template_parm_object_p, which looks at the\nmangled name -- anyway a bit flag on the node is better, IMHO).  We\nbreak apart the creation routine, so there's now an entry point the\nmodule machinery can use directly.\n\n\tgcc/cp/\n\t* cp-tree.h (DECL_NTTP_OBJECT_P): New.\n\t(template_parm_object_p): Delete.\n\t(build_template_parm_object): Declare.\n\t* cxx-pretty-print.cc (pp_cx_template_argument_list): Use DECL_NTTP_OBJECT_P.\n\t* error.cc (dump_simple_decl): Likewise.\n\t* mangle.cc (write_template_arg): Likewise.\n\t* pt.cc (template_parm_object_p): Delete.\n\t(create_template_parm_object): Separated out checking from ...\n\t(get_template_parm_object): ... this, new external entry point.", "tree": {"sha": "f48eebe3d44d85a5326b75a3a609ebc0b3a8c5fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f48eebe3d44d85a5326b75a3a609ebc0b3a8c5fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db288230db55dc1ff626f46c708b555847013a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db288230db55dc1ff626f46c708b555847013a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db288230db55dc1ff626f46c708b555847013a41"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "d0f1b18b0158313c8b051ebec0b77c68a4fa9f96", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "patch": "@@ -518,6 +518,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       CALL_EXPR_REVERSE_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n       CONSTRUCTOR_PLACEHOLDER_BOUNDARY (in CONSTRUCTOR)\n       OVL_EXPORT_P (in OVERLOAD)\n+      DECL_NTTP_OBJECT_P (in VAR_DECL)\n    6: TYPE_MARKED_P (in _TYPE)\n       DECL_NONTRIVIALLY_INITIALIZED_P (in VAR_DECL)\n       RANGE_FOR_IVDEP (in RANGE_FOR_STMT)\n@@ -3548,6 +3549,10 @@ struct GTY(()) lang_decl {\n #define DECL_TINFO_P(NODE)\t\t\t\\\n   TREE_LANG_FLAG_4 (TREE_CHECK2 (NODE,VAR_DECL,TYPE_DECL))\n \n+/* true iff VAR_DECL node NODE is a NTTP object decl.  */\n+#define DECL_NTTP_OBJECT_P(NODE)\t\t\t\\\n+  TREE_LANG_FLAG_5 (TREE_CHECK (NODE,VAR_DECL))\n+\n /* 1 iff VAR_DECL node NODE is virtual table or VTT.  We forward to\n    DECL_VIRTUAL_P from the common code, as that has the semantics we\n    need.  But we want a more descriptive name.  */\n@@ -7414,7 +7419,7 @@ extern bool alias_type_or_template_p            (tree);\n enum { nt_opaque = false, nt_transparent = true };\n extern tree alias_template_specialization_p     (const_tree, bool);\n extern tree dependent_alias_template_spec_p     (const_tree, bool);\n-extern bool template_parm_object_p\t\t(const_tree);\n+extern tree get_template_parm_object\t\t(tree expr, tree mangle);\n extern tree tparm_object_argument\t\t(tree);\n extern bool explicit_class_specialization_p     (tree);\n extern bool push_tinst_level                    (tree);"}, {"sha": "bbd51bb562ae3463b2c52b2f4b1e224c546fb08b", "filename": "gcc/cp/cxx-pretty-print.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fcxx-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fcxx-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.cc?ref=9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "patch": "@@ -1956,7 +1956,7 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n \t  if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n \t\t\t       && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n \t    pp->type_id (arg);\n-\t  else if (template_parm_object_p (arg))\n+\t  else if (TREE_CODE (arg) == VAR_DECL && DECL_NTTP_OBJECT_P (arg))\n \t    pp->expression (DECL_INITIAL (arg));\n \t  else\n \t    pp->expression (arg);"}, {"sha": "53904e3669d92b7303f6b52086a3ab42c473a146", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "patch": "@@ -1129,7 +1129,7 @@ dump_global_iord (cxx_pretty_printer *pp, tree t)\n static void\n dump_simple_decl (cxx_pretty_printer *pp, tree t, tree type, int flags)\n {\n-  if (template_parm_object_p (t))\n+  if (TREE_CODE (t) == VAR_DECL && DECL_NTTP_OBJECT_P (t))\n     return dump_expr (pp, DECL_INITIAL (t), flags);\n \n   if (flags & TFF_DECL_SPECIFIERS)"}, {"sha": "1a455858827286d08c55e65596fc720037325173", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "patch": "@@ -3672,7 +3672,7 @@ write_template_arg (tree node)\n \t}\n     }\n \n-  if (template_parm_object_p (node))\n+  if (TREE_CODE (node) == VAR_DECL && DECL_NTTP_OBJECT_P (node))\n     /* We want to mangle the argument, not the var we stored it in.  */\n     node = tparm_object_argument (node);\n "}, {"sha": "c7adaef997d77287f09727ffd8bd91d194309ab0", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "patch": "@@ -7112,16 +7112,6 @@ unify_template_argument_mismatch (bool explain_p, tree parm, tree arg)\n   return unify_invalid (explain_p);\n }\n \n-/* True if T is a C++20 template parameter object to store the argument for a\n-   template parameter of class type.  */\n-\n-bool\n-template_parm_object_p (const_tree t)\n-{\n-  return (TREE_CODE (t) == VAR_DECL && DECL_ARTIFICIAL (t) && DECL_NAME (t)\n-\t  && startswith (IDENTIFIER_POINTER (DECL_NAME (t)), \"_ZTA\"));\n-}\n-\n /* Subroutine of convert_nontype_argument, to check whether EXPR, as an\n    argument for TYPE, points to an unsuitable object.\n \n@@ -7256,16 +7246,11 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n \n }\n \n-/* The template arguments corresponding to template parameter objects of types\n-   that contain pointers to members.  */\n-\n-static GTY(()) hash_map<tree, tree> *tparm_obj_values;\n-\n /* Return a VAR_DECL for the C++20 template parameter object corresponding to\n    template argument EXPR.  */\n \n static tree\n-get_template_parm_object (tree expr, tsubst_flags_t complain)\n+create_template_parm_object (tree expr, tsubst_flags_t complain)\n {\n   if (TREE_CODE (expr) == TARGET_EXPR)\n     expr = TARGET_EXPR_INITIAL (expr);\n@@ -7283,13 +7268,27 @@ get_template_parm_object (tree expr, tsubst_flags_t complain)\n   /* This is no longer a compound literal.  */\n   gcc_assert (!TREE_HAS_CONSTRUCTOR (expr));\n \n-  tree name = mangle_template_parm_object (expr);\n+  return get_template_parm_object (expr, mangle_template_parm_object (expr));\n+}\n+\n+/* The template arguments corresponding to template parameter objects of types\n+   that contain pointers to members.  */\n+\n+static GTY(()) hash_map<tree, tree> *tparm_obj_values;\n+\n+/* Find or build an nttp object for (already-validated) EXPR with name\n+   NAME.  */\n+\n+tree\n+get_template_parm_object (tree expr, tree name)\n+{\n   tree decl = get_global_binding (name);\n   if (decl)\n     return decl;\n \n   tree type = cp_build_qualified_type (TREE_TYPE (expr), TYPE_QUAL_CONST);\n   decl = create_temporary_var (type);\n+  DECL_NTTP_OBJECT_P (decl) = true;\n   DECL_CONTEXT (decl) = NULL_TREE;\n   TREE_STATIC (decl) = true;\n   DECL_DECLARED_CONSTEXPR_P (decl) = true;\n@@ -7776,7 +7775,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       /* Replace the argument with a reference to the corresponding template\n \t parameter object.  */\n       if (!val_dep_p)\n-\texpr = get_template_parm_object (expr, complain);\n+\texpr = create_template_parm_object (expr, complain);\n       if (expr == error_mark_node)\n \treturn NULL_TREE;\n     }"}]}