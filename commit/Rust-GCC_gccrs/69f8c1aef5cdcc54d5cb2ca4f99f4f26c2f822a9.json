{"sha": "69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmOGMxYWVmNWNkY2M1NGQ1Y2IyY2E0Zjk5ZjRmMjZjMmY4MjJhOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-08T13:39:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-08T13:39:03Z"}, "message": "tree-vectorizer.h (_stmt_vec_info::v_reduc_type): Remove.\n\n2019-10-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::v_reduc_type): Remove.\n\t(_stmt_vec_info::is_reduc_info): Add.\n\t(STMT_VINFO_VEC_REDUCTION_TYPE): Remove.\n\t(vectorizable_condition): Remove.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_reduction): Adjust.\n\t(info_for_reduction): New.\n\t* tree-vect-loop.c (vect_force_simple_reduction): Fold into...\n\t(vect_analyze_scalar_cycles_1): ... here.\n\t(vect_analyze_loop_operations): Adjust.\n\t(needs_fold_left_reduction_p): Simplify for single caller.\n\t(vect_is_simple_reduction): Likewise.  Remove stmt restriction\n\tfor nested cycles not part of double reductions.\n\t(vect_model_reduction_cost): Pass in the reduction type.\n\t(info_for_reduction): New function.\n\t(vect_create_epilog_for_reduction): Use it, access reduction\n\tmeta off the stmt info it returns.  Use STMT_VINFO_REDUC_TYPE\n\tinstead of STMT_VINFO_VEC_REDUCTION_TYPE.\n\t(vectorize_fold_left_reduction): Remove pointless assert.\n\t(vectorizable_reduction): Analyze the full reduction when\n\tvisiting the outermost PHI.  Simplify.  Use STMT_VINFO_REDUC_TYPE\n\tinstead of STMT_VINFO_VEC_REDUCTION_TYPE.  Direct reduction\n\tstmt code-generation to vectorizable_* in most cases.  Verify\n\tcode-generation only for cases handled by\n\tvect_transform_reductuon.\n\t(vect_transform_reduction): Use info_for_reduction to get at\n\treduction meta.  Simplify.\n\t(vect_transform_cycle_phi): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Look\n\tat the PHI node for STMT_VINFO_REDUC_TYPE.\n\t* tree-vect-slp.c (vect_schedule_slp_instance): Remove no\n\tlonger necessary code.\n\t* tree-vect-stmts.c (vectorizable_shift): Make static again.\n\t(vectorizable_condition): Likewise.  Get at reduction related\n\tinfo via info_for_reduction.\n\t(vect_analyze_stmt): Adjust.\n\t(vect_transform_stmt): Likewise.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize\n\tSTMT_VINFO_REDUC_TYPE instead of STMT_VINFO_VEC_REDUCTION_TYPE.\n\n\t* gcc.dg/vect/pr65947-1.c: Adjust.\n\t* gcc.dg/vect/pr65947-13.c: Likewise.\n\t* gcc.dg/vect/pr65947-14.c: Likewise.\n\t* gcc.dg/vect/pr65947-4.c: Likewise.\n\t* gcc.dg/vect/pr80631-1.c: Likewise.\n\t* gcc.dg/vect/pr80631-2.c: Likewise.\n\nFrom-SVN: r276700", "tree": {"sha": "0ddd2e9b5af7bef9115a71ac714f0b9ab32281a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ddd2e9b5af7bef9115a71ac714f0b9ab32281a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65b67cf390bc0240a91730e8eb95d7a7b2d8aca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b67cf390bc0240a91730e8eb95d7a7b2d8aca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b67cf390bc0240a91730e8eb95d7a7b2d8aca0"}], "stats": {"total": 808, "additions": 379, "deletions": 429}, "files": [{"sha": "984a05d07565300ddaf610d67ac39a205c91d123", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -1,3 +1,46 @@\n+2019-10-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::v_reduc_type): Remove.\n+\t(_stmt_vec_info::is_reduc_info): Add.\n+\t(STMT_VINFO_VEC_REDUCTION_TYPE): Remove.\n+\t(vectorizable_condition): Remove.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_reduction): Adjust.\n+\t(info_for_reduction): New.\n+\t* tree-vect-loop.c (vect_force_simple_reduction): Fold into...\n+\t(vect_analyze_scalar_cycles_1): ... here.\n+\t(vect_analyze_loop_operations): Adjust.\n+\t(needs_fold_left_reduction_p): Simplify for single caller.\n+\t(vect_is_simple_reduction): Likewise.  Remove stmt restriction\n+\tfor nested cycles not part of double reductions.\n+\t(vect_model_reduction_cost): Pass in the reduction type.\n+\t(info_for_reduction): New function.\n+\t(vect_create_epilog_for_reduction): Use it, access reduction\n+\tmeta off the stmt info it returns.  Use STMT_VINFO_REDUC_TYPE\n+\tinstead of STMT_VINFO_VEC_REDUCTION_TYPE.\n+\t(vectorize_fold_left_reduction): Remove pointless assert.\n+\t(vectorizable_reduction): Analyze the full reduction when\n+\tvisiting the outermost PHI.  Simplify.  Use STMT_VINFO_REDUC_TYPE\n+\tinstead of STMT_VINFO_VEC_REDUCTION_TYPE.  Direct reduction\n+\tstmt code-generation to vectorizable_* in most cases.  Verify\n+\tcode-generation only for cases handled by\n+\tvect_transform_reductuon.\n+\t(vect_transform_reduction): Use info_for_reduction to get at\n+\treduction meta.  Simplify.\n+\t(vect_transform_cycle_phi): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Look\n+\tat the PHI node for STMT_VINFO_REDUC_TYPE.\n+\t* tree-vect-slp.c (vect_schedule_slp_instance): Remove no\n+\tlonger necessary code.\n+\t* tree-vect-stmts.c (vectorizable_shift): Make static again.\n+\t(vectorizable_condition): Likewise.  Get at reduction related\n+\tinfo via info_for_reduction.\n+\t(vect_analyze_stmt): Adjust.\n+\t(vect_transform_stmt): Likewise.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize\n+\tSTMT_VINFO_REDUC_TYPE instead of STMT_VINFO_VEC_REDUCTION_TYPE.\n+\n 2019-10-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/invoke.texi (-ffp-int-builtin-inexact): Document"}, {"sha": "fb2264fa2ba220c1b179842532c0b537ac68a79b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -1,3 +1,12 @@\n+2019-10-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/pr65947-1.c: Adjust.\n+\t* gcc.dg/vect/pr65947-13.c: Likewise.\n+\t* gcc.dg/vect/pr65947-14.c: Likewise.\n+\t* gcc.dg/vect/pr65947-4.c: Likewise.\n+\t* gcc.dg/vect/pr80631-1.c: Likewise.\n+\t* gcc.dg/vect/pr80631-2.c: Likewise.\n+\n 2019-10-08  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* gfortran.dg/goacc/continuation-free-form.f95: Update dg-error."}, {"sha": "b81baed914c8b606ffd60dfad863d79fb67eb8e7", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -42,4 +42,4 @@ main (void)\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { target { ! vect_fold_extract_last } } } } */"}, {"sha": "4ad5262019a6bb50608f5569b32af8af1602a9d8", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -41,5 +41,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { xfail vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { xfail vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */"}, {"sha": "d0194f237d4dc28079711366b5433e6cd975ad81", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -42,4 +42,4 @@ main (void)\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { target { ! vect_fold_extract_last } } } } */"}, {"sha": "405571047158143e8b01e320961602d1e088bf1a", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -42,5 +42,5 @@ main (void)\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { target { ! vect_fold_extract_last } } } } */\n "}, {"sha": "b531fe6dbf9420baa973ea178a7cd540f2706e80", "filename": "gcc/testsuite/gcc.dg/vect/pr80631-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -73,4 +73,4 @@ main ()\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 5 \"vect\" { target vect_condition } } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 10 \"vect\" { target vect_fold_extract_last } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target { { ! vect_fold_extract_last } && vect_condition } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 5 \"vect\" { target { { ! vect_fold_extract_last } && vect_condition } } } } */"}, {"sha": "07f1a721e477a15caac29d80257dde086f82d9aa", "filename": "gcc/testsuite/gcc.dg/vect/pr80631-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -72,5 +72,5 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 5 \"vect\" { target vect_condition } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target vect_condition xfail vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 5 \"vect\" { target vect_condition xfail vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 10 \"vect\" { target vect_fold_extract_last } } } */"}, {"sha": "f63bb8556181ddd518fb32a6ae32da53a67adfe3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 252, "deletions": 339, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -154,8 +154,8 @@ along with GCC; see the file COPYING3.  If not see\n */\n \n static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n-static stmt_vec_info vect_force_simple_reduction (loop_vec_info, stmt_vec_info,\n-\t\t\t\t\t\t  bool *, bool);\n+static stmt_vec_info vect_is_simple_reduction (loop_vec_info, stmt_vec_info,\n+\t\t\t\t\t       bool *);\n \n /* Subroutine of vect_determine_vf_for_stmt that handles only one\n    statement.  VECTYPE_MAYBE_SET_P is true if STMT_VINFO_VECTYPE\n@@ -561,19 +561,19 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop)\n \t\t  && STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n \n       stmt_vec_info reduc_stmt_info\n-\t= vect_force_simple_reduction (loop_vinfo, stmt_vinfo,\n-\t\t\t\t       &double_reduc, false);\n+\t= vect_is_simple_reduction (loop_vinfo, stmt_vinfo, &double_reduc);\n       if (reduc_stmt_info)\n         {\n-          if (double_reduc)\n-            {\n-              if (dump_enabled_p ())\n-                dump_printf_loc (MSG_NOTE, vect_location,\n+\t  STMT_VINFO_REDUC_DEF (stmt_vinfo) = reduc_stmt_info;\n+\t  STMT_VINFO_REDUC_DEF (reduc_stmt_info) = stmt_vinfo;\n+\t  if (double_reduc)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"Detected double reduction.\\n\");\n \n               STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_double_reduction_def;\n-\t      STMT_VINFO_DEF_TYPE (reduc_stmt_info)\n-\t\t= vect_double_reduction_def;\n+\t      STMT_VINFO_DEF_TYPE (reduc_stmt_info) = vect_double_reduction_def;\n             }\n           else\n             {\n@@ -1558,8 +1558,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t\t\t    == vect_double_reduction_def)\n \t\t\t|| STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t\t       && ! PURE_SLP_STMT (stmt_info))\n-\t\tok = vectorizable_reduction (stmt_info, NULL, NULL, NULL, NULL,\n-\t\t\t\t\t     &cost_vec);\n+\t\tok = vectorizable_reduction (stmt_info, NULL, NULL, &cost_vec);\n             }\n \n \t  /* SLP PHIs are tested by vect_slp_analyze_node_operations.  */\n@@ -2554,8 +2553,7 @@ vect_valid_reduction_input_p (stmt_vec_info def_stmt_info)\n    overflow must wrap.  */\n \n static bool\n-needs_fold_left_reduction_p (tree type, tree_code code,\n-\t\t\t     bool need_wrapping_integral_overflow)\n+needs_fold_left_reduction_p (tree type, tree_code code)\n {\n   /* CHECKME: check for !flag_finite_math_only too?  */\n   if (SCALAR_FLOAT_TYPE_P (type))\n@@ -2573,10 +2571,6 @@ needs_fold_left_reduction_p (tree type, tree_code code,\n     {\n       if (!operation_no_trapping_overflow (type, code))\n \treturn true;\n-      if (need_wrapping_integral_overflow\n-\t  && !TYPE_OVERFLOW_WRAPS (type)\n-\t  && operation_can_overflow (code))\n-\treturn true;\n       return false;\n     }\n \n@@ -2752,9 +2746,7 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n \n static stmt_vec_info\n vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n-\t\t\t  bool *double_reduc,\n-\t\t\t  bool need_wrapping_integral_overflow,\n-\t\t\t  enum vect_reduction_type *v_reduc_type)\n+\t\t\t  bool *double_reduc)\n {\n   gphi *phi = as_a <gphi *> (phi_info->stmt);\n   class loop *loop = (gimple_bb (phi))->loop_father;\n@@ -2770,7 +2762,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   bool phi_def;\n \n   *double_reduc = false;\n-  *v_reduc_type = TREE_CODE_REDUCTION;\n+  STMT_VINFO_REDUC_TYPE (phi_info) = TREE_CODE_REDUCTION;\n \n   tree phi_name = PHI_RESULT (phi);\n   /* ???  If there are no uses of the PHI result the inner loop reduction\n@@ -2928,22 +2920,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \n   if (nested_in_vect_loop && !check_reduction)\n     {\n-      /* FIXME: Even for non-reductions code generation is funneled\n-\t through vectorizable_reduction for the stmt defining the\n-\t PHI latch value.  So we have to artificially restrict ourselves\n-\t for the supported operations.  */\n-      switch (get_gimple_rhs_class (code))\n-\t{\n-\tcase GIMPLE_BINARY_RHS:\n-\tcase GIMPLE_TERNARY_RHS:\n-\t  break;\n-\tdefault:\n-\t  /* Not supported by vectorizable_reduction.  */\n-\t  if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"nested cycle: not handled operation: \");\n-\t  return NULL;\n-\t}\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected nested cycle: \");\n       return def_stmt_info;\n@@ -2959,7 +2935,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   if (code == COND_EXPR)\n     {\n       if (! nested_in_vect_loop)\n-\t*v_reduc_type = COND_REDUCTION;\n+\tSTMT_VINFO_REDUC_TYPE (phi_info) = COND_REDUCTION;\n \n       op3 = gimple_assign_rhs1 (def_stmt);\n       if (COMPARISON_CLASS_P (op3))\n@@ -3043,10 +3019,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n      and therefore vectorizing reductions in the inner-loop during\n      outer-loop vectorization is safe.  */\n   if (check_reduction\n-      && *v_reduc_type == TREE_CODE_REDUCTION\n-      && needs_fold_left_reduction_p (type, code,\n-\t\t\t\t      need_wrapping_integral_overflow))\n-    *v_reduc_type = FOLD_LEFT_REDUCTION;\n+      && STMT_VINFO_REDUC_TYPE (phi_info) == TREE_CODE_REDUCTION\n+      && needs_fold_left_reduction_p (type, code))\n+    STMT_VINFO_REDUC_TYPE (phi_info) = FOLD_LEFT_REDUCTION;\n \n   /* Reduction is safe. We're dealing with one of the following:\n      1) integer arithmetic and no trapv\n@@ -3142,30 +3117,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   return NULL;\n }\n \n-/* Wrapper around vect_is_simple_reduction, which will modify code\n-   in-place if it enables detection of more reductions.  Arguments\n-   as there.  */\n-\n-static stmt_vec_info\n-vect_force_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n-\t\t\t     bool *double_reduc,\n-\t\t\t     bool need_wrapping_integral_overflow)\n-{\n-  enum vect_reduction_type v_reduc_type;\n-  stmt_vec_info def_info\n-    = vect_is_simple_reduction (loop_info, phi_info, double_reduc,\n-\t\t\t\tneed_wrapping_integral_overflow,\n-\t\t\t\t&v_reduc_type);\n-  if (def_info)\n-    {\n-      STMT_VINFO_REDUC_TYPE (phi_info) = v_reduc_type;\n-      STMT_VINFO_REDUC_DEF (phi_info) = def_info;\n-      STMT_VINFO_REDUC_TYPE (def_info) = v_reduc_type;\n-      STMT_VINFO_REDUC_DEF (def_info) = phi_info;\n-    }\n-  return def_info;\n-}\n-\n /* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n int\n vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n@@ -3754,6 +3705,7 @@ have_whole_vector_shift (machine_mode mode)\n \n static void\n vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n+\t\t\t   vect_reduction_type reduction_type,\n \t\t\t   int ncopies, stmt_vector_for_cost *cost_vec)\n {\n   int prologue_cost = 0, epilogue_cost = 0, inside_cost;\n@@ -3768,8 +3720,6 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Condition reductions generate two reductions in the loop.  */\n-  vect_reduction_type reduction_type\n-    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n   if (reduction_type == COND_REDUCTION)\n     ncopies *= 2;\n \n@@ -4208,6 +4158,32 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n     gsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n }\n \n+/* For a statement STMT_INFO taking part in a reduction operation return\n+   the stmt_vec_info the meta information is stored on.  */\n+\n+stmt_vec_info\n+info_for_reduction (stmt_vec_info stmt_info)\n+{\n+  stmt_info = vect_orig_stmt (stmt_info);\n+  gcc_assert (STMT_VINFO_REDUC_DEF (stmt_info));\n+  if (!is_a <gphi *> (stmt_info->stmt))\n+    stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n+  gphi *phi = as_a <gphi *> (stmt_info->stmt);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+    {\n+      if (gimple_phi_num_args (phi) == 1)\n+\tstmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n+    }\n+  else if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n+    {\n+      edge pe = loop_preheader_edge (gimple_bb (phi)->loop_father);\n+      stmt_vec_info info\n+\t  = stmt_info->vinfo->lookup_def (PHI_ARG_DEF_FROM_EDGE (phi, pe));\n+      if (info && STMT_VINFO_DEF_TYPE (info) == vect_double_reduction_def)\n+\tstmt_info = info;\n+    }\n+  return stmt_info;\n+}\n \n /* Function vect_create_epilog_for_reduction\n \n@@ -4261,6 +4237,8 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t\t\t  slp_tree slp_node,\n \t\t\t\t  slp_instance slp_node_instance)\n {\n+  stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n+  gcc_assert (reduc_info->is_reduc_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   /* For double reductions we need to get at the inner loop reduction\n      stmt which has the meta info attached.  Our stmt_info is that of the\n@@ -4278,8 +4256,8 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n     }\n   gphi *reduc_def_stmt\n     = as_a <gphi *> (STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))->stmt);\n-  enum tree_code code = STMT_VINFO_REDUC_CODE (stmt_info);\n-  internal_fn reduc_fn = STMT_VINFO_REDUC_FN (stmt_info);\n+  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n+  internal_fn reduc_fn = STMT_VINFO_REDUC_FN (reduc_info);\n   tree neutral_op = NULL_TREE;\n   if (slp_node)\n     neutral_op\n@@ -4345,15 +4323,14 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t\t\t\t   loop_preheader_edge (loop));\n       /* Optimize: for induction condition reduction, if we can't use zero\n          for induc_val, use initial_def.  */\n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t  == INTEGER_INDUC_COND_REDUCTION)\n-\tinduc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info);\n+      if (STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n+\tinduc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info);\n       else if (double_reduc)\n \t;\n       else if (nested_in_vect_loop)\n \t;\n       else\n-\tadjustment_def = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (stmt_info);\n+\tadjustment_def = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info);\n     }\n \n   unsigned vec_num;\n@@ -4383,7 +4360,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n      The first match will be a 1 to allow 0 to be used for non-matching\n      indexes.  If there are no matches at all then the vector will be all\n      zeroes.  */\n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+  if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION)\n     {\n       tree indx_before_incr, indx_after_incr;\n       poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -4616,7 +4593,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   else\n     new_phi_result = PHI_RESULT (new_phis[0]);\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION\n+  if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION\n       && reduc_fn != IFN_LAST)\n     {\n       /* For condition reductions, we have a vector (NEW_PHI_RESULT) containing\n@@ -4725,7 +4702,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n       scalar_results.safe_push (new_temp);\n     }\n-  else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION\n+  else if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION\n \t   && reduc_fn == IFN_LAST)\n     {\n       /* Condition reduction without supported IFN_REDUC_MAX.  Generate\n@@ -4838,8 +4815,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       gimple_set_lhs (epilog_stmt, new_temp);\n       gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n-      if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t   == INTEGER_INDUC_COND_REDUCTION)\n+      if ((STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n \t  && induc_val)\n \t{\n \t  /* Earlier we set the initial value to be a vector if induc_val\n@@ -5201,8 +5177,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n             scalar_results.safe_push (new_temp);\n         }\n \n-      if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t   == INTEGER_INDUC_COND_REDUCTION)\n+      if ((STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n \t  && induc_val)\n \t{\n \t  /* Earlier we set the initial value to be a vector if induc_val\n@@ -5486,8 +5461,6 @@ vectorize_fold_left_reduction (stmt_vec_info stmt_info,\n   gcc_assert (!nested_in_vect_loop_p (loop, stmt_info));\n   gcc_assert (ncopies == 1);\n   gcc_assert (TREE_CODE_LENGTH (code) == binary_op);\n-  gcc_assert (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t      == FOLD_LEFT_REDUCTION);\n \n   if (slp_node)\n     gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype_out),\n@@ -5762,8 +5735,7 @@ build_vect_cond_expr (enum tree_code code, tree vop[3], tree mask,\n    does *NOT* necessarily hold for reduction patterns.  */\n \n bool\n-vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n+vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\t\tslp_instance slp_node_instance,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n@@ -5774,9 +5746,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code;\n   internal_fn reduc_fn;\n-  machine_mode vec_mode;\n   int op_type;\n-  optab optab;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n   stmt_vec_info cond_stmt_vinfo = NULL;\n   tree scalar_type;\n@@ -5799,6 +5769,69 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle)\n     return false;\n \n+  /* The stmt we store reduction analysis meta on.  */\n+  stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n+  reduc_info->is_reduc_info = true;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n+    {\n+      if (is_a <gphi *> (stmt_info->stmt))\n+\t{\n+\t  /* Analysis for double-reduction is done on the outer\n+\t     loop PHI, nested cycles have no further restrictions.  */\n+\t  STMT_VINFO_TYPE (stmt_info) = cycle_phi_info_type;\n+\t  /* For nested cycles we want to let regular vectorizable_*\n+\t     routines handle code-generation.  */\n+\t  if (STMT_VINFO_DEF_TYPE (reduc_info) != vect_double_reduction_def)\n+\t    {\n+\t      stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n+\t      STMT_VINFO_DEF_TYPE (stmt_info) = vect_internal_def;\n+\t      STMT_VINFO_DEF_TYPE (vect_stmt_to_vectorize (stmt_info))\n+\t\t= vect_internal_def;\n+\t    }\n+\t}\n+      else\n+\tSTMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+      return true;\n+    }\n+\n+  stmt_vec_info orig_stmt_of_analysis = stmt_info;\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+      || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+    {\n+      if (!is_a <gphi *> (stmt_info->stmt))\n+\t{\n+\t  STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+\t  return true;\n+\t}\n+      if (slp_node)\n+\t{\n+\t  slp_node_instance->reduc_phis = slp_node;\n+\t  /* ???  We're leaving slp_node to point to the PHIs, we only\n+\t     need it to get at the number of vector stmts which wasn't\n+\t     yet initialized for the instance root.  */\n+\t}\n+      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+\tstmt_info = vect_stmt_to_vectorize (STMT_VINFO_REDUC_DEF (stmt_info));\n+      else /* STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def */\n+\t{\n+\t  use_operand_p use_p;\n+\t  gimple *use_stmt;\n+\t  bool res = single_imm_use (gimple_phi_result (stmt_info->stmt),\n+\t\t\t\t     &use_p, &use_stmt);\n+\t  gcc_assert (res);\n+\t  stmt_info = loop_vinfo->lookup_stmt (use_stmt);\n+\t  stmt_info = vect_stmt_to_vectorize (STMT_VINFO_REDUC_DEF (stmt_info));\n+\t}\n+      /* STMT_VINFO_REDUC_DEF doesn't point to the first but the last\n+         element.  */\n+      if (slp_node && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+\t{\n+\t  gcc_assert (!REDUC_GROUP_NEXT_ELEMENT (stmt_info));\n+\t  stmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n+\t}\n+    }\n+\n   if (nested_in_vect_loop_p (loop, stmt_info))\n     {\n       loop = loop->inner;\n@@ -5809,18 +5842,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     gcc_assert (slp_node\n \t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info);\n \n-  if (is_a <gphi *> (stmt_info->stmt))\n-    {\n-      /* Analysis is fully done on the reduction stmt invocation.  */\n-      gcc_assert (! vec_stmt);\n-\n-      if (slp_node)\n-\tslp_node_instance->reduc_phis = slp_node;\n-\n-      STMT_VINFO_TYPE (stmt_info) = cycle_phi_info_type;\n-      return true;\n-    }\n-\n   /* 1. Is vectorizable reduction?  */\n   /* Not supportable if the reduction variable is used in the loop, unless\n      it's a reduction chain.  */\n@@ -5898,13 +5919,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n-  stmt_vec_info reduc_def_info;\n-  if (orig_stmt_info)\n-    reduc_def_info = STMT_VINFO_REDUC_DEF (orig_stmt_info);\n-  else\n-    reduc_def_info = STMT_VINFO_REDUC_DEF (stmt_info);\n-  gcc_assert (reduc_def_info);\n-  gphi *reduc_def_phi = as_a <gphi *> (reduc_def_info->stmt);\n+  stmt_vec_info phi_info = STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info));\n+  /* PHIs should not participate in patterns.  */\n+  gcc_assert (!STMT_VINFO_RELATED_STMT (phi_info));\n+  gphi *reduc_def_phi = as_a <gphi *> (phi_info->stmt);\n   tree reduc_def = PHI_RESULT (reduc_def_phi);\n   int reduc_index = -1;\n   for (i = 0; i < op_type; i++)\n@@ -5973,7 +5991,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      directy used in stmt.  */\n   if (reduc_index == -1)\n     {\n-      if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n+      if (STMT_VINFO_REDUC_TYPE (phi_info) == FOLD_LEFT_REDUCTION)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5998,17 +6016,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  /* PHIs should not participate in patterns.  */\n-  gcc_assert (!STMT_VINFO_RELATED_STMT (reduc_def_info));\n-  enum vect_reduction_type v_reduc_type\n-    = STMT_VINFO_REDUC_TYPE (reduc_def_info);\n-  stmt_vec_info tmp = STMT_VINFO_REDUC_DEF (reduc_def_info);\n-\n-  if (!vec_stmt)\n-    STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = v_reduc_type;\n+  enum vect_reduction_type v_reduc_type = STMT_VINFO_REDUC_TYPE (phi_info);\n+  STMT_VINFO_REDUC_TYPE (reduc_info) = v_reduc_type;\n   /* If we have a condition reduction, see if we can simplify it further.  */\n-  if (v_reduc_type == COND_REDUCTION\n-      && !vec_stmt)\n+  if (v_reduc_type == COND_REDUCTION)\n     {\n       /* TODO: We can't yet handle reduction chains, since we need to treat\n \t each COND_EXPR in the chain specially, not just the last one.\n@@ -6037,7 +6048,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"optimizing condition reduction with\"\n \t\t\t     \" FOLD_EXTRACT_LAST.\\n\");\n-\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = EXTRACT_LAST_REDUCTION;\n+\t  STMT_VINFO_REDUC_TYPE (reduc_info) = EXTRACT_LAST_REDUCTION;\n \t}\n       else if (cond_reduc_dt == vect_induction_def)\n \t{\n@@ -6077,12 +6088,14 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    }\n \t  if (cond_reduc_val)\n \t    {\n-\t      STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info)\n-\t\t= cond_reduc_op_code;\n-\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info)\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"condition expression based on \"\n+\t\t\t\t \"integer induction.\\n\");\n+\t      STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) = cond_reduc_op_code;\n+\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info)\n \t\t= cond_reduc_val;\n-\t      STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t= INTEGER_INDUC_COND_REDUCTION;\n+\t      STMT_VINFO_REDUC_TYPE (reduc_info) = INTEGER_INDUC_COND_REDUCTION;\n \t    }\n \t}\n       else if (cond_reduc_dt == vect_constant_def)\n@@ -6107,30 +6120,21 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t     \"condition expression based on \"\n \t\t\t\t     \"compile time constant.\\n\");\n \t\t  /* Record reduction code at analysis stage.  */\n-\t\t  STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info)\n+\t\t  STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info)\n \t\t    = integer_onep (e) ? MAX_EXPR : MIN_EXPR;\n-\t\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t    = CONST_COND_REDUCTION;\n+\t\t  STMT_VINFO_REDUC_TYPE (reduc_info) = CONST_COND_REDUCTION;\n \t\t}\n \t    }\n \t}\n     }\n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == INTEGER_INDUC_COND_REDUCTION\n-      && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"condition expression based on \"\n-\t\t     \"integer induction.\\n\");\n \n-  if (orig_stmt_info)\n-    gcc_assert (tmp == orig_stmt_info\n-\t\t|| REDUC_GROUP_FIRST_ELEMENT (tmp) == orig_stmt_info);\n-  else\n+  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     /* We changed STMT to be the first stmt in reduction chain, hence we\n        check that in this case the first element in the chain is STMT.  */\n-    gcc_assert (tmp == stmt_info\n-\t\t|| REDUC_GROUP_FIRST_ELEMENT (tmp) == stmt_info);\n+    gcc_assert (REDUC_GROUP_FIRST_ELEMENT (STMT_VINFO_REDUC_DEF (phi_info))\n+\t\t== vect_orig_stmt (stmt_info));\n \n-  if (STMT_VINFO_LIVE_P (reduc_def_info))\n+  if (STMT_VINFO_LIVE_P (phi_info))\n     return false;\n \n   if (slp_node)\n@@ -6140,25 +6144,16 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  vec_mode = TYPE_MODE (vectype_in);\n   poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n \n   if (nested_cycle)\n     {\n-      basic_block def_bb = gimple_bb (reduc_def_phi);\n-      class loop *def_stmt_loop = def_bb->loop_father;\n-      tree def_arg = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi,\n-\t\t\t\t\t    loop_preheader_edge (def_stmt_loop));\n-      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n-      if (def_arg_stmt_info\n-\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n-\t      == vect_double_reduction_def))\n-        double_reduc = true;\n-      gcc_assert (!double_reduc || STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_outer_by_reduction);\n+      gcc_assert (STMT_VINFO_DEF_TYPE (reduc_info)\n+\t\t  == vect_double_reduction_def);\n+      double_reduc = true;\n     }\n \n-  vect_reduction_type reduction_type\n-    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n+  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n   if ((double_reduc || reduction_type != TREE_CODE_REDUCTION)\n       && ncopies > 1)\n     {\n@@ -6169,78 +6164,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  if (code == COND_EXPR)\n-    {\n-      /* Only call during the analysis stage, otherwise we'll lose\n-\t STMT_VINFO_TYPE.  */\n-      gcc_assert (nested_cycle || reduc_index > 0);\n-      if (!vec_stmt && !vectorizable_condition (stmt_info, gsi, NULL,\n-\t\t\t\t\t\ttrue, reduc_index,\n-\t\t\t\t\t\tNULL, cost_vec))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported condition in reduction\\n\");\n-\t  return false;\n-        }\n-    }\n-  else if (code == LSHIFT_EXPR || code == RSHIFT_EXPR\n-\t   || code == LROTATE_EXPR || code == RROTATE_EXPR)\n-    {\n-      /* Only call during the analysis stage, otherwise we'll lose\n-\t STMT_VINFO_TYPE.  We only support this for nested cycles\n-\t without double reductions at the moment.  */\n-      if (!nested_cycle\n-\t  || double_reduc\n-\t  || (!vec_stmt && !vectorizable_shift (stmt_info, gsi, NULL,\n-\t\t\t\t\t\tNULL, cost_vec)))\n-\t{\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported shift or rotation in reduction\\n\");\n-\t  return false;\n-\t}\n-    }\n-  else\n-    {\n-      /* 4. Supportable by target?  */\n-\n-      /* 4.1. check support for the operation in the loop  */\n-      optab = optab_for_tree_code (code, vectype_in, optab_default);\n-      if (!optab)\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no optab.\\n\");\n-\n-          return false;\n-        }\n-\n-      if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n-        {\n-          if (dump_enabled_p ())\n-            dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n-\n-\t  if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n-\t      || !vect_worthwhile_without_simd_p (loop_vinfo, code))\n-            return false;\n-\n-          if (dump_enabled_p ())\n-  \t    dump_printf (MSG_NOTE, \"proceeding using word mode.\\n\");\n-        }\n-\n-      /* Worthwhile without SIMD support?  */\n-      if (!VECTOR_MODE_P (TYPE_MODE (vectype_in))\n-\t  && !vect_worthwhile_without_simd_p (loop_vinfo, code))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not worthwhile without SIMD support.\\n\");\n-\n-          return false;\n-        }\n-    }\n-\n   /* 4.2. Check support for the epilog operation.\n \n           If STMT represents a reduction pattern, then the type of the\n@@ -6285,7 +6208,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n          reduction variable, and get the tree-code from orig_stmt.  */\n       orig_code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n       gcc_assert (vectype_out);\n-      vec_mode = TYPE_MODE (vectype_out);\n     }\n   else\n     {\n@@ -6301,11 +6223,11 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (reduction_type == CONST_COND_REDUCTION\n \t  || reduction_type == INTEGER_INDUC_COND_REDUCTION)\n \t{\n-\t  orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info);\n+\t  orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info);\n \t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n \t}\n     }\n-  STMT_VINFO_REDUC_CODE (stmt_info) = orig_code;\n+  STMT_VINFO_REDUC_CODE (reduc_info) = orig_code;\n \n   reduc_fn = IFN_LAST;\n \n@@ -6353,7 +6275,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n \treduc_fn = IFN_REDUC_MAX;\n     }\n-  STMT_VINFO_REDUC_FN (stmt_info) = reduc_fn;\n+  STMT_VINFO_REDUC_FN (reduc_info) = reduc_fn;\n \n   if (reduction_type != EXTRACT_LAST_REDUCTION\n       && (!nested_cycle || double_reduc)\n@@ -6436,7 +6358,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t which each SLP statement has its own initial value and in which\n \t that value needs to be repeated for every instance of the\n \t statement within the initial vector.  */\n-      unsigned int group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n       scalar_mode elt_mode = SCALAR_TYPE_MODE (TREE_TYPE (vectype_out));\n       if (!neutral_op\n \t  && !can_duplicate_and_interleave_p (group_size, elt_mode))\n@@ -6467,22 +6389,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      constant fits the type in the pattern recognition pass.  */\n   if (code == DOT_PROD_EXPR\n       && !types_compatible_p (TREE_TYPE (ops[0]), TREE_TYPE (ops[1])))\n-    {\n-      gcc_unreachable ();\n-      /* No testcase for this.  PR49478.  */\n-      if (TREE_CODE (ops[0]) == INTEGER_CST)\n-        ops[0] = fold_convert (TREE_TYPE (ops[1]), ops[0]);\n-      else if (TREE_CODE (ops[1]) == INTEGER_CST)\n-        ops[1] = fold_convert (TREE_TYPE (ops[0]), ops[1]);\n-      else\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"invalid types in dot-prod\\n\");\n-\n-          return false;\n-        }\n-    }\n+    /* No testcase for this.  PR49478.  */\n+    gcc_unreachable ();\n \n   if (reduction_type == COND_REDUCTION)\n     {\n@@ -6551,6 +6459,52 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       && vect_stmt_to_vectorize (use_stmt_info) == stmt_info)\n     single_defuse_cycle = true;\n \n+  if (single_defuse_cycle\n+      || code == DOT_PROD_EXPR\n+      || code == WIDEN_SUM_EXPR\n+      || code == SAD_EXPR)\n+    {\n+      gcc_assert (code != COND_EXPR);\n+\n+      /* 4. Supportable by target?  */\n+\n+      /* 4.1. check support for the operation in the loop  */\n+      optab optab = optab_for_tree_code (code, vectype_in, optab_default);\n+      if (!optab)\n+        {\n+          if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"no optab.\\n\");\n+\n+          return false;\n+        }\n+\n+      machine_mode vec_mode = TYPE_MODE (vectype_in);\n+      if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n+        {\n+          if (dump_enabled_p ())\n+            dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n+\n+\t  if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n+\t      || !vect_worthwhile_without_simd_p (loop_vinfo, code))\n+            return false;\n+\n+          if (dump_enabled_p ())\n+\t    dump_printf (MSG_NOTE, \"proceeding using word mode.\\n\");\n+        }\n+\n+      /* Worthwhile without SIMD support?  */\n+      if (!VECTOR_MODE_P (TYPE_MODE (vectype_in))\n+\t  && !vect_worthwhile_without_simd_p (loop_vinfo, code))\n+        {\n+          if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not worthwhile without SIMD support.\\n\");\n+\n+          return false;\n+        }\n+    }\n+\n   /* If the reduction stmt is one of the patterns that have lane\n      reduction embedded we cannot handle the case of ! single_defuse_cycle.  */\n   if ((ncopies > 1\n@@ -6575,10 +6529,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n   bool mask_by_cond_expr = use_mask_by_cond_expr_p (code, cond_fn, vectype_in);\n \n-  /* transformation not required.  */\n-  gcc_assert (!vec_stmt);\n-\n-  vect_model_reduction_cost (stmt_info, reduc_fn, ncopies, cost_vec);\n+  vect_model_reduction_cost (stmt_info, reduc_fn, reduction_type, ncopies,\n+\t\t\t     cost_vec);\n   if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n     {\n       if (reduction_type != FOLD_LEFT_REDUCTION\n@@ -6609,7 +6561,18 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       && reduction_type == FOLD_LEFT_REDUCTION)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"using an in-order (fold-left) reduction.\\n\");\n-  STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+  STMT_VINFO_TYPE (orig_stmt_of_analysis) = cycle_phi_info_type;\n+  /* All but single defuse-cycle optimized, lane-reducing and fold-left\n+     reductions go through their own vectorizable_* routines.  */\n+  if (!single_defuse_cycle\n+      && code != DOT_PROD_EXPR\n+      && code != WIDEN_SUM_EXPR\n+      && code != SAD_EXPR\n+      && reduction_type != FOLD_LEFT_REDUCTION)\n+    {\n+      STMT_VINFO_DEF_TYPE (stmt_info) = vect_internal_def;\n+      STMT_VINFO_DEF_TYPE (vect_orig_stmt (stmt_info)) = vect_internal_def;\n+    }\n   return true;\n }\n \n@@ -6632,13 +6595,15 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   bool single_defuse_cycle = false;\n   int j;\n   tree ops[3];\n-  bool nested_cycle = false;\n   int vec_num;\n \n+  stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n+  gcc_assert (reduc_info->is_reduc_info);\n+\n   if (nested_in_vect_loop_p (loop, stmt_info))\n     {\n       loop = loop->inner;\n-      nested_cycle = true;\n+      gcc_assert (STMT_VINFO_DEF_TYPE (reduc_info) == vect_double_reduction_def);\n     }\n \n   gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n@@ -6674,10 +6639,8 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n-  stmt_vec_info reduc_def_info\n-    = STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info));\n-  gcc_assert (reduc_def_info);\n-  gphi *reduc_def_phi = as_a <gphi *> (reduc_def_info->stmt);\n+  stmt_vec_info phi_info = STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info));\n+  gphi *reduc_def_phi = as_a <gphi *> (phi_info->stmt);\n   tree reduc_def = PHI_RESULT (reduc_def_phi);\n   int reduc_index = -1;\n   for (i = 0; i < op_type; i++)\n@@ -6718,19 +6681,12 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (!vectype_in)\n     vectype_in = vectype_out;\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == INTEGER_INDUC_COND_REDUCTION\n-      && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"condition expression based on \"\n-\t\t     \"integer induction.\\n\");\n-\n   if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n \n-  vect_reduction_type reduction_type\n-    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n+  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n \n   /* In case of widenning multiplication by a constant, we update the type\n      of the constant to be the type of the other operand.  We check that the\n@@ -6814,18 +6770,16 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   if (reduction_type == FOLD_LEFT_REDUCTION)\n     {\n-      internal_fn reduc_fn = STMT_VINFO_REDUC_FN (stmt_info);\n+      internal_fn reduc_fn = STMT_VINFO_REDUC_FN (reduc_info);\n       return vectorize_fold_left_reduction\n \t  (stmt_info, gsi, vec_stmt, slp_node, reduc_def_phi, code,\n \t   reduc_fn, ops, vectype_in, reduc_index, masks);\n     }\n \n-  if (reduction_type == EXTRACT_LAST_REDUCTION)\n-    {\n-      gcc_assert (!slp_node && reduc_index > 0);\n-      return vectorizable_condition (stmt_info, gsi, vec_stmt,\n-\t\t\t\t     true, reduc_index, NULL, NULL);\n-    }\n+  gcc_assert (single_defuse_cycle\n+\t      || code == DOT_PROD_EXPR\n+\t      || code == WIDEN_SUM_EXPR\n+\t      || code == SAD_EXPR);\n \n   /* Create the destination vector  */\n   tree scalar_dest = gimple_assign_lhs (stmt);\n@@ -6842,20 +6796,6 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   for (j = 0; j < ncopies; j++)\n     {\n-      if (code == COND_EXPR)\n-        {\n-          gcc_assert (!slp_node && (nested_cycle || reduc_index > 0));\n-\t  vectorizable_condition (stmt_info, gsi, vec_stmt, true,\n-\t\t\t\t  reduc_index, NULL, NULL);\n-          break;\n-        }\n-      if (code == LSHIFT_EXPR\n-\t  || code == RSHIFT_EXPR)\n-\t{\n-\t  vectorizable_shift (stmt_info, gsi, vec_stmt, slp_node, NULL);\n-\t  break;\n-\t}\n-\n       /* Handle uses.  */\n       if (j == 0)\n         {\n@@ -7015,17 +6955,13 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n   gphi *phi = as_a <gphi *> (stmt_info->stmt);\n   tree phi_result = gimple_phi_result (phi);\n \n-  if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n-    /* Leave the scalar phi in place.  Note that checking\n-       STMT_VINFO_VEC_REDUCTION_TYPE (as below) only works\n-       for reductions involving a single statement.  */\n-    return true;\n-\n   stmt_vec_info reduc_stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n   reduc_stmt_info = vect_stmt_to_vectorize (reduc_stmt_info);\n+  stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n+  gcc_assert (reduc_info->is_reduc_info);\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-      == EXTRACT_LAST_REDUCTION)\n+  if (STMT_VINFO_REDUC_TYPE (reduc_info) == EXTRACT_LAST_REDUCTION\n+      || STMT_VINFO_REDUC_TYPE (reduc_info) == FOLD_LEFT_REDUCTION)\n     /* Leave the scalar phi in place.  */\n     return true;\n \n@@ -7091,8 +7027,7 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n       stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n       tree neutral_op\n \t= neutral_op_for_slp_reduction (slp_node,\n-\t\t\t\t\tSTMT_VINFO_REDUC_CODE\n-\t\t\t\t\t  (first ? first : reduc_stmt_info),\n+\t\t\t\t\tSTMT_VINFO_REDUC_CODE (reduc_info),\n \t\t\t\t\tfirst != NULL);\n       get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n \t\t\t\t      &vec_initial_defs, vec_num,\n@@ -7107,27 +7042,20 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n       /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n \t and we can't use zero for induc_val, use initial_def.  Similarly\n \t for REDUC_MIN and initial_def larger than the base.  */\n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-\t  == INTEGER_INDUC_COND_REDUCTION)\n+      if (STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n \t{\n-\t  tree induc_val\n-\t    = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info);\n+\t  tree induc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info);\n \t  if (TREE_CODE (initial_def) == INTEGER_CST\n-\t      && (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-\t\t  == INTEGER_INDUC_COND_REDUCTION)\n \t      && !integer_zerop (induc_val)\n-\t      && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n-\t\t    == MAX_EXPR)\n+\t      && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) == MAX_EXPR)\n \t\t   && tree_int_cst_lt (initial_def, induc_val))\n-\t\t  || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n-\t\t       == MIN_EXPR)\n+\t\t  || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) == MIN_EXPR)\n \t\t      && tree_int_cst_lt (induc_val, initial_def))))\n \t    {\n \t      induc_val = initial_def;\n \t      /* Communicate we used the initial_def to epilouge\n \t\t generation.  */\n-\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info)\n-\t\t= NULL_TREE;\n+\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info) = NULL_TREE;\n \t    }\n \t  vec_initial_def = build_vector_from_val (vectype_out, induc_val);\n \t}\n@@ -7142,24 +7070,13 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n \t{\n \t  tree adjustment_def = NULL_TREE;\n \t  tree *adjustment_defp = &adjustment_def;\n-\t  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_stmt_info);\n-\t  /* ???  For the outer loop PHI we have to do a bit of searching\n-\t     to find the stmt with the code.  reduc_stmt_info here is the\n-\t     loop-closed PHI of the inner reduction which means we can look\n-\t     at its single-arg def.  */\n+\t  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n \t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n-\t    {\n-\t      tree def = gimple_phi_arg_def\n-\t\t\t   (as_a <gphi *> (reduc_stmt_info->stmt), 0);\n-\t      code = STMT_VINFO_REDUC_CODE\n-\t\t       (vect_stmt_to_vectorize (loop_vinfo->lookup_def (def)));\n-\t      adjustment_defp = NULL;\n-\t    }\n+\t    adjustment_defp = NULL;\n \t  vec_initial_def\n \t    = get_initial_def_for_reduction (reduc_stmt_info, code,\n \t\t\t\t\t     initial_def, adjustment_defp);\n-\t  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_stmt_info)\n-\t    = adjustment_def;\n+\t  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info) = adjustment_def;\n \t}\n       vec_initial_defs.create (1);\n       vec_initial_defs.quick_push (vec_initial_def);\n@@ -7894,30 +7811,26 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n   /* The last stmt of a reduction is live and vectorized via\n      vect_create_epilog_for_reduction.  vectorizable_reduction assessed\n      validity so just trigger the transform here.  */\n-  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n-      || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+  if (STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info)))\n     {\n       if (!vec_stmt)\n \treturn true;\n-      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+      if (slp_node)\n \t{\n-\t  if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION\n-\t      || (STMT_VINFO_REDUC_TYPE (stmt_info) == COND_REDUCTION\n-\t\t  && (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t      == EXTRACT_LAST_REDUCTION)))\n+\t  /* For reduction chains the meta-info is attached to\n+\t     the group leader.  */\n+\t  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+\t    stmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n+\t  /* For SLP reductions we vectorize the epilogue for\n+\t     all involved stmts together.  */\n+\t  else if (slp_index != 0)\n \t    return true;\n-\t  if (slp_node)\n-\t    {\n-\t      /* For reduction chains the meta-info is attached to\n-\t         the group leader.  */\n-\t      if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-\t\tstmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n-\t      /* For SLP reductions we vectorize the epilogue for\n-\t         all involved stmts together.  */\n-\t      else if (slp_index != 0)\n-\t\treturn true;\n-\t    }\n \t}\n+      stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n+      gcc_assert (reduc_info->is_reduc_info);\n+      if (STMT_VINFO_REDUC_TYPE (reduc_info) == FOLD_LEFT_REDUCTION\n+\t  || STMT_VINFO_REDUC_TYPE (reduc_info) == EXTRACT_LAST_REDUCTION)\n+\treturn true;\n       vect_create_epilog_for_reduction (stmt_info, slp_node,\n \t\t\t\t\tslp_node_instance);\n       return true;"}, {"sha": "f9c74087893586086817e3dc53d76c91d205acf8", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -838,9 +838,11 @@ vect_convert_output (stmt_vec_info stmt_info, tree type, gimple *pattern_stmt,\n static bool\n vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n {\n-  return (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n-\t  ? STMT_VINFO_REDUC_TYPE (stmt_vinfo) != FOLD_LEFT_REDUCTION\n-\t  : REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL);\n+  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n+    return (STMT_VINFO_REDUC_TYPE (STMT_VINFO_REDUC_DEF (stmt_vinfo))\n+\t    != FOLD_LEFT_REDUCTION);\n+  else\n+    return REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL;\n }\n \n /* As above, but also require it to have code CODE and to be a reduction"}, {"sha": "77b18ba36d02dc7b5fc92ab5a56ecc40fbab390a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -3957,17 +3957,6 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   stmt_vec_info last_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n   si = gsi_for_stmt (last_stmt_info->stmt);\n \n-  /* Mark the first element of the reduction chain as reduction to properly\n-     transform the node.  In the analysis phase only the last element of the\n-     chain is marked as reduction.  */\n-  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n-      && REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info)\n-    {\n-      STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n-      STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n-    }\n-\n   /* Handle two-operation SLP nodes by vectorizing the group with\n      both operations and then performing a merge.  */\n   if (SLP_TREE_TWO_OPERATORS (node))"}, {"sha": "9ebd3e3fa369ad5023cb9fa1c375111844820cbb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -5501,7 +5501,7 @@ vect_supportable_shift (enum tree_code code, tree scalar_type)\n    stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n    Return true if STMT_INFO is vectorizable in this way.  */\n \n-bool\n+static bool\n vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n@@ -9776,10 +9776,9 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n    Return true if STMT_INFO is vectorizable in this way.  */\n \n-bool\n+static bool\n vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\tstmt_vec_info *vec_stmt, bool for_reduction,\n-\t\t\tint reduc_index,\n+\t\t\tstmt_vec_info *vec_stmt,\n \t\t\tslp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n@@ -9812,17 +9811,36 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n-  if (for_reduction && STMT_SLP_TYPE (stmt_info))\n+  /* Is vectorizable conditional operation?  */\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n-  vect_reduction_type reduction_type\n-    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n-  if (!for_reduction)\n+  code = gimple_assign_rhs_code (stmt);\n+  if (code != COND_EXPR)\n+    return false;\n+\n+  stmt_vec_info reduc_info = NULL;\n+  int reduc_index = -1;\n+  vect_reduction_type reduction_type = TREE_CODE_REDUCTION;\n+  bool for_reduction\n+    = STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info)) != NULL;\n+  if (for_reduction)\n+    {\n+      if (STMT_SLP_TYPE (stmt_info))\n+\treturn false;\n+      reduc_info = info_for_reduction (stmt_info);\n+      reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n+      reduc_index = STMT_VINFO_REDUC_IDX (stmt_info);\n+      gcc_assert (reduction_type != EXTRACT_LAST_REDUCTION\n+\t\t  || reduc_index != -1);\n+    }\n+  else\n     {\n       if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n \treturn false;\n \n-      /* FORNOW: not yet supported.  */\n+      /* FORNOW: only supported as part of a reduction.  */\n       if (STMT_VINFO_LIVE_P (stmt_info))\n \t{\n \t  if (dump_enabled_p ())\n@@ -9832,16 +9850,6 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  /* Is vectorizable conditional operation?  */\n-  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n-  if (!stmt)\n-    return false;\n-\n-  code = gimple_assign_rhs_code (stmt);\n-\n-  if (code != COND_EXPR)\n-    return false;\n-\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n@@ -10665,12 +10673,10 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t  || vectorizable_load (stmt_info, NULL, NULL, node, node_instance,\n \t\t\t\tcost_vec)\n \t  || vectorizable_store (stmt_info, NULL, NULL, node, cost_vec)\n-\t  || vectorizable_reduction (stmt_info, NULL, NULL, node,\n-\t\t\t\t     node_instance, cost_vec)\n+\t  || vectorizable_reduction (stmt_info, node, node_instance, cost_vec)\n \t  || vectorizable_induction (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_shift (stmt_info, NULL, NULL, node, cost_vec)\n-\t  || vectorizable_condition (stmt_info, NULL, NULL, false, -1, node,\n-\t\t\t\t     cost_vec)\n+\t  || vectorizable_condition (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_comparison (stmt_info, NULL, NULL, node,\n \t\t\t\t      cost_vec)\n \t  || vectorizable_lc_phi (stmt_info, NULL, node));\n@@ -10689,8 +10695,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t      || vectorizable_load (stmt_info, NULL, NULL, node, node_instance,\n \t\t\t\t    cost_vec)\n \t      || vectorizable_store (stmt_info, NULL, NULL, node, cost_vec)\n-\t      || vectorizable_condition (stmt_info, NULL, NULL, false, -1, node,\n-\t\t\t\t\t cost_vec)\n+\t      || vectorizable_condition (stmt_info, NULL, NULL, node, cost_vec)\n \t      || vectorizable_comparison (stmt_info, NULL, NULL, node,\n \t\t\t\t\t  cost_vec));\n     }\n@@ -10796,8 +10801,7 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       break;\n \n     case condition_vec_info_type:\n-      done = vectorizable_condition (stmt_info, gsi, &vec_stmt, false, -1,\n-\t\t\t\t     slp_node, NULL);\n+      done = vectorizable_condition (stmt_info, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n@@ -10895,20 +10899,22 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* If this stmt defines a value used on a backedge, update the\n      vectorized PHIs.  */\n   stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n-  if (!slp_node && STMT_VINFO_REDUC_DEF (orig_stmt_info)\n-      && STMT_VINFO_REDUC_TYPE (orig_stmt_info) != FOLD_LEFT_REDUCTION\n-      && (STMT_VINFO_REDUC_TYPE (orig_stmt_info) != COND_REDUCTION\n-\t  || (STMT_VINFO_VEC_REDUCTION_TYPE (orig_stmt_info)\n-\t      != EXTRACT_LAST_REDUCTION))\n-      && is_a <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt))\n-    {\n-      gphi *phi = as_a <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt);\n-      if (dominated_by_p (CDI_DOMINATORS,\n-\t\t\t  gimple_bb (orig_stmt_info->stmt), gimple_bb (phi)))\n+  stmt_vec_info reduc_info;\n+  if (STMT_VINFO_REDUC_DEF (orig_stmt_info)\n+      && (reduc_info = info_for_reduction (orig_stmt_info))\n+      && STMT_VINFO_REDUC_TYPE (reduc_info) != FOLD_LEFT_REDUCTION\n+      && STMT_VINFO_REDUC_TYPE (reduc_info) != EXTRACT_LAST_REDUCTION)\n+    {\n+      gphi *phi;\n+      if (!slp_node\n+\t  && (phi = dyn_cast <gphi *>\n+\t\t      (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt))\n+\t  && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t     gimple_bb (orig_stmt_info->stmt), gimple_bb (phi)))\n \t{\n \t  edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n \t  stmt_vec_info phi_info\n-\t      = STMT_VINFO_VEC_STMT (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n+\t    = STMT_VINFO_VEC_STMT (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n \t  stmt_vec_info vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t  do\n \t    {\n@@ -10921,24 +10927,19 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  while (phi_info);\n \t  gcc_assert (!vec_stmt);\n \t}\n-    }\n-  else if (slp_node && STMT_VINFO_REDUC_DEF (orig_stmt_info)\n-\t   /* Going back and forth via STMT_VINFO_REDUC_DEF gets us to the\n-\t      stmt with the reduction meta in case of reduction groups.  */\n-\t   && (STMT_VINFO_REDUC_TYPE\n-\t         (STMT_VINFO_REDUC_DEF (STMT_VINFO_REDUC_DEF (orig_stmt_info)))\n-\t       != FOLD_LEFT_REDUCTION)\n-\t   && slp_node != slp_node_instance->reduc_phis)\n-    {\n-      slp_tree phi_node = slp_node_instance->reduc_phis;\n-      gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n-      edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n-      gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n-\t\t  == SLP_TREE_VEC_STMTS (slp_node).length ());\n-      for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n-\tadd_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]->stmt),\n-\t\t     gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt),\n-\t\t     e, gimple_phi_arg_location (phi, e->dest_idx));\n+      else if (slp_node\n+\t       && slp_node != slp_node_instance->reduc_phis)\n+\t{\n+\t  slp_tree phi_node = slp_node_instance->reduc_phis;\n+\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n+\t  edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n+\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n+\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n+\t  for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n+\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]->stmt),\n+\t\t\t gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt),\n+\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n+\t}\n     }\n \n   /* Handle stmts whose DEF is used outside the loop-nest that is"}, {"sha": "3e8637f070d5cd526d6626d2b7ba1c5f9243ce0a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -637,7 +637,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_VECTORIZABLE (res) = true;\n-  STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n+  STMT_VINFO_REDUC_TYPE (res) = TREE_CODE_REDUCTION;\n   STMT_VINFO_VEC_COND_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_FN (res) = IFN_LAST;"}, {"sha": "71ea6adde045ab9a8e22cb91cf9c3ffeee3d8f73", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=69f8c1aef5cdcc54d5cb2ca4f99f4f26c2f822a9", "patch": "@@ -933,9 +933,6 @@ class _stmt_vec_info {\n      for loop vectorization.  */\n   vect_memory_access_type memory_access_type;\n \n-  /* For reduction loops, this is the type of reduction.  */\n-  enum vect_reduction_type v_reduc_type;\n-\n   /* For CONST_COND_REDUCTION and INTEGER_INDUC_COND_REDUCTION, the\n      reduction code.  */\n   enum tree_code cond_reduc_code;\n@@ -947,7 +944,7 @@ class _stmt_vec_info {\n   tree reduc_epilogue_adjustment;\n \n   /* On a reduction PHI the reduction type as detected by\n-     vect_force_simple_reduction.  */\n+     vect_is_simple_reduction and vectorizable_reduction.  */\n   enum vect_reduction_type reduc_type;\n \n   /* The original reduction code, to be used in the epilogue.  */\n@@ -964,6 +961,9 @@ class _stmt_vec_info {\n      corresponding PHI.  */\n   stmt_vec_info reduc_def;\n \n+  /* Whether on this stmt reduction meta is recorded.  */\n+  bool is_reduc_info;\n+\n   /* The number of scalar stmt references from active SLP instances.  */\n   unsigned int num_slp_uses;\n \n@@ -1046,7 +1046,6 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n #define STMT_VINFO_MEMORY_ACCESS_TYPE(S)   (S)->memory_access_type\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n-#define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n #define STMT_VINFO_VEC_COND_REDUC_CODE(S)  (S)->cond_reduc_code\n #define STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL(S) (S)->induc_cond_initial_val\n #define STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT(S) (S)->reduc_epilogue_adjustment\n@@ -1556,12 +1555,6 @@ extern bool vect_transform_stmt (stmt_vec_info, gimple_stmt_iterator *,\n extern void vect_remove_stores (stmt_vec_info);\n extern opt_result vect_analyze_stmt (stmt_vec_info, bool *, slp_tree,\n \t\t\t\t     slp_instance, stmt_vector_for_cost *);\n-extern bool vectorizable_condition (stmt_vec_info, gimple_stmt_iterator *,\n-\t\t\t\t    stmt_vec_info *, bool, int, slp_tree,\n-\t\t\t\t    stmt_vector_for_cost *);\n-extern bool vectorizable_shift (stmt_vec_info, gimple_stmt_iterator *,\n-\t\t\t\tstmt_vec_info *, slp_tree,\n-\t\t\t\tstmt_vector_for_cost *);\n extern void vect_get_load_cost (stmt_vec_info, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,\n@@ -1644,6 +1637,7 @@ extern void vect_record_loop_mask (loop_vec_info, vec_loop_masks *,\n \t\t\t\t   unsigned int, tree);\n extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n \t\t\t\tunsigned int, tree, unsigned int);\n+extern stmt_vec_info info_for_reduction (stmt_vec_info);\n \n /* Drive for loop transformation stage.  */\n extern class loop *vect_transform_loop (loop_vec_info);\n@@ -1653,8 +1647,7 @@ extern bool vectorizable_live_operation (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, slp_instance, int,\n \t\t\t\t\t stmt_vec_info *,\n \t\t\t\t\t stmt_vector_for_cost *);\n-extern bool vectorizable_reduction (stmt_vec_info, gimple_stmt_iterator *,\n-\t\t\t\t    stmt_vec_info *, slp_tree, slp_instance,\n+extern bool vectorizable_reduction (stmt_vec_info, slp_tree, slp_instance,\n \t\t\t\t    stmt_vector_for_cost *);\n extern bool vectorizable_induction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree,"}]}