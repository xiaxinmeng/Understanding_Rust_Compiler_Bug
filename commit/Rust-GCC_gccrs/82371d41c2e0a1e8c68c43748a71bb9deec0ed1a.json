{"sha": "82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNzFkNDFjMmUwYTFlOGM2OGM0Mzc0OGE3MWJiOWRlZWMwZWQxYQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-12-01T14:28:02Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-12-01T14:28:02Z"}, "message": "class.c (layout_class_method): Don't report error on non-static overriding static if the method is private.\n\nTue Dec  1 13:53:24 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (layout_class_method): Don't report error on non-static\n \toverriding static if the method is private.\n\t* java-tree.h (finish_class): Prototype added.\n\t* lex.c (java_get_line_col): Handle col argument -2 value.\n\t* parse.h: All static method declarations moved to parse.y.\n\t* parse.y: Now contains all static method declarations previously\n \tfound in parse.h.\n\t(find_expr_with_wfl, missing_return_error,\n \tunreachable_stmt_error): New functions.\n\t(java_get_real_method_name): Identify constructors bearing class\n \tnames in source code compiled classes only.\n\t(java_complete_expand_methods): Call missing_return_error.\n\t(invocation_mode): Private methods invoked as static methods.\n\t(java_complete_tree): Call unreachable_stmt_error.\nThis patch corrects the way unreachable statement and missing return\nstatement errors are reported. It also fixes random bugs.\n\nFrom-SVN: r24036", "tree": {"sha": "009299b3815a338dbba35958d0320cfdada1c86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/009299b3815a338dbba35958d0320cfdada1c86f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/comments", "author": null, "committer": null, "parents": [{"sha": "df3ba30ac3667b0ff00d7ae8aa29ffad2d1c68d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3ba30ac3667b0ff00d7ae8aa29ffad2d1c68d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3ba30ac3667b0ff00d7ae8aa29ffad2d1c68d4"}], "stats": {"total": 1599, "additions": 968, "deletions": 631}, "files": [{"sha": "e3b33a20d0808b9b73f3f500d1c4a6c31fbde15d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -1,3 +1,20 @@\n+Tue Dec  1 13:53:24 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class_method): Don't report error on non-static\n+ \toverriding static if the method is private.\n+\t* java-tree.h (finish_class): Prototype added.\n+\t* lex.c (java_get_line_col): Handle col argument -2 value.\n+\t* parse.h: All static method declarations moved to parse.y.\n+\t* parse.y: Now contains all static method declarations previously\n+ \tfound in parse.h.\n+\t(find_expr_with_wfl, missing_return_error,\n+ \tunreachable_stmt_error): New functions.\n+\t(java_get_real_method_name): Identify constructors bearing class\n+ \tnames in source code compiled classes only.\n+\t(java_complete_expand_methods): Call missing_return_error.\n+\t(invocation_mode): Private methods invoked as static methods.\n+\t(java_complete_tree): Call unreachable_stmt_error.\n+\n 1998-12-01  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in (+target): Removed."}, {"sha": "dedff9e5facf6cb448829170bb12cae36f77b978", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -1588,7 +1588,8 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n       if (super_method != NULL_TREE)\n \t{\n \t  DECL_VINDEX (method_decl) = DECL_VINDEX (super_method);\n-\t  if (DECL_VINDEX (method_decl) == NULL_TREE)\n+\t  if (DECL_VINDEX (method_decl) == NULL_TREE &&\n+\t      ! TREE_PRIVATE (method_decl))\n \t    error_with_decl (method_decl,\n \t\t\t     \"non-static method '%s' overrides static method\");\n #if 0"}, {"sha": "e8fbb611585ba648028741432744babf92a6f55b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -561,6 +561,7 @@ extern char *print_int_node PROTO ((tree));\n extern void parse_error_context VPROTO ((tree cl, char *msg, ...));\n extern tree build_primtype_type_ref PROTO ((char *));\n extern tree java_get_real_method_name PROTO ((tree));\n+extern void finish_class PROTO ((tree));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n "}, {"sha": "e645b4004b01fbd3a5b4aca9fd7d0fe004179bd8", "filename": "gcc/java/lex.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -1315,11 +1315,14 @@ java_get_line_col (filename, line, col)\n   /* Dumb implementation. Doesn't try to cache or optimize things. */\n   /* First line of the file is line 1, first column is 1 */\n \n-  /* COL <= 0 means, at the CR/LF in LINE */\n+  /* COL == -1 means, at the CR/LF in LINE */\n+  /* COL == -2 means, at the first non space char in LINE */\n \n   FILE *fp;\n   int c, ccol, cline = 1;\n   int current_line_col = 0;\n+  int first_non_space = 0;\n+  char *base;\n \n   if (!(fp = fopen (filename, \"r\")))\n     fatal (\"Can't open file - java_display_line_col\");\n@@ -1343,19 +1346,34 @@ java_get_line_col (filename, line, col)\n       c = getc (fp);\n       if (c < 0 || java_is_eol (fp, c))\n \tbreak;\n+      if (!first_non_space && !JAVA_WHITE_SPACE_P (c))\n+\tfirst_non_space = current_line_col;\n       obstack_1grow (&temporary_obstack, c);\n       current_line_col++;\n     }\n  have_line:\n \n   obstack_1grow (&temporary_obstack, '\\n');\n \n-  if (col < 0)\n-    col = current_line_col;\n+  if (col == -1)\n+    {\n+      col = current_line_col;\n+      first_non_space = 0;\n+    }\n+  else if (col == -2)\n+    col = first_non_space;\n+  else\n+    first_non_space = 0;\n \n   /* Place the '^' a the right position */\n+  base = obstack_base (&temporary_obstack);\n   for (ccol = 1; ccol <= col; ccol++)\n-    obstack_1grow (&temporary_obstack, ' ');\n+    {\n+      /* Compute \\t when reaching first_non_space */\n+      char c = (first_non_space ?\n+\t\t(base [ccol-1] == '\\t' ? '\\t' : ' ') : ' ');\n+      obstack_1grow (&temporary_obstack, c);\n+    }\n   obstack_grow0 (&temporary_obstack, \"^\", 1);\n \n   fclose (fp);"}, {"sha": "3683f98d063b05fa0cffb1f2d98a5c4787c514e4", "filename": "gcc/java/parse.c", "status": "modified", "additions": 679, "deletions": 451, "changes": 1130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -145,6 +145,171 @@\n #include \"zipfile.h\"\n #include \"convert.h\"\n \n+/* Local function prototypes */\n+static char *java_accstring_lookup PROTO ((int));\n+static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n+static void  check_modifiers PROTO ((char *, int, int));\n+static tree  create_class PROTO ((int, tree, tree, tree));\n+static tree  create_interface PROTO ((int, tree, tree));\n+static tree  find_field PROTO ((tree, tree));\n+static tree lookup_field_wrapper PROTO ((tree, tree));\n+static int   duplicate_declaration_error_p PROTO ((tree, tree, tree));\n+static void  register_fields PROTO ((int, tree, tree));\n+static tree parser_qualified_classname PROTO ((tree));\n+static int  parser_check_super PROTO ((tree, tree, tree));\n+static int  parser_check_super_interface PROTO ((tree, tree, tree));\n+static void check_modifiers_consistency PROTO ((int));\n+static tree lookup_cl PROTO ((tree));\n+static tree lookup_java_method2 PROTO ((tree, tree, int));\n+static tree method_header PROTO ((int, tree, tree, tree));\n+static void fix_method_argument_names PROTO ((tree ,tree));\n+static tree method_declarator PROTO ((tree, tree));\n+static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n+static void issue_warning_error_from_context PROTO ((tree, char *msg, va_list));\n+static tree parse_jdk1_1_error PROTO ((char *));\n+static void complete_class_report_errors PROTO ((jdep *));\n+static int process_imports PROTO ((void));\n+static void read_import_dir PROTO ((tree));\n+static int find_in_imports_on_demand PROTO ((tree));\n+static int find_in_imports PROTO ((tree));\n+static int check_pkg_class_access PROTO ((tree, tree));\n+static tree resolve_package PROTO ((tree, tree *));\n+static tree lookup_package_type PROTO ((char *, int));\n+static tree resolve_class PROTO ((tree, tree, tree));\n+static tree do_resolve_class PROTO ((tree, tree, tree));\n+static void declare_local_variables PROTO ((int, tree, tree));\n+static void source_start_java_method PROTO ((tree));\n+static void source_end_java_method PROTO ((void));\n+static void expand_start_java_method PROTO ((tree));\n+static tree find_name_in_single_imports PROTO ((tree));\n+static void check_abstract_method_header PROTO ((tree));\n+static tree lookup_java_interface_method2 PROTO ((tree, tree));\n+static tree resolve_expression_name PROTO ((tree, tree *));\n+static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n+static int check_class_interface_creation PROTO ((int, int, tree, \n+\t\t\t\t\t\t  tree, tree, tree));\n+static tree patch_method_invocation PROTO ((tree, tree, tree, \n+\t\t\t\t\t    int *, tree *, int));\n+static int breakdown_qualified PROTO ((tree *, tree *, tree));\n+static tree resolve_and_layout PROTO ((tree, tree));\n+static tree resolve_no_layout PROTO ((tree, tree));\n+static int invocation_mode PROTO ((tree, int));\n+static tree find_applicable_accessible_methods_list PROTO ((int, tree, \n+\t\t\t\t\t\t\t    tree, tree));\n+static tree find_most_specific_methods_list PROTO ((tree));\n+static int argument_types_convertible PROTO ((tree, tree));\n+static tree patch_invoke PROTO ((tree, tree, tree, int));\n+static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n+static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n+static tree obtain_incomplete_type PROTO ((tree));\n+static tree java_complete_tree PROTO ((tree));\n+static void java_complete_expand_method PROTO ((tree));\n+static int  unresolved_type_p PROTO ((tree, tree *));\n+static void create_jdep_list PROTO ((struct parser_ctxt *));\n+static tree build_expr_block PROTO ((tree, tree));\n+static tree enter_block PROTO ((void));\n+static tree enter_a_block PROTO ((tree));\n+static tree exit_block PROTO ((void));\n+static tree lookup_name_in_blocks PROTO ((tree));\n+static void maybe_absorb_scoping_blocks PROTO ((void));\n+static tree build_method_invocation PROTO ((tree, tree));\n+static tree build_new_invocation PROTO ((tree, tree));\n+static tree build_assignment PROTO ((int, int, tree, tree));\n+static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n+static int check_final_assignment PROTO ((tree ,tree));\n+static tree patch_assignment PROTO ((tree, tree, tree ));\n+static tree patch_binop PROTO ((tree, tree, tree));\n+static tree build_unaryop PROTO ((int, int, tree));\n+static tree build_incdec PROTO ((int, int, tree, int));\n+static tree patch_unaryop PROTO ((tree, tree));\n+static tree build_cast PROTO ((int, tree, tree));\n+static tree build_null_of_type PROTO ((tree));\n+static tree patch_cast PROTO ((tree, tree));\n+static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n+static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n+static int valid_cast_to_p PROTO ((tree, tree));\n+static int valid_method_invocation_conversion_p PROTO ((tree, tree));\n+static tree try_builtin_assignconv PROTO ((tree, tree, tree));\n+static tree try_reference_assignconv PROTO ((tree, tree));\n+static tree build_unresolved_array_type PROTO ((tree));\n+static tree build_array_from_name PROTO ((tree, tree, tree, tree *));\n+static tree build_array_ref PROTO ((int, tree, tree));\n+static tree patch_array_ref PROTO ((tree));\n+static tree make_qualified_name PROTO ((tree, tree, int));\n+static tree merge_qualified_name PROTO ((tree, tree));\n+static tree make_qualified_primary PROTO ((tree, tree, int));\n+static int resolve_qualified_expression_name PROTO ((tree, tree *, \n+\t\t\t\t\t\t     tree *, tree *));\n+static void qualify_ambiguous_name PROTO ((tree));\n+static void maybe_generate_clinit PROTO ((void));\n+static tree resolve_field_access PROTO ((tree, tree *, tree *));\n+static tree build_newarray_node PROTO ((tree, tree, int));\n+static tree patch_newarray PROTO ((tree));\n+static tree resolve_type_during_patch PROTO ((tree));\n+static tree build_this PROTO ((int));\n+static tree build_return PROTO ((int, tree));\n+static tree patch_return PROTO ((tree));\n+static tree maybe_access_field PROTO ((tree, tree, tree));\n+static int complete_function_arguments PROTO ((tree));\n+static int check_for_static_method_reference PROTO ((tree, tree, tree, tree, tree));\n+static int not_accessible_p PROTO ((tree, tree, int));\n+static void check_deprecation PROTO ((tree, tree));\n+static int class_in_current_package PROTO ((tree));\n+static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n+static tree patch_if_else_statement PROTO ((tree));\n+static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n+static tree add_stmt_to_block PROTO ((tree, tree, tree));\n+static tree patch_exit_expr PROTO ((tree));\n+static tree build_labeled_block PROTO ((int, tree));\n+static tree generate_labeled_block PROTO (());\n+static tree complete_labeled_statement PROTO ((tree, tree));\n+static tree build_bc_statement PROTO ((int, int, tree));\n+static tree patch_bc_statement PROTO ((tree));\n+static tree patch_loop_statement PROTO ((tree));\n+static tree build_new_loop PROTO ((tree));\n+static tree build_loop_body PROTO ((int, tree, int));\n+static tree complete_loop_body PROTO ((int, tree, tree, int));\n+static tree build_debugable_stmt PROTO ((int, tree));\n+static tree complete_for_loop PROTO ((int, tree, tree, tree));\n+static tree patch_switch_statement PROTO ((tree));\n+static tree string_constant_concatenation PROTO ((tree, tree));\n+static tree build_string_concatenation PROTO ((tree, tree));\n+static tree patch_string_cst PROTO ((tree));\n+static tree patch_string PROTO ((tree));\n+static tree build_jump_to_finally PROTO ((tree, tree, tree, tree));\n+static tree build_try_statement PROTO ((int, tree, tree, tree));\n+static tree patch_try_statement PROTO ((tree));\n+static tree patch_synchronized_statement PROTO ((tree, tree));\n+static tree patch_throw_statement PROTO ((tree, tree));\n+static void check_thrown_exceptions PROTO ((int, tree));\n+static int check_thrown_exceptions_do PROTO ((tree));\n+static void purge_unchecked_exceptions PROTO ((tree));\n+static void check_throws_clauses PROTO ((tree, tree, tree));\n+static void complete_method_declaration PROTO ((tree));\n+static tree build_super_invocation PROTO (());\n+static int verify_constructor_circularity PROTO ((tree, tree));\n+static char *constructor_circularity_msg PROTO ((tree, tree));\n+static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n+\t\t\t\t\t\t\t  int, int));\n+static char *get_printable_method_name PROTO ((tree));\n+static tree patch_conditional_expr PROTO ((tree, tree, tree));\n+static void maybe_generate_finit PROTO (());\n+static void fix_constructors PROTO ((tree));\n+static int verify_constructor_super PROTO (());\n+static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n+static void start_artificial_method_body PROTO ((tree));\n+static void end_artificial_method_body PROTO ((tree));\n+static tree generate_field_initialization_code PROTO ((tree));\n+static int check_method_redefinition PROTO ((tree, tree));\n+static int reset_method_name PROTO ((tree));\n+static void java_check_regular_methods PROTO ((tree));\n+static void java_check_abstract_methods PROTO ((tree));\n+static tree maybe_build_primttype_type_ref PROTO ((tree, tree));\n+static void unreachable_stmt_error PROTO ((tree));\n+static tree find_expr_with_wfl PROTO ((tree));\n+static void missing_return_error PROTO ((tree));\n+\n /* Number of error found so far. */\n int java_error_count; \n /* Number of warning found so far. */\n@@ -189,7 +354,7 @@ static tree wfl_append = NULL_TREE;\n /* The \"toString\" identifier used for String `+' operator. */\n static tree wfl_to_string = NULL_TREE;\n \n-#line 117 \"./parse.y\"\n+#line 282 \"./parse.y\"\n typedef union {\n   tree node;\n   int sub_token;\n@@ -493,56 +658,56 @@ static const short yyrhs[] = {   123,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   266,   272,   274,   275,   276,   277,   278,   282,   284,   287,\n-   289,   290,   293,   295,   298,   302,   306,   310,   316,   318,\n-   320,   322,   327,   329,   332,   336,   341,   346,   348,   349,\n-   350,   351,   352,   353,   354,   357,   362,   368,   370,   373,\n-   376,   378,   382,   384,   387,   414,   416,   420,   433,   435,\n-   439,   446,   447,   449,   459,   464,   479,   483,   486,   489,\n-   492,   494,   496,   498,   502,   504,   506,   508,   512,   514,\n-   516,   523,   529,   534,   538,   541,   545,   547,   550,   552,\n-   553,   554,   558,   560,   561,   563,   568,   571,   581,   584,\n-   586,   590,   593,   600,   606,   614,   616,   618,   620,   622,\n-   626,   628,   633,   640,   641,   645,   648,   650,   652,   654,\n-   656,   658,   660,   662,   669,   672,   674,   679,   681,   685,\n-   690,   695,   699,   704,   706,   708,   715,   717,   719,   723,\n-   726,   728,   732,   734,   735,   740,   745,   751,   759,   766,\n-   769,   772,   776,   779,   783,   792,   794,   796,   801,   808,\n-   816,   818,   822,   830,   841,   845,   848,   851,   854,   857,\n-   860,   863,   866,   868,   872,   878,   883,   885,   889,   892,\n-   896,   898,   901,   903,   904,   906,   910,   914,   920,   925,\n-   930,   934,   938,   944,   946,   947,   952,   955,   959,   964,\n-   972,   974,   977,   979,   981,   985,   989,   992,   996,   998,\n-   999,  1000,  1001,  1002,  1012,  1014,  1015,  1016,  1017,  1020,\n-  1022,  1023,  1024,  1025,  1026,  1027,  1028,  1029,  1030,  1031,\n-  1034,  1039,  1050,  1057,  1061,  1072,  1082,  1088,  1094,  1100,\n-  1102,  1108,  1110,  1116,  1118,  1120,  1122,  1124,  1128,  1130,\n-  1131,  1132,  1133,  1134,  1135,  1138,  1141,  1143,  1145,  1149,\n-  1154,  1159,  1165,  1174,  1180,  1182,  1184,  1188,  1190,  1191,\n-  1192,  1195,  1197,  1200,  1204,  1206,  1209,  1216,  1222,  1224,\n-  1226,  1230,  1238,  1241,  1243,  1245,  1249,  1254,  1263,  1268,\n-  1271,  1278,  1280,  1282,  1286,  1289,  1298,  1305,  1307,  1311,\n-  1324,  1326,  1332,  1338,  1342,  1344,  1348,  1351,  1353,  1357,\n-  1360,  1362,  1364,  1368,  1371,  1373,  1375,  1379,  1382,  1384,\n-  1386,  1390,  1396,  1398,  1402,  1409,  1411,  1413,  1415,  1419,\n-  1427,  1430,  1432,  1434,  1438,  1440,  1447,  1455,  1472,  1474,\n-  1476,  1480,  1486,  1491,  1493,  1496,  1498,  1500,  1502,  1503,\n-  1504,  1505,  1509,  1511,  1513,  1518,  1520,  1522,  1524,  1526,\n-  1530,  1533,  1538,  1540,  1545,  1546,  1547,  1548,  1549,  1551,\n-  1553,  1555,  1557,  1559,  1563,  1565,  1568,  1574,  1579,  1583,\n-  1586,  1588,  1590,  1594,  1596,  1598,  1600,  1604,  1607,  1611,\n-  1617,  1619,  1627,  1630,  1632,  1636,  1641,  1649,  1653,  1656,\n-  1658,  1669,  1680,  1685,  1694,  1696,  1700,  1703,  1705,  1710,\n-  1715,  1720,  1727,  1729,  1730,  1731,  1734,  1739,  1744,  1746,\n-  1747,  1749,  1751,  1752,  1754,  1758,  1761,  1765,  1768,  1772,\n-  1774,  1776,  1778,  1779,  1781,  1785,  1793,  1795,  1797,  1809,\n-  1811,  1817,  1819,  1821,  1825,  1827,  1832,  1837,  1842,  1844,\n-  1846,  1850,  1852,  1857,  1862,  1864,  1868,  1870,  1875,  1880,\n-  1885,  1887,  1889,  1893,  1895,  1900,  1905,  1910,  1915,  1917,\n-  1919,  1921,  1923,  1925,  1929,  1931,  1936,  1941,  1943,  1947,\n-  1949,  1954,  1958,  1960,  1965,  1969,  1971,  1976,  1980,  1982,\n-  1987,  1991,  1993,  1998,  2002,  2004,  2009,  2015,  2017,  2021,\n-  2023,  2026,  2029,  2037,  2039,  2040,  2043,  2045,  2048,  2052\n+   431,   437,   439,   440,   441,   442,   443,   447,   449,   452,\n+   454,   455,   458,   460,   463,   467,   471,   475,   481,   483,\n+   485,   487,   492,   494,   497,   501,   506,   511,   513,   514,\n+   515,   516,   517,   518,   519,   522,   527,   533,   535,   538,\n+   541,   543,   547,   549,   552,   579,   581,   585,   598,   600,\n+   604,   611,   612,   614,   624,   629,   644,   648,   651,   654,\n+   657,   659,   661,   663,   667,   669,   671,   673,   677,   679,\n+   681,   688,   694,   699,   703,   706,   710,   712,   715,   717,\n+   718,   719,   723,   725,   726,   728,   733,   736,   746,   749,\n+   751,   755,   758,   765,   771,   779,   781,   783,   785,   787,\n+   791,   793,   798,   805,   806,   810,   813,   815,   817,   819,\n+   821,   823,   825,   827,   834,   837,   839,   844,   846,   850,\n+   855,   860,   864,   869,   871,   873,   880,   882,   884,   888,\n+   891,   893,   897,   899,   900,   905,   910,   916,   924,   931,\n+   934,   937,   941,   944,   948,   957,   959,   961,   966,   973,\n+   981,   983,   987,   995,  1006,  1010,  1013,  1016,  1019,  1022,\n+  1025,  1028,  1031,  1033,  1037,  1043,  1048,  1050,  1054,  1057,\n+  1061,  1063,  1066,  1068,  1069,  1071,  1075,  1079,  1085,  1090,\n+  1095,  1099,  1103,  1109,  1111,  1112,  1117,  1120,  1124,  1129,\n+  1137,  1139,  1142,  1144,  1146,  1150,  1154,  1157,  1161,  1163,\n+  1164,  1165,  1166,  1167,  1177,  1179,  1180,  1181,  1182,  1185,\n+  1187,  1188,  1189,  1190,  1191,  1192,  1193,  1194,  1195,  1196,\n+  1199,  1204,  1215,  1222,  1226,  1237,  1247,  1253,  1259,  1265,\n+  1267,  1273,  1275,  1281,  1283,  1285,  1287,  1289,  1293,  1295,\n+  1296,  1297,  1298,  1299,  1300,  1303,  1306,  1308,  1310,  1314,\n+  1319,  1324,  1330,  1339,  1345,  1347,  1349,  1353,  1355,  1356,\n+  1357,  1360,  1362,  1365,  1369,  1371,  1374,  1381,  1387,  1389,\n+  1391,  1395,  1403,  1406,  1408,  1410,  1414,  1419,  1428,  1433,\n+  1436,  1443,  1445,  1447,  1451,  1454,  1463,  1470,  1472,  1476,\n+  1489,  1491,  1497,  1503,  1507,  1509,  1513,  1516,  1518,  1522,\n+  1525,  1527,  1529,  1533,  1536,  1538,  1540,  1544,  1547,  1549,\n+  1551,  1555,  1561,  1563,  1567,  1574,  1576,  1578,  1580,  1584,\n+  1592,  1595,  1597,  1599,  1603,  1605,  1612,  1620,  1637,  1639,\n+  1641,  1645,  1651,  1656,  1658,  1661,  1663,  1665,  1667,  1668,\n+  1669,  1670,  1674,  1676,  1678,  1683,  1685,  1687,  1689,  1691,\n+  1695,  1698,  1703,  1705,  1710,  1711,  1712,  1713,  1714,  1716,\n+  1718,  1720,  1722,  1724,  1728,  1730,  1733,  1739,  1744,  1748,\n+  1751,  1753,  1755,  1759,  1761,  1763,  1765,  1769,  1772,  1776,\n+  1782,  1784,  1792,  1795,  1797,  1801,  1806,  1814,  1818,  1821,\n+  1823,  1834,  1845,  1850,  1859,  1861,  1865,  1868,  1870,  1875,\n+  1880,  1885,  1892,  1894,  1895,  1896,  1899,  1904,  1909,  1911,\n+  1912,  1914,  1916,  1917,  1919,  1923,  1926,  1930,  1933,  1937,\n+  1939,  1941,  1943,  1944,  1946,  1950,  1958,  1960,  1962,  1974,\n+  1976,  1982,  1984,  1986,  1990,  1992,  1997,  2002,  2007,  2009,\n+  2011,  2015,  2017,  2022,  2027,  2029,  2033,  2035,  2040,  2045,\n+  2050,  2052,  2054,  2058,  2060,  2065,  2070,  2075,  2080,  2082,\n+  2084,  2086,  2088,  2090,  2094,  2096,  2101,  2106,  2108,  2112,\n+  2114,  2119,  2123,  2125,  2130,  2134,  2136,  2141,  2145,  2147,\n+  2152,  2156,  2158,  2163,  2167,  2169,  2174,  2180,  2182,  2186,\n+  2188,  2191,  2194,  2202,  2204,  2205,  2208,  2210,  2213,  2217\n };\n #endif\n \n@@ -2552,66 +2717,66 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 268 \"./parse.y\"\n+#line 433 \"./parse.y\"\n {;\n     break;}\n case 18:\n-#line 312 \"./parse.y\"\n+#line 477 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 19:\n-#line 317 \"./parse.y\"\n+#line 482 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 20:\n-#line 319 \"./parse.y\"\n+#line 484 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 21:\n-#line 321 \"./parse.y\"\n+#line 486 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 22:\n-#line 323 \"./parse.y\"\n+#line 488 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 26:\n-#line 338 \"./parse.y\"\n+#line 503 \"./parse.y\"\n { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 28:\n-#line 347 \"./parse.y\"\n+#line 512 \"./parse.y\"\n {yyval.node = NULL;;\n     break;}\n case 36:\n-#line 359 \"./parse.y\"\n+#line 524 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 37:\n-#line 363 \"./parse.y\"\n+#line 528 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 40:\n-#line 375 \"./parse.y\"\n+#line 540 \"./parse.y\"\n { ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;\n     break;}\n case 41:\n-#line 377 \"./parse.y\"\n+#line 542 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 42:\n-#line 379 \"./parse.y\"\n+#line 544 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 45:\n-#line 389 \"./parse.y\"\n+#line 554 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n@@ -2639,15 +2804,15 @@ case 45:\n \t\t;\n     break;}\n case 46:\n-#line 415 \"./parse.y\"\n+#line 580 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 47:\n-#line 417 \"./parse.y\"\n+#line 582 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 48:\n-#line 422 \"./parse.y\"\n+#line 587 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-3].node);\n \t\t  tree node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n@@ -2661,40 +2826,40 @@ case 48:\n \t\t;\n     break;}\n case 49:\n-#line 434 \"./parse.y\"\n+#line 599 \"./parse.y\"\n {yyerror (\"'*' expected\"); RECOVER;;\n     break;}\n case 50:\n-#line 436 \"./parse.y\"\n+#line 601 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 51:\n-#line 441 \"./parse.y\"\n+#line 606 \"./parse.y\"\n {\n \t\t  maybe_generate_clinit ();\n \t\t  maybe_generate_finit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 53:\n-#line 448 \"./parse.y\"\n+#line 613 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 450 \"./parse.y\"\n+#line 615 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 461 \"./parse.y\"\n+#line 626 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 465 \"./parse.y\"\n+#line 630 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -2708,116 +2873,116 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 481 \"./parse.y\"\n+#line 646 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 58:\n-#line 483 \"./parse.y\"\n+#line 648 \"./parse.y\"\n { \n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 59:\n-#line 487 \"./parse.y\"\n+#line 652 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 60:\n-#line 489 \"./parse.y\"\n+#line 654 \"./parse.y\"\n { \t\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 61:\n-#line 493 \"./parse.y\"\n+#line 658 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 495 \"./parse.y\"\n+#line 660 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 497 \"./parse.y\"\n+#line 662 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); DRECOVER(class1);;\n     break;}\n case 64:\n-#line 499 \"./parse.y\"\n+#line 664 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 503 \"./parse.y\"\n+#line 668 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 505 \"./parse.y\"\n+#line 670 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 507 \"./parse.y\"\n+#line 672 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 509 \"./parse.y\"\n+#line 674 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 513 \"./parse.y\"\n+#line 678 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 515 \"./parse.y\"\n+#line 680 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 517 \"./parse.y\"\n+#line 682 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 525 \"./parse.y\"\n+#line 690 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 530 \"./parse.y\"\n+#line 695 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 535 \"./parse.y\"\n+#line 700 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 540 \"./parse.y\"\n+#line 705 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 76:\n-#line 542 \"./parse.y\"\n+#line 707 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 82:\n-#line 555 \"./parse.y\"\n+#line 720 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"instance initializer\"); ;\n     break;}\n case 85:\n-#line 562 \"./parse.y\"\n+#line 727 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner classe declaration\"); ;\n     break;}\n case 86:\n-#line 564 \"./parse.y\"\n+#line 729 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 87:\n-#line 570 \"./parse.y\"\n+#line 735 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 88:\n-#line 572 \"./parse.y\"\n+#line 737 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -2827,19 +2992,19 @@ case 88:\n \t\t;\n     break;}\n case 90:\n-#line 585 \"./parse.y\"\n+#line 750 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 91:\n-#line 587 \"./parse.y\"\n+#line 752 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 92:\n-#line 592 \"./parse.y\"\n+#line 757 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 93:\n-#line 594 \"./parse.y\"\n+#line 759 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -2848,274 +3013,274 @@ case 93:\n \t\t;\n     break;}\n case 94:\n-#line 601 \"./parse.y\"\n+#line 766 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 95:\n-#line 607 \"./parse.y\"\n+#line 772 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 97:\n-#line 617 \"./parse.y\"\n+#line 782 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 98:\n-#line 619 \"./parse.y\"\n+#line 784 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 99:\n-#line 621 \"./parse.y\"\n+#line 786 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 623 \"./parse.y\"\n+#line 788 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 102:\n-#line 629 \"./parse.y\"\n+#line 794 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 103:\n-#line 635 \"./parse.y\"\n+#line 800 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 104:\n-#line 640 \"./parse.y\"\n+#line 805 \"./parse.y\"\n { complete_method_declaration (yyvsp[0].node); ;\n     break;}\n case 105:\n-#line 642 \"./parse.y\"\n+#line 807 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 106:\n-#line 647 \"./parse.y\"\n+#line 812 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 107:\n-#line 649 \"./parse.y\"\n+#line 814 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 651 \"./parse.y\"\n+#line 816 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 653 \"./parse.y\"\n+#line 818 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 655 \"./parse.y\"\n+#line 820 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 111:\n-#line 657 \"./parse.y\"\n+#line 822 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 112:\n-#line 659 \"./parse.y\"\n+#line 824 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 113:\n-#line 661 \"./parse.y\"\n+#line 826 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 663 \"./parse.y\"\n+#line 828 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 115:\n-#line 671 \"./parse.y\"\n+#line 836 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 116:\n-#line 673 \"./parse.y\"\n+#line 838 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 117:\n-#line 675 \"./parse.y\"\n+#line 840 \"./parse.y\"\n {\n \t\t  /* Issue a warning here: obsolete declaration. FIXME */\n \t\t  yyval.node = NULL;\t/* FIXME */\n \t\t;\n     break;}\n case 118:\n-#line 680 \"./parse.y\"\n+#line 845 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 119:\n-#line 682 \"./parse.y\"\n+#line 847 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 120:\n-#line 687 \"./parse.y\"\n+#line 852 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 121:\n-#line 691 \"./parse.y\"\n+#line 856 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 122:\n-#line 696 \"./parse.y\"\n+#line 861 \"./parse.y\"\n {yyerror (\"Missing formal parameter term\"); RECOVER;;\n     break;}\n case 123:\n-#line 701 \"./parse.y\"\n+#line 866 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 124:\n-#line 705 \"./parse.y\"\n+#line 870 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"final parameters\"); ;\n     break;}\n case 125:\n-#line 707 \"./parse.y\"\n+#line 872 \"./parse.y\"\n {yyerror (\"Missing identifier\"); RECOVER;;\n     break;}\n case 126:\n-#line 709 \"./parse.y\"\n+#line 874 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[-2].value));\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t;\n     break;}\n case 127:\n-#line 716 \"./parse.y\"\n+#line 881 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 128:\n-#line 718 \"./parse.y\"\n+#line 883 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 129:\n-#line 720 \"./parse.y\"\n+#line 885 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 130:\n-#line 725 \"./parse.y\"\n+#line 890 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 131:\n-#line 727 \"./parse.y\"\n+#line 892 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 132:\n-#line 729 \"./parse.y\"\n+#line 894 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 135:\n-#line 736 \"./parse.y\"\n+#line 901 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 136:\n-#line 742 \"./parse.y\"\n+#line 907 \"./parse.y\"\n {\n \t\t  RULE (\"STATIC_INITIALIZER\");\n \t\t;\n     break;}\n case 137:\n-#line 746 \"./parse.y\"\n+#line 911 \"./parse.y\"\n {\n \t\t  RULE (\"STATIC_INITIALIZER\");\n \t\t;\n     break;}\n case 138:\n-#line 753 \"./parse.y\"\n+#line 918 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[0].value));\n \t\t;\n     break;}\n case 139:\n-#line 761 \"./parse.y\"\n+#line 926 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 140:\n-#line 766 \"./parse.y\"\n+#line 931 \"./parse.y\"\n { complete_method_declaration (yyvsp[0].node); ;\n     break;}\n case 141:\n-#line 771 \"./parse.y\"\n+#line 936 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 142:\n-#line 773 \"./parse.y\"\n+#line 938 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 778 \"./parse.y\"\n+#line 943 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 144:\n-#line 780 \"./parse.y\"\n+#line 945 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 145:\n-#line 788 \"./parse.y\"\n+#line 953 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 146:\n-#line 793 \"./parse.y\"\n+#line 958 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 147:\n-#line 795 \"./parse.y\"\n+#line 960 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 148:\n-#line 797 \"./parse.y\"\n+#line 962 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 803 \"./parse.y\"\n+#line 968 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 150:\n-#line 809 \"./parse.y\"\n+#line 974 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 151:\n-#line 817 \"./parse.y\"\n+#line 982 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 152:\n-#line 819 \"./parse.y\"\n+#line 984 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 153:\n-#line 824 \"./parse.y\"\n+#line 989 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node, \n \t\t\t\t\t     input_filename, 0, 0);\n@@ -3124,7 +3289,7 @@ case 153:\n \t\t;\n     break;}\n case 154:\n-#line 831 \"./parse.y\"\n+#line 996 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node,\n \t\t\t\t\t     input_filename, 0, 0);\n@@ -3133,167 +3298,167 @@ case 154:\n \t\t;\n     break;}\n case 155:\n-#line 843 \"./parse.y\"\n+#line 1008 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 156:\n-#line 845 \"./parse.y\"\n+#line 1010 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 157:\n-#line 849 \"./parse.y\"\n+#line 1014 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 158:\n-#line 851 \"./parse.y\"\n+#line 1016 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 159:\n-#line 855 \"./parse.y\"\n+#line 1020 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 160:\n-#line 857 \"./parse.y\"\n+#line 1022 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 161:\n-#line 861 \"./parse.y\"\n+#line 1026 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 162:\n-#line 863 \"./parse.y\"\n+#line 1028 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 163:\n-#line 867 \"./parse.y\"\n+#line 1032 \"./parse.y\"\n {yyerror (\"(here)'{' expected\"); RECOVER;;\n     break;}\n case 164:\n-#line 869 \"./parse.y\"\n+#line 1034 \"./parse.y\"\n {yyerror (\"(there)'{' expected\"); RECOVER;;\n     break;}\n case 165:\n-#line 874 \"./parse.y\"\n+#line 1039 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 166:\n-#line 879 \"./parse.y\"\n+#line 1044 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 167:\n-#line 884 \"./parse.y\"\n+#line 1049 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 168:\n-#line 886 \"./parse.y\"\n+#line 1051 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 169:\n-#line 891 \"./parse.y\"\n+#line 1056 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 170:\n-#line 893 \"./parse.y\"\n+#line 1058 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 175:\n-#line 905 \"./parse.y\"\n+#line 1070 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 176:\n-#line 907 \"./parse.y\"\n+#line 1072 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 178:\n-#line 916 \"./parse.y\"\n+#line 1081 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 179:\n-#line 921 \"./parse.y\"\n+#line 1086 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 180:\n-#line 927 \"./parse.y\"\n+#line 1092 \"./parse.y\"\n {\n \t\t  RULE (\"ARRAY_INITIALIZER (empty)\");\n \t\t;\n     break;}\n case 181:\n-#line 931 \"./parse.y\"\n+#line 1096 \"./parse.y\"\n {\n \t\t  RULE (\"ARRAY_INITIALIZER (variable)\");\n \t\t;\n     break;}\n case 182:\n-#line 935 \"./parse.y\"\n+#line 1100 \"./parse.y\"\n {\n \t\t  RULE (\"ARRAY_INITIALIZER (,)\");\n \t\t;\n     break;}\n case 183:\n-#line 939 \"./parse.y\"\n+#line 1104 \"./parse.y\"\n {\n \t\t  RULE (\"ARRAY_INITIALIZER (variable, ,)\");\n \t\t;\n     break;}\n case 186:\n-#line 948 \"./parse.y\"\n+#line 1113 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 187:\n-#line 954 \"./parse.y\"\n+#line 1119 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 188:\n-#line 956 \"./parse.y\"\n+#line 1121 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 189:\n-#line 961 \"./parse.y\"\n+#line 1126 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 190:\n-#line 966 \"./parse.y\"\n+#line 1131 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  yyval.node = exit_block ();\n \t\t;\n     break;}\n case 194:\n-#line 980 \"./parse.y\"\n+#line 1145 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 195:\n-#line 982 \"./parse.y\"\n+#line 1147 \"./parse.y\"\n { parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 197:\n-#line 991 \"./parse.y\"\n+#line 1156 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 198:\n-#line 993 \"./parse.y\"\n+#line 1158 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 204:\n-#line 1003 \"./parse.y\"\n+#line 1168 \"./parse.y\"\n { \n \t\t  /* If the for loop is unlabeled, we must return the\n \t\t     block it was defined it. It our last chance to\n@@ -3303,11 +3468,11 @@ case 204:\n \t\t;\n     break;}\n case 221:\n-#line 1036 \"./parse.y\"\n+#line 1201 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 222:\n-#line 1041 \"./parse.y\"\n+#line 1206 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3317,27 +3482,27 @@ case 222:\n \t\t;\n     break;}\n case 223:\n-#line 1052 \"./parse.y\"\n+#line 1217 \"./parse.y\"\n { \n \t\t  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);\n \t\t  pop_labeled_block ();\n \t\t  POP_LABELED_BLOCK ();\n \t\t;\n     break;}\n case 224:\n-#line 1058 \"./parse.y\"\n+#line 1223 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 225:\n-#line 1063 \"./parse.y\"\n+#line 1228 \"./parse.y\"\n { \n \t\t  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);\n \t\t  pop_labeled_block ();\n \t\t  POP_LABELED_BLOCK ();\n \t\t;\n     break;}\n case 226:\n-#line 1074 \"./parse.y\"\n+#line 1239 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3348,105 +3513,105 @@ case 226:\n \t\t;\n     break;}\n case 227:\n-#line 1083 \"./parse.y\"\n+#line 1248 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 228:\n-#line 1089 \"./parse.y\"\n+#line 1254 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 229:\n-#line 1095 \"./parse.y\"\n+#line 1260 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 230:\n-#line 1101 \"./parse.y\"\n+#line 1266 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 231:\n-#line 1103 \"./parse.y\"\n+#line 1268 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 232:\n-#line 1109 \"./parse.y\"\n+#line 1274 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 233:\n-#line 1111 \"./parse.y\"\n+#line 1276 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 234:\n-#line 1117 \"./parse.y\"\n+#line 1282 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 235:\n-#line 1119 \"./parse.y\"\n+#line 1284 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 236:\n-#line 1121 \"./parse.y\"\n+#line 1286 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 237:\n-#line 1123 \"./parse.y\"\n+#line 1288 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 238:\n-#line 1125 \"./parse.y\"\n+#line 1290 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 246:\n-#line 1140 \"./parse.y\"\n+#line 1305 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 247:\n-#line 1142 \"./parse.y\"\n+#line 1307 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 248:\n-#line 1144 \"./parse.y\"\n+#line 1309 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 249:\n-#line 1146 \"./parse.y\"\n+#line 1311 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 250:\n-#line 1151 \"./parse.y\"\n+#line 1316 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 251:\n-#line 1156 \"./parse.y\"\n+#line 1321 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 252:\n-#line 1161 \"./parse.y\"\n+#line 1326 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 253:\n-#line 1165 \"./parse.y\"\n+#line 1330 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own COMPOUND_EXPR. */\n@@ -3456,96 +3621,96 @@ case 253:\n \t\t;\n     break;}\n case 254:\n-#line 1176 \"./parse.y\"\n+#line 1341 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 255:\n-#line 1181 \"./parse.y\"\n+#line 1346 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 256:\n-#line 1183 \"./parse.y\"\n+#line 1348 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 257:\n-#line 1185 \"./parse.y\"\n+#line 1350 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 267:\n-#line 1211 \"./parse.y\"\n+#line 1376 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 268:\n-#line 1217 \"./parse.y\"\n+#line 1382 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 269:\n-#line 1223 \"./parse.y\"\n+#line 1388 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 270:\n-#line 1225 \"./parse.y\"\n+#line 1390 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 271:\n-#line 1227 \"./parse.y\"\n+#line 1392 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 272:\n-#line 1232 \"./parse.y\"\n+#line 1397 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 273:\n-#line 1240 \"./parse.y\"\n+#line 1405 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 274:\n-#line 1242 \"./parse.y\"\n+#line 1407 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1244 \"./parse.y\"\n+#line 1409 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 276:\n-#line 1246 \"./parse.y\"\n+#line 1411 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 277:\n-#line 1251 \"./parse.y\"\n+#line 1416 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 278:\n-#line 1256 \"./parse.y\"\n+#line 1421 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 279:\n-#line 1265 \"./parse.y\"\n+#line 1430 \"./parse.y\"\n { yyval.node = complete_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 280:\n-#line 1270 \"./parse.y\"\n+#line 1435 \"./parse.y\"\n { yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 281:\n-#line 1272 \"./parse.y\"\n+#line 1437 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3554,23 +3719,23 @@ case 281:\n \t\t;\n     break;}\n case 282:\n-#line 1279 \"./parse.y\"\n+#line 1444 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 283:\n-#line 1281 \"./parse.y\"\n+#line 1446 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 284:\n-#line 1283 \"./parse.y\"\n+#line 1448 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 285:\n-#line 1288 \"./parse.y\"\n+#line 1453 \"./parse.y\"\n { yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 286:\n-#line 1290 \"./parse.y\"\n+#line 1455 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3579,23 +3744,23 @@ case 286:\n \t\t;\n     break;}\n case 287:\n-#line 1300 \"./parse.y\"\n+#line 1465 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 288:\n-#line 1306 \"./parse.y\"\n+#line 1471 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 289:\n-#line 1308 \"./parse.y\"\n+#line 1473 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 290:\n-#line 1313 \"./parse.y\"\n+#line 1478 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3608,176 +3773,176 @@ case 290:\n \t\t;\n     break;}\n case 291:\n-#line 1325 \"./parse.y\"\n+#line 1490 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 292:\n-#line 1327 \"./parse.y\"\n+#line 1492 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 293:\n-#line 1333 \"./parse.y\"\n+#line 1498 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 294:\n-#line 1339 \"./parse.y\"\n+#line 1504 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 295:\n-#line 1343 \"./parse.y\"\n+#line 1508 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 296:\n-#line 1345 \"./parse.y\"\n+#line 1510 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 297:\n-#line 1350 \"./parse.y\"\n+#line 1515 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 298:\n-#line 1352 \"./parse.y\"\n+#line 1517 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 299:\n-#line 1354 \"./parse.y\"\n+#line 1519 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 300:\n-#line 1359 \"./parse.y\"\n+#line 1524 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 301:\n-#line 1361 \"./parse.y\"\n+#line 1526 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 302:\n-#line 1363 \"./parse.y\"\n+#line 1528 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 303:\n-#line 1365 \"./parse.y\"\n+#line 1530 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 304:\n-#line 1370 \"./parse.y\"\n+#line 1535 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 305:\n-#line 1372 \"./parse.y\"\n+#line 1537 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 306:\n-#line 1374 \"./parse.y\"\n+#line 1539 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 307:\n-#line 1376 \"./parse.y\"\n+#line 1541 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 308:\n-#line 1381 \"./parse.y\"\n+#line 1546 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 309:\n-#line 1383 \"./parse.y\"\n+#line 1548 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 310:\n-#line 1385 \"./parse.y\"\n+#line 1550 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 311:\n-#line 1387 \"./parse.y\"\n+#line 1552 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 312:\n-#line 1392 \"./parse.y\"\n+#line 1557 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 313:\n-#line 1397 \"./parse.y\"\n+#line 1562 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 314:\n-#line 1399 \"./parse.y\"\n+#line 1564 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 315:\n-#line 1404 \"./parse.y\"\n+#line 1569 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 316:\n-#line 1410 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1412 \"./parse.y\"\n+#line 1577 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 318:\n-#line 1414 \"./parse.y\"\n+#line 1579 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 319:\n-#line 1416 \"./parse.y\"\n+#line 1581 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 320:\n-#line 1421 \"./parse.y\"\n+#line 1586 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 321:\n-#line 1429 \"./parse.y\"\n+#line 1594 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 322:\n-#line 1431 \"./parse.y\"\n+#line 1596 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 323:\n-#line 1433 \"./parse.y\"\n+#line 1598 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 324:\n-#line 1435 \"./parse.y\"\n+#line 1600 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 326:\n-#line 1441 \"./parse.y\"\n+#line 1606 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 327:\n-#line 1449 \"./parse.y\"\n+#line 1614 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 328:\n-#line 1457 \"./parse.y\"\n+#line 1622 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -3795,203 +3960,203 @@ case 328:\n \t\t;\n     break;}\n case 329:\n-#line 1473 \"./parse.y\"\n+#line 1638 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 330:\n-#line 1475 \"./parse.y\"\n+#line 1640 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 331:\n-#line 1477 \"./parse.y\"\n+#line 1642 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 332:\n-#line 1482 \"./parse.y\"\n+#line 1647 \"./parse.y\"\n { \n \t\t  yyval.node = build (FINALLY_EXPR, NULL_TREE,\n \t\t\t      create_label_decl (generate_name ()), yyvsp[0].node);\n \t\t;\n     break;}\n case 333:\n-#line 1487 \"./parse.y\"\n+#line 1652 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 337:\n-#line 1499 \"./parse.y\"\n+#line 1664 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 338:\n-#line 1501 \"./parse.y\"\n+#line 1666 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 343:\n-#line 1510 \"./parse.y\"\n+#line 1675 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 344:\n-#line 1512 \"./parse.y\"\n+#line 1677 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 345:\n-#line 1514 \"./parse.y\"\n+#line 1679 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 346:\n-#line 1519 \"./parse.y\"\n+#line 1684 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 347:\n-#line 1521 \"./parse.y\"\n+#line 1686 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 348:\n-#line 1523 \"./parse.y\"\n+#line 1688 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1525 \"./parse.y\"\n+#line 1690 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1527 \"./parse.y\"\n+#line 1692 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1532 \"./parse.y\"\n+#line 1697 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 352:\n-#line 1534 \"./parse.y\"\n+#line 1699 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 353:\n-#line 1539 \"./parse.y\"\n+#line 1704 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 354:\n-#line 1541 \"./parse.y\"\n+#line 1706 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 359:\n-#line 1550 \"./parse.y\"\n+#line 1715 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 360:\n-#line 1552 \"./parse.y\"\n+#line 1717 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1554 \"./parse.y\"\n+#line 1719 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1556 \"./parse.y\"\n+#line 1721 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1558 \"./parse.y\"\n+#line 1723 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1560 \"./parse.y\"\n+#line 1725 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1570 \"./parse.y\"\n+#line 1735 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 368:\n-#line 1575 \"./parse.y\"\n+#line 1740 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 369:\n-#line 1580 \"./parse.y\"\n+#line 1745 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 370:\n-#line 1585 \"./parse.y\"\n+#line 1750 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1587 \"./parse.y\"\n+#line 1752 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 372:\n-#line 1589 \"./parse.y\"\n+#line 1754 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 373:\n-#line 1591 \"./parse.y\"\n+#line 1756 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 374:\n-#line 1595 \"./parse.y\"\n+#line 1760 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1597 \"./parse.y\"\n+#line 1762 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 376:\n-#line 1599 \"./parse.y\"\n+#line 1764 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 377:\n-#line 1601 \"./parse.y\"\n+#line 1766 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 378:\n-#line 1606 \"./parse.y\"\n+#line 1771 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 379:\n-#line 1608 \"./parse.y\"\n+#line 1773 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 380:\n-#line 1613 \"./parse.y\"\n+#line 1778 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 381:\n-#line 1618 \"./parse.y\"\n+#line 1783 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 382:\n-#line 1620 \"./parse.y\"\n+#line 1785 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 383:\n-#line 1629 \"./parse.y\"\n+#line 1794 \"./parse.y\"\n { ctxp->osb_number = 1; ;\n     break;}\n case 384:\n-#line 1631 \"./parse.y\"\n+#line 1796 \"./parse.y\"\n { ctxp->osb_number++; ;\n     break;}\n case 385:\n-#line 1633 \"./parse.y\"\n+#line 1798 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 386:\n-#line 1638 \"./parse.y\"\n+#line 1803 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 387:\n-#line 1642 \"./parse.y\"\n+#line 1807 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node, \n@@ -4001,19 +4166,19 @@ case 387:\n \t\t;\n     break;}\n case 388:\n-#line 1650 \"./parse.y\"\n+#line 1815 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 389:\n-#line 1655 \"./parse.y\"\n+#line 1820 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 390:\n-#line 1657 \"./parse.y\"\n+#line 1822 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 391:\n-#line 1659 \"./parse.y\"\n+#line 1824 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4026,7 +4191,7 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1670 \"./parse.y\"\n+#line 1835 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4039,121 +4204,121 @@ case 392:\n \t\t;\n     break;}\n case 393:\n-#line 1681 \"./parse.y\"\n+#line 1846 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1686 \"./parse.y\"\n+#line 1851 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 395:\n-#line 1695 \"./parse.y\"\n+#line 1860 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1697 \"./parse.y\"\n+#line 1862 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 397:\n-#line 1702 \"./parse.y\"\n+#line 1867 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1704 \"./parse.y\"\n+#line 1869 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 399:\n-#line 1706 \"./parse.y\"\n+#line 1871 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1711 \"./parse.y\"\n+#line 1876 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1716 \"./parse.y\"\n+#line 1881 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1721 \"./parse.y\"\n+#line 1886 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 407:\n-#line 1736 \"./parse.y\"\n+#line 1901 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 408:\n-#line 1741 \"./parse.y\"\n+#line 1906 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 411:\n-#line 1748 \"./parse.y\"\n+#line 1913 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 412:\n-#line 1750 \"./parse.y\"\n+#line 1915 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 1753 \"./parse.y\"\n+#line 1918 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 1755 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 416:\n-#line 1760 \"./parse.y\"\n+#line 1925 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 417:\n-#line 1762 \"./parse.y\"\n+#line 1927 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 1767 \"./parse.y\"\n+#line 1932 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 1769 \"./parse.y\"\n+#line 1934 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 421:\n-#line 1775 \"./parse.y\"\n+#line 1940 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 1777 \"./parse.y\"\n+#line 1942 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 1780 \"./parse.y\"\n+#line 1945 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 1782 \"./parse.y\"\n+#line 1947 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 1787 \"./parse.y\"\n+#line 1952 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (ctxp->osb_number--)\n@@ -4162,15 +4327,15 @@ case 426:\n \t\t;\n     break;}\n case 427:\n-#line 1794 \"./parse.y\"\n+#line 1959 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 1796 \"./parse.y\"\n+#line 1961 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 429:\n-#line 1798 \"./parse.y\"\n+#line 1963 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (ctxp->osb_number--)\n@@ -4184,275 +4349,275 @@ case 429:\n \t\t;\n     break;}\n case 430:\n-#line 1810 \"./parse.y\"\n+#line 1975 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 431:\n-#line 1812 \"./parse.y\"\n+#line 1977 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 432:\n-#line 1818 \"./parse.y\"\n+#line 1983 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 1820 \"./parse.y\"\n+#line 1985 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 434:\n-#line 1822 \"./parse.y\"\n+#line 1987 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 1828 \"./parse.y\"\n+#line 1993 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 437:\n-#line 1833 \"./parse.y\"\n+#line 1998 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 1838 \"./parse.y\"\n+#line 2003 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 439:\n-#line 1843 \"./parse.y\"\n+#line 2008 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 1845 \"./parse.y\"\n+#line 2010 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 441:\n-#line 1847 \"./parse.y\"\n+#line 2012 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 1853 \"./parse.y\"\n+#line 2018 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 1858 \"./parse.y\"\n+#line 2023 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 445:\n-#line 1863 \"./parse.y\"\n+#line 2028 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 1865 \"./parse.y\"\n+#line 2030 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 1871 \"./parse.y\"\n+#line 2036 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 1876 \"./parse.y\"\n+#line 2041 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 1881 \"./parse.y\"\n+#line 2046 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 1886 \"./parse.y\"\n+#line 2051 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 1888 \"./parse.y\"\n+#line 2053 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 1890 \"./parse.y\"\n+#line 2055 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 1896 \"./parse.y\"\n+#line 2061 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 1901 \"./parse.y\"\n+#line 2066 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 1906 \"./parse.y\"\n+#line 2071 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 1911 \"./parse.y\"\n+#line 2076 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 1916 \"./parse.y\"\n+#line 2081 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 460:\n-#line 1918 \"./parse.y\"\n+#line 2083 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 1920 \"./parse.y\"\n+#line 2085 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 1922 \"./parse.y\"\n+#line 2087 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 1924 \"./parse.y\"\n+#line 2089 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 1926 \"./parse.y\"\n+#line 2091 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 466:\n-#line 1932 \"./parse.y\"\n+#line 2097 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 1937 \"./parse.y\"\n+#line 2102 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 1942 \"./parse.y\"\n+#line 2107 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 469:\n-#line 1944 \"./parse.y\"\n+#line 2109 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 1950 \"./parse.y\"\n+#line 2115 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 472:\n-#line 1955 \"./parse.y\"\n+#line 2120 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 1961 \"./parse.y\"\n+#line 2126 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 475:\n-#line 1966 \"./parse.y\"\n+#line 2131 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 477:\n-#line 1972 \"./parse.y\"\n+#line 2137 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 1977 \"./parse.y\"\n+#line 2142 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 480:\n-#line 1983 \"./parse.y\"\n+#line 2148 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 481:\n-#line 1988 \"./parse.y\"\n+#line 2153 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 483:\n-#line 1994 \"./parse.y\"\n+#line 2159 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 484:\n-#line 1999 \"./parse.y\"\n+#line 2164 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 486:\n-#line 2005 \"./parse.y\"\n+#line 2170 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 487:\n-#line 2010 \"./parse.y\"\n+#line 2175 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 488:\n-#line 2016 \"./parse.y\"\n+#line 2181 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 489:\n-#line 2018 \"./parse.y\"\n+#line 2183 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 492:\n-#line 2028 \"./parse.y\"\n+#line 2193 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 493:\n-#line 2030 \"./parse.y\"\n+#line 2195 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4657,7 +4822,7 @@ case 493:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2056 \"./parse.y\"\n+#line 2221 \"./parse.y\"\n \n \f\n \n@@ -4854,7 +5019,8 @@ issue_warning_error_from_context (cl, msg, ap)\n   force_error = 1;\n \n   ctxp->elc.line = EXPR_WFL_LINENO (cl);\n-  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n+  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : \n+\t\t    (EXPR_WFL_COLNO (cl) == 0xffe ? -2 : EXPR_WFL_COLNO (cl)));\n \n   /* We have a CL, that's a good reason for using it if it contains data */\n   saved = ctxp->filename;\n@@ -4909,6 +5075,75 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   va_end (ap);\n }\n \n+static tree\n+find_expr_with_wfl (node)\n+     tree node;\n+{\n+  while (node)\n+    {\n+      char code;\n+      tree to_return;\n+\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase BLOCK:\n+\t  return find_expr_with_wfl (BLOCK_EXPR_BODY (node));\n+\n+\tcase COMPOUND_EXPR:\n+\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  if (to_return)\n+\t    return to_return;\n+\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\t  return to_return;\n+\n+\tcase LOOP_EXPR:\n+\t  return find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  \n+\tcase LABELED_BLOCK_EXPR:\n+\t  return find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\tdefault:\n+\t  code = TREE_CODE_CLASS (TREE_CODE (node));\n+\t  if (((code == '1') || (code == '2') || (code == 'e'))\n+\t      && EXPR_WFL_LINECOL (node))\n+\t    return node;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Issue a missing return statement error. Uses METHOD to figure the\n+   last line of the method the error occurs in.  */\n+\n+static void\n+missing_return_error (method)\n+     tree method;\n+{\n+  EXPR_WFL_SET_LINECOL (wfl_operator, DECL_SOURCE_LINE_LAST (method), -2);\n+  parse_error_context (wfl_operator, \"Missing return statement\");\n+}\n+\n+/* Issue an unreachable statement error. From NODE, find the next\n+   statement to report appropriately.  */\n+static void\n+unreachable_stmt_error (node)\n+     tree node;\n+{\n+  /* Browse node to find the next expression node that has a WFL. Use\n+     the location to report the error */\n+  if (TREE_CODE (node) == COMPOUND_EXPR)\n+    node = find_expr_with_wfl (TREE_OPERAND (node, 1));\n+  else\n+    node = find_expr_with_wfl (node);\n+\n+  if (node)\n+    {\n+      EXPR_WFL_SET_LINECOL (wfl_operator, EXPR_WFL_LINENO (node), -2);\n+      parse_error_context (wfl_operator, \"Unreachable statement\");\n+    }\n+  else\n+    fatal (\"Can't get valid statement - unreachable_stmt_error\");\n+}\n+\n int\n java_report_errors ()\n {\n@@ -5311,7 +5546,7 @@ create_class (flags, id, super, interfaces)\n \t  super_decl_type = TREE_TYPE (super_decl);\n \t}\n       else\n-\tsuper_decl_type =\n+\tsuper_decl_type = \n \t  register_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n     }\n   else if (TREE_TYPE (decl) != object_type_node)\n@@ -5530,7 +5765,7 @@ maybe_generate_finit ()\n \n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_PRIVATE|ACC_FINAL, void_type_node,\n-\t\t\t\t    finit_identifier_node, NULL_TREE);\n+\t\t\t\t    finit_identifier_node, end_params_node);\n   start_artificial_method_body (mdecl);\n \n   ctxp->non_static_initialized = nreverse (ctxp->non_static_initialized);\n@@ -5558,7 +5793,7 @@ maybe_generate_clinit ()\n \n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n-\t\t\t\t    clinit_identifier_node, NULL_TREE);\n+\t\t\t\t    clinit_identifier_node, end_params_node);\n   start_artificial_method_body (mdecl);\n \n   /* Keep initialization in order to enforce 8.5 */\n@@ -5784,7 +6019,7 @@ fix_method_argument_names (orig_arg, meth)\n       TREE_PURPOSE (arg) = this_identifier_node;\n       arg = TREE_CHAIN (arg);\n     }\n-  while (orig_arg)\n+  while (orig_arg != end_params_node)\n     {\n       TREE_PURPOSE (arg) = TREE_PURPOSE (orig_arg);\n       orig_arg = TREE_CHAIN (orig_arg);\n@@ -5975,7 +6210,7 @@ method_declarator (id, list)\n       TREE_CHAIN (arg_node) = arg_types;\n       arg_types = arg_node;\n     }\n-  TYPE_ARG_TYPES (meth) = nreverse (arg_types);\n+  TYPE_ARG_TYPES (meth) = chainon (nreverse (arg_types), end_params_node);\n   node = build_tree_list (id, meth);\n   return node;\n }\n@@ -6569,17 +6804,14 @@ resolve_no_layout (name, cl)\n }\n \n /* Called when reporting errors. Skip leader '[' in a complex array\n-   type description that failed to be resolved. Append a matching\n-   number of [] at the end of a newly allocated string that contains\n-   the type's name part.  */\n+   type description that failed to be resolved.  */\n \n static char *\n purify_type_name (name)\n      char *name;\n {\n   while (*name && *name == '[')\n     name++;\n-\n   return name;\n }\n \n@@ -6711,9 +6943,15 @@ java_get_real_method_name (method_decl)\n   tree method_name = DECL_NAME (method_decl);\n   if (DECL_CONSTRUCTOR_P (method_decl))\n     return init_identifier_node;\n+\n+  /* Explain here why METHOD_DECL doesn't have the DECL_CONSTRUCTUR_P\n+     and still can be a constructor. FIXME */\n+\n   /* Don't confuse method only bearing the name of their class as\n      constructors */\n-  else if (ctxp && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n+  else if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (method_decl))\n+\t   && ctxp\n+\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n \t   && get_access_flags_from_decl (method_decl) <= ACC_PROTECTED\n \t   && TREE_TYPE (TREE_TYPE (method_decl)) == void_type_node)\n     return init_identifier_node;\n@@ -6948,7 +7186,7 @@ java_check_regular_methods (class_decl)\n       flags = (get_access_flags_from_decl (class_decl) & ACC_PUBLIC ?\n \t       ACC_PUBLIC : 0);\n       decl = create_artificial_method (class, flags, void_type_node, \n-\t\t\t\t       init_identifier_node, NULL_TREE);\n+\t\t\t\t       init_identifier_node, end_params_node);\n       DECL_CONSTRUCTOR_P (decl) = 1;\n       layout_class_method (TREE_TYPE (class_decl), NULL_TREE, decl, NULL_TREE);\n     }\n@@ -7639,7 +7877,7 @@ source_start_java_method (fndecl)\n   /* New scope for the function */\n   enter_block ();\n   for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;\n-       tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)\n+       tem != end_params_node; tem = TREE_CHAIN (tem), i++)\n     {\n       tree type = TREE_VALUE (tem);\n       tree name = TREE_PURPOSE (tem);\n@@ -7949,12 +8187,7 @@ java_complete_expand_methods ()\n       /* Make the class data, register it and run the rest of decl\n          compilation on it */\n       if (!java_error_count && ! flag_emit_class_files)\n-\t{\n-\t  make_class_data (current_class);\n-\t  register_class ();\n-\t  rest_of_decl_compilation (TYPE_NAME (current_class), \n-\t\t\t\t    (char*) 0, 1, 0);\n-\t}\n+\tfinish_class (current_class);\n     }\n }\n \n@@ -7995,9 +8228,7 @@ java_complete_expand_method (mdecl)\n \n       if ((block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n-\t{\n-\t  parse_error_context (fbody, \"Missing return statement\");\n-\t}\n+\tmissing_return_error (current_function_decl);\n       \n       /* Don't go any further if we've found error(s) during the\n          expansion */\n@@ -8122,7 +8353,7 @@ verify_constructor_super ()\n       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n \t{\n \t  if (DECL_CONSTRUCTOR_P (mdecl)\n-\t      && !TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))))\n+\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -9196,7 +9427,7 @@ patch_invoke (patch, method, args, from_super)\n   t = TYPE_ARG_TYPES (TREE_TYPE (method));\n   if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n     t = TREE_CHAIN (t);\n-  for (ta = args; t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n+  for (ta = args; t != end_params_node && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n@@ -9282,7 +9513,7 @@ invocation_mode (method, super)\n   if (super)\n     return INVOKE_SUPER;\n \n-  if (access & ACC_STATIC || access & ACC_FINAL)\n+  if (access & ACC_STATIC || access & ACC_FINAL || access & ACC_PRIVATE)\n     return INVOKE_STATIC;\n \n   if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n@@ -9306,7 +9537,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n      tree cl;\n      tree class, name, arg_list;\n {\n-  tree atl = NULL_TREE;\t\t/* Arg Type List */\n+  tree atl = end_params_node;\t\t/* Arg Type List */\n   tree method, signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n@@ -9507,7 +9738,7 @@ argument_types_convertible (m1, m2_or_arglist)\n       m2_arg_cache = m2_arg;\n     }\n \n-  while (m1_arg && m2_arg)\n+  while (m1_arg != end_params_node && m2_arg != end_params_node)\n     {\n       resolve_and_layout (TREE_VALUE (m1_arg), NULL_TREE);\n       if (!valid_method_invocation_conversion_p (TREE_VALUE (m1_arg),\n@@ -9516,7 +9747,7 @@ argument_types_convertible (m1, m2_or_arglist)\n       m1_arg = TREE_CHAIN (m1_arg);\n       m2_arg = TREE_CHAIN (m2_arg);\n     }\n-  return (!m1_arg && !m2_arg ? 1 : 0);\n+  return m1_arg == end_params_node && m2_arg == end_params_node;\n }\n \n /* Qualification routines */\n@@ -9785,11 +10016,7 @@ java_complete_tree (node)\n \t\t    }\n \t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n \t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n-\t\t    {\n-\t\t      SET_WFL_OPERATOR (wfl_operator, *ptr, wfl_op2);\n-\t\t      parse_error_context (wfl_operator, \n-\t\t\t\t\t   \"Unreachable statement\");\n-\t\t    }\n+\t\t    unreachable_stmt_error (*ptr);\n \t\t}\n \t      ptr = next;\n \t    }\n@@ -10029,7 +10256,6 @@ java_complete_tree (node)\n \n     case NEW_CLASS_EXPR:\n     case CALL_EXPR:\n-      CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Complete function's argument(s) first */\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n@@ -10049,6 +10275,7 @@ java_complete_tree (node)\n \t    DECL_CONSTRUCTOR_CALLS (current_function_decl) = \n \t      tree_cons (wfl, decl, \n \t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n+\t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t  return node;\n \t}\n \n@@ -12623,6 +12850,7 @@ build_jump_to_finally (block, decl, finally_label, type)\n   stmt = build (MODIFY_EXPR, void_type_node, decl,\n \t\tbuild_address_of (LABELED_BLOCK_LABEL (new_block)));\n   TREE_SIDE_EFFECTS (stmt) = 1;\n+  CAN_COMPLETE_NORMALLY (stmt) = 1;\n   add_stmt_to_block (block, type, stmt);\n   stmt = build (GOTO_EXPR, void_type_node, finally_label);\n   TREE_SIDE_EFFECTS (stmt) = 1;"}, {"sha": "fa475af6b62b8df94000bc4ec1157b5cce19fe0f", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 164, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -640,169 +640,7 @@ struct parser_ctxt {\n #endif /* JC1_LITE */\n };\n \n-/* Functions declarations */\n #ifndef JC1_LITE\n-static char *java_accstring_lookup PROTO ((int));\n-static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n-static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n-static void  check_modifiers PROTO ((char *, int, int));\n-static tree  create_class PROTO ((int, tree, tree, tree));\n-static tree  create_interface PROTO ((int, tree, tree));\n-static tree  find_field PROTO ((tree, tree));\n-static tree lookup_field_wrapper PROTO ((tree, tree));\n-static int   duplicate_declaration_error_p PROTO ((tree, tree, tree));\n-static void  register_fields PROTO ((int, tree, tree));\n-static tree parser_qualified_classname PROTO ((tree));\n-static int  parser_check_super PROTO ((tree, tree, tree));\n-static int  parser_check_super_interface PROTO ((tree, tree, tree));\n-static void check_modifiers_consistency PROTO ((int));\n-static tree lookup_cl PROTO ((tree));\n-static tree lookup_java_method2 PROTO ((tree, tree, int));\n-static tree method_header PROTO ((int, tree, tree, tree));\n-static void fix_method_argument_names PROTO ((tree ,tree));\n-static tree method_declarator PROTO ((tree, tree));\n-static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n-static void issue_warning_error_from_context PROTO ((tree, char *msg, va_list));\n-static tree parse_jdk1_1_error PROTO ((char *));\n-static void complete_class_report_errors PROTO ((jdep *));\n-static int process_imports PROTO ((void));\n-static void read_import_dir PROTO ((tree));\n-static int find_in_imports_on_demand PROTO ((tree));\n-static int find_in_imports PROTO ((tree));\n-static int check_pkg_class_access PROTO ((tree, tree));\n-static tree resolve_package PROTO ((tree, tree *));\n-static tree lookup_package_type PROTO ((char *, int));\n-static tree resolve_class PROTO ((tree, tree, tree));\n-static tree do_resolve_class PROTO ((tree, tree, tree));\n-static void declare_local_variables PROTO ((int, tree, tree));\n-static void source_start_java_method PROTO ((tree));\n-static void source_end_java_method PROTO ((void));\n-static void expand_start_java_method PROTO ((tree));\n-static tree find_name_in_single_imports PROTO ((tree));\n-static void check_abstract_method_header PROTO ((tree));\n-static tree lookup_java_interface_method2 PROTO ((tree, tree));\n-static tree resolve_expression_name PROTO ((tree, tree *));\n-static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n-static int check_class_interface_creation PROTO ((int, int, tree, \n-\t\t\t\t\t\t  tree, tree, tree));\n-static tree patch_method_invocation PROTO ((tree, tree, tree, \n-\t\t\t\t\t    int *, tree *, int));\n-static int breakdown_qualified PROTO ((tree *, tree *, tree));\n-static tree resolve_and_layout PROTO ((tree, tree));\n-static tree resolve_no_layout PROTO ((tree, tree));\n-static int invocation_mode PROTO ((tree, int));\n-static tree find_applicable_accessible_methods_list PROTO ((int, tree, \n-\t\t\t\t\t\t\t    tree, tree));\n-static tree find_most_specific_methods_list PROTO ((tree));\n-static int argument_types_convertible PROTO ((tree, tree));\n-static tree patch_invoke PROTO ((tree, tree, tree, int));\n-static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n-static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n-static tree obtain_incomplete_type PROTO ((tree));\n-static tree java_complete_tree PROTO ((tree));\n-static void java_complete_expand_method PROTO ((tree));\n-static int  unresolved_type_p PROTO ((tree, tree *));\n-static void create_jdep_list PROTO ((struct parser_ctxt *));\n-static tree build_expr_block PROTO ((tree, tree));\n-static tree enter_block PROTO ((void));\n-static tree enter_a_block PROTO ((tree));\n-static tree exit_block PROTO ((void));\n-static tree lookup_name_in_blocks PROTO ((tree));\n-static void maybe_absorb_scoping_blocks PROTO ((void));\n-static tree build_method_invocation PROTO ((tree, tree));\n-static tree build_new_invocation PROTO ((tree, tree));\n-static tree build_assignment PROTO ((int, int, tree, tree));\n-static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n-static int check_final_assignment PROTO ((tree ,tree));\n-static tree patch_assignment PROTO ((tree, tree, tree ));\n-static tree patch_binop PROTO ((tree, tree, tree));\n-static tree build_unaryop PROTO ((int, int, tree));\n-static tree build_incdec PROTO ((int, int, tree, int));\n-static tree patch_unaryop PROTO ((tree, tree));\n-static tree build_cast PROTO ((int, tree, tree));\n-static tree build_null_of_type PROTO ((tree));\n-static tree patch_cast PROTO ((tree, tree));\n-static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n-static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n-static int valid_cast_to_p PROTO ((tree, tree));\n-static int valid_method_invocation_conversion_p PROTO ((tree, tree));\n-static tree try_builtin_assignconv PROTO ((tree, tree, tree));\n-static tree try_reference_assignconv PROTO ((tree, tree));\n-static tree build_unresolved_array_type PROTO ((tree));\n-static tree build_array_from_name PROTO ((tree, tree, tree, tree *));\n-static tree build_array_ref PROTO ((int, tree, tree));\n-static tree patch_array_ref PROTO ((tree));\n-static tree make_qualified_name PROTO ((tree, tree, int));\n-static tree merge_qualified_name PROTO ((tree, tree));\n-static tree make_qualified_primary PROTO ((tree, tree, int));\n-static int resolve_qualified_expression_name PROTO ((tree, tree *, \n-\t\t\t\t\t\t     tree *, tree *));\n-static void qualify_ambiguous_name PROTO ((tree));\n-static void maybe_generate_clinit PROTO ((void));\n-static tree resolve_field_access PROTO ((tree, tree *, tree *));\n-static tree build_newarray_node PROTO ((tree, tree, int));\n-static tree patch_newarray PROTO ((tree));\n-static tree resolve_type_during_patch PROTO ((tree));\n-static tree build_this PROTO ((int));\n-static tree build_return PROTO ((int, tree));\n-static tree patch_return PROTO ((tree));\n-static tree maybe_access_field PROTO ((tree, tree, tree));\n-static int complete_function_arguments PROTO ((tree));\n-static int check_for_static_method_reference PROTO ((tree, tree, tree, tree, tree));\n-static int not_accessible_p PROTO ((tree, tree, int));\n-static void check_deprecation PROTO ((tree, tree));\n-static int class_in_current_package PROTO ((tree));\n-static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n-static tree patch_if_else_statement PROTO ((tree));\n-static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n-static tree add_stmt_to_block PROTO ((tree, tree, tree));\n-static tree patch_exit_expr PROTO ((tree));\n-static tree build_labeled_block PROTO ((int, tree));\n-static tree generate_labeled_block PROTO (());\n-static tree complete_labeled_statement PROTO ((tree, tree));\n-static tree build_bc_statement PROTO ((int, int, tree));\n-static tree patch_bc_statement PROTO ((tree));\n-static tree patch_loop_statement PROTO ((tree));\n-static tree build_new_loop PROTO ((tree));\n-static tree build_loop_body PROTO ((int, tree, int));\n-static tree complete_loop_body PROTO ((int, tree, tree, int));\n-static tree build_debugable_stmt PROTO ((int, tree));\n-static tree complete_for_loop PROTO ((int, tree, tree, tree));\n-static tree patch_switch_statement PROTO ((tree));\n-static tree string_constant_concatenation PROTO ((tree, tree));\n-static tree build_string_concatenation PROTO ((tree, tree));\n-static tree patch_string_cst PROTO ((tree));\n-static tree patch_string PROTO ((tree));\n-static tree build_jump_to_finally PROTO ((tree, tree, tree, tree));\n-static tree build_try_statement PROTO ((int, tree, tree, tree));\n-static tree patch_try_statement PROTO ((tree));\n-static tree patch_synchronized_statement PROTO ((tree, tree));\n-static tree patch_throw_statement PROTO ((tree, tree));\n-static void check_thrown_exceptions PROTO ((int, tree));\n-static int check_thrown_exceptions_do PROTO ((tree));\n-static void purge_unchecked_exceptions PROTO ((tree));\n-static void check_throws_clauses PROTO ((tree, tree, tree));\n-static void complete_method_declaration PROTO ((tree));\n-static tree build_super_invocation PROTO (());\n-static int verify_constructor_circularity PROTO ((tree, tree));\n-static char *constructor_circularity_msg PROTO ((tree, tree));\n-static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n-\t\t\t\t\t\t\t  int, int));\n-static char *get_printable_method_name PROTO ((tree));\n-static tree patch_conditional_expr PROTO ((tree, tree, tree));\n-static void maybe_generate_finit PROTO (());\n-static void fix_constructors PROTO ((tree));\n-static int verify_constructor_super PROTO (());\n-static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n-static void start_artificial_method_body PROTO ((tree));\n-static void end_artificial_method_body PROTO ((tree));\n-static tree generate_field_initialization_code PROTO ((tree));\n-static int check_method_redefinition PROTO ((tree, tree));\n-static int reset_method_name PROTO ((tree));\n-static void java_check_regular_methods PROTO ((tree));\n-static void java_check_abstract_methods PROTO ((tree));\n-static tree maybe_build_primttype_type_ref PROTO ((tree, tree));\n-\n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));\n void java_check_circular_reference PROTO ((void));\n@@ -813,10 +651,9 @@ char *java_get_line_col PROTO ((char *, int, int));\n void java_expand_switch PROTO ((tree));\n tree java_get_catch_block PROTO ((tree, int));\n int java_report_errors PROTO (());\n-#endif /* JC1_LITE */\n+#endif\n \n /* Always in use, no matter what you compile */\n-\n void java_push_parser_context PROTO ((void));\n void java_pop_parser_context PROTO ((int));\n void java_init_lex PROTO ((void));"}, {"sha": "aa9d076056681f25e01d87f454fb3bd7c23153fa", "filename": "gcc/java/parse.y", "status": "modified", "additions": 246, "deletions": 11, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82371d41c2e0a1e8c68c43748a71bb9deec0ed1a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=82371d41c2e0a1e8c68c43748a71bb9deec0ed1a", "patch": "@@ -69,6 +69,171 @@ definitions and other extensions.  */\n #include \"zipfile.h\"\n #include \"convert.h\"\n \n+/* Local function prototypes */\n+static char *java_accstring_lookup PROTO ((int));\n+static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n+static void  check_modifiers PROTO ((char *, int, int));\n+static tree  create_class PROTO ((int, tree, tree, tree));\n+static tree  create_interface PROTO ((int, tree, tree));\n+static tree  find_field PROTO ((tree, tree));\n+static tree lookup_field_wrapper PROTO ((tree, tree));\n+static int   duplicate_declaration_error_p PROTO ((tree, tree, tree));\n+static void  register_fields PROTO ((int, tree, tree));\n+static tree parser_qualified_classname PROTO ((tree));\n+static int  parser_check_super PROTO ((tree, tree, tree));\n+static int  parser_check_super_interface PROTO ((tree, tree, tree));\n+static void check_modifiers_consistency PROTO ((int));\n+static tree lookup_cl PROTO ((tree));\n+static tree lookup_java_method2 PROTO ((tree, tree, int));\n+static tree method_header PROTO ((int, tree, tree, tree));\n+static void fix_method_argument_names PROTO ((tree ,tree));\n+static tree method_declarator PROTO ((tree, tree));\n+static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n+static void issue_warning_error_from_context PROTO ((tree, char *msg, va_list));\n+static tree parse_jdk1_1_error PROTO ((char *));\n+static void complete_class_report_errors PROTO ((jdep *));\n+static int process_imports PROTO ((void));\n+static void read_import_dir PROTO ((tree));\n+static int find_in_imports_on_demand PROTO ((tree));\n+static int find_in_imports PROTO ((tree));\n+static int check_pkg_class_access PROTO ((tree, tree));\n+static tree resolve_package PROTO ((tree, tree *));\n+static tree lookup_package_type PROTO ((char *, int));\n+static tree resolve_class PROTO ((tree, tree, tree));\n+static tree do_resolve_class PROTO ((tree, tree, tree));\n+static void declare_local_variables PROTO ((int, tree, tree));\n+static void source_start_java_method PROTO ((tree));\n+static void source_end_java_method PROTO ((void));\n+static void expand_start_java_method PROTO ((tree));\n+static tree find_name_in_single_imports PROTO ((tree));\n+static void check_abstract_method_header PROTO ((tree));\n+static tree lookup_java_interface_method2 PROTO ((tree, tree));\n+static tree resolve_expression_name PROTO ((tree, tree *));\n+static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n+static int check_class_interface_creation PROTO ((int, int, tree, \n+\t\t\t\t\t\t  tree, tree, tree));\n+static tree patch_method_invocation PROTO ((tree, tree, tree, \n+\t\t\t\t\t    int *, tree *, int));\n+static int breakdown_qualified PROTO ((tree *, tree *, tree));\n+static tree resolve_and_layout PROTO ((tree, tree));\n+static tree resolve_no_layout PROTO ((tree, tree));\n+static int invocation_mode PROTO ((tree, int));\n+static tree find_applicable_accessible_methods_list PROTO ((int, tree, \n+\t\t\t\t\t\t\t    tree, tree));\n+static tree find_most_specific_methods_list PROTO ((tree));\n+static int argument_types_convertible PROTO ((tree, tree));\n+static tree patch_invoke PROTO ((tree, tree, tree, int));\n+static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n+static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n+static tree obtain_incomplete_type PROTO ((tree));\n+static tree java_complete_tree PROTO ((tree));\n+static void java_complete_expand_method PROTO ((tree));\n+static int  unresolved_type_p PROTO ((tree, tree *));\n+static void create_jdep_list PROTO ((struct parser_ctxt *));\n+static tree build_expr_block PROTO ((tree, tree));\n+static tree enter_block PROTO ((void));\n+static tree enter_a_block PROTO ((tree));\n+static tree exit_block PROTO ((void));\n+static tree lookup_name_in_blocks PROTO ((tree));\n+static void maybe_absorb_scoping_blocks PROTO ((void));\n+static tree build_method_invocation PROTO ((tree, tree));\n+static tree build_new_invocation PROTO ((tree, tree));\n+static tree build_assignment PROTO ((int, int, tree, tree));\n+static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n+static int check_final_assignment PROTO ((tree ,tree));\n+static tree patch_assignment PROTO ((tree, tree, tree ));\n+static tree patch_binop PROTO ((tree, tree, tree));\n+static tree build_unaryop PROTO ((int, int, tree));\n+static tree build_incdec PROTO ((int, int, tree, int));\n+static tree patch_unaryop PROTO ((tree, tree));\n+static tree build_cast PROTO ((int, tree, tree));\n+static tree build_null_of_type PROTO ((tree));\n+static tree patch_cast PROTO ((tree, tree));\n+static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n+static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n+static int valid_cast_to_p PROTO ((tree, tree));\n+static int valid_method_invocation_conversion_p PROTO ((tree, tree));\n+static tree try_builtin_assignconv PROTO ((tree, tree, tree));\n+static tree try_reference_assignconv PROTO ((tree, tree));\n+static tree build_unresolved_array_type PROTO ((tree));\n+static tree build_array_from_name PROTO ((tree, tree, tree, tree *));\n+static tree build_array_ref PROTO ((int, tree, tree));\n+static tree patch_array_ref PROTO ((tree));\n+static tree make_qualified_name PROTO ((tree, tree, int));\n+static tree merge_qualified_name PROTO ((tree, tree));\n+static tree make_qualified_primary PROTO ((tree, tree, int));\n+static int resolve_qualified_expression_name PROTO ((tree, tree *, \n+\t\t\t\t\t\t     tree *, tree *));\n+static void qualify_ambiguous_name PROTO ((tree));\n+static void maybe_generate_clinit PROTO ((void));\n+static tree resolve_field_access PROTO ((tree, tree *, tree *));\n+static tree build_newarray_node PROTO ((tree, tree, int));\n+static tree patch_newarray PROTO ((tree));\n+static tree resolve_type_during_patch PROTO ((tree));\n+static tree build_this PROTO ((int));\n+static tree build_return PROTO ((int, tree));\n+static tree patch_return PROTO ((tree));\n+static tree maybe_access_field PROTO ((tree, tree, tree));\n+static int complete_function_arguments PROTO ((tree));\n+static int check_for_static_method_reference PROTO ((tree, tree, tree, tree, tree));\n+static int not_accessible_p PROTO ((tree, tree, int));\n+static void check_deprecation PROTO ((tree, tree));\n+static int class_in_current_package PROTO ((tree));\n+static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n+static tree patch_if_else_statement PROTO ((tree));\n+static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n+static tree add_stmt_to_block PROTO ((tree, tree, tree));\n+static tree patch_exit_expr PROTO ((tree));\n+static tree build_labeled_block PROTO ((int, tree));\n+static tree generate_labeled_block PROTO (());\n+static tree complete_labeled_statement PROTO ((tree, tree));\n+static tree build_bc_statement PROTO ((int, int, tree));\n+static tree patch_bc_statement PROTO ((tree));\n+static tree patch_loop_statement PROTO ((tree));\n+static tree build_new_loop PROTO ((tree));\n+static tree build_loop_body PROTO ((int, tree, int));\n+static tree complete_loop_body PROTO ((int, tree, tree, int));\n+static tree build_debugable_stmt PROTO ((int, tree));\n+static tree complete_for_loop PROTO ((int, tree, tree, tree));\n+static tree patch_switch_statement PROTO ((tree));\n+static tree string_constant_concatenation PROTO ((tree, tree));\n+static tree build_string_concatenation PROTO ((tree, tree));\n+static tree patch_string_cst PROTO ((tree));\n+static tree patch_string PROTO ((tree));\n+static tree build_jump_to_finally PROTO ((tree, tree, tree, tree));\n+static tree build_try_statement PROTO ((int, tree, tree, tree));\n+static tree patch_try_statement PROTO ((tree));\n+static tree patch_synchronized_statement PROTO ((tree, tree));\n+static tree patch_throw_statement PROTO ((tree, tree));\n+static void check_thrown_exceptions PROTO ((int, tree));\n+static int check_thrown_exceptions_do PROTO ((tree));\n+static void purge_unchecked_exceptions PROTO ((tree));\n+static void check_throws_clauses PROTO ((tree, tree, tree));\n+static void complete_method_declaration PROTO ((tree));\n+static tree build_super_invocation PROTO (());\n+static int verify_constructor_circularity PROTO ((tree, tree));\n+static char *constructor_circularity_msg PROTO ((tree, tree));\n+static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n+\t\t\t\t\t\t\t  int, int));\n+static char *get_printable_method_name PROTO ((tree));\n+static tree patch_conditional_expr PROTO ((tree, tree, tree));\n+static void maybe_generate_finit PROTO (());\n+static void fix_constructors PROTO ((tree));\n+static int verify_constructor_super PROTO (());\n+static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n+static void start_artificial_method_body PROTO ((tree));\n+static void end_artificial_method_body PROTO ((tree));\n+static tree generate_field_initialization_code PROTO ((tree));\n+static int check_method_redefinition PROTO ((tree, tree));\n+static int reset_method_name PROTO ((tree));\n+static void java_check_regular_methods PROTO ((tree));\n+static void java_check_abstract_methods PROTO ((tree));\n+static tree maybe_build_primttype_type_ref PROTO ((tree, tree));\n+static void unreachable_stmt_error PROTO ((tree));\n+static tree find_expr_with_wfl PROTO ((tree));\n+static void missing_return_error PROTO ((tree));\n+\n /* Number of error found so far. */\n int java_error_count; \n /* Number of warning found so far. */\n@@ -2249,7 +2414,8 @@ issue_warning_error_from_context (cl, msg, ap)\n   force_error = 1;\n \n   ctxp->elc.line = EXPR_WFL_LINENO (cl);\n-  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n+  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : \n+\t\t    (EXPR_WFL_COLNO (cl) == 0xffe ? -2 : EXPR_WFL_COLNO (cl)));\n \n   /* We have a CL, that's a good reason for using it if it contains data */\n   saved = ctxp->filename;\n@@ -2304,6 +2470,75 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   va_end (ap);\n }\n \n+static tree\n+find_expr_with_wfl (node)\n+     tree node;\n+{\n+  while (node)\n+    {\n+      char code;\n+      tree to_return;\n+\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase BLOCK:\n+\t  return find_expr_with_wfl (BLOCK_EXPR_BODY (node));\n+\n+\tcase COMPOUND_EXPR:\n+\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  if (to_return)\n+\t    return to_return;\n+\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\t  return to_return;\n+\n+\tcase LOOP_EXPR:\n+\t  return find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  \n+\tcase LABELED_BLOCK_EXPR:\n+\t  return find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\tdefault:\n+\t  code = TREE_CODE_CLASS (TREE_CODE (node));\n+\t  if (((code == '1') || (code == '2') || (code == 'e'))\n+\t      && EXPR_WFL_LINECOL (node))\n+\t    return node;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Issue a missing return statement error. Uses METHOD to figure the\n+   last line of the method the error occurs in.  */\n+\n+static void\n+missing_return_error (method)\n+     tree method;\n+{\n+  EXPR_WFL_SET_LINECOL (wfl_operator, DECL_SOURCE_LINE_LAST (method), -2);\n+  parse_error_context (wfl_operator, \"Missing return statement\");\n+}\n+\n+/* Issue an unreachable statement error. From NODE, find the next\n+   statement to report appropriately.  */\n+static void\n+unreachable_stmt_error (node)\n+     tree node;\n+{\n+  /* Browse node to find the next expression node that has a WFL. Use\n+     the location to report the error */\n+  if (TREE_CODE (node) == COMPOUND_EXPR)\n+    node = find_expr_with_wfl (TREE_OPERAND (node, 1));\n+  else\n+    node = find_expr_with_wfl (node);\n+\n+  if (node)\n+    {\n+      EXPR_WFL_SET_LINECOL (wfl_operator, EXPR_WFL_LINENO (node), -2);\n+      parse_error_context (wfl_operator, \"Unreachable statement\");\n+    }\n+  else\n+    fatal (\"Can't get valid statement - unreachable_stmt_error\");\n+}\n+\n int\n java_report_errors ()\n {\n@@ -4103,9 +4338,15 @@ java_get_real_method_name (method_decl)\n   tree method_name = DECL_NAME (method_decl);\n   if (DECL_CONSTRUCTOR_P (method_decl))\n     return init_identifier_node;\n+\n+  /* Explain here why METHOD_DECL doesn't have the DECL_CONSTRUCTUR_P\n+     and still can be a constructor. FIXME */\n+\n   /* Don't confuse method only bearing the name of their class as\n      constructors */\n-  else if (ctxp && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n+  else if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (method_decl))\n+\t   && ctxp\n+\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n \t   && get_access_flags_from_decl (method_decl) <= ACC_PROTECTED\n \t   && TREE_TYPE (TREE_TYPE (method_decl)) == void_type_node)\n     return init_identifier_node;\n@@ -5382,9 +5623,7 @@ java_complete_expand_method (mdecl)\n \n       if ((block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n-\t{\n-\t  parse_error_context (fbody, \"Missing return statement\");\n-\t}\n+\tmissing_return_error (current_function_decl);\n       \n       /* Don't go any further if we've found error(s) during the\n          expansion */\n@@ -6669,7 +6908,7 @@ invocation_mode (method, super)\n   if (super)\n     return INVOKE_SUPER;\n \n-  if (access & ACC_STATIC || access & ACC_FINAL)\n+  if (access & ACC_STATIC || access & ACC_FINAL || access & ACC_PRIVATE)\n     return INVOKE_STATIC;\n \n   if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n@@ -7172,11 +7411,7 @@ java_complete_tree (node)\n \t\t    }\n \t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n \t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n-\t\t    {\n-\t\t      SET_WFL_OPERATOR (wfl_operator, *ptr, wfl_op2);\n-\t\t      parse_error_context (wfl_operator, \n-\t\t\t\t\t   \"Unreachable statement\");\n-\t\t    }\n+\t\t    unreachable_stmt_error (*ptr);\n \t\t}\n \t      ptr = next;\n \t    }"}]}