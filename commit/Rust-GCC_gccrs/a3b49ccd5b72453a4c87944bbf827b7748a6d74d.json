{"sha": "a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNiNDljY2Q1YjcyNDUzYTRjODc5NDRiYmY4MjdiNzc0OGE2ZDc0ZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-07-07T04:33:01Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-07-07T04:33:01Z"}, "message": "a partial merge.\n\nFrom-SVN: r7668", "tree": {"sha": "6a5a4f5ff2bc44f0d9fe008d0cd62f6c3606e64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a5a4f5ff2bc44f0d9fe008d0cd62f6c3606e64b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/comments", "author": null, "committer": null, "parents": [{"sha": "451c2f82ea4325edcc716a47a7d9b3cf622c829d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451c2f82ea4325edcc716a47a7d9b3cf622c829d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451c2f82ea4325edcc716a47a7d9b3cf622c829d"}], "stats": {"total": 218, "additions": 200, "deletions": 18}, "files": [{"sha": "d0f869cd7800f97339f05aec13453ce81d3d26a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "patch": "@@ -1,3 +1,24 @@\n+Wed Jul  6 20:25:48 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* except.c (init_exception_processing): Setup interim_eh_hook to\n+\tcall lang_interim_eh. \n+\t* except.c (do_unwind): Propagate throw object value across\n+\tstack unwinding.\n+\t* except.c (saved_throw_value): Used to hold the value of the object\n+\tbeing thrown.  It is always a reference to the real value.\n+\t* except.c (expand_start_catch_block): Add handling for the\n+\tvalue of the exception object.\n+\t* except.c (expand_start_catch_block): Add handler for the handler,\n+\tso that throws inside the handler go to the outer block.\n+\t* except.c (expand_end_catch_block): Ditto.\n+\t* parse.y (handler_args): Use parm instead, as the other doesn't yet\n+\thandle references correctly.\n+\n+Wed Jul  6 17:55:32 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* decl2.c (mark_vtable_entries):  If -ftable-thunks, set the\n+\tvtable entry properly to abort.\n+\n Fri Jul  1 09:35:51 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* parse.y (init): ANSI C++ does not forbid { }."}, {"sha": "80bb62aee5cbcbd6dff7eb383e4a6fd15f3e3e40", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "patch": "@@ -2322,6 +2322,8 @@ mark_vtable_entries (decl)\n       if (DECL_ABSTRACT_VIRTUAL_P (fn))\n \t{\n \t  extern tree abort_fndecl;\n+\t  if (flag_vtable_thunks)\n+\t    fnaddr = TREE_VALUE (entries);\n \t  TREE_OPERAND (fnaddr, 0) = abort_fndecl;\n \t}\n     }"}, {"sha": "dc91b9d3b1f0586f796bd8961e64e4a85ed97956", "filename": "gcc/cp/except.c", "status": "modified", "additions": 121, "deletions": 17, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "patch": "@@ -31,6 +31,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"expr.h\"\n \n+extern void (*interim_eh_hook)\tPROTO((tree));\n+\n /* holds the fndecl for __builtin_return_address () */\n tree builtin_return_address_fndecl;\n \n@@ -231,8 +233,10 @@ do_unwind (throw_label)\n   emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n \t\t\t\t\t\t\t Pmode,\n \t\t\t\t\t\t\t throw_label), -8));\n+  /* We use three values, PC, type, and value */\n   easy_expand_asm (\"st %l0,[%fp]\");\n   easy_expand_asm (\"st %l1,[%fp+4]\");\n+  easy_expand_asm (\"st %l2,[%fp+8]\");\n   easy_expand_asm (\"ret\");\n   easy_expand_asm (\"restore\");\n   emit_barrier ();\n@@ -488,10 +492,12 @@ struct exceptStack {\n \n    ========================================================================= */\n \n-/* holds the pc for doing \"throw\" */\n+/* Holds the pc for doing \"throw\" */\n rtx saved_pc;\n-/* holds the type of the thing being thrown. */\n+/* Holds the type of the thing being thrown. */\n rtx saved_throw_type;\n+/* Holds the value being thrown.  */\n+rtx saved_throw_value;\n \n rtx throw_label;\n \n@@ -749,6 +755,15 @@ new_except_stack (stack)\n }\n /* ========================================================================= */\n \n+void\n+lang_interim_eh (finalization)\n+     tree finalization;\n+{\n+  if (finalization)\n+    end_protect (finalization);\n+  else\n+    start_protect ();\n+}\n \n /* sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.\n@@ -772,6 +787,8 @@ init_exception_processing ()\n   tree unwind_fndecl;\n   tree temp, PFV;\n \n+  interim_eh_hook = lang_interim_eh;\n+\n   /* void (*)() */\n   PFV = build_pointer_type (build_function_type (void_type_node, void_list_node));\n \n@@ -844,6 +861,7 @@ init_exception_processing ()\n   throw_label = gen_label_rtx ();\n   saved_pc = gen_rtx (REG, Pmode, 16);\n   saved_throw_type = gen_rtx (REG, Pmode, 17);\n+  saved_throw_value = gen_rtx (REG, Pmode, 18);\n \n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n@@ -949,13 +967,17 @@ expand_start_all_catch ()\n   label = gen_label_rtx ();\n   /* The label for the exception handling block we will save.  */\n   emit_label (label);\n+  \n   push_label_entry (&caught_return_label_stack, label);\n \n   /* Remember where we started. */\n   push_last_insn ();\n \n+  emit_insn (gen_nop ());\n+\n   /* Will this help us not stomp on it? */\n   emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n \n   while (1)\n     {\n@@ -989,14 +1011,14 @@ expand_start_all_catch ()\n   pop_rtl_from_perm ();\n   emit_label (entry->end_label);\n \n-\n   enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n \n   /* After running the finalization, continue on out to the next\n      cleanup, if we have nothing better to do.  */\n   emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry->end_label));\n   /* Will this help us not stomp on it? */\n   emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n   emit_jump (throw_label);\n   emit_label (entry->exception_handler_label);\n   expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n@@ -1029,7 +1051,7 @@ expand_end_all_catch ()\n \n   push_except_stmts (&exceptstack, catchstart, catchend);\n   \n-  /* Here was fall through into the continuation code.  */\n+  /* Here we fall through into the continuation code.  */\n }\n \n \n@@ -1046,6 +1068,7 @@ expand_leftover_cleanups ()\n \n   /* Will this help us not stomp on it? */\n   emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n \n   while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n     {\n@@ -1082,6 +1105,7 @@ expand_leftover_cleanups ()\n       emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry.end_label));\n       /* Will this help us not stomp on it? */\n       emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+      emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n       emit_jump (throw_label);\n       emit_label (entry.exception_handler_label);\n       expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n@@ -1099,23 +1123,53 @@ expand_start_catch_block (declspecs, declarator)\n      tree declspecs, declarator;\n {\n   rtx false_label_rtx;\n+  rtx protect_label_rtx;\n   tree type;\n   tree decl;\n+  tree init;\n \n   if (! doing_eh (1))\n     return;\n \n+  /* Create a binding level for the parm.  */\n+  expand_start_bindings (0);\n+\n   if (declspecs)\n     {\n-      decl = grokdeclarator (declarator, declspecs, PARM, 0, NULL_TREE);\n+      tree init_type;\n+      decl = grokdeclarator (declarator, declspecs, NORMAL, 1, NULL_TREE);\n+\n+      /* Figure out the type that the initializer is. */\n+      init_type = TREE_TYPE (decl);\n+      if (TREE_CODE (init_type) != REFERENCE_TYPE)\n+\tinit_type = build_reference_type (init_type);\n+\n+      init = convert_from_reference (save_expr (make_tree (init_type, saved_throw_value)));\n+      \n+      /* Do we need the below two lines? */\n+      /* Let `finish_decl' know that this initializer is ok.  */\n+      DECL_INITIAL (decl) = init;\n+      /* This needs to be preallocated under the try block,\n+\t in a union of all catch variables. */\n+      pushdecl (decl);\n       type = TREE_TYPE (decl);\n+\n+      /* peel back references, so they match. */\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n     }\n   else\n     type = NULL_TREE;\n \n   false_label_rtx = gen_label_rtx ();\n   push_label_entry (&false_label_stack, false_label_rtx);\n \n+  /* This is saved for the exception table.  */\n+  push_rtl_perm ();\n+  protect_label_rtx = gen_label_rtx ();\n+  pop_rtl_from_perm ();\n+  push_label_entry (&false_label_stack, protect_label_rtx);\n+\n   if (type)\n     {\n       tree params;\n@@ -1143,11 +1197,16 @@ expand_start_catch_block (declspecs, declarator)\n \n       /* if it returned FALSE, jump over the catch block, else fall into it */\n       emit_jump_insn (gen_bne (false_label_rtx));\n+      finish_decl (decl, init, NULL_TREE, 0);\n     }\n   else\n     {\n       /* Fall into the catch all section. */\n     }\n+\n+  /* This is the starting of something to protect.  */\n+  emit_label (protect_label_rtx);\n+\n   emit_line_note (input_filename, lineno);\n }\n \n@@ -1159,11 +1218,45 @@ void expand_end_catch_block ()\n {\n   if (doing_eh (1))\n     {\n+      rtx start_protect_label_rtx;\n+      rtx end_protect_label_rtx;\n+      tree decls;\n+      struct ehEntry entry;\n+\n       /* label we jump to if we caught the exception */\n       emit_jump (top_label_entry (&caught_return_label_stack));\n \n+      /* Code to throw out to outer context, if we get an throw from within\n+\t our catch handler. */\n+      /* These are saved for the exception table.  */\n+      push_rtl_perm ();\n+      entry.exception_handler_label = gen_label_rtx ();\n+      pop_rtl_from_perm ();\n+      emit_label (entry.exception_handler_label);\n+      emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n+\t\t\t\t\t Pmode,\n+\t\t\t\t\t top_label_entry (&caught_return_label_stack)));\n+      emit_jump (throw_label);\n+      /* No associated finalization.  */\n+      entry.finalization = NULL_TREE;\n+\n+      /* Because we are reordered out of line, we have to protect this. */\n+      /* label for the start of the protection region.  */\n+      start_protect_label_rtx = pop_label_entry (&false_label_stack);\n+\n+      /* Cleanup the EH paramater.  */\n+      expand_end_bindings (decls = getdecls (), decls != NULL_TREE, 0);\n+      \n       /* label we emit to jump to if this catch block didn't match. */\n-      emit_label (pop_label_entry (&false_label_stack));\n+      emit_label (end_protect_label_rtx = pop_label_entry (&false_label_stack));\n+\n+      /* Because we are reordered out of line, we have to protect this. */\n+      entry.start_label = start_protect_label_rtx;\n+      entry.end_label = end_protect_label_rtx;\n+\n+      /* These set up a call to throw the caught exception into the outer\n+       context.  */\n+      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n     }\n }\n \n@@ -1300,34 +1393,45 @@ void\n expand_throw (exp)\n      tree exp;\n {\n-  tree raiseid = NULL_TREE;\n-  rtx temp_size;\n   rtx label;\n   tree type;\n \n   if (! doing_eh (1))\n     return;\n \n+  /* This is the label that represents where in the code we were, when\n+     we got an exception.  This needs to be updated when we rethrow an\n+     exception, so that the matching routine knows to search out.  */\n   label = gen_label_rtx ();\n   emit_label (label);\n   emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n \n   if (exp)\n     {\n-      /* throw variable */\n+      /* throw expression */\n       /* First, decay it. */\n       exp = default_conversion (exp);\n       type = TREE_TYPE (exp);\n+\n+      {\n+\tchar *typestring = build_overload_name (type, 1, 1);\n+\ttree throw_type = build1 (ADDR_EXPR, ptr_type_node, combine_strings (build_string (strlen (typestring)+1, typestring)));\n+\trtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n+\trtx throw_value_rtx;\n+\n+\temit_move_insn (saved_throw_type, throw_type_rtx);\n+\texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, NULL_TREE);\n+\tif (exp == error_mark_node)\n+\t  error (\"  in thrown expression\");\n+\tthrow_value_rtx = expand_expr (build_unary_op (ADDR_EXPR, exp, 0), NULL_RTX, VOIDmode, 0);\n+\temit_move_insn (saved_throw_value, throw_value_rtx);\n+      }\n     }\n   else\n-    type = void_type_node;\n-\n-  {\n-    char *typestring = build_overload_name (type, 1, 1);\n-    tree throw_type = build1 (ADDR_EXPR, ptr_type_node, combine_strings (build_string (strlen (typestring)+1, typestring)));\n-    rtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n-    emit_move_insn (saved_throw_type, throw_type_rtx);\n-  }\n+    {\n+      /* rethrow current exception */\n+      /* This part is easy, as we dont' have to do anything else.  */\n+    }\n \n   emit_jump (throw_label);\n }"}, {"sha": "00ff72e8a1bee3ad7681010ace36b19765c57101", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "patch": "@@ -1133,6 +1133,8 @@ This issue is currently under discussion in the core reflector\n @node  Exception Handling, Free Store, Copying Objects, Top\n @section Exception Handling\n \n+Note, exception handling in g++ is still under development.  \n+\n This section describes the mapping of C++ exceptions in the C++\n front-end, into the back-end exception handling framework.\n \n@@ -1150,7 +1152,9 @@ building functions names.  Int's are \"i\", const char * is PCc, etc...\n \n Unfortunately, the standard allows standard type conversions on throw\n parameters so they can match catch handlers.  This means we need a\n-mechanism to handle type conversion at run time, ICK.\n+mechanism to handle type conversion at run time, ICK.  I read this part\n+again, and it appears that we only have to be able to do a few of the\n+conversions at run time, so we should be ok.\n \n In C++, all cleanups should be protected by exception regions.  The\n region starts just after the reason why the cleanup is created has\n@@ -1177,6 +1181,52 @@ hit before the section finishes normally, they examine the list for\n actions to perform.  I hope they add this logic into the back-end, as it\n would be nice to get that alternative approach in C++.\n \n+On an rs6000, xlC stores exception objects on that stack, under the try\n+block.  When is unwinds down into a handler, the frame pointer is\n+adjusted back to the normal value for the frame in which the handler\n+resides, and the stack pointer is left unchanged from the time at which\n+the object was throwed.  This is so that there is always someplace for\n+the exception object, and nothing can overwrite it, once we start\n+throwing.  The only bad part, is that the stack remains large.\n+\n+Flaws in g++'s exception handling.  The stack pointer is restored from\n+stack, we want to match rs6000, and propagate the stack pointer from\n+time of throw, down, to the catch place.\n+\n+Only exact type matching of throw types works (references work also),\n+catch variables cannot be used.  Only works on a Sun sparc running SunOS\n+4.1.x.  Unwinding to outer catch clauses works.  All temps and local\n+variables are cleaned up in all unwinded scopes.  Completed parts of\n+partially constructed objects are not cleaned up.  Don't expect\n+exception handling to work right if you optimize, in fact the compiler\n+will probably core dump.  You can only have one source file worth of\n+exception handling code.  If two EH regions are the exact same size, the\n+backend cannot tell which one is first.  It punts by picking the last\n+one, if they tie.  This is usually right.  We really should stick in a\n+nop, if they are the same size.\n+\n+If we fall off the end of a series of catch blocks, we return to the\n+flow of control in a normal fasion.  But this is wrong, we should\n+rethrow.\n+\n+When we invoke the copy constructor for an exception object because it\n+is passed by value, and if we take a hit (exception) inside the copy\n+constructor someplace, where do we go?  I have tentatively choosen to\n+not catch throws by the outer block at the same unwind level, if one\n+exists, but rather to allow the frame to unwind into the next series of\n+handlers, if any.  If this is the wrong way to do it, we will need to\n+protect the rest of the handler in some fashion.  Maybe just changing\n+the handler's handler to protect the whole series of handlers is the\n+right way to go.\n+\n+The EH object is copied like it should be, if it is passed by value,\n+otherwise we get a reference directly to it.\n+\n+EH objects make it through unwinding, but are subject to being\n+overwritten as they are still past the top of stack.\n+\n+Exceptions in catch handlers now go to outer block.\n+\n @node Free Store, Concept Index, Exception Handling, Top\n @section Free Store\n "}, {"sha": "d30e511bbfb491882b7105b166ec1c0ca95c8f0c", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b49ccd5b72453a4c87944bbf827b7748a6d74d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a3b49ccd5b72453a4c87944bbf827b7748a6d74d", "patch": "@@ -3369,6 +3369,7 @@ type_specifier_seq:\n handler_args:\n \t  '(' ELLIPSIS ')'\n \t\t{ expand_start_catch_block (NULL_TREE, NULL_TREE); }\n+\t/* This doesn't allow reference parameters, the below does.\n \t| '(' type_specifier_seq absdcl ')'\n \t\t{ expand_start_catch_block ($2, $3); }\n \t| '(' type_specifier_seq ')'\n@@ -3377,6 +3378,10 @@ handler_args:\n \t\t{ expand_start_catch_block ($2, $3); }\n \t| '(' typed_typespecs after_type_declarator ')'\n \t\t{ expand_start_catch_block ($2, $3); }\n+\t*/\n+\t| '(' parm ')'\n+\t\t{ expand_start_catch_block (TREE_PURPOSE ($2),\n+\t\t\t\t\t    TREE_VALUE ($2)); }\n \t;\n \n label_colon:"}]}