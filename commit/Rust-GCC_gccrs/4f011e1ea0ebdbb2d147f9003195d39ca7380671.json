{"sha": "4f011e1ea0ebdbb2d147f9003195d39ca7380671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYwMTFlMWVhMGViZGJiMmQxNDdmOTAwMzE5NWQzOWNhNzM4MDY3MQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2008-06-05T23:03:11Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2008-06-05T23:03:11Z"}, "message": "config.gcc (powerpc-*-linux*spe*): Use t-dfprules.\n\n\t* config.gcc (powerpc-*-linux*spe*): Use t-dfprules.\n\t* config/rs6000/dfp.md (negdd2, absdd2, negtd2, abstd2): Do not\n\tenable for TARGET_E500_DOUBLE.\n\t(*movdd_softfloat32): Also enable for !TARGET_FPRS.\n\t* config/rs6000/rs6000.c (invalid_e500_subreg): Treat decimal\n\tfloating-point modes like integer modes for E500 double.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.  Do not allow REG+REG\n\taddressing for DDmode for E500 double.\n\t(rs6000_hard_regno_nregs): Do not treat decimal floating-point\n\tmodes as using 64-bits of registers for E500 double.\n\t(spe_build_register_parallel): Do not handle DDmode or TDmode.\n\t(rs6000_spe_function_arg): Do not handle DDmode or TDmode\n\tspecially for E500 double.\n\t(function_arg): Do not call rs6000_spe_function_arg for DDmode or\n\tTDmode for E500 double.\n\t(rs6000_gimplify_va_arg): Only handle SDmode in registers\n\tspecially if TARGET_HARD_FLOAT && TARGET_FPRS.\n\t(rs6000_split_multireg_move): Do not handle TDmode specially for\n\tE500 double.\n\t(spe_func_has_64bit_regs_p): Do not treat DDmode or TDmode as\n\tusing 64-bit registers for E500 double.\n\t(emit_frame_save): Do not handle DDmode specially for E500 double.\n\t(gen_frame_mem_offset): Likewise.\n\t(rs6000_function_value): Do not call spe_build_register_parallel\n\tfor DDmode or TDmode.\n\t(rs6000_libcall_value): Likewise.\n\t* config/rs6000/rs6000.h (LOCAL_ALIGNMENT, MEMBER_TYPE_FORCES_BLK,\n\tDATA_ALIGNMENT, CLASS_MAX_NREGS): Do not handle DDmode specially\n\tfor E500 double.\n\nFrom-SVN: r136416", "tree": {"sha": "fabdde7e70151a2ab9c05667204d68adddc6b661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fabdde7e70151a2ab9c05667204d68adddc6b661"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f011e1ea0ebdbb2d147f9003195d39ca7380671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f011e1ea0ebdbb2d147f9003195d39ca7380671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f011e1ea0ebdbb2d147f9003195d39ca7380671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f011e1ea0ebdbb2d147f9003195d39ca7380671/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3611e1767daf889bef7de7e867dacfa14527146e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3611e1767daf889bef7de7e867dacfa14527146e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3611e1767daf889bef7de7e867dacfa14527146e"}], "stats": {"total": 118, "additions": 76, "deletions": 42}, "files": [{"sha": "3cb7ec5d3d723a3554b224fb22529b80cd156b59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f011e1ea0ebdbb2d147f9003195d39ca7380671", "patch": "@@ -1,3 +1,36 @@\n+2008-06-05  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config.gcc (powerpc-*-linux*spe*): Use t-dfprules.\n+\t* config/rs6000/dfp.md (negdd2, absdd2, negtd2, abstd2): Do not\n+\tenable for TARGET_E500_DOUBLE.\n+\t(*movdd_softfloat32): Also enable for !TARGET_FPRS.\n+\t* config/rs6000/rs6000.c (invalid_e500_subreg): Treat decimal\n+\tfloating-point modes like integer modes for E500 double.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.  Do not allow REG+REG\n+\taddressing for DDmode for E500 double.\n+\t(rs6000_hard_regno_nregs): Do not treat decimal floating-point\n+\tmodes as using 64-bits of registers for E500 double.\n+\t(spe_build_register_parallel): Do not handle DDmode or TDmode.\n+\t(rs6000_spe_function_arg): Do not handle DDmode or TDmode\n+\tspecially for E500 double.\n+\t(function_arg): Do not call rs6000_spe_function_arg for DDmode or\n+\tTDmode for E500 double.\n+\t(rs6000_gimplify_va_arg): Only handle SDmode in registers\n+\tspecially if TARGET_HARD_FLOAT && TARGET_FPRS.\n+\t(rs6000_split_multireg_move): Do not handle TDmode specially for\n+\tE500 double.\n+\t(spe_func_has_64bit_regs_p): Do not treat DDmode or TDmode as\n+\tusing 64-bit registers for E500 double.\n+\t(emit_frame_save): Do not handle DDmode specially for E500 double.\n+\t(gen_frame_mem_offset): Likewise.\n+\t(rs6000_function_value): Do not call spe_build_register_parallel\n+\tfor DDmode or TDmode.\n+\t(rs6000_libcall_value): Likewise.\n+\t* config/rs6000/rs6000.h (LOCAL_ALIGNMENT, MEMBER_TYPE_FORCES_BLK,\n+\tDATA_ALIGNMENT, CLASS_MAX_NREGS): Do not handle DDmode specially\n+\tfor E500 double.\n+\n 2008-06-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (setup_incoming_varargs_64): Fix a typo"}, {"sha": "399d80c633b0ffeb9a3318a83dbc89b37ec6fe3f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=4f011e1ea0ebdbb2d147f9003195d39ca7380671", "patch": "@@ -1989,7 +1989,7 @@ powerpc-*-linux*altivec*)\n powerpc-*-linux*spe*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxspe.h rs6000/e500.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"t-dfprules rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \t;;\n powerpc-*-linux*paired*)\n         tm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/750cl.h\""}, {"sha": "90eaa2a0d5568fe476928e3fc0cb12c4e184c015", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=4f011e1ea0ebdbb2d147f9003195d39ca7380671", "patch": "@@ -155,7 +155,7 @@\n (define_expand \"negdd2\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n \t(neg:DD (match_operand:DD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"\")\n \n (define_insn \"*negdd2_fpr\"\n@@ -168,7 +168,7 @@\n (define_expand \"absdd2\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n \t(abs:DD (match_operand:DD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"\")\n \n (define_insn \"*absdd2_fpr\"\n@@ -376,7 +376,7 @@\n (define_insn \"*movdd_softfloat32\"\n   [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n \t(match_operand:DD 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n-  \"! TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n+  \"! TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n    && (gpc_reg_operand (operands[0], DDmode)\n        || gpc_reg_operand (operands[1], DDmode))\"\n   \"*\n@@ -486,7 +486,7 @@\n (define_expand \"negtd2\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"\")\n \t(neg:TD (match_operand:TD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"\")\n \n (define_insn \"*negtd2_fpr\"\n@@ -499,7 +499,7 @@\n (define_expand \"abstd2\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"\")\n \t(abs:TD (match_operand:TD 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"\")\n \n (define_insn \"*abstd2_fpr\""}, {"sha": "8493e771ae19cccb7ba47deb8da48ec63dfb3e38", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4f011e1ea0ebdbb2d147f9003195d39ca7380671", "patch": "@@ -3199,24 +3199,26 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n   if (TARGET_E500_DOUBLE)\n     {\n       /* Reject (subreg:SI (reg:DF)); likewise with subreg:DI or\n-\t subreg:TI and reg:TF.  */\n+\t subreg:TI and reg:TF.  Decimal float modes are like integer\n+\t modes (only low part of each register used) for this\n+\t purpose.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && (mode == SImode || mode == DImode || mode == TImode)\n+\t  && (mode == SImode || mode == DImode || mode == TImode\n+\t      || mode == DDmode || mode == TDmode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == DDmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TDmode))\n+\t      || GET_MODE (SUBREG_REG (op)) == TFmode))\n \treturn true;\n \n       /* Reject (subreg:DF (reg:DI)); likewise with subreg:TF and\n \t reg:TI.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && (mode == DFmode || mode == TFmode\n-\t      || mode == DDmode || mode == TDmode)\n+\t  && (mode == DFmode || mode == TFmode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DImode\n-\t      || GET_MODE (SUBREG_REG (op)) == TImode))\n+\t      || GET_MODE (SUBREG_REG (op)) == TImode\n+\t      || GET_MODE (SUBREG_REG (op)) == DDmode\n+\t      || GET_MODE (SUBREG_REG (op)) == TDmode))\n \treturn true;\n     }\n \n@@ -3467,10 +3469,10 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       return SPE_CONST_OFFSET_OK (offset);\n \n     case DFmode:\n-    case DDmode:\n       if (TARGET_E500_DOUBLE)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n+    case DDmode:\n     case DImode:\n       /* On e500v2, we may have:\n \n@@ -3487,11 +3489,11 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       break;\n \n     case TFmode:\n-    case TDmode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n \n+    case TDmode:\n     case TImode:\n       if (mode == TFmode || mode == TDmode || !TARGET_POWERPC64)\n \textra = 12;\n@@ -3638,7 +3640,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && !(SPE_VECTOR_MODE (mode)\n \t   || ALTIVEC_VECTOR_MODE (mode)\n \t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t\t      || mode == DImode))))\n+\t\t\t\t      || mode == DImode || mode == DDmode\n+\t\t\t\t      || mode == TDmode))))\n     {\n       HOST_WIDE_INT high_int, low_int;\n       rtx sum;\n@@ -3655,7 +3658,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t       || TARGET_POWERPC64\n \t       || ((mode != DImode && mode != DFmode && mode != DDmode)\n-\t\t   || TARGET_E500_DOUBLE))\n+\t\t   || (TARGET_E500_DOUBLE && mode != DDmode)))\n \t   && (TARGET_POWERPC64 || mode != DImode)\n \t   && mode != TImode\n \t   && mode != TFmode\n@@ -3704,7 +3707,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n             reg + offset] is not a legitimate addressing mode.  */\n          y = gen_rtx_PLUS (Pmode, op1, op2);\n \n-         if (GET_MODE_SIZE (mode) > 8 && REG_P (op2))\n+         if ((GET_MODE_SIZE (mode) > 8 || mode == DDmode) && REG_P (op2))\n            return force_reg (Pmode, y);\n          else\n            return y;\n@@ -4265,7 +4268,8 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n-\t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n+\t  || (mode != DFmode && mode != DDmode)\n+\t  || (TARGET_E500_DOUBLE && mode != DDmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n@@ -4389,7 +4393,8 @@ rs6000_hard_regno_nregs (int regno, enum machine_mode mode)\n      would require function_arg and rs6000_spe_function_arg to handle\n      SCmode so as to pass the value correctly in a pair of\n      registers.  */\n-  if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode)\n+  if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode\n+      && !DECIMAL_FLOAT_MODE_P (mode))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n \n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n@@ -5664,14 +5669,12 @@ spe_build_register_parallel (enum machine_mode mode, int gregno)\n   switch (mode)\n     {\n     case DFmode:\n-    case DDmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n \n     case DCmode:\n     case TFmode:\n-    case TDmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n@@ -5704,13 +5707,12 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   /* On E500 v2, double arithmetic is done on the full 64-bit GPR, but\n      are passed and returned in a pair of GPRs for ABI compatibility.  */\n   if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t     || mode == DDmode || mode == TDmode\n \t\t\t     || mode == DCmode || mode == TCmode))\n     {\n       int n_words = rs6000_arg_size (mode, type);\n \n       /* Doubles go in an odd/even register pair (r5/r6, etc).  */\n-      if (mode == DFmode || mode == DDmode)\n+      if (mode == DFmode)\n \tgregno += (1 - gregno) & 1;\n \n       /* Multi-reg args are not split between registers and stack.  */\n@@ -6123,10 +6125,8 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   else if (TARGET_SPE_ABI && TARGET_SPE\n \t   && (SPE_VECTOR_MODE (mode)\n \t       || (TARGET_E500_DOUBLE && (mode == DFmode\n-\t\t\t\t\t  || mode == DDmode\n \t\t\t\t\t  || mode == DCmode\n \t\t\t\t\t  || mode == TFmode\n-\t\t\t\t\t  || mode == TDmode\n \t\t\t\t\t  || mode == TCmode))))\n     return rs6000_spe_function_arg (cum, mode, type);\n \n@@ -6885,7 +6885,9 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n       /* _Decimal32 varargs are located in the second word of the 64-bit\n \t FP register for 32-bit binaries.  */\n-      if (!TARGET_POWERPC64 && TYPE_MODE (type) == SDmode)\n+      if (!TARGET_POWERPC64\n+\t  && TARGET_HARD_FLOAT && TARGET_FPRS\n+\t  && TYPE_MODE (type) == SDmode)\n \tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n \n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n@@ -14015,8 +14017,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : DFmode;\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n-  else if (TARGET_E500_DOUBLE && (mode == TFmode || mode == TDmode))\n-    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : DFmode;\n+  else if (TARGET_E500_DOUBLE && mode == TFmode)\n+    reg_mode = DFmode;\n   else\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);\n@@ -14757,8 +14759,7 @@ spe_func_has_64bit_regs_p (void)\n \n \t      if (SPE_VECTOR_MODE (mode))\n \t\treturn true;\n-\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t\t\t || mode == DDmode || mode == TDmode))\n+\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode))\n \t\treturn true;\n \t    }\n \t}\n@@ -15509,7 +15510,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \n   /* Some cases that need register indexed addressing.  */\n   if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n-      || (TARGET_E500_DOUBLE && (mode == DFmode || mode == DDmode))\n+      || (TARGET_E500_DOUBLE && mode == DFmode)\n       || (TARGET_SPE_ABI\n \t  && SPE_VECTOR_MODE (mode)\n \t  && !SPE_CONST_OFFSET_OK (offset)))\n@@ -15549,7 +15550,7 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n   int_rtx = GEN_INT (offset);\n \n   if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode))\n-      || (TARGET_E500_DOUBLE && (mode == DFmode || mode == DDmode)))\n+      || (TARGET_E500_DOUBLE && mode == DFmode))\n     {\n       offset_rtx = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n       emit_move_insn (offset_rtx, int_rtx);\n@@ -21864,8 +21865,8 @@ rs6000_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n \t   && ALTIVEC_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DDmode || mode == DCmode\n-\t       || mode == TFmode || mode == TDmode || mode == TCmode))\n+\t   && (mode == DFmode || mode == DCmode\n+\t       || mode == TFmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -21906,8 +21907,8 @@ rs6000_libcall_value (enum machine_mode mode)\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DDmode || mode == DCmode\n-\t       || mode == TFmode || mode == TDmode || mode == TCmode))\n+\t   && (mode == DFmode || mode == DCmode\n+\t       || mode == TFmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;"}, {"sha": "4c225a3f0e7cac4b31bce3f7774730db2d07f17d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f011e1ea0ebdbb2d147f9003195d39ca7380671/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4f011e1ea0ebdbb2d147f9003195d39ca7380671", "patch": "@@ -583,7 +583,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define LOCAL_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\\\n   ((TARGET_ALTIVEC && TREE_CODE (TYPE) == VECTOR_TYPE) ? 128 :\t\\\n     (TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n-     && (TYPE_MODE (TYPE) == DFmode || TYPE_MODE (TYPE) == DDmode)) ? 64 : \\\n+     && TYPE_MODE (TYPE) == DFmode) ? 64 : \\\n     ((TARGET_SPE && TREE_CODE (TYPE) == VECTOR_TYPE \\\n      && SPE_VECTOR_MODE (TYPE_MODE (TYPE))) || (TARGET_PAIRED_FLOAT \\\n         && TREE_CODE (TYPE) == VECTOR_TYPE \\\n@@ -609,7 +609,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    fit into 1, whereas DI still needs two.  */\n #define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) \\\n   ((TARGET_SPE && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE) \\\n-   || (TARGET_E500_DOUBLE && ((MODE) == DFmode || (MODE) == DDmode)))\n+   || (TARGET_E500_DOUBLE && (MODE) == DFmode))\n \n /* A bit-field declared as `int' forces `int' alignment for the struct.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n@@ -630,7 +630,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n   (TREE_CODE (TYPE) == VECTOR_TYPE ? ((TARGET_SPE_ABI \\\n    || TARGET_PAIRED_FLOAT) ? 64 : 128)\t\\\n    : (TARGET_E500_DOUBLE\t\t\t\\\n-      && (TYPE_MODE (TYPE) == DFmode || TYPE_MODE (TYPE) == DDmode)) ? 64 \\\n+      && TYPE_MODE (TYPE) == DFmode) ? 64 \\\n    : TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n@@ -1212,7 +1212,7 @@ enum reg_class\n  (((CLASS) == FLOAT_REGS) \t\t\t\t\t\t\\\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n   : (TARGET_E500_DOUBLE && (CLASS) == GENERAL_REGS\t\t\t\\\n-     && ((MODE) == DFmode || (MODE) == DDmode))\t\t\t\t\\\n+     && (MODE) == DFmode)\t\t\t\t\\\n   ? 1                                                                   \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n "}]}