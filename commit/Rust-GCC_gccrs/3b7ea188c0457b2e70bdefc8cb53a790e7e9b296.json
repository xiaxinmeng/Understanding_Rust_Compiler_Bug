{"sha": "3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I3ZWExODhjMDQ1N2IyZTcwYmRlZmM4Y2I1M2E3OTBlN2U5YjI5Ng==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-09T09:47:25Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-09T09:47:25Z"}, "message": "f95-lang.c (gfc_init_builtin_functions): Add more floating-point built-ins.\n\n\t* f95-lang.c (gfc_init_builtin_functions): Add more floating-point\n\tbuilt-ins.\n\t* mathbuiltins.def (OTHER_BUILTIN): Define built-ins for logb,\n\tremainder, rint and signbit.\n\t* trans-decl.c (save_fp_state, restore_fp_state): Move to\n\ttrans-intrinsic.c\n\t(gfc_generate_function_code): Use new names for these two functions.\n\t* trans-expr.c (gfc_conv_function_expr): Catch IEEE functions to\n\temit code from the front-end.\n\t* trans-intrinsic.c (gfc_save_fp_state, gfc_restore_fp_state,\n\tconv_ieee_function_args, conv_intrinsic_ieee_builtin,\n\tconv_intrinsic_ieee_is_normal, conv_intrinsic_ieee_is_negative,\n\tconv_intrinsic_ieee_logb_rint, conv_intrinsic_ieee_rem,\n\tconv_intrinsic_ieee_next_after, conv_intrinsic_ieee_scalb,\n\tconv_intrinsic_ieee_copy_sign, gfc_conv_ieee_arithmetic_function):\n\tNew functions.\n\t* trans.h (gfc_conv_ieee_arithmetic_function,\n\tgfc_save_fp_state, gfc_restore_fp_state): New prototypes.\n\n\t* ieee/ieee_helper.c (ieee_is_finite_*, ieee_is_nan_*,\n\tieee_is_negative_*, ieee_is_normal_*, ieee_copy_sign_*,\n\tieee_unordered_*, ieee_logb_*, ieee_rint_*, ieee_scalb_*,\n\tieee_rem_*, ieee_next_after_*): Remove functions.\n\t* gfortran.map (GFORTRAN_1.5): Remove corresponding symbols.\n\nFrom-SVN: r216036", "tree": {"sha": "50e92902ab44fae4fa8b683d332d148d1627916f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50e92902ab44fae4fa8b683d332d148d1627916f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d29866b5bdf7d42d974dc3f91fb2bd834354db"}], "stats": {"total": 796, "additions": 442, "deletions": 354}, "files": [{"sha": "68f47d4bbba0eb9847bbbf98b936607b2f137295", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -1,3 +1,24 @@\n+2014-10-09  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* f95-lang.c (gfc_init_builtin_functions): Add more floating-point\n+\tbuilt-ins.\n+\t* mathbuiltins.def (OTHER_BUILTIN): Define built-ins for logb,\n+\tremainder, rint and signbit.\n+\t* trans-decl.c (save_fp_state, restore_fp_state): Move to\n+\ttrans-intrinsic.c\n+\t(gfc_generate_function_code): Use new names for these two functions.\n+\t* trans-expr.c (gfc_conv_function_expr): Catch IEEE functions to\n+\temit code from the front-end.\n+\t* trans-intrinsic.c (gfc_save_fp_state, gfc_restore_fp_state,\n+\tconv_ieee_function_args, conv_intrinsic_ieee_builtin,\n+\tconv_intrinsic_ieee_is_normal, conv_intrinsic_ieee_is_negative,\n+\tconv_intrinsic_ieee_logb_rint, conv_intrinsic_ieee_rem,\n+\tconv_intrinsic_ieee_next_after, conv_intrinsic_ieee_scalb,\n+\tconv_intrinsic_ieee_copy_sign, gfc_conv_ieee_arithmetic_function):\n+\tNew functions.\n+\t* trans.h (gfc_conv_ieee_arithmetic_function,\n+\tgfc_save_fp_state, gfc_restore_fp_state): New prototypes.\n+\n 2014-10-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR fortran/44054"}, {"sha": "66cd3a331488bb07d8efc767262da5c7d7c30777", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -563,6 +563,7 @@ gfc_builtin_function (tree decl)\n #define ATTR_NOTHROW_LEAF_LIST\t\t(ECF_NOTHROW | ECF_LEAF)\n #define ATTR_NOTHROW_LEAF_MALLOC_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_MALLOC)\n #define ATTR_CONST_NOTHROW_LEAF_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_CONST)\n+#define ATTR_PURE_NOTHROW_LEAF_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_PURE)\n #define ATTR_NOTHROW_LIST\t\t(ECF_NOTHROW)\n #define ATTR_CONST_NOTHROW_LIST\t\t(ECF_NOTHROW | ECF_CONST)\n \n@@ -683,6 +684,8 @@ gfc_init_builtin_functions (void)\n   tree ftype, ptype;\n   tree builtin_types[(int) BT_LAST + 1];\n \n+  int attr;\n+\n   build_builtin_fntypes (mfunc_float, float_type_node);\n   build_builtin_fntypes (mfunc_double, double_type_node);\n   build_builtin_fntypes (mfunc_longdouble, long_double_type_node);\n@@ -770,6 +773,32 @@ gfc_init_builtin_functions (void)\n \t\t      BUILT_IN_NEXTAFTERF, \"nextafterf\",\n \t\t      ATTR_CONST_NOTHROW_LEAF_LIST);\n  \n+  /* Some built-ins depend on rounding mode. Depending on compilation options, they\n+     will be \"pure\" or \"const\".  */\n+  attr = flag_rounding_math ? ATTR_PURE_NOTHROW_LEAF_LIST : ATTR_CONST_NOTHROW_LEAF_LIST;\n+\n+  gfc_define_builtin (\"__builtin_rintl\", mfunc_longdouble[0], \n+\t\t      BUILT_IN_RINTL, \"rintl\", attr);\n+  gfc_define_builtin (\"__builtin_rint\", mfunc_double[0], \n+\t\t      BUILT_IN_RINT, \"rint\", attr);\n+  gfc_define_builtin (\"__builtin_rintf\", mfunc_float[0], \n+\t\t      BUILT_IN_RINTF, \"rintf\", attr);\n+\n+  gfc_define_builtin (\"__builtin_remainderl\", mfunc_longdouble[1], \n+\t\t      BUILT_IN_REMAINDERL, \"remainderl\", attr);\n+  gfc_define_builtin (\"__builtin_remainder\", mfunc_double[1], \n+\t\t      BUILT_IN_REMAINDER, \"remainder\", attr);\n+  gfc_define_builtin (\"__builtin_remainderf\", mfunc_float[1], \n+\t\t      BUILT_IN_REMAINDERF, \"remainderf\", attr);\n+ \n+  gfc_define_builtin (\"__builtin_logbl\", mfunc_longdouble[0], \n+\t\t      BUILT_IN_LOGBL, \"logbl\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_logb\", mfunc_double[0], \n+\t\t      BUILT_IN_LOGB, \"logb\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_logbf\", mfunc_float[0], \n+\t\t      BUILT_IN_LOGBF, \"logbf\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n+\n   gfc_define_builtin (\"__builtin_frexpl\", mfunc_longdouble[4], \n \t\t      BUILT_IN_FREXPL, \"frexpl\", ATTR_NOTHROW_LEAF_LIST);\n   gfc_define_builtin (\"__builtin_frexp\", mfunc_double[4], \n@@ -960,6 +989,34 @@ gfc_init_builtin_functions (void)\n                                     void_type_node, NULL_TREE);\n   gfc_define_builtin (\"__builtin_isnan\", ftype, BUILT_IN_ISNAN,\n \t\t      \"__builtin_isnan\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_isfinite\", ftype, BUILT_IN_ISFINITE,\n+\t\t      \"__builtin_isfinite\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_isnormal\", ftype, BUILT_IN_ISNORMAL,\n+\t\t      \"__builtin_isnormal\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n+  ftype = build_function_type_list (integer_type_node, void_type_node,\n+\t\t\t\t    void_type_node, NULL_TREE);\n+  gfc_define_builtin (\"__builtin_isunordered\", ftype, BUILT_IN_ISUNORDERED,\n+\t\t      \"__builtin_isunordered\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_islessequal\", ftype, BUILT_IN_ISLESSEQUAL,\n+\t\t      \"__builtin_islessequal\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_isgreaterequal\", ftype,\n+\t\t      BUILT_IN_ISGREATEREQUAL, \"__builtin_isgreaterequal\",\n+\t\t      ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n+  ftype = build_function_type_list (integer_type_node,\n+                                    float_type_node, NULL_TREE); \n+  gfc_define_builtin(\"__builtin_signbitf\", ftype, BUILT_IN_SIGNBITF,\n+\t\t     \"signbitf\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  ftype = build_function_type_list (integer_type_node,\n+                                    double_type_node, NULL_TREE); \n+  gfc_define_builtin(\"__builtin_signbit\", ftype, BUILT_IN_SIGNBIT,\n+\t\t     \"signbit\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  ftype = build_function_type_list (integer_type_node,\n+                                    long_double_type_node, NULL_TREE); \n+  gfc_define_builtin(\"__builtin_signbitl\", ftype, BUILT_IN_SIGNBITL,\n+\t\t     \"signbitl\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n \n #define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n   builtin_types[(int) ENUM] = VALUE;"}, {"sha": "848da7cc7639cc349342e1adb5229dbd670a2ba5", "filename": "gcc/fortran/mathbuiltins.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -62,11 +62,15 @@ OTHER_BUILTIN (CPOW,      \"cpow\",      cpow,    true)\n OTHER_BUILTIN (FABS,      \"fabs\",      1,       true)\n OTHER_BUILTIN (FMOD,      \"fmod\",      2,       true)\n OTHER_BUILTIN (FREXP,     \"frexp\",     frexp,   false)\n+OTHER_BUILTIN (LOGB,      \"logb\",      1,       true)\n OTHER_BUILTIN (LLROUND,   \"llround\",   llround, true)\n OTHER_BUILTIN (LROUND,    \"lround\",    lround,  true)\n OTHER_BUILTIN (IROUND,    \"iround\",    iround,  true)\n OTHER_BUILTIN (NEXTAFTER, \"nextafter\", 2,       true)\n-OTHER_BUILTIN (POW,       \"pow\",       1,       true)\n+OTHER_BUILTIN (POW,       \"pow\",       2,       true)\n+OTHER_BUILTIN (REMAINDER, \"remainder\", 2,       true)\n+OTHER_BUILTIN (RINT,      \"rint\",      1,       true)\n OTHER_BUILTIN (ROUND,     \"round\",     1,       true)\n OTHER_BUILTIN (SCALBN,    \"scalbn\",    scalbn,  true)\n+OTHER_BUILTIN (SIGNBIT,   \"signbit\",   iround,  true)\n OTHER_BUILTIN (TRUNC,     \"trunc\",     1,       true)"}, {"sha": "92b350e10f649e88748ecfdf5f4505c24b74e210", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -5619,36 +5619,6 @@ is_ieee_module_used (gfc_namespace *ns)\n }\n \n \n-static tree\n-save_fp_state (stmtblock_t *block)\n-{\n-  tree type, fpstate, tmp;\n-\n-  type = build_array_type (char_type_node,\n-\t                   build_range_type (size_type_node, size_zero_node,\n-\t\t\t\t\t     size_int (32)));\n-  fpstate = gfc_create_var (type, \"fpstate\");\n-  fpstate = gfc_build_addr_expr (pvoid_type_node, fpstate);\n-\n-  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_entry,\n-\t\t\t     1, fpstate);\n-  gfc_add_expr_to_block (block, tmp);\n-\n-  return fpstate;\n-}\n-\n-\n-static void\n-restore_fp_state (stmtblock_t *block, tree fpstate)\n-{\n-  tree tmp;\n-\n-  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_exit,\n-\t\t\t     1, fpstate);\n-  gfc_add_expr_to_block (block, tmp);\n-}\n-\n-\n /* Generate code for a function.  */\n \n void\n@@ -5760,7 +5730,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n      the floating point state.  */\n   ieee = is_ieee_module_used (ns);\n   if (ieee)\n-    fpstate = save_fp_state (&init);\n+    fpstate = gfc_save_fp_state (&init);\n \n   /* Now generate the code for the body of this function.  */\n   gfc_init_block (&body);\n@@ -5847,7 +5817,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   /* If IEEE modules are loaded, restore the floating-point state.  */\n   if (ieee)\n-    restore_fp_state (&cleanup, fpstate);\n+    gfc_restore_fp_state (&cleanup, fpstate);\n \n   /* Finish the function body and add init and cleanup code.  */\n   tmp = gfc_finish_block (&body);"}, {"sha": "18bc502a7c87ff615e328a801bb57fd557bbba08", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -5768,6 +5768,11 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   if (!sym)\n     sym = expr->symtree->n.sym;\n \n+  /* The IEEE_ARITHMETIC functions are caught here. */\n+  if (sym->from_intmod == INTMOD_IEEE_ARITHMETIC)\n+    if (gfc_conv_ieee_arithmetic_function (se, expr))\n+      return;\n+\n   /* We distinguish statement functions from general functions to improve\n      runtime performance.  */\n   if (sym->attr.proc == PROC_ST_FUNCTION)"}, {"sha": "b157b950ecc42232e03781844f5750e8ad3b1c01", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -7171,6 +7171,342 @@ conv_isocbinding_subroutine (gfc_code *code)\n }\n \n \n+/* Save and restore floating-point state.  */\n+\n+tree\n+gfc_save_fp_state (stmtblock_t *block)\n+{\n+  tree type, fpstate, tmp;\n+\n+  type = build_array_type (char_type_node,\n+\t                   build_range_type (size_type_node, size_zero_node,\n+\t\t\t\t\t     size_int (GFC_FPE_STATE_BUFFER_SIZE)));\n+  fpstate = gfc_create_var (type, \"fpstate\");\n+  fpstate = gfc_build_addr_expr (pvoid_type_node, fpstate);\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_entry,\n+\t\t\t     1, fpstate);\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return fpstate;\n+}\n+\n+\n+void\n+gfc_restore_fp_state (stmtblock_t *block, tree fpstate)\n+{\n+  tree tmp;\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_exit,\n+\t\t\t     1, fpstate);\n+  gfc_add_expr_to_block (block, tmp);\n+}\n+\n+\n+/* Generate code for arguments of IEEE functions.  */\n+\n+static void\n+conv_ieee_function_args (gfc_se *se, gfc_expr *expr, tree *argarray,\n+\t\t\t int nargs)\n+{\n+  gfc_actual_arglist *actual;\n+  gfc_expr *e;\n+  gfc_se argse;\n+  int arg;\n+\n+  actual = expr->value.function.actual;\n+  for (arg = 0; arg < nargs; arg++, actual = actual->next)\n+    {\n+      gcc_assert (actual);\n+      e = actual->expr;\n+\n+      gfc_init_se (&argse, se);\n+      gfc_conv_expr_val (&argse, e);\n+\n+      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      gfc_add_block_to_block (&se->post, &argse.post);\n+      argarray[arg] = argse.expr;\n+    }\n+}\n+\n+\n+/* Generate code for intrinsics IEEE_IS_NAN, IEEE_IS_FINITE,\n+   and IEEE_UNORDERED, which translate directly to GCC type-generic\n+   built-ins.  */\n+\n+static void\n+conv_intrinsic_ieee_builtin (gfc_se * se, gfc_expr * expr,\n+\t\t\t     enum built_in_function code, int nargs)\n+{\n+  tree args[2];\n+  gcc_assert ((unsigned) nargs <= sizeof(args)/sizeof(args[0]));\n+\n+  conv_ieee_function_args (se, expr, args, nargs);\n+  se->expr = build_call_expr_loc_array (input_location,\n+\t\t\t\t\tbuiltin_decl_explicit (code),\n+\t\t\t\t\tnargs, args);\n+  STRIP_TYPE_NOPS (se->expr);\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n+}\n+\n+\n+/* Generate code for IEEE_IS_NORMAL intrinsic:\n+     IEEE_IS_NORMAL(x) --> (__builtin_isnormal(x) || x == 0)  */\n+\n+static void\n+conv_intrinsic_ieee_is_normal (gfc_se * se, gfc_expr * expr)\n+{\n+  tree arg, isnormal, iszero;\n+\n+  /* Convert arg, evaluate it only once.  */\n+  conv_ieee_function_args (se, expr, &arg, 1);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  isnormal = build_call_expr_loc (input_location,\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_ISNORMAL),\n+\t\t\t\t  1, arg);\n+  iszero = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+\t\t\t    build_real_from_int_cst (TREE_TYPE (arg),\n+\t\t\t\t\t\t     integer_zero_node));\n+  se->expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t      boolean_type_node, isnormal, iszero);\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n+}\n+\n+\n+/* Generate code for IEEE_IS_NEGATIVE intrinsic:\n+     IEEE_IS_NEGATIVE(x) --> (__builtin_signbit(x) && !__builtin_isnan(x))  */\n+\n+static void\n+conv_intrinsic_ieee_is_negative (gfc_se * se, gfc_expr * expr)\n+{\n+  tree arg, signbit, isnan, decl;\n+  int argprec;\n+\n+  /* Convert arg, evaluate it only once.  */\n+  conv_ieee_function_args (se, expr, &arg, 1);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  isnan = build_call_expr_loc (input_location,\n+\t\t\t       builtin_decl_explicit (BUILT_IN_ISNAN),\n+\t\t\t       1, arg);\n+  STRIP_TYPE_NOPS (isnan);\n+\n+  argprec = TYPE_PRECISION (TREE_TYPE (arg));\n+  decl = builtin_decl_for_precision (BUILT_IN_SIGNBIT, argprec);\n+  signbit = build_call_expr_loc (input_location, decl, 1, arg);\n+  signbit = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     signbit, integer_zero_node);\n+\n+  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t      boolean_type_node, signbit,\n+\t\t\t      fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\t       TREE_TYPE(isnan), isnan));\n+\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n+}\n+\n+\n+/* Generate code for IEEE_LOGB and IEEE_RINT.  */\n+\n+static void\n+conv_intrinsic_ieee_logb_rint (gfc_se * se, gfc_expr * expr,\n+\t\t\t       enum built_in_function code)\n+{\n+  tree arg, decl, call, fpstate;\n+  int argprec;\n+\n+  conv_ieee_function_args (se, expr, &arg, 1);\n+  argprec = TYPE_PRECISION (TREE_TYPE (arg));\n+  decl = builtin_decl_for_precision (code, argprec);\n+\n+  /* Save floating-point state.  */\n+  fpstate = gfc_save_fp_state (&se->pre);\n+\n+  /* Make the function call.  */\n+  call = build_call_expr_loc (input_location, decl, 1, arg);\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), call);\n+\n+  /* Restore floating-point state.  */\n+  gfc_restore_fp_state (&se->post, fpstate);\n+}\n+\n+\n+/* Generate code for IEEE_REM.  */\n+\n+static void\n+conv_intrinsic_ieee_rem (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[2], decl, call, fpstate;\n+  int argprec;\n+\n+  conv_ieee_function_args (se, expr, args, 2);\n+\n+  /* If arguments have unequal size, convert them to the larger.  */\n+  if (TYPE_PRECISION (TREE_TYPE (args[0]))\n+      > TYPE_PRECISION (TREE_TYPE (args[1])))\n+    args[1] = fold_convert (TREE_TYPE (args[0]), args[1]);\n+  else if (TYPE_PRECISION (TREE_TYPE (args[1]))\n+\t   > TYPE_PRECISION (TREE_TYPE (args[0])))\n+    args[0] = fold_convert (TREE_TYPE (args[1]), args[0]);\n+\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[0]));\n+  decl = builtin_decl_for_precision (BUILT_IN_REMAINDER, argprec);\n+\n+  /* Save floating-point state.  */\n+  fpstate = gfc_save_fp_state (&se->pre);\n+\n+  /* Make the function call.  */\n+  call = build_call_expr_loc_array (input_location, decl, 2, args);\n+  se->expr = fold_convert (TREE_TYPE (args[0]), call);\n+\n+  /* Restore floating-point state.  */\n+  gfc_restore_fp_state (&se->post, fpstate);\n+}\n+\n+\n+/* Generate code for IEEE_NEXT_AFTER.  */\n+\n+static void\n+conv_intrinsic_ieee_next_after (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[2], decl, call, fpstate;\n+  int argprec;\n+\n+  conv_ieee_function_args (se, expr, args, 2);\n+\n+  /* Result has the characteristics of first argument.  */\n+  args[1] = fold_convert (TREE_TYPE (args[0]), args[1]);\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[0]));\n+  decl = builtin_decl_for_precision (BUILT_IN_NEXTAFTER, argprec);\n+\n+  /* Save floating-point state.  */\n+  fpstate = gfc_save_fp_state (&se->pre);\n+\n+  /* Make the function call.  */\n+  call = build_call_expr_loc_array (input_location, decl, 2, args);\n+  se->expr = fold_convert (TREE_TYPE (args[0]), call);\n+\n+  /* Restore floating-point state.  */\n+  gfc_restore_fp_state (&se->post, fpstate);\n+}\n+\n+\n+/* Generate code for IEEE_SCALB.  */\n+\n+static void\n+conv_intrinsic_ieee_scalb (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[2], decl, call, huge, type;\n+  int argprec, n;\n+\n+  conv_ieee_function_args (se, expr, args, 2);\n+\n+  /* Result has the characteristics of first argument.  */\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[0]));\n+  decl = builtin_decl_for_precision (BUILT_IN_SCALBN, argprec);\n+\n+  if (TYPE_PRECISION (TREE_TYPE (args[1])) > TYPE_PRECISION (integer_type_node))\n+    {\n+      /* We need to fold the integer into the range of a C int.  */\n+      args[1] = gfc_evaluate_now (args[1], &se->pre);\n+      type = TREE_TYPE (args[1]);\n+\n+      n = gfc_validate_kind (BT_INTEGER, gfc_c_int_kind, false);\n+      huge = gfc_conv_mpz_to_tree (gfc_integer_kinds[n].huge,\n+\t\t\t\t   gfc_c_int_kind);\n+      huge = fold_convert (type, huge);\n+      args[1] = fold_build2_loc (input_location, MIN_EXPR, type, args[1],\n+\t\t\t\t huge);\n+      args[1] = fold_build2_loc (input_location, MAX_EXPR, type, args[1],\n+\t\t\t\t fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t\t\t  type, huge));\n+    }\n+\n+  args[1] = fold_convert (integer_type_node, args[1]);\n+\n+  /* Make the function call.  */\n+  call = build_call_expr_loc_array (input_location, decl, 2, args);\n+  se->expr = fold_convert (TREE_TYPE (args[0]), call);\n+}\n+\n+\n+/* Generate code for IEEE_COPY_SIGN.  */\n+\n+static void\n+conv_intrinsic_ieee_copy_sign (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[2], decl, sign;\n+  int argprec;\n+\n+  conv_ieee_function_args (se, expr, args, 2);\n+\n+  /* Get the sign of the second argument.  */\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[1]));\n+  decl = builtin_decl_for_precision (BUILT_IN_SIGNBIT, argprec);\n+  sign = build_call_expr_loc (input_location, decl, 1, args[1]);\n+  sign = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  sign, integer_zero_node);\n+\n+  /* Create a value of one, with the right sign.  */\n+  sign = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+\t\t\t  sign,\n+\t\t\t  fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t\t   integer_type_node,\n+\t\t\t\t\t   integer_one_node),\n+\t\t\t  integer_one_node);\n+  args[1] = fold_convert (TREE_TYPE (args[0]), sign);\n+\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[0]));\n+  decl = builtin_decl_for_precision (BUILT_IN_COPYSIGN, argprec);\n+\n+  se->expr = build_call_expr_loc_array (input_location, decl, 2, args);\n+}\n+\n+\n+/* Generate code for an intrinsic function from the IEEE_ARITHMETIC\n+   module.  */\n+\n+bool\n+gfc_conv_ieee_arithmetic_function (gfc_se * se, gfc_expr * expr)\n+{\n+  const char *name = expr->value.function.name;\n+\n+#define STARTS_WITH(A,B) (strncmp((A), (B), strlen(B)) == 0)\n+\n+  if (STARTS_WITH (name, \"_gfortran_ieee_is_nan\"))\n+    conv_intrinsic_ieee_builtin (se, expr, BUILT_IN_ISNAN, 1);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_is_finite\"))\n+    conv_intrinsic_ieee_builtin (se, expr, BUILT_IN_ISFINITE, 1);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_unordered\"))\n+    conv_intrinsic_ieee_builtin (se, expr, BUILT_IN_ISUNORDERED, 2);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_is_normal\"))\n+    conv_intrinsic_ieee_is_normal (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_is_negative\"))\n+    conv_intrinsic_ieee_is_negative (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_copy_sign\"))\n+    conv_intrinsic_ieee_copy_sign (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_scalb\"))\n+    conv_intrinsic_ieee_scalb (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_next_after\"))\n+    conv_intrinsic_ieee_next_after (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_rem\"))\n+    conv_intrinsic_ieee_rem (se, expr);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_logb\"))\n+    conv_intrinsic_ieee_logb_rint (se, expr, BUILT_IN_LOGB);\n+  else if (STARTS_WITH (name, \"_gfortran_ieee_rint\"))\n+    conv_intrinsic_ieee_logb_rint (se, expr, BUILT_IN_RINT);\n+  else\n+    /* It is not among the functions we translate directly.  We return\n+       false, so a library function call is emitted.  */\n+    return false;\n+\n+#undef STARTS_WITH\n+\n+  return true;\n+}\n+\n+\n /* Generate code for an intrinsic function.  Some map directly to library\n    calls, others get special handling.  In some cases the name of the function\n    used depends on the type specifiers.  */"}, {"sha": "70719e4bc8af02183ddf0119e79f33c22cdc6948", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -437,6 +437,10 @@ tree size_of_string_in_bytes (int, tree);\n /* Intrinsic procedure handling.  */\n tree gfc_conv_intrinsic_subroutine (gfc_code *);\n void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n+bool gfc_conv_ieee_arithmetic_function (gfc_se *, gfc_expr *);\n+tree gfc_save_fp_state (stmtblock_t *);\n+void gfc_restore_fp_state (stmtblock_t *, tree);\n+\n \n /* Does an intrinsic map directly to an external library call\n    This is true for array-returning intrinsics, unless\n@@ -792,6 +796,10 @@ extern GTY(()) tree gfor_fndecl_sc_kind;\n extern GTY(()) tree gfor_fndecl_si_kind;\n extern GTY(()) tree gfor_fndecl_sr_kind;\n \n+/* IEEE-related.  */\n+extern GTY(()) tree gfor_fndecl_ieee_procedure_entry;\n+extern GTY(()) tree gfor_fndecl_ieee_procedure_exit;\n+\n \n /* True if node is an integer constant.  */\n #define INTEGER_CST_P(node) (TREE_CODE(node) == INTEGER_CST)"}, {"sha": "cf04401982ec8ace44068e68884eb503e5835ca8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -1,3 +1,11 @@\n+2014-10-09  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* ieee/ieee_helper.c (ieee_is_finite_*, ieee_is_nan_*,\n+\tieee_is_negative_*, ieee_is_normal_*, ieee_copy_sign_*,\n+\tieee_unordered_*, ieee_logb_*, ieee_rint_*, ieee_scalb_*,\n+\tieee_rem_*, ieee_next_after_*): Remove functions.\n+\t* gfortran.map (GFORTRAN_1.5): Remove corresponding symbols.\n+\n 2014-10-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/63460"}, {"sha": "cfbfb160a52a1b31122f926fc8acad01d1cba6dc", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -1197,38 +1197,8 @@ GFORTRAN_1.5 {\n \n GFORTRAN_1.6 {\n   global:\n-    _gfortran_ieee_copy_sign_4_4_;\n-    _gfortran_ieee_copy_sign_4_8_;\n-    _gfortran_ieee_copy_sign_8_4_;\n-    _gfortran_ieee_copy_sign_8_8_;\n-    _gfortran_ieee_is_finite_4_;\n-    _gfortran_ieee_is_finite_8_;\n-    _gfortran_ieee_is_nan_4_;\n-    _gfortran_ieee_is_nan_8_;\n-    _gfortran_ieee_is_negative_4_;\n-    _gfortran_ieee_is_negative_8_;\n-    _gfortran_ieee_is_normal_4_;\n-    _gfortran_ieee_is_normal_8_;\n-    _gfortran_ieee_logb_4_;\n-    _gfortran_ieee_logb_8_;\n-    _gfortran_ieee_next_after_4_4_;\n-    _gfortran_ieee_next_after_4_8_;\n-    _gfortran_ieee_next_after_8_4_;\n-    _gfortran_ieee_next_after_8_8_;\n     _gfortran_ieee_procedure_entry;\n     _gfortran_ieee_procedure_exit;\n-    _gfortran_ieee_rem_4_4_;\n-    _gfortran_ieee_rem_4_8_;\n-    _gfortran_ieee_rem_8_4_;\n-    _gfortran_ieee_rem_8_8_;\n-    _gfortran_ieee_rint_4_;\n-    _gfortran_ieee_rint_8_;\n-    _gfortran_ieee_scalb_4_;\n-    _gfortran_ieee_scalb_8_;\n-    _gfortran_ieee_unordered_4_4_;\n-    _gfortran_ieee_unordered_4_8_;\n-    _gfortran_ieee_unordered_8_4_;\n-    _gfortran_ieee_unordered_8_8_;\n     __ieee_arithmetic_MOD_ieee_class_4;\n     __ieee_arithmetic_MOD_ieee_class_8;\n     __ieee_arithmetic_MOD_ieee_class_type_eq;"}, {"sha": "023fbc38499b1d023b8e3ec3f509469e511b0f7b", "filename": "libgfortran/ieee/ieee_helper.c", "status": "modified", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b7ea188c0457b2e70bdefc8cb53a790e7e9b296/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=3b7ea188c0457b2e70bdefc8cb53a790e7e9b296", "patch": "@@ -33,31 +33,6 @@ internal_proto(ieee_class_helper_4);\n extern int ieee_class_helper_8 (GFC_REAL_8 *);\n internal_proto(ieee_class_helper_8);\n \n-extern int ieee_is_finite_4_ (GFC_REAL_4 *);\n-export_proto(ieee_is_finite_4_);\n-\n-extern int ieee_is_finite_8_ (GFC_REAL_8 *);\n-export_proto(ieee_is_finite_8_);\n-\n-extern int ieee_is_nan_4_ (GFC_REAL_4 *);\n-export_proto(ieee_is_nan_4_);\n-\n-extern int ieee_is_nan_8_ (GFC_REAL_8 *);\n-export_proto(ieee_is_nan_8_);\n-\n-extern int ieee_is_negative_4_ (GFC_REAL_4 *);\n-export_proto(ieee_is_negative_4_);\n-\n-extern int ieee_is_negative_8_ (GFC_REAL_8 *);\n-export_proto(ieee_is_negative_8_);\n-\n-extern int ieee_is_normal_4_ (GFC_REAL_4 *);\n-export_proto(ieee_is_normal_4_);\n-\n-extern int ieee_is_normal_8_ (GFC_REAL_8 *);\n-export_proto(ieee_is_normal_8_);\n-\n-\n /* Enumeration of the possible floating-point types. These values\n    correspond to the hidden arguments of the IEEE_CLASS_TYPE\n    derived-type of IEEE_ARITHMETIC.  */\n@@ -100,272 +75,6 @@ CLASSMACRO(4)\n CLASSMACRO(8)\n \n \n-/* Testing functions.  */\n-\n-int ieee_is_finite_4_ (GFC_REAL_4 *val)\n-{\n-  return __builtin_isfinite(*val) ? 1 : 0;\n-}\n-\n-int ieee_is_finite_8_ (GFC_REAL_8 *val)\n-{\n-  return __builtin_isfinite(*val) ? 1 : 0;\n-}\n-\n-int ieee_is_nan_4_ (GFC_REAL_4 *val)\n-{\n-  return __builtin_isnan(*val) ? 1 : 0;\n-}\n-\n-int ieee_is_nan_8_ (GFC_REAL_8 *val)\n-{\n-  return __builtin_isnan(*val) ? 1 : 0;\n-}\n-\n-int ieee_is_negative_4_ (GFC_REAL_4 *val)\n-{\n-  return (__builtin_signbit(*val) && !__builtin_isnan(*val)) ? 1 : 0;\n-}\n-\n-int ieee_is_negative_8_ (GFC_REAL_8 *val)\n-{\n-  return (__builtin_signbit(*val) && !__builtin_isnan(*val)) ? 1 : 0;\n-}\n-\n-int ieee_is_normal_4_ (GFC_REAL_4 *val)\n-{\n-  return (__builtin_isnormal(*val) || *val == 0) ? 1 : 0;\n-}\n-\n-int ieee_is_normal_8_ (GFC_REAL_8 *val)\n-{\n-  return (__builtin_isnormal(*val) || *val == 0) ? 1 : 0;\n-}\n-\n-GFC_REAL_4 ieee_copy_sign_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n-export_proto(ieee_copy_sign_4_4_);\n-GFC_REAL_4 ieee_copy_sign_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n-{\n-  GFC_REAL_4 s = __builtin_signbit(*y) ? -1 : 1;\n-  return __builtin_copysign(*x, s);\n-}\n-\n-GFC_REAL_4 ieee_copy_sign_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n-export_proto(ieee_copy_sign_4_8_);\n-GFC_REAL_4 ieee_copy_sign_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n-{\n-  GFC_REAL_4 s = __builtin_signbit(*y) ? -1 : 1;\n-  return __builtin_copysign(*x, s);\n-}\n-\n-GFC_REAL_8 ieee_copy_sign_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n-export_proto(ieee_copy_sign_8_4_);\n-GFC_REAL_8 ieee_copy_sign_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n-{\n-  GFC_REAL_8 s = __builtin_signbit(*y) ? -1 : 1;\n-  return __builtin_copysign(*x, s);\n-}\n-\n-GFC_REAL_8 ieee_copy_sign_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n-export_proto(ieee_copy_sign_8_8_);\n-GFC_REAL_8 ieee_copy_sign_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n-{\n-  GFC_REAL_8 s = __builtin_signbit(*y) ? -1 : 1;\n-  return __builtin_copysign(*x, s);\n-}\n-\n-int ieee_unordered_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n-export_proto(ieee_unordered_4_4_);\n-int ieee_unordered_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n-{\n-  return __builtin_isunordered(*x, *y);\n-}\n-\n-int ieee_unordered_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n-export_proto(ieee_unordered_4_8_);\n-int ieee_unordered_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n-{\n-  return __builtin_isunordered(*x, *y);\n-}\n-\n-int ieee_unordered_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n-export_proto(ieee_unordered_8_4_);\n-int ieee_unordered_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n-{\n-  return __builtin_isunordered(*x, *y);\n-}\n-\n-int ieee_unordered_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n-export_proto(ieee_unordered_8_8_);\n-int ieee_unordered_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n-{\n-  return __builtin_isunordered(*x, *y);\n-}\n-\n-\n-/* Arithmetic functions (LOGB, NEXT_AFTER, REM, RINT, SCALB).  */\n-\n-GFC_REAL_4 ieee_logb_4_ (GFC_REAL_4 *);\n-export_proto(ieee_logb_4_);\n-\n-GFC_REAL_4 ieee_logb_4_ (GFC_REAL_4 *x)\n-{\n-  GFC_REAL_4 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_logb (*x);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_8 ieee_logb_8_ (GFC_REAL_8 *);\n-export_proto(ieee_logb_8_);\n-\n-GFC_REAL_8 ieee_logb_8_ (GFC_REAL_8 *x)\n-{\n-  GFC_REAL_8 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_logb (*x);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_4 ieee_next_after_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n-export_proto(ieee_next_after_4_4_);\n-\n-GFC_REAL_4 ieee_next_after_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n-{\n-  return __builtin_nextafterf (*x, *y);\n-}\n-\n-GFC_REAL_4 ieee_next_after_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n-export_proto(ieee_next_after_4_8_);\n-\n-GFC_REAL_4 ieee_next_after_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n-{\n-  return __builtin_nextafterf (*x, *y);\n-}\n-\n-GFC_REAL_8 ieee_next_after_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n-export_proto(ieee_next_after_8_4_);\n-\n-GFC_REAL_8 ieee_next_after_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n-{\n-  return __builtin_nextafter (*x, *y);\n-}\n-\n-GFC_REAL_8 ieee_next_after_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n-export_proto(ieee_next_after_8_8_);\n-\n-GFC_REAL_8 ieee_next_after_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n-{\n-  return __builtin_nextafter (*x, *y);\n-}\n-\n-GFC_REAL_4 ieee_rem_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n-export_proto(ieee_rem_4_4_);\n-\n-GFC_REAL_4 ieee_rem_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n-{\n-  GFC_REAL_4 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_remainderf (*x, *y);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_8 ieee_rem_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n-export_proto(ieee_rem_4_8_);\n-\n-GFC_REAL_8 ieee_rem_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n-{\n-  GFC_REAL_8 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_remainder (*x, *y);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_8 ieee_rem_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n-export_proto(ieee_rem_8_4_);\n-\n-GFC_REAL_8 ieee_rem_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n-{\n-  GFC_REAL_8 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_remainder (*x, *y);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_8 ieee_rem_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n-export_proto(ieee_rem_8_8_);\n-\n-GFC_REAL_8 ieee_rem_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n-{\n-  GFC_REAL_8 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_remainder (*x, *y);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_4 ieee_rint_4_ (GFC_REAL_4 *);\n-export_proto(ieee_rint_4_);\n-\n-GFC_REAL_4 ieee_rint_4_ (GFC_REAL_4 *x)\n-{\n-  GFC_REAL_4 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_rint (*x);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_8 ieee_rint_8_ (GFC_REAL_8 *);\n-export_proto(ieee_rint_8_);\n-\n-GFC_REAL_8 ieee_rint_8_ (GFC_REAL_8 *x)\n-{\n-  GFC_REAL_8 res;\n-  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n-\n-  get_fpu_state (buffer);\n-  res = __builtin_rint (*x);\n-  set_fpu_state (buffer);\n-  return res;\n-}\n-\n-GFC_REAL_4 ieee_scalb_4_ (GFC_REAL_4 *, int *);\n-export_proto(ieee_scalb_4_);\n-\n-GFC_REAL_4 ieee_scalb_4_ (GFC_REAL_4 *x, int *i)\n-{\n-  return __builtin_scalbnf (*x, *i);\n-}\n-\n-GFC_REAL_8 ieee_scalb_8_ (GFC_REAL_8 *, int *);\n-export_proto(ieee_scalb_8_);\n-\n-GFC_REAL_8 ieee_scalb_8_ (GFC_REAL_8 *x, int *i)\n-{\n-  return __builtin_scalbn (*x, *i);\n-}\n-\n-\n #define GFC_FPE_ALL (GFC_FPE_INVALID | GFC_FPE_DENORMAL | \\\n \t\t     GFC_FPE_ZERO | GFC_FPE_OVERFLOW | \\\n \t\t     GFC_FPE_UNDERFLOW | GFC_FPE_INEXACT)"}]}