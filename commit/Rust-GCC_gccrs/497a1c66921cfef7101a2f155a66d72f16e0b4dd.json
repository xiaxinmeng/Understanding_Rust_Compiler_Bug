{"sha": "497a1c66921cfef7101a2f155a66d72f16e0b4dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3YTFjNjY5MjFjZmVmNzEwMWEyZjE1NWE2NmQ3MmYxNmUwYjRkZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-11-12T16:18:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-11-12T16:18:59Z"}, "message": "* asan.c: Formatting cleanups.\n\nFrom-SVN: r193442", "tree": {"sha": "ab062f6e151a39e7ef05776d02ede94121ddd941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab062f6e151a39e7ef05776d02ede94121ddd941"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/497a1c66921cfef7101a2f155a66d72f16e0b4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497a1c66921cfef7101a2f155a66d72f16e0b4dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497a1c66921cfef7101a2f155a66d72f16e0b4dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497a1c66921cfef7101a2f155a66d72f16e0b4dd/comments", "author": null, "committer": null, "parents": [{"sha": "f35db108b96cac4fd3f2b62024ed93ac006ff932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35db108b96cac4fd3f2b62024ed93ac006ff932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35db108b96cac4fd3f2b62024ed93ac006ff932"}], "stats": {"total": 206, "additions": 104, "deletions": 102}, "files": [{"sha": "5e781c44fb4b22594ba7086d11dee68315bc6daf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497a1c66921cfef7101a2f155a66d72f16e0b4dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497a1c66921cfef7101a2f155a66d72f16e0b4dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=497a1c66921cfef7101a2f155a66d72f16e0b4dd", "patch": "@@ -1,4 +1,8 @@\n-2012-11-12  Wei Mi <wmi@google.com>\n+2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* asan.c: Formatting cleanups.\n+\n+2012-11-12  Wei Mi  <wmi@google.com>\n \n \t* gcc.c (LINK_COMMAND_SPEC): Add -lasan to link command if\n \t-faddress-sanitizer is on.\n@@ -28,7 +32,6 @@\n \t* asan.c (create_cond_insert_point_before_iter): Factorize out of ...\n \t(build_check_stmt): ... here.\n \n-\n 2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n \n \t* asan.c (create_cond_insert_point_before_iter): Factorize out of ...\n@@ -40,7 +43,7 @@\n \trepresented by an SSA_NAME.\n \n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n-\t    Wei Mi <wmi@google.com>\n+\t    Wei Mi  <wmi@google.com>\n \n \t* varasm.c: Include asan.h.\n \t(assemble_noswitch_variable): Grow size by asan_red_zone_size\n@@ -111,7 +114,7 @@\n \n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n \t    Xinliang David Li  <davidxl@google.com>\n-\t    Dodji Seketeli <dodji@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n \n \t* Makefile.in (GTFILES): Add $(srcdir)/asan.c.\n \t(asan.o): Update the dependencies of asan.o.\n@@ -155,9 +158,9 @@\n \t* config/i386/i386.c (ix86_asan_shadow_offset): New function.\n \t(TARGET_ASAN_SHADOW_OFFSET): Define.\n \n-2012-11-12  Wei Mi <wmi@google.com>\n-\t    Diego Novillo <dnovillo@google.com>\n-\t    Dodji Seketeli <dodji@redhat.com>\n+2012-11-12  Wei Mi  <wmi@google.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n \n \t* Makefile.in: Add asan.c and its dependencies.\n \t* common.opt: Add -faddress-sanitizer option."}, {"sha": "6e7f20f7189ad4d9f2dc2909a234cfd7b94d2002", "filename": "gcc/asan.c", "status": "modified", "additions": 94, "deletions": 95, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497a1c66921cfef7101a2f155a66d72f16e0b4dd/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497a1c66921cfef7101a2f155a66d72f16e0b4dd/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=497a1c66921cfef7101a2f155a66d72f16e0b4dd", "patch": "@@ -33,42 +33,41 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"output.h\"\n \n-/*\n- AddressSanitizer finds out-of-bounds and use-after-free bugs \n- with <2x slowdown on average.\n-\n- The tool consists of two parts:\n- instrumentation module (this file) and a run-time library.\n- The instrumentation module adds a run-time check before every memory insn.\n-   For a 8- or 16- byte load accessing address X:\n-     ShadowAddr = (X >> 3) + Offset\n-     ShadowValue = *(char*)ShadowAddr;  // *(short*) for 16-byte access.\n-     if (ShadowValue)\n-       __asan_report_load8(X);\n-   For a load of N bytes (N=1, 2 or 4) from address X:\n-     ShadowAddr = (X >> 3) + Offset\n-     ShadowValue = *(char*)ShadowAddr;\n-     if (ShadowValue)\n-       if ((X & 7) + N - 1 > ShadowValue)\n-         __asan_report_loadN(X);\n- Stores are instrumented similarly, but using __asan_report_storeN functions.\n- A call too __asan_init() is inserted to the list of module CTORs.\n-\n- The run-time library redefines malloc (so that redzone are inserted around\n- the allocated memory) and free (so that reuse of free-ed memory is delayed),\n- provides __asan_report* and __asan_init functions.\n-\n- Read more:\n- http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n-\n- The current implementation supports detection of out-of-bounds and\n- use-after-free in the heap, on the stack and for global variables.\n-\n- [Protection of stack variables]\n-\n- To understand how detection of out-of-bounds and use-after-free works\n- for stack variables, lets look at this example on x86_64 where the\n- stack grows downward:\n+/* AddressSanitizer finds out-of-bounds and use-after-free bugs\n+   with <2x slowdown on average.\n+\n+   The tool consists of two parts:\n+   instrumentation module (this file) and a run-time library.\n+   The instrumentation module adds a run-time check before every memory insn.\n+     For a 8- or 16- byte load accessing address X:\n+       ShadowAddr = (X >> 3) + Offset\n+       ShadowValue = *(char*)ShadowAddr;  // *(short*) for 16-byte access.\n+       if (ShadowValue)\n+\t __asan_report_load8(X);\n+     For a load of N bytes (N=1, 2 or 4) from address X:\n+       ShadowAddr = (X >> 3) + Offset\n+       ShadowValue = *(char*)ShadowAddr;\n+       if (ShadowValue)\n+\t if ((X & 7) + N - 1 > ShadowValue)\n+\t   __asan_report_loadN(X);\n+   Stores are instrumented similarly, but using __asan_report_storeN functions.\n+   A call too __asan_init() is inserted to the list of module CTORs.\n+\n+   The run-time library redefines malloc (so that redzone are inserted around\n+   the allocated memory) and free (so that reuse of free-ed memory is delayed),\n+   provides __asan_report* and __asan_init functions.\n+\n+   Read more:\n+   http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n+\n+   The current implementation supports detection of out-of-bounds and\n+   use-after-free in the heap, on the stack and for global variables.\n+\n+   [Protection of stack variables]\n+\n+   To understand how detection of out-of-bounds and use-after-free works\n+   for stack variables, lets look at this example on x86_64 where the\n+   stack grows downward:\n \n      int\n      foo ()\n@@ -82,28 +81,28 @@ along with GCC; see the file COPYING3.  If not see\n        return a[5] + b[1];\n      }\n \n- For this function, the stack protected by asan will be organized as\n- follows, from the top of the stack to the bottom:\n+   For this function, the stack protected by asan will be organized as\n+   follows, from the top of the stack to the bottom:\n \n- Slot 1/ [red zone of 32 bytes called 'RIGHT RedZone']\n+   Slot 1/ [red zone of 32 bytes called 'RIGHT RedZone']\n \n- Slot 2/ [8 bytes of red zone, that adds up to the space of 'a' to make\n-\t  the next slot be 32 bytes aligned; this one is called Partial\n-\t  Redzone; this 32 bytes alignment is an asan constraint]\n+   Slot 2/ [8 bytes of red zone, that adds up to the space of 'a' to make\n+\t   the next slot be 32 bytes aligned; this one is called Partial\n+\t   Redzone; this 32 bytes alignment is an asan constraint]\n \n- Slot 3/ [24 bytes for variable 'a']\n+   Slot 3/ [24 bytes for variable 'a']\n \n- Slot 4/ [red zone of 32 bytes called 'Middle RedZone']\n+   Slot 4/ [red zone of 32 bytes called 'Middle RedZone']\n \n- Slot 5/ [24 bytes of Partial Red Zone (similar to slot 2]\n+   Slot 5/ [24 bytes of Partial Red Zone (similar to slot 2]\n \n- Slot 6/ [8 bytes for variable 'b']\n+   Slot 6/ [8 bytes for variable 'b']\n \n- Slot 7/ [32 bytes of Red Zone at the bottom of the stack, called 'LEFT\n-\t  RedZone']\n+   Slot 7/ [32 bytes of Red Zone at the bottom of the stack, called\n+\t    'LEFT RedZone']\n \n- The 32 bytes of LEFT red zone at the bottom of the stack can be\n- decomposed as such:\n+   The 32 bytes of LEFT red zone at the bottom of the stack can be\n+   decomposed as such:\n \n      1/ The first 8 bytes contain a magical asan number that is always\n      0x41B58AB3.\n@@ -122,7 +121,7 @@ along with GCC; see the file COPYING3.  If not see\n       3/ The following 16 bytes of the red zone have no particular\n       format.\n \n- The shadow memory for that stack layout is going to look like this:\n+   The shadow memory for that stack layout is going to look like this:\n \n      - content of shadow memory 8 bytes for slot 7: 0xF1F1F1F1.\n        The F1 byte pattern is a magic number called\n@@ -149,39 +148,39 @@ along with GCC; see the file COPYING3.  If not see\n        seat between two 32 aligned slots of {variable,padding}.\n \n      - content of shadow memory 8 bytes for slot 3 and 2:\n-       0xFFFFFFFFF4000000.  This represents is the concatenation of\n+       0xF4000000.  This represents is the concatenation of\n        variable 'a' and the partial red zone following it, like what we\n        had for variable 'b'.  The least significant 3 bytes being 00\n        means that the 3 bytes of variable 'a' are addressable.\n \n-     - content of shadow memory 8 bytes for slot 1: 0xFFFFFFFFF3F3F3F3.\n+     - content of shadow memory 8 bytes for slot 1: 0xF3F3F3F3.\n        The F3 byte pattern is a magic number called\n        ASAN_STACK_MAGIC_RIGHT.  It flags the fact that the memory\n        region for this shadow byte is a RIGHT red zone intended to seat\n        at the top of the variables of the stack.\n \n- Note that the real variable layout is done in expand_used_vars in\n- cfgexpand.c.  As far as Address Sanitizer is concerned, it lays out\n- stack variables as well as the different red zones, emits some\n- prologue code to populate the shadow memory as to poison (mark as\n- non-accessible) the regions of the red zones and mark the regions of\n- stack variables as accessible, and emit some epilogue code to\n- un-poison (mark as accessible) the regions of red zones right before\n- the function exits.\n+   Note that the real variable layout is done in expand_used_vars in\n+   cfgexpand.c.  As far as Address Sanitizer is concerned, it lays out\n+   stack variables as well as the different red zones, emits some\n+   prologue code to populate the shadow memory as to poison (mark as\n+   non-accessible) the regions of the red zones and mark the regions of\n+   stack variables as accessible, and emit some epilogue code to\n+   un-poison (mark as accessible) the regions of red zones right before\n+   the function exits.\n \n- [Protection of global variables]\n+   [Protection of global variables]\n \n- The basic idea is to insert a red zone between two global variables\n- and install a constructor function that calls the asan runtime to do\n- the populating of the relevant shadow memory regions at load time.\n+   The basic idea is to insert a red zone between two global variables\n+   and install a constructor function that calls the asan runtime to do\n+   the populating of the relevant shadow memory regions at load time.\n \n- So the global variables are laid out as to insert a red zone between\n- them. The size of the red zones is so that each variable starts on a\n- 32 bytes boundary.\n+   So the global variables are laid out as to insert a red zone between\n+   them. The size of the red zones is so that each variable starts on a\n+   32 bytes boundary.\n \n- Then a constructor function is installed so that, for each global\n- variable, it calls the runtime asan library function\n- __asan_register_globals_with an instance of this type:\n+   Then a constructor function is installed so that, for each global\n+   variable, it calls the runtime asan library function\n+   __asan_register_globals_with an instance of this type:\n \n      struct __asan_global\n      {\n@@ -202,8 +201,8 @@ along with GCC; see the file COPYING3.  If not see\n        uptr __has_dynamic_init;\n      }\n \n- A destructor function that calls the runtime asan library function\n- _asan_unregister_globals is also installed.  */\n+   A destructor function that calls the runtime asan library function\n+   _asan_unregister_globals is also installed.  */\n \n alias_set_type asan_shadow_set = -1;\n \n@@ -475,7 +474,7 @@ asan_protect_global (tree decl)\n     return false;\n #endif\n \n-  return true;    \n+  return true;\n }\n \n /* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n@@ -490,13 +489,13 @@ report_error_func (bool is_store, int size_in_bytes)\n   char name[100];\n \n   sprintf (name, \"__asan_report_%s%d\",\n-           is_store ? \"store\" : \"load\", size_in_bytes);\n+\t   is_store ? \"store\" : \"load\", size_in_bytes);\n   fn_type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   def = build_fn_decl (name, fn_type);\n   TREE_NOTHROW (def) = 1;\n   TREE_THIS_VOLATILE (def) = 1;  /* Attribute noreturn. Surprise!  */\n-  DECL_ATTRIBUTES (def) = tree_cons (get_identifier (\"leaf\"), \n-                                     NULL, DECL_ATTRIBUTES (def));\n+  DECL_ATTRIBUTES (def) = tree_cons (get_identifier (\"leaf\"),\n+\t\t\t\t     NULL, DECL_ATTRIBUTES (def));\n   DECL_ASSEMBLER_NAME (def);\n   return def;\n }\n@@ -598,7 +597,7 @@ create_cond_insert_point (gimple_stmt_iterator *iter,\n    outcoming edge of the 'then block' -- starts with the statement\n    pointed to by ITER.\n \n-   COND is the condition of the if.  \n+   COND is the condition of the if.\n \n    If THEN_MORE_LIKELY_P is true, the probability of the edge to the\n    'then block' is higher than the probability of the edge to the\n@@ -796,7 +795,7 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n \n static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n-                  location_t location, bool is_store)\n+\t\t  location_t location, bool is_store)\n {\n   tree type, base;\n   HOST_WIDE_INT size_in_bytes;\n@@ -864,7 +863,7 @@ instrument_mem_region_access (tree base, tree len,\n \t if (len != 0)\n \t   {\n \t     //asan instrumentation code goes here.\n-           }\n+\t   }\n \t   // falltrough instructions, starting with *ITER.  */\n \n       gimple g = gimple_build_cond (NE_EXPR,\n@@ -930,7 +929,7 @@ instrument_mem_region_access (tree base, tree len,\n   region_end =\n     gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n \t\t\t\t  make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t  gimple_assign_lhs (region_end), \n+\t\t\t\t  gimple_assign_lhs (region_end),\n \t\t\t\t  gimple_assign_lhs (offset));\n   gimple_set_location (region_end, location);\n   gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n@@ -1378,7 +1377,7 @@ transform_statements (void)\n     {\n       if (bb->index >= saved_last_basic_block) continue;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i);)\n-        {\n+\t{\n \t  gimple s = gsi_stmt (i);\n \n \t  if (gimple_assign_single_p (s))\n@@ -1391,7 +1390,7 @@ transform_statements (void)\n \t\tcontinue;\n \t    }\n \t  gsi_next (&i);\n-        }\n+\t}\n     }\n }\n \n@@ -1594,18 +1593,18 @@ struct gimple_opt_pass pass_asan =\n {\n  {\n   GIMPLE_PASS,\n-  \"asan\",                               /* name  */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_asan,                            /* gate  */\n-  asan_instrument,                      /* execute  */\n-  NULL,                                 /* sub  */\n-  NULL,                                 /* next  */\n-  0,                                    /* static_pass_number  */\n-  TV_NONE,                              /* tv_id  */\n+  \"asan\",\t\t\t\t/* name  */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  gate_asan,\t\t\t\t/* gate  */\n+  asan_instrument,\t\t\t/* execute  */\n+  NULL,\t\t\t\t\t/* sub  */\n+  NULL,\t\t\t\t\t/* next  */\n+  0,\t\t\t\t\t/* static_pass_number  */\n+  TV_NONE,\t\t\t\t/* tv_id  */\n   PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required  */\n-  0,                                    /* properties_provided  */\n-  0,                                    /* properties_destroyed  */\n-  0,                                    /* todo_flags_start  */\n+  0,\t\t\t\t\t/* properties_provided  */\n+  0,\t\t\t\t\t/* properties_destroyed  */\n+  0,\t\t\t\t\t/* todo_flags_start  */\n   TODO_verify_flow | TODO_verify_stmts\n   | TODO_update_ssa\t\t\t/* todo_flags_finish  */\n  }\n@@ -1622,7 +1621,7 @@ struct gimple_opt_pass pass_asan_O0 =\n  {\n   GIMPLE_PASS,\n   \"asan0\",\t\t\t\t/* name  */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n   gate_asan_O0,\t\t\t\t/* gate  */\n   asan_instrument,\t\t\t/* execute  */\n   NULL,\t\t\t\t\t/* sub  */"}]}