{"sha": "fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ4YjhjMDFjM2QwMDA2NWRjNWNkNGMwMDBkYjc5ZTViNDc0NjNkNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:54:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:54:33Z"}, "message": "[multiple changes]\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): Update the comment associated\n\twith the call to Check_Expression_Against_Static_Predicate.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Update the comment\n\tassociated with the call to Check_Expression_Against_Static_Predicate.\n\t* sem_util.adb (Check_Expression_Against_Static_Predicate):\n\tBroaden the check from a static expression to an expression with\n\ta known value at compile time.\n\t* sem_util.ads (Check_Expression_Against_Static_Predicate): Update\n\tcomment on usage.\n\n2013-04-25  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, cases Position,\n\tFirst_Bit, and Last_Bit): Fix incorrect test in implementation of\n\tRM 2005 13.5.2(3/2).\n\n2013-04-25  Claire Dross  <dross@adacore.com>\n\n\t* a-cfhase.adb, a-cfhase.ads, a-cforma.adb, a-cforma.ads, a-cfhama.adb,\n\ta-cfhama.ads, a-cforse.adb, a-cforse.ads, a-cofove.adb, a-cofove.ads\n\t(Query_Element): Removed.\n\t(Update_Element): Removed.\n\t(Insert): The version with no New_Item specified is removed.\n\t(Iterate): Removed.\n\t(Write): Removed.\n\t(Read): Removed.\n\tEvery check of fields Busy and Lock has been removed.\n\n2013-04-25  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Contract_Cases): Remove\n\tcall to S14_Pragma (Find_Related_Subprogram): Require proper\n\tplacement in subprogram body (Find_Related_Subprogram): Detect\n\tduplicates for all cases (Find_Related_Subprogram): Handle case\n\tof spec nested inside body.\n\nFrom-SVN: r198297", "tree": {"sha": "3835d998270eabe29f6eed6c25933bef3ec5d1e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3835d998270eabe29f6eed6c25933bef3ec5d1e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/comments", "author": null, "committer": null, "parents": [{"sha": "f197d2f29355314ccbf0a816f3ad20c20b506bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f197d2f29355314ccbf0a816f3ad20c20b506bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f197d2f29355314ccbf0a816f3ad20c20b506bef"}], "stats": {"total": 2176, "additions": 168, "deletions": 2008}, "files": [{"sha": "bb90af88a384afd3d33eff7719ff5c5267a21e5a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -1,3 +1,41 @@\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): Update the comment associated\n+\twith the call to Check_Expression_Against_Static_Predicate.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Update the comment\n+\tassociated with the call to Check_Expression_Against_Static_Predicate.\n+\t* sem_util.adb (Check_Expression_Against_Static_Predicate):\n+\tBroaden the check from a static expression to an expression with\n+\ta known value at compile time.\n+\t* sem_util.ads (Check_Expression_Against_Static_Predicate): Update\n+\tcomment on usage.\n+\n+2013-04-25  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, cases Position,\n+\tFirst_Bit, and Last_Bit): Fix incorrect test in implementation of\n+\tRM 2005 13.5.2(3/2).\n+\n+2013-04-25  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfhase.adb, a-cfhase.ads, a-cforma.adb, a-cforma.ads, a-cfhama.adb,\n+\ta-cfhama.ads, a-cforse.adb, a-cforse.ads, a-cofove.adb, a-cofove.ads\n+\t(Query_Element): Removed.\n+\t(Update_Element): Removed.\n+\t(Insert): The version with no New_Item specified is removed.\n+\t(Iterate): Removed.\n+\t(Write): Removed.\n+\t(Read): Removed.\n+\tEvery check of fields Busy and Lock has been removed.\n+\n+2013-04-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Contract_Cases): Remove\n+\tcall to S14_Pragma (Find_Related_Subprogram): Require proper\n+\tplacement in subprogram body (Find_Related_Subprogram): Detect\n+\tduplicates for all cases (Find_Related_Subprogram): Handle case\n+\tof spec nested inside body.\n+\n 2013-04-25  Arnaud Charlet  <charlet@adacore.com>\n \n \t* par-prag.adb: Fix typo."}, {"sha": "fc5c986ec2a2012b9b71b75a6689cc5b06eb399c", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 1, "deletions": 303, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -159,8 +159,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      --  Check busy bits\n-\n       Clear (Target);\n \n       Insert_Elements (Source);\n@@ -266,11 +264,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Position cursor of Delete has no element\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"Delete attempted to tamper with elements (map is busy)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n@@ -495,10 +488,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"Include attempted to tamper with cursors (map is locked)\";\n-         end if;\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n@@ -513,54 +502,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    -- Insert --\n    ------------\n \n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Assign_Key (Node : in out Node_Type);\n-      pragma Inline (Assign_Key);\n-\n-      function New_Node return Count_Type;\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert is\n-        new Key_Ops.Generic_Conditional_Insert (New_Node);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Assign_Key);\n-\n-      -----------------\n-      --  Assign_Key --\n-      -----------------\n-\n-      procedure Assign_Key (Node : in out Node_Type) is\n-      begin\n-         Node.Key := Key;\n-\n-         --  What is following commented out line doing here ???\n-         --  Node.Element := New_Item;\n-      end Assign_Key;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Count_Type is\n-         Result : Count_Type;\n-      begin\n-         Allocate (Container, Result);\n-         return Result;\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-\n-      Local_Insert (Container, Key, Position.Node, Inserted);\n-   end Insert;\n-\n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n@@ -635,47 +576,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return Length (Container) = 0;\n    end Is_Empty;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : Map;\n-      Process   : not null\n-                    access procedure (Container : Map; Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Count_Type);\n-      pragma Inline (Process_Node);\n-\n-      procedure Local_Iterate is new HT_Ops.Generic_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Count_Type) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-   --  Start of processing for Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n    ---------\n    -- Key --\n    ---------\n@@ -752,11 +652,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Clear (Target);\n \n       if Source.Length = 0 then\n@@ -849,105 +744,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return False;\n    end Overlap;\n \n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access\n-                    procedure (Key : Key_Type; Element : Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Query_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n-\n-      declare\n-         N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames N.Key;\n-            E : Element_Type renames N.Element;\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Map)\n-   is\n-      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n-                          return Count_Type;\n-\n-      procedure Read_Nodes is\n-        new HT_Ops.Generic_Read (Read_Node);\n-\n-      ---------------\n-      -- Read_Node --\n-      ---------------\n-\n-      function Read_Node\n-        (Stream : not null access Root_Stream_Type'Class) return Count_Type\n-      is\n-         procedure Read_Element (Node : in out Node_Type);\n-         pragma Inline (Read_Element);\n-\n-         procedure Allocate is\n-           new Generic_Allocate (Read_Element);\n-\n-         procedure Read_Element (Node : in out Node_Type) is\n-         begin\n-            Element_Type'Read (Stream, Node.Element);\n-         end Read_Element;\n-\n-         Node : Count_Type;\n-\n-      --  Start of processing for Read_Node\n-\n-      begin\n-         Allocate (Container, Node);\n-         return Node;\n-      end Read_Node;\n-\n-   --  Start of processing for Read\n-\n-   begin\n-      Read_Nodes (Stream, Container);\n-   end Read;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream set cursor\";\n-   end Read;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -965,11 +761,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"attempt to replace key not in map\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace attempted to tamper with cursors (map is locked)\";\n-      end if;\n-\n       declare\n          N : Node_Type renames Container.Nodes (Node);\n       begin\n@@ -993,11 +784,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace_Element attempted to tamper with cursors (map is locked)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, Position),\n                      \"bad cursor in Replace_Element\");\n \n@@ -1085,52 +871,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return True;\n    end Strict_Equal;\n \n-   --------------------\n-   -- Update_Element --\n-   --------------------\n-\n-   procedure Update_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Key     : Key_Type;\n-                                             Element : in out Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Update_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in Update_Element\");\n-\n-      declare\n-         B  : Natural renames Container.Busy;\n-         L  : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-            K : Key_Type renames N.Key;\n-            E : Element_Type renames N.Element;\n-\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Update_Element;\n-\n    ---------\n    -- Vet --\n    ---------\n@@ -1191,46 +931,4 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end;\n    end Vet;\n \n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Map)\n-   is\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type);\n-      pragma Inline (Write_Node);\n-\n-      procedure Write_Nodes is new HT_Ops.Generic_Write (Write_Node);\n-\n-      ----------------\n-      -- Write_Node --\n-      ----------------\n-\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type)\n-      is\n-      begin\n-         Key_Type'Write (Stream, Node.Key);\n-         Element_Type'Write (Stream, Node.Element);\n-      end Write_Node;\n-\n-   --  Start of processing for Write\n-\n-   begin\n-      Write_Nodes (Stream, Container);\n-   end Write;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream map cursor\";\n-   end Write;\n-\n end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "fdbd7a0a8a473050f6e305b821b397634fdead92", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 6, "deletions": 57, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -52,7 +52,6 @@\n --    See detailed specifications for these subprograms\n \n private with Ada.Containers.Hash_Tables;\n-private with Ada.Streams;\n \n generic\n    type Key_Type is private;\n@@ -87,14 +86,15 @@ package Ada.Containers.Formal_Hashed_Maps is\n \n    function Is_Empty (Container : Map) return Boolean;\n \n-   --  ??? what does clear do to active elements?\n    procedure Clear (Container : in out Map);\n \n    procedure Assign (Target : in out Map; Source : Map);\n \n-   --  ???\n-   --  capacity=0 means use container.length as cap of tgt\n-   --  modulos=0 means use default_modulous(container.length)\n+   --  Copy returns a container stricty equal to Source\n+   --  It must have the same cursors associated to each element\n+   --  Therefore:\n+   --  - capacity=0 means use container.capacity as cap of tgt\n+   --  - the modulus cannot be changed.\n    function Copy\n      (Source   : Map;\n       Capacity : Count_Type := 0) return Map;\n@@ -108,18 +108,6 @@ package Ada.Containers.Formal_Hashed_Maps is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access\n-                    procedure (Key : Key_Type; Element : Element_Type));\n-\n-   procedure Update_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access\n-                    procedure (Key : Key_Type; Element : in out Element_Type));\n-\n    procedure Move (Target : in out Map; Source : in out Map);\n \n    procedure Insert\n@@ -129,12 +117,6 @@ package Ada.Containers.Formal_Hashed_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n \n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean);\n-\n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n@@ -186,11 +168,6 @@ package Ada.Containers.Formal_Hashed_Maps is\n       Right  : Map;\n       CRight : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : Map;\n-      Process   : not null access\n-                    procedure (Container : Map; Position : Cursor));\n-\n    function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n \n    function Strict_Equal (Left, Right : Map) return Boolean;\n@@ -237,39 +214,11 @@ private\n       new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n    use HT_Types;\n-   use Ada.Streams;\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Map);\n-\n-   for Map'Write use Write;\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Map);\n-\n-   for Map'Read use Read;\n-\n-   type Map_Access is access all Map;\n-   for Map_Access'Storage_Size use 0;\n \n    type Cursor is record\n       Node : Count_Type;\n    end record;\n \n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor);\n-\n-   for Cursor'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n    Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n \n    No_Element : constant Cursor := (Node => 0);"}, {"sha": "539a0a88fe61c5602d1972d59b6cb3fd246302eb", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 1, "deletions": 306, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -295,11 +295,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n@@ -333,11 +328,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n       if Src_Length >= Target.Length then\n          Tgt_Node := HT_Ops.First (Target);\n          while Tgt_Node /= 0 loop\n@@ -572,9 +562,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end;\n    end Equivalent_Elements;\n \n-   --  What does the following comment signify???\n-   --  NOT MODIFIED\n-\n    ---------------------\n    -- Equivalent_Keys --\n    ---------------------\n@@ -700,10 +687,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n \n          Container.Nodes (Position.Node).Element := New_Item;\n       end if;\n@@ -804,11 +787,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n       Tgt_Node := HT_Ops.First (Target);\n       while Tgt_Node /= 0 loop\n          if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n@@ -930,48 +908,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return True;\n    end Is_Subset;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : Set;\n-      Process   :\n-      not null access procedure (Container : Set; Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Count_Type);\n-      pragma Inline (Process_Node);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Count_Type) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-   --  Start of processing for Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n    ----------\n    -- Left --\n    ----------\n@@ -1029,11 +965,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Clear (Target);\n \n       if Source.Length = 0 then\n@@ -1117,103 +1048,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return False;\n    end Overlap;\n \n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Query_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Container.Nodes (Position.Node).Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Set)\n-   is\n-      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n-                          return Count_Type;\n-\n-      procedure Read_Nodes is\n-        new HT_Ops.Generic_Read (Read_Node);\n-\n-      ---------------\n-      -- Read_Node --\n-      ---------------\n-\n-      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n-                          return Count_Type\n-      is\n-         procedure Read_Element (Node : in out Node_Type);\n-         pragma Inline (Read_Element);\n-\n-         procedure Allocate is new Generic_Allocate (Read_Element);\n-\n-         ------------------\n-         -- Read_Element --\n-         ------------------\n-\n-         procedure Read_Element (Node : in out Node_Type) is\n-         begin\n-            Element_Type'Read (Stream, Node.Element);\n-         end Read_Element;\n-\n-         Node : Count_Type;\n-\n-      --  Start of processing for Read_Node\n-\n-      begin\n-         Allocate (Container, Node);\n-         return Node;\n-      end Read_Node;\n-\n-   --  Start of processing for Read\n-\n-   begin\n-      Read_Nodes (Stream, Container);\n-   end Read;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream set cursor\";\n-   end Read;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1230,11 +1064,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is locked)\";\n-      end if;\n-\n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n \n@@ -1391,11 +1220,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n       Iterate (Source);\n    end Symmetric_Difference;\n \n@@ -1475,10 +1299,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n       Iterate (Source);\n    end Union;\n \n@@ -1557,47 +1377,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end;\n    end Vet;\n \n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Set)\n-   is\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type);\n-      pragma Inline (Write_Node);\n-\n-      procedure Write_Nodes is\n-        new HT_Ops.Generic_Write (Write_Node);\n-\n-      ----------------\n-      -- Write_Node --\n-      ----------------\n-\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type)\n-      is\n-      begin\n-         Element_Type'Write (Stream, Node.Element);\n-      end Write_Node;\n-\n-      --  Start of processing for Write\n-\n-   begin\n-      Write_Nodes (Stream, Container);\n-   end Write;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream set cursor\";\n-   end Write;\n    package body Generic_Keys is\n \n       -----------------------\n@@ -1752,90 +1531,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Replace_Element (Container, Node, New_Item);\n       end Replace;\n \n-      -----------------------------------\n-      -- Update_Element_Preserving_Key --\n-      -----------------------------------\n-\n-      procedure Update_Element_Preserving_Key\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access\n-                       procedure (Element : in out Element_Type))\n-      is\n-         Indx : Hash_Type;\n-         N    : Nodes_Type renames Container.Nodes;\n-\n-      begin\n-         if Position.Node = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor equals No_Element\";\n-         end if;\n-\n-         pragma Assert\n-           (Vet (Container, Position),\n-            \"bad cursor in Update_Element_Preserving_Key\");\n-\n-      --  Record bucket now, in case key is changed\n-\n-         Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n-\n-         declare\n-            E : Element_Type renames N (Position.Node).Element;\n-            K : constant Key_Type := Key (E);\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (E);\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-            if Equivalent_Keys (K, Key (E)) then\n-               pragma Assert (Hash (K) = Hash (E));\n-               return;\n-            end if;\n-         end;\n-\n-         --  Key was modified, so remove this node from set\n-\n-         if Container.Buckets (Indx) = Position.Node then\n-            Container.Buckets (Indx) := N (Position.Node).Next;\n-\n-         else\n-            declare\n-               Prev : Count_Type := Container.Buckets (Indx);\n-\n-            begin\n-               while N (Prev).Next /= Position.Node loop\n-                  Prev := N (Prev).Next;\n-\n-                  if Prev = 0 then\n-                     raise Program_Error with\n-                       \"Position cursor is bad (node not found)\";\n-                  end if;\n-               end loop;\n-\n-               N (Prev).Next := N (Position.Node).Next;\n-            end;\n-         end if;\n-\n-         Container.Length := Container.Length - 1;\n-         Free (Container, Position.Node);\n-\n-         raise Program_Error with \"key was modified\";\n-      end Update_Element_Preserving_Key;\n-\n    end Generic_Keys;\n \n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "a9278dcdbf098b4b59adeb466282d72ed59b0eee", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -52,7 +52,6 @@\n --    See detailed specifications for these subprograms\n \n private with Ada.Containers.Hash_Tables;\n-private with Ada.Streams;\n \n generic\n    type Element_Type is private;\n@@ -68,8 +67,7 @@ package Ada.Containers.Formal_Hashed_Sets is\n    pragma Pure;\n \n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n-   --  why is this commented out ???\n-   --  pragma Preelaborable_Initialization (Set);\n+   pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -108,11 +106,6 @@ package Ada.Containers.Formal_Hashed_Sets is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -187,11 +180,6 @@ package Ada.Containers.Formal_Hashed_Sets is\n      (Left  : Element_Type;\n       Right : Set; CRight : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : Set;\n-      Process   :\n-        not null access procedure (Container : Set; Position : Cursor));\n-\n    function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n \n    generic\n@@ -222,12 +210,6 @@ package Ada.Containers.Formal_Hashed_Sets is\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n-      procedure Update_Element_Preserving_Key\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access\n-                       procedure (Element : in out Element_Type));\n-\n    end Generic_Keys;\n \n    function Strict_Equal (Left, Right : Set) return Boolean;\n@@ -262,38 +244,13 @@ private\n       new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n    use HT_Types;\n-   use Ada.Streams;\n \n    type Cursor is record\n       Node : Count_Type;\n    end record;\n \n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor);\n-\n-   for Cursor'Read use Read;\n-\n    No_Element : constant Cursor := (Node => 0);\n \n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Set);\n-\n-   for Set'Write use Write;\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Set);\n-\n-   for Set'Read use Read;\n-\n    Empty_Set : constant Set := (Capacity => 0, Modulus => 0, others => <>);\n \n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "ac763918283042f1a283ce15651c4f2252acf5d4", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 1, "deletions": 331, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -558,11 +558,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (map is locked)\";\n-         end if;\n-\n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n          begin\n@@ -635,56 +630,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end if;\n    end Insert;\n \n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-      function New_Node return Node_Access;\n-\n-      procedure Insert_Post is\n-        new Key_Ops.Generic_Insert_Post (New_Node);\n-\n-      procedure Insert_Sans_Hint is\n-        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n-         procedure Initialize (Node : in out Node_Type);\n-         procedure Allocate_Node is new Generic_Allocate (Initialize);\n-\n-         ----------------\n-         -- Initialize --\n-         ----------------\n-\n-         procedure Initialize (Node : in out Node_Type) is\n-         begin\n-            Node.Key := Key;\n-         end Initialize;\n-\n-         X : Node_Access;\n-\n-      --  Start of processing for New_Node\n-\n-      begin\n-         Allocate_Node (Container, X);\n-         return X;\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Insert_Sans_Hint (Container, Key, Position.Node, Inserted);\n-   end Insert;\n-\n    --------------\n    -- Is_Empty --\n    --------------\n@@ -720,48 +665,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       return Left < Right.Key;\n    end Is_Less_Key_Node;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : Map;\n-      Process   :\n-        not null access procedure (Container : Map; Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Node_Access);\n-      pragma Inline (Process_Node);\n-\n-      procedure Local_Iterate is\n-        new Tree_Operations.Generic_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Node_Access) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-      --  Start of processing for Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n    ---------\n    -- Key --\n    ---------\n@@ -881,11 +784,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Clear (Target);\n \n       loop\n@@ -1014,93 +912,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end;\n    end Previous;\n \n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Key     : Key_Type;\n-                                             Element : Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Query_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position.Node),\n-                     \"Position cursor of Query_Element is bad\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N  : Node_Type renames Container.Nodes (Position.Node);\n-            K  : Key_Type renames N.Key;\n-            E  : Element_Type renames N.Element;\n-\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Map)\n-   is\n-      procedure Read_Element (Node : in out Node_Type);\n-      pragma Inline (Read_Element);\n-\n-      procedure Allocate is\n-         new Generic_Allocate (Read_Element);\n-\n-      procedure Read_Elements is\n-         new Tree_Operations.Generic_Read (Allocate);\n-\n-      ------------------\n-      -- Read_Element --\n-      ------------------\n-\n-      procedure Read_Element (Node : in out Node_Type) is\n-      begin\n-         Key_Type'Read (Stream, Node.Key);\n-         Element_Type'Read (Stream, Node.Element);\n-      end Read_Element;\n-\n-   --  Start of processing for Read\n-\n-   begin\n-      Read_Elements (Stream, Container);\n-   end Read;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream map cursor\";\n-   end Read;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1119,11 +930,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n             raise Constraint_Error with \"key not in map\";\n          end if;\n \n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (map is locked)\";\n-         end if;\n-\n          declare\n             N : Node_Type renames Container.Nodes (Node);\n          begin\n@@ -1148,59 +954,12 @@ package body Ada.Containers.Formal_Ordered_Maps is\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (map is locked)\";\n-      end if;\n-\n       pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n \n       Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : Map;\n-      Process   : not null access procedure (Container : Map;\n-                                             Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Node_Access);\n-      pragma Inline (Process_Node);\n-\n-      procedure Local_Reverse_Iterate is\n-        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Node_Access) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-   --  Start of processing for Reverse_Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Reverse_Iterate;\n-\n    -----------\n    -- Right --\n    -----------\n@@ -1305,93 +1064,4 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       return False;\n    end Strict_Equal;\n \n-   --------------------\n-   -- Update_Element --\n-   --------------------\n-\n-   procedure Update_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Key     : Key_Type;\n-                                             Element : in out Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Update_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position.Node),\n-                     \"Position cursor of Update_Element is bad\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-            K : Key_Type renames N.Key;\n-            E : Element_Type renames N.Element;\n-\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Update_Element;\n-\n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Map)\n-   is\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type);\n-      pragma Inline (Write_Node);\n-\n-      procedure Write_Nodes is\n-         new Tree_Operations.Generic_Write (Write_Node);\n-\n-      ----------------\n-      -- Write_Node --\n-      ----------------\n-\n-      procedure Write_Node\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type)\n-      is\n-      begin\n-         Key_Type'Write (Stream, Node.Key);\n-         Element_Type'Write (Stream, Node.Element);\n-      end Write_Node;\n-\n-   --  Start of processing for Write\n-\n-   begin\n-      Write_Nodes (Stream, Container);\n-   end Write;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream map cursor\";\n-   end Write;\n-\n end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "c96fee02d51ef9dcc3d587bd340df2d0819daec9", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -54,7 +54,6 @@\n --    See detailed specifications for these subprograms\n \n private with Ada.Containers.Red_Black_Trees;\n-private with Ada.Streams;\n \n generic\n    type Key_Type is private;\n@@ -99,18 +98,6 @@ package Ada.Containers.Formal_Ordered_Maps is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access\n-                    procedure (Key : Key_Type; Element : Element_Type));\n-\n-   procedure Update_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      Process   : not null access\n-                    procedure (Key : Key_Type; Element : in out Element_Type));\n-\n    procedure Move (Target : in out Map; Source : in out Map);\n \n    procedure Insert\n@@ -120,12 +107,6 @@ package Ada.Containers.Formal_Ordered_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n \n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean);\n-\n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n@@ -183,16 +164,6 @@ package Ada.Containers.Formal_Ordered_Maps is\n \n    function Has_Element (Container : Map; Position : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : Map;\n-      Process   :\n-        not null access procedure (Container : Map; Position : Cursor));\n-\n-   procedure Reverse_Iterate\n-     (Container : Map;\n-      Process   : not null access\n-                    procedure (Container : Map; Position : Cursor));\n-\n    function Strict_Equal (Left, Right : Map) return Boolean;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n@@ -234,38 +205,12 @@ private\n    type Map (Capacity : Count_Type) is\n       new Tree_Types.Tree_Type (Capacity) with null record;\n \n-   use Ada.Streams;\n-\n    type Cursor is record\n       Node : Node_Access;\n    end record;\n \n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor);\n-\n-   for Cursor'Read use Read;\n+   Empty_Map : constant Map := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := (Node => 0);\n \n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Map);\n-\n-   for Map'Write use Write;\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Map);\n-\n-   for Map'Read use Read;\n-\n-   Empty_Map : constant Map := (Capacity => 0, others => <>);\n-\n end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "22e92220b9d942cfceddc647a928ad6121963cef", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 2, "deletions": 292, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -807,64 +807,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          end if;\n       end Replace;\n \n-      -----------------------------------\n-      -- Update_Element_Preserving_Key --\n-      -----------------------------------\n-\n-      procedure Update_Element_Preserving_Key\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access procedure (Element : in out Element_Type))\n-      is\n-      begin\n-         if not Has_Element (Container, Position) then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert (Vet (Container, Position.Node),\n-                        \"bad cursor in Update_Element_Preserving_Key\");\n-\n-         declare\n-            N : Tree_Types.Nodes_Type renames Container.Nodes;\n-\n-            E : Element_Type renames N (Position.Node).Element;\n-            K : constant Key_Type := Key (E);\n-\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (E);\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-            if Equivalent_Keys (K, Key (E)) then\n-               return;\n-            end if;\n-         end;\n-\n-         declare\n-            X : constant Count_Type := Position.Node;\n-         begin\n-            Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-            Formal_Ordered_Sets.Free (Container, X);\n-         end;\n-\n-         raise Program_Error with \"key was modified\";\n-      end Update_Element_Preserving_Key;\n-\n    end Generic_Keys;\n \n    -----------------\n@@ -892,11 +834,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n-\n          declare\n             N : Tree_Types.Nodes_Type renames Container.Nodes;\n          begin\n@@ -1122,50 +1059,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       return Set_Ops.Set_Subset (Subset, Of_Set => Of_Set);\n    end Is_Subset;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : Set;\n-      Process   : not null access procedure (Container : Set;\n-                                             Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Count_Type);\n-      pragma Inline (Process_Node);\n-\n-      procedure Local_Iterate is\n-        new Tree_Operations.Generic_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Count_Type) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      --  Local variables\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-   --  Start of prccessing for Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n    ----------\n    -- Last --\n    ----------\n@@ -1257,11 +1150,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n-\n       Clear (Target);\n \n       loop\n@@ -1347,85 +1235,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Position := Previous (Container, Position);\n    end Previous;\n \n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position.Node),\n-                     \"bad cursor in Query_Element\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Container.Nodes (Position.Node).Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n-      end;\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Set)\n-   is\n-      procedure Read_Element (Node : in out Node_Type);\n-      pragma Inline (Read_Element);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Read_Element);\n-\n-      procedure Read_Elements is\n-        new Tree_Operations.Generic_Read (Allocate);\n-\n-      ------------------\n-      -- Read_Element --\n-      ------------------\n-\n-      procedure Read_Element (Node : in out Node_Type) is\n-      begin\n-         Element_Type'Read (Stream, Node.Element);\n-      end Read_Element;\n-\n-   --  Start of processing for Read\n-\n-   begin\n-      Read_Elements (Stream, Container);\n-   end Read;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream set cursor\";\n-   end Read;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1439,11 +1248,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is locked)\";\n-      end if;\n-\n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n \n@@ -1502,11 +1306,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          null;\n \n       else\n-         if Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n-\n          NN (Node).Element := Item;\n          return;\n       end if;\n@@ -1518,11 +1317,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n       elsif Item < NN (Hint).Element then\n          if Hint = Node then\n-            if Tree.Lock > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (set is locked)\";\n-            end if;\n-\n             NN (Node).Element := Item;\n             return;\n          end if;\n@@ -1532,7 +1326,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          raise Program_Error with \"attempt to replace existing element\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n \n       Local_Insert_With_Hint\n         (Tree     => Tree,\n@@ -1562,48 +1356,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Replace_Element (Container, Position.Node, New_Item);\n    end Replace_Element;\n \n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : Set;\n-      Process   : not null access procedure (Container : Set;\n-                                             Position : Cursor))\n-   is\n-      procedure Process_Node (Node : Count_Type);\n-      pragma Inline (Process_Node);\n-\n-      procedure Local_Reverse_Iterate is\n-        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n-\n-      ------------------\n-      -- Process_Node --\n-      ------------------\n-\n-      procedure Process_Node (Node : Count_Type) is\n-      begin\n-         Process (Container, (Node => Node));\n-      end Process_Node;\n-\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-\n-   --  Start of processing for Reverse_Iterate\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Reverse_Iterate;\n-\n    -----------\n    -- Right --\n    -----------\n@@ -1781,46 +1533,4 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end return;\n    end Union;\n \n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Set)\n-   is\n-      procedure Write_Element\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type);\n-      pragma Inline (Write_Element);\n-\n-      procedure Write_Elements is\n-        new Tree_Operations.Generic_Write (Write_Element);\n-\n-      -------------------\n-      -- Write_Element --\n-      -------------------\n-\n-      procedure Write_Element\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Node   : Node_Type)\n-      is\n-      begin\n-         Element_Type'Write (Stream, Node.Element);\n-      end Write_Element;\n-\n-   --  Start of processing for Write\n-\n-   begin\n-      Write_Elements (Stream, Container);\n-   end Write;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream set cursor\";\n-   end Write;\n-\n end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "77862a6df342f747fb7e333795f4dc640dbdada5", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -53,7 +53,6 @@\n --    See detailed specifications for these subprograms\n \n private with Ada.Containers.Red_Black_Trees;\n-private with Ada.Streams;\n \n generic\n    type Element_Type is private;\n@@ -100,11 +99,6 @@ package Ada.Containers.Formal_Ordered_Sets is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -195,16 +189,6 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    function Has_Element (Container : Set; Position : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : Set;\n-      Process   :\n-        not null access procedure (Container : Set; Position : Cursor));\n-\n-   procedure Reverse_Iterate\n-     (Container : Set;\n-      Process   : not null access\n-                    procedure (Container : Set; Position : Cursor));\n-\n    generic\n       type Key_Type (<>) is private;\n \n@@ -237,12 +221,6 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n-      procedure Update_Element_Preserving_Key\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access\n-                       procedure (Element : in out Element_Type));\n-\n    end Generic_Keys;\n \n    function Strict_Equal (Left, Right : Set) return Boolean;\n@@ -280,41 +258,13 @@ private\n      new Tree_Types.Tree_Type (Capacity) with null record;\n \n    use Red_Black_Trees;\n-   use Ada.Streams;\n-\n-   type Set_Access is access all Set;\n-   for Set_Access'Storage_Size use 0;\n \n    type Cursor is record\n       Node : Count_Type;\n    end record;\n \n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Cursor);\n-\n-   for Cursor'Read use Read;\n-\n    No_Element : constant Cursor := (Node => 0);\n \n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Set);\n-\n-   for Set'Write use Write;\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Set);\n-\n-   for Set'Read use Read;\n-\n    Empty_Set : constant Set := (Capacity => 0, others => <>);\n \n end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "69de29db5d4f079bc71f9c75abb849fc07cfa5b7", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 16, "deletions": 393, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,11 @@ package body Ada.Containers.Formal_Vectors is\n      (Container : Vector;\n       Position  : Count_Type) return Element_Type;\n \n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n    ---------\n    -- \"&\" --\n    ---------\n@@ -256,7 +261,7 @@ package body Ada.Containers.Formal_Vectors is\n    -- Capacity --\n    --------------\n \n-   function Capacity (Container : Vector) return Capacity_Subtype is\n+   function Capacity (Container : Vector) return Count_Type is\n    begin\n       return Container.Elements'Length;\n    end Capacity;\n@@ -267,11 +272,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       Container.Last := No_Index;\n    end Clear;\n \n@@ -293,10 +293,10 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Copy\n      (Source   : Vector;\n-      Capacity : Capacity_Subtype := 0) return Vector\n+      Capacity : Count_Type := 0) return Vector\n    is\n       LS : constant Count_Type := Length (Source);\n-      C  : Capacity_Subtype;\n+      C  : Count_Type;\n \n    begin\n       if Capacity = 0 then\n@@ -339,11 +339,6 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       declare\n          I_As_Int        : constant Int := Int (Index);\n          Old_Last_As_Int : constant Int := Index_Type'Pos (Container.Last);\n@@ -437,11 +432,6 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       Index := Int'Base (Container.Last) - Int'Base (Count);\n \n       if Index < Index_Type'Pos (Index_Type'First) then\n@@ -607,7 +597,7 @@ package body Ada.Containers.Formal_Vectors is\n          end if;\n \n          declare\n-            L : constant Capacity_Subtype := Length (Container);\n+            L : constant Count_Type := Length (Container);\n          begin\n             for J in Count_Type range 1 .. L - 1 loop\n                if Get_Element (Container, J + 1) <\n@@ -650,16 +640,6 @@ package body Ada.Containers.Formal_Vectors is\n \n             --  I think we're missing this check in a-convec.adb...  ???\n \n-            if Target.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with elements (vector is busy)\";\n-            end if;\n-\n-            if Source.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with elements (vector is busy)\";\n-            end if;\n-\n             I := Length (Target);\n             Target.Set_Length (I + Length (Source));\n \n@@ -709,11 +689,6 @@ package body Ada.Containers.Formal_Vectors is\n             return;\n          end if;\n \n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is locked)\";\n-         end if;\n-\n          Sort (Container.Elements (1 .. Length (Container)));\n       end Sort;\n \n@@ -807,11 +782,6 @@ package body Ada.Containers.Formal_Vectors is\n          --  Resolve issue of capacity vs. max index  ???\n       end;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       declare\n          EA : Elements_Array renames Container.Elements;\n \n@@ -1055,30 +1025,6 @@ package body Ada.Containers.Formal_Vectors is\n       Position := Cursor'(True, Index);\n    end Insert;\n \n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1)\n-   is\n-      New_Item : Element_Type;  -- Default-initialized value\n-      pragma Warnings (Off, New_Item);\n-\n-   begin\n-      Insert (Container, Before, New_Item, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n-   is\n-      New_Item : Element_Type;  -- Default-initialized value\n-      pragma Warnings (Off, New_Item);\n-   begin\n-      Insert (Container, Before, New_Item, Position, Count);\n-   end Insert;\n-\n    ------------------\n    -- Insert_Space --\n    ------------------\n@@ -1138,11 +1084,6 @@ package body Ada.Containers.Formal_Vectors is\n          --  Resolve issue of capacity vs. max index  ???\n       end;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       declare\n          EA : Elements_Array renames Container.Elements;\n \n@@ -1166,46 +1107,6 @@ package body Ada.Containers.Formal_Vectors is\n       Container.Last := New_Last;\n    end Insert_Space;\n \n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n-   is\n-      Index : Index_Type'Base;\n-\n-   begin\n-      if Count = 0 then\n-         if not Before.Valid\n-           or else Before.Index > Container.Last\n-         then\n-            Position := No_Element;\n-         else\n-            Position := (True, Before.Index);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if not Before.Valid\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n-            raise Constraint_Error with\n-              \"vector is already at its maximum length\";\n-         end if;\n-\n-         Index := Container.Last + 1;\n-\n-      else\n-         Index := Before.Index;\n-      end if;\n-\n-      Insert_Space (Container, Index, Count => Count);\n-\n-      Position := Cursor'(True, Index);\n-   end Insert_Space;\n-\n    --------------\n    -- Is_Empty --\n    --------------\n@@ -1215,34 +1116,6 @@ package body Ada.Containers.Formal_Vectors is\n       return Last_Index (Container) < Index_Type'First;\n    end Is_Empty;\n \n-   -------------\n-   -- Iterate --\n-   -------------\n-\n-   procedure Iterate\n-     (Container : Vector;\n-      Process   :\n-        not null access procedure (Container : Vector; Position : Cursor))\n-   is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in Index_Type'First .. Last_Index (Container) loop\n-            Process (Container, Cursor'(True, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Iterate;\n-\n    ----------\n    -- Last --\n    ----------\n@@ -1282,13 +1155,13 @@ package body Ada.Containers.Formal_Vectors is\n    -- Length --\n    ------------\n \n-   function Length (Container : Vector) return Capacity_Subtype is\n+   function Length (Container : Vector) return Count_Type is\n       L : constant Int := Int (Last_Index (Container));\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n \n    begin\n-      return Capacity_Subtype (N);\n+      return Count_Type (N);\n    end Length;\n \n    ----------\n@@ -1328,16 +1201,6 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (Target is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (Source is busy)\";\n-      end if;\n-\n       if N > Target.Capacity then\n          raise Constraint_Error with  -- correct exception here???\n            \"length of Source is greater than capacity of Target\";\n@@ -1440,96 +1303,6 @@ package body Ada.Containers.Formal_Vectors is\n       return No_Element;\n    end Previous;\n \n-   -------------------\n-   -- Query_Element --\n-   -------------------\n-\n-   procedure Query_Element\n-     (Container : Vector;\n-      Index     : Index_Type;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n-\n-   begin\n-      if Index > Last_Index (Container) then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      B := B + 1;\n-      L := L + 1;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n-\n-      begin\n-         Process (Get_Element (V, I));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n-   end Query_Element;\n-\n-   procedure Query_Element\n-     (Container : Vector;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-   begin\n-      if not Position.Valid then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      Query_Element (Container, Position.Index, Process);\n-   end Query_Element;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Vector)\n-   is\n-      Length : Count_Type'Base;\n-      Last   : Index_Type'Base := No_Index;\n-\n-   begin\n-      Clear (Container);\n-\n-      Count_Type'Base'Read (Stream, Length);\n-\n-      if Length < 0 then\n-         raise Program_Error with \"stream appears to be corrupt\";\n-      end if;\n-\n-      if Length > Container.Capacity then\n-         raise Storage_Error with \"not enough capacity\";  --  ???\n-      end if;\n-\n-      for J in Count_Type range 1 .. Length loop\n-         Last := Last + 1;\n-         Element_Type'Read (Stream, Container.Elements (J));\n-         Container.Last := Last;\n-      end loop;\n-   end Read;\n-\n-   procedure Read\n-     (Stream   : not null access Root_Stream_Type'Class;\n-      Position : out Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream vector cursor\";\n-   end Read;\n-\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1544,11 +1317,6 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is locked)\";\n-      end if;\n-\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Count_Type := Count_Type (II);\n@@ -1572,11 +1340,6 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is locked)\";\n-      end if;\n-\n       declare\n          II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n          I  : constant Count_Type := Count_Type (II);\n@@ -1591,11 +1354,11 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n-      Capacity  : Capacity_Subtype)\n+      Capacity  : Count_Type)\n    is\n    begin\n       if Capacity > Container.Capacity then\n-         raise Constraint_Error;  -- ???\n+         raise Constraint_Error with \"Capacity is out of range\";\n       end if;\n    end Reserve_Capacity;\n \n@@ -1609,11 +1372,6 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is locked)\";\n-      end if;\n-\n       declare\n          I, J : Count_Type;\n          E    : Elements_Array renames Container.Elements;\n@@ -1699,34 +1457,6 @@ package body Ada.Containers.Formal_Vectors is\n       return No_Index;\n    end Reverse_Find_Index;\n \n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : Vector;\n-      Process   : not null access procedure (Container : Vector;\n-                                             Position : Cursor))\n-   is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in reverse Index_Type'First .. Last_Index (Container) loop\n-            Process (Container, Cursor'(True, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n-   end Reverse_Iterate;\n-\n    -----------\n    -- Right --\n    -----------\n@@ -1757,18 +1487,13 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Set_Length\n      (Container : in out Vector;\n-      Length    : Capacity_Subtype)\n+      Length    : Count_Type)\n    is\n    begin\n       if Length = Formal_Vectors.Length (Container) then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n-\n       if Length > Container.Capacity then\n          raise Constraint_Error;  -- ???\n       end if;\n@@ -1799,11 +1524,6 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is locked)\";\n-      end if;\n-\n       declare\n          II : constant Int'Base := Int (I) - Int (No_Index);\n          JJ : constant Int'Base := Int (J) - Int (No_Index);\n@@ -1865,32 +1585,9 @@ package body Ada.Containers.Formal_Vectors is\n    -- To_Vector --\n    ---------------\n \n-   function To_Vector (Length : Capacity_Subtype) return Vector is\n-   begin\n-      if Length = 0 then\n-         return Empty_Vector;\n-      end if;\n-\n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type;\n-\n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error with \"Length is out of range\";  -- ???\n-         end if;\n-\n-         Last := Index_Type (Last_As_Int);\n-\n-         return (Length, (others => <>), Last => Last,\n-                 others => <>);\n-      end;\n-   end To_Vector;\n-\n    function To_Vector\n      (New_Item : Element_Type;\n-      Length   : Capacity_Subtype) return Vector\n+      Length   : Count_Type) return Vector\n    is\n    begin\n       if Length = 0 then\n@@ -1914,78 +1611,4 @@ package body Ada.Containers.Formal_Vectors is\n       end;\n    end To_Vector;\n \n-   --------------------\n-   -- Update_Element --\n-   --------------------\n-\n-   procedure Update_Element\n-     (Container : in out Vector;\n-      Index     : Index_Type;\n-      Process   : not null access procedure (Element : in out Element_Type))\n-   is\n-      B : Natural renames Container.Busy;\n-      L : Natural renames Container.Lock;\n-\n-   begin\n-      if Index > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      B := B + 1;\n-      L := L + 1;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n-\n-      begin\n-         Process (Container.Elements (I));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n-   end Update_Element;\n-\n-   procedure Update_Element\n-     (Container : in out Vector;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : in out Element_Type))\n-   is\n-   begin\n-      if not Position.Valid then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      Update_Element (Container, Position.Index, Process);\n-   end Update_Element;\n-\n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Vector)\n-   is\n-   begin\n-      Count_Type'Base'Write (Stream, Length (Container));\n-\n-      for J in 1 .. Length (Container) loop\n-         Element_Type'Write (Stream, Container.Elements (J));\n-      end loop;\n-   end Write;\n-\n-   procedure Write\n-     (Stream   : not null access Root_Stream_Type'Class;\n-      Position : Cursor)\n-   is\n-   begin\n-      raise Program_Error with \"attempt to stream vector cursor\";\n-   end Write;\n-\n end Ada.Containers.Formal_Vectors;"}, {"sha": "4d943837b823ea0edfd25f7fce0a89728fee18d2", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 9, "deletions": 106, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -55,7 +55,6 @@\n --      iterate over containers. Left returns the part of the container already\n --      scanned and Right the part not scanned yet.\n \n-private with Ada.Streams;\n with Ada.Containers;\n use Ada.Containers;\n \n@@ -72,21 +71,9 @@ package Ada.Containers.Formal_Vectors is\n    range Index_Type'First - 1 ..\n      Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n \n-   --  ??? i don't think we can do this...\n-   --  TODO: we need the ARG to either figure out how to declare this subtype,\n-   --  or eliminate the requirement that it be present.\n-   --  subtype Capacity_Subtype is Count_Type -- correct name???\n-   --  range 0 .. Count_Type'Max (0,\n-   --                             Index_Type'Pos (Index_Type'Last) -\n-   --                             Index_Type'Pos (Index_Type'First) + 1);\n-   --\n-   --  so for now:\n-   subtype Capacity_Subtype is Count_Type;\n-\n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   type Vector (Capacity : Capacity_Subtype) is tagged private;\n-   --  pragma Preelaborable_Initialization (Vector);\n+   type Vector (Capacity : Count_Type) is tagged private;\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -97,11 +84,9 @@ package Ada.Containers.Formal_Vectors is\n \n    function \"=\" (Left, Right : Vector) return Boolean;\n \n-   function To_Vector (Length : Capacity_Subtype) return Vector;\n-\n    function To_Vector\n      (New_Item : Element_Type;\n-      Length   : Capacity_Subtype) return Vector;\n+      Length   : Count_Type) return Vector;\n \n    function \"&\" (Left, Right : Vector) return Vector;\n \n@@ -111,17 +96,17 @@ package Ada.Containers.Formal_Vectors is\n \n    function \"&\" (Left, Right : Element_Type) return Vector;\n \n-   function Capacity (Container : Vector) return Capacity_Subtype;\n+   function Capacity (Container : Vector) return Count_Type;\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n-      Capacity  : Capacity_Subtype);\n+      Capacity  : Count_Type);\n \n-   function Length (Container : Vector) return Capacity_Subtype;\n+   function Length (Container : Vector) return Count_Type;\n \n    procedure Set_Length\n      (Container : in out Vector;\n-      Length    : Capacity_Subtype);\n+      Length    : Count_Type);\n \n    function Is_Empty (Container : Vector) return Boolean;\n \n@@ -131,7 +116,7 @@ package Ada.Containers.Formal_Vectors is\n \n    function Copy\n      (Source   : Vector;\n-      Capacity : Capacity_Subtype := 0) return Vector;\n+      Capacity : Count_Type := 0) return Vector;\n \n    function To_Cursor\n      (Container : Vector;\n@@ -157,26 +142,6 @@ package Ada.Containers.Formal_Vectors is\n       Position  : Cursor;\n       New_Item  : Element_Type);\n \n-   procedure Query_Element\n-     (Container : Vector;\n-      Index     : Index_Type;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n-   procedure Query_Element\n-     (Container : Vector;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n-   procedure Update_Element\n-     (Container : in out Vector;\n-      Index     : Index_Type;\n-      Process   : not null access procedure (Element : in out Element_Type));\n-\n-   procedure Update_Element\n-     (Container : in out Vector;\n-      Position  : Cursor;\n-      Process   : not null access procedure (Element : in out Element_Type));\n-\n    procedure Move (Target : in out Vector; Source : in out Vector);\n \n    procedure Insert\n@@ -214,17 +179,6 @@ package Ada.Containers.Formal_Vectors is\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1);\n-\n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Vector);\n@@ -243,17 +197,6 @@ package Ada.Containers.Formal_Vectors is\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n \n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1);\n-\n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1);\n-\n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n@@ -324,16 +267,6 @@ package Ada.Containers.Formal_Vectors is\n \n    function Has_Element (Container : Vector; Position : Cursor) return Boolean;\n \n-   procedure Iterate\n-     (Container : Vector;\n-      Process   : not null access\n-                    procedure (Container : Vector; Position : Cursor));\n-\n-   procedure Reverse_Iterate\n-     (Container : Vector;\n-      Process   : not null access\n-                    procedure (Container : Vector; Position : Cursor));\n-\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n@@ -357,8 +290,6 @@ private\n    pragma Inline (Element);\n    pragma Inline (First_Element);\n    pragma Inline (Last_Element);\n-   pragma Inline (Query_Element);\n-   pragma Inline (Update_Element);\n    pragma Inline (Replace_Element);\n    pragma Inline (Contains);\n    pragma Inline (Next);\n@@ -367,44 +298,16 @@ private\n    type Elements_Array is array (Count_Type range <>) of Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Vector (Capacity : Capacity_Subtype) is tagged record\n+   type Vector (Capacity : Count_Type) is tagged record\n       Elements : Elements_Array (1 .. Capacity);\n       Last     : Extended_Index := No_Index;\n-      Busy     : Natural := 0;\n-      Lock     : Natural := 0;\n    end record;\n \n-   use Ada.Streams;\n-\n-   procedure Write\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : Vector);\n-\n-   for Vector'Write use Write;\n-\n-   procedure Read\n-     (Stream    : not null access Root_Stream_Type'Class;\n-      Container : out Vector);\n-\n-   for Vector'Read use Read;\n-\n    type Cursor is record\n       Valid : Boolean    := True;\n       Index : Index_Type := Index_Type'First;\n    end record;\n \n-   procedure Write\n-     (Stream   : not null access Root_Stream_Type'Class;\n-      Position : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n-   procedure Read\n-     (Stream   : not null access Root_Stream_Type'Class;\n-      Position : out Cursor);\n-\n-   for Cursor'Read use Read;\n-\n    Empty_Vector : constant Vector := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := (Valid => False, Index => Index_Type'First);"}, {"sha": "570bfbc8a149797daeb2d8bd8c27f0a011f349db", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -2502,8 +2502,8 @@ package body Checks is\n          --  Here for normal case of predicate active\n \n          else\n-            --  If the type has a static predicate and the expression is also\n-            --  static, see if the expression satisfies the predicate.\n+            --  If the type has a static predicate and the expression is known\n+            --  at compile time, see if the expression satisfies the predicate.\n \n             Check_Expression_Against_Static_Predicate (N, Typ);\n "}, {"sha": "9e48afe888272b9b0adc681f11fe14b3151b0445", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -2741,20 +2741,20 @@ package body Exp_Attr is\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n-         --  In Ada 2005 (or later) if we have the standard nondefault\n-         --  bit order, then we return the original value as given in\n-         --  the component clause (RM 2005 13.5.2(3/2)).\n+         --  In Ada 2005 (or later) if we have the non-default bit order, then\n+         --  we return the original value as given in the component clause\n+         --  (RM 2005 13.5.2(3/2)).\n \n          if Present (Component_Clause (CE))\n            and then Ada_Version >= Ada_2005\n-           and then not Reverse_Bit_Order (Scope (CE))\n+           and then Reverse_Bit_Order (Scope (CE))\n          then\n             Rewrite (N,\n               Make_Integer_Literal (Loc,\n                 Intval => Expr_Value (First_Bit (Component_Clause (CE)))));\n             Analyze_And_Resolve (N, Typ);\n \n-         --  Otherwise (Ada 83/95 or Ada 2005 or later with reverse bit order),\n+         --  Otherwise (Ada 83/95 or Ada 2005 or later with default bit order),\n          --  rewrite with normalized value if we know it statically.\n \n          elsif Known_Static_Component_Bit_Offset (CE) then\n@@ -3321,20 +3321,20 @@ package body Exp_Attr is\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n-         --  In Ada 2005 (or later) if we have the standard nondefault\n-         --  bit order, then we return the original value as given in\n-         --  the component clause (RM 2005 13.5.2(4/2)).\n+         --  In Ada 2005 (or later) if we have the non-default bit order, then\n+         --  we return the original value as given in the component clause\n+         --  (RM 2005 13.5.2(3/2)).\n \n          if Present (Component_Clause (CE))\n            and then Ada_Version >= Ada_2005\n-           and then not Reverse_Bit_Order (Scope (CE))\n+           and then Reverse_Bit_Order (Scope (CE))\n          then\n             Rewrite (N,\n               Make_Integer_Literal (Loc,\n                 Intval => Expr_Value (Last_Bit (Component_Clause (CE)))));\n             Analyze_And_Resolve (N, Typ);\n \n-         --  Otherwise (Ada 83/95 or Ada 2005 or later with reverse bit order),\n+         --  Otherwise (Ada 83/95 or Ada 2005 or later with default bit order),\n          --  rewrite with normalized value if we know it statically.\n \n          elsif Known_Static_Component_Bit_Offset (CE)\n@@ -4243,18 +4243,18 @@ package body Exp_Attr is\n       begin\n          if Present (Component_Clause (CE)) then\n \n-            --  In Ada 2005 (or later) if we have the standard nondefault\n-            --  bit order, then we return the original value as given in\n-            --  the component clause (RM 2005 13.5.2(2/2)).\n+            --  In Ada 2005 (or later) if we have the non-default bit order,\n+            --  then we return the original value as given in the component\n+            --  clause (RM 2005 13.5.2(2/2)).\n \n             if Ada_Version >= Ada_2005\n-              and then not Reverse_Bit_Order (Scope (CE))\n+              and then Reverse_Bit_Order (Scope (CE))\n             then\n                Rewrite (N,\n                   Make_Integer_Literal (Loc,\n                     Intval => Expr_Value (Position (Component_Clause (CE)))));\n \n-            --  Otherwise (Ada 83 or 95, or reverse bit order specified in\n+            --  Otherwise (Ada 83 or 95, or default bit order specified in\n             --  later Ada version), return the normalized value.\n \n             else"}, {"sha": "a3b2c4e3a3e132ebab38ddd271078267a6448fa2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -3277,8 +3277,8 @@ package body Sem_Ch3 is\n             or else\n               Is_Partially_Initialized_Type (T, Include_Implicit => False))\n       then\n-         --  If the type has a static predicate and the expression is also\n-         --  static, see if the expression satisfies the predicate.\n+         --  If the type has a static predicate and the expression is known at\n+         --  compile time, see if the expression satisfies the predicate.\n \n          if Present (E) then\n             Check_Expression_Against_Static_Predicate (E, T);\n@@ -3297,8 +3297,7 @@ package body Sem_Ch3 is\n \n          if Is_String_Type (T) and then not Constant_Present (N) then\n             Check_SPARK_Restriction\n-              (\"declaration of object of unconstrained type not allowed\",\n-               N);\n+              (\"declaration of object of unconstrained type not allowed\", N);\n          end if;\n \n          --  Nothing to do in deferred constant case"}, {"sha": "e148d05bbf2e727632b3ccbb43378d463a7cfa16", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -202,7 +202,11 @@ package body Sem_Prag is\n       Check_Duplicates : Boolean := False) return Node_Id;\n    --  Find the declaration of the related subprogram subject to pragma Prag.\n    --  If flag Check_Duplicates is set, the routine emits errors concerning\n-   --  duplicate pragmas.\n+   --  duplicate pragmas. If a related subprogram is found, then either the\n+   --  corresponding N_Subprogram_Declaration node is returned, or, if the\n+   --  pragma applies to a subprogram body, then the N_Subprogram_Body node\n+   --  is returned. Note that in the latter case, no check is made to ensure\n+   --  that there is no separate declaration of the subprogram.\n \n    function Get_Base_Subprogram (Def_Id : Entity_Id) return Entity_Id;\n    --  If Def_Id refers to a renamed subprogram, then the base subprogram (the\n@@ -10043,7 +10047,6 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n-            S14_Pragma;\n             Check_Arg_Count (1);\n \n             --  Ensure the proper placement of the pragma. Contract_Cases must\n@@ -18113,63 +18116,83 @@ package body Sem_Prag is\n    is\n       Context   : constant Node_Id := Parent (Prag);\n       Nam       : constant Name_Id := Pragma_Name (Prag);\n-      Decl      : Node_Id;\n+      Elmt      : Node_Id;\n       Subp_Decl : Node_Id;\n \n    begin\n-      --  The pragma is a byproduct of an aspect\n+      pragma Assert (Nkind (Prag) = N_Pragma);\n+\n+      --  If the pragma comes from an aspect, then what we want is the\n+      --  declaration to which the aspect is attached, i.e. its parent.\n \n       if Present (Corresponding_Aspect (Prag)) then\n-         Subp_Decl := Parent (Corresponding_Aspect (Prag));\n+         return Parent (Corresponding_Aspect (Prag));\n+      end if;\n \n-      --  The pragma is associated with a library-level subprogram\n+      --  Otherwise the pragma must be a list element, and the first thing to\n+      --  do is to position past any previous pragmas or generated code. What\n+      --  we are doing here is looking for the preceding declaration. This is\n+      --  also where we will check for a duplicate pragma.\n \n-      elsif Nkind (Context) = N_Compilation_Unit_Aux then\n-         Subp_Decl := Unit (Parent (Context));\n+      pragma Assert (Is_List_Member (Prag));\n \n-      --  The pragma appears inside the declarative part of a subprogram body\n+      Elmt := Prag;\n+      loop\n+         Elmt := Prev (Elmt);\n+         exit when No (Elmt);\n \n-      elsif Nkind (Context) = N_Subprogram_Body then\n-         Subp_Decl := Context;\n+         --  Typically want we will want is the declaration original node. But\n+         --  for the generic subprogram case, don't go to to the original node,\n+         --  which is the unanalyzed tree: we need to attach the pre- and post-\n+         --  conditions to the analyzed version at this point. They propagate\n+         --  to the original tree when analyzing the corresponding body.\n \n-      --  The pragma appears someplace after its related subprogram. Inspect\n-      --  all previous declarations for a suitable candidate.\n+         if Nkind (Elmt) not in N_Generic_Declaration then\n+            Subp_Decl := Original_Node (Elmt);\n+         else\n+            Subp_Decl := Elmt;\n+         end if;\n \n-      else\n-         Decl      := Prag;\n-         Subp_Decl := Empty;\n-         while Present (Prev (Decl)) loop\n-            Decl := Prev (Decl);\n+         --  Skip prior pragmas\n \n-            if Nkind (Decl) in N_Generic_Declaration then\n-               Subp_Decl := Decl;\n-            else\n-               Subp_Decl := Original_Node (Decl);\n+         if Nkind (Subp_Decl) = N_Pragma then\n+            if Check_Duplicates and then Pragma_Name (Subp_Decl) = Nam then\n+               Error_Msg_Name_1 := Nam;\n+               Error_Msg_Sloc   := Sloc (Subp_Decl);\n+               Error_Msg_N (\"pragma % duplicates pragma declared #\", Prag);\n             end if;\n \n-            --  Skip prior pragmas\n+         --  Skip internally generated code\n \n-            if Nkind (Subp_Decl) = N_Pragma then\n-               if Check_Duplicates and then Pragma_Name (Subp_Decl) = Nam then\n-                  Error_Msg_Name_1 := Nam;\n-                  Error_Msg_Sloc   := Sloc (Subp_Decl);\n-                  Error_Msg_N (\"pragma % duplicates pragma declared #\", Prag);\n-               end if;\n+         elsif not Comes_From_Source (Subp_Decl) then\n+            null;\n \n-            --  Skip internally generated code\n+         --  Otherwise we have a declaration to return\n \n-            elsif not Comes_From_Source (Subp_Decl) then\n-               null;\n+         else\n+            return Subp_Decl;\n+         end if;\n+      end loop;\n \n-            --  The nearest preceding declaration is the related subprogram\n+      --  We fell through, which means there was no declaration preceding the\n+      --  pragma (either it was the first element of the list, or we only had\n+      --  other pragmas and generated code before it).\n \n-            else\n-               exit;\n-            end if;\n-         end loop;\n-      end if;\n+      --  The pragma is associated with a library-level subprogram\n+\n+      if Nkind (Context) = N_Compilation_Unit_Aux then\n+         return Unit (Parent (Context));\n \n-      return Subp_Decl;\n+      --  The pragma appears inside the declarative part of a subprogram body\n+\n+      elsif Nkind (Context) = N_Subprogram_Body then\n+         return Context;\n+\n+      --  Otherwise no subprogram found, return original pragma\n+\n+      else\n+         return Prag;\n+      end if;\n    end Find_Related_Subprogram;\n \n    -------------------------"}, {"sha": "c914703f8941514f08ba9f8590a9669751327e6e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -1301,11 +1301,11 @@ package body Sem_Util is\n       Typ  : Entity_Id)\n    is\n    begin\n-      --  When both the predicate and the expression are static, evaluate the\n-      --  check at compile time. A type becomes non-static when it has aspect\n-      --  Dynamic_Predicate.\n+      --  When the predicate is static and the value of the expression is known\n+      --  at compile time, evaluate the predicate check. A type is non-static\n+      --  when it has aspect Dynamic_Predicate.\n \n-      if Is_OK_Static_Expression (Expr)\n+      if Compile_Time_Known_Value (Expr)\n         and then Has_Predicates (Typ)\n         and then Present (Static_Predicate (Typ))\n         and then not Has_Dynamic_Predicate_Aspect (Typ)"}, {"sha": "7ea5657aa2b3d9472ecc2292742a49485433f4ae", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "patch": "@@ -195,9 +195,9 @@ package Sem_Util is\n      (Expr : Node_Id;\n       Typ  : Entity_Id);\n    --  Determine whether an arbitrary expression satisfies the static predicate\n-   --  of a type. The routine does nothing if Expr is non-static or Typ lacks a\n-   --  static predicate, otherwise it may emit a warning if the expression is\n-   --  prohibited by the predicate.\n+   --  of a type. The routine does nothing if Expr is not known at compile time\n+   --  or Typ lacks a static predicate, otherwise it may emit a warning if the\n+   --  expression is prohibited by the predicate.\n \n    procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n    --  Verify that the full declaration of type T has been seen. If not, place"}]}