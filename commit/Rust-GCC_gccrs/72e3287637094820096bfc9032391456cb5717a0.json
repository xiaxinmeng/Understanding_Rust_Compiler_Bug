{"sha": "72e3287637094820096bfc9032391456cb5717a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlMzI4NzYzNzA5NDgyMDA5NmJmYzkwMzIzOTE0NTZjYjU3MTdhMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-01T23:28:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-01T23:28:46Z"}, "message": "unwind-ia64.c: Include ia64intrin.h.\n\n        * config/ia64/unwind-ia64.c: Include ia64intrin.h.\n        (atomic_alloc, atomic_free): New.\n        (SIZE, MASK_FOR, PTR_IN): New.\n        (emergency_reg_state, emergency_reg_state_free): New.\n        (emergency_labeled_state, emergency_labeled_state_free): New.\n        (reg_state_alloced, labeled_state_alloced): New.\n        (alloc_reg_state, free_reg_state): New.\n        (alloc_label_state, free_label_state, free_label_states): New.\n        (push, pop, dup_state_stack, free_state_stack): Use them.\n        (desc_label_state): Likewise.\n        (uw_frame_state_for): Free label states and state stack.\n        (uw_update_reg_address): Eliminate warnings.\n\nFrom-SVN: r51722", "tree": {"sha": "f09740f6beb6c11a9b5a636d058e70e341a49806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09740f6beb6c11a9b5a636d058e70e341a49806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72e3287637094820096bfc9032391456cb5717a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e3287637094820096bfc9032391456cb5717a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e3287637094820096bfc9032391456cb5717a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e3287637094820096bfc9032391456cb5717a0/comments", "author": null, "committer": null, "parents": [{"sha": "84d760747ee51227a28a6dc8e156837a54e02d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d760747ee51227a28a6dc8e156837a54e02d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d760747ee51227a28a6dc8e156837a54e02d18"}], "stats": {"total": 222, "additions": 190, "deletions": 32}, "files": [{"sha": "a8aad866f269343820c4a017c7624b01c91c11da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e3287637094820096bfc9032391456cb5717a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e3287637094820096bfc9032391456cb5717a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72e3287637094820096bfc9032391456cb5717a0", "patch": "@@ -1,3 +1,18 @@\n+2002-04-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/unwind-ia64.c: Include ia64intrin.h.\n+\t(atomic_alloc, atomic_free): New.\n+\t(SIZE, MASK_FOR, PTR_IN): New.\n+\t(emergency_reg_state, emergency_reg_state_free): New.\n+\t(emergency_labeled_state, emergency_labeled_state_free): New.\n+\t(reg_state_alloced, labeled_state_alloced): New.\n+\t(alloc_reg_state, free_reg_state): New.\n+\t(alloc_label_state, free_label_state, free_label_states): New.\n+\t(push, pop, dup_state_stack, free_state_stack): Use them.\n+\t(desc_label_state): Likewise.\n+\t(uw_frame_state_for): Free label states and state stack.\n+\t(uw_update_reg_address): Eliminate warnings.\n+\n 2002-04-01  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* config/pa/pa-pro-end.h (ASM_OUTPUT_ALIGNED_COMMON,"}, {"sha": "daf02a2cd30d9fa5fcf6c80519a62b7aa8b9805c", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 175, "deletions": 32, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e3287637094820096bfc9032391456cb5717a0/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e3287637094820096bfc9032391456cb5717a0/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=72e3287637094820096bfc9032391456cb5717a0", "patch": "@@ -35,6 +35,10 @@\n #include \"tsystem.h\"\n #include \"unwind.h\"\n #include \"unwind-ia64.h\"\n+#include \"ia64intrin.h\"\n+\n+/* This isn't thread safe, but nice for occasional tests.  */\n+#undef ENABLE_MALLOC_CHECKING\n \n #ifndef __USING_SJLJ_EXCEPTIONS__\n #define UNW_VER(x)\t\t((x) >> 48)\n@@ -237,14 +241,128 @@ static unsigned char const save_order[] =\n \f\n #define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n \n-/* Routines to manipulate the state stack.  */\n+/* MASK is a bitmap describing the allocation state of emergency buffers,\n+   with bit set indicating free. Return >= 0 if allocation is successful;\n+   < 0 if failure.  */\n \n-static void\n-push (struct unw_state_record *sr)\n+static inline int\n+atomic_alloc (unsigned int *mask)\n+{\n+  unsigned int old = *mask, ret, new;\n+\n+  while (1)\n+    {\n+      if (old == 0)\n+\treturn -1;\n+      ret = old & -old;\n+      new = old & ~ret;\n+      new = __sync_val_compare_and_swap (mask, old, new);\n+      if (old == new)\n+\tbreak;\n+      old = new;\n+    }\n+\n+  return __builtin_ffs (ret) - 1;\n+}\n+\n+/* Similarly, free an emergency buffer.  */\n+\n+static inline void\n+atomic_free (unsigned int *mask, int bit)\n+{\n+  __sync_xor_and_fetch (mask, 1 << bit);\n+}\n+\n+\n+#define SIZE(X)\t\t(sizeof(X) / sizeof(*(X)))\n+#define MASK_FOR(X)\t((2U << (SIZE (X) - 1)) - 1)\n+#define PTR_IN(X, P)\t((P) >= (X) && (P) < (X) + SIZE (X))\n+\n+static struct unw_reg_state emergency_reg_state[32];\n+static int emergency_reg_state_free = MASK_FOR (emergency_reg_state);\n+\n+static struct unw_labeled_state emergency_labeled_state[8];\n+static int emergency_labeled_state_free = MASK_FOR (emergency_labeled_state);\n+\n+#ifdef ENABLE_MALLOC_CHECKING\n+static int reg_state_alloced;\n+static int labeled_state_alloced;\n+#endif\n+\n+/* Allocation and deallocation of structures.  */\n+\n+static struct unw_reg_state *\n+alloc_reg_state (void)\n {\n   struct unw_reg_state *rs;\n \n+#ifdef ENABLE_MALLOC_CHECKING\n+  reg_state_alloced++;\n+#endif\n+\n   rs = malloc (sizeof (struct unw_reg_state));\n+  if (!rs)\n+    {\n+      int n = atomic_alloc (&emergency_reg_state_free);\n+      if (n >= 0)\n+\trs = &emergency_reg_state[n];\n+    }\n+\n+  return rs;\n+}\n+\n+static void\n+free_reg_state (struct unw_reg_state *rs)\n+{\n+#ifdef ENABLE_MALLOC_CHECKING\n+  reg_state_alloced--;\n+#endif\n+\n+  if (PTR_IN (emergency_reg_state, rs))\n+    atomic_free (&emergency_reg_state_free, rs - emergency_reg_state);\n+  else\n+    free (rs);\n+}\n+\n+static struct unw_labeled_state *\n+alloc_label_state (void)\n+{\n+  struct unw_labeled_state *ls;\n+\n+#ifdef ENABLE_MALLOC_CHECKING\n+  labeled_state_alloced++;\n+#endif\n+\n+  ls = malloc(sizeof(struct unw_labeled_state));\n+  if (!ls)\n+    {\n+      int n = atomic_alloc (&emergency_labeled_state_free);\n+      if (n >= 0)\n+\tls = &emergency_labeled_state[n];\n+    }\n+\n+  return ls;\n+}\n+\n+static void\n+free_label_state (struct unw_labeled_state *ls)\n+{\n+#ifdef ENABLE_MALLOC_CHECKING\n+  labeled_state_alloced--;\n+#endif\n+\n+  if (PTR_IN (emergency_labeled_state, ls))\n+    atomic_free (&emergency_labeled_state_free, emergency_labeled_state - ls);\n+  else\n+    free (ls);\n+}\n+\n+/* Routines to manipulate the state stack.  */\n+\n+static void\n+push (struct unw_state_record *sr)\n+{\n+  struct unw_reg_state *rs = alloc_reg_state ();\n   memcpy (rs, &sr->curr, sizeof (*rs));\n   sr->curr.next = rs;\n }\n@@ -255,28 +373,30 @@ pop (struct unw_state_record *sr)\n   struct unw_reg_state *rs = sr->curr.next;\n \n   if (!rs)\n-    abort();\n-  memcpy(&sr->curr, rs, sizeof(*rs));\n-  free (rs);\n+    abort ();\n+  memcpy (&sr->curr, rs, sizeof(*rs));\n+  free_reg_state (rs);\n }\n \n /* Make a copy of the state stack.  Non-recursive to avoid stack overflows.  */\n+\n static struct unw_reg_state *\n dup_state_stack (struct unw_reg_state *rs)\n {\n   struct unw_reg_state *copy, *prev = NULL, *first = NULL;\n \n   while (rs)\n     {\n-      copy = malloc(sizeof(struct unw_state_record));\n-      memcpy(copy, rs, sizeof(*copy));\n+      copy = alloc_reg_state ();\n+      memcpy (copy, rs, sizeof(*copy));\n       if (first)\n \tprev->next = copy;\n       else\n \tfirst = copy;\n       rs = rs->next;\n       prev = copy;\n     }\n+\n   return first;\n }\n \n@@ -289,10 +409,26 @@ free_state_stack (struct unw_reg_state *rs)\n   for (p = rs->next; p != NULL; p = next)\n     {\n       next = p->next;\n-      free(p);\n+      free_reg_state (p);\n     }\n   rs->next = NULL;\n }\n+\n+/* Free all labeled states.  */\n+\n+static void\n+free_label_states (struct unw_labeled_state *ls)\n+{\n+  struct unw_labeled_state *next;\n+\n+  for (; ls ; ls = next)\n+    {\n+      next = ls->next;\n+\n+      free_state_stack (&ls->saved_state);\n+      free_label_state (ls);\n+    }\n+}\n \f\n /* Unwind decoder routines */\n \n@@ -377,7 +513,7 @@ finish_prologue (struct unw_state_record *sr)\n   /* First, resolve implicit register save locations\n      (see Section \"11.4.2.3 Rules for Using Unwind Descriptors\", rule 3).  */\n \n-  for (i = 0; i < (int) sizeof(save_order); ++i)\n+  for (i = 0; i < (int) sizeof (save_order); ++i)\n     {\n       reg = sr->curr.reg + save_order[i];\n       if (reg->where == UNW_WHERE_GR_SAVE)\n@@ -410,21 +546,21 @@ finish_prologue (struct unw_state_record *sr)\n \t    mask = *cp++;\n \t  kind = (mask >> 2*(3-(t & 3))) & 3;\n \t  if (kind > 0)\n-\t    spill_next_when(&regs[kind - 1], sr->curr.reg + limit[kind - 1],\n-\t\t\t    sr->region_start + t);\n+\t    spill_next_when (&regs[kind - 1], sr->curr.reg + limit[kind - 1],\n+\t\t\t     sr->region_start + t);\n \t}\n     }\n \n   /* Next, lay out the memory stack spill area.  */\n   if (sr->any_spills)\n     {\n       off = sr->spill_offset;\n-      alloc_spill_area(&off, 16, sr->curr.reg + UNW_REG_F2,\n-\t\t       sr->curr.reg + UNW_REG_F31); \n-      alloc_spill_area(&off,  8, sr->curr.reg + UNW_REG_B1,\n-\t\t       sr->curr.reg + UNW_REG_B5);\n-      alloc_spill_area(&off,  8, sr->curr.reg + UNW_REG_R4,\n-\t\t       sr->curr.reg + UNW_REG_R7);\n+      alloc_spill_area (&off, 16, sr->curr.reg + UNW_REG_F2,\n+\t\t        sr->curr.reg + UNW_REG_F31); \n+      alloc_spill_area (&off,  8, sr->curr.reg + UNW_REG_B1,\n+\t\t        sr->curr.reg + UNW_REG_B5);\n+      alloc_spill_area (&off,  8, sr->curr.reg + UNW_REG_R4,\n+\t\t        sr->curr.reg + UNW_REG_R7);\n     }\n }\n \n@@ -439,7 +575,7 @@ desc_prologue (int body, unw_word rlen, unsigned char mask,\n   int i;\n \n   if (!(sr->in_body || sr->first_region))\n-    finish_prologue(sr);\n+    finish_prologue (sr);\n   sr->first_region = 0;\n \n   /* Check if we're done.  */\n@@ -450,12 +586,13 @@ desc_prologue (int body, unw_word rlen, unsigned char mask,\n     }\n \n   for (i = 0; i < sr->epilogue_count; ++i)\n-    pop(sr);\n+    pop (sr);\n+\n   sr->epilogue_count = 0;\n   sr->epilogue_start = UNW_WHEN_NEVER;\n \n   if (!body)\n-    push(sr);\n+    push (sr);\n \n   sr->region_start += sr->region_len;\n   sr->region_len = rlen;\n@@ -685,9 +822,9 @@ desc_copy_state (unw_word label, struct unw_state_record *sr)\n     {\n       if (ls->label == label)\n         {\n-\t  free_state_stack(&sr->curr);\n-   \t  memcpy(&sr->curr, &ls->saved_state, sizeof(sr->curr));\n-\t  sr->curr.next = dup_state_stack(ls->saved_state.next);\n+\t  free_state_stack (&sr->curr);\n+   \t  memcpy (&sr->curr, &ls->saved_state, sizeof (sr->curr));\n+\t  sr->curr.next = dup_state_stack (ls->saved_state.next);\n \t  return;\n \t}\n     }\n@@ -697,14 +834,13 @@ desc_copy_state (unw_word label, struct unw_state_record *sr)\n static inline void\n desc_label_state (unw_word label, struct unw_state_record *sr)\n {\n-  struct unw_labeled_state *ls;\n+  struct unw_labeled_state *ls = alloc_label_state ();\n \n-  ls = malloc(sizeof(struct unw_labeled_state));\n   ls->label = label;\n-  memcpy(&ls->saved_state, &sr->curr, sizeof(ls->saved_state));\n-  ls->saved_state.next = dup_state_stack(sr->curr.next);\n+  memcpy (&ls->saved_state, &sr->curr, sizeof (ls->saved_state));\n+  ls->saved_state.next = dup_state_stack (sr->curr.next);\n \n-  /* insert into list of labeled states: */\n+  /* Insert into list of labeled states.  */\n   ls->next = sr->labeled_states;\n   sr->labeled_states = ls;\n }\n@@ -1574,6 +1710,14 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   while (!fs->done && insn < insn_end)\n     insn = unw_decode (insn, fs->in_body, fs);\n \n+  free_label_states (fs->labeled_states);\n+  free_state_stack (&fs->curr);\n+\n+#ifdef ENABLE_MALLOC_CHECKING\n+  if (reg_state_alloced || labeled_state_alloced)\n+    abort ();\n+#endif\n+\n   /* If we're in the epilogue, sp has been restored and all values\n      on the memory stack below psp also have been restored.  */\n   if (fs->when_target > fs->epilogue_start)\n@@ -1634,7 +1778,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n       /* Note that while RVAL can only be 1-5 from normal descriptors,\n \t we can want to look at B0 due to having manually unwound a\n \t signal frame.  */\n-      if (rval >= 0 && rval <= 5)\n+      if (rval <= 5)\n \taddr = context->br_loc[rval];\n       else\n \tabort ();\n@@ -1733,8 +1877,7 @@ uw_update_reg_address (struct _Unwind_Context *context,\n       context->psp = *(unsigned long *)addr;\n       break;\n \n-    case UNW_REG_RNAT:\n-    case UNW_NUM_REGS:\n+    default:\n       abort ();\n     }\n }"}]}