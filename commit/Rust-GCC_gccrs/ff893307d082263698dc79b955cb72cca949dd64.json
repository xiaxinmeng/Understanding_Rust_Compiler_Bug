{"sha": "ff893307d082263698dc79b955cb72cca949dd64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY4OTMzMDdkMDgyMjYzNjk4ZGM3OWI5NTVjYjcyY2NhOTQ5ZGQ2NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-09-10T02:49:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-10T02:49:45Z"}, "message": "algo.h, [...]: Update To September 8 SGI release.\n\n\t* algo.h, algobase.h, alloc.h, bvector.h, deque.h, hashtable.h,\n\titerator.h, list.h, rope.h, ropeimpl.h, slist.h, stl_config.h,\n\ttree.h, vector.h: Update To September 8 SGI release.\n\nFrom-SVN: r15211", "tree": {"sha": "6fbaaedc3231eb90bf4d0271528c64368c08b5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fbaaedc3231eb90bf4d0271528c64368c08b5a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff893307d082263698dc79b955cb72cca949dd64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff893307d082263698dc79b955cb72cca949dd64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff893307d082263698dc79b955cb72cca949dd64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff893307d082263698dc79b955cb72cca949dd64/comments", "author": null, "committer": null, "parents": [{"sha": "c6b50f1082077ca8013ed0cc514fd7de7e2f4aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b50f1082077ca8013ed0cc514fd7de7e2f4aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6b50f1082077ca8013ed0cc514fd7de7e2f4aaa"}], "stats": {"total": 1243, "additions": 779, "deletions": 464}, "files": [{"sha": "2e12e0c8dab2c6ec7589581b831c783e5295871e", "filename": "libstdc++/stl/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2FChangeLog?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -1,3 +1,9 @@\n+Tue Sep  9 19:47:28 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* algo.h, algobase.h, alloc.h, bvector.h, deque.h, hashtable.h,\n+\titerator.h, list.h, rope.h, ropeimpl.h, slist.h, stl_config.h,\n+\ttree.h, vector.h: Update To September 8 SGI release.\n+\n Tue Sep  9 17:38:47 1997  Mark Mitchell  <mmitchell@usa.net>\n \n \t* stl_config.h (__STL_MEMBER_TEMPLATES): Enable."}, {"sha": "2f142898d8b975cf5c8d8dbaeeeadf1855950f7f", "filename": "libstdc++/stl/algo.h", "status": "modified", "additions": 269, "deletions": 57, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgo.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -236,6 +236,63 @@ inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n \t\t    distance_type(first1), distance_type(first2));\n }\n \n+template <class ForwardIterator, class Integer, class T>\n+ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n+                         Integer count, const T& value) {\n+  if (count <= 0)\n+    return first;\n+  else {\n+    first = find(first, last, value);\n+    while (first != last) {\n+      Integer n = count - 1;\n+      ForwardIterator i = first;\n+      ++i;\n+      while (i != last && n != 0 && *i == value) {\n+        ++i;\n+        --n;\n+      }\n+      if (n == 0)\n+        return first;\n+      else\n+        first = find(i, last, value);\n+    }\n+    return last;\n+  }\n+}\n+\n+template <class ForwardIterator, class Integer, class T, class BinaryPredicate>\n+ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n+                         Integer count, const T& value,\n+                         BinaryPredicate binary_pred) {\n+  if (count <= 0)\n+    return first;\n+  else {\n+    while (first != last) {\n+      if (binary_pred(*first, value)) break;\n+      ++first;\n+    }\n+    while (first != last) {\n+      Integer n = count - 1;\n+      ForwardIterator i = first;\n+      ++i;\n+      while (i != last && n != 0 && binary_pred(*i, value)) {\n+        ++i;\n+        --n;\n+      }\n+      if (n == 0)\n+        return first;\n+      else {\n+        while (i != last) {\n+          if (binary_pred(*i, value)) break;\n+          ++i;\n+        }\n+        first = i;\n+      }\n+    }\n+    return last;\n+  }\n+} \n+\n template <class ForwardIterator1, class ForwardIterator2>\n ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,\n \t\t\t     ForwardIterator2 first2) {\n@@ -1400,15 +1457,6 @@ ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n     return first;\n }\n \n-template <class ForwardIterator, class T, class Distance>\n-inline ForwardIterator __lower_bound(ForwardIterator first,\n-\t\t\t\t     ForwardIterator last,\n-\t\t\t\t     const T& value, Distance*,\n-\t\t\t\t     bidirectional_iterator_tag) {\n-    return __lower_bound(first, last, value, (Distance*)0,\n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Distance>\n RandomAccessIterator __lower_bound(RandomAccessIterator first,\n \t\t\t\t   RandomAccessIterator last, const T& value,\n@@ -1459,15 +1507,6 @@ ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n     return first;\n }\n \n-template <class ForwardIterator, class T, class Compare, class Distance>\n-inline ForwardIterator __lower_bound(ForwardIterator first,\n-\t\t\t\t     ForwardIterator last,\n-\t\t\t\t     const T& value, Compare comp, Distance*,\n-\t\t\t\t     bidirectional_iterator_tag) {\n-    return __lower_bound(first, last, value, comp, (Distance*)0,\n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Compare, class Distance>\n RandomAccessIterator __lower_bound(RandomAccessIterator first,\n \t\t\t\t   RandomAccessIterator last,\n@@ -1520,15 +1559,6 @@ ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n     return first;\n }\n \n-template <class ForwardIterator, class T, class Distance>\n-inline ForwardIterator __upper_bound(ForwardIterator first,\n-\t\t\t\t     ForwardIterator last,\n-\t\t\t\t     const T& value, Distance*,\n-\t\t\t\t     bidirectional_iterator_tag) {\n-    return __upper_bound(first, last, value, (Distance*)0,\n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Distance>\n RandomAccessIterator __upper_bound(RandomAccessIterator first,\n \t\t\t\t   RandomAccessIterator last, const T& value,\n@@ -1581,15 +1611,6 @@ ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n     return first;\n }\n \n-template <class ForwardIterator, class T, class Compare, class Distance>\n-inline ForwardIterator __upper_bound(ForwardIterator first,\n-\t\t\t\t     ForwardIterator last,\n-\t\t\t\t     const T& value, Compare comp, Distance*,\n-\t\t\t\t     bidirectional_iterator_tag) {\n-    return __upper_bound(first, last, value, comp, (Distance*)0,\n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Compare, class Distance>\n RandomAccessIterator __upper_bound(RandomAccessIterator first,\n \t\t\t\t   RandomAccessIterator last,\n@@ -1648,14 +1669,6 @@ __equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n     return pair<ForwardIterator, ForwardIterator>(first, first);\n }\n \n-template <class ForwardIterator, class T, class Distance>\n-inline pair<ForwardIterator, ForwardIterator>\n-__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n-\t      Distance*, bidirectional_iterator_tag) {\n-    return __equal_range(first, last, value, (Distance*)0, \n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Distance>\n pair<RandomAccessIterator, RandomAccessIterator>\n __equal_range(RandomAccessIterator first, RandomAccessIterator last,\n@@ -1718,14 +1731,6 @@ __equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n     return pair<ForwardIterator, ForwardIterator>(first, first);\n }           \n \n-template <class ForwardIterator, class T, class Compare, class Distance>\n-inline pair<ForwardIterator, ForwardIterator>\n-__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n-\t      Compare comp, Distance*, bidirectional_iterator_tag) {\n-    return __equal_range(first, last, value, comp, (Distance*)0, \n-\t\t\t forward_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class T, class Compare, class Distance>\n pair<RandomAccessIterator, RandomAccessIterator>\n __equal_range(RandomAccessIterator first, RandomAccessIterator last,\n@@ -2543,6 +2548,213 @@ OutputIterator adjacent_difference(InputIterator first, InputIterator last,\n \t\t\t\t binary_op);\n }\n \n+template <class InputIterator, class ForwardIterator>\n+InputIterator find_first_of(InputIterator first1, InputIterator last1,\n+                            ForwardIterator first2, ForwardIterator last2)\n+{\n+  for ( ; first1 != last1; ++first1) \n+    for (ForwardIterator iter = first2; iter != last2; ++iter)\n+      if (*first1 == *iter)\n+        return first1;\n+  return last1;\n+}\n+\n+template <class InputIterator, class ForwardIterator, class BinaryPredicate>\n+InputIterator find_first_of(InputIterator first1, InputIterator last1,\n+                            ForwardIterator first2, ForwardIterator last2,\n+                            BinaryPredicate comp)\n+{\n+  for ( ; first1 != last1; ++first1) \n+    for (ForwardIterator iter = first2; iter != last2; ++iter)\n+      if (comp(*first1, *iter))\n+        return first1;\n+  return last1;\n+}\n+\n+\n+// Search [first2, last2) as a subsequence in [first1, last1).\n+\n+// find_end for forward iterators. \n+template <class ForwardIterator1, class ForwardIterator2>\n+ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n+                            ForwardIterator2 first2, ForwardIterator2 last2,\n+                            forward_iterator_tag, forward_iterator_tag)\n+{\n+  if (first2 == last2)\n+    return last1;\n+  else {\n+    ForwardIterator1 result = last1;\n+    while (1) {\n+      ForwardIterator1 new_result = search(first1, last1, first2, last2);\n+      if (new_result == last1)\n+        return result;\n+      else {\n+        result = new_result;\n+        first1 = new_result;\n+        ++first1;\n+      }\n+    }\n+  }\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2,\n+          class BinaryPredicate>\n+ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n+                            ForwardIterator2 first2, ForwardIterator2 last2,\n+                            forward_iterator_tag, forward_iterator_tag,\n+                            BinaryPredicate comp)\n+{\n+  if (first2 == last2)\n+    return last1;\n+  else {\n+    ForwardIterator1 result = last1;\n+    while (1) {\n+      ForwardIterator1 new_result = search(first1, last1, first2, last2, comp);\n+      if (new_result == last1)\n+        return result;\n+      else {\n+        result = new_result;\n+        first1 = new_result;\n+        ++first1;\n+      }\n+    }\n+  }\n+}\n+\n+// find_end for bidirectional iterators.  Requires partial specialization.\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2>\n+BidirectionalIterator1\n+__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n+           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n+           bidirectional_iterator_tag, bidirectional_iterator_tag)\n+{\n+  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n+  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n+\n+  reviter1 rlast1(first1);\n+  reviter2 rlast2(first2);\n+  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2);\n+\n+  if (rresult == rlast1)\n+    return last1;\n+  else {\n+    BidirectionalIterator1 result = rresult.base();\n+    advance(result, -distance(first2, last2));\n+    return result;\n+  }\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2,\n+          class BinaryPredicate>\n+BidirectionalIterator1\n+__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n+           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n+           bidirectional_iterator_tag, bidirectional_iterator_tag, \n+           BinaryPredicate comp)\n+{\n+  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n+  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n+\n+  reviter1 rlast1(first1);\n+  reviter2 rlast2(first2);\n+  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2,\n+                            comp);\n+\n+  if (rresult == rlast1)\n+    return last1;\n+  else {\n+    BidirectionalIterator1 result = rresult.base();\n+    advance(result, -distance(first2, last2));\n+    return result;\n+  }\n+}\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+// Dispatching functions.\n+\n+template <class ForwardIterator, class BidirectionalIterator>\n+inline ForwardIterator \n+__find_end(ForwardIterator first1, ForwardIterator last1, \n+           BidirectionalIterator first2, BidirectionalIterator last2,\n+           forward_iterator_tag, bidirectional_iterator_tag)\n+{\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag());\n+}\n+ \n+template <class BidirectionalIterator, class ForwardIterator>\n+inline BidirectionalIterator\n+__find_end(BidirectionalIterator first1, BidirectionalIterator last1, \n+           ForwardIterator first2, ForwardIterator last2,\n+           bidirectional_iterator_tag, forward_iterator_tag)\n+{\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag());\n+}\n+\n+template <class ForwardIterator, class BidirectionalIterator,\n+          class BinaryPredicate>\n+inline ForwardIterator \n+__find_end(ForwardIterator first1, ForwardIterator last1, \n+           BidirectionalIterator first2, BidirectionalIterator last2,\n+           forward_iterator_tag, bidirectional_iterator_tag,\n+           BinaryPredicate comp)\n+{\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag(),\n+                    comp);\n+\n+}\n+ \n+template <class BidirectionalIterator, class ForwardIterator,\n+          class BinaryPredicate>\n+inline BidirectionalIterator\n+__find_end(BidirectionalIterator first1, BidirectionalIterator last1, \n+           ForwardIterator first2, ForwardIterator last2,\n+           bidirectional_iterator_tag, forward_iterator_tag, \n+           BinaryPredicate comp)\n+{\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag(),\n+                    comp);\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2>\n+inline ForwardIterator1 \n+find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n+         ForwardIterator2 first2, ForwardIterator2 last2)\n+{\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+  return __find_end(first1, last1, first2, last2,\n+                    iterator_traits<ForwardIterator1>::iterator_category(),\n+                    iterator_traits<ForwardIterator2>::iterator_category());\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag());\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2, \n+          class BinaryPredicate>\n+inline ForwardIterator1 \n+find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n+         ForwardIterator2 first2, ForwardIterator2 last2,\n+         BinaryPredicate comp)\n+{\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+  return __find_end(first1, last1, first2, last2,\n+                    iterator_traits<ForwardIterator1>::iterator_category(),\n+                    iterator_traits<ForwardIterator2>::iterator_category(),\n+                    comp);\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag(),\n+                    comp);\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+}\n+\n // Returns x ** n, where n >= 0.  Note that \"multiplication\"\n //  is required to be associative, but not necessarily commutative.\n     \n@@ -2551,18 +2763,18 @@ T power(T x, Integer n, MonoidOperation op) {\n   if (n == 0)\n     return identity_element(op);\n   else {\n-    while (n % 2 == 0) {\n-      n /= 2;\n+    while ((n & 1) == 0) {\n+      n >>= 1;\n       x = op(x, x);\n     }\n \n     T result = x;\n-    n /= 2;\n+    n >>= 1;\n     while (n != 0) {\n       x = op(x, x);\n-      if (n % 2 != 0)\n+      if ((n & 1) != 0)\n         result = op(result, x);\n-      n /= 2;\n+      n >>= 1;\n     }\n     return result;\n   }"}, {"sha": "eccf465d52c4ca40f37cea69963c81123667e895", "filename": "libstdc++/stl/algobase.h", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgobase.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -86,19 +86,6 @@ inline void __distance(InputIterator first, InputIterator last, Distance& n,\n     while (first != last) { ++first; ++n; }\n }\n \n-template <class ForwardIterator, class Distance>\n-inline void __distance(ForwardIterator first, ForwardIterator last,\n-                       Distance& n, \n-                       forward_iterator_tag) {\n-    while (first != last) { ++first; ++n; }\n-}\n-\n-template <class BidirectionalIterator, class Distance>\n-inline void __distance(BidirectionalIterator first, BidirectionalIterator last,\n-                       Distance& n, bidirectional_iterator_tag) {\n-    while (first != last) { ++first; ++n; }\n-}\n-\n template <class RandomAccessIterator, class Distance>\n inline void __distance(RandomAccessIterator first, RandomAccessIterator last, \n \t\t       Distance& n, random_access_iterator_tag) {\n@@ -122,19 +109,6 @@ __distance(InputIterator first, InputIterator last, input_iterator_tag) {\n   return n;\n }\n \n-template <class ForwardIterator>\n-inline iterator_traits<ForwardIterator>::difference_type\n-__distance(ForwardIterator first, ForwardIterator last, forward_iterator_tag) {\n-  return __distance(first, last, input_iterator_tag());\n-}\n-\n-template <class BidirectionalIterator>\n-inline iterator_traits<BidirectionalIterator>::difference_type\n-__distance(BidirectionalIterator first, BidirectionalIterator last,\n-           bidirectional_iterator_tag) {\n-  return __distance(first, last, input_iterator_tag());\n-}\n-\n template <class RandomAccessIterator>\n inline iterator_traits<RandomAccessIterator>::difference_type\n __distance(RandomAccessIterator first, RandomAccessIterator last,\n@@ -156,11 +130,6 @@ inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {\n     while (n--) ++i;\n }\n \n-template <class ForwardIterator, class Distance>\n-inline void __advance(ForwardIterator& i, Distance n, forward_iterator_tag) {\n-    while (n--) ++i;\n-}\n-\n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1183\n #endif\n@@ -198,20 +167,6 @@ inline OutputIterator __copy(InputIterator first, InputIterator last,\n   return result;\n }\n \n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator __copy(InputIterator first, InputIterator last,\n-                             OutputIterator result, forward_iterator_tag)\n-{\n-  return __copy(first, last, result, input_iterator_tag());\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator __copy(InputIterator first, InputIterator last,\n-                             OutputIterator result, bidirectional_iterator_tag)\n-{\n-  return __copy(first, last, result, input_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class OutputIterator, class Distance>\n inline OutputIterator\n __copy_d(RandomAccessIterator first, RandomAccessIterator last,\n@@ -365,20 +320,6 @@ OutputIterator __copy_n(InputIterator first, Size count,\n   return result;\n }\n \n-template <class ForwardIterator, class Size, class OutputIterator>\n-inline OutputIterator __copy_n(ForwardIterator first, Size count,\n-                               OutputIterator result,\n-                               forward_iterator_tag) {\n-  return __copy_n(first, count, result, input_iterator_tag());\n-}\n-\n-template <class BidirectionalIterator, class Size, class OutputIterator>\n-inline OutputIterator __copy_n(BidirectionalIterator first, Size count,\n-                               OutputIterator result,\n-                               bidirectional_iterator_tag) {\n-  return __copy_n(first, count, result, input_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class Size, class OutputIterator>\n inline OutputIterator __copy_n(RandomAccessIterator first, Size count,\n                                OutputIterator result,\n@@ -657,22 +598,6 @@ ForwardIterator __uninitialized_copy_n(InputIterator first, Size count,\n #     endif /* __STL_USE_EXCEPTIONS */\n }\n \n-template <class ForwardIterator1, class Size, class ForwardIterator>\n-inline ForwardIterator\n-__uninitialized_copy_n(ForwardIterator1 first, Size count,\n-                       ForwardIterator result,\n-                       forward_iterator_tag) {\n-  return __uninitialized_copy_n(first, count, result, input_iterator_tag());\n-}\n-\n-template <class BidirectionalIterator, class Size, class ForwardIterator>\n-inline ForwardIterator\n-__uninitialized_copy_n(BidirectionalIterator first, Size count,\n-                       ForwardIterator result,\n-                       bidirectional_iterator_tag) {\n-  return __uninitialized_copy_n(first, count, result, input_iterator_tag());\n-}\n-\n template <class RandomAccessIterator, class Size, class ForwardIterator>\n inline ForwardIterator\n __uninitialized_copy_n(RandomAccessIterator first, Size count,"}, {"sha": "8831976c6149e009b0224b0bf4b12e8ea1f47077", "filename": "libstdc++/stl/alloc.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falloc.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -49,7 +49,6 @@\n #endif\n #ifdef __STL_WIN32THREADS\n #   include <windows.h>\n-//  This must precede stl_config.h\n #endif\n \n #include <stddef.h>\n@@ -91,7 +90,11 @@\n     // This should work without threads, with sproc threads, or with\n     // pthreads.  It is suboptimal in all cases.\n     // It is unlikely to even compile on nonSGI machines.\n-#   include <malloc.h>\n+\n+    extern int __us_rsthread_malloc;\n+\t// The above is copied from malloc.h.  Including <malloc.h>\n+\t// would be cleaner but fails with certain levels of standard\n+\t// conformance.\n #   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \\\n                 { __lock(&__node_allocator_lock); }\n #   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \\\n@@ -383,15 +386,17 @@ class __default_alloc_template {\n     obj * __VOLATILE * my_free_list;\n     obj * __RESTRICT result;\n \n-    if (n > __MAX_BYTES) {\n+    if (n > (size_t) __MAX_BYTES) {\n         return(malloc_alloc::allocate(n));\n     }\n     my_free_list = free_list + FREELIST_INDEX(n);\n     // Acquire the lock here with a constructor call.\n     // This ensures that it is released in exit or during stack\n     // unwinding.\n+#       ifndef _NOTHREADS\n         /*REFERENCED*/\n         lock lock_instance;\n+#       endif\n     result = *my_free_list;\n     if (result == 0) {\n         void *r = refill(ROUND_UP(n));\n@@ -407,14 +412,16 @@ class __default_alloc_template {\n     obj *q = (obj *)p;\n     obj * __VOLATILE * my_free_list;\n \n-    if (n > __MAX_BYTES) {\n+    if (n > (size_t) __MAX_BYTES) {\n         malloc_alloc::deallocate(p, n);\n         return;\n     }\n     my_free_list = free_list + FREELIST_INDEX(n);\n     // acquire lock\n+#       ifndef _NOTHREADS\n         /*REFERENCED*/\n         lock lock_instance;\n+#       endif /* _NOTHREADS */\n     q -> free_list_link = *my_free_list;\n     *my_free_list = q;\n     // lock is released here\n@@ -480,6 +487,7 @@ __default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)\n                     // right free list.\n                 }\n             }\n+\t    end_free = 0;\t// In case of exception.\n             start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n             // This should either throw an\n             // exception or remedy the situation.  Thus we assume it\n@@ -533,7 +541,7 @@ __default_alloc_template<threads, inst>::reallocate(void *p,\n     void * result;\n     size_t copy_sz;\n \n-    if (old_sz > __MAX_BYTES && new_sz > __MAX_BYTES) {\n+    if (old_sz > (size_t) __MAX_BYTES && new_sz > (size_t) __MAX_BYTES) {\n         return(realloc(p, new_sz));\n     }\n     if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n@@ -671,4 +679,6 @@ __default_alloc_template<threads, inst> ::free_list[\n #pragma reset woff 1174\n #endif\n \n-#endif /* __NODE_ALLOC_H */\n+#undef __PRIVATE\n+\n+#endif /* __ALLOC_H */"}, {"sha": "71b49173c400d1fe80010790a54dfbd843f3b8ad", "filename": "libstdc++/stl/bvector.h", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fbvector.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -82,7 +82,8 @@ class bit_vector {\n       friend class bit_vector;\n       friend class const_iterator;\n     public:\n-      typedef bit_reference reference;      \n+      typedef bit_reference  reference;\n+      typedef bit_reference* pointer;\n     protected:\n \tunsigned int* p;\n \tunsigned int offset;\n@@ -163,6 +164,7 @@ class bit_vector {\n       friend class bit_vector;\n     public:\n       typedef bit_const_reference reference;\n+      typedef const bool*         pointer;\n     protected:\n \tunsigned int* p;\n \tunsigned int offset;\n@@ -243,10 +245,15 @@ class bit_vector {\n \t}\n     };\n \n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+    typedef reverse_iterator<iterator> reverse_iterator;\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n     typedef reverse_iterator<const_iterator, value_type, const_reference, \n                              difference_type> const_reverse_iterator;\n     typedef reverse_iterator<iterator, value_type, reference, difference_type>\n         reverse_iterator;\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:\n     typedef simple_alloc<unsigned int, alloc> data_allocator;\n@@ -303,20 +310,6 @@ class bit_vector {\n       copy(first, last, start);\n     }\n \n-    template <class BidirectionalIterator>\n-    void initialize_range(BidirectionalIterator first,\n-                          BidirectionalIterator last,\n-                          bidirectional_iterator_tag) {\n-      initialize_range(first, last, forward_iterator_tag());\n-    }\n-                          \n-    template <class RandomAccessIterator>\n-    void initialize_range(RandomAccessIterator first,\n-                          RandomAccessIterator last,\n-                          random_access_iterator_tag) {\n-      initialize_range(first, last, forward_iterator_tag());\n-    }\n-\n     template <class InputIterator>\n     void insert_range(iterator pos,\n                       InputIterator first, InputIterator last,\n@@ -352,20 +345,6 @@ class bit_vector {\n       }\n     }      \n \n-    template <class BidirectionalIterator>\n-    void insert_range(iterator pos,\n-                      BidirectionalIterator first, BidirectionalIterator last,\n-                      bidirectional_iterator_tag) {\n-      insert_range(pos, first, last, forward_iterator_tag());\n-    }\n-\n-    template <class RandomAccessIterator>\n-    void insert_range(iterator pos,\n-                      RandomAccessIterator first, RandomAccessIterator last,\n-                      random_access_iterator_tag) {\n-      insert_range(pos, first, last, forward_iterator_tag());\n-    }\n-\n #endif /* __STL_MEMBER_TEMPLATES */\n \n     typedef bit_vector self;"}, {"sha": "e202a1173985e30c6da38c0429319b3f32de5127", "filename": "libstdc++/stl/deque.h", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fdeque.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -87,42 +87,44 @@ inline size_t __deque_buf_size(size_t n, size_t sz)\n }\n \n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-template <class T, class Ref, size_t BufSiz>\n+template <class T, class Ref, class Ptr, size_t BufSiz>\n struct __deque_iterator {\n-  typedef __deque_iterator<T, T&, BufSiz> iterator;\n-  typedef __deque_iterator<T, const T&, BufSiz> const_iterator;\n+  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;\n+  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;\n   static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }\n #else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n struct __deque_iterator {\n-  typedef __deque_iterator<T, T&> iterator;\n-  typedef __deque_iterator<T, const T&> const_iterator;\n+  typedef __deque_iterator<T, T&, T*>             iterator;\n+  typedef __deque_iterator<T, const T&, const T*> const_iterator;\n   static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }\n #endif\n \n   typedef random_access_iterator_tag iterator_category;\n   typedef T value_type;\n-  typedef value_type* pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n+  typedef Ptr pointer;\n+  typedef Ref reference;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n-  typedef pointer* map_pointer;\n+  typedef T** map_pointer;\n \n   typedef __deque_iterator self;\n \n-  pointer cur;\n-  pointer first;\n-  pointer last;\n+  T* cur;\n+  T* first;\n+  T* last;\n   map_pointer node;\n \n-  __deque_iterator(pointer x, map_pointer y) \n+  __deque_iterator(T* x, map_pointer y) \n     : cur(x), first(*y), last(*y + buffer_size()), node(y) {}\n   __deque_iterator() : cur(0), first(0), last(0), node(0) {}\n   __deque_iterator(const iterator& x)\n     : cur(x.cur), first(x.first), last(x.last), node(x.node) {}\n \n-  Ref operator*() const { return *cur; }\n+  reference operator*() const { return *cur; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   difference_type operator-(const self& x) const {\n     return buffer_size() * (node - x.node - 1) +\n@@ -183,7 +185,7 @@ struct __deque_iterator {\n     return tmp -= n;\n   }\n \n-  Ref operator[](difference_type n) const { return *(*this + n); }\n+  reference operator[](difference_type n) const { return *(*this + n); }\n \n   bool operator==(const self& x) const { return cur == x.cur; }\n   bool operator!=(const self& x) const { return !(*this == x); }\n@@ -198,40 +200,45 @@ struct __deque_iterator {\n   }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n \n-template <class T, class Ref, size_t BufSiz>\n+template <class T, class Ref, class Ptr, size_t BufSiz>\n inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref, BufSiz>&) {\n+iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n   return random_access_iterator_tag();\n }\n \n-template <class T, class Ref, size_t BufSiz>\n-inline T* value_type(const __deque_iterator<T, Ref, BufSiz>&) { return 0; }\n+template <class T, class Ref, class Ptr, size_t BufSiz>\n+inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n+  return 0;\n+}\n \n-template <class T, class Ref, size_t BufSiz>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, BufSiz>&) {\n+template <class T, class Ref, class Ptr, size_t BufSiz>\n+inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n   return 0;\n }\n \n #else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref>&) {\n+iterator_category(const __deque_iterator<T, Ref, Ptr>&) {\n   return random_access_iterator_tag();\n }\n \n-template <class T, class Ref>\n-inline T* value_type(const __deque_iterator<T, Ref>&) { return 0; }\n+template <class T, class Ref, class Ptr>\n+inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }\n \n-template <class T, class Ref>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref>&) {\n+template <class T, class Ref, class Ptr>\n+inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {\n   return 0;\n }\n \n #endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // See __deque_buf_size().  The only reason that the default value is 0\n //  is as a workaround for bugs in the way that some compilers handle\n@@ -248,17 +255,23 @@ class deque {\n \n public:                         // Iterators\n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-  typedef __deque_iterator<value_type, reference, BufSiz> iterator;\n-  typedef __deque_iterator<value_type, const_reference, BufSiz> const_iterator;\n+  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;\n+  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;\n #else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-  typedef __deque_iterator<value_type, reference> iterator;\n-  typedef __deque_iterator<value_type, const_reference> const_iterator;\n+  typedef __deque_iterator<T, T&, T*>                      iterator;\n+  typedef __deque_iterator<T, const T&, const T*>          const_iterator;\n #endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+  typedef reverse_iterator<iterator> reverse_iterator;\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n   typedef reverse_iterator<const_iterator, value_type, const_reference, \n                            difference_type>  \n           const_reverse_iterator;\n   typedef reverse_iterator<iterator, value_type, reference, difference_type>\n           reverse_iterator; \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:                      // Internal typedefs\n   typedef pointer* map_pointer;\n@@ -553,19 +566,6 @@ class deque {\n   void range_initialize(ForwardIterator first, ForwardIterator last,\n                         forward_iterator_tag);\n \n-  template <class BidirectionalIterator>\n-  void range_initialize(BidirectionalIterator first,\n-                        BidirectionalIterator last,\n-                        bidirectional_iterator_tag) {\n-    range_initialize(first, last, forward_iterator_tag());\n-  }\n-\n-  template <class RandomAccessIterator>\n-  void range_initialize(RandomAccessIterator first, RandomAccessIterator last,\n-                        random_access_iterator_tag) {\n-    range_initialize(first, last, forward_iterator_tag());\n-  }\n-\n #endif /* __STL_MEMBER_TEMPLATES */\n \n protected:                        // Internal push_* and pop_*\n@@ -587,19 +587,6 @@ class deque {\n   void insert(iterator pos, ForwardIterator first, ForwardIterator last,\n               forward_iterator_tag);\n \n-  template <class BidirectionalIterator>\n-  void insert(iterator pos,\n-              BidirectionalIterator first, BidirectionalIterator last,\n-              bidirectional_iterator_tag) {\n-    insert(pos, first, last, forward_iterator_tag());\n-  }\n-\n-  template <class RandomAccessIterator>\n-  void insert(iterator pos,\n-              RandomAccessIterator first, RandomAccessIterator last,\n-              random_access_iterator_tag) {\n-    insert(pos, first, last, forward_iterator_tag());\n-  }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n   iterator insert_aux(iterator pos, const value_type& x);\n@@ -881,7 +868,7 @@ void deque<T, Alloc, BufSize>::fill_initialize(size_type n,\n   }\n   catch(...) {\n     for (map_pointer n = start.node; n < cur; ++n)\n-      destroy(*cur, *cur + buffer_size());\n+      destroy(*n, *n + buffer_size());\n     destroy_map_and_nodes();\n     throw;\n   }"}, {"sha": "fb4abc2b3440f66d1731f4ffcc941b452a54df18", "filename": "libstdc++/stl/hashtable.h", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhashtable.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -123,7 +123,6 @@ struct __hashtable_iterator {\n   typedef ptrdiff_t difference_type;\n   typedef size_t size_type;\n   typedef Value& reference;\n-  typedef const Value& const_reference;\n   typedef Value* pointer;\n \n   node* cur;\n@@ -132,6 +131,9 @@ struct __hashtable_iterator {\n   __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}\n   __hashtable_iterator() {}\n   reference operator*() const { return cur->val; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   iterator& operator++();\n   iterator operator++(int);\n   bool operator==(const iterator& it) const { return cur == it.cur; }\n@@ -156,9 +158,8 @@ struct __hashtable_const_iterator {\n   typedef Value value_type;\n   typedef ptrdiff_t difference_type;\n   typedef size_t size_type;\n-  typedef Value& reference;\n-  typedef const Value& const_reference;\n-  typedef Value* pointer;\n+  typedef const Value& reference;\n+  typedef const Value* pointer;\n \n   const node* cur;\n   const hashtable* ht;\n@@ -167,7 +168,10 @@ struct __hashtable_const_iterator {\n     : cur(n), ht(tab) {}\n   __hashtable_const_iterator() {}\n   __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}\n-  const_reference operator*() const { return cur->val; }\n+  reference operator*() const { return cur->val; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   const_iterator& operator++();\n   const_iterator operator++(int);\n   bool operator==(const const_iterator& it) const { return cur == it.cur; }\n@@ -399,34 +403,6 @@ class hashtable {\n       insert_equal_noresize(*f);\n   }\n \n-  template <class BidirectionalIterator>\n-  void insert_unique(BidirectionalIterator f, BidirectionalIterator l,\n-                     bidirectional_iterator_tag)\n-  {\n-    insert_unique(f, l, forward_iterator_tag());\n-  }\n-\n-  template <class BidirectionalIterator>\n-  void insert_equal(BidirectionalIterator f, BidirectionalIterator l,\n-                    bidirectional_iterator_tag)\n-  {\n-    insert_equal(f, l, forward_iterator_tag());\n-  }\n-\n-  template <class RandomAccessIterator>\n-  void insert_unique(RandomAccessIterator f, RandomAccessIterator l,\n-                     random_access_iterator_tag)\n-  {\n-    insert_unique(f, l, forward_iterator_tag());\n-  }\n-\n-  template <class RandomAccessIterator>\n-  void insert_equal(RandomAccessIterator f, RandomAccessIterator l,\n-                    random_access_iterator_tag)\n-  {\n-    insert_equal(f, l, forward_iterator_tag());\n-  }\n-\n #else /* __STL_MEMBER_TEMPLATES */\n   void insert_unique(const value_type* f, const value_type* l)\n   {\n@@ -619,6 +595,7 @@ __hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n   return tmp;\n }\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n template <class V, class K, class HF, class ExK, class EqK, class All>\n inline forward_iterator_tag\n@@ -661,6 +638,8 @@ distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n   return (hashtable<V, K, HF, ExK, EqK, All>::difference_type*) 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class V, class K, class HF, class Ex, class Eq, class A>\n bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,\n                 const hashtable<V, K, HF, Ex, Eq, A>& ht2)"}, {"sha": "f8a19d0aa345b1fb9b42ea1a920afb27d318759b", "filename": "libstdc++/stl/iterator.h", "status": "modified", "additions": 200, "deletions": 7, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fiterator.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -33,9 +33,9 @@\n \n struct input_iterator_tag {};\n struct output_iterator_tag {};\n-struct forward_iterator_tag {};\n-struct bidirectional_iterator_tag {};\n-struct random_access_iterator_tag {};\n+struct forward_iterator_tag : public input_iterator_tag {};\n+struct bidirectional_iterator_tag : public forward_iterator_tag {};\n+struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n \n template <class T, class Distance> struct input_iterator {\n   typedef input_iterator_tag iterator_category;\n@@ -47,6 +47,10 @@ template <class T, class Distance> struct input_iterator {\n \n struct output_iterator {\n   typedef output_iterator_tag iterator_category;\n+  typedef void                value_type;\n+  typedef void                difference_type;\n+  typedef void                pointer;\n+  typedef void                reference;\n };\n \n template <class T, class Distance> struct forward_iterator {\n@@ -106,7 +110,34 @@ struct iterator_traits<T*> {\n   typedef T&                         reference;\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+template <class T>\n+struct iterator_traits<const T*> {\n+  typedef random_access_iterator_tag iterator_category;\n+  typedef T                          value_type;\n+  typedef ptrdiff_t                  difference_type;\n+  typedef const T*                   pointer;\n+  typedef const T&                   reference;\n+};\n+\n+template <class Iterator>\n+inline iterator_traits<Iterator>::iterator_category\n+iterator_category(const Iterator&) {\n+  return iterator_traits<Iterator>::iterator_category();\n+}\n+\n+template <class Iterator>\n+inline iterator_traits<Iterator>::difference_type*\n+distance_type(const Iterator&) {\n+  return static_cast<iterator_traits<Iterator>::difference_type*>(0);\n+}\n+\n+template <class Iterator>\n+inline iterator_traits<Iterator>::value_type*\n+value_type(const Iterator&) {\n+  return static_cast<iterator_traits<Iterator>::value_type*>(0);\n+}\n+\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n template <class T, class Distance> \n inline input_iterator_tag \n@@ -189,12 +220,18 @@ distance_type(const random_access_iterator<T, Distance>&) {\n template <class T>\n inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class Container>\n class back_insert_iterator {\n protected:\n     Container* container;\n public:\n     typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n \n     explicit back_insert_iterator(Container& x) : container(&x) {}\n     back_insert_iterator<Container>&\n@@ -207,13 +244,17 @@ class back_insert_iterator {\n     back_insert_iterator<Container>& operator++(int) { return *this; }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class Container>\n inline output_iterator_tag\n iterator_category(const back_insert_iterator<Container>&)\n {\n   return output_iterator_tag();\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class Container>\n inline back_insert_iterator<Container> back_inserter(Container& x) {\n   return back_insert_iterator<Container>(x);\n@@ -225,6 +266,10 @@ class front_insert_iterator {\n     Container* container;\n public:\n     typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n \n     explicit front_insert_iterator(Container& x) : container(&x) {}\n     front_insert_iterator<Container>&\n@@ -237,13 +282,17 @@ class front_insert_iterator {\n     front_insert_iterator<Container>& operator++(int) { return *this; }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class Container>\n inline output_iterator_tag\n iterator_category(const front_insert_iterator<Container>&)\n {\n   return output_iterator_tag();\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class Container>\n inline front_insert_iterator<Container> front_inserter(Container& x) {\n   return front_insert_iterator<Container>(x);\n@@ -256,6 +305,10 @@ class insert_iterator {\n     typename Container::iterator iter;\n public:\n     typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n \n     insert_iterator(Container& x, typename Container::iterator i) \n         : container(&x), iter(i) {}\n@@ -270,13 +323,17 @@ class insert_iterator {\n     insert_iterator<Container>& operator++(int) { return *this; }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class Container>\n inline output_iterator_tag\n iterator_category(const insert_iterator<Container>&)\n {\n   return output_iterator_tag();\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class Container, class Iterator>\n inline insert_iterator<Container> inserter(Container& x, Iterator i) {\n   typedef typename Container::iterator iter;\n@@ -311,6 +368,9 @@ class reverse_bidirectional_iterator {\n         BidirectionalIterator tmp = current;\n         return *--tmp;\n     }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+    pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n     self& operator++() {\n         --current;\n         return *this;\n@@ -331,6 +391,7 @@ class reverse_bidirectional_iterator {\n     }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n template <class BidirectionalIterator, class T, class Reference, \n           class Distance>\n@@ -357,6 +418,8 @@ distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,\n   return (Distance*) 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class BidirectionalIterator, class T, class Reference,\n           class Distance>\n inline bool operator==(\n@@ -367,6 +430,109 @@ inline bool operator==(\n     return x.current == y.current;\n }\n \n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+// This is the new version of reverse_iterator, as defined in the\n+//  draft C++ standard.  It relies on the iterator_traits template,\n+//  which in turn relies on partial specialization.  The class\n+//  reverse_bidirectional_iterator is no longer part of the draft\n+//  standard, but it is retained for backward compatibility.\n+\n+template <class Iterator>\n+class reverse_iterator : public iterator_traits<Iterator>\n+{\n+protected:\n+  Iterator current;\n+public:\n+  typedef Iterator iterator_type;\n+  typedef reverse_iterator<Iterator> self;\n+\n+public:\n+  reverse_iterator() {}\n+  explicit reverse_iterator(iterator_type x) : current(x) {}\n+\n+  reverse_iterator(const self& x) : current(x.current) {}\n+#ifdef __STL_MEMBER_TEMPLATES\n+  template <class Iter>\n+  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}\n+#endif /* __STL_MEMBER_TEMPLATES */\n+    \n+  iterator_type base() const { return current; }\n+  reference operator*() const {\n+    Iterator tmp = current;\n+    return *--tmp;\n+  }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n+\n+  self& operator++() {\n+    --current;\n+    return *this;\n+  }\n+  self operator++(int) {\n+    self tmp = *this;\n+    --current;\n+    return tmp;\n+  }\n+  self& operator--() {\n+    ++current;\n+    return *this;\n+  }\n+  self operator--(int) {\n+    self tmp = *this;\n+    ++current;\n+    return tmp;\n+  }\n+\n+  self operator+(difference_type n) const {\n+    return self(current - n);\n+  }\n+  self& operator+=(difference_type n) {\n+    current -= n;\n+    return *this;\n+  }\n+  self operator-(difference_type n) const {\n+    return self(current + n);\n+  }\n+  self& operator-=(difference_type n) {\n+    current += n;\n+    return *this;\n+  }\n+  reference operator[](difference_type n) { return *(*this + n); }  \n+}; \n+ \n+template <class Iterator>\n+inline bool operator==(const reverse_iterator<Iterator>& x, \n+                       const reverse_iterator<Iterator>& y) {\n+  return x.base() == y.base();\n+}\n+\n+template <class Iterator>\n+inline bool operator<(const reverse_iterator<Iterator>& x, \n+                      const reverse_iterator<Iterator>& y) {\n+  return y.base() < x.base();\n+}\n+\n+template <class Iterator>\n+inline reverse_iterator<Iterator>::difference_type\n+operator-(const reverse_iterator<Iterator>& x, \n+          const reverse_iterator<Iterator>& y) {\n+  return y.base() - x.base();\n+}\n+\n+template <class Iterator>\n+inline reverse_iterator<Iterator> \n+operator+(reverse_iterator<Iterator>::difference_type n,\n+          const reverse_iterator<Iterator>& x) {\n+  return reverse_iterator<Iterator>(x.base() - n);\n+}\n+\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+// This is the old version of reverse_iterator, as found in the original\n+//  HP STL.  It does not use partial specialization.\n+\n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n template <class RandomAccessIterator, class T, class Reference = T&,\n           class Distance = ptrdiff_t> \n@@ -394,6 +560,9 @@ class reverse_iterator {\n     explicit reverse_iterator(RandomAccessIterator x) : current(x) {}\n     RandomAccessIterator base() { return current; }\n     Reference operator*() const { return *(current - 1); }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+    pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n     self& operator++() {\n         --current;\n         return *this;\n@@ -482,13 +651,18 @@ operator+(Distance n,\n         (x.current - n);\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n template <class ForwardIterator, class T>\n class raw_storage_iterator {\n protected:\n     ForwardIterator iter;\n public:\n     typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n \n     explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}\n     raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }\n@@ -507,13 +681,17 @@ class raw_storage_iterator {\n     }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class ForwardIterator, class T>\n inline output_iterator_tag\n iterator_category(const raw_storage_iterator<ForwardIterator, T>&)\n {\n   return output_iterator_tag();\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class T, class Distance = ptrdiff_t> \n class istream_iterator {\n friend bool operator==(const istream_iterator<T, Distance>& x,\n@@ -531,12 +709,15 @@ friend bool operator==(const istream_iterator<T, Distance>& x,\n     typedef input_iterator_tag iterator_category;\n     typedef T                  value_type;\n     typedef Distance           difference_type;\n-    typedef T*                 pointer;\n-    typedef T&                 reference;\n+    typedef const T*           pointer;\n+    typedef const T&           reference;\n \n     istream_iterator() : stream(&cin), end_marker(false) {}\n     istream_iterator(istream& s) : stream(&s) { read(); }\n-    const T& operator*() const { return value; }\n+    reference operator*() const { return value; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+    pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n     istream_iterator<T, Distance>& operator++() { \n         read(); \n         return *this;\n@@ -548,6 +729,8 @@ friend bool operator==(const istream_iterator<T, Distance>& x,\n     }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class T, class Distance>\n inline input_iterator_tag \n iterator_category(const istream_iterator<T, Distance>&) {\n@@ -562,6 +745,8 @@ inline Distance* distance_type(const istream_iterator<T, Distance>&) {\n   return (Distance*) 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n template <class T, class Distance>\n bool operator==(const istream_iterator<T, Distance>& x,\n                 const istream_iterator<T, Distance>& y) {\n@@ -576,6 +761,10 @@ class ostream_iterator {\n     const char* string;\n public:\n     typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n \n     ostream_iterator(ostream& s) : stream(&s), string(0) {}\n     ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}\n@@ -589,10 +778,14 @@ class ostream_iterator {\n     ostream_iterator<T>& operator++(int) { return *this; } \n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n template <class T>\n inline output_iterator_tag \n iterator_category(const ostream_iterator<T>&) {\n   return output_iterator_tag();\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n #endif /* __SGI_STL_ITERATOR_H */"}, {"sha": "6d9492865e8fb588367a40a8fdae88dea9d451e7", "filename": "libstdc++/stl/list.h", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flist.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -40,17 +40,16 @@ struct __list_node {\n   T data;\n };\n \n-template<class T, class Ref>\n+template<class T, class Ref, class Ptr>\n struct __list_iterator {\n-  typedef __list_iterator<T, T&> iterator;\n-  typedef __list_iterator<T, const T&> const_iterator;\n-  typedef __list_iterator<T, Ref> self;\n+  typedef __list_iterator<T, T&, T*>             iterator;\n+  typedef __list_iterator<T, const T&, const T*> const_iterator;\n+  typedef __list_iterator<T, Ref, Ptr>           self;\n \n   typedef bidirectional_iterator_tag iterator_category;\n   typedef T value_type;\n-  typedef value_type* pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n+  typedef Ptr pointer;\n+  typedef Ref reference;\n   typedef __list_node<T>* link_type;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n@@ -63,7 +62,11 @@ struct __list_iterator {\n \n   bool operator==(const self& x) const { return node == x.node; }\n   bool operator!=(const self& x) const { return node != x.node; }\n-  Ref operator*() const { return (*node).data; }\n+  reference operator*() const { return (*node).data; }\n+\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   self& operator++() { \n     node = (link_type)((*node).next);\n@@ -85,25 +88,27 @@ struct __list_iterator {\n   }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n inline bidirectional_iterator_tag\n-iterator_category(const __list_iterator<T, Ref>&) {\n+iterator_category(const __list_iterator<T, Ref, Ptr>&) {\n   return bidirectional_iterator_tag();\n }\n \n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n inline T*\n-value_type(const __list_iterator<T, Ref>&) {\n+value_type(const __list_iterator<T, Ref, Ptr>&) {\n   return 0;\n }\n \n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n inline ptrdiff_t*\n-distance_type(const __list_iterator<T, Ref>&) {\n+distance_type(const __list_iterator<T, Ref, Ptr>&) {\n   return 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n template <class T, class Alloc = alloc>\n class list {\n@@ -121,15 +126,20 @@ class list {\n     typedef ptrdiff_t difference_type;\n \n public:\n-    typedef __list_iterator<T, T&> iterator;\n-    typedef __list_iterator<T, const T&> const_iterator;\n+    typedef __list_iterator<T, T&, T*>             iterator;\n+    typedef __list_iterator<T, const T&, const T*> const_iterator;\n \n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+    typedef reverse_iterator<iterator> reverse_iterator;\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n     typedef reverse_bidirectional_iterator<const_iterator, value_type,\n                                            const_reference, difference_type>\n             const_reverse_iterator;\n     typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n                                            difference_type>\n             reverse_iterator; \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:\n     link_type get_node() { return list_node_allocator::allocate(); }"}, {"sha": "399352f477eefd9ebc9acf138a84f476a58163d9", "filename": "libstdc++/stl/rope.h", "status": "modified", "additions": 63, "deletions": 42, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Frope.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -38,18 +38,18 @@ inline charT __eos(charT*) { return charT(); }\n // Test for basic character types.\n // For basic character types leaves having a trailing eos.\n template <class charT>\n-inline bool __is_basic_char_type(charT* c) { return false; }\n+inline bool __is_basic_char_type(charT *) { return false; }\n template <class charT>\n-inline bool __is_one_byte_char_type(charT* c) { return false; }\n+inline bool __is_one_byte_char_type(charT *) { return false; }\n \n-inline bool __is_basic_char_type(char* c) { return true; }\n-inline bool __is_one_byte_char_type(char* c) { return true; }\n-inline bool __is_basic_char_type(wchar_t* c) { return true; }\n+inline bool __is_basic_char_type(char *) { return true; }\n+inline bool __is_one_byte_char_type(char *) { return true; }\n+inline bool __is_basic_char_type(wchar_t *) { return true; }\n \n // Store an eos iff charT is a basic character type.\n // Do not reference __eos if it isn't.\n template <class charT>\n-inline void __cond_store_eos(charT& c) {}\n+inline void __cond_store_eos(charT&) {}\n \n inline void __cond_store_eos(char& c) { c = 0; }\n inline void __cond_store_eos(wchar_t& c) { c = 0; }\n@@ -235,6 +235,7 @@ template<class CharT, class Alloc> class __rope_charT_ptr_proxy;\n template<class charT, class Alloc>\n struct __rope_RopeBase {\n     typedef rope<charT,Alloc> my_rope;\n+    typedef simple_alloc<charT, Alloc> DataAlloc;\n     typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;\n     typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;\n     typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;\n@@ -368,12 +369,17 @@ struct __rope_RopeBase {\n \t  {\n \t      if (0 != t) t -> incr_refcount();\n \t  }\n+\t  static void free_if_unref(__rope_RopeBase* t)\n+ \t  {\n+\t      if (0 != t && 0 == t -> refcount) t -> free_tree();\n+\t  }\n #   else /* __GC */\n \t  void unref_nonnil() {}\n \t  void ref_nonnil() {}\n \t  static void unref(__rope_RopeBase* t) {}\n \t  static void ref(__rope_RopeBase* t) {}\n \t  static void fn_finalization_proc(void * tree, void *);\n+\t  static void free_if_unref(__rope_RopeBase* t) {}\n #   endif\n \n     // The data fields of leaves are allocated with some\n@@ -384,9 +390,9 @@ struct __rope_RopeBase {\n         size_t size_with_eos;\n \t     \n         if (__is_basic_char_type((charT *)0)) {\n-    \t    size_with_eos = (n + 1) * sizeof(charT);\n+    \t    size_with_eos = n + 1;\n     \t} else {\n-  \t    size_with_eos = n * sizeof(charT);\n+  \t    size_with_eos = n;\n \t}\n #       ifdef __GC\n    \t   return size_with_eos;\n@@ -684,6 +690,11 @@ class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {\n \t\t     const_cast<RopeBase *>(root), pos)\n \t\t   // Only nonconst iterators modify root ref count\n     {}\n+  public:\n+    typedef charT reference;    // Really a value.  Returning a reference\n+\t\t\t\t// Would be a mess, since it would have\n+\t\t\t\t// to be included in refcount.\n+    typedef const charT* pointer;\n \n   public:\n     __rope_const_iterator() {};\n@@ -702,7 +713,7 @@ class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {\n \t}\n \treturn(*this);\n     }\n-    const charT& operator*() {\n+    reference operator*() {\n \tif (0 == buf_ptr) setcache(*this);\n \treturn *buf_ptr;\n     }\n@@ -758,7 +769,7 @@ class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {\n     friend __rope_const_iterator<charT,Alloc> operator+\n \t(ptrdiff_t n,\n \t const __rope_const_iterator<charT,Alloc> & x);\n-    charT operator[](size_t n) {\n+    reference operator[](size_t n) {\n \treturn rope<charT,Alloc>::fetch(root, current_pos + n);\n     }\n     friend bool operator==\n@@ -790,6 +801,10 @@ class __rope_iterator : public __rope_iterator_base<charT,Alloc> {\n \t\tRopeBase::ref(root);\n \t     }\n     void check();\n+  public:\n+    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;\n+    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;\n+\n   public:\n     rope<charT,Alloc>& container() { return *root_rope; }\n     __rope_iterator() {\n@@ -819,7 +834,7 @@ class __rope_iterator : public __rope_iterator_base<charT,Alloc> {\n \tRopeBase::unref(old);\n \treturn(*this);\n     }\n-    __rope_charT_ref_proxy<charT,Alloc> operator*() {\n+    reference operator*() {\n \tcheck();\n \tif (0 == buf_ptr) {\n \t    return __rope_charT_ref_proxy<charT,Alloc>(root_rope, current_pos);\n@@ -862,7 +877,7 @@ class __rope_iterator : public __rope_iterator_base<charT,Alloc> {\n \tdecr(1);\n \treturn __rope_iterator<charT,Alloc>(root_rope, old_pos);\n     }\n-    __rope_charT_ref_proxy<charT,Alloc> operator[](ptrdiff_t n) {\n+    reference operator[](ptrdiff_t n) {\n \treturn __rope_charT_ref_proxy<charT,Alloc>(root_rope, current_pos + n);\n     }\n     friend bool operator==\n@@ -892,7 +907,7 @@ class rope {\n \ttypedef charT value_type;\n \ttypedef ptrdiff_t difference_type;\n \ttypedef size_t size_type;\n-\ttypedef const charT& const_reference;\n+\ttypedef charT const_reference;\n \ttypedef const charT* const_pointer;\n \ttypedef __rope_iterator<charT,Alloc> iterator;\n \ttypedef __rope_const_iterator<charT,Alloc> const_iterator;\n@@ -945,6 +960,7 @@ class rope {\n \n \tstatic charT empty_c_str[1];\n \n+    \ttypedef simple_alloc<charT, Alloc> DataAlloc;\n     \ttypedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;\n     \ttypedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;\n     \ttypedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;\n@@ -1054,8 +1070,7 @@ class rope {\n \t// Adds a trailing NULL for basic char types.\n \tstatic charT * alloc_copy(const charT *s, size_t size)\n \t{\n-\t    charT * result = (charT *)\n-\t\t\t\tAlloc::allocate(rounded_up_size(size));\n+\t    charT * result = DataAlloc::allocate(rounded_up_size(size));\n \n \t    uninitialized_copy_n(s, size, result);\n \t    __cond_store_eos(result[size]);\n@@ -1073,6 +1088,15 @@ class rope {\n \t\t// In the nonGC case, it was allocated from Alloc with\n \t\t// rounded_up_size(size).\n \n+\tstatic RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,\n+\t\t\t\t\t\t         size_t size) {\n+\t    charT * buf = alloc_copy(s, size);\n+            __STL_TRY\n+              return RopeLeaf_from_char_ptr(buf, size);\n+            __STL_UNWIND(RopeBase::free_string(buf, size))\n+\t}\n+\t    \n+\n \t// Concatenation of nonempty strings.\n \t// Always builds a concatenation node.\n \t// Rebalances if the result is too deep.\n@@ -1107,24 +1131,14 @@ class rope {\n \tfriend struct rope<charT,Alloc>::concat_fn;\n \n \tstruct concat_fn\n-\t\t: binary_function<RopeBase *, RopeBase *, RopeBase *> {\n-\t\tRopeBase * operator() (RopeBase * x, RopeBase *y) {\n-\t\t    RopeBase * result;\n-\t\t    x -> ref_nonnil();\n-\t\t    y -> ref_nonnil();\n-\t\t    __STL_TRY\n-\t\t      result = tree_concat(x, y);\n-#\t\t      ifndef __GC\n-\t\t\tresult -> refcount = 0;\n-#\t\t      endif\n-\t\t    __STL_UNWIND(unref(x); unref(y));\n-\t\t    return result;\n-\t\t    // In the nonGC case, x and y must remain accessible through\n-\t\t    // the result.  Use of concat could result on a memory leak.\n+\t\t: binary_function<rope<charT,Alloc>, rope<charT,Alloc>,\n+\t\t\t\t  rope<charT,Alloc> > {\n+\t\trope operator() (const rope& x, const rope& y) {\n+\t\t    return x + y;\n \t\t}\n \t};\n \n-        friend RopeBase* identity_element(concat_fn) { return 0; }\n+        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }\n \n \tstatic size_t char_ptr_len(const charT * s);\n \t\t\t// slightly generalized strlen\n@@ -1202,7 +1216,7 @@ class rope {\n \t    if (0 == len) {\n \t\ttree_ptr = 0;\n \t    } else {\n-\t\ttree_ptr = RopeLeaf_from_char_ptr(alloc_copy(s, len), len);\n+\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n #\t\tifndef __GC\n \t\t  __stl_assert(1 == tree_ptr -> refcount);\n #\t\tendif\n@@ -1214,7 +1228,7 @@ class rope {\n \t    if (0 == len) {\n \t\ttree_ptr = 0;\n \t    } else {\n-\t\ttree_ptr = RopeLeaf_from_char_ptr(alloc_copy(s, len), len);\n+\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n \t    }\n \t}\n \n@@ -1225,7 +1239,7 @@ class rope {\n \t    if (0 == len) {\n \t\ttree_ptr = 0;\n \t    } else {\n-\t\ttree_ptr = RopeLeaf_from_char_ptr(alloc_copy(s, len), len);\n+\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n \t    }\n \t}\n \n@@ -1241,10 +1255,12 @@ class rope {\n \n \trope(charT c)\n \t{\n-\t    charT * buf = (charT *)Alloc::allocate(rounded_up_size(1));\n+\t    charT * buf = DataAlloc::allocate(rounded_up_size(1));\n \n \t    construct(buf, c);\n-\t    tree_ptr = RopeLeaf_from_char_ptr(buf, 1);\n+\t    __STL_TRY\n+\t        tree_ptr = RopeLeaf_from_char_ptr(buf, 1);\n+            __STL_UNWIND(RopeBase::free_string(buf, 1))\n \t}\n \n \trope(size_t n, charT c);\n@@ -1258,7 +1274,7 @@ class rope {\n \t\ttree_ptr = 0;\n \t    } else {\n \t\tsize_t len = j - i;\n-\t\ttree_ptr = RopeLeaf_from_char_ptr(alloc_copy(i, len), len);\n+\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(i, len);\n \t    }\n \t}\n \n@@ -1312,15 +1328,12 @@ class rope {\n \t    return fetch(tree_ptr, tree_ptr -> size - 1);\n \t}\n \n-\tvoid push_front(const charT& x)\n+\tvoid push_front(charT x)\n \t{\n \t    RopeBase *old = tree_ptr;\n-\t    charT *buf = alloc_copy(&x, 1);\n \t    RopeBase *left;\n \n-\t    __STL_TRY\n-\t      left = RopeLeaf_from_char_ptr(buf, 1);\n-\t    __STL_UNWIND(RopeBase::free_string(buf, 1))\n+\t    left = RopeLeaf_from_unowned_char_ptr(&x, 1);\n \t    __STL_TRY\n \t      tree_ptr = concat(left, tree_ptr);\n \t      unref(old);\n@@ -1436,9 +1449,13 @@ class rope {\n \t    //  but it's harder to make guarantees.\n \t}\n \n+#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+        typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \ttypedef reverse_iterator<const_iterator, value_type, const_reference,\n \t\t\t\t difference_type>  const_reverse_iterator;\n- \n+#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n+\n \tconst_reverse_iterator rbegin() const {\n \t    return const_reverse_iterator(end());\n \t}\n@@ -1794,8 +1811,12 @@ class rope {\n \t    return(iterator(this, size()));\n \t}\n \n+#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+        typedef reverse_iterator<iterator> reverse_iterator;\n+#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \ttypedef reverse_iterator<iterator, value_type, reference,\n \t\t\t\t difference_type>  reverse_iterator;\n+#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n \n \treverse_iterator mutable_rbegin() {\n \t    return reverse_iterator(mutable_end());"}, {"sha": "d1c1ed4e68931b1da9f43c0d5bfacf7b712889e9", "filename": "libstdc++/stl/ropeimpl.h", "status": "modified", "additions": 74, "deletions": 83, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fropeimpl.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -11,11 +11,8 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#if defined(_MSC_VER)\n-#   include <ostream>\n-#else \n-#   include <iostream.h>\n-#endif\n+# include <stdio.h>\n+# include <iostream.h>\n \n // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n // if necessary.  Assumes path_end[leaf_index] and leaf_pos are correct.\n@@ -330,7 +327,7 @@ inline void __rope_RopeBase<charT,Alloc>::free_c_string()\n     if (0 != cstr) {\n \tsize_t sz = size + 1;\n \tdestroy(cstr, cstr + sz);\n-\tAlloc::deallocate(cstr, sz);\n+\tDataAlloc::deallocate(cstr, sz);\n     }\n }\n \n@@ -340,7 +337,7 @@ inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)\n     if (!__is_basic_char_type((charT *)0)) {\n \tdestroy(s, s + n);\n     }\n-    Alloc::deallocate(s, rounded_up_size(n));\n+    DataAlloc::deallocate(s, rounded_up_size(n));\n }\n \n template <class charT, class Alloc>\n@@ -413,7 +410,7 @@ rope<charT,Alloc>::leaf_concat_char_iter\n {\n     size_t old_len = r -> size;\n     charT * new_data = (charT *)\n-\tAlloc::allocate(rounded_up_size(old_len + len));\n+\tDataAlloc::allocate(rounded_up_size(old_len + len));\n     RopeLeaf * result;\n     \n     uninitialized_copy_n(r -> data, old_len, new_data);\n@@ -459,6 +456,7 @@ rope<charT,Alloc>::destr_leaf_concat_char_iter\n #endif\n \n // Assumes left and right are not 0.\n+// Does not increment (nor decrement on exception) child reference counts.\n // Result has ref count 1.\n template <class charT, class Alloc>\n rope<charT,Alloc>::RopeBase *\n@@ -473,7 +471,7 @@ rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)\n     result -> is_balanced = false;\n     result -> size = rsize = left -> size + right -> size;\n     if (right -> depth > child_depth) child_depth = right -> depth;\n-    unsigned char depth = child_depth + 1;\n+    unsigned char depth = (unsigned char)(child_depth + 1);\n     result -> depth = depth;\n     result -> left = left;\n     result -> right = right;\n@@ -492,7 +490,12 @@ rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)\n \t\t\t     && 1 == balanced -> refcount);\n \t     }\n #          endif\n-\t__STL_ALWAYS(result -> unref_nonnil());\n+\t   result -> unref_nonnil();\n+\t__STL_UNWIND(CAlloc::deallocate(result));\n+\t\t// In case of exception, we need to deallocate\n+\t\t// otherwise dangling result node.  But caller\n+\t\t// still owns its children.  Thus unref is\n+\t\t// inappropriate.\n \treturn balanced;\n     } else {\n \treturn result;\n@@ -508,7 +511,7 @@ rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter\n \tref(r);\n \treturn r;\n     }\n-    if (0 == r) return RopeLeaf_from_char_ptr(alloc_copy(s, slen), slen);\n+    if (0 == r) return RopeLeaf_from_unowned_char_ptr(s, slen);\n     if (RopeBase::leaf == r -> tag && r -> size + slen <= copy_max) {\n \tresult = leaf_concat_char_iter((RopeLeaf *)r, s, slen);\n #       ifndef __GC\n@@ -521,23 +524,22 @@ rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter\n \tRopeLeaf *right = (RopeLeaf *)(((RopeConcatenation *)r) -> right);\n \tif (right -> size + slen <= copy_max) {\n \t  RopeBase * left = ((RopeConcatenation *)r) -> left;\n+\t  RopeBase * nright = leaf_concat_char_iter((RopeLeaf *)right, s, slen);\n \t  left -> ref_nonnil();\n \t  __STL_TRY\n-\t    result = tree_concat(left,\n-\t\t\t\t leaf_concat_char_iter((RopeLeaf *)right,\n-\t\t\t\t\t\t\ts, slen));\n-\t  __STL_UNWIND(unref(left));\n+\t    result = tree_concat(left, nright);\n+\t  __STL_UNWIND(unref(left); unref(nright));\n #         ifndef __GC\n \t    __stl_assert(1 == result -> refcount);\n #         endif\n \t  return result;\n \t}\n     }\n+    RopeBase * nright = RopeLeaf_from_unowned_char_ptr(s, slen);\n     __STL_TRY\n       r -> ref_nonnil();\n-      result = tree_concat(r, RopeLeaf_from_char_ptr(alloc_copy(s, slen),\n-\t\t\t   slen));\n-    __STL_UNWIND(unref(r));\n+      result = tree_concat(r, nright);\n+    __STL_UNWIND(unref(r); unref(nright));\n #   ifndef __GC\n       __stl_assert(1 == result -> refcount);\n #   endif\n@@ -551,7 +553,7 @@ ::destr_concat_char_iter\n \t\t(RopeBase * r, const charT *s, size_t slen)\n {\n     RopeBase *result;\n-    if (0 == r) return RopeLeaf_from_char_ptr(alloc_copy(s, slen), slen);\n+    if (0 == r) return RopeLeaf_from_unowned_char_ptr(s, slen);\n     size_t count = r -> refcount;\n     size_t orig_size = r -> size;\n     __stl_assert(count >= 1);\n@@ -587,11 +589,11 @@ ::destr_concat_char_iter\n \t  return r;\n \t}\n     }\n-    charT * cpy = alloc_copy(s, slen);\n+    RopeBase *right = RopeLeaf_from_unowned_char_ptr(s, slen);\n     r -> ref_nonnil();\n     __STL_TRY\n-      result = tree_concat(r, RopeLeaf_from_char_ptr(cpy, slen));\n-    __STL_UNWIND(unref(r); RopeBase::free_string(cpy,slen))\n+      result = tree_concat(r, right);\n+    __STL_UNWIND(unref(r); unref(right))\n     __stl_assert(1 == result -> refcount);\n     return result;\n }\n@@ -629,13 +631,15 @@ rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)\n \t    leftleft -> ref_nonnil();\n \t    __STL_TRY\n \t      return(tree_concat(leftleft, rest));\n-\t    __STL_UNWIND(unref(left); unref(rest))\n+\t    __STL_UNWIND(unref(leftleft); unref(rest))\n \t  }\n \t}\n     }\n     left -> ref_nonnil();\n     right -> ref_nonnil();\n-    return(tree_concat(left, right));\n+    __STL_TRY\n+      return(tree_concat(left, right));\n+    __STL_UNWIND(unref(left); unref(right));\n }\n \n template <class charT, class Alloc>\n@@ -686,21 +690,18 @@ rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)\n \t    {\n \t\tRopeLeaf * l = (RopeLeaf *)base;\n \t\tRopeLeaf * result;\n-\t\t__GC_CONST charT *section;\n \t\tsize_t result_len;\n \t\tif (start >= adj_endp1) return 0;\n \t\tresult_len = adj_endp1 - start;\n \t\tif (result_len > lazy_threshold) goto lazy;\n #               ifdef __GC\n-\t\t    section = l -> data + start;\n+\t\t    const charT *section = l -> data + start;\n \t\t    result = RopeLeaf_from_char_ptr(section, result_len);\n \t\t    result -> c_string = 0;  // Not eos terminated.\n #               else\n-\t\t    section = alloc_copy(l -> data + start, result_len);\n \t\t    // We should sometimes create substring node instead.\n-\t\t    __STL_TRY\n-\t\t      result = RopeLeaf_from_char_ptr(section, result_len);\n-\t\t    __STL_UNWIND(RopeBase::free_string(section, result_len))\n+\t\t    result = RopeLeaf_from_unowned_char_ptr(\n+\t\t\t\t\tl -> data + start, result_len);\n #               endif\n \t\treturn result;\n \t    }\n@@ -730,7 +731,7 @@ rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)\n \n \t\tif (result_len > lazy_threshold) goto lazy;\n \t\tsection = (charT *)\n-\t\t\tAlloc::allocate(rounded_up_size(result_len));\n+\t\t\tDataAlloc::allocate(rounded_up_size(result_len));\n \t\t__STL_TRY\n \t\t  (*(f -> fn))(start, result_len, section);\n \t\t__STL_UNWIND(RopeBase::free_string(section, result_len));\n@@ -870,12 +871,11 @@ bool rope<charT, Alloc>::apply_to_pieces(\n \t\tRopeFunction * f = (RopeFunction *)r;\n \t\tsize_t len = end - begin;\n \t\tbool result;\n-\t\tcharT * buffer = (charT *)\n-\t\t\tAlloc::allocate(len * sizeof(charT));\n+\t\tcharT * buffer = DataAlloc::allocate(len);\n \t\t__STL_TRY\n \t\t  (*(f -> fn))(begin, end, buffer);\n \t\t  result = c(buffer, len);\n-\t\t__STL_ALWAYS(Alloc::deallocate(buffer, len * sizeof(charT)))\n+\t\t__STL_ALWAYS(DataAlloc::deallocate(buffer, len))\n \t\treturn result;\n \t    }\n \tdefault:\n@@ -887,23 +887,23 @@ bool rope<charT, Alloc>::apply_to_pieces(\n \n inline void __rope_fill(ostream& o, size_t n)\n {\n-    char f = cout.fill();\n+    char f = o.fill();\n     size_t i;\n \n     for (i = 0; i < n; i++) o.put(f);\n }\n     \n \n-template <class charT> inline bool __rope_is_simple(charT *c) { return false; }\n-inline bool __rope_is_simple(char * c) { return true; }\n-inline bool __rope_is_simple(wchar_t * c) { return true; }\n+template <class charT> inline bool __rope_is_simple(charT *) { return false; }\n+inline bool __rope_is_simple(char *) { return true; }\n+inline bool __rope_is_simple(wchar_t *) { return true; }\n \n \n template<class charT, class Alloc>\n ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)\n {\n     size_t w = o.width();\n-    bool left = o.flags() & ios::left;\n+    bool left = bool(o.flags() & ios::left);\n     size_t pad_len;\n     size_t rope_len = r.size();\n     __rope_insert_char_consumer<charT> c(o);\n@@ -1084,6 +1084,9 @@ rope<charT,Alloc>::balance(RopeBase *r)\n #\tendif\n \tresult = concat(forest[i], result);\n \tforest[i] -> unref_nonnil();\n+#\tif !defined(__GC) && defined(__STL_USE_EXCEPTIONS)\n+\t  forest[i] = 0;\n+#\tendif\n       }\n     __STL_UNWIND(for(i = 0; i <= RopeBase::max_rope_depth; i++)\n \t\t unref(forest[i]))\n@@ -1114,12 +1117,11 @@ template <class charT, class Alloc>\n void\n rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)\n {\n-    self_destruct_ptr insertee(r);   \t// included in refcount\n-    self_destruct_ptr too_tiny(0);     \t// included in refcount\n+    RopeBase * insertee;   \t\t// included in refcount\n+    RopeBase * too_tiny = 0;    \t// included in refcount\n     int i;  \t\t\t\t// forest[0..i-1] is empty\n-    size_t s = insertee -> size;\n+    size_t s = r -> size;\n \n-    ref(r);\n     for (i = 0; s >= min_len[i+1]/* not this bucket */; ++i) {\n \tif (0 != forest[i]) {\n #\t    ifndef __GC\n@@ -1132,12 +1134,12 @@ rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)\n     }\n     {\n #\tifndef __GC\n-\t  self_destruct_ptr old(insertee);\n+\t  self_destruct_ptr old(too_tiny);\n #\tendif\n-\tinsertee = concat_and_set_balanced(too_tiny, insertee);\n+\tinsertee = concat_and_set_balanced(too_tiny, r);\n     }\n-    unref(too_tiny);\t// too_tiny is dead.\n-    too_tiny = 0;\t// Needed for exception safety.\n+    // Too_tiny dead, and no longer included in refcount.\n+    // Insertee is live and included.\n     __stl_assert(is_almost_balanced(insertee));\n     __stl_assert(insertee -> depth <= r -> depth + 1);\n     for (;; ++i) {\n@@ -1155,7 +1157,6 @@ rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)\n \tif (i == RopeBase::max_rope_depth\n \t    || insertee -> size < min_len[i+1]) {\n \t    forest[i] = insertee;\n-\t    insertee = 0;\n \t    // refcount is OK since insertee is now dead.\n \t    return;\n \t}\n@@ -1348,66 +1349,56 @@ __rope_charT_ref_proxy<charT, Alloc>::operator& () const {\n template <class charT, class Alloc>\n rope<charT, Alloc>::rope(size_t n, charT c)\n {\n-    RopeBase * result;\n+    rope result;\n     const size_t exponentiate_threshold = 32;\n     size_t exponent;\n     size_t rest;\n     charT *rest_buffer;\n     RopeBase * remainder;\n+    rope remainder_rope;\n \n     if (0 == n) { tree_ptr = 0; return; }\n     exponent = n / exponentiate_threshold;\n     rest = n % exponentiate_threshold;\n     if (0 == rest) {\n \tremainder = 0;\n     } else {\n-\trest_buffer = (charT *)Alloc::allocate(rounded_up_size(rest));\n+\trest_buffer = DataAlloc::allocate(rounded_up_size(rest));\n \tuninitialized_fill_n(rest_buffer, rest, c);\n \t__cond_store_eos(rest_buffer[rest]);\n \t__STL_TRY\n \t    remainder = RopeLeaf_from_char_ptr(rest_buffer, rest);\n \t__STL_UNWIND(RopeBase::free_string(rest_buffer, rest))\n     }\n-    __STL_TRY\n-      if (exponent != 0) {\n+    remainder_rope.tree_ptr = remainder;\n+    if (exponent != 0) {\n \tcharT * base_buffer =\n-\t\t(charT *)Alloc::allocate(\n-\t\t\trounded_up_size(exponentiate_threshold));\n-\tself_destruct_ptr base_leaf;\n+\t\tDataAlloc::allocate(rounded_up_size(exponentiate_threshold));\n+\tRopeLeaf * base_leaf;\n+\trope base_rope;\n \tuninitialized_fill_n(base_buffer, exponentiate_threshold, c);\n \t__cond_store_eos(base_buffer[exponentiate_threshold]);\n \t__STL_TRY\n-\t  base_leaf = RopeLeaf_from_char_ptr(base_buffer,\n-\t\t\t\t\t     exponentiate_threshold);\n+\tbase_leaf = RopeLeaf_from_char_ptr(base_buffer,\n+\t\t\t\t\t   exponentiate_threshold);\n \t__STL_UNWIND(RopeBase::free_string(base_buffer, exponentiate_threshold))\n+\tbase_rope.tree_ptr = base_leaf;\n  \tif (1 == exponent) {\n-\t    result = base_leaf;\n-#           ifndef __GC\n-\t      __stl_assert(1 == result -> refcount);\n-\t      result -> refcount = 2;   // will be decremented when base_leaf disappears\n-#           endif\n+\t  result = base_rope;\n+#         ifndef __GC\n+\t    __stl_assert(1 == result -> tree_ptr -> refcount);\n+#         endif\n \t} else {\n-\t    result = power((RopeBase *)base_leaf, exponent, concat_fn());\n-#           ifndef __GC\n-\t      __stl_assert(0 == result -> refcount);\n-\t      result -> refcount = 1;\n-#           endif\n+\t  result = power(base_rope, exponent, concat_fn());\n \t}\n \tif (0 != remainder) {\n-#           ifndef __GC\n-\t      __stl_assert(1 == remainder -> refcount);\n-#           endif\n-\t    result = tree_concat(result, remainder);\n+\t  result += remainder_rope;\n \t}\n-\t// All partial results computed by power must be used.\n-      } else {\n-\tresult = remainder;\n-      }\n-    __STL_UNWIND(unref(remainder));\n-#   ifndef __GC\n-      __stl_assert(0 == result || 1 == result -> refcount);\n-#   endif\n-    tree_ptr = result;\n+    } else {\n+\tresult = remainder_rope;\n+    }\n+    tree_ptr = result.tree_ptr;\n+    tree_ptr -> ref_nonnil();\n }\n \n template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];\n@@ -1427,7 +1418,7 @@ const charT * rope<charT,Alloc>::c_str() const {\n     __GC_CONST charT * old_c_string = tree_ptr -> c_string;\n     if (0 != old_c_string) return(old_c_string);\n     size_t s = size();\n-    charT * result = (charT *)Alloc::allocate((s + 1)*sizeof(charT));\n+    charT * result = DataAlloc::allocate(s + 1);\n     flatten(tree_ptr, result);\n     result[s] = __eos((charT *)0);\n #   ifdef __GC\n@@ -1438,7 +1429,7 @@ const charT * rope<charT,Alloc>::c_str() const {\n \t// separately allocated.  Deallocate the old copy, since we just\n \t// replaced it.\n \tdestroy(old_c_string, old_c_string + s + 1);\n-\tAlloc::deallocate(old_c_string, s + 1);\n+\tDataAlloc::deallocate(old_c_string, s + 1);\n       }\n #   endif\n     return(result);\n@@ -1455,7 +1446,7 @@ const charT * rope<charT,Alloc>::replace_with_c_str() {\n \treturn(old_c_string);\n     }\n     size_t s = size();\n-    charT * result = (charT *)Alloc::allocate(rounded_up_size(s));\n+    charT * result = DataAlloc::allocate(rounded_up_size(s));\n     flatten(tree_ptr, result);\n     result[s] = __eos((charT *)0);\n     tree_ptr -> unref_nonnil();"}, {"sha": "9ae6e117f0df74fa4d1092abb8aeaa70b8bf4261", "filename": "libstdc++/stl/slist.h", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fslist.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -99,24 +99,27 @@ struct __slist_iterator_base\n   }\n };\n \n-template <class T, class Ref>\n+template <class T, class Ref, class Ptr>\n struct __slist_iterator : public __slist_iterator_base\n {\n-  typedef __slist_iterator<T, T&> iterator;\n-  typedef __slist_iterator<T, const T&> const_iterator;\n-  typedef __slist_iterator<T, Ref> self;\n+  typedef __slist_iterator<T, T&, T*>             iterator;\n+  typedef __slist_iterator<T, const T&, const T*> const_iterator;\n+  typedef __slist_iterator<T, Ref, Ptr>           self;\n \n   typedef T value_type;\n-  typedef value_type* pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n+  typedef Ptr pointer;\n+  typedef Ref reference;\n   typedef __slist_node<T> list_node;\n \n   __slist_iterator(list_node* x) : __slist_iterator_base(x) {}\n   __slist_iterator() : __slist_iterator_base(0) {}\n   __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}\n \n-  Ref operator*() const { return ((list_node*) node)->data; }\n+  reference operator*() const { return ((list_node*) node)->data; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n+\n   self& operator++()\n   {\n     incr();\n@@ -130,6 +133,8 @@ struct __slist_iterator : public __slist_iterator_base\n   }\n };\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n inline ptrdiff_t*\n distance_type(const __slist_iterator_base&)\n {\n@@ -142,12 +147,14 @@ iterator_category(const __slist_iterator_base&)\n   return forward_iterator_tag();\n }\n \n-template <class T, class Ref> \n+template <class T, class Ref, class Ptr> \n inline T* \n-value_type(const __slist_iterator<T, Ref>&) {\n+value_type(const __slist_iterator<T, Ref, Ptr>&) {\n   return 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n inline size_t __slist_size(__slist_node_base* node)\n {\n   size_t result = 0;\n@@ -167,8 +174,8 @@ class slist\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n \n-  typedef __slist_iterator<T, reference> iterator;\n-  typedef __slist_iterator<T, const_reference> const_iterator;\n+  typedef __slist_iterator<T, T&, T*>             iterator;\n+  typedef __slist_iterator<T, const T&, const T*> const_iterator;\n \n private:\n   typedef __slist_node<T> list_node;"}, {"sha": "31e96cf7cd308c63e7bec1eefe7e3e1e7532d996", "filename": "libstdc++/stl/stl_config.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_config.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -47,14 +47,16 @@\n //  (9) Defines __STL_NON_TYPE_TMPL_PARAM_BUG if the compiler has \n //      trouble performing function template argument deduction for\n //      non-type template parameters.\n-//  (10) Defines __STL_USE_EXCEPTIONS if the compiler (in the current\n-//      compilation mode) supports exceptions.\n-//  (11) Defines __STL_SGI_THREADS if this is being compiled on an SGI\n-//      compiler, and if the user hasn't selected pthreads or no threads\n-//      instead.\n-//  (12) Defines __STL_WIN32THREADS if this is being compiled on a \n+//  (10) Defines __SGI_STL_NO_ARROW_OPERATOR if the compiler is unable\n+//       to support the -> operator for iterators.\n+//  (11) Defines __STL_USE_EXCEPTIONS if the compiler (in the current\n+//       compilation mode) supports exceptions.\n+//  (12) Defines __STL_SGI_THREADS if this is being compiled on an SGI\n+//       compiler, and if the user hasn't selected pthreads or no threads\n+//       instead.\n+//  (13) Defines __STL_WIN32THREADS if this is being compiled on a \n //       WIN32 compiler in multithreaded mode.\n-//  (13) Defines __stl_assert either as a test or as a null macro,\n+//  (14) Defines __stl_assert either as a test or as a null macro,\n //       depending on whether or not __STL_ASSERTIONS is defined.\n \n # if defined(__sgi) && !defined(__GNUC__)\n@@ -120,6 +122,7 @@\n #     define __STL_NEED_EXPLICIT\n #   endif\n #   define __STL_NON_TYPE_TMPL_PARAM_BUG\n+#   define __SGI_STL_NO_ARROW_OPERATOR\n #   ifdef _CPPUNWIND\n #     define __STL_USE_EXCEPTIONS\n #   endif\n@@ -132,6 +135,7 @@\n #   define __STL_NO_DRAND48\n #   define __STL_NEED_TYPENAME\n #   define __STL_LIMITED_DEFAULT_TEMPLATES\n+#   define __SGI_STL_NO_ARROW_OPERATOR\n #   define __STL_NON_TYPE_TMPL_PARAM_BUG\n #   ifdef _CPPUNWIND\n #     define __STL_USE_EXCEPTIONS"}, {"sha": "b55f0c51f0f9d6e9afe642909c5295419cf086a6", "filename": "libstdc++/stl/tree.h", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftree.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -137,23 +137,25 @@ struct __rb_tree_base_iterator\n   }\n };\n \n-template <class Value, class Ref>\n+template <class Value, class Ref, class Ptr>\n struct __rb_tree_iterator : public __rb_tree_base_iterator\n {\n   typedef Value value_type;\n   typedef Value& reference;\n-  typedef const Value& const_reference;\n   typedef Value* pointer;\n-  typedef __rb_tree_iterator<Value, reference> iterator;\n-  typedef __rb_tree_iterator<Value, const_reference> const_iterator;\n-  typedef __rb_tree_iterator<Value, Ref> self;\n+  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;\n+  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;\n+  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;\n   typedef __rb_tree_node<Value>* link_type;\n \n   __rb_tree_iterator() {}\n   __rb_tree_iterator(link_type x) { node = x; }\n   __rb_tree_iterator(const iterator& it) { node = it.node; }\n \n-  Ref operator*() const { return link_type(node)->value_field; }\n+  reference operator*() const { return link_type(node)->value_field; }\n+#ifndef __SGI_STL_NO_ARROW_OPERATOR\n+  pointer operator->() const { return &(operator*()); }\n+#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   self& operator++() { increment(); return *this; }\n   self operator++(int) {\n@@ -180,6 +182,8 @@ inline bool operator!=(const __rb_tree_base_iterator& x,\n   return x.node != y.node;\n }\n \n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n inline bidirectional_iterator_tag\n iterator_category(const __rb_tree_base_iterator&) {\n   return bidirectional_iterator_tag();\n@@ -190,11 +194,13 @@ distance_type(const __rb_tree_base_iterator&) {\n   return (__rb_tree_base_iterator::difference_type*) 0;\n }\n \n-template <class Value, class Ref>\n-inline Value* value_type(const __rb_tree_iterator<Value, Ref>&) {\n+template <class Value, class Ref, class Ptr>\n+inline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {\n   return (Value*) 0;\n }\n \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n inline void \n __rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)\n {\n@@ -487,15 +493,21 @@ class rb_tree {\n     }\n \n public:\n-    typedef __rb_tree_iterator<value_type, reference> iterator;\n-    typedef __rb_tree_iterator<value_type, const_reference> const_iterator;\n-\n+    typedef __rb_tree_iterator<value_type, reference, pointer> iterator;\n+    typedef __rb_tree_iterator<value_type, const_reference, const_pointer> \n+            const_iterator;\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+    typedef reverse_iterator<iterator> reverse_iterator;\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n     typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n                                            difference_type>\n         reverse_iterator; \n     typedef reverse_bidirectional_iterator<const_iterator, value_type,\n                                            const_reference, difference_type>\n         const_reverse_iterator;\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n private:\n     iterator __insert(base_ptr x, base_ptr y, const value_type& v);\n     link_type __copy(link_type x, link_type p);"}, {"sha": "e0b88a1cd49b534a7754ea79649ac78c1fec744a", "filename": "libstdc++/stl/vector.h", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff893307d082263698dc79b955cb72cca949dd64/libstdc%2B%2B%2Fstl%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fvector.h?ref=ff893307d082263698dc79b955cb72cca949dd64", "patch": "@@ -42,10 +42,16 @@ class vector {\n     typedef const value_type& const_reference;\n     typedef size_t size_type;\n     typedef ptrdiff_t difference_type;\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+    typedef reverse_iterator<iterator> reverse_iterator;\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n     typedef reverse_iterator<const_iterator, value_type, const_reference, \n                              difference_type>  const_reverse_iterator;\n     typedef reverse_iterator<iterator, value_type, reference, difference_type>\n         reverse_iterator;\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n protected:\n     typedef simple_alloc<value_type, Alloc> data_allocator;\n     iterator start;\n@@ -256,20 +262,6 @@ class vector {\n       end_of_storage = finish;\n     }\n \n-    template <class BidirectionalIterator>\n-    void range_initialize(BidirectionalIterator first,\n-                          BidirectionalIterator last,\n-                          bidirectional_iterator_tag) {\n-      range_initialize(first, last, forward_iterator_tag());\n-    }\n-\n-    template <class RandomAccessIterator>\n-    void range_initialize(RandomAccessIterator first,\n-                          RandomAccessIterator last,\n-                          random_access_iterator_tag) {\n-      range_initialize(first, last, forward_iterator_tag());\n-    }\n-\n     template <class InputIterator>\n     void range_insert(iterator pos,\n                       InputIterator first, InputIterator last,\n@@ -280,19 +272,6 @@ class vector {\n                       ForwardIterator first, ForwardIterator last,\n                       forward_iterator_tag);\n \n-    template <class BidirectionalIterator>\n-    void range_insert(iterator pos,\n-                      BidirectionalIterator first, BidirectionalIterator last,\n-                      bidirectional_iterator_tag) {\n-      range_insert(pos, first, last, forward_iterator_tag());\n-    }\n-\n-    template <class RandomAccessIterator>\n-    void range_insert(iterator pos,\n-                      RandomAccessIterator first, RandomAccessIterator last,\n-                      random_access_iterator_tag) {\n-      range_insert(pos, first, last, forward_iterator_tag());\n-    }\n #endif /* __STL_MEMBER_TEMPLATES */\n };\n "}]}