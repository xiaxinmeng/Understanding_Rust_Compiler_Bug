{"sha": "08900f28893b98b2ad0e0c284338d8555636067c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5MDBmMjg4OTNiOThiMmFkMGUwYzI4NDMzOGQ4NTU1NjM2MDY3Yw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-19T15:21:45Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-19T16:54:43Z"}, "message": "Minor cleanups to forward threader.\n\nEvery time we allocate a threading edge we push it onto the path in a\ndistinct step.  There's no need to do this in two steps, and avoiding\nthis, keeps us from exposing the internals of the registry.\n\nI've also did some tiny cleanups in thread_across_edge, most importantly\nremoving the bitmap in favor of an auto_bitmap.\n\nThere are no functional changes.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c\n\t(back_threader_registry::register_path): Use push_edge.\n\t* tree-ssa-threadedge.c\n\t(jump_threader::thread_around_empty_blocks): Same.\n\t(jump_threader::thread_through_normal_block): Same.\n\t(jump_threader::thread_across_edge): Same.  Also, use auto_bitmap.\n\tTidy up code.\n\t* tree-ssa-threadupdate.c\n\t(jt_path_registry::allocate_thread_edge): Remove.\n\t(jt_path_registry::push_edge): New.\n\t(dump_jump_thread_path): Make static.\n\t* tree-ssa-threadupdate.h (allocate_thread_edge): Remove.\n\t(push_edge): New.", "tree": {"sha": "69f47d73c37d4c7800e1f95dab4bb32af9d28133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69f47d73c37d4c7800e1f95dab4bb32af9d28133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08900f28893b98b2ad0e0c284338d8555636067c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08900f28893b98b2ad0e0c284338d8555636067c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08900f28893b98b2ad0e0c284338d8555636067c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08900f28893b98b2ad0e0c284338d8555636067c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "124c354ad70f09c31610f67743b277a359527649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124c354ad70f09c31610f67743b277a359527649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124c354ad70f09c31610f67743b277a359527649"}], "stats": {"total": 93, "additions": 30, "deletions": 63}, "files": [{"sha": "c6530d3a6bb99f09e42e709d7cc31164f12ad6b7", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=08900f28893b98b2ad0e0c284338d8555636067c", "patch": "@@ -902,15 +902,11 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n \n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n-      jump_thread_edge *x\n-\t= m_lowlevel_registry.allocate_thread_edge (e, EDGE_COPY_SRC_BLOCK);\n-      jump_thread_path->safe_push (x);\n+      m_lowlevel_registry.push_edge (jump_thread_path, e, EDGE_COPY_SRC_BLOCK);\n     }\n \n-  jump_thread_edge *x\n-    = m_lowlevel_registry.allocate_thread_edge (taken_edge,\n-\t\t\t\t\t\tEDGE_NO_COPY_SRC_BLOCK);\n-  jump_thread_path->safe_push (x);\n+  m_lowlevel_registry.push_edge (jump_thread_path,\n+\t\t\t\t taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \n   if (m_lowlevel_registry.register_jump_thread (jump_thread_path))\n     ++m_threaded_paths;"}, {"sha": "04138cb06fe3ebf69bf174709a8cfe6c4bdf4140", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=08900f28893b98b2ad0e0c284338d8555636067c", "patch": "@@ -898,10 +898,7 @@ jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n \n \t  if (!bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n-\t      jump_thread_edge *x\n-\t\t= m_registry->allocate_thread_edge (taken_edge,\n-\t\t\t\t\t\t    EDGE_NO_COPY_SRC_BLOCK);\n-\t      path->safe_push (x);\n+\t      m_registry->push_edge (path, taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n \t      return thread_around_empty_blocks (path, taken_edge, visited);\n \t    }\n@@ -942,10 +939,7 @@ jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n \treturn false;\n       bitmap_set_bit (visited, taken_edge->dest->index);\n \n-      jump_thread_edge *x\n-\t= m_registry->allocate_thread_edge (taken_edge,\n-\t\t\t\t\t    EDGE_NO_COPY_SRC_BLOCK);\n-      path->safe_push (x);\n+      m_registry->push_edge (path, taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \n       thread_around_empty_blocks (path, taken_edge, visited);\n       return true;\n@@ -1051,16 +1045,9 @@ jump_threader::thread_through_normal_block (vec<jump_thread_edge *> *path,\n \t  /* Only push the EDGE_START_JUMP_THREAD marker if this is\n \t     first edge on the path.  */\n \t  if (path->length () == 0)\n-\t    {\n-              jump_thread_edge *x\n-\t\t= m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);\n-\t      path->safe_push (x);\n-\t    }\n+\t    m_registry->push_edge (path, e, EDGE_START_JUMP_THREAD);\n \n-\t  jump_thread_edge *x\n-\t    = m_registry->allocate_thread_edge (taken_edge,\n-\t\t\t\t\t\tEDGE_COPY_SRC_BLOCK);\n-\t  path->safe_push (x);\n+\t  m_registry->push_edge (path, taken_edge, EDGE_COPY_SRC_BLOCK);\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n@@ -1146,53 +1133,43 @@ edge_forwards_cmp_to_conditional_jump_through_empty_bb_p (edge e)\n void\n jump_threader::thread_across_edge (edge e)\n {\n-  bitmap visited = BITMAP_ALLOC (NULL);\n+  auto_bitmap visited;\n \n   m_state->push (e);\n \n   stmt_count = 0;\n \n   vec<jump_thread_edge *> *path = m_registry->allocate_thread_path ();\n-  bitmap_clear (visited);\n   bitmap_set_bit (visited, e->src->index);\n   bitmap_set_bit (visited, e->dest->index);\n \n-  int threaded;\n+  int threaded = 0;\n   if ((e->flags & EDGE_DFS_BACK) == 0)\n     threaded = thread_through_normal_block (path, e, visited);\n-  else\n-    threaded = 0;\n \n   if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n-      BITMAP_FREE (visited);\n       m_registry->register_jump_thread (path);\n       m_state->pop ();\n       return;\n     }\n-  else\n-    {\n-      /* Negative and zero return values indicate no threading was possible,\n-\t thus there should be no edges on the thread path and no need to walk\n-\t through the vector entries.  */\n-      gcc_assert (path->length () == 0);\n-      path->release ();\n \n-      /* A negative status indicates the target block was deemed too big to\n-\t duplicate.  Just quit now rather than trying to use the block as\n-\t a joiner in a jump threading path.\n+  gcc_checking_assert (path->length () == 0);\n+  path->release ();\n+\n+  if (threaded < 0)\n+    {\n+      /* The target block was deemed too big to duplicate.  Just quit\n+\t now rather than trying to use the block as a joiner in a jump\n+\t threading path.\n \n \t This prevents unnecessary code growth, but more importantly if we\n \t do not look at all the statements in the block, then we may have\n \t missed some invalidations if we had traversed a backedge!  */\n-      if (threaded < 0)\n-\t{\n-\t  BITMAP_FREE (visited);\n-\t  m_state->pop ();\n-\t  return;\n-\t}\n+      m_state->pop ();\n+      return;\n     }\n \n  /* We were unable to determine what out edge from E->dest is taken.  However,\n@@ -1217,7 +1194,6 @@ jump_threader::thread_across_edge (edge e)\n       if (taken_edge->flags & EDGE_COMPLEX)\n \t{\n \t  m_state->pop ();\n-\t  BITMAP_FREE (visited);\n \t  return;\n \t}\n \n@@ -1235,17 +1211,11 @@ jump_threader::thread_across_edge (edge e)\n \tbitmap_set_bit (visited, e->src->index);\n \tbitmap_set_bit (visited, e->dest->index);\n \tbitmap_set_bit (visited, taken_edge->dest->index);\n-\tvec<jump_thread_edge *> *path = m_registry->allocate_thread_path ();\n \n-\t/* Record whether or not we were able to thread through a successor\n-\t   of E->dest.  */\n-\tjump_thread_edge *x\n-\t  = m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);\n-\tpath->safe_push (x);\n+\tvec<jump_thread_edge *> *path = m_registry->allocate_thread_path ();\n+\tm_registry->push_edge (path, e, EDGE_START_JUMP_THREAD);\n+\tm_registry->push_edge (path, taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);\n \n-\tx = m_registry->allocate_thread_edge (taken_edge,\n-\t\t\t\t\t      EDGE_COPY_SRC_JOINER_BLOCK);\n-\tpath->safe_push (x);\n \tfound = thread_around_empty_blocks (path, taken_edge, visited);\n \n \tif (!found)\n@@ -1267,7 +1237,6 @@ jump_threader::thread_across_edge (edge e)\n \n \tm_state->pop ();\n       }\n-    BITMAP_FREE (visited);\n   }\n \n   m_state->pop ();"}, {"sha": "baac11280fafdb72955906324cc7fcb2512c2702", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=08900f28893b98b2ad0e0c284338d8555636067c", "patch": "@@ -196,10 +196,12 @@ back_jt_path_registry::back_jt_path_registry ()\n {\n }\n \n-jump_thread_edge *\n-jt_path_registry::allocate_thread_edge (edge e, jump_thread_edge_type t)\n+void\n+jt_path_registry::push_edge (vec<jump_thread_edge *> *path,\n+\t\t\t     edge e, jump_thread_edge_type type)\n {\n-  return m_allocator.allocate_thread_edge (e, t);\n+  jump_thread_edge *x =  m_allocator.allocate_thread_edge (e, type);\n+  path->safe_push (x);\n }\n \n vec<jump_thread_edge *> *\n@@ -211,9 +213,9 @@ jt_path_registry::allocate_thread_path ()\n /* Dump a jump threading path, including annotations about each\n    edge in the path.  */\n \n-void\n+static void\n dump_jump_thread_path (FILE *dump_file,\n-\t\t       const vec<jump_thread_edge *> path,\n+\t\t       const vec<jump_thread_edge *> &path,\n \t\t       bool registering)\n {\n   fprintf (dump_file,"}, {"sha": "8b48a671212af3e74f33f6bcd3922a04838fb431", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08900f28893b98b2ad0e0c284338d8555636067c/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=08900f28893b98b2ad0e0c284338d8555636067c", "patch": "@@ -66,7 +66,7 @@ class jt_path_registry\n   virtual ~jt_path_registry ();\n   bool register_jump_thread (vec<jump_thread_edge *> *);\n   bool thread_through_all_blocks (bool peel_loop_headers);\n-  jump_thread_edge *allocate_thread_edge (edge e, jump_thread_edge_type t);\n+  void push_edge (vec<jump_thread_edge *> *path, edge, jump_thread_edge_type);\n   vec<jump_thread_edge *> *allocate_thread_path ();\n   void debug ();\n protected:"}]}