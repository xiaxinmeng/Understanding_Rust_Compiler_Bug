{"sha": "5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI1OGIzOWIwYTdkMWM3OWIwZDU3ZTUxMTk5ODY0ZjlhMzY4NWJiNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-04-22T09:30:27Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-04-22T09:30:27Z"}, "message": "re PR middle-end/29274 (not using mulsidi3)\n\ngcc/\n\tPR middle-end/29274\n\t* optabs.h (expand_widening_mult): Declare.\n\t* tree-pass.h (pass_optimize_widening_mul): Declare.\n\t* tree-ssa-math-opts.c (execute_optimize_widening_mul,\n\tgate_optimize_widening_mul): New static functions.\n\t(pass_optimize_widening_mul): New.\n\t* expr.c (expand_expr_real_2) <case WIDEN_MULT_EXPR>: New\n\tcase.\n\t<case MULT_EXPR>: Remove support for widening multiplies.\n\t* tree.def (WIDEN_MULT_EXPR): Tweak comment.\n\t* cfgexpand.c (expand_debug_expr) <case WIDEN_MULT_EXPR>: Use\n\tsimplify_gen_unary rather than directly building extensions.\n\t* tree-cfg.c (verify_gimple_assign_binary): Add tests for\n\tWIDEN_MULT_EXPR.\n\t* expmed.c (expand_widening_mult): New function.\n\t* passes.c (init_optimization_passes): Add pass_optimize_widening_mul.\n\ngcc/testsuite/\n\tPR middle-end/29274\n\t* gcc.target/i386/wmul-1.c: New test.\n\t* gcc.target/i386/wmul-2.c: New test.\n\t* gcc.target/bfin/wmul-1.c: New test.\n\t* gcc.target/bfin/wmul-2.c: New test.\n\nFrom-SVN: r158633", "tree": {"sha": "9248604cc9a0efe5af0b9ed453fe7110c80743c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9248604cc9a0efe5af0b9ed453fe7110c80743c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/comments", "author": null, "committer": null, "parents": [{"sha": "92375a2020b1f32bf7be92025493cebd9b3b4400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92375a2020b1f32bf7be92025493cebd9b3b4400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92375a2020b1f32bf7be92025493cebd9b3b4400"}], "stats": {"total": 458, "additions": 356, "deletions": 102}, "files": [{"sha": "33e3f05721189a80108f47c4b19a8a97a6cb0329", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -1,3 +1,22 @@\n+2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR middle-end/29274\n+\t* optabs.h (expand_widening_mult): Declare.\n+\t* tree-pass.h (pass_optimize_widening_mul): Declare.\n+\t* tree-ssa-math-opts.c (execute_optimize_widening_mul,\n+\tgate_optimize_widening_mul): New static functions.\n+\t(pass_optimize_widening_mul): New.\n+\t* expr.c (expand_expr_real_2) <case WIDEN_MULT_EXPR>: New\n+\tcase.\n+\t<case MULT_EXPR>: Remove support for widening multiplies.\n+\t* tree.def (WIDEN_MULT_EXPR): Tweak comment.\n+\t* cfgexpand.c (expand_debug_expr) <case WIDEN_MULT_EXPR>: Use\n+\tsimplify_gen_unary rather than directly building extensions.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Add tests for\n+\tWIDEN_MULT_EXPR.\n+\t* expmed.c (expand_widening_mult): New function.\n+\t* passes.c (init_optimization_passes): Add pass_optimize_widening_mul.\n+\n 2010-04-21  Jan Hubicka  <jh@suse.cz>\n \n \t* timevar.def (TV_WHOPR_WPA_FIXUP): Remove."}, {"sha": "319b1832295d6620f28edb716b5ff40e9a56da42", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -3023,14 +3023,15 @@ expand_debug_expr (tree exp)\n       if (SCALAR_INT_MODE_P (GET_MODE (op0))\n \t  && SCALAR_INT_MODE_P (mode))\n \t{\n+\t  enum machine_mode inner_mode = GET_MODE (op0);\n \t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t    op0 = gen_rtx_ZERO_EXTEND (mode, op0);\n+\t    op0 = simplify_gen_unary (ZERO_EXTEND, mode, op0, inner_mode);\n \t  else\n-\t    op0 = gen_rtx_SIGN_EXTEND (mode, op0);\n+\t    op0 = simplify_gen_unary (SIGN_EXTEND, mode, op0, inner_mode);\n \t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1))))\n-\t    op1 = gen_rtx_ZERO_EXTEND (mode, op1);\n+\t    op1 = simplify_gen_unary (ZERO_EXTEND, mode, op1, inner_mode);\n \t  else\n-\t    op1 = gen_rtx_SIGN_EXTEND (mode, op1);\n+\t    op1 = simplify_gen_unary (SIGN_EXTEND, mode, op1, inner_mode);\n \t  return gen_rtx_MULT (mode, op0, op1);\n \t}\n       return NULL;"}, {"sha": "07b1dc6d70d0b47b7e1eb84b08811e7c6cad37c9", "filename": "gcc/expmed.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -3217,6 +3217,55 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n   gcc_assert (op0);\n   return op0;\n }\n+\n+/* Perform a widening multiplication and return an rtx for the result.\n+   MODE is mode of value; OP0 and OP1 are what to multiply (rtx's);\n+   TARGET is a suggestion for where to store the result (an rtx).\n+   THIS_OPTAB is the optab we should use, it must be either umul_widen_optab\n+   or smul_widen_optab.\n+\n+   We check specially for a constant integer as OP1, comparing the\n+   cost of a widening multiply against the cost of a sequence of shifts\n+   and adds.  */\n+\n+rtx\n+expand_widening_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n+\t\t      int unsignedp, optab this_optab)\n+{\n+  bool speed = optimize_insn_for_speed_p ();\n+\n+  if (CONST_INT_P (op1)\n+      && (INTVAL (op1) >= 0\n+\t  || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT))\n+    {\n+      HOST_WIDE_INT coeff = INTVAL (op1);\n+      int max_cost;\n+      enum mult_variant variant;\n+      struct algorithm algorithm;\n+\n+      /* Special case powers of two.  */\n+      if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n+\t{\n+\t  op0 = convert_to_mode (mode, op0, this_optab == umul_widen_optab);\n+\t  return expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t       build_int_cst (NULL_TREE, floor_log2 (coeff)),\n+\t\t\t       target, unsignedp);\n+\t}\n+\n+      /* Exclude cost of op0 from max_cost to match the cost\n+\t calculation of the synth_mult.  */\n+      max_cost = mul_widen_cost[speed][mode];\n+      if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n+\t\t\t       max_cost))\n+\t{\n+\t  op0 = convert_to_mode (mode, op0, this_optab == umul_widen_optab);\n+\t  return expand_mult_const (mode, op0, coeff, target,\n+\t\t\t\t    &algorithm, variant);\n+\t}\n+    }\n+  return expand_binop (mode, this_optab, op0, op1, target,\n+\t\t       unsignedp, OPTAB_LIB_WIDEN);\n+}\n \f\n /* Return the smallest n such that 2**n >= X.  */\n "}, {"sha": "5448bbe2b8fa3cae5200df803a67a9fd9d6fde28", "filename": "gcc/expr.c", "status": "modified", "additions": 73, "deletions": 97, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -7212,7 +7212,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n   optab this_optab;\n   rtx subtarget, original_target;\n   int ignore;\n-  tree subexp0, subexp1;\n   bool reduce_bit_field;\n   gimple subexp0_def, subexp1_def;\n   tree top0, top1;\n@@ -7667,13 +7666,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n       goto binop2;\n \n-    case MULT_EXPR:\n-      /* If this is a fixed-point operation, then we cannot use the code\n-\t below because \"expand_mult\" doesn't support sat/no-sat fixed-point\n-         multiplications.   */\n-      if (ALL_FIXED_POINT_MODE_P (mode))\n-\tgoto binop;\n-\n+    case WIDEN_MULT_EXPR:\n       /* If first operand is constant, swap them.\n \t Thus the following special case checks need only\n \t check the second operand.  */\n@@ -7684,96 +7677,35 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  treeop1 = t1;\n \t}\n \n-      /* Attempt to return something suitable for generating an\n-\t indexed address, for machines that support that.  */\n-\n-      if (modifier == EXPAND_SUM && mode == ptr_mode\n-\t  && host_integerp (treeop1, 0))\n-\t{\n-\t  tree exp1 = treeop1;\n-\n-\t  op0 = expand_expr (treeop0, subtarget, VOIDmode,\n-\t\t\t     EXPAND_SUM);\n-\n-\t  if (!REG_P (op0))\n-\t    op0 = force_operand (op0, NULL_RTX);\n-\t  if (!REG_P (op0))\n-\t    op0 = copy_to_mode_reg (mode, op0);\n-\n-\t  return REDUCE_BIT_FIELD (gen_rtx_MULT (mode, op0,\n-\t\t\t       gen_int_mode (tree_low_cst (exp1, 0),\n-\t\t\t\t\t     TYPE_MODE (TREE_TYPE (exp1)))));\n-\t}\n-\n-      if (modifier == EXPAND_STACK_PARM)\n-\ttarget = 0;\n-\n-      /* Check for multiplying things that have been extended\n-\t from a narrower type.  If this machine supports multiplying\n-\t in that narrower type with a result in the desired type,\n-\t do it that way, and avoid the explicit type-conversion.  */\n-\n-      subexp0 = treeop0;\n-      subexp1 = treeop1;\n-      subexp0_def = get_def_for_expr (subexp0, NOP_EXPR);\n-      subexp1_def = get_def_for_expr (subexp1, NOP_EXPR);\n-      top0 = top1 = NULL_TREE;\n-\n       /* First, check if we have a multiplication of one signed and one\n \t unsigned operand.  */\n-      if (subexp0_def\n-\t  && (top0 = gimple_assign_rhs1 (subexp0_def))\n-\t  && subexp1_def\n-\t  && (top1 = gimple_assign_rhs1 (subexp1_def))\n-\t  && TREE_CODE (type) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t      < TYPE_PRECISION (TREE_TYPE (subexp0)))\n-\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t      == TYPE_PRECISION (TREE_TYPE (top1)))\n-\t  && (TYPE_UNSIGNED (TREE_TYPE (top0))\n-\t      != TYPE_UNSIGNED (TREE_TYPE (top1))))\n+      if (TREE_CODE (treeop1) != INTEGER_CST\n+\t  && (TYPE_UNSIGNED (TREE_TYPE (treeop0))\n+\t      != TYPE_UNSIGNED (TREE_TYPE (treeop1))))\n \t{\n-\t  enum machine_mode innermode\n-\t    = TYPE_MODE (TREE_TYPE (top0));\n+\t  enum machine_mode innermode = TYPE_MODE (TREE_TYPE (treeop0));\n \t  this_optab = usmul_widen_optab;\n-\t  if (mode == GET_MODE_WIDER_MODE (innermode))\n+\t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n \t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n-\t\t  if (TYPE_UNSIGNED (TREE_TYPE (top0)))\n-\t\t    expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n+\t\t    expand_operands (treeop0, treeop1, subtarget, &op0, &op1,\n \t\t\t\t     EXPAND_NORMAL);\n \t\t  else\n-\t\t    expand_operands (top0, top1, NULL_RTX, &op1, &op0,\n+\t\t    expand_operands (treeop0, treeop1, subtarget, &op1, &op0,\n \t\t\t\t     EXPAND_NORMAL);\n-\n \t\t  goto binop3;\n \t\t}\n \t    }\n \t}\n-      /* Check for a multiplication with matching signedness.  If\n-\t valid, TOP0 and TOP1 were set in the previous if\n-\t condition.  */\n-      else if (top0\n-\t  && TREE_CODE (type) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t      < TYPE_PRECISION (TREE_TYPE (subexp0)))\n-\t  && ((TREE_CODE (subexp1) == INTEGER_CST\n-\t       && int_fits_type_p (subexp1, TREE_TYPE (top0))\n-\t       /* Don't use a widening multiply if a shift will do.  */\n-\t       && ((GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (subexp1)))\n-\t\t    > HOST_BITS_PER_WIDE_INT)\n-\t\t   || exact_log2 (TREE_INT_CST_LOW (subexp1)) < 0))\n-\t      ||\n-\t      (top1\n-\t       && (TYPE_PRECISION (TREE_TYPE (top1))\n-\t\t   == TYPE_PRECISION (TREE_TYPE (top0))\n-\t       /* If both operands are extended, they must either both\n-\t\t  be zero-extended or both be sign-extended.  */\n-\t       && (TYPE_UNSIGNED (TREE_TYPE (top1))\n-\t\t   == TYPE_UNSIGNED (TREE_TYPE (top0)))))))\n+      /* Check for a multiplication with matching signedness.  */\n+      else if ((TREE_CODE (treeop1) == INTEGER_CST\n+\t\t&& int_fits_type_p (treeop1, TREE_TYPE (treeop0)))\n+\t       || (TYPE_UNSIGNED (TREE_TYPE (treeop1))\n+\t\t   == TYPE_UNSIGNED (TREE_TYPE (treeop0))))\n \t{\n-\t  tree op0type = TREE_TYPE (top0);\n+\t  tree op0type = TREE_TYPE (treeop0);\n \t  enum machine_mode innermode = TYPE_MODE (op0type);\n \t  bool zextend_p = TYPE_UNSIGNED (op0type);\n \t  optab other_optab = zextend_p ? smul_widen_optab : umul_widen_optab;\n@@ -7783,24 +7715,22 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t    {\n \t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n-\t\t  if (TREE_CODE (subexp1) == INTEGER_CST)\n-\t\t    expand_operands (top0, subexp1, NULL_RTX, &op0, &op1,\n-\t\t\t\t     EXPAND_NORMAL);\n-\t\t  else\n-\t\t    expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n-\t\t\t\t     EXPAND_NORMAL);\n-\t\t  goto binop3;\n+\t\t  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n+\t\t\t\t   EXPAND_NORMAL);\n+\t\t  temp = expand_widening_mult (mode, op0, op1, target,\n+\t\t\t\t\t       unsignedp, this_optab);\n+\t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n-\t      else if (optab_handler (other_optab, mode)->insn_code != CODE_FOR_nothing\n-\t\t       && innermode == word_mode)\n+\t      if (optab_handler (other_optab, mode)->insn_code != CODE_FOR_nothing\n+\t\t  && innermode == word_mode)\n \t\t{\n \t\t  rtx htem, hipart;\n-\t\t  op0 = expand_normal (top0);\n-\t\t  if (TREE_CODE (subexp1) == INTEGER_CST)\n+\t\t  op0 = expand_normal (treeop0);\n+\t\t  if (TREE_CODE (treeop1) == INTEGER_CST)\n \t\t    op1 = convert_modes (innermode, mode,\n-\t\t\t\t\t expand_normal (subexp1), unsignedp);\n+\t\t\t\t\t expand_normal (treeop1), unsignedp);\n \t\t  else\n-\t\t    op1 = expand_normal (top1);\n+\t\t    op1 = expand_normal (treeop1);\n \t\t  temp = expand_binop (mode, other_optab, op0, op1, target,\n \t\t\t\t       unsignedp, OPTAB_LIB_WIDEN);\n \t\t  hipart = gen_highpart (innermode, temp);\n@@ -7813,7 +7743,53 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t}\n \t    }\n \t}\n-      expand_operands (subexp0, subexp1, subtarget, &op0, &op1, EXPAND_NORMAL);\n+      treeop0 = fold_build1 (CONVERT_EXPR, type, treeop0);\n+      treeop1 = fold_build1 (CONVERT_EXPR, type, treeop1);\n+      expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n+      return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n+\n+    case MULT_EXPR:\n+      /* If this is a fixed-point operation, then we cannot use the code\n+\t below because \"expand_mult\" doesn't support sat/no-sat fixed-point\n+         multiplications.   */\n+      if (ALL_FIXED_POINT_MODE_P (mode))\n+\tgoto binop;\n+\n+      /* If first operand is constant, swap them.\n+\t Thus the following special case checks need only\n+\t check the second operand.  */\n+      if (TREE_CODE (treeop0) == INTEGER_CST)\n+\t{\n+\t  tree t1 = treeop0;\n+\t  treeop0 = treeop1;\n+\t  treeop1 = t1;\n+\t}\n+\n+      /* Attempt to return something suitable for generating an\n+\t indexed address, for machines that support that.  */\n+\n+      if (modifier == EXPAND_SUM && mode == ptr_mode\n+\t  && host_integerp (treeop1, 0))\n+\t{\n+\t  tree exp1 = treeop1;\n+\n+\t  op0 = expand_expr (treeop0, subtarget, VOIDmode,\n+\t\t\t     EXPAND_SUM);\n+\n+\t  if (!REG_P (op0))\n+\t    op0 = force_operand (op0, NULL_RTX);\n+\t  if (!REG_P (op0))\n+\t    op0 = copy_to_mode_reg (mode, op0);\n+\n+\t  return REDUCE_BIT_FIELD (gen_rtx_MULT (mode, op0,\n+\t\t\t       gen_int_mode (tree_low_cst (exp1, 0),\n+\t\t\t\t\t     TYPE_MODE (TREE_TYPE (exp1)))));\n+\t}\n+\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n+\n+      expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n     case TRUNC_DIV_EXPR:"}, {"sha": "a6e5af5084156300a93749e2fd1daa80e8683237", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -943,6 +943,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_forwprop);\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_fold_builtins);\n+      NEXT_PASS (pass_optimize_widening_mul);\n       NEXT_PASS (pass_tail_calls);\n       NEXT_PASS (pass_rename_ssa_copies);\n       NEXT_PASS (pass_uncprop);"}, {"sha": "074b25d39cd1f3c05c931c16a63c844ba0aa7b12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -1,3 +1,11 @@\n+2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR middle-end/29274\n+\t* gcc.target/i386/wmul-1.c: New test.\n+\t* gcc.target/i386/wmul-2.c: New test.\n+\t* gcc.target/bfin/wmul-1.c: New test.\n+\t* gcc.target/bfin/wmul-2.c: New test.\n+\n 2010-04-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR fortran/43829"}, {"sha": "f17fc199e8c96d628b980a1094e234745bddb9da", "filename": "gcc/testsuite/gcc.target/bfin/wmul-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-1.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int mac(const short *a, const short *b, int sqr, int *sum)\n+{\n+  int i;\n+  int dotp = *sum;\n+\n+  for (i = 0; i < 150; i++) {\n+    dotp += b[i] * a[i];\n+    sqr += b[i] * b[i];\n+  }\n+\n+  *sum = dotp;\n+  return sqr;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\\\(IS\\\\)\" 2 } } */"}, {"sha": "2f2d2527e69bf39b8e25b83bf7618e223372c6f8", "filename": "gcc/testsuite/gcc.target/bfin/wmul-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Fwmul-2.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void vec_mpy(int y[], const short x[], short scaler)\n+{\n+ int i;\n+\n+ for (i = 0; i < 150; i++)\n+   y[i] += ((scaler * x[i]) >> 31);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\\\(IS\\\\)\" 1 } } */"}, {"sha": "279eb2d0e67e837aaaa7505987e09474d3d0cbe8", "filename": "gcc/testsuite/gcc.target/i386/wmul-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-1.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+long long mac(const int *a, const int *b, long long sqr, long long *sum)\n+{\n+  int i;\n+  long long dotp = *sum;\n+\n+  for (i = 0; i < 150; i++) {\n+    dotp += (long long)b[i] * a[i];\n+    sqr += (long long)b[i] * b[i];\n+  }\n+\n+  *sum = dotp;\n+  return sqr;\n+}\n+\n+/* { dg-final { scan-assembler-times \"imull\" 2 } } */"}, {"sha": "1ff8b350658457d98c6702f81c56a489a4dd5b32", "filename": "gcc/testsuite/gcc.target/i386/wmul-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-2.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void vec_mpy(int y[], const int x[], int scaler)\n+{\n+ int i;\n+\n+ for (i = 0; i < 150; i++)\n+   y[i] += (((long long)scaler * x[i]) >> 31);\n+}\n+\n+/* { dg-final { scan-assembler-times \"imull\" 1 } } */"}, {"sha": "761dce159d1d5be575c509e03288f60473c3a34d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -3455,8 +3455,13 @@ verify_gimple_assign_binary (gimple stmt)\n \t connected to the operand types.  */\n       return verify_gimple_comparison (lhs_type, rhs1, rhs2);\n \n-    case WIDEN_SUM_EXPR:\n     case WIDEN_MULT_EXPR:\n+      if (TREE_CODE (lhs_type) != INTEGER_TYPE)\n+\treturn true;\n+      return ((2 * TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (lhs_type))\n+\t      || (TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (rhs2_type)));\n+\n+    case WIDEN_SUM_EXPR:\n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n     case VEC_PACK_TRUNC_EXPR:"}, {"sha": "3d7798e4ca41ad120add66394bccd665b3654b84", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -411,6 +411,7 @@ extern struct gimple_opt_pass pass_late_warn_uninitialized;\n extern struct gimple_opt_pass pass_cse_reciprocals;\n extern struct gimple_opt_pass pass_cse_sincos;\n extern struct gimple_opt_pass pass_optimize_bswap;\n+extern struct gimple_opt_pass pass_optimize_widening_mul;\n extern struct gimple_opt_pass pass_warn_function_return;\n extern struct gimple_opt_pass pass_warn_function_noreturn;\n extern struct gimple_opt_pass pass_cselim;"}, {"sha": "90ede52c4b7c87f4575b0e948b818569daab4771", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "patch": "@@ -1260,3 +1260,137 @@ struct gimple_opt_pass pass_optimize_bswap =\n   0                                     /* todo_flags_finish */\n  }\n };\n+\n+/* Find integer multiplications where the operands are extended from\n+   smaller types, and replace the MULT_EXPR with a WIDEN_MULT_EXPR\n+   where appropriate.  */\n+\n+static unsigned int\n+execute_optimize_widening_mul (void)\n+{\n+  bool changed = false;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        {\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n+\t  tree type, type1 = NULL, type2 = NULL;\n+\t  tree rhs1, rhs2, rhs1_convop = NULL, rhs2_convop = NULL;\n+\t  enum tree_code rhs1_code, rhs2_code;\n+\n+\t  if (!is_gimple_assign (stmt)\n+\t      || gimple_assign_rhs_code (stmt) != MULT_EXPR)\n+\t    continue;\n+\n+\t  type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\n+\t  if (TREE_CODE (type) != INTEGER_TYPE)\n+\t    continue;\n+\n+\t  rhs1 = gimple_assign_rhs1 (stmt);\n+\t  rhs2 = gimple_assign_rhs2 (stmt);\n+\n+\t  if (TREE_CODE (rhs1) == SSA_NAME)\n+\t    {\n+\t      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+\t      if (!is_gimple_assign (rhs1_stmt))\n+\t\tcontinue;\n+\t      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n+\t      if (!CONVERT_EXPR_CODE_P (rhs1_code))\n+\t\tcontinue;\n+\t      rhs1_convop = gimple_assign_rhs1 (rhs1_stmt);\n+\t      type1 = TREE_TYPE (rhs1_convop);\n+\t      if (TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n+\t\tcontinue;\n+\t    }\n+\t  else if (TREE_CODE (rhs1) != INTEGER_CST)\n+\t    continue;\n+\n+\t  if (TREE_CODE (rhs2) == SSA_NAME)\n+\t    {\n+\t      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+\t      if (!is_gimple_assign (rhs2_stmt))\n+\t\tcontinue;\n+\t      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n+\t      if (!CONVERT_EXPR_CODE_P (rhs2_code))\n+\t\tcontinue;\n+\t      rhs2_convop = gimple_assign_rhs1 (rhs2_stmt);\n+\t      type2 = TREE_TYPE (rhs2_convop);\n+\t      if (TYPE_PRECISION (type2) * 2 != TYPE_PRECISION (type))\n+\t\tcontinue;\n+\t    }\n+\t  else if (TREE_CODE (rhs2) != INTEGER_CST)\n+\t    continue;\n+\n+\t  if (rhs1_stmt == NULL && rhs2_stmt == NULL)\n+\t    continue;\n+\n+\t  /* Verify that the machine can perform a widening multiply in this\n+\t     mode/signedness combination, otherwise this transformation is\n+\t     likely to pessimize code.  */\n+\t  if ((rhs1_stmt == NULL || TYPE_UNSIGNED (type1))\n+\t      && (rhs2_stmt == NULL || TYPE_UNSIGNED (type2))\n+\t      && (optab_handler (umul_widen_optab, TYPE_MODE (type))\n+\t\t  ->insn_code == CODE_FOR_nothing))\n+\t    continue;\n+\t  else if ((rhs1_stmt == NULL || !TYPE_UNSIGNED (type1))\n+\t\t   && (rhs2_stmt == NULL || !TYPE_UNSIGNED (type2))\n+\t\t   && (optab_handler (smul_widen_optab, TYPE_MODE (type))\n+\t\t       ->insn_code == CODE_FOR_nothing))\n+\t    continue;\n+\t  else if (rhs1_stmt != NULL && rhs2_stmt != 0\n+\t\t   && (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n+\t\t   && (optab_handler (usmul_widen_optab, TYPE_MODE (type))\n+\t\t       ->insn_code == CODE_FOR_nothing))\n+\t    continue;\n+\n+\t  if ((rhs1_stmt == NULL && !int_fits_type_p (rhs1, type2))\n+\t      || (rhs2_stmt == NULL && !int_fits_type_p (rhs2, type1)))\n+\t    continue;\n+\n+\t  if (rhs1_stmt == NULL)\n+\t    gimple_assign_set_rhs1 (stmt, fold_convert (type2, rhs1));\n+\t  else\n+\t    gimple_assign_set_rhs1 (stmt, rhs1_convop);\n+\t  if (rhs2_stmt == NULL)\n+\t    gimple_assign_set_rhs2 (stmt, fold_convert (type1, rhs2));\n+\t  else\n+\t    gimple_assign_set_rhs2 (stmt, rhs2_convop);\n+\t  gimple_assign_set_rhs_code (stmt, WIDEN_MULT_EXPR);\n+\t  update_stmt (stmt);\n+\t  changed = true;\n+\t}\n+    }\n+  return (changed ? TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n+\t  | TODO_verify_stmts : 0);\n+}\n+\n+static bool\n+gate_optimize_widening_mul (void)\n+{\n+  return flag_expensive_optimizations && optimize;\n+}\n+\n+struct gimple_opt_pass pass_optimize_widening_mul =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"widening_mul\",\t\t\t/* name */\n+  gate_optimize_widening_mul,\t\t/* gate */\n+  execute_optimize_widening_mul,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};"}]}