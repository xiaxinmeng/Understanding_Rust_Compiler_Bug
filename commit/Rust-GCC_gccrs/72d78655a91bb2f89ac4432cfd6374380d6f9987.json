{"sha": "72d78655a91bb2f89ac4432cfd6374380d6f9987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkNzg2NTVhOTFiYjJmODlhYzQ0MzJjZmQ2Mzc0MzgwZDZmOTk4Nw==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-02-16T15:27:56Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-02-16T15:30:10Z"}, "message": "[PR98096] inline-asm: Take inout operands into account for access to labels by names.\n\nGCC splits inout operands into output and new matched input operands\nduring gimplfication.  Addressing operands by name or number is not\nproblem as the new input operands are added at the end of existing\ninput operands.  However it became a problem for labels in asm goto\nwith output reloads.  Addressing labels should take into account the\nnew input operands.  The patch solves the problem.\n\ngcc/ChangeLog:\n\n\tPR inline-asm/98096\n\t* stmt.c (resolve_operand_name_1): Take inout operands into account\n\tfor access to labels by names.\n\t* doc/extend.texi: Describe counting operands for accessing labels.\n\ngcc/testsuite/ChangeLog:\n\n\tPR inline-asm/98096\n\t* gcc.c-torture/compile/pr98096.c: New.", "tree": {"sha": "58e1991a7c059630e352f1d0033972240ad82fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58e1991a7c059630e352f1d0033972240ad82fbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d78655a91bb2f89ac4432cfd6374380d6f9987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d78655a91bb2f89ac4432cfd6374380d6f9987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d78655a91bb2f89ac4432cfd6374380d6f9987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d78655a91bb2f89ac4432cfd6374380d6f9987/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebf9b6c13f0847ddcc22e540a5fcdbf644e85a9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf9b6c13f0847ddcc22e540a5fcdbf644e85a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf9b6c13f0847ddcc22e540a5fcdbf644e85a9c"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "6eb1d327e97dc94b0d8c4787e3eb955f3efe4ab6", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=72d78655a91bb2f89ac4432cfd6374380d6f9987", "patch": "@@ -10680,16 +10680,23 @@ should use @samp{+} constraint modifier meaning that the operand is\n input and output one.  With this modifier you will have the correct\n values on all possible paths from the @code{asm goto}.\n \n-To reference a label in the assembler template,\n-prefix it with @samp{%l} (lowercase @samp{L}) followed \n-by its (zero-based) position in @var{GotoLabels} plus the number of input \n-operands.  For example, if the @code{asm} has three inputs and references two \n-labels, refer to the first label as @samp{%l3} and the second as @samp{%l4}).\n-\n-Alternately, you can reference labels using the actual C label name enclosed\n-in brackets.  For example, to reference a label named @code{carry}, you can\n-use @samp{%l[carry]}.  The label must still be listed in the @var{GotoLabels}\n-section when using this approach.\n+To reference a label in the assembler template, prefix it with\n+@samp{%l} (lowercase @samp{L}) followed by its (zero-based) position\n+in @var{GotoLabels} plus the number of input and output operands.\n+Output operand with constraint modifier @samp{+} is counted as two\n+operands because it is considered as one output and one input operand.\n+For example, if the @code{asm} has three inputs, one output operand\n+with constraint modifier @samp{+} and one output operand with\n+constraint modifier @samp{=} and references two labels, refer to the\n+first label as @samp{%l6} and the second as @samp{%l7}).\n+\n+Alternately, you can reference labels using the actual C label name\n+enclosed in brackets.  For example, to reference a label named\n+@code{carry}, you can use @samp{%l[carry]}.  The label must still be\n+listed in the @var{GotoLabels} section when using this approach.  It\n+is better to use the named references for labels as in this case you\n+can avoid counting input and output operands and special treatment of\n+output operands with constraint modifier @samp{+}.\n \n Here is an example of @code{asm goto} for i386:\n "}, {"sha": "f52ffaf8e75031d08275b3906f34ed013a27a4cb", "filename": "gcc/stmt.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=72d78655a91bb2f89ac4432cfd6374380d6f9987", "patch": "@@ -611,7 +611,7 @@ static char *\n resolve_operand_name_1 (char *p, tree outputs, tree inputs, tree labels)\n {\n   char *q;\n-  int op;\n+  int op, op_inout;\n   tree t;\n \n   /* Collect the operand name.  */\n@@ -624,18 +624,22 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs, tree labels)\n   *q = '\\0';\n \n   /* Resolve the name to a number.  */\n-  for (op = 0, t = outputs; t ; t = TREE_CHAIN (t), op++)\n+  for (op_inout = op = 0, t = outputs; t ; t = TREE_CHAIN (t), op++)\n     {\n       tree name = TREE_PURPOSE (TREE_PURPOSE (t));\n       if (name && strcmp (TREE_STRING_POINTER (name), p) == 0)\n \tgoto found;\n+      tree constraint = TREE_VALUE (TREE_PURPOSE (t));\n+      if (constraint && strchr (TREE_STRING_POINTER (constraint), '+') != NULL)\n+        op_inout++;\n     }\n   for (t = inputs; t ; t = TREE_CHAIN (t), op++)\n     {\n       tree name = TREE_PURPOSE (TREE_PURPOSE (t));\n       if (name && strcmp (TREE_STRING_POINTER (name), p) == 0)\n \tgoto found;\n     }\n+  op += op_inout;\n   for (t = labels; t ; t = TREE_CHAIN (t), op++)\n     {\n       tree name = TREE_PURPOSE (t);"}, {"sha": "95ad55c81aa11818a7fbe777581518a788212a8d", "filename": "gcc/testsuite/gcc.c-torture/compile/pr98096.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr98096.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d78655a91bb2f89ac4432cfd6374380d6f9987/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr98096.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr98096.c?ref=72d78655a91bb2f89ac4432cfd6374380d6f9987", "patch": "@@ -0,0 +1,10 @@\n+/* Test for correct naming of label operands in asm goto in case of presence of\n+   input/output operands. */\n+/* { dg-do compile } */\n+int i, j;\n+int f(void) {\n+  asm goto (\"# %0 %2\" : \"+r\" (i) ::: jmp);\n+  i += 2;\n+  asm goto (\"# %0 %1 %l[jmp]\" : \"+r\" (i), \"+r\" (j) ::: jmp);\n+ jmp: return i;\n+}"}]}