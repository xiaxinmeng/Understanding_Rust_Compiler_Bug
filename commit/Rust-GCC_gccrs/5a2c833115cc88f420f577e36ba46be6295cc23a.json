{"sha": "5a2c833115cc88f420f577e36ba46be6295cc23a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyYzgzMzExNWNjODhmNDIwZjU3N2UzNmJhNDZiZTYyOTVjYzIzYQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-08-04T10:14:00Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-08-04T10:14:00Z"}, "message": "[AArch64][8/14] Implement TARGET_OPTION_VALID_ATTRIBUTE_P\n\n\t* common/config/aarch64/aarch64-common.c (aarch64_handle_option):\n\tRemove static.  Handle OPT_mgeneral_regs_only,\n\tOPT_mfix_cortex_a53_835769, OPT_mstrict_align,\n\tOPT_momit_leaf_frame_pointer.\n\t* config/aarch64/aarch64.c: Include opts.h and diagnostic.h\n\t(aarch64_attr_opt_type): New enum.\n\t(aarch64_attribute_info): New struct.\n\t(aarch64_handle_attr_arch): New function.\n\t(aarch64_handle_attr_cpu): Likewise.\n\t(aarch64_handle_attr_tune): Likewise.\n\t(aarch64_handle_attr_isa_flags): Likewise.\n\t(aarch64_attributes): New table.\n\t(aarch64_process_one_target_attr): New function.\n\t(num_occurences_in_str): Likewise.\n\t(aarch64_process_target_attr): Likewise.\n\t(aarch64_option_valid_attribute_p): Likewise.\n\t(TARGET_OPTION_VALID_ATTRIBUTE_P): Define.\n\t* config/aarch64/aarch64-protos.h: Include input.h\n\t(aarch64_handle_option): Declare prototype.\n\nFrom-SVN: r226560", "tree": {"sha": "9ed1e08b16d7aa19d73e52f157563335247fac4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ed1e08b16d7aa19d73e52f157563335247fac4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a2c833115cc88f420f577e36ba46be6295cc23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2c833115cc88f420f577e36ba46be6295cc23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2c833115cc88f420f577e36ba46be6295cc23a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2c833115cc88f420f577e36ba46be6295cc23a/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d78006d9504c41f96a476457754563c2aa100b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78006d9504c41f96a476457754563c2aa100b7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78006d9504c41f96a476457754563c2aa100b7a"}], "stats": {"total": 543, "additions": 542, "deletions": 1}, "files": [{"sha": "6344d8571ae913094eda290192578cc3939d89ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a2c833115cc88f420f577e36ba46be6295cc23a", "patch": "@@ -1,3 +1,25 @@\n+2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* common/config/aarch64/aarch64-common.c (aarch64_handle_option):\n+\tRemove static.  Handle OPT_mgeneral_regs_only,\n+\tOPT_mfix_cortex_a53_835769, OPT_mstrict_align,\n+\tOPT_momit_leaf_frame_pointer.\n+\t* config/aarch64/aarch64.c: Include opts.h and diagnostic.h\n+\t(aarch64_attr_opt_type): New enum.\n+\t(aarch64_attribute_info): New struct.\n+\t(aarch64_handle_attr_arch): New function.\n+\t(aarch64_handle_attr_cpu): Likewise.\n+\t(aarch64_handle_attr_tune): Likewise.\n+\t(aarch64_handle_attr_isa_flags): Likewise.\n+\t(aarch64_attributes): New table.\n+\t(aarch64_process_one_target_attr): New function.\n+\t(num_occurences_in_str): Likewise.\n+\t(aarch64_process_target_attr): Likewise.\n+\t(aarch64_option_valid_attribute_p): Likewise.\n+\t(TARGET_OPTION_VALID_ATTRIBUTE_P): Define.\n+\t* config/aarch64/aarch64-protos.h: Include input.h\n+\t(aarch64_handle_option): Declare prototype.\n+\n 2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.h (SWITCHABLE_TARGET): Define."}, {"sha": "726c62531d9b809cc8b0b2aafcb6380627126158", "filename": "gcc/common/config/aarch64/aarch64-common.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c?ref=5a2c833115cc88f420f577e36ba46be6295cc23a", "patch": "@@ -60,14 +60,15 @@ static const struct default_options aarch_option_optimization_table[] =\n    respective component of -mcpu.  This logic is implemented\n    in config/aarch64/aarch64.c:aarch64_override_options.  */\n \n-static bool\n+bool\n aarch64_handle_option (struct gcc_options *opts,\n \t\t       struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n \t\t       const struct cl_decoded_option *decoded,\n \t\t       location_t loc ATTRIBUTE_UNUSED)\n {\n   size_t code = decoded->opt_index;\n   const char *arg = decoded->arg;\n+  int val = decoded->value;\n \n   switch (code)\n     {\n@@ -83,6 +84,22 @@ aarch64_handle_option (struct gcc_options *opts,\n       opts->x_aarch64_tune_string = arg;\n       return true;\n \n+    case OPT_mgeneral_regs_only:\n+      opts->x_target_flags |= MASK_GENERAL_REGS_ONLY;\n+      return true;\n+\n+    case OPT_mfix_cortex_a53_835769:\n+      opts->x_aarch64_fix_a53_err835769 = val;\n+      return true;\n+\n+    case OPT_mstrict_align:\n+      opts->x_target_flags |= MASK_STRICT_ALIGN;\n+      return true;\n+\n+    case OPT_momit_leaf_frame_pointer:\n+      opts->x_flag_omit_frame_pointer = val;\n+      return true;\n+\n     default:\n       return true;\n     }"}, {"sha": "68a6f6e45b52b5743fe67e55111bea56a385f70a", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=5a2c833115cc88f420f577e36ba46be6295cc23a", "patch": "@@ -22,6 +22,8 @@\n #ifndef GCC_AARCH64_PROTOS_H\n #define GCC_AARCH64_PROTOS_H\n \n+#include \"input.h\"\n+\n /*\n   SYMBOL_CONTEXT_ADR\n   The symbol is used in a load-address operation.\n@@ -252,6 +254,8 @@ bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n bool aarch64_gen_movmemqi (rtx *);\n bool aarch64_gimple_fold_builtin (gimple_stmt_iterator *);\n+bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n+\t\t\t     const struct cl_decoded_option *, location_t);\n bool aarch64_is_extend_from_extract (machine_mode, rtx, rtx);\n bool aarch64_is_long_call_p (rtx);\n bool aarch64_label_mentioned_p (rtx);"}, {"sha": "7a369fd47346c74fc2f4782b115981b48bb4998f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2c833115cc88f420f577e36ba46be6295cc23a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5a2c833115cc88f420f577e36ba46be6295cc23a", "patch": "@@ -57,6 +57,8 @@\n #include \"tm_p.h\"\n #include \"recog.h\"\n #include \"langhooks.h\"\n+#include \"opts.h\"\n+#include \"diagnostic.h\"\n #include \"diagnostic-core.h\"\n #include \"internal-fn.h\"\n #include \"gimple-fold.h\"\n@@ -7964,6 +7966,499 @@ aarch64_set_current_function (tree fndecl)\n     }\n }\n \n+/* Enum describing the various ways we can handle attributes.\n+   In many cases we can reuse the generic option handling machinery.  */\n+\n+enum aarch64_attr_opt_type\n+{\n+  aarch64_attr_mask,\t/* Attribute should set a bit in target_flags.  */\n+  aarch64_attr_bool,\t/* Attribute sets or unsets a boolean variable.  */\n+  aarch64_attr_enum,\t/* Attribute sets an enum variable.  */\n+  aarch64_attr_custom\t/* Attribute requires a custom handling function.  */\n+};\n+\n+/* All the information needed to handle a target attribute.\n+   NAME is the name of the attribute.\n+   ATTR_TYPE specifies the type of behaviour of the attribute as described\n+   in the definition of enum aarch64_attr_opt_type.\n+   ALLOW_NEG is true if the attribute supports a \"no-\" form.\n+   HANDLER is the function that takes the attribute string and whether\n+   it is a pragma or attribute and handles the option.  It is needed only\n+   when the ATTR_TYPE is aarch64_attr_custom.\n+   OPT_NUM is the enum specifying the option that the attribute modifies.\n+   This is needed for attributes that mirror the behaviour of a command-line\n+   option, that is it has ATTR_TYPE aarch64_attr_mask, aarch64_attr_bool or\n+   aarch64_attr_enum.  */\n+\n+struct aarch64_attribute_info\n+{\n+  const char *name;\n+  enum aarch64_attr_opt_type attr_type;\n+  bool allow_neg;\n+  bool (*handler) (const char *, const char *);\n+  enum opt_code opt_num;\n+};\n+\n+/* Handle the ARCH_STR argument to the arch= target attribute.\n+   PRAGMA_OR_ATTR is used in potential error messages.  */\n+\n+static bool\n+aarch64_handle_attr_arch (const char *str, const char *pragma_or_attr)\n+{\n+  const struct processor *tmp_arch = NULL;\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_arch (str, &tmp_arch, &aarch64_isa_flags);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    {\n+      gcc_assert (tmp_arch);\n+      selected_arch = tmp_arch;\n+      explicit_arch = selected_arch->arch;\n+      return true;\n+    }\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing architecture name in 'arch' target %s\", pragma_or_attr);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for 'arch' target %s\", str, pragma_or_attr);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_FEATURE:\n+\terror (\"invalid feature modifier %qs for 'arch' target %s\",\n+\t       str, pragma_or_attr);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n+/* Handle the argument CPU_STR to the cpu= target attribute.\n+   PRAGMA_OR_ATTR is used in potential error messages.  */\n+\n+static bool\n+aarch64_handle_attr_cpu (const char *str, const char *pragma_or_attr)\n+{\n+  const struct processor *tmp_cpu = NULL;\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_cpu (str, &tmp_cpu, &aarch64_isa_flags);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    {\n+      gcc_assert (tmp_cpu);\n+      selected_tune = tmp_cpu;\n+      explicit_tune_core = selected_tune->ident;\n+\n+      selected_arch = &all_architectures[tmp_cpu->arch];\n+      explicit_arch = selected_arch->arch;\n+      return true;\n+    }\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing cpu name in 'cpu' target %s\", pragma_or_attr);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for 'cpu' target %s\", str, pragma_or_attr);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_FEATURE:\n+\terror (\"invalid feature modifier %qs for 'cpu' target %s\",\n+\t       str, pragma_or_attr);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n+/* Handle the argument STR to the tune= target attribute.\n+   PRAGMA_OR_ATTR is used in potential error messages.  */\n+\n+static bool\n+aarch64_handle_attr_tune (const char *str, const char *pragma_or_attr)\n+{\n+  const struct processor *tmp_tune = NULL;\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_tune (str, &tmp_tune);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    {\n+      gcc_assert (tmp_tune);\n+      selected_tune = tmp_tune;\n+      explicit_tune_core = selected_tune->ident;\n+      return true;\n+    }\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for 'tune' target %s\", str, pragma_or_attr);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n+/* Parse an architecture extensions target attribute string specified in STR.\n+   For example \"+fp+nosimd\".  Show any errors if needed.  Return TRUE\n+   if successful.  Update aarch64_isa_flags to reflect the ISA features\n+   modified.\n+   PRAGMA_OR_ATTR is used in potential error messages.  */\n+\n+static bool\n+aarch64_handle_attr_isa_flags (char *str, const char *pragma_or_attr)\n+{\n+  enum aarch64_parse_opt_result parse_res;\n+  unsigned long isa_flags = aarch64_isa_flags;\n+\n+  parse_res = aarch64_parse_extension (str, &isa_flags);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    {\n+      aarch64_isa_flags = isa_flags;\n+      return true;\n+    }\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing feature modifier in target %s %qs\",\n+\t       pragma_or_attr, str);\n+\tbreak;\n+\n+      case AARCH64_PARSE_INVALID_FEATURE:\n+\terror (\"invalid feature modifier in target %s %qs\",\n+\t       pragma_or_attr, str);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+ return false;\n+}\n+\n+/* The target attributes that we support.  On top of these we also support just\n+   ISA extensions, like  __attribute__ ((target (\"+crc\"))), but that case is\n+   handled explicitly in aarch64_process_one_target_attr.  */\n+\n+static const struct aarch64_attribute_info aarch64_attributes[] =\n+{\n+  { \"general-regs-only\", aarch64_attr_mask, false, NULL,\n+     OPT_mgeneral_regs_only },\n+  { \"fix-cortex-a53-835769\", aarch64_attr_bool, true, NULL,\n+     OPT_mfix_cortex_a53_835769 },\n+  { \"cmodel\", aarch64_attr_enum, false, NULL, OPT_mcmodel_ },\n+  { \"strict-align\", aarch64_attr_mask, false, NULL, OPT_mstrict_align },\n+  { \"omit-leaf-frame-pointer\", aarch64_attr_bool, true, NULL,\n+     OPT_momit_leaf_frame_pointer },\n+  { \"tls-dialect\", aarch64_attr_enum, false, NULL, OPT_mtls_dialect_ },\n+  { \"arch\", aarch64_attr_custom, false, aarch64_handle_attr_arch,\n+     OPT_march_ },\n+  { \"cpu\", aarch64_attr_custom, false, aarch64_handle_attr_cpu, OPT_mcpu_ },\n+  { \"tune\", aarch64_attr_custom, false, aarch64_handle_attr_tune,\n+     OPT_mtune_ },\n+  { NULL, aarch64_attr_custom, false, NULL, OPT____ }\n+};\n+\n+/* Parse ARG_STR which contains the definition of one target attribute.\n+   Show appropriate errors if any or return true if the attribute is valid.\n+   PRAGMA_OR_ATTR holds the string to use in error messages about whether\n+   we're processing a target attribute or pragma.  */\n+\n+static bool\n+aarch64_process_one_target_attr (char *arg_str, const char* pragma_or_attr)\n+{\n+  bool invert = false;\n+\n+  size_t len = strlen (arg_str);\n+\n+  if (len == 0)\n+    {\n+      error (\"malformed target %s\", pragma_or_attr);\n+      return false;\n+    }\n+\n+  char *str_to_check = (char *) alloca (len + 1);\n+  strcpy (str_to_check, arg_str);\n+\n+  /* Skip leading whitespace.  */\n+  while (*str_to_check == ' ' || *str_to_check == '\\t')\n+    str_to_check++;\n+\n+  /* We have something like __attribute__ ((target (\"+fp+nosimd\"))).\n+     It is easier to detect and handle it explicitly here rather than going\n+     through the machinery for the rest of the target attributes in this\n+     function.  */\n+  if (*str_to_check == '+')\n+    return aarch64_handle_attr_isa_flags (str_to_check, pragma_or_attr);\n+\n+  if (len > 3 && strncmp (str_to_check, \"no-\", 3) == 0)\n+    {\n+      invert = true;\n+      str_to_check += 3;\n+    }\n+  char *arg = strchr (str_to_check, '=');\n+\n+  /* If we found opt=foo then terminate STR_TO_CHECK at the '='\n+     and point ARG to \"foo\".  */\n+  if (arg)\n+    {\n+      *arg = '\\0';\n+      arg++;\n+    }\n+  const struct aarch64_attribute_info *p_attr;\n+  for (p_attr = aarch64_attributes; p_attr->name; p_attr++)\n+    {\n+      /* If the names don't match up, or the user has given an argument\n+\t to an attribute that doesn't accept one, or didn't give an argument\n+\t to an attribute that expects one, fail to match.  */\n+      if (strcmp (str_to_check, p_attr->name) != 0)\n+\tcontinue;\n+\n+      bool attr_need_arg_p = p_attr->attr_type == aarch64_attr_custom\n+\t\t\t      || p_attr->attr_type == aarch64_attr_enum;\n+\n+      if (attr_need_arg_p ^ (arg != NULL))\n+\t{\n+\t  error (\"target %s %qs does not accept an argument\",\n+\t\t  pragma_or_attr, str_to_check);\n+\t  return false;\n+\t}\n+\n+      /* If the name matches but the attribute does not allow \"no-\" versions\n+\t then we can't match.  */\n+      if (invert && !p_attr->allow_neg)\n+\t{\n+\t  error (\"target %s %qs does not allow a negated form\",\n+\t\t  pragma_or_attr, str_to_check);\n+\t  return false;\n+\t}\n+\n+      switch (p_attr->attr_type)\n+\t{\n+\t/* Has a custom handler registered.\n+\t   For example, cpu=, arch=, tune=.  */\n+\t  case aarch64_attr_custom:\n+\t    gcc_assert (p_attr->handler);\n+\t    if (!p_attr->handler (arg, pragma_or_attr))\n+\t      return false;\n+\t    break;\n+\n+\t  /* Either set or unset a boolean option.  */\n+\t  case aarch64_attr_bool:\n+\t    {\n+\t      struct cl_decoded_option decoded;\n+\n+\t      generate_option (p_attr->opt_num, NULL, !invert,\n+\t\t\t       CL_TARGET, &decoded);\n+\t      aarch64_handle_option (&global_options, &global_options_set,\n+\t\t\t\t      &decoded, input_location);\n+\t      break;\n+\t    }\n+\t  /* Set or unset a bit in the target_flags.  aarch64_handle_option\n+\t     should know what mask to apply given the option number.  */\n+\t  case aarch64_attr_mask:\n+\t    {\n+\t      struct cl_decoded_option decoded;\n+\t      /* We only need to specify the option number.\n+\t\t aarch64_handle_option will know which mask to apply.  */\n+\t      decoded.opt_index = p_attr->opt_num;\n+\t      decoded.value = !invert;\n+\t      aarch64_handle_option (&global_options, &global_options_set,\n+\t\t\t\t      &decoded, input_location);\n+\t      break;\n+\t    }\n+\t  /* Use the option setting machinery to set an option to an enum.  */\n+\t  case aarch64_attr_enum:\n+\t    {\n+\t      gcc_assert (arg);\n+\t      bool valid;\n+\t      int value;\n+\t      valid = opt_enum_arg_to_value (p_attr->opt_num, arg,\n+\t\t\t\t\t      &value, CL_TARGET);\n+\t      if (valid)\n+\t\t{\n+\t\t  set_option (&global_options, NULL, p_attr->opt_num, value,\n+\t\t\t      NULL, DK_UNSPECIFIED, input_location,\n+\t\t\t      global_dc);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  error (\"target %s %s=%s is not valid\",\n+\t\t\t pragma_or_attr, str_to_check, arg);\n+\t\t}\n+\t      break;\n+\t    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Count how many times the character C appears in\n+   NULL-terminated string STR.  */\n+\n+static unsigned int\n+num_occurences_in_str (char c, char *str)\n+{\n+  unsigned int res = 0;\n+  while (*str != '\\0')\n+    {\n+      if (*str == c)\n+\tres++;\n+\n+      str++;\n+    }\n+\n+  return res;\n+}\n+\n+/* Parse the tree in ARGS that contains the target attribute information\n+   and update the global target options space.  PRAGMA_OR_ATTR is a string\n+   to be used in error messages, specifying whether this is processing\n+   a target attribute or a target pragma.  */\n+\n+bool\n+aarch64_process_target_attr (tree args, const char* pragma_or_attr)\n+{\n+  if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      do\n+\t{\n+\t  tree head = TREE_VALUE (args);\n+\t  if (head)\n+\t    {\n+\t      if (!aarch64_process_target_attr (head, pragma_or_attr))\n+\t\treturn false;\n+\t    }\n+\t  args = TREE_CHAIN (args);\n+\t} while (args);\n+\n+      return true;\n+    }\n+  /* We expect to find a string to parse.  */\n+  gcc_assert (TREE_CODE (args) == STRING_CST);\n+\n+  size_t len = strlen (TREE_STRING_POINTER (args));\n+  char *str_to_check = (char *) alloca (len + 1);\n+  strcpy (str_to_check, TREE_STRING_POINTER (args));\n+\n+  if (len == 0)\n+    {\n+      error (\"malformed target %s value\", pragma_or_attr);\n+      return false;\n+    }\n+\n+  /* Used to catch empty spaces between commas i.e.\n+     attribute ((target (\"attr1,,attr2\"))).  */\n+  unsigned int num_commas = num_occurences_in_str (',', str_to_check);\n+\n+  /* Handle multiple target attributes separated by ','.  */\n+  char *token = strtok (str_to_check, \",\");\n+\n+  unsigned int num_attrs = 0;\n+  while (token)\n+    {\n+      num_attrs++;\n+      if (!aarch64_process_one_target_attr (token, pragma_or_attr))\n+\t{\n+\t  error (\"target %s %qs is invalid\", pragma_or_attr, token);\n+\t  return false;\n+\t}\n+\n+      token = strtok (NULL, \",\");\n+    }\n+\n+  if (num_attrs != num_commas + 1)\n+    {\n+      error (\"malformed target %s list %qs\",\n+\t      pragma_or_attr, TREE_STRING_POINTER (args));\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Implement TARGET_OPTION_VALID_ATTRIBUTE_P.  This is used to\n+   process attribute ((target (\"...\"))).  */\n+\n+static bool\n+aarch64_option_valid_attribute_p (tree fndecl, tree, tree args, int)\n+{\n+  struct cl_target_option cur_target;\n+  bool ret;\n+  tree old_optimize;\n+  tree new_target, new_optimize;\n+  tree existing_target = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);\n+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+\n+  old_optimize = build_optimization_node (&global_options);\n+  func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+\n+  /* If the function changed the optimization levels as well as setting\n+     target options, start with the optimizations specified.  */\n+  if (func_optimize && func_optimize != old_optimize)\n+    cl_optimization_restore (&global_options,\n+\t\t\t     TREE_OPTIMIZATION (func_optimize));\n+\n+  /* Save the current target options to restore at the end.  */\n+  cl_target_option_save (&cur_target, &global_options);\n+\n+  /* If fndecl already has some target attributes applied to it, unpack\n+     them so that we add this attribute on top of them, rather than\n+     overwriting them.  */\n+  if (existing_target)\n+    {\n+      struct cl_target_option *existing_options\n+\t= TREE_TARGET_OPTION (existing_target);\n+\n+      if (existing_options)\n+\tcl_target_option_restore (&global_options, existing_options);\n+    }\n+  else\n+    cl_target_option_restore (&global_options,\n+\t\t\tTREE_TARGET_OPTION (target_option_current_node));\n+\n+\n+  ret = aarch64_process_target_attr (args, \"attribute\");\n+\n+  /* Set up any additional state.  */\n+  if (ret)\n+    {\n+      aarch64_override_options_internal (&global_options);\n+      new_target = build_target_option_node (&global_options);\n+    }\n+  else\n+    new_target = NULL;\n+\n+  new_optimize = build_optimization_node (&global_options);\n+\n+  if (fndecl && ret)\n+    {\n+      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_target;\n+\n+      if (old_optimize != new_optimize)\n+\tDECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;\n+    }\n+\n+  cl_target_option_restore (&global_options, &cur_target);\n+\n+  if (old_optimize != new_optimize)\n+    cl_optimization_restore (&global_options,\n+\t\t\t     TREE_OPTIMIZATION (old_optimize));\n+  return ret;\n+}\n+\n /* Return true if SYMBOL_REF X binds locally.  */\n \n static bool\n@@ -12478,6 +12973,9 @@ aarch64_promoted_type (const_tree t)\n #undef TARGET_OPTION_PRINT\n #define TARGET_OPTION_PRINT aarch64_option_print\n \n+#undef TARGET_OPTION_VALID_ATTRIBUTE_P\n+#define TARGET_OPTION_VALID_ATTRIBUTE_P aarch64_option_valid_attribute_p\n+\n #undef TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION aarch64_set_current_function\n "}]}