{"sha": "3a74a7bf62f47ed0d19866576378724be932ee17", "node_id": "C_kwDOANBUbNoAKDNhNzRhN2JmNjJmNDdlZDBkMTk4NjY1NzYzNzg3MjRiZTkzMmVlMTc", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-15T11:56:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-15T11:56:57Z"}, "message": "ifcvt: Fix up noce_convert_multiple_sets [PR106590]\n\nThe following testcase is miscompiled on x86_64-linux.\nThe problem is in the noce_convert_multiple_sets optimization.\nWe essentially have:\nif (g == 1)\n  {\n    g = 1;\n    f = 23;\n  }\nelse\n  {\n    g = 2;\n    f = 20;\n  }\nand for each insn try to create a conditional move sequence.\nThere is code to detect overlap with the regs used in the condition\nand the destinations, so we actually try to construct:\ntmp_g = g == 1 ? 1 : 2;\nf = g == 1 ? 23 : 20;\ng = tmp_g;\nwhich is fine.  But, we actually try to create two different\nconditional move sequences in each case, seq1 with the whole\n(eq (reg/v:HI 82 [ g ]) (const_int 1 [0x1]))\ncondition and seq2 with cc_cmp\n(eq (reg:CCZ 17 flags) (const_int 0 [0]))\nto rely on the earlier present comparison.  In each case, we\ncompare the rtx costs and choose the cheaper sequence (seq1 if both\nhave the same cost).\nThe problem is that with the skylake tuning,\ntmp_g = g == 1 ? 1 : 2;\nis actually expanded as\ntmp_g = (g == 1) + 1;\nin seq1 (which clobbers (reg 17 flags)) and as a cmov in seq2\n(which doesn't).  The tuning says both have the same cost, so we\npick seq1.  Next we check sequences for\nf = g == 1 ? 23 : 20; and here the seq2 cmov is cheaper, but it\nuses (reg 17 flags) which has been clobbered earlier.\n\nThe following patch fixes that by detecting if we in the chosen\nsequence clobber some register mentioned in cc_cmp or rev_cc_cmp,\nand if yes, arranges for only seq1 (i.e. sequences that emit the\ncomparison itself) to be used after that.\n\n2022-08-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/106590\n\t* ifcvt.cc (check_for_cc_cmp_clobbers): New function.\n\t(noce_convert_multiple_sets_1): If SEQ sets or clobbers any regs\n\tmentioned in cc_cmp or rev_cc_cmp, don't consider seq2 for any\n\tfurther conditional moves.\n\n\t* gcc.dg/torture/pr106590.c: New test.", "tree": {"sha": "4ed5f3d89d7919549aa5e59a9a3a935c9cffb1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed5f3d89d7919549aa5e59a9a3a935c9cffb1ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a74a7bf62f47ed0d19866576378724be932ee17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a74a7bf62f47ed0d19866576378724be932ee17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a74a7bf62f47ed0d19866576378724be932ee17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a74a7bf62f47ed0d19866576378724be932ee17/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6624ad73064de241e937e97a28b65c50fe14c78e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6624ad73064de241e937e97a28b65c50fe14c78e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6624ad73064de241e937e97a28b65c50fe14c78e"}], "stats": {"total": 116, "additions": 112, "deletions": 4}, "files": [{"sha": "eb8efb89a89770fb7c9e930bf282d8159824b905", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a74a7bf62f47ed0d19866576378724be932ee17/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a74a7bf62f47ed0d19866576378724be932ee17/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=3a74a7bf62f47ed0d19866576378724be932ee17", "patch": "@@ -3369,6 +3369,20 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   return TRUE;\n }\n \n+/* Helper function for noce_convert_multiple_sets_1.  If store to\n+   DEST can affect P[0] or P[1], clear P[0].  Called via note_stores.  */\n+\n+static void\n+check_for_cc_cmp_clobbers (rtx dest, const_rtx, void *p0)\n+{\n+  rtx *p = (rtx *) p0;\n+  if (p[0] == NULL_RTX)\n+    return;\n+  if (reg_overlap_mentioned_p (dest, p[0])\n+      || (p[1] && reg_overlap_mentioned_p (dest, p[1])))\n+    p[0] = NULL_RTX;\n+}\n+\n /* This goes through all relevant insns of IF_INFO->then_bb and tries to\n    create conditional moves.  In case a simple move sufficis the insn\n    should be listed in NEED_NO_CMOV.  The rewired-src cases should be\n@@ -3519,7 +3533,7 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n \n \t as min/max and emit an insn, accordingly.  */\n       unsigned cost1 = 0, cost2 = 0;\n-      rtx_insn *seq, *seq1, *seq2;\n+      rtx_insn *seq, *seq1, *seq2 = NULL;\n       rtx temp_dest = NULL_RTX, temp_dest1 = NULL_RTX, temp_dest2 = NULL_RTX;\n       bool read_comparison = false;\n \n@@ -3531,9 +3545,10 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n \t as well.  This allows the backend to emit a cmov directly without\n \t creating an additional compare for each.  If successful, costing\n \t is easier and this sequence is usually preferred.  */\n-      seq2 = try_emit_cmove_seq (if_info, temp, cond,\n-\t\t\t\t new_val, old_val, need_cmov,\n-\t\t\t\t &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);\n+      if (cc_cmp)\n+\tseq2 = try_emit_cmove_seq (if_info, temp, cond,\n+\t\t\t\t   new_val, old_val, need_cmov,\n+\t\t\t\t   &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);\n \n       /* The backend might have created a sequence that uses the\n \t condition.  Check this.  */\n@@ -3588,6 +3603,24 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n \t  return FALSE;\n \t}\n \n+      if (cc_cmp)\n+\t{\n+\t  /* Check if SEQ can clobber registers mentioned in\n+\t     cc_cmp and/or rev_cc_cmp.  If yes, we need to use\n+\t     only seq1 from that point on.  */\n+\t  rtx cc_cmp_pair[2] = { cc_cmp, rev_cc_cmp };\n+\t  for (walk = seq; walk; walk = NEXT_INSN (walk))\n+\t    {\n+\t      note_stores (walk, check_for_cc_cmp_clobbers, cc_cmp_pair);\n+\t      if (cc_cmp_pair[0] == NULL_RTX)\n+\t\t{\n+\t\t  cc_cmp = NULL_RTX;\n+\t\t  rev_cc_cmp = NULL_RTX;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n       /* End the sub sequence and emit to the main sequence.  */\n       emit_insn (seq);\n "}, {"sha": "b7b847201487f6b1c4a94107accd0f9600f1353a", "filename": "gcc/testsuite/gcc.dg/torture/pr106590.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a74a7bf62f47ed0d19866576378724be932ee17/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106590.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a74a7bf62f47ed0d19866576378724be932ee17/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106590.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106590.c?ref=3a74a7bf62f47ed0d19866576378724be932ee17", "patch": "@@ -0,0 +1,75 @@\n+/* PR rtl-optimization/106590 } */\n+/* { dg-do run } */\n+/* { dg-additional-options \"-mtune=skylake\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+typedef struct A { short a; } A;\n+typedef A *B;\n+typedef struct C { int c, d; } C;\n+typedef C *D;\n+\n+B\n+foo (void)\n+{\n+  static A r = { .a = 1 };\n+  return &r;\n+}\n+\n+D\n+bar (void)\n+{\n+  static C r = { .c = 1, .d = 23 };\n+  return &r;\n+}\n+\n+static inline int __attribute__((always_inline))\n+baz (short a)\n+{\n+  int e = 1, f;\n+  short g;\n+  D h;\n+\n+  switch (a)\n+    {\n+    case 1:\n+      f = 23;\n+      g = 1;\n+      break;\n+    case 2:\n+      f = 20;\n+      g = 2;\n+      break;\n+    }\n+\n+  h = bar ();\n+\n+  if (h->d != f || h->c != g)\n+    __builtin_abort ();\n+  return e;\n+}\n+\n+int\n+qux (void)\n+{\n+  B i = foo ();\n+  int e = 1;\n+\n+  switch (i->a)\n+    {\n+    case 1:\n+    case 2:\n+      e = baz (i->a);\n+      break;\n+    case 3:\n+      e = 0;\n+      break;\n+    }\n+\n+  return e;\n+}\n+\n+int\n+main ()\n+{\n+  qux ();\n+  return 0;\n+}"}]}