{"sha": "87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdhYjJiMDRhZTE5OTdiNWI5MGY1ZGQxMTQ5NGYyMTg2ZWU0ZjNhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-06-26T10:03:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-06-26T10:03:22Z"}, "message": "trans.c (loop_info_d): Add low_bound...\n\n\t* gcc-interface/trans.c (loop_info_d): Add low_bound, high_bound,\n\tartificial, has_checks and warned_aggressive_loop_optimizations.\n\t(gigi): Set warn_aggressive_loop_optimizations to 0.\n\t(inside_loop_p): New inline predicate.\n\t(push_range_check_info): Rename into...\n\t(find_loop_for): ...this and do not push range_check_info_d object.\n\t(Loop_Statement_to_gnu): Set artificial, low_bound and high_bound\n\tfields of gnu_loop_info.  Adjust detection of checks enabled by\n\t-funswitch-loops and adds one for -faggressive-loop-optimizations.\n\t(gnat_to_gnu) <N_Indexed_Component>: If aggressive loop optimizations\n\tare enabled, warn for loops overrunning an array of size 1 not at the\n\tend of a record.\n\nFrom-SVN: r224998", "tree": {"sha": "02d1c7bd4feb8917b2ba8c73342c9d9ba436756f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02d1c7bd4feb8917b2ba8c73342c9d9ba436756f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/comments", "author": null, "committer": null, "parents": [{"sha": "63be509029db0b15f445400c75722862cf252b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63be509029db0b15f445400c75722862cf252b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63be509029db0b15f445400c75722862cf252b25"}], "stats": {"total": 179, "additions": 161, "deletions": 18}, "files": [{"sha": "b2319aa0d5b1505fa0bec18cd09d7181c0321ecd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -1,3 +1,18 @@\n+2015-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (loop_info_d): Add low_bound, high_bound,\n+\tartificial, has_checks and warned_aggressive_loop_optimizations.\n+\t(gigi): Set warn_aggressive_loop_optimizations to 0.\n+\t(inside_loop_p): New inline predicate.\n+\t(push_range_check_info): Rename into...\n+\t(find_loop_for): ...this and do not push range_check_info_d object.\n+\t(Loop_Statement_to_gnu): Set artificial, low_bound and high_bound\n+\tfields of gnu_loop_info.  Adjust detection of checks enabled by\n+\t-funswitch-loops and adds one for -faggressive-loop-optimizations.\n+\t(gnat_to_gnu) <N_Indexed_Component>: If aggressive loop optimizations\n+\tare enabled, warn for loops overrunning an array of size 1 not at the\n+\tend of a record.\n+\n 2015-06-25  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gcc-interface/trans.c: Remove ipa-ref.h and plugin-api.h from include"}, {"sha": "ff910cec343810e5bfd79bfa4fe9a1978c2610ba", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -209,7 +209,12 @@ typedef struct range_check_info_d *range_check_info;\n struct GTY(()) loop_info_d {\n   tree stmt;\n   tree loop_var;\n+  tree low_bound;\n+  tree high_bound;\n   vec<range_check_info, va_gc> *checks;\n+  bool artificial;\n+  bool has_checks;\n+  bool warned_aggressive_loop_optimizations;\n };\n \n typedef struct loop_info_d *loop_info;\n@@ -671,6 +676,10 @@ gigi (Node_Id gnat_root,\n   /* Now translate the compilation unit proper.  */\n   Compilation_Unit_to_gnu (gnat_root);\n \n+  /* Disable -Waggressive-loop-optimizations since we implement our own\n+     version of the warning.  */\n+  warn_aggressive_loop_optimizations = 0;\n+\n   /* Then process the N_Validate_Unchecked_Conversion nodes.  We do this at\n      the very end to avoid having to second-guess the front-end when we run\n      into dummy nodes during the regular processing.  */\n@@ -2622,12 +2631,19 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n-/* Find out whether VAR is an iteration variable of an enclosing loop in the\n-   current function.  If so, push a range_check_info structure onto the stack\n-   of this enclosing loop and return it.  Otherwise, return NULL.  */\n+/* Return true if we are in the body of a loop.  */\n+\n+static inline bool\n+inside_loop_p (void)\n+{\n+  return !vec_safe_is_empty (gnu_loop_stack);\n+}\n+\n+/* Find out whether VAR is the iteration variable of an enclosing loop in the\n+   current function.  If so, return the loop; otherwise, return NULL.  */\n \n-static struct range_check_info_d *\n-push_range_check_info (tree var)\n+static struct loop_info_d *\n+find_loop_for (tree var)\n {\n   struct loop_info_d *iter = NULL;\n   unsigned int i;\n@@ -2648,14 +2664,7 @@ push_range_check_info (tree var)\n     if (var == iter->loop_var)\n       break;\n \n-  if (iter)\n-    {\n-      struct range_check_info_d *rci = ggc_alloc<range_check_info_d> ();\n-      vec_safe_push (iter->checks, rci);\n-      return rci;\n-    }\n-\n-  return NULL;\n+  return iter;\n }\n \n /* Return true if VAL (of type TYPE) can equal the minimum value if MAX is\n@@ -2746,6 +2755,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n   /* Save the statement for later reuse.  */\n   gnu_loop_info->stmt = gnu_loop_stmt;\n+  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2941,6 +2951,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t  SET_DECL_INDUCTION_VAR (gnu_loop_var, gnu_loop_iv);\n \t}\n       gnu_loop_info->loop_var = gnu_loop_var;\n+      gnu_loop_info->low_bound = gnu_low;\n+      gnu_loop_info->high_bound = gnu_high;\n \n       /* Do all the arithmetics in the base type.  */\n       gnu_loop_var = convert (gnu_base_type, gnu_loop_var);\n@@ -5334,7 +5346,7 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t{\n \t  Node_Id gnat_range, gnat_index, gnat_type;\n \t  tree gnu_index, gnu_low_bound, gnu_high_bound;\n-\t  struct range_check_info_d *rci;\n+\t  struct loop_info_d *loop;\n \n \t  switch (Nkind (Right_Opnd (gnat_cond)))\n \t    {\n@@ -5382,24 +5394,36 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t     one of which has the checks eliminated and the other has\n \t     the original checks reinstated, and a run time selection.\n \t     The former loop will be suitable for vectorization.  */\n-\t  if (flag_unswitch_loops\n-\t      && !vec_safe_is_empty (gnu_loop_stack)\n+\t  if (optimize\n+\t      && flag_unswitch_loops\n+\t      && inside_loop_p ()\n \t      && (!gnu_low_bound\n \t\t  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))\n \t      && (!gnu_high_bound\n \t\t  || (gnu_high_bound = gnat_invariant_expr (gnu_high_bound)))\n-\t      && (rci = push_range_check_info (gnu_index)))\n+\t      && (loop = find_loop_for (gnu_index)))\n \t    {\n+\t      struct range_check_info_d *rci = ggc_alloc<range_check_info_d> ();\n \t      rci->low_bound = gnu_low_bound;\n \t      rci->high_bound = gnu_high_bound;\n \t      rci->type = get_unpadded_type (gnat_type);\n \t      rci->invariant_cond = build1 (SAVE_EXPR, boolean_type_node,\n \t\t\t\t\t    boolean_true_node);\n+\t      vec_safe_push (loop->checks, rci);\n+\t      loop->has_checks = true;\n \t      gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n \t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t  rci->invariant_cond,\n \t\t\t\t\t  gnat_to_gnu (gnat_cond));\n \t    }\n+\n+\t  /* Or else, if aggressive loop optimizations are enabled, we just\n+\t     record that there are checks applied to iteration variables.  */\n+\t  else if (optimize\n+\t\t   && flag_aggressive_loop_optimizations\n+\t\t   && inside_loop_p ()\n+\t\t   && (loop = find_loop_for (gnu_index)))\n+\t    loop->has_checks = true;\n \t}\n       break;\n \n@@ -5939,11 +5963,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnat_expr_array[i] = gnat_temp;\n \n \tfor (i = 0, gnu_type = TREE_TYPE (gnu_array_object);\n-\t     i < ndim; i++, gnu_type = TREE_TYPE (gnu_type))\n+\t     i < ndim;\n+\t     i++, gnu_type = TREE_TYPE (gnu_type))\n \t  {\n \t    gcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \t    gnat_temp = gnat_expr_array[i];\n \t    gnu_expr = gnat_to_gnu (gnat_temp);\n+\t    struct loop_info_d *loop;\n \n \t    if (Do_Range_Check (gnat_temp))\n \t      gnu_expr\n@@ -5965,6 +5991,31 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t&& !(Nkind (gnat_temp) == N_Identifier\n \t\t     && Ekind (Entity (gnat_temp)) == E_Constant))\n \t      TREE_THIS_NOTRAP (gnu_result) = 1;\n+\n+\t    /* If aggressive loop optimizations are enabled, we warn for loops\n+\t       overrunning a simple array of size 1 not at the end of a record.\n+\t       This is aimed to catch misuses of the trailing array idiom.  */\n+\t    if (optimize\n+\t\t&& flag_aggressive_loop_optimizations\n+\t\t&& inside_loop_p ()\n+\t\t&& TREE_CODE (TREE_TYPE (gnu_type)) != ARRAY_TYPE\n+\t\t&& TREE_CODE (gnu_array_object) != ARRAY_REF\n+\t\t&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),\n+\t\t\t\t       TYPE_MAX_VALUE (TYPE_DOMAIN (gnu_type)))\n+\t\t&& !array_at_struct_end_p (gnu_result)\n+\t\t&& (loop = find_loop_for (skip_simple_arithmetic (gnu_expr)))\n+\t\t&& !loop->artificial\n+\t\t&& !loop->has_checks\n+\t\t&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),\n+\t\t\t\t       loop->low_bound)\n+\t\t&& can_be_lower_p (loop->low_bound, loop->high_bound)\n+\t\t&& !loop->warned_aggressive_loop_optimizations\n+\t\t&& warning (OPT_Waggressive_loop_optimizations,\n+\t\t\t    \"out-of-bounds access may be optimized away\"))\n+\t      {\n+\t\tinform (EXPR_LOCATION (loop->stmt), \"containing loop\");\n+\t\tloop->warned_aggressive_loop_optimizations = true;\n+\t      }\n \t  }\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));"}, {"sha": "e3ae30a0a38f934540c3786ad6e1f61c45040d19", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -1,3 +1,9 @@\n+2015-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/warn11.adb: Add missing dg directive.\n+\t* gnat.dg/warn12.adb: New test.\n+\t* gnat.dg/warn12_pkg.ads: New helper.\n+\n 2015-06-26  Richard Biener  <rguenther@suse.de>\n \n \t* gfortran.dg/reassoc_3.f90: Adjust."}, {"sha": "e92835f0533c03b84c75ddc2f7087a4266e06f3a", "filename": "gcc/testsuite/gnat.dg/warn11.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn11.adb?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -1,3 +1,5 @@\n+-- { dg-do compile }\n+\n with Ada.Text_IO; use Ada.Text_IO;\n \n procedure Warn11 is"}, {"sha": "8ffd0c7dff082e9e9665bb4a5b2b05b1ffa03721", "filename": "gcc/testsuite/gnat.dg/warn12.adb", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12.adb?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -0,0 +1,48 @@\n+-- { dg-do compile }\r\n+-- { dg-options \"-O2\" }\r\n+\r\n+with Text_IO; use Text_IO;\r\n+with System.Storage_Elements; use System.Storage_Elements;\r\n+with Warn12_Pkg; use Warn12_Pkg;\r\n+\r\n+procedure Warn12 (N : Natural) is\r\n+\r\n+   Buffer_Size : constant Storage_Offset\r\n+      := Token_Groups'Size/System.Storage_Unit + 4096;\r\n+\r\n+   Buffer : Storage_Array (1 .. Buffer_Size);\r\n+   for Buffer'Alignment use 8;\r\n+\r\n+   Tg1 : Token_Groups;\r\n+   for Tg1'Address use Buffer'Address;\r\n+\r\n+   Tg2 : Token_Groups;\r\n+   pragma Warnings (Off, Tg2);\r\n+\r\n+   sid : Sid_And_Attributes;\r\n+\r\n+   pragma Suppress (Index_Check, Sid_And_Attributes_Array);\r\n+\r\n+begin\r\n+\r\n+   for I in 0 .. 7 loop\r\n+      sid :=  Tg1.Groups(I);  -- { dg-bogus \"out-of-bounds access\" }\r\n+      Put_Line(\"Iteration\");\r\n+   end loop;\r\n+\r\n+   for I in 0 .. N loop\r\n+      sid :=  Tg1.Groups(I);  -- { dg-bogus \"out-of-bounds access\" }\r\n+      Put_Line(\"Iteration\");\r\n+   end loop;\r\n+\r\n+   for I in 0 .. 7 loop\r\n+      sid :=  Tg2.Groups(I);  -- { dg-warning \"out-of-bounds access\" }\r\n+      Put_Line(\"Iteration\");\r\n+   end loop;\r\n+\r\n+   for I in 0 .. N loop\r\n+      sid :=  Tg2.Groups(I);  -- { dg-warning \"out-of-bounds access\" }\r\n+      Put_Line(\"Iteration\");\r\n+   end loop;\r\n+\r\n+end;\r"}, {"sha": "b3191cc304f6eae5930f338628111dace962066a", "filename": "gcc/testsuite/gnat.dg/warn12_pkg.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn12_pkg.ads?ref=87ab2b04ae1997b5b90f5dd11494f2186ee4f3a8", "patch": "@@ -0,0 +1,21 @@\n+with Interfaces.C; use Interfaces.C;\n+with System;\n+\n+package Warn12_Pkg is\n+\n+   Anysize_Array: constant := 0;\n+\n+   type Sid_And_Attributes is record\n+      Sid        : System.Address;\n+      Attributes : Interfaces.C.Unsigned_Long;\n+   end record;\n+\n+   type Sid_And_Attributes_Array\n+      is array (Integer range 0..Anysize_Array) of aliased Sid_And_Attributes;\n+\n+   type Token_Groups is record\n+      GroupCount : Interfaces.C.Unsigned_Long;\n+      Groups     : Sid_And_Attributes_Array;\n+   end record;\n+\n+end Warn12_Pkg;"}]}