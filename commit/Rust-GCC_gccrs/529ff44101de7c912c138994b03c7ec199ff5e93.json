{"sha": "529ff44101de7c912c138994b03c7ec199ff5e93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5ZmY0NDEwMWRlN2M5MTJjMTM4OTk0YjAzYzdlYzE5OWZmNWU5Mw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-05-06T16:49:13Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-05-06T16:49:13Z"}, "message": "re PR middle-end/40021 (Revision 146817 miscompiled DAXPY in BLAS)\n\n        PR middle-end/40021\n        * cfgexpand.c (maybe_cleanup_end_of_block): New static function.\n        (expand_gimple_cond): Use it to cleanup CFG and superfluous jumps.\n\n        * gfortran.dg/pr40021.f: New test.\n\nFrom-SVN: r147186", "tree": {"sha": "e95e93d5d2478bbf0f22d4f48c411f8243fe28ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e95e93d5d2478bbf0f22d4f48c411f8243fe28ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/529ff44101de7c912c138994b03c7ec199ff5e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529ff44101de7c912c138994b03c7ec199ff5e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/529ff44101de7c912c138994b03c7ec199ff5e93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529ff44101de7c912c138994b03c7ec199ff5e93/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c"}], "stats": {"total": 115, "additions": 100, "deletions": 15}, "files": [{"sha": "f6ec8624fb9026c2785b1c4aabdfab08da8d9bc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=529ff44101de7c912c138994b03c7ec199ff5e93", "patch": "@@ -1,3 +1,9 @@\n+2009-05-06  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/40021\n+\t* cfgexpand.c (maybe_cleanup_end_of_block): New static function.\n+\t(expand_gimple_cond): Use it to cleanup CFG and superfluous jumps.\n+\n 2009-05-06  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* Makefile.in (install-plugin): Fix srcdir handling."}, {"sha": "ab9464fdcb54d3e75f53fc06e98b63da5fb24063", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=529ff44101de7c912c138994b03c7ec199ff5e93", "patch": "@@ -1724,6 +1724,52 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n }\n \n \n+/* A subroutine of expand_gimple_cond.  Given E, a fallthrough edge\n+   of a basic block where we just expanded the conditional at the end,\n+   possibly clean up the CFG and instruction sequence.  */\n+\n+static void\n+maybe_cleanup_end_of_block (edge e)\n+{\n+  /* Special case: when jumpif decides that the condition is\n+     trivial it emits an unconditional jump (and the necessary\n+     barrier).  But we still have two edges, the fallthru one is\n+     wrong.  purge_dead_edges would clean this up later.  Unfortunately\n+     we have to insert insns (and split edges) before\n+     find_many_sub_basic_blocks and hence before purge_dead_edges.\n+     But splitting edges might create new blocks which depend on the\n+     fact that if there are two edges there's no barrier.  So the\n+     barrier would get lost and verify_flow_info would ICE.  Instead\n+     of auditing all edge splitters to care for the barrier (which\n+     normally isn't there in a cleaned CFG), fix it here.  */\n+  if (BARRIER_P (get_last_insn ()))\n+    {\n+      basic_block bb = e->src;\n+      rtx insn;\n+      remove_edge (e);\n+      /* Now, we have a single successor block, if we have insns to\n+\t insert on the remaining edge we potentially will insert\n+\t it at the end of this block (if the dest block isn't feasible)\n+\t in order to avoid splitting the edge.  This insertion will take\n+\t place in front of the last jump.  But we might have emitted\n+\t multiple jumps (conditional and one unconditional) to the\n+\t same destination.  Inserting in front of the last one then\n+\t is a problem.  See PR 40021.  We fix this by deleting all\n+\t jumps except the last unconditional one.  */\n+      insn = PREV_INSN (get_last_insn ());\n+      /* Make sure we have an unconditional jump.  Otherwise we're\n+\t confused.  */\n+      gcc_assert (JUMP_P (insn) && !any_condjump_p (insn));\n+      for (insn = PREV_INSN (insn); insn != BB_HEAD (bb);)\n+\t{\n+\t  insn = PREV_INSN (insn);\n+\t  if (JUMP_P (NEXT_INSN (insn)))\n+\t    delete_insn (NEXT_INSN (insn));\n+\t}\n+    }\n+}\n+\n+\n /* A subroutine of expand_gimple_basic_block.  Expand one GIMPLE_COND.\n    Returns a new basic block if we've terminated the current basic\n    block and created a new one.  */\n@@ -1767,19 +1813,7 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       true_edge->goto_block = NULL;\n       false_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n-      /* Special case: when jumpif decides that the condition is\n-         trivial it emits an unconditional jump (and the necessary\n-\t barrier).  But we still have two edges, the fallthru one is\n-\t wrong.  purge_dead_edges would clean this up later.  Unfortunately\n-\t we have to insert insns (and split edges) before\n-\t find_many_sub_basic_blocks and hence before purge_dead_edges.\n-\t But splitting edges might create new blocks which depend on the\n-\t fact that if there are two edges there's no barrier.  So the\n-\t barrier would get lost and verify_flow_info would ICE.  Instead\n-\t of auditing all edge splitters to care for the barrier (which\n-\t normally isn't there in a cleaned CFG), fix it here.  */\n-      if (BARRIER_P (get_last_insn ()))\n-\tremove_edge (false_edge);\n+      maybe_cleanup_end_of_block (false_edge);\n       return NULL;\n     }\n   if (true_edge->dest == bb->next_bb)\n@@ -1796,8 +1830,7 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       false_edge->goto_block = NULL;\n       true_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n-      if (BARRIER_P (get_last_insn ()))\n-\tremove_edge (true_edge);\n+      maybe_cleanup_end_of_block (true_edge);\n       return NULL;\n     }\n "}, {"sha": "b4abbedc4f3b8e393bbbaf73bd2c3107ccd19a7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=529ff44101de7c912c138994b03c7ec199ff5e93", "patch": "@@ -1,3 +1,7 @@\n+2009-05-06  Michael Matz  <matz@suse.de>\n+\n+\t* gfortran.dg/pr40021.f: New test.\n+\n 2009-05-06  Le-Chun Wu  <lcwu@google.com>\n \n \t* lib/plugin-support.exp: New file containing support procs for"}, {"sha": "6d3f44de4df8a5e5fa6e6b2c80d4a277dea23fac", "filename": "gcc/testsuite/gfortran.dg/pr40021.f", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr40021.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529ff44101de7c912c138994b03c7ec199ff5e93/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr40021.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr40021.f?ref=529ff44101de7c912c138994b03c7ec199ff5e93", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run { target i?86-*-* x86_64-*-* } }\n+! { dg-require-effective-target ilp32 }\n+! { dg-options \"-O2 -ftree-vectorize -msse2 -mfpmath=sse -ffast-math\" }\n+        PROGRAM test\n+        DOUBLE PRECISION DA\n+        INTEGER I, N\n+        DOUBLE PRECISION DX(9),DY(9)\n+\n+        EXTERNAL DAXPY\n+        N=5\n+        DA=1.0\n+        DATA DX/-2, -1, -3, -4, 1, 2, 10, 15, 14/\n+        DATA DY/0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0/\n+        CALL DAXPY (N,DA,DX,DY)\n+        DO 10 I = 1, N\n+          if (DX(I).ne.DY(I)) call abort\n+10      CONTINUE\n+        STOP\n+        END\n+\n+      SUBROUTINE DAXPY(N,DA,DX,DY)\n+      DOUBLE PRECISION DA\n+      INTEGER N\n+      DOUBLE PRECISION DX(*),DY(*)\n+      INTEGER I,IX,IY,M,MP1\n+      INTRINSIC MOD\n+      IF (N.LE.0) RETURN\n+   20 M = MOD(N,4)\n+      IF (M.EQ.0) GO TO 40\n+      DO 30 I = 1,M\n+          DY(I) = DY(I) + DA*DX(I)\n+   30 CONTINUE\n+      IF (N.LT.4) RETURN\n+   40 MP1 = M + 1\n+      DO 50 I = MP1,N,4\n+          DY(I) = DY(I) + DA*DX(I)\n+          DY(I+1) = DY(I+1) + DA*DX(I+1)\n+          DY(I+2) = DY(I+2) + DA*DX(I+2)\n+          DY(I+3) = DY(I+3) + DA*DX(I+3)\n+   50 CONTINUE\n+      RETURN\n+      END"}]}