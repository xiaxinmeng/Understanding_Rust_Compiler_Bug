{"sha": "4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjMGZkZDJmYTczYjJkNDA5YWE1OWQxZWY1OTcwYjMzMjg0NGZhZA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-02-11T03:52:28Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-02-11T03:52:28Z"}, "message": "reload1.c (first_label_num): New.\n\n\t* reload1.c (first_label_num): New.\n\t(reload): Index offsets_known_at and offsets_at using difference of\n\tlabel number and first label number.  Don't use offset pointers.\n\t(set_label_offsets, set_initial_label_offsets): Likewise.\n\nFrom-SVN: r62672", "tree": {"sha": "fc5cebd932bae4239dc5bd39c2b8bb1ce9d8d083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc5cebd932bae4239dc5bd39c2b8bb1ce9d8d083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad/comments", "author": null, "committer": null, "parents": [{"sha": "44b1fa1152d5a382080da9d0391f0630a72becb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b1fa1152d5a382080da9d0391f0630a72becb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b1fa1152d5a382080da9d0391f0630a72becb5"}], "stats": {"total": 57, "additions": 30, "deletions": 27}, "files": [{"sha": "a4a047f1839e2391815c9c01ce5b0d199ae78fcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "patch": "@@ -1,3 +1,10 @@\n+2003-02-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* reload1.c (first_label_num): New.\n+\t(reload): Index offsets_known_at and offsets_at using difference of\n+\tlabel number and first label number.  Don't use offset pointers.\n+\t(set_label_offsets, set_initial_label_offsets): Likewise.\n+\n 2003-02-10  Roger Sayle  <roger@eyesopen.com>\n \n \t* mips-tfile.c (init_file): Add missing initializers in the"}, {"sha": "e2726409330501aebd810697db17471e0977b45a", "filename": "gcc/reload1.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc0fdd2fa73b2d409aa59d1ef5970b332844fad/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4cc0fdd2fa73b2d409aa59d1ef5970b332844fad", "patch": "@@ -354,11 +354,14 @@ static int num_eliminable_invariants;\n \n /* For each label, we record the offset of each elimination.  If we reach\n    a label by more than one path and an offset differs, we cannot do the\n-   elimination.  This information is indexed by the number of the label.\n-   The first table is an array of flags that records whether we have yet\n-   encountered a label and the second table is an array of arrays, one\n-   entry in the latter array for each elimination.  */\n-\n+   elimination.  This information is indexed by the difference of the\n+   number of the label and the first label number.  We can't offset the\n+   pointer itself as this can cause problems on machines with segmented\n+   memory.  The first table is an array of flags that records whether we\n+   have yet encountered a label and the second table is an array of arrays,\n+   one entry in the latter array for each elimination.  */\n+\n+static int first_label_num;\n static char *offsets_known_at;\n static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n@@ -675,11 +678,6 @@ reload (first, global)\n   struct elim_table *ep;\n   basic_block bb;\n \n-  /* The two pointers used to track the true location of the memory used\n-     for label offsets.  */\n-  char *real_known_ptr = NULL;\n-  int (*real_at_ptr)[NUM_ELIMINABLE_REGS];\n-\n   /* Make sure even insns with volatile mem refs are recognizable.  */\n   init_recog ();\n \n@@ -858,21 +856,18 @@ reload (first, global)\n \n   init_elim_table ();\n \n-  num_labels = max_label_num () - get_first_label_num ();\n+  first_label_num = get_first_label_num ();\n+  num_labels = max_label_num () - first_label_num;\n \n   /* Allocate the tables used to store offset information at labels.  */\n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause a core dump.  */\n-  real_known_ptr = xmalloc (num_labels);\n-  real_at_ptr\n+  offsets_known_at = xmalloc (num_labels);\n+  offsets_at\n     = (int (*)[NUM_ELIMINABLE_REGS])\n     xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (int));\n \n-  offsets_known_at = real_known_ptr - get_first_label_num ();\n-  offsets_at\n-    = (int (*)[NUM_ELIMINABLE_REGS]) (real_at_ptr - get_first_label_num ());\n-\n   /* Alter each pseudo-reg rtx to contain its hard reg number.\n      Assign stack slots to the pseudos that lack hard regs or equivalents.\n      Do not touch virtual registers.  */\n@@ -1271,10 +1266,10 @@ reload (first, global)\n     free (reg_equiv_memory_loc);\n   reg_equiv_memory_loc = 0;\n \n-  if (real_known_ptr)\n-    free (real_known_ptr);\n-  if (real_at_ptr)\n-    free (real_at_ptr);\n+  if (offsets_known_at)\n+    free (offsets_known_at);\n+  if (offsets_at)\n+    free (offsets_at);\n \n   free (reg_equiv_mem);\n   free (reg_equiv_init);\n@@ -2160,13 +2155,13 @@ set_label_offsets (x, insn, initial_p)\n \t we guessed wrong, we will suppress an elimination that might have\n \t been possible had we been able to guess correctly.  */\n \n-      if (! offsets_known_at[CODE_LABEL_NUMBER (x)])\n+      if (! offsets_known_at[CODE_LABEL_NUMBER (x) - first_label_num])\n \t{\n \t  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t    offsets_at[CODE_LABEL_NUMBER (x)][i]\n+\t    offsets_at[CODE_LABEL_NUMBER (x) - first_label_num][i]\n \t      = (initial_p ? reg_eliminate[i].initial_offset\n \t\t : reg_eliminate[i].offset);\n-\t  offsets_known_at[CODE_LABEL_NUMBER (x)] = 1;\n+\t  offsets_known_at[CODE_LABEL_NUMBER (x) - first_label_num] = 1;\n \t}\n \n       /* Otherwise, if this is the definition of a label and it is\n@@ -2183,7 +2178,7 @@ set_label_offsets (x, insn, initial_p)\n \t   where the offsets disagree.  */\n \n \tfor (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t  if (offsets_at[CODE_LABEL_NUMBER (x)][i]\n+\t  if (offsets_at[CODE_LABEL_NUMBER (x) - first_label_num][i]\n \t      != (initial_p ? reg_eliminate[i].initial_offset\n \t\t  : reg_eliminate[i].offset))\n \t    reg_eliminate[i].can_eliminate = 0;\n@@ -3399,7 +3394,7 @@ static void\n set_initial_label_offsets ()\n {\n   rtx x;\n-  memset ((char *) &offsets_known_at[get_first_label_num ()], 0, num_labels);\n+  memset (offsets_known_at, 0, num_labels);\n \n   for (x = forced_labels; x; x = XEXP (x, 1))\n     if (XEXP (x, 0))\n@@ -3420,7 +3415,8 @@ set_offsets_for_label (insn)\n   num_not_at_initial_offset = 0;\n   for (i = 0, ep = reg_eliminate; i < NUM_ELIMINABLE_REGS; ep++, i++)\n     {\n-      ep->offset = ep->previous_offset = offsets_at[label_nr][i];\n+      ep->offset = ep->previous_offset\n+\t\t = offsets_at[label_nr - first_label_num][i];\n       if (ep->can_eliminate && ep->offset != ep->initial_offset)\n \tnum_not_at_initial_offset++;\n     }"}]}