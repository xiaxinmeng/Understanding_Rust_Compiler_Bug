{"sha": "f27c1867108c24557452bc6ea11196c7e7f09801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3YzE4NjcxMDhjMjQ1NTc0NTJiYzZlYTExMTk2YzdlN2YwOTgwMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-08-13T02:37:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-08-13T02:37:51Z"}, "message": "tree-pass.h (write_summary, [...]): Remove set and vset arguments.\n\n\n\t* tree-pass.h (write_summary, write_optimization_summary): Remove\n\tset and vset arguments.\n\t* ipa-cp.c (ipcp_write_summary): Remove set and vset arugments.\n\t(write_node_summary_p): Likewise; use the encoder.\n\t(ipa_reference_write_optimization_summary): Likewise.\n\t* lto-cgraph.c (output_cgraph_opt_summary): Use encoder.\n\t(lto_symtab_encoder_new): Initialize in_partition field.\n\t(lto_symtab_encoder_delete): Destroy in_partition field.\n\t(LCC_NOT_FOUND): Move to lto-streamer.h\n\t(lto_symtab_encoder_deref): Likewise.\n\t(lto_symtab_encoder_in_partition_p,\n\tlto_set_symtab_encoder_in_partition): New functions.\n\t(referenced_from_other_partition_p): Rewrite to use encoder.\n\t(reachable_from_other_partition_p): Likewise.\n\t(referenced_from_this_partition_p): Likewise.\n\t(reachable_from_this_partition_p): Likewise.\n\t(lto_output_node): Likewise.\n\t(lto_output_varpool_node): Likewise.\n\t(output_refs): Likewise.\n\t(compute_ltrans_boundary): Initialize in_partition fileds of\n\tthe encoder.\n\t(output_symtab): Likewise.\n\t(input_refs): Match the changes in output_refs.\n\t(output_cgraph_opt_summary_p): Remove set argument.\n\t(output_node_opt_summary): Replace set by encoder.\n\t(output_cgraph_opt_summary): Remove set argument; use\n\tthe encoder.\n\t* ipa-pure-const.c (pure_const_write_summary): Remove set and vset\n\targuments; use the encoder.\n\t* lto-streamer-out.c (lto_output): Remove set and vset argument; use\n\tthe encoder.\n\t(produce_symtab): Likewise.\n\t* ipa-inline.h (inline_write_summary): Remove set and vset arguments.\n\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n\t* ipa-prop.c (ipa_prop_write_jump_functions): Remove set argument;\n\tuse encoder.\n\t* ipa-prop.h (ipa_prop_write_jump_functions): Likewise.\n\t* passes.c (ipa_write_summaries_2): Remove set and vset arguments.\n\t(ipa_write_summaries_1): Update.\n\t(ipa_write_optimization_summaries_1): Likewise.\n\t(ipa_write_optimization_summaries): Likewise.\n\t* lto-streamer.h (lto_symtab_encoder_t): Add in_partition.\n\t(lto_symtab_encoder_iterator): New type.\n\t(lto_symtab_encoder_deref): Make inline.\n\t(output_symtab, referenced_from_other_partition_p,\n\treachable_from_other_partition_p, referenced_from_this_partition_p,\n\treachable_from_this_partition_p): Update.\n\t(lsei_end_p, lsei_next, lsei_node, lsei_cgraph_node, lsei_varpool_node): New\n\tinline functions.\n\t(LCC_NOT_FOUND): New macro.\n\t(lto_symtab_encoder_deref, lsei_start, lsei_next_in_partition,\n\tlsei_start_in_partition, lsei_next_function_in_partition,\n\tlsei_start_function_in_partition, lsei_next_variable_in_partition,\n\tlsei_start_variable_in_partition): New inline functions.\n\n\t* lto-partition.c (set_referenced_from_other_partition_p,\n\tset_reachable_from_other_partition_p, set_referenced_from_this_partition_p):\n\tNew functions.\n\t(lto_promote_cross_file_statics): Use them.\n\nFrom-SVN: r190336", "tree": {"sha": "45f40f7cd77f92dcd298eb5c790cad79a92c02be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45f40f7cd77f92dcd298eb5c790cad79a92c02be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f27c1867108c24557452bc6ea11196c7e7f09801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27c1867108c24557452bc6ea11196c7e7f09801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27c1867108c24557452bc6ea11196c7e7f09801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27c1867108c24557452bc6ea11196c7e7f09801/comments", "author": null, "committer": null, "parents": [{"sha": "56142d02b398b0a1b1d7ca1bcb3dbb291c597a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56142d02b398b0a1b1d7ca1bcb3dbb291c597a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56142d02b398b0a1b1d7ca1bcb3dbb291c597a30"}], "stats": {"total": 611, "additions": 422, "deletions": 189}, "files": [{"sha": "0108a0d3a7b37896500135b8bdc1a4c985a4b588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -1,3 +1,60 @@\n+2012-08-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (write_summary, write_optimization_summary): Remove\n+\tset and vset arguments.\n+\t* ipa-cp.c (ipcp_write_summary): Remove set and vset arugments.\n+\t(write_node_summary_p): Likewise; use the encoder.\n+\t(ipa_reference_write_optimization_summary): Likewise.\n+\t* lto-cgraph.c (output_cgraph_opt_summary): Use encoder.\n+\t(lto_symtab_encoder_new): Initialize in_partition field.\n+\t(lto_symtab_encoder_delete): Destroy in_partition field.\n+\t(LCC_NOT_FOUND): Move to lto-streamer.h\n+\t(lto_symtab_encoder_deref): Likewise.\n+\t(lto_symtab_encoder_in_partition_p,\n+\tlto_set_symtab_encoder_in_partition): New functions.\n+\t(referenced_from_other_partition_p): Rewrite to use encoder.\n+\t(reachable_from_other_partition_p): Likewise.\n+\t(referenced_from_this_partition_p): Likewise.\n+\t(reachable_from_this_partition_p): Likewise.\n+\t(lto_output_node): Likewise.\n+\t(lto_output_varpool_node): Likewise.\n+\t(output_refs): Likewise.\n+\t(compute_ltrans_boundary): Initialize in_partition fileds of\n+\tthe encoder.\n+\t(output_symtab): Likewise.\n+\t(input_refs): Match the changes in output_refs.\n+\t(output_cgraph_opt_summary_p): Remove set argument.\n+\t(output_node_opt_summary): Replace set by encoder.\n+\t(output_cgraph_opt_summary): Remove set argument; use\n+\tthe encoder.\n+\t* ipa-pure-const.c (pure_const_write_summary): Remove set and vset\n+\targuments; use the encoder.\n+\t* lto-streamer-out.c (lto_output): Remove set and vset argument; use\n+\tthe encoder.\n+\t(produce_symtab): Likewise.\n+\t* ipa-inline.h (inline_write_summary): Remove set and vset arguments.\n+\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n+\t* ipa-prop.c (ipa_prop_write_jump_functions): Remove set argument;\n+\tuse encoder.\n+\t* ipa-prop.h (ipa_prop_write_jump_functions): Likewise.\n+\t* passes.c (ipa_write_summaries_2): Remove set and vset arguments.\n+\t(ipa_write_summaries_1): Update.\n+\t(ipa_write_optimization_summaries_1): Likewise.\n+\t(ipa_write_optimization_summaries): Likewise.\n+\t* lto-streamer.h (lto_symtab_encoder_t): Add in_partition.\n+\t(lto_symtab_encoder_iterator): New type.\n+\t(lto_symtab_encoder_deref): Make inline.\n+\t(output_symtab, referenced_from_other_partition_p,\n+\treachable_from_other_partition_p, referenced_from_this_partition_p,\n+\treachable_from_this_partition_p): Update.\n+\t(lsei_end_p, lsei_next, lsei_node, lsei_cgraph_node, lsei_varpool_node): New\n+\tinline functions.\n+\t(LCC_NOT_FOUND): New macro.\n+\t(lto_symtab_encoder_deref, lsei_start, lsei_next_in_partition,\n+\tlsei_start_in_partition, lsei_next_function_in_partition,\n+\tlsei_start_function_in_partition, lsei_next_variable_in_partition,\n+\tlsei_start_variable_in_partition): New inline functions.\n+\n 2012-08-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.md (prefetch): Simplify expander.  Fix condition to"}, {"sha": "ef9569e8009cdb83c570c3e00273c7e7b62cf824", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -2508,10 +2508,9 @@ ipcp_generate_summary (void)\n /* Write ipcp summary for nodes in SET.  */\n \n static void\n-ipcp_write_summary (cgraph_node_set set,\n-\t\t    varpool_node_set vset ATTRIBUTE_UNUSED)\n+ipcp_write_summary (void)\n {\n-  ipa_prop_write_jump_functions (set);\n+  ipa_prop_write_jump_functions ();\n }\n \n /* Read ipcp summary.  */"}, {"sha": "f19f1f78d5a9264f36afb033d1c44a0062cdfe61", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -3358,8 +3358,7 @@ write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n    active, we don't need to write them twice.  */\n \n void\n-inline_write_summary (cgraph_node_set set,\n-\t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n+inline_write_summary (void)\n {\n   struct cgraph_node *node;\n   symtab_node snode;\n@@ -3426,7 +3425,7 @@ inline_write_summary (cgraph_node_set set,\n   destroy_output_block (ob);\n \n   if (optimize && !flag_ipa_cp)\n-    ipa_prop_write_jump_functions (set);\n+    ipa_prop_write_jump_functions ();\n }\n \n "}, {"sha": "6bcbb94834c2c9c53b036c4a8cc1bd8a319748aa", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -171,7 +171,7 @@ void dump_inline_summaries (FILE *f);\n void dump_inline_summary (FILE * f, struct cgraph_node *node);\n void inline_generate_summary (void);\n void inline_read_summary (void);\n-void inline_write_summary (cgraph_node_set, varpool_node_set);\n+void inline_write_summary (void);\n void inline_free_summary (void);\n void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);"}, {"sha": "21a74933bdf18b1803668c41c7a8ae679107858a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -3391,21 +3391,25 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n /* Write jump functions for nodes in SET.  */\n \n void\n-ipa_prop_write_jump_functions (cgraph_node_set set)\n+ipa_prop_write_jump_functions (void)\n {\n   struct cgraph_node *node;\n   struct output_block *ob;\n   unsigned int count = 0;\n-  cgraph_node_set_iterator csi;\n+  lto_symtab_encoder_iterator lsei;\n+  lto_symtab_encoder_t encoder;\n+\n \n   if (!ipa_node_params_vector)\n     return;\n \n   ob = create_output_block (LTO_section_jump_functions);\n+  encoder = ob->decl_state->symtab_node_encoder;\n   ob->cgraph_node = NULL;\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       if (cgraph_function_with_gimple_body_p (node)\n \t  && IPA_NODE_REF (node) != NULL)\n \tcount++;\n@@ -3414,9 +3418,10 @@ ipa_prop_write_jump_functions (cgraph_node_set set)\n   streamer_write_uhwi (ob, count);\n \n   /* Process all of the functions.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       if (cgraph_function_with_gimple_body_p (node)\n \t  && IPA_NODE_REF (node) != NULL)\n         ipa_write_node_info (ob, node);"}, {"sha": "3ef0dc79cdbf023ed1a684258fd1219727c7258c", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -590,7 +590,7 @@ ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n \t\t\t\t\t\t ipa_parm_adjustment_vec);\n void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n \n-void ipa_prop_write_jump_functions (cgraph_node_set set);\n+void ipa_prop_write_jump_functions (void);\n void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);"}, {"sha": "905ae3bece5191ee08e686953d480009cc7eb376", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -935,28 +935,32 @@ generate_summary (void)\n /* Serialize the ipa info for lto.  */\n \n static void\n-pure_const_write_summary (cgraph_node_set set,\n-\t\t\t  varpool_node_set vset ATTRIBUTE_UNUSED)\n+pure_const_write_summary (void)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob\n     = lto_create_simple_output_block (LTO_section_ipa_pure_const);\n   unsigned int count = 0;\n-  cgraph_node_set_iterator csi;\n+  lto_symtab_encoder_iterator lsei;\n+  lto_symtab_encoder_t encoder;\n \n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  encoder = lto_get_out_decl_state ()->symtab_node_encoder;\n+\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       if (node->analyzed && has_function_state (node))\n \tcount++;\n     }\n \n   streamer_write_uhwi_stream (ob->main_stream, count);\n \n   /* Process all of the functions.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       if (node->analyzed && has_function_state (node))\n \t{\n \t  struct bitpack_d bp;"}, {"sha": "0d2ef287576b9b2feaf820b671d0940e6489e5f5", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -956,8 +956,7 @@ propagate (void)\n \n static bool\n write_node_summary_p (struct cgraph_node *node,\n-\t\t      cgraph_node_set set,\n-\t\t      varpool_node_set vset,\n+\t\t      lto_symtab_encoder_t encoder,\n \t\t      bitmap ltrans_statics)\n {\n   ipa_reference_optimization_summary_t info;\n@@ -976,8 +975,8 @@ write_node_summary_p (struct cgraph_node *node,\n \n      In future we might also want to include summaries of functions references\n      by initializers of constant variables references in current unit.  */\n-  if (!reachable_from_this_partition_p (node, set)\n-      && !referenced_from_this_partition_p (&node->symbol.ref_list, set, vset))\n+  if (!reachable_from_this_partition_p (node, encoder)\n+      && !referenced_from_this_partition_p (&node->symbol.ref_list, encoder))\n     return false;\n \n   /* See if the info has non-empty intersections with vars we want to encode.  */\n@@ -1025,8 +1024,7 @@ stream_out_bitmap (struct lto_simple_output_block *ob,\n /* Serialize the ipa info for lto.  */\n \n static void\n-ipa_reference_write_optimization_summary (cgraph_node_set set,\n-\t\t\t\t\t  varpool_node_set vset)\n+ipa_reference_write_optimization_summary (void)\n {\n   struct cgraph_node *node;\n   symtab_node snode;\n@@ -1049,7 +1047,7 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \tcontinue;\n       vnode = varpool (snode);\n       if (bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n-\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset))\n+\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, encoder))\n \t{\n \t  tree decl = vnode->symbol.decl;\n \t  bitmap_set_bit (ltrans_statics, DECL_UID (decl));\n@@ -1064,7 +1062,7 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n \t  && write_node_summary_p (cgraph (snode),\n-\t\t\t\tset, vset, ltrans_statics))\n+\t\t\t\t   encoder, ltrans_statics))\n \t  count++;\n \n   streamer_write_uhwi_stream (ob->main_stream, count);\n@@ -1080,7 +1078,7 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \tif (!symtab_function_p (snode))\n \t  continue;\n \tnode = cgraph (snode);\n-\tif (write_node_summary_p (node, set, vset, ltrans_statics))\n+\tif (write_node_summary_p (node, encoder, ltrans_statics))\n \t  {\n \t    ipa_reference_optimization_summary_t info;\n \t    int node_ref;"}, {"sha": "c08d09987790d83853dbadd20439915acc2f49fb", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 69, "deletions": 119, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"gcov-io.h\"\n \n-static void output_cgraph_opt_summary (cgraph_node_set set);\n+static void output_cgraph_opt_summary (void);\n static void input_cgraph_opt_summary (VEC (symtab_node, heap) * nodes);\n \n /* Number of LDPR values known to GCC.  */\n@@ -82,6 +82,7 @@ lto_symtab_encoder_new (void)\n   encoder->nodes = NULL;\n   encoder->body = pointer_set_create ();\n   encoder->initializer = pointer_set_create ();\n+  encoder->in_partition = pointer_set_create ();\n   return encoder;\n }\n \n@@ -95,6 +96,7 @@ lto_symtab_encoder_delete (lto_symtab_encoder_t encoder)\n    pointer_map_destroy (encoder->map);\n    pointer_set_destroy (encoder->body);\n    pointer_set_destroy (encoder->initializer);\n+   pointer_set_destroy (encoder->in_partition);\n    free (encoder);\n }\n \n@@ -124,7 +126,6 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n   return ref;\n }\n \n-#define LCC_NOT_FOUND\t(-1)\n \n /* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n    or LCC_NOT_FOUND if it is not there.  */\n@@ -138,18 +139,6 @@ lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n }\n \n \n-/* Return the cgraph node corresponding to REF using ENCODER.  */\n-\n-symtab_node\n-lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n-{\n-  if (ref == LCC_NOT_FOUND)\n-    return NULL;\n-\n-  return VEC_index (symtab_node, encoder->nodes, ref);\n-}\n-\n-\n /* Return TRUE if we should encode initializer of NODE (if any).  */\n \n bool\n@@ -186,6 +175,25 @@ lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n   pointer_set_insert (encoder->initializer, node);\n }\n \n+/* Return TRUE if we should encode initializer of NODE (if any).  */\n+\n+bool\n+lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t encoder,\n+\t\t\t\t   symtab_node node)\n+{\n+  return pointer_set_contains (encoder->in_partition, node);\n+}\n+\n+/* Return TRUE if we should encode body of NODE (if any).  */\n+\n+void\n+lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t encoder,\n+\t\t\t\t     symtab_node node)\n+{\n+  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+  pointer_set_insert (encoder->in_partition, node);\n+}\n+\n /* Output the cgraph EDGE to OB using ENCODER.  */\n \n static void\n@@ -248,34 +256,23 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n /* Return if LIST contain references from other partitions.  */\n \n bool\n-referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n-\t\t\t\t   varpool_node_set vset)\n+referenced_from_other_partition_p (struct ipa_ref_list *list, lto_symtab_encoder_t encoder)\n {\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n-      if (symtab_function_p (ref->referring))\n-\t{\n-\t  if (ipa_ref_referring_node (ref)->symbol.in_other_partition\n-\t      || !cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n-\t    return true;\n-\t}\n-      else\n-\t{\n-\t  if (ipa_ref_referring_varpool_node (ref)->symbol.in_other_partition\n-\t      || !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n-\t\t\t\t         vset))\n-\t    return true;\n-\t}\n+      if (ref->referring->symbol.in_other_partition\n+          || !lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n+\treturn true;\n     }\n   return false;\n }\n \n /* Return true when node is reachable from other partition.  */\n \n bool\n-reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n+reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t encoder)\n {\n   struct cgraph_edge *e;\n   if (!node->analyzed)\n@@ -284,44 +281,33 @@ reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->caller->symbol.in_other_partition\n-\t|| !cgraph_node_in_set_p (e->caller, set))\n+\t|| !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)e->caller))\n       return true;\n   return false;\n }\n \n /* Return if LIST contain references from other partitions.  */\n \n bool\n-referenced_from_this_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n-\t\t\t\t  varpool_node_set vset)\n+referenced_from_this_partition_p (struct ipa_ref_list *list,\n+\t\t\t\t  lto_symtab_encoder_t encoder)\n {\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n-    {\n-      if (symtab_function_p (ref->referring))\n-\t{\n-\t  if (cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n-\t    return true;\n-\t}\n-      else\n-\t{\n-\t  if (varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n-\t\t\t\t     vset))\n-\t    return true;\n-\t}\n-    }\n+    if (lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n+      return true;\n   return false;\n }\n \n /* Return true when node is reachable from other partition.  */\n \n bool\n-reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n+reachable_from_this_partition_p (struct cgraph_node *node, lto_symtab_encoder_t encoder)\n {\n   struct cgraph_edge *e;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (cgraph_node_in_set_p (e->caller, set))\n+    if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node)e->caller))\n       return true;\n   return false;\n }\n@@ -336,8 +322,7 @@ reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n \n static void\n lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n-\t\t lto_symtab_encoder_t encoder, cgraph_node_set set,\n-\t\t varpool_node_set vset)\n+\t\t lto_symtab_encoder_t encoder)\n {\n   unsigned int tag;\n   struct bitpack_d bp;\n@@ -346,7 +331,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bool in_other_partition = false;\n   struct cgraph_node *clone_of;\n \n-  boundary_p = !cgraph_node_in_set_p (node, set);\n+  boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n \n   if (node->analyzed && !boundary_p)\n     tag = LTO_symtab_analyzed_node;\n@@ -436,9 +421,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n \t\t && !DECL_EXTERNAL (node->symbol.decl)\n \t\t && !DECL_COMDAT (node->symbol.decl)\n-\t\t && (reachable_from_other_partition_p (node, set)\n+\t\t && (reachable_from_other_partition_p (node, encoder)\n \t\t     || referenced_from_other_partition_p (&node->symbol.ref_list,\n-\t\t\t\t\t\t\t   set, vset)), 1);\n+\t\t\t\t\t\t\t   encoder)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n   /* Real aliases in a boundary become non-aliases. However we still stream\n@@ -482,10 +467,10 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n-\t\t\t lto_symtab_encoder_t encoder,\n-\t\t         cgraph_node_set set, varpool_node_set vset)\n+\t\t\t lto_symtab_encoder_t encoder)\n {\n-  bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n+  bool boundary_p = (node->analyzed\n+\t\t     && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node));\n   struct bitpack_d bp;\n   int ref;\n \n@@ -514,7 +499,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     {\n       bp_pack_value (&bp, node->analyzed\n \t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n-\t\t\t\t\t\t\t   set, vset), 1);\n+\t\t\t\t\t\t\t   encoder), 1);\n       bp_pack_value (&bp, boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n \t  /* in_other_partition.  */\n     }\n@@ -624,48 +609,27 @@ output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n /* Output the part of the cgraph in SET.  */\n \n static void\n-output_refs (cgraph_node_set set, varpool_node_set vset,\n-\t     lto_symtab_encoder_t encoder)\n+output_refs (lto_symtab_encoder_t encoder)\n {\n-  cgraph_node_set_iterator csi;\n-  varpool_node_set_iterator vsi;\n+  lto_symtab_encoder_iterator lsei;\n   struct lto_simple_output_block *ob;\n   int count;\n   struct ipa_ref *ref;\n   int i;\n \n   ob = lto_create_simple_output_block (LTO_section_refs);\n \n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    {\n-      struct cgraph_node *node = csi_node (csi);\n-\n-      count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n-      if (count)\n-\t{\n-\t  streamer_write_uhwi_stream (ob->main_stream, count);\n-\t  streamer_write_uhwi_stream (ob->main_stream,\n-\t\t\t\t     lto_symtab_encoder_lookup (encoder, \n-\t\t\t\t\t\t\t\t(symtab_node)node));\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n-\t\t\t\t\t\t      i, ref); i++)\n-\t    lto_output_ref (ob, ref, encoder);\n-\t}\n-    }\n-\n-  streamer_write_uhwi_stream (ob->main_stream, 0);\n-\n-  for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+  for (lsei = lsei_start_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_in_partition (&lsei))\n     {\n-      struct varpool_node *node = vsi_node (vsi);\n+      symtab_node node = lsei_node (lsei);\n \n       count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n       if (count)\n \t{\n \t  streamer_write_uhwi_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n-\t\t\t\t     lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t\t\t\t\t(symtab_node)node));\n+\t\t\t\t     lto_symtab_encoder_lookup (encoder, node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n \t\t\t\t\t\t      i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder);\n@@ -697,13 +661,14 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n     {\n       node = csi_node (csi);\n       add_node_to (encoder, node, true);\n+      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n       add_references (encoder, &node->symbol.ref_list);\n     }\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n       struct varpool_node *vnode = vsi_node (vsi);\n       gcc_assert (!vnode->alias || vnode->alias_of);\n-      lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n+      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       add_references (encoder, &vnode->symbol.ref_list);\n     }\n@@ -750,17 +715,17 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n /* Output the part of the symtab in SET and VSET.  */\n \n void\n-output_symtab (cgraph_node_set set, varpool_node_set vset)\n+output_symtab (void)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob;\n-  cgraph_node_set_iterator csi;\n+  lto_symtab_encoder_iterator lsei;\n   int i, n_nodes;\n   lto_symtab_encoder_t encoder;\n   static bool asm_nodes_output = false;\n \n   if (flag_wpa)\n-    output_cgraph_opt_summary (set);\n+    output_cgraph_opt_summary ();\n \n   ob = lto_create_simple_output_block (LTO_section_symtab_nodes);\n \n@@ -779,17 +744,17 @@ output_symtab (cgraph_node_set set, varpool_node_set vset)\n     {\n       symtab_node node = lto_symtab_encoder_deref (encoder, i);\n       if (symtab_function_p (node))\n-        lto_output_node (ob, cgraph (node), encoder, set, vset);\n+        lto_output_node (ob, cgraph (node), encoder);\n       else\n-        lto_output_varpool_node (ob, varpool (node), encoder,\n-\t\t\t         set, vset);\n+        lto_output_varpool_node (ob, varpool (node), encoder);\n \t\n     }\n \n   /* Go over the nodes in SET again to write edges.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       output_outgoing_cgraph_edges (node->callees, ob, encoder);\n       output_outgoing_cgraph_edges (node->indirect_calls, ob, encoder);\n     }\n@@ -808,7 +773,7 @@ output_symtab (cgraph_node_set set, varpool_node_set vset)\n       lto_output_toplevel_asms ();\n     }\n \n-  output_refs (set, vset, encoder);\n+  output_refs (encoder);\n }\n \n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n@@ -1170,29 +1135,15 @@ input_refs (struct lto_input_block *ib,\n   int idx;\n   while (true)\n     {\n-      struct cgraph_node *node;\n+      symtab_node node;\n       count = streamer_read_uhwi (ib);\n       if (!count)\n \tbreak;\n       idx = streamer_read_uhwi (ib);\n-      node = cgraph (VEC_index (symtab_node, nodes, idx));\n-      while (count)\n-\t{\n-\t  input_ref (ib, (symtab_node) node, nodes);\n-\t  count--;\n-\t}\n-    }\n-  while (true)\n-    {\n-      struct varpool_node *node;\n-      count = streamer_read_uhwi (ib);\n-      if (!count)\n-\tbreak;\n-      node = varpool (VEC_index (symtab_node, nodes,\n-\t\t      streamer_read_uhwi (ib)));\n+      node = VEC_index (symtab_node, nodes, idx);\n       while (count)\n \t{\n-\t  input_ref (ib, (symtab_node) node, nodes);\n+\t  input_ref (ib, node, nodes);\n \t  count--;\n \t}\n     }\n@@ -1362,8 +1313,7 @@ input_symtab (void)\n /* True when we need optimization summary for NODE.  */\n \n static int\n-output_cgraph_opt_summary_p (struct cgraph_node *node,\n-\t\t\t     cgraph_node_set set ATTRIBUTE_UNUSED)\n+output_cgraph_opt_summary_p (struct cgraph_node *node)\n {\n   return (node->clone_of\n \t  && (node->clone.tree_map\n@@ -1383,7 +1333,7 @@ output_edge_opt_summary (struct output_block *ob ATTRIBUTE_UNUSED,\n static void\n output_node_opt_summary (struct output_block *ob,\n \t\t\t struct cgraph_node *node,\n-\t\t\t cgraph_node_set set)\n+\t\t\t lto_symtab_encoder_t encoder)\n {\n   unsigned int index;\n   bitmap_iterator bi;\n@@ -1430,7 +1380,7 @@ output_node_opt_summary (struct output_block *ob,\n       streamer_write_bitpack (&bp);\n     }\n \n-  if (cgraph_node_in_set_p (node, set))\n+  if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node) node))\n     {\n       for (e = node->callees; e; e = e->next_callee)\n \toutput_edge_opt_summary (ob, e);\n@@ -1443,7 +1393,7 @@ output_node_opt_summary (struct output_block *ob,\n    At the moment it is the clone info structure.  */\n \n static void\n-output_cgraph_opt_summary (cgraph_node_set set)\n+output_cgraph_opt_summary (void)\n {\n   symtab_node node;\n   int i, n_nodes;\n@@ -1456,17 +1406,17 @@ output_cgraph_opt_summary (cgraph_node_set set)\n   n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     if (symtab_function_p (node = lto_symtab_encoder_deref (encoder, i))\n-\t&& output_cgraph_opt_summary_p (cgraph (node), set))\n+\t&& output_cgraph_opt_summary_p (cgraph (node)))\n       count++;\n   streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n       node = lto_symtab_encoder_deref (encoder, i);\n       if (symtab_function_p (node)\n-\t  && output_cgraph_opt_summary_p (cgraph (node), set))\n+\t  && output_cgraph_opt_summary_p (cgraph (node)))\n \t{\n \t  streamer_write_uhwi (ob, i);\n-\t  output_node_opt_summary (ob, cgraph (node), set);\n+\t  output_node_opt_summary (ob, cgraph (node), encoder);\n \t}\n     }\n   produce_asm (ob, NULL);"}, {"sha": "f5532d039a78f36914a2b1e9dc3375293ca27de8", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -973,7 +973,7 @@ copy_function (struct cgraph_node *node)\n /* Main entry point from the pass manager.  */\n \n static void\n-lto_output (cgraph_node_set set, varpool_node_set vset)\n+lto_output (void)\n {\n   struct cgraph_node *node;\n   struct lto_out_decl_state *decl_state;\n@@ -1018,7 +1018,7 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n      be done now to make sure that all the statements in every function\n      have been renumbered so that edges can be associated with call\n      statements using the statement UIDs.  */\n-  output_symtab (set, vset);\n+  output_symtab ();\n \n #ifdef ENABLE_CHECKING\n   lto_bitmap_free (output);\n@@ -1388,8 +1388,7 @@ produce_symtab (struct output_block *ob)\n    recover these on other side.  */\n \n static void\n-produce_asm_for_decls (cgraph_node_set set ATTRIBUTE_UNUSED,\n-\t\t       varpool_node_set vset ATTRIBUTE_UNUSED)\n+produce_asm_for_decls (void)\n {\n   struct lto_out_decl_state *out_state;\n   struct lto_out_decl_state *fn_out_state;"}, {"sha": "bed408aef0a92c4aa101a15d609f6c113f065b50", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 162, "deletions": 14, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -433,17 +433,21 @@ struct lto_symtab_encoder_d\n   struct pointer_set_t *body;\n   /* Map of nodes where we want to output initializer.  */\n   struct pointer_set_t *initializer;\n+  /* Map of nodes in this partition.  */\n+  struct pointer_set_t *in_partition;\n };\n \n typedef struct lto_symtab_encoder_d *lto_symtab_encoder_t;\n \n-/* Return number of encoded nodes in ENCODER.  */\n-\n-static inline int\n-lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n+/* Iterator structure for cgraph node sets.  */\n+typedef struct\n {\n-  return VEC_length (symtab_node, encoder->nodes);\n-}\n+  lto_symtab_encoder_t encoder;\n+  unsigned index;\n+} lto_symtab_encoder_iterator;\n+\n+\n+\n \n /* Mapping from indices to trees.  */\n struct GTY(()) lto_tree_ref_table\n@@ -808,28 +812,29 @@ void lto_output_location (struct output_block *, location_t);\n \n \n /* In lto-cgraph.c  */\n-symtab_node lto_symtab_encoder_deref (lto_symtab_encoder_t, int);\n int lto_symtab_encoder_lookup (lto_symtab_encoder_t, symtab_node);\n lto_symtab_encoder_t lto_symtab_encoder_new (void);\n int lto_symtab_encoder_encode (lto_symtab_encoder_t, symtab_node);\n void lto_symtab_encoder_delete (lto_symtab_encoder_t);\n bool lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t,\n \t\t\t\t       struct cgraph_node *);\n+bool lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t,\n+\t\t\t\t\tsymtab_node);\n+void lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t,\n+\t\t\t\t\t  symtab_node);\n \n bool lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t,\n \t\t\t\t\t      struct varpool_node *);\n-void output_symtab (cgraph_node_set, varpool_node_set);\n+void output_symtab (void);\n void input_symtab (void);\n bool referenced_from_other_partition_p (struct ipa_ref_list *,\n-\t\t\t\t        cgraph_node_set,\n-\t\t\t\t        varpool_node_set vset);\n+\t\t\t\t        lto_symtab_encoder_t);\n bool reachable_from_other_partition_p (struct cgraph_node *,\n-\t\t\t\t       cgraph_node_set);\n+\t\t\t\t       lto_symtab_encoder_t);\n bool referenced_from_this_partition_p (struct ipa_ref_list *,\n-\t\t\t\t        cgraph_node_set,\n-\t\t\t\t        varpool_node_set vset);\n+\t\t\t\t\tlto_symtab_encoder_t);\n bool reachable_from_this_partition_p (struct cgraph_node *,\n-\t\t\t\t       cgraph_node_set);\n+\t\t\t\t      lto_symtab_encoder_t);\n void compute_ltrans_boundary (struct lto_out_decl_state *state,\n \t\t\t      cgraph_node_set, varpool_node_set);\n \n@@ -985,6 +990,149 @@ emit_label_in_global_context_p (tree label)\n   return DECL_NONLOCAL (label) || FORCED_LABEL (label);\n }\n \n+/* Return number of encoded nodes in ENCODER.  */\n+static inline int\n+lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n+{\n+  return VEC_length (symtab_node, encoder->nodes);\n+}\n+\n+/* Return true if iterator LSE points to nothing.  */\n+static inline bool\n+lsei_end_p (lto_symtab_encoder_iterator lsei)\n+{\n+  return lsei.index >= (unsigned)lto_symtab_encoder_size (lsei.encoder);\n+}\n+\n+/* Advance iterator LSE.  */\n+static inline void\n+lsei_next (lto_symtab_encoder_iterator *lsei)\n+{\n+  lsei->index++;\n+}\n+\n+/* Return the node pointed to by LSI.  */\n+static inline symtab_node\n+lsei_node (lto_symtab_encoder_iterator lsei)\n+{\n+  return VEC_index (symtab_node, lsei.encoder->nodes, lsei.index);\n+}\n+\n+/* Return the node pointed to by LSI.  */\n+static inline struct cgraph_node *\n+lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n+{\n+  return cgraph (VEC_index (symtab_node, lsei.encoder->nodes, lsei.index));\n+}\n+\n+/* Return the node pointed to by LSI.  */\n+static inline struct varpool_node *\n+lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n+{\n+  return varpool (VEC_index (symtab_node, lsei.encoder->nodes, lsei.index));\n+}\n+\n+/* Value used to represent failure of lto_symtab_encoder_lookup.  */\n+#define LCC_NOT_FOUND\t(-1)\n+\n+/* Return the cgraph node corresponding to REF using ENCODER.  */\n+\n+static inline symtab_node\n+lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n+{\n+  if (ref == LCC_NOT_FOUND)\n+    return NULL;\n+\n+  return VEC_index (symtab_node, encoder->nodes, ref);\n+}\n+\n+/* Return an iterator to the first node in LSI.  */\n+static inline lto_symtab_encoder_iterator\n+lsei_start (lto_symtab_encoder_t encoder)\n+{\n+  lto_symtab_encoder_iterator lsei;\n+\n+  lsei.encoder = encoder;\n+  lsei.index = 0;\n+  return lsei;\n+}\n+\n+/* Advance iterator LSE.  */\n+static inline void\n+lsei_next_in_partition (lto_symtab_encoder_iterator *lsei)\n+{\n+  lsei_next (lsei);\n+  while (!lsei_end_p (*lsei)\n+\t && !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei)))\n+    lsei_next (lsei);\n+}\n+\n+/* Return an iterator to the first node in LSI.  */\n+static inline lto_symtab_encoder_iterator\n+lsei_start_in_partition (lto_symtab_encoder_t encoder)\n+{\n+  lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n+\n+  if (lsei_end_p (lsei))\n+    return lsei;\n+  if (!lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n+    lsei_next_in_partition (&lsei);\n+\n+  return lsei;\n+}\n+\n+/* Advance iterator LSE.  */\n+static inline void\n+lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n+{\n+  lsei_next (lsei);\n+  while (!lsei_end_p (*lsei)\n+\t && (!symtab_function_p (lsei_node (*lsei))\n+\t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n+    lsei_next (lsei);\n+}\n+\n+/* Return an iterator to the first node in LSI.  */\n+static inline lto_symtab_encoder_iterator\n+lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n+{\n+  lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n+\n+  if (lsei_end_p (lsei))\n+    return lsei;\n+  if (!symtab_function_p (lsei_node (lsei))\n+      || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n+    lsei_next_function_in_partition (&lsei);\n+\n+  return lsei;\n+}\n+\n+/* Advance iterator LSE.  */\n+static inline void\n+lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n+{\n+  lsei_next (lsei);\n+  while (!lsei_end_p (*lsei)\n+\t && (!symtab_variable_p (lsei_node (*lsei))\n+\t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n+    lsei_next (lsei);\n+}\n+\n+/* Return an iterator to the first node in LSI.  */\n+static inline lto_symtab_encoder_iterator\n+lsei_start_variable_in_partition (lto_symtab_encoder_t encoder)\n+{\n+  lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n+\n+  if (lsei_end_p (lsei))\n+    return lsei;\n+  if (!symtab_variable_p (lsei_node (lsei))\n+      || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n+    lsei_next_variable_in_partition (&lsei);\n+\n+  return lsei;\n+}\n+\n DEFINE_DECL_STREAM_FUNCS (TYPE, type)\n DEFINE_DECL_STREAM_FUNCS (FIELD_DECL, field_decl)\n DEFINE_DECL_STREAM_FUNCS (FN_DECL, fn_decl)"}, {"sha": "4143c6af25db953641e97d2c17ee95fc0eb871c5", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -1,3 +1,10 @@\n+2012-08-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (set_referenced_from_other_partition_p,\n+\tset_reachable_from_other_partition_p, set_referenced_from_this_partition_p):\n+\tNew functions.\n+\t(lto_promote_cross_file_statics): Use them.\n+\n 2012-07-24  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Use input_symtab."}, {"sha": "37289b694efbb595dccab5b8cc1f32b4eab0ada0", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -797,6 +797,79 @@ promote_fn (struct cgraph_node *node)\n   return true;\n }\n \n+/* Return if LIST contain references from other partitions.  \n+   TODO: remove this once lto partitioning is using encoders.  */\n+\n+static bool\n+set_referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n+\t\t\t\t       varpool_node_set vset)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n+    {\n+      if (symtab_function_p (ref->referring))\n+\t{\n+\t  if (ipa_ref_referring_node (ref)->symbol.in_other_partition\n+\t      || !cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  if (ipa_ref_referring_varpool_node (ref)->symbol.in_other_partition\n+\t      || !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n+\t\t\t\t         vset))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true when node is reachable from other partition. \n+   TODO: remove this once lto partitioning is using encoders.  */\n+\n+static bool\n+set_reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n+{\n+  struct cgraph_edge *e;\n+  if (!node->analyzed)\n+    return false;\n+  if (node->global.inlined_to)\n+    return false;\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->caller->symbol.in_other_partition\n+\t|| !cgraph_node_in_set_p (e->caller, set))\n+      return true;\n+  return false;\n+}\n+\n+\n+/* Return if LIST contain references from other partitions. \n+   TODO: remove this once lto partitioning is using encoders.  */\n+\n+static bool\n+set_referenced_from_this_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n+\t\t\t\t  varpool_node_set vset)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n+    {\n+      if (symtab_function_p (ref->referring))\n+\t{\n+\t  if (cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  if (varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n+\t\t\t\t     vset))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n    all inlinees are added.  */\n@@ -834,8 +907,8 @@ lto_promote_cross_file_statics (void)\n \t    continue;\n \t  if ((!DECL_EXTERNAL (node->symbol.decl)\n \t       && !DECL_COMDAT (node->symbol.decl))\n-\t      && (referenced_from_other_partition_p (&node->symbol.ref_list, set, vset)\n-\t\t  || reachable_from_other_partition_p (node, set)))\n+\t      && (set_referenced_from_other_partition_p (&node->symbol.ref_list, set, vset)\n+\t\t  || set_reachable_from_other_partition_p (node, set)))\n \t    promote_fn (node);\n \t}\n       for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n@@ -848,7 +921,7 @@ lto_promote_cross_file_statics (void)\n \t      && !DECL_EXTERNAL (vnode->symbol.decl)\n \t      && !DECL_COMDAT (vnode->symbol.decl)\n \t      && !vnode->symbol.externally_visible && vnode->analyzed\n-\t      && referenced_from_other_partition_p (&vnode->symbol.ref_list,\n+\t      && set_referenced_from_other_partition_p (&vnode->symbol.ref_list,\n \t\t\t\t\t\t    set, vset))\n \t    promote_var (vnode);\n \t}\n@@ -866,7 +939,7 @@ lto_promote_cross_file_statics (void)\n \tif (const_value_known_p (vnode->symbol.decl)\n \t    && DECL_INITIAL (vnode->symbol.decl)\n \t    && !varpool_node_in_set_p (vnode, vset)\n-\t    && referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset)\n+\t    && set_referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset)\n \t    && !pointer_set_insert (inserted, vnode))\n \tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n "}, {"sha": "c2d8f086ead2e46cf8cd00336af61a3dc759f5bd", "filename": "gcc/passes.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -2221,9 +2221,7 @@ execute_pass_list (struct opt_pass *pass)\n    those node in SET. */\n \n static void\n-ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n-\t\t       varpool_node_set vset,\n-\t\t       struct lto_out_decl_state *state)\n+ipa_write_summaries_2 (struct opt_pass *pass, struct lto_out_decl_state *state)\n {\n   while (pass)\n     {\n@@ -2241,7 +2239,7 @@ ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n \n           pass_init_dump_file (pass);\n \n-\t  ipa_pass->write_summary (set,vset);\n+\t  ipa_pass->write_summary ();\n \n           pass_fini_dump_file (pass);\n \n@@ -2251,7 +2249,7 @@ ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n \t}\n \n       if (pass->sub && pass->sub->type != GIMPLE_PASS)\n-\tipa_write_summaries_2 (pass->sub, set, vset, state);\n+\tipa_write_summaries_2 (pass->sub, state);\n \n       pass = pass->next;\n     }\n@@ -2270,8 +2268,8 @@ ipa_write_summaries_1 (cgraph_node_set set, varpool_node_set vset)\n   lto_push_out_decl_state (state);\n \n   gcc_assert (!flag_wpa);\n-  ipa_write_summaries_2 (all_regular_ipa_passes, set, vset, state);\n-  ipa_write_summaries_2 (all_lto_gen_passes, set, vset, state);\n+  ipa_write_summaries_2 (all_regular_ipa_passes, state);\n+  ipa_write_summaries_2 (all_lto_gen_passes, state);\n \n   gcc_assert (lto_get_out_decl_state () == state);\n   lto_pop_out_decl_state ();\n@@ -2339,9 +2337,7 @@ ipa_write_summaries (void)\n    only those node in SET. */\n \n static void\n-ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n-\t\t       varpool_node_set vset,\n-\t\t       struct lto_out_decl_state *state)\n+ipa_write_optimization_summaries_1 (struct opt_pass *pass, struct lto_out_decl_state *state)\n {\n   while (pass)\n     {\n@@ -2359,7 +2355,7 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n \n           pass_init_dump_file (pass);\n \n-\t  ipa_pass->write_optimization_summary (set, vset);\n+\t  ipa_pass->write_optimization_summary ();\n \n           pass_fini_dump_file (pass);\n \n@@ -2369,7 +2365,7 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n \t}\n \n       if (pass->sub && pass->sub->type != GIMPLE_PASS)\n-\tipa_write_optimization_summaries_1 (pass->sub, set, vset, state);\n+\tipa_write_optimization_summaries_1 (pass->sub, state);\n \n       pass = pass->next;\n     }\n@@ -2404,8 +2400,8 @@ ipa_write_optimization_summaries (cgraph_node_set set, varpool_node_set vset)\n     }\n \n   gcc_assert (flag_wpa);\n-  ipa_write_optimization_summaries_1 (all_regular_ipa_passes, set, vset, state);\n-  ipa_write_optimization_summaries_1 (all_lto_gen_passes, set, vset, state);\n+  ipa_write_optimization_summaries_1 (all_regular_ipa_passes, state);\n+  ipa_write_optimization_summaries_1 (all_lto_gen_passes, state);\n \n   gcc_assert (lto_get_out_decl_state () == state);\n   lto_pop_out_decl_state ();"}, {"sha": "db5bf825732cca769459cf4ac7e567fd0a11e00c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27c1867108c24557452bc6ea11196c7e7f09801/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f27c1867108c24557452bc6ea11196c7e7f09801", "patch": "@@ -106,15 +106,13 @@ struct ipa_opt_pass_d\n   void (*generate_summary) (void);\n \n   /* This hook is used to serialize IPA summaries on disk.  */\n-  void (*write_summary) (struct cgraph_node_set_def *,\n-\t\t\t struct varpool_node_set_def *);\n+  void (*write_summary) (void);\n \n   /* This hook is used to deserialize IPA summaries from disk.  */\n   void (*read_summary) (void);\n \n   /* This hook is used to serialize IPA optimization summaries on disk.  */\n-  void (*write_optimization_summary) (struct cgraph_node_set_def *,\n-\t\t\t\t      struct varpool_node_set_def *);\n+  void (*write_optimization_summary) (void);\n \n   /* This hook is used to deserialize IPA summaries from disk.  */\n   void (*read_optimization_summary) (void);"}]}