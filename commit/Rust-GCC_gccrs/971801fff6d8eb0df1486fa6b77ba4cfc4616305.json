{"sha": "971801fff6d8eb0df1486fa6b77ba4cfc4616305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcxODAxZmZmNmQ4ZWIwZGYxNDg2ZmE2Yjc3YmE0Y2ZjNDYxNjMwNQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-09-15T20:48:10Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-09-15T20:48:10Z"}, "message": "attribs.c, [...]: Use %<, %> and %q for quoting in diagnostics going through pretty-print.c.\n\ngcc:\n\t* attribs.c, builtins.c, c-format.c, c-pch.c, coverage.c,\n\texcept.c, fold-const.c, function.c, langhooks.c, params.c,\n\treload.c, reload1.c, stmt.c, stor-layout.c, toplev.c, tree-cfg.c,\n\ttree-dump.c, tree-mudflap.c, tree.c, varasm.c: Use %<, %> and %q\n\tfor quoting in diagnostics going through pretty-print.c.  Use ''\n\tfor quoting in other diagnostic text.\n\t* langhooks.c: Include intl.h.  Mark text locating diagnostics for\n\ttranslation.\n\t* Makefile.in (langhooks.o): Update dependencies.\n\t* pretty-print.h (pp_printf): Mark as accepting GCC diagnostic\n\tformats.\n\ngcc/testsuite:\n\t* g++.dg/ext/member-attr.C, g++.dg/warn/deprecated.C,\n\tgcc.dg/deprecated.c, gcc.dg/noreturn-1.c, gcc.dg/noreturn-4.c:\n\tUpdate expected messages.\n\nlibmudflap:\n\t* testsuite/libmudflap.c/pass35-frag.c: Update expected message.\n\nFrom-SVN: r87563", "tree": {"sha": "4034f8306b245baf4a83c67767977aaa06c4a83b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4034f8306b245baf4a83c67767977aaa06c4a83b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/971801fff6d8eb0df1486fa6b77ba4cfc4616305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971801fff6d8eb0df1486fa6b77ba4cfc4616305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/971801fff6d8eb0df1486fa6b77ba4cfc4616305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971801fff6d8eb0df1486fa6b77ba4cfc4616305/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1daf6f3a5ba3a54bde4b8843b7b75dad3bb536eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1daf6f3a5ba3a54bde4b8843b7b75dad3bb536eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1daf6f3a5ba3a54bde4b8843b7b75dad3bb536eb"}], "stats": {"total": 515, "additions": 282, "deletions": 233}, "files": [{"sha": "cf5b444dadb0b889627c3f8fe2c3941c07feefa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1,3 +1,17 @@\n+2004-09-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* attribs.c, builtins.c, c-format.c, c-pch.c, coverage.c,\n+\texcept.c, fold-const.c, function.c, langhooks.c, params.c,\n+\treload.c, reload1.c, stmt.c, stor-layout.c, toplev.c, tree-cfg.c,\n+\ttree-dump.c, tree-mudflap.c, tree.c, varasm.c: Use %<, %> and %q\n+\tfor quoting in diagnostics going through pretty-print.c.  Use ''\n+\tfor quoting in other diagnostic text.\n+\t* langhooks.c: Include intl.h.  Mark text locating diagnostics for\n+\ttranslation.\n+\t* Makefile.in (langhooks.o): Update dependencies.\n+\t* pretty-print.h (pp_printf): Mark as accepting GCC diagnostic\n+\tformats.\n+\n 2004-09-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* configure.ac: Check for COMDAT support.  Robustify check for"}, {"sha": "b3c83c8b5a2549134767119aef7fa62041c67699", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1577,7 +1577,7 @@ convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FLA\n \n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) toplev.h \\\n    tree-inline.h $(RTL_H) insn-config.h $(INTEGRATE_H) langhooks.h \\\n-   $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) diagnostic.h\n+   $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) diagnostic.h intl.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) function.h $(PARAMS_H) \\\n    toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\"}, {"sha": "1aab101c624f2c7b0ea371a0764184315b819cb7", "filename": "gcc/attribs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -172,15 +172,15 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n       if (spec == NULL)\n \t{\n-\t  warning (\"`%s' attribute directive ignored\",\n+\t  warning (\"%qs attribute directive ignored\",\n \t\t   IDENTIFIER_POINTER (name));\n \t  continue;\n \t}\n       else if (list_length (args) < spec->min_length\n \t       || (spec->max_length >= 0\n \t\t   && list_length (args) > spec->max_length))\n \t{\n-\t  error (\"wrong number of arguments specified for `%s' attribute\",\n+\t  error (\"wrong number of arguments specified for %qs attribute\",\n \t\t IDENTIFIER_POINTER (name));\n \t  continue;\n \t}\n@@ -197,7 +197,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t    }\n \t  else\n \t    {\n-\t      warning (\"`%s' attribute does not apply to types\",\n+\t      warning (\"%qs attribute does not apply to types\",\n \t\t       IDENTIFIER_POINTER (name));\n \t      continue;\n \t    }\n@@ -243,7 +243,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t  if (TREE_CODE (*anode) != FUNCTION_TYPE\n \t      && TREE_CODE (*anode) != METHOD_TYPE)\n \t    {\n-\t      warning (\"`%s' attribute only applies to function types\",\n+\t      warning (\"%qs attribute only applies to function types\",\n \t\t       IDENTIFIER_POINTER (name));\n \t      continue;\n \t    }"}, {"sha": "a95f11db9ec570d2bce4ca45955ba5507756b387", "filename": "gcc/builtins.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -924,7 +924,7 @@ expand_builtin_prefetch (tree arglist)\n   /* Argument 1 (read/write flag) must be a compile-time constant int.  */\n   if (TREE_CODE (arg1) != INTEGER_CST)\n     {\n-      error (\"second arg to `__builtin_prefetch' must be a constant\");\n+      error (\"second arg to %<__builtin_prefetch%> must be a constant\");\n       arg1 = integer_zero_node;\n     }\n   op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n@@ -938,7 +938,7 @@ expand_builtin_prefetch (tree arglist)\n   /* Argument 2 (locality) must be a compile-time constant int.  */\n   if (TREE_CODE (arg2) != INTEGER_CST)\n     {\n-      error (\"third arg to `__builtin_prefetch' must be a constant\");\n+      error (\"third arg to %<__builtin_prefetch%> must be a constant\");\n       arg2 = integer_zero_node;\n     }\n   op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n@@ -4147,19 +4147,19 @@ expand_builtin_args_info (tree arglist)\n   if (arglist != 0)\n     {\n       if (!host_integerp (TREE_VALUE (arglist), 0))\n-\terror (\"argument of `__builtin_args_info' must be constant\");\n+\terror (\"argument of %<__builtin_args_info%> must be constant\");\n       else\n \t{\n \t  HOST_WIDE_INT wordnum = tree_low_cst (TREE_VALUE (arglist), 0);\n \n \t  if (wordnum < 0 || wordnum >= nwords)\n-\t    error (\"argument of `__builtin_args_info' out of range\");\n+\t    error (\"argument of %<__builtin_args_info%> out of range\");\n \t  else\n \t    return GEN_INT (word_ptr[wordnum]);\n \t}\n     }\n   else\n-    error (\"missing argument in `__builtin_args_info'\");\n+    error (\"missing argument in %<__builtin_args_info%>\");\n \n   return const0_rtx;\n }\n@@ -4175,7 +4175,7 @@ expand_builtin_next_arg (tree arglist)\n       || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t  == void_type_node))\n     {\n-      error (\"`va_start' used in function with fixed args\");\n+      error (\"%<va_start%> used in function with fixed args\");\n       return const0_rtx;\n     }\n \n@@ -4194,12 +4194,12 @@ expand_builtin_next_arg (tree arglist)\n \t     || TREE_CODE (arg) == INDIRECT_REF)\n \targ = TREE_OPERAND (arg, 0);\n       if (arg != last_parm)\n-\twarning (\"second parameter of `va_start' not last named argument\");\n+\twarning (\"second parameter of %<va_start%> not last named argument\");\n     }\n   else\n     /* Evidently an out of date version of <stdarg.h>; can't validate\n        va_start's second argument, but can still work as intended.  */\n-    warning (\"`__builtin_next_arg' called without an argument\");\n+    warning (\"%<__builtin_next_arg%> called without an argument\");\n \n   return expand_binop (Pmode, add_optab,\n \t\t       current_function_internal_arg_pointer,\n@@ -4284,7 +4284,7 @@ expand_builtin_va_start (tree arglist)\n   chain = TREE_CHAIN (arglist);\n \n   if (TREE_CHAIN (chain))\n-    error (\"too many arguments to function `va_start'\");\n+    error (\"too many arguments to function %<va_start%>\");\n \n   nextarg = expand_builtin_next_arg (chain);\n   valist = stabilize_va_list (TREE_VALUE (arglist), 1);\n@@ -4430,7 +4430,7 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n   if (TYPE_MAIN_VARIANT (want_va_type) != TYPE_MAIN_VARIANT (have_va_type))\n     {\n-      error (\"first argument to `va_arg' not of type `va_list'\");\n+      error (\"first argument to %<va_arg%> not of type %<va_list%>\");\n       return GS_ERROR;\n     }\n \n@@ -4444,12 +4444,12 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       /* Unfortunately, this is merely undefined, rather than a constraint\n \t violation, so we cannot make this an error.  If this call is never\n \t executed, the program is still strictly conforming.  */\n-      warning (\"`%T' is promoted to `%T' when passed through `...'\",\n+      warning (\"%qT is promoted to %qT when passed through %<...%>\",\n \t       type, promoted_type);\n       if (! gave_help)\n \t{\n \t  gave_help = true;\n-\t  warning (\"(so you should pass `%T' not `%T' to `va_arg')\",\n+\t  warning (\"(so you should pass %qT not %qT to %<va_arg%>)\",\n \t\t   promoted_type, type);\n \t}\n \n@@ -4573,9 +4573,9 @@ expand_builtin_frame_address (tree fndecl, tree arglist)\n   else if (! host_integerp (TREE_VALUE (arglist), 1))\n     {\n       if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n-\terror (\"invalid arg to `__builtin_frame_address'\");\n+\terror (\"invalid arg to %<__builtin_frame_address%>\");\n       else\n-\terror (\"invalid arg to `__builtin_return_address'\");\n+\terror (\"invalid arg to %<__builtin_return_address%>\");\n       return const0_rtx;\n     }\n   else\n@@ -4589,9 +4589,9 @@ expand_builtin_frame_address (tree fndecl, tree arglist)\n       if (tem == NULL)\n \t{\n \t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n-\t    warning (\"unsupported arg to `__builtin_frame_address'\");\n+\t    warning (\"unsupported arg to %<__builtin_frame_address%>\");\n \t  else\n-\t    warning (\"unsupported arg to `__builtin_return_address'\");\n+\t    warning (\"unsupported arg to %<__builtin_return_address%>\");\n \t  return const0_rtx;\n \t}\n \n@@ -4757,7 +4757,7 @@ expand_builtin_expect (tree arglist, rtx target)\n \n   if (TREE_CODE (c) != INTEGER_CST)\n     {\n-      error (\"second arg to `__builtin_expect' must be a constant\");\n+      error (\"second arg to %<__builtin_expect%> must be a constant\");\n       c = integer_zero_node;\n     }\n \n@@ -8040,19 +8040,19 @@ fold_builtin_classify (tree exp, int builtin_index)\n       /* Check that we have exactly one argument.  */\n       if (arglist == 0)\n \t{\n-\t  error (\"too few arguments to function `%s'\",\n+\t  error (\"too few arguments to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n       else if (TREE_CHAIN (arglist) != 0)\n \t{\n-\t  error (\"too many arguments to function `%s'\",\n+\t  error (\"too many arguments to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n       else\n \t{\n-\t  error (\"non-floating-point argument to function `%s'\",\n+\t  error (\"non-floating-point argument to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n@@ -8136,13 +8136,13 @@ fold_builtin_unordered_cmp (tree exp,\n       /* Check that we have exactly two arguments.  */\n       if (arglist == 0 || TREE_CHAIN (arglist) == 0)\n \t{\n-\t  error (\"too few arguments to function `%s'\",\n+\t  error (\"too few arguments to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n       else if (TREE_CHAIN (TREE_CHAIN (arglist)) != 0)\n \t{\n-\t  error (\"too many arguments to function `%s'\",\n+\t  error (\"too many arguments to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n@@ -8166,7 +8166,7 @@ fold_builtin_unordered_cmp (tree exp,\n \tcmp_type = type1;\n       else\n \t{\n-\t  error (\"non-floating-point argument to function `%s'\",\n+\t  error (\"non-floating-point argument to function %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n \t  return error_mark_node;\n \t}\n@@ -9247,7 +9247,7 @@ simplify_builtin_va_start (tree arglist)\n   tree chain = TREE_CHAIN (arglist);\n \n   if (TREE_CHAIN (chain))\n-    error (\"too many arguments to function `va_start'\");\n+    error (\"too many arguments to function %<va_start%>\");\n \n   simplify_builtin_next_arg (chain);\n }\n@@ -9260,7 +9260,7 @@ simplify_builtin_next_arg (tree arglist)\n   if (TYPE_ARG_TYPES (fntype) == 0\n       || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t  == void_type_node))\n-    error (\"`va_start' used in function with fixed args\");\n+    error (\"%<va_start%> used in function with fixed args\");\n   else if (arglist)\n     {\n       tree last_parm = tree_last (DECL_ARGUMENTS (current_function_decl));\n@@ -9276,13 +9276,13 @@ simplify_builtin_next_arg (tree arglist)\n \t     || TREE_CODE (arg) == INDIRECT_REF)\n \targ = TREE_OPERAND (arg, 0);\n       if (arg != last_parm)\n-\twarning (\"second parameter of `va_start' not last named argument\");\n+\twarning (\"second parameter of %<va_start%> not last named argument\");\n       TREE_VALUE (arglist) = arg;\n     }\n   else\n     /* Evidently an out of date version of <stdarg.h>; can't validate\n        va_start's second argument, but can still work as intended.  */\n-    warning (\"`__builtin_next_arg' called without an argument\");\n+    warning (\"%<__builtin_next_arg%> called without an argument\");\n }\n \n "}, {"sha": "bb730f3acda387611de4364c43f2eea0044908f3", "filename": "gcc/c-format.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -342,13 +342,13 @@ static const format_length_info strfmon_length_specs[] =\n \n static const format_flag_spec printf_flag_specs[] =\n {\n-  { ' ',  0, 0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n-  { '0',  0, 0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n-  { '\\'', 0, 0, N_(\"`'' flag\"),        N_(\"the `'' printf flag\"),              STD_EXT },\n-  { 'I',  0, 0, N_(\"`I' flag\"),        N_(\"the `I' printf flag\"),              STD_EXT },\n+  { ' ',  0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n+  { '\\'', 0, 0, N_(\"''' flag\"),        N_(\"the ''' printf flag\"),              STD_EXT },\n+  { 'I',  0, 0, N_(\"'I' flag\"),        N_(\"the 'I' printf flag\"),              STD_EXT },\n   { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n@@ -366,11 +366,11 @@ static const format_flag_pair printf_flag_pairs[] =\n \n static const format_flag_spec asm_fprintf_flag_specs[] =\n {\n-  { ' ',  0, 0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n-  { '0',  0, 0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n+  { ' ',  0, 0, N_(\"' ' flag\"),        N_(\"the ' ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, N_(\"'0' flag\"),        N_(\"the '0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' printf flag\"),              STD_C89 },\n   { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n@@ -395,7 +395,7 @@ static const format_flag_pair gcc_diag_flag_pairs[] =\n \n static const format_flag_spec gcc_diag_flag_specs[] =\n {\n-  { 'q',  0, 0, N_(\"`q' flag\"),        N_(\"the `q' diagnostic flag\"),          STD_C89 },\n+  { 'q',  0, 0, N_(\"'q' flag\"),        N_(\"the 'q' diagnostic flag\"),          STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n   { 0, 0, 0, NULL, NULL, 0 }\n@@ -405,9 +405,9 @@ static const format_flag_spec gcc_diag_flag_specs[] =\n \n static const format_flag_spec gcc_cxxdiag_flag_specs[] =\n {\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n-  { 'q',  0, 0, N_(\"`q' flag\"),        N_(\"the `q' diagnostic flag\"),          STD_C89 },\n+  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"'#' flag\"),        N_(\"the '#' printf flag\"),              STD_C89 },\n+  { 'q',  0, 0, N_(\"'q' flag\"),        N_(\"the 'q' diagnostic flag\"),          STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n   { 0, 0, 0, NULL, NULL, 0 }\n@@ -416,11 +416,11 @@ static const format_flag_spec gcc_cxxdiag_flag_specs[] =\n static const format_flag_spec scanf_flag_specs[] =\n {\n   { '*',  0, 0, N_(\"assignment suppression\"), N_(\"the assignment suppression scanf feature\"), STD_C89 },\n-  { 'a',  0, 0, N_(\"`a' flag\"),               N_(\"the `a' scanf flag\"),                       STD_EXT },\n+  { 'a',  0, 0, N_(\"'a' flag\"),               N_(\"the 'a' scanf flag\"),                       STD_EXT },\n   { 'w',  0, 0, N_(\"field width\"),            N_(\"field width in scanf format\"),              STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"),          STD_C89 },\n-  { '\\'', 0, 0, N_(\"`'' flag\"),               N_(\"the `'' scanf flag\"),                       STD_EXT },\n-  { 'I',  0, 0, N_(\"`I' flag\"),               N_(\"the `I' scanf flag\"),                       STD_EXT },\n+  { '\\'', 0, 0, N_(\"''' flag\"),               N_(\"the ''' scanf flag\"),                       STD_EXT },\n+  { 'I',  0, 0, N_(\"'I' flag\"),               N_(\"the 'I' scanf flag\"),                       STD_EXT },\n   { 0, 0, 0, NULL, NULL, 0 }\n };\n \n@@ -434,15 +434,15 @@ static const format_flag_pair scanf_flag_pairs[] =\n \n static const format_flag_spec strftime_flag_specs[] =\n {\n-  { '_', 0,   0, N_(\"`_' flag\"),     N_(\"the `_' strftime flag\"),          STD_EXT },\n-  { '-', 0,   0, N_(\"`-' flag\"),     N_(\"the `-' strftime flag\"),          STD_EXT },\n-  { '0', 0,   0, N_(\"`0' flag\"),     N_(\"the `0' strftime flag\"),          STD_EXT },\n-  { '^', 0,   0, N_(\"`^' flag\"),     N_(\"the `^' strftime flag\"),          STD_EXT },\n-  { '#', 0,   0, N_(\"`#' flag\"),     N_(\"the `#' strftime flag\"),          STD_EXT },\n+  { '_', 0,   0, N_(\"'_' flag\"),     N_(\"the '_' strftime flag\"),          STD_EXT },\n+  { '-', 0,   0, N_(\"'-' flag\"),     N_(\"the '-' strftime flag\"),          STD_EXT },\n+  { '0', 0,   0, N_(\"'0' flag\"),     N_(\"the '0' strftime flag\"),          STD_EXT },\n+  { '^', 0,   0, N_(\"'^' flag\"),     N_(\"the '^' strftime flag\"),          STD_EXT },\n+  { '#', 0,   0, N_(\"'#' flag\"),     N_(\"the '#' strftime flag\"),          STD_EXT },\n   { 'w', 0,   0, N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n-  { 'E', 0,   0, N_(\"`E' modifier\"), N_(\"the `E' strftime modifier\"),      STD_C99 },\n-  { 'O', 0,   0, N_(\"`O' modifier\"), N_(\"the `O' strftime modifier\"),      STD_C99 },\n-  { 'O', 'o', 0, NULL,               N_(\"the `O' modifier\"),               STD_EXT },\n+  { 'E', 0,   0, N_(\"'E' modifier\"), N_(\"the 'E' strftime modifier\"),      STD_C99 },\n+  { 'O', 0,   0, N_(\"'O' modifier\"), N_(\"the 'O' strftime modifier\"),      STD_C99 },\n+  { 'O', 'o', 0, NULL,               N_(\"the 'O' modifier\"),               STD_EXT },\n   { 0, 0, 0, NULL, NULL, 0 }\n };\n \n@@ -461,11 +461,11 @@ static const format_flag_pair strftime_flag_pairs[] =\n static const format_flag_spec strfmon_flag_specs[] =\n {\n   { '=',  0, 1, N_(\"fill character\"),  N_(\"fill character in strfmon format\"),  STD_C89 },\n-  { '^',  0, 0, N_(\"`^' flag\"),        N_(\"the `^' strfmon flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' strfmon flag\"),              STD_C89 },\n-  { '(',  0, 0, N_(\"`(' flag\"),        N_(\"the `(' strfmon flag\"),              STD_C89 },\n-  { '!',  0, 0, N_(\"`!' flag\"),        N_(\"the `!' strfmon flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' strfmon flag\"),              STD_C89 },\n+  { '^',  0, 0, N_(\"'^' flag\"),        N_(\"the '^' strfmon flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' strfmon flag\"),              STD_C89 },\n+  { '(',  0, 0, N_(\"'(' flag\"),        N_(\"the '(' strfmon flag\"),              STD_C89 },\n+  { '!',  0, 0, N_(\"'!' flag\"),        N_(\"the '!' strfmon flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"'-' flag\"),        N_(\"the '-' strfmon flag\"),              STD_C89 },\n   { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in strfmon format\"),     STD_C89 },\n   { '#',  0, 0, N_(\"left precision\"),  N_(\"left precision in strfmon format\"),  STD_C89 },\n   { 'p',  0, 0, N_(\"right precision\"), N_(\"right precision in strfmon format\"), STD_C89 },\n@@ -587,7 +587,7 @@ static const format_char_info gcc_cxxdiag_char_table[] =\n   /* These will require a \"tree\" at runtime.  */\n   { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n \n-  /* These accept either an `int' or an `enum tree_code' (which is handled as an `int'.)  */\n+  /* These accept either an 'int' or an 'enum tree_code' (which is handled as an 'int'.)  */\n   { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n@@ -1720,7 +1720,7 @@ check_format_info_main (format_check_results *res,\n \t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n \t\t  || format_chars[1] == '[')\n \t\t{\n-\t\t  /* `a' is used as a flag.  */\n+\t\t  /* 'a' is used as a flag.  */\n \t\t  i = strlen (flag_chars);\n \t\t  flag_chars[i++] = 'a';\n \t\t  flag_chars[i] = 0;\n@@ -2137,7 +2137,7 @@ check_format_types (format_wanted_type *types, const char *format_start,\n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n       if (wanted_type == cur_type)\n \tcontinue;\n-      /* If we want `void *', allow any pointer type.\n+      /* If we want 'void *', allow any pointer type.\n \t (Anything else would already have got a warning.)\n \t With -pedantic, only allow pointers to void and to character\n \t types.  */\n@@ -2327,15 +2327,15 @@ init_dynamic_diag_info (void)\n       unsigned int i;\n \n       /* For the GCC-diagnostics custom format specifiers to work, one\n-\t must have declared `tree' and/or `location_t' prior to using\n+\t must have declared 'tree' and/or 'location_t' prior to using\n \t those attributes.  If we haven't seen these declarations then\n \t you shouldn't use the specifiers requiring these types.\n \t However we don't force a hard ICE because we may see only one\n \t or the other type.  */\n       if ((loc = maybe_get_identifier (\"location_t\")))\n \tloc = TREE_TYPE (identifier_global_value (loc));\n \n-      /* We need to grab the underlying `union tree_node' so peek into\n+      /* We need to grab the underlying 'union tree_node' so peek into\n \t an extra type level.  */\n       if ((t = maybe_get_identifier (\"tree\")))\n \tt = TREE_TYPE (TREE_TYPE (identifier_global_value (t)));\n@@ -2529,7 +2529,7 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       if (info.format_type == asm_fprintf_format_type)\n \tinit_dynamic_asm_fprintf_info();\n       /* If this is one of the diagnostic attributes, then we have to\n-         initialize `location_t' and `tree' at runtime.  */\n+         initialize 'location_t' and 'tree' at runtime.  */\n       else if (info.format_type == gcc_diag_format_type\n \t       || info.format_type == gcc_cdiag_format_type\n \t       || info.format_type == gcc_cxxdiag_format_type)"}, {"sha": "04eee838dfa055eb2f539a2aeacbfb49b096545b", "filename": "gcc/c-pch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -161,7 +161,7 @@ pch_init (void)\n   /* The driver always provides a valid -o option.  */\n   if (asm_file_name == NULL\n       || strcmp (asm_file_name, \"-\") == 0)\n-    fatal_error (\"`%s' is not a valid output file\", asm_file_name);\n+    fatal_error (\"%qs is not a valid output file\", asm_file_name);\n   \n   asm_file_startpos = ftell (asm_out_file);\n   \n@@ -284,7 +284,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n \tcpp_error (pfile, CPP_DL_WARNING, \n-\t\t   \"%s: created on host `%.*s', but used on host `%s'\", name,\n+\t\t   \"%s: created on host '%.*s', but used on host '%s'\", name,\n \t\t   v.host_machine_length, short_strings, host_machine);\n       return 2;\n     }\n@@ -294,7 +294,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n \tcpp_error (pfile, CPP_DL_WARNING, \n-\t\t   \"%s: created for target `%.*s', but used for target `%s'\", \n+\t\t   \"%s: created for target '%.*s', but used for target '%s'\", \n \t\t   name, v.target_machine_length, \n \t\t   short_strings + v.host_machine_length, target_machine);\n       return 2;\n@@ -307,7 +307,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n \tcpp_error (pfile, CPP_DL_WARNING,\n-\t\t   \"%s: created by version `%.*s', but this is version `%s'\", \n+\t\t   \"%s: created by version '%.*s', but this is version '%s'\", \n \t\t   name, v.version_length, \n \t\t   (short_strings + v.host_machine_length \n \t\t    + v.target_machine_length), "}, {"sha": "a4f4d001c13cc0e7bcf2dc92aecfdadb90828eeb", "filename": "gcc/coverage.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -165,7 +165,7 @@ read_counts_file (void)\n \n   if (!gcov_magic (gcov_read_unsigned (), GCOV_DATA_MAGIC))\n     {\n-      warning (\"`%s' is not a gcov data file\", da_file_name);\n+      warning (\"%qs is not a gcov data file\", da_file_name);\n       gcov_close ();\n       return;\n     }\n@@ -176,7 +176,7 @@ read_counts_file (void)\n       GCOV_UNSIGNED2STRING (v, tag);\n       GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n \n-      warning (\"`%s' is version `%.*s', expected version `%.*s'\",\n+      warning (\"%qs is version %q.*s, expected version %q.*s\",\n  \t       da_file_name, 4, v, 4, e);\n       gcov_close ();\n       return;\n@@ -293,7 +293,7 @@ read_counts_file (void)\n       gcov_sync (offset, length);\n       if ((is_error = gcov_is_error ()))\n \t{\n-\t  error (is_error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n+\t  error (is_error < 0 ? \"%qs has overflowed\" : \"%qs is corrupted\",\n \t\t da_file_name);\n \t  htab_delete (counts_hash);\n \t  break;\n@@ -330,23 +330,23 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   entry = htab_find (counts_hash, &elt);\n   if (!entry)\n     {\n-      warning (\"no coverage for function '%s' found.\", IDENTIFIER_POINTER\n+      warning (\"no coverage for function %qs found.\", IDENTIFIER_POINTER\n \t       (DECL_ASSEMBLER_NAME (current_function_decl)));\n       return 0;\n     }\n \n   checksum = compute_checksum ();\n   if (entry->checksum != checksum)\n     {\n-      error (\"coverage mismatch for function '%s' while reading counter '%s'.\",\n+      error (\"coverage mismatch for function %qs while reading counter %qs.\",\n \t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)),\n \t     ctr_names[counter]);\n       error (\"checksum is %x instead of %x\", entry->checksum, checksum);\n       return 0;\n     }\n   else if (entry->summary.num != expected)\n     {\n-      error (\"coverage mismatch for function '%s' while reading counter '%s'.\",\n+      error (\"coverage mismatch for function %qs while reading counter %qs.\",\n \t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)),\n \t     ctr_names[counter]);\n       error (\"number of counters is %d instead of %d\", entry->summary.num, expected);\n@@ -564,7 +564,7 @@ coverage_end_function (void)\n \n   if (bbg_file_opened > 1 && gcov_is_error ())\n     {\n-      warning (\"error writing `%s'\", bbg_file_name);\n+      warning (\"error writing %qs\", bbg_file_name);\n       bbg_file_opened = -1;\n     }\n "}, {"sha": "259a3c795b3d2c2d50dc8648e44d539fe5fa8984", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -2921,7 +2921,7 @@ expand_builtin_eh_return_data_regno (tree arglist)\n \n   if (TREE_CODE (which) != INTEGER_CST)\n     {\n-      error (\"argument of `__builtin_eh_return_regno' must be constant\");\n+      error (\"argument of %<__builtin_eh_return_regno%> must be constant\");\n       return constm1_rtx;\n     }\n "}, {"sha": "378578d000ff98441a0f1810efd415cb73f1065f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -4897,12 +4897,12 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n     {\n       if (wanted_code == NE_EXPR)\n \t{\n-\t  warning (\"`or' of unmatched not-equal tests is always 1\");\n+\t  warning (\"%<or%> of unmatched not-equal tests is always 1\");\n \t  return constant_boolean_node (true, truth_type);\n \t}\n       else\n \t{\n-\t  warning (\"`and' of mutually exclusive equal-tests is always 0\");\n+\t  warning (\"%<and%> of mutually exclusive equal-tests is always 0\");\n \t  return constant_boolean_node (false, truth_type);\n \t}\n     }"}, {"sha": "a7613e13908908b95475ad802f8f2af1f6002fd6", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -831,7 +831,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n-\t  error (\"%Jsize of variable '%D' is too large\", decl, decl);\n+\t  error (\"%Jsize of variable %qD is too large\", decl, decl);\n \t  size = 1;\n \t}\n \n@@ -1432,7 +1432,7 @@ static void\n instantiate_virtual_regs_lossage (rtx insn)\n {\n   gcc_assert (asm_noperands (PATTERN (insn)) >= 0);\n-  error_for_asm (insn, \"impossible constraint in `asm'\");\n+  error_for_asm (insn, \"impossible constraint in %<asm%>\");\n   delete_insn (insn);\n }\n /* Given a pointer to a piece of rtx and an optional pointer to the\n@@ -3454,7 +3454,8 @@ setjmp_vars_warning (tree block)\n \t  && DECL_RTL_SET_P (decl)\n \t  && REG_P (DECL_RTL (decl))\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-\twarning (\"%Jvariable '%D' might be clobbered by `longjmp' or `vfork'\",\n+\twarning (\"%Jvariable %qD might be clobbered by %<longjmp%>\"\n+\t\t \" or %<vfork%>\",\n \t\t decl, decl);\n     }\n \n@@ -3474,7 +3475,7 @@ setjmp_args_warning (void)\n     if (DECL_RTL (decl) != 0\n \t&& REG_P (DECL_RTL (decl))\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-      warning (\"%Jargument '%D' might be clobbered by `longjmp' or `vfork'\",\n+      warning (\"%Jargument %qD might be clobbered by %<longjmp%> or %<vfork%>\",\n \t       decl, decl);\n }\n \n@@ -4198,7 +4199,7 @@ do_warn_unused_parameter (tree fn)\n        decl; decl = TREE_CHAIN (decl))\n     if (!TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n \t&& DECL_NAME (decl) && !DECL_ARTIFICIAL (decl))\n-      warning (\"%Junused parameter '%D'\", decl, decl);\n+      warning (\"%Junused parameter %qD\", decl, decl);\n }\n \n static GTY(()) rtx initial_trampoline;"}, {"sha": "b52d36b612cbba3e47702756ff4434372346709d", "filename": "gcc/langhooks.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"intl.h\"\n #include \"tm.h\"\n #include \"toplev.h\"\n #include \"tree.h\"\n@@ -512,16 +513,16 @@ lhd_print_error_function (diagnostic_context *context, const char *file)\n       pp_set_prefix (context->printer, new_prefix);\n \n       if (current_function_decl == NULL)\n-\tpp_printf (context->printer, \"At top level:\");\n+\tpp_printf (context->printer, _(\"At top level:\"));\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n \t    pp_printf\n-\t      (context->printer, \"In member function `%s':\",\n+\t      (context->printer, _(\"In member function %qs:\"),\n \t       lang_hooks.decl_printable_name (current_function_decl, 2));\n \t  else\n \t    pp_printf\n-\t      (context->printer, \"In function `%s':\",\n+\t      (context->printer, _(\"In function %qs:\"),\n \t       lang_hooks.decl_printable_name (current_function_decl, 2));\n \t}\n "}, {"sha": "f7db8003a5326b1ae79a9445128077d92c9212c6", "filename": "gcc/params.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -73,5 +73,5 @@ set_param_value (const char *name, int value)\n       }\n \n   /* If we didn't find this parameter, issue an error message.  */\n-  error (\"invalid parameter `%s'\", name);\n+  error (\"invalid parameter %qs\", name);\n }"}, {"sha": "42bf8e1b1803a64b5a57f0cb24e91eb816adc03e", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -248,7 +248,17 @@ extern const char *pp_base_formatted_text (pretty_printer *);\n extern const char *pp_base_last_position_in_text (const pretty_printer *);\n extern void pp_base_emit_prefix (pretty_printer *);\n extern void pp_base_append_text (pretty_printer *, const char *, const char *);\n-extern void pp_printf (pretty_printer *, const char *, ...) ATTRIBUTE_PRINTF_2;\n+\n+/* This header may be included before toplev.h, hence the duplicate\n+   definitions to allow for GCC-specific formats.  */\n+#if GCC_VERSION >= 3005\n+#define ATTRIBUTE_GCC_PPDIAG(m, n) __attribute__ ((__format__ (__gcc_diag__, m ,n))) ATTRIBUTE_NONNULL(m)\n+#else\n+#define ATTRIBUTE_GCC_PPDIAG(m, n) ATTRIBUTE_NONNULL(m)\n+#endif\n+extern void pp_printf (pretty_printer *, const char *, ...)\n+     ATTRIBUTE_GCC_PPDIAG(2,3);\n+\n extern void pp_verbatim (pretty_printer *, const char *, ...);\n extern void pp_base_flush (pretty_printer *);\n extern void pp_base_format_text (pretty_printer *, text_info *);"}, {"sha": "f3c5978164e4134cb4c1deed01bd509672255ee3", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1254,7 +1254,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \tmode = outmode;\n       if (mode == VOIDmode)\n \t{\n-\t  error_for_asm (this_insn, \"cannot reload integer constant operand in `asm'\");\n+\t  error_for_asm (this_insn, \"cannot reload integer constant \"\n+\t\t\t \"operand in %<asm%>\");\n \t  mode = word_mode;\n \t  if (in != 0)\n \t    inmode = word_mode;\n@@ -1276,7 +1277,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  }\n       if (i == FIRST_PSEUDO_REGISTER)\n \t{\n-\t  error_for_asm (this_insn, \"impossible register constraint in `asm'\");\n+\t  error_for_asm (this_insn, \"impossible register constraint \"\n+\t\t\t \"in %<asm%>\");\n \t  class = ALL_REGS;\n \t}\n     }\n@@ -3513,7 +3515,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tthis_alternative_earlyclobber[i] = 0;\n \t\tgcc_assert (this_insn_is_asm);\n \t\terror_for_asm (this_insn,\n-\t\t\t\t\"`&' constraint used with no register class\");\n+\t\t\t       \"%<&%> constraint used with no register class\");\n \t      }\n \n \t    for (j = 0; j < noperands; j++)\n@@ -3680,7 +3682,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n       /* No alternative works with reloads??  */\n       if (insn_code_number >= 0)\n \tfatal_insn (\"unable to generate reloads for:\", insn);\n-      error_for_asm (insn, \"inconsistent operand constraints in an `asm'\");\n+      error_for_asm (insn, \"inconsistent operand constraints in an %<asm%>\");\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n       n_reloads = 0;\n@@ -3891,7 +3893,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \telse\n \t  {\n \t    gcc_assert (insn_code_number < 0);\n-\t    error_for_asm (insn, \"inconsistent operand constraints in an `asm'\");\n+\t    error_for_asm (insn, \"inconsistent operand constraints \"\n+\t\t\t   \"in an %<asm%>\");\n \t    /* Avoid further trouble with this insn.  */\n \t    PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n \t    n_reloads = 0;"}, {"sha": "8d2c2d8af1b6f60eb7fc53cab429b3f8849c32d1", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1871,11 +1871,12 @@ spill_failure (rtx insn, enum reg_class class)\n {\n   static const char *const reg_class_names[] = REG_CLASS_NAMES;\n   if (asm_noperands (PATTERN (insn)) >= 0)\n-    error_for_asm (insn, \"can't find a register in class `%s' while reloading `asm'\",\n+    error_for_asm (insn, \"can't find a register in class %qs while \"\n+\t\t   \"reloading %<asm%>\",\n \t\t   reg_class_names[class]);\n   else\n     {\n-      error (\"unable to find a register to spill in class `%s'\",\n+      error (\"unable to find a register to spill in class %qs\",\n \t     reg_class_names[class]);\n       fatal_insn (\"this is the insn:\", insn);\n     }\n@@ -3867,7 +3868,8 @@ reload_as_needed (int live_known)\n \t\t\t  || (extract_insn (p), ! constrain_operands (1))))\n \t\t    {\n \t\t      error_for_asm (insn,\n-\t\t\t\t     \"`asm' operand requires impossible reload\");\n+\t\t\t\t     \"%<asm%> operand requires \"\n+\t\t\t\t     \"impossible reload\");\n \t\t      delete_insn (p);\n \t\t    }\n \t    }\n@@ -4990,7 +4992,7 @@ failed_reload (rtx insn, int r)\n   /* It's the user's fault; the operand's mode and constraint\n      don't match.  Disable this reload so we don't crash in final.  */\n   error_for_asm (insn,\n-\t\t \"`asm' operand constraint incompatible with operand size\");\n+\t\t \"%<asm%> operand constraint incompatible with operand size\");\n   rld[r].in = 0;\n   rld[r].out = 0;\n   rld[r].reg_rtx = 0;\n@@ -6609,7 +6611,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n       if (asm_noperands (PATTERN (insn)) < 0)\n \t/* It's the compiler's fault.  */\n \tfatal_insn (\"VOIDmode on an output\", insn);\n-      error_for_asm (insn, \"output operand is constant in `asm'\");\n+      error_for_asm (insn, \"output operand is constant in %<asm%>\");\n       /* Prevent crash--use something we know is valid.  */\n       mode = word_mode;\n       old = gen_rtx_REG (mode, REGNO (reloadreg));"}, {"sha": "2db6dfa896dbe6e8a31397a3683b5728f801f5dd", "filename": "gcc/stmt.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -312,7 +312,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n      message.  */\n   if (!p)\n     {\n-      error (\"output operand constraint lacks `='\");\n+      error (\"output operand constraint lacks %<=%>\");\n       return false;\n     }\n \n@@ -327,7 +327,8 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n       size_t c_len = strlen (constraint);\n \n       if (p != constraint)\n-\twarning (\"output constraint `%c' for operand %d is not at the beginning\",\n+\twarning (\"output constraint %qc for operand %d \"\n+\t\t \"is not at the beginning\",\n \t\t *p, operand_num);\n \n       /* Make a copy of the constraint.  */\n@@ -349,13 +350,14 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n       {\n       case '+':\n       case '=':\n-\terror (\"operand constraint contains incorrectly positioned '+' or '='\");\n+\terror (\"operand constraint contains incorrectly positioned \"\n+\t       \"%<+%> or %<=%>\");\n \treturn false;\n \n       case '%':\n \tif (operand_num + 1 == ninputs + noutputs)\n \t  {\n-\t    error (\"`%%' constraint used with last operand\");\n+\t    error (\"%<%%%> constraint used with last operand\");\n \t    return false;\n \t  }\n \tbreak;\n@@ -445,7 +447,7 @@ parse_input_constraint (const char **constraint_p, int input_num,\n       case '+':  case '=':  case '&':\n \tif (constraint == orig_constraint)\n \t  {\n-\t    error (\"input operand constraint contains `%c'\", constraint[j]);\n+\t    error (\"input operand constraint contains %qc\", constraint[j]);\n \t    return false;\n \t  }\n \tbreak;\n@@ -454,7 +456,7 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \tif (constraint == orig_constraint\n \t    && input_num + 1 == ninputs - ninout)\n \t  {\n-\t    error (\"`%%' constraint used with last operand\");\n+\t    error (\"%<%%%> constraint used with last operand\");\n \t    return false;\n \t  }\n \tbreak;\n@@ -525,7 +527,7 @@ parse_input_constraint (const char **constraint_p, int input_num,\n       default:\n \tif (! ISALPHA (constraint[j]))\n \t  {\n-\t    error (\"invalid punctuation `%c' in constraint\", constraint[j]);\n+\t    error (\"invalid punctuation %qc in constraint\", constraint[j]);\n \t    return false;\n \t  }\n \tif (REG_CLASS_FROM_CONSTRAINT (constraint[j], constraint + j)\n@@ -604,7 +606,8 @@ decl_conflicts_with_clobbers_p (tree decl, const HARD_REG_SET clobbered_regs)\n \t   regno++)\n \tif (TEST_HARD_REG_BIT (clobbered_regs, regno))\n \t  {\n-\t    error (\"asm-specifier for variable `%s' conflicts with asm clobber list\",\n+\t    error (\"asm-specifier for variable %qs conflicts with \"\n+\t\t   \"asm clobber list\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n \t    /* Reset registerness to stop multiple errors emitted for a\n@@ -692,15 +695,15 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n       if (i >= 0 || i == -4)\n \t++nclobbers;\n       else if (i == -2)\n-\terror (\"unknown register name `%s' in `asm'\", regname);\n+\terror (\"unknown register name %qs in %<asm%>\", regname);\n \n       /* Mark clobbered registers.  */\n       if (i >= 0)\n         {\n \t  /* Clobbering the PIC register is an error */\n \t  if (i == (int) PIC_OFFSET_TABLE_REGNUM)\n \t    {\n-\t      error (\"PIC register `%s' clobbered in `asm'\", regname);\n+\t      error (\"PIC register %qs clobbered in %<asm%>\", regname);\n \t      return;\n \t    }\n \n@@ -747,7 +750,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   ninputs += ninout;\n   if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n     {\n-      error (\"more than %d operands in `asm'\", MAX_RECOG_OPERANDS);\n+      error (\"more than %d operands in %<asm%>\", MAX_RECOG_OPERANDS);\n       return;\n     }\n \n@@ -889,7 +892,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t  if (allows_reg)\n \t    op = force_reg (TYPE_MODE (type), op);\n \t  else if (!allows_mem)\n-\t    warning (\"asm operand %d probably doesn't match constraints\",\n+\t    warning (\"asm operand %d probably doesn%'t match constraints\",\n \t\t     i + noutputs);\n \t  else if (MEM_P (op))\n \t    {\n@@ -1127,7 +1130,7 @@ check_operand_nalternatives (tree outputs, tree inputs)\n \n       if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n \t{\n-\t  error (\"too many alternatives in `asm'\");\n+\t  error (\"too many alternatives in %<asm%>\");\n \t  return false;\n \t}\n \n@@ -1139,7 +1142,8 @@ check_operand_nalternatives (tree outputs, tree inputs)\n \n \t  if (n_occurrences (',', constraint) != nalternatives)\n \t    {\n-\t      error (\"operand constraints for `asm' differ in number of alternatives\");\n+\t      error (\"operand constraints for %<asm%> differ \"\n+\t\t     \"in number of alternatives\");\n \t      return false;\n \t    }\n \n@@ -1191,7 +1195,7 @@ check_unique_operand_names (tree outputs, tree inputs)\n   return true;\n \n  failure:\n-  error (\"duplicate asm operand name '%s'\",\n+  error (\"duplicate asm operand name %qs\",\n \t TREE_STRING_POINTER (TREE_PURPOSE (TREE_PURPOSE (i))));\n   return false;\n }\n@@ -1317,7 +1321,7 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs)\n     }\n \n   *q = '\\0';\n-  error (\"undefined named operand '%s'\", p + 1);\n+  error (\"undefined named operand %qs\", p + 1);\n   op = 0;\n  found:\n "}, {"sha": "ccbca424bbfb128eb8f646284a88f194fed5e80c", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -149,7 +149,7 @@ variable_size (tree size)\n   if (lang_hooks.decls.global_bindings_p ())\n     {\n       if (TREE_CONSTANT (size))\n-\terror (\"type size can't be explicitly evaluated\");\n+\terror (\"type size can%'t be explicitly evaluated\");\n       else\n \terror (\"variable-size type declared outside of any function\");\n \n@@ -455,9 +455,9 @@ layout_decl (tree decl, unsigned int known_align)\n \t  int size_as_int = TREE_INT_CST_LOW (size);\n \n \t  if (compare_tree_int (size, size_as_int) == 0)\n-\t    warning (\"%Jsize of '%D' is %d bytes\", decl, decl, size_as_int);\n+\t    warning (\"%Jsize of %qD is %d bytes\", decl, decl, size_as_int);\n \t  else\n-\t    warning (\"%Jsize of '%D' is larger than %d bytes\",\n+\t    warning (\"%Jsize of %qD is larger than %d bytes\",\n                      decl, decl, larger_than_size);\n \t}\n     }\n@@ -840,9 +840,9 @@ place_field (record_layout_info rli, tree field)\n \t    {\n \t      if (STRICT_ALIGNMENT)\n \t\twarning (\"%Jpacked attribute causes inefficient alignment \"\n-                         \"for '%D'\", field, field);\n+                         \"for %qD\", field, field);\n \t      else\n-\t\twarning (\"%Jpacked attribute is unnecessary for '%D'\",\n+\t\twarning (\"%Jpacked attribute is unnecessary for %qD\",\n \t\t\t field, field);\n \t    }\n \t}\n@@ -858,7 +858,7 @@ place_field (record_layout_info rli, tree field)\n \t Bump the cumulative size to multiple of field alignment.  */\n \n       if (warn_padded)\n-\twarning (\"%Jpadding struct to align '%D'\", field, field);\n+\twarning (\"%Jpadding struct to align %qD\", field, field);\n \n       /* If the alignment is still within offset_align, just align\n \t the bit position.  */\n@@ -1230,9 +1230,10 @@ finalize_record_size (record_layout_info rli)\n \t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (rli->t)));\n \n \t      if (STRICT_ALIGNMENT)\n-\t\twarning (\"packed attribute causes inefficient alignment for `%s'\", name);\n+\t\twarning (\"packed attribute causes inefficient \"\n+\t\t\t \"alignment for %qs\", name);\n \t      else\n-\t\twarning (\"packed attribute is unnecessary for `%s'\", name);\n+\t\twarning (\"packed attribute is unnecessary for %qs\", name);\n \t    }\n \t  else\n \t    {"}, {"sha": "e04c94049e0778c08cb44f3a37b840b394a858e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1,3 +1,9 @@\n+2004-09-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* g++.dg/ext/member-attr.C, g++.dg/warn/deprecated.C,\n+\tgcc.dg/deprecated.c, gcc.dg/noreturn-1.c, gcc.dg/noreturn-4.c:\n+\tUpdate expected messages.\n+\n 2004-09-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/16485"}, {"sha": "ede63c1572930c7752c8dbe2ef728960f6a6ca1a", "filename": "gcc/testsuite/g++.dg/ext/member-attr.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmember-attr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmember-attr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmember-attr.C?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -9,6 +9,6 @@\n \n class T {\n   public:\n-    __attribute__ ((garbage1)) void member1(int) {} /* { dg-error \"`garbage1' attribute directive ignored\" \"\" } */\n-    void __attribute__ ((garbage2)) member2(int) {} /* { dg-error \"`garbage2' attribute directive ignored\" \"\" } */\n+    __attribute__ ((garbage1)) void member1(int) {} /* { dg-error \"'garbage1' attribute directive ignored\" \"\" } */\n+    void __attribute__ ((garbage2)) member2(int) {} /* { dg-error \"'garbage2' attribute directive ignored\" \"\" } */\n };"}, {"sha": "21b901af4f592c55e1eceabcfe1031773a952f19", "filename": "gcc/testsuite/g++.dg/warn/deprecated.C", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdeprecated.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdeprecated.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdeprecated.C?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -6,26 +6,26 @@\n typedef int INT1 __attribute__((deprecated));\n typedef INT1 INT2 __attribute__ ((__deprecated__));\n \n-typedef INT1 INT1a; \t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+typedef INT1 INT1a; \t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n typedef INT1 INT1b __attribute__ ((deprecated));\n \n-INT1 should_be_unavailable; \t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+INT1 should_be_unavailable; \t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n INT1a should_not_be_deprecated;\n \n INT1 f1(void) __attribute__ ((deprecated)); \n-INT1 f2(void) { return 0; }\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+INT1 f2(void) { return 0; }\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n \n INT2 f3(void) __attribute__ ((__deprecated__)); \n-INT2 f4(void) { return 0; }\t\t/* { dg-warning \"`INT2' is deprecated\" \"\" } */\n-int f5(INT2 x);\t\t\t\t/* { dg-warning \"`INT2' is deprecated\" \"\" } */\n+INT2 f4(void) { return 0; }\t\t/* { dg-warning \"'INT2' is deprecated\" \"\" } */\n+int f5(INT2 x);\t\t\t\t/* { dg-warning \"'INT2' is deprecated\" \"\" } */\n int f6(INT2 x) __attribute__ ((__deprecated__));\n \n typedef enum Color {red, green, blue} Color __attribute__((deprecated));\n \n int g1;\n int g2 __attribute__ ((deprecated));\n int g3 __attribute__ ((__deprecated__));\n-Color k;\t\t\t\t/* { dg-warning \"`Color' is deprecated\" \"\" } */\n+Color k;\t\t\t\t/* { dg-warning \"'Color' is deprecated\" \"\" } */\n \n typedef struct {\n   int field1;\n@@ -46,54 +46,54 @@ typedef struct {\n \n int func1()\n {\n-   INT1 w;\t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+   INT1 w;\t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n    int x __attribute__ ((deprecated));\n    int y __attribute__ ((__deprecated__));\n    int z;\n-   int (*pf)() = f1;\t\t\t/* { dg-warning \"`f1' is deprecated\" \"\" } */\n+   int (*pf)() = f1;\t\t\t/* { dg-warning \"'f1' is deprecated\" \"\" } */\n \n-   z = w + x + y + g1 + g2 + g3;\t/* { dg-warning \"`x' is deprecated\" \"\" } */\n-   \t\t\t\t\t/* { dg-warning \"`y' is deprecated\" \"\" { target *-*-* } 55 } */\n-   \t\t\t\t\t/* { dg-warning \"`g2' is deprecated\" \"\" { target *-*-* } 55 } */\n-   \t\t\t\t\t/* { dg-warning \"`g3' is deprecated\" \"\" { target *-*-* } 55 } */\n-   return f1(); \t\t\t/* { dg-warning \"`f1' is deprecated\" \"\" } */\n+   z = w + x + y + g1 + g2 + g3;\t/* { dg-warning \"'x' is deprecated\" \"\" } */\n+   \t\t\t\t\t/* { dg-warning \"'y' is deprecated\" \"\" { target *-*-* } 55 } */\n+   \t\t\t\t\t/* { dg-warning \"'g2' is deprecated\" \"\" { target *-*-* } 55 } */\n+   \t\t\t\t\t/* { dg-warning \"'g3' is deprecated\" \"\" { target *-*-* } 55 } */\n+   return f1(); \t\t\t/* { dg-warning \"'f1' is deprecated\" \"\" } */\n }\n \n int func2(S1 *p)\n {\n   S1 lp;\n   \n   if (p->field1)\n-     return p->field2;\t\t\t/* { dg-warning \"`field2' is deprecated\" \"\" } */\n-  else if (lp.field4)\t\t\t/* { dg-warning \"`field4' is deprecated\" \"\" } */\n+     return p->field2;\t\t\t/* { dg-warning \"'field2' is deprecated\" \"\" } */\n+  else if (lp.field4)\t\t\t/* { dg-warning \"'field4' is deprecated\" \"\" } */\n      return p->field3;\n   \n   p->u1.field5 = g1 + p->field7;\n-  p->u2.field9;\t\t\t\t/* { dg-warning \"`u2' is deprecated\" \"\" } */\n-  return p->u1.field6 + p->field8;\t/* { dg-warning \"`field6' is deprecated\" \"\" } */\n-  \t\t\t\t\t/* { dg-warning \"`field8' is deprecated\" \"\" { target *-*-* } 73 } */\n+  p->u2.field9;\t\t\t\t/* { dg-warning \"'u2' is deprecated\" \"\" } */\n+  return p->u1.field6 + p->field8;\t/* { dg-warning \"'field6' is deprecated\" \"\" } */\n+  \t\t\t\t\t/* { dg-warning \"'field8' is deprecated\" \"\" { target *-*-* } 73 } */\n }\n \n struct SS1 {\n   int x;\n-  INT1 y; \t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+  INT1 y; \t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n } __attribute__ ((deprecated));\n \n-struct SS1 *p1;\t\t\t\t/* { dg-warning \"`SS1' is deprecated\" \"\" } */\n+struct SS1 *p1;\t\t\t\t/* { dg-warning \"'SS1' is deprecated\" \"\" } */\n \n struct __attribute__ ((__deprecated__)) SS2 {\n   int x;\n-  INT1 y; \t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+  INT1 y; \t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n };\n \n-struct SS2 *p2;\t\t\t\t/* { dg-warning \"`SS2' is deprecated\" \"\" } */\n+struct SS2 *p2;\t\t\t\t/* { dg-warning \"'SS2' is deprecated\" \"\" } */\n #endif\n \n #ifdef __cplusplus\n class T {\n   public:\n     void member1(int) __attribute__ ((deprecated));\n-    void member2(INT1) __attribute__ ((__deprecated__)); /* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+    void member2(INT1) __attribute__ ((__deprecated__)); /* { dg-warning \"'INT1' is deprecated\" \"\" } */\n     int member3(T *);\n     int x;\n } __attribute__ ((deprecated));\n@@ -104,13 +104,13 @@ inline void T::member1(int) {}\n \n int T::member3(T *p)\n {\n-  p->member1(1);\t\t\t/* { dg-warning \"`member1' is deprecated\" \"\" } */\n-  (*p).member1(2);\t\t\t/* { dg-warning \"`member1' is deprecated\" \"\" } */\n-  p->member2(1);\t\t\t/* { dg-warning \"`member2' is deprecated\" \"\" } */\n-  (*p).member2(2);\t\t\t/* { dg-warning \"`member2' is deprecated\" \"\" } */\n+  p->member1(1);\t\t\t/* { dg-warning \"'member1' is deprecated\" \"\" } */\n+  (*p).member1(2);\t\t\t/* { dg-warning \"'member1' is deprecated\" \"\" } */\n+  p->member2(1);\t\t\t/* { dg-warning \"'member2' is deprecated\" \"\" } */\n+  (*p).member2(2);\t\t\t/* { dg-warning \"'member2' is deprecated\" \"\" } */\n   p->member3(p);\n   (*p).member3(p);\n-  return f1(); \t\t\t\t/* { dg-warning \"`f1' is deprecated\" \"\" } */\n+  return f1(); \t\t\t\t/* { dg-warning \"'f1' is deprecated\" \"\" } */\n }\n #endif\n "}, {"sha": "1e07efe6314b91504d9db231fa8c6595b7683bdc", "filename": "gcc/testsuite/gcc.dg/deprecated.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fdeprecated.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fdeprecated.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeprecated.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -6,26 +6,26 @@\n typedef int INT1 __attribute__((deprecated));\n typedef INT1 INT2 __attribute__ ((__deprecated__));\n \n-typedef INT1 INT1a; \t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+typedef INT1 INT1a; \t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n typedef INT1 INT1b __attribute__ ((deprecated));\n \n-INT1 should_be_unavailable; \t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+INT1 should_be_unavailable; \t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n INT1a should_not_be_deprecated;\n \n INT1 f1(void) __attribute__ ((deprecated)); \n-INT1 f2(void) { return 0; }\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+INT1 f2(void) { return 0; }\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n \n INT2 f3(void) __attribute__ ((__deprecated__)); \n-INT2 f4(void) { return 0; }\t\t/* { dg-warning \"`INT2' is deprecated\" \"\" } */\n-int f5(INT2 x);\t\t\t\t/* { dg-warning \"`INT2' is deprecated\" \"\" } */\n-int f6(INT2 x) __attribute__ ((__deprecated__)); /* { dg-warning \"`INT2' is deprecated\" \"\" } */\n+INT2 f4(void) { return 0; }\t\t/* { dg-warning \"'INT2' is deprecated\" \"\" } */\n+int f5(INT2 x);\t\t\t\t/* { dg-warning \"'INT2' is deprecated\" \"\" } */\n+int f6(INT2 x) __attribute__ ((__deprecated__)); /* { dg-warning \"'INT2' is deprecated\" \"\" } */\n \n typedef enum {red, green, blue} Color __attribute__((deprecated));\n \n int g1;\n int g2 __attribute__ ((deprecated));\n int g3 __attribute__ ((__deprecated__));\n-Color k;\t\t\t\t/* { dg-warning \"`Color' is deprecated\" \"\" } */\n+Color k;\t\t\t\t/* { dg-warning \"'Color' is deprecated\" \"\" } */\n \n typedef struct {\n   int field1;\n@@ -46,47 +46,47 @@ typedef struct {\n \n int func1()\n {\n-   INT1 w;\t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+   INT1 w;\t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n    int x __attribute__ ((deprecated));\n    int y __attribute__ ((__deprecated__));\n    int z;\n-   int (*pf)() = f1;\t\t\t/* { dg-warning \"`f1' is deprecated\" \"\" } */\n+   int (*pf)() = f1;\t\t\t/* { dg-warning \"'f1' is deprecated\" \"\" } */\n \n-   z = w + x + y + g1 + g2 + g3;\t/* { dg-warning \"`x' is deprecated\" \"\" } */\n-   \t\t\t\t\t/* { dg-warning \"`y' is deprecated\" \"\" { target *-*-* } 55 } */\n-   \t\t\t\t\t/* { dg-warning \"`g2' is deprecated\" \"\" { target *-*-* } 55 } */\n-   \t\t\t\t\t/* { dg-warning \"`g3' is deprecated\" \"\" { target *-*-* } 55 } */\n-   return f1(); \t\t\t/* { dg-warning \"`f1' is deprecated\" \"\" } */\n+   z = w + x + y + g1 + g2 + g3;\t/* { dg-warning \"'x' is deprecated\" \"\" } */\n+   \t\t\t\t\t/* { dg-warning \"'y' is deprecated\" \"\" { target *-*-* } 55 } */\n+   \t\t\t\t\t/* { dg-warning \"'g2' is deprecated\" \"\" { target *-*-* } 55 } */\n+   \t\t\t\t\t/* { dg-warning \"'g3' is deprecated\" \"\" { target *-*-* } 55 } */\n+   return f1(); \t\t\t/* { dg-warning \"'f1' is deprecated\" \"\" } */\n }\n \n int func2(S1 *p)\n {\n   S1 lp;\n   \n   if (p->field1)\n-     return p->field2;\t\t\t/* { dg-warning \"`field2' is deprecated\" \"\" } */\n-  else if (lp.field4)\t\t\t/* { dg-warning \"`field4' is deprecated\" \"\" } */\n+     return p->field2;\t\t\t/* { dg-warning \"'field2' is deprecated\" \"\" } */\n+  else if (lp.field4)\t\t\t/* { dg-warning \"'field4' is deprecated\" \"\" } */\n      return p->field3;\n   \n   p->u1.field5 = g1 + p->field7;\n-  p->u2.field9;\t\t\t\t/* { dg-warning \"`u2' is deprecated\" \"\" } */\n-  return p->u1.field6 + p->field8;\t/* { dg-warning \"`field6' is deprecated\" \"\" } */\n-  \t\t\t\t\t/* { dg-warning \"`field8' is deprecated\" \"\" { target *-*-* } 73 } */\n+  p->u2.field9;\t\t\t\t/* { dg-warning \"'u2' is deprecated\" \"\" } */\n+  return p->u1.field6 + p->field8;\t/* { dg-warning \"'field6' is deprecated\" \"\" } */\n+  \t\t\t\t\t/* { dg-warning \"'field8' is deprecated\" \"\" { target *-*-* } 73 } */\n }\n \n struct SS1 {\n   int x;\n-  INT1 y; \t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+  INT1 y; \t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n } __attribute__ ((deprecated));\n \n-struct SS1 *p1;\t\t\t\t/* { dg-warning \"`SS1' is deprecated\" \"\" } */\n+struct SS1 *p1;\t\t\t\t/* { dg-warning \"'SS1' is deprecated\" \"\" } */\n \n struct __attribute__ ((__deprecated__)) SS2 {\n   int x;\n-  INT1 y; \t\t\t\t/* { dg-warning \"`INT1' is deprecated\" \"\" } */\n+  INT1 y; \t\t\t\t/* { dg-warning \"'INT1' is deprecated\" \"\" } */\n };\n \n-struct SS2 *p2;\t\t\t\t/* { dg-warning \"`SS2' is deprecated\" \"\" } */\n+struct SS2 *p2;\t\t\t\t/* { dg-warning \"'SS2' is deprecated\" \"\" } */\n #endif\n \n #ifdef __cplusplus\n@@ -104,13 +104,13 @@ inline void T::member1(int) {}\n \n int T::member2(T *p)\n {\n-  p->member1(1);\t\t\t/* { xxdg-warning \"`member1' is deprecated\" \"\" } */\n-  (*p).member1(2);\t\t\t/* { xxdg-warning \"`member1' is deprecated\" \"\" } */\n-  p->member2(1);\t\t\t/* { xxdg-warning \"`member2' is deprecated\" \"\" } */\n-  (*p).member2(2);\t\t\t/* { xxdg-warning \"`member2' is deprecated\" \"\" } */\n+  p->member1(1);\t\t\t/* { xxdg-warning \"'member1' is deprecated\" \"\" } */\n+  (*p).member1(2);\t\t\t/* { xxdg-warning \"'member1' is deprecated\" \"\" } */\n+  p->member2(1);\t\t\t/* { xxdg-warning \"'member2' is deprecated\" \"\" } */\n+  (*p).member2(2);\t\t\t/* { xxdg-warning \"'member2' is deprecated\" \"\" } */\n   p->member3(p);\n   (*p).member3(p);\n-  return f1(); \t\t\t\t/* { xxdg-warning \"`f1' is deprecated\" \"\" } */\n+  return f1(); \t\t\t\t/* { xxdg-warning \"'f1' is deprecated\" \"\" } */\n }\n #endif\n "}, {"sha": "3bd6a26c582cb8462be7e77b91c38c71c9eaa318", "filename": "gcc/testsuite/gcc.dg/noreturn-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -8,7 +8,7 @@ extern void foo1(void) __attribute__ ((__noreturn__));\n void\n foo1(void)\n {\n-} /* { dg-warning \"`noreturn' function does return\" \"detect falling off end of noreturn\" } */\n+} /* { dg-warning \"'noreturn' function does return\" \"detect falling off end of noreturn\" } */\n \n extern void foo2(void) __attribute__ ((__noreturn__));\n void\n@@ -26,7 +26,7 @@ foo3(void)\n extern void foo4(void);\n void\n foo4(void)\n-{ /* { dg-warning \"candidate for attribute `noreturn'\" \"detect noreturn candidate\" } */\n+{ /* { dg-warning \"candidate for attribute 'noreturn'\" \"detect noreturn candidate\" } */\n   exit(0);\n }\n \n@@ -56,4 +56,4 @@ void\n foo8(void)\n {\n   foo7();\n-} /* { dg-warning \"`noreturn' function does return\" \"detect return from tail call\" } */\n+} /* { dg-warning \"'noreturn' function does return\" \"detect return from tail call\" } */"}, {"sha": "91f64573a55d1fdac95417c8990ae45b35a1c073", "filename": "gcc/testsuite/gcc.dg/noreturn-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-4.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -5,6 +5,6 @@ extern void exit (int) __attribute__ ((__noreturn__));\n \n int\n main (void)\n-{ /* { dg-warning \"warning: function might be possible candidate for attribute `noreturn'\" \"warn for main\" } */\n+{ /* { dg-warning \"warning: function might be possible candidate for attribute 'noreturn'\" \"warn for main\" } */\n   exit (0);\n }"}, {"sha": "848bfca570bb3987546eef11366321b7cbaeba6c", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -534,7 +534,7 @@ read_integral_parameter (const char *p, const char *pname, const int  defval)\n   if (*endp != 0)\n     {\n       if (pname != 0)\n-\terror (\"invalid option argument `%s'\", pname);\n+\terror (\"invalid option argument %qs\", pname);\n       return defval;\n     }\n \n@@ -840,9 +840,10 @@ check_global_declarations (tree *vec, int len)\n \t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t{\n \t  if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t    pedwarn (\"%J'%F' used but never defined\", decl, decl);\n+\t    pedwarn (\"%J%qF used but never defined\", decl, decl);\n \t  else\n-\t    warning (\"%J'%F' declared `static' but never defined\", decl, decl);\n+\t    warning (\"%J%qF declared %<static%> but never defined\",\n+\t\t     decl, decl);\n \t  /* This symbol is effectively an \"extern\" declaration now.  */\n \t  TREE_PUBLIC (decl) = 1;\n \t  assemble_external (decl);\n@@ -867,7 +868,7 @@ check_global_declarations (tree *vec, int len)\n \t  && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n \t  /* Otherwise, ask the language.  */\n \t  && lang_hooks.decls.warn_unused_global (decl))\n-\twarning (\"%J'%D' defined but not used\", decl, decl);\n+\twarning (\"%J%qD defined but not used\", decl, decl);\n \n       /* Avoid confusing the debug information machinery when there are\n \t errors.  */\n@@ -890,7 +891,7 @@ warn_deprecated_use (tree node)\n   if (DECL_P (node))\n     {\n       expanded_location xloc = expand_location (DECL_SOURCE_LOCATION (node));\n-      warning (\"`%s' is deprecated (declared at %s:%d)\",\n+      warning (\"%qs is deprecated (declared at %s:%d)\",\n \t       IDENTIFIER_POINTER (DECL_NAME (node)),\n \t       xloc.file, xloc.line);\n     }\n@@ -913,7 +914,7 @@ warn_deprecated_use (tree node)\n \t  expanded_location xloc\n \t    = expand_location (DECL_SOURCE_LOCATION (decl));\n \t  if (what)\n-\t    warning (\"`%s' is deprecated (declared at %s:%d)\", what,\n+\t    warning (\"%qs is deprecated (declared at %s:%d)\", what,\n \t\t       xloc.file, xloc.line);\n \t  else\n \t    warning (\"type is deprecated (declared at %s:%d)\",\n@@ -922,7 +923,7 @@ warn_deprecated_use (tree node)\n       else\n \t{\n \t  if (what)\n-\t    warning (\"`%s' is deprecated\", what);\n+\t    warning (\"%qs is deprecated\", what);\n \t  else\n \t    warning (\"type is deprecated\");\n \t}\n@@ -1216,7 +1217,7 @@ set_target_switch (const char *name)\n #endif\n \n   if (!valid_target_option)\n-    error (\"invalid option `%s'\", name);\n+    error (\"invalid option %qs\", name);\n }\n \n /* Print version information to FILE.\n@@ -1393,7 +1394,7 @@ init_asm_output (const char *name)\n       else\n \tasm_out_file = fopen (asm_file_name, \"w+b\");\n       if (asm_out_file == 0)\n-\tfatal_error (\"can't open %s for writing: %m\", asm_file_name);\n+\tfatal_error (\"can%'t open %s for writing: %m\", asm_file_name);\n     }\n \n #ifdef IO_BUFFER_SIZE\n@@ -1529,7 +1530,7 @@ default_pch_valid_p (const void *data_p, size_t len)\n  make_message:\n   {\n     char *r;\n-    asprintf (&r, _(\"created and used with differing settings of `-m%s'\"),\n+    asprintf (&r, _(\"created and used with differing settings of '-m%s'\"),\n \t\t  flag_that_differs);\n     if (r == NULL)\n       return _(\"out of memory\");\n@@ -1861,7 +1862,7 @@ process_options (void)\n     {\n       aux_info_file = fopen (aux_info_file_name, \"w\");\n       if (aux_info_file == 0)\n-\tfatal_error (\"can't open %s: %m\", aux_info_file_name);\n+\tfatal_error (\"can%'t open %s: %m\", aux_info_file_name);\n     }\n \n   if (! targetm.have_named_sections)"}, {"sha": "b8b712b9dce792ca67771b9c8213b81c3fa463d2", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -3274,7 +3274,7 @@ verify_stmt (tree stmt, bool last_in_block)\n     {\n       if (!tree_could_throw_p (stmt))\n \t{\n-\t  error (\"Statement marked for throw, but doesn't.\");\n+\t  error (\"Statement marked for throw, but doesn%'t.\");\n \t  goto fail;\n \t}\n       if (!last_in_block && tree_can_throw_internal (stmt))\n@@ -3555,15 +3555,15 @@ tree_verify_flow_info (void)\n \t    if (!has_label_p (true_edge->dest,\n \t\t\t      GOTO_DESTINATION (COND_EXPR_THEN (stmt))))\n \t      {\n-\t\terror (\"`then' label does not match edge at end of bb %d\\n\",\n+\t\terror (\"%<then%> label does not match edge at end of bb %d\\n\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n \n \t    if (!has_label_p (false_edge->dest,\n \t\t\t      GOTO_DESTINATION (COND_EXPR_ELSE (stmt))))\n \t      {\n-\t\terror (\"`else' label does not match edge at end of bb %d\\n\",\n+\t\terror (\"%<else%> label does not match edge at end of bb %d\\n\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n@@ -4842,7 +4842,8 @@ execute_warn_function_return (void)\n       && !TREE_THIS_VOLATILE (cfun->decl)\n       && EXIT_BLOCK_PTR->pred == NULL\n       && !lang_hooks.function.missing_noreturn_ok_p (cfun->decl))\n-    warning (\"%Jfunction might be possible candidate for attribute `noreturn'\",\n+    warning (\"%Jfunction might be possible candidate for \"\n+\t     \"attribute %<noreturn%>\",\n \t     cfun->decl);\n \n   /* If we have a path to EXIT, then we do return.  */\n@@ -4868,11 +4869,11 @@ execute_warn_function_return (void)\n #ifdef USE_MAPPED_LOCATION\n       if (location == UNKNOWN_LOCATION)\n \tlocation = cfun->function_end_locus;\n-      warning (\"%H`noreturn' function does return\", &location);\n+      warning (\"%H%<noreturn%> function does return\", &location);\n #else\n       if (!locus)\n \tlocus = &cfun->function_end_locus;\n-      warning (\"%H`noreturn' function does return\", locus);\n+      warning (\"%H%<noreturn%> function does return\", locus);\n #endif\n     }\n "}, {"sha": "a8818c30f869e1149fbc3717721edad4dbbd0e75", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -842,7 +842,7 @@ dump_begin (enum tree_dump_index phase, int *flag_ptr)\n   dfi = get_dump_file_info (phase);\n   stream = fopen (name, dfi->state < 0 ? \"w\" : \"a\");\n   if (!stream)\n-    error (\"could not open dump file `%s': %s\", name, strerror (errno));\n+    error (\"could not open dump file %qs: %s\", name, strerror (errno));\n   else\n     dfi->state = 1;\n   free (name);\n@@ -955,7 +955,7 @@ dump_switch_p_1 (const char *arg, struct dump_file_info *dfi)\n \t    flags |= option_ptr->value;\n \t    goto found;\n \t  }\n-      warning (\"ignoring unknown option `%.*s' in `-fdump-%s'\",\n+      warning (\"ignoring unknown option %q.*s in %<-fdump-%s%>\",\n \t       length, ptr, dfi->swtch);\n     found:;\n       ptr = end_ptr;"}, {"sha": "d5e278d6b213d60fd7905b89c5afd828e21a374f", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1160,7 +1160,7 @@ mudflap_enqueue_decl (tree obj)\n       for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_static_decls); i++)\n         if (VARRAY_TREE (deferred_static_decls, i) == obj)\n           {\n-            warning (\"mudflap cannot track lifetime of `%s'\",\n+            warning (\"mudflap cannot track lifetime of %qs\",\n                      IDENTIFIER_POINTER (DECL_NAME (obj)));\n             return;\n           }"}, {"sha": "392d997535c28825712e790f349614f53d830ef6", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -3072,7 +3072,7 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n \t}\n       if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n \t{\n-\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n \t  *no_add_attrs = true;\n \t}\n \n@@ -3090,15 +3090,15 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       if (TREE_CODE (node) == FUNCTION_DECL  && DECL_INITIAL (node)\n           && !DECL_DECLARED_INLINE_P (node))\n \t{\n-\t  error (\"%Jfunction `%D' definition is marked dllimport.\", node, node);\n+\t  error (\"%Jfunction %qD definition is marked dllimport.\", node, node);\n \t  *no_add_attrs = true;\n \t}\n \n       else if (TREE_CODE (node) == VAR_DECL)\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n-\t      error (\"%Jvariable `%D' definition is marked dllimport.\",\n+\t      error (\"%Jvariable %qD definition is marked dllimport.\",\n \t\t     node, node);\n \t      *no_add_attrs = true;\n \t    }\n@@ -3118,8 +3118,8 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       && (TREE_CODE (node) == VAR_DECL\n \t  || TREE_CODE (node) == FUNCTION_DECL))\n     {\n-      error (\"%Jexternal linkage required for symbol '%D' because of \"\n-\t     \"'%s' attribute.\", node, node, IDENTIFIER_POINTER (name));\n+      error (\"%Jexternal linkage required for symbol %qD because of \"\n+\t     \"%qs attribute.\", node, node, IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5316,7 +5316,7 @@ tree_class_check_failed (const tree node, int cl, const char *file,\n \t\t\t int line, const char *function)\n {\n   internal_error\n-    (\"tree check: expected class '%c', have '%c' (%s) in %s, at %s:%d\",\n+    (\"tree check: expected class %qc, have %qc (%s) in %s, at %s:%d\",\n      cl, TREE_CODE_CLASS (TREE_CODE (node)),\n      tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n }"}, {"sha": "b5362b920016a34217524818b15e49137fd2cb6b", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -897,14 +897,14 @@ make_decl_rtl (tree decl)\n     {\n       /* First detect errors in declaring global registers.  */\n       if (reg_number == -1)\n-\terror (\"%Jregister name not specified for '%D'\", decl, decl);\n+\terror (\"%Jregister name not specified for %qD\", decl, decl);\n       else if (reg_number < 0)\n-\terror (\"%Jinvalid register name for '%D'\", decl, decl);\n+\terror (\"%Jinvalid register name for %qD\", decl, decl);\n       else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n-\terror (\"%Jdata type of '%D' isn't suitable for a register\",\n+\terror (\"%Jdata type of %qD isn%'t suitable for a register\",\n \t       decl, decl);\n       else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n-\terror (\"%Jregister specified for '%D' isn't suitable for data type\",\n+\terror (\"%Jregister specified for %qD isn%'t suitable for data type\",\n                decl, decl);\n       /* Now handle properly declared static register variables.  */\n       else\n@@ -917,7 +917,8 @@ make_decl_rtl (tree decl)\n \t      error (\"global register variable has initial value\");\n \t    }\n \t  if (TREE_THIS_VOLATILE (decl))\n-\t    warning (\"volatile register variables don't work as you might wish\");\n+\t    warning (\"volatile register variables don%'t \"\n+\t\t     \"work as you might wish\");\n \n \t  /* If the user specified one of the eliminables registers here,\n \t     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable\n@@ -949,7 +950,7 @@ make_decl_rtl (tree decl)\n      Also handle vars declared register invalidly.  */\n \n   if (name[0] == '*' && (reg_number >= 0 || reg_number == -3))\n-    error (\"%Jregister name given for non-register variable '%D'\", decl, decl);\n+    error (\"%Jregister name given for non-register variable %qD\", decl, decl);\n \n   /* Specifying a section attribute on a variable forces it into a\n      non-.bss section, and thus it cannot be common.  */\n@@ -1519,7 +1520,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   if (!dont_output_data && DECL_SIZE (decl) == 0)\n     {\n-      error (\"%Jstorage size of `%D' isn't known\", decl, decl);\n+      error (\"%Jstorage size of %qD isn%'t known\", decl, decl);\n       TREE_ASM_WRITTEN (decl) = 1;\n       return;\n     }\n@@ -1547,7 +1548,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (! dont_output_data\n       && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n     {\n-      error (\"%Jsize of variable '%D' is too large\", decl, decl);\n+      error (\"%Jsize of variable %qD is too large\", decl, decl);\n       return;\n     }\n \n@@ -1570,7 +1571,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n      In particular, a.out format supports a maximum alignment of 4.  */\n   if (align > MAX_OFILE_ALIGNMENT)\n     {\n-      warning (\"%Jalignment of '%D' is greater than maximum object \"\n+      warning (\"%Jalignment of %qD is greater than maximum object \"\n                \"file alignment.  Using %d\", decl, decl,\n \t       MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n       align = MAX_OFILE_ALIGNMENT;\n@@ -1644,7 +1645,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n       if ((unsigned HOST_WIDE_INT) DECL_ALIGN_UNIT (decl) > rounded)\n-\twarning (\"%Jrequested alignment for '%D' is greater than \"\n+\twarning (\"%Jrequested alignment for %qD is greater than \"\n                  \"implemented alignment of %d\", decl, decl, rounded);\n #endif\n \n@@ -4011,7 +4012,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t  total_bytes += fieldsize;\n \t}\n       else if (val != 0 && TREE_CODE (val) != INTEGER_CST)\n-\terror (\"invalid initial value for member `%s'\",\n+\terror (\"invalid initial value for member %qs\",\n \t       IDENTIFIER_POINTER (DECL_NAME (field)));\n       else\n \t{\n@@ -4198,15 +4199,15 @@ merge_weak (tree newdecl, tree olddecl)\n \t declare_weak because the NEWDECL and OLDDECL was not yet\n \t been merged; therefore, TREE_ASM_WRITTEN was not set.  */\n       if (TREE_ASM_WRITTEN (olddecl))\n-\terror (\"%Jweak declaration of '%D' must precede definition\",\n+\terror (\"%Jweak declaration of %qD must precede definition\",\n \t       newdecl, newdecl);\n \n       /* If we've already generated rtl referencing OLDDECL, we may\n \t have done so in a way that will not function properly with\n \t a weak symbol.  */\n       else if (TREE_USED (olddecl)\n \t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (olddecl)))\n-\twarning (\"%Jweak declaration of '%D' after first use results \"\n+\twarning (\"%Jweak declaration of %qD after first use results \"\n                  \"in unspecified behavior\", newdecl, newdecl);\n \n       if (SUPPORTS_WEAK)\n@@ -4240,16 +4241,16 @@ void\n declare_weak (tree decl)\n {\n   if (! TREE_PUBLIC (decl))\n-    error (\"%Jweak declaration of '%D' must be public\", decl, decl);\n+    error (\"%Jweak declaration of %qD must be public\", decl, decl);\n   else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n-    error (\"%Jweak declaration of '%D' must precede definition\", decl, decl);\n+    error (\"%Jweak declaration of %qD must precede definition\", decl, decl);\n   else if (SUPPORTS_WEAK)\n     {\n       if (! DECL_WEAK (decl))\n \tweak_decls = tree_cons (NULL, decl, weak_decls);\n     }\n   else\n-    warning (\"%Jweak declaration of '%D' not supported\", decl, decl);\n+    warning (\"%Jweak declaration of %qD not supported\", decl, decl);\n \n   mark_weak (decl);\n }"}, {"sha": "984e22bbe7312764d31590b7d4ccd29d2ee09159", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -1,3 +1,7 @@\n+2004-09-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* testsuite/libmudflap.c/pass35-frag.c: Update expected message.\n+\n 2004-09-07  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* configure.ac: Look for pwd.h, grp.h, netdb.h headers and functions."}, {"sha": "dbd9737a92e490e644316ab7bcb4f29431ca91b0", "filename": "libmudflap/testsuite/libmudflap.c/pass35-frag.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971801fff6d8eb0df1486fa6b77ba4cfc4616305/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971801fff6d8eb0df1486fa6b77ba4cfc4616305/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c?ref=971801fff6d8eb0df1486fa6b77ba4cfc4616305", "patch": "@@ -3,7 +3,7 @@\n #include <string.h>\n \n extern char end [];   /* Any old symbol we're sure will be defined. */\n-/* { dg-warning \"cannot track lifetime of `end'\" \"cannot track lifetime\" { target *-*-* } 0 } */\n+/* { dg-warning \"cannot track lifetime of 'end'\" \"cannot track lifetime\" { target *-*-* } 0 } */\n \n int main ()\n {"}]}