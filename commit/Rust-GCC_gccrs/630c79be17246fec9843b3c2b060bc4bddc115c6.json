{"sha": "630c79be17246fec9843b3c2b060bc4bddc115c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwYzc5YmUxNzI0NmZlYzk4NDNiM2MyYjA2MGJjNGJkZGMxMTVjNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-06T09:20:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-06T09:20:38Z"}, "message": "Changes in cse.c/loop.c cost calculations\n\nFrom-SVN: r36192", "tree": {"sha": "6f4ec3752992fd08f6269340cb140839ba3e34bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f4ec3752992fd08f6269340cb140839ba3e34bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630c79be17246fec9843b3c2b060bc4bddc115c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630c79be17246fec9843b3c2b060bc4bddc115c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630c79be17246fec9843b3c2b060bc4bddc115c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630c79be17246fec9843b3c2b060bc4bddc115c6/comments", "author": null, "committer": null, "parents": [{"sha": "39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f"}], "stats": {"total": 359, "additions": 261, "deletions": 98}, "files": [{"sha": "10e9bb519406181cd9a4174f272938ffe9e41346", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -1,3 +1,38 @@\n+2000-09-06  Bernd Schmidt  <bernds@redhat.co.uk>\n+\t\n+\t* Makefile.in (cse.o): Depend on $(BASIC_BLOCK_H).\n+\t* cse.c: Include \"basic-block.h\".\n+\t(struct table_elt): New field REGCOST.\n+\t(CHEAP_REG): Delete macro.\n+\t(COST): Return 0 for REGs.\n+\t(approx_reg_cost_1, approx_reg_cost, preferrable): New functions.\n+\t(notreg_cost): Return 0 for appropriate SUBREGs.\n+\t(COSTS_N_INSNS): Return N * 2.\n+\t(rtx_cost): Return 0 for REGs, and use cost of nested rtx for cheap\n+\tSUBREGs.\n+\t(CHEAPER): Use new function preferrable.\n+\t(insert): Initialize REGCOST member.\n+\t(find_best_addr): Use approx_reg_cost for estimation of register\n+\tusage.\n+\t(cse_insn): Likewise.\n+\t* loop.c (iv_add_mult_cost): New function.\n+\t(add_cost, shift_cost, mult_cost): Delete variables.\n+\t(init_loop): Don't initialize add_cost; reduce copy_cost by half.\n+\t(strength_reduce): Use iv_add_mult_cost instead of fixed add_cost.\n+\tMake code that detects autoinc opportunities slightly less optimistic.\n+\t(simplify_giv_expr): If expression contains other reg that is also a\n+\tgiv, only increment benefit if this is the only use of that reg.\n+\t(consec_sets_giv): Take that change into account.\n+\t(combine_givs): Slightly more verbose output.\n+\n+\t* i386.h (RTX_COSTS): For MULT, return true cost of multiplication,\n+\tnot the cost of an equivalent shift.\n+\t* sh-protos.h (addsubcosts): Declare.\n+\t* sh.c (addsubcosts): New function.\n+\t* sh.h (CONST_COSTS): If CONST_OK_FOR_I, then return 0.\n+\t(RTX_COSTS): Tweak.  Use addsubcosts.\n+\t(ADDRESS_COST): Return higher cost for reg+reg addressing.\n+\n 2000-09-06  Geoff Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.c (validate_condition_mode): New function."}, {"sha": "2543ec42e24da30edad28bacdceaa738feef847a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -1322,7 +1322,8 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h ggc.h $(OBSTACK_H)\n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n-   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h $(GGC_H)\n+   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h \\\n+   $(BASIC_BLOCK_H) $(GGC_H)\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n    function.h output.h toplev.h"}, {"sha": "5f6f0257af1908e348dc7fbf5efbca8a21332b89", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -1978,22 +1978,14 @@ while (0)\n \tunsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\\\n \tint nbits = 0;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (value == 2)\t\t\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\\\n-\tif (value == 4 || value == 8)\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->lea);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n \twhile (value != 0)\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    nbits++;\t\t\t\t\t\t\t\\\n \t    value >>= 1;\t\t\t\t\t\t\\\n \t  } \t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (nbits == 1)\t\t\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_const);\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n-\t\t\t          + nbits * ix86_cost->mult_bit);\t\\\n+\tTOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n+\t\t\t        + nbits * ix86_cost->mult_bit);\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t/* This is arbitrary */\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\"}, {"sha": "fc441a97febe775ed567ad3c4b431b5ab99a7b60", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -54,6 +54,7 @@ extern int prepare_move_operands PARAMS ((rtx[], enum machine_mode mode));\n extern void from_compare PARAMS ((rtx *, int));\n extern int shift_insns_rtx PARAMS ((rtx));\n extern int shiftcosts PARAMS ((rtx));\n+extern int addsubcosts PARAMS ((rtx));\n extern int andcosts PARAMS ((rtx));\n extern int multcosts PARAMS ((rtx));\n extern void gen_ashift PARAMS ((int, int, rtx));"}, {"sha": "20babcbb6a5666890699c16554978ed52ad34869", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -1012,6 +1012,25 @@ andcosts (x)\n   return 3;\n }\n \n+/* Return the cost of an addition or a subtraction.  */\n+\n+int\n+addsubcosts (x)\n+     rtx x;\n+{\n+  /* Adding a register is a single cycle insn.  */\n+  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+    return 1;\n+\n+  /* Likewise for small constants.  */\n+  if (CONST_OK_FOR_I (INTVAL (XEXP (x, 1))))\n+    return 1;\n+\n+  /* Any other constant requires a 2 cycle pc-relative load plus an\n+     addition.  */\n+  return 3;\n+}\n+\n /* Return the cost of a multiply.  */\n int\n multcosts (x)"}, {"sha": "feb58530deb3e1f4735355dca43890abca8c9bec", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -1651,15 +1651,12 @@ extern int current_function_anonymous_args;\n #define Pmode  SImode\n #define FUNCTION_MODE  Pmode\n \n-/* The relative costs of various types of constants.  Note that cse.c defines\n-   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n+/* The relative costs of various types of constants.  */\n \n #define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\\\n   case CONST_INT:\t\t\t\t\\\n-    if (INTVAL (RTX) == 0)\t\t\t\\\n+    if (CONST_OK_FOR_I (INTVAL (RTX)))\t\t\\\n       return 0;\t\t\t\t\t\\\n-    else if (CONST_OK_FOR_I (INTVAL (RTX)))\t\\\n-      return 1;\t\t\t\t\t\\\n     else if (((OUTER_CODE) == AND || (OUTER_CODE) == IOR || (OUTER_CODE) == XOR) \\\n \t     && CONST_OK_FOR_L (INTVAL (RTX)))\t\\\n       return 1;\t\t\t\t\t\\\n@@ -1674,24 +1671,15 @@ extern int current_function_anonymous_args;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\\\n-    return (COSTS_N_INSNS (1)\t\t\t\t\\\n-\t    + rtx_cost (XEXP ((X), 0), PLUS)\t\t\\\n-\t    + (rtx_equal_p (XEXP ((X), 0), XEXP ((X), 1))\\\n-\t       ? 0 : rtx_cost (XEXP ((X), 1), PLUS)));\\\n+    return COSTS_N_INSNS (addsubcosts (X));\t\t\\\n   case AND:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (andcosts (X));\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\\\n-    /* Add one extra unit for the matching constraint.\t\\\n-       Otherwise loop strength reduction would think that\\\n-       a shift with different sourc and destination is\t\\\n-       as cheap as adding a constant to a register.  */\t\\\n-    return (COSTS_N_INSNS (shiftcosts (X))\t\t\\\n-\t    + rtx_cost (XEXP ((X), 0), (CODE))\t\t\\\n-\t    + 1);\t\t\t\t\t\\\n+    return COSTS_N_INSNS (shiftcosts (X));\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -1768,11 +1756,11 @@ while (0)\n   && nonpic_symbol_mentioned_p (X))\n \f\n /* Compute the cost of an address.  For the SH, all valid addresses are\n-   the same cost.  */\n-/* ??? Perhaps we should make reg+reg addresses have higher cost because\n-   they add to register pressure on r0.  */\n+   the same cost.  Use a slightly higher cost for reg + reg addressing,\n+   since it increases pressure on r0.  */\n \n-#define ADDRESS_COST(RTX) 1\n+#define ADDRESS_COST(X) (GET_CODE (X) == PLUS && ! CONSTANT_P (XEXP (X, 1)) \\\n+\t\t\t ? 1 : 0)\n \n /* Compute extra cost of moving data between one register class\n    and another.  */"}, {"sha": "f9348fbabeb6b06ef8ee8662ac9ab4da99e5732f", "filename": "gcc/cse.c", "status": "modified", "additions": 129, "deletions": 48, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n #include \"flags.h\"\n #include \"real.h\"\n #include \"insn-config.h\"\n@@ -434,6 +435,8 @@ static int hash_arg_in_memory;\n    chain is not useful.\n \n    The `cost' field stores the cost of this element's expression.\n+   The `regcost' field stores the value returned by approx_reg_cost for\n+   this element's expression.\n \n    The `is_const' flag is set if the element is a constant (including\n    a fixed address).\n@@ -456,6 +459,7 @@ struct table_elt\n   struct table_elt *first_same_value;\n   struct table_elt *related_value;\n   int cost;\n+  int regcost;\n   enum machine_mode mode;\n   char in_memory;\n   char is_const;\n@@ -477,7 +481,8 @@ struct table_elt\n   ? (((unsigned) REG << 7) + (unsigned) REG_QTY (REGNO (X)))\t\\\n   : canon_hash (X, M)) & HASH_MASK)\n \n-/* Determine whether register number N is considered a fixed register for CSE.\n+/* Determine whether register number N is considered a fixed register for the\n+   purpose of approximating register costs.\n    It is desirable to replace other regs with fixed regs, to reduce need for\n    non-fixed hard regs.\n    A reg wins if it is either the frame pointer or designated as fixed.  */\n@@ -497,19 +502,7 @@ struct table_elt\n    || ((N) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n-/* A register is cheap if it is a user variable assigned to the register\n-   or if its register number always corresponds to a cheap register.  */\n-\n-#define CHEAP_REG(N) \\\n-  ((REG_USERVAR_P (N) && REGNO (N) < FIRST_PSEUDO_REGISTER)\t\\\n-   || CHEAP_REGNO (REGNO (N)))\n-\n-#define COST(X)\t\t\t\t\t\t\t\t\\\n-  (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-   ? (CHEAP_REG (X) ? 0\t\t\t\t\t\t\t\\\n-      : REGNO (X) >= FIRST_PSEUDO_REGISTER ? 1\t\t\t\t\\\n-      : 2)\t\t\t\t\t\t\t\t\\\n-   : notreg_cost(X))\n+#define COST(X) (GET_CODE (X) == REG ? 0 : notreg_cost (X))\n \n /* Get the info associated with register N.  */\n \n@@ -644,6 +637,9 @@ struct cse_basic_block_data\n    || GET_CODE (X) == ADDRESSOF)\n \n static int notreg_cost\t\tPARAMS ((rtx));\n+static int approx_reg_cost_1\tPARAMS ((rtx *, void *));\n+static int approx_reg_cost\tPARAMS ((rtx));\n+static int preferrable\t\tPARAMS ((int, int, int, int));\n static void new_basic_block\tPARAMS ((void));\n static void make_new_qty\tPARAMS ((unsigned int, enum machine_mode));\n static void make_regs_eqv\tPARAMS ((unsigned int, unsigned int));\n@@ -717,6 +713,62 @@ dump_class (classp)\n     }\n }\n \n+/* Subroutine of approx_reg_cost; called through for_each_rtx.  */\n+static int\n+approx_reg_cost_1 (xp, data)\n+     rtx *xp;\n+     void *data;\n+{\n+  rtx x = *xp;\n+  regset set = (regset) data;\n+\n+  if (x && GET_CODE (x) == REG)\n+    SET_REGNO_REG_SET (set, REGNO (x));\n+  return 0;\n+}\n+\n+/* Return an estimate of the cost of the registers used in an rtx.\n+   This is mostly the number of different REG expressions in the rtx;\n+   however for some excecptions like fixed registers we use a cost of\n+   0.  */\n+\n+static int\n+approx_reg_cost (x)\n+     rtx x;\n+{\n+  regset_head set;\n+  int i;\n+  int cost = 0;\n+\n+  INIT_REG_SET (&set);\n+  for_each_rtx (&x, approx_reg_cost_1, (void *)&set);\n+\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (&set, 0, i,\n+     {\n+       if (! CHEAP_REGNO (i))\n+\t cost++;\n+     });\n+\n+  CLEAR_REG_SET (&set);\n+  return cost;\n+}\n+\n+/* Return a negative value if an rtx A, whose costs are given by COST_A\n+   and REGCOST_A, is more desirable than an rtx B.\n+   Return a positive value if A is less desirable, or 0 if the two are\n+   equally good.  */\n+static int\n+preferrable (cost_a, regcost_a, cost_b, regcost_b)\n+     int cost_a, regcost_a, cost_b, regcost_b;\n+{\n+  if (cost_a != cost_b)\n+    return cost_a - cost_b;\n+  if (regcost_a != regcost_b)\n+    return regcost_a - regcost_b;\n+  return 0;\n+}\n+\n /* Internal function, to compute cost when X is not a register; called\n    from COST macro to keep it simple.  */\n \n@@ -733,17 +785,15 @@ notreg_cost (x)\n \t   && subreg_lowpart_p (x)\n \t   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (x)),\n \t\t\t\t     GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))))\n-\t  ? (CHEAP_REG (SUBREG_REG (x)) ? 0\n-\t     : (REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t: 2))\n+\t  ? 0\n \t  : rtx_cost (x, SET) * 2);\n }\n \n /* Return the right cost to give to an operation\n    to make the cost of the corresponding register-to-register instruction\n    N times that of a fast register-to-register instruction.  */\n \n-#define COSTS_N_INSNS(N) ((N) * 4 - 2)\n+#define COSTS_N_INSNS(N) ((N) * 2)\n \n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n@@ -795,15 +845,16 @@ rtx_cost (x, outer_code)\n   switch (code)\n     {\n     case REG:\n-      return ! CHEAP_REG (x);\n+      return 0;\n \n     case SUBREG:\n       /* If we can't tie these modes, make this expensive.  The larger\n \t the mode, the more expensive it is.  */\n       if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))\n \treturn COSTS_N_INSNS (2\n \t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n-      return 2;\n+      break;\n+\n #ifdef RTX_COSTS\n       RTX_COSTS (x, code, outer_code);\n #endif\n@@ -860,6 +911,7 @@ address_cost (x, mode)\n   return rtx_cost (x, MEM);\n #endif\n }\n+\n \f\n static struct cse_reg_info *\n get_cse_reg_info (regno)\n@@ -1474,7 +1526,8 @@ lookup_as_function (x, code)\n \n    If necessary, update table showing constant values of quantities.  */\n \n-#define CHEAPER(X,Y)   ((X)->cost < (Y)->cost)\n+#define CHEAPER(X, Y) \\\n+ (preferrable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n \n static struct table_elt *\n insert (x, classp, hash, mode)\n@@ -1521,6 +1574,7 @@ insert (x, classp, hash, mode)\n   elt->exp = x;\n   elt->canon_exp = NULL_RTX;\n   elt->cost = COST (x);\n+  elt->regcost = approx_reg_cost (x);\n   elt->next_same_value = 0;\n   elt->prev_same_value = 0;\n   elt->next_same_hash = table[hash];\n@@ -2775,7 +2829,6 @@ find_best_addr (insn, loc, mode)\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n   int addr_volatile;\n   int regno;\n-  int folded_cost, addr_cost;\n   unsigned hash;\n \n   /* Do not try to replace constant addresses or addresses of local and\n@@ -2808,14 +2861,15 @@ find_best_addr (insn, loc, mode)\n   if (GET_CODE (addr) != REG)\n     {\n       rtx folded = fold_rtx (copy_rtx (addr), NULL_RTX);\n-\n-      folded_cost = address_cost (folded, mode);\n-      addr_cost = address_cost (addr, mode);\n-\n-      if ((folded_cost < addr_cost\n-\t   || (folded_cost == addr_cost\n-\t       && rtx_cost (folded, MEM) > rtx_cost (addr, MEM)))\n-\t  && rtx_cost (folded, MEM) < rtx_cost (addr, MEM)\n+      int addr_folded_cost = address_cost (folded, mode);\n+      int addr_cost = address_cost (addr, mode);\n+\n+      if ((addr_folded_cost < addr_cost\n+\t   || (addr_folded_cost == addr_cost\n+\t       /* ??? The rtx_cost comparison is left over from an older\n+\t\t  version of this code.  It is probably no longer helpful.  */\n+\t       && (rtx_cost (folded, MEM) > rtx_cost (addr, MEM)\n+\t\t   || approx_reg_cost (folded) < approx_reg_cost (addr))))\n \t  && validate_change (insn, loc, folded, 0))\n \taddr = folded;\n     }\n@@ -4822,6 +4876,8 @@ cse_insn (insn, libcall_insn)\n       struct table_elt *src_const_elt = 0;\n       int src_cost = 10000, src_eqv_cost = 10000, src_folded_cost = 10000;\n       int src_related_cost = 10000, src_elt_cost = 10000;\n+      int src_regcost, src_eqv_regcost, src_folded_regcost;\n+      int src_related_regcost, src_elt_regcost;\n       /* Set non-zero if we need to call force_const_mem on with the\n \t contents of src_folded before using it.  */\n       int src_folded_force_flag = 0;\n@@ -5230,31 +5286,43 @@ cse_insn (insn, libcall_insn)\n \t  if (rtx_equal_p (src, dest))\n \t    src_cost = -1;\n \t  else\n-\t    src_cost = COST (src);\n+\t    {\n+\t      src_cost = COST (src);\n+\t      src_regcost = approx_reg_cost (src);\n+\t    }\n \t}\n \n       if (src_eqv_here)\n \t{\n \t  if (rtx_equal_p (src_eqv_here, dest))\n \t    src_eqv_cost = -1;\n \t  else\n-\t    src_eqv_cost = COST (src_eqv_here);\n+\t    {\n+\t      src_eqv_cost = COST (src_eqv_here);\n+\t      src_eqv_regcost = approx_reg_cost (src_eqv_here);\n+\t    }\n \t}\n \n       if (src_folded)\n \t{\n \t  if (rtx_equal_p (src_folded, dest))\n \t    src_folded_cost = -1;\n \t  else\n-\t    src_folded_cost = COST (src_folded);\n+\t    {\n+\t      src_folded_cost = COST (src_folded);\n+\t      src_folded_regcost = approx_reg_cost (src_folded);\n+\t    }\n \t}\n \n       if (src_related)\n \t{\n \t  if (rtx_equal_p (src_related, dest))\n \t    src_related_cost = -1;\n \t  else\n-\t    src_related_cost = COST (src_related);\n+\t    {\n+\t      src_related_cost = COST (src_related);\n+\t      src_related_regcost = approx_reg_cost (src_related);\n+\t    }\n \t}\n \n       /* If this was an indirect jump insn, a known label will really be\n@@ -5292,30 +5360,43 @@ cse_insn (insn, libcall_insn)\n \t      continue;\n \t    }\n \n-\t  if (elt)\n-\t    src_elt_cost = elt->cost;\n+          if (elt)\n+\t    {\n+\t      src_elt_cost = elt->cost;\n+\t      src_elt_regcost = elt->regcost;\n+\t    }\n \n-\t  /* Find cheapest and skip it for the next time.   For items\n+          /* Find cheapest and skip it for the next time.   For items\n \t     of equal cost, use this order:\n \t     src_folded, src, src_eqv, src_related and hash table entry.  */\n-\t  if (src_folded_cost <= src_cost\n-\t      && src_folded_cost <= src_eqv_cost\n-\t      && src_folded_cost <= src_related_cost\n-\t      && src_folded_cost <= src_elt_cost)\n+\t  if (preferrable (src_folded_cost, src_folded_regcost,\n+\t\t\t   src_cost, src_regcost) <= 0\n+\t      && preferrable (src_folded_cost, src_folded_regcost,\n+\t\t\t      src_eqv_cost, src_eqv_regcost) <= 0\n+\t      && preferrable (src_folded_cost, src_folded_regcost,\n+\t\t\t      src_related_cost, src_related_regcost) <= 0\n+\t      && preferrable (src_folded_cost, src_folded_regcost,\n+\t\t\t      src_elt_cost, src_elt_regcost) <= 0)\n \t    {\n \t      trial = src_folded, src_folded_cost = 10000;\n \t      if (src_folded_force_flag)\n \t\ttrial = force_const_mem (mode, trial);\n \t    }\n-\t  else if (src_cost <= src_eqv_cost\n-\t\t   && src_cost <= src_related_cost\n-\t\t   && src_cost <= src_elt_cost)\n+\t  else if (preferrable (src_cost, src_regcost,\n+\t\t\t\tsrc_eqv_cost, src_eqv_regcost) <= 0\n+\t\t   && preferrable (src_cost, src_regcost,\n+\t\t\t\t   src_related_cost, src_related_regcost) <= 0\n+\t\t   && preferrable (src_cost, src_regcost,\n+\t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n \t    trial = src, src_cost = 10000;\n-\t  else if (src_eqv_cost <= src_related_cost\n-\t\t   && src_eqv_cost <= src_elt_cost)\n+\t  else if (preferrable (src_eqv_cost, src_eqv_regcost,\n+\t\t\t\tsrc_related_cost, src_related_regcost) <= 0\n+\t\t   && preferrable (src_eqv_cost, src_eqv_regcost,\n+\t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n \t    trial = copy_rtx (src_eqv_here), src_eqv_cost = 10000;\n-\t  else if (src_related_cost <= src_elt_cost)\n-\t    trial = copy_rtx (src_related), src_related_cost = 10000;\n+\t  else if (preferrable (src_related_cost, src_related_regcost,\n+\t\t\t\tsrc_elt_cost, src_elt_regcost) <= 0)\n+  \t    trial = copy_rtx (src_related), src_related_cost = 10000;\n \t  else\n \t    {\n \t      trial = copy_rtx (elt->exp);"}, {"sha": "ce3494bd4153488ce4daa33c1698d8442f2f40ed", "filename": "gcc/loop.c", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c79be17246fec9843b3c2b060bc4bddc115c6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=630c79be17246fec9843b3c2b060bc4bddc115c6", "patch": "@@ -312,6 +312,7 @@ static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n static int replace_label PARAMS ((rtx *, void *));\n static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n+static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n void debug_loop PARAMS ((const struct loop *));\n@@ -341,13 +342,6 @@ static int compute_luids PARAMS ((rtx, rtx, int));\n static int biv_elimination_giv_has_0_offset PARAMS ((struct induction *,\n \t\t\t\t\t\t   struct induction *, rtx));\n \f\n-/* Relative gain of eliminating various kinds of operations.  */\n-static int add_cost;\n-#if 0\n-static int shift_cost;\n-static int mult_cost;\n-#endif\n-\n /* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to\n    copy the value of the strength reduced giv to its original register.  */\n static int copy_cost;\n@@ -361,15 +355,9 @@ init_loop ()\n   char *free_point = (char *) oballoc (1);\n   rtx reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n-  add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n-\n   reg_address_cost = address_cost (reg, SImode);\n \n-  /* We multiply by 2 to reconcile the difference in scale between\n-     these two ways of computing costs.  Otherwise the cost of a copy\n-     will be far less than the cost of an add.  */\n-\n-  copy_cost = 2 * 2;\n+  copy_cost = 2;\n \n   /* Free the objects we just allocated.  */\n   obfree (free_point);\n@@ -3825,6 +3813,7 @@ strength_reduce (loop, insn_count, flags)\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n   rtx loop_scan_start = loop->scan_start;\n+  rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n   VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n   VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n@@ -4436,11 +4425,15 @@ strength_reduce (loop, insn_count, flags)\n       for (v = bl->giv; v; v = v->next_iv)\n \t{\n \t  struct induction *tv;\n+\t  int add_cost;\n \n \t  if (v->ignore || v->same)\n \t    continue;\n \n \t  benefit = v->benefit;\n+\t  PUT_MODE (test_reg, v->mode);\n+\t  add_cost = iv_add_mult_cost (bl->biv->add_val, v->mult_val,\n+\t\t\t\t       test_reg, test_reg);\n \n \t  /* Reduce benefit if not replaceable, since we will insert\n \t     a move-insn to replace the insn that calculates this giv.\n@@ -4457,7 +4450,14 @@ strength_reduce (loop, insn_count, flags)\n \t    benefit -= copy_cost;\n \n \t  /* Decrease the benefit to count the add-insns that we will\n-\t     insert to increment the reduced reg for the giv.  */\n+\t     insert to increment the reduced reg for the giv.\n+\t     ??? This can overestimate the run-time cost of the additional\n+\t     insns, e.g. if there are multiple basic blocks that increment\n+\t     the biv, but only one of these blocks is executed during each\n+\t     iteration.  There is no good way to detect cases like this with\n+\t     the current structure of the loop optimizer.\n+\t     This code is more accurate for determining code size than\n+\t     run-time benefits.  */\n \t  benefit -= add_cost * bl->biv_count;\n \n \t  /* Decide whether to strength-reduce this giv or to leave the code\n@@ -4469,6 +4469,10 @@ strength_reduce (loop, insn_count, flags)\n \t     new add insns; if so, increase BENEFIT (undo the subtraction of\n \t     add_cost that was done above).  */\n \t  if (v->giv_type == DEST_ADDR\n+\t      /* Increasing the benefit is risky, since this is only a guess.\n+\t\t Avoid increasing register pressure in cases where there would\n+\t\t be no other benefit from reducing this giv.  */\n+\t      && benefit > 0\n \t      && GET_CODE (v->mult_val) == CONST_INT)\n \t    {\n \t      if (HAVE_POST_INCREMENT\n@@ -6439,7 +6443,20 @@ simplify_giv_expr (loop, x, benefit)\n \n \t    /* Form expression from giv and add benefit.  Ensure this giv\n \t       can derive another and subtract any needed adjustment if so.  */\n-\t    *benefit += v->benefit;\n+\n+\t    /* Increasing the benefit here is risky.  The only case in which it\n+\t       is arguably correct is if this is the only use of V.  In other\n+\t       cases, this will artificially inflate the benefit of the current\n+\t       giv, and lead to suboptimal code.  Thus, it is disabled, since\n+\t       potentially not reducing an only marginally beneficial giv is\n+\t       less harmful than reducing many givs that are not really\n+\t       beneficial.  */\n+\t    {\n+\t      rtx single_use = VARRAY_RTX (reg_single_usage, REGNO (x));\n+\t      if (single_use && single_use != const0_rtx)\n+\t\t*benefit += v->benefit;\n+\t    }\n+\n \t    if (v->cant_derive)\n \t      return 0;\n \n@@ -6683,7 +6700,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n \t  count--;\n \t  v->mult_val = *mult_val;\n \t  v->add_val = *add_val;\n-\t  v->benefit = benefit;\n+\t  v->benefit += benefit;\n \t}\n       else if (code != NOTE)\n \t{\n@@ -7098,8 +7115,9 @@ combine_givs (bl)\n \n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream,\n-\t\t\t \"giv at %d combined with giv at %d\\n\",\n-\t\t\t INSN_UID (g2->insn), INSN_UID (g1->insn));\n+\t\t\t \"giv at %d combined with giv at %d; new benefit %d + %d, lifetime %d\\n\",\n+\t\t\t INSN_UID (g2->insn), INSN_UID (g1->insn),\n+\t\t\t g1->benefit, g1_add_benefit, g1->lifetime);\n \t    }\n \t}\n \n@@ -7613,6 +7631,34 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n \t   && GET_CODE (SET_DEST (seq)) == REG)\n     record_base_value (REGNO (SET_DEST (seq)), SET_SRC (seq), 0);\n }\n+\n+/* Similar to emit_iv_add_mult, but compute cost rather than emitting\n+   insns.  */\n+static int\n+iv_add_mult_cost (b, m, a, reg)\n+     rtx b;          /* initial value of basic induction variable */\n+     rtx m;          /* multiplicative constant */\n+     rtx a;          /* additive constant */\n+     rtx reg;        /* destination register */\n+{\n+  int cost = 0;\n+  rtx last, result;\n+\n+  start_sequence ();\n+  result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 0);\n+  if (reg != result)\n+    emit_move_insn (reg, result);\n+  last = get_last_insn ();\n+  while (last)\n+    {\n+      rtx t = single_set (last);\n+      if (t)\n+\tcost += rtx_cost (SET_SRC (t), SET);\n+      last = PREV_INSN (last);\n+    }\n+  end_sequence ();\n+  return cost;\n+}\n \f\n /* Test whether A * B can be computed without\n    an actual multiply insn.  Value is 1 if so.  */"}]}