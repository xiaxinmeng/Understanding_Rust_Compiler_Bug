{"sha": "94db2f7184544fc0cc6c625adda0c319db4a0350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkYjJmNzE4NDU0NGZjMGNjNmM2MjVhZGRhMGMzMTlkYjRhMDM1MA==", "commit": {"author": {"name": "Bruce Korb", "email": "ddsinc09@ix.netcom.com", "date": "1999-05-12T07:32:58Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-05-12T07:32:58Z"}, "message": "verify a file's existence before copying it\n\nFrom-SVN: r26898", "tree": {"sha": "c8fc6cda888e75e1c57730679bf60a7745fc486e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8fc6cda888e75e1c57730679bf60a7745fc486e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94db2f7184544fc0cc6c625adda0c319db4a0350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94db2f7184544fc0cc6c625adda0c319db4a0350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94db2f7184544fc0cc6c625adda0c319db4a0350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94db2f7184544fc0cc6c625adda0c319db4a0350/comments", "author": null, "committer": null, "parents": [{"sha": "41af162ca78944f562a35c32287de901abd9c84f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41af162ca78944f562a35c32287de901abd9c84f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41af162ca78944f562a35c32287de901abd9c84f"}], "stats": {"total": 148, "additions": 90, "deletions": 58}, "files": [{"sha": "7fc833979a800e63d6146afb5f6bf83e6f6e5ed8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94db2f7184544fc0cc6c625adda0c319db4a0350/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94db2f7184544fc0cc6c625adda0c319db4a0350/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94db2f7184544fc0cc6c625adda0c319db4a0350", "patch": "@@ -1,3 +1,9 @@\n+Wed May 12 07:30:31 1999  Bruce Korb <ddsinc09@ix.netcom.com>\n+\n+\t* fixinc/fixincl.c(quoted_file_exists): new procedure to ensure that\n+\ta file exists before trying to copy it into the destination\n+\t(extract_quoted_files): use that routine.\n+\n Wed May 12 07:27:31 1999  Craig Burley  <craig@jcb-sc.com>\n \n \tAllow front end (like g77's) to override maintenance of errno:"}, {"sha": "47c9ef1344af41e2d1bbe0d43ce0aa1ce009ae25", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 84, "deletions": 58, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94db2f7184544fc0cc6c625adda0c319db4a0350/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94db2f7184544fc0cc6c625adda0c319db4a0350/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=94db2f7184544fc0cc6c625adda0c319db4a0350", "patch": "@@ -22,14 +22,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#ifdef FIXINC_BROKEN\n-/* The fixincl program is known to not run properly on this particular\n-   system.  Instead of producing a probably broken executable, we force\n-   a compilation error and let the mkfixinc.sh script install the\n-   inclhack.sh shell script instead.  */\n-# include \"The fixincl program does not work properly on this system!\"\n-#endif\n-\n #include \"auto-host.h\"\n \n #include <sys/types.h>\n@@ -147,10 +139,10 @@ pid_t process_chain_head = (pid_t) -1;\n const char incl_quote_pat[] = \"^[ \\t]*#[ \\t]*include[ \\t]*\\\"[^/]\";\n regex_t incl_quote_re;\n \n-char *load_file (const char *);\n-void process (char *, const char *);\n+char *load_file  _P_((const char *));\n+void process  _P_((char *, const char *));\n void run_compiles ();\n-void wait_for_pid( pid_t, int );\n+void wait_for_pid _P_(( pid_t ));\n void initialize ();\n \n #include \"fixincl.x\"\n@@ -253,6 +245,9 @@ main (argc, argv)\n       if (file_name_ct == 0)\n         return EXIT_SUCCESS;\n \n+      fflush (stdout);\n+      fflush (stderr);\n+\n       {\n         pid_t child = fork ();\n         if (child == NULLPROCESS)\n@@ -265,6 +260,11 @@ main (argc, argv)\n             exit (EXIT_FAILURE);\n           }\n \n+#ifdef DEBUG\n+        fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n+                 child, file_name_ct);\n+#endif\n+\n         wait_for_pid( child, file_name_ct );\n       }\n     }\n@@ -279,11 +279,6 @@ main (argc, argv)\n \n   signal (SIGCLD,  SIG_IGN);\n \n-#ifdef DEBUG\n-  fprintf (stderr, \"Child start  --  processing %d files\\n\",\n-           file_name_ct);\n-#endif\n-\n   /*  For every file specified in stdandard in\n       (except as throttled for bogus reasons)...\n       */\n@@ -389,11 +384,6 @@ initialize()\n void\n wait_for_pid( pid_t child, int file_name_ct )\n {\n-#ifdef DEBUG\n-  fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n-           child, file_name_ct);\n-#endif\n-\n   for (;;) {\n     int status;\n     pid_t dead_kid = wait (&status);\n@@ -412,10 +402,6 @@ wait_for_pid( pid_t child, int file_name_ct )\n                      child, WEXITSTATUS( status ));\n             exit (EXIT_FAILURE);\n           }\n-#ifdef DEBUG\n-        fprintf (stderr, \"child finished %d files %s\\n\", file_name_ct,\n-                 status ? strerror (status & 0xFF) : \"ok\");\n-#endif\n         break; /* normal child completion */\n       }\n \n@@ -530,8 +516,8 @@ load_file (pz_file_name)\n void\n run_compiles ()\n {\n-  tSCC z_bad_comp[] = \"fixincl ERROR:  cannot compile %s regex for %s\\n\"\n-    \"\\texpr = `%s'\\n\" \"\\terror %s\\n\";\n+  tSCC z_bad_comp[] = \"fixincl ERROR:  cannot compile %s regex for %s\\n\\\n+\\texpr = `%s'\\n\\terror %s\\n\";\n   tFixDesc *p_fixd = fixDescList;\n   int fix_ct = FIX_COUNT;\n   tTestDesc *p_test;\n@@ -771,16 +757,17 @@ test_test (p_test, pz_file_name)\n      tTestDesc *p_test;\n      char*      pz_file_name;\n {\n+  tSCC cmd_fmt[] =\n+\"file=%s\\n\\\n+if ( test %s ) > /dev/null 2>&1\\n\\\n+then echo TRUE\\n\\\n+else echo FALSE\\n\\\n+fi\";\n+\n   char *pz_res;\n   t_success res = FAILURE;\n \n   static char cmd_buf[4096];\n-  tSCC cmd_fmt[] =\n-    \"file=%s\\n\"\n-    \"if ( test %s ) > /dev/null 2>&1\\n\"\n-    \"then echo TRUE\\n\"\n-    \"else echo FALSE\\n\"\n-    \"fi\";\n \n   sprintf (cmd_buf, cmd_fmt, pz_file_name, p_test->pz_test_text);\n   pz_res = run_shell (cmd_buf);\n@@ -819,6 +806,41 @@ egrep_test (pz_data, p_test)\n }\n \n \n+/* * * * * * * * * * * * *\n+\n+  quoted_file_exists  Make sure that a file exists before we emit\n+  the file name.  If we emit the name, our invoking shell will try\n+  to copy a non-existing file into the destination directory.  */\n+\n+int\n+quoted_file_exists (pz_src_path, pz_file_path, pz_file)\n+     char* pz_src_path;\n+     char* pz_file_path;\n+     char* pz_file;\n+{\n+  char z[ MAXPATHLEN ];\n+  char* pz;\n+  sprintf (z, \"%s/%s/\", pz_src_path, pz_file_path);\n+  pz = z + strlen ( z );\n+\n+  for (;;) {\n+    char ch = *pz_file++;\n+    if (! isgraph( ch ))\n+      return 0;\n+    if (ch == '\"')\n+      break;\n+    *pz++ = ch;\n+  }\n+  *pz = '\\0';\n+  {\n+    struct stat s;\n+    if (stat (z, &s) != 0)\n+      return 0;\n+    return S_ISREG( s.st_mode );\n+  }\n+}\n+\n+\n /* * * * * * * * * * * * *\n  *\n    extract_quoted_files\n@@ -840,6 +862,7 @@ egrep_test (pz_data, p_test)\n    Result: internally nothing.  The results are written to stdout\n            for interpretation by the invoking shell  */\n \n+\n void\n extract_quoted_files (pz_data, pz_file_name, p_re_match)\n      char *pz_data;\n@@ -852,7 +875,7 @@ extract_quoted_files (pz_data, pz_file_name, p_re_match)\n   fprintf (stderr, \"Quoted includes in %s\\n\", pz_file_name);\n \n   /*  Set \"pz_file_name\" to point to the containing subdirectory of the source\n-      If there is none, then it is in our current direcory, \".\".   */\n+      If there is none, then it is in our current directory, \".\".   */\n \n   if (pz_dir_end == (char *) NULL)\n     pz_file_name = \".\";\n@@ -872,23 +895,26 @@ extract_quoted_files (pz_data, pz_file_name, p_re_match)\n       while (*pz_incl_quot++ != '\"')\n         ;\n \n-      /* Print the source directory and the subdirectory of the file\n-         in question.  */\n-      printf (\"%s  %s/\", pz_src_dir, pz_file_name);\n-      pz_dir_end = pz_incl_quot;\n-\n-      /* Append to the directory the relative path of the desired file */\n-      while (*pz_incl_quot != '\"')\n-        putc (*pz_incl_quot++, stdout);\n-\n-      /* Now print the destination directory appended with the\n-         relative path of the desired file */\n-      printf (\"  %s/%s/\", pz_dest_dir, pz_file_name);\n-      while (*pz_dir_end != '\"')\n-        putc (*pz_dir_end++, stdout);\n-\n-      /* End of entry */\n-      putc ('\\n', stdout);\n+      if (quoted_file_exists (pz_src_dir, pz_file_name, pz_incl_quot))\n+        {\n+          /* Print the source directory and the subdirectory\n+             of the file in question.  */\n+          printf (\"%s  %s/\", pz_src_dir, pz_file_name);\n+          pz_dir_end = pz_incl_quot;\n+\n+          /* Append to the directory the relative path of the desired file */\n+          while (*pz_incl_quot != '\"')\n+            putc (*pz_incl_quot++, stdout);\n+\n+          /* Now print the destination directory appended with the\n+             relative path of the desired file */\n+          printf (\"  %s/%s/\", pz_dest_dir, pz_file_name);\n+          while (*pz_dir_end != '\"')\n+            putc (*pz_dir_end++, stdout);\n+\n+          /* End of entry */\n+          putc ('\\n', stdout);\n+        }\n \n       /* Find the next entry */\n       if (regexec (&incl_quote_re, pz_incl_quot, 1, p_re_match, 0) != 0)\n@@ -936,7 +962,7 @@ process (pz_data, pz_file_name)\n    */\n   strcpy (env_current_file + 5, pz_file_name);\n   process_chain_head = NOPROCESS;\n-\n+  fprintf (stderr, \"%-50s   \\r\", pz_file_name );\n   /* For every fix in our fix list, ...  */\n   for (; todo_ct > 0; p_fixd++, todo_ct--)\n     {\n@@ -982,7 +1008,7 @@ process (pz_data, pz_file_name)\n            test_ct-- > 0;\n            p_test++)\n         {\n-#ifdef DEBUG\n+#ifdef DEBUG_TEST\n           static const char z_test_fail[] =\n             \"%16s test %2d failed for %s\\n\";\n #endif\n@@ -991,7 +1017,7 @@ process (pz_data, pz_file_name)\n             case TT_TEST:\n               if (!SUCCESSFUL (test_test (p_test, pz_file_name)))\n                 {\n-#ifdef DEBUG\n+#ifdef DEBUG_TEST\n                   fprintf (stderr, z_test_fail, p_fixd->fix_name,\n                            p_fixd->test_ct - test_ct, pz_file_name);\n #endif\n@@ -1002,7 +1028,7 @@ process (pz_data, pz_file_name)\n             case TT_EGREP:\n               if (!SUCCESSFUL (egrep_test (pz_data, p_test)))\n                 {\n-#ifdef DEBUG\n+#ifdef DEBUG_TEST\n                   fprintf (stderr, z_test_fail, p_fixd->fix_name,\n                            p_fixd->test_ct - test_ct, pz_file_name);\n #endif\n@@ -1013,7 +1039,7 @@ process (pz_data, pz_file_name)\n             case TT_NEGREP:\n               if (SUCCESSFUL (egrep_test (pz_data, p_test)))\n                 {\n-#ifdef DEBUG\n+#ifdef DEBUG_TEST\n                   fprintf (stderr, z_test_fail, p_fixd->fix_name,\n                            p_fixd->test_ct - test_ct, pz_file_name);\n #endif\n@@ -1050,6 +1076,7 @@ process (pz_data, pz_file_name)\n \n       for (;;)\n         {\n+          tSCC z_err[] = \"Error %d (%s) starting filter process for %s\\n\";\n           static int failCt = 0;\n           int fd = chain_open (fdp.read_fd,\n                                (t_pchar *) p_fixd->patch_args,\n@@ -1062,8 +1089,7 @@ process (pz_data, pz_file_name)\n               break;\n             }\n \n-          fprintf (stderr, \"Error %d (%s) starting filter process \"\n-                   \"for %s\\n\", errno, strerror (errno),\n+          fprintf (stderr, z_err, errno, strerror (errno),\n                    p_fixd->fix_name);\n \n           if ((errno != EAGAIN) || (++failCt > 10))"}]}