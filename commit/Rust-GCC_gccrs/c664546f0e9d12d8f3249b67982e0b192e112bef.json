{"sha": "c664546f0e9d12d8f3249b67982e0b192e112bef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY2NDU0NmYwZTlkMTJkOGYzMjQ5YjY3OTgyZTBiMTkyZTExMmJlZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-01-18T07:54:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-01-18T07:54:47Z"}, "message": "re PR rtl-optimization/52573 (regrename creates overlapping register allocations for output operands)\n\n\tPR rtl-optimization/52573\n        * regrename.c (build_def_use): Ignore REG_DEAD notes if there is\n        a REG_UNUSED for the same register.\n\n\t* gcc.dg/pr52573.c: New test.\n\nFrom-SVN: r195288", "tree": {"sha": "eeafc6e254984b4679789b0594673c47e2dc2585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeafc6e254984b4679789b0594673c47e2dc2585"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c664546f0e9d12d8f3249b67982e0b192e112bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c664546f0e9d12d8f3249b67982e0b192e112bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c664546f0e9d12d8f3249b67982e0b192e112bef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c664546f0e9d12d8f3249b67982e0b192e112bef/comments", "author": null, "committer": null, "parents": [{"sha": "1f8b0400aa92a00ab1fd022d9e3eb3e0c7526f38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8b0400aa92a00ab1fd022d9e3eb3e0c7526f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f8b0400aa92a00ab1fd022d9e3eb3e0c7526f38"}], "stats": {"total": 180, "additions": 178, "deletions": 2}, "files": [{"sha": "e179e2929e9c3968c63f453db41b417b72838ae3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c664546f0e9d12d8f3249b67982e0b192e112bef", "patch": "@@ -1,3 +1,10 @@\n+2013-01-18  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/52573\n+\t* regrename.c (build_def_use): Ignore REG_DEAD notes if there is a\n+\tREG_UNUSED for the same register.\n+\n+\n 2013-01-17  Richard Biener  <rguenther@suse.de>\n \t    Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "20e2ae9f7926ca29a96c993ab4ec51b4d707b28a", "filename": "gcc/regrename.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c664546f0e9d12d8f3249b67982e0b192e112bef", "patch": "@@ -1710,9 +1710,16 @@ build_def_use (basic_block bb)\n \t      scan_rtx (insn, &XEXP (note, 0), ALL_REGS, mark_read,\n \t\t\tOP_INOUT);\n \n-\t  /* Step 4: Close chains for registers that die here.  */\n+\t  /* Step 4: Close chains for registers that die here, unless\n+\t     the register is mentioned in a REG_UNUSED note.  In that\n+\t     case we keep the chain open until step #7 below to ensure\n+\t     it conflicts with other output operands of this insn.\n+\t     See PR 52573.  Arguably the insn should not have both\n+\t     notes; it has proven difficult to fix that without\n+\t     other undesirable side effects.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t    if (REG_NOTE_KIND (note) == REG_DEAD\n+\t\t&& !find_regno_note (insn, REG_UNUSED, REGNO (XEXP (note, 0))))\n \t      {\n \t\tremove_from_hard_reg_set (&live_hard_regs,\n \t\t\t\t\t  GET_MODE (XEXP (note, 0)),"}, {"sha": "cf1890abdb75be1990a3c88bfca6064ea3baa315", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c664546f0e9d12d8f3249b67982e0b192e112bef", "patch": "@@ -1,3 +1,7 @@\n+2013-01-17  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/52573\n+\t* gcc.dg/pr52573.c: New test.\n 2013-01-17  Jack Howarth <howarth@bromo.med.uc.edu>\n \n         PR sanitizer/55679"}, {"sha": "7e82749fbbbf74b0404d311cbff2bcb0ef32bfb6", "filename": "gcc/testsuite/gcc.dg/pr52573.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52573.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c664546f0e9d12d8f3249b67982e0b192e112bef/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52573.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52573.c?ref=c664546f0e9d12d8f3249b67982e0b192e112bef", "patch": "@@ -0,0 +1,158 @@\n+\n+/* { dg-do compile { target  { m68k-*-* } } } */\n+/* { dg-options \"-w -O3 -funroll-loops\" } */\n+/* { dg-final { scan-assembler-not \"%d0:%d0\" } } */\n+/* { dg-final { scan-assembler-not \"%d1:%d1\" } } */\n+/* { dg-final { scan-assembler-not \"%d2:%d2\" } } */\n+/* { dg-final { scan-assembler-not \"%d3:%d3\" } } */\n+/* { dg-final { scan-assembler-not \"%d4:%d4\" } } */\n+/* { dg-final { scan-assembler-not \"%d5:%d5\" } } */\n+/* { dg-final { scan-assembler-not \"%d6:%d6\" } } */\n+/* { dg-final { scan-assembler-not \"%d7:%d7\" } } */\n+/* Test arithmetics on bitfields.  */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+unsigned int\n+myrnd (void)\n+{\n+  static unsigned int s = 1388815473;\n+  s *= 1103515245;\n+  s += 12345;\n+  return (s / 65536) % 2048;\n+}\n+\n+#define T(S)\t\t\t\t\t\\\n+struct S s##S;\t\t\t\t\t\\\n+struct S retme##S (struct S x)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return x;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn1##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y = retme##S (y);\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn2##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y.k %= 15;\t\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int retit##S (void)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return s##S.k;\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn3##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  s##S.k += x;\t\t\t\t\t\\\n+  return retit##S ();\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+void test##S (void)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\\\n+  unsigned int mask, v, a, r;\t\t\t\\\n+  struct S x;\t\t\t\t\t\\\n+  char *p = (char *) &s##S;\t\t\t\\\n+  for (i = 0; i < sizeof (s##S); ++i)\t\t\\\n+    *p++ = myrnd ();\t\t\t\t\\\n+  if (__builtin_classify_type (s##S.l) == 8)\t\\\n+    s##S.l = 5.25;\t\t\t\t\\\n+  s##S.k = -1;\t\t\t\t\t\\\n+  mask = s##S.k;\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn1##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn2##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((((v + a) & mask) % 15) & mask) != r)\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn3##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || s##S.k != r || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+}\n+\n+struct A { unsigned int i : 6, l : 1, j : 10, k : 15; }; T(A)\n+struct B { unsigned int i : 6, j : 11, k : 15; unsigned int l; }; T(B)\n+struct C { unsigned int l; unsigned int i : 6, j : 11, k : 15; }; T(C)\n+struct D { unsigned long long l : 6, i : 6, j : 23, k : 29; }; T(D)\n+struct E { unsigned long long l, i : 12, j : 23, k : 29; }; T(E)\n+struct F { unsigned long long i : 12, j : 23, k : 29, l; }; T(F)\n+struct G { unsigned int i : 12, j : 13, k : 7; unsigned long long l; }; T(G)\n+struct H { unsigned int i : 12, j : 11, k : 9; unsigned long long l; }; T(H)\n+struct I { unsigned short i : 1, j : 6, k : 9; unsigned long long l; }; T(I)\n+struct J { unsigned short i : 1, j : 8, k : 7; unsigned short l; }; T(J)\n+struct K { unsigned int k : 6, l : 1, j : 10, i : 15; }; T(K)\n+struct L { unsigned int k : 6, j : 11, i : 15; unsigned int l; }; T(L)\n+struct M { unsigned int l; unsigned int k : 6, j : 11, i : 15; }; T(M)\n+struct N { unsigned long long l : 6, k : 6, j : 23, i : 29; }; T(N)\n+struct O { unsigned long long l, k : 12, j : 23, i : 29; }; T(O)\n+struct P { unsigned long long k : 12, j : 23, i : 29, l; }; T(P)\n+struct Q { unsigned int k : 12, j : 13, i : 7; unsigned long long l; }; T(Q)\n+struct R { unsigned int k : 12, j : 11, i : 9; unsigned long long l; }; T(R)\n+struct S { unsigned short k : 1, j : 6, i : 9; unsigned long long l; }; T(S)\n+struct T { unsigned short k : 1, j : 8, i : 7; unsigned short l; }; T(T)\n+struct U { unsigned short j : 6, k : 1, i : 9; unsigned long long l; }; T(U)\n+struct V { unsigned short j : 8, k : 1, i : 7; unsigned short l; }; T(V)\n+struct W { long double l; unsigned int k : 12, j : 13, i : 7; }; T(W)\n+struct X { unsigned int k : 12, j : 13, i : 7; long double l; }; T(X)\n+struct Y { unsigned int k : 12, j : 11, i : 9; long double l; }; T(Y)\n+struct Z { long double l; unsigned int j : 13, i : 7, k : 12; }; T(Z)\n+\n+int\n+main (void)\n+{\n+  testA ();\n+  testB ();\n+  testC ();\n+  testD ();\n+  testE ();\n+  testF ();\n+  testG ();\n+  testH ();\n+  testI ();\n+  testJ ();\n+  testK ();\n+  testL ();\n+  testM ();\n+  testN ();\n+  testO ();\n+  testP ();\n+  testQ ();\n+  testR ();\n+  testS ();\n+  testT ();\n+  testU ();\n+  testV ();\n+  testW ();\n+  testX ();\n+  testY ();\n+  testZ ();\n+  exit (0);\n+}"}]}