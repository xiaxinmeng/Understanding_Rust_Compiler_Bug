{"sha": "16595a1f286b9f421000a25866f465bd45a24538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1OTVhMWYyODZiOWY0MjEwMDBhMjU4NjZmNDY1YmQ0NWEyNDUzOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2016-02-12T01:38:06Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2016-02-12T01:38:06Z"}, "message": "Fix obstack use-after-free problems in C frontend, PR69522\n\nc/\n\tPR c/69522\n\t* c-parser.c (c_parser_braced_init): New arg outer_obstack.  All\n\tcallers changed.  If nested_p is true, use it to call\n\tfinish_implicit_inits.\n\t* c-tree.h (finish_implicit_inits): Declare.\n\t* c-typeck.c (finish_implicit_inits): New function.  Move code\n\tfrom ...\n\t(push_init_level): ... here.\n\t(set_designator, process_init_element): Call finish_implicit_inits.\n\ntestsuite/\n\tPR c/69522\n\tgcc.dg/pr69522.c: New test.\n\nFrom-SVN: r233366", "tree": {"sha": "91eedf26ad1b6621eed02ddc3ccecc0614c40a1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91eedf26ad1b6621eed02ddc3ccecc0614c40a1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16595a1f286b9f421000a25866f465bd45a24538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16595a1f286b9f421000a25866f465bd45a24538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16595a1f286b9f421000a25866f465bd45a24538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16595a1f286b9f421000a25866f465bd45a24538/comments", "author": null, "committer": null, "parents": [{"sha": "38d795d27c34ebc70a944009d82d20415ec81a64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d795d27c34ebc70a944009d82d20415ec81a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d795d27c34ebc70a944009d82d20415ec81a64"}], "stats": {"total": 98, "additions": 65, "deletions": 33}, "files": [{"sha": "dda2216abb9fc02d6d7dde3b5f72d85ecfc97790", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -1,3 +1,15 @@\n+2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR c/69522\n+\t* c-parser.c (c_parser_braced_init): New arg outer_obstack.  All\n+\tcallers changed.  If nested_p is true, use it to call\n+\tfinish_implicit_inits.\n+\t* c-tree.h (finish_implicit_inits): Declare.\n+\t* c-typeck.c (finish_implicit_inits): New function.  Move code\n+\tfrom ...\n+\t(push_init_level): ... here.\n+\t(set_designator, process_init_element): Call finish_implicit_inits.\n+\n 2016-02-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/69768"}, {"sha": "7a272447900a9a0305a644bd0ca2f0e16738e7e6", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -1293,7 +1293,8 @@ static tree c_parser_simple_asm_expr (c_parser *);\n static tree c_parser_attributes (c_parser *);\n static struct c_type_name *c_parser_type_name (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *);\n-static struct c_expr c_parser_braced_init (c_parser *, tree, bool);\n+static struct c_expr c_parser_braced_init (c_parser *, tree, bool,\n+\t\t\t\t\t   struct obstack *);\n static void c_parser_initelt (c_parser *, struct obstack *);\n static void c_parser_initval (c_parser *, struct c_expr *,\n \t\t\t      struct obstack *);\n@@ -4307,7 +4308,7 @@ static struct c_expr\n c_parser_initializer (c_parser *parser)\n {\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-    return c_parser_braced_init (parser, NULL_TREE, false);\n+    return c_parser_braced_init (parser, NULL_TREE, false, NULL);\n   else\n     {\n       struct c_expr ret;\n@@ -4327,7 +4328,8 @@ c_parser_initializer (c_parser *parser)\n    top-level initializer in a declaration.  */\n \n static struct c_expr\n-c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n+c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n+\t\t      struct obstack *outer_obstack)\n {\n   struct c_expr ret;\n   struct obstack braced_init_obstack;\n@@ -4336,7 +4338,10 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));\n   c_parser_consume_token (parser);\n   if (nested_p)\n-    push_init_level (brace_loc, 0, &braced_init_obstack);\n+    {\n+      finish_implicit_inits (brace_loc, outer_obstack);\n+      push_init_level (brace_loc, 0, &braced_init_obstack);\n+    }\n   else\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -4594,7 +4599,8 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n   location_t loc = c_parser_peek_token (parser)->location;\n \n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) && !after)\n-    init = c_parser_braced_init (parser, NULL_TREE, true);\n+    init = c_parser_braced_init (parser, NULL_TREE, true,\n+\t\t\t\t braced_init_obstack);\n   else\n     {\n       init = c_parser_expr_no_commas (parser, after);\n@@ -8083,7 +8089,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n       error_at (type_loc, \"compound literal has variable size\");\n       type = error_mark_node;\n     }\n-  init = c_parser_braced_init (parser, type, false);\n+  init = c_parser_braced_init (parser, type, false, NULL);\n   finish_init ();\n   maybe_warn_string_init (type_loc, type, init);\n "}, {"sha": "96ab049b982de71d9b736dcede2b00c60e74e5ea", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -625,6 +625,7 @@ extern void maybe_warn_string_init (location_t, tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n+extern void finish_implicit_inits (location_t, struct obstack *);\n extern void push_init_level (location_t, int, struct obstack *);\n extern struct c_expr pop_init_level (location_t, int, struct obstack *);\n extern void set_init_index (location_t, tree, tree, struct obstack *);"}, {"sha": "1122a88417bd46ae195bc580a732285fabeaf51b", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -7548,6 +7548,30 @@ really_start_incremental_init (tree type)\n     }\n }\n \f\n+/* Called when we see an open brace for a nested initializer.  Finish\n+   off any pending levels with implicit braces.  */\n+void\n+finish_implicit_inits (location_t loc, struct obstack *braced_init_obstack)\n+{\n+  while (constructor_stack->implicit)\n+    {\n+      if (RECORD_OR_UNION_TYPE_P (constructor_type)\n+\t  && constructor_fields == 0)\n+\tprocess_init_element (input_location,\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      true, braced_init_obstack);\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t       && constructor_max_index\n+\t       && tree_int_cst_lt (constructor_max_index,\n+\t\t\t\t   constructor_index))\n+\tprocess_init_element (input_location,\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      true, braced_init_obstack);\n+      else\n+\tbreak;\n+    }\n+}\n+\n /* Push down into a subobject, for initialization.\n    If this is for an explicit set of braces, IMPLICIT is 0.\n    If it is because the next element belongs at a lower level,\n@@ -7560,33 +7584,6 @@ push_init_level (location_t loc, int implicit,\n   struct constructor_stack *p;\n   tree value = NULL_TREE;\n \n-  /* If we've exhausted any levels that didn't have braces,\n-     pop them now.  If implicit == 1, this will have been done in\n-     process_init_element; do not repeat it here because in the case\n-     of excess initializers for an empty aggregate this leads to an\n-     infinite cycle of popping a level and immediately recreating\n-     it.  */\n-  if (implicit != 1)\n-    {\n-      while (constructor_stack->implicit)\n-\t{\n-\t  if (RECORD_OR_UNION_TYPE_P (constructor_type)\n-\t      && constructor_fields == 0)\n-\t    process_init_element (input_location,\n-\t\t\t\t  pop_init_level (loc, 1, braced_init_obstack),\n-\t\t\t\t  true, braced_init_obstack);\n-\t  else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t\t   && constructor_max_index\n-\t\t   && tree_int_cst_lt (constructor_max_index,\n-\t\t\t\t       constructor_index))\n-\t    process_init_element (input_location,\n-\t\t\t\t  pop_init_level (loc, 1, braced_init_obstack),\n-\t\t\t\t  true, braced_init_obstack);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n   /* Unless this is an explicit brace, we need to preserve previous\n      content if any.  */\n   if (implicit)\n@@ -8013,6 +8010,7 @@ set_designator (location_t loc, int array,\n     }\n \n   constructor_designated = 1;\n+  finish_implicit_inits (loc, braced_init_obstack);\n   push_init_level (loc, 2, braced_init_obstack);\n   return 0;\n }\n@@ -9396,6 +9394,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      p = p->next;\n \t      if (!p)\n \t\tbreak;\n+\t      finish_implicit_inits (loc, braced_init_obstack);\n \t      push_init_level (loc, 2, braced_init_obstack);\n \t      p->stack = constructor_stack;\n \t      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))"}, {"sha": "cd3161fac13f4bccc3eefcb8d679cae42ece6160", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -1,3 +1,8 @@\n+2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR c/69522\n+\tgcc.dg/pr69522.c: New test.\n+\n 2016-02-12  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/69098"}, {"sha": "452a1ae1b0353492f6623f933ab1deb8736e9c0d", "filename": "gcc/testsuite/gcc.dg/pr69522.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69522.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16595a1f286b9f421000a25866f465bd45a24538/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69522.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69522.c?ref=16595a1f286b9f421000a25866f465bd45a24538", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+struct str {};\n+struct {\n+  struct str b;\n+  float c[1];\n+  int d[1];\n+  float e[2];\n+  int f[1];\n+} a = {{}, 0, {0.5}, 0, 0, {0}};"}]}