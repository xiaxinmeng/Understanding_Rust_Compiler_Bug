{"sha": "bbb362e69327419645706dc498ed4b6f36f2a38c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJiMzYyZTY5MzI3NDE5NjQ1NzA2ZGM0OThlZDRiNmYzNmYyYTM4Yw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-07-11T11:49:25Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-07-11T11:49:25Z"}, "message": "linux.h (MD_FALLBACK_FRAME_STATE_FOR): For SIGSEGV and SIGBUS signal frames...\n\nChangeLog:\n\n\t* config/s390/linux.h (MD_FALLBACK_FRAME_STATE_FOR): For SIGSEGV and\n\tSIGBUS signal frames, the PSW address points *to* the faulting\n\tinstruction, not after it.\n\nlibjava/ChangeLog:\n\n\t* include/s390-signal.c (SIGNAL_HANDLER): Use SIGINFO-style prototype.\n\t(struct old_s390_kernel_sigaction): Likewise for k_sa_handler.\n\t(MAKE_THROW_FRAME): Do not modify PSW address.\n\t(INIT_SEGV): Install SIGINFO-style signal handler.\n\t(INIT_FPE): Likewise.\n\nFrom-SVN: r84506", "tree": {"sha": "50692d12dfe4f9dda2dfd3313cdbd8a3d64c267d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50692d12dfe4f9dda2dfd3313cdbd8a3d64c267d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbb362e69327419645706dc498ed4b6f36f2a38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbb362e69327419645706dc498ed4b6f36f2a38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbb362e69327419645706dc498ed4b6f36f2a38c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbb362e69327419645706dc498ed4b6f36f2a38c/comments", "author": null, "committer": null, "parents": [{"sha": "e5dce82f98a9602dfb781c3cf64ee2c3d0cc05d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5dce82f98a9602dfb781c3cf64ee2c3d0cc05d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5dce82f98a9602dfb781c3cf64ee2c3d0cc05d1"}], "stats": {"total": 64, "additions": 50, "deletions": 14}, "files": [{"sha": "414b18b0c6e52679933825213301b53941429e2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb362e69327419645706dc498ed4b6f36f2a38c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb362e69327419645706dc498ed4b6f36f2a38c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbb362e69327419645706dc498ed4b6f36f2a38c", "patch": "@@ -1,3 +1,9 @@\n+2004-07-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/linux.h (MD_FALLBACK_FRAME_STATE_FOR): For SIGSEGV and \n+\tSIGBUS signal frames, the PSW address points *to* the faulting\n+\tinstruction, not after it.\n+\n 2004-07-11  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (legitimize_tls_address): Handle constant offsets"}, {"sha": "0f51ef7d84b139f017e623970a58b58bf8ca4eae", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb362e69327419645706dc498ed4b6f36f2a38c/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb362e69327419645706dc498ed4b6f36f2a38c/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=bbb362e69327419645706dc498ed4b6f36f2a38c", "patch": "@@ -113,6 +113,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       } __attribute__ ((__aligned__ (8))) sigregs_;\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     sigregs_ *regs_;\t\t\t\t\t\t\t\\\n+    int *signo_ = NULL;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* svc $__NR_sigreturn or svc $__NR_rt_sigreturn  */\t\t\\\n     if (pc_[0] != 0x0a || (pc_[1] != 119 && pc_[1] != 173))\t\t\\\n@@ -133,6 +134,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t  } *uc_ = (CONTEXT)->cfa + 8 + 128;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tregs_ = &uc_->uc_mcontext;\t\t\t\t\t\\\n+\tsigno_ = (CONTEXT)->cfa + sizeof(long);\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* Old-style RT frame and all non-RT frames:\t\t\t\\\n@@ -141,6 +143,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tregs_ = *(sigregs_ **)((CONTEXT)->cfa + 8);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* Recent kernels store the signal number immediately after\t\\\n+\t   the sigregs; old kernels have the return trampoline at\t\\\n+\t   this location.  */\t\t\t\t\t\t\\\n+\tif ((void *)(regs_ + 1) != (CONTEXT)->ra)\t\t\t\\\n+\t  signo_ = (int *)(regs_ + 1);\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n       \t\t\t\t\t\t\t\t\t\\\n     new_cfa_ = regs_->gprs[15] + 16*sizeof(long) + 32;\t\t\t\\\n@@ -163,10 +171,31 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* Load return addr from PSW into dummy register 32.  */\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n     (FS)->regs.reg[32].how = REG_SAVED_OFFSET;\t\t\t\t\\\n     (FS)->regs.reg[32].loc.offset = (long)&regs_->psw_addr - new_cfa_;\t\\\n     (FS)->retaddr_column = 32;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+    /* If we got a SIGSEGV or a SIGBUS, the PSW address points *to*\t\\\n+       the faulting instruction, not after it.  This causes the logic\t\\\n+       in unwind-dw2.c that decrements the RA to determine the correct\t\\\n+       CFI region to get confused.  To fix that, we *increment* the RA\t\\\n+       here in that case.  Note that we cannot modify the RA in place,\t\\\n+       and the frame state wants a *pointer*, not a value; thus we put\t\\\n+       the modified RA value into the unused register 33 slot of FS and\t\\\n+       have the register 32 save address point to that slot.\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+       Unfortunately, for regular signals on old kernels, we don't know\t\\\n+       the signal number.  We default to not fiddling with the RA; \t\\\n+       that can fail in rare cases.  Upgrade your kernel.  */\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (signo_ && (*signo_ == 11 || *signo_ == 7))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[33].loc.exp = regs_->psw_addr + 1;\t\t\\\n+\t(FS)->regs.reg[32].loc.offset = \t\t\t\t\\\n+\t\t(long)&(FS)->regs.reg[33].loc.exp - new_cfa_;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n     goto SUCCESS;\t\t\t\t\t\t\t\\\n   } while (0)\n "}, {"sha": "01952d6a5d5ce204e4143861f60771f370b0df0d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb362e69327419645706dc498ed4b6f36f2a38c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb362e69327419645706dc498ed4b6f36f2a38c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bbb362e69327419645706dc498ed4b6f36f2a38c", "patch": "@@ -1,3 +1,11 @@\n+2004-07-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* include/s390-signal.c (SIGNAL_HANDLER): Use SIGINFO-style prototype.\n+\t(struct old_s390_kernel_sigaction): Likewise for k_sa_handler.\n+\t(MAKE_THROW_FRAME): Do not modify PSW address.\n+\t(INIT_SEGV): Install SIGINFO-style signal handler.\n+\t(INIT_FPE): Likewise.\n+\n 2004-07-10  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* testsuite/libjava.jacks/jacks.xfail: Updates to reflect current"}, {"sha": "743c398830b110e6e6311eed8a312e5e961fdd74", "filename": "libjava/include/s390-signal.h", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb362e69327419645706dc498ed4b6f36f2a38c/libjava%2Finclude%2Fs390-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb362e69327419645706dc498ed4b6f36f2a38c/libjava%2Finclude%2Fs390-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fs390-signal.h?ref=bbb362e69327419645706dc498ed4b6f36f2a38c", "patch": "@@ -20,18 +20,11 @@ details.  */\n #undef HANDLE_FPE\n \n #define SIGNAL_HANDLER(_name)\t\\\n-static void _name (int /* _signal */, struct sigcontext _sc)\n+static void _name (int, siginfo_t *, void *)\n \n-#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* Advance the program counter so that it is after the start of the\t\\\n-     instruction:  the s390 exception handler expects the PSW to point \t\\\n-     to the instruction after a call. */\t\t\t\t\\\n-  _sc.sregs->regs.psw.addr += 2;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+/* We no longer need to fiddle with the PSW address in the signal handler;\n+   this is now all handled correctly in MD_FALLBACK_FRAME_STATE_FOR.  */\n+#define MAKE_THROW_FRAME(_exception)\n \n \n /* For an explanation why we cannot simply use sigaction to\n@@ -43,7 +36,7 @@ while (0)\n    visible to us in a header file so we define it here.  */\n \n struct old_s390_kernel_sigaction {\n-\tvoid (*k_sa_handler) (int, struct sigcontext);\n+\tvoid (*k_sa_handler) (int, siginfo_t *, void *);\n \tunsigned long k_sa_mask;\n \tunsigned long k_sa_flags;\n \tvoid (*sa_restorer) (void);\n@@ -55,7 +48,7 @@ do\t\t\t\t\t\t\t\\\n     struct old_s390_kernel_sigaction kact;\t\t\\\n     kact.k_sa_handler = catch_segv;\t\t\t\\\n     kact.k_sa_mask = 0;\t\t\t\t\t\\\n-    kact.k_sa_flags = 0;\t\t\t\t\\\n+    kact.k_sa_flags = SA_SIGINFO;\t\t\t\\\n     syscall (SYS_sigaction, SIGSEGV, &kact, NULL);\t\\\n   }\t\t\t\t\t\t\t\\\n while (0)  \n@@ -66,7 +59,7 @@ do\t\t\t\t\t\t\t\t\\\n     struct old_s390_kernel_sigaction kact;\t\t\t\\\n     kact.k_sa_handler = catch_fpe;\t\t\t\t\\\n     kact.k_sa_mask = 0;\t\t\t\t\t\t\\\n-    kact.k_sa_flags = 0;\t\t\t\t\t\\\n+    kact.k_sa_flags = SA_SIGINFO;\t\t\t\t\\\n     syscall (SYS_sigaction, SIGFPE, &kact, NULL);\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  "}]}