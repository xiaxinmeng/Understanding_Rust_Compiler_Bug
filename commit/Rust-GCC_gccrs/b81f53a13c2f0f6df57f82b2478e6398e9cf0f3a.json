{"sha": "b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxZjUzYTEzYzJmMGY2ZGY1N2Y4MmIyNDc4ZTYzOThlOWNmMGYzYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-23T10:42:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-23T10:42:56Z"}, "message": "alpha.c: Remove #ifdef HAIFA since now only scheduler.\n\n\t* config/alpha/alpha.c: Remove #ifdef HAIFA since now only scheduler.\n\t(alpha_start_function): Never write ..ng label if VMS or NT.\n\t(alpha_align_insns): Remove GP_IN_USE arg.\n\tAlignment now unsigned.\n\t(alpha_reorg): Don't pass GP_IN_USE arg to alpha_align_insns.\n\t* config/alpha/alpha.md (prologue_ldgp): Split into one define_expand\n\tand two define_insn's.\n\nFrom-SVN: r34104", "tree": {"sha": "6cc7b525785624ef5dbf2655e41f8605eb7afa8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc7b525785624ef5dbf2655e41f8605eb7afa8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/comments", "author": null, "committer": null, "parents": [{"sha": "3c094e2201dea8e5a727abb28ed6a8ad0e0c9277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c094e2201dea8e5a727abb28ed6a8ad0e0c9277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c094e2201dea8e5a727abb28ed6a8ad0e0c9277"}], "stats": {"total": 102, "additions": 62, "deletions": 40}, "files": [{"sha": "68ee38034fafafb578ad8c27d2c962e432067042", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "patch": "@@ -1,3 +1,13 @@\n+Tue May 23 06:50:29 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* config/alpha/alpha.c: Remove #ifdef HAIFA since now only scheduler.\n+\t(alpha_start_function): Never write ..ng label if VMS or NT.\n+\t(alpha_align_insns): Remove GP_IN_USE arg.\n+\tAlignment now unsigned.\n+\t(alpha_reorg): Don't pass GP_IN_USE arg to alpha_align_insns.\n+\t* config/alpha/alpha.md (prologue_ldgp): Split into one define_expand\n+\tand two define_insn's.\n+\n 2000-05-22  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (simplify_comparison): Use trunc_int_for_mode."}, {"sha": "d19f0b0cdf04a4f462aa9c1720e603a5be321850", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "patch": "@@ -4434,7 +4434,8 @@ alpha_start_function (file, fnname, decl)\n \n       /* If the function needs GP, we'll write the \"..ng\" label there.\n \t Otherwise, do it here.  */\n-      if (! alpha_function_needs_gp)\n+      if (! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\n+\t  && ! alpha_function_needs_gp)\n \t{\n \t  putc ('$', file);\n \t  assemble_name (file, fnname);\n@@ -5179,7 +5180,6 @@ alpha_handle_trap_shadows (insns)\n     }\n }\n \f\n-#ifdef HAIFA\n /* Alpha can only issue instruction groups simultaneously if they are\n    suitibly aligned.  This is very processor-specific.  */\n \n@@ -5203,13 +5203,13 @@ enum alphaev5_pipe {\n \n static enum alphaev4_pipe alphaev4_insn_pipe PARAMS ((rtx));\n static enum alphaev5_pipe alphaev5_insn_pipe PARAMS ((rtx));\n-static rtx alphaev4_next_group PARAMS ((rtx, int*, int*));\n-static rtx alphaev5_next_group PARAMS ((rtx, int*, int*));\n-static rtx alphaev4_next_nop PARAMS ((int*));\n-static rtx alphaev5_next_nop PARAMS ((int*));\n+static rtx alphaev4_next_group PARAMS ((rtx, int *, int *));\n+static rtx alphaev5_next_group PARAMS ((rtx, int *, int *));\n+static rtx alphaev4_next_nop PARAMS ((int *));\n+static rtx alphaev5_next_nop PARAMS ((int *));\n \n static void alpha_align_insns\n-  PARAMS ((rtx, int, rtx (*)(rtx, int*, int*), rtx (*)(int*), int));\n+  PARAMS ((rtx, unsigned int, rtx (*)(rtx, int *, int *), rtx (*)(int *)));\n \n static enum alphaev4_pipe\n alphaev4_insn_pipe (insn)\n@@ -5249,7 +5249,7 @@ alphaev4_insn_pipe (insn)\n       return EV4_IB1;\n \n     default:\n-      abort();\n+      abort ();\n     }\n }\n \n@@ -5596,15 +5596,14 @@ alphaev5_next_nop (pin_use)\n /* The instruction group alignment main loop.  */\n \n static void\n-alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n+alpha_align_insns (insns, max_align, next_group, next_nop)\n      rtx insns;\n-     int max_align;\n-     rtx (*next_group) PARAMS ((rtx, int*, int*));\n-     rtx (*next_nop) PARAMS ((int*));\n-     int gp_in_use;\n+     unsigned int max_align;\n+     rtx (*next_group) PARAMS ((rtx, int *, int *));\n+     rtx (*next_nop) PARAMS ((int *));\n {\n   /* ALIGN is the known alignment for the insn group.  */\n-  int align;\n+  unsigned int align;\n   /* OFS is the offset of the current insn in the insn group.  */\n   int ofs;\n   int prev_in_use, in_use, len;\n@@ -5613,35 +5612,29 @@ alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n   /* Let shorten branches care for assigning alignments to code labels.  */\n   shorten_branches (insns);\n \n-  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < max_align\n-\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : max_align);\n+  align = (FUNCTION_BOUNDARY / BITS_PER_UNIT < max_align\n+\t   ? FUNCTION_BOUNDARY / BITS_PER_UNIT : max_align);\n \n-  /* Account for the initial GP load, which happens before the scheduled\n-     prologue we emitted as RTL.  */\n   ofs = prev_in_use = 0;\n-  if (alpha_does_function_need_gp())\n-    {\n-      ofs = 8 & (align - 1);\n-      prev_in_use = gp_in_use;\n-    }\n-\n   i = insns;\n   if (GET_CODE (i) == NOTE)\n     i = next_nonnote_insn (i);\n \n   while (i)\n     {\n-      next = (*next_group)(i, &in_use, &len);\n+      next = (*next_group) (i, &in_use, &len);\n \n       /* When we see a label, resync alignment etc.  */\n       if (GET_CODE (i) == CODE_LABEL)\n \t{\n-\t  int new_align = 1 << label_to_alignment (i);\n+\t  unsigned int new_align = 1 << label_to_alignment (i);\n+\n \t  if (new_align >= align)\n \t    {\n \t      align = new_align < max_align ? new_align : max_align;\n \t      ofs = 0;\n \t    }\n+\n \t  else if (ofs & (new_align-1))\n \t    ofs = (ofs | (new_align-1)) + 1;\n \t  if (len != 0)\n@@ -5666,7 +5659,7 @@ alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n \t realign the output.  */\n       else if (align < len)\n \t{\n-\t  int new_log_align = len > 8 ? 4 : 3;\n+\t  unsigned int new_log_align = len > 8 ? 4 : 3;\n \t  rtx where;\n \n \t  where = prev_nonnote_insn (i);\n@@ -5717,7 +5710,6 @@ alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n       i = next;\n     }\n }\n-#endif /* HAIFA */\n \f\n /* Machine dependant reorg pass.  */\n \n@@ -5728,24 +5720,19 @@ alpha_reorg (insns)\n   if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)\n     alpha_handle_trap_shadows (insns);\n \n-#ifdef HAIFA\n   /* Due to the number of extra trapb insns, don't bother fixing up\n      alignment when trap precision is instruction.  Moreover, we can\n-     only do our job when sched2 is run and Haifa is our scheduler.  */\n+     only do our job when sched2 is run.  */\n   if (optimize && !optimize_size\n       && alpha_tp != ALPHA_TP_INSN\n       && flag_schedule_insns_after_reload)\n     {\n       if (alpha_cpu == PROCESSOR_EV4)\n-\talpha_align_insns (insns, 8, alphaev4_next_group,\n-\t\t\t   alphaev4_next_nop, EV4_IB0);\n+\talpha_align_insns (insns, 8, alphaev4_next_group, alphaev4_next_nop);\n       else if (alpha_cpu == PROCESSOR_EV5)\n-\talpha_align_insns (insns, 16, alphaev5_next_group,\n-\t\t\t   alphaev5_next_nop, EV5_E01 | EV5_E0);\n+\talpha_align_insns (insns, 16, alphaev5_next_group, alphaev5_next_nop);\n     }\n-#endif\n }\n-\n \f\n /* Check a floating-point value for validity for a particular machine mode.  */\n "}, {"sha": "10b5aa1b50b74ffaf9c556b96e0f360e92b21440", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=b81f53a13c2f0f6df57f82b2478e6398e9cf0f3a", "patch": "@@ -5493,11 +5493,29 @@\n   DONE;\n }\")\n \n-(define_insn \"prologue_ldgp\"\n-  [(unspec_volatile [(const_int 0)] 9)]\n+;; These take care of emitting the ldgp insn in the prologue. This will be\n+;; an lda/ldah pair and we want to align them properly.  So we have two\n+;; unspec_volatile insns, the first of which emits the ldgp assembler macro\n+;; and the second of which emits nothing.  However, both are marked as type\n+;; IADD (the default) so the alignment code in alpha.c does the right thing\n+;; with them.\n+\n+(define_expand \"prologue_ldgp\"\n+  [(unspec_volatile [(const_int 0)] 9)\n+   (unspec_volatile [(const_int 0)] 10)]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*prologue_ldgp_1\"\n+  [(unspec_volatile [(const_int 0)] 9)]\n+  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n   \"ldgp $29,0($27)\\\\n$%~..ng:\")\n \n+(define_insn \"*prologue_ldgp_2\"\n+  [(unspec_volatile [(const_int 0)] 10)]\n+  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"\")\n+\n (define_insn \"init_fp\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (match_operand:DI 1 \"register_operand\" \"r\"))\n@@ -5508,12 +5526,19 @@\n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n-  \"alpha_expand_epilogue ();\")\n+  \"\n+{\n+  alpha_expand_epilogue ();\n+}\")\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n   \"!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT\"\n-  \"alpha_expand_epilogue (); DONE;\")\n+  \"\n+{\n+  alpha_expand_epilogue ();\n+  DONE;\n+}\")\n \n (define_expand \"eh_epilogue\"\n   [(use (match_operand:DI 0 \"register_operand\" \"r\"))"}]}