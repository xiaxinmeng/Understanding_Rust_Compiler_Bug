{"sha": "87ccab5d9c97337980d95a78889c38f6b70fc544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjY2FiNWQ5Yzk3MzM3OTgwZDk1YTc4ODg5YzM4ZjZiNzBmYzU0NA==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-05T16:03:09Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-05T16:03:09Z"}, "message": "move param detection to scop detection\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r228493", "tree": {"sha": "d14d522a2c05e6cb729f8267bbff38471e619564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d14d522a2c05e6cb729f8267bbff38471e619564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ccab5d9c97337980d95a78889c38f6b70fc544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ccab5d9c97337980d95a78889c38f6b70fc544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ccab5d9c97337980d95a78889c38f6b70fc544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ccab5d9c97337980d95a78889c38f6b70fc544/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "076d564d3072837b2c008912634d5980f8a3c0e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076d564d3072837b2c008912634d5980f8a3c0e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076d564d3072837b2c008912634d5980f8a3c0e3"}], "stats": {"total": 675, "additions": 310, "deletions": 365}, "files": [{"sha": "930933190c774f5b6d0c0f545eff17f99eadcfb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -1,3 +1,30 @@\n+2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-poly.c (new_gimple_poly_bb): ... here.\n+\t(free_data_refs_aux): ... here.\n+\t(free_gimple_poly_bb): ... here.\n+\t(remove_gbbs_in_scop): ... here.\n+\t(new_scop): Call new_sese.\n+\t(free_scop): Call remove_gbbs_in_scop and free_sese.\n+\t* graphite-poly.h (base_alias_pair): ... here.\n+\t(new_gimple_poly_bb): Declare.\n+\t(free_gimple_poly_bb): Declare.\n+\t* graphite-scop-detection.c (parameter_index_in_region_1):\n+\t(parameter_index_in_region): ... here.\n+\t(scan_tree_for_params): ... here.\n+\t(find_params_in_bb): ... here.\n+\t(find_scop_parameters): ... here.\n+\t(build_scops): Call find_scop_parameters.\n+\t* graphite-sese-to-poly.c (free_gimple_poly_bb): Move...\n+\t(free_scops): Move...\n+\t(single_pred_cond_non_loop_exit): Move...\n+\t(sese_dom_walker::before_dom_children): Move...\n+\t(sese_dom_walker::after_dom_children): Move...\n+\t(build_poly_scop): Move...\n+\t* graphite-sese-to-poly.h (base_alias_pair): Move...\n+\t* graphite.c (free_scops): ... here.\n+\n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "ce1a18fbd218ec0b98ed1946847db008ffc48b77", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -257,11 +257,72 @@ debug_pdr (poly_dr_p pdr, int verbosity)\n   print_pdr (stderr, pdr, verbosity);\n }\n \n-/* Creates a new SCOP containing REGION.  */\n+/* Store the GRAPHITE representation of BB.  */\n+\n+gimple_poly_bb_p\n+new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs)\n+{\n+  gimple_poly_bb_p gbb;\n+\n+  gbb = XNEW (struct gimple_poly_bb);\n+  bb->aux = gbb;\n+  GBB_BB (gbb) = bb;\n+  GBB_DATA_REFS (gbb) = drs;\n+  GBB_CONDITIONS (gbb).create (0);\n+  GBB_CONDITION_CASES (gbb).create (0);\n+\n+  return gbb;\n+}\n+\n+static void\n+free_data_refs_aux (vec<data_reference_p> datarefs)\n+{\n+  unsigned int i;\n+  data_reference_p dr;\n+\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+    if (dr->aux)\n+      {\n+\tbase_alias_pair_p bap = (base_alias_pair_p)(dr->aux);\n+\n+\tfree (bap->alias_set);\n+\n+\tfree (bap);\n+\tdr->aux = NULL;\n+      }\n+}\n+/* Frees GBB.  */\n+\n+void\n+free_gimple_poly_bb (gimple_poly_bb_p gbb)\n+{\n+  free_data_refs_aux (GBB_DATA_REFS (gbb));\n+  free_data_refs (GBB_DATA_REFS (gbb));\n+\n+  GBB_CONDITIONS (gbb).release ();\n+  GBB_CONDITION_CASES (gbb).release ();\n+  GBB_BB (gbb)->aux = 0;\n+  XDELETE (gbb);\n+}\n+\n+/* Deletes all gimple bbs in SCOP.  */\n+\n+static void\n+remove_gbbs_in_scop (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n+    free_gimple_poly_bb (PBB_BLACK_BOX (pbb));\n+}\n+\n+/* Creates a new SCOP containing the region (ENTRY, EXIT).  */\n \n scop_p\n-new_scop (sese region)\n+new_scop (edge entry, edge exit)\n {\n+  sese region = new_sese (entry, exit);\n   scop_p scop = XNEW (struct scop);\n \n   scop->context = NULL;\n@@ -292,6 +353,9 @@ free_scop (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n \n+  remove_gbbs_in_scop (scop);\n+  free_sese (SCOP_REGION (scop));\n+\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     free_poly_bb (pbb);\n "}, {"sha": "c404b421aa07bd1c0bf52cd22b1e93dacc7121ed", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -422,9 +422,16 @@ struct scop\n #define SCOP_CONTEXT(S) (NULL)\n #define POLY_SCOP_P(S) (S->poly_scop_p)\n \n-extern scop_p new_scop (sese);\n+typedef struct base_alias_pair\n+{\n+  int base_obj_set;\n+  int *alias_set;\n+} *base_alias_pair_p;\n+\n+extern scop_p new_scop (edge, edge);\n extern void free_scop (scop_p);\n-extern void free_scops (vec<scop_p> );\n+extern gimple_poly_bb_p new_gimple_poly_bb (basic_block, vec<data_reference_p>);\n+extern void free_gimple_poly_bb (gimple_poly_bb_p);\n extern void print_generated_program (FILE *, scop_p);\n extern void debug_generated_program (scop_p);\n extern int unify_scattering_dimensions (scop_p);"}, {"sha": "cd8e4d56082904aaed1ec239b9586366e67ea879", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 187, "deletions": 30, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -149,23 +149,6 @@ same_close_phi_node (gphi *p1, gphi *p2)\n \t\t\t  gimple_phi_arg_def (p2, 0), 0);\n }\n \n-/* Store the GRAPHITE representation of BB.  */\n-\n-static gimple_poly_bb_p\n-new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs)\n-{\n-  gimple_poly_bb_p gbb;\n-\n-  gbb = XNEW (struct gimple_poly_bb);\n-  bb->aux = gbb;\n-  GBB_BB (gbb) = bb;\n-  GBB_DATA_REFS (gbb) = drs;\n-  GBB_CONDITIONS (gbb).create (0);\n-  GBB_CONDITION_CASES (gbb).create (0);\n-\n-  return gbb;\n-}\n-\n /* Compare the depth of two basic_block's P1 and P2.  */\n \n static int\n@@ -1690,6 +1673,171 @@ scop_detection::nb_pbbs_in_loops (scop_p scop)\n   return res;\n }\n \n+/* When parameter NAME is in REGION, returns its index in SESE_PARAMS.\n+   Otherwise returns -1.  */\n+\n+static inline int\n+parameter_index_in_region_1 (tree name, sese region)\n+{\n+  int i;\n+  tree p;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, p)\n+    if (p == name)\n+      return i;\n+\n+  return -1;\n+}\n+\n+/* When the parameter NAME is in REGION, returns its index in\n+   SESE_PARAMS.  Otherwise this function inserts NAME in SESE_PARAMS\n+   and returns the index of NAME.  */\n+\n+static int\n+parameter_index_in_region (tree name, sese region)\n+{\n+  int i;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  /* Cannot constrain on anything else than INTEGER_TYPE parameters.  */\n+  if (TREE_CODE (TREE_TYPE (name)) != INTEGER_TYPE)\n+    return -1;\n+\n+  if (!invariant_in_sese_p_rec (name, region))\n+    return -1;\n+\n+  i = parameter_index_in_region_1 (name, region);\n+  if (i != -1)\n+    return i;\n+\n+  gcc_assert (SESE_ADD_PARAMS (region));\n+\n+  i = SESE_PARAMS (region).length ();\n+  SESE_PARAMS (region).safe_push (name);\n+  return i;\n+}\n+\n+/* In the context of sese S, scan the expression E and translate it to\n+   a linear expression C.  When parsing a symbolic multiplication, K\n+   represents the constant multiplier of an expression containing\n+   parameters.  */\n+\n+static void\n+scan_tree_for_params (sese s, tree e)\n+{\n+  if (e == chrec_dont_know)\n+    return;\n+\n+  switch (TREE_CODE (e))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      scan_tree_for_params (s, CHREC_LEFT (e));\n+      break;\n+\n+    case MULT_EXPR:\n+      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 0));\n+      else\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 1));\n+      break;\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n+      scan_tree_for_params (s, TREE_OPERAND (e, 1));\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n+      break;\n+\n+    case SSA_NAME:\n+      parameter_index_in_region (e, s);\n+      break;\n+\n+    case INTEGER_CST:\n+    case ADDR_EXPR:\n+    case REAL_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      break;\n+\n+   default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+/* Find parameters with respect to REGION in BB. We are looking in memory\n+   access functions, conditions and loop bounds.  */\n+\n+static void\n+find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n+{\n+  int i;\n+  unsigned j;\n+  data_reference_p dr;\n+  gimple *stmt;\n+  loop_p loop = GBB_BB (gbb)->loop_father;\n+\n+  /* Find parameters in the access functions of data references.  */\n+  FOR_EACH_VEC_ELT (GBB_DATA_REFS (gbb), i, dr)\n+    for (j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n+      scan_tree_for_params (region, DR_ACCESS_FN (dr, j));\n+\n+  /* Find parameters in conditional statements.  */\n+  FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n+    {\n+      tree lhs = scalar_evolution_in_region (region, loop,\n+\t\t\t\t\t     gimple_cond_lhs (stmt));\n+      tree rhs = scalar_evolution_in_region (region, loop,\n+\t\t\t\t\t     gimple_cond_rhs (stmt));\n+\n+      scan_tree_for_params (region, lhs);\n+      scan_tree_for_params (region, rhs);\n+    }\n+}\n+\n+/* Record the parameters used in the SCOP.  A variable is a parameter\n+   in a scop if it does not vary during the execution of that scop.  */\n+\n+static void\n+find_scop_parameters (scop_p scop)\n+{\n+  poly_bb_p pbb;\n+  unsigned i;\n+  sese region = SCOP_REGION (scop);\n+  struct loop *loop;\n+  int nbp;\n+\n+  /* Find the parameters used in the loop bounds.  */\n+  FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n+    {\n+      tree nb_iters = number_of_latch_executions (loop);\n+\n+      if (!chrec_contains_symbols (nb_iters))\n+\tcontinue;\n+\n+      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n+      scan_tree_for_params (region, nb_iters);\n+    }\n+\n+  /* Find the parameters used in data accesses.  */\n+  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n+    find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n+\n+  nbp = sese_nb_params (region);\n+  scop_set_nb_params (scop, nbp);\n+  SESE_ADD_PARAMS (region) = false;\n+}\n+\n class sese_dom_walker : public dom_walker\n {\n public:\n@@ -1779,31 +1927,40 @@ build_scops (vec<scop_p> *scops)\n   sese_l s (0);\n   FOR_EACH_VEC_ELT (scops_l, i, s)\n     {\n-      sese sese_reg = new_sese (s.entry, s.exit);\n-      scop_p scop = new_scop (sese_reg);\n+      scop_p scop = new_scop (s.entry, s.exit);\n \n+      sb.build_scop_bbs (scop);\n       /* Do not optimize a scop containing only PBBs that do not belong\n \t to any loops.  */\n       if (sb.nb_pbbs_in_loops (scop) == 0)\n \t{\n-\t  free_sese (sese_reg);\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] no data references.\\n\");\n+\t  free_scop (scop);\n+\t  continue;\n+\t}\n+\n+      build_sese_loop_nests (scop->region);\n+      /* Record all conditions in REGION.  */\n+      sese_dom_walker (CDI_DOMINATORS, scop->region).walk\n+\t(cfun->cfg->x_entry_block_ptr);\n+\n+      find_scop_parameters (scop);\n+      graphite_dim_t max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n+\n+      if (scop_nb_params (scop) > max_dim)\n+\t{\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] too many parameters: \"\n+\t\t          << scop_nb_params (scop)\n+\t\t          << \" larger than --param graphite-max-nb-scop-params=\"\n+\t\t          << max_dim << \".\\n\");\n+\n \t  free_scop (scop);\n \t  continue;\n \t}\n \n       scops->safe_push (scop);\n     }\n \n-  scop_p scop;\n-  FOR_EACH_VEC_ELT (*scops, i, scop)\n-  {\n-    sb.build_scop_bbs (scop);\n-    sese region = SCOP_REGION (scop);\n-    build_sese_loop_nests (region);\n-    /* Record all conditions in REGION.  */\n-    sese_dom_walker (CDI_DOMINATORS, region).walk (cfun->cfg->x_entry_block_ptr);\n-  }\n-\n   DEBUG_PRINT (dp << \"number of SCoPs: \" << (scops ? scops->length () : 0););\n }\n "}, {"sha": "af9fa659db0696a2c1111822705f503643d55011", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 324, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -196,84 +196,6 @@ reduction_phi_p (sese region, gphi_iterator *psi)\n   return true;\n }\n \n-/* Store the GRAPHITE representation of BB.  */\n-\n-static gimple_poly_bb_p\n-new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs)\n-{\n-  gimple_poly_bb_p gbb;\n-\n-  gbb = XNEW (struct gimple_poly_bb);\n-  bb->aux = gbb;\n-  GBB_BB (gbb) = bb;\n-  GBB_DATA_REFS (gbb) = drs;\n-  GBB_CONDITIONS (gbb).create (0);\n-  GBB_CONDITION_CASES (gbb).create (0);\n-\n-  return gbb;\n-}\n-\n-static void\n-free_data_refs_aux (vec<data_reference_p> datarefs)\n-{\n-  unsigned int i;\n-  data_reference_p dr;\n-\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    if (dr->aux)\n-      {\n-\tbase_alias_pair_p bap = (base_alias_pair_p)(dr->aux);\n-\n-\tfree (bap->alias_set);\n-\n-\tfree (bap);\n-\tdr->aux = NULL;\n-      }\n-}\n-/* Frees GBB.  */\n-\n-static void\n-free_gimple_poly_bb (gimple_poly_bb_p gbb)\n-{\n-  free_data_refs_aux (GBB_DATA_REFS (gbb));\n-  free_data_refs (GBB_DATA_REFS (gbb));\n-\n-  GBB_CONDITIONS (gbb).release ();\n-  GBB_CONDITION_CASES (gbb).release ();\n-  GBB_BB (gbb)->aux = 0;\n-  XDELETE (gbb);\n-}\n-\n-/* Deletes all gimple bbs in SCOP.  */\n-\n-static void\n-remove_gbbs_in_scop (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    free_gimple_poly_bb (PBB_BLACK_BOX (pbb));\n-}\n-\n-/* Deletes all scops in SCOPS.  */\n-\n-void\n-free_scops (vec<scop_p> scops)\n-{\n-  int i;\n-  scop_p scop;\n-\n-  FOR_EACH_VEC_ELT (scops, i, scop)\n-    {\n-      remove_gbbs_in_scop (scop);\n-      free_sese (SCOP_REGION (scop));\n-      free_scop (scop);\n-    }\n-\n-  scops.release ();\n-}\n-\n /* Return an ISL identifier for the polyhedral basic block PBB.  */\n \n static isl_id *\n@@ -587,35 +509,6 @@ parameter_index_in_region_1 (tree name, sese region)\n   return -1;\n }\n \n-/* When the parameter NAME is in REGION, returns its index in\n-   SESE_PARAMS.  Otherwise this function inserts NAME in SESE_PARAMS\n-   and returns the index of NAME.  */\n-\n-static int\n-parameter_index_in_region (tree name, sese region)\n-{\n-  int i;\n-\n-  gcc_assert (TREE_CODE (name) == SSA_NAME);\n-\n-  /* Cannot constrain on anything else than INTEGER_TYPE parameters.  */\n-  if (TREE_CODE (TREE_TYPE (name)) != INTEGER_TYPE)\n-    return -1;\n-\n-  if (!invariant_in_sese_p_rec (name, region))\n-    return -1;\n-\n-  i = parameter_index_in_region_1 (name, region);\n-  if (i != -1)\n-    return i;\n-\n-  gcc_assert (SESE_ADD_PARAMS (region));\n-\n-  i = SESE_PARAMS (region).length ();\n-  SESE_PARAMS (region).safe_push (name);\n-  return i;\n-}\n-\n /* Extract an affine expression from the tree E in the scop S.  */\n \n static isl_pw_aff *\n@@ -687,124 +580,6 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n   return res;\n }\n \n-/* In the context of sese S, scan the expression E and translate it to\n-   a linear expression C.  When parsing a symbolic multiplication, K\n-   represents the constant multiplier of an expression containing\n-   parameters.  */\n-\n-static void\n-scan_tree_for_params (sese s, tree e)\n-{\n-  if (e == chrec_dont_know)\n-    return;\n-\n-  switch (TREE_CODE (e))\n-    {\n-    case POLYNOMIAL_CHREC:\n-      scan_tree_for_params (s, CHREC_LEFT (e));\n-      break;\n-\n-    case MULT_EXPR:\n-      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n-\tscan_tree_for_params (s, TREE_OPERAND (e, 0));\n-      else\n-\tscan_tree_for_params (s, TREE_OPERAND (e, 1));\n-      break;\n-\n-    case PLUS_EXPR:\n-    case POINTER_PLUS_EXPR:\n-    case MINUS_EXPR:\n-      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n-      scan_tree_for_params (s, TREE_OPERAND (e, 1));\n-      break;\n-\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n-    CASE_CONVERT:\n-    case NON_LVALUE_EXPR:\n-      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n-      break;\n-\n-    case SSA_NAME:\n-      parameter_index_in_region (e, s);\n-      break;\n-\n-    case INTEGER_CST:\n-    case ADDR_EXPR:\n-    case REAL_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-      break;\n-\n-   default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-}\n-\n-/* Find parameters with respect to REGION in BB. We are looking in memory\n-   access functions, conditions and loop bounds.  */\n-\n-static void\n-find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n-{\n-  int i;\n-  unsigned j;\n-  data_reference_p dr;\n-  gimple *stmt;\n-  loop_p loop = GBB_BB (gbb)->loop_father;\n-\n-  /* Find parameters in the access functions of data references.  */\n-  FOR_EACH_VEC_ELT (GBB_DATA_REFS (gbb), i, dr)\n-    for (j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n-      scan_tree_for_params (region, DR_ACCESS_FN (dr, j));\n-\n-  /* Find parameters in conditional statements.  */\n-  FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n-    {\n-      tree lhs = scalar_evolution_in_region (region, loop,\n-\t\t\t\t\t     gimple_cond_lhs (stmt));\n-      tree rhs = scalar_evolution_in_region (region, loop,\n-\t\t\t\t\t     gimple_cond_rhs (stmt));\n-\n-      scan_tree_for_params (region, lhs);\n-      scan_tree_for_params (region, rhs);\n-    }\n-}\n-\n-/* Record the parameters used in the SCOP.  A variable is a parameter\n-   in a scop if it does not vary during the execution of that scop.  */\n-\n-static void\n-find_scop_parameters (scop_p scop)\n-{\n-  poly_bb_p pbb;\n-  unsigned i;\n-  sese region = SCOP_REGION (scop);\n-  struct loop *loop;\n-  int nbp;\n-\n-  /* Find the parameters used in the loop bounds.  */\n-  FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n-    {\n-      tree nb_iters = number_of_latch_executions (loop);\n-\n-      if (!chrec_contains_symbols (nb_iters))\n-\tcontinue;\n-\n-      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n-      scan_tree_for_params (region, nb_iters);\n-    }\n-\n-  /* Find the parameters used in data accesses.  */\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n-\n-  nbp = sese_nb_params (region);\n-  scop_set_nb_params (scop, nbp);\n-  SESE_ADD_PARAMS (region) = false;\n-}\n-\n /* Assign dimension for each parameter in SCOP.  */\n \n static void\n@@ -1057,100 +832,6 @@ add_conditions_to_constraints (scop_p scop)\n     add_conditions_to_domain (pbb);\n }\n \n-/* Returns a COND_EXPR statement when BB has a single predecessor, the\n-   edge between BB and its predecessor is not a loop exit edge, and\n-   the last statement of the single predecessor is a COND_EXPR.  */\n-\n-static gcond *\n-single_pred_cond_non_loop_exit (basic_block bb)\n-{\n-  if (single_pred_p (bb))\n-    {\n-      edge e = single_pred_edge (bb);\n-      basic_block pred = e->src;\n-      gimple *stmt;\n-\n-      if (loop_depth (pred->loop_father) > loop_depth (bb->loop_father))\n-\treturn NULL;\n-\n-      stmt = last_stmt (pred);\n-\n-      if (stmt && gimple_code (stmt) == GIMPLE_COND)\n-\treturn as_a <gcond *> (stmt);\n-    }\n-\n-  return NULL;\n-}\n-\n-class sese_dom_walker : public dom_walker\n-{\n-public:\n-  sese_dom_walker (cdi_direction, sese);\n-\n-  virtual void before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-private:\n-  auto_vec<gimple *, 3> m_conditions, m_cases;\n-  sese m_region;\n-};\n-\n-sese_dom_walker::sese_dom_walker (cdi_direction direction, sese region)\n-  : dom_walker (direction), m_region (region)\n-{\n-}\n-\n-/* Call-back for dom_walk executed before visiting the dominated\n-   blocks.  */\n-\n-void\n-sese_dom_walker::before_dom_children (basic_block bb)\n-{\n-  gimple_poly_bb_p gbb;\n-  gcond *stmt;\n-\n-  if (!bb_in_sese_p (bb, m_region))\n-    return;\n-\n-  stmt = single_pred_cond_non_loop_exit (bb);\n-\n-  if (stmt)\n-    {\n-      edge e = single_pred_edge (bb);\n-\n-      m_conditions.safe_push (stmt);\n-\n-      if (e->flags & EDGE_TRUE_VALUE)\n-\tm_cases.safe_push (stmt);\n-      else\n-\tm_cases.safe_push (NULL);\n-    }\n-\n-  gbb = gbb_from_bb (bb);\n-\n-  if (gbb)\n-    {\n-      GBB_CONDITIONS (gbb) = m_conditions.copy ();\n-      GBB_CONDITION_CASES (gbb) = m_cases.copy ();\n-    }\n-}\n-\n-/* Call-back for dom_walk executed after visiting the dominated\n-   blocks.  */\n-\n-void\n-sese_dom_walker::after_dom_children (basic_block bb)\n-{\n-  if (!bb_in_sese_p (bb, m_region))\n-    return;\n-\n-  if (single_pred_cond_non_loop_exit (bb))\n-    {\n-      m_conditions.pop ();\n-      m_cases.pop ();\n-    }\n-}\n-\n /* Add constraints on the possible values of parameter P from the type\n    of P.  */\n \n@@ -2338,11 +2019,6 @@ rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n void\n build_poly_scop (scop_p scop)\n {\n-  find_scop_parameters (scop);\n-\n-  graphite_dim_t max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n-  if (scop_nb_params (scop) > max_dim)\n-    return;\n   set_scop_parameter_dim (scop);\n   build_scop_iteration_domain (scop);\n   build_scop_context (scop);"}, {"sha": "48f0d56acff418119600c68ec39ed833a12e5b80", "filename": "gcc/graphite-sese-to-poly.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -21,12 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n #define GCC_GRAPHITE_SESE_TO_POLY_H\n \n-typedef struct base_alias_pair\n-{\n-  int base_obj_set;\n-  int *alias_set;\n-} *base_alias_pair_p;\n-\n void build_poly_scop (scop_p);\n \n #endif"}, {"sha": "1188c243b1c5333e90b273ccd2c48d1fe0b00b48", "filename": "gcc/graphite.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -278,6 +278,20 @@ graphite_finalize (bool need_cfg_cleanup_p)\n     print_loops (dump_file, 3);\n }\n \n+/* Deletes all scops in SCOPS.  */\n+\n+static void\n+free_scops (vec<scop_p> scops)\n+{\n+  int i;\n+  scop_p scop;\n+\n+  FOR_EACH_VEC_ELT (scops, i, scop)\n+    free_scop (scop);\n+\n+  scops.release ();\n+}\n+\n isl_ctx *the_isl_ctx;\n \n /* Perform a set of linear transforms on the loops of the current"}, {"sha": "aa748ee83054def4e383e4dbc54502a014a08d22", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -1,3 +1,8 @@\n+2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+        * gcc.dg/graphite/scop-sor.c: Xfail.\n+\n 2015-10-05  Martin Jambor  <mjambor@suse.cz>\n \t    Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "aec8b9cbf2974f7bf82d149cb08930e1f0804c4b", "filename": "gcc/testsuite/gcc.dg/graphite/scop-sor.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-sor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ccab5d9c97337980d95a78889c38f6b70fc544/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-sor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-sor.c?ref=87ccab5d9c97337980d95a78889c38f6b70fc544", "patch": "@@ -14,4 +14,5 @@ void sor(int N1, int N2){\n #pragma endscop\n }\n \n-/* { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\" } } */\n+/* This requires more than 3 parameters.  */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 0\" 1 \"graphite\" } } */"}]}