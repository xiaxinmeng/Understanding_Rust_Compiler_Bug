{"sha": "9771799c29d553ad28453dd5bf2e72d6be593531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc3MTc5OWMyOWQ1NTNhZDI4NDUzZGQ1YmYyZTcyZDZiZTU5MzUzMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-08-01T02:26:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-08-01T02:26:21Z"}, "message": "call.c (reference_binding): Rename lvalue_p to is_lvalue.\n\n\t* call.c (reference_binding): Rename lvalue_p to is_lvalue.\n\tDo direct binding of \"rvalues\" in memory to rvalue references.\n\t* tree.c (lvalue_p_1): Can't be both non-addressable lvalue and\n\t\"rvalue\" in memory.\n\t* typeck.c (build_static_cast_1): Do direct binding of memory\n\t\"rvalues\" to rvalue references.\n\t* cvt.c (cp_fold_convert): New.\n\t* cp-tree.h: Declare it.\n\nFrom-SVN: r150325", "tree": {"sha": "af6722d746b28559306995a7a4806f6f9e2ea51c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af6722d746b28559306995a7a4806f6f9e2ea51c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9771799c29d553ad28453dd5bf2e72d6be593531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9771799c29d553ad28453dd5bf2e72d6be593531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9771799c29d553ad28453dd5bf2e72d6be593531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9771799c29d553ad28453dd5bf2e72d6be593531/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3e1e89e50a64005a622759d5b2c4a8d1a77393f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e1e89e50a64005a622759d5b2c4a8d1a77393f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e1e89e50a64005a622759d5b2c4a8d1a77393f"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "9a9de744a89b82815505c8bf0f1c029a66d6a5d0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -1,3 +1,14 @@\n+2009-07-31  Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (reference_binding): Rename lvalue_p to is_lvalue.\n+\tDo direct binding of \"rvalues\" in memory to rvalue references.\n+\t* tree.c (lvalue_p_1): Can't be both non-addressable lvalue and\n+\t\"rvalue\" in memory.\n+\t* typeck.c (build_static_cast_1): Do direct binding of memory\n+\t\"rvalues\" to rvalue references.\n+\t* cvt.c (cp_fold_convert): New.\n+\t* cp-tree.h: Declare it.\n+\n 2009-07-31  Jason Merrill  <jason@redhat.com>\n \n \t* typeck.c (build_address): Do fold away ADDR_EXPR of INDIRECT_REF."}, {"sha": "144d07ed9614c5c7eb63013586124e0aa9859af7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -1205,7 +1205,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   tree tfrom;\n   bool related_p;\n   bool compatible_p;\n-  cp_lvalue_kind lvalue_p = clk_none;\n+  cp_lvalue_kind is_lvalue = clk_none;\n \n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n@@ -1218,7 +1218,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     {\n       /* Anything with reference type is an lvalue.  */\n-      lvalue_p = clk_ordinary;\n+      is_lvalue = clk_ordinary;\n       from = TREE_TYPE (from);\n     }\n \n@@ -1235,11 +1235,11 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \t}\n     }\n \n-  if (lvalue_p == clk_none && expr)\n-    lvalue_p = real_lvalue_p (expr);\n+  if (is_lvalue == clk_none && expr)\n+    is_lvalue = real_lvalue_p (expr);\n \n   tfrom = from;\n-  if ((lvalue_p & clk_bitfield) != 0)\n+  if ((is_lvalue & clk_bitfield) != 0)\n     tfrom = unlowered_expr_type (expr);\n \n   /* Figure out whether or not the types are reference-related and\n@@ -1256,12 +1256,15 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   /* Directly bind reference when target expression's type is compatible with\n      the reference and expression is an lvalue. In DR391, the wording in\n      [8.5.3/5 dcl.init.ref] is changed to also require direct bindings for\n-     const and rvalue references to rvalues of compatible class type. */\n+     const and rvalue references to rvalues of compatible class type.\n+     We should also do direct bindings for non-class \"rvalues\" derived from\n+     rvalue references.  */\n   if (compatible_p\n-      && (lvalue_p\n-\t  || (!(flags & LOOKUP_NO_TEMP_BIND)\n-\t      && (CP_TYPE_CONST_NON_VOLATILE_P(to) || TYPE_REF_IS_RVALUE (rto))\n-\t      && CLASS_TYPE_P (from))))\n+      && (is_lvalue\n+\t  || (((CP_TYPE_CONST_NON_VOLATILE_P (to)\n+\t\t&& !(flags & LOOKUP_NO_TEMP_BIND))\n+\t       || TYPE_REF_IS_RVALUE (rto))\n+\t      && (CLASS_TYPE_P (from) || (expr && lvalue_p (expr))))))\n     {\n       /* [dcl.init.ref]\n \n@@ -1288,10 +1291,10 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \tconv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n       else\n \tconv->rvaluedness_matches_p \n-          = (TYPE_REF_IS_RVALUE (rto) == !lvalue_p);\n+          = (TYPE_REF_IS_RVALUE (rto) == !is_lvalue);\n \n-      if ((lvalue_p & clk_bitfield) != 0\n-\t  || ((lvalue_p & clk_packed) != 0 && !TYPE_PACKED (to)))\n+      if ((is_lvalue & clk_bitfield) != 0\n+\t  || ((is_lvalue & clk_packed) != 0 && !TYPE_PACKED (to)))\n \t/* For the purposes of overload resolution, we ignore the fact\n \t   this expression is a bitfield or packed field. (In particular,\n \t   [over.ics.ref] says specifically that a function with a"}, {"sha": "07e89d354df7fe77bb70bc576117b82fa14cecaf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -4339,6 +4339,7 @@ extern tree force_rvalue\t\t\t(tree);\n extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n extern tree cp_convert\t\t\t\t(tree, tree);\n extern tree cp_convert_and_check                (tree, tree);\n+extern tree cp_fold_convert\t\t\t(tree, tree);\n extern tree convert_to_void\t(tree, const char */*implicit context*/,\n                                  tsubst_flags_t);\n extern tree convert_force\t\t\t(tree, tree, int);"}, {"sha": "cdc6a10a825e9fcff6d1b967f8dd2852af997abf", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -539,7 +539,16 @@ force_rvalue (tree expr)\n \n   return expr;\n }\n+\n \f\n+/* Fold away simple conversions, but make sure the result is an rvalue.  */\n+\n+tree\n+cp_fold_convert (tree type, tree expr)\n+{\n+  return rvalue (fold_convert (type, expr));\n+}\n+\n /* C++ conversions, preference to static cast conversions.  */\n \n tree"}, {"sha": "9e194fca44402faa0541a8909ea47aedb35c01ba", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -214,10 +214,14 @@ lvalue_p_1 (const_tree ref)\n   /* Otherwise, it's an lvalue, and it has all the odd properties\n      contributed by either operand.  */\n   op1_lvalue_kind = op1_lvalue_kind | op2_lvalue_kind;\n-  /* It's not an ordinary lvalue if it involves either a bit-field or\n-     a class rvalue.  */\n+  /* It's not an ordinary lvalue if it involves any other kind.  */\n   if ((op1_lvalue_kind & ~clk_ordinary) != clk_none)\n     op1_lvalue_kind &= ~clk_ordinary;\n+  /* It can't be both a pseudo-lvalue and a non-addressable lvalue.\n+     A COND_EXPR of those should be wrapped in a TARGET_EXPR.  */\n+  if ((op1_lvalue_kind & (clk_rvalueref|clk_class))\n+      && (op1_lvalue_kind & (clk_bitfield|clk_packed)))\n+    op1_lvalue_kind = clk_none;\n   return op1_lvalue_kind;\n }\n "}, {"sha": "a956fdcc97faa956e414635036ff8a132a3b6f1f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771799c29d553ad28453dd5bf2e72d6be593531/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9771799c29d553ad28453dd5bf2e72d6be593531", "patch": "@@ -5284,7 +5284,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   if (TREE_CODE (type) == REFERENCE_TYPE\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (intype)\n-      && real_lvalue_p (expr)\n+      && (TYPE_REF_IS_RVALUE (type) || real_lvalue_p (expr))\n       && DERIVED_FROM_P (intype, TREE_TYPE (type))\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT\n@@ -5310,7 +5310,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t\t\t      base, /*nonnull=*/false);\n       /* Convert the pointer to a reference -- but then remember that\n \t there are no expressions with reference type in C++.  */\n-      return convert_from_reference (build_nop (type, expr));\n+      return convert_from_reference (cp_fold_convert (type, expr));\n     }\n \n   orig = expr;"}]}