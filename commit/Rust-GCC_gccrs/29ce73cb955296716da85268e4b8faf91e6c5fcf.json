{"sha": "29ce73cb955296716da85268e4b8faf91e6c5fcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjljZTczY2I5NTUyOTY3MTZkYTg1MjY4ZTRiOGZhZjkxZTZjNWZjZg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2010-12-17T21:23:36Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2010-12-17T21:23:36Z"}, "message": "re PR c/20385 (Lame parse error message for undefined type)\n\ngcc:\n2010-12-17  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR c/20385\n\t* function.c (used_types_insert): Handle ERROR_MARK.\n\t* c-decl.c (grokdeclarator): Handle ERROR_MARK.\n\t(declspecs_add_type): Leave error_mark_node in specs->type.\n\t(finish_declspecs): Change it to integer_type_node here.\n\t* c-parser.c (c_parser_peek_2nd_token): Move earlier.\n\t(enum c_lookahead_kind): New.\n\t(c_parser_next_token_starts_typename): New name of\n\tc_parser_next_tokens_start_typename.  Accept lookahead enum\n\tand handle it here instead of...\n\t(c_parser_next_tokens_start_declaration): ... here.  Call it.\n\t(c_parser_declspecs): Accept another argument.  Do not exit\n\ton C_ID_ID if it is guessed to be an unknown typename.\n\t(c_parser_parms_declarator): Use 2nd token to distinguish a K&R\n\tdeclaration from an ANSI declaration starting with an unknown\n\ttypename.\n\t(c_parser_struct_declaration, c_parser_objc_type_name,\n\tc_parser_typeof_specifier, c_parser_declarator,\n\tc_parser_direct_declarator_inner): Adjust calls.\n\t(c_parser_parameter_declaration): Likewise.\n\t(c_parser_type_name): Pass back an error_mark_node to the caller.\n\t(c_parser_postfix_expression): Do error recovery when \n\tc_parser_type_name returns NULL.\n\ntestsuite:\n2010-12-17  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR c/20385\n\t* objc.dg/tls/init-2.m: Adjust.\n\t* gcc.dg/noncompile/920923-1.c: Adjust.\n\t* gcc.dg/noncompile/pr44517.c: Adjust.\n\t* gcc.dg/declspec-18.c: New test.\n\nFrom-SVN: r167999", "tree": {"sha": "c4cfe728320526019a5d30a613a686238e9911e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4cfe728320526019a5d30a613a686238e9911e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ce73cb955296716da85268e4b8faf91e6c5fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ce73cb955296716da85268e4b8faf91e6c5fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ce73cb955296716da85268e4b8faf91e6c5fcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ce73cb955296716da85268e4b8faf91e6c5fcf/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f2605707f4089459163f7d767f0ba5e1c9361e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2605707f4089459163f7d767f0ba5e1c9361e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2605707f4089459163f7d767f0ba5e1c9361e6"}], "stats": {"total": 357, "additions": 268, "deletions": 89}, "files": [{"sha": "944f8069d72423f4271b44231e0b09edcd37ffc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -1,3 +1,29 @@\n+2010-12-17  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c/20385\n+\t* function.c (used_types_insert): Handle ERROR_MARK.\n+\t* c-decl.c (grokdeclarator): Handle ERROR_MARK.\n+\t(declspecs_add_type): Leave error_mark_node in specs->type.\n+\t(finish_declspecs): Change it to integer_type_node here.\n+\t* c-parser.c (c_parser_peek_2nd_token): Move earlier.\n+\t(enum c_lookahead_kind): New.\n+\t(c_parser_next_token_starts_typename): New name of\n+\tc_parser_next_tokens_start_typename.  Accept lookahead enum\n+\tand handle it here instead of...\n+\t(c_parser_next_tokens_start_declaration): ... here.  Call it.\n+\t(c_parser_declspecs): Accept another argument.  Do not exit\n+\ton C_ID_ID if it is guessed to be an unknown typename.\n+\t(c_parser_parms_declarator): Use 2nd token to distinguish a K&R\n+\tdeclaration from an ANSI declaration starting with an unknown\n+\ttypename.\n+\t(c_parser_struct_declaration, c_parser_objc_type_name,\n+\tc_parser_typeof_specifier, c_parser_declarator,\n+\tc_parser_direct_declarator_inner): Adjust calls.\n+\t(c_parser_parameter_declaration): Likewise.\n+\t(c_parser_type_name): Pass back an error_mark_node to the caller.\n+\t(c_parser_postfix_expression): Do error recovery when \n+\tc_parser_type_name returns NULL.\n+\n 2010-12-17  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/i386/netware.h (ASM_SPEC, SIZE_TYPE, PTRDIFF_TYPE):"}, {"sha": "f9672a0975ff2930bb997e64a159bec2bfe086a7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -4865,6 +4865,8 @@ grokdeclarator (const struct c_declarator *declarator,\n   tree expr_dummy;\n   bool expr_const_operands_dummy;\n \n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n   if (expr == NULL)\n     expr = &expr_dummy;\n   if (expr_const_operands == NULL)\n@@ -9315,9 +9317,9 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n       else\n \tspecs->type = TREE_TYPE (t);\n     }\n-  else if (TREE_CODE (type) != ERROR_MARK)\n+  else\n     {\n-      if (spec.kind == ctsk_typeof)\n+      if (TREE_CODE (type) != ERROR_MARK && spec.kind == ctsk_typeof)\n \t{\n \t  specs->typedef_p = true;\n \t  if (spec.expr)\n@@ -9332,11 +9334,6 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t}\n       specs->type = type;\n     }\n-  else\n-    {\n-      /* Set a dummy type here to avoid warning about implicit 'int'.  */\n-      specs->type = integer_type_node;\n-    }\n \n   return specs;\n }\n@@ -9452,6 +9449,10 @@ finish_declspecs (struct c_declspecs *specs)\n       gcc_assert (!specs->long_p && !specs->long_long_p && !specs->short_p\n \t\t  && !specs->signed_p && !specs->unsigned_p\n \t\t  && !specs->complex_p);\n+\n+      /* Set a dummy type.  */\n+      if (TREE_CODE (specs->type) == ERROR_MARK)\n+        specs->type = integer_type_node;\n       return specs;\n     }\n "}, {"sha": "261ea3da56e94d72b0ebd8f9fb6da9fc1d5ab2b5", "filename": "gcc/c-parser.c", "status": "modified", "additions": 119, "deletions": 77, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -433,6 +433,22 @@ c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n   return c_parser_peek_token (parser)->keyword == keyword;\n }\n \n+/* Return a pointer to the next-but-one token from PARSER, reading it\n+   in if necessary.  The next token is already read in.  */\n+\n+static c_token *\n+c_parser_peek_2nd_token (c_parser *parser)\n+{\n+  if (parser->tokens_avail >= 2)\n+    return &parser->tokens[1];\n+  gcc_assert (parser->tokens_avail == 1);\n+  gcc_assert (parser->tokens[0].type != CPP_EOF);\n+  gcc_assert (parser->tokens[0].type != CPP_PRAGMA_EOL);\n+  c_lex_one_token (parser, &parser->tokens[1]);\n+  parser->tokens_avail = 2;\n+  return &parser->tokens[1];\n+}\n+\n /* Return true if TOKEN can start a type name,\n    false otherwise.  */\n static bool\n@@ -497,13 +513,46 @@ c_token_starts_typename (c_token *token)\n     }\n }\n \n+enum c_lookahead_kind {\n+  /* Always treat unknown identifiers as typenames.  */\n+  cla_prefer_type,\n+\n+  /* Could be parsing a nonabstract declarator.  Only treat an identifier\n+     as a typename if followed by another identifier or a star.  */\n+  cla_nonabstract_decl,\n+\n+  /* Never treat identifiers as typenames.  */\n+  cla_prefer_id\n+};\n+\n /* Return true if the next token from PARSER can start a type name,\n-   false otherwise.  */\n+   false otherwise.  LA specifies how to do lookahead in order to\n+   detect unknown type names.  If unsure, pick CLA_PREFER_ID.  */\n+\n static inline bool\n-c_parser_next_token_starts_typename (c_parser *parser)\n+c_parser_next_tokens_start_typename (c_parser *parser, enum c_lookahead_kind la)\n {\n   c_token *token = c_parser_peek_token (parser);\n-  return c_token_starts_typename (token);\n+  if (c_token_starts_typename (token))\n+    return true;\n+\n+  /* Try a bit harder to detect an unknown typename.  */\n+  if (la != cla_prefer_id\n+      && token->type == CPP_NAME\n+      && token->id_kind == C_ID_ID\n+\n+      /* Do not try too hard when we could have \"object in array\".  */\n+      && !parser->objc_could_be_foreach_context\n+\n+      && (la == cla_prefer_type\n+\t  || c_parser_peek_2nd_token (parser)->type == CPP_NAME\n+\t  || c_parser_peek_2nd_token (parser)->type == CPP_MULT)\n+\n+      /* Only unknown identifiers.  */\n+      && !lookup_name (token->value))\n+    return true;\n+\n+  return false;\n }\n \n /* Return true if TOKEN is a type qualifier, false otherwise.  */\n@@ -631,8 +680,6 @@ c_token_starts_declaration (c_token *token)\n     return false;\n }\n \n-static c_token *c_parser_peek_2nd_token (c_parser *parser);\n-\n /* Return true if the next token from PARSER can start declaration\n    specifiers, false otherwise.  */\n static inline bool\n@@ -677,36 +724,12 @@ c_parser_next_tokens_start_declaration (c_parser *parser)\n   if (c_token_starts_declaration (token))\n     return true;\n \n-  /* Try a bit harder to detect an unknown typename.  */\n-  if (token->type == CPP_NAME\n-      && token->id_kind == C_ID_ID\n-      && (c_parser_peek_2nd_token (parser)->type == CPP_NAME\n-          || c_parser_peek_2nd_token (parser)->type == CPP_MULT)\n-      && !lookup_name (token->value)\n-\n-      /* Do not try too hard when we could have \"object in array\".  */\n-      && !parser->objc_could_be_foreach_context)\n+  if (c_parser_next_tokens_start_typename (parser, cla_nonabstract_decl))\n     return true;\n \n   return false;\n }\n \n-/* Return a pointer to the next-but-one token from PARSER, reading it\n-   in if necessary.  The next token is already read in.  */\n-\n-static c_token *\n-c_parser_peek_2nd_token (c_parser *parser)\n-{\n-  if (parser->tokens_avail >= 2)\n-    return &parser->tokens[1];\n-  gcc_assert (parser->tokens_avail == 1);\n-  gcc_assert (parser->tokens[0].type != CPP_EOF);\n-  gcc_assert (parser->tokens[0].type != CPP_PRAGMA_EOL);\n-  c_lex_one_token (parser, &parser->tokens[1]);\n-  parser->tokens_avail = 2;\n-  return &parser->tokens[1];\n-}\n-\n /* Consume the next token from PARSER.  */\n \n static void\n@@ -1076,7 +1099,7 @@ static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n-\t\t\t\tbool);\n+\t\t\t\tbool, enum c_lookahead_kind);\n static struct c_typespec c_parser_enum_specifier (c_parser *);\n static struct c_typespec c_parser_struct_or_union_specifier (c_parser *);\n static tree c_parser_struct_declaration (c_parser *);\n@@ -1425,7 +1448,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       fndef_ok = !nested;\n     }\n \n-  c_parser_declspecs (parser, specs, true, true, start_attr_ok);\n+  c_parser_declspecs (parser, specs, true, true, start_attr_ok, cla_nonabstract_decl);\n   if (parser->error)\n     {\n       c_parser_skip_to_end_of_block_or_statement (parser);\n@@ -1922,34 +1945,31 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n \n static void\n c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n-\t\t    bool scspec_ok, bool typespec_ok, bool start_attr_ok)\n+\t\t    bool scspec_ok, bool typespec_ok, bool start_attr_ok,\n+\t\t    enum c_lookahead_kind la)\n {\n   bool attrs_ok = start_attr_ok;\n   bool seen_type = specs->typespec_kind != ctsk_none;\n-  while ((c_parser_next_token_is (parser, CPP_NAME)\n-\t  && c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+\n+  if (!typespec_ok)\n+    gcc_assert (la == cla_prefer_id);\n+\n+  while (c_parser_next_token_is (parser, CPP_NAME)\n \t || c_parser_next_token_is (parser, CPP_KEYWORD)\n \t || (c_dialect_objc () && c_parser_next_token_is (parser, CPP_LESS)))\n     {\n       struct c_typespec t;\n       tree attrs;\n       location_t loc = c_parser_peek_token (parser)->location;\n \n-      if (!c_parser_next_token_is_qualifier (parser))\n-        {\n-\t  /* Exit for TYPENAMEs after any type because they can appear as a\n-\t     field name.  */\n-          if (seen_type && c_parser_next_token_is (parser, CPP_NAME))\n-            break;\n-\n-          /* If we cannot accept a type, and the next token must start one,\n-\t     exit.  Do the same if we already have seen a tagged definition,\n-\t     since it would be an error anyway and likely the user has simply\n-\t     forgotten a semicolon.  */\n-          if ((!typespec_ok || specs->typespec_kind == ctsk_tagdef)\n-\t      && c_parser_next_token_starts_typename (parser))\n-            break;\n-        }\n+      /* If we cannot accept a type, exit if the next token must start\n+\t one.  Also, if we already have seen a tagged definition,\n+\t a typename would be an error anyway and likely the user\n+\t has simply forgotten a semicolon, so we exit.  */\n+      if ((!typespec_ok || specs->typespec_kind == ctsk_tagdef)\n+\t  && c_parser_next_tokens_start_typename (parser, la)\n+\t  && !c_parser_next_token_is_qualifier (parser))\n+\tbreak;\n \n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n@@ -1966,20 +1986,34 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      continue;\n \t    }\n \n-\t  /* Now at a C_ID_TYPENAME or C_ID_CLASSNAME.  */\n+\t  gcc_assert (!c_parser_next_token_is_qualifier (parser));\n+\n+\t  /* If we cannot accept a type, and the next token must start one,\n+\t     exit.  Do the same if we already have seen a tagged definition,\n+\t     since it would be an error anyway and likely the user has simply\n+\t     forgotten a semicolon.  */\n+\t  if (seen_type || !c_parser_next_tokens_start_typename (parser, la))\n+\t    break;\n+\n+\t  /* Now at an unknown typename (C_ID_ID), a C_ID_TYPENAME or\n+\t     a C_ID_CLASSNAME.  */\n \t  c_parser_consume_token (parser);\n \t  seen_type = true;\n \t  attrs_ok = true;\n-\t  if (kind == C_ID_TYPENAME\n-\t      && (!c_dialect_objc ()\n-\t\t  || c_parser_next_token_is_not (parser, CPP_LESS)))\n+\t  if (kind == C_ID_ID)\n+\t    {\n+\t      error (\"unknown type name %qE\", value);\n+\t      t.kind = ctsk_typedef;\n+\t      t.spec = error_mark_node;\n+\t    }\n+\t  else if (kind == C_ID_TYPENAME\n+\t           && (!c_dialect_objc ()\n+\t               || c_parser_next_token_is_not (parser, CPP_LESS)))\n \t    {\n \t      t.kind = ctsk_typedef;\n \t      /* For a typedef name, record the meaning, not the name.\n \t\t In case of 'foo foo, bar;'.  */\n \t      t.spec = lookup_name (value);\n-\t      t.expr = NULL_TREE;\n-\t      t.expr_const_operands = true;\n \t    }\n \t  else\n \t    {\n@@ -1989,9 +2023,9 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      if (c_parser_next_token_is (parser, CPP_LESS))\n \t\tproto = c_parser_objc_protocol_refs (parser);\n \t      t.spec = objc_get_protocol_qualified_type (value, proto);\n-\t      t.expr = NULL_TREE;\n-\t      t.expr_const_operands = true;\n \t    }\n+\t  t.expr = NULL_TREE;\n+\t  t.expr_const_operands = true;\n \t  declspecs_add_type (loc, specs, t);\n \t  continue;\n \t}\n@@ -2498,7 +2532,7 @@ c_parser_struct_declaration (c_parser *parser)\n     }\n   specs = build_null_declspecs ();\n   decl_loc = c_parser_peek_token (parser)->location;\n-  c_parser_declspecs (parser, specs, false, true, true);\n+  c_parser_declspecs (parser, specs, false, true, true, cla_nonabstract_decl);\n   if (parser->error)\n     return NULL_TREE;\n   if (!specs->declspecs_seen_p)\n@@ -2644,7 +2678,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       in_typeof--;\n       return ret;\n     }\n-  if (c_parser_next_token_starts_typename (parser))\n+  if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))\n     {\n       struct c_type_name *type = c_parser_type_name (parser);\n       c_inhibit_evaluation_warnings--;\n@@ -2765,7 +2799,7 @@ c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       struct c_declspecs *quals_attrs = build_null_declspecs ();\n       struct c_declarator *inner;\n       c_parser_consume_token (parser);\n-      c_parser_declspecs (parser, quals_attrs, false, false, true);\n+      c_parser_declspecs (parser, quals_attrs, false, false, true, cla_prefer_id);\n       inner = c_parser_declarator (parser, type_seen_p, kind, seen_id);\n       if (inner == NULL)\n \treturn NULL;\n@@ -2917,12 +2951,12 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       bool star_seen;\n       tree dimen;\n       c_parser_consume_token (parser);\n-      c_parser_declspecs (parser, quals_attrs, false, false, true);\n+      c_parser_declspecs (parser, quals_attrs, false, false, true, cla_prefer_id);\n       static_seen = c_parser_next_token_is_keyword (parser, RID_STATIC);\n       if (static_seen)\n \tc_parser_consume_token (parser);\n       if (static_seen && !quals_attrs->declspecs_seen_p)\n-\tc_parser_declspecs (parser, quals_attrs, false, false, true);\n+\tc_parser_declspecs (parser, quals_attrs, false, false, true, cla_prefer_id);\n       if (!quals_attrs->declspecs_seen_p)\n \tquals_attrs = NULL;\n       /* If \"static\" is present, there must be an array dimension.\n@@ -3010,7 +3044,13 @@ c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs)\n   if (id_list_ok\n       && !attrs\n       && c_parser_next_token_is (parser, CPP_NAME)\n-      && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+      && c_parser_peek_token (parser)->id_kind == C_ID_ID\n+      \n+      /* Look ahead to detect typos in type names.  */\n+      && c_parser_peek_2nd_token (parser)->type != CPP_NAME\n+      && c_parser_peek_2nd_token (parser)->type != CPP_MULT\n+      && c_parser_peek_2nd_token (parser)->type != CPP_OPEN_PAREN\n+      && c_parser_peek_2nd_token (parser)->type != CPP_OPEN_SQUARE)\n     {\n       tree list = NULL_TREE, *nextp = &list;\n       while (c_parser_next_token_is (parser, CPP_NAME)\n@@ -3173,9 +3213,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       if (parser->error)\n \treturn NULL;\n       c_parser_set_source_position_from_token (token);\n-      if (token->type == CPP_NAME\n-\t  && c_parser_peek_2nd_token (parser)->type != CPP_COMMA\n-\t  && c_parser_peek_2nd_token (parser)->type != CPP_CLOSE_PAREN)\n+      if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))\n \t{\n \t  error (\"unknown type name %qE\", token->value);\n \t  parser->error = true;\n@@ -3194,7 +3232,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       declspecs_add_attrs (specs, attrs);\n       attrs = NULL_TREE;\n     }\n-  c_parser_declspecs (parser, specs, true, true, true);\n+  c_parser_declspecs (parser, specs, true, true, true, cla_nonabstract_decl);\n   finish_declspecs (specs);\n   pending_xref_error ();\n   prefix_attrs = specs->attrs;\n@@ -3484,14 +3522,17 @@ c_parser_type_name (c_parser *parser)\n   struct c_declarator *declarator;\n   struct c_type_name *ret;\n   bool dummy = false;\n-  c_parser_declspecs (parser, specs, false, true, true);\n+  c_parser_declspecs (parser, specs, false, true, true, cla_prefer_type);\n   if (!specs->declspecs_seen_p)\n     {\n       c_parser_error (parser, \"expected specifier-qualifier-list\");\n       return NULL;\n     }\n-  pending_xref_error ();\n-  finish_declspecs (specs);\n+  if (specs->type != error_mark_node)\n+    {\n+      pending_xref_error ();\n+      finish_declspecs (specs);\n+    }\n   declarator = c_parser_declarator (parser,\n \t\t\t\t    specs->typespec_kind != ctsk_none,\n \t\t\t\t    C_DTR_ABSTRACT, &dummy);\n@@ -5619,7 +5660,8 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n   /* If the expression begins with a parenthesized type name, it may\n      be either a cast or a compound literal; we need to see whether\n      the next character is '{' to tell the difference.  If not, it is\n-     an unary expression.  */\n+     an unary expression.  Full detection of unknown typenames here\n+     would require a 3-token lookahead.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n       && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n     {\n@@ -6181,16 +6223,16 @@ c_parser_postfix_expression (c_parser *parser)\n \t    }\n \t  t1 = c_parser_type_name (parser);\n \t  if (t1 == NULL)\n-\t    {\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n+\t    parser->error = true;\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+            gcc_assert (parser->error);\n+\t  if (parser->error)\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n \t      break;\n \t    }\n+\n \t  {\n \t    tree type = groktypename (t1, NULL, NULL);\n \t    tree offsetof_ref;\n@@ -7436,7 +7478,7 @@ c_parser_objc_type_name (c_parser *parser)\n       else\n \tbreak;\n     }\n-  if (c_parser_next_token_starts_typename (parser))\n+  if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))\n     type_name = c_parser_type_name (parser);\n   if (type_name)\n     type = groktypename (type_name, NULL, NULL);"}, {"sha": "7fa3b0c0aac6970265e09f20807394b797aaacc7", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -5712,6 +5712,8 @@ used_types_insert (tree t)\n       break;\n     else\n       t = TREE_TYPE (t);\n+  if (TREE_CODE (t) == ERROR_MARK)\n+    return;\n   if (TYPE_NAME (t) == NULL_TREE\n       || TYPE_NAME (t) == TYPE_NAME (TYPE_MAIN_VARIANT (t)))\n     t = TYPE_MAIN_VARIANT (t);"}, {"sha": "7db98fc0a440fbef6a4e075f10b194a72d7e3ef8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -1,3 +1,11 @@\n+2010-12-17  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c/20385\n+\t* objc.dg/tls/init-2.m: Adjust.\n+\t* gcc.dg/noncompile/920923-1.c: Adjust.\n+\t* gcc.dg/noncompile/pr44517.c: Adjust.\n+\t* gcc.dg/declspec-18.c: New test.\n+\n 2010-12-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* gcc.dg/titype-1.c: Enable TImode on __SPU__."}, {"sha": "d29ff13732cd9c4382cca888d237de469c901273", "filename": "gcc/testsuite/gcc.dg/declspec-18.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-18.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89\" } */\n+\n+static t1 *a;           /* { dg-error \"unknown type name 't1'\" } */\n+\n+int z;                  /* { dg-message \"previous declaration of 'z'\" } */\n+typedef t2 *z;          /* { dg-error \"unknown type name 't2'\" } */\n+/* { dg-error \"'z' redeclared \" \"\" { target *-*-* } 7 } */\n+\n+extern t3 p1(void);     /* { dg-error \"unknown type name 't3'\" } */\n+int p2(const t4 x);     /* { dg-error \"unknown type name 't4'\" } */\n+int p3(const t1 x);     /* { dg-error \"unknown type name 't1'\" } */ /* dup??? */\n+int p4(t5 (*x)(void));  /* { dg-error \"unknown type name 't5'\" } */\n+int p5(t6 *);           /* { dg-error \"unknown type name 't6'\" } */\n+int p6(t7 x);           /* { dg-error \"unknown type name 't7'\" } */\n+int p7(t8[]);           /* { dg-error \"unknown type name 't8'\" } */\n+int p8(int, t9);        /* { dg-error \"unknown type name 't9'\" } */\n+\n+struct s {\n+  const t1 a;           /* { dg-error \"unknown type name 't1'\" } */ /* dup??? */\n+  const t10 b;          /* { dg-error \"unknown type name 't10'\" } */\n+  int b;                /* { dg-error \"duplicate member\" } */\n+};\n+\n+typeof (z) c1;\n+typeof (x1) c2;         /* { dg-error \"undeclared\" } */\n+typeof (const t11) c3;  /* { dg-error \"unknown type name 't11'\" } */\n+typeof (t12 *) c3;      /* { dg-error \"unknown type name 't12'\" \"\" { xfail *-*-* } } */\n+/* { dg-bogus \"unknown type name 'x1'\" \"\" { target *-*-* } 26 } */\n+/* { dg-bogus \"undeclared\" \"\" { xfail *-*-* } 28 } */\n+/* { dg-bogus \"expected expression before\" \"\" { xfail *-*-* } 28 } */\n+\n+int recover1;\n+\n+int s0 = sizeof (z);\n+int s1 = sizeof (x2);          /* { dg-error \"undeclared\" } */\n+int s2 = sizeof (const t13);   /* { dg-error \"unknown type name 't13'\" } */\n+int s3 = sizeof (t14 *);       /* { dg-error \"unknown type name 't14'\" \"\" { xfail *-*-* } } */\n+\n+int recover2;\n+\n+/* { dg-bogus \"unknown type name 'x2'\" \"\" { target *-*-* } 36 } */\n+/* { dg-bogus \"undeclared\" \"\" { xfail *-*-* } 38 } */\n+/* { dg-bogus \"expected expression before\" \"\" { xfail *-*-* } 38 } */\n+\n+int a0 = __alignof__ (z);\n+int a1 = __alignof__ (x3);          /* { dg-error \"undeclared\" } */\n+int a2 = __alignof__ (const t15);   /* { dg-error \"unknown type name 't15'\" } */\n+int a3 = __alignof__ (t16 *);       /* { dg-error \"unknown type name 't16'\" \"\" { xfail *-*-* } } */\n+\n+int recover3;\n+\n+/* { dg-bogus \"unknown type name 'x3'\" \"\" { target *-*-* } 47 } */\n+/* { dg-bogus \"undeclared\" \"\" { xfail *-*-* } 49 } */\n+/* { dg-bogus \"expected expression before\" \"\" { xfail *-*-* } 49 } */\n+\n+\n+/* Cannot detect (undefd_type *) or (undefd_type (*) because it would\n+   require 3 tokens of lookahead (same as above).  */\n+\n+const char *f1()\n+{\n+  return (const t17) \"abc\";       /* { dg-error \"unknown type name 't17'\" } */\n+/* { dg-bogus \"expected\" \"\" { target *-*-* } 63 } */\n+}\n+\n+const char *f2()\n+{\n+  return (const t18 *) \"abc\";     /* { dg-error \"unknown type name 't18'\" } */\n+/* { dg-bogus \"expected\" \"\" { target *-*-* } 69 } */\n+}\n+\n+\n+/* The parser has problems distinguishing semantic and syntactic errors,\n+   so it emits a wrong \"expected ')'\" error here.  */\n+\n+void *f3(int x)\n+{\n+  return (void *) ((void *(*)(t19)) f3);       /* { dg-error \"unknown type name 't19'\" } */\n+/* { dg-bogus \"expected\" \"\" { xfail *-*-* } 79 } */\n+}\n+\n+const void *f4()\n+{\n+  return &((const t20){1});       /* { dg-error \"unknown type name 't20'\" } */\n+/* { dg-bogus \"return discards 'const'\" \"\" { target *-*-* } 85 } */\n+/* { dg-bogus \"expected\" \"\" { target *-*-* } 85 } */\n+}\n+\n+int f5(__builtin_va_list ap)\n+{\n+  int x = __builtin_va_arg (ap, t21);       /* { dg-error \"unknown type name 't21'\" } */\n+  int y = __builtin_va_arg (ap, const t22); /* { dg-error \"unknown type name 't22'\" } */\n+}\n+\n+int f6(void)\n+{\n+  return __builtin_offsetof (t23, field); /* { dg-error \"unknown type name 't23'\" } */\n+/* { dg-bogus \"request for member\" \"\" { target *-*-* } 98 } */\n+}"}, {"sha": "ccd1dc3a7829ea3f11bf9712419199cd2dab9907", "filename": "gcc/testsuite/gcc.dg/noncompile/920923-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -2,13 +2,13 @@\n typedef BYTE unsigned char;\t/* { dg-error \"expected\" } */\n typedef int item_n;\n typedef int perm_set;\n-struct PENT { caddr_t v_addr; };/* { dg-error \"expected\" } */\n+struct PENT { caddr_t v_addr; };/* { dg-error \"unknown type name\" } */\n typedef struct PENT prec;\n typedef struct PENT *prec_t;\n prec_t mem_hash;\n BYTE *mem_base;\t\t\t/* { dg-error \"unknown type name\" } */\n struct PTE {\n-     BYTE *p_page;\t\t/* { dg-error \"expected\" } */\n+     BYTE *p_page;\t\t/* { dg-error \"unknown type name\" } */\n      perm_set p_perms;\n };\n typedef struct PTE pte;\n@@ -56,7 +56,7 @@ int va_op;\n caddr_t v_addr;\t\t\t/* { dg-error \"unknown type name\" } */\n {\n      register prec_t bucket;\n-     register caddr_t p_addr;\t/* { dg-error \"expected|undeclared\" } */\n+     register caddr_t p_addr;\t/* { dg-error \"unknown type name\" } */\n      bucket = mem_hash+((((v_addr)>>ITEMBITS))&hash_mask);  /* { dg-error \"undeclared\" } */\n      do {\n \t  if (bucket->v_addr == ((v_addr)>>ITEMBITS) {\t/* { dg-error \"expected|undeclared|no member\" } */"}, {"sha": "3a5148af83f83c0ac2d2319d510d00e69f55a736", "filename": "gcc/testsuite/gcc.dg/noncompile/pr44517.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr44517.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr44517.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr44517.c?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -12,7 +12,7 @@ int f2(int x, lon y, long z, ...){ /* { dg-error \"unknown type name 'lon'\" } */\n void f3(int n, int a[n], pid_t x); /* { dg-error \"unknown type name 'pid_t'\" } */\n void f4() {}\n void f5(int a, *b); /* { dg-error \"expected declaration specifiers or\" } */\n-void f6(int a, b);  /* { dg-error \"expected declaration specifiers or\" } */\n+void f6(int a, b);  /* { dg-error \"unknown type name 'b'\" } */\n void f7(int a, goto b); /* { dg-error \"expected declaration specifiers or\" } */\n void f8(int a, in goto); /* { dg-error \"unknown type name 'in'\" } */\n void f9(int a, in 1); /* { dg-error \"unknown type name 'in'\" } */"}, {"sha": "882e5f809950b3e334d58ec6518e789279b22ec3", "filename": "gcc/testsuite/objc.dg/tls/init-2.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fobjc.dg%2Ftls%2Finit-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ce73cb955296716da85268e4b8faf91e6c5fcf/gcc%2Ftestsuite%2Fobjc.dg%2Ftls%2Finit-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftls%2Finit-2.m?ref=29ce73cb955296716da85268e4b8faf91e6c5fcf", "patch": "@@ -11,4 +11,4 @@\n {\n   S(); \t\t\t/* { dg-error \"expected specifier-qualifier-list before 'S'\" } */\n };\n-__thread S s;\t\t/* { dg-error \"expected\" } two errors here */\n+__thread S s;\t\t/* { dg-error \"unknown type name\" } */"}]}