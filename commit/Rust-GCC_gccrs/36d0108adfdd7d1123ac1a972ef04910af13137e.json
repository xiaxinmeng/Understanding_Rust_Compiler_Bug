{"sha": "36d0108adfdd7d1123ac1a972ef04910af13137e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkMDEwOGFkZmRkN2QxMTIzYWMxYTk3MmVmMDQ5MTBhZjEzMTM3ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T14:54:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T14:56:32Z"}, "message": "c++: name-lookup refactoring\n\nHere are some refactorings to the name-lookup machinery.  Primarily\nbreakout out worker functions that the modules patch will also use.\nFixing a couple of comments on the way.\n\n\tgcc/cp/\n\t* name-lookup.c (pop_local_binding): Check for IDENTIFIER_ANON_P.\n\t(update_binding): Level may be null, don't add namespaces to\n\tlevel.\n\t(newbinding_bookkeeping): New, broken out of ...\n\t(do_pushdecl): ... here, call it.  Don't push anonymous decls.\n\t(pushdecl, add_using_namespace): Correct comments.\n\t(do_push_nested_namespace): Remove assert.\n\t(make_namespace, make_namespace_finish): New, broken out of ...\n\t(push_namespace): ... here.  Call them.  Add namespace to level\n\there.", "tree": {"sha": "9f0dd4cde65f86161d7bbd5489ae07726d8fa1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0dd4cde65f86161d7bbd5489ae07726d8fa1d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d0108adfdd7d1123ac1a972ef04910af13137e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d0108adfdd7d1123ac1a972ef04910af13137e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d0108adfdd7d1123ac1a972ef04910af13137e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d0108adfdd7d1123ac1a972ef04910af13137e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237a8e8d5647e45aca2736906033291d49545a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237a8e8d5647e45aca2736906033291d49545a2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/237a8e8d5647e45aca2736906033291d49545a2c"}], "stats": {"total": 216, "additions": 135, "deletions": 81}, "files": [{"sha": "051ef0b36b15e06852ad27f7496bea77d12baaff", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 135, "deletions": 81, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d0108adfdd7d1123ac1a972ef04910af13137e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d0108adfdd7d1123ac1a972ef04910af13137e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=36d0108adfdd7d1123ac1a972ef04910af13137e", "patch": "@@ -1916,7 +1916,7 @@ push_binding (tree id, tree decl, cp_binding_level* level)\n void\n pop_local_binding (tree id, tree decl)\n {\n-  if (id == NULL_TREE)\n+  if (!id || IDENTIFIER_ANON_P (id))\n     /* It's easiest to write the loops that call this function without\n        checking whether or not the entities involved have names.  We\n        get here for such an entity.  */\n@@ -2266,8 +2266,9 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n   tree to_type = old_type;\n   bool local_overload = false;\n \n-  gcc_assert (level->kind == sk_namespace ? !binding\n+  gcc_assert (!level || level->kind == sk_namespace ? !binding\n \t      : level->kind != sk_class && !slot);\n+\n   if (old == error_mark_node)\n     old = NULL_TREE;\n \n@@ -2343,7 +2344,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \twarning (OPT_Wshadow, \"%q#D hides constructor for %q#D\",\n \t\t decl, to_type);\n \n-      local_overload = old && level->kind != sk_namespace;\n+      local_overload = old && level && level->kind != sk_namespace;\n       to_val = ovl_insert (decl, old, -int (hiding));\n     }\n   else if (old)\n@@ -2354,11 +2355,8 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n       else if (TREE_CODE (old) == TYPE_DECL)\n \t{\n \t  if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n-\t    {\n-\t      /* Two type decls to the same type.  Do nothing.  */\n-\t      gcc_checking_assert (!hiding);\n-\t      return old;\n-\t    }\n+\t    /* Two type decls to the same type.  Do nothing.  */\n+\t    return old;\n \t  else\n \t    goto conflict;\n \t}\n@@ -2370,7 +2368,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t    goto conflict;\n \n \t  /* The new one must be an alias at this point.  */\n-\t  gcc_assert (DECL_NAMESPACE_ALIAS (decl) && !hiding);\n+\t  gcc_assert (DECL_NAMESPACE_ALIAS (decl));\n \t  return old;\n \t}\n       else if (TREE_CODE (old) == VAR_DECL)\n@@ -2405,7 +2403,11 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t  gcc_checking_assert (binding->value && OVL_P (binding->value));\n \t  update_local_overload (binding, to_val);\n \t}\n-      else\n+      else if (level\n+\t       && !(TREE_CODE (decl) == NAMESPACE_DECL\n+\t\t    && !DECL_NAMESPACE_ALIAS (decl)))\n+\t/* Don't add namespaces here.  They're done in\n+\t   push_namespace.  */\n \tadd_decl_to_level (level, decl);\n \n       if (slot)\n@@ -2911,6 +2913,41 @@ push_local_extern_decl_alias (tree decl)\n   DECL_LOCAL_DECL_ALIAS (decl) = alias;\n }\n \n+/* DECL has just been bound at LEVEL.  finish up the bookkeeping.  */\n+\n+static void\n+newbinding_bookkeeping (tree name, tree decl, cp_binding_level *level)\n+{\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      tree type = TREE_TYPE (decl);\n+\n+      if (type != error_mark_node)\n+\t{\n+\t  if (TYPE_NAME (type) != decl)\n+\t    set_underlying_type (decl);\n+\n+\t  set_identifier_type_value_with_scope (name, decl, level);\n+\n+\t  if (level->kind != sk_namespace\n+\t      && !instantiating_current_function_p ())\n+\t    /* This is a locally defined typedef in a function that\n+\t       is not a template instantation, record it to implement\n+\t       -Wunused-local-typedefs.  */\n+\t    record_locally_defined_typedef (decl);\n+\t}\n+    }\n+  else\n+    {\n+      if (VAR_P (decl) && !DECL_LOCAL_DECL_P (decl))\n+\tmaybe_register_incomplete_var (decl);\n+\n+      if (VAR_OR_FUNCTION_DECL_P (decl)\n+\t  && DECL_EXTERN_C_P (decl))\n+\tcheck_extern_c_conflict (decl);\n+    }\n+}\n+\n /* Record DECL as belonging to the current lexical scope.  Check for\n    errors (such as an incompatible declaration for the same name\n    already seen in the same scope).  IS_FRIEND is true if DECL is\n@@ -2939,7 +2976,7 @@ do_pushdecl (tree decl, bool hiding)\n   /* An anonymous namespace has a NULL DECL_NAME, but we still want to\n      insert it.  Other NULL-named decls, not so much.  */\n   tree name = DECL_NAME (decl);\n-  if (name || TREE_CODE (decl) == NAMESPACE_DECL)\n+  if (name ? !IDENTIFIER_ANON_P (name) : TREE_CODE (decl) == NAMESPACE_DECL)\n     {\n       cxx_binding *binding = NULL; /* Local scope binding.  */\n       tree ns = NULL_TREE; /* Searched namespace.  */\n@@ -3064,38 +3101,15 @@ do_pushdecl (tree decl, bool hiding)\n       if (old != decl)\n \t/* An existing decl matched, use it.  */\n \tdecl = old;\n-      else if (TREE_CODE (decl) == TYPE_DECL)\n-\t{\n-\t  tree type = TREE_TYPE (decl);\n-\n-\t  if (type != error_mark_node)\n-\t    {\n-\t      if (TYPE_NAME (type) != decl)\n-\t\tset_underlying_type (decl);\n-\n-\t      set_identifier_type_value_with_scope (name, decl, level);\n-\t    }\n-\n-\t  /* If this is a locally defined typedef in a function that\n-\t     is not a template instantation, record it to implement\n-\t     -Wunused-local-typedefs.  */\n-\t  if (!instantiating_current_function_p ())\n-\t    record_locally_defined_typedef (decl);\n-\t}\n       else\n \t{\n-\t  if (VAR_P (decl) && !DECL_LOCAL_DECL_P (decl))\n-\t    maybe_register_incomplete_var (decl);\n-\n-\t  if (VAR_OR_FUNCTION_DECL_P (decl))\n-\t    {\n-\t      if (DECL_LOCAL_DECL_P (decl)\n-\t\t  && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n-\t\tpush_local_extern_decl_alias (decl);\n+\t  newbinding_bookkeeping (name, decl, level);\n+\t  \n \n-\t      if (DECL_EXTERN_C_P (decl))\n-\t\tcheck_extern_c_conflict (decl);\n-\t    }\n+\t  if (VAR_OR_FUNCTION_DECL_P (decl)\n+\t      && DECL_LOCAL_DECL_P (decl)\n+\t      && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n+\t    push_local_extern_decl_alias (decl);\n \t}\n     }\n   else\n@@ -3105,8 +3119,8 @@ do_pushdecl (tree decl, bool hiding)\n }\n \n /* Record a decl-node X as belonging to the current lexical scope.\n-   It's a friend if IS_FRIEND is true -- which affects exactly where\n-   we push it.  */\n+   The new binding is hidden if HIDING is true (an anticipated builtin\n+   or hidden friend).   */\n \n tree\n pushdecl (tree x, bool hiding)\n@@ -7279,8 +7293,6 @@ do_push_nested_namespace (tree ns)\n   else\n     {\n       do_push_nested_namespace (CP_DECL_CONTEXT (ns));\n-      gcc_checking_assert\n-\t(find_namespace_value (current_namespace, DECL_NAME (ns)) == ns);\n       resume_scope (NAMESPACE_LEVEL (ns));\n       current_namespace = ns;\n     }\n@@ -7302,10 +7314,10 @@ do_pop_nested_namespace (tree ns)\n   do_pop_from_top_level ();\n }\n \n-/* Add TARGET to USINGS, if it does not already exist there.\n-   We used to build the complete graph of usings at this point, from\n-   the POV of the source namespaces.  Now we build that as we perform\n-   the unqualified search.  */\n+/* Add TARGET to USINGS, if it does not already exist there.  We used\n+   to build the complete graph of usings at this point, from the POV\n+   of the source namespaces.  Now we build that as we perform the\n+   unqualified search.  */\n \n static void\n add_using_namespace (vec<tree, va_gc> *&usings, tree target)\n@@ -7412,6 +7424,55 @@ push_inline_namespaces (tree ns)\n   return count;\n }\n \n+/* Create a new namespace decl NAME in CTX.  */\n+\n+static tree\n+make_namespace (tree ctx, tree name, location_t loc, bool inline_p)\n+{\n+  /* Create the namespace.  */\n+  tree ns = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n+  DECL_SOURCE_LOCATION (ns) = loc;\n+  SCOPE_DEPTH (ns) = SCOPE_DEPTH (ctx) + 1;\n+  if (!SCOPE_DEPTH (ns))\n+    /* We only allow depth 255. */\n+    sorry (\"cannot nest more than %d namespaces\", SCOPE_DEPTH (ctx));\n+  DECL_CONTEXT (ns) = FROB_CONTEXT (ctx);\n+\n+  if (!name)\n+    /* Anon-namespaces in different header-unit imports are distinct.\n+       But that's ok as their contents all have internal linkage.\n+       (This is different to how they'd behave as textual includes,\n+       but doing this at all is really odd source.)  */\n+    SET_DECL_ASSEMBLER_NAME (ns, anon_identifier);\n+  else if (TREE_PUBLIC (ctx))\n+    TREE_PUBLIC (ns) = true;\n+\n+  if (inline_p)\n+    DECL_NAMESPACE_INLINE_P (ns) = true;\n+\n+  return ns;\n+}\n+\n+/* NS was newly created, finish off making it.  */\n+\n+static void\n+make_namespace_finish (tree ns)\n+{\n+  tree ctx = CP_DECL_CONTEXT (ns);\n+  cp_binding_level *scope = ggc_cleared_alloc<cp_binding_level> ();\n+  scope->this_entity = ns;\n+  scope->more_cleanups_ok = true;\n+  scope->kind = sk_namespace;\n+  scope->level_chain = NAMESPACE_LEVEL (ctx);\n+  NAMESPACE_LEVEL (ns) = scope;\n+\n+  if (DECL_NAMESPACE_INLINE_P (ns))\n+    vec_safe_push (DECL_NAMESPACE_INLINEES (ctx), ns);\n+\n+  if (DECL_NAMESPACE_INLINE_P (ns) || !DECL_NAME (ns))\n+    emit_debug_info_using_namespace (ctx, ns, true);\n+}\n+\n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE,\n    then we enter an anonymous namespace.  If MAKE_INLINE is true, then\n    we create an inline namespace (it is up to the caller to check upon\n@@ -7488,59 +7549,52 @@ push_namespace (tree name, bool make_inline)\n \t}\n   }\n \n-  bool new_ns = false;\n   if (ns)\n-    /* DR2061.  NS might be a member of an inline namespace.  We\n-       need to push into those namespaces.  */\n-    count += push_inline_namespaces (CP_DECL_CONTEXT (ns));\n+    {\n+      /* DR2061.  NS might be a member of an inline namespace.  We\n+\t need to push into those namespaces.  */\n+      count += push_inline_namespaces (CP_DECL_CONTEXT (ns));\n+      if (DECL_SOURCE_LOCATION (ns) == BUILTINS_LOCATION)\n+\t/* It's not builtin now.  */\n+\tDECL_SOURCE_LOCATION (ns) = input_location;\n+    }\n   else\n     {\n-      ns = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-      SCOPE_DEPTH (ns) = SCOPE_DEPTH (current_namespace) + 1;\n-      if (!SCOPE_DEPTH (ns))\n-\t/* We only allow depth 255. */\n-\tsorry (\"cannot nest more than %d namespaces\",\n-\t       SCOPE_DEPTH (current_namespace));\n-      DECL_CONTEXT (ns) = FROB_CONTEXT (current_namespace);\n-      new_ns = true;\n+      /* Before making a new namespace, see if we already have one in\n+\t the existing partitions of the current namespace.  */\n+      tree *slot = find_namespace_slot (current_namespace, name, false);\n+      ns = make_namespace (current_namespace, name, input_location, make_inline);\n \n       if (pushdecl (ns) == error_mark_node)\n \tns = NULL_TREE;\n       else\n \t{\n-\t  if (!name)\n+\t  /* Finish up making the namespace.  */\n+\t  add_decl_to_level (NAMESPACE_LEVEL (current_namespace), ns);\n+\t  if (!slot)\n \t    {\n-\t      SET_DECL_ASSEMBLER_NAME (ns, anon_identifier);\n-\n-\t      if (!make_inline)\n-\t\tadd_using_namespace (current_binding_level->using_directives,\n-\t\t\t\t     ns);\n+\t      slot = find_namespace_slot (current_namespace, name);\n+\t      /* This should find the slot created by pushdecl.  */\n+\t      gcc_checking_assert (slot && *slot == ns);\n \t    }\n-\t  else if (TREE_PUBLIC (current_namespace))\n-\t    TREE_PUBLIC (ns) = 1;\n+\t  make_namespace_finish (ns);\n \n-\t  if (make_inline)\n-\t    {\n-\t      DECL_NAMESPACE_INLINE_P (ns) = true;\n-\t      vec_safe_push (DECL_NAMESPACE_INLINEES (current_namespace), ns);\n-\t    }\n-\n-\t  if (!name || make_inline)\n-\t    emit_debug_info_using_namespace (current_namespace, ns, true);\n+\t  /* Add the anon using-directive here, we don't do it in\n+\t     make_namespace_finish.  */\n+\t  if (!DECL_NAMESPACE_INLINE_P (ns) && !name)\n+\t    add_using_namespace (current_binding_level->using_directives, ns);\n \t}\n     }\n \n   if (ns)\n     {\n       if (make_inline && !DECL_NAMESPACE_INLINE_P (ns))\n \t{\n-\t  error (\"inline namespace must be specified at initial definition\");\n+\t  error_at (input_location,\n+\t\t    \"inline namespace must be specified at initial definition\");\n \t  inform (DECL_SOURCE_LOCATION (ns), \"%qD defined here\", ns);\n \t}\n-      if (new_ns)\n-\tbegin_scope (sk_namespace, ns);\n-      else\n-\tresume_scope (NAMESPACE_LEVEL (ns));\n+      resume_scope (NAMESPACE_LEVEL (ns));\n       current_namespace = ns;\n       count++;\n     }"}]}