{"sha": "355526af2b3527bde465ccbfbb6a6af42a74ceea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1NTI2YWYyYjM1MjdiZGU0NjVjY2JmYmI2YTZhZjQyYTc0Y2VlYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-03-06T05:13:58Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-03-06T05:13:58Z"}, "message": "natPosixProcess.cc (fail): Removed.\n\n\t* java/lang/natPosixProcess.cc (fail): Removed.\n\t(startProcess): Simplified error-handling.  Preserve\n\tLD_LIBRARY_PATH across exec.\n\nFrom-SVN: r50342", "tree": {"sha": "9fa842ec89f4fa278d0c4378170b354d0ef7b665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa842ec89f4fa278d0c4378170b354d0ef7b665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355526af2b3527bde465ccbfbb6a6af42a74ceea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355526af2b3527bde465ccbfbb6a6af42a74ceea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355526af2b3527bde465ccbfbb6a6af42a74ceea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355526af2b3527bde465ccbfbb6a6af42a74ceea/comments", "author": null, "committer": null, "parents": [{"sha": "50b424a908827a6b049c96a8455109514ab444d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b424a908827a6b049c96a8455109514ab444d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b424a908827a6b049c96a8455109514ab444d1"}], "stats": {"total": 283, "additions": 157, "deletions": 126}, "files": [{"sha": "392d370d115ad345d7ea2e5a5d61eec7f88d1a85", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355526af2b3527bde465ccbfbb6a6af42a74ceea/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355526af2b3527bde465ccbfbb6a6af42a74ceea/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=355526af2b3527bde465ccbfbb6a6af42a74ceea", "patch": "@@ -1,5 +1,9 @@\n 2002-03-05  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/lang/natPosixProcess.cc (fail): Removed.\n+\t(startProcess): Simplified error-handling.  Preserve\n+\tLD_LIBRARY_PATH across exec.\n+\n \t* jni.cc (_Jv_LookupJNIMethod): Throw UnsatisfiedLinkError, not\n \tAbstractMethodError.\n "}, {"sha": "b480afb81a8ef96e08b7b8ad10797daa1276d507", "filename": "libjava/java/lang/natPosixProcess.cc", "status": "modified", "additions": 153, "deletions": 126, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355526af2b3527bde465ccbfbb6a6af42a74ceea/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355526af2b3527bde465ccbfbb6a6af42a74ceea/libjava%2Fjava%2Flang%2FnatPosixProcess.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatPosixProcess.cc?ref=355526af2b3527bde465ccbfbb6a6af42a74ceea", "patch": "@@ -114,38 +114,6 @@ myclose (int &fd)\n   fd = -1;\n }\n \n-static void\n-fail (int error_value, char **args, char **env,\n-      int *one = NULL, int *two = NULL,\n-      int *three = NULL, int *four = NULL,\n-      java::lang::Throwable *t = NULL)\n-{\n-  cleanup (args, env);\n-  if (one != NULL)\n-    {\n-      myclose (one[0]);\n-      myclose (one[1]);\n-    }\n-  if (two != NULL)\n-    {\n-      myclose (two[0]);\n-      myclose (two[1]);\n-    }\n-  if (three != NULL)\n-    {\n-      myclose (three[0]);\n-      myclose (three[1]);\n-    }\n-  if (four != NULL)\n-    {\n-      myclose (four[0]);\n-      myclose (four[1]);\n-    }\n-  if (t == NULL)\n-    t = new java::io::IOException (JvNewStringLatin1 (strerror (error_value)));\n-  throw t;\n-}\n-\n void\n java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n \t\t\t\t\t   jstringArray envp)\n@@ -154,21 +122,34 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n \n   hasExited = false;\n \n-  if (! progarray)\n-    throw new NullPointerException;\n-\n-  // Transform arrays to native form.\n-  char **args = (char **) _Jv_Malloc ((progarray->length + 1)\n-\t\t\t\t      * sizeof (char *));\n+  // Initialize all locals here to make cleanup simpler.\n+  char **args = NULL;\n   char **env = NULL;\n-\n-  // Initialize so we can gracefully recover.\n-  jstring *elts = elements (progarray);\n-  for (int i = 0; i <= progarray->length; ++i)\n-    args[i] = NULL;\n+  int inp[2], outp[2], errp[2], msgp[2];\n+  inp[0] = -1;\n+  inp[1] = -1;\n+  outp[0] = -1;\n+  outp[1] = -1;\n+  errp[0] = -1;\n+  errp[1] = -1;\n+  msgp[0] = -1;\n+  msgp[1] = -1;\n+  java::lang::Throwable *exc = NULL;\n+  errorStream = NULL;\n+  inputStream = NULL;\n+  outputStream = NULL;\n \n   try\n     {\n+      // Transform arrays to native form.\n+      args = (char **) _Jv_Malloc ((progarray->length + 1)\n+\t\t\t\t   * sizeof (char *));\n+\n+      // Initialize so we can gracefully recover.\n+      jstring *elts = elements (progarray);\n+      for (int i = 0; i <= progarray->length; ++i)\n+\targs[i] = NULL;\n+\n       for (int i = 0; i < progarray->length; ++i)\n \targs[i] = new_string (elts[i]);\n       args[progarray->length] = NULL;\n@@ -186,105 +167,151 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n \t    env[i] = new_string (elts[i]);\n \t  env[envp->length] = NULL;\n \t}\n-    }\n-  catch (java::lang::OutOfMemoryError *oome)\n-    {\n-      fail (0, args, env, NULL, NULL, NULL, NULL, oome);\n-      throw oome;\n-    }\n \n-  // Create pipes for I/O.  MSGP is for communicating exec() status.\n-  int inp[2], outp[2], errp[2], msgp[2];\n+      // Create pipes for I/O.  MSGP is for communicating exec()\n+      // status.\n+      if (pipe (inp) || pipe (outp) || pipe (errp) || pipe (msgp)\n+\t  || fcntl (msgp[1], F_SETFD, FD_CLOEXEC))\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n \n-  if (pipe (inp))\n-    fail (errno, args, env);\n-  if (pipe (outp))\n-    fail (errno, args, env, inp);\n-  if (pipe (errp))\n-    fail (errno, args, env, inp, outp);\n-  if (pipe (msgp))\n-    fail (errno, args, env, inp, outp, errp);\n-  if (fcntl (msgp[1], F_SETFD, FD_CLOEXEC))\n-    fail (errno, args, env, inp, outp, errp, msgp);\n-\n-  // We create the streams before forking.  Otherwise if we had an\n-  // error while creating the streams we would have run the child with\n-  // no way to communicate with it.\n-  try\n-    {\n+      // We create the streams before forking.  Otherwise if we had an\n+      // error while creating the streams we would have run the child\n+      // with no way to communicate with it.\n       errorStream = new FileInputStream (new FileDescriptor (errp[0]));\n       inputStream = new FileInputStream (new FileDescriptor (inp[0]));\n       outputStream = new FileOutputStream (new FileDescriptor (outp[1]));\n-    }\n-  catch (java::lang::Throwable *t)\n-    {\n-      fail (0, args, env, inp, outp, errp, msgp, t);\n-    }\n \n-  // We don't use vfork() because that would cause the local\n-  // environment to be set by the child.\n-  if ((pid = (jlong) fork ()) == -1)\n-    fail (errno, args, env, inp, outp, errp, msgp);\n+      // We don't use vfork() because that would cause the local\n+      // environment to be set by the child.\n+      if ((pid = (jlong) fork ()) == -1)\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n \n-  if (pid == 0)\n-    {\n-      // Child process, so remap descriptors and exec.\n+      if (pid == 0)\n+\t{\n+\t  // Child process, so remap descriptors and exec.\n \n-      if (envp)\n-        {\n-\t  // preserve PATH unless specified explicitly\n-\t  char *path_val = getenv (\"PATH\");\n-\t  environ = env;\n-\t  if (getenv (\"PATH\") == NULL)\n+\t  if (envp)\n \t    {\n-\t      char *path_env = (char *) _Jv_Malloc (strlen (path_val) + 5 + 1);\n-\t      strcpy (path_env, \"PATH=\");\n-\t      strcat (path_env, path_val);\n-\t      putenv (path_env);\n+\t      // Preserve PATH and LD_LIBRARY_PATH unless specified\n+\t      // explicitly.\n+\t      char *path_val = getenv (\"PATH\");\n+\t      char *ld_path_val = getenv (\"LD_LIBRARY_PATH\");\n+\t      environ = env;\n+\t      if (getenv (\"PATH\") == NULL)\n+\t\t{\n+\t\t  char *path_env = (char *) _Jv_Malloc (strlen (path_val)\n+\t\t\t\t\t\t\t+ 5 + 1);\n+\t\t  strcpy (path_env, \"PATH=\");\n+\t\t  strcat (path_env, path_val);\n+\t\t  putenv (path_env);\n+\t\t}\n+\t      if (getenv (\"LD_LIBRARY_PATH\") == NULL)\n+\t\t{\n+\t\t  char *ld_path_env\n+\t\t    = (char *) _Jv_Malloc (strlen (ld_path_val) + 16 + 1);\n+\t\t  strcpy (ld_path_env, \"LD_LIBRARY_PATH=\");\n+\t\t  strcat (ld_path_env, ld_path_val);\n+\t\t  putenv (ld_path_env);\n+\t\t}\n \t    }\n+\n+\t  // We ignore errors from dup2 because they should never occur.\n+\t  dup2 (outp[0], 0);\n+\t  dup2 (inp[1], 1);\n+\t  dup2 (errp[1], 2);\n+\n+\t  // Use close and not myclose -- we're in the child, and we\n+\t  // aren't worried about the possible race condition.\n+\t  close (inp[0]);\n+\t  close (inp[1]);\n+\t  close (errp[0]);\n+\t  close (errp[1]);\n+\t  close (outp[0]);\n+\t  close (outp[1]);\n+\t  close (msgp[0]);\n+\n+\t  execvp (args[0], args);\n+\n+\t  // Send the parent notification that the exec failed.\n+\t  char c = errno;\n+\t  write (msgp[1], &c, 1);\n+\t  _exit (127);\n \t}\n-\t\n-      // We ignore errors from dup2 because they should never occur.\n-      dup2 (outp[0], 0);\n-      dup2 (inp[1], 1);\n-      dup2 (errp[1], 2);\n-\n-      // Use close and not myclose -- we're in the child, and we\n-      // aren't worried about the possible race condition.\n-      close (inp[0]);\n-      close (inp[1]);\n-      close (errp[0]);\n-      close (errp[1]);\n-      close (outp[0]);\n-      close (outp[1]);\n-      close (msgp[0]);\n-\n-      execvp (args[0], args);\n-\n-      // Send the parent notification that the exec failed.\n-      char c = errno;\n-      write (msgp[1], &c, 1);\n-      _exit (127);\n+\n+      // Parent.  Close extra file descriptors and mark ours as\n+      // close-on-exec.\n+      myclose (outp[0]);\n+      myclose (inp[1]);\n+      myclose (errp[1]);\n+      myclose (msgp[1]);\n+\n+      char c;\n+      int r = read (msgp[0], &c, 1);\n+      if (r == -1)\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n+      else if (r != 0)\n+\tthrow new IOException (JvNewStringLatin1 (strerror (c)));\n     }\n+  catch (java::lang::Throwable *thrown)\n+    {\n+      // Do some cleanup we only do on failure.  If a stream object\n+      // has been created, we must close the stream itself (to avoid\n+      // duplicate closes when the stream object is collected).\n+      // Otherwise we simply close the underlying file descriptor.\n+      // We ignore errors here as they are uninteresting.\n+\n+      try\n+\t{\n+\t  if (inputStream != NULL)\n+\t    inputStream->close ();\n+\t  else\n+\t    myclose (inp[0]);\n+\t}\n+      catch (java::lang::Throwable *ignore)\n+\t{\n+\t}\n+\n+      try\n+\t{\n+\t  if (outputStream != NULL)\n+\t    outputStream->close ();\n+\t  else\n+\t    myclose (outp[1]);\n+\t}\n+      catch (java::lang::Throwable *ignore)\n+\t{\n+\t}\n+\n+      try\n+\t{\n+\t  if (errorStream != NULL)\n+\t    errorStream->close ();\n+\t  else\n+\t    myclose (errp[0]);\n+\t}\n+      catch (java::lang::Throwable *ignore)\n+\t{\n+\t}\n \n-  // Parent.  Close extra file descriptors and mark ours as\n-  // close-on-exec.\n-  myclose (outp[0]);\n-  myclose (inp[1]);\n-  myclose (errp[1]);\n-  myclose (msgp[1]);\n+      // These are potentially duplicate, but it doesn't matter due to\n+      // the use of myclose.\n+      myclose (outp[0]);\n+      myclose (inp[1]);\n+      myclose (errp[1]);\n+      myclose (msgp[1]);\n \n-  char c;\n-  int r = read (msgp[0], &c, 1);\n-  if (r == -1)\n-    fail (errno, args, env, inp, outp, errp, msgp);\n-  else if (r != 0)\n-    fail (c, args, env, inp, outp, errp, msgp);\n+      exc = thrown;\n+    }\n \n   myclose (msgp[0]);\n   cleanup (args, env);\n \n-  fcntl (outp[1], F_SETFD, FD_CLOEXEC);\n-  fcntl (inp[0], F_SETFD, FD_CLOEXEC);\n-  fcntl (errp[0], F_SETFD, FD_CLOEXEC);\n+  if (exc != NULL)\n+    throw exc;\n+  else\n+    {\n+      fcntl (outp[1], F_SETFD, FD_CLOEXEC);\n+      fcntl (inp[0], F_SETFD, FD_CLOEXEC);\n+      fcntl (errp[0], F_SETFD, FD_CLOEXEC);\n+    }\n }"}]}