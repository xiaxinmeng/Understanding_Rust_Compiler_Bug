{"sha": "b2f21330f7bc725e088522d63070b05f0253a672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJmMjEzMzBmN2JjNzI1ZTA4ODUyMmQ2MzA3MGIwNWYwMjUzYTY3Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2009-04-23T10:39:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2009-04-23T10:39:24Z"}, "message": "vxlib-tls.c (active_tls_threads): Delete.\n\n\t* config/vxlib-tls.c (active_tls_threads): Delete.\n\t(delete_hook_installed): New.\n\t(tls_delete_hook): Don't delete the delete hook.\n\t(tls_destructor): Delete it here.\n\t(__gthread_set_specific): Adjust installing the delete hook.\n\t(tls_delete_hook): Use __gthread_enter_tsd_dtor_context and\n\t__gthread_leave_tsd_dtor_context.\n\nFrom-SVN: r146641", "tree": {"sha": "a68753e7f723e4501f53e6f560f35058bb22ce31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a68753e7f723e4501f53e6f560f35058bb22ce31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2f21330f7bc725e088522d63070b05f0253a672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f21330f7bc725e088522d63070b05f0253a672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2f21330f7bc725e088522d63070b05f0253a672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f21330f7bc725e088522d63070b05f0253a672/comments", "author": null, "committer": null, "parents": [{"sha": "ee721644f5958a0bf1d40aabd8e0dfaa6f8ed870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee721644f5958a0bf1d40aabd8e0dfaa6f8ed870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee721644f5958a0bf1d40aabd8e0dfaa6f8ed870"}], "stats": {"total": 62, "additions": 37, "deletions": 25}, "files": [{"sha": "916b30a6f0ea63de303b5597b239c52d103c4d5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f21330f7bc725e088522d63070b05f0253a672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f21330f7bc725e088522d63070b05f0253a672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2f21330f7bc725e088522d63070b05f0253a672", "patch": "@@ -1,3 +1,13 @@\n+2009-04-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/vxlib-tls.c (active_tls_threads): Delete.\n+\t(delete_hook_installed): New.\n+\t(tls_delete_hook): Don't delete the delete hook.\n+\t(tls_destructor): Delete it here.\n+\t(__gthread_set_specific): Adjust installing the delete hook.\n+\t(tls_delete_hook): Use __gthread_enter_tsd_dtor_context and\n+\t__gthread_leave_tsd_dtor_context.\n+\n 2009-04-23  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* c-format.c (gcc_tdiag_char_table): Add support for %E."}, {"sha": "c4696768f0f1dac29b6e9848ec764b89d819e1b0", "filename": "gcc/config/vxlib-tls.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f21330f7bc725e088522d63070b05f0253a672/gcc%2Fconfig%2Fvxlib-tls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f21330f7bc725e088522d63070b05f0253a672/gcc%2Fconfig%2Fvxlib-tls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxlib-tls.c?ref=b2f21330f7bc725e088522d63070b05f0253a672", "patch": "@@ -91,9 +91,9 @@ struct tls_data\n    include a pointer to a local variable in the TLS data object.  */\n static int self_owner;\n \n-/* The number of threads for this module which have active TLS data.\n-   This is protected by tls_lock.  */\n-static int active_tls_threads;\n+/* Flag to check whether the delete hook is installed.  Once installed\n+   it is only removed when unloading this module.  */\n+static volatile int delete_hook_installed;\n \n /* kernel provided routines */\n extern void *__gthread_get_tls_data (void);\n@@ -166,7 +166,11 @@ tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n   \n   if (data && data->owner == &self_owner)\n     {\n+#ifdef __RTP__\n       __gthread_enter_tls_dtor_context ();\n+#else\n+      __gthread_enter_tsd_dtor_context (tcb);\n+#endif\n       for (key = 0; key < MAX_KEYS; key++)\n \t{\n \t  if (data->generation[key] == tls_keys.generation[key])\n@@ -178,22 +182,17 @@ tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n \t    }\n \t}\n       free (data);\n+#ifdef __RTP__\n+      __gthread_leave_tls_dtor_context ();\n+#else\n+      __gthread_leave_tsd_dtor_context ();\n+#endif\n \n-      /* We can't handle an error here, so just leave the thread\n-\t marked as loaded if one occurs.  */\n-      if (__gthread_mutex_lock (&tls_lock) != ERROR)\n-\t{\n-\t  active_tls_threads--;\n-\t  if (active_tls_threads == 0)\n-\t    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n-\t  __gthread_mutex_unlock (&tls_lock);\n-\t}\n #ifdef __RTP__\n       __gthread_set_tls_data (0);\n #else\n       __gthread_set_tsd_data (tcb, 0);\n #endif\n-      __gthread_leave_tls_dtor_context ();\n     }\n } \n \n@@ -211,13 +210,10 @@ tls_destructor (void)\n #ifdef __RTP__\n   /* All threads but this one should have exited by now.  */\n   tls_delete_hook (NULL);\n-#else\n-  /* Unregister the hook forcibly.  The counter of active threads may\n-     be incorrect, because constructors (like the C++ library's) and\n-     destructors (like this one) run in the context of the shell rather\n-     than in a task spawned from this module.  */\n-  taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n #endif\n+  /* Unregister the hook.  */\n+  if (delete_hook_installed)\n+    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n \n   if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)\n     semDelete (tls_lock);\n@@ -331,12 +327,18 @@ __gthread_setspecific (__gthread_key_t key, void *value)\n   data = __gthread_get_tls_data ();\n   if (!data)\n     {\n-      if (__gthread_mutex_lock (&tls_lock) == ERROR)\n-\treturn ENOMEM;\n-      if (active_tls_threads == 0)\n-\ttaskDeleteHookAdd ((FUNCPTR)tls_delete_hook);\n-      active_tls_threads++;\n-      __gthread_mutex_unlock (&tls_lock);\n+      if (!delete_hook_installed)\n+\t{\n+\t  /* Install the delete hook.  */\n+\t  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n+\t    return ENOMEM;\n+\t  if (!delete_hook_installed)\n+\t    {\n+\t      taskDeleteHookAdd ((FUNCPTR)tls_delete_hook);\n+\t      delete_hook_installed = 1;\n+\t    }\n+\t  __gthread_mutex_unlock (&tls_lock);\n+\t}\n \n       data = malloc (sizeof (struct tls_data));\n       if (!data)"}]}