{"sha": "8d6e462ba263caef7e9663232267af59b15b86cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ2ZTQ2MmJhMjYzY2FlZjdlOTY2MzIzMjI2N2FmNTliMTViODZjZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@kalessin.cygnus.com", "date": "1995-08-25T23:05:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-25T23:05:26Z"}, "message": "(struct binding_level):  New fields dead_vars_from_for and is_for_scope.\n\n(note_level_for_for):  New function.\n(poplevel):  Special processing if is_for_scope.\n(pushdecl):  Warn if for-scope variable shadows local.\n\nFrom-SVN: r10273", "tree": {"sha": "3a7a792b0b833221884391be681917a630dfcb58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a7a792b0b833221884391be681917a630dfcb58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d6e462ba263caef7e9663232267af59b15b86cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d6e462ba263caef7e9663232267af59b15b86cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d6e462ba263caef7e9663232267af59b15b86cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d6e462ba263caef7e9663232267af59b15b86cd/comments", "author": null, "committer": null, "parents": [{"sha": "57c0c9cac9b0ed9c6d2fdbddd85dc650c4254d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c0c9cac9b0ed9c6d2fdbddd85dc650c4254d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c0c9cac9b0ed9c6d2fdbddd85dc650c4254d96"}], "stats": {"total": 109, "additions": 92, "deletions": 17}, "files": [{"sha": "50ca421517e18eb81242f23af51709027f044d70", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d6e462ba263caef7e9663232267af59b15b86cd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d6e462ba263caef7e9663232267af59b15b86cd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8d6e462ba263caef7e9663232267af59b15b86cd", "patch": "@@ -552,6 +552,11 @@ struct binding_level\n        structure or union types.  */\n     unsigned int n_incomplete;\n \n+    /* List of VAR_DECLS saved from a previous for statement.\n+       These would be dead in ANSI-conformant code, but might\n+       be referenced in traditional code. */\n+    tree dead_vars_from_for;\n+\n     /* 1 for the level that holds the parameters of a function.\n        2 for the level that holds a class declaration.\n        3 for levels that hold parameter declarations.  */\n@@ -583,6 +588,9 @@ struct binding_level\n     /* This is set for a namespace binding level.  */\n     unsigned namespace_p : 1;\n \n+    /* True if this level is that of a for-statement. */\n+    unsigned is_for_scope : 1;\n+\n     /* One bit left for this word.  */\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n@@ -939,6 +947,12 @@ pushlevel (tag_transparent)\n   keep_next_level_flag = 0;\n }\n \n+int\n+note_level_for_for ()\n+{\n+  current_binding_level->is_for_scope = 1;\n+}\n+\n void\n pushlevel_temporary (tag_transparent)\n      int tag_transparent;\n@@ -1097,28 +1111,81 @@ poplevel (keep, reverse, functionbody)\n \n   /* Clear out the meanings of the local variables of this level.  */\n \n-  for (link = decls; link; link = TREE_CHAIN (link))\n+  for (link = current_binding_level->dead_vars_from_for;\n+       link != NULL_TREE; link = TREE_CHAIN (link))\n     {\n-      if (DECL_NAME (link) != NULL_TREE)\n+      if (DECL_DEAD_FOR_LOCAL (link))\n \t{\n-\t  /* If the ident. was used or addressed via a local extern decl,\n-\t     don't forget that fact.  */\n-\t  if (DECL_EXTERNAL (link))\n+\t  tree id = DECL_NAME (link);\n+\t  if (IDENTIFIER_LOCAL_VALUE (id) == link)\n+\t    IDENTIFIER_LOCAL_VALUE (id) = DECL_SHADOWED_FOR_VAR (link);\n+\t}\n+    }\n+\n+  if (current_binding_level->is_for_scope && flag_new_for_scope == 1)\n+    {\n+      for (link = decls; link; link = TREE_CHAIN (link))\n+\t{\n+\t  if (TREE_CODE (link) == VAR_DECL)\n+\t    DECL_DEAD_FOR_LOCAL (link) = 1;\n+\t}\n+    }\n+  else\n+    {\n+      for (link = decls; link; link = TREE_CHAIN (link))\n+\t{\n+\t  if (DECL_NAME (link) != NULL_TREE)\n \t    {\n-\t      if (TREE_USED (link))\n-\t\tTREE_USED (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t      if (TREE_ADDRESSABLE (link))\n-\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t      /* If the ident. was used or addressed via a local extern decl,\n+\t\t don't forget that fact.  */\n+\t      if (DECL_EXTERNAL (link))\n+\t\t{\n+\t\t  if (TREE_USED (link))\n+\t\t    TREE_USED (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t\t  if (TREE_ADDRESSABLE (link))\n+\t\t    TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t\t}\n+\t      IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n \t    }\n-\t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n \t}\n     }\n \n   /* Restore all name-meanings of the outer levels\n      that were shadowed by this level.  */\n \n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  if (current_binding_level->is_for_scope && flag_new_for_scope == 1)\n+    {\n+      struct binding_level *outer = current_binding_level->level_chain;\n+      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+\t{\n+\t  tree id = TREE_PURPOSE (link);\n+\t  tree decl = IDENTIFIER_LOCAL_VALUE (id);\n+\t  if (DECL_DEAD_FOR_LOCAL (decl))\n+\t    DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n+\t  else\n+\t    IDENTIFIER_LOCAL_VALUE (id) = TREE_VALUE (link);\n+\t}\n+\n+      /* Save declarations made in a 'for' statement so we can support pre-ANSI\n+\t 'for' scoping semantics. */\n+\n+      /* We append the current names of for-variables to those from previous\n+\t declarations, so that when we get around to do an poplevel\n+\t on the OUTER level, we restore the any shadowed readl bindings.\n+\t Note that the new names are put first on the combined list,\n+\t so they get to be restored first.  This is important if there are\n+\t two for-loops using the same for-variable in the same block.\n+\t The binding we really want restored is whatever binding was shadowed\n+\t by the *first* for-variable, not the binding shadowed by the\n+\t second for-variable (which would be the first for-variable). */\n+      outer->dead_vars_from_for\n+\t= chainon (current_binding_level->names, outer->dead_vars_from_for);\n+    }\n+  else\n+    {\n+      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+\tIDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+    }\n   for (link = current_binding_level->class_shadowed;\n        link; link = TREE_CHAIN (link))\n     IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n@@ -3029,15 +3096,16 @@ pushdecl (x)\n \n       else if (t != NULL_TREE)\n \t{\n-\t  if (TREE_CODE (t) == PARM_DECL)\n+\t  file = DECL_SOURCE_FILE (t);\n+\t  line = DECL_SOURCE_LINE (t);\n+\t  if (TREE_CODE (x) == VAR_DECL && DECL_DEAD_FOR_LOCAL (x))\n+\t    ; /* This is OK. */\n+\t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n \t\tfatal (\"parse errors have confused me too much\");\n \t    }\n-\t  file = DECL_SOURCE_FILE (t);\n-\t  line = DECL_SOURCE_LINE (t);\n-\n-\t  if (((TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c)\n+\t  else if (((TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c)\n \t       || (TREE_CODE (x) == TEMPLATE_DECL\n \t\t   && ! DECL_TEMPLATE_IS_CLASS (x)))\n \t      && is_overloaded_fn (t))\n@@ -3303,6 +3371,13 @@ pushdecl (x)\n \t      if (b->parm_flag == 1)\n \t\tcp_error (\"declaration of `%#D' shadows a parameter\", name);\n \t    }\n+\t  else if (oldlocal != NULL_TREE && b->is_for_scope\n+\t\t   && !DECL_DEAD_FOR_LOCAL (oldlocal))\n+\t    {\n+\t      warning (\"variable `%s' shadows local\",\n+\t\t       IDENTIFIER_POINTER (name));\n+\t      cp_warning_at (\"  this is the shadowed declaration\", oldlocal);\n+\t    }\t\t   \n \t  /* Maybe warn if shadowing something else.  */\n \t  else if (warn_shadow && !DECL_EXTERNAL (x)\n \t\t   /* No shadow warnings for internally generated vars.  */"}]}