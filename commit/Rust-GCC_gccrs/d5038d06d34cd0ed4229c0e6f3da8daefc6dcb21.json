{"sha": "d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwMzhkMDZkMzRjZDBlZDQyMjljMGU2ZjNkYThkYWVmYzZkY2IyMQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-01-19T15:06:04Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-01-19T15:06:04Z"}, "message": "re PR tree-optimization/46590 (long compile time with -O2 and many loops)\n\n        PR tree-optimization/46590\n\t* cfgexpand.c (add_scope_conflicts_1): New old_conflicts argument,\n\tuse it in remembering which conflicts we already created.\n\t(add_scope_conflicts): Adjust call to above, (de)allocate helper\n\tbitmap.\n\nFrom-SVN: r183305", "tree": {"sha": "c76c4271fa6983ad65e44cfda02ebb2d7e4bdcb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c76c4271fa6983ad65e44cfda02ebb2d7e4bdcb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e58d4228453c9e7036259acd104222bff680a880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58d4228453c9e7036259acd104222bff680a880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e58d4228453c9e7036259acd104222bff680a880"}], "stats": {"total": 42, "additions": 33, "deletions": 9}, "files": [{"sha": "8bb487cc0fc842411acfb018a49b868ecb63e403", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "patch": "@@ -1,3 +1,11 @@\n+2012-01-19  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/46590\n+\t* cfgexpand.c (add_scope_conflicts_1): New old_conflicts argument,\n+\tuse it in remembering which conflicts we already created.\n+\t(add_scope_conflicts): Adjust call to above, (de)allocate helper\n+\tbitmap.\n+\n 2012-01-19  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR lto/51280"}, {"sha": "9f0797ce05020433d6fce54a66b3723f42409edd", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d5038d06d34cd0ed4229c0e6f3da8daefc6dcb21", "patch": "@@ -441,11 +441,12 @@ visit_conflict (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n \n /* Helper routine for add_scope_conflicts, calculating the active partitions\n    at the end of BB, leaving the result in WORK.  We're called to generate\n-   conflicts when FOR_CONFLICT is true, otherwise we're just tracking\n-   liveness.  */\n+   conflicts when OLD_CONFLICTS is non-null, otherwise we're just tracking\n+   liveness.  If we generate conflicts then OLD_CONFLICTS stores the bits\n+   for which we generated conflicts already.  */\n \n static void\n-add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n+add_scope_conflicts_1 (basic_block bb, bitmap work, bitmap old_conflicts)\n {\n   edge e;\n   edge_iterator ei;\n@@ -482,24 +483,35 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t}\n       else if (!is_gimple_debug (stmt))\n \t{\n-\t  if (for_conflict\n+\t  if (old_conflicts\n \t      && visit == visit_op)\n \t    {\n \t      /* If this is the first real instruction in this BB we need\n \t         to add conflicts for everything live at this point now.\n \t\t Unlike classical liveness for named objects we can't\n \t\t rely on seeing a def/use of the names we're interested in.\n \t\t There might merely be indirect loads/stores.  We'd not add any\n-\t\t conflicts for such partitions.  */\n+\t\t conflicts for such partitions.  We know that we generated\n+\t\t conflicts between all partitions in old_conflicts already,\n+\t\t so we need to generate only the new ones, avoiding to\n+\t\t repeatedly pay the O(N^2) cost for each basic block.  */\n \t      bitmap_iterator bi;\n \t      unsigned i;\n-\t      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n+\n+\t      EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, 0, i, bi)\n \t\t{\n \t\t  unsigned j;\n \t\t  bitmap_iterator bj;\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (work, i + 1, j, bj)\n+\t\t  /* First the conflicts between new and old_conflicts.  */\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (old_conflicts, 0, j, bj)\n+\t\t    add_stack_var_conflict (i, j);\n+\t\t  /* Then the conflicts between only the new members.  */\n+\t\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, i + 1,\n+\t\t\t\t\t\t  j, bj)\n \t\t    add_stack_var_conflict (i, j);\n \t\t}\n+\t      /* And remember for the next basic block.  */\n+\t      bitmap_ior_into (old_conflicts, work);\n \t      visit = visit_conflict;\n \t    }\n \t  walk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n@@ -516,6 +528,7 @@ add_scope_conflicts (void)\n   basic_block bb;\n   bool changed;\n   bitmap work = BITMAP_ALLOC (NULL);\n+  bitmap old_conflicts;\n \n   /* We approximate the live range of a stack variable by taking the first\n      mention of its name as starting point(s), and by the end-of-scope\n@@ -537,15 +550,18 @@ add_scope_conflicts (void)\n       FOR_EACH_BB (bb)\n \t{\n \t  bitmap active = (bitmap)bb->aux;\n-\t  add_scope_conflicts_1 (bb, work, false);\n+\t  add_scope_conflicts_1 (bb, work, NULL);\n \t  if (bitmap_ior_into (active, work))\n \t    changed = true;\n \t}\n     }\n \n+  old_conflicts = BITMAP_ALLOC (NULL);\n+\n   FOR_EACH_BB (bb)\n-    add_scope_conflicts_1 (bb, work, true);\n+    add_scope_conflicts_1 (bb, work, old_conflicts);\n \n+  BITMAP_FREE (old_conflicts);\n   BITMAP_FREE (work);\n   FOR_ALL_BB (bb)\n     BITMAP_FREE (bb->aux);"}]}