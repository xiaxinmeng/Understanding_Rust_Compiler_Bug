{"sha": "fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEzOTdkZGFmYjMzNWViMGE2N2IwOGUwMTQ2MDViZjVmOWFiN2NjNQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-07-26T11:21:45Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-07-26T11:21:45Z"}, "message": "Calendar.java (set): Never recompute fields here.\n\n\t* java/util/Calendar.java (set): Never recompute fields here. They\n\twill already be set if someone set time explicitly, and it can cause\n\tproblems to do so. Don't invalidate AM_PM setting if HOUR is set.\n\t* java/util/GregorianCalendar.java (computeTime): Don't ignore an\n\tHOUR setting if AM_PM is set. Don't try to ensure the HOUR value is\n\tsane.\n\t* java/text/SimpleDateFormat.java (defaultCentury): New field.\n\t(readObject): Call set2DigitYearStart if appropriate so that\n\tdefaultCentury is calculated.\n\t(SimpleDateFormat): Don't bother clearing calendar here. Call\n\tcomputeCenturyStart().\n\t(set2DigitYearStart): Calculate and set defaultCentury.\n\t(format): Don't clone the calendar. Use \"calendar\" not \"theCalendar\"\n\teverywhere.\n\t(parse): Likewise. If the pattern is \"y\" or \"yy\" and it found exactly\n\t2 numeric digits, use the 80-20 heuristic to parse the value into a\n\tdefault century based on defaultCenturyStart.\n\t(computeCenturyStart): Rewritten. Call set2DigitYearStart().\n\nFrom-SVN: r44395", "tree": {"sha": "f1888f988daa008faa5d48c983f690f3067987c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1888f988daa008faa5d48c983f690f3067987c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/comments", "author": null, "committer": null, "parents": [{"sha": "2cf50fd3a47891bb7ae2a0ada9254ae7ef236a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf50fd3a47891bb7ae2a0ada9254ae7ef236a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf50fd3a47891bb7ae2a0ada9254ae7ef236a28"}], "stats": {"total": 183, "additions": 112, "deletions": 71}, "files": [{"sha": "15a2c566acb0b1d649a7cd2d1be0699f3fce6b6e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "patch": "@@ -1,3 +1,24 @@\n+2001-07-26  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/util/Calendar.java (set): Never recompute fields here. They \n+\twill already be set if someone set time explicitly, and it can cause\n+\tproblems to do so. Don't invalidate AM_PM setting if HOUR is set.\n+\t* java/util/GregorianCalendar.java (computeTime): Don't ignore an\n+\tHOUR setting if AM_PM is set. Don't try to ensure the HOUR value is \n+\tsane.\n+\t* java/text/SimpleDateFormat.java (defaultCentury): New field.\n+\t(readObject): Call set2DigitYearStart if appropriate so that \n+\tdefaultCentury is calculated.\n+\t(SimpleDateFormat): Don't bother clearing calendar here. Call\n+\tcomputeCenturyStart().\n+\t(set2DigitYearStart): Calculate and set defaultCentury.\n+\t(format): Don't clone the calendar. Use \"calendar\" not \"theCalendar\"\n+\teverywhere.\n+\t(parse): Likewise. If the pattern is \"y\" or \"yy\" and it found exactly\n+\t2 numeric digits, use the 80-20 heuristic to parse the value into a\n+\tdefault century based on defaultCenturyStart.\n+\t(computeCenturyStart): Rewritten. Call set2DigitYearStart().\n+\n 2001-07-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "8d914fb3ebfea986a81f2001c741763da4991a97", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 80, "deletions": 63, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "patch": "@@ -62,7 +62,8 @@ public FieldSizePair(int f, int s) {\n \n   private transient Vector tokens;\n   private DateFormatSymbols formatData;  // formatData\n-  private Date defaultCenturyStart = computeCenturyStart ();\n+  private Date defaultCenturyStart;\n+  private transient int defaultCentury;\n   private String pattern;\n   private int serialVersionOnStream = 1; // 0 indicates JDK1.1.3 or earlier\n   private static final long serialVersionUID = 4774881970558875024L;\n@@ -78,9 +79,12 @@ private void readObject(ObjectInputStream stream)\n     stream.defaultReadObject();\n     if (serialVersionOnStream < 1)\n       {\n-        defaultCenturyStart = computeCenturyStart ();\n+        computeCenturyStart ();\n \tserialVersionOnStream = 1;\n       }\n+    else\n+      // Ensure that defaultCentury gets set.\n+      set2DigitYearStart(defaultCenturyStart);\n \n     // Set up items normally taken care of by the constructor.\n     tokens = new Vector();\n@@ -159,7 +163,7 @@ public SimpleDateFormat()\n     super();\n     Locale locale = Locale.getDefault();\n     calendar = new GregorianCalendar(locale);\n-    calendar.clear ();\n+    computeCenturyStart();\n     tokens = new Vector();\n     formatData = new DateFormatSymbols(locale);\n     pattern = (formatData.dateFormats[DEFAULT] + ' '\n@@ -186,7 +190,7 @@ public SimpleDateFormat(String pattern, Locale locale)\n   {\n     super();\n     calendar = new GregorianCalendar(locale);\n-    calendar.clear ();\n+    computeCenturyStart();\n     tokens = new Vector();\n     formatData = new DateFormatSymbols(locale);\n     compileFormat(pattern);\n@@ -203,10 +207,6 @@ public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n   {\n     super();\n     calendar = new GregorianCalendar();\n-    calendar.clear ();\n-    // FIXME: XXX: Is it really necessary to set the timezone?\n-    // The Calendar constructor is supposed to take care of this.\n-    calendar.setTimeZone(TimeZone.getDefault());\n     tokens = new Vector();\n     this.formatData = formatData;\n     compileFormat(pattern);\n@@ -309,6 +309,10 @@ public Date get2DigitYearStart()\n   public void set2DigitYearStart(Date date)\n   {\n     defaultCenturyStart = date;\n+    calendar.clear();\n+    calendar.setTime(date);\n+    int year = calendar.get(Calendar.YEAR);\n+    defaultCentury = year - (year % 100);\n   }\n \n   /**\n@@ -386,8 +390,7 @@ public boolean equals(Object o)\n   public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n   {\n     String temp;\n-    Calendar theCalendar = (Calendar) calendar.clone();\n-    theCalendar.setTime(date);\n+    calendar.setTime(date);\n     \n     // go through vector, filling in fields where applicable, else toString\n     Enumeration e = tokens.elements();\n@@ -398,71 +401,71 @@ public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n \tint beginIndex = buffer.length();\n \tswitch (p.field) {\n \tcase ERA_FIELD:\n-\t  buffer.append(formatData.eras[theCalendar.get(Calendar.ERA)]);\n+\t  buffer.append(formatData.eras[calendar.get(Calendar.ERA)]);\n \t  break;\n \tcase YEAR_FIELD:\n-\t  temp = String.valueOf(theCalendar.get(Calendar.YEAR));\n+\t  temp = String.valueOf(calendar.get(Calendar.YEAR));\n \t  if (p.size < 4)\n \t    buffer.append(temp.substring(temp.length()-2));\n \t  else\n \t    buffer.append(temp);\n \t  break;\n \tcase MONTH_FIELD:\n \t  if (p.size < 3)\n-\t    withLeadingZeros(theCalendar.get(Calendar.MONTH)+1,p.size,buffer);\n+\t    withLeadingZeros(calendar.get(Calendar.MONTH)+1,p.size,buffer);\n \t  else if (p.size < 4)\n-\t    buffer.append(formatData.shortMonths[theCalendar.get(Calendar.MONTH)]);\n+\t    buffer.append(formatData.shortMonths[calendar.get(Calendar.MONTH)]);\n \t  else\n-\t    buffer.append(formatData.months[theCalendar.get(Calendar.MONTH)]);\n+\t    buffer.append(formatData.months[calendar.get(Calendar.MONTH)]);\n \t  break;\n \tcase DATE_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.DATE),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.DATE),p.size,buffer);\n \t  break;\n \tcase HOUR_OF_DAY1_FIELD: // 1-24\n-\t  withLeadingZeros(((theCalendar.get(Calendar.HOUR_OF_DAY)+23)%24)+1,p.size,buffer);\n+\t  withLeadingZeros(((calendar.get(Calendar.HOUR_OF_DAY)+23)%24)+1,p.size,buffer);\n \t  break;\n \tcase HOUR_OF_DAY0_FIELD: // 0-23\n-\t  withLeadingZeros(theCalendar.get(Calendar.HOUR_OF_DAY),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.HOUR_OF_DAY),p.size,buffer);\n \t  break;\n \tcase MINUTE_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.MINUTE),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.MINUTE),p.size,buffer);\n \t  break;\n \tcase SECOND_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.SECOND),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.SECOND),p.size,buffer);\n \t  break;\n \tcase MILLISECOND_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.MILLISECOND),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.MILLISECOND),p.size,buffer);\n \t  break;\n \tcase DAY_OF_WEEK_FIELD:\n \t  if (p.size < 4)\n-\t    buffer.append(formatData.shortWeekdays[theCalendar.get(Calendar.DAY_OF_WEEK)]);\n+\t    buffer.append(formatData.shortWeekdays[calendar.get(Calendar.DAY_OF_WEEK)]);\n \t  else\n-\t    buffer.append(formatData.weekdays[theCalendar.get(Calendar.DAY_OF_WEEK)]);\n+\t    buffer.append(formatData.weekdays[calendar.get(Calendar.DAY_OF_WEEK)]);\n \t  break;\n \tcase DAY_OF_YEAR_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.DAY_OF_YEAR),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.DAY_OF_YEAR),p.size,buffer);\n \t  break;\n \tcase DAY_OF_WEEK_IN_MONTH_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.DAY_OF_WEEK_IN_MONTH),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH),p.size,buffer);\n \t  break;\n \tcase WEEK_OF_YEAR_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.WEEK_OF_YEAR),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.WEEK_OF_YEAR),p.size,buffer);\n \t  break;\n \tcase WEEK_OF_MONTH_FIELD:\n-\t  withLeadingZeros(theCalendar.get(Calendar.WEEK_OF_MONTH),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.WEEK_OF_MONTH),p.size,buffer);\n \t  break;\n \tcase AM_PM_FIELD:\n-\t  buffer.append(formatData.ampms[theCalendar.get(Calendar.AM_PM)]);\n+\t  buffer.append(formatData.ampms[calendar.get(Calendar.AM_PM)]);\n \t  break;\n \tcase HOUR1_FIELD: // 1-12\n-\t  withLeadingZeros(((theCalendar.get(Calendar.HOUR)+11)%12)+1,p.size,buffer);\n+\t  withLeadingZeros(((calendar.get(Calendar.HOUR)+11)%12)+1,p.size,buffer);\n \t  break;\n \tcase HOUR0_FIELD: // 0-11\n-\t  withLeadingZeros(theCalendar.get(Calendar.HOUR),p.size,buffer);\n+\t  withLeadingZeros(calendar.get(Calendar.HOUR),p.size,buffer);\n \t  break;\n \tcase TIMEZONE_FIELD:\n-\t  TimeZone zone = theCalendar.getTimeZone();\n-\t  boolean isDST = theCalendar.get(Calendar.DST_OFFSET) != 0;\n+\t  TimeZone zone = calendar.getTimeZone();\n+\t  boolean isDST = calendar.get(Calendar.DST_OFFSET) != 0;\n \t  // FIXME: XXX: This should be a localized time zone.\n \t  String zoneID = zone.getDisplayName(isDST, p.size > 3 ? TimeZone.LONG : TimeZone.SHORT);\n \t  buffer.append(zoneID);\n@@ -482,7 +485,8 @@ else if (p.size < 4)\n     return buffer;\n   }\n \n-  private void withLeadingZeros(int value, int length, StringBuffer buffer) {\n+  private void withLeadingZeros(int value, int length, StringBuffer buffer) \n+  {\n     String valStr = String.valueOf(value);\n     for (length -= valStr.length(); length > 0; length--)\n       buffer.append('0');\n@@ -514,12 +518,10 @@ public Date parse (String dateStr, ParsePosition pos)\n     int fmt_index = 0;\n     int fmt_max = pattern.length();\n \n-    // We copy the Calendar because if we don't we will modify it and\n-    // then this.equals() will no longer have the desired result.\n-    Calendar theCalendar = (Calendar) calendar.clone ();\n-    theCalendar.clear();\n+    calendar.clear();\n     boolean saw_timezone = false;\n     int quote_start = -1;\n+    boolean is2DigitYear = false;\n     for (; fmt_index < fmt_max; ++fmt_index)\n       {\n \tchar ch = pattern.charAt(fmt_index);\n@@ -552,7 +554,7 @@ public Date parse (String dateStr, ParsePosition pos)\n \tint first = fmt_index;\n \twhile (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n \t  ;\n-\tint count = fmt_index - first;\n+\tint fmt_count = fmt_index - first;\n \t--fmt_index;\n \n \t// We can handle most fields automatically: most either are\n@@ -564,6 +566,7 @@ public Date parse (String dateStr, ParsePosition pos)\n \tboolean is_numeric = true;\n \tString[] match = null;\n \tint offset = 0;\n+\tboolean maybe2DigitYear = false;\n \tswitch (ch)\n \t  {\n \t  case 'd':\n@@ -579,7 +582,7 @@ public Date parse (String dateStr, ParsePosition pos)\n \t    is_numeric = false;\n \t    offset = 1;\n \t    calendar_field = Calendar.DAY_OF_WEEK;\n-\t    match = (count <= 3\n+\t    match = (fmt_count <= 3\n \t\t     ? formatData.getShortWeekdays()\n \t\t     : formatData.getWeekdays());\n \t    break;\n@@ -591,20 +594,20 @@ public Date parse (String dateStr, ParsePosition pos)\n \t    break;\n \t  case 'M':\n \t    calendar_field = Calendar.MONTH;\n-\t    if (count <= 2)\n+\t    if (fmt_count <= 2)\n \t      offset = -1;\n \t    else\n \t      {\n \t\tis_numeric = false;\n-\t\tmatch = (count <= 3\n+\t\tmatch = (fmt_count <= 3\n \t\t\t ? formatData.getShortMonths()\n \t\t\t : formatData.getMonths());\n \t      }\n \t    break;\n \t  case 'y':\n \t    calendar_field = Calendar.YEAR;\n-\t    if (count <= 2)\n-\t      offset = 1900;\n+\t    if (fmt_count <= 2)\n+\t      maybe2DigitYear = true;\n \t    break;\n \t  case 'K':\n \t    calendar_field = Calendar.HOUR;\n@@ -655,8 +658,8 @@ public Date parse (String dateStr, ParsePosition pos)\n \t\t    found_zone = true;\n \t\t    saw_timezone = true;\n \t\t    TimeZone tz = TimeZone.getTimeZone (strings[0]);\n-\t\t    theCalendar.setTimeZone (tz);\n-\t\t    theCalendar.set (Calendar.ZONE_OFFSET, tz.getRawOffset ());\n+\t\t    calendar.setTimeZone (tz);\n+\t\t    calendar.set (Calendar.ZONE_OFFSET, tz.getRawOffset ());\n \t\t    offset = 0;\n \t\t    if (k > 2 && tz instanceof SimpleTimeZone)\n \t\t      {\n@@ -680,17 +683,20 @@ public Date parse (String dateStr, ParsePosition pos)\n \n \t// Compute the value we should assign to the field.\n \tint value;\n+\tint index = -1;\n \tif (is_numeric)\n \t  {\n-\t    numberFormat.setMinimumIntegerDigits(count);\n+\t    numberFormat.setMinimumIntegerDigits(fmt_count);\n+\t    if (maybe2DigitYear)\n+\t      index = pos.getIndex();\n \t    Number n = numberFormat.parse(dateStr, pos);\n \t    if (pos == null || ! (n instanceof Long))\n \t      return null;\n \t    value = n.intValue() + offset;\n \t  }\n \telse if (match != null)\n \t  {\n-\t    int index = pos.getIndex();\n+\t    index = pos.getIndex();\n \t    int i;\n \t    for (i = offset; i < match.length; ++i)\n \t      {\n@@ -707,9 +713,28 @@ else if (match != null)\n \t  }\n \telse\n \t  value = offset;\n+\t  \n+\tif (maybe2DigitYear)\n+\t  {\n+\t    // Parse into default century if the numeric year string has \n+\t    // exactly 2 digits.\n+\t    int digit_count = pos.getIndex() - index;\n+\t    if (digit_count == 2)\n+\t      is2DigitYear = true;\n+\t  }\n \n \t// Assign the value and move on.\n-\ttheCalendar.set(calendar_field, value);\n+\tcalendar.set(calendar_field, value);\n+      }\n+    \n+    if (is2DigitYear)\n+      {\n+\t// Apply the 80-20 heuristic to dermine the full year based on \n+\t// defaultCenturyStart. \n+\tint year = defaultCentury + calendar.get(Calendar.YEAR);\n+\tcalendar.set(Calendar.YEAR, year);\n+\tif (calendar.getTime().compareTo(defaultCenturyStart) < 0)\n+\t  calendar.set(Calendar.YEAR, year + 100);      \n       }\n \n     try\n@@ -718,10 +743,10 @@ else if (match != null)\n \t  {\n \t    // Use the real rules to determine whether or not this\n \t    // particular time is in daylight savings.\n-\t    theCalendar.clear (Calendar.DST_OFFSET);\n-\t    theCalendar.clear (Calendar.ZONE_OFFSET);\n+\t    calendar.clear (Calendar.DST_OFFSET);\n+\t    calendar.clear (Calendar.ZONE_OFFSET);\n \t  }\n-        return theCalendar.getTime();\n+        return calendar.getTime();\n       }\n     catch (IllegalArgumentException x)\n       {\n@@ -732,18 +757,10 @@ else if (match != null)\n \n   // Compute the start of the current century as defined by\n   // get2DigitYearStart.\n-  private Date computeCenturyStart ()\n+  private void computeCenturyStart()\n   {\n-    // Compute the current year.  We assume a year has 365 days.  Then\n-    // compute 80 years ago, and finally reconstruct the number of\n-    // milliseconds.  We do this computation in this strange way\n-    // because it lets us easily truncate the milliseconds, seconds,\n-    // etc, which don't matter and which confuse\n-    // SimpleDateFormat.equals().\n-    long now = System.currentTimeMillis ();\n-    now /= 365L * 24L * 60L * 60L * 1000L;\n-    now -= 80;\n-    now *= 365L * 24L * 60L * 60L * 1000L;\n-    return new Date (now);\n+    int year = calendar.get(Calendar.YEAR);\n+    calendar.set(Calendar.YEAR, year - 80);\n+    set2DigitYearStart(calendar.getTime());\n   }\n }"}, {"sha": "81494112533038d95ea1fcc77fcb7b0d4a1605e9", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "patch": "@@ -549,8 +549,6 @@ protected final int internalGet(int field)\n    */\n   public final void set(int field, int value)\n   {\n-    if (!areFieldsSet)\n-      computeFields();\n     isTimeSet = false;\n     fields[field] = value;\n     isSet[field] = true;\n@@ -573,7 +571,6 @@ public final void set(int field, int value)\n \tisSet[HOUR] = false;\n \tbreak;\n       case HOUR:\n-\tisSet[AM_PM] = false;\n \tisSet[HOUR_OF_DAY] = false;\n \tbreak;\n       }\n@@ -587,8 +584,6 @@ public final void set(int field, int value)\n    */\n   public final void set(int year, int month, int date)\n   {\n-    if (!areFieldsSet)\n-      computeFields();\n     isTimeSet = false;\n     fields[YEAR] = year;\n     fields[MONTH] = month;"}, {"sha": "2c68907bac4a82f03d2218d19e8035aa6f27e25e", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa397ddafb335eb0a67b08e014605bf5f9ab7cc5/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=fa397ddafb335eb0a67b08e014605bf5f9ab7cc5", "patch": "@@ -373,9 +373,17 @@ protected synchronized void computeTime()\n       year = 1 - year;\n \n     int[] daysOfYear = getDayOfYear(year);\n-    int hour = isSet[HOUR_OF_DAY] ? fields[HOUR_OF_DAY]\n-      : (isSet[HOUR] && isSet[AM_PM]\n-\t ? fields[AM_PM] * 12 + (fields[HOUR] % 12) : 0);\n+\n+    int hour = 0;\n+    if (isSet[HOUR_OF_DAY])\n+      hour = fields[HOUR_OF_DAY];\n+    else if (isSet[HOUR])\n+      {\n+\thour = fields[HOUR];\n+        if (isSet[AM_PM] && fields[AM_PM] == PM)\n+\t  hour += 12;\n+      }\n+\n     int minute = isSet[MINUTE] ? fields[MINUTE] : 0;\n     int second = isSet[SECOND] ? fields[SECOND] : 0;\n     int millis = isSet[MILLISECOND] ? fields[MILLISECOND] : 0;"}]}