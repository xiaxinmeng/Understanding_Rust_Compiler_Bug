{"sha": "da557ab84661f8906af7f8b55a8a4e68f4176258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1NTdhYjg0NjYxZjg5MDZhZjdmOGI1NWE4YTRlNjhmNDE3NjI1OA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-31T10:15:48Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-31T10:15:48Z"}, "message": "2003-03-31  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/File.java\n\t(separator): Merged documentation from classpath.\n\t(separatorChar): Merged documentation from classpath.\n\t(pathSeparator): Merged documentation from classpath.\n\t(pathSeparatorChar): Merged documentation from classpath.\n\t(path): Merged documentation from classpath.\n\t(canRead): Merged documentation from classpath.\n\t(canWrite): Merged documentation from classpath.\n\t(createNewFile): Merged documentation from classpath.\n\t(delete): Merged documentation from classpath.\n\t(equals): Merged documentation from classpath.\n\t(exists): Merged documentation from classpath.\n\t(File): Renamed p to name to match classpath, merged documentation\n\tfrom classpath.\n\t(getAbsolutePath): Merged documentation from classpath.\n\t(getCanonicalPath): Merged documentation from classpath.\n\t(getCanonicalFile): Merged documentation from classpath.\n\t(getName): Merged documentation from classpath.\n\t(getParent): Merged documentation from classpath.\n\t(getParentFile): Merged documentation from classpath.\n\t(getPath): Merged documentation from classpath.\n\t(hashCode): Merged documentation from classpath.\n\t(isAbsolute): Merged documentation from classpath.\n\t(isDirectory): Merged documentation from classpath.\n\t(isFile): Merged documentation from classpath.\n\t(isHidden): Merged documentation from classpath.\n\t(lastModified): Merged documentation from classpath.\n\t(length): Merged documentation from classpath.\n\t(list): Merged documentation from classpath.\n\t(listFiles): Merged documentation from classpath.\n\t(toString): Merged documentation from classpath.\n\t(toURL): Merged documentation from classpath.\n\t(mkdir): Merged documentation from classpath.\n\t(mkdirs): Merged documentation from classpath.\n\t(createTempFile): Merged documentation from classpath.\n\t(setReadOnly): Merged documentation from classpath.\n\t(listRoots): Merged documentation from classpath.\n\t(compareTo): Merged documentation from classpath.\n\t(renameTo): Merged documentation from classpath.\n\t(setLastModified): Merged documentation from classpath.\n\t* java/io/PrintStream.java\n\t(auto_flush): Merged documentation from classpath.\n\t(PrintStream): Merged documentation from classpath.\n\t(checkError): Merged documentation from classpath.\n\t(setError): Merged documentation from classpath.\n\t(close): Merged documentation from classpath.\n\t(flush): Merged documentation from classpath.\n\t(print): Merged documentation from classpath.\n\t(println):  Merged documentation from classpath.\n\t(write): Renamed count to len to match classpath,\n\tmerged documentation from classpath.\n\t* java/io/RandomAccessFile.java\n\t(readShort): Merged documentation from classpath.\n\t(readUnsignedByte): Merged documentation from classpath.\n\t(readUnsignedShort): Merged documentation from classpath.\n\t(readUTF): Merged documentation from classpath.\n\t(seek): Reformatted, merged documentation from classpath.\n\t(skipBytes): Renamed some variables to match classpath, reformatted,\n\tmerged documentation from classpath.\n\t(write): Merged documentation from classpath.\n\t(writeBoolean): Merged documentation from classpath.\n\t(writeByte): Merged documentation from classpath.\n\t(writeShort): Merged documentation from classpath.\n\t(writeChar): Merged documentation from classpath.\n\t(writeInt): Merged documentation from classpath.\n\t(writeLong): Merged documentation from classpath.\n\t(writeFloat): Merged documentation from classpath.\n\t(writeDouble): Merged documentation from classpath.\n\t(writeBytes): Merged documentation from classpath.\n\t(writeChars): Merged documentation from classpath.\n\t(writeUTF): Reformatted.\n\t(getChannel): Reformatted.\n\nFrom-SVN: r65081", "tree": {"sha": "ea7df3d001361fb6531733b2f5dc547f932c0320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea7df3d001361fb6531733b2f5dc547f932c0320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da557ab84661f8906af7f8b55a8a4e68f4176258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da557ab84661f8906af7f8b55a8a4e68f4176258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da557ab84661f8906af7f8b55a8a4e68f4176258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da557ab84661f8906af7f8b55a8a4e68f4176258/comments", "author": null, "committer": null, "parents": [{"sha": "c32130d9d28a4a4d4ffef46b2f87305cd8efafa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c32130d9d28a4a4d4ffef46b2f87305cd8efafa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c32130d9d28a4a4d4ffef46b2f87305cd8efafa1"}], "stats": {"total": 1236, "additions": 1175, "deletions": 61}, "files": [{"sha": "b1311744d5c5e75be05f4d7af61a20f6502eec4c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=da557ab84661f8906af7f8b55a8a4e68f4176258", "patch": "@@ -1,3 +1,78 @@\n+2003-03-31  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/File.java\n+\t(separator): Merged documentation from classpath.\n+\t(separatorChar): Merged documentation from classpath.\n+\t(pathSeparator): Merged documentation from classpath.\n+\t(pathSeparatorChar): Merged documentation from classpath.\n+\t(path): Merged documentation from classpath.\n+\t(canRead): Merged documentation from classpath.\n+\t(canWrite): Merged documentation from classpath.\n+\t(createNewFile): Merged documentation from classpath.\n+\t(delete): Merged documentation from classpath.\n+\t(equals): Merged documentation from classpath.\n+\t(exists): Merged documentation from classpath.\n+\t(File): Renamed p to name to match classpath, merged documentation\n+\tfrom classpath.\n+\t(getAbsolutePath): Merged documentation from classpath.\n+\t(getCanonicalPath): Merged documentation from classpath.\n+\t(getCanonicalFile): Merged documentation from classpath.\n+\t(getName): Merged documentation from classpath.\n+\t(getParent): Merged documentation from classpath.\n+\t(getParentFile): Merged documentation from classpath.\n+\t(getPath): Merged documentation from classpath.\n+\t(hashCode): Merged documentation from classpath.\n+\t(isAbsolute): Merged documentation from classpath.\n+\t(isDirectory): Merged documentation from classpath.\n+\t(isFile): Merged documentation from classpath.\n+\t(isHidden): Merged documentation from classpath.\n+\t(lastModified): Merged documentation from classpath.\n+\t(length): Merged documentation from classpath.\n+\t(list): Merged documentation from classpath.\n+\t(listFiles): Merged documentation from classpath.\n+\t(toString): Merged documentation from classpath.\n+\t(toURL): Merged documentation from classpath.\n+\t(mkdir): Merged documentation from classpath.\n+\t(mkdirs): Merged documentation from classpath.\n+\t(createTempFile): Merged documentation from classpath.\n+\t(setReadOnly): Merged documentation from classpath.\n+\t(listRoots): Merged documentation from classpath.\n+\t(compareTo): Merged documentation from classpath.\n+\t(renameTo): Merged documentation from classpath.\n+\t(setLastModified): Merged documentation from classpath.\n+\t* java/io/PrintStream.java\n+\t(auto_flush): Merged documentation from classpath.\n+\t(PrintStream): Merged documentation from classpath.\n+\t(checkError): Merged documentation from classpath.\n+\t(setError): Merged documentation from classpath.\n+\t(close): Merged documentation from classpath.\n+\t(flush): Merged documentation from classpath.\n+\t(print): Merged documentation from classpath.\n+\t(println):  Merged documentation from classpath.\n+\t(write): Renamed count to len to match classpath,\n+\tmerged documentation from classpath.\n+\t* java/io/RandomAccessFile.java\n+\t(readShort): Merged documentation from classpath.\n+\t(readUnsignedByte): Merged documentation from classpath.\n+\t(readUnsignedShort): Merged documentation from classpath.\n+\t(readUTF): Merged documentation from classpath.\n+\t(seek): Reformatted, merged documentation from classpath.\n+\t(skipBytes): Renamed some variables to match classpath, reformatted,\n+\tmerged documentation from classpath.\n+\t(write): Merged documentation from classpath.\n+\t(writeBoolean): Merged documentation from classpath.\n+\t(writeByte): Merged documentation from classpath.\n+\t(writeShort): Merged documentation from classpath.\n+\t(writeChar): Merged documentation from classpath.\n+\t(writeInt): Merged documentation from classpath.\n+\t(writeLong): Merged documentation from classpath.\n+\t(writeFloat): Merged documentation from classpath.\n+\t(writeDouble): Merged documentation from classpath.\n+\t(writeBytes): Merged documentation from classpath.\n+\t(writeChars): Merged documentation from classpath.\n+\t(writeUTF): Reformatted.\n+\t(getChannel): Reformatted.\n+\n 2003-03-31  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/font/TextAttribute.java"}, {"sha": "83e4c2e800d8ceea69df3c14ec323c9ea50425fa", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 595, "deletions": 47, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=da557ab84661f8906af7f8b55a8a4e68f4176258", "patch": "@@ -81,12 +81,94 @@ public class File implements Serializable, Comparable\n   private final native boolean _access (int query);\n   private final native boolean _stat (int query);\n \n+  /**\n+   * This is the path separator string for the current host. This field\n+   * contains the value of the <code>file.separator</code> system property.\n+   * An example separator string would be \"/\" on the GNU system.\n+   */\n+  public static final String separator = System.getProperty(\"file.separator\");\n+\n+  /**\n+   * This is the first character of the file separator string.  On many\n+   * hosts (for example, on the GNU system), this represents the entire \n+   * separator string.  The complete separator string is obtained from the\n+   * <code>file.separator</code>system property.\n+   */\n+  public static final char separatorChar = separator.charAt(0);\n+  \n+  /**\n+   * This is the string that is used to separate the host name from the\n+   * path name in paths than include the host name.  It is the value of\n+   * the <code>path.separator</code> system property.\n+   */\n+  public static final String pathSeparator\n+    = System.getProperty(\"path.separator\");\n+  \n+  /**\n+   * This is the first character of the string used to separate the host name\n+   * from the path name in paths that include a host.  The separator string\n+   * is taken from the <code>path.separator</code> system property.\n+   */\n+  public static final char pathSeparatorChar = pathSeparator.charAt(0);\n+  \n+\n+  static final String tmpdir = System.getProperty(\"java.io.tmpdir\");\n+  static int maxPathLen;\n+  static boolean caseSensitive;\n+  static String dupSeparator = separator + separator;\n+  \n+  static\n+  {\n+    init_native();\n+  }\n+  \n+  // Native function called at class initialization. This should should\n+  // set the maxPathLen and caseSensitive variables.\n+  private static native void init_native();\n+\n+  /**\n+   * This is the path to the file set when the object is created.  It\n+   * may be an absolute or relative path name.\n+   */\n+  private String path;\n+\n+  // We keep a counter for use by createTempFile.  We choose the first\n+  // value randomly to try to avoid clashes with other VMs.\n+  private static long counter = Double.doubleToLongBits (Math.random ());\n+\n+  /**\n+   * This method tests whether or not the current thread is allowed to\n+   * to read the file pointed to by this object.  This will be true if and\n+   * and only if 1) the file exists and 2) the <code>SecurityManager</code>\n+   * (if any) allows access to the file via it's <code>checkRead</code>\n+   * method 3) the file is readable.\n+   *\n+   * @return <code>true</code> if reading is allowed, \n+   * <code>false</code> otherwise\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> \n+   * does not allow access to the file\n+   */\n   public boolean canRead ()\n   {\n     checkRead();\n     return _access (READ);\n   }\n \n+  /**\n+   * This method test whether or not the current thread is allowed to\n+   * write to this object.  This will be true if and only if 1) The\n+   * <code>SecurityManager</code> (if any) allows write access to the\n+   * file and 2) The file exists and 3) The file is writable.  To determine\n+   * whether or not a non-existent file can be created, check the parent\n+   * directory for write access.\n+   *\n+   * @return <code>true</code> if writing is allowed, <code>false</code> \n+   * otherwise\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> \n+   * does not allow access to the file\n+   */\n   public boolean canWrite ()\n   {\n     checkWrite();\n@@ -95,14 +177,40 @@ public boolean canWrite ()\n   \n   private native boolean performCreate() throws IOException;\n \n-  /** @since 1.2 */\n+  /**\n+   * This method creates a new file of zero length with the same name as\n+   * the path of this <code>File</code> object if an only if that file\n+   * does not already exist.\n+   * <p>\n+   * A <code>SecurityManager</code>checkWrite</code> check is done prior\n+   * to performing this action.\n+   *\n+   * @return <code>true</code> if the file was created, <code>false</code> if\n+   * the file alread existed.\n+   *\n+   * @exception IOException If an I/O error occurs\n+   * @exception SecurityException If the <code>SecurityManager</code> will\n+   * not allow this operation to be performed.\n+   *\n+   * @since 1.2\n+   */\n   public boolean createNewFile() throws IOException\n   {\n     checkWrite();\n     return performCreate();\n   }\n   \n   private native boolean performDelete ();\n+\n+  /**\n+   * This method deletes the file represented by this object.  If this file\n+   * is a directory, it must be empty in order for the delete to succeed.\n+   *\n+   * @return <code>true</code> if the file was deleted, <code>false</code> \n+   * otherwise\n+   *\n+   * @exception SecurityException If deleting of the file is not allowed\n+   */\n   public boolean delete ()\n   {\n     SecurityManager s = System.getSecurityManager();\n@@ -112,6 +220,21 @@ public boolean delete ()\n     return performDelete ();\n   }\n \n+  /**\n+   * This method tests two <code>File</code> objects for equality by \n+   * comparing the path of the specified <code>File</code> against the path\n+   * of this object.  The two objects are equal if an only if 1) The\n+   * argument is not null 2) The argument is a <code>File</code> object and\n+   * 3) The path of the <code>File</code>argument is equal to the path\n+   * of this object.\n+   * <p>\n+   * The paths of the files are determined by calling the \n+   * <code>getPath()</code>\n+   * method on each object.\n+   *\n+   * @return <code>true</code> if the two objects are equal, \n+   * <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof File))\n@@ -123,15 +246,29 @@ public boolean equals (Object obj)\n       return (path.equalsIgnoreCase(other.path));      \n   }\n \n+  /**\n+   * This method tests whether or not the file represented by the object\n+   * actually exists on the filesystem.\n+   *\n+   * @return <code>true</code> if the file exists, <code>false</code>otherwise.\n+   *\n+   * @exception SecurityException If reading of the file is not permitted\n+   */\n   public boolean exists ()\n   {\n     checkRead();\n     return _access (EXISTS);\n   }\n \n-  public File (String p)\n+  /**\n+   * This method initializes a new <code>File</code> object to represent\n+   * a file with the specified path.\n+   *\n+   * @param name The path name of the file\n+   */\n+  public File (String name)\n   {\n-    path = normalizePath(p);\n+    path = normalizePath (name);\n   }\n \n   // Remove duplicate and redundant separator characters.\n@@ -195,7 +332,17 @@ private String normalizePath(String p)\n     \n     return newpath.toString();\n   }\n-  \n+ \n+  /**\n+   * This method initializes a new <code>File</code> object to represent\n+   * a file in the specified named directory.  The path name to the file\n+   * will be the directory name plus the separator string plus the file\n+   * name.  If the directory path name ends in the separator string, another\n+   * separator string will still be appended.\n+   *\n+   * @param dirname The path to the directory the file resides in\n+   * @param name The name of the file\n+   */\n   public File (String dirPath, String name)\n   {\n     if (name == null)\n@@ -213,11 +360,30 @@ public File (String dirPath, String name)\n       path = normalizePath(name);\n   }\n \n-  public File (File dir, String name)\n+  /**\n+   * This method initializes a new <code>File</code> object to represent\n+   * a file in the specified directory.  If the <code>directory</code>\n+   * argument is <code>null</code>, the file is assumed to be in the\n+   * current directory as specified by the <code>user.dir</code> system\n+   * property\n+   *\n+   * @param directory The directory this file resides in\n+   * @param name The name of the file\n+   */\n+  public File (File directory, String name)\n   {\n-    this (dir == null ? null : dir.path, name);\n+    this (directory == null ? null : directory.path, name);\n   }\n \n+  /**\n+   * This method returns the path of this file as an absolute path name.\n+   * If the path name is already absolute, then it is returned.  Otherwise\n+   * the value returned is the current directory plus the separatory\n+   * string plus the path of the file.  The current directory is determined\n+   * from the <code>user.dir</code> system property.\n+   *\n+   * @return The absolute path of this file\n+   */\n   public String getAbsolutePath ()\n   {\n     if (isAbsolute ())\n@@ -234,26 +400,70 @@ else if (separatorChar == '\\\\'\n       return System.getProperty (\"user.dir\") + separatorChar + path;\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method returns a <code>File</code> object representing the\n+   * absolute path of this object.\n+   *\n+   * @return A <code>File</code> with the absolute path of the object.\n+   *\n+   * @since 1.2\n+   */\n   public File getAbsoluteFile ()\n   {\n     return new File (getAbsolutePath());\n   }\n \n+  /**\n+   * This method returns a canonical representation of the pathname of\n+   * this file.  The actual form of the canonical representation is\n+   * different.  On the GNU system, the canonical form differs from the\n+   * absolute form in that all relative file references to \".\" and \"..\"\n+   * are resolved and removed.\n+   * <p>\n+   * Note that this method, unlike the other methods which return path\n+   * names, can throw an IOException.  This is because native method \n+   * might be required in order to resolve the canonical path\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public native String getCanonicalPath () throws IOException;\n \n-  /** @since 1.2 */\n+  /**\n+   * This method returns a <code>File</code> object representing the\n+   * canonical path of this object.\n+   *\n+   * @return A <code>File</code> instance representing the canonical path of\n+   * this object.\n+   *\n+   * @exception IOException If an error occurs.\n+   *\n+   * @since 1.2\n+   */\n   public File getCanonicalFile () throws IOException\n   {\n     return new File (getCanonicalPath());\n   }\n \n+  /**\n+   * This method returns the name of the file.  This is everything in the\n+   * complete path of the file after the last instance of the separator\n+   * string.\n+   *\n+   * @return The file name\n+   */\n   public String getName ()\n   {\n     int last = path.lastIndexOf(separatorChar);\n     return path.substring(last + 1);\n   }\n \n+  /**\n+   * This method returns a <code>String</code> the represents this file's\n+   * parent.  <code>null</code> is returned if the file has no parent.  The\n+   * parent is determined via a simple operation which removes the\n+   *\n+   * @return The parent directory of this file\n+   */\n   public String getParent ()\n   {\n     int last = path.lastIndexOf(separatorChar);\n@@ -265,18 +475,40 @@ public String getParent ()\n     return path.substring(0, last);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method returns a <code>File</code> object representing the parent\n+   * file of this one.\n+   *\n+   * @param A <code>File</code> for the parent of this object.  \n+   * <code>null</code>\n+   * will be returned if this object does not have a parent.\n+   *\n+   * @since 1.2\n+   */\n   public File getParentFile ()\n   {\n     String parent = getParent ();\n     return (parent == null ? null : new File (parent));\n   }\n \n+  /**\n+   * Returns the path name that represents this file.  May be a relative\n+   * or an absolute path name\n+   *\n+   * @return The pathname of this file\n+   */\n   public String getPath ()\n   {\n     return path;\n   }\n \n+  /**\n+   * This method returns a hash code representing this file.  It is the\n+   * hash code of the path of this file (as returned by <code>getPath()</code>)\n+   * exclusived or-ed with the value 1234321.\n+   *\n+   * @return The hash code for this object\n+   */\n   public int hashCode ()\n   {\n     if (caseSensitive)\n@@ -285,33 +517,93 @@ public int hashCode ()\n       return (path.toLowerCase().hashCode() ^ 1234321);\n   }\n \n+  /**\n+   * This method returns true if this object represents an absolute file\n+   * path and false if it does not.  The definition of an absolute path varies\n+   * by system.  As an example, on GNU systems, a path is absolute if it starts\n+   * with a \"/\".\n+   *\n+   * @return <code>true</code> if this object represents an absolute \n+   * file name, <code>false</code> otherwise.\n+   */\n   public native boolean isAbsolute ();\n \n+  /**\n+   * This method tests whether or not the file represented by this object\n+   * is a directory.  In order for this method to return <code>true</code>,\n+   * the file represented by this object must exist and be a directory.\n+   * \n+   * @return <code>true</code> if this file is a directory, <code>false</code>\n+   * otherwise\n+   *\n+   * @exception SecurityException If reading of the file is not permitted\n+   */\n   public boolean isDirectory ()\n   {\n     checkRead();\n     return _stat (DIRECTORY);\n   }\n \n+  /**\n+   * This method tests whether or not the file represented by this object\n+   * is a \"plain\" file.  A file is a plain file if and only if it 1) Exists,\n+   * 2) Is not a directory or other type of special file.\n+   *\n+   * @return <code>true</code> if this is a plain file, <code>false</code> \n+   * otherwise\n+   *\n+   * @exception SecurityException If reading of the file is not permitted\n+   */\n   public boolean isFile ()\n   {\n     checkRead();\n     return _stat (ISFILE);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method tests whether or not this file represents a \"hidden\" file.\n+   * On GNU systems, a file is hidden if its name begins with a \".\"\n+   * character.  Files with these names are traditionally not shown with\n+   * directory listing tools.\n+   *\n+   * @return <code>true</code> if the file is hidden, <code>false</code>\n+   * otherwise.\n+   *\n+   * @since 1.2\n+   */\n   public boolean isHidden()\n   {\n     checkRead();\n     return _stat (ISHIDDEN);\n   }\n \n+  /**\n+   * This method returns the last modification time of this file.  The\n+   * time value returned is an abstract value that should not be interpreted\n+   * as a specified time value.  It is only useful for comparing to other\n+   * such time values returned on the same system.  In that case, the larger\n+   * value indicates a more recent modification time. \n+   * <p>\n+   * If the file does not exist, then a value of 0 is returned.\n+   *\n+   * @return The last modification time of the file\n+   *\n+   * @exception SecurityException If reading of the file is not permitted\n+   */\n   public long lastModified ()\n   {\n     checkRead();\n     return attr (MODIFIED);\n   }\n \n+  /**\n+   * This method returns the length of the file represented by this object,\n+   * or 0 if the specified file does not exist.\n+   *\n+   * @return The length of the file\n+   *\n+   * @exception SecurityException If reading of the file is not permitted\n+   */\n   public long length ()\n   {\n     checkRead();\n@@ -322,44 +614,168 @@ private final native Object[] performList (FilenameFilter filter,\n \t\t\t\t\t     FileFilter fileFilter,\n \t\t\t\t\t     Class result_type);\n \n+  /**\n+   * This method returns a array of <code>String</code>'s representing the\n+   * list of files is then directory represented by this object.  If this\n+   * object represents a non-directory file or a non-existent file, then\n+   * <code>null</code> is returned.  The list of files will not contain\n+   * any names such as \".\" or \"..\" which indicate the current or parent\n+   * directory.  Also, the names are not guaranteed to be sorted.\n+   * <p>\n+   * In this form of the <code>list()</code> method, a filter is specified\n+   * that allows the caller to control which files are returned in the\n+   * list.  The <code>FilenameFilter</code> specified is called for each\n+   * file returned to determine whether or not that file should be included\n+   * in the list.\n+   * <p>\n+   * A <code>SecurityManager</code> check is made prior to reading the\n+   * directory.  If read access to the directory is denied, an exception\n+   * will be thrown.\n+   *\n+   * @param filter An object which will identify files to exclude from \n+   * the directory listing.\n+   *\n+   * @return An array of files in the directory, or <code>null</code> \n+   * if this object does not represent a valid directory.\n+   * \n+   * @exception SecurityException If read access is not allowed to the \n+   * directory by the <code>SecurityManager</code>\n+   */\n   public String[] list (FilenameFilter filter)\n   {\n     checkRead();\n     return (String[]) performList (filter, null, String.class);\n   }\n \n+  /**\n+   * This method returns a array of <code>String</code>'s representing the\n+   * list of files is then directory represented by this object.  If this\n+   * object represents a non-directory file or a non-existent file, then\n+   * <code>null</code> is returned.  The list of files will not contain\n+   * any names such as \".\" or \"..\" which indicate the current or parent\n+   * directory.  Also, the names are not guaranteed to be sorted.\n+   * <p>\n+   * A <code>SecurityManager</code> check is made prior to reading the\n+   * directory.  If read access to the directory is denied, an exception\n+   * will be thrown.\n+   *\n+   * @return An array of files in the directory, or <code>null</code> if \n+   * this object does not represent a valid directory.\n+   * \n+   * @exception SecurityException If read access is not allowed to the \n+   * directory by the <code>SecurityManager</code>\n+   */\n   public String[] list ()\n   {\n     checkRead();\n     return (String[]) performList (null, null, String.class);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method returns an array of <code>File</code> objects representing\n+   * all the files in the directory represented by this object. If this\n+   * object does not represent a directory, <code>null</code> is returned.\n+   * Each of the returned <code>File</code> object is constructed with this\n+   * object as its parent.\n+   * <p>\n+   * A <code>SecurityManager</code> check is made prior to reading the\n+   * directory.  If read access to the directory is denied, an exception\n+   * will be thrown.\n+   *\n+   * @return An array of <code>File</code> objects for this directory.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> denies\n+   * access to this directory.\n+   *\n+   * @since 1.2\n+   */\n   public File[] listFiles()\n   {\n     checkRead();\n     return (File[]) performList (null, null, File.class);\n   }\n   \n-  /** @since 1.2 */\n+  /**\n+   * This method returns an array of <code>File</code> objects representing\n+   * all the files in the directory represented by this object. If this\n+   * object does not represent a directory, <code>null</code> is returned.\n+   * Each of the returned <code>File</code> object is constructed with this\n+   * object as its parent.\n+   * <p> \n+   * In this form of the <code>listFiles()</code> method, a filter is specified\n+   * that allows the caller to control which files are returned in the\n+   * list.  The <code>FilenameFilter</code> specified is called for each\n+   * file returned to determine whether or not that file should be included\n+   * in the list.\n+   * <p>\n+   * A <code>SecurityManager</code> check is made prior to reading the\n+   * directory.  If read access to the directory is denied, an exception\n+   * will be thrown.\n+   *\n+   * @return An array of <code>File</code> objects for this directory.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> denies\n+   * access to this directory.\n+   *\n+   * @since 1.2\n+   */\n   public File[] listFiles(FilenameFilter filter)\n   {\n     checkRead();\n     return (File[]) performList (filter, null, File.class);\n   }\n   \n-  /** @since 1.2 */\n+  /**\n+   * This method returns an array of <code>File</code> objects representing\n+   * all the files in the directory represented by this object. If this\n+   * object does not represent a directory, <code>null</code> is returned.\n+   * Each of the returned <code>File</code> object is constructed with this\n+   * object as its parent.\n+   * <p> \n+   * In this form of the <code>listFiles()</code> method, a filter is specified\n+   * that allows the caller to control which files are returned in the\n+   * list.  The <code>FileFilter</code> specified is called for each\n+   * file returned to determine whether or not that file should be included\n+   * in the list.\n+   * <p>\n+   * A <code>SecurityManager</code> check is made prior to reading the\n+   * directory.  If read access to the directory is denied, an exception\n+   * will be thrown.\n+   *\n+   * @return An array of <code>File</code> objects for this directory.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> denies\n+   * access to this directory.\n+   *\n+   * @since 1.2\n+   */\n   public File[] listFiles(FileFilter filter)\n   {\n     checkRead();\n     return (File[]) performList (null, filter, File.class);\n   }\n \n+  /**\n+   * This method returns a <code>String</code> that is the path name of the\n+   * file as returned by <code>getPath</code>.\n+   *\n+   * @return A <code>String</code> representation of this file\n+   */\n   public String toString ()\n   {\n     return path;\n   }\n \n+  /**\n+   * This method returns a <code>URL</code> with the <code>file:</code>\n+   * protocol that represents this file.  The exact form of this URL is\n+   * system dependent.\n+   *\n+   * @return A <code>URL</code> for this object.\n+   *\n+   * @exception MalformedURLException If the URL cannot be created \n+   * successfully.\n+   */\n   public URL toURL () throws MalformedURLException\n   {\n     // On Win32, Sun's JDK returns URLs of the form \"file:/c:/foo/bar.txt\",\n@@ -374,6 +790,14 @@ public URL toURL () throws MalformedURLException\n \n   private final native boolean performMkdir ();\n \n+  /**\n+   * This method creates a directory for the path represented by this object.\n+   *\n+   * @return <code>true</code> if the directory was created, \n+   * <code>false</code> otherwise\n+   *\n+   * @exception SecurityException If write access is not allowed to this file\n+   */\n   public boolean mkdir ()\n   {\n     checkWrite();\n@@ -396,6 +820,15 @@ private static boolean mkdirs (File x)\n     return x.mkdir();\n   }\n \n+  /**\n+   * This method creates a directory for the path represented by this file.\n+   * It will also create any intervening parent directories if necessary.\n+   *\n+   * @return <code>true</code> if the directory was created, \n+   * <code>false</code> otherwise\n+   *\n+   * @exception SecurityException If write access is not allowed to this file\n+   */\n   public boolean mkdirs ()\n   {\n     checkWrite();\n@@ -409,7 +842,36 @@ private static synchronized String nextValue ()\n     return Long.toString(counter++, Character.MAX_RADIX);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method creates a temporary file in the specified directory.  If \n+   * the directory name is null, then this method uses the system temporary \n+   * directory. The files created are guaranteed not to currently exist and \n+   * the same file name will never be used twice in the same virtual \n+   * machine instance.  \n+   * The system temporary directory is determined by examinging the \n+   * <code>java.io.tmpdir</code> system property.\n+   * <p>\n+   * The <code>prefix</code> parameter is a sequence of at least three\n+   * characters that are used as the start of the generated filename.  The\n+   * <code>suffix</code> parameter is a sequence of characters that is used\n+   * to terminate the file name.  This parameter may be <code>null</code>\n+   * and if it is, the suffix defaults to \".tmp\".\n+   * <p>\n+   * If a <code>SecurityManager</code> exists, then its <code>checkWrite</code>\n+   * method is used to verify that this operation is permitted.\n+   *\n+   * @param prefix The character prefix to use in generating the path name.\n+   * @param suffix The character suffix to use in generating the path name.\n+   * @param directory The directory to create the file in, or \n+   * <code>null</code> for the default temporary directory\n+   *\n+   * @exception IllegalArgumentException If the patterns is not valid\n+   * @exception SecurityException If there is no permission to perform \n+   * this operation\n+   * @exception IOException If an error occurs\n+   *\n+   * @since 1.2\n+   */\n   public static File createTempFile (String prefix, String suffix,\n \t\t\t\t     File directory)\n     throws IOException\n@@ -473,7 +935,20 @@ public static File createTempFile (String prefix, String suffix,\n \n   private native boolean performSetReadOnly();\n \n-  /** @since 1.2 */\n+  /**\n+   * This method sets the file represented by this object to be read only.\n+   * A read only file or directory cannot be modified.  Please note that \n+   * GNU systems allow read only files to be deleted if the directory it\n+   * is contained in is writable.\n+   *\n+   * @return <code>true</code> if the operation succeeded, <code>false</code>\n+   * otherwise.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> does\n+   * not allow this operation.\n+   *\n+   * @since 1.2\n+   */\n   public boolean setReadOnly()\n   {\n     checkWrite();\n@@ -482,7 +957,17 @@ public boolean setReadOnly()\n \n   private static native File[] performListRoots();\n \n-  /** @since 1.2 */\n+  /**\n+   * This method returns an array of filesystem roots.  Some operating systems\n+   * have volume oriented filesystem.  This method provides a mechanism for\n+   * determining which volumes exist.  GNU systems use a single hierarchical\n+   * filesystem, so will have only one \"/\" filesystem root.\n+   *\n+   * @return An array of <code>File</code> objects for each filesystem root\n+   * available.\n+   *\n+   * @since 1.2\n+   */\n   public static File[] listRoots()\n   {\n     File[] roots = performListRoots();\n@@ -519,13 +1004,55 @@ public static File[] listRoots()\n     return roots;\n   }\n \n+  /**\n+   * This method creates a temporary file in the system temporary directory. \n+   * The files created are guaranteed not to currently exist and the same file\n+   * name will never be used twice in the same virtual machine instance.  The\n+   * system temporary directory is determined by examinging the \n+   * <code>java.io.tmpdir</code> system property.\n+   * <p>\n+   * The <code>prefix</code> parameter is a sequence of at least three\n+   * characters that are used as the start of the generated filename.  The\n+   * <code>suffix</code> parameter is a sequence of characters that is used\n+   * to terminate the file name.  This parameter may be <code>null</code>\n+   * and if it is, the suffix defaults to \".tmp\".\n+   * <p>\n+   * If a <code>SecurityManager</code> exists, then its <code>checkWrite</code>\n+   * method is used to verify that this operation is permitted.\n+   * <p>\n+   * This method is identical to calling \n+   * <code>createTempFile(prefix, suffix, null)</code>.\n+   *\n+   * @param prefix The character prefix to use in generating the path name.\n+   * @param suffix The character suffix to use in generating the path name.\n+   *\n+   * @exception IllegalArgumentException If the prefix or suffix are not valid.\n+   * @exception SecurityException If there is no permission to perform \n+   * this operation\n+   * @exception IOException If an error occurs\n+   */\n   public static File createTempFile (String prefix, String suffix)\n     throws IOException\n   {\n     return createTempFile (prefix, suffix, null);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method compares the specified <code>File</code> to this one\n+   * to test for equality.  It does this by comparing the canonical path names\n+   * of the files. \n+   * <p>\n+   * The canonical paths of the files are determined by calling the\n+   * <code>getCanonicalPath</code> method on each object.\n+   * <p>\n+   * This method returns a 0 if the specified <code>Object</code> is equal\n+   * to this one, a negative value if it is less than this one \n+   * a positive value if it is greater than this one.\n+   *\n+   * @return An integer as described above\n+   *\n+   * @since 1.2\n+   */\n   public int compareTo(File other)\n   {\n     if (caseSensitive)\n@@ -534,14 +1061,47 @@ public int compareTo(File other)\n       return path.compareToIgnoreCase (other.path);\n   }\n \n-  /** @since 1.2 */\n+  /**\n+   * This method compares the specified <code>Object</code> to this one\n+   * to test for equality.  It does this by comparing the canonical path names\n+   * of the files.  This method is identical to <code>compareTo(File)</code>\n+   * except that if the <code>Object</code> passed to it is not a \n+   * <code>File</code>, it throws a <code>ClassCastException</code>\n+   * <p>\n+   * The canonical paths of the files are determined by calling the\n+   * <code>getCanonicalPath</code> method on each object.\n+   * <p>\n+   * This method returns a 0 if the specified <code>Object</code> is equal\n+   * to this one, a negative value if it is less than this one \n+   * a positive value if it is greater than this one.\n+   *\n+   * @return An integer as described above\n+   *\n+   * @exception ClassCastException If the passed <code>Object</code> is \n+   * not a <code>File</code>\n+   *\n+   * @since 1.2\n+   */\n   public int compareTo(Object o)\n   {\n     File other = (File) o;\n     return compareTo (other);\n   }\n \n   private native boolean performRenameTo (File dest);\n+\n+  /**\n+   * This method renames the file represented by this object to the path\n+   * of the file represented by the argument <code>File</code>.\n+   *\n+   * @param dest The <code>File</code> object representing the target name\n+   *\n+   * @return <code>true</code> if the rename succeeds, <code>false</code> \n+   * otherwise.\n+   *\n+   * @exception SecurityException If write access is not allowed to the \n+   * file by the <code>SecurityMananger</code>.\n+   */\n   public boolean renameTo (File dest)\n   {\n     SecurityManager s = System.getSecurityManager();\n@@ -556,41 +1116,29 @@ public boolean renameTo (File dest)\n   }\n \n   private native boolean performSetLastModified(long time);\n-  \n-  /** @since 1.2 */\n+ \n+  /**\n+   * This method sets the modification time on the file to the specified\n+   * value.  This is specified as the number of seconds since midnight\n+   * on January 1, 1970 GMT.\n+   *\n+   * @param time The desired modification time.\n+   *\n+   * @return <code>true</code> if the operation succeeded, <code>false</code>\n+   * otherwise.\n+   *\n+   * @exception IllegalArgumentException If the specified time is negative.\n+   * @exception SecurityException If the <code>SecurityManager</code> will\n+   * not allow this operation.\n+   *\n+   * @since 1.2\n+   */\n   public boolean setLastModified(long time)\n   {\n     checkWrite();\n     return performSetLastModified(time);\n   }\n \n-  public static final String pathSeparator\n-    = System.getProperty(\"path.separator\");\n-  public static final char pathSeparatorChar = pathSeparator.charAt(0);\n-  public static final String separator = System.getProperty(\"file.separator\");\n-  public static final char separatorChar = separator.charAt(0);\n-\n-  static final String tmpdir = System.getProperty(\"java.io.tmpdir\");\n-  static int maxPathLen;\n-  static boolean caseSensitive;\n-  static String dupSeparator = separator + separator;\n-  \n-  static\n-  {\n-    init_native();\n-  }\n-  \n-  // Native function called at class initialization. This should should\n-  // set the maxPathLen and caseSensitive variables.\n-  private static native void init_native();\n-\n-  // The path.\n-  private String path;\n-\n-  // We keep a counter for use by createTempFile.  We choose the first\n-  // value randomly to try to avoid clashes with other VMs.\n-  private static long counter = Double.doubleToLongBits (Math.random ());\n-\n   private void checkWrite ()\n   {\n     SecurityManager s = System.getSecurityManager();"}, {"sha": "418d7f2cbd5635623cf0274c34c12dbad13d5ed9", "filename": "libjava/java/io/PrintStream.java", "status": "modified", "additions": 203, "deletions": 3, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FPrintStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FPrintStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintStream.java?ref=da557ab84661f8906af7f8b55a8a4e68f4176258", "patch": "@@ -84,32 +84,76 @@ public class PrintStream extends FilterOutputStream\n   // True if error occurred.\n   private boolean error;\n   // True if auto-flush.\n+  /**\n+   * This is <code>true</code> if auto-flush is enabled, \n+   * <code>false</code> otherwise\n+   */\n   private boolean auto_flush;\n \n+  /**\n+   * This method intializes a new <code>PrintStream</code> object to write\n+   * to the specified output sink.  Note that this class is deprecated in\n+   * favor of <code>PrintWriter</code>.\n+   *\n+   * @param out The <code>OutputStream</code> to write to.\n+   *\n+   * @deprecated\n+   */\n   public PrintStream (OutputStream out)\n   {\n     this(out, false);\n   }\n \n+  /**\n+   * This method intializes a new <code>PrintStream</code> object to write\n+   * to the specified output sink.  This constructor also allows \"auto-flush\"\n+   * functionality to be specified where the stream will be flushed after\n+   * every line is terminated or newline character is written.\n+   * <p>\n+   * Note that this class is deprecated in favor of <code>PrintWriter</code>.\n+   *\n+   * @param out The <code>OutputStream</code> to write to.\n+   * @param auto_flush <code>true</code> to flush the stream after every \n+   * line, <code>false</code> otherwise\n+   *\n+   * @deprecated\n+   */\n   public PrintStream (OutputStream out, boolean auto_flush)\n   {\n     super(out);\n+\n     converter = UnicodeToBytes.getDefaultEncoder();\n     error = false;\n     this.auto_flush = auto_flush;\n   }\n \n+  /**\n+   * This method checks to see if an error has occurred on this stream.  Note\n+   * that once an error has occurred, this method will continue to report\n+   * <code>true</code> forever for this stream.  Before checking for an\n+   * error condition, this method flushes the stream.\n+   *\n+   * @return <code>true</code> if an error has occurred, \n+   * <code>false</code> otherwise\n+   */\n   public boolean checkError ()\n   {\n     flush();\n     return error;\n   }\n \n+  /**\n+   * This method can be called by subclasses to indicate that an error\n+   * has occurred and should be reported by <code>checkError</code>.\n+   */\n   protected void setError ()\n   {\n     error = true;\n   }\n \n+  /**\n+   * This method closes this stream and all underlying streams.\n+   */\n   public void close ()\n   {\n     try\n@@ -127,6 +171,10 @@ public void close ()\n       }\n   }\n \n+  /**\n+   * This method flushes any buffered bytes to the underlying stream and\n+   * then flushes that stream as well.\n+   */\n   public void flush ()\n   {\n     try\n@@ -210,103 +258,245 @@ private void writeChars(String str, int offset, int count)\n       }\n   }\n \n+  /**\n+   * This methods prints a boolean value to the stream.  <code>true</code>\n+   * values are printed as \"true\" and <code>false</code> values are printed\n+   * as \"false\".\n+   *\n+   * @param b The <code>boolean</code> value to print\n+   */\n   public void print (boolean bool)\n   {\n     print(String.valueOf(bool), false);\n   }\n \n+  /**\n+   * This method prints an integer to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   *\n+   * @param inum The <code>int</code> value to be printed\n+   */\n   public void print (int inum)\n   {\n     print(String.valueOf(inum), false);\n   }\n \n+  /**\n+   * This method prints a long to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   *\n+   * @param lnum The <code>long</code> value to be printed\n+   */\n   public void print (long lnum)\n   {\n     print(String.valueOf(lnum), false);\n   }\n \n+  /**\n+   * This method prints a float to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   *\n+   * @param fnum The <code>float</code> value to be printed\n+   */\n   public void print (float fnum)\n   {\n     print(String.valueOf(fnum), false);\n   }\n \n+  /**\n+   * This method prints a double to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   *\n+   * @param dnum The <code>double</code> value to be printed\n+   */\n   public void print (double dnum)\n   {\n     print(String.valueOf(dnum), false);\n   }\n \n+  /**\n+   * This method prints an <code>Object</code> to the stream.  The actual\n+   * value printed is determined by calling the <code>String.valueOf()</code>\n+   * method.\n+   *\n+   * @param obj The <code>Object</code> to print.\n+   */\n   public void print (Object obj)\n   {\n     print(obj == null ? \"null\" : obj.toString(), false);\n   }\n \n+  /**\n+   * This method prints a <code>String</code> to the stream.  The actual\n+   * value printed depends on the system default encoding.\n+   *\n+   * @param str The <code>String</code> to print.\n+   */\n   public void print (String str)\n   {\n     print(str == null ? \"null\" : str, false);\n   }\n \n+  /**\n+   * This method prints a char to the stream.  The actual value printed is\n+   * determined by the character encoding in use.\n+   *\n+   * @param ch The <code>char</code> value to be printed\n+   */\n   public synchronized void print (char ch)\n   {\n     work[0] = ch;\n     print(work, 0, 1, false);\n   }\n \n+  /**\n+   * This method prints an array of characters to the stream.  The actual\n+   * value printed depends on the system default encoding.\n+   *\n+   * @param s The array of characters to print.\n+   */\n   public void print (char[] charArray)\n   {\n     print(charArray, 0, charArray.length, false);\n   }\n \n+  /**\n+   * This method prints a line separator sequence to the stream.  The value\n+   * printed is determined by the system property <xmp>line.separator</xmp>\n+   * and is not necessarily the Unix '\\n' newline character.\n+   */\n   public void println ()\n   {\n     print(line_separator, 0, line_separator.length, false);\n   }\n \n+  /**\n+   * This methods prints a boolean value to the stream.  <code>true</code>\n+   * values are printed as \"true\" and <code>false</code> values are printed\n+   * as \"false\".\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param b The <code>boolean</code> value to print\n+   */\n   public void println (boolean bool)\n   {\n     print(String.valueOf(bool), true);\n   }\n \n+  /**\n+   * This method prints an integer to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param inum The <code>int</code> value to be printed\n+   */\n   public void println (int inum)\n   {\n     print(String.valueOf(inum), true);\n   }\n \n+  /**\n+   * This method prints a long to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param lnum The <code>long</code> value to be printed\n+   */\n   public void println (long lnum)\n   {\n     print(String.valueOf(lnum), true);\n   }\n \n+  /**\n+   * This method prints a float to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param fnum The <code>float</code> value to be printed\n+   */\n   public void println (float fnum)\n   {\n     print(String.valueOf(fnum), true);\n   }\n \n+  /**\n+   * This method prints a double to the stream.  The value printed is\n+   * determined using the <code>String.valueOf()</code> method.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param dnum The <code>double</code> value to be printed\n+   */\n   public void println (double dnum)\n   {\n     print(String.valueOf(dnum), true);\n   }\n \n+  /**\n+   * This method prints an <code>Object</code> to the stream.  The actual\n+   * value printed is determined by calling the <code>String.valueOf()</code>\n+   * method.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param obj The <code>Object</code> to print.\n+   */\n   public void println (Object obj)\n   {\n     print(obj == null ? \"null\" : obj.toString(), true);\n   }\n \n+  /**\n+   * This method prints a <code>String</code> to the stream.  The actual\n+   * value printed depends on the system default encoding.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param str The <code>String</code> to print.\n+   */\n   public void println (String str)\n   {\n     print (str == null ? \"null\" : str, true);\n   }\n \n+  /**\n+   * This method prints a char to the stream.  The actual value printed is\n+   * determined by the character encoding in use.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param ch The <code>char</code> value to be printed\n+   */\n   public synchronized void println (char ch)\n   {\n     work[0] = ch;\n     print(work, 0, 1, true);\n   }\n \n+  /**\n+   * This method prints an array of characters to the stream.  The actual\n+   * value printed depends on the system default encoding.\n+   * <p>\n+   * This method prints a line termination sequence after printing the value.\n+   *\n+   * @param s The array of characters to print.\n+   */\n   public void println (char[] charArray)\n   {\n     print(charArray, 0, charArray.length, true);\n   }\n \n+  /**\n+   * This method writes a byte of data to the stream.  If auto-flush is\n+   * enabled, printing a newline character will cause the stream to be\n+   * flushed after the character is written.\n+   * \n+   * @param b The byte to be written\n+   */\n   public void write (int oneByte)\n   {\n     try\n@@ -325,11 +515,20 @@ public void write (int oneByte)\n       }\n   }\n \n-  public void write (byte[] buffer, int offset, int count)\n+  /**\n+   * This method writes <code>len</code> bytes from the specified array\n+   * starting at index <code>offset</code> into the array.\n+   *\n+   * @param buffer The array of bytes to write\n+   * @param offset The index into the array to start writing from\n+   * @param len The number of bytes to write\n+   */\n+  public void write (byte[] buffer, int offset, int len)\n   {\n     try\n       {\n-\tout.write(buffer, offset, count);\n+\tout.write (buffer, offset, len);\n+        \n \tif (auto_flush)\n \t  flush();\n       }\n@@ -343,4 +542,5 @@ public void write (byte[] buffer, int offset, int count)\n       }\n   }\n \n-}\n+} // class PrintStream\n+"}, {"sha": "990b2dcb5bdd2dd83c36c377ff1b8b1ee341949c", "filename": "libjava/java/io/RandomAccessFile.java", "status": "modified", "additions": 302, "deletions": 11, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da557ab84661f8906af7f8b55a8a4e68f4176258/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FRandomAccessFile.java?ref=da557ab84661f8906af7f8b55a8a4e68f4176258", "patch": "@@ -525,100 +525,391 @@ public final long readLong () throws IOException\n     return in.readLong();\n   }\n \n+  /**\n+   * This method reads a signed 16-bit value into a Java in from the stream.\n+   * It operates by reading two bytes from the stream and converting them to \n+   * a single 16-bit Java <code>short</code>  The two bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> and code{byte2</code> \n+   * represent the first\n+   * and second byte read from the stream respectively, they will be\n+   * transformed to a <code>short</code> in the following manner:\n+   * <p>\n+   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <p>\n+   * The value returned is in the range of -32768 to 32767.\n+   * <p>\n+   * This method can read a <code>short</code> written by an object \n+   * implementing the\n+   * <code>writeShort()</code> method in the <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>short</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final short readShort () throws IOException\n   {\n     return in.readShort();\n   }\n \n+  /**\n+   * This method reads 8 unsigned bits into a Java <code>int</code> value \n+   * from the \n+   * stream. The value returned is in the range of 0 to 255.\n+   * <p>\n+   * This method can read an unsigned byte written by an object implementing \n+   * the <code>writeUnsignedByte()</code> method in the \n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The unsigned bytes value read as a Java <code>int</code>\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final int readUnsignedByte () throws IOException\n   {\n     return in.readUnsignedByte();\n   }\n \n+  /**\n+   * This method reads 16 unsigned bits into a Java int value from the stream.\n+   * It operates by reading two bytes from the stream and converting them to \n+   * a single Java <code>int</code>  The two bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> and <code>byte2</code> \n+   * represent the first\n+   * and second byte read from the stream respectively, they will be\n+   * transformed to an <code>int</code> in the following manner:\n+   * <p>\n+   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an unsigned short written by an object implementing\n+   * the <code>writeUnsignedShort()</code> method in the \n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The unsigned short value read as a Java <code>int</code>\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   */\n   public final int readUnsignedShort () throws IOException\n   {\n     return in.readUnsignedShort();\n   }\n \n+  /**\n+   * This method reads a <code>String</code> from an input stream that \n+   * is encoded in\n+   * a modified UTF-8 format.  This format has a leading two byte sequence\n+   * that contains the remaining number of bytes to read.  This two byte\n+   * sequence is read using the <code>readUnsignedShort()</code> method of this\n+   * interface.\n+   * <p>\n+   * After the number of remaining bytes have been determined, these bytes\n+   * are read an transformed into <code>char</code> values.  \n+   * These <code>char</code> values\n+   * are encoded in the stream using either a one, two, or three byte format.\n+   * The particular format in use can be determined by examining the first\n+   * byte read.  \n+   * <p>\n+   * If the first byte has a high order bit of 0 then\n+   * that character consists on only one byte.  This character value consists\n+   * of seven bits that are at positions 0 through 6 of the byte.  As an\n+   * example, if <code>byte1</code> is the byte read from the stream, it would\n+   * be converted to a <code>char</code> like so:\n+   * <p>\n+   * <code>(char)byte1</code>\n+   * <p>\n+   * If the first byte has <code>110</code> as its high order bits, then the \n+   * character consists of two bytes.  The bits that make up the character\n+   * value are in positions 0 through 4 of the first byte and bit positions\n+   * 0 through 5 of the second byte.  (The second byte should have \n+   * 10 as its high order bits).  These values are in most significant\n+   * byte first (i.e., \"big endian\") order.\n+   * <p>\n+   * As an example, if <code>byte1</code> and <code>byte2</code> \n+   * are the first two bytes\n+   * read respectively, and the high order bits of them match the patterns\n+   * which indicate a two byte character encoding, then they would be\n+   * converted to a Java <code>char</code> like so:\n+   * <p>\n+   * <code>(char)(((byte1 & 0x1F) << 6) | (byte2 & 0x3F))</code>\n+   * <p>\n+   * If the first byte has a <code>1110</code> as its high order bits, then the\n+   * character consists of three bytes.  The bits that make up the character\n+   * value are in positions 0 through 3 of the first byte and bit positions\n+   * 0 through 5 of the other two bytes.  (The second and third bytes should\n+   * have <code>10</code> as their high order bits).  These values are in most\n+   * significant byte first (i.e., \"big endian\") order.\n+   * <p>\n+   * As an example, if <code>byte1</code> <code>byte2</code> \n+   * and <code>byte3</code> are the\n+   * three bytes read, and the high order bits of them match the patterns\n+   * which indicate a three byte character encoding, then they would be\n+   * converted to a Java <code>char</code> like so:\n+   * <p>\n+   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | \n+   * (byte3 & 0x3F))</code>\n+   * <p>\n+   * Note that all characters are encoded in the method that requires the\n+   * fewest number of bytes with the exception of the character with the\n+   * value of <code>&#92;u0000</code> which is encoded as two bytes.  This is \n+   * a  modification of the UTF standard used to prevent C language style\n+   * <code>NUL</code> values from appearing in the byte stream.\n+   * <p>\n+   * This method can read data that was written by an object implementing the\n+   * <code>writeUTF()</code> method in <code>DataOutput</code>\n+   * \n+   * @return The <code>String</code> read\n+   *\n+   * @exception EOFException If end of file is reached before reading the \n+   * String\n+   * @exception UTFDataFormatException If the data is not in UTF-8 format\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final String readUTF () throws IOException\n   {\n     return in.readUTF();\n   }\n \n+  /**\n+   * This method sets the current file position to the specified offset \n+   * from the beginning of the file.  Note that some operating systems will\n+   * allow the file pointer to be set past the current end of the file.\n+   *\n+   * @param pos The offset from the beginning of the file at which to set \n+   * the file pointer\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void seek (long pos) throws IOException\n   {\n-    fd.seek(pos, FileDescriptor.SET, false);\n+    fd.seek (pos, FileDescriptor.SET, false);\n   }\n \n-  public int skipBytes (int count) throws IOException\n+  /**\n+   * This method attempts to skip and discard the specified number of bytes \n+   * in the input stream.  It may actually skip fewer bytes than requested. \n+   * The actual number of bytes skipped is returned.  This method will not\n+   * skip any bytes if passed a negative number of bytes to skip.\n+   *\n+   * @param numBytes The requested number of bytes to skip.\n+   *\n+   * @return The number of bytes actually skipped.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public int skipBytes (int numBytes) throws IOException\n   {\n-    if (count <= 0)\n+    if (numBytes < 0)\n+      throw new IllegalArgumentException (\"Can't skip negative bytes: \" +\n+                                          numBytes);\n+    \n+    if (numBytes == 0)\n       return 0;\n-    long startPos = fd.getFilePointer();\n-    long endPos = fd.seek(count, FileDescriptor.CUR, true);\n-    return (int) (endPos - startPos);\n+    \n+    long curPos = fd.getFilePointer ();\n+    long newPos = fd.seek (numBytes, FileDescriptor.CUR, true);\n+    \n+    return (int) (newPos - curPos);\n   }\n \n+  /**\n+   * This method writes a single byte of data to the file. The file must\n+   * be open for read-write in order for this operation to succeed.\n+   *\n+   * @param The byte of data to write, passed as an int.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write (int oneByte) throws IOException\n   {\n     out.write(oneByte);\n   }\n \n+  /**\n+   * This method writes all the bytes in the specified array to the file.\n+   * The file must be open read-write in order for this operation to succeed.\n+   *\n+   * @param buf The array of bytes to write to the file\n+   */\n   public void write (byte[] buffer) throws IOException\n   {\n     out.write(buffer);\n   }\n \n-  public void write (byte[] buffer, int offset, int count) throws IOException\n+  /**\n+   * This method writes <code>len</code> bytes to the file from the specified\n+   * array starting at index <code>offset</code> into the array.\n+   *\n+   * @param buf The array of bytes to write to the file\n+   * @param offset The index into the array to start writing file\n+   * @param len The number of bytes to write\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public void write (byte[] buffer, int offset, int len) throws IOException\n   {\n-    out.write(buffer, offset, count);\n+    out.write (buffer, offset, len);\n   }\n \n+  /**\n+   * This method writes a Java <code>boolean</code> to the underlying output \n+   * stream. For a value of <code>true</code>, 1 is written to the stream.\n+   * For a value of <code>false</code>, 0 is written.\n+   *\n+   * @param b The <code>boolean</code> value to write to the stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeBoolean (boolean val) throws IOException\n   {\n     out.writeBoolean(val);\n   }\n \n+  /**\n+   * This method writes a Java <code>byte</code> value to the underlying\n+   * output stream.\n+   *\n+   * @param b The <code>byte</code> to write to the stream, passed \n+   * as an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeByte (int v) throws IOException\n   {\n     out.writeByte(v);\n   }\n \n+  /**\n+   * This method writes a Java <code>short</code> to the stream, high byte\n+   * first.  This method requires two bytes to encode the value.\n+   *\n+   * @param s The <code>short</code> value to write to the stream, \n+   * passed as an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeShort (int v) throws IOException\n   {\n     out.writeShort(v);\n   }\n \n+  /**\n+   * This method writes a single <code>char</code> value to the stream,\n+   * high byte first.\n+   *\n+   * @param v The <code>char</code> value to write, passed as \n+   * an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeChar (int v) throws IOException\n   {\n     out.writeChar(v);\n   }\n \n+  /**\n+   * This method writes a Java <code>int</code> to the stream, high bytes\n+   * first.  This method requires four bytes to encode the value.\n+   *\n+   * @param v The <code>int</code> value to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeInt (int v) throws IOException\n   {\n     out.writeInt(v);\n   }\n \n+  /**\n+   * This method writes a Java <code>long</code> to the stream, high bytes\n+   * first.  This method requires eight bytes to encode the value.\n+   *\n+   * @param v The <code>long</code> value to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeLong (long v) throws IOException\n   {\n     out.writeLong(v);\n   }\n \n+  /**\n+   * This method writes a Java <code>float</code> value to the stream.  This\n+   * value is written by first calling the method \n+   * <code>Float.floatToIntBits</code>\n+   * to retrieve an <code>int</code> representing the floating point number,\n+   * then writing this <code>int</code> value to the stream exactly the same\n+   * as the <code>writeInt()</code> method does.\n+   *\n+   * @param v The floating point number to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see #writeInt(int)\n+   */\n   public final void writeFloat (float v) throws IOException\n   {\n     out.writeFloat(v);\n   }\n \n+  /**\n+   * This method writes a Java <code>double</code> value to the stream.  This\n+   * value is written by first calling the method \n+   * <code>Double.doubleToLongBits</code>\n+   * to retrieve an <code>long</code> representing the floating point number,\n+   * then writing this <code>long</code> value to the stream exactly the same\n+   * as the <code>writeLong()</code> method does.\n+   *\n+   * @param v The double precision floating point number to write to the \n+   * stream.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see #writeLong(long)\n+   */\n   public final void writeDouble (double v) throws IOException\n   {\n     out.writeDouble(v);\n   }\n \n+  /**\n+   * This method writes all the bytes in a <code>String</code> out to the\n+   * stream.  One byte is written for each character in the <code>String</code>.\n+   * The high eight bits of each character are discarded.\n+   *\n+   * @param s The <code>String</code> to write to the stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeBytes (String s) throws IOException\n   {\n     out.writeBytes(s);\n   }\n-\n+  \n+  /**\n+   * This method writes all the characters in a <code>String</code> to the\n+   * stream.  There will be two bytes for each character value.  The high\n+   * byte of the character will be written first.\n+   *\n+   * @param s The <code>String</code> to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeChars (String s) throws IOException\n   {\n     out.writeChars(s);\n@@ -653,7 +944,7 @@ public final void writeChars (String s) throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public final void writeUTF(String s) throws IOException\n+  public final void writeUTF (String s) throws IOException\n   {\n     out.writeUTF(s);\n   }\n@@ -664,7 +955,7 @@ public final void writeUTF(String s) throws IOException\n    * A file channel must be created by first creating an instance of\n    * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n    */\n-  public synchronized FileChannel getChannel() \n+  public synchronized FileChannel getChannel ()\n   {\n     if (ch == null)\n       ch = new FileChannelImpl (fd, true, this);"}]}