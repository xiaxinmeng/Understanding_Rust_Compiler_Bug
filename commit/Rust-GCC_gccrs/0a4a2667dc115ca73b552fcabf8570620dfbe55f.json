{"sha": "0a4a2667dc115ca73b552fcabf8570620dfbe55f", "node_id": "C_kwDOANBUbNoAKDBhNGEyNjY3ZGMxMTVjYTczYjU1MmZjYWJmODU3MDYyMGRmYmU1NWY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-06T11:46:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-06T12:55:51Z"}, "message": "tree-optimization/106754 - fix compute_control_dep_chain defect\n\nThe following handles the situation of a loop exit along the\ncontrol path to the PHI def or from there to the use in a different\nway, aoviding premature abort of the walks as noticed in the two\ncases where the exit is outermost (gcc.dg/uninit-pred-11.c) or\nwrapped in a condition that is on the path (gcc.dg/uninit-pred-12.c).\nInstead of handling such exits during recursion we now pick them\nup in the parent when walking post-dominators.  That requires an\nadditional post-dominator walk at the outermost level which is\nfacilitated by splitting out the walk to a helper function and\nthe existing wrapper added earlier.\n\nThe patch also removes the bogus early exit from\nuninit_analysis::init_use_preds, fixing a simplified version\nof the PR106155 testcase.\n\n\tPR tree-optimization/106754\n\t* gimple-predicate-analysis.cc (compute_control_dep_chain_pdom):\n\tNew function, split out from compute_control_dep_chain.  Handle\n\tloop-exit like conditions here by pushing to the control vector.\n\t(compute_control_dep_chain): Adjust and streamline dumping.\n\tIn the wrapper perform a post-dominator walk as well.\n\t(uninit_analysis::init_use_preds): Remove premature early exit.\n\n\t* gcc.dg/uninit-pred-12.c: New testcase.\n\t* gcc.dg/uninit-pr106155-1.c: Likewise.", "tree": {"sha": "4f3cc335be7580f5327681165492257fa465d88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f3cc335be7580f5327681165492257fa465d88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a4a2667dc115ca73b552fcabf8570620dfbe55f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4a2667dc115ca73b552fcabf8570620dfbe55f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a4a2667dc115ca73b552fcabf8570620dfbe55f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4a2667dc115ca73b552fcabf8570620dfbe55f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0c2696724d4d004ea189a69f15781c7baa68e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0c2696724d4d004ea189a69f15781c7baa68e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0c2696724d4d004ea189a69f15781c7baa68e1"}], "stats": {"total": 260, "additions": 180, "deletions": 80}, "files": [{"sha": "5dade4589473b525822af63e0db2f2fa12183601", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 106, "deletions": 80, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=0a4a2667dc115ca73b552fcabf8570620dfbe55f", "patch": "@@ -981,6 +981,94 @@ dfs_mark_dominating_region (edge exit, basic_block dom, int flag,\n   return true;\n }\n \n+static bool\n+compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n+\t\t\t   vec<edge> cd_chains[], unsigned *num_chains,\n+\t\t\t   vec<edge> &cur_cd_chain, unsigned *num_calls,\n+\t\t\t   unsigned in_region, unsigned depth,\n+\t\t\t   bool *complete_p);\n+\n+/* Helper for compute_control_dep_chain that walks the post-dominator\n+   chain from CD_BB up unto TARGET_BB looking for paths to DEP_BB.  */\n+\n+static bool\n+compute_control_dep_chain_pdom (basic_block cd_bb, const_basic_block dep_bb,\n+\t\t\t\tbasic_block target_bb,\n+\t\t\t\tvec<edge> cd_chains[], unsigned *num_chains,\n+\t\t\t\tvec<edge> &cur_cd_chain, unsigned *num_calls,\n+\t\t\t\tunsigned in_region, unsigned depth,\n+\t\t\t\tbool *complete_p)\n+{\n+  bool found_cd_chain = false;\n+  while (cd_bb != target_bb)\n+    {\n+      if (cd_bb == dep_bb)\n+\t{\n+\t  /* Found a direct control dependence.  */\n+\t  if (*num_chains < MAX_NUM_CHAINS)\n+\t    {\n+\t      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\t\tfprintf (dump_file, \"%*s pushing { %s }\\n\",\n+\t\t\t depth, \"\", format_edge_vec (cur_cd_chain).c_str ());\n+\t      cd_chains[*num_chains] = cur_cd_chain.copy ();\n+\t      (*num_chains)++;\n+\t    }\n+\t  found_cd_chain = true;\n+\t  /* Check path from next edge.  */\n+\t  break;\n+\t}\n+\n+      /* If the dominating region has been marked avoid walking outside.  */\n+      if (in_region != 0 && !(cd_bb->flags & in_region))\n+\tbreak;\n+\n+      /* Count the number of steps we perform to limit compile-time.\n+\t This should cover both recursion and the post-dominator walk.  */\n+      if (*num_calls > (unsigned)param_uninit_control_dep_attempts)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"param_uninit_control_dep_attempts \"\n+\t\t     \"exceeded: %u\\n\", *num_calls);\n+\t  *complete_p = false;\n+\t  break;\n+\t}\n+      ++*num_calls;\n+\n+      /* Check if DEP_BB is indirectly control-dependent on DOM_BB.  */\n+      if (!single_succ_p (cd_bb)\n+\t  && compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n+\t\t\t\t\tnum_chains, cur_cd_chain,\n+\t\t\t\t\tnum_calls, in_region, depth + 1,\n+\t\t\t\t\tcomplete_p))\n+\t{\n+\t  found_cd_chain = true;\n+\t  break;\n+\t}\n+\n+      /* The post-dominator walk will reach a backedge only\n+\t from a forwarder, otherwise it should choose to exit\n+\t the SCC.  */\n+      if (single_succ_p (cd_bb)\n+\t  && single_succ_edge (cd_bb)->flags & EDGE_DFS_BACK)\n+\tbreak;\n+      basic_block prev_cd_bb = cd_bb;\n+      cd_bb = get_immediate_dominator (CDI_POST_DOMINATORS, cd_bb);\n+      if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\tbreak;\n+      /* Pick up conditions toward the post dominator such like\n+\t loop exit conditions.  See gcc.dg/uninit-pred-11.c and\n+\t gcc.dg/unninit-pred-12.c and PR106754.  */\n+      if (single_pred_p (cd_bb))\n+\t{\n+\t  edge e2 = find_edge (prev_cd_bb, cd_bb);\n+\t  gcc_assert (e2);\n+\t  cur_cd_chain.safe_push (e2);\n+\t}\n+    }\n+  return found_cd_chain;\n+}\n+\n+\n /* Recursively compute the control dependence chains (paths of edges)\n    from the dependent basic block, DEP_BB, up to the dominating basic\n    block, DOM_BB (the head node of a chain should be dominated by it),\n@@ -1024,9 +1112,10 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \n   if (DEBUG_PREDICATE_ANALYZER && dump_file)\n     fprintf (dump_file,\n-\t     \"%*s%s (dom_bb = %u, dep_bb = %u, cd_chains = { %s }, ...)\\n\",\n+\t     \"%*s%s (dom_bb = %u, dep_bb = %u, ..., \"\n+\t     \"cur_cd_chain = { %s }, ...)\\n\",\n \t     depth, \"\", __func__, dom_bb->index, dep_bb->index,\n-\t     format_edge_vecs (cd_chains, *num_chains).c_str ());\n+\t     format_edge_vec (cur_cd_chain).c_str ());\n \n   bool found_cd_chain = false;\n \n@@ -1039,75 +1128,17 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \tcontinue;\n \n       basic_block cd_bb = e->dest;\n+      unsigned pop_mark = cur_cd_chain.length ();\n       cur_cd_chain.safe_push (e);\n-      while (!dominated_by_p (CDI_POST_DOMINATORS, dom_bb, cd_bb)\n-\t     /* We want to stop when the CFG merges back from the\n-\t\tbranch in dom_bb.  The post-dominance check alone\n-\t\tfalls foul of the case of a loop exit test branch\n-\t\twhere the path on the loop exit post-dominates\n-\t\tthe branch block.\n-\t\tThe following catches this but will not allow\n-\t\texploring the post-dom path further.  For the\n-\t\toutermost recursion this means we will fail to\n-\t\treach dep_bb while for others it means at least\n-\t\tdropping the loop exit predicate from the path\n-\t\twhich is problematic as it increases the domain\n-\t\tspanned by the resulting predicate.\n-\t\tSee gcc.dg/uninit-pred-11.c for the first case\n-\t\tand PR106754 for the second.  */\n-\t     || single_pred_p (cd_bb))\n-\t{\n-\t  if (cd_bb == dep_bb)\n-\t    {\n-\t      /* Found a direct control dependence.  */\n-\t      if (*num_chains < MAX_NUM_CHAINS)\n-\t\t{\n-\t\t  cd_chains[*num_chains] = cur_cd_chain.copy ();\n-\t\t  (*num_chains)++;\n-\t\t}\n-\t      found_cd_chain = true;\n-\t      /* Check path from next edge.  */\n-\t      break;\n-\t    }\n-\n-\t  /* If the dominating region has been marked avoid walking outside.  */\n-\t  if (in_region != 0 && !(cd_bb->flags & in_region))\n-\t    break;\n-\n-\t  /* Count the number of steps we perform to limit compile-time.\n-\t     This should cover both recursion and the post-dominator walk.  */\n-\t  if (*num_calls > (unsigned)param_uninit_control_dep_attempts)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"param_uninit_control_dep_attempts \"\n-\t\t\t \"exceeded: %u\\n\", *num_calls);\n-\t      *complete_p = false;\n-\t      break;\n-\t    }\n-\t  ++*num_calls;\n-\n-\t  /* Check if DEP_BB is indirectly control-dependent on DOM_BB.  */\n-\t  if (!single_succ_p (cd_bb)\n-\t      && compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n-\t\t\t\t\t    num_chains, cur_cd_chain,\n-\t\t\t\t\t    num_calls, in_region, depth + 1,\n-\t\t\t\t\t    complete_p))\n-\t    {\n-\t      found_cd_chain = true;\n-\t      break;\n-\t    }\n-\n-\t  /* The post-dominator walk will reach a backedge only\n-\t     from a forwarder, otherwise it should choose to exit\n-\t     the SCC.  */\n-\t  if (single_succ_p (cd_bb)\n-\t      && single_succ_edge (cd_bb)->flags & EDGE_DFS_BACK)\n-\t    break;\n-\t  cd_bb = get_immediate_dominator (CDI_POST_DOMINATORS, cd_bb);\n-\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t    break;\n-\t}\n-      cur_cd_chain.pop ();\n+      basic_block target_bb\n+\t= get_immediate_dominator (CDI_POST_DOMINATORS, dom_bb);\n+      /* Walk the post-dominator chain up to the CFG merge.  */\n+      found_cd_chain\n+\t  |= compute_control_dep_chain_pdom (cd_bb, dep_bb, target_bb,\n+\t\t\t\t\t     cd_chains, num_chains,\n+\t\t\t\t\t     cur_cd_chain, num_calls,\n+\t\t\t\t\t     in_region, depth, complete_p);\n+      cur_cd_chain.truncate (pop_mark);\n       gcc_assert (cur_cd_chain.length () == cur_chain_len);\n     }\n \n@@ -1127,9 +1158,10 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n   unsigned num_calls = 0;\n   unsigned depth = 0;\n   bool complete_p = true;\n-  compute_control_dep_chain (dom_bb, dep_bb, cd_chains, num_chains,\n-\t\t\t     cur_cd_chain, &num_calls, in_region, depth,\n-\t\t\t     &complete_p);\n+  /* Walk the post-dominator chain.  */\n+  compute_control_dep_chain_pdom (dom_bb, dep_bb, NULL, cd_chains,\n+\t\t\t\t  num_chains, cur_cd_chain, &num_calls,\n+\t\t\t\t  in_region, depth, &complete_p);\n   return complete_p;\n }\n \n@@ -1935,9 +1967,7 @@ uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n   unsigned num_chains = 0;\n   auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n \n-  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains)\n-      /* ???  Workaround PR106754.  */\n-      || num_chains == 0)\n+  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains))\n     {\n       /* If the info in dep_chains is not complete we need to use a\n \t conservative approximation for the use predicate.  */\n@@ -2099,10 +2129,6 @@ uninit_analysis::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n   /* The basic block where the PHI is defined.  */\n   basic_block def_bb = gimple_bb (phi);\n \n-  if (dominated_by_p (CDI_POST_DOMINATORS, def_bb, use_bb))\n-    /* The use is not guarded.  */\n-    return false;\n-\n   /* Try to build the predicate expression under which the PHI flows\n      into its use.  This will be empty if the PHI is defined and used\n      in the same bb.  */"}, {"sha": "5c4410deec85a18ef0882760e9a223a157728a89", "filename": "gcc/testsuite/gcc.dg/uninit-pr106155-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr106155-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr106155-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr106155-1.c?ref=0a4a2667dc115ca73b552fcabf8570620dfbe55f", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-ivopts -Wuninitialized\" } */\n+\n+int *e;\n+int f1 (void);\n+void f2 (int);\n+long f3 (void *, long, int *);\n+void f4 (void *);\n+int *fh;\n+\n+void tst (void)\n+{\n+  int status;\n+  unsigned char badData[3][3] = { { 7 }, { 16 }, { 23 } };\n+  int badDataSize[3] = { 1, 1, 1 };\n+  int i;\n+\n+  for (i = 0; i < 3; i++)\n+    {\n+      int emax;\n+      if (i == 2)\n+        emax = f1 ();\n+      status = f3 (&badData[i][0], badDataSize[i], fh);\n+      if (status)\n+        {\n+          f1 ();\n+          f1 ();\n+          f1 ();\n+        }\n+      f4 (fh);\n+      *e = 0;\n+      f1 ();\n+      /* When threading the following out of the loop uninit\n+\t analysis needs to pick up the loop exit condition\n+\t to match up with this guard.\n+\t ???  This doesn't work reliably when IVOPTs is run.  */\n+      if (i == 2)\n+        f2 (emax);  /* { dg-bogus \"uninitialized\" } */\n+    }\n+}"}, {"sha": "ebf0288af1f9ddd53bac0b8d9f4e108fb4f02487", "filename": "gcc/testsuite/gcc.dg/uninit-pred-12.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4a2667dc115ca73b552fcabf8570620dfbe55f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-12.c?ref=0a4a2667dc115ca73b552fcabf8570620dfbe55f", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -Wmaybe-uninitialized -fdump-tree-uninit1\" } */\n+\n+extern unsigned bar (void);\n+extern void quux (void);\n+int z;\n+unsigned foo (unsigned v, int y, int w)\n+{\n+  unsigned u;\n+  if (v != 1)\n+    u = bar ();\n+\n+  // Prevent the \"dom\" pass from changing the CFG layout based on the inference\n+  // 'if (v != 1) is false then (v != 2) is true'.  (Now it would have to\n+  // duplicate the loop in order to do so, which is deemed expensive.)\n+  for (int i = 0; i < 10; i++)\n+    quux ();\n+\n+  // This variantion from uninit-pred-11.c caused compute_control_dep_chain\n+  // to run into a defect, producing z != 0 && v != 1, omitting !(i<10)\n+  // from the path predicate\n+  if (w)\n+    {\n+      if (y)\n+\tz = 1;\n+      if (v != 1)\n+\treturn u;       /* { dg-bogus \"may be used uninitialized\" } */\n+    }\n+\n+  return 0;\n+}\n+\n+/* Make sure predicate analysis picked up the loop exit condition.  */\n+/* { dg-final { scan-tree-dump \"AND \\\\(NOT \\\\(ivtmp\" \"uninit1\" } } */"}]}