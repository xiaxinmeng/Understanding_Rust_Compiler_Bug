{"sha": "2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZmNWZmYjYyM2UxN2I2YmI4MTUzMjM5NGNiMWY0MmZlN2IzNTRjOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-11-27T12:30:59Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-11-27T12:30:59Z"}, "message": "Come up with memop_ret enum instead of int endp for memory operations.\n\n2018-11-27  Martin Liska  <mliska@suse.cz>\n\n\t* asan.c (asan_emit_stack_protection): Use new enum values\n\tinstead of int constants.\n\t* builtins.c (expand_builtin_memory_copy_args): Replace int\n\ttype with memop_ret enum type.\n\t(expand_builtin_mempcpy_args): Likewise.\n\t(expand_builtin_memcpy): Use new enum values\n\tinstead of int constants. Likewise.\n\t(expand_builtin_mempcpy): Likewise.\n\t(expand_movstr): Likewise.\n\t(expand_builtin_strcpy_args): Likewise.\n\t(expand_builtin_stpcpy_1): Likewise.\n\t(expand_builtin_strncpy): Likewise.\n\t(expand_builtin_memset_args): Likewise.\n\t* expr.c (move_by_pieces_d::finish_endp): Rename to ...\n\t(move_by_pieces_d::finish_retmode): ... this.\n\t(move_by_pieces): Change last argument type to memop_ret.\n\t(store_by_pieces): Use new enum values\n\tinstead of int constants.\n\t(emit_block_move_hints): Likewise.\n\t(emit_push_insn): Likewise.\n\t(store_expr): Likewise.\n\t* expr.h (store_by_pieces): Change int to newly added enum\n\ttype.\n\t* rtl.h (enum memop_ret): Define.\n\t(move_by_pieces): Use the enum type.\n\nFrom-SVN: r266508", "tree": {"sha": "82fc40305d36ff9ce012e68a6947467161e0a015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82fc40305d36ff9ce012e68a6947467161e0a015"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da193a2713d34358d564c9fd5b5347d7bc2cc150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da193a2713d34358d564c9fd5b5347d7bc2cc150", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da193a2713d34358d564c9fd5b5347d7bc2cc150"}], "stats": {"total": 175, "additions": 107, "deletions": 68}, "files": [{"sha": "b539e130209aaaa86fd231ab60a524916d7cdefc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -1,3 +1,31 @@\n+2018-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\t* asan.c (asan_emit_stack_protection): Use new enum values\n+\tinstead of int constants.\n+\t* builtins.c (expand_builtin_memory_copy_args): Replace int\n+\ttype with memop_ret enum type.\n+\t(expand_builtin_mempcpy_args): Likewise.\n+\t(expand_builtin_memcpy): Use new enum values\n+\tinstead of int constants. Likewise.\n+\t(expand_builtin_mempcpy): Likewise.\n+\t(expand_movstr): Likewise.\n+\t(expand_builtin_strcpy_args): Likewise.\n+\t(expand_builtin_stpcpy_1): Likewise.\n+\t(expand_builtin_strncpy): Likewise.\n+\t(expand_builtin_memset_args): Likewise.\n+\t* expr.c (move_by_pieces_d::finish_endp): Rename to ...\n+\t(move_by_pieces_d::finish_retmode): ... this.\n+\t(move_by_pieces): Change last argument type to memop_ret.\n+\t(store_by_pieces): Use new enum values\n+\tinstead of int constants.\n+\t(emit_block_move_hints): Likewise.\n+\t(emit_push_insn): Likewise.\n+\t(store_expr): Likewise.\n+\t* expr.h (store_by_pieces): Change int to newly added enum\n+\ttype.\n+\t* rtl.h (enum memop_ret): Define.\n+\t(move_by_pieces): Use the enum type.\n+\n 2018-11-27  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/aix71.h (ASM_SPEC): Don't select default -maix64"}, {"sha": "45906bf8fee9ee56499c5b2525315d5a4f3b37f1", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -1484,7 +1484,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \t  && can_store_by_pieces (sz, builtin_memset_read_str, &c,\n \t\t\t\t  BITS_PER_UNIT, true))\n \tstore_by_pieces (shadow_mem, sz, builtin_memset_read_str, &c,\n-\t\t\t BITS_PER_UNIT, true, 0);\n+\t\t\t BITS_PER_UNIT, true, RETURN_BEGIN);\n       else if (use_after_return_class >= 5\n \t       || !set_storage_via_setmem (shadow_mem,\n \t\t\t\t\t   GEN_INT (sz),"}, {"sha": "dcac49d8be1327128039b714160e39d5021158f9", "filename": "gcc/builtins.c", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -126,10 +126,11 @@ static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n-\t\t\t\t\t    rtx target, tree exp, int endp);\n+\t\t\t\t\t    rtx target, tree exp,\n+\t\t\t\t\t    memop_ret retmode);\n static rtx expand_builtin_memmove (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx);\n-static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, int);\n+static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, memop_ret);\n static rtx expand_builtin_strcat (tree, rtx);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, tree, rtx);\n@@ -3751,7 +3752,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n   check_memop_access (exp, dest, src, len);\n \n   return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n-\t\t\t\t\t  /*endp=*/ 0);\n+\t\t\t\t\t  /*retmode=*/ RETURN_BEGIN);\n }\n \n /* Check a call EXP to the memmove built-in for validity.\n@@ -3776,10 +3777,7 @@ expand_builtin_memmove (tree exp, rtx)\n /* Expand a call EXP to the mempcpy builtin.\n    Return NULL_RTX if we failed; the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n-   mode MODE if that's convenient).  If ENDP is 0 return the\n-   destination pointer, if ENDP is 1 return the end pointer ala\n-   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n-   stpcpy.  */\n+   mode MODE if that's convenient).  */\n \n static rtx\n expand_builtin_mempcpy (tree exp, rtx target)\n@@ -3812,20 +3810,17 @@ expand_builtin_mempcpy (tree exp, rtx target)\n     return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t      target, exp, /*endp=*/ 1);\n+\t\t\t\t      target, exp, /*retmode=*/ RETURN_END);\n }\n \n /* Helper function to do the actual work for expand of memory copy family\n    functions (memcpy, mempcpy, stpcpy).  Expansing should assign LEN bytes\n-   of memory from SRC to DEST and assign to TARGET if convenient.\n-   If ENDP is 0 return the\n-   destination pointer, if ENDP is 1 return the end pointer ala\n-   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n-   stpcpy.  */\n+   of memory from SRC to DEST and assign to TARGET if convenient.  Return\n+   value is based on RETMODE argument.  */\n \n static rtx\n expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n-\t\t\t\t rtx target, tree exp, int endp)\n+\t\t\t\t rtx target, tree exp, memop_ret retmode)\n {\n   const char *src_str;\n   unsigned int src_align = get_pointer_alignment (src);\n@@ -3872,7 +3867,7 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n       dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t  builtin_memcpy_read_str,\n \t\t\t\t  CONST_CAST (char *, src_str),\n-\t\t\t\t  dest_align, false, endp);\n+\t\t\t\t  dest_align, false, retmode);\n       dest_mem = force_operand (XEXP (dest_mem, 0), target);\n       dest_mem = convert_memory_address (ptr_mode, dest_mem);\n       return dest_mem;\n@@ -3883,9 +3878,10 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \n   /* Copy word part most expediently.  */\n   enum block_op_methods method = BLOCK_OP_NORMAL;\n-  if (CALL_EXPR_TAILCALL (exp) && (endp == 0 || target == const0_rtx))\n+  if (CALL_EXPR_TAILCALL (exp)\n+      && (retmode == RETURN_BEGIN || target == const0_rtx))\n     method = BLOCK_OP_TAILCALL;\n-  if (endp == 1 && target != const0_rtx)\n+  if (retmode == RETURN_END && target != const0_rtx)\n     method = BLOCK_OP_NO_LIBCALL_RET;\n   dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx, method,\n \t\t\t\t     expected_align, expected_size,\n@@ -3899,11 +3895,11 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n       dest_addr = convert_memory_address (ptr_mode, dest_addr);\n     }\n \n-  if (endp && target != const0_rtx)\n+  if (retmode != RETURN_BEGIN && target != const0_rtx)\n     {\n       dest_addr = gen_rtx_PLUS (ptr_mode, dest_addr, len_rtx);\n       /* stpcpy pointer to last byte.  */\n-      if (endp == 2)\n+      if (retmode == RETURN_END_MINUS_ONE)\n \tdest_addr = gen_rtx_MINUS (ptr_mode, dest_addr, const1_rtx);\n     }\n \n@@ -3912,21 +3908,19 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \n static rtx\n expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n-\t\t\t     rtx target, tree orig_exp, int endp)\n+\t\t\t     rtx target, tree orig_exp, memop_ret retmode)\n {\n   return expand_builtin_memory_copy_args (dest, src, len, target, orig_exp,\n-\t\t\t\t\t  endp);\n+\t\t\t\t\t  retmode);\n }\n \n /* Expand into a movstr instruction, if one is available.  Return NULL_RTX if\n    we failed, the caller should emit a normal call, otherwise try to\n-   get the result in TARGET, if convenient.  If ENDP is 0 return the\n-   destination pointer, if ENDP is 1 return the end pointer ala\n-   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n-   stpcpy.  */\n+   get the result in TARGET, if convenient.\n+   Return value is based on RETMODE argument.  */\n \n static rtx\n-expand_movstr (tree dest, tree src, rtx target, int endp)\n+expand_movstr (tree dest, tree src, rtx target, memop_ret retmode)\n {\n   struct expand_operand ops[3];\n   rtx dest_mem;\n@@ -3937,25 +3931,25 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n \n   dest_mem = get_memory_rtx (dest, NULL);\n   src_mem = get_memory_rtx (src, NULL);\n-  if (!endp)\n+  if (retmode != RETURN_BEGIN)\n     {\n       target = force_reg (Pmode, XEXP (dest_mem, 0));\n       dest_mem = replace_equiv_address (dest_mem, target);\n     }\n \n-  create_output_operand (&ops[0], endp ? target : NULL_RTX, Pmode);\n+  create_output_operand (&ops[0], retmode ? target : NULL_RTX, Pmode);\n   create_fixed_operand (&ops[1], dest_mem);\n   create_fixed_operand (&ops[2], src_mem);\n   if (!maybe_expand_insn (targetm.code_for_movstr, 3, ops))\n     return NULL_RTX;\n \n-  if (endp && target != const0_rtx)\n+  if (retmode != RETURN_BEGIN && target != const0_rtx)\n     {\n       target = ops[0].value;\n       /* movstr is supposed to set end to the address of the NUL\n \t terminator.  If the caller requested a mempcpy-like return value,\n \t adjust it.  */\n-      if (endp == 1)\n+      if (retmode == RETURN_END)\n \t{\n \t  rtx tem = plus_constant (GET_MODE (target),\n \t\t\t\t   gen_lowpart (GET_MODE (target), target), 1);\n@@ -4044,7 +4038,7 @@ expand_builtin_strcpy_args (tree exp, tree dest, tree src, rtx target)\n       return NULL_RTX;\n     }\n \n-  return expand_movstr (dest, src, target, /*endp=*/0);\n+  return expand_movstr (dest, src, target, /*retmode=*/ RETURN_BEGIN);\n }\n \n /* Expand a call EXP to the stpcpy builtin.\n@@ -4091,14 +4085,16 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n       memset (&data, 0, sizeof (c_strlen_data));\n       if (!c_getstr (src, NULL)\n \t  || !(len = c_strlen (src, 0, &data, 1)))\n-\treturn expand_movstr (dst, src, target, /*endp=*/2);\n+\treturn expand_movstr (dst, src, target,\n+\t\t\t      /*retmode=*/ RETURN_END_MINUS_ONE);\n \n       if (data.decl && !TREE_NO_WARNING (exp))\n \twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, data.decl);\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n-\t\t\t\t\t target, exp, /*endp=*/2);\n+\t\t\t\t\t target, exp,\n+\t\t\t\t\t /*retmode=*/ RETURN_END_MINUS_ONE);\n \n       if (ret)\n \treturn ret;\n@@ -4132,7 +4128,8 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \t    }\n \t}\n \n-      return expand_movstr (dst, src, target, /*endp=*/2);\n+      return expand_movstr (dst, src, target,\n+\t\t\t    /*retmode=*/ RETURN_END_MINUS_ONE);\n     }\n }\n \n@@ -4378,7 +4375,8 @@ expand_builtin_strncpy (tree exp, rtx target)\n \t  dest_mem = get_memory_rtx (dest, len);\n \t  store_by_pieces (dest_mem, tree_to_uhwi (len),\n \t\t\t   builtin_strncpy_read_str,\n-\t\t\t   CONST_CAST (char *, p), dest_align, false, 0);\n+\t\t\t   CONST_CAST (char *, p), dest_align, false,\n+\t\t\t   RETURN_BEGIN);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), target);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -4523,7 +4521,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t  val_rtx = force_reg (val_mode, val_rtx);\n \t  store_by_pieces (dest_mem, tree_to_uhwi (len),\n \t\t\t   builtin_memset_gen_str, val_rtx, dest_align,\n-\t\t\t   true, 0);\n+\t\t\t   true, RETURN_BEGIN);\n \t}\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\tdest_align, expected_align,\n@@ -4546,7 +4544,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t  builtin_memset_read_str, &c, dest_align,\n \t\t\t\t  true))\n \tstore_by_pieces (dest_mem, tree_to_uhwi (len),\n-\t\t\t builtin_memset_read_str, &c, dest_align, true, 0);\n+\t\t\t builtin_memset_read_str, &c, dest_align, true,\n+\t\t\t RETURN_BEGIN);\n       else if (!set_storage_via_setmem (dest_mem, len_rtx,\n \t\t\t\t\tgen_int_mode (c, val_mode),\n \t\t\t\t\tdest_align, expected_align,"}, {"sha": "85b7847431bdbefd626a8966c477a8b76e33d34d", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -1146,7 +1146,7 @@ class move_by_pieces_d : public op_by_pieces_d\n     : op_by_pieces_d (to, false, from, true, NULL, NULL, len, align)\n   {\n   }\n-  rtx finish_endp (int);\n+  rtx finish_retmode (memop_ret);\n };\n \n /* Return true if MODE can be used for a set of copies, given an\n@@ -1182,15 +1182,14 @@ move_by_pieces_d::generate (rtx op0, rtx op1,\n }\n \n /* Perform the final adjustment at the end of a string to obtain the\n-   correct return value for the block operation.  If ENDP is 1 return\n-   memory at the end ala mempcpy, and if ENDP is 2 return memory the\n-   end minus one byte ala stpcpy.  */\n+   correct return value for the block operation.\n+   Return value is based on RETMODE argument.  */\n \n rtx\n-move_by_pieces_d::finish_endp (int endp)\n+move_by_pieces_d::finish_retmode (memop_ret retmode)\n {\n   gcc_assert (!m_reverse);\n-  if (endp == 2)\n+  if (retmode == RETURN_END_MINUS_ONE)\n     {\n       m_to.maybe_postinc (-1);\n       --m_offset;\n@@ -1206,13 +1205,11 @@ move_by_pieces_d::finish_endp (int endp)\n \n    ALIGN is maximum stack alignment we can assume.\n \n-   If ENDP is 0 return to, if ENDP is 1 return memory at the end ala\n-   mempcpy, and if ENDP is 2 return memory the end minus one byte ala\n-   stpcpy.  */\n+   Return value is based on RETMODE argument.  */\n \n rtx\n move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n-\t\tunsigned int align, int endp)\n+\t\tunsigned int align, memop_ret retmode)\n {\n #ifndef PUSH_ROUNDING\n   if (to == NULL)\n@@ -1223,8 +1220,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \n   data.run ();\n \n-  if (endp)\n-    return data.finish_endp (endp);\n+  if (retmode)\n+    return data.finish_retmode (retmode);\n   else\n     return to;\n }\n@@ -1244,7 +1241,7 @@ class store_by_pieces_d : public op_by_pieces_d\n     : op_by_pieces_d (to, false, NULL_RTX, true, cfn, cfn_data, len, align)\n   {\n   }\n-  rtx finish_endp (int);\n+  rtx finish_retmode (memop_ret);\n };\n \n /* Return true if MODE can be used for a set of stores, given an\n@@ -1272,15 +1269,14 @@ store_by_pieces_d::generate (rtx op0, rtx op1, machine_mode)\n }\n \n /* Perform the final adjustment at the end of a string to obtain the\n-   correct return value for the block operation.  If ENDP is 1 return\n-   memory at the end ala mempcpy, and if ENDP is 2 return memory the\n-   end minus one byte ala stpcpy.  */\n+   correct return value for the block operation.\n+   Return value is based on RETMODE argument.  */\n \n rtx\n-store_by_pieces_d::finish_endp (int endp)\n+store_by_pieces_d::finish_retmode (memop_ret retmode)\n {\n   gcc_assert (!m_reverse);\n-  if (endp == 2)\n+  if (retmode == RETURN_END_MINUS_ONE)\n     {\n       m_to.maybe_postinc (-1);\n       --m_offset;\n@@ -1370,18 +1366,17 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n    pointer which will be passed as argument in every CONSTFUN call.\n    ALIGN is maximum alignment we can assume.  MEMSETP is true if this is\n    a memset operation and false if it's a copy of a constant string.\n-   If ENDP is 0 return to, if ENDP is 1 return memory at the end ala\n-   mempcpy, and if ENDP is 2 return memory the end minus one byte ala\n-   stpcpy.  */\n+   Return value is based on RETMODE argument.  */\n \n rtx\n store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\t rtx (*constfun) (void *, HOST_WIDE_INT, scalar_int_mode),\n-\t\t void *constfundata, unsigned int align, bool memsetp, int endp)\n+\t\t void *constfundata, unsigned int align, bool memsetp,\n+\t\t memop_ret retmode)\n {\n   if (len == 0)\n     {\n-      gcc_assert (endp != 2);\n+      gcc_assert (retmode != RETURN_END_MINUS_ONE);\n       return to;\n     }\n \n@@ -1393,8 +1388,8 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n   store_by_pieces_d data (to, constfun, constfundata, len, align);\n   data.run ();\n \n-  if (endp)\n-    return data.finish_endp (endp);\n+  if (retmode)\n+    return data.finish_retmode (retmode);\n   else\n     return to;\n }\n@@ -1624,7 +1619,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n     }\n \n   if (CONST_INT_P (size) && can_move_by_pieces (INTVAL (size), align))\n-    move_by_pieces (x, y, INTVAL (size), align, 0);\n+    move_by_pieces (x, y, INTVAL (size), align, RETURN_BEGIN);\n   else if (emit_block_move_via_movmem (x, y, size, align,\n \t\t\t\t       expected_align, expected_size,\n \t\t\t\t       min_size, max_size, probable_max_size))\n@@ -4421,7 +4416,8 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t      && where_pad != stack_direction)\n \t    anti_adjust_stack (gen_int_mode (extra, Pmode));\n \n-\t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align, 0);\n+\t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align,\n+\t\t\t  RETURN_BEGIN);\n \t}\n       else\n #endif /* PUSH_ROUNDING  */\n@@ -5618,7 +5614,8 @@ store_expr (tree exp, rtx target, int call_param_p,\n \t\t\t\t  CONST_CAST (char *,\n \t\t\t\t\t      TREE_STRING_POINTER (str)),\n \t\t\t\t  MEM_ALIGN (target), false,\n-\t\t\t\t  exp_len > str_copy_len ? 1 : 0);\n+\t\t\t\t  (exp_len > str_copy_len ? RETURN_END :\n+\t\t\t\t   RETURN_BEGIN));\n       if (exp_len > str_copy_len)\n \tclear_storage (adjust_address (dest_mem, BLKmode, 0),\n \t\t       GEN_INT (exp_len - str_copy_len),"}, {"sha": "6ae343d81f02762d43c602024377b7b8c002a6d4", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -219,7 +219,7 @@ extern int can_store_by_pieces (unsigned HOST_WIDE_INT,\n    MEMSETP is true if this is a real memset/bzero, not a copy.\n    Returns TO + LEN.  */\n extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT, by_pieces_constfn,\n-\t\t\t    void *, unsigned int, bool, int);\n+\t\t\t    void *, unsigned int, bool, memop_ret);\n \n /* Emit insns to set X from Y.  */\n extern rtx_insn *emit_move_insn (rtx, rtx);"}, {"sha": "c2aaa9eff4b5d12068549b47fe9cdd39e5faeb94", "filename": "gcc/rtl.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff5ffb623e17b6bb81532394cb1f42fe7b354c8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2ff5ffb623e17b6bb81532394cb1f42fe7b354c8", "patch": "@@ -4046,9 +4046,24 @@ extern void expand_null_return (void);\n extern void expand_naked_return (void);\n extern void emit_jump (rtx);\n \n+/* Memory operation built-ins differ by return value.  Mapping\n+   of the enum values is following:\n+   - RETURN_BEGIN - return destination, e.g. memcpy\n+   - RETURN_END - return destination + n, e.g. mempcpy\n+   - RETURN_END_MINUS_ONE - return a pointer to the terminating\n+    null byte of the string, e.g. strcpy\n+*/\n+\n+enum memop_ret\n+{\n+  RETURN_BEGIN,\n+  RETURN_END,\n+  RETURN_END_MINUS_ONE\n+};\n+\n /* In expr.c */\n extern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n-\t\t\t   unsigned int, int);\n+\t\t\t   unsigned int, memop_ret);\n extern poly_int64 find_args_size_adjust (rtx_insn *);\n extern poly_int64 fixup_args_size_notes (rtx_insn *, rtx_insn *, poly_int64);\n "}]}