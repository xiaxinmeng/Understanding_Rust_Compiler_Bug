{"sha": "c8094d835f3b458cc3d47195966d944c89208396", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwOTRkODM1ZjNiNDU4Y2MzZDQ3MTk1OTY2ZDk0NGM4OTIwODM5Ng==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-06-14T20:01:59Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-06-14T20:01:59Z"}, "message": "Remove extra white spacing at end of lines.\n\nFrom-SVN: r100952", "tree": {"sha": "e2e8da31d73e8224774fa3715773e9360eaf680f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e8da31d73e8224774fa3715773e9360eaf680f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8094d835f3b458cc3d47195966d944c89208396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8094d835f3b458cc3d47195966d944c89208396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8094d835f3b458cc3d47195966d944c89208396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8094d835f3b458cc3d47195966d944c89208396/comments", "author": null, "committer": null, "parents": [{"sha": "581fb421b9b908bcc7c99a27ae22204066f8509a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581fb421b9b908bcc7c99a27ae22204066f8509a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581fb421b9b908bcc7c99a27ae22204066f8509a"}], "stats": {"total": 5489, "additions": 2745, "deletions": 2744}, "files": [{"sha": "789815f7d2ebf120cf67be36ad60bcb433cd15ba", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -117,7 +117,7 @@\n \t* parser.c (cp_parser_postfix_expression): Allow non-constant\n \texpressions as arguments to __builtin_constant_p.\n \t* tree.c (builtin_valid_in_constant_expr_p): Use\n-\tDECL_IS_BUILTIN_CONSTANT_P. \n+\tDECL_IS_BUILTIN_CONSTANT_P.\n \n 2005-06-03  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -315,7 +315,7 @@\n \t    Mike Stump  <mrs@apple.com>\n \n \tYet more Objective-C++...\n-\t\n+\n \t* cp-objcp-common.h (cxx_get_alias_set): Move from\n \there...\n \t(cxx_warn_unused_global_decl): Likewise.\n@@ -422,7 +422,7 @@\n \n \t* typeck.c (build_unary_op): Do not resort to address arithmetic\n \twhen taking the address of a COMPONENT_REF.\n-\t\n+\n 2005-05-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* class.c (vtbl_init_data_s): Change the type of fns to\n@@ -593,7 +593,7 @@\n \t* decl2.c (check_classfn): Adjust.\n \t* init.c (sort_mem_initializers, push_base_cleanups): Adjust.\n \t* method.c (do_build_copy_constructor): Adjust.\n-\t* name-lookup.c (new_class_binding, store_binding, \n+\t* name-lookup.c (new_class_binding, store_binding,\n \tstore_bindings, store_class_bindings): Adjust.\n \t* name-lookup.h: Define VEC(cxx_saved_binding,gc),\n \tVEC(cp_class_binding,gc).\n@@ -649,7 +649,7 @@\n \t* typeck.c (cxx_sizeof_or_alignof_type): Check whether the type to\n \twhich sizeof/alignof is dependent, rather than just whether we are\n \tprocessing_template_decl.\n-\t\n+\n 2005-04-17  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cp-tree.h (LOOKUP_GLOBAL): Remove.\n@@ -679,7 +679,7 @@\n \n \t* decl2.c (determine_visibility): Don't use export_class_data.\n \t(import_export_decl): Honor TARGET_CXX_CLASS_DATA_ALWAYS_WEAK and\n-\tTARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY. \n+\tTARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY.\n \n 2005-04-09  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -738,7 +738,7 @@\n \t(cp_parser_type_specifier_seq): In a condition, do not allow\n \tinvalid type-specifier combinations.\n \t(cp_parser_exception_declaration): Adjust call to\n-\tcp_parser_type_specifier_seq. \n+\tcp_parser_type_specifier_seq.\n \n \t* cp-tree.def (TINST_LEVEL): Document TINST_IN_SYSTEM_HEADER_P.\n \t* cp-tree.h (struct tinst_level): Add in_system_header_p.\n@@ -1021,14 +1021,14 @@\n \t(lookup_template_class, instantiate_class_template): Adjust call\n \tto pushtag.\n \t* semantics.c (begin_class_definition): Likewise.\n-\t* rtti.c (init_rtti_processing, build_dynamic_cast_1, \n+\t* rtti.c (init_rtti_processing, build_dynamic_cast_1,\n \ttinfo_base_init, emit_support_tinfos): Use ts_current instead of\n \tts_global.\n \n 2005-03-13  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/20157\n-\t* pt.c (determine_specialization): Reject non-specializations. \n+\t* pt.c (determine_specialization): Reject non-specializations.\n \n 2005-03-11  Per Bothner  <per@bothner.com>\n \n@@ -1054,7 +1054,7 @@\n \n 2005-03-09  Paolo Carlini  <pcarlini@suse.de>\n \n-\tPR c++/16859\t\n+\tPR c++/16859\n \t* decl.c (complete_array_type): In pedantic mode, return\n \t3 for an empty initializer list as the initializer for an\n \tarray of unknown bound (8.5.1/4).\n@@ -1075,7 +1075,7 @@\n \t(cp_finish_decl): Remove dead code.\n \t* init.c (build_vec_init): When determining whether or not the\n \telement type has an asignment operator, look through all array\n-\tdimensions. \n+\tdimensions.\n \t* typeck.c (target_type): Remove.\n \n 2005-03-07  Mark Mitchell  <mark@codesourcery.com>\n@@ -1109,7 +1109,7 @@\n \n \tPR c++/20232\n \t* class.c (update_vtable_entry_for_fn): Don't crash on invalid\n-\tcovariancy. \n+\tcovariancy.\n \n \t* cp-tree.g (THUNK_TARGET): Expand comment.\n \t* method.c (use_thunk): Make sure we also use the target, if that\n@@ -1164,7 +1164,7 @@\n \tPR c++/20152\n \t* parser.c (cp_parser_class_head): Check for redefintions here.\n \t* semantics.c (begin_class_definition): Not here.\n-\t\n+\n \tPR c++/20153\n \t* decl2.c (build_anon_union_vars): Add type parameter.\n \t(finish_anon_union): Pass it.\n@@ -1177,15 +1177,15 @@\n \t* parser.c (cp_parser_direct_declarator): Always complain about\n \tnon-constant array bounds when in a function scope.\n \t* semantics.c (finish_id_expression): Do not mark dependent names\n-\tas non-constant. \n+\tas non-constant.\n \n 2005-02-21  Douglas Gregor  <dgregor@cs.indiana.edu>\n-\t\n+\n \tPR c++/19076\n \tPR c++/6628\n \t* cp-tree.h (cp_apply_type_quals_to_decl): Declared.\n \t* decl.c (grokdeclarator): Pedwarn about qualifying a function\n-\ttype. \n+\ttype.\n \tAdd qualifiers when declaring a typedef of a function type.\n \tMember function pointers pick up the qualifiers of the typedef\n \tused to declare them.\n@@ -1196,7 +1196,7 @@\n \t(start_preparsed_function): Use cp_apply_type_quals_to_decl.\n \t(grokclassfn): Use cp_apply_type_quals_to_decl.\n \t* error.c (dump_type_suffix): Print qualifiers for function\n-\ttypes. \n+\ttypes.\n \t* pt.c (tsubst_decl): Use cp_apply_type_quals_to_decl.\n \t(tsubst): When substituting a function type into a member\n \tpointer type, pass along the qualifiers."}, {"sha": "24d635df7d300d002a38080eab8fc82bd8c04037", "filename": "gcc/cp/ChangeLog-1994", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-1994", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-1994", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-1994?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -805,7 +805,7 @@ Sat Oct  1 15:18:49 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n \tpush_c_function_context.\n \t(pop_cp_function_context): Similarly.\n \t(finish_function): Reverse order of poplevel and pop_nested_class so\n-\tthat current_class_decl is restored properly. \n+\tthat current_class_decl is restored properly.\n \t(start_function): Likewise.\n \t(finish_function): Add parameter 'nested'.  Don't call\n \tpermanent_allocation if (nested)."}, {"sha": "2342d11a730af8305c4bb7280f6f422efb0bcb2e", "filename": "gcc/cp/ChangeLog-1999", "status": "modified", "additions": 178, "deletions": 178, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-1999", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-1999", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-1999?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -7,7 +7,7 @@\n \t(determine_primary_base): ... this.  Simplify.\n \t(create_vtable_ptr): Tweak accordingly.\n \t(finish_struct_1): Simplify.\n-\t\n+\n \t* cp-tree.h (CLASSTYPE_VBASECLASSES): Update documentation.\n \t(CLASSTYPE_N_BASECLASSES): Likewise.\n \t(BINFO_FOR_VBASE): New macro.\n@@ -27,7 +27,7 @@\n \t(get_vbase_types): Don't return a value.  Set\n \tCLASSTYPE_VBASECLASSES here.\n \t* typeck.c (get_delta_difference): Use BINFO_FOR_VBASE.\n-\t\n+\n 1999-12-30  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (fixup_inline_methods): Clear CLASSTYPE_INLINE_FRIENDS.\n@@ -56,10 +56,10 @@\n \t(fixup_inline_methods): New function.\n \t* method.c (fixup_pending_inline): Remove.\n \t(do_inline_function_hair): Likewise.\n-\t\n+\n \t* decl.c (BOOL_TYPE_SIZE): Bools always have size `1' under the\n \tnew ABI.\n-\t\n+\n \t* cp-tree.h (lang_type): Replace abstract_virtuals with pure_virtuals.\n \t(CLASSTYPE_ABSTRACT_VIRTUALS): Rename to ...\n \t(CLASSTYPE_PURE_VIRTUALS): ... this.\n@@ -86,7 +86,7 @@\n \t* typeck2.c (abstract_virtuals_error): Likewise.\n \t* xref.c (GNU_xref_member): Likewise.\n \t* search.c (get_abstract_virtuals): Rename to get_pure_virtuals.\n-\t\n+\n 1999-12-26  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cp-tree.h: Replace ENABLE_CHECKING with ENABLE_TREE_CHECKING\n@@ -98,7 +98,7 @@\n \tDECL_RESULT, not the mode of DECL_RESULT itself.\n \t* semantics.c (finish_named_return_value): Set DECL_UNINLINABLE\n \tfor functions that used named return values.\n-\t\n+\n 1999-12-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (expand_body): Use\n@@ -127,7 +127,7 @@\n \tthe first field in the class.\n \t* tree.c (layout_basetypes): Use CLASSTYPE_N_BASECLASSES.  Handle\n \tseeing TYPE_VFIELD as the first field in the class.\n-\t\n+\n \t* cp-tree.h (TYPE_VIRTUAL_P): Rename to ...\n \t(TYPE_POLYMORPHIC_P): ... this.\n \t(TYPE_USES_COMPLEX_INHERITANCE): Rename to ...\n@@ -160,7 +160,7 @@\n \t* typeck.c (build_component_ref): Likewise.\n \t(build_component_addr): Likewise.\n \t* typeck2.c (process_init_constructor): Likewise.\n-\t\n+\n 1999-12-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* typeck.c (strip_all_pointer_quals): New static function.\n@@ -196,7 +196,7 @@\n \t(avoid_overlap): Moved here from tree.c.\n \t(build_base_fields): Likewise.\n \t(check_bases): New function, split out from finish_base_struct.\n-\t(check_bases_and_members): New function, split out from \n+\t(check_bases_and_members): New function, split out from\n \tfinish_struct_1.\n \t(struct base_info): Remove cant_have_default_ctor,\n \tcant_have_const_ctor, cant_have_asn_ref.\n@@ -209,7 +209,7 @@\n \t(build_base_fields): Don't declare.\n \t* tree.c (avoid_overlap): Remove.\n \t(build_base_fields): Likewise.\n-\t\n+\n \t* optimize.c (struct inline_data): Remove scope_stmt.\n \t(remap_block): Don't use insert_block_after_note.  Don't update\n \tscope_stmt.\n@@ -244,7 +244,7 @@\n \t* method.c (fixup_pending_inline): New function, split out from\t...\n \t(do_inline_function_hair): ... here.\n \t* tree.c (build_vbase_pointer_fields): Remove.\n-\t\n+\n 1999-12-15  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* tree.c (walk_tree): Walk operand subtrees in forward order.\n@@ -367,15 +367,15 @@\n \t(expand_body): Use it.\n \t* tree.c (walk_tree): Special-case TARGET_EXPRs since they\n \tsometimes present the same sub-tree twice.\n-\t\n+\n \t* dump.c (dequeue_and_dump): Abbreviate `class' as `cls', not\n \t`csl'.\n \n \t* semantics.c (finish_switch_cond): Do conversions here, not ...\n \t* typeck.c (c_expand_start_case): Here.\n \n \t* semantics.c (do_poplevel): Remove unused variable.\n-\t\n+\n 1999-12-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (walk_tree): Don't recurse into DECL_INITIAL or DECL_SIZE\n@@ -418,7 +418,7 @@\n \tparameters of the inlined function.\n \t(optimize_function): Prevent recursion into partially complete\n \tfunctions.\n-\t\n+\n \t* cp-tree.def (SCOPE_STMT): Take one operand.\n \t* cp-tree.h (SCOPE_STMT_BLOCK): New macro.\n \t(SCOPE_NULLIFIED_P): Redefine.\n@@ -441,15 +441,15 @@\n \t* tree.c (copy_tree_r): Clear SCOPE_STMT_BLOCK rather than setting\n \tSCOPE_NULLIFIED_P.\n \t* Makefile.in (semantics.o): Depend on RTL_H.\n-\t\n+\n \t* decl2.c (pending_statics_used): Make it a macro.\n \t(saved_inlines_used): Likewise.\n \t(finish_static_data_member_decl): Use VARRAY_PUSH_TREE.\n \t(mark_inline_for_output): Likewise.\n \t(ssdf_decls_used): Remove.\n \t(start_static_storage_duration_function): Use VARRAY_PUSH_TREE.\n \t(generate_ctor_or_dtor_function): Adjust accordingly.\n-\t\n+\n 1999-11-24  Geoffrey Keating  <geoffk@cygnus.com>\n \t    Greg McGary  <gkm@gnu.org>\n \n@@ -483,7 +483,7 @@\n \t* typeck.c (build_component_ref): Don't use scratch_ovl_cons.\n \t(build_x_function_call): Likewise.\n \t(build_c_cast): Don't use min_tree_cons.\n-\t\n+\n 1999-11-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (tsubst_decl): Robustify.\n@@ -497,17 +497,17 @@\n \n 1999-11-25  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* Make-lang.in (CXX_SRCS): Add optimize.c.  \n+\t* Make-lang.in (CXX_SRCS): Add optimize.c.\n \t* Makefile.in (CXX_OBJS): Add optimize.o.\n \t(CXX_TREE_H): Add splay-tree.h, system.h, and $(CONFIG_H).\n \t(spew.o, lex.o, decl.o, decl2.o, typeck2.o, typeck.o): Adjust.\n \t(class.o, call.o, friend.o, init.o, method.o, cvt.o): Likewise.\n \t(search.o, tree.o, ptree.o, rtti.o, except.o, expr.o): Likewise.\n \t(xref.o, pt.o, error.o, errfn.o, repo.o, semantics.o): Likewise.\n \t(dump.o): Likewise.\n-\t(optimize.o): New target.  \n+\t(optimize.o): New target.\n \t* class.c: Don't include splay-tree.h.\n-\t* cp-tree.def (CTOR_COMPLETE): Rename to CTOR_STMT.  \n+\t* cp-tree.def (CTOR_COMPLETE): Rename to CTOR_STMT.\n \t* cp-tree.h: Include splay-tree.h.\n \t(DECL_UNINLINABLE): New macro.\n \t(CTOR_BEGIN_P, CTOR_END_P): New macros.\n@@ -517,7 +517,7 @@\n \t(optimize_function): Likewise.\n \t(cplus_unsave_expr_now): Remove.\n \t(copy_tree_r): Declare.\n-\t(remap_save_expr): Likewise.  \n+\t(remap_save_expr): Likewise.\n \t* decl.c (local_variable_p): Don't\n \tmake it static.\n \t(local_variable_p_walkfn): New function.\n@@ -530,19 +530,19 @@\n \t(start_function): Set the DECL_CONTEXT for automatically generated\n \tlabels.\n \t(finish_constructor_body): Use CTOR_STMT to mark the end of a\n-\tconstructor.  \n+\tconstructor.\n \t* decl2.c: Don't include splay-tree.h.\n-\t(flag_inline_trees): Define.  \n+\t(flag_inline_trees): Define.\n \t* dump.c: Don't include\n-\tsplay-tree.h.  \n+\tsplay-tree.h.\n \t* except.c (expand_end_catch_block): Fix comment formatting.\n \t(expand_end_eh_spec): Set DECL_CONTEXT on temporary variables.\n-\t(expand_throw): Tidy comment.  \n-\t* init.c (build_vec_delete_1): Use create_temporary_var.  \n+\t(expand_throw): Tidy comment.\n+\t* init.c (build_vec_delete_1): Use create_temporary_var.\n \t* lex.c (cplus_tree_code_type): Make it static.\n \t(cplus_tree_code_length): Likewise.\n-\t(cplus_tree_code_name): Likewise.  \n-\t* optimize.c: New file.  \n+\t(cplus_tree_code_name): Likewise.\n+\t* optimize.c: New file.\n \t* semantics.c (finish_goto_stmt): Set DECL_UNLINABLE for functions\n \twith computed gotos.\n \t(setup_vtbl_ptr): Mark the beginnings of constructors with\n@@ -564,11 +564,11 @@\n \t(init_tree): Set lang_unsave to cp_unsave.\n \t(remap_save_expr): Define.\n \t* ir.texi: Document CTOR_STMT.\n-\t\n+\n 1999-11-24  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* search.c (note_debug_info_needed): Do perform this optimization\n-\tfor dwarf2.  \n+\tfor dwarf2.\n \t(maybe_suppress_debug_info): Likewise.  Start by clearing\n \tTYPE_DECL_SUPPRESS_DEBUG.\n \n@@ -599,7 +599,7 @@\n \t(finish_function): Don't call end_protect_partials here.\n \t* ir.texi (CTOR_COMPLETE): Document it.\n \t* semantics.c (expand_stmt): Handle it.\n-\t\n+\n \t* cp-tree.def (FUNCTION_NAME): New tree node.\n \t* cp-tree.h (current_function_name_declared): Tweak documentation.\n \t(lang_decl_flags): Add pretty_function_p, adjust dummy.\n@@ -617,7 +617,7 @@\n \teven in template functions.\n \t(setup_vtbl_ptr): Don't declare __PRETTY_FUNCTION in the\n \tconditional scope at the top of a destructor.\n-\t\n+\n \t* error.c (dump_function_decl): Use `[ with ... ]' syntax for\n \tspecializations too.\n \n@@ -659,7 +659,7 @@\n 1999-11-15  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* cp-tree.h, decl.c (compute_array_index_type): Make nonstatic.\n-\t* pt.c (tsubst, case INTEGER_TYPE): Call it.  \n+\t* pt.c (tsubst, case INTEGER_TYPE): Call it.\n \tCheck uses_template_parms.\n \n \t* class.c (finish_struct): If we're a local class in a template\n@@ -674,7 +674,7 @@\n \t* cp-tree.h: Declare it.\n \t* decl2.c (finish_vtable_vardecl): Override TYPE_DECL_SUPPRESS_DEBUG\n \tif we're writing out the vtable.\n-\t* decl.c, search.c (dfs_debug_mark, dfs_debug_unmarked_p, \n+\t* decl.c, search.c (dfs_debug_mark, dfs_debug_unmarked_p,\n \tnote_debug_info_needed): #if 0 out.\n \n 1999-11-14  Mark Mitchell  <mark@codesourcery.com>\n@@ -684,7 +684,7 @@\n \tTREE_PERMANENT.\n \t* decl.c (pushdecl): Set DECL_LOCAL_FUNCTION_P.\n \t* decl2.c (lookup_arg_dependent): Use it.\n-\t\n+\n \t* cp-tree.h (cp_finish_decl): Change prototype.\n \t(finish_static_data_member_decl): Likewise.\n \t(push_permanent_obstack): Remove declaration.\n@@ -779,7 +779,7 @@\n \t(push_expression_obstack): Remove.\n \t(push_permanent_obstack): Likewise.\n \t* typeck.c (mark_addressable): Likewise.\n-\t\n+\n 1999-11-13  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_conditional_expr): Use build_target_expr_with_type.\n@@ -858,7 +858,7 @@ Thu Nov 11 12:42:11 MST 1999\tDiego Novillo <dnovillo@cygnus.com>\n \t(structsp): Adjust.\n \t* parse.c: Regenerated.\n \t* pt.c (tsubst_enum): Adjust according to build_enumerator changes.\n-\t\n+\n Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n \t                  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -913,7 +913,7 @@ Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n \t* pt.c (tsubst_expr): Don't suspend_momentary or resume_momentary.\n \t* semantics.c (begin_new_placement): Remove.\n \t(finish_new_placement): Likewise.\n-\t\n+\n 1999-11-05  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* cp-tree.h (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK): New macro.\n@@ -933,7 +933,7 @@ Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n \n \t* pt.c (tinst_level_tick): Make it static.\n \t(last_template_error_tick): Likewise.\n-\t\n+\n \t* cp-tree.h (mapcar): Remove declaration.\n \t(search_tree): Likewise.\n \t(walk_tree_fn): New typedef.\n@@ -953,7 +953,7 @@ Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n \t(check_default_argument): Use walk_tree.\n \t* pt.c (for_each_template_parm_r): New function, split out from ...\n \t(for_each_template_parm): Here.  Use it, via walk_tree.\n-\t\n+\n 1999-11-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (check_bitfield_decl): New function, split out from\n@@ -962,7 +962,7 @@ Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n \tanonymous structs.\n \t(finish_struct_1): Use them.\n \t* cp-tree.h (ANON_UNION_TYPE_P): New macro.\n-\t\n+\n 1999-11-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (grokfndecl): Remove dead code.\n@@ -1002,7 +1002,7 @@ Sat Oct 30 22:42:50 1999  Stephen L Moshier <moshier@mediaone.net>\n \tfunction.  Clear DECL_SAVED_TREE after generating RTL for a\n \tfunction.\n \t* Makefile.in (semantics.o): Depend on ggc.h.\n-\t\n+\n 1999-10-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (make_typename_type): Change prototype.\n@@ -1014,7 +1014,7 @@ Sat Oct 30 22:42:50 1999  Stephen L Moshier <moshier@mediaone.net>\n \t* pt.c (convert_template_argument): Pass complain to\n \tmake_typename_type.\n \t(tsubst): Likewise.\n-\t\n+\n 1999-10-28  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (finish_handler): End the scope of the handler\n@@ -1059,7 +1059,7 @@ Sat Oct 30 22:42:50 1999  Stephen L Moshier <moshier@mediaone.net>\n \t(do_pushlevel): Likewise.\n \t(do_poplevel): Likewise.\n \t* tree.c (make_temp_vec): Remove.\n-\t\n+\n \t* dump.c (dequeue_and_dump): Dump HANDLERs and SAVE_EXPRs.  Dump\n \tCLEANUP_P for a TRY_BLOCK.\n \t* ir.texi: Document SAVE_EXPR.\n@@ -1068,7 +1068,7 @@ Tue Oct 26 23:29:56 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* call.c (build_over_call):  Check that the built-in function is\n \tof class BUILT_IN_NORMAL before trying to recongize it as BUILT_IN_ABS.\n-\t* typeck.c (build_function_call_real): Similarly. \n+\t* typeck.c (build_function_call_real): Similarly.\n \n 1999-10-26  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -1078,7 +1078,7 @@ Tue Oct 26 23:29:56 1999  Jeffrey A Law  (law@cygnus.com)\n 1999-10-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (push_overloaded_decl_1): Use pushdecl.\n-\t\n+\n \t* decl.c (auto_function): Replace #ifdef'd __inline with just\n \tplain inline.\n \t* lex.c (my_get_run_time): Likeise.\n@@ -1092,7 +1092,7 @@ Tue Oct 26 23:29:56 1999  Jeffrey A Law  (law@cygnus.com)\n \t(issue_ktype): Likewise.\n \t* parse.y (empty_parms): Likewise.\n \t* parse.c: Regenerated.\n-\t\n+\n 1999-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dump.c (dequeue_and_dump): Replace several uses of\n@@ -1114,12 +1114,12 @@ Tue Oct 26 23:29:56 1999  Jeffrey A Law  (law@cygnus.com)\n \t(do_pushlevel): Use it.\n \t(do_poplevel): Use it.\n \t(expand_stmt): Check SCOPE_PARTIAL_P.\n-\t\n+\n \t* cp-tree.def (EMPTY_CLASS_EXPR): New tree node.\n \t* call.c (build_call): Use EMPTY_CLASS_EXPR instead of RTL_EXPR.\n \t* expr.c (cplus_expand_expr): Expand it.\n \t* ir.texi: Document EMPTY_CLASS_EXPR.\n-\t\n+\n 1999-10-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (DECL_NAMESPACE_SCOPE_P): Don't treat template\n@@ -1147,7 +1147,7 @@ Tue Oct 26 23:29:56 1999  Jeffrey A Law  (law@cygnus.com)\n \t* dump.c (dequeue_and_dump): Handle CLEANUP_POINT_EXPR.\n \n \t* ir.texi: Clean up documentation of RETURN_INIT.\n-\t\n+\n 1999-10-15  Greg McGary  <gkm@gnu.org>\n \n \t* lex.c (lang_init_options): Set flag_bounds_check as \"unspecified\".\n@@ -1179,7 +1179,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* cp-tree.h (build_x_va_arg): Prototype new function.\n \t* call.c (build_x_va_arg): Define it.\n \t* parse.y (unary_expr): Call build_x_va_arg.\n-\t\n+\n \t* cp-tree.h (convert_type_from_ellipsis): Prototype new function.\n \t* call.c (convert_type_from_ellipsis): Define it.\n \t* decl.c (init_decl_processing): Set lang_type_promotes_to.\n@@ -1197,12 +1197,12 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n 1999-10-09  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* cp-tree.h (make_rtl_for_local_static): New function.  \n+\t* cp-tree.h (make_rtl_for_local_static): New function.\n \t* decl.c (make_rtl_for_nonlocal_decl): Move code to create RTL for\n \tlocal statics ...\n \t(make_rtl_for_local_static): Here.\n \t* semantics.c (expand_stmt): Use make_rtl_for_local_static.\n-\t\n+\n 1999-10-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* method.c: Include tm_p.h.\n@@ -1212,12 +1212,12 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* cp-tree.h (cp_make_lake_type): Renamed from make_lang_type.\n \t* lex.c (cp_make_lake_type): Likewise.\n \t* tree.c (init_tree): Init make_lang_type_fn.\n-\t\n+\n 1999-10-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (tsubst_expr): Set DECL_TEMPLATE_INSTANTIATED for a catch\n \tparameter.\n-\t\n+\n \t* semantics.c (expand_stmt): Don't pretend to have asmspecs for\n \tlocal statics if we don't really have them.\n \n@@ -1258,7 +1258,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(expand_upcast_fixups): Likewise.\n \t* typeck.c (build_component_ref): Likewise.\n \t(build_binary_op_nodefault): Likewise.\n-\t\n+\n \t* dump.c (dqueue_and_dump): Dump TYPE_VFIELD.\n \t* ir.texi: Document TYPE_VFIELD.\n \n@@ -1283,21 +1283,21 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(dequeue_and_dump): Unconditionally print children.  Adjust calls\n \tto functions mentioned above.\n \t(dump_node):  Pass DUMP_NONE, instead of DUMP_CHILDREN to queue.\n-\t\n+\n \t* ir.texi: Document BIND_EXPR, LOOP_EXPR, and EXIT_EXPR.\n \t* dump.c (dequeue_and_dump): Dump them.\n-\t\n+\n \t* method.c (synthesize_method): Call setup_vtbl_ptr for destructors.\n \n \t* decl.c (start_function): Set current_in_charge_parm for\n \tconstructors, too, where appropriate.\n \t* search.c (fixup_all_virtual_upcast_offsets): New function.\n \t(expand_indirect_vtbls_init): Use it.\n-\t\n+\n 1999-10-04  Nathan Sidwell  <nathan@acm.org>\n \n \t* decl2.c (grok_alignof): Don't decay lvalues.\n-\t\n+\n \t* init.c (build_new): Remove unused variable.\n \n 1999-10-04  Mark Mitchell  <mark@codesourcery.com>\n@@ -1306,7 +1306,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(static_labelno): Remove macro.\n \t* method.c (build_overload_nested_name): Make static_labelno\n \tstatic here.\n-\t\n+\n \t* pt.c (instantiate_decl): Use DECL_SAVED_TREE, not DECL_INITIAL,\n \tto decide whether or not a function is defined.\n \n@@ -1350,7 +1350,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(building_stmt_tree): Simplify.\n \t* decl.c (mark_stmt_tree): New function.\n \t(mark_saved_scope): Use it.\n-\t(start_function): Rearrange slightly to call begin_stmt_tree \n+\t(start_function): Rearrange slightly to call begin_stmt_tree\n \tearlier.\n \t(save_function_data): Tweak.\n \t(finish_function): Adjust call to finish_stmt_tree.\n@@ -1372,17 +1372,17 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(finish_stmt_tree): Likewise.\n \t* tree.c (search_tree): Don't handle VEC_INIT_EXPR.\n \t(mapcar): Likewise.\n-\t\n+\n \t* parse.y (simple_stmt): Don't call finish_stmt unnecessarily.\n \t* parse.c: Regenerated.\n-\t\n+\n \t* dump.c (dqueue_and_dump): Dump bitfieldness.\n-\t\n+\n \t* tree.c (lvalue_p_1): Use DECL_C_BIT_FIELD to check for\n \tbitfields, rather than DECL_BIT_FIELD.\n \t* ir.texi: Document how to tell whether or not a field is a\n \tbitfield.\n-\t\n+\n \t* lex.c (make_lang_type): Fix typo in comment.\n \n 1999-10-01  Jason Merrill  <jason@yorick.cygnus.com>\n@@ -1410,7 +1410,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(DECL_GLOBAL_CTOR_P, DECL_GLOBAL_DTOR_P): New macros.\n \t(GLOBAL_INIT_PRIORITY): Likewise.\n \t* decl.c (lang_mark_tree): Adjust accordingly.\n-\t(start_objects): Set DECL_GLOBAL_CTOR_P, DECL_GLOBAL_DTOR_P, \n+\t(start_objects): Set DECL_GLOBAL_CTOR_P, DECL_GLOBAL_DTOR_P,\n \tand GLOBAL_INIT_PRIORITY.\n \t* dump.c (dequeue_and_dump): Print them.\n \t* ir.texi: Document them.\n@@ -1432,7 +1432,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(prune_vars_needing_no_initialization): New function.\n \t(write_out_vars): Likewise.\n \t(finish_file): Use the various new functions instead of the old.\n-\t\n+\n Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \n \t* cp-tree.h (warn_float_equal): Declare.\n@@ -1492,7 +1492,7 @@ Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \t(TMPL_ARG, SET_TMPL_ARG, NUM_TMPL_ARGS, TMPL_PARMS_DEPTH): Likewise.\n \t(tsubst_copy): Clarify variable name.\n \t(most_general_template): Robustify.\n-\t\n+\n 1999-09-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* error.c (dump_template_parms): Don't use TS_PEDANTIC_NAME\n@@ -1513,7 +1513,7 @@ Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \t* semantics.c: Include flags.h.\n \t(expand_body): Don't do RTL generation if -fsyntax-only.\n \t* Makefile.in (semantics.o): Depends on flags.h.\n-\t\n+\n 1999-09-28  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* pt.c (most_general_template): Adjust declaration.\n@@ -1613,7 +1613,7 @@ Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \t(cplus_expand_expr): Don't call expand_throw here.\n \t* Makefile.in (expr.o): Depend on except.h.\n \t* ir.texi: Update documentation for THROW_EXPR.\n-\t\n+\n \t* decl.c (start_function): Set x_dont_save_pending_sizes rather\n \tthan calling get_pending_sizes.\n \t* init.c (build_new): Don't save and restore\n@@ -1645,7 +1645,7 @@ Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \tfunction split out from c_expand_return.\n \t(check_return_expr): Likewise.\n \t(c_expand_return): Just generate the RTL for the return.\n-\t\n+\n 1999-09-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CPTI_CLEANUP_TYPE): New macro.\n@@ -1692,7 +1692,7 @@ Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(make_rtl_for_nonlocal_decl): Don't fuss with obstacks.  Simplify.\n \tDon't accidentally make RTL for local declarations.\n \t(emit_local_var): Handle declarations with asm-specifiers here.\n-\t\n+\n 1999-09-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ir.texi: Improve documentation for TARGET_EXPRs.  Discuss\n@@ -1706,21 +1706,21 @@ Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tin function-at-a-time mode.\n \t(finish_objects): Likewise.\n \t(generate_ctor_or_dtor_function): Adjust accordingly.\n-\t\n+\n \t* cp-tree.h (DECL_ANON_UNION_ELEMS): New macro.\n \t* decl2.c (finish_anon_union): Set DECL_ANON_UNION_ELEMS.\n \tDon't call expand_anon_union_decl here\n \t* semantics.c (exapnd_stmt): Call it here, instead.\n \t* typeck.c (mark_addressable): Addressed variables are implicitly\n \tused.\n-\t\n+\n 1999-09-23  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): New macro.\n \t(RECORD_OR_UNION_TYPE_CHECK, LANG_IDENTIFIER_CAST): Likewise.\n \t(DEFARG_NODE_CHECK): Remove; replace with DEFAULT_ARG_CHECK.\n \t* cp-tree.h: Add tree checking macros to various tree access\n-\tmacros.\t\n+\tmacros.\n \t* ptree.c (print_lang_decl): Test for function or variable\n \tbefore accessing template info.\n \n@@ -1730,7 +1730,7 @@ Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* lang-specs.h: If -fshort-wchar, override __WCHAR_TYPE__.\n \t* decl2.c (lang_f_options): Add -fshort-wchar.\n \t* cp-tree.h: Declare flag_short_wchar.\n-\t* decl.c (init_decl_processing): If -fshort-wchar, use 'short unsigned \n+\t* decl.c (init_decl_processing): If -fshort-wchar, use 'short unsigned\n \tint' for wchar_t.\n \n 1999-09-23  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n@@ -1870,7 +1870,7 @@ Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* typeck.c (build_modify_expr): Don't check for assignments to\n \tthis.\n \t(c_expand_return): Don't suggest assigning to `this'.\n-\t\n+\n \t* Makefile.in (decl.o): Depend on RTL_H.\n \t(decl2.o): Likewise.\n \t(class.o): Likewise.\n@@ -1885,7 +1885,7 @@ Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* ir.texi (CTOR_INITIALIZER): Remove mention.  Fix typo.  Add\n \tdetail about the statement-tree.\n-\t\n+\n 1999-09-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* parse.y (primary): Use build_functional_cast for CV_QUALIFIER.\n@@ -1909,7 +1909,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n 1999-09-18  Paul Burchard <burchard@pobox.com>\n \n \t* gxxint.texi: G++ now implements namespaces.\n-\t\n+\n 1999-09-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (pop_label): Don't warn about unused labels more than\n@@ -1929,7 +1929,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n 1999-09-17  Mark Mitchell  <mark@codesourcery.com>\n \n-\tTurn on function-at-a-time processing.  \n+\tTurn on function-at-a-time processing.\n \t* cp-tree.h (doing_semantic_analysis_p): New macro.\n \t(SF_DEFAULT): Define to zero, not SF_EXPAND.\n \t(start_handler_parms): Change prototype.\n@@ -1941,7 +1941,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(begin_catch_block): Declare.\n \t(finish_handler): Change prototype.\n \t(do_pushlevel): Declare.\n-\t(do_poplevel): Likewise.  \n+\t(do_poplevel): Likewise.\n \t* decl.c (pushlevel): Don't create\n \tbinding levels when not doing semantic analysis.\n \t(poplevel): Don't pop them.\n@@ -1965,7 +1965,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(push_cp_function_context): Don't expand functions without an\n \texplicit call to expand_body.\n \t(mark_lang_function): Make eh_spec_try_block and\n-\tx_scope_stmt_stack.  \n+\tx_scope_stmt_stack.\n \t* except.c (expand_end_eh_spec): Don't\n \tdeclare.\n \t(process_start_catch_block): Likewise.\n@@ -1979,13 +1979,13 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(expand_exception_blocks): Simplify.\n \t(start_anon_func): Use do_pushlevel.\n \t(end_anon_func): Use do_poplvel.  Call expand_body for the\n-\tfunction.  \n-\t* expr.c (do_case): Don't call define_case_label.  \n+\tfunction.\n+\t* expr.c (do_case): Don't call define_case_label.\n \t* init.c (create_temporary_var): Set DECL_CONTEXT for local\n-\tvariables.  \n+\tvariables.\n \t* method.c (emit_thunk): Call expand_body for the\n \tthunk.\n-\t(sythesize_method): Likewise.  \n+\t(sythesize_method): Likewise.\n \t* parse.y (handler_args): Give it ttype.\n \t(eat_saved_input): Call expand_body.\n \t(base_init): Use do_pushlevel.\n@@ -1995,7 +1995,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(handler_args): Don't call expand_start_catch_block.  Return the\n \tcatch parameter.  * pt.c (tsubst_expr): Adjust HANDLER handling.\n \t* parse.c: Regenerated.\n-\t* rtti.c (synthesize_tinfo_fn): Call finish_function.  \n+\t* rtti.c (synthesize_tinfo_fn): Call finish_function.\n \t* semantics.c (do_pushlevel): Give it external linkage.  Build\n \tSCOPE_STMTs.\n \t(do_poplevel): Likewise.\n@@ -2018,7 +2018,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tHANDLERs.  Handle SCOPE_STMT, CTOR_INITIALIZER, and RETURN_INIT.\n \t(expand_body): Let expand_stmt handle CTOR_INITIALIZER,\n \tRETURN_INIT and function try blocks.\n-\t\n+\n \t* cp-tree.h (language_function): Add x_eh_spec_try_block.  Add\n \tx_scope_stmt_stack.  Add x_in_charge_parm.\n \t(current_eh_spec_try_block): New macro.\n@@ -2087,7 +2087,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* Makefile.in (CONFLICTS): Adjust.\n \n 1999-09-17  Gabriel Dos Reis  <gdr@codesourcery.com>\n-\t\n+\n \t* error.c: Reduce code duplication.\n \t(dump_template_value): New function.\n \t(dump_type_real): Use it.\n@@ -2122,7 +2122,7 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tproblems with extern \"C\" functions redeclared as static.\n \t(duplicate_decls): When a builtin is redeclared static, make the\n \tnew function have internal linkage.\n-\t\n+\n 1999-09-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (build_expr_from_tree): Handle VA_ARG_EXPR.\n@@ -2141,14 +2141,14 @@ Mon Sep 20 10:49:05 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n 1999-09-14  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* decl.c (build_target_expr): Set TREE_SIDE_EFFECTS on the \n+\t* decl.c (build_target_expr): Set TREE_SIDE_EFFECTS on the\n \tTARGET_EXPR.\n \t* call.c (build_over_call): Don't set TREE_SIDE_EFFECTS on\n \tthe TARGET_EXPR.\n \t* cvt.c (build_up_reference): Likewise.\n \t* tree.c (build_cplus_new): Likewise.\n \t(get_target_expr): Likewise.\n-\t\n+\n Tue Sep 14 01:45:10 1999  Marc Espie <espie@cvs.openbsd.org>\n \n \t* Makefile.in:  Prepend $(SHELL) to move-if-change calls.\n@@ -2195,7 +2195,7 @@ Sun Sep 12 23:29:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \t* error.c (dump_expr): Handle OVERLOADs.\n \t* spew.c (probe_obstack): Remove.\n \t* typeck.c (condition_conversion): Use perform_implicit_conversion.\n-\t\n+\n 1999-09-12  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cp-tree.h (auto_function, define_function): Adjust prototypes.\n@@ -2223,7 +2223,7 @@ Sun Sep 12 23:29:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \tnon-permanent CONSTANTs and STRINGs.\n \t* tree.c (build_cplus_array_type_1): Don't fuss with\n \tTREE_PERMANENT on ARRAY_TYPEs.\n-\t\n+\n \t* cp-tree.def (CLEANUP_STMT): New node.\n \t* cp-tree.h (language_function): Add name_declared.\n \t(current_function_name_declared): New macro.\n@@ -2254,9 +2254,9 @@ Sun Sep 12 23:29:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \t* semantics.c (begin_compound_stmt): Call declare_function_name,\n \tif appropriate.\n \t(finish_decl_cleanup): New function.\n-\t(expand_stmt): Use emit_local_var to output variables.\t\t\n+\t(expand_stmt): Use emit_local_var to output variables.\n \t(expand_body): Set current_function_name_declared.\n-\t\n+\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (finish_cleanup_try_block): New function.\n@@ -2301,7 +2301,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(finish_do_stmt): Likewise.\n \t(finish_for_cond): Likewise.\n \t(expand_cond): Adjust.\n-\t\n+\n \t* cp-tree.h (FN_TRY_BLOCK_P): New macro.\n \t* init.c (perform_member_init): Remove obstack machinations.\n \t(expand_cleanup_for_base): Likewise.\n@@ -2314,7 +2314,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* pt.c (tsubst_expr): Handle various kinds of try blocks.\n \t* semantics.c (expand_stmts): Remove.\n \t(begin_function_try_block): Set FN_TRY_BLOCK_P.\n-\t(finish_function_try_block): Be careful rechaining \n+\t(finish_function_try_block): Be careful rechaining\n \tfunction try blocks.\n \t(expand_stmt): Loop through all the statements at a given level.\n \t(exapnd_body): Be careful with line-numbers here too.  Prepare for\n@@ -2345,7 +2345,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* semantics.c (RECHAIN_STMTS): Remove `last' parameter.\n \t(RECHAIN_STMTS_FROM_LAST): Remove.  Replace all uses with\n-\tRECHAIN_STMTS. \n+\tRECHAIN_STMTS.\n \t(RECHAIN_STMST_FROM_CHAIN): Likewise.\n \n \t* parse.y (simple_stmt): Fix typo in last change.\n@@ -2366,7 +2366,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(finish_stmt_tree): Tweak line-number handling.\n \t(prep_stmt): New function.\n \t(expand_stmt): Use it.\n-\t\n+\n \t* cp-tree.h (begin_switch_stmt): Adjust prototype.\n \t(finish_switch_cond): Likewise.\n \t* parse.y (simple_stmt): Adjust accordingly.\n@@ -2393,10 +2393,10 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(language_function): Rename binding_level to bindings.\n \t(cp_function_chain): Use the current_function, not the\n \touter_function_chain.\n-\t(current_class_ptr): Make it work, even when there's no \n+\t(current_class_ptr): Make it work, even when there's no\n \tcurrent function.\n \t(current_class_ref): Likewise.\n-\t(SF_DEFAULT, SF_PRE_PARSED, SF_INCLASS_INLINE, SF_EXPAND): New \n+\t(SF_DEFAULT, SF_PRE_PARSED, SF_INCLASS_INLINE, SF_EXPAND): New\n \tmacros.\n \t(clear_temp_name): Remove.\n \t* decl.c (check_function_type): New function, broken out from\n@@ -2422,11 +2422,11 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* decl2.c (clear_temp_name): Remove.\n \t(start_objects): Use SF flags to start_function.\n \t(start_static_storage_duration_function): Likewise.\n-\t* except.c (start_anon_func): Remove redundant calls to \n+\t* except.c (start_anon_func): Remove redundant calls to\n \tpush_function_context_to.  Use SF flags to start function.\n \t(end_anon_func): Remove redundant call to pop_function_context\n \tfrom.\n-\t* lex.c (reinit_parse_for_function): Don't initialize per-function \n+\t* lex.c (reinit_parse_for_function): Don't initialize per-function\n \tdata.\n \t* method.c (emit_thunk): Clear current_function after calling\n \tassemble_end_function.  Use SF flags for start_function.\n@@ -2442,7 +2442,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* rtti.c (sythesize_tinfo_fn): Use SF flags to start_function.\n \t* semantics.c (begin_function_definition): Likewise.\n \t(expand_body): Likewise.\n-\t\n+\n 1999-09-09  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-tree.h (convert_to_void): Prototype new function.\n@@ -2456,7 +2456,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(build_static_cast): Likewise.\n \t(build_c_cast): Likewise.\n \t* semantics.c (finish_expr_stmt): Do not decay full expressions.\n-\t\n+\n \t* typeck.c (build_x_compound_expr): Add FIXME.\n \n 1999-09-08  Mark Mitchell  <mark@codesourcery.com>\n@@ -2480,7 +2480,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* typeck.c: Likewise.\n \t* parse.c: Regenerated.\n \t* tree.c (build_srcloc): Simplify.\n-\t\n+\n 1999-09-08  Bruce Korb  autogen@linuxbox.com\n \n \t* Makefile.in: Give the gperf user a hint about why \"gperf -F\" fails.\n@@ -2498,7 +2498,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(retrofit_lang_decl): Likewise.\n \t(copy_lang_decl): Likewise.\n \n-\t* cp-tree.h (saved_scope): Remove old_binding_level and \n+\t* cp-tree.h (saved_scope): Remove old_binding_level and\n \tfunction_decl.  Tidy up.\n \t* decl.c (mark_saved_scope): Don't set them.\n \t(maybe_push_to_top_level): Clear memory.\n@@ -2511,7 +2511,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(grokvardecl): Don't complete types here.\n \n \t* decl.c (start_function): Clear last_dtor_insn and\n-\tlast_parm_cleanup_insn. \n+\tlast_parm_cleanup_insn.\n \t(push_cp_function_context): Just copy over a little of\n \tthe old context, not all of it.\n \n@@ -2555,7 +2555,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* typeckc.c (build_static_cast): Likewise.\n \t(build_reinterpret_cast): Likewise.\n \t(build_const_cast): Likewise.\n-\t\n+\n 1999-09-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (ggc_p): Set it to 1.\n@@ -2635,7 +2635,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(binding_init): Remove.\n \t(init_cplus_unsave): Rename to ...\n \t(init_tree): This.  Add GC roots.\n-\t\n+\n 1999-09-05  Mark Mitchell  <mark@codesourcery.com>\n \n \tGet ready for garbage collection.\n@@ -2678,7 +2678,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(cp_global_trees): Add access_default, access_public,\n \taccess_protected, access_private, access_default_virtual,\n \taccess_public_virtual, access_protected_virtual,\n-\taccess_private_virtual, ctor_identifier, delta2_identifier, \n+\taccess_private_virtual, ctor_identifier, delta2_identifier,\n \tdelta_identifier, dtor_identifier, in_charge_identifier,\n \tindex_identifier, nelts_identifier, this_identifier,\n \tpfn_identifier, pfn_or_delta2_identifier, vptr_identifier,\n@@ -2717,7 +2717,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* decl2.c: Don't include varray.h.\n \t(current_namespace): Remove.\n \t(init_decl2): Add GC roots.\n-\t* except.c (Terminate): Remove. \n+\t* except.c (Terminate): Remove.\n \t(init_exception_processing): Use terminate_node instead.\n \t(build_terminate_handler): Likewise.\n \t* init.c (nc_nelts_field_id): Remove.\n@@ -2752,7 +2752,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(expand_indirect_vtbls_init): Remove redundant declaration of\n \tin_charge_identifier.\n \t(init_search_processing): Use vptr_identifier.\n-\t\n+\n 1999-09-05  Richard Henderson  <rth@cygnus.com>\n \t    Bernd Schmidt <bernds@cygnus.co.uk>\n \t    Mark Mitchell  <mark@codesourcery.com>\n@@ -2773,7 +2773,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(init_init_processing): Add GC roots.\n \t* parse.y: Include ggc.h.\n \t(cp_parse_init): New function.\n-\t\n+\n 1999-09-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (init_decl_processing): Set mark_lang_status.\n@@ -2793,7 +2793,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tx_base_init_list, x_member_init_list, x_base_init_expr,\n \tx_current_class_ptr, x_current_class_ref, x_last_tree,\n \tx_last_expr_type, x_last_dtor_insn, x_last_parm_cleanup_insn, and\n-\tx_result_rtx. \n+\tx_result_rtx.\n \t(dtor_label, ctor_label, current_base_init_list,\n \tcurrent_member_init_list, base_init_expr, current_class_ptr,\n \tcurrent_class_ref, last_tree, last_expr_type): Adjust accordingly.\n@@ -2807,7 +2807,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(mark_false_label_stack): Likewise.\n \t(lang_mark_tree): Likewise.\n \t(lang_cleanup_tree): Likewise.\n-\t\n+\n 1999-09-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (CXX_TREE_H): Include function.h.\n@@ -2841,15 +2841,15 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tpop_cp_function_context.\n \t* init.c: Don't include function.h.\n \t* lex.c (begin_definition_of_inclass_inline): Call\n-\tpush_function_context_to, not push_cp_function_context. \n+\tpush_function_context_to, not push_cp_function_context.\n \t(process_next_inline):  Call pop_function_context_from, not\n \tpop_cp_function_context.\n \t* method.c: Don't include function.h.\n \t(synthesize_method): Call push_function_context_to, not\n \tpush_cp_function_context.  Call pop_function_context_from, not\n \tpop_cp_function_context.\n \t* typeck.c: Don't include function.h.\n-\t\n+\n \t* decl.c (expand_static_init): Tweak handling of static\n \tinitializations for objects without constructors.\n \n@@ -2915,12 +2915,12 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(last_expr_type): Likewise.\n \t* typeck.c (dtor_label): Likewise.\n \t(ctor_label): Likewise.\n-\t\n+\n 1999-09-01  Alex Samuel  <samuel@codesourcery.com>\n \n \t* decl2.c (arg_assoc_template_arg): New prototype.  New function.\n \t(arg_assoc_class): Use arg_assoc_template_arg for template\n-\targuments. \n+\targuments.\n \t(arg_assoc): Likewise.\n \t* pt.c (mangle_class_name_for_template): Allow member template\n \ttemplate arguments.\n@@ -2992,7 +2992,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(tsubst_expr): Adjust calls to expand_start_catch_block\n \tappropriately.\n \t* semantics.c (expand_stmt): Likewise.\n-\t\n+\n 1999-08-29  Alex Samuel  <samuel@codesourcery.com>\n \n \t* pt.c (push_template_decl_real): Use template declaration from\n@@ -3020,7 +3020,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* pt.c (tsbust_expr): Fix indentation.  Call cp_finish_decl here.\n \t* semantics.c (expand_stmt): Don't call cp_finish_decl here.  Just\n \tcall initialize_local_var to generate initialization code.\n-\t\n+\n 1999-08-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h (fndecl_as_string, type_as_string,\n@@ -3057,7 +3057,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(make_rtl_for_nonlocal_decl): Likewise.\n \t(cp_finish_decl): Use them.\n \t* typeck.c (strip_array_types): New function.\n-\t\n+\n \t* cp-tree.def (LABEL_STMT): New tree node.\n \t* cp-tree.h (LABEL_STMT_LABEL): New macro.\n \t(shadow_label): Remove.\n@@ -3090,7 +3090,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \tbuilding_stmt_tree.\n \t(finish_label_decl): New function.\n \t(expand_stmt): Handle LABEL_STMTs and local label declarations.\n-\t\n+\n 1999-08-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (lookup_label): Build labels on the permanent obstack\n@@ -3102,15 +3102,15 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(expand_stmt): Adjust accordingly.\n \t* pt.c (tsubst_expr); Likewise.\n \t(do_decl_instantiation): Robustify.\n-\t\n+\n \t* cp-tree.h (AGGR_INIT_VIA_CTOR_P): New macro.\n \t* tree.c (build_cplus_new): Set it.\n \t* expr.c (cplus_expand_expr): Use it.\n \t* dump.c (deque_and_dump): Handle AGGR_INIT_EXPR.\n-\t\n+\n \t* decl.c (store_parm_decls): Reset immediate_size_expand.\n \t(finish_function): Likewise.\n-\t\n+\n \t* tree.c (cplus_unsave_expr_now): Don't return a value.\n \n \t* semantics.c (do_poplevel): Always initialize the return value.\n@@ -3209,7 +3209,7 @@ Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t* typeck.c (build_modify_expr): Don't build an RTL_EXPR.\n \t* typeck2.c (store_init_value): Change expand_aggr_init to\n \tbuild_aggr_init in comment.\n-\t\n+\n 1999-08-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dump.c (dequeue_and_dump): Dump TARGET_EXPRs.\n@@ -3254,12 +3254,12 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* dump.c (dump_next_stmt): New function.\n \t(dequeue_and_dump): Use it.\n-\t\n+\n \t* pt.c (tsubst_copy): Make sure to initialize return value for a\n \tSTMT_EXPR, even when processing_template_decl.\n \t* semantics.c (finish_stmt_expr): A statement-expression whose\n-\tlast statement is not an expression-statement has type `void'.\t\n-\t\n+\tlast statement is not an expression-statement has type `void'.\n+\n 1999-08-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (finish_stmt_expr): Fix typo in comment.\n@@ -3269,7 +3269,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \tBIND_EXPR permanent.\n \t* pt.c (register_specialization): Don't register a specialization\n \tmore than once.\n-\t\n+\n 1999-08-18  Andrew Haley  <aph@cygnus.com>\n \n \t* method.c (process_overload_item): Call build_mangled_C9x_name ()\n@@ -3305,7 +3305,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t(tsubst_copy): Likewise.\n \t* tree.c (search_tree): Likewise.\n \t* semantics.c (finish_pseudo_destructor_call): Create it.\n-\t\n+\n 1999-08-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* search.c (setup_class_bindings): Robustify.\n@@ -3388,7 +3388,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t(build_lang_field_decl): Likewise.\n \t(copy_lang_decl): Use CAN_HAVE_FULLLANG_DECL_P to decide how much\n \tto copy.\n-\t\n+\n \t* cp-tree.def (STMT_EXPR): New tree node.\n \t* cp-tree.h (STMT_EXPR_STMT): New macro.\n \t(store_return_init): Change prototype.\n@@ -3484,23 +3484,23 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \tsorry, if an unsupported node is encountered.\n \t* typeck.c (require_complete_type_in_void): Handle BIND_EXPR.\n \t(c_expand_return): Don't call add_tree here.\n-\t\n+\n 1999-08-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (check_default_tmpl_args): Don't check in local scopes.\n \t(tsubst_decl): Make sure the declaration is on a saveable\n \tobstack.  Clear DECL_DEAD_FOR_LOCAL when making a copy of a local\n \tvariable.\n \t(tsubst_expr): Adjust now that DECL_STMTs really contain DECLs.\n-\t\n+\n 1999-08-14  Jason Merrill  <jason@yorick.cygnus.com>\n \n \tSpeed up Koenig lookup.\n \t* decl.c (unqualified_namespace_lookup): Nonstatic.  Add spacep parm\n \tto return namespaces we've looked at.\n \t* decl2.c (lookup_using_namespace): Likewise.\n \t(add_function): Don't call ovl_member.\n-\t(lookup_arg_dependent): Initialize k.namespaces to the list of \n+\t(lookup_arg_dependent): Initialize k.namespaces to the list of\n \tnamespaces seen in unqualified lookup.\n \t* call.c (equal_functions): Move here from tree.c.\n \t(joust): Use it to handle duplicate candidates.\n@@ -3580,7 +3580,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t(push_permanent_obstack): Define.\n \t(mark_addressable): Use it.\n \t* typeck.c (mark_addressable): Likewise.\n-\t\n+\n 1999-08-13  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* cp-tree.h (init_cplus_unsave): New.\n@@ -3627,11 +3627,11 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t* dump.c (queue): Be careful when computing bitmasks.\n \t(dequeue_and_dump): Describe binfos as binfos, not as\n \tvectors.\n-\t\n+\n \t* parse.y (pedantic): Give it itype.  Adjust usage accordingly\n-\tthroughout. \t\n+\tthroughout.\n \t* parse.c: Regenerated.\n-\t\n+\n \t* Make-lang.in (CXX_SRCS): Remove sig.c.\n \t* Makefile.in (CXX_OBJS): Remove sig.o.\n \t(sig.o): Remove.\n@@ -3718,12 +3718,12 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t* hash.h: Regenerated.\n \t* init.c (build_new_1): Remove support for signatures.\n \t* lang-options.h: Remove -fhandle-signatures,\n-\t-fno-handle-signatures. \n+\t-fno-handle-signatures.\n \t* lex.c (init_parse): Remove support for signatures.\n \t(yyprint): Likewise.\n \t* lex.h (rid): Remove RID_SIGNATURE.\n \t* method.c (build_decl_overload_real): Remove support for\n-\tsignatures. \n+\tsignatures.\n \t(hack_identifier): Likewise.\n \t* parse.y (base_class): Likewise.\n \t(base_class.1): Likewise.\n@@ -3750,7 +3750,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t(build_x_arrow): Likewise.\n \t(build_functional_cast): Likewise.\n \t* xref.c (GNU_xref_decl): Likewise.\n-\t\n+\n 1999-08-10  Martin v. Loewis  <martin@mira.isdn.cs.tu-berlin.de>\n \n \t* lex.c (do_identifier): Remove unnecessary lookup of class field.\n@@ -3869,7 +3869,7 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t* search.c (binfo_from_vbase): New fn.\n \t* cp-tree.h: Declare it.\n \t* cvt.c (cp_convert_to_pointer): Use it to diagnose conversion\n-\tfrom pointer to member of virtual base.  \n+\tfrom pointer to member of virtual base.\n \t* typeck.c (get_delta_difference): Likewise.\n \n 1999-08-06  Alexandre Oliva  <oliva@dcc.unicamp.br>\n@@ -3892,13 +3892,13 @@ Mon Aug 23 22:17:20 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \t`1', `2', and `<'; handle them generically.  Don't be sorry about\n \t\"unrecognized tree codes\"; just abort.\n \t(no_linkage_check): Don't do linkage checks for templates.\n-\t\n+\n \t* tree.c (cp_build_qualified_type_real): Handle\n \tpointer-to-member-function types correctly.\n \n 1999-08-05  Jason Merrill  <jason@yorick.cygnus.com>\n \n-\t* decl.c (pushdecl): Only give an error for shadowing a parm \n+\t* decl.c (pushdecl): Only give an error for shadowing a parm\n \tfrom *this* function.\n \n Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n@@ -3932,7 +3932,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \tspecifiers.\n \t(comptypes): Adjust for comp_except_specs.\n \t* typeck2.c (add_exception_specifier): New global function.\n-\t\n+\n \t* class.c (check_for_override): Reword error message.\n \n 1999-08-03  Nathan Sidwell  <nathan@acm.org>\n@@ -3995,7 +3995,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t(tsubst_expr): Use STMT_LINENO.\n \t* semantics.c (finish_asm_stmt): Eliminate duplicate code.  Check\n \tfor invalid cv-qualifiers even while building templates.\n-\t\n+\n 1999-08-02  Richard Henderson  <rth@cygnus.com>\n \n \t* call.c: Include defaults.h instead of expr.h.\n@@ -4059,7 +4059,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t(build_conditional_expr): Tweak.\n \t(convert_like): Some BASE_CONVs really do require the generation\n \tof code.\n-\t\n+\n \t* init.c (perform_member_init): Don't go through build_modify_expr\n \tfor simple initializations.\n \n@@ -4101,7 +4101,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t* tree.c (debug_binfo): Likewise.\n \t* decl2.c (mark_vtable_entries): Don't bash abstract virtuals to\n \t__pure_virtual here.\n-\t\n+\n 1999-07-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (build_cplus_new): Adjust call to abstract_virtuals_error\n@@ -4165,7 +4165,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t(build_binary_op_nodefault): Use null_ptr_cst_p.\n \t(build_conditional_expr): Remove.\n \t(convert_for_assignment): Use new conversion functions.\n-\t\n+\n \t* cp-tree.h (abstract_virtuals_error): Change declaration.\n \t* typeck2.c (abstract_virtuals_error): Check to see if an error\n \toccurred, and return a boolean value accordingly.\n@@ -4181,7 +4181,7 @@ Thu Aug  5 02:40:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t* pt.c (unify): Don't get confused by pointers-to-member functions.\n \n \t* search.c (build_cplus_new): Robustify.\n-\t\n+\n 1999-07-24  Richard Henderson  <rth@cygnus.com>\n \n \t* gxx.gperf (__builtin_va_arg): New.\n@@ -4251,7 +4251,7 @@ Sun Jul 25 15:24:21 1999  Jeffrey A Law  (law@cygnus.com)\n \t(lvalue_p): Likewise.\n \t(build_cplus_new): Don't allow the creation of an abstract class.\n \t* typeck.c (convert_for_initialization): Use initialize_reference.\n-\t\n+\n 1999-07-21  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* lex.c (real_yylex) : Correct the test for overflow when lexing\n@@ -4361,7 +4361,7 @@ Sat Jul 17 23:51:30 1999  Jeffrey A Law  (law@cygnus.com)\n \t* Makefile.in (INTERFACE): Bump to 2.\n \n 1999-07-17  Alexandre Oliva  <oliva@dcc.unicamp.br>\n-\t\n+\n \t* typeck2.c (my_friendly_abort): Updated URL with bug reporting\n \tinstructions to gcc.gnu.org.  Removed e-mail address.\n \n@@ -4385,7 +4385,7 @@ Sat Jul 17 23:51:30 1999  Jeffrey A Law  (law@cygnus.com)\n \t* class.c (method_name_cmp): New function.\n \t(finish_struct_methods): Modified to support sorting and searching\n \tmethods.\n-\t(finish_struct_anon): Changed code in inner loop to use ELT rather \n+\t(finish_struct_anon): Changed code in inner loop to use ELT rather\n \tthan UELT (which required an extra indirection for every reference).\n \t(field_decl_cmp): New function to support sorting FIELD_DECLs.\n \t(finish_struct_1): Sort fields.\n@@ -4430,7 +4430,7 @@ Sat Jul 17 23:51:30 1999  Jeffrey A Law  (law@cygnus.com)\n \tinitial declaration, then don't save the inline info and by all\n \tmeans don't mark the function as a builtin function.\n \n-\t* decl.c (lookup_name_real): Set NONCLASS to 1 if \n+\t* decl.c (lookup_name_real): Set NONCLASS to 1 if\n \tCURRENT_CLASS_TYPE is 0.\n \n \t* class.c (duplicate_tag_error): Set TYPE_NONCOPIED_PARTS to\n@@ -4469,7 +4469,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t(init_decl_processing): Handle/use the two new types.\n \t* lex.c (real_yylex): Same.\n \t* typeck.c (unsigned_type,signed_type,signed_or_unsigned_type) :\n-\tSame. \n+\tSame.\n \n 1999-07-01  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -4491,7 +4491,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* error.c (dump_type_real): Handle TREE_LIST again.\n \n-\t* typeck.c (comp_target_parms): Don't complain about \n+\t* typeck.c (comp_target_parms): Don't complain about\n \tconverting from () to (...) if !flag_strict_prototype.\n \n \t* decl.c (grokdeclarator): Update the names of all variants when\n@@ -4500,7 +4500,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n 1999-06-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (expand_aggr_vbase_init): Rename to\n-\tconstruct_virtual_bases.  Conditionalize construction here, \n+\tconstruct_virtual_bases.  Conditionalize construction here,\n \trather than ...\n \t(emit_base_init): Here.\n \n@@ -4515,16 +4515,16 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* error.c (dump_expr): Handle BIND_EXPR, LOOP_EXPR, and\n \tEXIT_EXPR.\n-\t\n+\n 1999-06-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (expand_aggr_vbase_init): Add flag parameter.\n \t(build_partial_cleanup_for): Remove, inlining into ..\n \t(expand_cleanup_for_base): ... here.  Take flag parameter.\n \t(emit_base_init): Pass the in_chrg parameter to\n-\temit_aggr_vbase_init. \n+\temit_aggr_vbase_init.\n \t(emit_aggr_vbase_init): Pass it to expand_cleanup_for_base.\n-\t\n+\n 1999-06-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (import_export_decl): Use same_type_p, rather than\n@@ -4558,7 +4558,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t(push_class_level_binding): Use push_cache_obstack, not\n \tmaybe_push_cache_obstack.\n \t* search.c (push_class_decls): Likewise.\n-\t\n+\n 1999-06-14  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* pt.c (tsubst_friend_function): Push into namespace of friend\n@@ -4637,7 +4637,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t* tree.c (build_cplus_array_type_1): Use push_obstacks_nochange\n \tand friends rather than messing with current_obstack directly.\n \t(cp_build_qualified_type_real): Rework ARRAY_TYPE\n-\tallocation to match practice throughout the rest of the \n+\tallocation to match practice throughout the rest of the\n \tcompiler.\n \n 1999-05-30  Mark Mitchell  <mark@codesourcery.com>\n@@ -4679,7 +4679,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t(DECL_SAVED_TREE): Document.\n \t(DECL_TEMPLATE_INJECT): Remove.\n \t* class.c (finish_struct): Remove code to deal with\n-\tDECL_TEMPLATE_INJECT. \n+\tDECL_TEMPLATE_INJECT.\n \n \t* decl.c (maybe_process_template_type_declaration): Handle all new\n \ttypes in templates uniformly.\n@@ -4689,15 +4689,15 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \tforward-declarations.\n \t(instantiate_class_template): Remove code processing\n \tDECL_TEMPLATE_INJECT.\n-\t\n+\n \t* pt.c (lookup_template_class): Tweak lookup to find member\n \ttemplates.\n \n \t* pt.c (tsubst_expr, case ASM_STMT): Don't tsubst into\n \tASM_CV_QUAL.\n \t* semantics.c (finish_asm_stmt): Make strings permanent if they're\n \tused in a template.\n-\t\n+\n 1999-05-25  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (casts_away_constness, casts_away_constness_r): Strip both\n@@ -4707,7 +4707,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* decl2.c (mark_vtable_entries): Don't make a copy of a function,\n \tand then make it look like `abort'.  Just use `abort' instead.\n-\t\n+\n \t* typeck.c (build_static_cast): Don't allow static_casts that cast\n \taway constness.\n \t(casts_away_constness_r): New function.\n@@ -4720,12 +4720,12 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t* lex.c (is_global): A template parameter isn't global.\n \t* parse.y (class_head): Robustify.\n \t* parse.c: Regenerated.\n-\t\n+\n 1999-05-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (for_each_template_parm): Walk into TYPENAME_TYPEs,\n \tINDIRECT_REFs, and COMPONENT_REFs.  Handle FIELD_DECLs.\n-\t\n+\n \t* cp-tree.h (push_nested_namespace): Declare.\n \t(pop_nested_namespace): Likewise.\n \t* decl.c (push_nested_namespace): New function.\n@@ -4746,7 +4746,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n 1999-05-21  Mark Mitchell  <mark@codesourcery.com>\n \t    Nathan Sidwell  <nathan@acm.org>\n-\t\n+\n \t* Make-lang.in (cc1plus): Make it depend on gxx.gperf.\n \t* cp-tree.h: Fix typo in documentation on pointers-to-members.\n \t(cp_build_qualified_type): Make it a macro.\n@@ -4768,7 +4768,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t(cp_build_qualified_type): Rename to ...\n \t(cp_build_qualified_type_real): Add additional COMPLAIN parameter\n \tand modify appropriately.\n-\t\n+\n \t* typeck.c (build_ptrmemfunc): Handle PTRMEM_CSTs carefully to\n \treveal optimization opportunities.\n \n@@ -4883,7 +4883,7 @@ Tue May 18 00:21:34 1999  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \t* search.c (marked_pushdecls_p): Don't descend into\n \tTEMPLATE_TYPE_PARMs and the like.\n \t(unmarked_pushdecls_p): Likewise.\n-\t\n+\n \t* call.c (build_over_call): Don't throw away\n \tinitializations/copies of empty classes; use MODIFY_EXPR and\n \tINIT_EXPR as for non-empty classes.\n@@ -4935,7 +4935,7 @@ Tue May 18 00:21:34 1999  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \tconvert_for_initialization): Likewise.\n \t* class.c (instantiate_type): Handle seeing a baselink under an\n \tOFFSET_REF.\n-\t* error.c (dump_expr): Likewise.\t\n+\t* error.c (dump_expr): Likewise.\n \t* pt.c (for_each_template_parm): Likewise.\n \t(resolve_overloaded_unification): Likewise.\n \t* tree.c (is_overloaded_fn, really_overloaded_fn): Likewise.\n@@ -4986,7 +4986,7 @@ Tue May 18 00:21:34 1999  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \tTREE_LIST for ambiguous lookups.\n \t(setup_class_bindings): Adjust accordingly.\n \t(push_class_decls): Revise out-of-date comments.\n-\t\n+\n \t* typeck.c (build_const_cast): Tighten checks for legality.\n \n 1999-05-02  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>"}, {"sha": "07ed1edbfcc3a621fd4cd1305fade625ad737f8b", "filename": "gcc/cp/ChangeLog-2003", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-2003", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog-2003", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-2003?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -190,7 +190,7 @@\n \tother parsing fails.\n \t(cp_parser_enclosed_template_argument_list): If the argument list is\n \tparsed correctly, but the next token is '>>', emit a diagnostic.\n-\t(cp_parser_next_token_ends_template_argument): Accept '>>' as \n+\t(cp_parser_next_token_ends_template_argument): Accept '>>' as\n \tdelimiter of template argument, it will be later detected as a typo.\n \n 2003-12-17  Kelley Cook  <kcook@gcc.gnu.org>\n@@ -396,7 +396,7 @@\n \n \tPR c/13134\n \t* decl.c (duplicate_decls): Copy visibility flag when appropriate.\n-\t\n+\n 2003-12-09  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* init.c (build_new_1): Deal with an OVERLOAD set when\n@@ -414,7 +414,7 @@\n \n \tPR c++/11929\n \t* call.c (magic_varargs_p): New fn.\n-\t(build_over_call): Do no ellipsis conversions for arguments to \n+\t(build_over_call): Do no ellipsis conversions for arguments to\n \tfunctions with magic varargs.\n \n \t* name-lookup.c, init.c, except.c: Revert Giovanni's patch from\n@@ -460,7 +460,7 @@\n \tPR c++/13305\n \t* parser.c (cp_parser_elaborated_type_specifier): Accept\n \tattributes.\n-\t\n+\n 2003-12-05  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13314\n@@ -514,7 +514,7 @@\n 2003-12-02  Richard Henderson  <rth@redhat.com>\n \n \t* name-lookup.h (struct cp_binding_level): Use ENUM_BITFIELD.\n-        * parser.c (struct cp_token): Likewise.   \n+        * parser.c (struct cp_token): Likewise.\n         (struct cp_parser_token_tree_map_node): Likewise.\n \t* lex.c (struct resword): Move const after ENUM_BITFIELD.\n \n@@ -709,7 +709,7 @@\n \t* decl.c (duplicate_decls): copy DECL_VISIBILITY field.\n \t* method.c (use_thunk): give thunk same visibility as function.\n \t* optimize.c (maybe_clone_body): copy DECL_VISIBILITY field.\n-\t\n+\n 2003-11-05  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/11616\n@@ -799,7 +799,8 @@\n \tmangle a non-existant middle operator to the ?: operator.\n \n 2003-10-21  Robert Bowdidge   <bowdidge@apple.com>\n-\t* decl.c (cp_finish_decl): Remove clause intended for asm directives \n+\n+\t* decl.c (cp_finish_decl): Remove clause intended for asm directives\n           in struct or class fields: this code is never executed.\n \n 2003-10-22  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n@@ -961,7 +962,7 @@\n \n 2003-10-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n-\tBreak out decl.c (2/n) \n+\tBreak out decl.c (2/n)\n \t* name-lookup.c: Include diagnostic.h\n \t(cxx_binding_free): Make static.\n \t(cxx_binding_make): Likewise.\n@@ -1056,7 +1057,7 @@\n \t(maybe_process_template_type_declaration): Likewise.\n \t(pop_binding): Likewise.\n \t* cp-tree.h: Move corresponding declarations to name-lookup.h\n-\t\n+\n 2003-10-12  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cvt.c (ocp_convert): Move warning to C common code.\n@@ -1096,7 +1097,7 @@\n \tpp_cxx_flag_qualified_id and pp_cxx_flag_global_scope.\n \t* cxx-pretty-print.c (pp_cxx_id_expression): Always display\n \tqualified entities using qualified names.\n-\t\n+\n \tPR c++/12337\n \t* init.c (build_new_1): Make sure that the expression returned is\n \tnot an lvalue.\n@@ -1122,7 +1123,7 @@\n 2003-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* name-lookup.c (binding_entry_free): Nullify name and type\n-\tfields. \n+\tfields.\n \n 2003-10-02  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -1143,7 +1144,7 @@\n 2003-09-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* decl.c (pop_binding): Don't mess with nullifying binding->scope\n-\there. \n+\there.\n \t* name-lookup.c: Re-format.\n \t(cxx_binding_free): Nullify binding->scope.\n \n@@ -1286,7 +1287,7 @@\n 2003-09-19  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* decl.c (cxx_scope_descriptor): Fix thinko.\n-\t(struct cp_binding_level): Adjust type of binding_depth field. \n+\t(struct cp_binding_level): Adjust type of binding_depth field.\n \n 2003-09-18  Danny Smith  <dannysmith@users.sourceforge.net>\n \n@@ -1317,7 +1318,7 @@\n 2003-09-18  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* error.c (dump_type): Simplify.  Use pp_type_specifier_seq for\n-\t\"C\" types. \n+\t\"C\" types.\n \t* cxx-pretty-print.c (pp_cxx_type_specifier_seq): Fix thinko.\n \n 2003-09-17  Richard Henderson  <rth@redhat.com>\n@@ -1397,7 +1398,7 @@\n \tthe various flags.\n \t(set_block): Remove check for doing_semantic_analysis_p.\n \t(pushlevel_class): Use \"kind\" field in binding_level, not\n-\tthe various flags. \n+\tthe various flags.\n \t(poplevel_class): Likewise.\n \t(initial_push_namespace_scope): Likewise.\n \t(maybe_push_to_top_level): Likewise.\n@@ -1427,7 +1428,7 @@\n \t(save_function-data): Do not set expanding_p.\n \t(cxx_push_function_context): Do not clear expanding_p.\n \t* semantics.c (cxx_expand_function_start): Do not set expanding_p.\n-\t\n+\n 2003-09-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_class_type): Make DECL_MODE match TYPE_MODE for\n@@ -1487,7 +1488,7 @@\n \n 2003-09-09  Richard Henderson  <rth@redhat.com>\n \n-\t* semantics.c (expand_or_defer_fn): Update call to \n+\t* semantics.c (expand_or_defer_fn): Update call to\n \tcgraph_finalize_function.\n \n \t* semantics.c (expand_or_defer_fn): Use cgraph_finalize_function\n@@ -1540,7 +1541,7 @@\n \t* error.c (dump_decl): Handle namespace-alias-definition.\n \t* decl.c (warn_extern_redeclared_static): There is no point in\n \tchecking changes in storage class specifier for a namespace\n-\tdeclaration. \n+\tdeclaration.\n \t(duplicate_decls): Tidy diagnostic message.\n \t* cxx-pretty-print.c (pp_cxx_left_brace): New macro.\n \t(pp_cxx_right_brace): Likewise.\n@@ -1571,7 +1572,7 @@\n \t(push_class_binding): Likewise.\n \t(set_identifier_type_value_with_scope): Likewise.\n \t* name-lookup.c (supplement_binding): Rename from add_binding.\n-\tReturn a bool.  Improve documentation. \n+\tReturn a bool.  Improve documentation.\n \t(set_namespace_binding): Adjust.\n \t* Make-lang.in (cp/name-lookup.o): Depend on toplev.h\n \n@@ -1785,7 +1786,7 @@\n \n \tPR c++/11811\n \t* cxx-pretty-print.c (pp_cxx_canonical_template_parameter): New\n-\tfunction. \n+\tfunction.\n \t* cxx-pretty-print.h: Declare.\n \t* error.c (dump_template_parameter): Use it.\n \t(dump_type): Likewise."}, {"sha": "a85593c3d5785d9cc9d9fe6b449815abf0614b45", "filename": "gcc/cp/ChangeLog.tree-ssa", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog.tree-ssa?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -49,7 +49,7 @@\n \n \t* init.c (build_vec_delete_1): Convert 2nd argument to NE_EXPR to\n \tthe proper type.\n- \n+\n 2004-02-24  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/13944\n@@ -89,7 +89,7 @@\n \t* call.c, cvt.c, init.c, typeck.c: Use TREE_NO_WARNING instead\n \tof TREE_NO_UNUSED_WARNING.\n \t* cvt.c (convert_to_void): Also use it for \"has no effect\" warning.\n-\t\n+\n 2004-01-30  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* cp-mudflap.c (mflang_flush_calls): Mark static ctor as TREE_USED.\n@@ -138,7 +138,7 @@\n \t* cp-lang.c (LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Kill.\n \t* cp-tree.h (cxx_callgraph_analyze_expr): Kill.\n \t* decl2.c (cxx_callgraph_analyze_expr): Kill.\n-\t\n+\n 2003-12-14  Jan Hubicka  <jh@suse.cz>\n \n \t* cp-lang.c (LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Kill."}, {"sha": "abd39d4b43ef472c1f0bff6b6237c83dcd6097b2", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -60,7 +60,7 @@ g++spec.o: $(srcdir)/cp/g++spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) $(CON\n \t\t$(INCLUDES) $(srcdir)/cp/g++spec.c)\n \n # Create the compiler driver for g++.\n-GXX_OBJS = gcc.o g++spec.o intl.o prefix.o version.o \n+GXX_OBJS = gcc.o g++spec.o intl.o prefix.o version.o\n g++$(exeext): $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n \t  $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)\n@@ -181,7 +181,7 @@ c++.install-common: installdirs\n doc/g++.1: doc/gcc.1\n \tcp doc/gcc.1 doc/g++.1\n \n-c++.install-man: $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(man1ext) \n+c++.install-man: $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(man1ext)\n \n $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(man1ext): doc/g++.1 installdirs\n \t-rm -f $@"}, {"sha": "29b76117367c5ba6ad4a3c7b3dee201350ab2624", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -9,15 +9,15 @@\n * G++ no longer allows in-class initializations of static data members\n   that do not have arithmetic or enumeration type.  For example:\n \n-    struct S { \n+    struct S {\n       static const char* const p = \"abc\";\n     };\n \n-  is no longer accepted.  \n+  is no longer accepted.\n \n   Use the standards-conformant form:\n \n-    struct S { \n+    struct S {\n       static const char* const p;\n     };\n \n@@ -39,30 +39,30 @@\n   pointer to cv-qualified member function types.\n \n * The C++ ABI has been changed to correctly handle this code:\n-\t\n+\n     struct A {\n       void operator delete[] (void *, size_t);\n     };\n \n-    struct B : public A { \n+    struct B : public A {\n     };\n \n     new B[10];\n \n   The amount of storage allocated for the array will be greater than\n   it was in 3.0, in order to store the number of elements in the\n   array, so that the correct size can be passed to `operator delete[]'\n-  when the array is deleted.  Previously, the value passed to \n+  when the array is deleted.  Previously, the value passed to\n   `operator delete[]' was unpredictable.\n \n   This change will only affect code that declares a two-argument\n   `operator delete[]' with a second parameter of type `size_t'\n-  in a base class, and does not override that definition in a \n+  in a base class, and does not override that definition in a\n   derived class.\n \n * The C++ ABI has been changed so that:\n \n-    struct A { \n+    struct A {\n       void operator delete[] (void *, size_t);\n       void operator delete[] (void *);\n     };\n@@ -109,7 +109,7 @@\n   are those whose types involve non-type template arguments whose\n   mangled representations require more than one digit.\n \n-* Support for assignment to `this' has been removed.  This idiom \n+* Support for assignment to `this' has been removed.  This idiom\n   was used in the very early days of C++, before users were allowed\n   to overload `operator new'; it is no longer allowed by the C++\n   standard.\n@@ -124,15 +124,15 @@\n \n * G++ previously allowed `sizeof (X::Y)' where Y was a non-static\n   member of X, even if the `sizeof' expression occurred outside\n-  of a non-static member function of X (or one of its derived classes, \n+  of a non-static member function of X (or one of its derived classes,\n   or a member-initializer for X or one of its derived classes.)   This\n   extension has been removed.\n \n-* G++ no longer allows you to overload the conditional operator (i.e., \n+* G++ no longer allows you to overload the conditional operator (i.e.,\n   the `?:' operator.)\n \n * The \"named return value\" extension:\n-\t\n+\n     int f () return r { r = 3; }\n \n   has been deprecated, and will be removed in a future version of G++.\n@@ -175,7 +175,7 @@\n \n *** Changes in EGCS 1.1:\n \n-* Namespaces are fully supported.  The library has not yet been converted \n+* Namespaces are fully supported.  The library has not yet been converted\n   to use namespace std, however, and the old std-faking code is still on by\n   default.  To turn it off, you can use -fhonor-std.\n \n@@ -252,7 +252,7 @@\n \n             http://www.cygnus.com/misc/wp/dec96pub/template.html#temp.res\n \n-     + Guiding declarations are no longer supported.  Function declarations, \n+     + Guiding declarations are no longer supported.  Function declarations,\n        including friend declarations, do not refer to template instantiations.\n        You can restore the old behavior with -fguiding-decls until you fix\n        your code.\n@@ -315,7 +315,7 @@\n        converting from a bound member function pointer to function\n        pointer).\n \n-     + A flag -Weffc++ has been added for violations of some of the style \n+     + A flag -Weffc++ has been added for violations of some of the style\n        guidelines in Scott Meyers' _Effective C++_ books.\n \n      + -Woverloaded-virtual now warns if a virtual function in a base\n@@ -336,13 +336,13 @@\n \n * __FUNCTION__ and __PRETTY_FUNCTION__ are now treated as variables by the\n   parser; previously they were treated as string constants.  So code like\n-  `printf (__FUNCTION__ \": foo\")' must be rewritten to \n+  `printf (__FUNCTION__ \": foo\")' must be rewritten to\n   `printf (\"%s: foo\", __FUNCTION__)'.  This is necessary for templates.\n \n * local static variables in extern inline functions will be shared between\n   translation units.\n \n-* -fvtable-thunks is supported for all targets, and is the default for \n+* -fvtable-thunks is supported for all targets, and is the default for\n   Linux with glibc 2.x (also called libc 6.x).\n \n * bool is now always the same size as another built-in type. Previously,\n@@ -395,7 +395,7 @@\n * Joe Buck <jbuck@synopsys.com>, the maintainer of the g++ FAQ.\n * Brendan Kehoe <brendan@cygnus.com>, who coordinates testing of g++.\n * Jason Merrill <jason@cygnus.com>, the g++ maintainer.\n-* Mark Mitchell <mmitchell@usa.net>, who implemented member function \n+* Mark Mitchell <mmitchell@usa.net>, who implemented member function\n   templates and explicit qualification of function templates.\n * Mike Stump <mrs@wrs.com>, the previous g++ maintainer, who did most of\n   the exception handling work."}, {"sha": "f6873cc1854367353f02ac87fff5d3135b535692", "filename": "gcc/cp/call.c", "status": "modified", "additions": 259, "deletions": 259, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1,5 +1,5 @@\n /* Functions related to invoking methods and overloaded functions.\n-   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) and\n    modified by Brendan Kehoe (brendan@cygnus.com).\n@@ -42,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* The various kinds of conversion.  */\n \n-typedef enum conversion_kind { \n+typedef enum conversion_kind {\n   ck_identity,\n   ck_lvalue,\n   ck_qual,\n@@ -93,7 +93,7 @@ struct conversion {\n      used.  */\n   BOOL_BITFIELD check_copy_constructor_p : 1;\n   /* If KIND is ck_ptr or ck_pmem, true to indicate that a conversion\n-     from a pointer-to-derived to pointer-to-base is being performed.  */ \n+     from a pointer-to-derived to pointer-to-base is being performed.  */\n   BOOL_BITFIELD base_p : 1;\n   /* The type of the expression resulting from the conversion.  */\n   tree type;\n@@ -148,12 +148,12 @@ static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n-        (struct z_candidate **, tree, tree, tree, tree, tree, \n+        (struct z_candidate **, tree, tree, tree, tree, tree,\n          tree, tree, int, unification_kind_t);\n static struct z_candidate *add_template_candidate_real\n-\t(struct z_candidate **, tree, tree, tree, tree, tree, \n+\t(struct z_candidate **, tree, tree, tree, tree, tree,\n            tree, tree, int, tree, unification_kind_t);\n-static struct z_candidate *add_template_conv_candidate \n+static struct z_candidate *add_template_conv_candidate\n         (struct z_candidate **, tree, tree, tree, tree, tree, tree);\n static void add_builtin_candidates\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n@@ -162,12 +162,12 @@ static void add_builtin_candidate\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n \t       tree, tree, tree, tree *, tree *, int);\n static bool is_complete (tree);\n-static void build_builtin_candidate \n+static void build_builtin_candidate\n \t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n \t       int);\n-static struct z_candidate *add_conv_candidate \n+static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree);\n-static struct z_candidate *add_function_candidate \n+static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n static conversion *implicit_conversion (tree, tree, tree, int);\n static conversion *standard_conversion (tree, tree, tree, int);\n@@ -176,8 +176,8 @@ static conversion *build_conv (conversion_kind, tree, conversion *);\n static bool is_subseq (conversion *, conversion *);\n static tree maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n-static struct z_candidate *add_candidate \n-        (struct z_candidate **, tree, tree, size_t, \n+static struct z_candidate *add_candidate\n+        (struct z_candidate **, tree, tree, size_t,\n \t conversion **, tree, tree, int);\n static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n@@ -226,11 +226,11 @@ check_dtor_name (tree basetype, tree name)\n   else\n     {\n       /* In the case of:\n-      \t  \t\n+\n       \t template <class T> struct S { ~S(); };\n       \t int i;\n        \t i.~S();\n-\t  \n+\n      \t NAME will be a class template.  */\n       gcc_assert (DECL_CLASS_TEMPLATE_P (name));\n       return false;\n@@ -340,7 +340,7 @@ build_call (tree function, tree parms)\n   function = build3 (CALL_EXPR, result_type, function, parms, NULL_TREE);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n-  \n+\n   return function;\n }\n \n@@ -485,7 +485,7 @@ void\n validate_conversion_obstack (void)\n {\n   if (conversion_obstack_initialized)\n-    gcc_assert ((obstack_next_free (&conversion_obstack) \n+    gcc_assert ((obstack_next_free (&conversion_obstack)\n \t\t == obstack_base (&conversion_obstack)));\n }\n \n@@ -544,7 +544,7 @@ static conversion *\n build_identity_conv (tree type, tree expr)\n {\n   conversion *c;\n-  \n+\n   c = alloc_conversion (ck_identity);\n   c->type = type;\n   c->u.expr = expr;\n@@ -632,7 +632,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n          conversion.  */\n       conversion *part_conv = standard_conversion\n         (TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, flags);\n-      \n+\n       if (part_conv)\n         {\n \t  conv = build_conv (part_conv->kind, to, conv);\n@@ -680,7 +680,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)\n \t{\n \t  from = build_pointer_type\n-\t    (cp_build_qualified_type (void_type_node, \n+\t    (cp_build_qualified_type (void_type_node,\n \t\t\t\t      cp_type_quals (TREE_TYPE (from))));\n \t  conv = build_conv (ck_ptr, from, conv);\n \t}\n@@ -694,7 +694,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t\t  (TYPE_PTRMEM_POINTED_TO_TYPE (from),\n \t\t   TYPE_PTRMEM_POINTED_TO_TYPE (to))))\n \t    {\n-\t      from = build_ptrmem_type (tbase, \n+\t      from = build_ptrmem_type (tbase,\n \t\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (from));\n \t      conv = build_conv (ck_pmem, from, conv);\n \t    }\n@@ -704,7 +704,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n       else if (IS_AGGR_TYPE (TREE_TYPE (from))\n \t       && IS_AGGR_TYPE (TREE_TYPE (to))\n \t       /* [conv.ptr]\n-\t\t  \n+\n \t          An rvalue of type \"pointer to cv D,\" where D is a\n \t\t  class type, can be converted to an rvalue of type\n \t\t  \"pointer to cv B,\" where B is a base class (clause\n@@ -716,7 +716,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t          access or uniqueness.  */\n \t       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n \t{\n-\t  from = \n+\t  from =\n \t    cp_build_qualified_type (TREE_TYPE (to),\n \t\t\t\t     cp_type_quals (TREE_TYPE (from)));\n \t  from = build_pointer_type (from);\n@@ -767,7 +767,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \treturn 0;\n \n       from = cp_build_qualified_type (tbase, cp_type_quals (fbase));\n-      from = build_method_type_directly (from, \n+      from = build_method_type_directly (from,\n \t\t\t\t\t TREE_TYPE (fromfn),\n \t\t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n       from = build_ptrmemfunc_type (build_pointer_type (from));\n@@ -788,12 +788,12 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t  conv = build_conv (ck_std, to, conv);\n \t  if (fcode == POINTER_TYPE\n \t      || TYPE_PTRMEM_P (from)\n-\t      || (TYPE_PTRMEMFUNC_P (from) \n+\t      || (TYPE_PTRMEMFUNC_P (from)\n \t\t  && conv->rank < cr_pbool))\n \t    conv->rank = cr_pbool;\n \t  return conv;\n \t}\n-      \n+\n       return NULL;\n     }\n   /* We don't check for ENUMERAL_TYPE here because there are no standard\n@@ -917,7 +917,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t{\n \t  tree f = OVL_CURRENT (fns);\n \t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n-\t  \n+\n \t  cand = NULL;\n \n \t  /* If this is a template function, try to get an exact\n@@ -933,7 +933,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t\t\t\t\t     TREE_PURPOSE (conversions),\n \t\t\t\t\t     LOOKUP_NORMAL,\n \t\t\t\t\t     DEDUCE_CONV);\n-\t      \n+\n \t      if (cand)\n \t\t{\n \t\t  /* Now, see if the conversion function really returns\n@@ -952,23 +952,23 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t    }\n \t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n \t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n-\t    cand = add_function_candidate (&candidates, f, s, arglist, \n-\t\t\t\t\t   TYPE_BINFO (s), \t\n+\t    cand = add_function_candidate (&candidates, f, s, arglist,\n+\t\t\t\t\t   TYPE_BINFO (s),\n \t\t\t\t\t   TREE_PURPOSE (conversions),\n \t\t\t\t\t   LOOKUP_NORMAL);\n-\t  \n+\n \t  if (cand)\n \t    {\n \t      conversion *identity_conv;\n \t      /* Build a standard conversion sequence indicating the\n \t\t binding from the reference type returned by the\n \t\t function to the desired REFERENCE_TYPE.  */\n-\t      identity_conv \n-\t\t= build_identity_conv (TREE_TYPE (TREE_TYPE \n+\t      identity_conv\n+\t\t= build_identity_conv (TREE_TYPE (TREE_TYPE\n \t\t\t\t\t\t  (TREE_TYPE (cand->fn))),\n \t\t\t\t       NULL_TREE);\n \t      cand->second_conv\n-\t\t= (direct_reference_binding \n+\t\t= (direct_reference_binding\n \t\t   (reference_type, identity_conv));\n \t      cand->second_conv->bad_p |= cand->convs[0]->bad_p;\n \t    }\n@@ -1005,7 +1005,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \n   if (cand->viable == -1)\n     conv->bad_p = true;\n-  \n+\n   return cand->second_conv;\n }\n \n@@ -1023,15 +1023,15 @@ direct_reference_binding (tree type, conversion *conv)\n \n   t = TREE_TYPE (type);\n \n-  /* [over.ics.rank] \n-     \n+  /* [over.ics.rank]\n+\n      When a parameter of reference type binds directly\n      (_dcl.init.ref_) to an argument expression, the implicit\n      conversion sequence is the identity conversion, unless the\n      argument expression has a type that is a derived class of the\n      parameter type, in which case the implicit conversion sequence is\n      a derived-to-base Conversion.\n-\t \n+\n      If the parameter binds directly to the result of applying a\n      conversion function to the argument expression, the implicit\n      conversion sequence is a user-defined conversion sequence\n@@ -1094,11 +1094,11 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     {\n       /* [dcl.init.ref]\n \n-\t If the initializer expression \n-\t \n+\t If the initializer expression\n+\n \t -- is an lvalue (but not an lvalue for a bit-field), and \"cv1 T1\"\n \t    is reference-compatible with \"cv2 T2,\"\n-\t \n+\n \t the reference is bound directly to the initializer expression\n \t lvalue.  */\n       conv = build_identity_conv (from, expr);\n@@ -1117,7 +1117,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t   a temporary, so we just issue an error when the conversion\n \t   actually occurs.  */\n \tconv->need_temporary_p = true;\n-\t\t\t\t\t\n+\n       return conv;\n     }\n   else if (CLASS_TYPE_P (from) && !(flags & LOOKUP_NO_CONVERSION))\n@@ -1131,7 +1131,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t    \"cv1 T1\" is reference-compatible with \"cv3 T3\".  (this\n \t    conversion is selected by enumerating the applicable\n \t    conversion functions (_over.match.ref_) and choosing the\n-\t    best one through overload resolution.  (_over.match_). \n+\t    best one through overload resolution.  (_over.match_).\n \n         the reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n@@ -1146,7 +1146,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     return NULL;\n \n   /* [over.ics.rank]\n-     \n+\n      When a parameter of reference type is not bound directly to an\n      argument expression, the conversion sequence is the one required\n      to convert the argument expression to the underlying type of the\n@@ -1163,16 +1163,16 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     return NULL;\n \n   /* [dcl.init.ref]\n-     \n+\n      If the initializer expression is an rvalue, with T2 a class type,\n      and \"cv1 T1\" is reference-compatible with \"cv2 T2\", the reference\n      is bound in one of the following ways:\n-     \n+\n      -- The reference is bound to the object represented by the rvalue\n-        or to a sub-object within that object.  \n+        or to a sub-object within that object.\n \n      -- ...\n-\t\n+\n      We use the first alternative.  The implicit conversion sequence\n      is supposed to be same as we would obtain by generating a\n      temporary.  Fortunately, if the types are reference compatible,\n@@ -1256,13 +1256,13 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n    functions.  */\n \n static struct z_candidate *\n-add_candidate (struct z_candidate **candidates, \n-\t       tree fn, tree args, \n-\t       size_t num_convs, conversion **convs, \n-\t       tree access_path, tree conversion_path, \n+add_candidate (struct z_candidate **candidates,\n+\t       tree fn, tree args,\n+\t       size_t num_convs, conversion **convs,\n+\t       tree access_path, tree conversion_path,\n \t       int viable)\n {\n-  struct z_candidate *cand \n+  struct z_candidate *cand\n     = conversion_obstack_alloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n@@ -1286,8 +1286,8 @@ add_candidate (struct z_candidate **candidates,\n    comes from for purposes of overload resolution.  */\n \n static struct z_candidate *\n-add_function_candidate (struct z_candidate **candidates, \n-\t\t\ttree fn, tree ctype, tree arglist, \n+add_function_candidate (struct z_candidate **candidates,\n+\t\t\ttree fn, tree ctype, tree arglist,\n \t\t\ttree access_path, tree conversion_path,\n \t\t\tint flags)\n {\n@@ -1311,7 +1311,7 @@ add_function_candidate (struct z_candidate **candidates,\n       orig_arglist = arglist;\n       arglist = skip_artificial_parms_for (fn, arglist);\n     }\n-  else \n+  else\n     orig_arglist = arglist;\n \n   len = list_length (arglist);\n@@ -1410,7 +1410,7 @@ add_function_candidate (struct z_candidate **candidates,\n     }\n \n  out:\n-  return add_candidate (candidates, fn, orig_arglist, len, convs, \n+  return add_candidate (candidates, fn, orig_arglist, len, convs,\n \t\t\taccess_path, conversion_path, viable);\n }\n \n@@ -1488,7 +1488,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n   if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n-  return add_candidate (candidates, totype, arglist, len, convs, \n+  return add_candidate (candidates, totype, arglist, len, convs,\n \t\t\taccess_path, conversion_path, viable);\n }\n \n@@ -1536,10 +1536,10 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \tconvs[0] = t;\n       else\n \tviable = 0;\n-    }      \n+    }\n \n-  add_candidate (candidates, fnname, /*args=*/NULL_TREE, \n-\t\t num_convs, convs, \n+  add_candidate (candidates, fnname, /*args=*/NULL_TREE,\n+\t\t num_convs, convs,\n \t\t /*access_path=*/NULL_TREE,\n \t\t /*conversion_path=*/NULL_TREE,\n \t\t viable);\n@@ -1571,9 +1571,9 @@ promoted_arithmetic_type_p (tree type)\n /* Create any builtin operator overload candidates for the operator in\n    question given the converted operand types TYPE1 and TYPE2.  The other\n    args are passed through from add_builtin_candidates to\n-   build_builtin_candidate.  \n-   \n-   TYPE1 and TYPE2 may not be permissible, and we must filter them. \n+   build_builtin_candidate.\n+\n+   TYPE1 and TYPE2 may not be permissible, and we must filter them.\n    If CODE is requires candidates operands of the same type of the kind\n    of which TYPE1 and TYPE2 are, we add both candidates\n    CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */\n@@ -1642,7 +1642,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  && (TYPE_PTROB_P (type1)\n \t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n \tbreak;\n-      return; \n+      return;\n \n /* 9 For every type T, there exist candidate operator functions of the form\n \t     T*      operator+(T*);\n@@ -1910,9 +1910,9 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       /* [over.built]\n \n \t For every pair of promoted arithmetic types L and R, there\n-\t exist candidate operator functions of the form \n+\t exist candidate operator functions of the form\n \n-\t LR operator?(bool, L, R); \n+\t LR operator?(bool, L, R);\n \n \t where LR is the result of the usual arithmetic conversions\n \t between types L and R.\n@@ -1930,7 +1930,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       if (!(TYPE_PTR_P (type1) || TYPE_PTR_TO_MEMBER_P (type1))\n \t  || !(TYPE_PTR_P (type2) || TYPE_PTR_TO_MEMBER_P (type2)))\n \treturn;\n-      \n+\n       /* We don't check that the two types are the same; the logic\n \t below will actually create two candidates; one in which both\n \t parameter types are TYPE1, and one in which both parameter\n@@ -1980,7 +1980,7 @@ type_decays_to (tree type)\n       one of the input types converts to.\n    3) arithmetic candidates.  According to the standard, we should generate\n       all of these, but I'm trying not to...\n-   \n+\n    Here we generate a superset of the possible candidates for this particular\n    case.  That is a subset of the full set the standard defines, plus some\n    other cases which the standard disallows. add_builtin_candidate will\n@@ -2055,7 +2055,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     case GE_EXPR:\n       enum_p = 1;\n       /* Fall through.  */\n-    \n+\n     default:\n       ref1 = 0;\n     }\n@@ -2199,7 +2199,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   /* In [class.copy]:\n \n        A member function template is never instantiated to perform the\n-       copy of a class object to an object of its class type.  \n+       copy of a class object to an object of its class type.\n \n      It's a little unclear what this means; the standard explicitly\n      does allow a template to be used to copy a class.  For example,\n@@ -2211,14 +2211,14 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n        };\n        const A f ();\n        void g () { A a (f ()); }\n-       \n+\n      the member template will be used to make the copy.  The section\n      quoted above appears in the paragraph that forbids constructors\n      whose only parameter is (a possibly cv-qualified variant of) the\n      class type, and a logical interpretation is that the intent was\n      to forbid the instantiation of member templates which would then\n      have that form.  */\n-  if (DECL_CONSTRUCTOR_P (fn) && list_length (arglist) == 2) \n+  if (DECL_CONSTRUCTOR_P (fn) && list_length (arglist) == 2)\n     {\n       tree arg_types = FUNCTION_FIRST_USER_PARMTYPE (fn);\n       if (arg_types && same_type_p (TYPE_MAIN_VARIANT (TREE_VALUE (arg_types)),\n@@ -2232,7 +2232,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \t\t\t       conversion_path, arglist);\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n-\t\t\t\t   arglist, access_path, \n+\t\t\t\t   arglist, access_path,\n \t\t\t\t   conversion_path, flags);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n@@ -2266,9 +2266,9 @@ add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n                         tree access_path, tree conversion_path, int flags,\n                         unification_kind_t strict)\n {\n-  return \n+  return\n     add_template_candidate_real (candidates, tmpl, ctype,\n-\t\t\t\t explicit_targs, arglist, return_type, \n+\t\t\t\t explicit_targs, arglist, return_type,\n \t\t\t\t access_path, conversion_path,\n \t\t\t\t flags, NULL_TREE, strict);\n }\n@@ -2279,7 +2279,7 @@ add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n                              tree obj, tree arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path)\n {\n-  return \n+  return\n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n \t\t\t\t arglist, return_type, access_path,\n \t\t\t\t conversion_path, 0, obj, DEDUCE_CONV);\n@@ -2304,8 +2304,8 @@ splice_viable (struct z_candidate *cands,\n   last_viable = &viable;\n   *any_viable_p = false;\n \n-  cand = &cands; \n-  while (*cand) \n+  cand = &cands;\n+  while (*cand)\n     {\n       struct z_candidate *c = *cand;\n       if (strict_p ? c->viable == 1 : c->viable)\n@@ -2460,7 +2460,7 @@ merge_conversion_sequences (conversion *user_seq, conversion *std_seq)\n   gcc_assert (user_seq->kind == ck_user);\n \n   /* Find the end of the second conversion sequence.  */\n-  t = &(std_seq); \n+  t = &(std_seq);\n   while ((*t)->kind != ck_identity)\n     t = &((*t)->u.next);\n \n@@ -2526,18 +2526,18 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       if (DECL_NONCONVERTING_P (ctor))\n \tcontinue;\n \n-      if (TREE_CODE (ctor) == TEMPLATE_DECL) \n+      if (TREE_CODE (ctor) == TEMPLATE_DECL)\n \tcand = add_template_candidate (&candidates, ctor, totype,\n-\t\t\t\t       NULL_TREE, args, NULL_TREE, \n+\t\t\t\t       NULL_TREE, args, NULL_TREE,\n \t\t\t\t       TYPE_BINFO (totype),\n \t\t\t\t       TYPE_BINFO (totype),\n \t\t\t\t       flags,\n \t\t\t\t       DEDUCE_CALL);\n-      else \n+      else\n \tcand = add_function_candidate (&candidates, ctor, totype,\n-\t\t\t\t       args, TYPE_BINFO (totype), \n+\t\t\t\t       args, TYPE_BINFO (totype),\n \t\t\t\t       TYPE_BINFO (totype),\n-\t\t\t\t       flags); \n+\t\t\t\t       flags);\n \n       if (cand)\n \tcand->second_conv = build_identity_conv (totype, NULL_TREE);\n@@ -2558,11 +2558,11 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t look for a temporary binding.  */\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n-      \n+\n       for (fns = TREE_VALUE (conv_fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n-\t  \n+\n \t  /* [over.match.funcs] For conversion functions, the function\n \t     is considered to be a member of the class of the implicit\n \t     object argument for the purpose of defining the type of\n@@ -2571,29 +2571,29 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t     So we pass fromtype as CTYPE to add_*_candidate.  */\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    cand = add_template_candidate (&candidates, fn, fromtype, \n+\t    cand = add_template_candidate (&candidates, fn, fromtype,\n \t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   args, totype, \n-\t\t\t\t\t   TYPE_BINFO (fromtype), \n+\t\t\t\t\t   args, totype,\n+\t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags,\n \t\t\t\t\t   DEDUCE_CONV);\n-\t  else \n+\t  else\n \t    cand = add_function_candidate (&candidates, fn, fromtype,\n \t\t\t\t\t   args,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n-\t\t\t\t\t   flags); \n+\t\t\t\t\t   flags);\n \n \t  if (cand)\n \t    {\n \t      conversion *ics\n-\t\t= implicit_conversion (totype, \n+\t\t= implicit_conversion (totype,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (cand->fn)),\n \t\t\t\t       0, convflags);\n \n \t      cand->second_conv = ics;\n-\t      \n+\n \t      if (!ics)\n \t\tcand->viable = 0;\n \t      else if (candidates->viable == 1 && ics->bad_p)\n@@ -2671,7 +2671,7 @@ resolve_args (tree args)\n   for (t = args; t; t = TREE_CHAIN (t))\n     {\n       tree arg = TREE_VALUE (t);\n-      \n+\n       if (arg == error_mark_node)\n \treturn error_mark_node;\n       else if (VOID_TYPE_P (TREE_TYPE (arg)))\n@@ -2690,14 +2690,14 @@ resolve_args (tree args)\n    that overload resolution fails, *CANDIDATES will be the set of\n    candidates considered, and ANY_VIABLE_P will be set to true or\n    false to indicate whether or not any of the candidates were\n-   viable.  \n+   viable.\n \n    The ARGS should already have gone through RESOLVE_ARGS before this\n    function is called.  */\n \n static struct z_candidate *\n-perform_overload_resolution (tree fn, \n-\t\t\t     tree args, \n+perform_overload_resolution (tree fn,\n+\t\t\t     tree args,\n \t\t\t     struct z_candidate **candidates,\n \t\t\t     bool *any_viable_p)\n {\n@@ -2709,7 +2709,7 @@ perform_overload_resolution (tree fn,\n   *any_viable_p = true;\n \n   /* Check FN and ARGS.  */\n-  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL \n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n \t      || TREE_CODE (fn) == TEMPLATE_DECL\n \t      || TREE_CODE (fn) == OVERLOAD\n \t      || TREE_CODE (fn) == TEMPLATE_ID_EXPR);\n@@ -2739,7 +2739,7 @@ perform_overload_resolution (tree fn,\n \n /* Return an expression for a call to FN (a namespace-scope function,\n    or a static member function) with the ARGS.  */\n-      \n+\n tree\n build_new_function_call (tree fn, tree args)\n {\n@@ -2816,7 +2816,7 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n \n   /* Figure out what function is being called.  */\n   cand = perform_overload_resolution (fns, args, &candidates, &any_viable_p);\n-  \n+\n   /* If no suitable function could be found, issue an error message\n      and give up.  */\n   if (!cand)\n@@ -2857,7 +2857,7 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n \t   /* Skip the size_t parameter.  */\n \t   arg_types = TREE_CHAIN (arg_types);\n \t   /* Check the remaining parameters (if any).  */\n-\t   if (arg_types \n+\t   if (arg_types\n \t       && TREE_CHAIN (arg_types) == void_list_node\n \t       && same_type_p (TREE_VALUE (arg_types),\n \t\t\t       ptr_type_node))\n@@ -2919,7 +2919,7 @@ build_object_call (tree obj, tree args)\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n-\t\t\t\t    mem_args, NULL_TREE, \n+\t\t\t\t    mem_args, NULL_TREE,\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n@@ -2947,8 +2947,8 @@ build_object_call (tree obj, tree args)\n \tfor (; fns; fns = OVL_NEXT (fns))\n \t  {\n \t    tree fn = OVL_CURRENT (fns);\n-\t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n-\t      add_template_conv_candidate \n+\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t      add_template_conv_candidate\n \t\t(&candidates, fn, obj, args, totype,\n \t\t /*access_path=*/NULL_TREE,\n \t\t /*conversion_path=*/NULL_TREE);\n@@ -3012,12 +3012,12 @@ op_error (enum tree_code code, enum tree_code code2,\n       error (\"%s for ternary %<operator?:%> in %<%E ? %E : %E%>\",\n              problem, arg1, arg2, arg3);\n       break;\n-      \n+\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       error (\"%s for %<operator%s%> in %<%E%s%>\", problem, opname, arg1, opname);\n       break;\n-      \n+\n     case ARRAY_REF:\n       error (\"%s for %<operator[]%> in %<%E[%E]%>\", problem, arg1, arg2);\n       break;\n@@ -3026,7 +3026,7 @@ op_error (enum tree_code code, enum tree_code code2,\n     case IMAGPART_EXPR:\n       error (\"%s for %qs in %<%s %E%>\", problem, opname, opname, arg1);\n       break;\n-      \n+\n     default:\n       if (arg2)\n \terror (\"%s for %<operator%s%> in %<%E %s %E%>\",\n@@ -3057,7 +3057,7 @@ conditional_conversion (tree e1, tree e2)\n      reference must bind directly (_dcl.init.ref_) to E1.  */\n   if (real_lvalue_p (e2))\n     {\n-      conv = implicit_conversion (build_reference_type (t2), \n+      conv = implicit_conversion (build_reference_type (t2),\n \t\t\t\t  t1,\n \t\t\t\t  e1,\n \t\t\t\t  LOOKUP_NO_TEMP_BIND);\n@@ -3081,7 +3081,7 @@ conditional_conversion (tree e1, tree e2)\n       if (good_base && at_least_as_qualified_p (t2, t1))\n \t{\n \t  conv = build_identity_conv (t1, e1);\n-\t  if (!same_type_p (TYPE_MAIN_VARIANT (t1), \n+\t  if (!same_type_p (TYPE_MAIN_VARIANT (t1),\n \t\t\t    TYPE_MAIN_VARIANT (t2)))\n \t    conv = build_conv (ck_base, t2, conv);\n \t  else\n@@ -3132,7 +3132,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     }\n \n   /* [expr.cond]\n-  \n+\n      The first expr ession is implicitly converted to bool (clause\n      _conv_).  */\n   arg1 = perform_implicit_conversion (boolean_type_node, arg1);\n@@ -3174,20 +3174,20 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t   type of the other and is an rvalue.\n \n \t --Both the second and the third operands have type void; the\n-\t   result is of type void and is an rvalue.  \n+\t   result is of type void and is an rvalue.\n \n          We must avoid calling force_rvalue for expressions of type\n \t \"void\" because it will complain that their value is being\n \t used.  */\n-      if (TREE_CODE (arg2) == THROW_EXPR \n+      if (TREE_CODE (arg2) == THROW_EXPR\n \t  && TREE_CODE (arg3) != THROW_EXPR)\n \t{\n \t  if (!VOID_TYPE_P (arg3_type))\n \t    arg3 = force_rvalue (arg3);\n \t  arg3_type = TREE_TYPE (arg3);\n \t  result_type = arg3_type;\n \t}\n-      else if (TREE_CODE (arg2) != THROW_EXPR \n+      else if (TREE_CODE (arg2) != THROW_EXPR\n \t       && TREE_CODE (arg3) == THROW_EXPR)\n \t{\n \t  if (!VOID_TYPE_P (arg2_type))\n@@ -3217,7 +3217,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     {\n       conversion *conv2;\n       conversion *conv3;\n-      \n+\n       /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n       p = conversion_obstack_alloc (0);\n \n@@ -3262,7 +3262,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n       /* If, after the conversion, both operands have class type,\n \t treat the cv-qualification of both operands as if it were the\n-\t union of the cv-qualification of the operands.  \n+\t union of the cv-qualification of the operands.\n \n \t The standard is not clear about what to do in this\n \t circumstance.  For example, if the first operand has type\n@@ -3278,7 +3278,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n       if ((conv2 || conv3)\n \t  && CLASS_TYPE_P (arg2_type)\n \t  && TYPE_QUALS (arg2_type) != TYPE_QUALS (arg3_type))\n-\targ2_type = arg3_type = \n+\targ2_type = arg3_type =\n \t  cp_build_qualified_type (arg2_type,\n \t\t\t\t   TYPE_QUALS (arg2_type)\n \t\t\t\t   | TYPE_QUALS (arg3_type));\n@@ -3288,8 +3288,8 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n      If the second and third operands are lvalues and have the same\n      type, the result is of that type and is an lvalue.  */\n-  if (real_lvalue_p (arg2) \n-      && real_lvalue_p (arg3) \n+  if (real_lvalue_p (arg2)\n+      && real_lvalue_p (arg3)\n       && same_type_p (arg2_type, arg3_type))\n     {\n       result_type = arg2_type;\n@@ -3317,8 +3317,8 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n       args[0] = arg2;\n       args[1] = arg3;\n       args[2] = arg1;\n-      add_builtin_candidates (&candidates, \n-\t\t\t      COND_EXPR, \n+      add_builtin_candidates (&candidates,\n+\t\t\t      COND_EXPR,\n \t\t\t      NOP_EXPR,\n \t\t\t      ansi_opname (COND_EXPR),\n \t\t\t      args,\n@@ -3377,9 +3377,9 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n   if (arg2 == error_mark_node || arg3 == error_mark_node)\n     return error_mark_node;\n-  \n+\n   /* [expr.cond]\n-     \n+\n      After those conversions, one of the following shall hold:\n \n      --The second and third operands have the same type; the result  is  of\n@@ -3391,15 +3391,15 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n      --The second and third operands have arithmetic or enumeration\n        type; the usual arithmetic conversions are performed to bring\n        them to a common type, and the result is of that type.  */\n-  else if ((ARITHMETIC_TYPE_P (arg2_type) \n+  else if ((ARITHMETIC_TYPE_P (arg2_type)\n \t    || TREE_CODE (arg2_type) == ENUMERAL_TYPE)\n \t   && (ARITHMETIC_TYPE_P (arg3_type)\n \t       || TREE_CODE (arg3_type) == ENUMERAL_TYPE))\n     {\n       /* In this case, there is always a common type.  */\n-      result_type = type_after_usual_arithmetic_conversions (arg2_type, \n+      result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n-      \n+\n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n           && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n          warning (0, \"enumeral mismatch in conditional expression: %qT vs %qT\",\n@@ -3410,7 +3410,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n                    || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n                        && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n         warning (0, \"enumeral and non-enumeral type in conditional expression\");\n-      \n+\n       arg2 = perform_implicit_conversion (result_type, arg2);\n       arg3 = perform_implicit_conversion (result_type, arg3);\n     }\n@@ -3430,9 +3430,9 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n        them to a common type, whose cv-qualification shall match the\n        cv-qualification of either the second or the third operand.\n        The result is of the common type.  */\n-  else if ((null_ptr_cst_p (arg2) \n+  else if ((null_ptr_cst_p (arg2)\n \t    && (TYPE_PTR_P (arg3_type) || TYPE_PTR_TO_MEMBER_P (arg3_type)))\n-\t   || (null_ptr_cst_p (arg3) \n+\t   || (null_ptr_cst_p (arg3)\n \t       && (TYPE_PTR_P (arg2_type) || TYPE_PTR_TO_MEMBER_P (arg2_type)))\n \t   || (TYPE_PTR_P (arg2_type) && TYPE_PTR_P (arg3_type))\n \t   || (TYPE_PTRMEM_P (arg2_type) && TYPE_PTRMEM_P (arg3_type))\n@@ -3453,7 +3453,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     }\n \n  valid_operands:\n-  result = fold_if_not_in_template (build3 (COND_EXPR, result_type, arg1, \n+  result = fold_if_not_in_template (build3 (COND_EXPR, result_type, arg1,\n \t\t\t\t\t    arg2, arg3));\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n@@ -3463,7 +3463,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n      sometimes wrap them in NOP_EXPRs so the test would fail.  */\n   if (!lvalue_p && CLASS_TYPE_P (TREE_TYPE (result)))\n     result = get_target_expr (result);\n-  \n+\n   /* If this expression is an rvalue, but might be mistaken for an\n      lvalue, we must add a NON_LVALUE_EXPR.  */\n   if (!lvalue_p && real_lvalue_p (result))\n@@ -3499,7 +3499,7 @@ prep_operand (tree operand)\n    ACCESS_PATH, and FLAGS are as for add_function_candidate.  */\n \n static void\n-add_candidates (tree fns, tree args, \n+add_candidates (tree fns, tree args,\n \t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n@@ -3512,7 +3512,7 @@ add_candidates (tree fns, tree args,\n   /* Delay creating the implicit this parameter until it is needed.  */\n   non_static_args = NULL_TREE;\n \n-  while (fns) \n+  while (fns)\n     {\n       tree fn;\n       tree fn_args;\n@@ -3534,8 +3534,8 @@ add_candidates (tree fns, tree args,\n \tfn_args = args;\n \n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\tadd_template_candidate (candidates, \n-\t\t\t\tfn, \n+\tadd_template_candidate (candidates,\n+\t\t\t\tfn,\n \t\t\t\tctype,\n \t\t\t\texplicit_targs,\n \t\t\t\tfn_args,\n@@ -3571,8 +3571,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   bool strict_p;\n   bool any_viable_p;\n \n-  if (error_operand_p (arg1) \n-      || error_operand_p (arg2) \n+  if (error_operand_p (arg1)\n+      || error_operand_p (arg2)\n       || error_operand_p (arg3))\n     return error_mark_node;\n \n@@ -3586,7 +3586,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     fnname = ansi_opname (code);\n \n   arg1 = prep_operand (arg1);\n-  \n+\n   switch (code)\n     {\n     case NEW_EXPR:\n@@ -3605,7 +3605,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \n   arg2 = prep_operand (arg2);\n   arg3 = prep_operand (arg3);\n-  \n+\n   if (code == COND_EXPR)\n     {\n       if (arg2 == NULL_TREE\n@@ -3649,7 +3649,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  goto user_defined_result_ready;\n \t}\n       if (fns)\n-\tadd_candidates (BASELINK_FUNCTIONS (fns), arglist, \n+\tadd_candidates (BASELINK_FUNCTIONS (fns), arglist,\n \t\t\tNULL_TREE, false,\n \t\t\tBASELINK_BINFO (fns),\n \t\t\tTYPE_BINFO (TREE_TYPE (arg1)),\n@@ -3691,7 +3691,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     default:\n       strict_p = pedantic;\n       break;\n-    }      \n+    }\n \n   candidates = splice_viable (candidates, strict_p, &any_viable_p);\n   if (!any_viable_p)\n@@ -3705,12 +3705,12 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  if (flags & LOOKUP_COMPLAIN)\n \t    pedwarn (\"no %<%D(int)%> declared for postfix %qs, \"\n                      \"trying prefix operator instead\",\n-                     fnname, \n+                     fnname,\n                      operator_name_info[code].name);\n \t  if (code == POSTINCREMENT_EXPR)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n-\t    code = PREDECREMENT_EXPR;\t\n+\t    code = PREDECREMENT_EXPR;\n \t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE,\n \t\t\t\t overloaded_p);\n \t  break;\n@@ -3771,12 +3771,12 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t    case LE_EXPR:\n \t    case EQ_EXPR:\n \t    case NE_EXPR:\n-\t      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n-\t\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE \n+\t      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE\n+\t\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE\n \t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n \t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n \t\t{\n-\t\t  warning (0, \"comparison between %q#T and %q#T\", \n+\t\t  warning (0, \"comparison between %q#T and %q#T\",\n                            TREE_TYPE (arg1), TREE_TYPE (arg2));\n \t\t}\n \t      break;\n@@ -3909,15 +3909,15 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   fnname = ansi_opname (code);\n \n-  if (CLASS_TYPE_P (type) \n+  if (CLASS_TYPE_P (type)\n       && COMPLETE_TYPE_P (complete_type (type))\n       && !global_p)\n     /* In [class.free]\n \n        If the result of the lookup is ambiguous or inaccessible, or if\n        the lookup selects a placement deallocation function, the\n        program is ill-formed.\n-  \n+\n        Therefore, we ask lookup_fnfields to complain about ambiguity.  */\n     {\n       fns = lookup_fnfields (TYPE_BINFO (type), fnname, 1);\n@@ -3959,12 +3959,12 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n      the first pass, we look for a one-operator (or placement)\n      operator delete.  If we're not doing placement delete, then on\n      the second pass we look for a two-argument delete.  */\n-  for (pass = 0; pass < (placement ? 1 : 2); ++pass) \n+  for (pass = 0; pass < (placement ? 1 : 2); ++pass)\n     {\n       /* Go through the `operator delete' functions looking for one\n \t with a matching type.  */\n-      for (fn = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns; \n-\t   fn; \n+      for (fn = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;\n+\t   fn;\n \t   fn = OVL_NEXT (fn))\n \t{\n \t  tree t;\n@@ -4016,7 +4016,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       if (pass == 0)\n \targs = tree_cons (NULL_TREE, addr, args);\n       else\n-\targs = tree_cons (NULL_TREE, addr, \n+\targs = tree_cons (NULL_TREE, addr,\n \t\t\t  build_tree_list (NULL_TREE, size));\n \n       if (placement)\n@@ -4048,7 +4048,7 @@ bool\n enforce_access (tree basetype_path, tree decl)\n {\n   gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n-  \n+\n   if (!accessible_p (basetype_path, decl, true))\n     {\n       if (TREE_PRIVATE (decl))\n@@ -4072,7 +4072,7 @@ check_constructor_callable (tree type, tree expr)\n {\n   build_special_member_call (NULL_TREE,\n \t\t\t     complete_ctor_identifier,\n-\t\t\t     build_tree_list (NULL_TREE, expr), \n+\t\t\t     build_tree_list (NULL_TREE, expr),\n \t\t\t     type,\n \t\t\t     LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING\n \t\t\t     | LOOKUP_NO_CONVERSION\n@@ -4086,15 +4086,15 @@ check_constructor_callable (tree type, tree expr)\n    to NULL.  */\n \n static tree\n-build_temp (tree expr, tree type, int flags, \n+build_temp (tree expr, tree type, int flags,\n \t    void (**diagnostic_fn)(const char *, ...))\n {\n   int savew, savee;\n-  \n+\n   savew = warningcount, savee = errorcount;\n   expr = build_special_member_call (NULL_TREE,\n \t\t\t\t    complete_ctor_identifier,\n-\t\t\t\t    build_tree_list (NULL_TREE, expr), \n+\t\t\t\t    build_tree_list (NULL_TREE, expr),\n \t\t\t\t    type, flags);\n   if (warningcount > savew)\n     *diagnostic_fn = warning0;\n@@ -4104,7 +4104,7 @@ build_temp (tree expr, tree type, int flags,\n     *diagnostic_fn = NULL;\n   return expr;\n }\n-\t    \n+\n \n /* Perform the conversions in CONVS on the expression EXPR.  FN and\n    ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n@@ -4117,7 +4117,7 @@ build_temp (tree expr, tree type, int flags,\n    conversions to inaccessible bases are permitted.  */\n \n static tree\n-convert_like_real (conversion *convs, tree expr, tree fn, int argnum, \n+convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t   int inner, bool issue_conversion_warnings,\n \t\t   bool c_cast_p)\n {\n@@ -4151,7 +4151,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tpedwarn (\"  initializing argument %P of %qD\", argnum, fn);\n       return cp_convert (totype, expr);\n     }\n-  \n+\n   if (issue_conversion_warnings)\n     {\n       tree t = non_reference (totype);\n@@ -4180,15 +4180,15 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t variable.  */\n       else if (TYPE_UNSIGNED (t) && TREE_CODE (t) != BOOLEAN_TYPE)\n \t{\n-\t  if (TREE_CODE (expr) == INTEGER_CST && TREE_NEGATED_INT (expr)) \n+\t  if (TREE_CODE (expr) == INTEGER_CST && TREE_NEGATED_INT (expr))\n \t    {\n \t      if (fn)\n \t\twarning (0, \"passing negative value %qE for argument %P to %qD\",\n \t\t\t expr, argnum, fn);\n \t      else\n \t\twarning (0, \"converting negative value %qE to %qT\", expr, t);\n \t    }\n-\t  \n+\n \t  overflow_warning (expr);\n \t}\n     }\n@@ -4233,23 +4233,23 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tif (IS_AGGR_TYPE (totype)\n \t    && (inner >= 0 || !lvalue_p (expr)))\n \t  {\n-\t    expr = (build_temp \n-\t\t    (expr, totype, \n+\t    expr = (build_temp\n+\t\t    (expr, totype,\n \t\t     /* Core issue 84, now a DR, says that we don't\n \t\t\tallow UDCs for these args (which deliberately\n \t\t\tbreaks copy-init of an auto_ptr<Base> from an\n \t\t\tauto_ptr<Derived>).  */\n \t\t     LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING|LOOKUP_NO_CONVERSION,\n \t\t     &diagnostic_fn));\n-\t\t    \n+\n \t    if (diagnostic_fn)\n \t      {\n \t\tif (fn)\n-\t\t  diagnostic_fn \n+\t\t  diagnostic_fn\n \t\t    (\"  initializing argument %P of %qD from result of %qD\",\n \t\t     argnum, fn, convfn);\n \t\telse\n-\t\t diagnostic_fn \n+\t\t diagnostic_fn\n \t\t   (\"  initializing temporary from result of %qD\",  convfn);\n \t      }\n \t    expr = build_cplus_new (totype, expr);\n@@ -4343,8 +4343,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t       copy constructor, and we'll end up with an infinite\n \t       loop.  If we can use a bitwise copy, then we'll be\n \t       OK.  */\n-\t    if ((lvalue & clk_packed) \n-\t\t&& CLASS_TYPE_P (type) \n+\t    if ((lvalue & clk_packed)\n+\t\t&& CLASS_TYPE_P (type)\n \t\t&& !TYPE_HAS_TRIVIAL_INIT_REF (type))\n \t      {\n \t\terror (\"cannot bind packed field %qE to %qT\",\n@@ -4363,7 +4363,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t/* Convert it to a pointer to the type referred to by the\n \t   reference.  This will adjust the pointer if a derived to\n \t   base conversion is being performed.  */\n-\texpr = cp_convert (build_pointer_type (TREE_TYPE (ref_type)), \n+\texpr = cp_convert (build_pointer_type (TREE_TYPE (ref_type)),\n \t\t\t   expr);\n \t/* Convert the pointer to the desired reference type.  */\n \treturn build_nop (ref_type, expr);\n@@ -4432,15 +4432,15 @@ convert_arg_to_ellipsis (tree arg)\n     arg = perform_integral_promotions (arg);\n \n   arg = require_complete_type (arg);\n-  \n+\n   if (arg != error_mark_node\n       && !pod_type_p (TREE_TYPE (arg)))\n     {\n       /* Undefined behavior [expr.call] 5.2.2/7.  We used to just warn\n \t here and do a bitwise copy, but now cp_expr_size will abort if we\n-\t try to do that. \n-\t If the call appears in the context of a sizeof expression, \n-\t there is no need to emit a warning, since the expression won't be \n+\t try to do that.\n+\t If the call appears in the context of a sizeof expression,\n+\t there is no need to emit a warning, since the expression won't be\n \t evaluated. We keep the builtin_trap just as a safety check.  */\n       if (!skip_evaluation)\n \twarning (0, \"cannot pass objects of non-POD type %q#T through %<...%>; \"\n@@ -4460,12 +4460,12 @@ build_x_va_arg (tree expr, tree type)\n {\n   if (processing_template_decl)\n     return build_min (VA_ARG_EXPR, type, expr);\n-  \n+\n   type = complete_type_or_else (type, NULL_TREE);\n \n   if (expr == error_mark_node || !type)\n     return error_mark_node;\n-  \n+\n   if (! pod_type_p (type))\n     {\n       /* Undefined behavior [expr.call] 5.2.2/7.  */\n@@ -4477,7 +4477,7 @@ build_x_va_arg (tree expr, tree type)\n       expr = build_indirect_ref (expr, NULL);\n       return expr;\n     }\n-  \n+\n   return build_va_arg (expr, type);\n }\n \n@@ -4497,7 +4497,7 @@ cxx_type_promotes_to (tree type)\n   promote = type_promotes_to (type);\n   if (same_type_p (type, promote))\n     promote = type;\n-  \n+\n   return promote;\n }\n \n@@ -4699,23 +4699,23 @@ build_over_call (struct z_candidate *cand, int flags)\n       parm = TREE_CHAIN (parm);\n       /* We should never try to call the abstract constructor.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (fn));\n-      \n+\n       if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n \t  converted_args = tree_cons\n \t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n \t  arg = TREE_CHAIN (arg);\n \t  parm = TREE_CHAIN (parm);\n \t}\n-    }      \n+    }\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n     {\n       tree parmtype = TREE_VALUE (parm);\n       tree argtype = TREE_TYPE (TREE_VALUE (arg));\n       tree converted_arg;\n       tree base_binfo;\n-      \n+\n       if (convs[i]->bad_p)\n \tpedwarn (\"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n                  TREE_TYPE (argtype), fn);\n@@ -4734,7 +4734,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t\t\t       cand->conversion_path,\n \t\t\t\t       1);\n       /* Check that the base class is accessible.  */\n-      if (!accessible_base_p (TREE_TYPE (argtype), \n+      if (!accessible_base_p (TREE_TYPE (argtype),\n \t\t\t      BINFO_TYPE (cand->conversion_path), true))\n \terror (\"%qT is not an accessible base of %qT\",\n \t       BINFO_TYPE (cand->conversion_path),\n@@ -4746,7 +4746,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t\t\tTREE_TYPE (parmtype), ba_unique, NULL);\n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n \t\t\t\t       base_binfo, 1);\n-      \n+\n       converted_args = tree_cons (NULL_TREE, converted_arg, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n@@ -4769,9 +4769,9 @@ build_over_call (struct z_candidate *cand, int flags)\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm), i++)\n-    converted_args \n-      = tree_cons (NULL_TREE, \n-\t\t   convert_default_arg (TREE_VALUE (parm), \n+    converted_args\n+      = tree_cons (NULL_TREE,\n+\t\t   convert_default_arg (TREE_VALUE (parm),\n \t\t\t\t\tTREE_PURPOSE (parm),\n \t\t\t\t\tfn, i - is_method),\n \t\t   converted_args);\n@@ -4812,7 +4812,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       if (TREE_CODE (targ) == ADDR_EXPR)\n \t{\n \t  targ = TREE_OPERAND (targ, 0);\n-\t  if (!same_type_ignoring_top_level_qualifiers_p \n+\t  if (!same_type_ignoring_top_level_qualifiers_p\n \t      (TREE_TYPE (TREE_TYPE (arg)), TREE_TYPE (targ)))\n \t    targ = NULL_TREE;\n \t}\n@@ -4883,7 +4883,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t  t = convert (TREE_TYPE (TREE_VALUE (args)), t);\n \t  val = build_indirect_ref (t, 0);\n \t}\n-      \n+\n       return val;\n     }\n \n@@ -4896,7 +4896,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t\t\tDECL_CONTEXT (fn),\n \t\t\t\tba_any, NULL);\n       gcc_assert (binfo && binfo != error_mark_node);\n-      \n+\n       *p = build_base_path (PLUS_EXPR, *p, binfo, 1);\n       if (TREE_SIDE_EFFECTS (*p))\n \t*p = save_expr (*p);\n@@ -4928,7 +4928,7 @@ build_cxx_call (tree fn, tree args)\n \n   /* If this call might throw an exception, note that fact.  */\n   fndecl = get_callee_fndecl (fn);\n-  if ((!fndecl || !TREE_NOTHROW (fndecl)) \n+  if ((!fndecl || !TREE_NOTHROW (fndecl))\n       && at_function_scope_p ()\n       && cfun)\n     cp_function_chain->can_throw = 1;\n@@ -4961,23 +4961,23 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   tree lookup_args, lookup_fn, method, idx;\n   tree klass_ref, iface, iface_ref;\n   int i;\n-  \n+\n   if (!java_iface_lookup_fn)\n     {\n       tree endlink = build_void_list_node ();\n       tree t = tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t     tree_cons (NULL_TREE, java_int_type_node,\n \t\t\t\t\t\tendlink)));\n-      java_iface_lookup_fn \n+      java_iface_lookup_fn\n \t= builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n \t\t\t    build_function_type (ptr_type_node, t),\n \t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n     }\n \n-  /* Look up the pointer to the runtime java.lang.Class object for `instance'. \n+  /* Look up the pointer to the runtime java.lang.Class object for `instance'.\n      This is the first entry in the vtable.  */\n-  klass_ref = build_vtbl_ref (build_indirect_ref (instance, 0), \n+  klass_ref = build_vtbl_ref (build_indirect_ref (instance, 0),\n \t\t\t      integer_zero_node);\n \n   /* Get the java.lang.Class pointer for the interface being called.  */\n@@ -4986,13 +4986,13 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n       || DECL_CONTEXT (iface_ref) != iface)\n     {\n-      error (\"could not find class$ field in java interface type %qT\", \n+      error (\"could not find class$ field in java interface type %qT\",\n \t\tiface);\n       return error_mark_node;\n     }\n   iface_ref = build_address (iface_ref);\n   iface_ref = convert (build_pointer_type (iface), iface_ref);\n-  \n+\n   /* Determine the itable index of FN.  */\n   i = 1;\n   for (method = TYPE_METHODS (iface); method; method = TREE_CHAIN (method))\n@@ -5005,18 +5005,18 @@ build_java_interface_fn_ref (tree fn, tree instance)\n     }\n   idx = build_int_cst (NULL_TREE, i);\n \n-  lookup_args = tree_cons (NULL_TREE, klass_ref, \n+  lookup_args = tree_cons (NULL_TREE, klass_ref,\n \t\t\t   tree_cons (NULL_TREE, iface_ref,\n \t\t\t\t      build_tree_list (NULL_TREE, idx)));\n-  lookup_fn = build1 (ADDR_EXPR, \n+  lookup_fn = build1 (ADDR_EXPR,\n \t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n \t\t      java_iface_lookup_fn);\n   return build3 (CALL_EXPR, ptr_type_node, lookup_fn, lookup_args, NULL_TREE);\n }\n \n /* Returns the value to use for the in-charge parameter when making a\n    call to a function with the indicated NAME.\n-   \n+\n    FIXME:Can't we find a neater way to do this mapping?  */\n \n tree\n@@ -5051,7 +5051,7 @@ in_charge_arg_for_name (tree name)\n    store the newly constructed object into a VAR_DECL.  */\n \n tree\n-build_special_member_call (tree instance, tree name, tree args, \n+build_special_member_call (tree instance, tree name, tree args,\n \t\t\t   tree binfo, int flags)\n {\n   tree fns;\n@@ -5072,7 +5072,7 @@ build_special_member_call (tree instance, tree name, tree args,\n \n       binfo = TYPE_BINFO (binfo);\n     }\n-  \n+\n   gcc_assert (binfo != NULL_TREE);\n \n   class_type = BINFO_TYPE (binfo);\n@@ -5085,13 +5085,13 @@ build_special_member_call (tree instance, tree name, tree args,\n     }\n   else\n     {\n-      if (name == complete_dtor_identifier \n+      if (name == complete_dtor_identifier\n \t  || name == base_dtor_identifier\n \t  || name == deleting_dtor_identifier)\n \tgcc_assert (args == NULL_TREE);\n \n       /* Convert to the base class, if necessary.  */\n-      if (!same_type_ignoring_top_level_qualifiers_p \n+      if (!same_type_ignoring_top_level_qualifiers_p\n \t  (TREE_TYPE (instance), BINFO_TYPE (binfo)))\n \t{\n \t  if (name != ansi_assopname (NOP_EXPR))\n@@ -5108,11 +5108,11 @@ build_special_member_call (tree instance, tree name, tree args,\n \t\t\t\t\tbinfo, /*nonnull=*/1);\n \t}\n     }\n-  \n+\n   gcc_assert (instance != NULL_TREE);\n \n   fns = lookup_fnfields (binfo, name, 1);\n-    \n+\n   /* When making a call to a constructor or destructor for a subobject\n      that uses virtual base classes, pass down a pointer to a VTT for\n      the subobject.  */\n@@ -5140,14 +5140,14 @@ build_special_member_call (tree instance, tree name, tree args,\n       args = tree_cons (NULL_TREE, sub_vtt, args);\n     }\n \n-  return build_new_method_call (instance, fns, args, \n-\t\t\t\tTYPE_BINFO (BINFO_TYPE (binfo)), \n+  return build_new_method_call (instance, fns, args,\n+\t\t\t\tTYPE_BINFO (BINFO_TYPE (binfo)),\n \t\t\t\tflags);\n }\n \n /* Return the NAME, as a C string.  The NAME indicates a function that\n    is a member of TYPE.  *FREE_P is set to true if the caller must\n-   free the memory returned.  \n+   free the memory returned.\n \n    Rather than go through all of this, we should simply set the names\n    of constructors and destructors appropriately, and dispense with\n@@ -5163,7 +5163,7 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   /* Constructors and destructors are special.  */\n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n-      pretty_name \n+      pretty_name\n \t= (char *) IDENTIFIER_POINTER (constructor_name (type));\n       /* For a destructor, add the '~'.  */\n       if (name == complete_dtor_identifier\n@@ -5193,7 +5193,7 @@ name_as_c_string (tree name, tree type, bool *free_p)\n /* Build a call to \"INSTANCE.FN (ARGS)\".  */\n \n tree\n-build_new_method_call (tree instance, tree fns, tree args, \n+build_new_method_call (tree instance, tree fns, tree args,\n \t\t       tree conversion_path, int flags)\n {\n   struct z_candidate *candidates = 0, *cand;\n@@ -5216,7 +5216,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   gcc_assert (instance != NULL_TREE);\n \n-  if (error_operand_p (instance) \n+  if (error_operand_p (instance)\n       || error_operand_p (fns)\n       || args == error_mark_node)\n     return error_mark_node;\n@@ -5322,16 +5322,16 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n       if (TREE_CODE (t) == TEMPLATE_DECL)\n \t/* A member template.  */\n-\tadd_template_candidate (&candidates, t, \n+\tadd_template_candidate (&candidates, t,\n \t\t\t\tclass_type,\n \t\t\t\texplicit_targs,\n \t\t\t\tthis_arglist, optype,\n-\t\t\t\taccess_binfo, \n+\t\t\t\taccess_binfo,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n \t\t\t\tDEDUCE_CALL);\n       else if (! template_only)\n-\tadd_function_candidate (&candidates, t, \n+\tadd_function_candidate (&candidates, t,\n \t\t\t\tclass_type,\n \t\t\t\tthis_arglist,\n \t\t\t\taccess_binfo,\n@@ -5384,15 +5384,15 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t\t  || DECL_DESTRUCTOR_P (current_function_decl)))\n \t    /* This is not an error, it is runtime undefined\n \t       behavior.  */\n-\t    warning (0, (DECL_CONSTRUCTOR_P (current_function_decl) ? \n+\t    warning (0, (DECL_CONSTRUCTOR_P (current_function_decl) ?\n \t\t      \"abstract virtual %q#D called from constructor\"\n \t\t      : \"abstract virtual %q#D called from destructor\"),\n \t\t     cand->fn);\n-\t  \n+\n \t  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n \t      && is_dummy_object (instance_ptr))\n \t    {\n-\t      error (\"cannot call member function %qD without object\", \n+\t      error (\"cannot call member function %qD without object\",\n \t\t     cand->fn);\n \t      call = error_mark_node;\n \t    }\n@@ -5408,9 +5408,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t\t out to be a static member function, `a' is\n \t\t none-the-less evaluated.  */\n \t      if (TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE\n-\t\t  && !is_dummy_object (instance_ptr) \n+\t\t  && !is_dummy_object (instance_ptr)\n \t\t  && TREE_SIDE_EFFECTS (instance))\n-\t\tcall = build2 (COMPOUND_EXPR, TREE_TYPE (call), \n+\t\tcall = build2 (COMPOUND_EXPR, TREE_TYPE (call),\n \t\t\t       instance, call);\n \t    }\n \t}\n@@ -5461,7 +5461,7 @@ is_subseq (conversion *ics1, conversion *ics2)\n \n       if (ics2->kind == ics1->kind\n \t  && same_type_p (ics2->type, ics1->type)\n-\t  && same_type_p (ics2->u.next->type, \n+\t  && same_type_p (ics2->u.next->type,\n \t\t\t  ics1->u.next->type))\n \treturn true;\n     }\n@@ -5495,7 +5495,7 @@ maybe_handle_implicit_object (conversion **ics)\n   if ((*ics)->this_p)\n     {\n       /* [over.match.funcs]\n-\t \n+\n \t For non-static member functions, the type of the\n \t implicit object parameter is \"reference to cv X\"\n \t where X is the class of which the function is a\n@@ -5515,7 +5515,7 @@ maybe_handle_implicit_object (conversion **ics)\n       if (t->kind == ck_ptr)\n \tt = t->u.next;\n       t = build_identity_conv (TREE_TYPE (t->type), NULL_TREE);\n-      t = direct_reference_binding (reference_type, t); \n+      t = direct_reference_binding (reference_type, t);\n       *ics = t;\n     }\n }\n@@ -5582,13 +5582,13 @@ compare_ics (conversion *ics1, conversion *ics2)\n      --a standard conversion sequence (_over.ics.scs_) is a better\n        conversion sequence than a user-defined conversion sequence\n        or an ellipsis conversion sequence, and\n-     \n+\n      --a user-defined conversion sequence (_over.ics.user_) is a\n        better conversion sequence than an ellipsis conversion sequence\n        (_over.ics.ellipsis_).  */\n   rank1 = CONVERSION_RANK (ics1);\n   rank2 = CONVERSION_RANK (ics2);\n-  \n+\n   if (rank1 > rank2)\n     return -1;\n   else if (rank1 < rank2)\n@@ -5644,24 +5644,24 @@ compare_ics (conversion *ics1, conversion *ics2)\n       conversion *t1;\n       conversion *t2;\n \n-      /* We're dealing with two standard conversion sequences. \n+      /* We're dealing with two standard conversion sequences.\n \n \t [over.ics.rank]\n-\t \n+\n \t Standard conversion sequence S1 is a better conversion\n \t sequence than standard conversion sequence S2 if\n-     \n+\n \t --S1 is a proper subsequence of S2 (comparing the conversion\n \t   sequences in the canonical form defined by _over.ics.scs_,\n \t   excluding any Lvalue Transformation; the identity\n \t   conversion sequence is considered to be a subsequence of\n \t   any non-identity conversion sequence */\n-      \n+\n       t1 = ics1;\n       while (t1->kind != ck_identity)\n \tt1 = t1->u.next;\n       from_type1 = t1->type;\n-      \n+\n       t2 = ics2;\n       while (t2->kind != ck_identity)\n \tt2 = t2->u.next;\n@@ -5696,7 +5696,7 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n     --A conversion that is not a conversion of a pointer, or pointer\n       to member, to bool is better than another conversion that is such\n-      a conversion.  \n+      a conversion.\n \n     The ICS_STD_RANK automatically handles the pointer-to-bool rule,\n     so that we do not have to check it explicitly.  */\n@@ -5739,10 +5739,10 @@ compare_ics (conversion *ics1, conversion *ics2)\n       && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type1))\n       && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type2)))\n     {\n-      /* This was one of the pointer or pointer-like conversions.  \n+      /* This was one of the pointer or pointer-like conversions.\n \n \t [over.ics.rank]\n-\t \n+\n \t --If class B is derived directly or indirectly from class A,\n \t   conversion of B* to A* is better than conversion of B* to\n \t   void*, and conversion of A* to void* is better than\n@@ -5781,10 +5781,10 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n \t     --If class B is derived directly or indirectly from class A\n \t       and class C is derived directly or indirectly from B,\n-\t     \n+\n \t     --conversion of C* to B* is better than conversion of C* to\n-\t       A*, \n-\t     \n+\t       A*,\n+\n \t     --conversion of B* to A* is better than conversion of C* to\n \t       A*  */\n \t  if (same_type_p (deref_from_type1, deref_from_type2))\n@@ -5813,7 +5813,7 @@ compare_ics (conversion *ics1, conversion *ics2)\n       tree from = non_reference (from_type1);\n \n       /* [over.ics.rank]\n-\t \n+\n \t --binding of an expression of type C to a reference of type\n \t   B& is better than binding an expression of type C to a\n \t   reference of type A&\n@@ -5837,7 +5837,7 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n \t --binding of an expression of type B to a reference of type\n \t   A& is better than binding an expression of type C to a\n-\t   reference of type A&, \n+\t   reference of type A&,\n \n \t --conversion of B to A is better than conversion of C to A  */\n       if (is_properly_derived_from (from_type1, to)\n@@ -5862,13 +5862,13 @@ compare_ics (conversion *ics1, conversion *ics2)\n     return comp_cv_qual_signature (to_type1, to_type2);\n \n   /* [over.ics.rank]\n-     \n+\n      --S1 and S2 are reference bindings (_dcl.init.ref_), and the\n      types to which the references refer are the same type except for\n      top-level cv-qualifiers, and the type to which the reference\n      initialized by S2 refers is more cv-qualified than the type to\n      which the reference initialized by S1 refers */\n-      \n+\n   if (target_type1 && target_type2\n       && same_type_ignoring_top_level_qualifiers_p (to_type1, to_type2))\n     return comp_cv_qualification (target_type2, target_type1);\n@@ -5954,7 +5954,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n       int static_2 = DECL_STATIC_FUNCTION_P (cand2->fn);\n \n       gcc_assert (static_1 != static_2);\n-      \n+\n       if (static_1)\n \toff2 = 1;\n       else\n@@ -6023,12 +6023,12 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n     {\n       struct z_candidate *w, *l;\n       bool give_warning = false;\n-      \n+\n       if (winner == 1)\n \tw = cand1, l = cand2;\n       else\n \tw = cand2, l = cand1;\n-      \n+\n       /* We don't want to complain about `X::operator T1 ()'\n \t beating `X::operator T2 () const', when T2 is a no less\n \t cv-qualified version of T1.  */\n@@ -6037,7 +6037,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t{\n \t  tree t = TREE_TYPE (TREE_TYPE (l->fn));\n \t  tree f = TREE_TYPE (TREE_TYPE (w->fn));\n-\t  \n+\n \t  if (TREE_CODE (t) == TREE_CODE (f) && POINTER_TYPE_P (t))\n \t    {\n \t      t = TREE_TYPE (t);\n@@ -6048,7 +6048,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t}\n       else\n \tgive_warning = true;\n-      \n+\n       if (!give_warning)\n \t/*NOP*/;\n       else if (warn)\n@@ -6071,17 +6071,17 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   /* or, if not that,\n      F1 is a non-template function and F2 is a template function\n      specialization.  */\n-         \n+\n   if (!cand1->template_decl && cand2->template_decl)\n     return 1;\n   else if (cand1->template_decl && !cand2->template_decl)\n     return -1;\n-  \n+\n   /* or, if not that,\n      F1 and F2 are template functions and the function template for F1 is\n      more specialized than the template for F2 according to the partial\n      ordering rules.  */\n-  \n+\n   if (cand1->template_decl && cand2->template_decl)\n     {\n       winner = more_specialized_fn\n@@ -6116,18 +6116,18 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n       if (winner)\n         return winner;\n     }\n-  \n+\n   /* Check whether we can discard a builtin candidate, either because we\n      have two identical ones or matching builtin and non-builtin candidates.\n \n      (Pedantically in the latter case the builtin which matched the user\n      function should not be added to the overload set, but we spot it here.\n-     \n+\n      [over.match.oper]\n      ... the builtin candidates include ...\n      - do not have the same parameter type list as any non-template\n        non-member candidate.  */\n-                            \n+\n   if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE\n       || TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n     {\n@@ -6154,7 +6154,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   if (DECL_P (cand1->fn) && DECL_P (cand2->fn)\n       && equal_functions (cand1->fn, cand2->fn))\n     return 1;\n- \n+\n tweak:\n \n   /* Extension: If the worst conversion for one candidate is worse than the\n@@ -6238,8 +6238,8 @@ tourney (struct z_candidate *candidates)\n   /* Make sure the champ is better than all the candidates it hasn't yet\n      been compared to.  */\n \n-  for (challenger = candidates; \n-       challenger != champ \n+  for (challenger = candidates;\n+       challenger != champ\n \t && !(champ_compared_to_predecessor && challenger->next == champ);\n        challenger = challenger->next)\n     {\n@@ -6341,7 +6341,7 @@ perform_implicit_conversion (tree type, tree expr)\n    cast.  */\n \n tree\n-perform_direct_initialization_if_possible (tree type, \n+perform_direct_initialization_if_possible (tree type,\n \t\t\t\t\t   tree expr,\n \t\t\t\t\t   bool c_cast_p)\n {\n@@ -6374,7 +6374,7 @@ perform_direct_initialization_if_possible (tree type,\n   if (!conv || conv->bad_p)\n     expr = NULL_TREE;\n   else\n-    expr = convert_like_real (conv, expr, NULL_TREE, 0, 0, \n+    expr = convert_like_real (conv, expr, NULL_TREE, 0, 0,\n \t\t\t      /*issue_conversion_warnings=*/false,\n \t\t\t      c_cast_p);\n \n@@ -6389,7 +6389,7 @@ perform_direct_initialization_if_possible (tree type,\n    with the indicated TYPE; this variable will store the value to\n    which the reference is bound.  */\n \n-tree \n+tree\n make_temporary_var_for_ref_to_temp (tree decl, tree type)\n {\n   tree var;\n@@ -6456,7 +6456,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n                type, TREE_TYPE (expr));\n       else\n         error (\"invalid initialization of reference of type \"\n-\t       \"%qT from expression of type %qT\", type, \n+\t       \"%qT from expression of type %qT\", type,\n \t       TREE_TYPE (expr));\n       return error_mark_node;\n     }\n@@ -6475,12 +6475,12 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n        full-expression in which they are created.\n \n      In that case, we store the converted expression into a new\n-     VAR_DECL in a new scope.  \n+     VAR_DECL in a new scope.\n \n      However, we want to be careful not to create temporaries when\n      they are not required.  For example, given:\n \n-       struct B {}; \n+       struct B {};\n        struct D : public B {};\n        D f();\n        const B& b = f();\n@@ -6580,7 +6580,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t      /* Use its address to initialize the reference variable.  */\n \t      expr = build_address (var);\n \t      if (base_conv_type)\n-\t\texpr = convert_to_base (expr, \n+\t\texpr = convert_to_base (expr,\n \t\t\t\t\tbuild_pointer_type (base_conv_type),\n \t\t\t\t\t/*check_access=*/true,\n \t\t\t\t\t/*nonnull=*/true);\n@@ -6591,7 +6591,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    expr = build_unary_op (ADDR_EXPR, expr, 0);\n \t  /* If a BASE_CONV was required, perform it now.  */\n \t  if (base_conv_type)\n-\t    expr = (perform_implicit_conversion \n+\t    expr = (perform_implicit_conversion\n \t\t    (build_pointer_type (base_conv_type), expr));\n \t  expr = build_nop (type, expr);\n \t}"}, {"sha": "a53cbbc83a9b2d24fea32a25b2ae1e38bbd95d34", "filename": "gcc/cp/class.c", "status": "modified", "additions": 309, "deletions": 309, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -263,7 +263,7 @@ build_base_path (enum tree_code code,\n \t       && SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), probe))\n \t      || (code == PLUS_EXPR\n \t\t  && SAME_BINFO_TYPE_P (BINFO_TYPE (d_binfo), probe)));\n-  \n+\n   if (binfo == d_binfo)\n     /* Nothing to do.  */\n     return expr;\n@@ -339,18 +339,18 @@ build_base_path (enum tree_code code,\n       else\n \tv_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (expr)));\n-      \n+\n       v_offset = build2 (PLUS_EXPR, TREE_TYPE (v_offset),\n \t\t\t v_offset,  BINFO_VPTR_FIELD (v_binfo));\n-      v_offset = build1 (NOP_EXPR, \n+      v_offset = build1 (NOP_EXPR,\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n       v_offset = build_indirect_ref (v_offset, NULL);\n       TREE_CONSTANT (v_offset) = 1;\n       TREE_INVARIANT (v_offset) = 1;\n \n       offset = convert_to_integer (ptrdiff_type_node,\n-\t\t\t\t   size_diffop (offset, \n+\t\t\t\t   size_diffop (offset,\n \t\t\t\t\t\tBINFO_OFFSET (v_binfo)));\n \n       if (!integer_zerop (offset))\n@@ -370,20 +370,20 @@ build_base_path (enum tree_code code,\n     }\n \n   target_type = code == PLUS_EXPR ? BINFO_TYPE (binfo) : BINFO_TYPE (d_binfo);\n-  \n+\n   target_type = cp_build_qualified_type\n     (target_type, cp_type_quals (TREE_TYPE (TREE_TYPE (expr))));\n   ptr_target_type = build_pointer_type (target_type);\n   if (want_pointer)\n     target_type = ptr_target_type;\n-  \n+\n   expr = build1 (NOP_EXPR, ptr_target_type, expr);\n \n   if (!integer_zerop (offset))\n     expr = build2 (code, ptr_target_type, expr, offset);\n   else\n     null_test = NULL;\n-  \n+\n   if (!want_pointer)\n     expr = build_indirect_ref (expr, NULL);\n \n@@ -410,9 +410,9 @@ build_simple_base_path (tree expr, tree binfo)\n   if (d_binfo == NULL_TREE)\n     {\n       tree temp;\n-      \n+\n       gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type);\n-      \n+\n       /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x'\n      \t into `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only\n      \t an lvalue in the frontend; only _DECLs and _REFs are lvalues\n@@ -443,15 +443,15 @@ build_simple_base_path (tree expr, tree binfo)\n \t\t       cp_build_qualified_type (type, type_quals),\n \t\t       expr, field, NULL_TREE);\n \texpr = fold_if_not_in_template (expr);\n-\t\n+\n \t/* Mark the expression const or volatile, as appropriate.\n \t   Even though we've dealt with the type above, we still have\n \t   to mark the expression itself.  */\n \tif (type_quals & TYPE_QUAL_CONST)\n \t  TREE_READONLY (expr) = 1;\n \tif (type_quals & TYPE_QUAL_VOLATILE)\n \t  TREE_THIS_VOLATILE (expr) = 1;\n-\t\n+\n \treturn expr;\n       }\n \n@@ -481,7 +481,7 @@ convert_to_base (tree object, tree type, bool check_access, bool nonnull)\n     object_type = TREE_TYPE (object);\n \n   binfo = lookup_base (object_type, type,\n-\t\t       check_access ? ba_check : ba_unique, \n+\t\t       check_access ? ba_check : ba_unique,\n \t\t       NULL);\n   if (!binfo || binfo == error_mark_node)\n     return error_mark_node;\n@@ -507,7 +507,7 @@ convert_to_base_statically (tree expr, tree base)\n       pointer_type = build_pointer_type (expr_type);\n       expr = build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n-\t  expr = build2 (PLUS_EXPR, pointer_type, expr, \n+\t  expr = build2 (PLUS_EXPR, pointer_type, expr,\n \t\t\t build_nop (pointer_type, BINFO_OFFSET (base)));\n       expr = build_nop (build_pointer_type (BINFO_TYPE (base)), expr);\n       expr = build1 (INDIRECT_REF, BINFO_TYPE (base), expr);\n@@ -576,7 +576,7 @@ build_vtbl_ref_1 (tree instance, tree idx)\n \n   if (!vtbl)\n     vtbl = build_vfield_ref (instance, basetype);\n-  \n+\n   assemble_external (vtbl);\n \n   aref = build_array_ref (vtbl, idx);\n@@ -694,10 +694,10 @@ build_vtable (tree class_type, tree name, tree vtable_type)\n      is rather important that such things be ignored because any\n      effort to actually generate DWARF for them will run into\n      trouble when/if we encounter code like:\n-       \n+\n      #pragma interface\n      struct S { virtual void member (); };\n-\t   \n+\n      because the artificial declaration of the vtable itself (as\n      manufactured by the g++ front end) will say that the vtable is\n      a static member of `S' but only *after* the debug output for\n@@ -720,14 +720,14 @@ build_vtable (tree class_type, tree name, tree vtable_type)\n    impossible to actually build the vtable, but is useful to get at those\n    which are known to exist in the runtime.  */\n \n-tree \n+tree\n get_vtable_decl (tree type, int complete)\n {\n   tree decl;\n \n   if (CLASSTYPE_VTABLES (type))\n     return CLASSTYPE_VTABLES (type);\n-  \n+\n   decl = build_vtable (type, get_vtable_name (type), vtbl_type_node);\n   CLASSTYPE_VTABLES (type) = decl;\n \n@@ -753,14 +753,14 @@ build_primary_vtable (tree binfo, tree type)\n   tree virtuals;\n \n   decl = get_vtable_decl (type, /*complete=*/0);\n-  \n+\n   if (binfo)\n     {\n       if (BINFO_NEW_VTABLE_MARKED (binfo))\n \t/* We have already created a vtable for this base, so there's\n \t   no need to do it again.  */\n \treturn 0;\n-      \n+\n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n       TREE_TYPE (decl) = TREE_TYPE (get_vtbl_decl_for_binfo (binfo));\n       DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n@@ -810,7 +810,7 @@ build_secondary_vtable (tree binfo)\n   /* Remember that we've created a vtable for this BINFO, so that we\n      don't try to do so again.  */\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n-  \n+\n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n \n@@ -847,9 +847,9 @@ make_new_vtable (tree t, tree binfo)\n \n static void\n modify_vtable_entry (tree t,\n-                     tree binfo, \n-                     tree fndecl, \n-                     tree delta, \n+                     tree binfo,\n+                     tree fndecl,\n+                     tree delta,\n                      tree *virtuals)\n {\n   tree v;\n@@ -922,7 +922,7 @@ add_method (tree type, tree method, tree using_decl)\n   else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n     {\n       slot = CLASSTYPE_DESTRUCTOR_SLOT;\n-      \n+\n       if (TYPE_FOR_JAVA (type))\n \t{\n \t  if (!DECL_ARTIFICIAL (method))\n@@ -939,7 +939,7 @@ add_method (tree type, tree method, tree using_decl)\n \n       insert_p = true;\n       /* See if we already have an entry with this name.  */\n-      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n \t   VEC_iterate (tree, method_vec, slot, m);\n \t   ++slot)\n \t{\n@@ -965,7 +965,7 @@ add_method (tree type, tree method, tree using_decl)\n \t}\n     }\n   current_fns = insert_p ? NULL_TREE : VEC_index (tree, method_vec, slot);\n-  \n+\n   if (processing_template_decl)\n     /* TYPE is a template class.  Don't issue any errors now; wait\n        until instantiation time to complain.  */\n@@ -1006,20 +1006,20 @@ add_method (tree type, tree method, tree using_decl)\n \t      && (TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms1)))\n \t\t  != TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms2)))))\n \t    same = 0;\n-\t  \n+\n \t  /* For templates, the template parms must be identical.  */\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL\n \t      && !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n \t\t\t\t       DECL_TEMPLATE_PARMS (method)))\n \t    same = 0;\n-\t  \n+\n \t  if (! DECL_STATIC_FUNCTION_P (fn))\n \t    parms1 = TREE_CHAIN (parms1);\n \t  if (! DECL_STATIC_FUNCTION_P (method))\n \t    parms2 = TREE_CHAIN (parms2);\n \n-\t  if (same && compparms (parms1, parms2) \n-\t      && (!DECL_CONV_FN_P (fn) \n+\t  if (same && compparms (parms1, parms2)\n+\t      && (!DECL_CONV_FN_P (fn)\n \t\t  || same_type_p (TREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\t  TREE_TYPE (TREE_TYPE (method)))))\n \t    {\n@@ -1039,7 +1039,7 @@ add_method (tree type, tree method, tree using_decl)\n \t\t  cp_error_at (\"%q#D cannot be overloaded\", method);\n \t\t  cp_error_at (\"with %q#D\", fn);\n \t\t}\n-\t      \n+\n \t      /* We don't call duplicate_decls here to merge the\n \t\t declarations because that will confuse things if the\n \t\t methods have inline definitions.  In particular, we\n@@ -1049,9 +1049,9 @@ add_method (tree type, tree method, tree using_decl)\n \t}\n     }\n \n-  /* Add the new binding.  */ \n+  /* Add the new binding.  */\n   overload = build_overload (method, current_fns);\n-  \n+\n   if (!conv_p && slot >= CLASSTYPE_FIRST_CONVERSION_SLOT && !complete_p)\n     push_class_level_binding (DECL_NAME (method), overload);\n \n@@ -1129,7 +1129,7 @@ handle_using_decl (tree using_decl, tree t)\n   tree old_value;\n \n   gcc_assert (!processing_template_decl && decl);\n-  \n+\n   old_value = lookup_member (t, name, /*protect=*/0, /*want_type=*/false);\n   if (old_value)\n     {\n@@ -1141,9 +1141,9 @@ handle_using_decl (tree using_decl, tree t)\n       else\n \told_value = NULL_TREE;\n     }\n-  \n+\n   cp_emit_debug_info_for_using (decl, current_class_type);\n-  \n+\n   if (is_overloaded_fn (decl))\n     flist = decl;\n \n@@ -1168,7 +1168,7 @@ handle_using_decl (tree using_decl, tree t)\n       cp_error_at (\"  because of local member %q#D with same name\", old_value);\n       return;\n     }\n-  \n+\n   /* Make type T see field decl FDECL with access ACCESS.  */\n   if (flist)\n     for (; flist; flist = OVL_NEXT (flist))\n@@ -1202,7 +1202,7 @@ check_bases (tree t,\n       tree basetype = TREE_TYPE (base_binfo);\n \n       gcc_assert (COMPLETE_TYPE_P (basetype));\n-      \n+\n       /* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P\n \t here because the case of virtual functions but non-virtual\n \t dtor is handled in finish_struct_1.  */\n@@ -1240,13 +1240,13 @@ check_bases (tree t,\n       /* A lot of properties from the bases also apply to the derived\n \t class.  */\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n-      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t|= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype);\n-      TYPE_HAS_COMPLEX_ASSIGN_REF (t) \n+      TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n \t|= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n       TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n       TYPE_POLYMORPHIC_P (t) |= TYPE_POLYMORPHIC_P (basetype);\n-      CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) \n+      CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t)\n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n     }\n }\n@@ -1277,7 +1277,7 @@ determine_primary_bases (tree t)\n \t{\n \t  tree parent = BINFO_INHERITANCE_CHAIN (base_binfo);\n \t  tree parent_primary = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (parent));\n-\t  \n+\n \t  if (parent_primary\n \t      && SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo),\n \t\t\t\t    BINFO_TYPE (parent_primary)))\n@@ -1296,18 +1296,18 @@ determine_primary_bases (tree t)\n \t  else\n \t    {\n \t      tree delta;\n-\t      \n+\n \t      BINFO_PRIMARY_P (this_primary) = 1;\n \t      BINFO_INHERITANCE_CHAIN (this_primary) = base_binfo;\n-\t      \n+\n \t      /* A virtual binfo might have been copied from within\n   \t         another hierarchy. As we're about to use it as a\n   \t         primary base, make sure the offsets match.  */\n \t      delta = size_diffop (convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (base_binfo)),\n \t\t\t\t   convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (this_primary)));\n-\t  \n+\n \t      propagate_binfo_offsets (this_primary, delta);\n \t    }\n \t}\n@@ -1346,13 +1346,13 @@ determine_primary_bases (tree t)\n \t  /* Remember the first candidate.  */\n \t  primary = base_binfo;\n       }\n-  \n+\n  found:\n   /* If we've got a primary base, use it.  */\n   if (primary)\n     {\n       tree basetype = BINFO_TYPE (primary);\n-      \n+\n       CLASSTYPE_PRIMARY_BINFO (t) = primary;\n       if (BINFO_PRIMARY_P (primary))\n \t/* We are stealing a primary base.  */\n@@ -1368,12 +1368,12 @@ determine_primary_bases (tree t)\n   \t     base, make sure the offsets match.  */\n \t  delta = size_diffop (ssize_int (0),\n \t\t\t       convert (ssizetype, BINFO_OFFSET (primary)));\n-\t  \n+\n \t  propagate_binfo_offsets (primary, delta);\n \t}\n-      \n+\n       primary = TYPE_BINFO (basetype);\n-      \n+\n       TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n       BINFO_VTABLE (type_binfo) = BINFO_VTABLE (primary);\n       BINFO_VIRTUALS (type_binfo) = BINFO_VIRTUALS (primary);\n@@ -1387,7 +1387,7 @@ static void\n finish_struct_bits (tree t)\n {\n   tree variants;\n-  \n+\n   /* Fix up variants (if any).  */\n   for (variants = TYPE_NEXT_VARIANT (t);\n        variants;\n@@ -1397,11 +1397,11 @@ finish_struct_bits (tree t)\n \t the TYPE_LANG_SPECIFIC component, so they are not shared.  */\n       TYPE_HAS_CONSTRUCTOR (variants) = TYPE_HAS_CONSTRUCTOR (t);\n       TYPE_NEEDS_CONSTRUCTING (variants) = TYPE_NEEDS_CONSTRUCTING (t);\n-      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (variants) \n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (variants)\n \t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n \n       TYPE_POLYMORPHIC_P (variants) = TYPE_POLYMORPHIC_P (t);\n-      \n+\n       TYPE_BINFO (variants) = TYPE_BINFO (t);\n \n       /* Copy whatever these are holding today.  */\n@@ -1422,7 +1422,7 @@ finish_struct_bits (tree t)\n        recalculate what's really an abstract virtual at this point (by\n        looking in the vtables).  */\n     get_pure_virtuals (t);\n-  \n+\n   /* If this type has a copy constructor or a destructor, force its\n      mode to be BLKmode, and force its TREE_ADDRESSABLE bit to be\n      nonzero.  This will cause it to be passed by invisible reference\n@@ -1440,7 +1440,7 @@ finish_struct_bits (tree t)\n }\n \n /* Issue warnings about T having private constructors, but no friends,\n-   and so forth.  \n+   and so forth.\n \n    HAS_NONPRIVATE_METHOD is nonzero if T has any non-private methods or\n    static members.  HAS_NONPRIVATE_STATIC_FN is nonzero if T has any\n@@ -1461,10 +1461,10 @@ maybe_warn_about_overly_private_class (tree t)\n       /* We will have warned when the template was declared; there's\n \t no need to warn on every instantiation.  */\n       || CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-    /* There's no reason to even consider warning about this \n+    /* There's no reason to even consider warning about this\n        class.  */\n     return;\n-    \n+\n   /* We only issue one warning, if more than one applies, because\n      otherwise, on code like:\n \n@@ -1484,25 +1484,25 @@ maybe_warn_about_overly_private_class (tree t)\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n     /* We're not interested in compiler-generated methods; they don't\n        provide any way to call private members.  */\n-    if (!DECL_ARTIFICIAL (fn)) \n+    if (!DECL_ARTIFICIAL (fn))\n       {\n \tif (!TREE_PRIVATE (fn))\n \t  {\n-\t    if (DECL_STATIC_FUNCTION_P (fn)) \n+\t    if (DECL_STATIC_FUNCTION_P (fn))\n \t      /* A non-private static member function is just like a\n \t\t friend; it can create and invoke private member\n \t\t functions, and be accessed without a class\n \t\t instance.  */\n \t      return;\n-\t\t\n+\n \t    has_nonprivate_method = 1;\n \t    /* Keep searching for a static member function.  */\n \t  }\n \telse if (!DECL_CONSTRUCTOR_P (fn) && !DECL_DESTRUCTOR_P (fn))\n \t  has_member_fn = 1;\n-      } \n+      }\n \n-  if (!has_nonprivate_method && has_member_fn) \n+  if (!has_nonprivate_method && has_member_fn)\n     {\n       /* There are no non-private methods, and there's at least one\n \t private member function that isn't a constructor or\n@@ -1512,14 +1512,14 @@ maybe_warn_about_overly_private_class (tree t)\n \t constructors/destructors.)  */\n       unsigned i;\n       tree binfo = TYPE_BINFO (t);\n-      \n+\n       for (i = 0; i != BINFO_N_BASE_BINFOS (binfo); i++)\n \tif (BINFO_BASE_ACCESS (binfo, i) != access_private_node)\n \t  {\n \t    has_nonprivate_method = 1;\n \t    break;\n \t  }\n-      if (!has_nonprivate_method) \n+      if (!has_nonprivate_method)\n \t{\n \t  warning (0, \"all member functions in class %qT are private\", t);\n \t  return;\n@@ -1540,21 +1540,21 @@ maybe_warn_about_overly_private_class (tree t)\n   if (TYPE_HAS_CONSTRUCTOR (t))\n     {\n       int nonprivate_ctor = 0;\n-\t  \n+\n       /* If a non-template class does not define a copy\n \t constructor, one is defined for it, enabling it to avoid\n \t this warning.  For a template class, this does not\n \t happen, and so we would normally get a warning on:\n \n-\t   template <class T> class C { private: C(); };  \n-\t  \n+\t   template <class T> class C { private: C(); };\n+\n \t To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All\n \t complete non-template or fully instantiated classes have this\n \t flag set.  */\n       if (!TYPE_HAS_INIT_REF (t))\n \tnonprivate_ctor = 1;\n-      else \n-\tfor (fn = CLASSTYPE_CONSTRUCTORS (t); fn; fn = OVL_NEXT (fn)) \n+      else\n+\tfor (fn = CLASSTYPE_CONSTRUCTORS (t); fn; fn = OVL_NEXT (fn))\n \t  {\n \t    tree ctor = OVL_CURRENT (fn);\n \t    /* Ideally, we wouldn't count copy constructors (or, in\n@@ -1591,7 +1591,7 @@ method_name_cmp (const void* m1_p, const void* m2_p)\n {\n   const tree *const m1 = m1_p;\n   const tree *const m2 = m2_p;\n-  \n+\n   if (*m1 == NULL_TREE && *m2 == NULL_TREE)\n     return 0;\n   if (*m1 == NULL_TREE)\n@@ -1630,7 +1630,7 @@ resort_method_name_cmp (const void* m1_p, const void* m2_p)\n \n /* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n \n-void \n+void\n resort_type_method_vec (void* obj,\n                         void* orig_obj ATTRIBUTE_UNUSED ,\n                         gt_pointer_operator new_value,\n@@ -1678,7 +1678,7 @@ finish_struct_methods (tree t)\n   len = VEC_length (tree, method_vec);\n \n   /* Clear DECL_IN_AGGR_P for all functions.  */\n-  for (fn_fields = TYPE_METHODS (t); fn_fields; \n+  for (fn_fields = TYPE_METHODS (t); fn_fields;\n        fn_fields = TREE_CHAIN (fn_fields))\n     DECL_IN_AGGR_P (fn_fields) = 0;\n \n@@ -1708,7 +1708,7 @@ layout_vtable_decl (tree binfo, int n)\n   tree atype;\n   tree vtable;\n \n-  atype = build_cplus_array_type (vtable_entry_type, \n+  atype = build_cplus_array_type (vtable_entry_type,\n \t\t\t\t  build_index_type (size_int (n - 1)));\n   layout_type (atype);\n \n@@ -1759,7 +1759,7 @@ same_signature_p (tree fndecl, tree base_fndecl)\n \n /* Returns TRUE if DERIVED is a binfo containing the binfo BASE as a\n    subobject.  */\n- \n+\n static bool\n base_derived_from (tree derived, tree base)\n {\n@@ -1794,7 +1794,7 @@ typedef struct find_final_overrider_data_s {\n    Returns true if an overrider was found; false otherwise.  */\n \n static bool\n-dfs_find_final_overrider_1 (tree binfo, \n+dfs_find_final_overrider_1 (tree binfo,\n \t\t\t    find_final_overrider_data *ffod,\n \t\t\t    unsigned depth)\n {\n@@ -1814,7 +1814,7 @@ dfs_find_final_overrider_1 (tree binfo,\n   if (method)\n     {\n       tree *candidate = &ffod->candidates;\n-      \n+\n       /* Remove any candidates overridden by this new function.  */\n       while (*candidate)\n \t{\n@@ -1828,7 +1828,7 @@ dfs_find_final_overrider_1 (tree binfo,\n \t  else\n \t    candidate = &TREE_CHAIN (*candidate);\n \t}\n-      \n+\n       /* Add the new function.  */\n       ffod->candidates = tree_cons (method, binfo, ffod->candidates);\n       return true;\n@@ -1876,16 +1876,16 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n        struct T { virtual void f (); };\n        struct U : public S, public T { };\n \n-     even though calling `f' in `U' is ambiguous.  But, \n+     even though calling `f' in `U' is ambiguous.  But,\n \n        struct R { virtual void f(); };\n        struct S : virtual public R { virtual void f (); };\n        struct T : virtual public R { virtual void f (); };\n        struct U : public S, public T { };\n \n      is not -- there's no way to decide whether to put `S::f' or\n-     `T::f' in the vtable for `R'.  \n-     \n+     `T::f' in the vtable for `R'.\n+\n      The solution is to look at all paths to BINFO.  If we find\n      different overriders along any two, then there is a problem.  */\n   if (DECL_THUNK_P (fn))\n@@ -1901,11 +1901,11 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n \t\tdfs_find_final_overrider_post, &ffod);\n \n   VEC_free (tree, heap, ffod.path);\n-  \n+\n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n     {\n-      error (\"no unique final overrider for %qD in %qT\", fn, \n+      error (\"no unique final overrider for %qD in %qT\", fn,\n \t     BINFO_TYPE (derived));\n       return error_mark_node;\n     }\n@@ -1970,11 +1970,11 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   if (overrider == error_mark_node)\n     return;\n   overrider_target = overrider_fn = TREE_PURPOSE (overrider);\n-  \n+\n   /* Check for adjusting covariant return types.  */\n   over_return = TREE_TYPE (TREE_TYPE (overrider_target));\n   base_return = TREE_TYPE (TREE_TYPE (target_fn));\n-  \n+\n   if (POINTER_TYPE_P (over_return)\n       && TREE_CODE (over_return) == TREE_CODE (base_return)\n       && CLASS_TYPE_P (TREE_TYPE (over_return))\n@@ -1988,7 +1988,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \n       over_return = TREE_TYPE (over_return);\n       base_return = TREE_TYPE (base_return);\n-      \n+\n       if (DECL_THUNK_P (fn))\n \t{\n \t  gcc_assert (DECL_RESULT_THUNK_P (fn));\n@@ -2031,14 +2031,14 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t    if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),\n \t\t\t\t   BINFO_TYPE (base_binfo)))\n \t      break;\n-\t  \n+\n \t  /* See if virtual inheritance is involved.  */\n \t  for (virtual_offset = thunk_binfo;\n \t       virtual_offset;\n \t       virtual_offset = BINFO_INHERITANCE_CHAIN (virtual_offset))\n \t    if (BINFO_VIRTUAL_P (virtual_offset))\n \t      break;\n-\t  \n+\n \t  if (virtual_offset\n \t      || (thunk_binfo && !BINFO_OFFSET_ZEROP (thunk_binfo)))\n \t    {\n@@ -2061,7 +2061,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\tfixed_offset = offset;\n \t    }\n \t}\n-      \n+\n       if (fixed_offset || virtual_offset)\n \t/* Replace the overriding function with a covariant thunk.  We\n \t   will emit the overriding function in its own slot as\n@@ -2071,7 +2071,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n     }\n   else\n     gcc_assert (!DECL_THUNK_P (fn));\n-  \n+\n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n   virtual_base = NULL_TREE;\n@@ -2118,14 +2118,14 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t     && (unsigned) list_length (BINFO_VIRTUALS (probe)) > ix)\n \tif (BINFO_VIRTUAL_P (probe))\n \t  virtual_base = probe;\n-      \n+\n       if (virtual_base)\n \t/* Even if we find a virtual base, the correct delta is\n \t   between the overrider and the binfo we're building a vtable\n \t   for.  */\n \tgoto virtual_covariant;\n     }\n-  \n+\n   /* Compute the constant adjustment to the `this' pointer.  The\n      `this' pointer, when this function is called, will point at BINFO\n      (or one of its primary bases, which are at the same offset).  */\n@@ -2152,7 +2152,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   modify_vtable_entry (t, binfo, overrider_fn, delta, virtuals);\n \n   if (virtual_base)\n-    BV_VCALL_INDEX (*virtuals) \n+    BV_VCALL_INDEX (*virtuals)\n       = get_vcall_index (overrider_target, BINFO_TYPE (virtual_base));\n   else\n     BV_VCALL_INDEX (*virtuals) = NULL_TREE;\n@@ -2172,7 +2172,7 @@ dfs_modify_vtables (tree binfo, void* data)\n     /* A base without a vtable needs no modification, and its bases\n        are uninteresting.  */\n     return dfs_skip_bases;\n-  \n+\n   if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t)\n       && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     /* Don't do the primary vtable, if it's new.  */\n@@ -2186,7 +2186,7 @@ dfs_modify_vtables (tree binfo, void* data)\n     return NULL_TREE;\n \n   make_new_vtable (t, binfo);\n-      \n+\n   /* Now, go through each of the virtual functions in the virtual\n      function table for BINFO.  Find the final overrider, and update\n      the BINFO_VIRTUALS list appropriately.  */\n@@ -2195,8 +2195,8 @@ dfs_modify_vtables (tree binfo, void* data)\n        virtuals;\n        ix++, virtuals = TREE_CHAIN (virtuals),\n \t old_virtuals = TREE_CHAIN (old_virtuals))\n-    update_vtable_entry_for_fn (t, \n-\t\t\t\tbinfo, \n+    update_vtable_entry_for_fn (t,\n+\t\t\t\tbinfo,\n \t\t\t\tBV_FN (old_virtuals),\n \t\t\t\t&virtuals, ix);\n \n@@ -2328,7 +2328,7 @@ warn_hidden (tree t)\n   size_t i;\n \n   /* We go through each separately named virtual function.  */\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        VEC_iterate (tree, method_vec, i, fns);\n        ++i)\n     {\n@@ -2366,8 +2366,8 @@ warn_hidden (tree t)\n \t  if (DECL_VINDEX (fndecl))\n \t    {\n \t      tree *prev = &base_fndecls;\n-\t      \n-\t      while (*prev) \n+\n+\t      while (*prev)\n \t\t/* If the method from the base class has the same\n \t\t   signature as the method from the derived class, it\n \t\t   has been overridden.  */\n@@ -2380,7 +2380,7 @@ warn_hidden (tree t)\n \n       /* Now give a warning for all base functions without overriders,\n \t as they are hidden.  */\n-      while (base_fndecls) \n+      while (base_fndecls)\n \t{\n \t  /* Here we know it is a hider, and no overrider exists.  */\n \t  cp_warning_at (\"%qD was hidden\", TREE_VALUE (base_fndecls));\n@@ -2418,7 +2418,7 @@ finish_struct_anon (tree t)\n \t\t though, so we explicitly tolerate that.  We use\n \t\t TYPE_ANONYMOUS_P rather than ANON_AGGR_TYPE_P so that\n \t\t we also allow unnamed types used for defining fields.  */\n-\t      if (DECL_ARTIFICIAL (elt) \n+\t      if (DECL_ARTIFICIAL (elt)\n \t\t  && (!DECL_IMPLICIT_TYPEDEF_P (elt)\n \t\t      || TYPE_ANONYMOUS_P (TREE_TYPE (elt))))\n \t\tcontinue;\n@@ -2449,7 +2449,7 @@ finish_struct_anon (tree t)\n    will be used later during class template instantiation.\n    When FRIEND_P is zero, T can be a static member data (VAR_DECL),\n    a non-static member data (FIELD_DECL), a member function\n-   (FUNCTION_DECL), a nested type (RECORD_TYPE, ENUM_TYPE), \n+   (FUNCTION_DECL), a nested type (RECORD_TYPE, ENUM_TYPE),\n    a typedef (TYPE_DECL) or a member class template (TEMPLATE_DECL)\n    When FRIEND_P is nonzero, T is either a friend class\n    (RECORD_TYPE, TEMPLATE_DECL) or a friend function\n@@ -2473,7 +2473,7 @@ maybe_add_class_template_decl_list (tree type, tree t, int friend_p)\n    a const reference, respectively.  */\n \n static void\n-add_implicitly_declared_members (tree t, \n+add_implicitly_declared_members (tree t,\n \t\t\t\t int cant_have_const_cctor,\n \t\t\t\t int cant_have_const_assignment)\n {\n@@ -2519,7 +2519,7 @@ add_implicitly_declared_members (tree t,\n \t    }\n \n \t  /* If we can't get away with being lazy, generate the destructor\n-\t     now.  */ \n+\t     now.  */\n \t  if (!lazy_p)\n \t    lazily_declare_fn (sfk_destructor, t);\n \t}\n@@ -2648,7 +2648,7 @@ check_bitfield_decl (tree field)\n \tcp_warning_at (\"%qD is too small to hold all values of %q#T\",\n \t\t       field, type);\n     }\n-  \n+\n   /* Remove the bit-field width indicator so that the rest of the\n      compiler does not treat that value as an initializer.  */\n   DECL_INITIAL (field) = NULL_TREE;\n@@ -2701,7 +2701,7 @@ check_field_decl (tree field,\n       /* Never let anything with uninheritable virtuals\n \t make it through without complaint.  */\n       abstract_virtuals_error (field, type);\n-\t\t      \n+\n       if (TREE_CODE (t) == UNION_TYPE)\n \t{\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n@@ -2717,7 +2717,7 @@ check_field_decl (tree field,\n       else\n \t{\n \t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n-\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t    |= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type);\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n \t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n@@ -2816,7 +2816,7 @@ check_field_decls (tree t, tree *access_decls,\n \t      /* If one of the data members contains an empty class,\n \t\t so does T.  */\n \t      element_type = strip_array_types (type);\n-\t      if (CLASS_TYPE_P (element_type) \n+\t      if (CLASS_TYPE_P (element_type)\n \t\t  && CLASSTYPE_CONTAINS_EMPTY_CLASS_P (element_type))\n \t\tCLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) = 1;\n \t    }\n@@ -2888,7 +2888,7 @@ check_field_decls (tree t, tree *access_decls,\n \n       if (type == error_mark_node)\n \tcontinue;\n-\t  \n+\n       if (TREE_CODE (x) == CONST_DECL || TREE_CODE (x) == VAR_DECL)\n \tcontinue;\n \n@@ -3000,7 +3000,7 @@ check_field_decls (tree t, tree *access_decls,\n      -- Warn only if there is a non-trivial destructor. We assume that the\n \tuser at least implemented the cleanup correctly, and a destructor\n \tis needed to free dynamic memory.\n-\t\n+\n      This seems enough for practical purposes.  */\n     if (warn_ecpp\n \t&& has_pointers\n@@ -3009,7 +3009,7 @@ check_field_decls (tree t, tree *access_decls,\n \t&& !(TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n       warning (0, \"%q#T has pointer data members\", t);\n-      \n+\n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n \t  warning (0, \"  but does not override %<%T(const %T&)%>\", t, t);\n@@ -3043,10 +3043,10 @@ record_subobject_offset (tree type, tree offset, splay_tree offsets)\n   /* Record the location of this empty object in OFFSETS.  */\n   n = splay_tree_lookup (offsets, (splay_tree_key) offset);\n   if (!n)\n-    n = splay_tree_insert (offsets, \n+    n = splay_tree_insert (offsets,\n \t\t\t   (splay_tree_key) offset,\n \t\t\t   (splay_tree_value) NULL_TREE);\n-  n->value = ((splay_tree_value) \n+  n->value = ((splay_tree_value)\n \t      tree_cons (NULL_TREE,\n \t\t\t type,\n \t\t\t (tree) n->value));\n@@ -3090,11 +3090,11 @@ check_subobject_offset (tree type, tree offset, splay_tree offsets)\n    is returned.  Otherwise, returns zero.  */\n \n static int\n-walk_subobject_offsets (tree type, \n-                        subobject_offset_fn f, \n-                        tree offset, \n-                        splay_tree offsets, \n-                        tree max_offset, \n+walk_subobject_offsets (tree type,\n+                        subobject_offset_fn f,\n+                        tree offset,\n+                        splay_tree offsets,\n+                        tree max_offset,\n                         int vbases_p)\n {\n   int r = 0;\n@@ -3105,7 +3105,7 @@ walk_subobject_offsets (tree type,\n   if (max_offset && INT_CST_LT (max_offset, offset))\n     return 0;\n \n-  if (!TYPE_P (type)) \n+  if (!TYPE_P (type))\n     {\n       if (abi_version_at_least (2))\n \ttype_binfo = type;\n@@ -3134,12 +3134,12 @@ walk_subobject_offsets (tree type,\n \t{\n \t  tree binfo_offset;\n \n-\t  if (abi_version_at_least (2) \n+\t  if (abi_version_at_least (2)\n \t      && BINFO_VIRTUAL_P (binfo))\n \t    continue;\n \n-\t  if (!vbases_p \n-\t      && BINFO_VIRTUAL_P (binfo) \n+\t  if (!vbases_p\n+\t      && BINFO_VIRTUAL_P (binfo)\n \t      && !BINFO_PRIMARY_P (binfo))\n \t    continue;\n \n@@ -3154,7 +3154,7 @@ walk_subobject_offsets (tree type,\n \t\t class yet, but the offsets for direct non-virtual\n \t\t bases can be calculated by going back to the TYPE.  */\n \t      orig_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n-\t      binfo_offset = size_binop (PLUS_EXPR,\t      \n+\t      binfo_offset = size_binop (PLUS_EXPR,\n \t\t\t\t\t offset,\n \t\t\t\t\t BINFO_OFFSET (orig_binfo));\n \t    }\n@@ -3164,7 +3164,7 @@ walk_subobject_offsets (tree type,\n \t\t\t\t      binfo_offset,\n \t\t\t\t      offsets,\n \t\t\t\t      max_offset,\n-\t\t\t\t      (abi_version_at_least (2) \n+\t\t\t\t      (abi_version_at_least (2)\n \t\t\t\t       ? /*vbases_p=*/0 : vbases_p));\n \t  if (r)\n \t    return r;\n@@ -3201,12 +3201,12 @@ walk_subobject_offsets (tree type,\n \t\t virtual.  (If it is non-virtual, then it was walked\n \t\t above.)  */\n \t      tree vbase = get_primary_binfo (type_binfo);\n-\t      \n+\n \t      if (vbase && BINFO_VIRTUAL_P (vbase)\n \t\t  && BINFO_PRIMARY_P (vbase)\n \t\t  && BINFO_INHERITANCE_CHAIN (vbase) == type_binfo)\n \t\t{\n-\t\t  r = (walk_subobject_offsets \n+\t\t  r = (walk_subobject_offsets\n \t\t       (vbase, f, offset,\n \t\t\toffsets, max_offset, /*vbases_p=*/0));\n \t\t  if (r)\n@@ -3253,7 +3253,7 @@ walk_subobject_offsets (tree type,\n       /* Step through each of the elements in the array.  */\n       for (index = size_zero_node;\n \t   /* G++ 3.2 had an off-by-one error here.  */\n-\t   (abi_version_at_least (2) \n+\t   (abi_version_at_least (2)\n \t    ? !INT_CST_LT (TYPE_MAX_VALUE (domain), index)\n \t    : INT_CST_LT (index, TYPE_MAX_VALUE (domain)));\n \t   index = size_binop (PLUS_EXPR, index, size_one_node))\n@@ -3266,7 +3266,7 @@ walk_subobject_offsets (tree type,\n \t\t\t\t      /*vbases_p=*/1);\n \t  if (r)\n \t    return r;\n-\t  offset = size_binop (PLUS_EXPR, offset, \n+\t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n \t  /* If this new OFFSET is bigger than the MAX_OFFSET, then\n \t     there's no point in iterating through the remaining\n@@ -3284,9 +3284,9 @@ walk_subobject_offsets (tree type,\n    examined.  */\n \n static void\n-record_subobject_offsets (tree type, \n-                          tree offset, \n-                          splay_tree offsets, \n+record_subobject_offsets (tree type,\n+                          tree offset,\n+                          splay_tree offsets,\n                           int vbases_p)\n {\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n@@ -3299,8 +3299,8 @@ record_subobject_offsets (tree type,\n \n static int\n layout_conflict_p (tree type,\n-                   tree offset, \n-                   splay_tree offsets, \n+                   tree offset,\n+                   splay_tree offsets,\n                    int vbases_p)\n {\n   splay_tree_node max_node;\n@@ -3325,15 +3325,15 @@ layout_conflict_p (tree type,\n    the position of the DECL.  */\n \n static void\n-layout_nonempty_base_or_field (record_layout_info rli, \n-\t\t\t       tree decl, \n-\t\t\t       tree binfo, \n+layout_nonempty_base_or_field (record_layout_info rli,\n+\t\t\t       tree decl,\n+\t\t\t       tree binfo,\n \t\t\t       splay_tree offsets)\n {\n   tree offset = NULL_TREE;\n   bool field_p;\n   tree type;\n-  \n+\n   if (binfo)\n     {\n       /* For the purposes of determining layout conflicts, we want to\n@@ -3363,11 +3363,11 @@ layout_nonempty_base_or_field (record_layout_info rli,\n       /* We have to check to see whether or not there is already\n \t something of the same type at the offset we're about to use.\n \t For example, consider:\n-\t \n+\n \t   struct S {};\n \t   struct T : public S { int i; };\n \t   struct U : public S, public T {};\n-\t \n+\n \t Here, we put S at offset zero in U.  Then, we can't put T at\n \t offset zero -- its S component would be at the same address\n \t as the S we already allocated.  So, we have to skip ahead.\n@@ -3383,7 +3383,7 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t virtual base.  */\n       if (!abi_version_at_least (2) && binfo && BINFO_VIRTUAL_P (binfo))\n \tbreak;\n-      if (layout_conflict_p (field_p ? type : binfo, offset, \n+      if (layout_conflict_p (field_p ? type : binfo, offset,\n \t\t\t     offsets, field_p))\n \t{\n \t  /* Strip off the size allocated to this field.  That puts us\n@@ -3393,8 +3393,8 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \n \t  /* Bump up by the alignment required for the type.  */\n \t  rli->bitpos\n-\t    = size_binop (PLUS_EXPR, rli->bitpos, \n-\t\t\t  bitsize_int (binfo \n+\t    = size_binop (PLUS_EXPR, rli->bitpos,\n+\t\t\t  bitsize_int (binfo\n \t\t\t\t       ? CLASSTYPE_ALIGN (type)\n \t\t\t\t       : TYPE_ALIGN (type)));\n \t  normalize_rli (rli);\n@@ -3411,9 +3411,9 @@ layout_nonempty_base_or_field (record_layout_info rli,\n        this point because their BINFO_OFFSET is copied from another\n        hierarchy.  Therefore, we may not need to add the entire\n        OFFSET.  */\n-    propagate_binfo_offsets (binfo, \n+    propagate_binfo_offsets (binfo,\n \t\t\t     size_diffop (convert (ssizetype, offset),\n-\t\t\t\t\t  convert (ssizetype, \n+\t\t\t\t\t  convert (ssizetype,\n \t\t\t\t\t\t   BINFO_OFFSET (binfo))));\n }\n \n@@ -3454,22 +3454,22 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n \t\t \"change in a future version of GCC\",\n \t\t BINFO_TYPE (binfo));\n     }\n-  \n+\n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n   if (layout_conflict_p (binfo,\n \t\t\t BINFO_OFFSET (binfo),\n-\t\t\t offsets, \n+\t\t\t offsets,\n \t\t\t /*vbases_p=*/0))\n     {\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       atend = true;\n       propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n-      while (1) \n+      while (1)\n \t{\n \t  if (!layout_conflict_p (binfo,\n-\t\t\t\t  BINFO_OFFSET (binfo), \n+\t\t\t\t  BINFO_OFFSET (binfo),\n \t\t\t\t  offsets,\n \t\t\t\t  /*vbases_p=*/0))\n \t    /* We finally found a spot where there's no overlap.  */\n@@ -3487,7 +3487,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n    any base class.  OFFSETS gives the location of empty base\n    subobjects.  T is the most derived type.  Return nonzero if the new\n    object cannot be nearly-empty.  A new FIELD_DECL is inserted at\n-   *NEXT_FIELD, unless BINFO is for an empty base class.  \n+   *NEXT_FIELD, unless BINFO is for an empty base class.\n \n    Returns the location at which the next field should be inserted.  */\n \n@@ -3502,7 +3502,7 @@ build_base_field (record_layout_info rli, tree binfo,\n     /* This error is now reported in xref_tag, thus giving better\n        location information.  */\n     return next_field;\n-  \n+\n   /* Place the base class.  */\n   if (!is_empty_class (basetype))\n     {\n@@ -3511,7 +3511,7 @@ build_base_field (record_layout_info rli, tree binfo,\n       /* The containing class is non-empty because it has a non-empty\n \t base class.  */\n       CLASSTYPE_EMPTY_P (t) = 0;\n-      \n+\n       /* Create the FIELD_DECL.  */\n       decl = build_decl (FIELD_DECL, NULL_TREE, CLASSTYPE_AS_BASE (basetype));\n       DECL_ARTIFICIAL (decl) = 1;\n@@ -3552,7 +3552,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t  /* The check above (used in G++ 3.2) is insufficient  because\n \t     an empty class placed at offset zero might itself have an\n \t     empty base at a nonzero offset.  */\n-\t  else if (walk_subobject_offsets (basetype, \n+\t  else if (walk_subobject_offsets (basetype,\n \t\t\t\t\t   empty_base_at_nonzero_offset_p,\n \t\t\t\t\t   size_zero_node,\n \t\t\t\t\t   /*offsets=*/NULL,\n@@ -3566,7 +3566,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t\t\t \"future version of GCC\", t);\n \t    }\n \t}\n-\t\n+\n       /* We do not create a FIELD_DECL for empty base classes because\n \t it might overlap some other field.  We want to be able to\n \t create CONSTRUCTORs for the class by iterating over the\n@@ -3582,7 +3582,7 @@ build_base_field (record_layout_info rli, tree binfo,\n   /* Record the offsets of BINFO and its base subobjects.  */\n   record_subobject_offsets (binfo,\n \t\t\t    BINFO_OFFSET (binfo),\n-\t\t\t    offsets, \n+\t\t\t    offsets,\n \t\t\t    /*vbases_p=*/0);\n \n   return next_field;\n@@ -3712,14 +3712,14 @@ build_clone (tree fn, tree name)\n \tparmtypes = TREE_CHAIN (parmtypes);\n        /* If this is subobject constructor or destructor, add the vtt\n \t parameter.  */\n-      TREE_TYPE (clone) \n+      TREE_TYPE (clone)\n \t= build_method_type_directly (basetype,\n \t\t\t\t      TREE_TYPE (TREE_TYPE (clone)),\n \t\t\t\t      parmtypes);\n       if (exceptions)\n \tTREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone),\n \t\t\t\t\t\t     exceptions);\n-      TREE_TYPE (clone) \n+      TREE_TYPE (clone)\n \t= cp_build_type_attribute_variant (TREE_TYPE (clone),\n \t\t\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (fn)));\n     }\n@@ -3759,7 +3759,7 @@ build_clone (tree fn, tree name)\n   /* Create the RTL for this function.  */\n   SET_DECL_RTL (clone, NULL_RTX);\n   rest_of_decl_compilation (clone, /*top_level=*/1, at_eof);\n-  \n+\n   /* Make it easy to find the CLONE given the FN.  */\n   TREE_CHAIN (clone) = TREE_CHAIN (fn);\n   TREE_CHAIN (fn) = clone;\n@@ -3769,7 +3769,7 @@ build_clone (tree fn, tree name)\n     {\n       tree result;\n \n-      DECL_TEMPLATE_RESULT (clone) \n+      DECL_TEMPLATE_RESULT (clone)\n \t= build_clone (DECL_TEMPLATE_RESULT (clone), name);\n       result = DECL_TEMPLATE_RESULT (clone);\n       DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n@@ -3815,7 +3815,7 @@ clone_function_decl (tree fn, int update_method_vec_p)\n \t version.  We clone the deleting version first because that\n \t means it will go second on the TYPE_METHODS list -- and that\n \t corresponds to the correct layout order in the virtual\n-\t function table.  \n+\t function table.\n \n          For a non-virtual destructor, we do not build a deleting\n \t destructor.  */\n@@ -3848,7 +3848,7 @@ void\n adjust_clone_args (tree decl)\n {\n   tree clone;\n-  \n+\n   for (clone = TREE_CHAIN (decl); clone && DECL_CLONED_FUNCTION (clone);\n        clone = TREE_CHAIN (clone))\n     {\n@@ -3857,7 +3857,7 @@ adjust_clone_args (tree decl)\n       tree decl_parms, clone_parms;\n \n       clone_parms = orig_clone_parms;\n-      \n+\n       /* Skip the 'this' parameter.  */\n       orig_clone_parms = TREE_CHAIN (orig_clone_parms);\n       orig_decl_parms = TREE_CHAIN (orig_decl_parms);\n@@ -3866,18 +3866,18 @@ adjust_clone_args (tree decl)\n \torig_decl_parms = TREE_CHAIN (orig_decl_parms);\n       if (DECL_HAS_VTT_PARM_P (decl))\n \torig_decl_parms = TREE_CHAIN (orig_decl_parms);\n-      \n+\n       clone_parms = orig_clone_parms;\n       if (DECL_HAS_VTT_PARM_P (clone))\n \tclone_parms = TREE_CHAIN (clone_parms);\n-      \n+\n       for (decl_parms = orig_decl_parms; decl_parms;\n \t   decl_parms = TREE_CHAIN (decl_parms),\n \t     clone_parms = TREE_CHAIN (clone_parms))\n \t{\n \t  gcc_assert (same_type_p (TREE_TYPE (decl_parms),\n \t\t\t\t   TREE_TYPE (clone_parms)));\n-\t  \n+\n \t  if (TREE_PURPOSE (decl_parms) && !TREE_PURPOSE (clone_parms))\n \t    {\n \t      /* A default parameter has been added. Adjust the\n@@ -3901,7 +3901,7 @@ adjust_clone_args (tree decl)\n \t      if (exceptions)\n \t\ttype = build_exception_variant (type, exceptions);\n \t      TREE_TYPE (clone) = type;\n-\t      \n+\n \t      clone_parms = NULL_TREE;\n \t      break;\n \t    }\n@@ -3936,11 +3936,11 @@ remove_zero_width_bit_fields (tree t)\n {\n   tree *fieldsp;\n \n-  fieldsp = &TYPE_FIELDS (t); \n+  fieldsp = &TYPE_FIELDS (t);\n   while (*fieldsp)\n     {\n       if (TREE_CODE (*fieldsp) == FIELD_DECL\n-\t  && DECL_C_BIT_FIELD (*fieldsp) \n+\t  && DECL_C_BIT_FIELD (*fieldsp)\n \t  && DECL_INITIAL (*fieldsp))\n \t*fieldsp = TREE_CHAIN (*fieldsp);\n       else\n@@ -3969,7 +3969,7 @@ type_requires_array_cookie (tree type)\n      argument is of type `size_t', then we have to pass the size of\n      the array to the deallocation function, so we will need to store\n      a cookie.  */\n-  fns = lookup_fnfields (TYPE_BINFO (type), \n+  fns = lookup_fnfields (TYPE_BINFO (type),\n \t\t\t ansi_opname (VEC_DELETE_EXPR),\n \t\t\t /*protect=*/0);\n   /* If there are no `operator []' members, or the lookup is\n@@ -4051,7 +4051,7 @@ check_bases_and_members (tree t)\n   CLASSTYPE_NON_AGGREGATE (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_POLYMORPHIC_P (t));\n   CLASSTYPE_NON_POD_P (t)\n-    |= (CLASSTYPE_NON_AGGREGATE (t) \n+    |= (CLASSTYPE_NON_AGGREGATE (t)\n \t|| TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t|| TYPE_HAS_ASSIGN_REF (t));\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n@@ -4097,15 +4097,15 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n \t&& TREE_CODE (DECL_VINDEX (fn)) != INTEGER_CST)\n       {\n \ttree new_virtual = make_node (TREE_LIST);\n-\t\n+\n \tBV_FN (new_virtual) = fn;\n \tBV_DELTA (new_virtual) = integer_zero_node;\n \tBV_VCALL_INDEX (new_virtual) = NULL_TREE;\n \n \tTREE_CHAIN (new_virtual) = *virtuals_p;\n \t*virtuals_p = new_virtual;\n       }\n-  \n+\n   /* If we couldn't find an appropriate base class, create a new field\n      here.  Even if there weren't any new virtual functions, we might need a\n      new virtual function table if we're supposed to include vptrs in\n@@ -4124,7 +4124,7 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n \t the derived class vtable pointer, since they have different\n \t types.  Thus, in a derived class destructor, where the base\n \t class constructor was inlined, we could generate bad code for\n-\t setting up the vtable pointer.  \n+\t setting up the vtable pointer.\n \n          Therefore, we use one type for all vtable pointers.  We still\n \t use a type-correct type; it's just doesn't indicate the array\n@@ -4139,9 +4139,9 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n       DECL_ARTIFICIAL (field) = 1;\n       DECL_FIELD_CONTEXT (field) = t;\n       DECL_FCONTEXT (field) = t;\n-      \n+\n       TYPE_VFIELD (t) = field;\n-      \n+\n       /* This class is non-empty.  */\n       CLASSTYPE_EMPTY_P (t) = 0;\n \n@@ -4213,7 +4213,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \n   /* Update BINFO's offset.  */\n   BINFO_OFFSET (binfo)\n-    = convert (sizetype, \n+    = convert (sizetype,\n \t       size_binop (PLUS_EXPR,\n \t\t\t   convert (ssizetype, BINFO_OFFSET (binfo)),\n \t\t\t   offset));\n@@ -4223,7 +4223,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \n   if (primary_binfo && BINFO_INHERITANCE_CHAIN (primary_binfo) == binfo)\n     propagate_binfo_offsets (primary_binfo, offset);\n-  \n+\n   /* Scan all of the bases, pushing the BINFO_OFFSET adjust\n      downwards.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n@@ -4301,7 +4301,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t     the results which is not particularly tractable.  */\n \t  if (warn_abi\n \t      && first_vbase\n-\t      && (tree_int_cst_lt \n+\t      && (tree_int_cst_lt\n \t\t  (size_binop (CEIL_DIV_EXPR,\n \t\t\t       round_up (CLASSTYPE_SIZE (t),\n \t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n@@ -4398,7 +4398,7 @@ warn_about_ambiguous_bases (tree t)\n   /* If there are no repeated bases, nothing can be ambiguous.  */\n   if (!CLASSTYPE_REPEATED_BASE_P (t))\n     return;\n-  \n+\n   /* Check direct bases.  */\n   for (binfo = TYPE_BINFO (t), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n@@ -4416,7 +4416,7 @@ warn_about_ambiguous_bases (tree t)\n \t VEC_iterate (tree, vbases, i, binfo); i++)\n       {\n \tbasetype = BINFO_TYPE (binfo);\n-\t\n+\n \tif (!lookup_base (t, basetype, ba_unique | ba_quiet, NULL))\n \t  warning (0, \"virtual base %qT inaccessible in %qT due to ambiguity\",\n \t\t   basetype, t);\n@@ -4445,7 +4445,7 @@ include_empty_classes (record_layout_info rli)\n      because we are willing to overlay multiple bases at the same\n      offset.  However, now we need to make sure that RLI is big enough\n      to reflect the entire class.  */\n-  eoc = end_of_class (rli->t, \n+  eoc = end_of_class (rli->t,\n \t\t      CLASSTYPE_AS_BASE (rli->t) != NULL_TREE);\n   rli_size = rli_size_unit_so_far (rli);\n   if (TREE_CODE (rli_size) == INTEGER_CST\n@@ -4462,8 +4462,8 @@ include_empty_classes (record_layout_info rli)\n \t/* The size should have been rounded to a whole byte.  */\n \tgcc_assert (tree_int_cst_equal\n \t\t    (rli->bitpos, round_down (rli->bitpos, BITS_PER_UNIT)));\n-      rli->bitpos \n-\t= size_binop (PLUS_EXPR, \n+      rli->bitpos\n+\t= size_binop (PLUS_EXPR,\n \t\t      rli->bitpos,\n \t\t      size_binop (MULT_EXPR,\n \t\t\t\t  convert (bitsizetype,\n@@ -4519,10 +4519,10 @@ layout_class_type (tree t, tree *virtuals_p)\n     next_field = &TYPE_FIELDS (t);\n \n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n-  empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n+  empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts,\n \t\t\t\t       NULL, NULL);\n   build_base_fields (rli, empty_base_offsets, next_field);\n-  \n+\n   /* Layout the non-static data members.  */\n   for (field = non_static_data_members; field; field = TREE_CHAIN (field))\n     {\n@@ -4535,13 +4535,13 @@ layout_class_type (tree t, tree *virtuals_p)\n \t{\n \t  place_field (rli, field);\n \t  /* If the static data member has incomplete type, keep track\n-\t     of it so that it can be completed later.  (The handling \n+\t     of it so that it can be completed later.  (The handling\n \t     of pending statics in finish_record_layout is\n \t     insufficient; consider:\n \n \t       struct S1;\n \t       struct S2 { static S1 s1; };\n-\t       \n+\n              At this point, finish_record_layout will be called, but\n \t     S1 is still incomplete.)  */\n \t  if (TREE_CODE (field) == VAR_DECL)\n@@ -4556,7 +4556,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t}\n \n       type = TREE_TYPE (field);\n-      \n+\n       padding = NULL_TREE;\n \n       /* If this field is a bit-field whose width is greater than its\n@@ -4573,7 +4573,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t     of the field.  Then, we are supposed to use the left over\n \t     bits as additional padding.  */\n \t  for (itk = itk_char; itk != itk_none; ++itk)\n-\t    if (INT_CST_LT (DECL_SIZE (field), \n+\t    if (INT_CST_LT (DECL_SIZE (field),\n \t\t\t    TYPE_SIZE (integer_types[itk])))\n \t      break;\n \n@@ -4597,7 +4597,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t  if (warn_abi && TREE_CODE (t) == UNION_TYPE)\n \t\t    warning (0, \"size assigned to %qT may not be \"\n \t\t\t     \"ABI-compliant and may change in a future \"\n-\t\t\t     \"version of GCC\", \n+\t\t\t     \"version of GCC\",\n \t\t\t     t);\n \t\t  padding = size_binop (MINUS_EXPR, DECL_SIZE (field),\n \t\t\t\t\tTYPE_SIZE (integer_type));\n@@ -4643,7 +4643,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \n       /* Remember the location of any empty classes in FIELD.  */\n       if (abi_version_at_least (2))\n-\trecord_subobject_offsets (TREE_TYPE (field), \n+\trecord_subobject_offsets (TREE_TYPE (field),\n \t\t\t\t  byte_position(field),\n \t\t\t\t  empty_base_offsets,\n \t\t\t\t  /*vbases_p=*/1);\n@@ -4652,7 +4652,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t and yet it starts in the middle of a byte, we have failed to\n \t comply with the ABI.  */\n       if (warn_abi\n-\t  && DECL_C_BIT_FIELD (field) \n+\t  && DECL_C_BIT_FIELD (field)\n \t  /* The TREE_NO_WARNING flag gets set by Objective-C when\n \t     laying out an Objective-C class.  The ObjC ABI differs\n \t     from the C++ ABI, and so we do not want a warning\n@@ -4663,12 +4663,12 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n \tcp_warning_at (\"offset of %qD is not ABI-compliant and may \"\n-                       \"change in a future version of GCC\", \n+                       \"change in a future version of GCC\",\n \t\t       field);\n \n       /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n \t offset of the field.  */\n-      if (warn_abi \n+      if (warn_abi\n \t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n \t\t\t\t  byte_position (field))\n \t  && contains_empty_class_p (TREE_TYPE (field)))\n@@ -4683,16 +4683,16 @@ layout_class_type (tree t, tree *virtuals_p)\n \t{\n \t  tree padding_field;\n \n-\t  padding_field = build_decl (FIELD_DECL, \n+\t  padding_field = build_decl (FIELD_DECL,\n \t\t\t\t      NULL_TREE,\n-\t\t\t\t      char_type_node); \n+\t\t\t\t      char_type_node);\n \t  DECL_BIT_FIELD (padding_field) = 1;\n \t  DECL_SIZE (padding_field) = padding;\n \t  DECL_CONTEXT (padding_field) = t;\n \t  DECL_ARTIFICIAL (padding_field) = 1;\n \t  DECL_IGNORED_P (padding_field) = 1;\n \t  layout_nonempty_base_or_field (rli, padding_field,\n-\t\t\t\t\t NULL_TREE, \n+\t\t\t\t\t NULL_TREE,\n \t\t\t\t\t empty_base_offsets);\n \t}\n \n@@ -4723,7 +4723,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   if (CLASSTYPE_NON_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n       base_t = make_node (TREE_CODE (t));\n-      \n+\n       /* Set the size and alignment for the new type.  In G++ 3.2, all\n \t empty classes were considered to have size zero when used as\n \t base classes.  */\n@@ -4748,14 +4748,14 @@ layout_class_type (tree t, tree *virtuals_p)\n \t     rli_size_so_far, rather than rli_size_unit_so_far, is\n \t     used to compute TYPE_SIZE_UNIT.  */\n \t  eoc = end_of_class (t, /*include_virtuals_p=*/0);\n-\t  TYPE_SIZE_UNIT (base_t) \n+\t  TYPE_SIZE_UNIT (base_t)\n \t    = size_binop (MAX_EXPR,\n \t\t\t  convert (sizetype,\n \t\t\t\t   size_binop (CEIL_DIV_EXPR,\n \t\t\t\t\t       rli_size_so_far (rli),\n \t\t\t\t\t       bitsize_int (BITS_PER_UNIT))),\n \t\t\t  eoc);\n-\t  TYPE_SIZE (base_t) \n+\t  TYPE_SIZE (base_t)\n \t    = size_binop (MAX_EXPR,\n \t\t\t  rli_size_so_far (rli),\n \t\t\t  size_binop (MULT_EXPR,\n@@ -4771,7 +4771,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n \t    *next_field = build_decl (FIELD_DECL,\n-\t\t\t\t      DECL_NAME (field), \n+\t\t\t\t      DECL_NAME (field),\n \t\t\t\t      TREE_TYPE (field));\n \t    DECL_CONTEXT (*next_field) = base_t;\n \t    DECL_FIELD_OFFSET (*next_field) = DECL_FIELD_OFFSET (field);\n@@ -4804,13 +4804,13 @@ layout_class_type (tree t, tree *virtuals_p)\n      base subobject fields.  */\n   layout_virtual_bases (rli, empty_base_offsets);\n \n-  /* Make sure that empty classes are reflected in RLI at this \n+  /* Make sure that empty classes are reflected in RLI at this\n      point.  */\n   include_empty_classes(rli);\n \n   /* Make sure not to create any structures with zero size.  */\n   if (integer_zerop (rli_size_unit_so_far (rli)) && CLASSTYPE_EMPTY_P (t))\n-    place_field (rli, \n+    place_field (rli,\n \t\t build_decl (FIELD_DECL, NULL_TREE, char_type_node));\n \n   /* Let the back-end lay out the type.  */\n@@ -4884,7 +4884,7 @@ finish_struct_1 (tree t)\n   CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n \n   fixup_inline_methods (t);\n-  \n+\n   /* Make assumptions about the class; we'll reset the flags if\n      necessary.  */\n   CLASSTYPE_EMPTY_P (t) = 1;\n@@ -4951,9 +4951,9 @@ finish_struct_1 (tree t)\n \t= chainon (BINFO_VIRTUALS (TYPE_BINFO (t)), virtuals);\n \n       /* Set DECL_VINDEX for all functions declared in this class.  */\n-      for (vindex = 0, fn = BINFO_VIRTUALS (TYPE_BINFO (t)); \n-\t   fn; \n-\t   fn = TREE_CHAIN (fn), \n+      for (vindex = 0, fn = BINFO_VIRTUALS (TYPE_BINFO (t));\n+\t   fn;\n+\t   fn = TREE_CHAIN (fn),\n \t     vindex += (TARGET_VTABLE_USES_DESCRIPTORS\n \t\t\t? TARGET_VTABLE_USES_DESCRIPTORS : 1))\n \t{\n@@ -5003,7 +5003,7 @@ finish_struct_1 (tree t)\n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n   finish_vtbls (t);\n-  \n+\n   /* Build the VTT for T.  */\n   build_vtt (t);\n \n@@ -5020,10 +5020,10 @@ finish_struct_1 (tree t)\n \t     if it were virtual, we would have created it by now.  */\n \t  !dtor\n \t  || (!DECL_VINDEX (dtor)\n-\t      && (!TREE_PRIVATE (dtor) \n-\t\t  || CLASSTYPE_FRIEND_CLASSES (t) \n+\t      && (!TREE_PRIVATE (dtor)\n+\t\t  || CLASSTYPE_FRIEND_CLASSES (t)\n \t\t  || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))))\n-\twarning (0, \"%q#T has virtual functions but non-virtual destructor\", \n+\twarning (0, \"%q#T has virtual functions but non-virtual destructor\",\n \t\t t);\n     }\n \n@@ -5035,7 +5035,7 @@ finish_struct_1 (tree t)\n   maybe_suppress_debug_info (t);\n \n   dump_class_hierarchy (t);\n-  \n+\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, ! LOCAL_CLASS_P (t));\n }\n@@ -5058,8 +5058,8 @@ unreverse_member_declarations (tree t)\n   /* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in\n      reverse order, so we can't just use nreverse.  */\n   prev = NULL_TREE;\n-  for (x = TYPE_FIELDS (t); \n-       x && TREE_CODE (x) != TYPE_DECL; \n+  for (x = TYPE_FIELDS (t);\n+       x && TREE_CODE (x) != TYPE_DECL;\n        x = next)\n     {\n       next = TREE_CHAIN (x);\n@@ -5224,7 +5224,7 @@ fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n         {\n           if (nonnull)\n             *nonnull = 1;\n-        \n+\n           /* if we're in a ctor or dtor, we know our type.  */\n           if (DECL_LANG_SPECIFIC (current_function_decl)\n               && (DECL_CONSTRUCTOR_P (current_function_decl)\n@@ -5240,11 +5240,11 @@ fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n           /* Reference variables should be references to objects.  */\n           if (nonnull)\n \t    *nonnull = 1;\n-\t  \n+\n \t  /* DECL_VAR_MARKED_P is used to prevent recursion; a\n \t     variable's initializer may refer to the variable\n \t     itself.  */\n-\t  if (TREE_CODE (instance) == VAR_DECL \n+\t  if (TREE_CODE (instance) == VAR_DECL\n \t      && DECL_INITIAL (instance)\n \t      && !DECL_VAR_MARKED_P (instance))\n \t    {\n@@ -5282,7 +5282,7 @@ resolves_to_fixed_type_p (tree instance, int* nonnull)\n {\n   tree t = TREE_TYPE (instance);\n   int cdtorp = 0;\n-  \n+\n   tree fixed = fixed_type_or_null (instance, nonnull, &cdtorp);\n   if (fixed == NULL_TREE)\n     return 0;\n@@ -5299,7 +5299,7 @@ init_class_processing (void)\n {\n   current_class_depth = 0;\n   current_class_stack_size = 10;\n-  current_class_stack \n+  current_class_stack\n     = xmalloc (current_class_stack_size * sizeof (struct class_stack_node));\n   local_classes = VEC_alloc (tree, gc, 8);\n \n@@ -5322,8 +5322,8 @@ restore_class_cache (void)\n   push_binding_level (previous_class_level);\n   class_binding_level = previous_class_level;\n   /* Restore IDENTIFIER_TYPE_VALUE.  */\n-  for (type = class_binding_level->type_shadowed; \n-       type; \n+  for (type = class_binding_level->type_shadowed;\n+       type;\n        type = TREE_CHAIN (type))\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (type), TREE_TYPE (type));\n }\n@@ -5343,7 +5343,7 @@ pushclass (tree type)\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* Make sure there is enough room for the new entry on the stack.  */\n-  if (current_class_depth + 1 >= current_class_stack_size) \n+  if (current_class_depth + 1 >= current_class_stack_size)\n     {\n       current_class_stack_size *= 2;\n       current_class_stack\n@@ -5367,8 +5367,8 @@ pushclass (tree type)\n \n   /* By default, things in classes are private, while things in\n      structures or unions are public.  */\n-  current_access_specifier = (CLASSTYPE_DECLARED_CLASS (type) \n-\t\t\t      ? access_private_node \n+  current_access_specifier = (CLASSTYPE_DECLARED_CLASS (type)\n+\t\t\t      ? access_private_node\n \t\t\t      : access_public_node);\n \n   if (previous_class_level\n@@ -5379,7 +5379,7 @@ pushclass (tree type)\n       invalidate_class_lookup_cache ();\n     }\n \n-  if (!previous_class_level \n+  if (!previous_class_level\n       || type != previous_class_level->this_entity\n       || current_class_depth > 1)\n     pushlevel_class ();\n@@ -5396,7 +5396,7 @@ invalidate_class_lookup_cache (void)\n {\n   previous_class_level = NULL;\n }\n- \n+\n /* Get out of the current class scope. If we were in a class scope\n    previously, that is the one popped to.  */\n \n@@ -5468,14 +5468,14 @@ push_nested_class (tree type)\n   tree context;\n \n   /* A namespace might be passed in error cases, like A::B:C.  */\n-  if (type == NULL_TREE \n-      || type == error_mark_node \n+  if (type == NULL_TREE\n+      || type == error_mark_node\n       || TREE_CODE (type) == NAMESPACE_DECL\n       || ! IS_AGGR_TYPE (type)\n       || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n       || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     return;\n-  \n+\n   context = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n \n   if (context && CLASS_TYPE_P (context))\n@@ -5538,7 +5538,7 @@ push_lang_context (tree name)\n   else\n     error (\"language string %<\\\"%E\\\"%> not recognized\", name);\n }\n-  \n+\n /* Get out of the current language scope.  */\n \n void\n@@ -5558,14 +5558,14 @@ pop_lang_context (void)\n    template arguments.  */\n \n static tree\n-resolve_address_of_overloaded_function (tree target_type, \n+resolve_address_of_overloaded_function (tree target_type,\n \t\t\t\t\ttree overload,\n \t\t\t\t\ttsubst_flags_t flags,\n \t\t\t\t\tbool template_only,\n \t\t\t\t\ttree explicit_targs)\n {\n   /* Here's what the standard says:\n-     \n+\n        [over.over]\n \n        If the name is a function template, template argument deduction\n@@ -5605,7 +5605,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t      || TREE_CODE (TREE_TYPE (target_type)) != METHOD_TYPE);\n \n   gcc_assert (is_overloaded_fn (overload));\n-  \n+\n   /* Check that the TARGET_TYPE is reasonable.  */\n   if (TYPE_PTRFN_P (target_type))\n     /* This is OK.  */;\n@@ -5619,15 +5619,15 @@ resolve_address_of_overloaded_function (tree target_type,\n       target_type = build_reference_type (target_type);\n       is_reference = 1;\n     }\n-  else \n+  else\n     {\n       if (flags & tf_error)\n \terror (\"cannot resolve overloaded function %qD based on\"\n-               \" conversion to type %qT\", \n+               \" conversion to type %qT\",\n                DECL_NAME (OVL_FUNCTION (overload)), target_type);\n       return error_mark_node;\n     }\n-  \n+\n   /* If we can find a non-template function that matches, we can just\n      use it.  There's no point in generating template instantiations\n      if we're just going to throw them out anyhow.  But, of course, we\n@@ -5670,7 +5670,7 @@ resolve_address_of_overloaded_function (tree target_type,\n   /* Now, if we've already got a match (or matches), there's no need\n      to proceed to the template functions.  But, if we don't have a\n      match we need to look at them, too.  */\n-  if (!matches) \n+  if (!matches)\n     {\n       tree target_fn_type;\n       tree target_arg_types;\n@@ -5688,7 +5688,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       /* Never do unification on the 'this' parameter.  */\n       if (TREE_CODE (target_fn_type) == METHOD_TYPE)\n \ttarget_arg_types = TREE_CHAIN (target_arg_types);\n-\t  \n+\n       for (fns = overload; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n@@ -5723,7 +5723,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  /* See if there's a match.  */\n \t  instantiation_type = TREE_TYPE (instantiation);\n \t  if (is_ptrmem)\n-\t    instantiation_type = \n+\t    instantiation_type =\n \t      build_ptrmemfunc_type (build_pointer_type (instantiation_type));\n \t  else if (!is_reference)\n \t    instantiation_type = build_pointer_type (instantiation_type);\n@@ -5747,7 +5747,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       /* There were *no* matches.  */\n       if (flags & tf_error)\n \t{\n- \t  error (\"no matches converting function %qD to type %q#T\", \n+ \t  error (\"no matches converting function %qD to type %q#T\",\n                  DECL_NAME (OVL_FUNCTION (overload)),\n                  target_type);\n \n@@ -5757,7 +5757,7 @@ resolve_address_of_overloaded_function (tree target_type,\n           for (; overload; overload = OVL_NEXT (overload))\n             matches = tree_cons (NULL_TREE, OVL_CURRENT (overload),\n \t\t\t\t matches);\n-          \n+\n \t  print_candidates (matches);\n \t}\n       return error_mark_node;\n@@ -5770,7 +5770,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t{\n \t  tree match;\n \n- \t  error (\"converting overloaded function %qD to type %q#T is ambiguous\", \n+ \t  error (\"converting overloaded function %qD to type %q#T is ambiguous\",\n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n \t\t    target_type);\n \n@@ -5781,7 +5781,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \n \t  print_candidates (matches);\n \t}\n-      \n+\n       return error_mark_node;\n     }\n \n@@ -5792,7 +5792,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       && !(flags & tf_ptrmem_ok) && !flag_ms_extensions)\n     {\n       static int explained;\n-      \n+\n       if (!(flags & tf_error))\n         return error_mark_node;\n \n@@ -5830,17 +5830,17 @@ resolve_address_of_overloaded_function (tree target_type,\n    we complain on errors.  If we are not complaining, never modify rhs,\n    as overload resolution wants to try many possible instantiations, in\n    the hope that at least one will work.\n-   \n+\n    For non-recursive calls, LHSTYPE should be a function, pointer to\n    function, or a pointer to member function.  */\n \n tree\n instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n {\n   tsubst_flags_t flags_in = flags;\n-  \n+\n   flags &= ~tf_ptrmem_ok;\n-  \n+\n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n       if (flags & tf_error)\n@@ -5852,7 +5852,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     {\n       if (same_type_p (lhstype, TREE_TYPE (rhs)))\n \treturn rhs;\n-      if (flag_ms_extensions \n+      if (flag_ms_extensions\n \t  && TYPE_PTRMEMFUNC_P (lhstype)\n \t  && !TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n \t/* Microsoft allows `A::f' to be resolved to a\n@@ -5954,7 +5954,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n     case OVERLOAD:\n     case FUNCTION_DECL:\n-      return \n+      return\n \tresolve_address_of_overloaded_function (lhstype, rhs, flags_in,\n \t\t\t\t\t\t/*template_only=*/false,\n \t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n@@ -6057,12 +6057,12 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n       TREE_TYPE (rhs) = lhstype;\n       return rhs;\n-      \n+\n     case ADDR_EXPR:\n     {\n       if (PTRMEM_OK_P (rhs))\n         flags |= tf_ptrmem_ok;\n-      \n+\n       return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n     }\n \n@@ -6097,7 +6097,7 @@ get_vfield_name (tree type)\n \t  || !TYPE_CONTAINS_VPTR_P (BINFO_TYPE (base_binfo)))\n \tbreak;\n     }\n-  \n+\n   type = BINFO_TYPE (binfo);\n   buf = alloca (sizeof (VFIELD_NAME_FORMAT) + TYPE_NAME_LENGTH (type) + 2);\n   sprintf (buf, VFIELD_NAME_FORMAT,\n@@ -6208,10 +6208,10 @@ maybe_note_name_used_in_class (tree name, tree decl)\n   if (!(innermost_scope_kind() == sk_class\n \t&& TYPE_BEING_DEFINED (current_class_type)))\n     return;\n-  \n+\n   /* If there's already a binding for this NAME, then we don't have\n      anything to worry about.  */\n-  if (lookup_member (current_class_type, name, \n+  if (lookup_member (current_class_type, name,\n \t\t     /*protect=*/0, /*want_type=*/false))\n     return;\n \n@@ -6221,7 +6221,7 @@ maybe_note_name_used_in_class (tree name, tree decl)\n   names_used = current_class_stack[current_class_depth - 1].names_used;\n \n   splay_tree_insert (names_used,\n-\t\t     (splay_tree_key) name, \n+\t\t     (splay_tree_key) name,\n \t\t     (splay_tree_value) decl);\n }\n \n@@ -6235,7 +6235,7 @@ note_name_declared_in_class (tree name, tree decl)\n   splay_tree_node n;\n \n   /* Look to see if we ever used this name.  */\n-  names_used \n+  names_used\n     = current_class_stack[current_class_depth - 1].names_used;\n   if (!names_used)\n     return;\n@@ -6244,12 +6244,12 @@ note_name_declared_in_class (tree name, tree decl)\n   if (n)\n     {\n       /* [basic.scope.class]\n-\t \n+\n \t A name N used in a class S shall refer to the same declaration\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n       error (\"declaration of %q#D\", decl);\n-      cp_error_at (\"changes meaning of %qD from %q+#D\", \n+      cp_error_at (\"changes meaning of %qD from %q+#D\",\n \t\t   DECL_NAME (OVL_CURRENT (decl)),\n \t\t   (tree) n->value);\n     }\n@@ -6287,7 +6287,7 @@ get_primary_binfo (tree binfo)\n {\n   tree primary_base;\n   tree result;\n-  \n+\n   primary_base = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo));\n   if (!primary_base)\n     return NULL_TREE;\n@@ -6321,7 +6321,7 @@ dump_class_hierarchy_r (FILE *stream,\n   int indented = 0;\n   tree base_binfo;\n   int i;\n-  \n+\n   indented = maybe_indent_hierarchy (stream, indent, 0);\n   fprintf (stream, \"%s (0x%lx) \",\n \t   type_as_string (BINFO_TYPE (binfo), TFF_PLAIN_IDENTIFIER),\n@@ -6332,7 +6332,7 @@ dump_class_hierarchy_r (FILE *stream,\n       return igo;\n     }\n   igo = TREE_CHAIN (binfo);\n-  \n+\n   fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n \t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n   if (is_empty_class (BINFO_TYPE (binfo)))\n@@ -6363,7 +6363,7 @@ dump_class_hierarchy_r (FILE *stream,\n   if (!(flags & TDF_SLIM))\n     {\n       int indented = 0;\n-      \n+\n       if (BINFO_SUBVTT_INDEX (binfo))\n \t{\n \t  indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n@@ -6392,14 +6392,14 @@ dump_class_hierarchy_r (FILE *stream,\n \t\t   expr_as_string (BINFO_VTABLE (binfo),\n \t\t\t\t   TFF_PLAIN_IDENTIFIER));\n \t}\n-      \n+\n       if (indented)\n \tfprintf (stream, \"\\n\");\n     }\n \n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     igo = dump_class_hierarchy_r (stream, flags, base_binfo, igo, indent + 2);\n-  \n+\n   return igo;\n }\n \n@@ -6476,7 +6476,7 @@ dump_vtable (tree t, tree binfo, tree vtable)\n   if (!(flags & TDF_SLIM))\n     {\n       int ctor_vtbl_p = TYPE_BINFO (t) != binfo;\n-      \n+\n       fprintf (stream, \"%s for %s\",\n \t       ctor_vtbl_p ? \"Construction vtable\" : \"Vtable\",\n \t       type_as_string (BINFO_TYPE (binfo), TFF_PLAIN_IDENTIFIER));\n@@ -6490,7 +6490,7 @@ dump_vtable (tree t, tree binfo, tree vtable)\n       dump_array (stream, vtable);\n       fprintf (stream, \"\\n\");\n     }\n-  \n+\n   dump_end (TDI_class, stream);\n }\n \n@@ -6510,7 +6510,7 @@ dump_vtt (tree t, tree vtt)\n       dump_array (stream, vtt);\n       fprintf (stream, \"\\n\");\n     }\n-  \n+\n   dump_end (TDI_class, stream);\n }\n \n@@ -6522,7 +6522,7 @@ dump_thunk (FILE *stream, int indent, tree thunk)\n   static const char spaces[] = \"        \";\n   tree name = DECL_NAME (thunk);\n   tree thunks;\n-      \n+\n   fprintf (stream, \"%.*s%p %s %s\", indent, spaces,\n \t   (void *)thunk,\n \t   !DECL_THUNK_P (thunk) ? \"function\"\n@@ -6575,7 +6575,7 @@ finish_vtbls (tree t)\n   list = build_tree_list (BINFO_VTABLE (TYPE_BINFO (t)), NULL_TREE);\n   accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n \t\t\t TYPE_BINFO (t), t, list);\n-  \n+\n   /* Then come the virtual bases, also in inheritance graph order.  */\n   for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n@@ -6603,15 +6603,15 @@ initialize_vtable (tree binfo, tree inits)\n \n /* Build the VTT (virtual table table) for T.\n    A class requires a VTT if it has virtual bases.\n-   \n+\n    This holds\n    1 - primary virtual pointer for complete object T\n    2 - secondary VTTs for each direct non-virtual base of T which requires a\n        VTT\n    3 - secondary virtual pointers for each direct or indirect base of T which\n        has virtual bases or is reachable via a virtual path from T.\n    4 - secondary VTTs for each direct or indirect virtual base of T.\n-   \n+\n    Secondary VTTs look like complete object VTTs without part 4.  */\n \n static void\n@@ -6634,7 +6634,7 @@ build_vtt (tree t)\n   /* Figure out the type of the VTT.  */\n   type = build_index_type (size_int (list_length (inits) - 1));\n   type = build_cplus_array_type (const_ptr_type_node, type);\n-\t\t\t\t \n+\n   /* Now, build the VTT object itself.  */\n   vtt = build_vtable (t, get_vtt_name (t), type);\n   initialize_artificial_var (vtt, inits);\n@@ -6727,20 +6727,20 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n       BINFO_VPTR_INDEX (binfo) = *index;\n     }\n   *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n-\t\t       \n+\n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, b); ++i)\n     if (!BINFO_VIRTUAL_P (b))\n       inits = build_vtt_inits (b, t, inits, index);\n-      \n+\n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or reachable along a virtual path, except\n      subobjects that are non-virtual primary bases.  */\n   data.top_level_p = top_level_p;\n   data.index = *index;\n   data.inits = NULL;\n   data.type_being_constructed = BINFO_TYPE (binfo);\n-  \n+\n   dfs_walk_once (binfo, dfs_build_secondary_vptr_vtt_inits, NULL, &data);\n \n   *index = data.index;\n@@ -6763,7 +6763,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n       {\n \tif (!BINFO_VIRTUAL_P (b))\n \t  continue;\n-\t\n+\n \tinits = build_vtt_inits (b, t, inits, index);\n       }\n   else\n@@ -6795,11 +6795,11 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n   if (!(CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo))\n \t|| binfo_via_virtual (binfo, data->type_being_constructed)))\n     return dfs_skip_bases;\n-  \n+\n   /* We're not interested in non-virtual primary bases.  */\n   if (!BINFO_VIRTUAL_P (binfo) && BINFO_PRIMARY_P (binfo))\n     return NULL_TREE;\n-  \n+\n   /* Record the index where this secondary vptr can be found.  */\n   if (data->top_level_p)\n     {\n@@ -6816,7 +6816,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n \t    binfo = BINFO_INHERITANCE_CHAIN (binfo);\n \t}\n     }\n-  \n+\n   /* Add the initializer for the secondary vptr itself.  */\n   data->inits = tree_cons (NULL_TREE, binfo_ctor_vtable (binfo), data->inits);\n \n@@ -6840,12 +6840,12 @@ dfs_fixup_binfo_vtbls (tree binfo, void* data)\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n     /* If this class has no vtable, none of its bases do.  */\n     return dfs_skip_bases;\n-  \n+\n   if (!vtable)\n     /* This might be a primary base, so have no vtable in this\n        hierarchy.  */\n     return NULL_TREE;\n-  \n+\n   /* If we scribbled the construction vtable vptr into BINFO, clear it\n      out now.  */\n   if (TREE_CODE (vtable) == TREE_LIST\n@@ -6885,16 +6885,16 @@ build_ctor_vtbl_group (tree binfo, tree t)\n \n   /* Add the vtables for each of our virtual bases using the vbase in T\n      binfo.  */\n-  for (vbase = TYPE_BINFO (BINFO_TYPE (binfo)); \n-       vbase; \n+  for (vbase = TYPE_BINFO (BINFO_TYPE (binfo));\n+       vbase;\n        vbase = TREE_CHAIN (vbase))\n     {\n       tree b;\n \n       if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n       b = copied_binfo (vbase, binfo);\n-      \n+\n       accumulate_vtbl_inits (b, vbase, binfo, t, list);\n     }\n   inits = TREE_VALUE (list);\n@@ -6936,20 +6936,20 @@ accumulate_vtbl_inits (tree binfo,\n   /* If it doesn't have a vptr, we don't do anything.  */\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n     return;\n-  \n+\n   /* If we're building a construction vtable, we're not interested in\n      subobjects that don't require construction vtables.  */\n-  if (ctor_vtbl_p \n+  if (ctor_vtbl_p\n       && !CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo))\n       && !binfo_via_virtual (orig_binfo, BINFO_TYPE (rtti_binfo)))\n     return;\n \n   /* Build the initializers for the BINFO-in-T vtable.  */\n-  TREE_VALUE (inits) \n+  TREE_VALUE (inits)\n     = chainon (TREE_VALUE (inits),\n \t       dfs_accumulate_vtbl_inits (binfo, orig_binfo,\n \t\t\t\t\t  rtti_binfo, t, inits));\n-\t\t      \n+\n   /* Walk the BINFO and its bases.  We walk in preorder so that as we\n      initialize each vtable we can figure out at what offset the\n      secondary vtable lies from the primary vtable.  We can't use\n@@ -6991,14 +6991,14 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \t primary, we still need a VTT entry for the vtable, but it\n \t should point to the ctor vtable for the base it is a\n \t primary for within the sub-hierarchy of RTTI_BINFO.\n-\t      \n+\n \t There are three possible cases:\n-\t      \n+\n \t 1) We are in the same place.\n \t 2) We are a primary base within a lost primary virtual base of\n \t RTTI_BINFO.\n \t 3) We are primary to something not a base of RTTI_BINFO.  */\n-\t  \n+\n       tree b;\n       tree last = NULL_TREE;\n \n@@ -7018,7 +7018,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \tif (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n \t  break;\n     found:\n-      \n+\n       /* If we found RTTI_BINFO, this is case 1.  If we found a virtual\n \t base B and it is a base of RTTI_BINFO, this is case 2.  In\n \t either case, we share our vtable with LAST, i.e. the\n@@ -7086,7 +7086,7 @@ static GTY(()) tree abort_fndecl_addr;\n    The value returned is a TREE_LIST suitable for wrapping in a\n    CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If\n    NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the\n-   number of non-function entries in the vtable.  \n+   number of non-function entries in the vtable.\n \n    It might seem that this function should never be called with a\n    BINFO for which BINFO_PRIMARY_P holds, the vtable for such a\n@@ -7108,7 +7108,7 @@ build_vtbl_initializer (tree binfo,\n   unsigned ix;\n   tree vbinfo;\n   VEC(tree,gc) *vbases;\n-  \n+\n   /* Initialize VID.  */\n   memset (&vid, 0, sizeof (vid));\n   vid.binfo = binfo;\n@@ -7130,7 +7130,7 @@ build_vtbl_initializer (tree binfo,\n   vid.fns = VEC_alloc (tree, gc, 32);\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n-  \n+\n   /* Clear BINFO_VTABLE_PATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n@@ -7168,7 +7168,7 @@ build_vtbl_initializer (tree binfo,\n       tree vcall_index;\n       tree fn, fn_original;\n       tree init = NULL_TREE;\n-      \n+\n       fn = BV_FN (v);\n       fn_original = fn;\n       if (DECL_THUNK_P (fn))\n@@ -7182,7 +7182,7 @@ build_vtbl_initializer (tree binfo,\n \t    }\n \t  fn_original = THUNK_TARGET (fn);\n \t}\n-      \n+\n       /* If the only definition of this function signature along our\n \t primary base chain is from a lost primary, this vtable slot will\n \t never be used, so just zero it out.  This is important to avoid\n@@ -7267,7 +7267,7 @@ build_vtbl_initializer (tree binfo,\n   /* The initializers for virtual functions were built up in reverse\n      order; straighten them out now.  */\n   vfun_inits = nreverse (vfun_inits);\n-  \n+\n   /* The negative offset initializers are also in reverse order.  */\n   vid.inits = nreverse (vid.inits);\n \n@@ -7313,7 +7313,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n     return;\n \n   t = vid->derived;\n-  \n+\n   /* We might be a primary base class.  Go up the inheritance hierarchy\n      until we find the most derived class of which we are a primary base:\n      it is the offset of that which we need to use.  */\n@@ -7345,7 +7345,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n     {\n       tree b;\n       tree delta;\n-      \n+\n       if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n \n@@ -7360,7 +7360,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       BINFO_VTABLE_PATH_MARKED (b) = 1;\n \n       /* Figure out where we can find this vbase offset.  */\n-      delta = size_binop (MULT_EXPR, \n+      delta = size_binop (MULT_EXPR,\n \t\t\t  vid->index,\n \t\t\t  convert (ssizetype,\n \t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n@@ -7380,10 +7380,10 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \t we are walking in inheritance graph order so these end up in\n \t the right order.  */\n       delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (non_primary_binfo));\n-      \n-      *vid->last_init \n+\n+      *vid->last_init\n \t= build_tree_list (NULL_TREE,\n-\t\t\t   fold_build1 (NOP_EXPR, \n+\t\t\t   fold_build1 (NOP_EXPR,\n \t\t\t\t\tvtable_entry_type,\n \t\t\t\t\tdelta));\n       vid->last_init = &TREE_CHAIN (*vid->last_init);\n@@ -7445,7 +7445,7 @@ add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n      through the recursion in build_vcall_and_vbase_vtbl_entries.  */\n   if (BINFO_VIRTUAL_P (binfo) && vid->vbase != binfo)\n     return;\n-  \n+\n   /* If BINFO has a primary base, process it first.  */\n   primary_binfo = get_primary_binfo (binfo);\n   if (primary_binfo)\n@@ -7519,7 +7519,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \t   where rtti_binfo is the most derived type.  */\n \tnon_primary_binfo\n \t  = original_binfo (non_primary_binfo, vid->rtti_binfo);\n-      \n+\n       for (base_virtuals = BINFO_VIRTUALS (binfo),\n \t     derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n \t     orig_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n@@ -7558,7 +7558,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n      signature as FN, then we do not need a second vcall offset.\n      Check the list of functions already present in the derived\n      class vtable.  */\n-  for (i = 0; VEC_iterate (tree, vid->fns, i, derived_entry); ++i) \n+  for (i = 0; VEC_iterate (tree, vid->fns, i, derived_entry); ++i)\n     {\n       if (same_signature_p (derived_entry, orig_fn)\n \t  /* We only use one vcall offset for virtual destructors,\n@@ -7579,7 +7579,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n       elt->purpose = orig_fn;\n       elt->value = vid->index;\n     }\n-  \n+\n   /* The next vcall offset will be found at a more negative\n      offset.  */\n   vid->index = size_binop (MINUS_EXPR, vid->index,\n@@ -7654,7 +7654,7 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n     decl = build_address (get_tinfo_decl (t));\n   else\n     decl = integer_zero_node;\n-  \n+\n   /* Convert the declaration to a type that can be stored in the\n      vtable.  */\n   init = build_nop (vfunc_ptr_type_node, decl);"}, {"sha": "4af7843d6f54c5a420d8357f50e96a304df79a6e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -635,7 +635,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t\t      CLEANUP_EXPR (stmt));\n \n   pointer_set_insert (p_set, *stmt_p);\n-  \n+\n   return NULL;\n }\n "}, {"sha": "a8b807b5644f6cf2986ad539f5bd195ae4f35983", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -99,7 +99,7 @@ cp_expr_size (tree exp)\n                      the result.  Since the \"s\" subobject is never\n                      constructed, this is a valid transformation.  */\n \t\t  || CP_AGGREGATE_TYPE_P (type));\n-      \n+\n       /* This would be wrong for a type with virtual bases, but they are\n \t caught by the assert above.  */\n       return (is_empty_class (type)"}, {"sha": "833ad3374b39de18446e750a0266a6412e035716", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    additional tree codes used in the GNU C++ compiler (see tree.def\n    for the standard codes).\n-   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998, 2003, 2004, 2005, \n+   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998, 2003, 2004, 2005,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -22,7 +22,7 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n- \n+\n /* An OFFSET_REF is used in two situations:\n \n    1. An expression of the form `A::m' where `A' is a class and `m' is\n@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n       The expression is a pointer-to-member if its address is taken,\n       but simply denotes a member of the object if its address is not\n       taken.\n-      \n+\n       This form is only used during the parsing phase; once semantic\n       analysis has taken place they are eliminated.\n \n@@ -97,7 +97,7 @@ DEFTREECODE (ALIAS_DECL, \"alias_decl\", tcc_declaration, 0)\n    functions.  BASELINK_BINFO gives the base from which the functions\n    come, i.e., the base to which the `this' pointer must be converted\n    before the functions are called.  BASELINK_ACCESS_BINFO gives the\n-   base used to name the functions.  \n+   base used to name the functions.\n \n    A BASELINK is an expression; the TREE_TYPE of the BASELINK gives\n    the type of the expression.  This type is either a FUNCTION_TYPE,\n@@ -127,14 +127,14 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n    gives the level (from 1) of the parameter.\n \n    Here's an example:\n-   \n+\n    template <class T> // Index 0, Level 1.\n    struct S\n    {\n       template <class U, // Index 0, Level 2.\n                 class V> // Index 1, Level 2.\n       void f();\n-   };  \n+   };\n \n    The DESCENDANTS will be a chain of TEMPLATE_PARM_INDEXs descended\n    from this one.  The first descendant will have the same IDX, but\n@@ -151,17 +151,17 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n                class V> // Index 1, Level 1, Orig Level 2\n      void f();\n    };\n-  \n+\n    The LEVEL is the level of the parameter when we are worrying about\n    the types of things; the ORIG_LEVEL is the level when we are\n    worrying about instantiating things.  */\n DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", tcc_exceptional, 0)\n \n /* Index into a template parameter list for template template parameters.\n-   This parameter must be a type.  The TYPE_FIELDS value will be a \n+   This parameter must be a type.  The TYPE_FIELDS value will be a\n    TEMPLATE_PARM_INDEX.\n \n-   It is used without template arguments like TT in C<TT>, \n+   It is used without template arguments like TT in C<TT>,\n    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO is NULL_TREE\n    and TYPE_NAME is a TEMPLATE_DECL.  */\n DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", tcc_type, 0)\n@@ -170,7 +170,7 @@ DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", tcc_type, 0)\n    macros in tree.h.  Changing the order will degrade the speed of the\n    compiler.  TEMPLATE_TYPE_PARM, TYPENAME_TYPE, TYPEOF_TYPE,\n    BOUND_TEMPLATE_TEMPLATE_PARM.  */\n-     \n+\n /* Index into a template parameter list.  This parameter must be a type.\n    The type.value field will be a TEMPLATE_PARM_INDEX.  */\n DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", tcc_type, 0)\n@@ -185,7 +185,7 @@ DEFTREECODE (TYPENAME_TYPE, \"typename_type\", tcc_type, 0)\n    expression in question.  */\n DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", tcc_type, 0)\n \n-/* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments \n+/* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments\n    like TT<int>.\n    In this case, TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO contains the\n    template name and its bound arguments.  TYPE_NAME is a TYPE_DECL.  */\n@@ -203,7 +203,7 @@ DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", tcc_type, 0)\n    not an alias, but is later expanded into multiple aliases.  */\n DEFTREECODE (USING_DECL, \"using_decl\", tcc_declaration, 0)\n \n-/* A using directive. The operand is USING_STMT_NAMESPACE.  */     \n+/* A using directive. The operand is USING_STMT_NAMESPACE.  */\n DEFTREECODE (USING_STMT, \"using_directive\", tcc_statement, 1)\n \n /* An un-parsed default argument.  Holds a vector of input tokens and\n@@ -218,20 +218,20 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", tcc_exceptional, 0)\n    member template, the template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", tcc_expression, 2)\n \n-/* A list-like node for chaining overloading candidates. TREE_TYPE is \n+/* A list-like node for chaining overloading candidates. TREE_TYPE is\n    the original name, and the parameter is the FUNCTION_DECL.  */\n DEFTREECODE (OVERLOAD, \"overload\", tcc_exceptional, 0)\n \n /* A pseudo-destructor, of the form \"OBJECT.~DESTRUCTOR\" or\n    \"OBJECT.SCOPE::~DESTRUCTOR.  The first operand is the OBJECT.  The\n    second operand (if non-NULL) is the SCOPE.  The third operand is\n    the TYPE node corresponding to the DESTRUCTOR.  The type of the\n-   first operand will always be a scalar type. \n+   first operand will always be a scalar type.\n \n    The type of a PSEUDO_DTOR_EXPR is always \"void\", even though it can\n    be used as if it were a zero-argument function.  We handle the\n    function-call case specially, and giving it \"void\" type prevents it\n-   being used in expressions in ways that are not permitted.  */  \n+   being used in expressions in ways that are not permitted.  */\n DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", tcc_expression, 3)\n \n /* A whole bunch of tree codes for the initial, superficial parsing of\n@@ -281,7 +281,7 @@ DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", tcc_statement, 3)\n \n /* Represents an 'if' statement. The operands are IF_COND,\n    THEN_CLAUSE, and ELSE_CLAUSE, respectively.  */\n-/* ??? It is currently still necessary to distinguish between IF_STMT \n+/* ??? It is currently still necessary to distinguish between IF_STMT\n    and COND_EXPR for the benefit of templates.  */\n DEFTREECODE (IF_STMT, \"if_stmt\", tcc_statement, 3)\n "}, {"sha": "ef90c3d528ba826da6db4fcc38f1f5c94a720000", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1041,7 +1041,7 @@ struct lang_type_class GTY(())\n   unsigned java_interface : 1;\n   unsigned debug_requested : 1;\n   unsigned fields_readonly : 1;\n-  \n+\n   unsigned use_template : 2;\n   unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n@@ -1170,7 +1170,7 @@ struct lang_type GTY(())\n    it has not yet been declared.  */\n #define CLASSTYPE_LAZY_DESTRUCTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->lazy_destructor)\n- \n+\n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n #define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n \n@@ -1529,7 +1529,7 @@ struct lang_decl_flags GTY(())\n   unsigned initialized_in_class : 1;\n   unsigned assignment_operator_p : 1;\n   unsigned u1sel : 1;\n- \n+\n   unsigned u2sel : 1;\n   unsigned can_be_full : 1;\n   unsigned thunk_p : 1;\n@@ -1578,7 +1578,7 @@ struct lang_decl GTY(())\n \tunsigned u3sel : 1;\n \tunsigned pending_inline_p : 1;\n \tunsigned spare : 22;\n-\t\n+\n \t/* For a non-thunk function decl, this is a tree list of\n   \t   friendly classes. For a thunk function decl, it is the\n   \t   thunked to function decl.  */\n@@ -1597,12 +1597,12 @@ struct lang_decl GTY(())\n \t  /* In a non-thunk FUNCTION_DECL or TEMPLATE_DECL, this is\n \t     DECL_CLONED_FUNCTION.  */\n \t  tree GTY ((tag (\"0\"))) cloned_function;\n-\t  \n+\n \t  /* In a FUNCTION_DECL for which THUNK_P holds this is the\n \t     THUNK_FIXED_OFFSET.  */\n \t  HOST_WIDE_INT GTY ((tag (\"1\"))) fixed_offset;\n \t} GTY ((desc (\"%0.decl_flags.thunk_p\"))) u5;\n-\t\n+\n \tunion lang_decl_u3\n \t{\n \t  struct sorted_fields_type * GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\")))\n@@ -1911,7 +1911,7 @@ struct lang_decl GTY(())\n   (TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n    && DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n    && DECL_LANG_SPECIFIC (NODE)->decl_flags.thunk_p)\n-     \n+\n /* Set DECL_THUNK_P for node.  */\n #define SET_DECL_THUNK_P(NODE, THIS_ADJUSTING)\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.thunk_p = 1,\t\t\\"}, {"sha": "f136d5bde494d02f198f2fb4e22c1ac2a700bd97", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -140,7 +140,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t  intype_class = TREE_TYPE (intype);\n \t  type_class = TREE_TYPE (type);\n \n-\t  same_p = same_type_p (TYPE_MAIN_VARIANT (intype_class), \n+\t  same_p = same_type_p (TYPE_MAIN_VARIANT (intype_class),\n \t\t\t\tTYPE_MAIN_VARIANT (type_class));\n \t  binfo = NULL_TREE;\n \t  /* Try derived to base conversion.  */\n@@ -174,7 +174,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n     }\n   else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n     {\n-      tree b1; \n+      tree b1;\n       tree b2;\n       tree binfo;\n       enum tree_code code = PLUS_EXPR;\n@@ -211,7 +211,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \texpr = cplus_expand_constant (expr);\n \n       if (binfo && !integer_zerop (BINFO_OFFSET (binfo)))\n-\texpr = size_binop (code, \n+\texpr = size_binop (code,\n \t\t\t   build_nop (sizetype, expr),\n \t\t\t   BINFO_OFFSET (binfo));\n       return build_nop (type, expr);\n@@ -255,7 +255,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t}\n       else\n \texpr = build_int_cst (type, 0);\n-      \n+\n       return expr;\n     }\n   else if (TYPE_PTR_TO_MEMBER_P (type) && INTEGRAL_CODE_P (form))\n@@ -274,7 +274,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t as a pointer.  */\n       gcc_assert (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n \t\t  == GET_MODE_SIZE (TYPE_MODE (type)));\n-      \n+\n       return convert_to_pointer (type, expr);\n     }\n \n@@ -295,7 +295,7 @@ convert_to_pointer_force (tree type, tree expr)\n {\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form = TREE_CODE (intype);\n-  \n+\n   if (form == POINTER_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n@@ -363,7 +363,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \n       /* Process the initializer for the declaration.  */\n       DECL_INITIAL (arg) = targ;\n-      cp_finish_decl (arg, targ, NULL_TREE, \n+      cp_finish_decl (arg, targ, NULL_TREE,\n \t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n     }\n   else if (!(flags & DIRECT_BIND) && ! lvalue_p (arg))\n@@ -398,7 +398,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n /* Subroutine of convert_to_reference. REFTYPE is the target reference type.\n    INTYPE is the original rvalue type and DECL is an optional _DECL node\n    for diagnostics.\n-   \n+\n    [dcl.init.ref] says that if an rvalue is used to\n    initialize a reference, then the reference must be to a\n    non-volatile const type.  */\n@@ -407,7 +407,7 @@ static void\n warn_ref_binding (tree reftype, tree intype, tree decl)\n {\n   tree ttl = TREE_TYPE (reftype);\n-  \n+\n   if (!CP_TYPE_CONST_NON_VOLATILE_P (ttl))\n     {\n       const char *msg;\n@@ -446,9 +446,9 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n \n-  if (TREE_CODE (type) == FUNCTION_TYPE \n+  if (TREE_CODE (type) == FUNCTION_TYPE\n       && TREE_TYPE (expr) == unknown_type_node)\n-    expr = instantiate_type (type, expr, \n+    expr = instantiate_type (type, expr,\n \t\t\t     (flags & LOOKUP_COMPLAIN)\n \t\t\t     ? tf_error | tf_warning : tf_none);\n \n@@ -491,7 +491,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n \t  if (! real_lvalue_p (expr))\n \t    warn_ref_binding (reftype, intype, decl);\n-\t  \n+\n \t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n \t    pedwarn (\"conversion from %qT to %qT discards qualifiers\",\n@@ -514,7 +514,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, reftype);\n-\t  \n+\n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)),\n@@ -554,7 +554,7 @@ convert_from_reference (tree val)\n     {\n       tree t = canonical_type_variant (TREE_TYPE (TREE_TYPE (val)));\n       tree ref = build1 (INDIRECT_REF, t, val);\n-      \n+\n        /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t  so that we get the proper error message if the result is used\n \t  to assign to.  Also, &* is supposed to be a no-op.  */\n@@ -565,7 +565,7 @@ convert_from_reference (tree val)\n       REFERENCE_REF_P (ref) = 1;\n       val = ref;\n     }\n-  \n+\n   return val;\n }\n \n@@ -752,7 +752,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t   the target with the temp (see [dcl.init]).  */\n \tctor = build_user_type_conversion (type, ctor, flags);\n       else\n-\tctor = build_special_member_call (NULL_TREE, \n+\tctor = build_special_member_call (NULL_TREE,\n \t\t\t\t\t  complete_ctor_identifier,\n \t\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n \t\t\t\t\t  type, flags);\n@@ -780,13 +780,13 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n    volatile references we do not do this interpretation, because that would\n    make it impossible to ignore the reference return value from functions. We\n    issue warnings in the confusing cases.\n-   \n+\n    IMPLICIT is tells us the context of an implicit void conversion.  */\n \n tree\n convert_to_void (tree expr, const char *implicit)\n {\n-  if (expr == error_mark_node \n+  if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n   if (!TREE_TYPE (expr))\n@@ -813,20 +813,20 @@ convert_to_void (tree expr, const char *implicit)\n         tree new_op2 = convert_to_void\n \t  (op2, (implicit && !TREE_SIDE_EFFECTS (op1)\n \t\t ? \"third operand of conditional\" : NULL));\n-        \n+\n \texpr = build3 (COND_EXPR, TREE_TYPE (new_op1),\n \t\t       TREE_OPERAND (expr, 0), new_op1, new_op2);\n         break;\n       }\n-    \n+\n     case COMPOUND_EXPR:\n       {\n         /* The second part of a compound expr contains the value.  */\n         tree op1 = TREE_OPERAND (expr,1);\n         tree new_op1 = convert_to_void\n \t  (op1, (implicit && !TREE_NO_WARNING (expr)\n \t\t ? \"right-hand operand of comma\" : NULL));\n-        \n+\n         if (new_op1 != op1)\n \t  {\n \t    tree t = build2 (COMPOUND_EXPR, TREE_TYPE (new_op1),\n@@ -836,23 +836,23 @@ convert_to_void (tree expr, const char *implicit)\n \n         break;\n       }\n-    \n+\n     case NON_LVALUE_EXPR:\n     case NOP_EXPR:\n       /* These have already decayed to rvalue.  */\n       break;\n-    \n+\n     case CALL_EXPR:   /* We have a special meaning for volatile void fn().  */\n       break;\n-    \n+\n     case INDIRECT_REF:\n       {\n         tree type = TREE_TYPE (expr);\n         int is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n                            == REFERENCE_TYPE;\n         int is_volatile = TYPE_VOLATILE (type);\n         int is_complete = COMPLETE_TYPE_P (complete_type (type));\n-        \n+\n         if (is_volatile && !is_complete)\n           warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n                    type, implicit ? implicit : \"void context\");\n@@ -862,16 +862,16 @@ convert_to_void (tree expr, const char *implicit)\n                    implicit ? implicit : \"void context\");\n         if (is_reference || !is_volatile || !is_complete)\n           expr = TREE_OPERAND (expr, 0);\n-      \n+\n         break;\n       }\n-    \n+\n     case VAR_DECL:\n       {\n         /* External variables might be incomplete.  */\n         tree type = TREE_TYPE (expr);\n         int is_complete = COMPLETE_TYPE_P (complete_type (type));\n-        \n+\n         if (TYPE_VOLATILE (type) && !is_complete)\n           warning (0, \"object %qE of incomplete type %qT will not be accessed in %s\",\n                    expr, type, implicit ? implicit : \"void context\");\n@@ -882,7 +882,7 @@ convert_to_void (tree expr, const char *implicit)\n     }\n   {\n     tree probe = expr;\n-  \n+\n     if (TREE_CODE (probe) == ADDR_EXPR)\n       probe = TREE_OPERAND (expr, 0);\n     if (type_unknown_p (probe))\n@@ -898,7 +898,7 @@ convert_to_void (tree expr, const char *implicit)\n       warning (0, \"%s is a reference, not call, to function %qE\",\n \t\t  implicit, expr);\n   }\n-  \n+\n   if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n       if (implicit && warn_unused_value && !TREE_NO_WARNING (expr))\n@@ -907,12 +907,12 @@ convert_to_void (tree expr, const char *implicit)\n \t     been explicitly cast to void, so we must do so here.  */\n \t  if (!TREE_SIDE_EFFECTS (expr))\n \t    warning (0, \"%s has no effect\", implicit);\n-\t  else \n-\t    { \n+\t  else\n+\t    {\n \t      tree e;\n \t      enum tree_code code;\n \t      enum tree_code_class class;\n-\t      \n+\n \t      e = expr;\n \t      /* We might like to warn about (say) \"(int) f()\", as the\n \t\t cast has no effect, but the compiler itself will\n@@ -931,7 +931,7 @@ convert_to_void (tree expr, const char *implicit)\n \t      class = TREE_CODE_CLASS (code);\n \t      if (class == tcc_comparison\n \t\t   || class == tcc_unary\n-\t\t   || (class == tcc_binary \n+\t\t   || (class == tcc_binary\n \t\t       && !(code == MODIFY_EXPR\n \t\t\t    || code == INIT_EXPR\n \t\t\t    || code == PREDECREMENT_EXPR\n@@ -991,7 +991,7 @@ convert_force (tree type, tree expr, int convtype)\n   enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n-    return (fold_if_not_in_template \n+    return (fold_if_not_in_template\n \t    (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n \t\t\t\t   NULL_TREE)));\n \n@@ -1043,11 +1043,11 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n   tree conv = NULL_TREE;\n   tree winner = NULL_TREE;\n \n-  if (expr == null_node \n-      && (desires & WANT_INT) \n+  if (expr == null_node\n+      && (desires & WANT_INT)\n       && !(desires & WANT_NULL))\n     warning (0, \"converting NULL to non-pointer type\");\n-    \n+\n   basetype = TREE_TYPE (expr);\n \n   if (basetype == error_mark_node)\n@@ -1070,7 +1070,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \treturn (desires & WANT_FLOAT) ? expr : NULL_TREE;\n       case POINTER_TYPE:\n \treturn (desires & WANT_POINTER) ? expr : NULL_TREE;\n-\t\n+\n       case FUNCTION_TYPE:\n       case ARRAY_TYPE:\n \treturn (desires & WANT_POINTER) ? decay_conversion (expr)\n@@ -1180,7 +1180,7 @@ type_promotes_to (tree type)\n     }\n   else if (type == float_type_node)\n     type = double_type_node;\n-    \n+\n   return type;\n }\n \n@@ -1193,7 +1193,7 @@ type_promotes_to (tree type)\n    to TYPE.  Return the resulting expression, or error_mark_node if\n    the conversion was impossible.  */\n \n-tree \n+tree\n perform_qualification_conversions (tree type, tree expr)\n {\n   tree expr_type;"}, {"sha": "9f813a586f58d9125e02cbb2f3cf43959f3acd16", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -147,7 +147,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case OVERLOAD:\n-      t = OVL_CURRENT (t);      \n+      t = OVL_CURRENT (t);\n     case VAR_DECL:\n     case PARM_DECL:\n     case CONST_DECL:\n@@ -159,7 +159,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n     case USING_DECL:\n     case TEMPLATE_DECL:\n       t = DECL_NAME (t);\n-      \n+\n     case IDENTIFIER_NODE:\n       if (t == NULL)\n         pp_cxx_identifier (pp, \"<unnamed>\");\n@@ -383,7 +383,7 @@ static void\n pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n-  \n+\n   switch (code)\n     {\n     case AGGR_INIT_EXPR:\n@@ -407,19 +407,19 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n             tree object = code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t)\n               ? TREE_OPERAND (t, 2)\n               : TREE_VALUE (args);\n-            \n+\n             while (TREE_CODE (object) == NOP_EXPR)\n               object = TREE_OPERAND (object, 0);\n \n             if (TREE_CODE (object) == ADDR_EXPR)\n               object = TREE_OPERAND (object, 0);\n-            \n+\n             if (TREE_CODE (TREE_TYPE (object)) != POINTER_TYPE)\n               {\n                 pp_cxx_postfix_expression (pp, object);\n                 pp_cxx_dot (pp);\n               }\n-            else \n+            else\n               {\n                 pp_cxx_postfix_expression (pp, object);\n                 pp_cxx_arrow (pp);\n@@ -587,8 +587,8 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n           pp_right_bracket (pp);\n         }\n       pp_c_cast_expression (pp_c_base (pp), TREE_OPERAND (t, 0));\n-      break;      \n-      \n+      break;\n+\n     default:\n       pp_unsupported_tree (pp, t);\n     }\n@@ -626,7 +626,7 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n     case VEC_DELETE_EXPR:\n       pp_cxx_delete_expression (pp, t);\n       break;\n-      \n+\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       pp_cxx_identifier (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n@@ -855,9 +855,9 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_unqualified_id (pp, t);\n       break;\n \n-#if 0      \n+#if 0\n     case OFFSET_REF:\n-#endif       \n+#endif\n     case SCOPE_REF:\n     case PTRMEM_CST:\n       pp_cxx_qualified_id (pp, t);\n@@ -884,9 +884,9 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n     case STATIC_CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n-#if 0      \n+#if 0\n     case MEMBER_REF:\n-#endif      \n+#endif\n     case EMPTY_CLASS_EXPR:\n     case TYPEID_EXPR:\n     case PSEUDO_DTOR_EXPR:\n@@ -944,7 +944,7 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n \n     default:\n       pp_c_expression (pp_c_base (pp), t);\n-      break;      \n+      break;\n     }\n }\n \n@@ -996,7 +996,7 @@ pp_cxx_decl_specifier_seq (cxx_pretty_printer *pp, tree t)\n       pp_cxx_storage_class_specifier (pp, t);\n       pp_cxx_decl_specifier_seq (pp, TREE_TYPE (t));\n       break;\n-      \n+\n     case TYPE_DECL:\n       pp_cxx_identifier (pp, \"typedef\");\n       pp_cxx_decl_specifier_seq (pp, TREE_TYPE (t));\n@@ -1193,7 +1193,7 @@ static void\n pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n {\n   tree args = TYPE_P (t) ? NULL : FUNCTION_FIRST_USER_PARM (t);\n-  tree types = \n+  tree types =\n     TYPE_P (t) ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n   const bool abstract = args == NULL\n     || pp_c_base (pp)->flags & pp_c_flag_abstract;\n@@ -1269,12 +1269,12 @@ pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n         }\n       pp_cxx_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n-      \n+\n     case FUNCTION_DECL:\n       pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (TREE_TYPE (t)));\n       pp_cxx_id_expression (pp, t);\n       pp_cxx_parameter_declaration_clause (pp, t);\n-      \n+\n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n         {\n           pp_base (pp)->padding = pp_before;\n@@ -1421,7 +1421,7 @@ pp_cxx_direct_abstract_declarator (cxx_pretty_printer *pp, tree t)\n \n     default:\n       pp_c_direct_abstract_declarator (pp_c_base (pp), t);\n-      break;      \n+      break;\n     }\n }\n \n@@ -1545,7 +1545,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n             handler handler-seq(opt)\n \n          handler:\n-         catch ( exception-declaration ) compound-statement \n+         catch ( exception-declaration ) compound-statement\n \n          exception-declaration:\n             type-specifier-seq declarator\n@@ -1812,7 +1812,7 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n   if (code == TEMPLATE_TYPE_PARM || code == TEMPLATE_TEMPLATE_PARM\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     parm = TEMPLATE_TYPE_PARM_INDEX (parm);\n-  \n+\n   pp_cxx_begin_template_argument_list (pp);\n   pp_cxx_identifier (pp, \"template-parameter-\");\n   pp_wide_integer (pp, TEMPLATE_PARM_LEVEL (parm));\n@@ -1887,7 +1887,7 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n       case 1:\n         pp_cxx_template_declaration (pp, t);\n         break;\n-        \n+\n       case 2:\n         pp_cxx_explicit_specialization (pp, t);\n         break;\n@@ -1905,7 +1905,7 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n     case TYPE_DECL:\n       pp_cxx_simple_declaration (pp, t);\n       break;\n-      \n+\n     case FUNCTION_DECL:\n       if (DECL_SAVED_TREE (t))\n         pp_cxx_function_definition (pp, t);"}, {"sha": "560b094f7c4f584615f15e7623010cd0a521ad65", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -31,7 +31,7 @@ typedef enum\n {\n   /* Ask for an qualified-id.  */\n   pp_cxx_flag_default_argument = 1 << pp_c_flag_last_bit\n-  \n+\n } cxx_pretty_printer_flags;\n \n typedef struct"}, {"sha": "1bf834ab517ac016a2199979dc54ed325a7edb34", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -633,14 +633,14 @@ poplevel (int keep, int reverse, int functionbody)\n       else\n \t{\n \t  tree name;\n-\t  \n+\n \t  /* Remove the binding.  */\n \t  decl = link;\n \n \t  if (TREE_CODE (decl) == TREE_LIST)\n \t    decl = TREE_VALUE (decl);\n \t  name = decl;\n-\t  \n+\n \t  if (TREE_CODE (name) == OVERLOAD)\n \t    name = OVL_FUNCTION (name);\n \n@@ -1317,16 +1317,16 @@ duplicate_decls (tree newdecl, tree olddecl)\n   else if (TREE_CODE (newdecl) == NAMESPACE_DECL)\n     {\n       /* In [namespace.alias] we have:\n-\t \n+\n            In a declarative region, a namespace-alias-definition can be\n \t   used to redefine a namespace-alias declared in that declarative\n \t   region to refer only to the namespace to which it already\n \t   refers.\n-\t   \n+\n \t Therefore, if we encounter a second alias directive for the same\n \t alias, we can just ignore the second directive.  */\n       if (DECL_NAMESPACE_ALIAS (newdecl)\n-\t  && (DECL_NAMESPACE_ALIAS (newdecl) \n+\t  && (DECL_NAMESPACE_ALIAS (newdecl)\n \t      == DECL_NAMESPACE_ALIAS (olddecl)))\n \treturn olddecl;\n       /* [namespace.alias]\n@@ -1672,14 +1672,14 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_COMDAT (newdecl) |= DECL_COMDAT (olddecl);\n       DECL_TEMPLATE_INSTANTIATED (newdecl)\n \t|= DECL_TEMPLATE_INSTANTIATED (olddecl);\n-      \n+\n       /* If the OLDDECL is an instantiation and/or specialization,\n \t then the NEWDECL must be too.  But, it may not yet be marked\n \t as such if the caller has created NEWDECL, but has not yet\n \t figured out that it is a redeclaration.  */\n       if (!DECL_USE_TEMPLATE (newdecl))\n \tDECL_USE_TEMPLATE (newdecl) = DECL_USE_TEMPLATE (olddecl);\n-      \n+\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n@@ -1800,7 +1800,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \n   /* Warn about conflicting visibility specifications.  */\n-  if (DECL_VISIBILITY_SPECIFIED (olddecl) \n+  if (DECL_VISIBILITY_SPECIFIED (olddecl)\n       && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n@@ -1820,7 +1820,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n      with that from NEWDECL below.  */\n   if (DECL_LANG_SPECIFIC (olddecl))\n     {\n-      gcc_assert (DECL_LANG_SPECIFIC (olddecl) \n+      gcc_assert (DECL_LANG_SPECIFIC (olddecl)\n \t\t  != DECL_LANG_SPECIFIC (newdecl));\n       ggc_free (DECL_LANG_SPECIFIC (olddecl));\n     }\n@@ -2465,7 +2465,7 @@ typename_compare (const void * k1, const void * k2)\n \n /* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is\n    the type of `T', NAME is the IDENTIFIER_NODE for `t'.\n- \n+\n    Returns the new TYPENAME_TYPE.  */\n \n static GTY ((param_is (union tree_node))) htab_t typename_htab;\n@@ -2484,7 +2484,7 @@ build_typename_type (tree context, tree name, tree fullname,\n     typename_htab = htab_create_ggc (61, &typename_hash,\n \t\t\t\t     &typename_compare, NULL);\n \n-  ti.scope = FROB_CONTEXT (context); \n+  ti.scope = FROB_CONTEXT (context);\n   ti.name = name;\n   ti.template_id = fullname;\n   ti.enum_p = tag_type == enum_type;\n@@ -2506,7 +2506,7 @@ build_typename_type (tree context, tree name, tree fullname,\n       TYPENAME_TYPE_FULLNAME (t) = ti.template_id;\n       TYPENAME_IS_ENUM_P (t) = ti.enum_p;\n       TYPENAME_IS_CLASS_P (t) = ti.class_p;\n-      \n+\n       /* Build the corresponding TYPE_DECL.  */\n       d = build_decl (TYPE_DECL, name, t);\n       TYPE_NAME (TREE_TYPE (d)) = d;\n@@ -2517,7 +2517,7 @@ build_typename_type (tree context, tree name, tree fullname,\n       /* Store it in the hash table.  */\n       *e = t;\n     }\n-      \n+\n   return t;\n }\n \n@@ -2641,7 +2641,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n }\n \n /* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name\n-   can be resolved or an UNBOUND_CLASS_TEMPLATE, unless an error occurs, \n+   can be resolved or an UNBOUND_CLASS_TEMPLATE, unless an error occurs,\n    in which case error_mark_node is returned.\n \n    If PARM_LIST is non-NULL, also make sure that the template parameter\n@@ -3574,15 +3574,15 @@ start_decl (const cp_declarator *declarator,\n \t    cp_decl_specifier_seq *declspecs,\n             int initialized,\n             tree attributes,\n-            tree prefix_attributes, \n+            tree prefix_attributes,\n \t    tree *pushed_scope_p)\n {\n   tree decl;\n   tree type, tem;\n   tree context;\n \n   *pushed_scope_p = NULL_TREE;\n- \n+\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec)\n     {\n@@ -3615,7 +3615,7 @@ start_decl (const cp_declarator *declarator,\n   if (context)\n     {\n       *pushed_scope_p = push_scope (context);\n-  \n+\n       /* We are only interested in class contexts, later.  */\n       if (TREE_CODE (context) == NAMESPACE_DECL)\n \tcontext = NULL_TREE;\n@@ -3719,15 +3719,15 @@ start_decl (const cp_declarator *declarator,\n       /* Do not mark DECL as an explicit specialization if it was not\n \t already marked as an instantiation; a declaration should\n \t never be marked as a specialization unless we know what\n-\t template is being specialized.  */ \n+\t template is being specialized.  */\n       if (DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))\n \t{\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-      \n+\n \t  /* [temp.expl.spec] An explicit specialization of a static data\n \t     member of a template is a definition if the declaration\n \t     includes an initializer; otherwise, it is a declaration.\n-\t      \n+\n \t     We check for processing_specialization so this only applies\n \t     to the new specialization syntax.  */\n \t  if (!DECL_INITIAL (decl)\n@@ -4362,7 +4362,7 @@ reshape_init (tree type, tree *initp)\n     }\n \n   /* If there are more initializers than necessary, issue a\n-     diagnostic.  */  \n+     diagnostic.  */\n   if (*initp)\n     {\n       if (brace_enclosed_p)\n@@ -4771,7 +4771,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  && !DECL_PRETTY_FUNCTION_P (decl)\n \t  && !dependent_type_p (TREE_TYPE (decl)))\n \tmaybe_deduce_size_from_array_init (decl, init);\n-      \n+\n       goto finish_end;\n     }\n \n@@ -4802,7 +4802,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     }\n \n   /* A reference will be modified here, as it is initialized.  */\n-  if (! DECL_EXTERNAL (decl) \n+  if (! DECL_EXTERNAL (decl)\n       && TREE_READONLY (decl)\n       && TREE_CODE (type) == REFERENCE_TYPE)\n     {\n@@ -4843,7 +4843,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t      DECL_INITIALIZED_IN_CLASS_P (decl) = 0;\n \t      init = NULL_TREE;\n \t    }\n-\t  \n+\n \t  /* Handle:\n \n \t     [dcl.init]\n@@ -4933,7 +4933,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t      else if (!TREE_STATIC (decl))\n \t\tinitialize_local_var (decl, init);\n \t    }\n-\t  \n+\n \t  /* If a variable is defined, and then a subsequent\n \t     definition with external linkage is encountered, we will\n \t     get here twice for the same variable.  We want to avoid\n@@ -4943,8 +4943,8 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t     initializer.  It is not legal to redeclare a static data\n \t     member, so this issue does not arise in that case.  */\n \t  if (var_definition_p && TREE_STATIC (decl))\n-\t    expand_static_init (decl, init); \n-\t} \n+\t    expand_static_init (decl, init);\n+\t}\n     }\n \n   /* If a CLEANUP_STMT was created to destroy a temporary bound to a\n@@ -5273,7 +5273,7 @@ expand_static_init (tree decl, tree init)\n \n \t   [stmt.dcl]\n \n-\t   If the initialization exits by throwing an exception, the  \n+\t   If the initialization exits by throwing an exception, the\n \t   initialization is not complete, so it will be tried again\n \t   the next time control enters the declaration.\n \n@@ -5735,7 +5735,7 @@ grokfndecl (tree ctype,\n \t\t\t\t(processing_template_decl\n \t\t\t\t > template_class_depth (ctype))\n \t\t\t\t? current_template_parms\n-\t\t\t\t: NULL_TREE); \n+\t\t\t\t: NULL_TREE);\n \n       if (old_decl && TREE_CODE (old_decl) == TEMPLATE_DECL)\n \t/* Because grokfndecl is always supposed to return a\n@@ -6359,7 +6359,7 @@ check_var_type (tree identifier, tree type)\n \terror (\"variable or field declared void\");\n       type = integer_type_node;\n     }\n-  \n+\n   return type;\n }\n \n@@ -6534,13 +6534,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      error (\"declaration of %qD as non-function\", decl);\n \t\t      return error_mark_node;\n \t\t    }\n-\t\t  else if (!qualifying_scope \n+\t\t  else if (!qualifying_scope\n \t\t\t   && !(current_class_type && at_class_scope_p ()))\n \t\t    {\n \t\t      error (\"declaration of %qD as non-member\", decl);\n \t\t      return error_mark_node;\n \t\t    }\n-\t\t  \n+\n \t\t  type = TREE_OPERAND (decl, 0);\n \t\t  name = IDENTIFIER_POINTER (constructor_name (type));\n \t\t}\n@@ -6899,7 +6899,7 @@ grokdeclarator (const cp_declarator *declarator,\n     error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n            ctor_return_type);\n \n-  if (TREE_CODE (type) == FUNCTION_TYPE \n+  if (TREE_CODE (type) == FUNCTION_TYPE\n       && type_quals != TYPE_UNQUALIFIED)\n     {\n       /* This was an error in C++98 (cv-qualifiers cannot be added to\n@@ -7286,7 +7286,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  || (quals && TREE_CODE (type) == METHOD_TYPE)))\n \t    {\n \t      tree dummy;\n-\t      \n+\n               /* If the type is a FUNCTION_TYPE, pick up the\n                  qualifiers from that function type. No other\n                  qualifiers may be supplied. */\n@@ -7539,7 +7539,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  if (!current_function_decl)\n \t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \t  else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (current_function_decl)\n-\t\t   || (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P \n+\t\t   || (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P\n \t\t       (current_function_decl)))\n \t    /* The TYPE_DECL is \"abstract\" because there will be\n \t       clones of this constructor/destructor, and there will\n@@ -7643,15 +7643,15 @@ grokdeclarator (const cp_declarator *declarator,\n       if (decl_context != TYPENAME)\n         {\n           /* A cv-qualifier-seq shall only be part of the function type\n-             for a non-static member function. [8.3.5/4 dcl.fct] */ \n+             for a non-static member function. [8.3.5/4 dcl.fct] */\n           if (cp_type_quals (type) != TYPE_UNQUALIFIED\n               && (current_class_type == NULL_TREE || staticp) )\n             {\n               error (\"qualified function types cannot be used to declare %s functions\",\n                      (staticp? \"static member\" : \"free\"));\n               type = TYPE_MAIN_VARIANT (type);\n             }\n-          \n+\n           /* The qualifiers on the function type become the qualifiers on\n              the non-static member function. */\n           quals |= cp_type_quals (type);\n@@ -7852,11 +7852,11 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t    /* Check that the name used for a destructor makes sense.  */\n \t    if (sfk == sfk_destructor\n-\t\t&& !same_type_p (TREE_OPERAND \n+\t\t&& !same_type_p (TREE_OPERAND\n \t\t\t\t (id_declarator->u.id.unqualified_name, 0),\n \t\t\t\t ctype))\n \t      {\n-\t\terror (\"declaration of %qD as member of %qT\", \n+\t\terror (\"declaration of %qD as member of %qT\",\n \t\t       id_declarator->u.id.unqualified_name,\n \t\t       ctype);\n \t\treturn error_mark_node;\n@@ -7922,8 +7922,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       unqualified_id,\n \t\t\t       virtualp, flags, quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, 1, 0, sfk,\n-\t\t\t       funcdef_flag, template_count, in_namespace, \n-\t\t\t       attrlist); \n+\t\t\t       funcdef_flag, template_count, in_namespace,\n+\t\t\t       attrlist);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t  }\n@@ -8476,7 +8476,7 @@ copy_fn_p (tree d)\n \n   gcc_assert (DECL_FUNCTION_MEMBER_P (d));\n \n-  if (DECL_TEMPLATE_INFO (d) \n+  if (DECL_TEMPLATE_INFO (d)\n       && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (d)))\n     /* Instantiations of template member functions are never copy\n        functions.  Note that member functions of templated classes are\n@@ -8767,7 +8767,7 @@ grok_op_properties (tree decl, bool complain)\n \treturn;\n \n       /* Warn about conversion operators that will never be used.  */\n-      if (IDENTIFIER_TYPENAME_P (name) \n+      if (IDENTIFIER_TYPENAME_P (name)\n \t  && ! DECL_TEMPLATE_INFO (decl)\n \t  && warn_conversion\n \t  /* Warn only declaring the function; there is no need to\n@@ -9425,7 +9425,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  CLASSTYPE_REPEATED_BASE_P (ref)\n \t    |= CLASSTYPE_REPEATED_BASE_P (basetype);\n \t}\n-      \n+\n       /* We must do this test after we've seen through a typedef\n \t type.  */\n       if (TYPE_MARKED_P (basetype))\n@@ -9688,7 +9688,7 @@ finish_enum (tree enumtype)\n \n       /* Do not clobber shared ints.  */\n       value = copy_node (value);\n-      \n+\n       TREE_TYPE (value) = enumtype;\n       DECL_INITIAL (decl) = value;\n       TREE_VALUE (values) = value;\n@@ -10149,7 +10149,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       DECL_NOT_REALLY_EXTERN (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n       /* If this function is in an interface implemented in this file,\n-\t make sure that the backend knows to emit this function \n+\t make sure that the backend knows to emit this function\n \t here.  */\n       if (!DECL_EXTERNAL (decl1))\n \tmark_needed (decl1);"}, {"sha": "a05fbef2ac664cc6c4b0657a9c09bff0b695030d", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -31,6 +31,6 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator (const cp_declarator *, \n-\t\t\t    const cp_decl_specifier_seq *, \n+extern tree grokdeclarator (const cp_declarator *,\n+\t\t\t    const cp_decl_specifier_seq *,\n \t\t\t    enum decl_context, int, tree*);"}, {"sha": "c8f09f91e34a32830f7a303035f56ac1645c05fe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -256,7 +256,7 @@ maybe_retrofit_in_chrg (tree fn)\n    QUALS are the qualifiers for the this pointer.  */\n \n void\n-grokclassfn (tree ctype, tree function, enum overload_flags flags, \n+grokclassfn (tree ctype, tree function, enum overload_flags flags,\n \t     cp_cv_quals quals)\n {\n   tree fn_name = DECL_NAME (function);\n@@ -355,9 +355,9 @@ grok_array_decl (tree array_expr, tree index_exp)\n       else\n \tp2 = build_expr_type_conversion (WANT_POINTER, index_exp, false);\n \n-      i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, \n+      i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr,\n \t\t\t\t       false);\n-      i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, \n+      i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp,\n \t\t\t\t       false);\n \n       if ((p1 && i2) && (i1 && p2))\n@@ -447,7 +447,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n     return build1 (NOP_EXPR, void_type_node, t);\n \n   if (doing_vec)\n-    return build_vec_delete (t, /*maxindex=*/NULL_TREE, \n+    return build_vec_delete (t, /*maxindex=*/NULL_TREE,\n \t\t\t     sfk_deleting_destructor,\n \t\t\t     use_global_delete);\n   else\n@@ -472,26 +472,26 @@ check_member_template (tree tmpl)\n     {\n       if (current_function_decl)\n \t/* 14.5.2.2 [temp.mem]\n-\t   \n+\n \t   A local class shall not have member templates.  */\n \terror (\"invalid declaration of member template %q#D in local class\",\n                decl);\n-      \n+\n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n \t{\n \t  /* 14.5.2.3 [temp.mem]\n \n \t     A member function template shall not be virtual.  */\n-\t  error \n+\t  error\n \t    (\"invalid use of %<virtual%> in template declaration of %q#D\",\n \t     decl);\n \t  DECL_VIRTUAL_P (decl) = 0;\n \t}\n \n       /* The debug-information generating code doesn't know what to do\n-\t with member templates.  */ \n+\t with member templates.  */\n       DECL_IGNORED_P (tmpl) = 1;\n-    } \n+    }\n   else\n     error (\"template declaration of %q#D\", decl);\n }\n@@ -552,7 +552,7 @@ check_java_method (tree method)\n     arg_types = TREE_CHAIN (arg_types);\n   if (DECL_HAS_VTT_PARM_P (method))\n     arg_types = TREE_CHAIN (arg_types);\n-  \n+\n   for (; arg_types != NULL_TREE; arg_types = TREE_CHAIN (arg_types))\n     {\n       tree type = TREE_VALUE (arg_types);\n@@ -569,7 +569,7 @@ check_java_method (tree method)\n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n    TEMPLATE_PARMS is used to specify the template parameters of a member\n-   template passed as FUNCTION_DECL. If the member template is passed as a \n+   template passed as FUNCTION_DECL. If the member template is passed as a\n    TEMPLATE_DECL, it can be NULL since the parameters can be extracted\n    from the declaration. If the function is not a function template, it\n    must be NULL.\n@@ -581,18 +581,18 @@ check_classfn (tree ctype, tree function, tree template_parms)\n {\n   int ix;\n   bool is_template;\n-  \n+\n   if (DECL_USE_TEMPLATE (function)\n       && !(TREE_CODE (function) == TEMPLATE_DECL\n \t   && DECL_TEMPLATE_SPECIALIZATION (function))\n       && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (function)))\n     /* Since this is a specialization of a member template,\n        we're not going to find the declaration in the class.\n        For example, in:\n-       \n+\n          struct S { template <typename T> void f(T); };\n          template <> void S::f(int);\n-       \n+\n        we're not going to find `S::f(int)', but there's no\n        reason we should, either.  We let our callers know we didn't\n        find the method, but we don't complain.  */\n@@ -602,8 +602,8 @@ check_classfn (tree ctype, tree function, tree template_parms)\n      either were not passed, or they are the same of DECL_TEMPLATE_PARMS.  */\n   if (TREE_CODE (function) == TEMPLATE_DECL)\n     {\n-      gcc_assert (!template_parms \n-\t\t  || comp_template_parms (template_parms, \n+      gcc_assert (!template_parms\n+\t\t  || comp_template_parms (template_parms,\n \t\t\t\t\t  DECL_TEMPLATE_PARMS (function)));\n       template_parms = DECL_TEMPLATE_PARMS (function);\n     }\n@@ -619,22 +619,22 @@ check_classfn (tree ctype, tree function, tree template_parms)\n       bool is_conv_op;\n       tree pushed_scope;\n       const char *format = NULL;\n-      \n+\n       pushed_scope = push_scope (ctype);\n       for (fndecls = VEC_index (tree, methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n \t  tree p1, p2;\n-\t  \n+\n \t  fndecl = OVL_CURRENT (fndecls);\n \t  p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n \t  p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \n \t  /* We cannot simply call decls_match because this doesn't\n \t     work for static member functions that are pretending to\n \t     be methods, and because the name may have been changed by\n-\t     asm(\"new_name\").  */ \n-\t      \n+\t     asm(\"new_name\").  */\n+\n \t   /* Get rid of the this parameter on functions that become\n \t      static.  */\n \t  if (DECL_STATIC_FUNCTION_P (fndecl)\n@@ -645,17 +645,17 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t     declaration.  */\n \t  if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n \t    continue;\n-\t      \n+\n \t  if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t   TREE_TYPE (TREE_TYPE (fndecl)))\n \t      && compparms (p1, p2)\n \t      && (!is_template\n-\t\t  || comp_template_parms (template_parms, \n+\t\t  || comp_template_parms (template_parms,\n \t\t\t\t\t  DECL_TEMPLATE_PARMS (fndecl)))\n \t      && (DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t  == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n \t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n-\t\t  || (DECL_TI_TEMPLATE (function) \n+\t\t  || (DECL_TI_TEMPLATE (function)\n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n \t    break;\n \t}\n@@ -767,7 +767,7 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n   if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n     {\n       static int explained = 0;\n-\t  \n+\n       error (\"initializer invalid for static member with constructor\");\n       if (!explained)\n         {\n@@ -805,8 +805,8 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (const cp_declarator *declarator, \n-\t   cp_decl_specifier_seq *declspecs, \n+grokfield (const cp_declarator *declarator,\n+\t   cp_decl_specifier_seq *declspecs,\n \t   tree init, tree asmspec_tree,\n            tree attrlist)\n {\n@@ -816,7 +816,7 @@ grokfield (const cp_declarator *declarator,\n \n   if (!declspecs->any_specifiers_p\n       && declarator->kind == cdk_id\n-      && declarator->u.id.qualifying_scope \n+      && declarator->u.id.qualifying_scope\n       && TREE_CODE (declarator->u.id.unqualified_name) == IDENTIFIER_NODE)\n     /* Access declaration */\n     return do_class_using_decl (declarator->u.id.qualifying_scope,\n@@ -919,7 +919,7 @@ grokfield (const cp_declarator *declarator,\n \t\tinit = digest_init (TREE_TYPE (value), init, (tree *)0);\n \t      else\n \t\tinit = integral_constant_value (init);\n-\t      \n+\n \t      if (init != error_mark_node && ! TREE_CONSTANT (init))\n \t\t{\n \t\t  /* We can allow references to things that are effectively\n@@ -951,7 +951,7 @@ grokfield (const cp_declarator *declarator,\n   switch (TREE_CODE (value))\n     {\n     case VAR_DECL:\n-      finish_static_data_member_decl (value, init, asmspec_tree, \n+      finish_static_data_member_decl (value, init, asmspec_tree,\n \t\t\t\t      flags);\n       return value;\n \n@@ -970,7 +970,7 @@ grokfield (const cp_declarator *declarator,\n \tset_user_assembler_name (value, asmspec);\n       if (!DECL_FRIEND_P (value))\n \tgrok_special_member_properties (value);\n-      \n+\n       cp_finish_decl (value, init, asmspec_tree, flags);\n \n       /* Pass friends back this way.  */\n@@ -979,7 +979,7 @@ grokfield (const cp_declarator *declarator,\n \n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n-      \n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -990,7 +990,7 @@ grokfield (const cp_declarator *declarator,\n    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */\n \n tree\n-grokbitfield (const cp_declarator *declarator, \n+grokbitfield (const cp_declarator *declarator,\n \t      cp_decl_specifier_seq *declspecs, tree width)\n {\n   tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL);\n@@ -1074,8 +1074,8 @@ build_anon_union_vars (tree type, tree object)\n   if (TREE_CODE (type) != UNION_TYPE)\n     error (\"anonymous struct not inside named type\");\n \n-  for (field = TYPE_FIELDS (type); \n-       field != NULL_TREE; \n+  for (field = TYPE_FIELDS (type);\n+       field != NULL_TREE;\n        field = TREE_CHAIN (field))\n     {\n       tree decl;\n@@ -1106,7 +1106,7 @@ build_anon_union_vars (tree type, tree object)\n       if (DECL_NAME (field))\n \t{\n \t  decl = build_decl (ALIAS_DECL, DECL_NAME (field), TREE_TYPE (field));\n-\t  DECL_INITIAL (decl) = ref;\t    \n+\t  DECL_INITIAL (decl) = ref;\n \t  TREE_PUBLIC (decl) = 0;\n \t  TREE_STATIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 1;\n@@ -1143,7 +1143,7 @@ finish_anon_union (tree anon_union_decl)\n \n   /* The VAR_DECL's context is the same as the TYPE's context.  */\n   DECL_CONTEXT (anon_union_decl) = DECL_CONTEXT (TYPE_NAME (type));\n-  \n+\n   if (TYPE_FIELDS (type) == NULL_TREE)\n     return;\n \n@@ -1188,7 +1188,7 @@ coerce_new_type (tree type)\n   tree args = TYPE_ARG_TYPES (type);\n \n   gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n-  \n+\n   if (!same_type_p (TREE_TYPE (type), ptr_type_node))\n     {\n       e = 1;\n@@ -1224,7 +1224,7 @@ coerce_delete_type (tree type)\n {\n   int e = 0;\n   tree args = TYPE_ARG_TYPES (type);\n-  \n+\n   gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n \n   if (!same_type_p (TREE_TYPE (type), void_type_node))\n@@ -1282,7 +1282,7 @@ mark_vtable_entries (tree decl)\n \t we output the vtables that contain them.  With vcall offsets,\n \t we know all the thunks we'll need when we emit a virtual\n \t function, so we emit the thunks there instead.  */\n-      if (DECL_THUNK_P (fn)) \n+      if (DECL_THUNK_P (fn))\n \tuse_thunk (fn, /*emit_p=*/0);\n       mark_used (fn);\n     }\n@@ -1296,17 +1296,17 @@ comdat_linkage (tree decl)\n {\n   if (flag_weak)\n     make_decl_one_only (decl);\n-  else if (TREE_CODE (decl) == FUNCTION_DECL \n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n \t   || (TREE_CODE (decl) == VAR_DECL && DECL_ARTIFICIAL (decl)))\n     /* We can just emit function and compiler-generated variables\n        statically; having multiple copies is (for the most part) only\n-       a waste of space.  \n+       a waste of space.\n \n        There are two correctness issues, however: the address of a\n        template instantiation with external linkage should be the\n        same, independent of what translation unit asks for the\n        address, and this will not hold when we emit multiple copies of\n-       the function.  However, there's little else we can do.  \n+       the function.  However, there's little else we can do.\n \n        Also, by default, the typeinfo implementation assumes that\n        there will be only one copy of the string used as the name for\n@@ -1342,8 +1342,8 @@ comdat_linkage (tree decl)\n \n /* For win32 we also want to put explicit instantiations in\n    linkonce sections, so that they will be merged with implicit\n-   instantiations; otherwise we get duplicate symbol errors.  \n-   For Darwin we do not want explicit instantiations to be \n+   instantiations; otherwise we get duplicate symbol errors.\n+   For Darwin we do not want explicit instantiations to be\n    linkonce.  */\n \n void\n@@ -1490,7 +1490,7 @@ decl_needed_p (tree decl)\n     return true;\n   /* If this entity was used, let the back-end see it; it will decide\n      whether or not to emit it into the object file.  */\n-  if (TREE_USED (decl) \n+  if (TREE_USED (decl)\n       || (DECL_ASSEMBLER_NAME_SET_P (decl)\n \t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n       return true;\n@@ -1536,7 +1536,7 @@ maybe_emit_vtables (tree ctype)\n       /* If the references to this class' vtables are optimized away,\n \t still emit the appropriate debugging information.  See\n \t dfs_debug_mark.  */\n-      if (DECL_COMDAT (primary_vtbl) \n+      if (DECL_COMDAT (primary_vtbl)\n \t  && CLASSTYPE_DEBUG_REQUESTED (ctype))\n \tnote_debug_info_needed (ctype);\n       return false;\n@@ -1552,7 +1552,7 @@ maybe_emit_vtables (tree ctype)\n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n \t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl));\n-\t  \n+\n \t  /* It had better be all done at compile-time.  */\n \t  gcc_assert (!expr);\n \t}\n@@ -1778,7 +1778,7 @@ import_export_decl (tree decl)\n       else if (CLASSTYPE_INTERFACE_KNOWN (class_type))\n \t{\n \t  /* CLASS_TYPE is being exported from this translation unit,\n-\t     so DECL should be defined here.  */ \n+\t     so DECL should be defined here.  */\n \t  if (!flag_weak && CLASSTYPE_EXPLICIT_INSTANTIATION (class_type))\n \t    /* If a class is declared in a header with the \"extern\n \t       template\" extension, then it will not be instantiated,\n@@ -1829,7 +1829,7 @@ import_export_decl (tree decl)\n \t\t wherever it is used.  */\n \t      && flag_rtti)\n \t    import_p = true;\n-\t  else \n+\t  else\n \t    {\n \t      if (CLASSTYPE_INTERFACE_KNOWN (type)\n \t\t  && !CLASSTYPE_INTERFACE_ONLY (type))\n@@ -1856,7 +1856,7 @@ import_export_decl (tree decl)\n \t data member.  */\n       if (flag_implicit_templates\n \t  || (flag_implicit_inline_templates\n-\t      && TREE_CODE (decl) == FUNCTION_DECL \n+\t      && TREE_CODE (decl) == FUNCTION_DECL\n \t      && DECL_DECLARED_INLINE_P (decl)))\n \tcomdat_p = true;\n       else\n@@ -1874,7 +1874,7 @@ import_export_decl (tree decl)\n \t    {\n \t      DECL_NOT_REALLY_EXTERN (decl)\n \t\t= ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n-\t\t     || (DECL_DECLARED_INLINE_P (decl) \n+\t\t     || (DECL_DECLARED_INLINE_P (decl)\n \t\t\t && ! flag_implement_inlines\n \t\t\t && !DECL_VINDEX (decl)));\n \n@@ -1922,7 +1922,7 @@ import_export_decl (tree decl)\n       && DECL_VISIBILITY_SPECIFIED (decl)\n       && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n     targetm.cxx.determine_class_data_visibility (decl);\n-  \n+\n   DECL_INTERFACE_KNOWN (decl) = 1;\n }\n \n@@ -1976,15 +1976,15 @@ get_guard (tree decl)\n \t as an integer counter.  */\n       guard_type = targetm.cxx.guard_type ();\n       guard = build_decl (VAR_DECL, sname, guard_type);\n-      \n+\n       /* The guard should have the same linkage as what it guards.  */\n       TREE_PUBLIC (guard) = TREE_PUBLIC (decl);\n       TREE_STATIC (guard) = TREE_STATIC (decl);\n       DECL_COMMON (guard) = DECL_COMMON (decl);\n       DECL_ONE_ONLY (guard) = DECL_ONE_ONLY (decl);\n       if (TREE_PUBLIC (decl))\n         DECL_WEAK (guard) = DECL_WEAK (decl);\n-      \n+\n       DECL_ARTIFICIAL (guard) = 1;\n       DECL_IGNORED_P (guard) = 1;\n       TREE_USED (guard) = 1;\n@@ -2003,11 +2003,11 @@ get_guard_bits (tree guard)\n     {\n       /* We only set the first byte of the guard, in order to leave room\n \t for a mutex in the high-order bits.  */\n-      guard = build1 (ADDR_EXPR, \n+      guard = build1 (ADDR_EXPR,\n \t\t      build_pointer_type (TREE_TYPE (guard)),\n \t\t      guard);\n-      guard = build1 (NOP_EXPR, \n-\t\t      build_pointer_type (char_type_node), \n+      guard = build1 (NOP_EXPR,\n+\t\t      build_pointer_type (char_type_node),\n \t\t      guard);\n       guard = build1 (INDIRECT_REF, char_type_node, guard);\n     }\n@@ -2084,7 +2084,7 @@ start_objects (int method_type, int initp)\n   else\n     sprintf (type, \"%c\", method_type);\n \n-  fndecl = build_lang_decl (FUNCTION_DECL, \n+  fndecl = build_lang_decl (FUNCTION_DECL,\n \t\t\t    get_file_function_name_long (type),\n \t\t\t    build_function_type (void_type_node,\n \t\t\t\t\t\t void_list_node));\n@@ -2181,7 +2181,7 @@ static splay_tree priority_info_map;\n    nonzero, it performs initializations.  Otherwise, it performs\n    destructions.  It only performs those initializations or\n    destructions with the indicated __PRIORITY.  The generated function\n-   returns no value.  \n+   returns no value.\n \n    It is assumed that this function will only be called once per\n    translation unit.  */\n@@ -2205,7 +2205,7 @@ start_static_storage_duration_function (unsigned count)\n   type = build_function_type (void_type_node, parm_types);\n \n   /* Create the FUNCTION_DECL itself.  */\n-  ssdf_decl = build_lang_decl (FUNCTION_DECL, \n+  ssdf_decl = build_lang_decl (FUNCTION_DECL,\n \t\t\t       get_identifier (id),\n \t\t\t       type);\n   TREE_PUBLIC (ssdf_decl) = 0;\n@@ -2253,7 +2253,7 @@ start_static_storage_duration_function (unsigned count)\n      function as:\n \n        static void __ssdf (int __initialize_p, init __priority_p);\n-       \n+\n      It is static because we only need to call this function from the\n      various constructor and destructor functions for this module.  */\n   start_preparsed_function (ssdf_decl,\n@@ -2293,7 +2293,7 @@ get_priority_info (int priority)\n   priority_info pi;\n   splay_tree_node n;\n \n-  n = splay_tree_lookup (priority_info_map, \n+  n = splay_tree_lookup (priority_info_map,\n \t\t\t (splay_tree_key) priority);\n   if (!n)\n     {\n@@ -2353,7 +2353,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n        the conversion functions, or the destructor called to\n        create and destroy a static data member is performed as\n        if these calls appeared in the scope of the member's\n-       class.  \n+       class.\n \n      we pretend we are in a static member function of the class of\n      which the DECL is a member.  */\n@@ -2362,7 +2362,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n       DECL_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n       DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n     }\n-  \n+\n   /* Conditionalize this initialization on being in the right priority\n      and being initializing/finalizing appropriately.  */\n   guard_if_stmt = begin_if_stmt ();\n@@ -2381,7 +2381,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n      might be initialized in more than one place.  (For example, a\n      static data member of a template, when the data member requires\n      construction.)  */\n-  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n+  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n \t\t\t     || DECL_ONE_ONLY (decl)\n \t\t\t     || DECL_WEAK (decl)))\n     {\n@@ -2406,14 +2406,14 @@ start_static_initialization_or_destruction (tree decl, int initp)\n \t destructions only if the GUARD is one, i.e., if we are the\n \t last to destroy the variable.  */\n       else if (initp)\n-\tguard_cond \n+\tguard_cond\n \t  = cp_build_binary_op (EQ_EXPR,\n \t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n \t\t\t\t\t\tguard,\n \t\t\t\t\t\t/*noconvert=*/1),\n \t\t\t\tinteger_one_node);\n       else\n-\tguard_cond \n+\tguard_cond\n \t  = cp_build_binary_op (EQ_EXPR,\n \t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n \t\t\t\t\t\tguard,\n@@ -2540,7 +2540,7 @@ prune_vars_needing_no_initialization (tree *vars)\n \n       /* Also, if the initializer already contains errors, we can bail\n \t out now.  */\n-      if (init && TREE_CODE (init) == TREE_LIST \n+      if (init && TREE_CODE (init) == TREE_LIST\n \t  && value_member (error_mark_node, init))\n \t{\n \t  var = &TREE_CHAIN (t);\n@@ -2596,7 +2596,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n #else\n   locus->line++;\n #endif\n-  \n+\n   /* We use `I' to indicate initialization and `D' to indicate\n      destruction.  */\n   function_key = constructor_p ? 'I' : 'D';\n@@ -2616,7 +2616,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \n   /* Call the static storage duration function with appropriate\n      arguments.  */\n-  for (i = 0; VEC_iterate (tree, ssdf_decls, i, fndecl); ++i) \n+  for (i = 0; VEC_iterate (tree, ssdf_decls, i, fndecl); ++i)\n     {\n       /* Calls to pure or const functions will expand to nothing.  */\n       if (! (flags_from_decl_or_type (fndecl) & (ECF_CONST | ECF_PURE)))\n@@ -2625,7 +2625,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \t    body = start_objects (function_key, priority);\n \n \t  arguments = tree_cons (NULL_TREE,\n-\t\t\t\t build_int_cst (NULL_TREE, priority), \n+\t\t\t\t build_int_cst (NULL_TREE, priority),\n \t\t\t\t NULL_TREE);\n \t  arguments = tree_cons (NULL_TREE,\n \t\t\t\t build_int_cst (NULL_TREE, constructor_p),\n@@ -2641,7 +2641,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n     {\n       tree fns;\n \n-      for (fns = constructor_p ? static_ctors : static_dtors; \n+      for (fns = constructor_p ? static_ctors : static_dtors;\n \t   fns;\n \t   fns = TREE_CHAIN (fns))\n \t{\n@@ -2718,7 +2718,7 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t       vtbl = TREE_CHAIN (vtbl))\n \t    mark_decl_referenced (vtbl);\n \t}\n-      else if (DECL_CONTEXT (t) \n+      else if (DECL_CONTEXT (t)\n \t       && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)\n \t/* If we need a static variable in a function, then we\n \t   need the containing function.  */\n@@ -2818,7 +2818,7 @@ cp_finish_file (void)\n          static storage duration.  (Local objects with static storage\n \t duration are initialized when their scope is first entered,\n \t and are cleaned up via atexit.)\n-       o Virtual function tables.  \n+       o Virtual function tables.\n \n      All of these may cause others to be needed.  For example,\n      instantiating one function may cause another to be needed, and\n@@ -2829,7 +2829,7 @@ cp_finish_file (void)\n \n   emit_support_tinfos ();\n \n-  do \n+  do\n     {\n       tree t;\n       tree decl;\n@@ -2853,12 +2853,12 @@ cp_finish_file (void)\n   \t  reconsider = true;\n  \t  keyed_classes = TREE_CHAIN (keyed_classes);\n  \t}\n- \n+\n       t = keyed_classes;\n       if (t != NULL_TREE)\n  \t{\n  \t  tree next = TREE_CHAIN (t);\n- \n+\n  \t  while (next)\n  \t    {\n  \t      if (maybe_emit_vtables (TREE_VALUE (next)))\n@@ -2868,7 +2868,7 @@ cp_finish_file (void)\n  \t\t}\n  \t      else\n  \t\tt = next;\n- \n+\n  \t      next = TREE_CHAIN (t);\n  \t    }\n  \t}\n@@ -2950,7 +2950,7 @@ cp_finish_file (void)\n \t  locus.line++;\n #endif\n \t}\n-      \n+\n       /* Go through the set of inline functions whose bodies have not\n \t been emitted yet.  If out-of-line copies of these functions\n \t are required, emit them.  */\n@@ -3023,7 +3023,7 @@ cp_finish_file (void)\n \treconsider = true;\n \n       /* Static data members are just like namespace-scope globals.  */\n-      for (i = 0; VEC_iterate (tree, pending_statics, i, decl); ++i) \n+      for (i = 0; VEC_iterate (tree, pending_statics, i, decl); ++i)\n \t{\n \t  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl))\n \t    continue;\n@@ -3039,7 +3039,7 @@ cp_finish_file (void)\n \treconsider = true;\n \n       retries++;\n-    } \n+    }\n   while (reconsider);\n \n   /* All used inline functions must have a definition at this point.  */\n@@ -3068,19 +3068,19 @@ cp_finish_file (void)\n \t  TREE_PUBLIC (decl) = 1;\n \t}\n     }\n-  \n+\n   /* We give C linkage to static constructors and destructors.  */\n   push_lang_context (lang_name_c);\n \n   /* Generate initialization and destruction functions for all\n      priorities for which they are required.  */\n   if (priority_info_map)\n-    splay_tree_foreach (priority_info_map, \n+    splay_tree_foreach (priority_info_map,\n \t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n \t\t\t/*data=*/&locus);\n   else\n     {\n-      \n+\n       if (static_ctors)\n \tgenerate_ctor_or_dtor_function (/*constructor_p=*/true,\n \t\t\t\t\tDEFAULT_INIT_PRIORITY, &locus);\n@@ -3127,7 +3127,7 @@ cp_finish_file (void)\n \tdump_end (TDI_tu, stream);\n       }\n   }\n-  \n+\n   timevar_pop (TV_VARCONST);\n \n   if (flag_detailed_statistics)\n@@ -3198,7 +3198,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n     return build_min_non_dep (CALL_EXPR, expr, orig_fn, orig_args, NULL_TREE);\n   return expr;\n }\n-  \n+\n \n void\n check_default_args (tree x)\n@@ -3232,23 +3232,23 @@ mark_used (tree decl)\n     {\n       if (DECL_DEFERRED_FN (decl))\n \treturn;\n-      \n+\n       /* Remember the current location for a function we will end up\n          synthesizing.  Then we can inform the user where it was\n          required in the case of error.  */\n       if (DECL_ARTIFICIAL (decl) && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n \t  && !DECL_THUNK_P (decl))\n \tDECL_SOURCE_LOCATION (decl) = input_location;\n-      \n+\n       note_vague_linkage_fn (decl);\n     }\n-  \n+\n   assemble_external (decl);\n \n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n-      && DECL_ARTIFICIAL (decl) \n+      && DECL_ARTIFICIAL (decl)\n       && !DECL_THUNK_P (decl)\n       && ! DECL_INITIAL (decl)\n       /* Kludge: don't synthesize for default args.  Unfortunately this\n@@ -3270,8 +3270,8 @@ mark_used (tree decl)\n   if ((DECL_NON_THUNK_FUNCTION_P (decl) || TREE_CODE (decl) == VAR_DECL)\n       && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n       && (!DECL_EXPLICIT_INSTANTIATION (decl)\n-\t  || (TREE_CODE (decl) == FUNCTION_DECL \n-\t      && DECL_INLINE (DECL_TEMPLATE_RESULT \n+\t  || (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && DECL_INLINE (DECL_TEMPLATE_RESULT\n \t\t\t      (template_for_substitution (decl))))))\n     /* We put off instantiating functions in order to improve compile\n        times.  Maintaining a stack of active functions is expensive,"}, {"sha": "8e7ac443795b370420248e4f76d2a28d82f78635", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -186,7 +186,7 @@ dump_op (dump_info_p di, tree t)\n       dump_string (di, \"subs\");\n       break;\n     case POSTINCREMENT_EXPR:\n-      dump_string (di, \"postinc\");     \n+      dump_string (di, \"postinc\");\n       break;\n     case POSTDECREMENT_EXPR:\n       dump_string (di, \"postdec\");\n@@ -257,7 +257,7 @@ cp_dump_tree (void* dump_info, tree t)\n \t  dump_child (\"bfld\", TYPE_CONTEXT (t));\n \t  return true;\n \t}\n-      \n+\n       if (! IS_AGGR_TYPE (t))\n \tbreak;\n \n@@ -270,12 +270,12 @@ cp_dump_tree (void* dump_info, tree t)\n \t  int i;\n \t  tree binfo;\n \t  tree base_binfo;\n-\t  \n+\n \t  for (binfo = TYPE_BINFO (t), i = 0;\n \t       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n \t    {\n \t      dump_child (\"base\", BINFO_TYPE (base_binfo));\n-\t      if (BINFO_VIRTUAL_P (base_binfo)) \n+\t      if (BINFO_VIRTUAL_P (base_binfo))\n \t\tdump_string (di, \"virtual\");\n \t      dump_access (di, base_binfo);\n \t    }\n@@ -293,7 +293,7 @@ cp_dump_tree (void* dump_info, tree t)\n         dump_access (di, t);\n       if (TREE_STATIC (t) && !TREE_PUBLIC (t))\n         dump_string (di, \"static\");\n-      break; \n+      break;\n \n     case FUNCTION_DECL:\n       if (!DECL_THUNK_P (t))\n@@ -302,7 +302,7 @@ cp_dump_tree (void* dump_info, tree t)\n \t    dump_string (di, \"operator\");\n             dump_op (di, t);\n           }\n-\t  if (DECL_FUNCTION_MEMBER_P (t)) \n+\t  if (DECL_FUNCTION_MEMBER_P (t))\n \t    {\n \t      dump_string (di, \"member\");\n \t      dump_access (di, t);\n@@ -327,7 +327,7 @@ cp_dump_tree (void* dump_info, tree t)\n       else\n \t{\n \t  tree virt = THUNK_VIRTUAL_OFFSET (t);\n-\t  \n+\n \t  dump_string (di, \"thunk\");\n \t  if (DECL_THIS_THUNK_P (t))\n \t    dump_string (di, \"this adjusting\");\n@@ -393,7 +393,7 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"args\", TREE_OPERAND (t, 1));\n       dump_child (\"decl\", TREE_OPERAND (t, 2));\n       break;\n-      \n+\n     case HANDLER:\n       dump_stmt (di, t);\n       dump_child (\"parm\", HANDLER_PARMS (t));"}, {"sha": "5ed081833af3034f7d1cea238fd82713cc4f497e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -348,8 +348,8 @@ dump_type (tree t, int flags)\n     }\n     case TYPENAME_TYPE:\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      pp_cxx_identifier (cxx_pp, \n-\t\t\t TYPENAME_IS_ENUM_P (t) ? \"enum\" \n+      pp_cxx_identifier (cxx_pp,\n+\t\t\t TYPENAME_IS_ENUM_P (t) ? \"enum\"\n \t\t\t : TYPENAME_IS_CLASS_P (t) ? \"class\"\n \t\t\t : \"typename\");\n       dump_typename (t, flags);\n@@ -481,7 +481,7 @@ dump_aggr_type (tree t, int flags)\n    Arrays must also do this for DECL nodes, like int a[], and for things like\n    int *[]&.  */\n \n-static void \n+static void\n dump_type_prefix (tree t, int flags)\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n@@ -722,7 +722,7 @@ dump_decl (tree t, int flags)\n \t      && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t    /* Say `class T' not just `T'.  */\n \t    pp_cxx_identifier (cxx_pp, \"class\");\n-\t  \n+\n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n \t}\n@@ -826,7 +826,7 @@ dump_decl (tree t, int flags)\n \t  dump_decl (DECL_NAME (t), flags);\n \t  break;\n \t}\n-      \n+\n       /* If there's only one function, just treat it like an ordinary\n \t FUNCTION_DECL.  */\n       t = OVL_CURRENT (t);\n@@ -848,7 +848,7 @@ dump_decl (tree t, int flags)\n     case TEMPLATE_ID_EXPR:\n       {\n \ttree name = TREE_OPERAND (t, 0);\n-\t\n+\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n \tdump_decl (name, flags);\n@@ -1214,7 +1214,7 @@ dump_template_parms (tree info, int primary, int flags)\n \n       if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n \targs = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n-      \n+\n       len = TREE_VEC_LENGTH (args);\n \n       for (ix = 0; ix != len; ix++)\n@@ -1223,7 +1223,7 @@ dump_template_parms (tree info, int primary, int flags)\n \n           if (ix)\n             pp_separate_with_comma (cxx_pp);\n-          \n+\n           if (!arg)\n             pp_identifier (cxx_pp, \"<template parameter error>\");\n           else\n@@ -1273,7 +1273,7 @@ dump_expr (tree t, int flags)\n {\n   if (t == 0)\n     return;\n-  \n+\n   switch (TREE_CODE (t))\n     {\n     case VAR_DECL:\n@@ -1295,7 +1295,7 @@ dump_expr (tree t, int flags)\n       if (PAREN_STRING_LITERAL_P (t))\n \tpp_cxx_right_paren (cxx_pp);\n       break;\n-      \n+\n     case INTEGER_CST:\n     case REAL_CST:\n        pp_c_constant (pp_c_base (cxx_pp), t);\n@@ -1595,7 +1595,7 @@ dump_expr (tree t, int flags)\n     case CONVERT_EXPR:\n       {\n \ttree op = TREE_OPERAND (t, 0);\n-\t\n+\n \tif (!same_type_p (TREE_TYPE (op), TREE_TYPE (t)))\n \t  {\n \t    /* It is a cast, but we cannot tell whether it is a\n@@ -1613,7 +1613,7 @@ dump_expr (tree t, int flags)\n \t  dump_expr (op, flags);\n \tbreak;\n       }\n-      \n+\n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n \t{\n@@ -1670,7 +1670,7 @@ dump_expr (tree t, int flags)\n \t  dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n           pp_cxx_right_brace (cxx_pp);\n \t}\n-      \n+\n       break;\n \n     case OFFSET_REF:\n@@ -1683,7 +1683,7 @@ dump_expr (tree t, int flags)\n \t      /* A::f */\n \t      dump_expr (t, flags | TFF_EXPR_IN_PARENS);\n \t    else if (BASELINK_P (t))\n-\t      dump_expr (OVL_CURRENT (BASELINK_FUNCTIONS (t)), \n+\t      dump_expr (OVL_CURRENT (BASELINK_FUNCTIONS (t)),\n \t\t\t flags | TFF_EXPR_IN_PARENS);\n \t    else\n \t      dump_decl (t, flags);\n@@ -1950,7 +1950,7 @@ location_of (tree t)\n     t = TYPE_MAIN_DECL (t);\n   else if (TREE_CODE (t) == OVERLOAD)\n     t = OVL_FUNCTION (t);\n-  \n+\n   return DECL_SOURCE_LOCATION (t);\n }\n \n@@ -2182,7 +2182,7 @@ print_instantiation_full_context (diagnostic_context *context)\n {\n   tree p = current_instantiation ();\n   location_t location = input_location;\n-  \n+\n   if (p)\n     {\n       if (current_function_decl != TINST_DECL (p)\n@@ -2295,7 +2295,7 @@ cp_printer (pretty_printer *pp, text_info *text)\n     case 'Q': result = assop_to_string (next_tcode);\t        break;\n     case 'T': result = type_to_string (next_tree, verbose);\tbreak;\n     case 'V': result = cv_to_string (next_tree, verbose);\tbreak;\n- \n+\n     default:\n       return false;\n     }"}, {"sha": "a90cae0919983b64a4717de2ea7ce1fcdd92e6a4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -95,7 +95,7 @@ cp_protect_cleanup_actions (void)\n      When the destruction of an object during stack unwinding exits\n      using an exception ... void terminate(); is called.  */\n   return build_call (terminate_node, NULL_TREE);\n-}     \n+}\n \n static tree\n prepare_eh_type (tree type)\n@@ -346,7 +346,7 @@ choose_personality_routine (enum languages lang)\n \n /* Initialize the catch parameter DECL.  */\n \n-static void \n+static void\n initialize_handler_parm (tree decl, tree exp)\n {\n   tree init;\n@@ -357,7 +357,7 @@ initialize_handler_parm (tree decl, tree exp)\n   TREE_USED (decl) = 1;\n \n   /* Figure out the type that the initializer is.  Pointers are returned\n-     adjusted by value from __cxa_begin_catch.  Others are returned by \n+     adjusted by value from __cxa_begin_catch.  Others are returned by\n      reference.  */\n   init_type = TREE_TYPE (decl);\n   if (!POINTER_TYPE_P (init_type))\n@@ -528,7 +528,7 @@ do_allocate_exception (tree type)\n       tree tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n       fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n-  \n+\n   return build_function_call (fn, tree_cons (NULL_TREE, size_in_bytes (type),\n \t\t\t\t\t     NULL_TREE));\n }\n@@ -600,7 +600,7 @@ build_throw (tree exp)\n \n   if (exp == null_node)\n     warning (0, \"throwing NULL, which has integral, not pointer type\");\n-  \n+\n   if (exp != NULL_TREE)\n     {\n       if (!is_admissible_throw_operand (exp))\n@@ -645,7 +645,7 @@ build_throw (tree exp)\n \t  tmp = build_function_type (void_type_node, tmp);\n \t  cleanup_type = build_pointer_type (tmp);\n \t}\n-      \n+\n       fn = get_identifier (\"__cxa_throw\");\n       if (!get_global_value_if_present (fn, &fn))\n \t{\n@@ -658,7 +658,7 @@ build_throw (tree exp)\n \t  tmp = build_function_type (void_type_node, tmp);\n \t  fn = push_throw_library_fn (fn, tmp);\n \t}\n-      \n+\n       /* throw expression */\n       /* First, decay it.  */\n       exp = decay_conversion (exp);\n@@ -751,7 +751,7 @@ build_throw (tree exp)\n \t}\n       else\n \tcleanup = build_int_cst (cleanup_type, 0);\n-\t\n+\n       tmp = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n       tmp = tree_cons (NULL_TREE, throw_type, tmp);\n       tmp = tree_cons (NULL_TREE, ptr, tmp);\n@@ -774,7 +774,7 @@ build_throw (tree exp)\n \t}\n \n       /* ??? Indicate that this function call allows exceptions of the type\n-\t of the enclosing catch block (if known).  */\t \n+\t of the enclosing catch block (if known).  */\n       exp = build_function_call (fn, NULL_TREE);\n     }\n \n@@ -792,18 +792,18 @@ static int\n complete_ptr_ref_or_void_ptr_p (tree type, tree from)\n {\n   int is_ptr;\n-  \n+\n   /* Check complete.  */\n   type = complete_type_or_else (type, from);\n   if (!type)\n     return 0;\n-  \n+\n   /* Or a pointer or ref to one, or cv void *.  */\n   is_ptr = TREE_CODE (type) == POINTER_TYPE;\n   if (is_ptr || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       tree core = TREE_TYPE (type);\n-  \n+\n       if (is_ptr && VOID_TYPE_P (core))\n         /* OK */;\n       else if (!complete_type_or_else (core, from))"}, {"sha": "efa5c9ae55500e7cead3fd2e5d15dd560017c361", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -46,11 +46,11 @@ cplus_expand_constant (tree cst)\n       {\n \ttree type = TREE_TYPE (cst);\n \ttree member;\n-      \n+\n \t/* Find the member.  */\n \tmember = PTRMEM_CST_MEMBER (cst);\n \n-\tif (TREE_CODE (member) == FIELD_DECL) \n+\tif (TREE_CODE (member) == FIELD_DECL)\n \t  {\n \t    /* Find the offset for the field.  */\n \t    cst = byte_position (member);"}, {"sha": "346ff4c36d67ad0e0d1d69d4d644f687581a637f", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -85,18 +85,18 @@ is_friend (tree type, tree supplicant)\n \t   context = TYPE_CONTEXT (context))\n \tif (type == context)\n \t  return 1;\n-      \n+\n       list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n       for (; list ; list = TREE_CHAIN (list))\n \t{\n \t  tree t = TREE_VALUE (list);\n \n-\t  if (TREE_CODE (t) == TEMPLATE_DECL ? \n+\t  if (TREE_CODE (t) == TEMPLATE_DECL ?\n \t      is_specialization_of_friend (TYPE_MAIN_DECL (supplicant), t) :\n \t      same_type_p (supplicant, t))\n \t    return 1;\n \t}\n-    }      \n+    }\n \n   if (declp && DECL_FUNCTION_MEMBER_P (supplicant))\n     context = DECL_CONTEXT (supplicant);\n@@ -174,7 +174,7 @@ add_friend (tree type, tree decl, bool complain)\n     = tree_cons (DECL_NAME (decl), build_tree_list (NULL_TREE, decl),\n \t\t DECL_FRIENDLIST (typedecl));\n   if (!uses_template_parms (type))\n-    DECL_BEFRIENDING_CLASSES (decl) \n+    DECL_BEFRIENDING_CLASSES (decl)\n       = tree_cons (NULL_TREE, type,\n \t\t   DECL_BEFRIENDING_CLASSES (decl));\n }\n@@ -375,8 +375,8 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t    }\n \t}\n     }\n-  \n-  if (!classes) \n+\n+  if (!classes)\n     {\n       maybe_add_class_template_decl_list (type, friend_type, /*friend_p=*/1);\n \n@@ -386,12 +386,12 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \tfriend_type = TREE_TYPE (friend_type);\n       if (!uses_template_parms (type))\n \tCLASSTYPE_BEFRIENDING_CLASSES (friend_type)\n-\t  = tree_cons (NULL_TREE, type, \n-\t\t       CLASSTYPE_BEFRIENDING_CLASSES (friend_type)); \n+\t  = tree_cons (NULL_TREE, type,\n+\t\t       CLASSTYPE_BEFRIENDING_CLASSES (friend_type));\n     }\n }\n \n-/* Main friend processor. \n+/* Main friend processor.\n \n    CTYPE is the class this friend belongs to.\n \n@@ -406,7 +406,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \n tree\n do_friend (tree ctype, tree declarator, tree decl,\n-\t   tree attrlist, enum overload_flags flags, \n+\t   tree attrlist, enum overload_flags flags,\n \t   cp_cv_quals quals,\n \t   int funcdef_flag)\n {\n@@ -482,8 +482,8 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t       validity of the declaration later.  */\n \t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n \t  else\n-\t    decl = check_classfn (ctype, decl, \n-\t\t\t\t  template_member_p \n+\t    decl = check_classfn (ctype, decl,\n+\t\t\t\t  template_member_p\n \t\t\t\t  ? current_template_parms\n \t\t\t\t  : NULL_TREE);\n \n@@ -527,7 +527,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t       general, such a declaration depends on template\n \t       parameters.  Instead, we call pushdecl when the class\n \t       is instantiated.  */\n-\t    decl = push_template_decl_real (decl, /*is_friend=*/1); \n+\t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n \t  else if (current_function_decl)\n \t    /* This must be a local class, so pushdecl will be ok, and\n \t       insert an unqualified friend into the local scope\n@@ -541,7 +541,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t         unqualified friend decl into the template parameter\n \t         scope, rather than the namespace containing it.  */\n \t      tree ns = decl_namespace_context (decl);\n-\t      \n+\n \t      push_nested_namespace (ns);\n \t      decl = pushdecl_namespace_level (decl);\n \t      pop_nested_namespace (ns);\n@@ -565,8 +565,8 @@ do_friend (tree ctype, tree declarator, tree decl,\n \n       if (decl == error_mark_node)\n \treturn error_mark_node;\n-      \n-      add_friend (current_class_type, \n+\n+      add_friend (current_class_type,\n \t\t  is_friend_template ? DECL_TI_TEMPLATE (decl) : decl,\n \t\t  /*complain=*/true);\n       DECL_FRIEND_P (decl) = 1;"}, {"sha": "6390574d80081be0bff9e0580745ef672286ae9e", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -190,7 +190,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \t\t cause a warning.  */\n \t      library = -1;\n \t    }\n-\t  else if (strcmp (argv[i], \"-static-libgcc\") == 0 \n+\t  else if (strcmp (argv[i], \"-static-libgcc\") == 0\n \t\t   || strcmp (argv[i], \"-static\") == 0)\n \t    shared_libgcc = 0;\n \t  else if (DEFAULT_WORD_SWITCH_TAKES_ARG (&argv[i][1]))\n@@ -201,7 +201,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \t}\n       else\n \t{\n-\t  int len; \n+\t  int len;\n \n \t  if (saw_speclang)\n \t    {\n@@ -213,15 +213,15 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \t     But not if a specified -x option is currently active.  */\n \t  len = strlen (argv[i]);\n \t  if (len > 2\n-\t      && (argv[i][len - 1] == 'c' \n+\t      && (argv[i][len - 1] == 'c'\n \t\t  || argv[i][len - 1] == 'i'\n \t\t  || argv[i][len - 1] == 'h')\n \t      && argv[i][len - 2] == '.')\n \t    {\n \t      args[i] |= LANGSPEC;\n \t      added += 2;\n \t    }\n-\t  \n+\n \t  /* If we don't know that this is a header file, we might\n \t     need to be linking in the libraries.  */\n \t  if (library == 0)\n@@ -256,7 +256,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \n   i = 0;\n   j = 0;\n-  \n+\n   /* Copy the 0th argument, i.e., the name of the program itself.  */\n   arglist[i++] = argv[j++];\n \n@@ -344,7 +344,7 @@ int lang_specific_pre_link (void)  /* Not used for C++.  */\n /* Number of extra output files that lang_specific_pre_link may generate.  */\n int lang_specific_extra_outfiles = 0;  /* Not used for C++.  */\n \n-/* Table of language-specific spec functions.  */ \n+/* Table of language-specific spec functions.  */\n const struct spec_function lang_specific_spec_functions[] =\n {\n   { 0, 0 }"}, {"sha": "e72b4b1ea0f28c797dce11ba330a65351fe70662", "filename": "gcc/cp/init.c", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -70,7 +70,7 @@ static bool\n begin_init_stmts (tree *stmt_expr_p, tree *compound_stmt_p)\n {\n   bool is_global = !building_stmt_tree ();\n-  \n+\n   *stmt_expr_p = begin_stmt_expr ();\n   *compound_stmt_p = begin_compound_stmt (BCS_NO_SCOPE);\n \n@@ -82,13 +82,13 @@ begin_init_stmts (tree *stmt_expr_p, tree *compound_stmt_p)\n \n static tree\n finish_init_stmts (bool is_global, tree stmt_expr, tree compound_stmt)\n-{  \n+{\n   finish_compound_stmt (compound_stmt);\n-  \n+\n   stmt_expr = finish_stmt_expr (stmt_expr, true);\n \n   gcc_assert (!building_stmt_tree () == is_global);\n-  \n+\n   return stmt_expr;\n }\n \n@@ -103,7 +103,7 @@ dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n {\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n     return dfs_skip_bases;\n-  \n+\n   if (!BINFO_PRIMARY_P (binfo) || BINFO_VIRTUAL_P (binfo))\n     {\n       tree base_ptr = TREE_VALUE ((tree) data);\n@@ -200,7 +200,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t     over TYPE_FIELDs will result in correct initialization of\n \t     all of the subobjects.  */\n \t  if (static_storage_p && !zero_init_p (TREE_TYPE (field)))\n-\t    inits = tree_cons (field, \n+\t    inits = tree_cons (field,\n \t\t\t       build_zero_init (TREE_TYPE (field),\n \t\t\t\t\t\t/*nelts=*/NULL_TREE,\n \t\t\t\t\t\tstatic_storage_p),\n@@ -236,16 +236,16 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t\t\t\t\t   /*nelts=*/NULL_TREE,\n \t\t\t\t\t   static_storage_p);\n \t  tree range;\n-\t  \n+\n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n \t    range = size_zero_node;\n \t  else\n \t   range = build2 (RANGE_EXPR, sizetype, size_zero_node, max_index);\n-\t  \n+\n \t  inits = tree_cons (range, elt_init, inits);\n \t}\n-      \n+\n       CONSTRUCTOR_ELTS (init) = nreverse (inits);\n     }\n   else\n@@ -292,7 +292,7 @@ build_default_init (tree type, tree nelts)\n      a class with a pointer-to-data member as a non-static data member\n      does not have TYPE_NEEDS_CONSTRUCTING set.)  Therefore, we end up\n      passing non-PODs to build_zero_init below, which is contrary to\n-     the semantics quoted above from [dcl.init].  \n+     the semantics quoted above from [dcl.init].\n \n      It happens, however, that the behavior of the constructor the\n      standard says we should have generated would be precisely the\n@@ -301,7 +301,7 @@ build_default_init (tree type, tree nelts)\n   if (TYPE_NEEDS_CONSTRUCTING (type)\n       || (nelts && TREE_CODE (nelts) != INTEGER_CST))\n     return NULL_TREE;\n-      \n+\n   /* At this point, TYPE is either a POD class type, an array of POD\n      classes, or something even more innocuous.  */\n   return build_zero_init (type, nelts, /*static_storage_p=*/false);\n@@ -409,7 +409,7 @@ perform_member_init (tree member, tree init)\n /* Returns a TREE_LIST containing (as the TREE_PURPOSE of each node) all\n    the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */\n \n-static tree \n+static tree\n build_field_list (tree t, tree list, int *uses_unions_p)\n {\n   tree fields;\n@@ -425,7 +425,7 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n       /* Skip CONST_DECLs for enumeration constants and so forth.  */\n       if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n \tcontinue;\n-      \n+\n       /* Keep track of whether or not any fields are unions.  */\n       if (TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n \t*uses_unions_p = 1;\n@@ -439,7 +439,7 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n \t     initialize the entire aggregate.  */\n \t  list = tree_cons (fields, NULL_TREE, list);\n \t  /* And now add the fields in the anonymous aggregate.  */\n-\t  list = build_field_list (TREE_TYPE (fields), list, \n+\t  list = build_field_list (TREE_TYPE (fields), list,\n \t\t\t\t   uses_unions_p);\n \t}\n       /* Add this field.  */\n@@ -474,12 +474,12 @@ sort_mem_initializers (tree t, tree mem_inits)\n      TREE_VALUE will be the constructor arguments, or NULL if no\n      explicit initialization was provided.  */\n   sorted_inits = NULL_TREE;\n-  \n+\n   /* Process the virtual bases.  */\n   for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n        VEC_iterate (tree, vbases, i, base); i++)\n     sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n-  \n+\n   /* Process the direct bases.  */\n   for (binfo = TYPE_BINFO (t), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n@@ -508,10 +508,10 @@ sort_mem_initializers (tree t, tree mem_inits)\n       subobject = TREE_PURPOSE (init);\n \n       /* If the explicit initializers are in sorted order, then\n-\t SUBOBJECT will be NEXT_SUBOBJECT, or something following \n+\t SUBOBJECT will be NEXT_SUBOBJECT, or something following\n \t it.  */\n-      for (subobject_init = next_subobject; \n-\t   subobject_init; \n+      for (subobject_init = next_subobject;\n+\t   subobject_init;\n \t   subobject_init = TREE_CHAIN (subobject_init))\n \tif (TREE_PURPOSE (subobject_init) == subobject)\n \t  break;\n@@ -541,7 +541,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t  while (TREE_PURPOSE (subobject_init) != subobject)\n \t    subobject_init = TREE_CHAIN (subobject_init);\n \t}\n-\t\n+\n       /* It is invalid to initialize the same subobject more than\n \t once.  */\n       if (TREE_VALUE (subobject_init))\n@@ -550,7 +550,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t    error (\"%Jmultiple initializations given for %qD\",\n \t\t   current_function_decl, subobject);\n \t  else\n-\t    error (\"%Jmultiple initializations given for base %qT\", \n+\t    error (\"%Jmultiple initializations given for base %qT\",\n \t\t   current_function_decl, subobject);\n \t}\n \n@@ -574,7 +574,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t  int done;\n \n \t  /* Skip uninitialized members and base classes.  */\n-\t  if (!TREE_VALUE (init) \n+\t  if (!TREE_VALUE (init)\n \t      || TREE_CODE (TREE_PURPOSE (init)) != FIELD_DECL)\n \t    continue;\n \t  /* See if this field is a member of a union, or a member of a\n@@ -628,7 +628,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \n \t\t  last_field_type = TYPE_CONTEXT (last_field_type);\n \t\t}\n-\t      \n+\n \t      /* If we've reached the outermost class, then we're\n \t\t done.  */\n \t      if (same_type_p (field_type, t))\n@@ -659,15 +659,15 @@ emit_mem_initializers (tree mem_inits)\n      the type is incomplete.  */\n   if (!COMPLETE_TYPE_P (current_class_type))\n     return;\n-  \n+\n   /* Sort the mem-initializers into the order in which the\n      initializations should be performed.  */\n   mem_inits = sort_mem_initializers (current_class_type, mem_inits);\n \n   in_base_initializer = 1;\n-  \n+\n   /* Initialize base classes.  */\n-  while (mem_inits \n+  while (mem_inits\n \t && TREE_CODE (TREE_PURPOSE (mem_inits)) != FIELD_DECL)\n     {\n       tree subobject = TREE_PURPOSE (mem_inits);\n@@ -676,7 +676,7 @@ emit_mem_initializers (tree mem_inits)\n       /* If these initializations are taking place in a copy\n \t constructor, the base class should probably be explicitly\n \t initialized.  */\n-      if (extra_warnings && !arguments \n+      if (extra_warnings && !arguments\n \t  && DECL_COPY_CONSTRUCTOR_P (current_function_decl)\n \t  && TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (subobject)))\n \twarning (0, \"%Jbase class %q#T should be explicitly initialized in the \"\n@@ -694,11 +694,11 @@ emit_mem_initializers (tree mem_inits)\n       else\n \t{\n \t  tree base_addr;\n-\t  \n+\n \t  base_addr = build_base_path (PLUS_EXPR, current_class_ptr,\n \t\t\t\t       subobject, 1);\n \t  expand_aggr_init_1 (subobject, NULL_TREE,\n-\t\t\t      build_indirect_ref (base_addr, NULL), \n+\t\t\t      build_indirect_ref (base_addr, NULL),\n \t\t\t      arguments,\n \t\t\t      LOOKUP_NORMAL);\n \t  expand_cleanup_for_base (subobject, NULL_TREE);\n@@ -710,7 +710,7 @@ emit_mem_initializers (tree mem_inits)\n \n   /* Initialize the vptrs.  */\n   initialize_vtbl_ptrs (current_class_ptr);\n-  \n+\n   /* Initialize the data members.  */\n   while (mem_inits)\n     {\n@@ -777,8 +777,8 @@ expand_virtual_init (tree binfo, tree decl)\n \n       /* Compute the value to use, when there's a VTT.  */\n       vtt_parm = current_vtt_parm;\n-      vtbl2 = build2 (PLUS_EXPR, \n-\t\t      TREE_TYPE (vtt_parm), \n+      vtbl2 = build2 (PLUS_EXPR,\n+\t\t      TREE_TYPE (vtt_parm),\n \t\t      vtt_parm,\n \t\t      vtt_index);\n       vtbl2 = build_indirect_ref (vtbl2, NULL);\n@@ -787,11 +787,11 @@ expand_virtual_init (tree binfo, tree decl)\n       /* The actual initializer is the VTT value only in the subobject\n \t constructor.  In maybe_clone_body we'll substitute NULL for\n \t the vtt_parm in the case of the non-subobject constructor.  */\n-      vtbl = build3 (COND_EXPR, \n-\t\t     TREE_TYPE (vtbl), \n+      vtbl = build3 (COND_EXPR,\n+\t\t     TREE_TYPE (vtbl),\n \t\t     build2 (EQ_EXPR, boolean_type_node,\n \t\t\t     current_in_charge_parm, integer_zero_node),\n-\t\t     vtbl2, \n+\t\t     vtbl2,\n \t\t     vtbl);\n     }\n \n@@ -820,7 +820,7 @@ expand_cleanup_for_base (tree binfo, tree flag)\n     return;\n \n   /* Call the destructor.  */\n-  expr = build_special_member_call (current_class_ref, \n+  expr = build_special_member_call (current_class_ref,\n \t\t\t\t    base_dtor_identifier,\n \t\t\t\t    NULL_TREE,\n \t\t\t\t    binfo,\n@@ -841,7 +841,7 @@ construct_virtual_base (tree vbase, tree arguments)\n {\n   tree inner_if_stmt;\n   tree exp;\n-  tree flag;  \n+  tree flag;\n \n   /* If there are virtual base classes with destructors, we need to\n      emit cleanups to destroy them if an exception is thrown during\n@@ -867,7 +867,7 @@ construct_virtual_base (tree vbase, tree arguments)\n      we already know where it is.  */\n   exp = convert_to_base_statically (current_class_ref, vbase);\n \n-  expand_aggr_init_1 (vbase, current_class_ref, exp, arguments, \n+  expand_aggr_init_1 (vbase, current_class_ref, exp, arguments,\n \t\t      LOOKUP_COMPLAIN);\n   finish_then_clause (inner_if_stmt);\n   finish_if_stmt (inner_if_stmt);\n@@ -893,7 +893,7 @@ initializing_context (tree field)\n    is erroneous.  FIELD is the member we decided to initialize.\n    TYPE is the type for which the initialization is being performed.\n    FIELD must be a member of TYPE.\n-   \n+\n    MEMBER_NAME is the name of the member.  */\n \n static int\n@@ -1003,7 +1003,7 @@ expand_member_init (tree name)\n \tvirtual_binfo = binfo_for_vbase (basetype, current_class_type);\n \n       /* [class.base.init]\n-\t \n+\n          If a mem-initializer-id is ambiguous because it designates\n \t both a direct non-virtual base class and an inherited virtual\n \t base class, the mem-initializer is ill-formed.  */\n@@ -1366,7 +1366,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n \n   if (type == NULL_TREE)\n     return error_mark_node;\n-  \n+\n   /* Handle namespace names fully here.  */\n   if (TREE_CODE (type) == NAMESPACE_DECL)\n     {\n@@ -1411,7 +1411,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n   else\n     {\n       member = lookup_member (basebinfo, name, 1, 0);\n-      \n+\n       if (member == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -1465,9 +1465,9 @@ build_offset_ref (tree type, tree name, bool address_p)\n           t = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n \t\t      TREE_OPERAND (orig_name, 1));\n \t  t = build2 (OFFSET_REF, unknown_type_node, decl, t);\n-          \n+\n           PTRMEM_OK_P (t) = 1;\n-          \t  \n+\n \t  return t;\n \t}\n \n@@ -1539,7 +1539,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t      PTRMEM_OK_P (member) = 1;\n \t      return build_unary_op (ADDR_EXPR, member, 0);\n \t    }\n-\t  error (\"invalid use of non-static member function %qD\", \n+\t  error (\"invalid use of non-static member function %qD\",\n \t\t TREE_OPERAND (member, 1));\n \t  return member;\n \t}\n@@ -1597,7 +1597,7 @@ decl_constant_value (tree decl)\n        \t then re-evaluating it could give different results.  */\n       && TREE_CONSTANT (DECL_INITIAL (decl)))\n     return DECL_INITIAL (decl);\n-  \n+\n   return decl;\n }\n \f\n@@ -1622,7 +1622,7 @@ build_builtin_delete_call (tree addr)\n    explicitly wrote \"::new\" rather than just \"new\".  */\n \n tree\n-build_new (tree placement, tree type, tree nelts, tree init, \n+build_new (tree placement, tree type, tree nelts, tree init,\n \t   int use_global_new)\n {\n   tree rval;\n@@ -1632,7 +1632,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n \n   if (processing_template_decl)\n     {\n-      rval = build_min (NEW_EXPR, build_pointer_type (type), \n+      rval = build_min (NEW_EXPR, build_pointer_type (type),\n \t\t\tplacement, type, nelts, init);\n       NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n       TREE_SIDE_EFFECTS (rval) = 1;\n@@ -1735,13 +1735,13 @@ build_new_1 (tree exp)\n   tree placement, init;\n   tree size, rval;\n   /* True iff this is a call to \"operator new[]\" instead of just\n-     \"operator new\".  */   \n+     \"operator new\".  */\n   bool array_p = false;\n   /* True iff ARRAY_P is true and the bound of the array type is\n      not necessarily a compile time constant.  For example, VLA_P is\n      true for \"new int[f()]\".  */\n   bool vla_p = false;\n-  /* The type being allocated.  If ARRAY_P is true, this will be an \n+  /* The type being allocated.  If ARRAY_P is true, this will be an\n      ARRAY_TYPE.  */\n   tree full_type;\n   /* If ARRAY_P is true, the element type of the array.  This is an\n@@ -1801,7 +1801,7 @@ build_new_1 (tree exp)\n       outer_nelts = nelts;\n       array_p = true;\n \n-      /* ??? The middle-end will error on us for building a VLA outside a \n+      /* ??? The middle-end will error on us for building a VLA outside a\n \t function context.  Methinks that's not it's purvey.  So we'll do\n \t our own VLA layout later.  */\n       vla_p = true;\n@@ -1827,7 +1827,7 @@ build_new_1 (tree exp)\n   for (elt_type = type;\n        TREE_CODE (elt_type) == ARRAY_TYPE;\n        elt_type = TREE_TYPE (elt_type))\n-    nelts = cp_build_binary_op (MULT_EXPR, nelts, \n+    nelts = cp_build_binary_op (MULT_EXPR, nelts,\n \t\t\t\tarray_type_nelts_top (elt_type));\n \n   if (!complete_type_or_else (elt_type, exp))\n@@ -1876,7 +1876,7 @@ build_new_1 (tree exp)\n \n       use_java_new = 1;\n       alloc_decl = NULL;\n-      if (!get_global_value_if_present (get_identifier (alloc_name), \n+      if (!get_global_value_if_present (get_identifier (alloc_name),\n \t\t\t\t\t&alloc_decl))\n \t{\n \t  error (\"call to Java constructor with %qs undefined\", alloc_name);\n@@ -1900,7 +1900,7 @@ build_new_1 (tree exp)\n \n       fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n-      if (!globally_qualified_p \n+      if (!globally_qualified_p\n \t  && CLASS_TYPE_P (elt_type)\n \t  && (array_p\n \t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n@@ -1937,7 +1937,7 @@ build_new_1 (tree exp)\n \t  else\n \t    cookie_size = NULL_TREE;\n \n-\t  alloc_call = build_operator_new_call (fnname, placement, \n+\t  alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t\t&size, &cookie_size);\n \t}\n     }\n@@ -1958,7 +1958,7 @@ build_new_1 (tree exp)\n   alloc_node = TARGET_EXPR_SLOT (alloc_expr);\n \n   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */\n-  while (TREE_CODE (alloc_call) == COMPOUND_EXPR) \n+  while (TREE_CODE (alloc_call) == COMPOUND_EXPR)\n     alloc_call = TREE_OPERAND (alloc_call, 1);\n   alloc_fn = get_callee_fndecl (alloc_call);\n   gcc_assert (alloc_fn != NULL_TREE);\n@@ -1973,8 +1973,8 @@ build_new_1 (tree exp)\n      there is no explicit placement argument.  If there is more than\n      one argument, or there are variable arguments, then this is a\n      placement allocation function.  */\n-  placement_allocation_fn_p \n-    = (type_num_arguments (TREE_TYPE (alloc_fn)) > 1 \n+  placement_allocation_fn_p\n+    = (type_num_arguments (TREE_TYPE (alloc_fn)) > 1\n        || varargs_function_p (alloc_fn));\n \n   /* Preevaluate the placement args so that we don't reevaluate them for a\n@@ -2069,7 +2069,7 @@ build_new_1 (tree exp)\n \t}\n       else if (TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n-\t  init_expr = build_special_member_call (init_expr, \n+\t  init_expr = build_special_member_call (init_expr,\n \t\t\t\t\t\t complete_ctor_identifier,\n \t\t\t\t\t\t init, elt_type,\n \t\t\t\t\t\t LOOKUP_NORMAL);\n@@ -2110,9 +2110,9 @@ build_new_1 (tree exp)\n \t  /* The Standard is unclear here, but the right thing to do\n \t     is to use the same method for finding deallocation\n \t     functions that we use for finding allocation functions.  */\n-\t  cleanup = build_op_delete_call (dcode, alloc_node, size, \n+\t  cleanup = build_op_delete_call (dcode, alloc_node, size,\n \t\t\t\t\t  globally_qualified_p,\n-\t\t\t\t\t  (placement_allocation_fn_p \n+\t\t\t\t\t  (placement_allocation_fn_p\n \t\t\t\t\t   ? alloc_call : NULL_TREE));\n \n \t  if (!cleanup)\n@@ -2153,7 +2153,7 @@ build_new_1 (tree exp)\n \t\t\t  build2 (COMPOUND_EXPR, void_type_node, init_expr,\n \t\t\t\t  end));\n \t    }\n-\t    \n+\n \t}\n     }\n   else\n@@ -2277,10 +2277,10 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t  tree cookie_size;\n \n \t  cookie_size = targetm.cxx.get_cookie_size (type);\n-\t  base_tbd \n+\t  base_tbd\n \t    = cp_convert (ptype,\n \t\t\t  cp_build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t      cp_convert (string_type_node, \n+\t\t\t\t\t      cp_convert (string_type_node,\n \t\t\t\t\t\t\t  base),\n \t\t\t\t\t      cookie_size));\n \t  /* True size with header.  */\n@@ -2300,10 +2300,10 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     body = deallocate_expr;\n   else\n     body = build_compound_expr (body, deallocate_expr);\n-  \n+\n   if (!body)\n     body = integer_zero_node;\n-  \n+\n   /* Outermost wrapper: If pointer is null, punt.  */\n   body = fold_build3 (COND_EXPR, void_type_node,\n \t\t      fold_build2 (NE_EXPR, boolean_type_node, base,\n@@ -2325,13 +2325,13 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   return convert_to_void (body, /*implicit=*/NULL);\n }\n \n-/* Create an unnamed variable of the indicated TYPE.  */ \n+/* Create an unnamed variable of the indicated TYPE.  */\n \n tree\n create_temporary_var (tree type)\n {\n   tree decl;\n- \n+\n   decl = build_decl (VAR_DECL, NULL_TREE, type);\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -2356,7 +2356,7 @@ get_temp_regvar (tree type, tree init)\n \n   decl = create_temporary_var (type);\n   add_decl_expr (decl);\n-  \n+\n   finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \n   return decl;\n@@ -2390,7 +2390,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   tree atype = TREE_TYPE (base);\n   /* The type of an element in the array.  */\n   tree type = TREE_TYPE (atype);\n-  /* The element type reached after removing all outer array \n+  /* The element type reached after removing all outer array\n      types.  */\n   tree inner_elt_type;\n   /* The type of a pointer to an element in the array.  */\n@@ -2401,7 +2401,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   tree try_block = NULL_TREE;\n   int num_initialized_elts = 0;\n   bool is_global;\n-  \n+\n   if (TYPE_DOMAIN (atype))\n     maxindex = array_type_nelts (atype);\n \n@@ -2411,7 +2411,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   inner_elt_type = strip_array_types (atype);\n   if (init\n       && (from_array == 2\n-\t  ? (!CLASS_TYPE_P (inner_elt_type) \n+\t  ? (!CLASS_TYPE_P (inner_elt_type)\n \t     || !TYPE_HAS_COMPLEX_ASSIGN_REF (inner_elt_type))\n \t  : !TYPE_NEEDS_CONSTRUCTING (type))\n       && ((TREE_CODE (init) == CONSTRUCTOR\n@@ -2450,14 +2450,14 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n        }\n        rval;\n      })\n-       \n+\n      We can omit the try and catch blocks if we know that the\n      initialization will never throw an exception, or if the array\n      elements do not have destructors.  We can omit the loop completely if\n-     the elements of the array do not have constructors.  \n+     the elements of the array do not have constructors.\n \n      We actually wrap the entire body of the above in a STMT_EXPR, for\n-     tidiness.  \n+     tidiness.\n \n      When copying from array to another, when the array elements have\n      only trivial copy constructors, we should use __builtin_memcpy\n@@ -2515,7 +2515,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n     {\n       /* If initializing one array from another, initialize element by\n \t element.  We rely upon the below calls the do argument\n-\t checking.  */ \n+\t checking.  */\n       if (init)\n \t{\n \t  base2 = decay_conversion (init);\n@@ -2585,9 +2585,9 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t\t\t\t     0, 0, 0);\n \t}\n       else\n-\telt_init = build_aggr_init (build1 (INDIRECT_REF, type, base), \n+\telt_init = build_aggr_init (build1 (INDIRECT_REF, type, base),\n \t\t\t\t    init, 0);\n-      \n+\n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n       finish_expr_stmt (elt_init);\n       current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n@@ -2613,7 +2613,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t\t\t\tarray_type_nelts_total (type));\n \n       finish_cleanup_try_block (try_block);\n-      e = build_vec_delete_1 (rval, m, \n+      e = build_vec_delete_1 (rval, m,\n \t\t\t      inner_elt_type, sfk_base_destructor,\n \t\t\t      /*use_global_delete=*/0);\n       finish_cleanup (e, try_block);\n@@ -2629,7 +2629,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   atype = build_pointer_type (atype);\n   stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n   stmt_expr = build_indirect_ref (stmt_expr, NULL);\n-  \n+\n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   return stmt_expr;\n }\n@@ -2655,7 +2655,7 @@ build_x_delete (tree addr, int which_delete, tree virtual_size)\n   int use_vec_delete = !!(which_delete & 2);\n   enum tree_code code = use_vec_delete ? VEC_DELETE_EXPR : DELETE_EXPR;\n \n-  return build_op_delete_call (code, addr, virtual_size, use_global_delete, \n+  return build_op_delete_call (code, addr, virtual_size, use_global_delete,\n \t\t\t       NULL_TREE);\n }\n \n@@ -2685,7 +2685,7 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n       gcc_unreachable ();\n     }\n   fn = lookup_fnfields (TREE_TYPE (exp), name, /*protect=*/2);\n-  return build_new_method_call (exp, fn, \n+  return build_new_method_call (exp, fn,\n \t\t\t\t/*args=*/NULL_TREE,\n \t\t\t\t/*conversion_path=*/NULL_TREE,\n \t\t\t\tflags);\n@@ -2756,7 +2756,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n     handle_array:\n-      \n+\n       if (TYPE_DOMAIN (type) == NULL_TREE)\n \t{\n \t  error (\"unknown array size in delete\");\n@@ -2884,11 +2884,11 @@ push_base_cleanups (void)\n \t{\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t    {\n-\t      expr = build_special_member_call (current_class_ref, \n+\t      expr = build_special_member_call (current_class_ref,\n \t\t\t\t\t\tbase_dtor_identifier,\n \t\t\t\t\t\tNULL_TREE,\n \t\t\t\t\t\tbase_binfo,\n-\t\t\t\t\t\t(LOOKUP_NORMAL \n+\t\t\t\t\t\t(LOOKUP_NORMAL\n \t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n \t      expr = build3 (COND_EXPR, void_type_node, cond,\n \t\t\t     expr, void_zero_node);\n@@ -2905,9 +2905,9 @@ push_base_cleanups (void)\n \t  || BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n \n-      expr = build_special_member_call (current_class_ref, \n+      expr = build_special_member_call (current_class_ref,\n \t\t\t\t\tbase_dtor_identifier,\n-\t\t\t\t\tNULL_TREE, base_binfo, \n+\t\t\t\t\tNULL_TREE, base_binfo,\n \t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n       finish_decl_cleanup (NULL_TREE, expr);\n     }\n@@ -2919,8 +2919,8 @@ push_base_cleanups (void)\n \tcontinue;\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n \t{\n-\t  tree this_member = (build_class_member_access_expr \n-\t\t\t      (current_class_ref, member, \n+\t  tree this_member = (build_class_member_access_expr\n+\t\t\t      (current_class_ref, member,\n \t\t\t       /*access_path=*/NULL_TREE,\n \t\t\t       /*preserve_reference=*/false));\n \t  tree this_type = TREE_TYPE (member);"}, {"sha": "4494cf8c0176df2724c58c1a57ca5ddb13383e50", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -633,16 +633,16 @@ unqualified_fn_lookup_error (tree name)\n \t declaration of \"f\" is available.  Historically, G++ and most\n \t other compilers accepted that usage since they deferred all name\n \t lookup until instantiation time rather than doing unqualified\n-\t name lookup at template definition time; explain to the user what \n+\t name lookup at template definition time; explain to the user what\n \t is going wrong.\n \n \t Note that we have the exact wording of the following message in\n \t the manual (trouble.texi, node \"Name lookup\"), so they need to\n \t be kept in synch.  */\n       pedwarn (\"there are no arguments to %qD that depend on a template \"\n-\t       \"parameter, so a declaration of %qD must be available\", \n+\t       \"parameter, so a declaration of %qD must be available\",\n \t       name, name);\n-      \n+\n       if (!flag_permissive)\n \t{\n \t  static bool hint;\n@@ -670,7 +670,7 @@ build_lang_decl (enum tree_code code, tree name, tree type)\n \n   /* All nesting of C++ functions is lexical; there is never a \"static\n      chain\" in the sense of GNU C nested functions.  */\n-  if (code == FUNCTION_DECL) \n+  if (code == FUNCTION_DECL)\n     DECL_NO_STATIC_CHAIN (t) = 1;\n \n   return t;"}, {"sha": "5ceeecea56ac7fc4a5bff2e5a6d80eb7267b0865", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -319,7 +319,7 @@ decl_is_template_id (const tree decl, tree* const template_info)\n \t    *template_info = TYPE_TEMPLATE_INFO (type);\n \t  return 1;\n \t}\n-    } \n+    }\n   else\n     {\n       /* Check if this is a primary template.  */\n@@ -362,12 +362,12 @@ dump_substitution_candidates (void)\n       else if (TYPE_NAME (el))\n \tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (el)));\n       fprintf (stderr, \" S%d_ = \", i - 1);\n-      if (TYPE_P (el) && \n-\t  (CP_TYPE_RESTRICT_P (el) \n-\t   || CP_TYPE_VOLATILE_P (el) \n+      if (TYPE_P (el) &&\n+\t  (CP_TYPE_RESTRICT_P (el)\n+\t   || CP_TYPE_VOLATILE_P (el)\n \t   || CP_TYPE_CONST_P (el)))\n \tfprintf (stderr, \"CV-\");\n-      fprintf (stderr, \"%s (%s at %p)\\n\", \n+      fprintf (stderr, \"%s (%s at %p)\\n\",\n \t       name, tree_code_name[TREE_CODE (el)], (void *) el);\n     }\n }\n@@ -400,7 +400,7 @@ add_substitution (tree node)\n   tree c;\n \n   if (DEBUG_MANGLE)\n-    fprintf (stderr, \"  ++ add_substitution (%s at %10p)\\n\", \n+    fprintf (stderr, \"  ++ add_substitution (%s at %10p)\\n\",\n \t     tree_code_name[TREE_CODE (node)], (void *) node);\n \n   /* Get the canonicalized substitution candidate for NODE.  */\n@@ -419,7 +419,7 @@ add_substitution (tree node)\n     for (i = 0; VEC_iterate (tree, G.substitutions, i, candidate); i++)\n       {\n \tgcc_assert (!(DECL_P (node) && node == candidate));\n-\tgcc_assert (!(TYPE_P (node) && TYPE_P (candidate) \n+\tgcc_assert (!(TYPE_P (node) && TYPE_P (candidate)\n \t\t      && same_type_p (node, candidate)));\n       }\n   }\n@@ -436,7 +436,7 @@ add_substitution (tree node)\n    which may be a decl or a CLASS_TYPE, is a template-id with template\n    name of substitution_index[INDEX] in the ::std namespace.  */\n \n-static inline int \n+static inline int\n is_std_substitution (const tree node,\n \t\t     const substitution_identifier_index_t index)\n {\n@@ -453,14 +453,14 @@ is_std_substitution (const tree node,\n       type = node;\n       decl = TYPE_NAME (node);\n     }\n-  else \n+  else\n     /* These are not the droids you're looking for.  */\n     return 0;\n \n   return (DECL_NAMESPACE_STD_P (CP_DECL_CONTEXT (decl))\n-\t  && TYPE_LANG_SPECIFIC (type) \n+\t  && TYPE_LANG_SPECIFIC (type)\n \t  && TYPE_TEMPLATE_INFO (type)\n-\t  && (DECL_NAME (TYPE_TI_TEMPLATE (type)) \n+\t  && (DECL_NAME (TYPE_TI_TEMPLATE (type))\n \t      == subst_identifiers[index]));\n }\n \n@@ -479,14 +479,14 @@ is_std_substitution_char (const tree node,\n     return 0;\n   /* Figure out its template args.  */\n   if (DECL_P (node))\n-    args = DECL_TI_ARGS (node);  \n+    args = DECL_TI_ARGS (node);\n   else if (CLASS_TYPE_P (node))\n     args = CLASSTYPE_TI_ARGS (node);\n   else\n     /* Oops, not a template.  */\n     return 0;\n   /* NODE's template arg list should be <char>.  */\n-  return \n+  return\n     TREE_VEC_LENGTH (args) == 1\n     && TREE_VEC_ELT (args, 0) == char_type_node;\n }\n@@ -496,28 +496,28 @@ is_std_substitution_char (const tree node,\n \n    First, check standard special-case substitutions.\n \n-     <substitution> ::= St     \n+     <substitution> ::= St\n          # ::std\n \n-                    ::= Sa     \n+                    ::= Sa\n \t # ::std::allocator\n \n-                    ::= Sb     \n+                    ::= Sb\n          # ::std::basic_string\n \n-                    ::= Ss \n+                    ::= Ss\n          # ::std::basic_string<char,\n \t\t\t       ::std::char_traits<char>,\n \t\t\t       ::std::allocator<char> >\n \n-                    ::= Si \n+                    ::= Si\n          # ::std::basic_istream<char, ::std::char_traits<char> >\n \n-                    ::= So \n+                    ::= So\n          # ::std::basic_ostream<char, ::std::char_traits<char> >\n \n-                    ::= Sd \n-         # ::std::basic_iostream<char, ::std::char_traits<char> >   \n+                    ::= Sd\n+         # ::std::basic_iostream<char, ::std::char_traits<char> >\n \n    Then examine the stack of currently available substitution\n    candidates for entities appearing earlier in the same mangling\n@@ -547,7 +547,7 @@ find_substitution (tree node)\n   type = TYPE_P (node) ? node : TREE_TYPE (node);\n \n   /* Check for std::allocator.  */\n-  if (decl \n+  if (decl\n       && is_std_substitution (decl, SUBID_ALLOCATOR)\n       && !CLASSTYPE_USE_TEMPLATE (TREE_TYPE (decl)))\n     {\n@@ -560,8 +560,8 @@ find_substitution (tree node)\n     {\n       if (TYPE_P (node))\n \t{\n-\t  /* If this is a type (i.e. a fully-qualified template-id), \n-\t     check for \n+\t  /* If this is a type (i.e. a fully-qualified template-id),\n+\t     check for\n   \t         std::basic_string <char,\n \t\t \t\t    std::char_traits<char>,\n \t\t\t\t    std::allocator<char> > .  */\n@@ -596,7 +596,7 @@ find_substitution (tree node)\n       && CLASSTYPE_USE_TEMPLATE (type)\n       && CLASSTYPE_TEMPLATE_INFO (type) != NULL)\n     {\n-      /* First, check for the template \n+      /* First, check for the template\n \t args <char, std::char_traits<char> > .  */\n       tree args = CLASSTYPE_TI_ARGS (type);\n       if (TREE_VEC_LENGTH (args) == 2\n@@ -659,7 +659,7 @@ find_substitution (tree node)\n /* TOP_LEVEL is true, if this is being called at outermost level of\n   mangling. It should be false when mangling a decl appearing in an\n   expression within some other mangling.\n-  \n+\n   <mangled-name>      ::= _Z <encoding>  */\n \n static void\n@@ -673,7 +673,7 @@ write_mangled_name (const tree decl, bool top_level)\n       && !DECL_OVERLOADED_OPERATOR_P (decl))\n     {\n     unmangled_name:;\n-      \n+\n       if (top_level)\n \twrite_string (IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n@@ -761,7 +761,7 @@ write_encoding (const tree decl)\n \t  d = decl;\n \t}\n \n-      write_bare_function_type (fn_type, \n+      write_bare_function_type (fn_type,\n \t\t\t\t(!DECL_CONSTRUCTOR_P (decl)\n \t\t\t\t && !DECL_DESTRUCTOR_P (decl)\n \t\t\t\t && !DECL_CONV_FN_P (decl)\n@@ -773,7 +773,7 @@ write_encoding (const tree decl)\n /* <name> ::= <unscoped-name>\n           ::= <unscoped-template-name> <template-args>\n \t  ::= <nested-name>\n-\t  ::= <local-name>  \n+\t  ::= <local-name>\n \n    If IGNORE_LOCAL_SCOPE is nonzero, this production of <name> is\n    called from <local-name>, which mangles the enclosing scope\n@@ -803,8 +803,8 @@ write_name (tree decl, const int ignore_local_scope)\n      latter with a special substitution.  Also, a name that is\n      directly in a local function scope is also mangled with\n      <unscoped-name> rather than a full <nested-name>.  */\n-  if (context == NULL \n-      || context == global_namespace \n+  if (context == NULL\n+      || context == global_namespace\n       || DECL_NAMESPACE_STD_P (context)\n       || (ignore_local_scope && TREE_CODE (context) == FUNCTION_DECL))\n     {\n@@ -880,10 +880,10 @@ write_unscoped_name (const tree decl)\n     {\n       /* If not, it should be either in the global namespace, or directly\n      \t in a local function scope.  */\n-      gcc_assert (context == global_namespace \n+      gcc_assert (context == global_namespace\n \t\t  || context == NULL\n \t\t  || TREE_CODE (context) == FUNCTION_DECL);\n-      \n+\n       write_unqualified_name (decl);\n     }\n }\n@@ -904,7 +904,7 @@ write_unscoped_template_name (const tree decl)\n \n /* Write the nested name, including CV-qualifiers, of DECL.\n \n-   <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E  \n+   <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E\n                  ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n \n    <CV-qualifiers> ::= [r] [V] [K]  */\n@@ -917,9 +917,9 @@ write_nested_name (const tree decl)\n   MANGLE_TRACE_TREE (\"nested-name\", decl);\n \n   write_char ('N');\n-  \n+\n   /* Write CV-qualifiers, if this is a member function.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL \n+  if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n     {\n       if (DECL_VOLATILE_MEMFUNC_P (decl))\n@@ -988,7 +988,7 @@ write_prefix (const tree node)\n     }\n \n   /* In G++ 3.2, the name of the template parameter was used.  */\n-  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM \n+  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM\n       && !abi_version_at_least (2))\n     G.need_abi_warning = true;\n \n@@ -1033,7 +1033,7 @@ write_template_prefix (const tree node)\n   else\n     {\n       gcc_assert (CLASSTYPE_TEMPLATE_ID_P (type));\n-  \n+\n       template = TYPE_TI_TEMPLATE (type);\n     }\n \n@@ -1085,10 +1085,10 @@ write_template_prefix (const tree node)\n }\n \n /* We don't need to handle thunks, vtables, or VTTs here.  Those are\n-   mangled through special entry points.  \n+   mangled through special entry points.\n \n     <unqualified-name>  ::= <operator-name>\n-\t\t\t::= <special-name>  \n+\t\t\t::= <special-name>\n \t\t\t::= <source-name>  */\n \n static void\n@@ -1102,9 +1102,9 @@ write_unqualified_name (const tree decl)\n     write_special_name_destructor (decl);\n   else if (DECL_NAME (decl) == NULL_TREE)\n     write_source_name (DECL_ASSEMBLER_NAME (decl));\n-  else if (DECL_CONV_FN_P (decl)) \n+  else if (DECL_CONV_FN_P (decl))\n     {\n-      /* Conversion operator. Handle it right here.  \n+      /* Conversion operator. Handle it right here.\n            <operator> ::= cv <type>  */\n       tree type;\n       if (decl_is_template_id (decl, NULL))\n@@ -1126,7 +1126,7 @@ write_unqualified_name (const tree decl)\n \toni = assignment_operator_name_info;\n       else\n \toni = operator_name_info;\n-      \n+\n       write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n     }\n   else\n@@ -1142,7 +1142,7 @@ write_conversion_operator_name (const tree type)\n   write_type (type);\n }\n \n-/* Non-terminal <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.  \n+/* Non-terminal <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.\n \n      <source-name> ::= </length/ number> <identifier>  */\n \n@@ -1172,11 +1172,11 @@ hwint_to_ascii (unsigned HOST_WIDE_INT number, const unsigned int base,\n {\n   static const char base_digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n   unsigned digits = 0;\n-  \n+\n   while (number)\n     {\n       unsigned HOST_WIDE_INT d = number / base;\n-      \n+\n       *--buffer = base_digits[number - d * base];\n       digits++;\n       number = d;\n@@ -1234,14 +1234,14 @@ write_integer_cst (const tree cst)\n \t representable.  */\n       chunk = 1000000000;\n       chunk_digits = 9;\n-      \n+\n       if (sizeof (HOST_WIDE_INT) >= 8)\n \t{\n \t  /* It is at least 64 bits, so 10^18 is representable.  */\n \t  chunk_digits = 18;\n \t  chunk *= chunk;\n \t}\n-      \n+\n       type = c_common_signed_or_unsigned_type (1, TREE_TYPE (cst));\n       base = build_int_cstu (type, chunk);\n       n = build_int_cst_wide (type,\n@@ -1269,11 +1269,11 @@ write_integer_cst (const tree cst)\n       while (!done);\n       write_chars (ptr, count);\n     }\n-  else \n+  else\n     {\n       /* A small num.  */\n       unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (cst);\n-      \n+\n       if (sign < 0)\n \t{\n \t  write_char ('n');\n@@ -1283,8 +1283,8 @@ write_integer_cst (const tree cst)\n     }\n }\n \n-/* Write out a floating-point literal.  \n-    \n+/* Write out a floating-point literal.\n+\n     \"Floating-point literals are encoded using the bit pattern of the\n     target processor's internal representation of that number, as a\n     fixed-length lowercase hexadecimal string, high-order bytes first\n@@ -1341,7 +1341,7 @@ write_real_cst (const tree value)\n \t format for REAL_VALUE_TYPE.  */\n       size_t i;\n       for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n-\twrite_number (((unsigned char *) &TREE_REAL_CST (value))[i], \n+\twrite_number (((unsigned char *) &TREE_REAL_CST (value))[i],\n \t\t      /*unsigned_p*/ 1,\n \t\t      /*base*/ 16);\n       G.need_abi_warning = 1;\n@@ -1360,13 +1360,13 @@ write_identifier (const char *identifier)\n }\n \n /* Handle constructor productions of non-terminal <special-name>.\n-   CTOR is a constructor FUNCTION_DECL. \n+   CTOR is a constructor FUNCTION_DECL.\n \n      <special-name> ::= C1   # complete object constructor\n                     ::= C2   # base object constructor\n                     ::= C3   # complete object allocating constructor\n \n-   Currently, allocating constructors are never used. \n+   Currently, allocating constructors are never used.\n \n    We also need to provide mangled names for the maybe-in-charge\n    constructor, so we treat it here too.  mangle_decl_string will\n@@ -1390,7 +1390,7 @@ write_special_name_constructor (const tree ctor)\n }\n \n /* Handle destructor productions of non-terminal <special-name>.\n-   DTOR is a destructor FUNCTION_DECL. \n+   DTOR is a destructor FUNCTION_DECL.\n \n      <special-name> ::= D0 # deleting (in-charge) destructor\n                     ::= D1 # complete object (in-charge) destructor\n@@ -1434,7 +1434,7 @@ discriminator_for_local_entity (tree entity)\n   else if (TREE_CODE (entity) == TYPE_DECL)\n     {\n       int ix;\n-      \n+\n       /* Scan the list of local classes.  */\n       entity = TREE_TYPE (entity);\n       for (ix = 0; ; ix++)\n@@ -1446,7 +1446,7 @@ discriminator_for_local_entity (tree entity)\n \t      && TYPE_CONTEXT (type) == TYPE_CONTEXT (entity))\n \t    ++discriminator;\n \t}\n-    }  \n+    }\n \n   return discriminator;\n }\n@@ -1463,7 +1463,7 @@ discriminator_for_string_literal (tree function ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-/*   <discriminator> := _ <number>   \n+/*   <discriminator> := _ <number>\n \n    The discriminator is used only for the second and later occurrences\n    of the same name within a single function. In this case <number> is\n@@ -1501,7 +1501,7 @@ write_local_name (const tree function, const tree local_entity,\n   if (TREE_CODE (entity) == STRING_CST)\n     {\n       write_char ('s');\n-      write_discriminator (discriminator_for_string_literal (function, \n+      write_discriminator (discriminator_for_string_literal (function,\n \t\t\t\t\t\t\t     entity));\n     }\n   else\n@@ -1514,7 +1514,7 @@ write_local_name (const tree function, const tree local_entity,\n     }\n }\n \n-/* Non-terminals <type> and <CV-qualifier>.  \n+/* Non-terminals <type> and <CV-qualifier>.\n \n      <type> ::= <builtin-type>\n             ::= <function-type>\n@@ -1528,11 +1528,11 @@ write_local_name (const tree function, const tree local_entity,\n             ::= R <type>    # reference-to\n             ::= C <type>    # complex pair (C 2000)\n             ::= G <type>    # imaginary (C 2000)     [not supported]\n-            ::= U <source-name> <type>   # vendor extended type qualifier \n+            ::= U <source-name> <type>   # vendor extended type qualifier\n \n    TYPE is a type node.  */\n \n-static void \n+static void\n write_type (tree type)\n {\n   /* This gets set to nonzero if TYPE turns out to be a (possibly\n@@ -1546,7 +1546,7 @@ write_type (tree type)\n \n   if (find_substitution (type))\n     return;\n-  \n+\n   if (write_CV_qualifiers_for_type (type) > 0)\n     /* If TYPE was CV-qualified, we just wrote the qualifiers; now\n        mangle the unqualified type.  The recursive call is needed here\n@@ -1639,7 +1639,7 @@ write_type (tree type)\n \n \tcase BOUND_TEMPLATE_TEMPLATE_PARM:\n \t  write_template_template_param (type);\n-\t  write_template_args \n+\t  write_template_args\n \t    (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n \t  break;\n \n@@ -1672,7 +1672,7 @@ write_CV_qualifiers_for_type (const tree type)\n \n        \"In cases where multiple order-insensitive qualifiers are\n        present, they should be ordered 'K' (closest to the base type),\n-       'V', 'r', and 'U' (farthest from the base type) ...\"  \n+       'V', 'r', and 'U' (farthest from the base type) ...\"\n \n      Note that we do not use cp_type_quals below; given \"const\n      int[3]\", the \"const\" is emitted with the \"int\", not with the\n@@ -1697,9 +1697,9 @@ write_CV_qualifiers_for_type (const tree type)\n   return num_qualifiers;\n }\n \n-/* Non-terminal <builtin-type>. \n+/* Non-terminal <builtin-type>.\n \n-     <builtin-type> ::= v   # void \n+     <builtin-type> ::= v   # void\n                     ::= b   # bool\n                     ::= w   # wchar_t\n                     ::= c   # char\n@@ -1712,16 +1712,16 @@ write_CV_qualifiers_for_type (const tree type)\n                     ::= l   # long\n                     ::= m   # unsigned long\n                     ::= x   # long long, __int64\n-                    ::= y   # unsigned long long, __int64  \n+                    ::= y   # unsigned long long, __int64\n                     ::= n   # __int128\n                     ::= o   # unsigned __int128\n                     ::= f   # float\n                     ::= d   # double\n-                    ::= e   # long double, __float80 \n+                    ::= e   # long double, __float80\n                     ::= g   # __float128          [not supported]\n                     ::= u <source-name>  # vendor extended type */\n \n-static void \n+static void\n write_builtin_type (tree type)\n {\n   switch (TREE_CODE (type))\n@@ -1849,7 +1849,7 @@ write_function_type (const tree type)\n        extern \"C\" function_t f; // Vice versa.\n \n      See [dcl.link].  */\n-  write_bare_function_type (type, /*include_return_type_p=*/1, \n+  write_bare_function_type (type, /*include_return_type_p=*/1,\n \t\t\t    /*decl=*/NULL);\n   write_char ('E');\n }\n@@ -1872,7 +1872,7 @@ write_bare_function_type (const tree type, const int include_return_type_p,\n     write_type (TREE_TYPE (type));\n \n   /* Now mangle the types of the arguments.  */\n-  write_method_parms (TYPE_ARG_TYPES (type), \n+  write_method_parms (TYPE_ARG_TYPES (type),\n \t\t      TREE_CODE (type) == METHOD_TYPE,\n \t\t      decl);\n }\n@@ -1894,10 +1894,10 @@ write_method_parms (tree parm_types, const int method_p, const tree decl)\n   int varargs_p = 1;\n \n   /* If this is a member function, skip the first arg, which is the\n-     this pointer.  \n+     this pointer.\n        \"Member functions do not encode the type of their implicit this\n-       parameter.\"  \n-  \n+       parameter.\"\n+\n      Similarly, there's no need to mangle artificial parameters, like\n      the VTT parameters for constructors and destructors.  */\n   if (method_p)\n@@ -1912,8 +1912,8 @@ write_method_parms (tree parm_types, const int method_p, const tree decl)\n \t}\n     }\n \n-  for (first_parm_type = parm_types; \n-       parm_types; \n+  for (first_parm_type = parm_types;\n+       parm_types;\n        parm_types = TREE_CHAIN (parm_types))\n     {\n       tree parm = TREE_VALUE (parm_types);\n@@ -1941,7 +1941,7 @@ write_method_parms (tree parm_types, const int method_p, const tree decl)\n \n /* <class-enum-type> ::= <name>  */\n \n-static void \n+static void\n write_class_enum_type (const tree type)\n {\n   write_name (TYPE_NAME (type), /*ignore_local_scope=*/0);\n@@ -1957,7 +1957,7 @@ write_template_args (tree args)\n {\n   int i;\n   int length = TREE_VEC_LENGTH (args);\n-  \n+\n   MANGLE_TRACE_TREE (\"template-args\", args);\n \n   write_char ('I');\n@@ -1973,7 +1973,7 @@ write_template_args (tree args)\n     }\n   for (i = 0; i < length; ++i)\n     write_template_arg (TREE_VEC_ELT (args, i));\n-  \n+\n   write_char ('E');\n }\n \n@@ -1983,7 +1983,7 @@ write_template_args (tree args)\n \n    <expr-primary> ::= <template-param>\n \t\t  ::= L <type> <value number> E  # literal\n-\t\t  ::= L <mangled-name> E         # external name  \n+\t\t  ::= L <mangled-name> E         # external name\n                   ::= sr <type> <unqualified-name>\n                   ::= sr <type> <unqualified-name> <template-args> */\n \n@@ -2016,7 +2016,7 @@ write_expression (tree expr)\n     }\n \n   /* Handle template parameters.  */\n-  if (code == TEMPLATE_TYPE_PARM \n+  if (code == TEMPLATE_TYPE_PARM\n       || code == TEMPLATE_TEMPLATE_PARM\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM\n       || code == TEMPLATE_PARM_INDEX)\n@@ -2035,7 +2035,7 @@ write_expression (tree expr)\n       write_mangled_name (expr, false);\n       write_char ('E');\n     }\n-  else if (TREE_CODE (expr) == SIZEOF_EXPR \n+  else if (TREE_CODE (expr) == SIZEOF_EXPR\n \t   && TYPE_P (TREE_OPERAND (expr, 0)))\n     {\n       write_string (\"st\");\n@@ -2095,7 +2095,7 @@ write_expression (tree expr)\n \t\telse if (assignment_operator_name_info[i].identifier\n \t\t\t == member)\n \t\t  {\n-\t\t    mangled_name \n+\t\t    mangled_name\n \t\t      = assignment_operator_name_info[i].mangled_name;\n \t\t    break;\n \t\t  }\n@@ -2156,7 +2156,7 @@ write_expression (tree expr)\n \t  write_expression (TREE_OPERAND (expr, 0));\n \t  break;\n \n-\t  \n+\n \t/* Handle pointers-to-members specially.  */\n \tcase SCOPE_REF:\n \t  write_type (TREE_OPERAND (expr, 0));\n@@ -2204,7 +2204,7 @@ write_expression (tree expr)\n     }\n }\n \n-/* Literal subcase of non-terminal <template-arg>.  \n+/* Literal subcase of non-terminal <template-arg>.\n \n      \"Literal arguments, e.g. \"A<42L>\", are encoded with their type\n      and value. Negative integer values are preceded with \"n\"; for\n@@ -2222,7 +2222,7 @@ write_template_arg_literal (const tree value)\n     case CONST_DECL:\n       write_integer_cst (DECL_INITIAL (value));\n       break;\n-      \n+\n     case INTEGER_CST:\n       gcc_assert (!same_type_p (TREE_TYPE (value), boolean_type_node)\n \t\t  || integer_zerop (value) || integer_onep (value));\n@@ -2236,11 +2236,11 @@ write_template_arg_literal (const tree value)\n     default:\n       gcc_unreachable ();\n     }\n-  \n+\n   write_char ('E');\n }\n \n-/* Non-terminal <template-arg>.  \n+/* Non-terminal <template-arg>.\n \n      <template-arg> ::= <type>                        # type\n                     ::= L <type> </value/ number> E   # literal\n@@ -2266,7 +2266,7 @@ write_template_arg (tree node)\n \t  code = TREE_CODE (node);\n \t}\n     }\n-  \n+\n   if (TREE_CODE (node) == NOP_EXPR\n       && TREE_CODE (TREE_TYPE (node)) == REFERENCE_TYPE)\n     {\n@@ -2291,7 +2291,7 @@ write_template_arg (tree node)\n   else if (DECL_P (node))\n     {\n       /* Until ABI version 2, non-type template arguments of\n-\t enumeration type were mangled using their names.  */ \n+\t enumeration type were mangled using their names.  */\n       if (code == CONST_DECL && !abi_version_at_least (2))\n \tG.need_abi_warning = 1;\n       write_char ('L');\n@@ -2332,9 +2332,9 @@ write_template_template_arg (const tree decl)\n }\n \n \n-/* Non-terminal <array-type>.  TYPE is an ARRAY_TYPE.  \n+/* Non-terminal <array-type>.  TYPE is an ARRAY_TYPE.\n \n-     <array-type> ::= A [</dimension/ number>] _ </element/ type>  \n+     <array-type> ::= A [</dimension/ number>] _ </element/ type>\n                   ::= A <expression> _ </element/ type>\n \n      \"Array types encode the dimension (number of elements) and the\n@@ -2375,7 +2375,7 @@ write_array_type (const tree type)\n \t    }\n \t  write_expression (max);\n \t}\n-      \n+\n     }\n   write_char ('_');\n   write_type (TREE_TYPE (type));\n@@ -2437,7 +2437,7 @@ write_template_param (const tree parm)\n }\n \n /*  <template-template-param>\n-                        ::= <template-param> \n+                        ::= <template-param>\n \t\t\t::= <substitution>  */\n \n static void\n@@ -2450,7 +2450,7 @@ write_template_template_param (const tree parm)\n      only the template.  */\n   if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n-      template \n+      template\n \t= TI_TEMPLATE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm));\n       if (find_substitution (template))\n \treturn;\n@@ -2463,7 +2463,7 @@ write_template_template_param (const tree parm)\n     add_substitution (template);\n }\n \n-/* Non-terminal <substitution>.  \n+/* Non-terminal <substitution>.\n \n       <substitution> ::= S <seq-id> _\n                      ::= S_  */\n@@ -2486,7 +2486,7 @@ start_mangling (const tree entity, const bool ident_p)\n {\n   G.entity = entity;\n   G.need_abi_warning = false;\n-  if (!ident_p) \n+  if (!ident_p)\n     {\n       obstack_free (&name_obstack, name_base);\n       mangle_obstack = &name_obstack;\n@@ -2549,7 +2549,7 @@ mangle_decl_string (const tree decl)\n     write_type (TREE_TYPE (decl));\n   else\n     write_mangled_name (decl, true);\n-  \n+\n   result = finish_mangling (/*warn=*/true);\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_decl_string = '%s'\\n\\n\", result);\n@@ -2562,7 +2562,7 @@ mangle_decl_string (const tree decl)\n static inline tree\n get_identifier_nocopy (const char *name)\n {\n-  hashnode ht_node = ht_lookup (ident_hash, (const unsigned char *) name, \n+  hashnode ht_node = ht_lookup (ident_hash, (const unsigned char *) name,\n \t\t\t\tstrlen (name), HT_ALLOCED);\n   return HT_IDENT_TO_GCC_IDENT (ht_node);\n }\n@@ -2572,7 +2572,7 @@ get_identifier_nocopy (const char *name)\n void\n mangle_decl (const tree decl)\n {\n-  SET_DECL_ASSEMBLER_NAME (decl, \n+  SET_DECL_ASSEMBLER_NAME (decl,\n \t\t\t   get_identifier_nocopy (mangle_decl_string (decl)));\n }\n \n@@ -2654,13 +2654,13 @@ mangle_vtt_for_type (const tree type)\n \n /* Return an identifier for a construction vtable group.  TYPE is\n    the most derived class in the hierarchy; BINFO is the base\n-   subobject for which this construction vtable group will be used.  \n+   subobject for which this construction vtable group will be used.\n \n    This mangling isn't part of the ABI specification; in the ABI\n    specification, the vtable group is dumped in the same COMDAT as the\n    main vtable, and is referenced only from that vtable, so it doesn't\n    need an external name.  For binary formats without COMDAT sections,\n-   though, we need external names for the vtable groups.  \n+   though, we need external names for the vtable groups.\n \n    We use the production\n \n@@ -2687,10 +2687,10 @@ mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n }\n \n /* Mangle a this pointer or result pointer adjustment.\n-   \n+\n    <call-offset> ::= h <fixed offset number> _\n \t\t ::= v <fixed offset number> _ <virtual offset number> _ */\n-   \n+\n static void\n mangle_call_offset (const tree fixed_offset, const tree virtual_offset)\n {\n@@ -2727,12 +2727,12 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n \t      tree virtual_offset)\n {\n   const char *result;\n-  \n+\n   start_mangling (fn_decl, /*ident_p=*/true);\n \n   write_string (\"_Z\");\n   write_char ('T');\n-  \n+\n   if (!this_adjusting)\n     {\n       /* Covariant thunk with no this adjustment */\n@@ -2797,16 +2797,16 @@ mangle_conv_op_name_for_type (const tree type)\n   void **slot;\n   tree identifier;\n \n-  if (conv_type_names == NULL) \n+  if (conv_type_names == NULL)\n     conv_type_names = htab_create_ggc (31, &hash_type, &compare_type, NULL);\n \n-  slot = htab_find_slot_with_hash (conv_type_names, type, \n+  slot = htab_find_slot_with_hash (conv_type_names, type,\n \t\t\t\t   (hashval_t) TYPE_UID (type), INSERT);\n   identifier = (tree)*slot;\n   if (!identifier)\n     {\n       char buffer[64];\n-      \n+\n        /* Create a unique name corresponding to TYPE.  */\n       sprintf (buffer, \"operator %lu\",\n \t       (unsigned long) htab_elements (conv_type_names));\n@@ -2821,7 +2821,7 @@ mangle_conv_op_name_for_type (const tree type)\n       IDENTIFIER_OPNAME_P (identifier) = 1;\n       IDENTIFIER_TYPENAME_P (identifier) = 1;\n     }\n-  \n+\n   return identifier;\n }\n "}, {"sha": "c5d68d6b684e2070187cb9cb5a164f480fe02547", "filename": "gcc/cp/method.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1,11 +1,11 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n-   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n@@ -89,22 +89,22 @@ make_thunk (tree function, bool this_adjusting,\n {\n   HOST_WIDE_INT d;\n   tree thunk;\n-  \n+\n   gcc_assert (TREE_CODE (function) == FUNCTION_DECL);\n   /* We can have this thunks to covariant thunks, but not vice versa.  */\n   gcc_assert (!DECL_THIS_THUNK_P (function));\n   gcc_assert (!DECL_RESULT_THUNK_P (function) || this_adjusting);\n-  \n+\n   /* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */\n   if (this_adjusting && virtual_offset)\n-    virtual_offset \n+    virtual_offset\n       = size_binop (MULT_EXPR,\n  \t\t    virtual_offset,\n   \t\t    convert (ssizetype,\n   \t\t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n-  \n+\n   d = tree_low_cst (fixed_offset, 0);\n-  \n+\n   /* See if we already have the thunk in question.  For this_adjusting\n      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it\n      will be a BINFO.  */\n@@ -118,7 +118,7 @@ make_thunk (tree function, bool this_adjusting,\n \t\t\t\t      virtual_offset)\n \t\t: THUNK_VIRTUAL_OFFSET (thunk) == virtual_offset)))\n       return thunk;\n-  \n+\n   /* All thunks must be created before FUNCTION is actually emitted;\n      the ABI requires that all thunks be emitted together with the\n      function to which they transfer control.  */\n@@ -132,7 +132,7 @@ make_thunk (tree function, bool this_adjusting,\n   DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (function);\n   cxx_dup_lang_specific_decl (thunk);\n   DECL_THUNKS (thunk) = NULL_TREE;\n-  \n+\n   DECL_CONTEXT (thunk) = DECL_CONTEXT (function);\n   TREE_READONLY (thunk) = TREE_READONLY (function);\n   TREE_THIS_VOLATILE (thunk) = TREE_THIS_VOLATILE (function);\n@@ -144,7 +144,7 @@ make_thunk (tree function, bool this_adjusting,\n   THUNK_FIXED_OFFSET (thunk) = d;\n   THUNK_VIRTUAL_OFFSET (thunk) = virtual_offset;\n   THUNK_ALIAS (thunk) = NULL_TREE;\n-  \n+\n   /* The thunk itself is not a constructor or destructor, even if\n      the thing it is thunking to is.  */\n   DECL_INTERFACE_KNOWN (thunk) = 1;\n@@ -163,7 +163,7 @@ make_thunk (tree function, bool this_adjusting,\n   DECL_DECLARED_INLINE_P (thunk) = 0;\n   /* Nor has it been deferred.  */\n   DECL_DEFERRED_FN (thunk) = 0;\n-  \n+\n   /* Add it to the list of thunks associated with FUNCTION.  */\n   TREE_CHAIN (thunk) = DECL_THUNKS (function);\n   DECL_THUNKS (function) = thunk;\n@@ -206,7 +206,7 @@ finish_thunk (tree thunk)\n \t    break;\n \t  }\n     }\n-  \n+\n   DECL_NAME (thunk) = name;\n   SET_DECL_ASSEMBLER_NAME (thunk, name);\n }\n@@ -234,7 +234,7 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       ptr = save_expr (ptr);\n       /* The vptr is always at offset zero in the object.  */\n       vtable = build1 (NOP_EXPR,\n-\t\t       build_pointer_type (build_pointer_type \n+\t\t       build_pointer_type (build_pointer_type\n \t\t\t\t\t   (vtable_entry_type)),\n \t\t       ptr);\n       /* Form the vtable address.  */\n@@ -246,7 +246,7 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       /* Adjust the `this' pointer.  */\n       ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable);\n     }\n-  \n+\n   if (!this_adjusting)\n     /* Adjust the pointer by the constant.  */\n     ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n@@ -332,7 +332,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n-  \n+\n   function = THUNK_TARGET (thunk_fndecl);\n   if (DECL_RESULT (thunk_fndecl))\n     /* We already turned this thunk into an ordinary function.\n@@ -342,7 +342,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   if (DECL_THUNK_P (function))\n     /* The target is itself a thunk, process it now.  */\n     use_thunk (function, emit_p);\n-  \n+\n   /* Thunks are always addressable; they only appear in vtables.  */\n   TREE_ADDRESSABLE (thunk_fndecl) = 1;\n \n@@ -370,7 +370,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n     }\n   else\n     virtual_value = 0;\n-  \n+\n   /* And, if we need to emit the thunk, it's used.  */\n   mark_used (thunk_fndecl);\n   /* This thunk is actually defined.  */\n@@ -379,7 +379,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n      rewrite.  */\n   TREE_PUBLIC (thunk_fndecl) = TREE_PUBLIC (function);\n   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);\n-  DECL_VISIBILITY_SPECIFIED (thunk_fndecl) \n+  DECL_VISIBILITY_SPECIFIED (thunk_fndecl)\n     = DECL_VISIBILITY_SPECIFIED (function);\n   if (flag_weak && TREE_PUBLIC (thunk_fndecl))\n     comdat_linkage (thunk_fndecl);\n@@ -423,7 +423,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   a = nreverse (t);\n   DECL_ARGUMENTS (thunk_fndecl) = a;\n   BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) = a;\n-  \n+\n   if (this_adjusting\n       && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n \t\t\t\t\t      virtual_value, alias))\n@@ -468,15 +468,15 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       if (this_adjusting)\n \tt = thunk_adjust (t, /*this_adjusting=*/1,\n \t\t\t  fixed_offset, virtual_offset);\n-      \n+\n       /* Build up the call to the real function.  */\n       t = tree_cons (NULL_TREE, t, NULL_TREE);\n       for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n \tt = tree_cons (NULL_TREE, a, t);\n       t = nreverse (t);\n       t = build_call (alias, t);\n       CALL_FROM_THUNK_P (t) = 1;\n-      \n+\n       if (VOID_TYPE_P (TREE_TYPE (t)))\n \tfinish_expr_stmt (t);\n       else\n@@ -494,7 +494,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t\t  t = save_expr (t);\n \t\t  cond = cp_convert (boolean_type_node, t);\n \t\t}\n-\t      \n+\n \t      t = thunk_adjust (t, /*this_adjusting=*/0,\n \t\t\t\tfixed_offset, virtual_offset);\n \t      if (cond)\n@@ -560,7 +560,7 @@ do_build_copy_constructor (tree fndecl)\n       for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n \t   VEC_iterate (tree, vbases, i, binfo); i++)\n \t{\n-\t  member_init_list \n+\t  member_init_list\n \t    = tree_cons (binfo,\n \t\t\t build_tree_list (NULL_TREE,\n \t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n@@ -572,9 +572,9 @@ do_build_copy_constructor (tree fndecl)\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n \t  if (BINFO_VIRTUAL_P (base_binfo))\n-\t    continue; \n+\t    continue;\n \n-\t  member_init_list \n+\t  member_init_list\n \t    = tree_cons (base_binfo,\n \t\t\t build_tree_list (NULL_TREE,\n \t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n@@ -611,12 +611,12 @@ do_build_copy_constructor (tree fndecl)\n \t  if (TREE_CODE (expr_type) != REFERENCE_TYPE)\n \t    {\n \t      int quals = cvquals;\n-\t      \n+\n \t      if (DECL_MUTABLE_P (field))\n \t\tquals &= ~TYPE_QUAL_CONST;\n \t      expr_type = cp_build_qualified_type (expr_type, quals);\n \t    }\n-\t  \n+\n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \t  init = build_tree_list (NULL_TREE, init);\n \n@@ -661,18 +661,18 @@ do_build_assign_ref (tree fndecl)\n \t     explicitly since the base class may be ambiguous.  */\n \t  converted_parm = build_base_path (PLUS_EXPR, parm, base_binfo, 1);\n \t  /* Call the base class assignment operator.  */\n-\t  finish_expr_stmt \n-\t    (build_special_member_call (current_class_ref, \n+\t  finish_expr_stmt\n+\t    (build_special_member_call (current_class_ref,\n \t\t\t\t\tansi_assopname (NOP_EXPR),\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, \n+\t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t converted_parm),\n \t\t\t\t\tbase_binfo,\n \t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL));\n \t}\n \n       /* Assign to each of the non-static data members.  */\n-      for (fields = TYPE_FIELDS (current_class_type); \n-\t   fields; \n+      for (fields = TYPE_FIELDS (current_class_type);\n+\t   fields;\n \t   fields = TREE_CHAIN (fields))\n \t{\n \t  tree comp = current_class_ref;\n@@ -685,7 +685,7 @@ do_build_assign_ref (tree fndecl)\n \t    continue;\n \n \t  expr_type = TREE_TYPE (field);\n-\t  \n+\n \t  if (CP_TYPE_CONST_P (expr_type))\n \t    {\n               error (\"non-static const member %q#D, can't use default \"\n@@ -712,13 +712,13 @@ do_build_assign_ref (tree fndecl)\n \t    continue;\n \n \t  comp = build3 (COMPONENT_REF, expr_type, comp, field, NULL_TREE);\n-\t  \n+\n \t  /* Compute the type of init->field  */\n \t  quals = cvquals;\n \t  if (DECL_MUTABLE_P (field))\n \t    quals &= ~TYPE_QUAL_CONST;\n \t  expr_type = cp_build_qualified_type (expr_type, quals);\n-\t  \n+\n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \n \t  if (DECL_NAME (field))\n@@ -749,7 +749,7 @@ synthesize_method (tree fndecl)\n      deferred, and thus have saved where we were first needed.  */\n   DECL_SOURCE_LOCATION (fndecl)\n     = DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (fndecl)));\n-  \n+\n   /* If we've been asked to synthesize a clone, just synthesize the\n      cloned function instead.  Doing so will automatically fill in the\n      body for the clone.  */\n@@ -832,27 +832,27 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n       if (fn)\n         {\n           tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-          \n+\n           raises = merge_exception_specifiers (raises, fn_raises);\n         }\n     }\n   for (; fields; fields = TREE_CHAIN (fields))\n     {\n       tree type = TREE_TYPE (fields);\n       tree fn;\n-      \n+\n       if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n         continue;\n       while (TREE_CODE (type) == ARRAY_TYPE)\n   \ttype = TREE_TYPE (type);\n       if (TREE_CODE (type) != RECORD_TYPE)\n         continue;\n-      \n+\n       fn = (*extractor) (type, client);\n       if (fn)\n         {\n           tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-          \n+\n           raises = merge_exception_specifiers (raises, fn_raises);\n         }\n     }\n@@ -873,7 +873,7 @@ static tree\n locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n   tree fns;\n-  \n+\n   if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n     return NULL_TREE;\n \n@@ -886,7 +886,7 @@ locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n     {\n       tree fn = OVL_CURRENT (fns);\n       tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-      \n+\n       if (sufficient_parms_p (TREE_CHAIN (parms)))\n         return fn;\n     }\n@@ -910,7 +910,7 @@ locate_copy (tree type, void *client_)\n   tree fns;\n   tree best = NULL_TREE;\n   bool excess_p = false;\n-  \n+\n   if (client->name)\n     {\n       int ix;\n@@ -936,7 +936,7 @@ locate_copy (tree type, void *client_)\n       tree src_type;\n       int excess;\n       int quals;\n-      \n+\n       parms = TREE_CHAIN (parms);\n       if (!parms)\n         continue;\n@@ -1022,7 +1022,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     case sfk_assignment_operator:\n     {\n       struct copy_data data;\n-      \n+\n       data.name = NULL;\n       data.quals = 0;\n       if (kind == sfk_assignment_operator)\n@@ -1121,7 +1121,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n   add_method (type, fn, NULL_TREE);\n   /* Add it to TYPE_METHODS.  */\n-  if (sfk == sfk_destructor \n+  if (sfk == sfk_destructor\n       && DECL_VIRTUAL_P (fn)\n       && abi_version_at_least (2))\n     /* The ABI requires that a virtual destructor go at the end of the\n@@ -1131,7 +1131,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n     {\n       /* G++ 3.2 put the implicit destructor at the *beginning* of the\n \t TYPE_METHODS list, which cause the destructor to be emitted\n-\t in an incorrect location in the vtable.  */ \n+\t in an incorrect location in the vtable.  */\n       if (warn_abi && DECL_VIRTUAL_P (fn))\n \twarning (0, \"vtable layout for class %qT may not be ABI-compliant\"\n \t\t \"and may change in a future version of GCC due to \""}, {"sha": "c03b48b356a23f5acef3546bbd7e0db5faaecad6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -300,7 +300,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n {\n   cp_class_binding *cb;\n   cxx_binding *binding;\n-  \n+\n   if (VEC_length (cp_class_binding, scope->class_shadowed))\n     {\n       cp_class_binding *old_base;\n@@ -309,7 +309,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n \t{\n \t  /* Fixup the current bindings, as they might have moved.  */\n \t  size_t i;\n-\t  \n+\n \t  for (i = 0;\n \t       VEC_iterate (cp_class_binding, scope->class_shadowed, i, cb);\n \t       i++)\n@@ -325,7 +325,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n     }\n   else\n     cb = VEC_safe_push (cp_class_binding, gc, scope->class_shadowed, NULL);\n-  \n+\n   cb->identifier = name;\n   binding = &cb->base;\n   binding->scope = scope;\n@@ -348,7 +348,7 @@ push_binding (tree id, tree decl, cxx_scope* level)\n     }\n   else\n     binding = new_class_binding (id, decl, /*type=*/NULL_TREE, level);\n-\t\t\t      \n+\n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n   INHERITED_VALUE_BINDING_P (binding) = 0;\n@@ -430,7 +430,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n   else if (/* BVAL is null when push_class_level_binding moves an\n \t      inherited type-binding out of the way to make room for a\n \t      new value binding.  */\n-\t   !bval \n+\t   !bval\n \t   /* BVAL is error_mark_node when DECL's name has been used\n \t      in a non-class scope prior declaration.  In that case,\n \t      we should have already issued a diagnostic; for graceful\n@@ -469,7 +469,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n \n \t In a given scope, a typedef specifier can be used to redefine\n \t the name of any type declared in that scope to refer to the\n-\t type to which it already refers.  \n+\t type to which it already refers.\n \n        However, in class scopes, this rule does not apply due to the\n        stricter language in [class.mem] prohibiting redeclarations of\n@@ -496,7 +496,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n \t   && DECL_NAMESPACE_ALIAS (bval)\n \t   && ORIGINAL_NAMESPACE (bval) == ORIGINAL_NAMESPACE (decl))\n     /* [namespace.alias]\n-       \n+\n       In a declarative region, a namespace-alias-definition can be\n       used to redefine a namespace-alias declared in that declarative\n       region to refer only to the namespace to which it already\n@@ -517,7 +517,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n static void\n add_decl_to_level (tree decl, cxx_scope *b)\n {\n-  if (TREE_CODE (decl) == NAMESPACE_DECL \n+  if (TREE_CODE (decl) == NAMESPACE_DECL\n       && !DECL_NAMESPACE_ALIAS (decl))\n     {\n       TREE_CHAIN (decl) = b->namespaces;\n@@ -528,7 +528,7 @@ add_decl_to_level (tree decl, cxx_scope *b)\n       TREE_CHAIN (decl) = b->vtables;\n       b->vtables = decl;\n     }\n-  else       \n+  else\n     {\n       /* We build up the list in reverse order, and reverse it later if\n          necessary.  */\n@@ -537,7 +537,7 @@ add_decl_to_level (tree decl, cxx_scope *b)\n       b->names_size++;\n \n       /* If appropriate, add decl to separate list of statics.  We\n-\t include extern variables because they might turn out to be \n+\t include extern variables because they might turn out to be\n \t static later.  It's OK for this list to contain a few false\n \t positives.  */\n       if (b->kind == sk_namespace)\n@@ -698,7 +698,7 @@ pushdecl (tree x)\n \t  else\n \t    {\n \t      tree olddecl = duplicate_decls (x, t);\n-\t      \n+\n \t      /* If the redeclaration failed, we can stop at this\n \t\t point.  */\n \t      if (olddecl == error_mark_node)\n@@ -717,9 +717,9 @@ pushdecl (tree x)\n \t\t{\n \t\t  /* A redeclaration of main, but not a duplicate of the\n \t\t     previous one.\n-\t\t     \n+\n \t\t     [basic.start.main]\n-\t\t     \n+\n \t\t     This function shall not be overloaded.  */\n \t\t  cp_error_at (\"invalid redeclaration of %qD\", t);\n \t\t  error (\"as %qD\", x);\n@@ -958,7 +958,7 @@ pushdecl (tree x)\n \t\t\t\t\t/*want_type=*/false);\n \t      else\n \t\tmember = NULL_TREE;\n-\t\t  \n+\n \t      if (member && !TREE_STATIC (member))\n \t\t{\n \t\t  /* Location of previous decl is not useful in this case.  */\n@@ -1228,7 +1228,7 @@ cxx_scope *\n begin_scope (scope_kind kind, tree entity)\n {\n   cxx_scope *scope;\n-  \n+\n   /* Reuse or create a struct for this binding level.  */\n   if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n     {\n@@ -1246,7 +1246,7 @@ begin_scope (scope_kind kind, tree entity)\n     case sk_cleanup:\n       scope->keep = true;\n       break;\n-      \n+\n     case sk_template_spec:\n       scope->explicit_spec_p = true;\n       kind = sk_template_parms;\n@@ -1296,7 +1296,7 @@ leave_scope (void)\n   /* We cannot leave a scope, if there are none left.  */\n   if (NAMESPACE_LEVEL (global_namespace))\n     gcc_assert (!global_scope_p (scope));\n-  \n+\n   if (ENABLE_SCOPE_CHECKING)\n     {\n       indent (--binding_depth);\n@@ -1524,9 +1524,9 @@ print_binding_level (struct cp_binding_level* lvl)\n       size_t i;\n       cp_class_binding *b;\n       fprintf (stderr, \" class-shadowed:\");\n-      for (i = 0; \n+      for (i = 0;\n \t   VEC_iterate(cp_class_binding, lvl->class_shadowed, i, b);\n-\t   ++i) \n+\t   ++i)\n \tfprintf (stderr, \" %s \", IDENTIFIER_POINTER (b->identifier));\n       fprintf (stderr, \"\\n\");\n     }\n@@ -1635,7 +1635,7 @@ set_identifier_type_value_with_scope (tree id, tree decl, cxx_scope *b)\n \tsupplement_binding (binding, decl);\n       else\n \tbinding->value = decl;\n-      \n+\n       /* Store marker instead of real type.  */\n       type = global_type_node;\n     }\n@@ -1684,10 +1684,10 @@ constructor_name_p (tree name, tree type)\n \n   if (!name)\n     return false;\n-  \n+\n   if (TREE_CODE (name) != IDENTIFIER_NODE)\n     return false;\n-  \n+\n   ctor_name = constructor_name_full (type);\n   if (name == ctor_name)\n     return true;\n@@ -1713,7 +1713,7 @@ make_anon_name (void)\n   return get_identifier (buf);\n }\n \n-/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */ \n+/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */\n \n static inline cxx_binding *\n find_binding (cxx_scope *scope, cxx_binding *binding)\n@@ -2034,7 +2034,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n   /* It is impossible to overload a built-in function; any explicit\n      declaration eliminates the built-in declaration.  So, if OLDVAL\n      is a built-in, then we can just pretend it isn't there.  */\n-  if (oldval \n+  if (oldval\n       && TREE_CODE (oldval) == FUNCTION_DECL\n       && DECL_ANTICIPATED (oldval))\n     oldval = NULL_TREE;\n@@ -2094,7 +2094,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t     scope.  */\n \t  if (tmp1)\n \t    continue;\n-\t    \n+\n \t  /* If we are adding to an existing OVERLOAD, then we no\n \t     longer know the type of the set of functions.  */\n \t  if (*newval && TREE_CODE (*newval) == OVERLOAD)\n@@ -2113,7 +2113,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t  OVL_USED (*newval) = 1;\n \t}\n     }\n-  else \n+  else\n     {\n       *newval = decls.value;\n       if (oldval && !decls_match (*newval, oldval))\n@@ -2164,9 +2164,9 @@ do_local_using_decl (tree decl, tree scope, tree name)\n \t    term = OVL_FUNCTION (oldval);\n \t  else\n \t    term = oldval;\n-\t  for (fn = newval; fn && OVL_CURRENT (fn) != term; \n+\t  for (fn = newval; fn && OVL_CURRENT (fn) != term;\n \t       fn = OVL_NEXT (fn))\n-\t    push_overloaded_decl (OVL_CURRENT (fn), \n+\t    push_overloaded_decl (OVL_CURRENT (fn),\n \t\t\t\t  PUSH_LOCAL | PUSH_USING);\n \t}\n       else\n@@ -2194,7 +2194,7 @@ is_ancestor (tree root, tree child)\n \t       || CLASS_TYPE_P (root)));\n   gcc_assert ((TREE_CODE (child) == NAMESPACE_DECL\n \t       || CLASS_TYPE_P (child)));\n-  \n+\n   /* The global namespace encloses everything.  */\n   if (root == global_namespace)\n     return true;\n@@ -2299,7 +2299,7 @@ push_inner_scope_r (tree outer, tree inner)\n    pushing name into scope.  In case a template parameter scope is present,\n    namespace is pushed under the template parameter scope according to\n    name lookup rule in 14.6.1/6.\n-   \n+\n    Return the former current scope suitable for pop_inner_scope.  */\n \n tree\n@@ -2515,7 +2515,7 @@ get_class_binding (tree name, cxx_scope *scope)\n     ;\n   else if (value_binding)\n     {\n-      if (TREE_CODE (value_binding) == TREE_LIST \n+      if (TREE_CODE (value_binding) == TREE_LIST\n \t  && TREE_TYPE (value_binding) == error_mark_node)\n \t/* NAME is ambiguous.  */\n \t;\n@@ -2528,8 +2528,8 @@ get_class_binding (tree name, cxx_scope *scope)\n      new binding object.  */\n   if (type_binding || value_binding)\n     {\n-      binding = new_class_binding (name, \n-\t\t\t\t   value_binding, \n+      binding = new_class_binding (name,\n+\t\t\t\t   value_binding,\n \t\t\t\t   type_binding,\n \t\t\t\t   scope);\n       /* This is a class-scope binding, not a block-scope binding.  */\n@@ -2541,7 +2541,7 @@ get_class_binding (tree name, cxx_scope *scope)\n \n   return binding;\n }\n-\t\t   \n+\n /* Make the declaration(s) of X appear in CLASS scope under the name\n    NAME.  Returns true if the binding is valid.  */\n \n@@ -2563,7 +2563,7 @@ push_class_level_binding (tree name, tree x)\n   /* We could have been passed a tree list if this is an ambiguous\n      declaration. If so, pull the declaration out because\n      check_template_shadow will not handle a TREE_LIST.  */\n-  if (TREE_CODE (decl) == TREE_LIST \n+  if (TREE_CODE (decl) == TREE_LIST\n       && TREE_TYPE (decl) == error_mark_node)\n     decl = TREE_VALUE (decl);\n \n@@ -2693,7 +2693,7 @@ do_class_using_decl (tree scope, tree name)\n   tree value, decl, binfo;\n   base_kind b_kind;\n   bool dependent_p;\n-  \n+\n   if (!scope || !TYPE_P (scope))\n     {\n       error (\"using-declaration for non-member at class scope\");\n@@ -2712,13 +2712,13 @@ do_class_using_decl (tree scope, tree name)\n       else\n \tb_kind = bk_proper_base;\n     }\n-  \n+\n   if (b_kind < bk_proper_base)\n     {\n       error_not_base_type (scope, current_class_type);\n       return NULL_TREE;\n     }\n-  \n+\n   /* Make sure the name is not invalid */\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n@@ -2745,7 +2745,7 @@ do_class_using_decl (tree scope, tree name)\n   if (!dependent_p)\n     {\n       decl = lookup_member (binfo, name, 0, false);\n-  \n+\n       if (!decl)\n \t{\n \t  error (\"no members matching %<%T::%D%> in %q#T\", scope, name, scope);\n@@ -2811,18 +2811,18 @@ void\n set_decl_namespace (tree decl, tree scope, bool friendp)\n {\n   tree old;\n-  \n+\n   /* Get rid of namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n-  \n+\n   /* It is ok for friends to be qualified in parallel space.  */\n   if (!friendp && !is_ancestor (current_namespace, scope))\n     error (\"declaration of %qD not in a namespace surrounding %qD\",\n            decl, scope);\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n \n-  /* Writing \"int N::i\" to declare a variable within \"N\" is invalid.  */ \n-  if (scope == current_namespace) \n+  /* Writing \"int N::i\" to declare a variable within \"N\" is invalid.  */\n+  if (scope == current_namespace)\n     {\n       if (at_namespace_scope_p ())\n \terror (\"explicit qualification in declaration of `%D'\",\n@@ -2862,7 +2862,7 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n       return;\n  complain:\n   error (\"%qD should have been declared inside %qD\", decl, scope);\n-} \n+}\n \n /* Return the namespace where the current declaration is declared.  */\n \n@@ -2878,7 +2878,7 @@ current_decl_namespace (void)\n     result = decl_namespace_context (current_class_type);\n   else if (current_function_decl)\n     result = decl_namespace_context (current_function_decl);\n-  else \n+  else\n     result = current_namespace;\n   return result;\n }\n@@ -2895,7 +2895,7 @@ push_namespace (tree name)\n   bool anon = !name;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  \n+\n   /* We should not get here if the global_namespace is not yet constructed\n      nor if NAME designates the global namespace:  The global scope is\n      constructed elsewhere.  */\n@@ -3017,7 +3017,7 @@ pop_decl_namespace (void)\n   decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n }\n \n-/* Return the namespace that is the common ancestor \n+/* Return the namespace that is the common ancestor\n    of two given namespaces.  */\n \n static tree\n@@ -3045,7 +3045,7 @@ do_namespace_alias (tree alias, tree namespace)\n   namespace = ORIGINAL_NAMESPACE (namespace);\n \n   /* Build the alias.  */\n-  alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n+  alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);\n   DECL_NAMESPACE_ALIAS (alias) = namespace;\n   DECL_EXTERNAL (alias) = 1;\n   DECL_CONTEXT (alias) = FROB_CONTEXT (current_scope ());\n@@ -3104,7 +3104,7 @@ pushdecl_namespace_level (tree x)\n /* Insert USED into the using list of USER. Set INDIRECT_flag if this\n    directive is not directly from the source. Also find the common\n    ancestor and let our users know about the new namespace */\n-static void \n+static void\n add_using_namespace (tree user, tree used, bool indirect)\n {\n   tree t;\n@@ -3129,8 +3129,8 @@ add_using_namespace (tree user, tree used, bool indirect)\n     }\n \n   /* Add used to the user's using list.  */\n-  DECL_NAMESPACE_USING (user) \n-    = tree_cons (used, namespace_ancestor (user, used), \n+  DECL_NAMESPACE_USING (user)\n+    = tree_cons (used, namespace_ancestor (user, used),\n \t\t DECL_NAMESPACE_USING (user));\n \n   TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n@@ -3162,7 +3162,7 @@ do_toplevel_using_decl (tree decl, tree scope, tree name)\n   decl = validate_nonmember_using_decl (decl, scope, name);\n   if (decl == NULL_TREE)\n     return;\n-  \n+\n   binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n \n   oldval = binding->value;\n@@ -3191,7 +3191,7 @@ do_using_directive (tree namespace)\n \n   if (building_stmt_tree ())\n     add_stmt (build_stmt (USING_STMT, namespace));\n-  \n+\n   /* using namespace A::B::C; */\n   if (TREE_CODE (namespace) == SCOPE_REF)\n       namespace = TREE_OPERAND (namespace, 1);\n@@ -3221,7 +3221,7 @@ do_using_directive (tree namespace)\n       if (current_namespace != global_namespace)\n \tcontext = current_namespace;\n     }\n-      \n+\n   /* Emit debugging info.  */\n   if (!processing_template_decl)\n     (*debug_hooks->imported_module_or_decl) (namespace, context);\n@@ -3311,12 +3311,12 @@ merge_functions (tree s1, tree s2)\n \t     need to add it again.  For `extern \"C\"' functions, we\n \t     might have two FUNCTION_DECLs for the same function, in\n \t     different namespaces; again, we only need one of them.  */\n-\t  if (fn1 == fn2 \n+\t  if (fn1 == fn2\n \t      || (DECL_EXTERN_C_P (fn1) && DECL_EXTERN_C_P (fn2)\n \t\t  && DECL_NAME (fn1) == DECL_NAME (fn2)))\n \t    break;\n \t}\n-      \n+\n       /* If we exhausted all of the functions in S1, FN2 is new.  */\n       if (!fns1)\n \ts1 = build_overload (fn2, s1);\n@@ -3368,7 +3368,7 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n         if (LOOKUP_QUALIFIERS_ONLY (flags))\n           val = NULL_TREE;\n       }\n-        \n+\n   if (!old->value)\n     old->value = val;\n   else if (val && val != old->value)\n@@ -3451,7 +3451,7 @@ qualify_lookup (tree val, int flags)\n   return true;\n }\n \n-/* Given a lookup that returned VAL, decide if we want to ignore it or \n+/* Given a lookup that returned VAL, decide if we want to ignore it or\n    not based on DECL_ANTICIPATED_P.  */\n \n bool\n@@ -3564,7 +3564,7 @@ select_decl (const struct scope_binding *binding, int flags)\n   if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n     val = binding->type;\n   /* Don't return non-types if we really prefer types.  */\n-  else if (val && LOOKUP_TYPES_ONLY (flags) \n+  else if (val && LOOKUP_TYPES_ONLY (flags)\n \t   && ! DECL_DECLARES_TYPE_P (val))\n     val = NULL_TREE;\n \n@@ -3633,7 +3633,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \n /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n    or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type\n-   bindings.  \n+   bindings.\n \n    Returns a DECL (or OVERLOAD, or BASELINK) representing the\n    declaration found.  If no suitable declaration can be found,\n@@ -3768,7 +3768,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n    CLASS_P is false, then class bindings are ignored.  */\n \n cxx_binding *\n-outer_binding (tree name, \n+outer_binding (tree name,\n \t       cxx_binding *binding,\n \t       bool class_p)\n {\n@@ -3795,10 +3795,10 @@ outer_binding (tree name,\n   if (class_p)\n     while (scope && scope != outer_scope && scope->kind != sk_namespace)\n       {\n-\tif (scope->kind == sk_class) \n+\tif (scope->kind == sk_class)\n \t  {\n \t    cxx_binding *class_binding;\n-\t    \n+\n \t    class_binding = get_class_binding (name, scope);\n \t    if (class_binding)\n \t      {\n@@ -3856,22 +3856,22 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n      operators.  */\n-  if (IDENTIFIER_TYPENAME_P (name)) \n+  if (IDENTIFIER_TYPENAME_P (name))\n     {\n       struct cp_binding_level *level;\n \n-      for (level = current_binding_level; \n+      for (level = current_binding_level;\n \t   level && level->kind != sk_namespace;\n \t   level = level->level_chain)\n \t{\n \t  tree class_type;\n \t  tree operators;\n-\t  \n-\t  /* A conversion operator can only be declared in a class \n+\n+\t  /* A conversion operator can only be declared in a class\n \t     scope.  */\n \t  if (level->kind != sk_class)\n \t    continue;\n-\t  \n+\n \t  /* Lookup the conversion operator in the class.  */\n \t  class_type = level->this_entity;\n \t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n@@ -3895,11 +3895,11 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \t iter = outer_binding (name, iter, !nonclass))\n       {\n \ttree binding;\n-\t\n+\n \t/* Skip entities we don't want.  */\n \tif (LOCAL_BINDING_P (iter) ? !block_p : nonclass)\n \t  continue;\n-\t\n+\n \t/* If this is the kind of thing we're looking for, we're done.  */\n \tif (qualify_lookup (iter->value, flags)\n \t    && !hidden_name_p (iter->value))\n@@ -3910,7 +3910,7 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \t  binding = iter->type;\n \telse\n \t  binding = NULL_TREE;\n-\t\n+\n \tif (binding)\n \t  {\n \t    val = binding;\n@@ -3941,17 +3941,17 @@ lookup_name_nonclass (tree name)\n tree\n lookup_function_nonclass (tree name, tree args, bool block_p)\n {\n-  return \n-    lookup_arg_dependent (name, \n-\t\t\t  lookup_name_real (name, 0, 1, block_p, 0, \n+  return\n+    lookup_arg_dependent (name,\n+\t\t\t  lookup_name_real (name, 0, 1, block_p, 0,\n \t\t\t\t\t    LOOKUP_COMPLAIN),\n \t\t\t  args);\n }\n \n tree\n lookup_name (tree name, int prefer_type)\n {\n-  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true, \n+  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true,\n \t\t\t   0, LOOKUP_COMPLAIN);\n }\n \n@@ -3964,7 +3964,7 @@ lookup_name (tree name, int prefer_type)\n    Unlike lookup_name_real, we make sure that NAME is actually\n    declared in the desired scope, not from inheritance, nor using\n    directive.  For using declaration, there is DR138 still waiting\n-   to be resolved.  Hidden name coming from earlier an friend \n+   to be resolved.  Hidden name coming from earlier an friend\n    declaration is also returned.\n \n    A TYPE_DECL best matching the NAME is returned.  Catching error\n@@ -3984,9 +3984,9 @@ lookup_type_scope (tree name, tag_scope scope)\n   for (; iter; iter = outer_binding (name, iter, /*class_p=*/ true))\n     {\n       /* Check if this is the kind of thing we're looking for.\n-\t If SCOPE is TS_CURRENT, also make sure it doesn't come from \n+\t If SCOPE is TS_CURRENT, also make sure it doesn't come from\n \t base class.  For ITER->VALUE, we can simply use\n-\t INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use \n+\t INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use\n \t our own check.\n \n \t We check ITER->TYPE before ITER->VALUE in order to handle\n@@ -4021,7 +4021,7 @@ lookup_type_scope (tree name, tag_scope scope)\n \t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n \t    val = iter->value;\n \t}\n-\t\n+\n     }\n \n   /* Type found, check if it is in the allowed scopes, ignoring cleanup\n@@ -4151,7 +4151,7 @@ add_function (struct arg_lookup *k, tree fn)\n      case.  */\n \n   /* We must find only functions, or exactly one non-function.  */\n-  if (!k->functions) \n+  if (!k->functions)\n     k->functions = fn;\n   else if (fn == k->functions)\n     ;\n@@ -4219,15 +4219,15 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n        value = TREE_CHAIN (value))\n     if (arg_assoc_namespace (k, TREE_PURPOSE (value)))\n       return true;\n-  \n+\n   value = namespace_binding (k->name, scope);\n   if (!value)\n     return false;\n \n   for (; value; value = OVL_NEXT (value))\n     if (add_function (k, OVL_CURRENT (value)))\n       return true;\n-  \n+\n   return false;\n }\n \n@@ -4260,7 +4260,7 @@ arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n       if (TREE_CODE (ctx) == NAMESPACE_DECL)\n         return arg_assoc_namespace (k, ctx);\n       /* Otherwise, it must be member template.  */\n-      else \n+      else\n         return arg_assoc_class (k, ctx);\n     }\n   /* It's not a template template argument, but it is a type template\n@@ -4280,7 +4280,7 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n {\n   tree list, friends, context;\n   int i;\n-  \n+\n   /* Backend build structures, such as __builtin_va_list, aren't\n      affected by all this.  */\n   if (!CLASS_TYPE_P (type))\n@@ -4289,7 +4289,7 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n   if (purpose_member (type, k->classes))\n     return false;\n   k->classes = tree_cons (type, NULL_TREE, k->classes);\n-  \n+\n   context = decl_namespace_context (type);\n   if (arg_assoc_namespace (k, context))\n     return true;\n@@ -4298,18 +4298,18 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n     {\n       /* Process baseclasses.  */\n       tree binfo, base_binfo;\n-      \n+\n       for (binfo = TYPE_BINFO (type), i = 0;\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \tif (arg_assoc_class (k, BINFO_TYPE (base_binfo)))\n \t  return true;\n     }\n-  \n+\n   /* Process friends.  */\n-  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n+  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list;\n        list = TREE_CHAIN (list))\n     if (k->name == FRIEND_NAME (list))\n-      for (friends = FRIEND_DECLS (list); friends; \n+      for (friends = FRIEND_DECLS (list); friends;\n \t   friends = TREE_CHAIN (friends))\n \t{\n \t  tree fn = TREE_VALUE (friends);\n@@ -4328,11 +4328,11 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n \t}\n \n   /* Process template arguments.  */\n-  if (CLASSTYPE_TEMPLATE_INFO (type) \n+  if (CLASSTYPE_TEMPLATE_INFO (type)\n       && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type)))\n     {\n       list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n-      for (i = 0; i < TREE_VEC_LENGTH (list); ++i) \n+      for (i = 0; i < TREE_VEC_LENGTH (list); ++i)\n         arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n     }\n \n@@ -4455,15 +4455,15 @@ arg_assoc (struct arg_lookup *k, tree n)\n \n       if (TREE_CODE (template) == COMPONENT_REF)\n         template = TREE_OPERAND (template, 1);\n-      \n+\n       /* First, the template.  There may actually be more than one if\n \t this is an overloaded function template.  But, in that case,\n \t we only need the first; all the functions will be in the same\n \t namespace.  */\n       template = OVL_CURRENT (template);\n \n       ctx = CP_DECL_CONTEXT (template);\n-       \n+\n       if (TREE_CODE (ctx) == NAMESPACE_DECL)\n \t{\n \t  if (arg_assoc_namespace (k, ctx) == 1)\n@@ -4513,7 +4513,7 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n      should be visible during argument-dependent lookup.  */\n   if (fns)\n     fn = OVL_CURRENT (fns);\n-  if (fn && TREE_CODE (fn) == FUNCTION_DECL \n+  if (fn && TREE_CODE (fn) == FUNCTION_DECL\n       && (CP_DECL_CONTEXT (fn) != current_decl_namespace ()\n \t  || DECL_LOCAL_FUNCTION_P (fn)))\n     k.namespaces = NULL_TREE;\n@@ -4686,7 +4686,7 @@ pushtag (tree name, tree type, tag_scope scope)\n \t    context = current_namespace;\n \n \t  if (b->kind == sk_class\n-\t      || (b->kind == sk_template_parms \n+\t      || (b->kind == sk_template_parms\n \t\t  && b->level_chain->kind == sk_class))\n \t    in_class = 1;\n \n@@ -4799,7 +4799,7 @@ store_binding (tree id, VEC(cxx_saved_binding,gc) **old_bindings)\n \n   if (IDENTIFIER_MARKED (id))\n     return;\n-  \n+\n   IDENTIFIER_MARKED (id) = 1;\n \n   saved = VEC_safe_push (cxx_saved_binding, gc, *old_bindings, NULL);\n@@ -4833,7 +4833,7 @@ store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n    objects, rather than a TREE_LIST.  */\n \n static void\n-store_class_bindings (VEC(cp_class_binding,gc) *names, \n+store_class_bindings (VEC(cp_class_binding,gc) *names,\n \t\t      VEC(cxx_saved_binding,gc) **old_bindings)\n {\n   size_t i;\n@@ -4919,7 +4919,7 @@ pop_from_top_level (void)\n   cxx_saved_binding *saved;\n   size_t i;\n \n-  timevar_push (TV_NAME_LOOKUP); \n+  timevar_push (TV_NAME_LOOKUP);\n   /* Clear out class-level bindings cache.  */\n   if (previous_class_level)\n     invalidate_class_lookup_cache ();\n@@ -4964,15 +4964,15 @@ pop_everything (void)\n }\n \n /* Emit debugging information for using declarations and directives.\n-   If input tree is overloaded fn then emit debug info for all \n+   If input tree is overloaded fn then emit debug info for all\n    candidates.  */\n \n void\n cp_emit_debug_info_for_using (tree t, tree context)\n {\n-  /* Ignore this FUNCTION_DECL if it refers to a builtin declaration \n+  /* Ignore this FUNCTION_DECL if it refers to a builtin declaration\n      of a builtin function.  */\n-  if (TREE_CODE (t) == FUNCTION_DECL \n+  if (TREE_CODE (t) == FUNCTION_DECL\n       && DECL_EXTERNAL (t)\n       && DECL_BUILT_IN (t))\n     return;\n@@ -4981,10 +4981,10 @@ cp_emit_debug_info_for_using (tree t, tree context)\n      it is a global namespace.  */\n   if (context == global_namespace)\n     context = NULL_TREE;\n-  \n+\n   if (BASELINK_P (t))\n     t = BASELINK_FUNCTIONS (t);\n-  \n+\n   /* FIXME: Handle TEMPLATE_DECLs.  */\n   for (t = OVL_CURRENT (t); t; t = OVL_NEXT (t))\n     if (TREE_CODE (t) != TEMPLATE_DECL)"}, {"sha": "db0bfe09aa873fc1a5e91fdeddd1746940a8e4b6", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -191,7 +191,7 @@ struct cp_binding_level GTY(())\n     VEC(tree,gc) *static_decls;\n \n     /* A chain of VTABLE_DECL nodes.  */\n-    tree vtables; \n+    tree vtables;\n \n     /* A list of USING_DECL nodes.  */\n     tree usings;"}, {"sha": "845dbbd2de94db52ec2815660a3a6419a5b30393", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1,8 +1,8 @@\n /* -*-C-*-\n-\t\n+\n    This file contains definitions of the various C++ operators,\n    including both overloadable operators (like `+') and\n-   non-overloadable operators (like the `?:' ternary operator).  \n+   non-overloadable operators (like the `?:' ternary operator).\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n    Copyright (C) 2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.\n@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n      preceding `operator'.  This is the name that would be given in\n      the source program.  For `operator +', for example, this would be\n      `+'.\n-   \n+\n    CODE\n \n      The tree_code for this operator.  For `operator +', for example,\n@@ -47,7 +47,7 @@ Boston, MA 02111-1307, USA.  */\n      would be \"pl\".\n \n    ARITY\n-   \n+\n      The arity of the operator, or -1 if any arity is allowed.  (As\n      for `operator ()'.)  Postincrement and postdecrement operators\n      are marked as binary.\n@@ -57,12 +57,12 @@ Boston, MA 02111-1307, USA.  */\n      A boolean value.  If nonzero, this is an assignment operator.\n \n    Before including this file, you should define DEFOPERATOR\n-   to take these arguments.  \n+   to take these arguments.\n \n    There is code (such as in grok_op_properties) that depends on the\n    order the operators are presented in this file.  In particular,\n    unary operators must precede binary operators.  */\n- \n+\n /* Use DEF_SIMPLE_OPERATOR to define a non-assignment operator.  Its\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always zero.  */"}, {"sha": "06eadc1cd5e0b4ee0efa3d77105fafe90b4eac40", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -62,9 +62,9 @@ update_cloned_parm (tree parm, tree cloned_parm)\n \n   /* The definition might have different constness.  */\n   TREE_READONLY (cloned_parm) = TREE_READONLY (parm);\n-  \n+\n   TREE_USED (cloned_parm) = TREE_USED (parm);\n-  \n+\n   /* The name may have changed from the declaration.  */\n   DECL_NAME (cloned_parm) = DECL_NAME (parm);\n   DECL_SOURCE_LOCATION (cloned_parm) = DECL_SOURCE_LOCATION (parm);"}, {"sha": "cbd705caef862948d754499c91deee672c114fbf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -93,7 +93,7 @@ typedef struct cp_lexer GTY (())\n   /* If the lexer owns the buffer, this is the number of tokens in the\n      buffer.  */\n   size_t buffer_length;\n-  \n+\n   /* A pointer just past the last available token.  The tokens\n      in this lexer are [buffer, last_token).  */\n   cp_token_position GTY ((skip)) last_token;\n@@ -258,13 +258,13 @@ cp_lexer_new_main (void)\n   /* Allocate the memory.  */\n   lexer = GGC_CNEW (cp_lexer);\n \n-#ifdef ENABLE_CHECKING  \n+#ifdef ENABLE_CHECKING\n   /* Initially we are not debugging.  */\n   lexer->debugging_p = false;\n #endif /* ENABLE_CHECKING */\n   lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n \t\t\t\t   CP_SAVED_TOKEN_STACK);\n-\t \n+\n   /* Create the buffer.  */\n   alloc = CP_LEXER_BUFFER_SIZE;\n   buffer = ggc_alloc (alloc * sizeof (cp_token));\n@@ -273,7 +273,7 @@ cp_lexer_new_main (void)\n   space = alloc;\n   pos = buffer;\n   *pos = first_token;\n-  \n+\n   /* Get the remaining tokens from the preprocessor.  */\n   while (pos->type != CPP_EOF)\n     {\n@@ -316,7 +316,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   lexer->buffer_length = 0;\n   lexer->next_token = first == last ? (cp_token *)&eof_token : first;\n   lexer->last_token = last;\n-  \n+\n   lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n \t\t\t\t   CP_SAVED_TOKEN_STACK);\n \n@@ -356,7 +356,7 @@ static inline cp_token_position\n cp_lexer_token_position (cp_lexer *lexer, bool previous_p)\n {\n   gcc_assert (!previous_p || lexer->next_token != &eof_token);\n-  \n+\n   return lexer->next_token - previous_p;\n }\n \n@@ -388,7 +388,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n     = c_lex_with_flags (&token->value, &token->location, &token->flags);\n   token->in_system_header = in_system_header;\n \n-  /* On some systems, some header files are surrounded by an \n+  /* On some systems, some header files are surrounded by an\n      implicit extern \"C\" block.  Set a flag in the token if it\n      comes from such a header.  */\n   is_extern_c += pending_lang_change;\n@@ -513,7 +513,7 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n \t  token = (cp_token *)&eof_token;\n \t  break;\n \t}\n-      \n+\n       if (token->type != CPP_PURGED)\n \t--n;\n     }\n@@ -536,7 +536,7 @@ cp_lexer_consume_token (cp_lexer* lexer)\n   cp_token *token = lexer->next_token;\n \n   gcc_assert (token != &eof_token);\n-  \n+\n   do\n     {\n       lexer->next_token++;\n@@ -545,20 +545,20 @@ cp_lexer_consume_token (cp_lexer* lexer)\n \t  lexer->next_token = (cp_token *)&eof_token;\n \t  break;\n \t}\n-      \n+\n     }\n   while (lexer->next_token->type == CPP_PURGED);\n-  \n+\n   cp_lexer_set_source_position_from_token (token);\n-  \n+\n   /* Provide debugging output.  */\n   if (cp_lexer_debugging_p (lexer))\n     {\n       fputs (\"cp_lexer: consuming token: \", cp_lexer_debug_stream);\n       cp_lexer_print_token (cp_lexer_debug_stream, token);\n       putc ('\\n', cp_lexer_debug_stream);\n     }\n-  \n+\n   return token;\n }\n \n@@ -570,7 +570,7 @@ static void\n cp_lexer_purge_token (cp_lexer *lexer)\n {\n   cp_token *tok = lexer->next_token;\n-  \n+\n   gcc_assert (tok != &eof_token);\n   tok->type = CPP_PURGED;\n   tok->location = UNKNOWN_LOCATION;\n@@ -601,7 +601,7 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n \n   if (peek == &eof_token)\n     peek = lexer->last_token;\n-  \n+\n   gcc_assert (tok < peek);\n \n   for ( tok += 1; tok != peek; tok += 1)\n@@ -693,7 +693,7 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n     \"NESTED_NAME_SPECIFIER\",\n     \"PURGED\"\n   };\n-  \n+\n   /* If we have a name for the token, print it out.  Otherwise, we\n      simply give the numeric code.  */\n   gcc_assert (token->type < ARRAY_SIZE(token_names));\n@@ -1671,7 +1671,7 @@ static tree cp_parser_objc_message_expression\n   (cp_parser *);\n static tree cp_parser_objc_encode_expression\n   (cp_parser *);\n-static tree cp_parser_objc_defs_expression \n+static tree cp_parser_objc_defs_expression\n   (cp_parser *);\n static tree cp_parser_objc_protocol_expression\n   (cp_parser *);\n@@ -1866,7 +1866,7 @@ cp_parser_error (cp_parser* parser, const char* message)\n       cp_lexer_set_source_position_from_token (token);\n       if (token->type == CPP_PRAGMA)\n \t{\n-\t  error (\"%<#pragma%> is not allowed here\"); \n+\t  error (\"%<#pragma%> is not allowed here\");\n \t  cp_lexer_purge_token (parser->lexer);\n \t  return;\n \t}\n@@ -1899,12 +1899,12 @@ cp_parser_name_lookup_error (cp_parser* parser,\n \t       parser->scope, name);\n       else if (parser->scope == global_namespace)\n \terror (\"%<::%D%> has not been declared\", name);\n-      else if (parser->object_scope \n+      else if (parser->object_scope\n \t       && !CLASS_TYPE_P (parser->object_scope))\n \terror (\"request for member %qD in non-class type %qT\",\n \t       name, parser->object_scope);\n       else if (parser->object_scope)\n-\terror (\"%<%T::%D%> has not been declared\", \n+\terror (\"%<%T::%D%> has not been declared\",\n \t       parser->object_scope, name);\n       else\n \terror (\"%qD has not been declared\", name);\n@@ -2008,7 +2008,7 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n /* If parsing an integral constant-expression, issue an error message\n    about the fact that THING appeared and return true.  Otherwise,\n    return false.  In either case, set\n-   PARSER->NON_INTEGRAL_CONSTANT_EXPRESSION_P.  */ \n+   PARSER->NON_INTEGRAL_CONSTANT_EXPRESSION_P.  */\n \n static bool\n cp_parser_non_integral_constant_expression (cp_parser  *parser,\n@@ -2319,7 +2319,7 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n   while (nesting_depth >= 0)\n     {\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      \n+\n       if (token->type == CPP_EOF)\n \tbreak;\n \n@@ -2343,7 +2343,7 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \t  if (!nesting_depth)\n \t    nesting_depth = -1;\n \t  break;\n-\t  \n+\n \tcase CPP_OPEN_BRACE:\n \t  /* Nest. */\n \t  nesting_depth++;\n@@ -2352,10 +2352,10 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \tdefault:\n \t  break;\n \t}\n-      \n+\n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n-      \n+\n     }\n }\n \n@@ -2792,7 +2792,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t     checked at that point.  If we are not within a cast, then\n \t     this code is invalid.  */\n \t  if (!cast_p)\n-\t    cp_parser_non_integral_constant_expression \n+\t    cp_parser_non_integral_constant_expression\n \t      (parser, \"floating-point literal\");\n \t}\n       return token->value;\n@@ -3053,7 +3053,7 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* Anything else is an error.  */\n     default:\n       /* ...unless we have an Objective-C++ message or string literal, that is.  */\n-      if (c_dialect_objc () \n+      if (c_dialect_objc ()\n \t  && (token->type == CPP_OPEN_SQUARE || token->type == CPP_OBJC_STRING))\n \treturn cp_parser_objc_expression (parser);\n \n@@ -3563,11 +3563,11 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t look up names in \"X<T>::I\" in order to determine that \"Y\" is\n \t a template.  So, if we have a typename at this point, we make\n \t an effort to look through it.  */\n-      if (is_declaration \n+      if (is_declaration\n \t  && !typename_keyword_p\n-\t  && parser->scope \n+\t  && parser->scope\n \t  && TREE_CODE (parser->scope) == TYPENAME_TYPE)\n-\tparser->scope = resolve_typename_type (parser->scope, \n+\tparser->scope = resolve_typename_type (parser->scope,\n \t\t\t\t\t       /*only_current_p=*/false);\n       /* Parse the qualifying entity.  */\n       new_scope\n@@ -3659,13 +3659,13 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n   if (success && start)\n     {\n       cp_token *token = cp_lexer_token_at (parser->lexer, start);\n-      \n+\n       /* Reset the contents of the START token.  */\n       token->type = CPP_NESTED_NAME_SPECIFIER;\n       token->value = build_tree_list (access_check, parser->scope);\n       TREE_TYPE (token->value) = parser->qualifying_scope;\n       token->keyword = RID_MAX;\n-      \n+\n       /* Purge all subsequent tokens.  */\n       cp_lexer_purge_tokens_after (parser->lexer, start);\n     }\n@@ -3808,7 +3808,7 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \n    If ADDRESS_P is true, the postfix expression is the operand of the\n    `&' operator.  CAST_P is true if this expression is the target of a\n-   cast. \n+   cast.\n \n    Returns a representation of the expression.  */\n \n@@ -4136,7 +4136,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    bool saved_non_integral_constant_expression_p = false;\n \t    tree args;\n \n-\t    is_builtin_constant_p \n+\t    is_builtin_constant_p\n \t      = DECL_IS_BUILTIN_CONSTANT_P (postfix_expression);\n \t    if (is_builtin_constant_p)\n \t      {\n@@ -4149,7 +4149,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\tparser->integral_constant_expression_p = false;\n \t      }\n \t    args = (cp_parser_parenthesized_expression_list\n-\t\t    (parser, /*is_attribute_list=*/false, \n+\t\t    (parser, /*is_attribute_list=*/false,\n \t\t     /*cast_p=*/false,\n \t\t     /*non_constant_p=*/NULL));\n \t    if (is_builtin_constant_p)\n@@ -4884,7 +4884,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n       token = cp_lexer_consume_token (parser->lexer);\n       /* Parse the cast-expression.  */\n       cast_expression\n-\t= cp_parser_cast_expression (parser, \n+\t= cp_parser_cast_expression (parser,\n \t\t\t\t     unary_operator == ADDR_EXPR,\n \t\t\t\t     /*cast_p=*/false);\n       /* Now, build an appropriate representation.  */\n@@ -5112,7 +5112,7 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n       *nelts = declarator->u.array.bounds;\n       if (*nelts == error_mark_node)\n \t*nelts = integer_one_node;\n-      \n+\n       if (outer_declarator)\n \touter_declarator->declarator = declarator->declarator;\n       else\n@@ -5388,7 +5388,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n          ctor of T, but looks like a cast to function returning T\n          without a dependent expression.  */\n       if (!cp_parser_error_occurred (parser))\n-\texpr = cp_parser_cast_expression (parser, \n+\texpr = cp_parser_cast_expression (parser,\n \t\t\t\t\t  /*address_p=*/false,\n \t\t\t\t\t  /*cast_p=*/true);\n \n@@ -5454,7 +5454,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n      relational-expression >= shift-expression\n \n   GNU Extension:\n-  \n+\n    relational-expression:\n      relational-expression <? shift-expression\n      relational-expression >? shift-expression\n@@ -5527,7 +5527,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n          - either we found a token which is not an operator (`>' where it is not\n            an operator, or prec == PREC_NOT_OPERATOR), in which case popping\n            will happen repeatedly;\n-         - or, we found an operator which has lower priority.  This is the case \n+         - or, we found an operator which has lower priority.  This is the case\n            where the recursive descent *ascends*, as in `3 * 4 + 5' after\n            parsing `3 * 4'.  */\n       if (new_prec <= prec)\n@@ -5571,7 +5571,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n          pop:\n           /* If the stack is not empty, we have parsed into LHS the right side\n \t     (`4' in the example above) of an expression we had suspended.\n-\t     We can use the information on the stack to recover the LHS (`3') \n+\t     We can use the information on the stack to recover the LHS (`3')\n \t     from the stack together with the tree code (`MULT_EXPR'), and\n \t     the precedence of the higher level subexpression\n \t     (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token,\n@@ -5593,7 +5593,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n          least one of the operands is of enumeration type.  */\n \n       if (overloaded_p\n-          && (cp_parser_non_integral_constant_expression \n+          && (cp_parser_non_integral_constant_expression\n               (parser, \"calls to overloaded operators\")))\n         return error_mark_node;\n     }\n@@ -5897,15 +5897,15 @@ cp_parser_constant_expression (cp_parser* parser,\n      constant.  */\n   expression = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n   /* Restore the old settings.  */\n-  parser->integral_constant_expression_p \n+  parser->integral_constant_expression_p\n     = saved_integral_constant_expression_p;\n   parser->allow_non_integral_constant_expression_p\n     = saved_allow_non_integral_constant_expression_p;\n   if (allow_non_constant_p)\n     *non_constant_p = parser->non_integral_constant_expression_p;\n   else if (parser->non_integral_constant_expression_p)\n     expression = error_mark_node;\n-  parser->non_integral_constant_expression_p \n+  parser->non_integral_constant_expression_p\n     = saved_non_integral_constant_expression_p;\n \n   return expression;\n@@ -6455,7 +6455,7 @@ cp_parser_condition (cp_parser* parser)\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n-\t  tree pushed_scope;\t\n+\t  tree pushed_scope;\n \n \t  /* Create the declaration.  */\n \t  decl = start_decl (declarator, &type_specifiers,\n@@ -7128,11 +7128,11 @@ cp_parser_simple_declaration (cp_parser* parser,\n       /* Give up.  */\n       goto done;\n     }\n-  \n+\n   /* If we have seen at least one decl-specifier, and the next token\n      is not a parenthesis, then we must be looking at a declaration.\n      (After \"int (\" we might be looking at a functional cast.)  */\n-  if (decl_specifiers.any_specifiers_p \n+  if (decl_specifiers.any_specifiers_p\n       && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n     cp_parser_commit_to_tentative_parse (parser);\n \n@@ -8673,12 +8673,12 @@ cp_parser_template_id (cp_parser *parser,\n   if (start_of_id)\n     {\n       cp_token *token = cp_lexer_token_at (parser->lexer, start_of_id);\n-      \n+\n       /* Reset the contents of the START_OF_ID token.  */\n       token->type = CPP_TEMPLATE_ID;\n       token->value = build_tree_list (access_check, template_id);\n       token->keyword = RID_MAX;\n-      \n+\n       /* Purge all subsequent tokens.  */\n       cp_lexer_purge_tokens_after (parser->lexer, start_of_id);\n \n@@ -8798,7 +8798,7 @@ cp_parser_template_name (cp_parser* parser,\n \t  && !constructor_name_p (identifier, parser->scope))\n \t{\n \t  cp_token_position start = 0;\n-\t  \n+\n \t  /* Explain what went wrong.  */\n \t  error (\"non-template %qD used as template\", identifier);\n \t  inform (\"use %<%T::template %D%> to indicate that it is a template\",\n@@ -9097,7 +9097,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t      gcc_assert (REFERENCE_REF_P (argument));\n \t      argument = TREE_OPERAND (argument, 0);\n \t    }\n-\t  \n+\n \t  if (qualifying_class)\n \t    argument = finish_qualified_id_expr (qualifying_class,\n \t\t\t\t\t\t argument,\n@@ -9729,7 +9729,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t}\n \n       cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type));\n-    } \n+    }\n \n   return type;\n }\n@@ -9782,7 +9782,7 @@ cp_parser_type_name (cp_parser* parser)\n \t  /* See if this is an Objective-C type.  */\n \t  tree protos = cp_parser_objc_protocol_refs_opt (parser);\n \t  tree type = objc_get_protocol_qualified_type (identifier, protos);\n-\t  if (type) \n+\t  if (type)\n \t    type_decl = TYPE_NAME (type);\n \t}\n \n@@ -9941,7 +9941,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t}\n \n       /* For a `typename', we needn't call xref_tag.  */\n-      if (tag_type == typename_type \n+      if (tag_type == typename_type\n \t  && TREE_CODE (parser->scope) != NAMESPACE_DECL)\n \treturn cp_parser_make_typename_type (parser, parser->scope,\n \t\t\t\t\t     identifier);\n@@ -9984,7 +9984,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n \t  if (TREE_CODE (decl) != TYPE_DECL)\n \t    {\n-\t      cp_parser_diagnose_invalid_type_name (parser, \n+\t      cp_parser_diagnose_invalid_type_name (parser,\n \t\t\t\t\t\t    parser->scope,\n \t\t\t\t\t\t    identifier);\n \t      return error_mark_node;\n@@ -10632,7 +10632,7 @@ cp_parser_asm_definition (cp_parser* parser)\n \t  tree temp = asm_stmt;\n \t  if (TREE_CODE (temp) == CLEANUP_POINT_EXPR)\n \t    temp = TREE_OPERAND (temp, 0);\n-\t  \n+\n \t  ASM_INPUT_P (temp) = 1;\n \t}\n     }\n@@ -10983,7 +10983,7 @@ cp_parser_init_declarator (cp_parser* parser,\n    expression, not a declaration.)\n \n    If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff\n-   the declarator is a direct-declarator of the form \"(...)\".  \n+   the declarator is a direct-declarator of the form \"(...)\".\n \n    MEMBER_P is true iff this declarator is a member-declarator.  */\n \n@@ -11286,7 +11286,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\tbounds = fold_non_dependent_expr (bounds);\n \t      /* Normally, the array bound must be an integral constant\n \t\t expression.  However, as an extension, we allow VLAs\n-\t\t in function scopes.  */  \n+\t\t in function scopes.  */\n \t      else if (!at_function_scope_p ())\n \t\t{\n \t\t  error (\"array bound is not an integer constant\");\n@@ -11319,7 +11319,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      if (!cp_parser_parse_definitely (parser))\n \t\tunqualified_name = error_mark_node;\n \t      else if (qualifying_scope\n-\t\t       || (TREE_CODE (unqualified_name) \n+\t\t       || (TREE_CODE (unqualified_name)\n \t\t\t   != IDENTIFIER_NODE))\n \t\t{\n \t\t  cp_parser_error (parser, \"expected unqualified-id\");\n@@ -11353,7 +11353,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     \t specialized, then this `i' will not be used, so there\n \t     \t is no harm in resolving the types here.  */\n \t      tree type;\n-\t      \n+\n \t      /* Resolve the TYPENAME_TYPE.  */\n \t      type = resolve_typename_type (qualifying_scope,\n \t\t\t\t\t    /*only_current_p=*/false);\n@@ -11365,7 +11365,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      qualifying_scope = type;\n \t    }\n \n-\t  declarator = make_id_declarator (qualifying_scope, \n+\t  declarator = make_id_declarator (qualifying_scope,\n \t\t\t\t\t   unqualified_name);\n \t  declarator->id_loc = token->location;\n \t  if (unqualified_name)\n@@ -11391,7 +11391,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t   && (constructor_name_p (unqualified_name,\n \t\t\t\t\t\t   class_type)\n \t\t\t       || (TREE_CODE (unqualified_name) == TYPE_DECL\n-\t\t\t\t   && (same_type_p \n+\t\t\t\t   && (same_type_p\n \t\t\t\t       (TREE_TYPE (unqualified_name),\n \t\t\t\t\tclass_type)))))\n \t\t    declarator->u.id.sfk = sfk_constructor;\n@@ -11741,7 +11741,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       /* The standard says that a condition can be:\n \n             type-specifier-seq declarator = assignment-expression\n-      \n+\n \t However, given:\n \n \t   struct S {};\n@@ -11755,7 +11755,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n          then add a semantic restriction that if any decl-specifiers\n          that are not type-specifiers appear, the program is invalid.  */\n       if (is_condition && !is_cv_qualifier)\n-\tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES; \n+\tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n     }\n \n   return;\n@@ -12174,7 +12174,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t    = parser->local_variables_forbidden_p;\n \t  parser->local_variables_forbidden_p = true;\n \t  /* Parse the assignment-expression.  */\n-\t  default_argument \n+\t  default_argument\n \t    = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n \t  /* Restore saved state.  */\n \t  parser->greater_than_is_operator_p\n@@ -12753,7 +12753,7 @@ cp_parser_class_specifier (cp_parser* parser)\n    involving a nested-name-specifier was used, and FALSE otherwise.\n \n    Returns error_mark_node if this is not a class-head.\n-   \n+\n    Returns NULL_TREE if the class-head is syntactically valid, but\n    semantically invalid in a way that means we should skip the entire\n    body of the class.  */\n@@ -13034,7 +13034,7 @@ cp_parser_class_head (cp_parser* parser,\n \t      goto done;\n \t    }\n \t}\n-      \n+\n       type = TREE_TYPE (type);\n       *nested_name_specifier_p = true;\n     }\n@@ -14316,7 +14316,7 @@ cp_parser_attribute_list (cp_parser* parser)\n \t  token = cp_lexer_consume_token (parser->lexer);\n \n \t  /* Save away the identifier that indicates which attribute\n-\t     this is.  */ \n+\t     this is.  */\n \t  identifier = token->value;\n \t  attribute = build_tree_list (identifier, NULL_TREE);\n \n@@ -14328,7 +14328,7 @@ cp_parser_attribute_list (cp_parser* parser)\n \t      tree arguments;\n \n \t      arguments = (cp_parser_parenthesized_expression_list\n-\t\t\t   (parser, true, /*cast_p=*/false, \n+\t\t\t   (parser, true, /*cast_p=*/false,\n \t\t\t    /*non_constant_p=*/NULL));\n \t      /* Save the identifier and arguments away.  */\n \t      TREE_VALUE (attribute) = arguments;\n@@ -14448,7 +14448,7 @@ cp_parser_label_declaration (cp_parser* parser)\n    are ignored.\n \n    If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent\n-   types.  \n+   types.\n \n    If AMBIGUOUS_P is non-NULL, it is set to true if name-lookup\n    results in an ambiguity, and false otherwise.  */\n@@ -14569,8 +14569,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n-\t  decl = lookup_qualified_name (parser->scope, name, \n-\t\t\t\t\ttag_type != none_type, \n+\t  decl = lookup_qualified_name (parser->scope, name,\n+\t\t\t\t\ttag_type != none_type,\n \t\t\t\t\t/*complain=*/true);\n \t  if (pushed_scope)\n \t    pop_scope (pushed_scope);\n@@ -14590,10 +14590,10 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t   parse, those errors are valid.  */\n \tobject_decl = lookup_member (object_type,\n \t\t\t\t     name,\n-\t\t\t\t     /*protect=*/0, \n+\t\t\t\t     /*protect=*/0,\n \t\t\t\t     tag_type != none_type);\n       /* Look it up in the enclosing context, too.  */\n-      decl = lookup_name_real (name, tag_type != none_type, \n+      decl = lookup_name_real (name, tag_type != none_type,\n \t\t\t       /*nonclass=*/0,\n \t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n@@ -14604,7 +14604,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     }\n   else\n     {\n-      decl = lookup_name_real (name, tag_type != none_type, \n+      decl = lookup_name_real (name, tag_type != none_type,\n \t\t\t       /*nonclass=*/0,\n \t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n@@ -14754,7 +14754,7 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \t      scope = TYPE_CONTEXT (scope);\n \t    }\n \t}\n-      else if (TREE_CODE (declarator->u.id.unqualified_name) \n+      else if (TREE_CODE (declarator->u.id.unqualified_name)\n \t       == TEMPLATE_ID_EXPR)\n \t/* If the DECLARATOR has the form `X<y>' then it uses one\n \t   additional level of template parameters.  */\n@@ -15516,14 +15516,14 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n       tokens = DECL_PENDING_INLINE_INFO (member_function);\n       DECL_PENDING_INLINE_INFO (member_function) = NULL;\n       DECL_PENDING_INLINE_P (member_function) = 0;\n-      \n+\n       /* If this is a local class, enter the scope of the containing\n \t function.  */\n       function_scope = current_function_decl;\n       if (function_scope)\n \tpush_function_context_to (function_scope);\n \n-      \n+\n       /* Push the body of the function onto the lexer stack.  */\n       cp_parser_push_lexer_for_tokens (parser, tokens);\n \n@@ -15535,14 +15535,14 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n       /* Don't do access checking if it is a templated function.  */\n       if (processing_template_decl)\n \tpush_deferring_access_checks (dk_no_check);\n-      \n+\n       /* Now, parse the body of the function.  */\n       cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t      /*inline_p=*/true);\n \n       if (processing_template_decl)\n \tpop_deferring_access_checks ();\n-      \n+\n       /* Leave the scope of the containing function.  */\n       if (function_scope)\n \tpop_function_context_from (function_scope);\n@@ -15611,7 +15611,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       VEC(tree,gc) *insts;\n       tree copy;\n       unsigned ix;\n-      \n+\n       if (!default_arg)\n \tcontinue;\n \n@@ -15684,7 +15684,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n \n   /* The restrictions on constant-expressions do not apply inside\n      sizeof expressions.  */\n-  saved_integral_constant_expression_p \n+  saved_integral_constant_expression_p\n     = parser->integral_constant_expression_p;\n   saved_non_integral_constant_expression_p\n     = parser->non_integral_constant_expression_p;\n@@ -15741,7 +15741,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   free ((char *) parser->type_definition_forbidden_message);\n   /* And restore the old one.  */\n   parser->type_definition_forbidden_message = saved_message;\n-  parser->integral_constant_expression_p \n+  parser->integral_constant_expression_p\n     = saved_integral_constant_expression_p;\n   parser->non_integral_constant_expression_p\n     = saved_non_integral_constant_expression_p;\n@@ -16416,7 +16416,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n \n    objc-encode-expression:\n      @encode objc-typename\n-     \n+\n    Returns an encoded representation of the type argument.  */\n \n static tree\n@@ -16547,12 +16547,12 @@ cp_parser_objc_identifier_list (cp_parser* parser)\n   while (sep->type == CPP_COMMA)\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-      list = chainon (list, \n+      list = chainon (list,\n \t\t      build_tree_list (NULL_TREE,\n \t\t\t\t       cp_parser_identifier (parser)));\n       sep = cp_lexer_peek_token (parser->lexer);\n     }\n-    \n+\n   return list;\n }\n \n@@ -16725,7 +16725,7 @@ static tree\n cp_parser_objc_selector (cp_parser* parser)\n {\n   cp_token *token = cp_lexer_consume_token (parser->lexer);\n-  \n+\n   if (!cp_parser_objc_selector_p (token->type))\n     {\n       error (\"invalid Objective-C++ selector name\");\n@@ -16778,7 +16778,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n \n       params\n \t= chainon (params,\n-\t\t   objc_build_keyword_decl (selector, \n+\t\t   objc_build_keyword_decl (selector,\n \t\t\t\t\t    typename,\n \t\t\t\t\t    identifier));\n \n@@ -16815,7 +16815,7 @@ cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp)\n       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n       parm = grokdeclarator (parmdecl->declarator,\n \t\t\t     &parmdecl->decl_specifiers,\n-\t\t\t     PARM, /*initialized=*/0, \n+\t\t\t     PARM, /*initialized=*/0,\n \t\t\t     /*attrlist=*/NULL);\n \n       chainon (params, build_tree_list (NULL_TREE, parm));\n@@ -16992,7 +16992,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t  else\n \t    {\n \t      /* Parse the declarator.  */\n-\t      declarator \n+\t      declarator\n \t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t\t&ctor_dtor_or_conv_p,\n \t\t\t\t\t/*parenthesized_p=*/NULL,\n@@ -17016,7 +17016,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t  else\n \t    decl = grokfield (declarator, &declspecs, NULL_TREE,\n \t\t\t      NULL_TREE, attributes);\n-\t  \n+\n \t  /* Add the instance variable.  */\n \t  objc_add_instance_variable (decl);\n \n@@ -17063,14 +17063,14 @@ cp_parser_objc_protocol_declaration (cp_parser* parser)\n \n   /* See if we have a forward declaration or a definition.  */\n   tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n-  \n+\n   /* Try a forward declaration first.  */\n   if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n     {\n       objc_declare_protocols (cp_parser_objc_identifier_list (parser));\n-     finish: \n+     finish:\n       cp_parser_consume_semicolon_at_end_of_statement (parser);\n-    } \n+    }\n \n   /* Ok, we got a full-fledged definition (or at least should).  */\n   else\n@@ -17227,7 +17227,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n   stmt = push_stmt_list ();\n   cp_parser_compound_statement (parser, NULL, false);\n   objc_begin_try_stmt (location, pop_stmt_list (stmt));\n-  \n+\n   while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n     {\n       cp_parameter_declarator *parmdecl;\n@@ -17238,7 +17238,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n       parm = grokdeclarator (parmdecl->declarator,\n \t\t\t     &parmdecl->decl_specifiers,\n-\t\t\t     PARM, /*initialized=*/0, \n+\t\t\t     PARM, /*initialized=*/0,\n \t\t\t     /*attrlist=*/NULL);\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n       objc_begin_catch_clause (parm);"}, {"sha": "8a8e1fc65bf180d75dca72c0bf47ba150b4dc509", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 671, "deletions": 671, "changes": 1342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c8094d835f3b458cc3d47195966d944c89208396"}, {"sha": "227dde59f3799152bda94eafbfb06fe50bbea71f", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -129,7 +129,7 @@ cxx_print_type (FILE *file, tree node, int indent)\n \t\t BINFO_N_BASE_BINFOS (TYPE_BINFO (node)));\n       else\n \tfprintf (file, \" no-binfo\");\n-      \n+\n       fprintf (file, \" use_template=%d\", CLASSTYPE_USE_TEMPLATE (node));\n       if (CLASSTYPE_INTERFACE_ONLY (node))\n \tfprintf (file, \" interface-only\");"}, {"sha": "206487d6d3a388545db26d8137083bde1fb19b77", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -115,7 +115,7 @@ get_base_filename (const char *filename)\n     }\n \n   return lbasename (filename);\n-}        \n+}\n \n static void\n open_repo_file (const char *filename)\n@@ -332,7 +332,7 @@ repo_export_class_p (tree class_type)\n     return false;\n   /* If the virtual table has been assigned to this translation unit,\n      export the class.  */\n-  return (IDENTIFIER_REPO_CHOSEN \n+  return (IDENTIFIER_REPO_CHOSEN\n \t  (DECL_ASSEMBLER_NAME (CLASSTYPE_VTABLES (class_type))));\n }\n "}, {"sha": "7aa8a1e4f7b41cc170394ff94f3db2cebe296af1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -110,7 +110,7 @@ void\n init_rtti_processing (void)\n {\n   tree type_info_type;\n-  \n+\n   push_namespace (std_identifier);\n   type_info_type = xref_tag (class_type, get_identifier (\"type_info\"),\n \t\t\t     /*tag_scope=*/ts_current, false);\n@@ -120,7 +120,7 @@ init_rtti_processing (void)\n   type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n \n   unemitted_tinfo_decls = VEC_alloc (tree, gc, 124);\n-  \n+\n   create_tinfo_types ();\n }\n \n@@ -151,9 +151,9 @@ build_headof (tree exp)\n \n   offset = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n \n-  type = build_qualified_type (ptr_type_node, \n+  type = build_qualified_type (ptr_type_node,\n \t\t\t       cp_type_quals (TREE_TYPE (exp)));\n-  return build2 (PLUS_EXPR, type, exp, \n+  return build2 (PLUS_EXPR, type, exp,\n \t\t convert_to_integer (ptrdiff_type_node, offset));\n }\n \n@@ -168,7 +168,7 @@ throw_bad_cast (void)\n   if (!get_global_value_if_present (fn, &fn))\n     fn = push_throw_library_fn (fn, build_function_type (ptr_type_node,\n \t\t\t\t\t\t\t void_list_node));\n-  \n+\n   return build_cxx_call (fn, NULL_TREE);\n }\n \n@@ -201,7 +201,7 @@ get_tinfo_decl_dynamic (tree exp)\n {\n   tree type;\n   tree t;\n-  \n+\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n@@ -210,10 +210,10 @@ get_tinfo_decl_dynamic (tree exp)\n \n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n-  \n+\n   if (!VOID_TYPE_P (type))\n     type = complete_type_or_else (type, exp);\n-  \n+\n   if (!type)\n     return error_mark_node;\n \n@@ -244,13 +244,13 @@ typeid_ok_p (void)\n       error (\"cannot use typeid with -fno-rtti\");\n       return false;\n     }\n-  \n+\n   if (!COMPLETE_TYPE_P (const_type_info_type_node))\n     {\n       error (\"must #include <typeinfo> before using typeid\");\n       return false;\n     }\n-  \n+\n   return true;\n }\n \n@@ -308,19 +308,19 @@ tinfo_name (tree type)\n \n /* Return a VAR_DECL for the internal ABI defined type_info object for\n    TYPE. You must arrange that the decl is mark_used, if actually use\n-   it --- decls in vtables are only used if the vtable is output.  */ \n+   it --- decls in vtables are only used if the vtable is output.  */\n \n tree\n get_tinfo_decl (tree type)\n {\n   tree name;\n   tree d;\n \n-  if (COMPLETE_TYPE_P (type) \n+  if (COMPLETE_TYPE_P (type)\n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       error (\"cannot create type information for type %qT because \"\n-             \"its size is variable\", \n+             \"its size is variable\",\n \t     type);\n       return error_mark_node;\n     }\n@@ -337,7 +337,7 @@ get_tinfo_decl (tree type)\n       if (d)\n \treturn d;\n     }\n-    \n+\n   name = mangle_typeinfo_for_type (type);\n \n   d = IDENTIFIER_GLOBAL_VALUE (name);\n@@ -379,7 +379,7 @@ get_tinfo_ptr (tree type)\n   tree decl = get_tinfo_decl (type);\n \n   mark_used (decl);\n-  return build_nop (type_info_ptr_type, \n+  return build_nop (type_info_ptr_type,\n \t\t    build_address (decl));\n }\n \n@@ -390,7 +390,7 @@ get_typeid (tree type)\n {\n   if (type == error_mark_node || !typeid_ok_p ())\n     return error_mark_node;\n-  \n+\n   if (processing_template_decl)\n     return build_min (TYPEID_EXPR, const_type_info_type_node, type);\n \n@@ -405,7 +405,7 @@ get_typeid (tree type)\n \n   if (!VOID_TYPE_P (type))\n     type = complete_type_or_else (type, NULL_TREE);\n-  \n+\n   if (!type)\n     return error_mark_node;\n \n@@ -419,7 +419,7 @@ static tree\n ifnonnull (tree test, tree result)\n {\n   return build3 (COND_EXPR, TREE_TYPE (result),\n-\t\t build2 (EQ_EXPR, boolean_type_node, test, \n+\t\t build2 (EQ_EXPR, boolean_type_node, test,\n \t\t         cp_convert (TREE_TYPE (test), integer_zero_node)),\n \t\t cp_convert (TREE_TYPE (result), integer_zero_node),\n \t\t result);\n@@ -504,7 +504,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  errstr = \"source is of incomplete class type\";\n \t  goto fail;\n \t}\n-      \n+\n     }\n \n   /* The dynamic_cast operator shall not cast away constness.  */\n@@ -584,7 +584,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t\t{\n \t\t  warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n                            op, type);\n-\t\t  retval = build_int_cst (type, 0); \n+\t\t  retval = build_int_cst (type, 0);\n \t\t  return retval;\n \t\t}\n \t    }\n@@ -600,7 +600,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \n           /* Determine how T and V are related.  */\n           boff = dcast_base_hint (static_type, target_type);\n-          \n+\n \t  /* Since expr is used twice below, save it.  */\n \t  expr = save_expr (expr);\n \n@@ -621,12 +621,12 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      tree tinfo_ptr;\n \t      tree ns = abi_node;\n \t      const char *name;\n-\t      \n+\n \t      push_nested_namespace (ns);\n \t      tinfo_ptr = xref_tag (class_type,\n \t\t\t\t    get_identifier (\"__class_type_info\"),\n \t\t\t\t    /*tag_scope=*/ts_current, false);\n-\t      \n+\n \t      tinfo_ptr = build_pointer_type\n \t\t(build_qualified_type\n \t\t (tinfo_ptr, TYPE_QUAL_CONST));\n@@ -647,7 +647,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  if (tc == REFERENCE_TYPE)\n \t    {\n \t      tree bad = throw_bad_cast ();\n-\t      \n+\n \t      result = save_expr (result);\n \t      return build3 (COND_EXPR, type, result, result, bad);\n \t    }\n@@ -671,12 +671,12 @@ build_dynamic_cast (tree type, tree expr)\n {\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n-  \n+\n   if (processing_template_decl)\n     {\n       expr = build_min (DYNAMIC_CAST_EXPR, type, expr);\n       TREE_SIDE_EFFECTS (expr) = 1;\n-      \n+\n       return expr;\n     }\n \n@@ -690,7 +690,7 @@ qualifier_flags (tree type)\n {\n   int flags = 0;\n   int quals = cp_type_quals (type);\n-  \n+\n   if (quals & TYPE_QUAL_CONST)\n     flags |= 1;\n   if (quals & TYPE_QUAL_VOLATILE)\n@@ -733,7 +733,7 @@ involves_incomplete_p (tree type)\n \n     case OFFSET_TYPE:\n     ptrmem:\n-      return \n+      return\n \t(target_incomplete_p (TYPE_PTRMEM_POINTED_TO_TYPE (type))\n \t || !COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)));\n \n@@ -763,10 +763,10 @@ tinfo_base_init (tree desc, tree target)\n   tree init = NULL_TREE;\n   tree name_decl;\n   tree vtable_ptr;\n-  \n+\n   {\n     tree name_name;\n-    \n+\n     /* Generate the NTBS array variable.  */\n     tree name_type = build_cplus_array_type\n                      (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n@@ -803,12 +803,12 @@ tinfo_base_init (tree desc, tree target)\n   if (!vtable_ptr)\n     {\n       tree real_type;\n-  \n+\n       push_nested_namespace (abi_node);\n       real_type = xref_tag (class_type, TINFO_REAL_NAME (desc),\n \t\t\t    /*tag_scope=*/ts_current, false);\n       pop_nested_namespace (abi_node);\n-  \n+\n       if (!COMPLETE_TYPE_P (real_type))\n \t{\n           /* We never saw a definition of this type, so we need to\n@@ -832,15 +832,15 @@ tinfo_base_init (tree desc, tree target)\n     }\n \n   init = tree_cons (NULL_TREE, vtable_ptr, init);\n-  \n+\n   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n-  \n+\n   init = build_constructor (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   init = tree_cons (NULL_TREE, init, NULL_TREE);\n-  \n+\n   return init;\n }\n \n@@ -852,7 +852,7 @@ static tree\n generic_initializer (tree desc, tree target)\n {\n   tree init = tinfo_base_init (desc, target);\n-  \n+\n   init = build_constructor (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n@@ -871,14 +871,14 @@ ptr_initializer (tree desc, tree target)\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n-  \n+\n   if (incomplete)\n     flags |= 8;\n   init = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags), init);\n   init = tree_cons (NULL_TREE,\n                     get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n                     init);\n-  \n+\n   init = build_constructor (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n@@ -899,7 +899,7 @@ ptm_initializer (tree desc, tree target)\n   tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n-  \n+\n   if (incomplete)\n     flags |= 0x8;\n   if (!COMPLETE_TYPE_P (klass))\n@@ -910,13 +910,13 @@ ptm_initializer (tree desc, tree target)\n                     init);\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (klass),\n-\t\t    init);  \n-  \n+\t\t    init);\n+\n   init = build_constructor (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n-  return init;  \n+  return init;\n }\n \n /* Return the CONSTRUCTOR expr for a type_info of class TYPE.\n@@ -927,13 +927,13 @@ static tree\n class_initializer (tree desc, tree target, tree trail)\n {\n   tree init = tinfo_base_init (desc, target);\n-  \n+\n   TREE_CHAIN (init) = trail;\n   init = build_constructor (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n-  return init;  \n+  return init;\n }\n \n /* Returns true if the typeinfo for type should be placed in\n@@ -957,7 +957,7 @@ typeinfo_in_lib_p (tree type)\n     case REAL_TYPE:\n     case VOID_TYPE:\n       return true;\n-    \n+\n     default:\n       return false;\n     }\n@@ -995,7 +995,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n           tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n \t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n-\t  \n+\n \t  return class_initializer (var_desc, type, base_inits);\n \t}\n       else\n@@ -1007,7 +1007,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n           tree base_inits = NULL_TREE;\n           int ix;\n-          \n+\n           /* Generate the base information initializer.  */\n           for (ix = nbases; ix--;)\n             {\n@@ -1016,7 +1016,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n               int flags = 0;\n               tree tinfo;\n               tree offset;\n-              \n+\n               if (VEC_index (tree, base_accesses, ix) == access_public_node)\n                 flags |= 2;\n               tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n@@ -1030,7 +1030,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t\t}\n \t      else\n \t\toffset = BINFO_OFFSET (base_binfo);\n-              \n+\n               /* Combine offset and flags into one field.  */\n               offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n \t\t\t\t\t   build_int_cst (NULL_TREE, 8));\n@@ -1071,7 +1071,7 @@ get_pseudo_ti_init (tree type, tree var_desc)\n    vtable.  We have to delay generating the VAR_DECL of the vtable\n    until the end of the translation, when we'll have seen the library\n    definition, if there was one.\n-   \n+\n    REAL_NAME is the runtime's name of the type. Trailing arguments are\n    additional FIELD_DECL's for the structure. The final argument must be\n    NULL.  */\n@@ -1094,17 +1094,17 @@ create_pseudo_type_info (const char *real_name, int ident, ...)\n   strcat (pseudo_name, \"_pseudo\");\n   if (ident)\n     sprintf (pseudo_name + strlen (pseudo_name), \"%d\", ident);\n-  \n+\n   /* First field is the pseudo type_info base class.  */\n   fields = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n-  \n+\n   /* Now add the derived fields.  */\n   while ((field_decl = va_arg (ap, tree)))\n     {\n       TREE_CHAIN (field_decl) = fields;\n       fields = field_decl;\n     }\n-  \n+\n   /* Create the pseudo type.  */\n   pseudo_type = make_aggr_type (RECORD_TYPE);\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n@@ -1114,7 +1114,7 @@ create_pseudo_type_info (const char *real_name, int ident, ...)\n   TINFO_REAL_NAME (result) = get_identifier (real_name);\n   TINFO_PSEUDO_TYPE (result) =\n     cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n-  \n+\n   va_end (ap);\n   return result;\n }\n@@ -1156,7 +1156,7 @@ get_pseudo_ti_desc (tree type)\n \t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \t  tree base_binfo = BINFO_BASE_BINFO (binfo, 0);\n \t  int num_bases = BINFO_N_BASE_BINFOS (binfo);\n-\t  \n+\n \t  if (num_bases == 1\n \t      && VEC_index (tree, base_accesses, 0) == access_public_node\n \t      && !BINFO_VIRTUAL_P (base_binfo)\n@@ -1167,12 +1167,12 @@ get_pseudo_ti_desc (tree type)\n \t    {\n \t      tree var_desc;\n \t      tree array_domain, base_array;\n-\t      \n+\n \t      if (TREE_VEC_LENGTH (vmi_class_desc_type_node) <= num_bases)\n \t\t{\n \t\t  int ix;\n \t\t  tree extend = make_tree_vec (num_bases + 5);\n-\t\t  \n+\n \t\t  for (ix = TREE_VEC_LENGTH (vmi_class_desc_type_node); ix--;)\n \t\t    TREE_VEC_ELT (extend, ix)\n \t\t      = TREE_VEC_ELT (vmi_class_desc_type_node, ix);\n@@ -1181,7 +1181,7 @@ get_pseudo_ti_desc (tree type)\n \t      var_desc = TREE_VEC_ELT (vmi_class_desc_type_node, num_bases);\n \t      if (var_desc)\n \t\treturn var_desc;\n-  \n+\n \t      /* Create the array of __base_class_type_info entries.\n \t\t G++ 3.2 allocated an array that had one too many\n \t\t entries, and then filled that extra entries with\n@@ -1220,7 +1220,7 @@ create_tinfo_types (void)\n   gcc_assert (!ti_desc_type_node);\n \n   push_nested_namespace (abi_node);\n-  \n+\n   /* Create the internal type_info structure. This is used as a base for\n      the other structures.  */\n   {\n@@ -1229,16 +1229,16 @@ create_tinfo_types (void)\n     ti_desc_type_node = make_aggr_type (RECORD_TYPE);\n     field = build_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n     fields = field;\n-    \n+\n     field = build_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n-    \n+\n     finish_builtin_struct (ti_desc_type_node, \"__type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n     TYPE_HAS_CONSTRUCTOR (ti_desc_type_node) = 1;\n   }\n-  \n+\n   /* Fundamental type_info */\n   bltn_desc_type_node = create_pseudo_type_info\n       (\"__fundamental_type_info\", 0,\n@@ -1254,40 +1254,40 @@ create_tinfo_types (void)\n   enum_desc_type_node = create_pseudo_type_info\n        (\"__enum_type_info\", 0,\n         NULL);\n-  \n+\n   /* Class type_info. Add a flags field.  */\n   class_desc_type_node = create_pseudo_type_info\n         (\"__class_type_info\", 0,\n          NULL);\n-  \n-  /* Single public non-virtual base class. Add pointer to base class. \n+\n+  /* Single public non-virtual base class. Add pointer to base class.\n      This is really a descendant of __class_type_info.  */\n   si_class_desc_type_node = create_pseudo_type_info\n            (\"__si_class_type_info\", 0,\n             build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n             NULL);\n-  \n+\n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags.  */\n   {\n     tree field, fields;\n-    \n+\n     field = build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type);\n     fields = field;\n-    \n+\n     field = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n-  \n+\n     base_desc_type_node = make_aggr_type (RECORD_TYPE);\n     finish_builtin_struct (base_desc_type_node, \"__base_class_type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n     TYPE_HAS_CONSTRUCTOR (base_desc_type_node) = 1;\n   }\n-  \n+\n   /* General hierarchy is created as necessary in this vector.  */\n   vmi_class_desc_type_node = make_tree_vec (10);\n-  \n+\n   /* Pointer type_info. Adds two fields, qualification mask\n      and pointer to the pointed to type.  This is really a descendant of\n      __pbase_type_info.  */\n@@ -1334,10 +1334,10 @@ emit_support_tinfos (void)\n   };\n   int ix;\n   tree bltn_type, dtor;\n-  \n+\n   push_nested_namespace (abi_node);\n   bltn_type = xref_tag (class_type,\n-\t\t\tget_identifier (\"__fundamental_type_info\"), \n+\t\t\tget_identifier (\"__fundamental_type_info\"),\n \t\t\t/*tag_scope=*/ts_current, false);\n   pop_nested_namespace (abi_node);\n   if (!COMPLETE_TYPE_P (bltn_type))\n@@ -1354,9 +1354,9 @@ emit_support_tinfos (void)\n \n       types[0] = bltn;\n       types[1] = build_pointer_type (bltn);\n-      types[2] = build_pointer_type (build_qualified_type (bltn, \n+      types[2] = build_pointer_type (build_qualified_type (bltn,\n \t\t\t\t\t\t\t   TYPE_QUAL_CONST));\n- \n+\n       for (i = 0; i < 3; ++i)\n \t{\n \t  tree tinfo;\n@@ -1365,7 +1365,7 @@ emit_support_tinfos (void)\n \t  TREE_USED (tinfo) = 1;\n \t  mark_needed (tinfo);\n \t  /* The C++ ABI requires that these objects be COMDAT.  But,\n-\t     On systems without weak symbols, initialized COMDAT \n+\t     On systems without weak symbols, initialized COMDAT\n \t     objects are emitted with internal linkage.  (See\n \t     comdat_linkage for details.)  Since we want these objects\n \t     to have external linkage so that copies do not have to be\n@@ -1391,8 +1391,8 @@ emit_tinfo_decl (tree decl)\n   int in_library = typeinfo_in_lib_p (type);\n   tree var_desc, var_init;\n \n-  gcc_assert (DECL_TINFO_P (decl)); \n-  \n+  gcc_assert (DECL_TINFO_P (decl));\n+\n   if (in_library)\n     {\n       if (doing_runtime)"}, {"sha": "285472900826132ae9dcf0d5ee04ace9612a4a80", "filename": "gcc/cp/search.c", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -106,22 +106,22 @@ dfs_lookup_base (tree binfo, void *data_)\n \t  data->binfo = binfo;\n \t  data->via_virtual\n \t    = binfo_via_virtual (data->binfo, data->t) != NULL_TREE;\n-\t  \n+\n \t  if (!data->repeated_base)\n \t    /* If there are no repeated bases, we can stop now.  */\n \t    return binfo;\n-\t  \n+\n \t  if (data->want_any && !data->via_virtual)\n \t    /* If this is a non-virtual base, then we can't do\n \t       better.  */\n \t    return binfo;\n-\t  \n+\n \t  return dfs_skip_bases;\n \t}\n       else\n \t{\n \t  gcc_assert (binfo != data->binfo);\n-\t  \n+\n \t  /* We've found more than one matching binfo.  */\n \t  if (!data->want_any)\n \t    {\n@@ -144,7 +144,7 @@ dfs_lookup_base (tree binfo, void *data_)\n \t  return dfs_skip_bases;\n \t}\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -161,7 +161,7 @@ accessible_base_p (tree t, tree base, bool consider_local_p)\n   /* [class.access.base]\n \n      A base class is said to be accessible if an invented public\n-     member of the base class is accessible.  \n+     member of the base class is accessible.\n \n      If BASE is a non-proper base, this condition is trivially\n      true.  */\n@@ -193,15 +193,15 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n   tree binfo;\n   tree t_binfo;\n   base_kind bk;\n-  \n+\n   if (t == error_mark_node || base == error_mark_node)\n     {\n       if (kind_ptr)\n \t*kind_ptr = bk_not_base;\n       return error_mark_node;\n     }\n   gcc_assert (TYPE_P (base));\n-  \n+\n   if (!TYPE_P (t))\n     {\n       t_binfo = t;\n@@ -212,7 +212,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n       t = complete_type (TYPE_MAIN_VARIANT (t));\n       t_binfo = TYPE_BINFO (t);\n     }\n-  \n+\n   base = complete_type (TYPE_MAIN_VARIANT (base));\n \n   if (t_binfo)\n@@ -228,7 +228,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \n       dfs_walk_once (t_binfo, dfs_lookup_base, NULL, &data);\n       binfo = data.binfo;\n-      \n+\n       if (!binfo)\n \tbk = data.ambiguous ? bk_ambig : bk_not_base;\n       else if (binfo == t_binfo)\n@@ -284,7 +284,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \n   if (kind_ptr)\n     *kind_ptr = bk;\n-  \n+\n   return binfo;\n }\n \n@@ -310,7 +310,7 @@ dfs_dcast_hint_pre (tree binfo, void *data_)\n \n   if (BINFO_VIRTUAL_P (binfo))\n     data->virt_depth++;\n-  \n+\n   if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), data->subtype))\n     {\n       if (data->virt_depth)\n@@ -362,7 +362,7 @@ dcast_base_hint (tree subtype, tree target)\n   data.virt_depth = 0;\n   data.offset = NULL_TREE;\n   data.repeated_base = CLASSTYPE_REPEATED_BASE_P (target);\n-  \n+\n   dfs_walk_once_accessible (TYPE_BINFO (target), /*friends=*/false,\n \t\t\t    dfs_dcast_hint_pre, dfs_dcast_hint_post, &data);\n   return data.offset ? data.offset : ssize_int (-2);\n@@ -386,7 +386,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n       || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n       || TREE_CODE (type) == TYPENAME_TYPE)\n-    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and \n+    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and\n        BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;\n        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,\n        the code often worked even when we treated the index as a list\n@@ -477,7 +477,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \t}\n \n       if (DECL_NAME (field) == name\n-\t  && (!want_type \n+\t  && (!want_type\n \t      || TREE_CODE (field) == TYPE_DECL\n \t      || DECL_CLASS_TEMPLATE_P (field)))\n \treturn field;\n@@ -493,7 +493,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n }\n \n /* Return the FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, or\n-   NAMESPACE_DECL corresponding to the innermost non-block scope.  */  \n+   NAMESPACE_DECL corresponding to the innermost non-block scope.  */\n \n tree\n current_scope (void)\n@@ -563,11 +563,11 @@ tree\n context_for_name_lookup (tree decl)\n {\n   /* [class.union]\n-     \n+\n      For the purposes of name lookup, after the anonymous union\n      definition, the members of the anonymous union are considered to\n      have been defined in the scope in which the anonymous union is\n-     declared.  */ \n+     declared.  */\n   tree context = DECL_CONTEXT (decl);\n \n   while (context && TYPE_P (context) && ANON_AGGR_TYPE_P (context))\n@@ -611,7 +611,7 @@ dfs_access_in_type (tree binfo, void *data)\n       else\n \taccess = ak_public;\n     }\n-  else \n+  else\n     {\n       /* First, check for an access-declaration that gives us more\n \t access to the DECL.  The CONST_DECL for an enumeration\n@@ -620,11 +620,11 @@ dfs_access_in_type (tree binfo, void *data)\n       if (DECL_LANG_SPECIFIC (decl) && !DECL_DISCRIMINATOR_P (decl))\n \t{\n \t  tree decl_access = purpose_member (type, DECL_ACCESS (decl));\n-\t  \n+\n \t  if (decl_access)\n \t    {\n \t      decl_access = TREE_VALUE (decl_access);\n-\t      \n+\n \t      if (decl_access == access_public_node)\n \t\taccess = ak_public;\n \t      else if (decl_access == access_protected_node)\n@@ -641,7 +641,7 @@ dfs_access_in_type (tree binfo, void *data)\n \t  int i;\n \t  tree base_binfo;\n \t  VEC(tree,gc) *accesses;\n-\t  \n+\n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n \t  accesses = BINFO_BASE_ACCESSES (binfo);\n@@ -698,7 +698,7 @@ access_in_type (tree type, tree decl)\n \n        If a name can be reached by several paths through a multiple\n        inheritance graph, the access is that of the path that gives\n-       most access.  \n+       most access.\n \n     The algorithm we use is to make a post-order depth-first traversal\n     of the base-class hierarchy.  As we come up the tree, we annotate\n@@ -721,7 +721,7 @@ protected_accessible_p (tree decl, tree derived, tree binfo)\n        m as a member of N is protected, and the reference occurs in a\n        member or friend of class N, or in a member or friend of a\n        class P derived from N, where m as a member of P is private or\n-       protected.  \n+       protected.\n \n     Here DERIVED is a possible P and DECL is m.  accessible_p will\n     iterate over various values of N, but the access to m in DERIVED\n@@ -741,7 +741,7 @@ protected_accessible_p (tree decl, tree derived, tree binfo)\n   /* If m is inaccessible in DERIVED, then it's not a P.  */\n   if (access == ak_none)\n     return 0;\n-  \n+\n   /* [class.protected]\n \n      When a friend or a member function of a derived class references\n@@ -760,7 +760,7 @@ protected_accessible_p (tree decl, tree derived, tree binfo)\n       tree t = binfo;\n       while (BINFO_INHERITANCE_CHAIN (t))\n \tt = BINFO_INHERITANCE_CHAIN (t);\n-      \n+\n       if (!DERIVED_FROM_P (derived, BINFO_TYPE (t)))\n \treturn 0;\n     }\n@@ -802,8 +802,8 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n   if (TREE_CODE (scope) == FUNCTION_DECL\n       || DECL_FUNCTION_TEMPLATE_P (scope))\n     {\n-      /* Perhaps this SCOPE is a member of a class which is a \n-\t friend.  */ \n+      /* Perhaps this SCOPE is a member of a class which is a\n+\t friend.  */\n       if (DECL_CLASS_SCOPE_P (scope)\n \t  && friend_accessible_p (DECL_CONTEXT (scope), decl, binfo))\n \treturn 1;\n@@ -836,7 +836,7 @@ dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n \t  && is_friend (BINFO_TYPE (binfo), scope))\n \treturn binfo;\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -848,7 +848,7 @@ dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n    CONSIDER_LOCAL is true, do consider special access the current\n    scope or friendship thereof we might have.  */\n \n-int \n+int\n accessible_p (tree type, tree decl, bool consider_local_p)\n {\n   tree binfo;\n@@ -899,7 +899,7 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n        protected, or\n \n      --there exists a base class B of N that is accessible at the point\n-       of reference, and m is accessible when named in class B.  \n+       of reference, and m is accessible when named in class B.\n \n     We walk the base class hierarchy, checking these conditions.  */\n \n@@ -927,10 +927,10 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n   if (access == ak_public\n       || (access == ak_protected && protected_ok))\n     return 1;\n-  \n+\n   if (!consider_local_p)\n     return 0;\n-  \n+\n   /* Walk the hierarchy again, looking for a base class that allows\n      access.  */\n   return dfs_walk_once_accessible (binfo, /*friends=*/true,\n@@ -959,7 +959,7 @@ struct lookup_field_info {\n /* Within the scope of a template class, you can refer to the to the\n    current specialization with the name of the template itself.  For\n    example:\n-   \n+\n      template <typename T> struct S { S* sp; }\n \n    Returns nonzero if DECL is such a declaration in a class TYPE.  */\n@@ -1011,7 +1011,7 @@ static int\n is_subobject_of_p (tree parent, tree binfo)\n {\n   tree probe;\n-  \n+\n   for (probe = parent; probe; probe = BINFO_INHERITANCE_CHAIN (probe))\n     {\n       if (probe == binfo)\n@@ -1038,7 +1038,7 @@ lookup_field_r (tree binfo, void *data)\n   /* If this is a dependent base, don't look in it.  */\n   if (BINFO_DEPENDENT_BASE_P (binfo))\n     return NULL_TREE;\n-  \n+\n   /* If this base class is hidden by the best-known value so far, we\n      don't need to look.  */\n   if (lfi->rval_binfo && BINFO_INHERITANCE_CHAIN (binfo) == lfi->rval_binfo\n@@ -1088,21 +1088,21 @@ lookup_field_r (tree binfo, void *data)\n                                                 lfi->name);\n \t  if (e != NULL)\n \t    nval = TYPE_MAIN_DECL (e->type);\n-\t  else \n+\t  else\n \t    goto done;\n \t}\n     }\n \n   /* You must name a template base class with a template-id.  */\n-  if (!same_type_p (type, lfi->type) \n+  if (!same_type_p (type, lfi->type)\n       && template_self_reference_p (type, nval))\n     goto done;\n \n   /* If the lookup already found a match, and the new value doesn't\n      hide the old one, we might have an ambiguity.  */\n   if (lfi->rval_binfo\n       && !is_subobject_of_p (lfi->rval_binfo, binfo))\n-    \n+\n     {\n       if (nval == lfi->rval && shared_member_p (nval))\n \t/* The two things are really the same.  */\n@@ -1236,8 +1236,8 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n      just return NULL_TREE.  */\n   if (!protect && lfi.ambiguous)\n     return NULL_TREE;\n-  \n-  if (protect == 2) \n+\n+  if (protect == 2)\n     {\n       if (lfi.ambiguous)\n \treturn lfi.ambiguous;\n@@ -1260,7 +1260,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n       rval = error_mark_node;\n     }\n \n-  if (rval && is_overloaded_fn (rval)) \n+  if (rval && is_overloaded_fn (rval))\n     rval = build_baselink (rval_binfo, basetype_path, rval,\n \t\t\t   (IDENTIFIER_TYPENAME_P (name)\n \t\t\t   ? TREE_TYPE (name): NULL_TREE));\n@@ -1274,7 +1274,7 @@ tree\n lookup_field (tree xbasetype, tree name, int protect, bool want_type)\n {\n   tree rval = lookup_member (xbasetype, name, protect, want_type);\n-  \n+\n   /* Ignore functions, but propagate the ambiguity list.  */\n   if (!error_operand_p (rval)\n       && (rval && BASELINK_P (rval)))\n@@ -1314,7 +1314,7 @@ lookup_conversion_operator (tree class_type, tree type)\n       int i;\n       tree fn;\n       VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (class_type);\n-      \n+\n       for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n \t   VEC_iterate (tree, methods, i, fn); ++i)\n \t{\n@@ -1325,7 +1325,7 @@ lookup_conversion_operator (tree class_type, tree type)\n \t  fn = OVL_CURRENT (fn);\n \t  if (!DECL_CONV_FN_P (fn))\n \t    break;\n-\t  \n+\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    /* All the templated conversion functions are on the same\n \t       slot, so remember it.  */\n@@ -1348,7 +1348,7 @@ lookup_fnfields_1 (tree type, tree name)\n   tree fn;\n   tree tmp;\n   size_t i;\n-  \n+\n   if (!CLASS_TYPE_P (type))\n     return -1;\n \n@@ -1471,11 +1471,11 @@ class_method_index_for_fn (tree class_type, tree function)\n    `B', not `D'.  This function makes that adjustment.  */\n \n tree\n-adjust_result_of_qualified_name_lookup (tree decl, \n+adjust_result_of_qualified_name_lookup (tree decl,\n \t\t\t\t\ttree qualifying_scope,\n \t\t\t\t\ttree context_class)\n {\n-  if (context_class && CLASS_TYPE_P (qualifying_scope) \n+  if (context_class && CLASS_TYPE_P (qualifying_scope)\n       && DERIVED_FROM_P (qualifying_scope, context_class)\n       && BASELINK_P (decl))\n     {\n@@ -1493,7 +1493,7 @@ adjust_result_of_qualified_name_lookup (tree decl,\n       if (base)\n \t{\n \t  BASELINK_ACCESS_BINFO (decl) = base;\n-\t  BASELINK_BINFO (decl) \n+\t  BASELINK_BINFO (decl)\n \t    = lookup_base (base, BINFO_TYPE (BASELINK_BINFO (decl)),\n \t\t\t   ba_unique | ba_quiet,\n \t\t\t   NULL);\n@@ -1521,7 +1521,7 @@ dfs_walk_all (tree binfo, tree (*pre_fn) (tree, void *),\n   tree rval;\n   unsigned ix;\n   tree base_binfo;\n-  \n+\n   /* Call the pre-order walking function.  */\n   if (pre_fn)\n     {\n@@ -1550,7 +1550,7 @@ dfs_walk_all (tree binfo, tree (*pre_fn) (tree, void *),\n       gcc_assert (rval != dfs_skip_bases);\n       return rval;\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -1564,7 +1564,7 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n   tree rval;\n   unsigned ix;\n   tree base_binfo;\n-  \n+\n   /* Call the pre-order walking function.  */\n   if (pre_fn)\n     {\n@@ -1573,7 +1573,7 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n \t{\n \t  if (rval == dfs_skip_bases)\n \t    goto skip_bases;\n-\t  \n+\n \t  return rval;\n \t}\n     }\n@@ -1587,12 +1587,12 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n \t    continue;\n \t  BINFO_MARKED (base_binfo) = 1;\n \t}\n-  \n+\n       rval = dfs_walk_once_r (base_binfo, pre_fn, post_fn, data);\n       if (rval)\n \treturn rval;\n     }\n-  \n+\n  skip_bases:\n   /* Call the post-order walking function.  */\n   if (post_fn)\n@@ -1601,19 +1601,19 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n       gcc_assert (rval != dfs_skip_bases);\n       return rval;\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n /* Worker for dfs_walk_once. Recursively unmark the virtual base binfos of\n    BINFO.  */\n-   \n+\n static void\n dfs_unmark_r (tree binfo)\n {\n   unsigned ix;\n   tree base_binfo;\n-  \n+\n   /* Process the basetypes.  */\n   for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n@@ -1644,7 +1644,7 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n   gcc_assert (pre_fn || post_fn);\n   gcc_assert (!active);\n   active++;\n-  \n+\n   if (!CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n     /* We are not diamond shaped, and therefore cannot encounter the\n        same binfo twice.  */\n@@ -1660,7 +1660,7 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n \t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n-\t  \n+\n \t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n \t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n \t    BINFO_MARKED (base_binfo) = 0;\n@@ -1670,7 +1670,7 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n     }\n \n   active--;\n-  \n+\n   return rval;\n }\n \n@@ -1696,7 +1696,7 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n \t{\n \t  if (rval == dfs_skip_bases)\n \t    goto skip_bases;\n-\t  \n+\n \t  return rval;\n \t}\n     }\n@@ -1708,7 +1708,7 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n \n       if (mark && BINFO_MARKED (base_binfo))\n \tcontinue;\n-  \n+\n       /* If the base is inherited via private or protected\n      \t inheritance, then we can't see it, unless we are a friend of\n      \t the current binfo.  */\n@@ -1718,7 +1718,7 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n \t  if (!friends_p)\n \t    continue;\n \t  scope = current_scope ();\n-\t  if (!scope \n+\t  if (!scope\n \t      || TREE_CODE (scope) == NAMESPACE_DECL\n \t      || !is_friend (BINFO_TYPE (binfo), scope))\n \t    continue;\n@@ -1732,7 +1732,7 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n       if (rval)\n \treturn rval;\n     }\n-  \n+\n  skip_bases:\n   /* Call the post-order walking function.  */\n   if (post_fn)\n@@ -1741,7 +1741,7 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n       gcc_assert (rval != dfs_skip_bases);\n       return rval;\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -1757,7 +1757,7 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n   bool diamond_shaped = CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo));\n   tree rval = dfs_walk_once_accessible_r (binfo, friends_p, diamond_shaped,\n \t\t\t\t\t  pre_fn, post_fn, data);\n-  \n+\n   if (diamond_shaped)\n     {\n       if (!BINFO_INHERITANCE_CHAIN (binfo))\n@@ -1768,7 +1768,7 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n \t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n-\t  \n+\n \t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n \t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n \t    BINFO_MARKED (base_binfo) = 0;\n@@ -1804,12 +1804,12 @@ check_final_overrider (tree overrider, tree basefn)\n     {\n       /* Potentially covariant.  */\n       unsigned base_quals, over_quals;\n-      \n+\n       fail = !POINTER_TYPE_P (base_return);\n       if (!fail)\n \t{\n \t  fail = cp_type_quals (base_return) != cp_type_quals (over_return);\n-\t  \n+\n \t  base_return = TREE_TYPE (base_return);\n \t  over_return = TREE_TYPE (over_return);\n \t}\n@@ -1818,7 +1818,7 @@ check_final_overrider (tree overrider, tree basefn)\n \n       if ((base_quals & over_quals) != over_quals)\n \tfail = 1;\n-      \n+\n       if (CLASS_TYPE_P (base_return) && CLASS_TYPE_P (over_return))\n \t{\n \t  tree binfo = lookup_base (over_return, base_return,\n@@ -1867,7 +1867,7 @@ check_final_overrider (tree overrider, tree basefn)\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n     }\n-  \n+\n   /* Check throw specifier is at least as strict.  */\n   if (!comp_except_specs (base_throw, over_throw, 0))\n     {\n@@ -1876,17 +1876,17 @@ check_final_overrider (tree overrider, tree basefn)\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n     }\n-  \n+\n   return 1;\n }\n \n /* Given a class TYPE, and a function decl FNDECL, look for\n    virtual functions in TYPE's hierarchy which FNDECL overrides.\n    We do not look in TYPE itself, only its bases.\n-   \n+\n    Returns nonzero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we\n    find that it overrides anything.\n-   \n+\n    We check that every function which is overridden, is correctly\n    overridden.  */\n \n@@ -1901,7 +1901,7 @@ look_for_overrides (tree type, tree fndecl)\n   for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n       tree basetype = BINFO_TYPE (base_binfo);\n-      \n+\n       if (TYPE_POLYMORPHIC_P (basetype))\n         found += look_for_overrides_r (basetype, fndecl);\n     }\n@@ -1929,7 +1929,7 @@ look_for_overrides_here (tree type, tree fndecl)\n   if (ix >= 0)\n     {\n       tree fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n-  \n+\n       for (; fns; fns = OVL_NEXT (fns))\n         {\n           tree fn = OVL_CURRENT (fns);\n@@ -1994,7 +1994,7 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n   if (!BINFO_PRIMARY_P (binfo))\n     {\n       tree virtuals;\n-      \n+\n       for (virtuals = BINFO_VIRTUALS (binfo);\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n@@ -2155,11 +2155,11 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n \t  int we_hide_them;\n \t  int they_hide_us;\n \t  tree *prev, other;\n-\t  \n+\n \t  if (!(virtual_depth || TREE_STATIC (level)))\n \t    /* Neither is morally virtual, so cannot hide each other.  */\n \t    continue;\n-\t  \n+\n \t  if (!TREE_VALUE (level))\n \t    /* They evaporated away already.  */\n \t    continue;\n@@ -2172,7 +2172,7 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n \t  if (!(we_hide_them || they_hide_us))\n \t    /* Neither is within the other, so no hiding can occur.  */\n \t    continue;\n-\t  \n+\n \t  for (prev = &TREE_VALUE (level), other = *prev; other;)\n \t    {\n \t      if (same_type_p (to_type, TREE_TYPE (other)))\n@@ -2212,12 +2212,12 @@ split_conversions (tree my_convs, tree parent_convs,\n {\n   tree t;\n   tree prev;\n-  \n+\n   /* Remove the original other_convs portion from child_convs.  */\n   for (prev = NULL, t = child_convs;\n        t != other_convs; prev = t, t = TREE_CHAIN (t))\n     continue;\n-  \n+\n   if (prev)\n     TREE_CHAIN (prev) = NULL_TREE;\n   else\n@@ -2231,7 +2231,7 @@ split_conversions (tree my_convs, tree parent_convs,\n     }\n   else\n     my_convs = child_convs;\n-  \n+\n   return my_convs;\n }\n \n@@ -2276,15 +2276,15 @@ lookup_conversions_r (tree binfo,\n   if (!TYPE_HAS_CONVERSION (BINFO_TYPE (binfo)))\n     {\n       *convs = *tpl_convs = NULL_TREE;\n-      \n+\n       return 0;\n     }\n-  \n+\n   if (BINFO_VIRTUAL_P (binfo))\n     virtual_depth++;\n-  \n+\n   /* First, locate the unhidden ones at this level.  */\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        VEC_iterate (tree, method_vec, i, conv);\n        ++i)\n     {\n@@ -2303,7 +2303,7 @@ lookup_conversions_r (tree binfo,\n \t    {\n \t      tree tpl = OVL_CURRENT (tpls);\n \t      tree type = DECL_CONV_FN_TYPE (tpl);\n-\t      \n+\n \t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n \t\t\t\t      type, parent_tpl_convs, other_tpl_convs))\n \t\t{\n@@ -2324,7 +2324,7 @@ lookup_conversions_r (tree binfo,\n \t  if (!IDENTIFIER_MARKED (name))\n \t    {\n \t      tree type = DECL_CONV_FN_TYPE (cur);\n-\t      \n+\n \t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n \t\t\t\t      type, parent_convs, other_convs))\n \t\t{\n@@ -2347,7 +2347,7 @@ lookup_conversions_r (tree binfo,\n       if (virtual_depth)\n \tTREE_STATIC (parent_convs) = 1;\n     }\n-  \n+\n   if (my_tpl_convs)\n     {\n       parent_tpl_convs = tree_cons (binfo, my_tpl_convs, parent_tpl_convs);\n@@ -2357,7 +2357,7 @@ lookup_conversions_r (tree binfo,\n \n   child_convs = other_convs;\n   child_tpl_convs = other_tpl_convs;\n-  \n+\n   /* Now iterate over each base, looking for more conversions.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n@@ -2383,7 +2383,7 @@ lookup_conversions_r (tree binfo,\n \t\t\t      child_convs, other_convs);\n   *tpl_convs = split_conversions (my_tpl_convs, parent_tpl_convs,\n \t\t\t\t  child_tpl_convs, other_tpl_convs);\n-  \n+\n   return my_virtualness;\n }\n \n@@ -2401,15 +2401,15 @@ lookup_conversions (tree type)\n {\n   tree convs, tpl_convs;\n   tree list = NULL_TREE;\n-  \n+\n   complete_type (type);\n   if (!TYPE_BINFO (type))\n     return NULL_TREE;\n-  \n+\n   lookup_conversions_r (TYPE_BINFO (type), 0, 0,\n \t\t\tNULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n \t\t\t&convs, &tpl_convs);\n-  \n+\n   /* Flatten the list-of-lists */\n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n@@ -2423,7 +2423,7 @@ lookup_conversions (tree type)\n \t  list = probe;\n \t}\n     }\n-  \n+\n   for (; tpl_convs; tpl_convs = TREE_CHAIN (tpl_convs))\n     {\n       tree probe, next;\n@@ -2436,7 +2436,7 @@ lookup_conversions (tree type)\n \t  list = probe;\n \t}\n     }\n-  \n+\n   return list;\n }\n \n@@ -2464,7 +2464,7 @@ binfo_via_virtual (tree binfo, tree limit)\n   if (limit && !CLASSTYPE_VBASECLASSES (limit))\n     /* LIMIT has no virtual bases, so BINFO cannot be via one.  */\n     return NULL_TREE;\n-  \n+\n   for (; binfo && !SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), limit);\n        binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n@@ -2482,7 +2482,7 @@ tree\n copied_binfo (tree binfo, tree here)\n {\n   tree result = NULL_TREE;\n-  \n+\n   if (BINFO_VIRTUAL_P (binfo))\n     {\n       tree t;\n@@ -2498,7 +2498,7 @@ copied_binfo (tree binfo, tree here)\n       tree cbinfo;\n       tree base_binfo;\n       int ix;\n-      \n+\n       cbinfo = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n       for (ix = 0; BINFO_BASE_ITERATE (cbinfo, ix, base_binfo); ix++)\n \tif (SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo)))\n@@ -2523,7 +2523,7 @@ binfo_for_vbase (tree base, tree t)\n   unsigned ix;\n   tree binfo;\n   VEC(tree,gc) *vbases;\n-  \n+\n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n        VEC_iterate (tree, vbases, ix, binfo); ix++)\n     if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), base))\n@@ -2540,7 +2540,7 @@ tree\n original_binfo (tree binfo, tree here)\n {\n   tree result = NULL;\n-  \n+\n   if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), BINFO_TYPE (here)))\n     result = here;\n   else if (BINFO_VIRTUAL_P (binfo))\n@@ -2550,13 +2550,13 @@ original_binfo (tree binfo, tree here)\n   else if (BINFO_INHERITANCE_CHAIN (binfo))\n     {\n       tree base_binfos;\n-      \n+\n       base_binfos = original_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n       if (base_binfos)\n \t{\n \t  int ix;\n \t  tree base_binfo;\n-\t  \n+\n \t  for (ix = 0; (base_binfo = BINFO_BASE_BINFO (base_binfos, ix)); ix++)\n \t    if (SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo),\n \t\t\t\t   BINFO_TYPE (binfo)))\n@@ -2566,7 +2566,7 @@ original_binfo (tree binfo, tree here)\n \t      }\n \t}\n     }\n-  \n+\n   return result;\n }\n "}, {"sha": "92a195e54a723c6c7052f0ecf5f089c410a5f7be", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -1,25 +1,25 @@\n /* Perform the semantic phase of parsing, i.e., the process of\n    building tree structure, checking semantic consistency, and\n    building RTL.  These routines are used both during actual parsing\n-   and during the instantiation of template functions. \n+   and during the instantiation of template functions.\n \n    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n    Written by Mark Mitchell (mmitchell@usa.net) based on code found\n-   formerly in parse.y and pt.c.  \n+   formerly in parse.y and pt.c.\n \n    This file is part of GCC.\n \n    GCC is free software; you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2, or (at your option)\n    any later version.\n-   \n+\n    GCC is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    General Public License for more details.\n-   \n+\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING.  If not, write to the Free\n    Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n@@ -91,7 +91,7 @@ static tree finalize_nrv_r (tree *, int *, void *);\n    instantiations.\n \n    Typical use of access checking functions is described here:\n-   \n+\n    1. When we enter a context that requires certain access checking\n       mode, the function `push_deferring_access_checks' is called with\n       DEFERRING argument specifying the desired mode.  Access checking\n@@ -121,23 +121,23 @@ typedef struct deferred_access GTY(())\n      names used in a decl-specifier-seq until we know what is being\n      declared because code like:\n \n-       class A { \n+       class A {\n          class B {};\n          B* f();\n        }\n \n        A::B* A::f() { return 0; }\n \n-     is valid, even though `A::B' is not generally accessible.  \n+     is valid, even though `A::B' is not generally accessible.\n \n      The TREE_PURPOSE of each node is the scope used to qualify the\n      name being looked up; the TREE_VALUE is the DECL to which the\n      name was resolved.  */\n   tree deferred_access_checks;\n-  \n+\n   /* The current mode of access checks.  */\n   enum deferring_kind deferring_access_checks_kind;\n-  \n+\n } deferred_access;\n DEF_VEC_O (deferred_access);\n DEF_VEC_ALLOC_O (deferred_access,gc);\n@@ -199,8 +199,8 @@ pop_deferring_access_checks (void)\n     VEC_pop (deferred_access, deferred_access_stack);\n }\n \n-/* Returns a TREE_LIST representing the deferred checks.  \n-   The TREE_PURPOSE of each node is the type through which the \n+/* Returns a TREE_LIST representing the deferred checks.\n+   The TREE_PURPOSE of each node is the type through which the\n    access occurred; the TREE_VALUE is the declaration named.\n    */\n \n@@ -236,20 +236,20 @@ pop_to_parent_deferring_access_checks (void)\n       if (ptr->deferring_access_checks_kind == dk_no_deferred)\n \t{\n \t  /* Check access.  */\n-\t  for (; checks; checks = TREE_CHAIN (checks)) \n-\t    enforce_access (TREE_PURPOSE (checks), \n+\t  for (; checks; checks = TREE_CHAIN (checks))\n+\t    enforce_access (TREE_PURPOSE (checks),\n \t\t\t    TREE_VALUE (checks));\n \t}\n       else\n \t{\n \t  /* Merge with parent.  */\n \t  tree next;\n \t  tree original = ptr->deferred_access_checks;\n-\t  \n+\n \t  for (; checks; checks = next)\n \t    {\n \t      tree probe;\n-\t      \n+\n \t      next = TREE_CHAIN (checks);\n \n \t      for (probe = original; probe; probe = TREE_CHAIN (probe))\n@@ -290,7 +290,7 @@ perform_deferred_access_checks (void)\n        deferred_check;\n        deferred_check = TREE_CHAIN (deferred_check))\n     /* Check access.  */\n-    enforce_access (TREE_PURPOSE (deferred_check), \n+    enforce_access (TREE_PURPOSE (deferred_check),\n \t\t    TREE_VALUE (deferred_check));\n }\n \n@@ -307,18 +307,18 @@ perform_or_defer_access_check (tree binfo, tree decl)\n      */\n   if (deferred_access_no_check)\n     return;\n-  \n+\n   gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n \n   ptr = VEC_last (deferred_access, deferred_access_stack);\n-  \n+\n   /* If we are not supposed to defer access checks, just check now.  */\n   if (ptr->deferring_access_checks_kind == dk_no_deferred)\n     {\n       enforce_access (binfo, decl);\n       return;\n     }\n-  \n+\n   /* See if we are already going to perform this check.  */\n   for (check = ptr->deferred_access_checks;\n        check;\n@@ -373,8 +373,8 @@ add_stmt (tree t)\n stmt_tree\n current_stmt_tree (void)\n {\n-  return (cfun \n-\t  ? &cfun->language->base.x_stmt_tree \n+  return (cfun\n+\t  ? &cfun->language->base.x_stmt_tree\n \t  : &scope_chain->x_stmt_tree);\n }\n \n@@ -436,7 +436,7 @@ do_poplevel (tree stmt_list)\n     block = poplevel (kept_level_p (), 1, 0);\n \n   stmt_list = pop_stmt_list (stmt_list);\n-  \n+\n   if (!processing_template_decl)\n     {\n       stmt_list = c_build_bind_expr (block, stmt_list);\n@@ -446,7 +446,7 @@ do_poplevel (tree stmt_list)\n   return stmt_list;\n }\n \n-/* Begin a new scope.  */ \n+/* Begin a new scope.  */\n \n static tree\n do_pushlevel (scope_kind sk)\n@@ -505,7 +505,7 @@ finish_cond (tree *cond_p, tree expr)\n             for (;;) { A x = 42; if (!x) break; }\n    The statement list for BODY will be empty if the conditional did\n    not declare anything.  */\n-                                                                                \n+\n static void\n simplify_loop_decl_cond (tree *cond_p, tree body)\n {\n@@ -516,7 +516,7 @@ simplify_loop_decl_cond (tree *cond_p, tree body)\n \n   cond = *cond_p;\n   *cond_p = boolean_true_node;\n-   \n+\n   if_stmt = begin_if_stmt ();\n   cond = build_unary_op (TRUTH_NOT_EXPR, cond, 0);\n   finish_if_stmt_cond (cond, if_stmt);\n@@ -548,7 +548,7 @@ finish_goto_stmt (tree destination)\n \t addresses, or some such.  */\n       DECL_UNINLINABLE (current_function_decl) = 1;\n     }\n-  \n+\n   check_goto (destination);\n \n   return add_stmt (build_stmt (GOTO_EXPR, destination));\n@@ -626,7 +626,7 @@ begin_if_stmt (void)\n /* Process the COND of an if-statement, which may be given by\n    IF_STMT.  */\n \n-void \n+void\n finish_if_stmt_cond (tree cond, tree if_stmt)\n {\n   finish_cond (&IF_COND (if_stmt), maybe_convert_cond (cond));\n@@ -663,7 +663,7 @@ finish_else_clause (tree if_stmt)\n \n /* Finish an if-statement.  */\n \n-void \n+void\n finish_if_stmt (tree if_stmt)\n {\n   tree scope = TREE_CHAIN (if_stmt);\n@@ -689,7 +689,7 @@ begin_while_stmt (void)\n /* Process the COND of a while-statement, which may be given by\n    WHILE_STMT.  */\n \n-void \n+void\n finish_while_stmt_cond (tree cond, tree while_stmt)\n {\n   finish_cond (&WHILE_COND (while_stmt), maybe_convert_cond (cond));\n@@ -698,7 +698,7 @@ finish_while_stmt_cond (tree cond, tree while_stmt)\n \n /* Finish a while-statement, which may be given by WHILE_STMT.  */\n \n-void \n+void\n finish_while_stmt (tree while_stmt)\n {\n   WHILE_BODY (while_stmt) = do_poplevel (WHILE_BODY (while_stmt));\n@@ -748,7 +748,7 @@ finish_return_stmt (tree expr)\n   if (!processing_template_decl)\n     {\n       if (DECL_DESTRUCTOR_P (current_function_decl)\n-\t  || (DECL_CONSTRUCTOR_P (current_function_decl) \n+\t  || (DECL_CONSTRUCTOR_P (current_function_decl)\n \t      && targetm.cxx.cdtor_returns_this ()))\n \t{\n \t  /* Similarly, all destructors must run destructors for\n@@ -774,7 +774,7 @@ begin_for_stmt (void)\n {\n   tree r;\n \n-  r = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE, \n+  r = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n \t\t  NULL_TREE, NULL_TREE);\n \n   if (flag_new_for_scope > 0)\n@@ -853,7 +853,7 @@ finish_for_stmt (tree for_stmt)\n       add_stmt (do_poplevel (scope));\n     }\n \n-  finish_stmt (); \n+  finish_stmt ();\n }\n \n /* Finish a break-statement.  */\n@@ -945,7 +945,7 @@ finish_switch_stmt (tree switch_stmt)\n \n   SWITCH_STMT_BODY (switch_stmt) =\n     pop_stmt_list (SWITCH_STMT_BODY (switch_stmt));\n-  pop_switch (); \n+  pop_switch ();\n   finish_stmt ();\n \n   scope = TREE_CHAIN (switch_stmt);\n@@ -1090,7 +1090,7 @@ finish_handler (tree handler)\n /* Begin a compound statement.  FLAGS contains some bits that control the\n    behavior and context.  If BCS_NO_SCOPE is set, the compound statement\n    does not define a scope.  If BCS_FN_BODY is set, this is the outermost\n-   block of a function.  If BCS_TRY_BLOCK is set, this is the block \n+   block of a function.  If BCS_TRY_BLOCK is set, this is the block\n    created on behalf of a TRY statement.  Returns a token to be passed to\n    finish_compound_stmt.  */\n \n@@ -1107,7 +1107,7 @@ begin_compound_stmt (unsigned int flags)\n       /* Normally, we try hard to keep the BLOCK for a statement-expression.\n \t But, if it's a statement-expression with a scopeless block, there's\n \t nothing to keep, and we don't want to accidentally keep a block\n-\t *inside* the scopeless block.  */ \n+\t *inside* the scopeless block.  */\n       keep_next_level (false);\n     }\n   else\n@@ -1215,15 +1215,15 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n       for (i = 0, t = input_operands; t; ++i, t = TREE_CHAIN (t))\n \t{\n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-\t  operand = decay_conversion (TREE_VALUE (t)); \n+\t  operand = decay_conversion (TREE_VALUE (t));\n \n \t  /* If the type of the operand hasn't been determined (e.g.,\n \t     because it involves an overloaded function), then issue\n \t     an error message.  There's no context available to\n \t     resolve the overloading.  */\n \t  if (TREE_TYPE (operand) == unknown_type_node)\n \t    {\n-\t      error (\"type of asm operand %qE could not be determined\", \n+\t      error (\"type of asm operand %qE could not be determined\",\n                      TREE_VALUE (t));\n \t      operand = error_mark_node;\n \t    }\n@@ -1279,7 +1279,7 @@ finish_label_decl (tree name)\n \n /* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n \n-void \n+void\n finish_decl_cleanup (tree decl, tree cleanup)\n {\n   push_cleanup (decl, cleanup, false);\n@@ -1323,10 +1323,10 @@ finish_parenthesized_expr (tree expr)\n     /* [expr.unary.op]/3 The qualified id of a pointer-to-member must not be\n        enclosed in parentheses.  */\n     PTRMEM_OK_P (expr) = 0;\n-  \n+\n   if (TREE_CODE (expr) == STRING_CST)\n     PAREN_STRING_LITERAL_P (expr) = 1;\n-  \n+\n   return expr;\n }\n \n@@ -1340,7 +1340,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n   if (!object)\n     {\n-      if (current_function_decl \n+      if (current_function_decl\n \t  && DECL_STATIC_FUNCTION_P (current_function_decl))\n \tcp_error_at (\"invalid use of member %qD in static member function\",\n \t\t     decl);\n@@ -1361,21 +1361,21 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t{\n \t  /* Set the cv qualifiers.  */\n \t  int quals = cp_type_quals (TREE_TYPE (current_class_ref));\n-\t  \n+\n \t  if (DECL_MUTABLE_P (decl))\n \t    quals &= ~TYPE_QUAL_CONST;\n \n \t  quals |= cp_type_quals (TREE_TYPE (decl));\n \t  type = cp_build_qualified_type (type, quals);\n \t}\n-      \n+\n       return build_min (COMPONENT_REF, type, object, decl, NULL_TREE);\n     }\n   else\n     {\n       tree access_type = TREE_TYPE (object);\n       tree lookup_context = context_for_name_lookup (decl);\n-      \n+\n       while (!DERIVED_FROM_P (lookup_context, access_type))\n \t{\n \t  access_type = TYPE_CONTEXT (access_type);\n@@ -1421,8 +1421,8 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n    `A::B' then NESTED_NAME_SPECIFIER is `A'.  */\n \n void\n-check_accessibility_of_qualified_id (tree decl, \n-\t\t\t\t     tree object_type, \n+check_accessibility_of_qualified_id (tree decl,\n+\t\t\t\t     tree object_type,\n \t\t\t\t     tree nested_name_specifier)\n {\n   tree scope;\n@@ -1431,14 +1431,14 @@ check_accessibility_of_qualified_id (tree decl,\n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return;\n-  \n+\n   /* Determine the SCOPE of DECL.  */\n   scope = context_for_name_lookup (decl);\n   /* If the SCOPE is not a type, then DECL is not a member.  */\n   if (!TYPE_P (scope))\n     return;\n   /* Compute the scope through which DECL is being accessed.  */\n-  if (object_type \n+  if (object_type\n       /* OBJECT_TYPE might not be a class type; consider:\n \n \t   class A { typedef int I; };\n@@ -1496,7 +1496,7 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n     {\n       if (TREE_CODE (expr) == SCOPE_REF)\n \texpr = TREE_OPERAND (expr, 1);\n-      expr = build_offset_ref (qualifying_class, expr, \n+      expr = build_offset_ref (qualifying_class, expr,\n \t\t\t       /*address_p=*/true);\n       return expr;\n     }\n@@ -1515,9 +1515,9 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n       /* If so, the expression may be relative to the current\n \t class.  */\n       if (!shared_member_p (fns)\n-\t  && current_class_type \n+\t  && current_class_type\n \t  && DERIVED_FROM_P (qualifying_class, current_class_type))\n-\texpr = (build_class_member_access_expr \n+\texpr = (build_class_member_access_expr\n \t\t(maybe_dummy_object (qualifying_class, NULL),\n \t\t expr,\n \t\t BASELINK_ACCESS_BINFO (expr),\n@@ -1534,7 +1534,7 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n /* Begin a statement-expression.  The value returned must be passed to\n    finish_stmt_expr.  */\n \n-tree \n+tree\n begin_stmt_expr (void)\n {\n   return push_stmt_list ();\n@@ -1552,7 +1552,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \n   if (error_operand_p (expr))\n     return error_mark_node;\n-  \n+\n   if (expr)\n     {\n       if (!processing_template_decl && !VOID_TYPE_P (TREE_TYPE (expr)))\n@@ -1594,21 +1594,21 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t  add_stmt (result);\n \t}\n     }\n-  \n+\n   finish_stmt ();\n \n   /* Remember the last expression so that finish_stmt_expr\n      can pull it apart.  */\n   TREE_TYPE (stmt_expr) = result;\n-  \n+\n   return result;\n }\n \n /* Finish a statement-expression.  EXPR should be the value returned\n    by the previous begin_stmt_expr.  Returns an expression\n    representing the statement-expression.  */\n \n-tree \n+tree\n finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n {\n   tree result, result_stmt, type;\n@@ -1755,7 +1755,7 @@ perform_koenig_lookup (tree fn, tree args)\n \n    Returns code for the call.  */\n \n-tree \n+tree\n finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n {\n   tree result;\n@@ -1820,7 +1820,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \t   function call is transformed into a qualified function call\n \t   using (*this) as the postfix-expression to the left of the\n \t   . operator.... [Otherwise] a contrived object of type T\n-\t   becomes the implied object argument.  \n+\t   becomes the implied object argument.\n \n         This paragraph is unclear about this situation:\n \n@@ -1829,9 +1829,9 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \t  struct C : public A { void g() { B::f(); }};\n \n \tIn particular, for `B::f', this paragraph does not make clear\n-\twhether \"the class of that member function\" refers to `A' or \n+\twhether \"the class of that member function\" refers to `A' or\n \tto `B'.  We believe it refers to `B'.  */\n-      if (current_class_type \n+      if (current_class_type\n \t  && DERIVED_FROM_P (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n \t\t\t     current_class_type)\n \t  && current_class_ref)\n@@ -1856,7 +1856,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \t}\n \n       result = build_new_method_call (object, fn, args, NULL_TREE,\n-\t\t\t\t      (disallow_virtual \n+\t\t\t\t      (disallow_virtual\n \t\t\t\t       ? LOOKUP_NONVIRTUAL : 0));\n     }\n   else if (is_overloaded_fn (fn))\n@@ -1905,15 +1905,15 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n    is indicated by CODE, which should be POSTINCREMENT_EXPR or\n    POSTDECREMENT_EXPR.)  */\n \n-tree \n+tree\n finish_increment_expr (tree expr, enum tree_code code)\n {\n-  return build_x_unary_op (code, expr);  \n+  return build_x_unary_op (code, expr);\n }\n \n /* Finish a use of `this'.  Returns an expression for `this'.  */\n \n-tree \n+tree\n finish_this_expr (void)\n {\n   tree result;\n@@ -1945,7 +1945,7 @@ finish_this_expr (void)\n    the TYPE for the type given.  If SCOPE is non-NULL, the expression\n    was of the form `OBJECT.SCOPE::~DESTRUCTOR'.  */\n \n-tree \n+tree\n finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n {\n   if (destructor == error_mark_node)\n@@ -1960,7 +1960,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n \t  error (\"invalid qualifying scope in pseudo-destructor name\");\n \t  return error_mark_node;\n \t}\n-      \n+\n       /* [expr.pseudo] says both:\n \n            The type designated by the pseudo-destructor-name shall be\n@@ -1974,7 +1974,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n \n          We implement the more generous second sentence, since that is\n          what most other compilers do.  */\n-      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (object), \n+      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (object),\n \t\t\t\t\t\t      destructor))\n \t{\n \t  error (\"%qE is not of type %qT\", object, destructor);\n@@ -2047,7 +2047,7 @@ tree\n finish_fname (tree id)\n {\n   tree decl;\n-  \n+\n   decl = fname_decl (C_RID_CODE (id), id);\n   if (processing_template_decl)\n     decl = DECL_NAME (decl);\n@@ -2056,7 +2056,7 @@ finish_fname (tree id)\n \n /* Finish a translation unit.  */\n \n-void \n+void\n finish_translation_unit (void)\n {\n   /* In case there were missing closebraces,\n@@ -2072,7 +2072,7 @@ finish_translation_unit (void)\n /* Finish a template type parameter, specified as AGGR IDENTIFIER.\n    Returns the parameter.  */\n \n-tree \n+tree\n finish_template_type_parm (tree aggr, tree identifier)\n {\n   if (aggr != class_type_node)\n@@ -2087,7 +2087,7 @@ finish_template_type_parm (tree aggr, tree identifier)\n /* Finish a template template parameter, specified as AGGR IDENTIFIER.\n    Returns the parameter.  */\n \n-tree \n+tree\n finish_template_template_parm (tree aggr, tree identifier)\n {\n   tree decl = build_decl (TYPE_DECL, identifier, NULL_TREE);\n@@ -2119,7 +2119,7 @@ check_template_template_default_arg (tree argument)\n \n \t  /* Try to emit a slightly smarter error message if we detect\n \t     that the user is using a template instantiation.  */\n-\t  if (CLASSTYPE_TEMPLATE_INFO (t) \n+\t  if (CLASSTYPE_TEMPLATE_INFO (t)\n \t      && CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n \t    error (\"invalid use of type %qT as a default value for a \"\n \t           \"template template-parameter\", t);\n@@ -2168,7 +2168,7 @@ begin_class_definition (tree t)\n \n   /* Update the location of the decl.  */\n   DECL_SOURCE_LOCATION (TYPE_NAME (t)) = input_location;\n-  \n+\n   if (TYPE_BEING_DEFINED (t))\n     {\n       t = make_aggr_type (TREE_CODE (t));\n@@ -2198,7 +2198,7 @@ begin_class_definition (tree t)\n \t(t, finfo->interface_unknown);\n     }\n   reset_specialization();\n-  \n+\n   /* Make a declaration for this class in its own scope.  */\n   build_self_reference ();\n \n@@ -2222,9 +2222,9 @@ finish_member_declaration (tree decl)\n   gcc_assert (TREE_CHAIN (decl) == NULL_TREE);\n \n   /* Set up access control for DECL.  */\n-  TREE_PRIVATE (decl) \n+  TREE_PRIVATE (decl)\n     = (current_access_specifier == access_private_node);\n-  TREE_PROTECTED (decl) \n+  TREE_PROTECTED (decl)\n     = (current_access_specifier == access_protected_node);\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n@@ -2245,7 +2245,7 @@ finish_member_declaration (tree decl)\n   /* Put functions on the TYPE_METHODS list and everything else on the\n      TYPE_FIELDS list.  Note that these are built up in reverse order.\n      We reverse them (to obtain declaration order) in finish_struct.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL \n+  if (TREE_CODE (decl) == FUNCTION_DECL\n       || DECL_FUNCTION_TEMPLATE_P (decl))\n     {\n       /* We also need to add this function to the\n@@ -2255,7 +2255,7 @@ finish_member_declaration (tree decl)\n       TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n       TYPE_METHODS (current_class_type) = decl;\n \n-      maybe_add_class_template_decl_list (current_class_type, decl, \n+      maybe_add_class_template_decl_list (current_class_type, decl,\n \t\t\t\t\t  /*friend_p=*/0);\n     }\n   /* Enter the DECL into the scope of the class.  */\n@@ -2280,15 +2280,15 @@ finish_member_declaration (tree decl)\n \t list.)  */\n \n       if (TREE_CODE (decl) == TYPE_DECL)\n-\tTYPE_FIELDS (current_class_type) \n+\tTYPE_FIELDS (current_class_type)\n \t  = chainon (TYPE_FIELDS (current_class_type), decl);\n       else\n \t{\n \t  TREE_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n \t  TYPE_FIELDS (current_class_type) = decl;\n \t}\n \n-      maybe_add_class_template_decl_list (current_class_type, decl, \n+      maybe_add_class_template_decl_list (current_class_type, decl,\n \t\t\t\t\t  /*friend_p=*/0);\n     }\n \n@@ -2319,7 +2319,7 @@ note_decl_for_pch (tree decl)\n       comdat_linkage (decl);\n       DECL_INTERFACE_KNOWN (decl) = 1;\n     }\n-  \n+\n   /* There's a good chance that we'll have to mangle names at some\n      point, even if only for emission in debugging information.  */\n   if (TREE_CODE (decl) == VAR_DECL\n@@ -2365,7 +2365,7 @@ finish_template_type (tree name, tree args, int entering_scope)\n    access_{default,public,protected_private}_node.  For a virtual base\n    we set TREE_TYPE.  */\n \n-tree \n+tree\n finish_base_specifier (tree base, tree access, bool virtual_p)\n {\n   tree result;\n@@ -2415,12 +2415,12 @@ qualified_name_lookup_error (tree scope, tree name, tree decl)\n   else\n     error (\"%<::%D%> has not been declared\", name);\n }\n-\t      \n+\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n    ID_EXPRESSION.  DECL is the entity to which that name has been\n-   resolved.  \n+   resolved.\n \n    *CONSTANT_EXPRESSION_P is true if we are presently parsing a\n    constant-expression.  In that case, *NON_CONSTANT_EXPRESSION_P will\n@@ -2439,12 +2439,12 @@ qualified_name_lookup_error (tree scope, tree name, tree decl)\n    Return an expression for the entity, after issuing appropriate\n    diagnostics.  This function is also responsible for transforming a\n    reference to a non-static member into a COMPONENT_REF that makes\n-   the use of \"this\" explicit.  \n+   the use of \"this\" explicit.\n \n    Upon return, *IDK will be filled in appropriately.  */\n \n tree\n-finish_id_expression (tree id_expression, \n+finish_id_expression (tree id_expression,\n \t\t      tree decl,\n \t\t      tree scope,\n \t\t      cp_id_kind *idk,\n@@ -2467,13 +2467,13 @@ finish_id_expression (tree id_expression,\n \t   || TREE_CODE (decl) == TYPE_DECL)\n     ;\n   /* Look up the name.  */\n-  else \n+  else\n     {\n       if (decl == error_mark_node)\n \t{\n \t  /* Name lookup failed.  */\n-\t  if (scope \n-\t      && (!TYPE_P (scope) \n+\t  if (scope\n+\t      && (!TYPE_P (scope)\n \t\t  || (!dependent_type_p (scope)\n \t\t      && !(TREE_CODE (id_expression) == IDENTIFIER_NODE\n \t\t\t   && IDENTIFIER_TYPENAME_P (id_expression)\n@@ -2529,13 +2529,13 @@ finish_id_expression (tree id_expression,\n       || TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n     {\n       tree r;\n-      \n+\n       *idk = CP_ID_KIND_NONE;\n       if (TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n \tdecl = TEMPLATE_PARM_DECL (decl);\n       r = convert_from_reference (DECL_INITIAL (decl));\n-      \n-      if (integral_constant_expression_p \n+\n+      if (integral_constant_expression_p\n \t  && !dependent_type_p (TREE_TYPE (decl))\n \t  && !(INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (r))))\n \t{\n@@ -2547,7 +2547,7 @@ finish_id_expression (tree id_expression,\n \t}\n       return r;\n     }\n-  /* Similarly, we resolve enumeration constants to their \n+  /* Similarly, we resolve enumeration constants to their\n      underlying values.  */\n   else if (TREE_CODE (decl) == CONST_DECL)\n     {\n@@ -2563,7 +2563,7 @@ finish_id_expression (tree id_expression,\n       /* If the declaration was explicitly qualified indicate\n \t that.  The semantics of `A::f(3)' are different than\n \t `f(3)' if `f' is virtual.  */\n-      *idk = (scope \n+      *idk = (scope\n \t      ? CP_ID_KIND_QUALIFIED\n \t      : (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n \t\t ? CP_ID_KIND_TEMPLATE_ID\n@@ -2587,13 +2587,13 @@ finish_id_expression (tree id_expression,\n       /* A template-id where the name of the template was not resolved\n \t is definitely dependent.  */\n       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (decl, 0)) \n+\t       && (TREE_CODE (TREE_OPERAND (decl, 0))\n \t\t   == IDENTIFIER_NODE))\n \tdependent_p = true;\n       /* For anything except an overloaded function, just check its\n \t type.  */\n       else if (!is_overloaded_fn (decl))\n-\tdependent_p \n+\tdependent_p\n \t  = dependent_type_p (TREE_TYPE (decl));\n       /* For a set of overloaded functions, check each of the\n \t functions.  */\n@@ -2699,7 +2699,7 @@ finish_id_expression (tree id_expression,\n \t    }\n \t  *non_integral_constant_expression_p = true;\n \t}\n-      \n+\n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t{\n \t  error (\"use of namespace %qD as expression\", decl);\n@@ -2728,7 +2728,7 @@ finish_id_expression (tree id_expression,\n \n       if (scope)\n \t{\n-\t  decl = (adjust_result_of_qualified_name_lookup \n+\t  decl = (adjust_result_of_qualified_name_lookup\n \t\t  (decl, scope, current_class_type));\n \n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -2739,7 +2739,7 @@ finish_id_expression (tree id_expression,\n \t  else\n \t    {\n \t      tree r = convert_from_reference (decl);\n-\t      \n+\n \t      if (processing_template_decl\n \t\t  && TYPE_P (scope))\n \t\tr = build2 (SCOPE_REF, TREE_TYPE (r), scope, decl);\n@@ -2782,7 +2782,7 @@ finish_id_expression (tree id_expression,\n \t      || TREE_CODE (decl) == RESULT_DECL)\n \t    {\n \t      tree context = decl_function_context (decl);\n-\t      \n+\n \t      if (context != NULL_TREE && context != current_function_decl\n \t\t  && ! TREE_STATIC (decl))\n \t\t{\n@@ -2793,20 +2793,20 @@ finish_id_expression (tree id_expression,\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n-\t  \n+\n \t  if (DECL_P (decl) && DECL_NONLOCAL (decl)\n \t      && DECL_CLASS_SCOPE_P (decl)\n \t      && DECL_CONTEXT (decl) != current_class_type)\n \t    {\n \t      tree path;\n-\t      \n+\n \t      path = currently_open_derived_class (DECL_CONTEXT (decl));\n \t      perform_or_defer_access_check (TYPE_BINFO (path), decl);\n \t    }\n-\t  \n+\n \t  decl = convert_from_reference (decl);\n \t}\n-      \n+\n       /* Resolve references to variables of anonymous unions\n \t into COMPONENT_REFs.  */\n       if (TREE_CODE (decl) == ALIAS_DECL)\n@@ -2850,7 +2850,7 @@ finish_typeof (tree expr)\n    with equivalent CALL_EXPRs.  */\n \n static tree\n-simplify_aggr_init_exprs_r (tree* tp, \n+simplify_aggr_init_exprs_r (tree* tp,\n                             int* walk_subtrees,\n                             void* data ATTRIBUTE_UNUSED)\n {\n@@ -2919,7 +2919,7 @@ simplify_aggr_init_expr (tree *tp)\n \t{\n \t  /* The return type might have different cv-quals from the slot.  */\n \t  tree fntype = TREE_TYPE (TREE_TYPE (fn));\n-\t  \n+\n \t  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n \t\t      || TREE_CODE (fntype) == METHOD_TYPE);\n \t  addr = convert (build_pointer_type (TREE_TYPE (fntype)), addr);\n@@ -2928,7 +2928,7 @@ simplify_aggr_init_expr (tree *tp)\n       args = tree_cons (NULL_TREE, addr, args);\n     }\n \n-  call_expr = build3 (CALL_EXPR, \n+  call_expr = build3 (CALL_EXPR,\n \t\t      TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n \t\t      fn, args, NULL_TREE);\n \n@@ -2963,7 +2963,7 @@ emit_associated_thunks (tree fn)\n   if (DECL_VIRTUAL_P (fn))\n     {\n       tree thunk;\n-      \n+\n       for (thunk = DECL_THUNKS (fn); thunk; thunk = TREE_CHAIN (thunk))\n \t{\n \t  if (!THUNK_ALIAS (thunk))\n@@ -2972,7 +2972,7 @@ emit_associated_thunks (tree fn)\n \t      if (DECL_RESULT_THUNK_P (thunk))\n \t\t{\n \t\t  tree probe;\n-\t\t  \n+\n \t\t  for (probe = DECL_THUNKS (thunk);\n \t\t       probe; probe = TREE_CHAIN (probe))\n \t\t    use_thunk (probe, /*emit_p=*/1);\n@@ -3024,7 +3024,7 @@ expand_body (tree fn)\n       /* If this is a clone, go through the other clones now and mark\n          their parameters used.  We have to do that here, as we don't\n          know whether any particular clone will be expanded, and\n-         therefore cannot pick one arbitrarily.  */ \n+         therefore cannot pick one arbitrarily.  */\n       tree probe;\n \n       for (probe = TREE_CHAIN (DECL_CLONED_FUNCTION (fn));"}, {"sha": "22c4814492139202258e17f89fad5f5b7aed7b36", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 190, "deletions": 190, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -247,11 +247,11 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n   tree attributes;\n \n   /* FIXME: Attributes.  */\n-  gcc_assert (ARITHMETIC_TYPE_P (t1) \n+  gcc_assert (ARITHMETIC_TYPE_P (t1)\n \t      || TREE_CODE (t1) == COMPLEX_TYPE\n \t      || TREE_CODE (t1) == VECTOR_TYPE\n \t      || TREE_CODE (t1) == ENUMERAL_TYPE);\n-  gcc_assert (ARITHMETIC_TYPE_P (t2) \n+  gcc_assert (ARITHMETIC_TYPE_P (t2)\n \t      || TREE_CODE (t2) == COMPLEX_TYPE\n \t      || TREE_CODE (t1) == VECTOR_TYPE\n \t      || TREE_CODE (t2) == ENUMERAL_TYPE);\n@@ -332,7 +332,7 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n \t convert to a long long.  Otherwise, convert to an unsigned long\n \t long.  Otherwise, if either operand is long long, convert the\n \t other to long long.\n-\t \n+\n \t Since we're here, we know the TYPE_PRECISION is the same;\n \t therefore converting to long long cannot represent all the values\n \t of an unsigned long, so we choose unsigned long long in that\n@@ -341,11 +341,11 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n \t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_long_integer_type_node))\n \t{\n \t  tree t = ((TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t\t    ? long_long_unsigned_type_node \n+\t\t    ? long_long_unsigned_type_node\n \t\t    : long_long_integer_type_node);\n \t  return build_type_attribute_variant (t, attributes);\n \t}\n-      \n+\n       /* Go through the same procedure, but for longs.  */\n       if (same_type_p (TYPE_MAIN_VARIANT (t1), long_unsigned_type_node)\n \t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_unsigned_type_node))\n@@ -378,7 +378,7 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n \t  || same_type_p (TYPE_MAIN_VARIANT (t2), float_type_node))\n \treturn build_type_attribute_variant (float_type_node,\n \t\t\t\t\t     attributes);\n-      \n+\n       /* Two floating-point types whose TYPE_MAIN_VARIANTs are none of\n          the standard C++ floating-point types.  Logic earlier in this\n          function has already eliminated the possibility that\n@@ -457,12 +457,12 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n \n /* Return the composite pointer type (see [expr.rel]) for T1 and T2.\n    ARG1 and ARG2 are the values with those types.  The LOCATION is a\n-   string describing the current location, in case an error occurs. \n+   string describing the current location, in case an error occurs.\n \n    This routine also implements the computation of a common type for\n    pointers-to-members as per [expr.eq].  */\n \n-tree \n+tree\n composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \t\t\tconst char* location)\n {\n@@ -477,7 +477,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n     return t2;\n   if (null_ptr_cst_p (arg2))\n     return t1;\n- \n+\n   /* We have:\n \n        [expr.rel]\n@@ -505,7 +505,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       if (pedantic && TYPE_PTRFN_P (t2))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type %<void *%> \"\n                  \"and pointer-to-function\", location);\n-      result_type \n+      result_type\n \t= cp_build_qualified_type (void_type_node,\n \t\t\t\t   (cp_type_quals (TREE_TYPE (t1))\n \t\t\t\t    | cp_type_quals (TREE_TYPE (t2))));\n@@ -534,10 +534,10 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       class2 = TREE_TYPE (t2);\n \n       if (DERIVED_FROM_P (class1, class2))\n-\tt2 = (build_pointer_type \n+\tt2 = (build_pointer_type\n \t      (cp_build_qualified_type (class1, TYPE_QUALS (class2))));\n       else if (DERIVED_FROM_P (class2, class1))\n-\tt1 = (build_pointer_type \n+\tt1 = (build_pointer_type\n \t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n       else\n \t{\n@@ -764,7 +764,7 @@ common_type (tree t1, tree t2)\n /* Compare two exception specifier types for exactness or subsetness, if\n    allowed. Returns false for mismatch, true for match (same, or\n    derived and !exact).\n- \n+\n    [except.spec] \"If a class X ... objects of class X or any class publicly\n    and unambiguously derived from X. Similarly, if a pointer type Y * ...\n    exceptions of type Y * or that are pointers to any type publicly and\n@@ -774,7 +774,7 @@ common_type (tree t1, tree t2)\n    [except.throw] and catch [except.catch] will do. They will ignore the\n    top level cv qualifiers, and allow qualifiers in the pointer to class\n    example.\n-   \n+\n    We implement the letter of the standard.  */\n \n static bool\n@@ -786,7 +786,7 @@ comp_except_types (tree a, tree b, bool exact)\n     {\n       if (cp_type_quals (a) || cp_type_quals (b))\n         return false;\n-      \n+\n       if (TREE_CODE (a) == POINTER_TYPE\n           && TREE_CODE (b) == POINTER_TYPE)\n         {\n@@ -795,11 +795,11 @@ comp_except_types (tree a, tree b, bool exact)\n           if (cp_type_quals (a) || cp_type_quals (b))\n             return false;\n         }\n-      \n+\n       if (TREE_CODE (a) != RECORD_TYPE\n           || TREE_CODE (b) != RECORD_TYPE)\n         return false;\n-      \n+\n       if (PUBLICLY_UNIQUELY_DERIVED_P (a, b))\n         return true;\n     }\n@@ -821,7 +821,7 @@ comp_except_specs (tree t1, tree t2, bool exact)\n \n   if (t1 == t2)\n     return true;\n-  \n+\n   if (t1 == NULL_TREE)              /* T1 is ...  */\n     return t2 == NULL_TREE || !exact;\n   if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n@@ -830,7 +830,7 @@ comp_except_specs (tree t1, tree t2, bool exact)\n     return false;\n   if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n     return !exact;\n-  \n+\n   /* Neither set is ... or EMPTY, make sure each part of T2 is in T1.\n      Count how many we find, to determine exactness. For exact matching and\n      ordered T1, T2, this is an O(n) operation, otherwise its worst case is\n@@ -841,7 +841,7 @@ comp_except_specs (tree t1, tree t2, bool exact)\n         {\n           tree a = TREE_VALUE (probe);\n           tree b = TREE_VALUE (t2);\n-          \n+\n           if (comp_except_types (a, b, exact))\n             {\n               if (probe == base && exact)\n@@ -886,7 +886,7 @@ comp_array_types (tree t1, tree t2, bool allow_redeclaration)\n        extern int a[];\n        int a[3];\n \n-     by [basic.link]: \n+     by [basic.link]:\n \n        declarations for an array object can specify\n        array types that differ by the presence or absence of a major\n@@ -930,9 +930,9 @@ comptypes (tree t1, tree t2, int strict)\n   /* Suppress errors caused by previously reported errors.  */\n   if (t1 == error_mark_node || t2 == error_mark_node)\n     return false;\n-  \n+\n   gcc_assert (TYPE_P (t1) && TYPE_P (t2));\n-  \n+\n   /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n      current instantiation.  */\n   if (TREE_CODE (t1) == TYPENAME_TYPE)\n@@ -942,7 +942,7 @@ comptypes (tree t1, tree t2, int strict)\n       if (resolved != error_mark_node)\n \tt1 = resolved;\n     }\n-  \n+\n   if (TREE_CODE (t2) == TYPENAME_TYPE)\n     {\n       tree resolved = resolve_typename_type (t2, /*only_current_p=*/true);\n@@ -1011,12 +1011,12 @@ comptypes (tree t1, tree t2, int strict)\n \t      || TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t  && comp_template_args (TYPE_TI_ARGS (t1), TYPE_TI_ARGS (t2)))\n \tbreak;\n-      \n+\n       if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n \tbreak;\n       else if ((strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n \tbreak;\n-      \n+\n       return false;\n \n     case OFFSET_TYPE:\n@@ -1098,7 +1098,7 @@ at_least_as_qualified_p (tree type1, tree type2)\n {\n   int q1 = cp_type_quals (type1);\n   int q2 = cp_type_quals (type2);\n-  \n+\n   /* All qualifiers for TYPE2 must also appear in TYPE1.  */\n   return (q1 & q2) == q2;\n }\n@@ -1160,7 +1160,7 @@ common_base_type (tree tt1, tree tt2)\n     {\n       tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (tt1), i));\n       tree trial = common_base_type (basetype, tt2);\n-      \n+\n       if (trial)\n \t{\n \t  if (trial == error_mark_node)\n@@ -1177,7 +1177,7 @@ common_base_type (tree tt1, tree tt2)\n     {\n       tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (tt2), i));\n       tree trial = common_base_type (tt1, basetype);\n-      \n+\n       if (trial)\n \t{\n \t  if (trial == error_mark_node)\n@@ -1234,14 +1234,14 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n   gcc_assert (op == SIZEOF_EXPR || op == ALIGNOF_EXPR);\n   if (type == error_mark_node)\n     return error_mark_node;\n-  \n+\n   if (dependent_type_p (type))\n     {\n       value = build_min (op, size_type_node, type);\n       TREE_READONLY (value) = 1;\n       return value;\n     }\n-  \n+\n   op_name = operator_name_info[(int) op].name;\n \n   type = non_reference (type);\n@@ -1268,19 +1268,19 @@ tree\n cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n {\n   const char *op_name = operator_name_info[(int) op].name;\n-  \n+\n   if (e == error_mark_node)\n     return error_mark_node;\n-  \n+\n   if (processing_template_decl)\n     {\n       e = build_min (op, size_type_node, e);\n       TREE_SIDE_EFFECTS (e) = 0;\n       TREE_READONLY (e) = 1;\n-      \n+\n       return e;\n     }\n-  \n+\n   if (TREE_CODE (e) == COMPONENT_REF\n       && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n       && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n@@ -1301,23 +1301,23 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n     }\n   else\n     e = TREE_TYPE (e);\n-  \n+\n   return cxx_sizeof_or_alignof_type (e, op, true);\n }\n-  \n+\n \f\n /* EXPR is being used in a context that is not a function call.\n    Enforce:\n \n-     [expr.ref] \n+     [expr.ref]\n \n      The expression can be used only as the left-hand operand of a\n-     member function call.  \n+     member function call.\n \n      [expr.mptr.operator]\n \n      If the result of .* or ->* is a function, then that result can be\n-     used only as the operand for the function call operator ().  \n+     used only as the operand for the function call operator ().\n \n    by issuing an error message if appropriate.  Returns true iff EXPR\n    violates these rules.  */\n@@ -1358,7 +1358,7 @@ decay_conversion (tree exp)\n     }\n \n   exp = integral_constant_value (exp);\n-  \n+\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n \n@@ -1377,7 +1377,7 @@ decay_conversion (tree exp)\n       tree ptrtype;\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\treturn build_nop (build_pointer_type (TREE_TYPE (type)), \n+\treturn build_nop (build_pointer_type (TREE_TYPE (type)),\n \t\t\t  TREE_OPERAND (exp, 0));\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n@@ -1575,15 +1575,15 @@ lookup_anon_field (tree t, tree type)\n    non-NULL, it indicates the path to the base used to name MEMBER.\n    If PRESERVE_REFERENCE is true, the expression returned will have\n    REFERENCE_TYPE if the MEMBER does.  Otherwise, the expression\n-   returned will have the type referred to by the reference. \n+   returned will have the type referred to by the reference.\n \n    This function does not perform access control; that is either done\n    earlier by the parser when the name of MEMBER is resolved to MEMBER\n    itself, or later when overload resolution selects one of the\n    functions indicated by MEMBER.  */\n \n tree\n-build_class_member_access_expr (tree object, tree member, \n+build_class_member_access_expr (tree object, tree member,\n \t\t\t\ttree access_path, bool preserve_reference)\n {\n   tree object_type;\n@@ -1600,12 +1600,12 @@ build_class_member_access_expr (tree object, tree member,\n      The type of the first expression shall be \"class object\" (of a\n      complete type).  */\n   object_type = TREE_TYPE (object);\n-  if (!currently_open_class (object_type) \n+  if (!currently_open_class (object_type)\n       && !complete_type_or_else (object_type, object))\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member %qD in %qE, which is of non-class type %qT\", \n+      error (\"request for member %qD in %qE, which is of non-class type %qT\",\n \t     member, object, object_type);\n       return error_mark_node;\n     }\n@@ -1692,7 +1692,7 @@ build_class_member_access_expr (tree object, tree member,\n \t    }\n \n \t  /* Convert to the base.  */\n-\t  object = build_base_path (PLUS_EXPR, object, binfo, \n+\t  object = build_base_path (PLUS_EXPR, object, binfo,\n \t\t\t\t    /*nonnull=*/1);\n \t  /* If we found the base successfully then we should be able\n \t     to convert to it successfully.  */\n@@ -1712,7 +1712,7 @@ build_class_member_access_expr (tree object, tree member,\n \t  && !DECL_FIELD_IS_BASE (member)\n \t  && !skip_evaluation)\n \t{\n-\t  warning (0, \"invalid access to non-static data member %qD of NULL object\", \n+\t  warning (0, \"invalid access to non-static data member %qD of NULL object\",\n \t\t   member);\n \t  warning (0, \"(perhaps the %<offsetof%> macro was used incorrectly)\");\n \t}\n@@ -1728,7 +1728,7 @@ build_class_member_access_expr (tree object, tree member,\n \t     constructed, and was then disassembled before calling\n \t     build_field_call.  After the function-call code is\n \t     cleaned up, this waste can be eliminated.  */\n-\t  && (!same_type_ignoring_top_level_qualifiers_p \n+\t  && (!same_type_ignoring_top_level_qualifiers_p\n \t      (TREE_TYPE (object), DECL_CONTEXT (member))))\n \t{\n \t  tree anonymous_union;\n@@ -1746,9 +1746,9 @@ build_class_member_access_expr (tree object, tree member,\n       member_type = TREE_TYPE (member);\n       if (TREE_CODE (member_type) != REFERENCE_TYPE)\n \t{\n-\t  type_quals = (cp_type_quals (member_type)  \n+\t  type_quals = (cp_type_quals (member_type)\n \t\t\t| cp_type_quals (object_type));\n-\t  \n+\n \t  /* A field is const (volatile) if the enclosing object, or the\n \t     field itself, is const (volatile).  But, a mutable field is\n \t     not const, even within a const object.  */\n@@ -1805,7 +1805,7 @@ build_class_member_access_expr (tree object, tree member,\n \n   if (!preserve_reference)\n     /* [expr.ref]\n-       \n+\n        If E2 is declared to have type \"reference to T\", then ... the\n        type of E1.E2 is T.  */\n     result = convert_from_reference (result);\n@@ -1889,17 +1889,17 @@ finish_class_member_access_expr (tree object, tree name)\n \treturn build_min_nt (COMPONENT_REF, object, name, NULL_TREE);\n       object = build_non_dependent_expr (object);\n     }\n-  \n+\n   /* [expr.ref]\n \n      The type of the first expression shall be \"class object\" (of a\n      complete type).  */\n-  if (!currently_open_class (object_type) \n+  if (!currently_open_class (object_type)\n       && !complete_type_or_else (object_type, object))\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member %qD in %qE, which is of non-class type %qT\", \n+      error (\"request for member %qD in %qE, which is of non-class type %qT\",\n \t     name, object, object_type);\n       return error_mark_node;\n     }\n@@ -1945,7 +1945,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t     name a member of OBJECT_TYPE.  */\n \t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n-\t      error (\"%<%D::%D%> is not a member of %qT\", \n+\t      error (\"%<%D::%D%> is not a member of %qT\",\n \t\t     scope, name, object_type);\n \t      return error_mark_node;\n \t    }\n@@ -1971,7 +1971,7 @@ finish_class_member_access_expr (tree object, tree name)\n       else\n \t{\n \t  /* Look up the member.  */\n-\t  member = lookup_member (access_path, name, /*protect=*/1, \n+\t  member = lookup_member (access_path, name, /*protect=*/1,\n \t\t\t\t  /*want_type=*/false);\n \t  if (member == NULL_TREE)\n \t    {\n@@ -1981,11 +1981,11 @@ finish_class_member_access_expr (tree object, tree name)\n \t  if (member == error_mark_node)\n \t    return error_mark_node;\n \t}\n-      \n+\n       if (is_template_id)\n \t{\n \t  tree template = member;\n-\t  \n+\n \t  if (BASELINK_P (template))\n \t    template = lookup_template_function (template, template_args);\n \t  else\n@@ -2084,9 +2084,9 @@ build_indirect_ref (tree ptr, const char *errorstring)\n   if (POINTER_TYPE_P (type))\n     {\n       /* [expr.unary.op]\n-\t \n+\n \t If the type of the expression is \"pointer to T,\" the type\n-\t of  the  result  is  \"T.\"   \n+\t of  the  result  is  \"T.\"\n \n          We must use the canonical variant because certain parts of\n \t the back end, like fold, do pointer comparisons between\n@@ -2363,14 +2363,14 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t be incomplete.  In that case, the function will of course be\n \t a member of C, and no conversion is required.  In fact,\n \t lookup_base will fail in that case, because incomplete\n-\t classes do not have BINFOs.  */ \n+\t classes do not have BINFOs.  */\n       basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n-      if (!same_type_ignoring_top_level_qualifiers_p \n+      if (!same_type_ignoring_top_level_qualifiers_p\n \t  (basetype, TREE_TYPE (TREE_TYPE (instance_ptr))))\n \t{\n \t  basetype = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)),\n \t\t\t\t  basetype, ba_check, NULL);\n-\t  instance_ptr = build_base_path (PLUS_EXPR, instance_ptr, basetype, \n+\t  instance_ptr = build_base_path (PLUS_EXPR, instance_ptr, basetype,\n \t\t\t\t\t  1);\n \t  if (instance_ptr == error_mark_node)\n \t    return error_mark_node;\n@@ -2401,7 +2401,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \n       TREE_TYPE (e2) = TREE_TYPE (e3);\n       e1 = build_conditional_expr (e1, e2, e3);\n-      \n+\n       /* Make sure this doesn't get evaluated first inside one of the\n \t branches of the COND_EXPR.  */\n       if (instance_save_expr)\n@@ -2446,7 +2446,7 @@ build_function_call (tree function, tree params)\n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n \t needs to be separately compiled).  */\n-      \n+\n       if (DECL_INLINE (function))\n \tfunction = inline_conversion (function);\n       else\n@@ -2511,7 +2511,7 @@ build_function_call (tree function, tree params)\n    NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.\n \n    This is also where warnings about wrong number of args are generated.\n-   \n+\n    Return a list of expressions for the parameters as converted.\n \n    Both VALUES and the returned value are chains of TREE_LIST nodes\n@@ -2638,14 +2638,14 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n   if (typetail != 0 && typetail != void_list_node)\n     {\n       /* See if there are default arguments that can be used.  */\n-      if (TREE_PURPOSE (typetail) \n+      if (TREE_PURPOSE (typetail)\n \t  && TREE_CODE (TREE_PURPOSE (typetail)) != DEFAULT_ARG)\n \t{\n \t  for (; typetail != void_list_node; ++i)\n \t    {\n-\t      tree parmval \n-\t\t= convert_default_arg (TREE_VALUE (typetail), \n-\t\t\t\t       TREE_PURPOSE (typetail), \n+\t      tree parmval\n+\t\t= convert_default_arg (TREE_VALUE (typetail),\n+\t\t\t\t       TREE_PURPOSE (typetail),\n \t\t\t\t       fndecl, i);\n \n \t      if (parmval == error_mark_node)\n@@ -2679,7 +2679,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n    conversions on the operands.  CODE is the kind of expression to build.  */\n \n tree\n-build_x_binary_op (enum tree_code code, tree arg1, tree arg2, \n+build_x_binary_op (enum tree_code code, tree arg1, tree arg2,\n \t\t   bool *overloaded_p)\n {\n   tree orig_arg1;\n@@ -2701,12 +2701,12 @@ build_x_binary_op (enum tree_code code, tree arg1, tree arg2,\n   if (code == DOTSTAR_EXPR)\n     expr = build_m_component_ref (arg1, arg2);\n   else\n-    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE, \n+    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n \t\t\t overloaded_p);\n \n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (code, expr, orig_arg1, orig_arg2);\n-  \n+\n   return expr;\n }\n \n@@ -2786,7 +2786,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* Apply default conversions.  */\n   op0 = orig_op0;\n   op1 = orig_op1;\n-  \n+\n   if (code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n       || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n       || code == TRUTH_XOR_EXPR)\n@@ -2888,7 +2888,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t    warning (0, \"division by zero in %<%E / 0%>\", op0);\n \t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n \t    warning (0, \"division by zero in %<%E / 0.%>\", op0);\n-\t      \n+\n \t  if (code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n \t    code0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n \t  if (code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE)\n@@ -2925,7 +2925,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \twarning (0, \"division by zero in %<%E %% 0%>\", op0);\n       else if (code1 == REAL_TYPE && real_zerop (op1))\n \twarning (0, \"division by zero in %<%E %% 0.%>\", op0);\n-      \n+\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  /* Although it would be tempting to shorten always here, that loses\n@@ -3022,7 +3022,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (warn_float_equal && (code0 == REAL_TYPE || code1 == REAL_TYPE))\n \twarning (0, \"comparing floating point with == or != is unsafe\");\n \n-      build_type = boolean_type_node; \n+      build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n \t   || code0 == COMPLEX_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n@@ -3076,9 +3076,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \t  /* We generate:\n \n-\t     (op0.pfn == op1.pfn \n+\t     (op0.pfn == op1.pfn\n \t      && (!op0.pfn || op0.delta == op1.delta))\n-\t     \n+\n \t     The reason for the `!op0.pfn' bit is that a NULL\n \t     pointer-to-member is any member with a zero PFN; the\n \t     DELTA field is unspecified.  */\n@@ -3089,7 +3089,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  delta1 = build_ptrmemfunc_access_expr (op1,\n \t\t\t\t\t\t delta_identifier);\n \t  e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n-\t  e2 = cp_build_binary_op (EQ_EXPR, \n+\t  e2 = cp_build_binary_op (EQ_EXPR,\n \t\t\t\t   pfn0,\n \t\t\t\t   cp_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t       integer_zero_node));\n@@ -3109,7 +3109,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t      || !same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1),\n \t\t\t\t       type0));\n \t}\n-      \n+\n       break;\n \n     case MAX_EXPR:\n@@ -3172,7 +3172,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     }\n \n   if (((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n-       && (code1 == INTEGER_TYPE || code1 == REAL_TYPE \n+       && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n \t   || code1 == COMPLEX_TYPE)))\n     arithmetic_types_p = 1;\n   else\n@@ -3188,7 +3188,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     }\n   /* Determine the RESULT_TYPE, if it is not already known.  */\n   if (!result_type\n-      && arithmetic_types_p \n+      && arithmetic_types_p\n       && (shorten || common || short_compare))\n     result_type = common_type (type0, type1);\n \n@@ -3202,8 +3202,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* If we're in a template, the only thing we need to know is the\n      RESULT_TYPE.  */\n   if (processing_template_decl)\n-    return build2 (resultcode, \n-\t\t   build_type ? build_type : result_type, \n+    return build2 (resultcode,\n+\t\t   build_type ? build_type : result_type,\n \t\t   op0, op1);\n \n   if (arithmetic_types_p)\n@@ -3330,7 +3330,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     pass the copies by reference, then copy them back afterward.  */\n \t  tree xop0 = op0, xop1 = op1, xresult_type = result_type;\n \t  enum tree_code xresultcode = resultcode;\n-\t  tree val \n+\t  tree val\n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \t  if (val != 0)\n \t    return cp_convert (boolean_type_node, val);\n@@ -3353,12 +3353,12 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n \t  /* Check for comparison of different enum types.  */\n-\t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE \n-\t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE \n+\t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n+\t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n-\t      warning (0, \"comparison between types %q#T and %q#T\", \n+\t      warning (0, \"comparison between types %q#T and %q#T\",\n                        TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n@@ -3411,7 +3411,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\tprimop0 = get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n \t      if (TREE_CODE (primop1) == BIT_NOT_EXPR)\n \t\tprimop1 = get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n-\t      \n+\n \t      if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n \t\t{\n \t\t  tree primop;\n@@ -3467,7 +3467,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  || (orig_op1 == null_node\n \t      && TREE_CODE (TREE_TYPE (op0)) != POINTER_TYPE)\n \t  /* Or, both are NULL and the operation was not a comparison.  */\n-\t  || (orig_op0 == null_node && orig_op1 == null_node \n+\t  || (orig_op0 == null_node && orig_op1 == null_node\n \t      && code != EQ_EXPR && code != NE_EXPR)))\n     /* Some sort of arithmetic operation involving NULL was\n        performed.  Note that pointer-difference and pointer-addition\n@@ -3478,9 +3478,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if (! converted)\n     {\n       if (TREE_TYPE (op0) != result_type)\n-\top0 = cp_convert (result_type, op0); \n+\top0 = cp_convert (result_type, op0);\n       if (TREE_TYPE (op1) != result_type)\n-\top1 = cp_convert (result_type, op1); \n+\top1 = cp_convert (result_type, op1);\n \n       if (op0 == error_mark_node || op1 == error_mark_node)\n \treturn error_mark_node;\n@@ -3541,15 +3541,15 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n-  op0 = cp_build_binary_op (MINUS_EXPR, \n+  op0 = cp_build_binary_op (MINUS_EXPR,\n \t\t\t    cp_convert (restype, op0),\n \t\t\t    cp_convert (restype, op1));\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n     error (\"invalid use of a pointer to an incomplete type in pointer arithmetic\");\n \n-  op1 = (TYPE_PTROB_P (ptrtype) \n+  op1 = (TYPE_PTROB_P (ptrtype)\n \t ? size_in_bytes (target_type)\n \t : integer_one_node);\n \n@@ -3569,7 +3569,7 @@ build_x_unary_op (enum tree_code code, tree xarg)\n   tree orig_expr = xarg;\n   tree exp;\n   int ptrmem = 0;\n-  \n+\n   if (processing_template_decl)\n     {\n       if (type_dependent_expression_p (xarg))\n@@ -3619,11 +3619,11 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t      PTRMEM_OK_P (xarg) = 1;\n \t    }\n \t}\n-      \n+\n       if (TREE_CODE (xarg) == OFFSET_REF)\n         {\n           ptrmem = PTRMEM_OK_P (xarg);\n-          \n+\n           if (!ptrmem && !flag_ms_extensions\n               && TREE_CODE (TREE_TYPE (TREE_OPERAND (xarg, 1))) == METHOD_TYPE)\n \t    {\n@@ -3633,7 +3633,7 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t\t\t     TREE_OPERAND (xarg, 0),\n \t\t\t     ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n-\t    }\t      \n+\t    }\n         }\n       else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (0, \"taking address of temporary\");\n@@ -3663,7 +3663,7 @@ cp_truthvalue_conversion (tree expr)\n }\n \n /* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */\n-   \n+\n tree\n condition_conversion (tree expr)\n {\n@@ -3674,7 +3674,7 @@ condition_conversion (tree expr)\n   t = fold_build_cleanup_point_expr (boolean_type_node, t);\n   return t;\n }\n-\t\t\n+\n /* Return an ADDR_EXPR giving the address of T.  This function\n    attempts no optimizations or simplifications; it is a low-level\n    primitive.  */\n@@ -3789,7 +3789,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n     case NOP_EXPR:\n       break;\n-      \n+\n     case REALPART_EXPR:\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \treturn TREE_REALPART (arg);\n@@ -3811,7 +3811,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t}\n       else\n \treturn cp_convert (TREE_TYPE (arg), integer_zero_node);\n-      \n+\n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n@@ -3873,13 +3873,13 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  pedwarn (\"ISO C++ forbids %sing an enum\",\n \t\t   (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t\t   ? \"increment\" : \"decrement\");\n-\t    \n+\n \t/* Compute the increment.  */\n \n \tif (TREE_CODE (argtype) == POINTER_TYPE)\n \t  {\n \t    tree type = complete_type (TREE_TYPE (argtype));\n-\t    \n+\n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n \t      error (\"cannot %s a pointer to incomplete type %qT\",\n                      ((code == PREINCREMENT_EXPR\n@@ -4043,10 +4043,10 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  arg = build_offset_ref (base, name, /*address_p=*/true);\n         }\n \n-    offset_ref:        \n+    offset_ref:\n       if (type_unknown_p (arg))\n \treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n-\t\n+\n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n       val = unary_complex_lvalue (code, arg);\n@@ -4079,15 +4079,15 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \t    if (!PTRMEM_OK_P (arg))\n \t      return build_unary_op (code, arg, 0);\n-\t    \n+\n \t    t = TREE_OPERAND (arg, 1);\n \t    if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n \t      {\n \t\terror (\"cannot create pointer to reference member %qD\", t);\n \t\treturn error_mark_node;\n \t      }\n-\t    \n-\t    type = build_ptrmem_type (context_for_name_lookup (t), \n+\n+\t    type = build_ptrmem_type (context_for_name_lookup (t),\n \t\t\t\t      TREE_TYPE (t));\n \t    t = make_ptrmem_cst (type, TREE_OPERAND (arg, 1));\n \t    return t;\n@@ -4188,7 +4188,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n    If ARG is not a kind of expression we can handle, return\n    NULL_TREE.  */\n-   \n+\n tree\n unary_complex_lvalue (enum tree_code code, tree arg)\n {\n@@ -4245,7 +4245,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n       || TREE_CODE (TREE_TYPE (arg)) == METHOD_TYPE\n       || TREE_CODE (arg) == OFFSET_REF)\n     return NULL_TREE;\n-  \n+\n   /* We permit compiler to make function calls returning\n      objects of aggregate type look like lvalues.  */\n   {\n@@ -4376,7 +4376,7 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n \n   expr = build_conditional_expr (ifexp, op1, op2);\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (COND_EXPR, expr, \n+    return build_min_non_dep (COND_EXPR, expr,\n \t\t\t      orig_ifexp, orig_op1, orig_op2);\n   return expr;\n }\n@@ -4387,7 +4387,7 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n tree build_x_compound_expr_from_list (tree list, const char *msg)\n {\n   tree expr = TREE_VALUE (list);\n-  \n+\n   if (TREE_CHAIN (list))\n     {\n       if (msg)\n@@ -4396,7 +4396,7 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n \texpr = build_x_compound_expr (expr, TREE_VALUE (list));\n     }\n-  \n+\n   return expr;\n }\n \n@@ -4425,7 +4425,7 @@ build_x_compound_expr (tree op1, tree op2)\n \n   if (processing_template_decl && result != error_mark_node)\n     return build_min_non_dep (COMPOUND_EXPR, result, orig_op1, orig_op2);\n-  \n+\n   return result;\n }\n \n@@ -4435,23 +4435,23 @@ tree\n build_compound_expr (tree lhs, tree rhs)\n {\n   lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n-  \n+\n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n-  \n+\n   if (TREE_CODE (rhs) == TARGET_EXPR)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n          expression inside the target_expr's initializer. This\n \t helps the compiler to eliminate unnecessary temporaries.  */\n       tree init = TREE_OPERAND (rhs, 1);\n-      \n+\n       init = build2 (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);\n       TREE_OPERAND (rhs, 1) = init;\n-      \n+\n       return rhs;\n     }\n-  \n+\n   return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n }\n \n@@ -4477,7 +4477,7 @@ check_for_casting_away_constness (tree src_type, tree dest_type,\n    only the other direction is permitted.  If C_CAST_P is true, this\n    conversion is taking place as part of a C-style cast.  */\n \n-tree \n+tree\n convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t\tbool c_cast_p)\n {\n@@ -4488,17 +4488,17 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n       if (TREE_CODE (expr) == PTRMEM_CST)\n \texpr = cplus_expand_constant (expr);\n       delta = get_delta_difference (TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t    TYPE_PTRMEM_CLASS_TYPE (type), \n+\t\t\t\t    TYPE_PTRMEM_CLASS_TYPE (type),\n \t\t\t\t    allow_inverse_p,\n \t\t\t\t    c_cast_p);\n       if (!integer_zerop (delta))\n-\texpr = cp_build_binary_op (PLUS_EXPR, \n+\texpr = cp_build_binary_op (PLUS_EXPR,\n \t\t\t\t   build_nop (ptrdiff_type_node, expr),\n \t\t\t\t   delta);\n       return build_nop (type, expr);\n     }\n   else\n-    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, \n+    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr,\n \t\t\t     allow_inverse_p, c_cast_p);\n }\n \n@@ -4528,7 +4528,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   if (c_cast_p)\n     {\n       /* C-style casts are allowed to cast away constness.  With\n-\t WARN_CAST_QUAL, we still want to issue a warning.  */ \n+\t WARN_CAST_QUAL, we still want to issue a warning.  */\n       diag_fn = warn_cast_qual ? warning0 : NULL;\n       desc = \"cast\";\n     }\n@@ -4538,7 +4538,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       diag_fn = error;\n       desc = \"static_cast\";\n     }\n-      \n+\n   /* [expr.static.cast]\n \n      An lvalue of type \"cv1 B\", where B is a class type, can be cast\n@@ -4564,7 +4564,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       && real_lvalue_p (expr)\n       && DERIVED_FROM_P (intype, TREE_TYPE (type))\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n-\t\t      build_pointer_type (TYPE_MAIN_VARIANT \n+\t\t      build_pointer_type (TYPE_MAIN_VARIANT\n \t\t\t\t\t  (TREE_TYPE (type))))\n       && (c_cast_p\n \t  || at_least_as_qualified_p (TREE_TYPE (type), intype)))\n@@ -4577,13 +4577,13 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t ambiguity.  However, if this is a static_cast being performed\n \t because the user wrote a C-style cast, then accessibility is\n \t not considered.  */\n-      base = lookup_base (TREE_TYPE (type), intype, \n-\t\t\t  c_cast_p ? ba_unique : ba_check, \n+      base = lookup_base (TREE_TYPE (type), intype,\n+\t\t\t  c_cast_p ? ba_unique : ba_check,\n \t\t\t  NULL);\n \n       /* Convert from \"B*\" to \"D*\".  This function will check that \"B\"\n \t is not a virtual base of \"D\".  */\n-      expr = build_base_path (MINUS_EXPR, build_address (expr), \n+      expr = build_base_path (MINUS_EXPR, build_address (expr),\n \t\t\t      base, /*nonnull=*/false);\n       /* Convert the pointer to a reference -- but then remember that\n \t there are no expressions with reference type in C++.  */\n@@ -4621,7 +4621,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \tresult = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n       return result;\n     }\n-  \n+\n   /* [expr.static.cast]\n \n      Any expression can be explicitly converted to type cv void.  */\n@@ -4642,7 +4642,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n      floating point conversions, floating-integral conversions,\n      pointer conversions, and pointer to member conversions.  */\n   /* DR 128\n-     \n+\n      A value of integral _or enumeration_ type can be explicitly\n      converted to an enumeration type.  */\n   /* The effect of all that is that any conversion between any two\n@@ -4666,21 +4666,21 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   if (TYPE_PTR_P (type) && TYPE_PTR_P (intype)\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (TREE_TYPE (intype))\n-      && can_convert (build_pointer_type (TYPE_MAIN_VARIANT \n-\t\t\t\t\t  (TREE_TYPE (intype))), \n-\t\t      build_pointer_type (TYPE_MAIN_VARIANT \n+      && can_convert (build_pointer_type (TYPE_MAIN_VARIANT\n+\t\t\t\t\t  (TREE_TYPE (intype))),\n+\t\t      build_pointer_type (TYPE_MAIN_VARIANT\n \t\t\t\t\t  (TREE_TYPE (type)))))\n     {\n       tree base;\n \n       if (!c_cast_p)\n \tcheck_for_casting_away_constness (intype, type, diag_fn, desc);\n-      base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype), \n-\t\t\t  c_cast_p ? ba_unique : ba_check, \n+      base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n+\t\t\t  c_cast_p ? ba_unique : ba_check,\n \t\t\t  NULL);\n       return build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false);\n     }\n-  \n+\n   if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n       || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     {\n@@ -4694,10 +4694,10 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n       if (TYPE_PTRMEM_P (type))\n \t{\n-\t  t1 = (build_ptrmem_type \n+\t  t1 = (build_ptrmem_type\n \t\t(c1,\n \t\t TYPE_MAIN_VARIANT (TYPE_PTRMEM_POINTED_TO_TYPE (intype))));\n-\t  t2 = (build_ptrmem_type \n+\t  t2 = (build_ptrmem_type\n \t\t(c2,\n \t\t TYPE_MAIN_VARIANT (TYPE_PTRMEM_POINTED_TO_TYPE (type))));\n \t}\n@@ -4709,20 +4709,20 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (can_convert (t1, t2))\n \t{\n \t  if (!c_cast_p)\n-\t    check_for_casting_away_constness (intype, type, diag_fn, \n+\t    check_for_casting_away_constness (intype, type, diag_fn,\n \t\t\t\t\t      desc);\n \t  return convert_ptrmem (type, expr, /*allow_inverse_p=*/1,\n \t\t\t\t c_cast_p);\n \t}\n     }\n-    \n+\n   /* [expr.static.cast]\n \n      An rvalue of type \"pointer to cv void\" can be explicitly\n      converted to a pointer to object type.  A value of type pointer\n      to object converted to \"pointer to cv void\" and back to the\n      original pointer type will have its original value.  */\n-  if (TREE_CODE (intype) == POINTER_TYPE \n+  if (TREE_CODE (intype) == POINTER_TYPE\n       && VOID_TYPE_P (TREE_TYPE (intype))\n       && TYPE_PTROB_P (type))\n     {\n@@ -4765,7 +4765,7 @@ build_static_cast (tree type, tree expr)\n   if (valid_p)\n     return result;\n \n-  error (\"invalid static_cast from type %qT to type %qT\", \n+  error (\"invalid static_cast from type %qT to type %qT\",\n \t TREE_TYPE (expr), type);\n   return error_mark_node;\n }\n@@ -4788,7 +4788,7 @@ convert_member_func_to_ptr (tree type, tree expr)\n \n   if (pedantic || warn_pmf2ptr)\n     pedwarn (\"converting from %qT to %qT\", intype, type);\n-    \n+\n   if (TREE_CODE (intype) == METHOD_TYPE)\n     expr = build_addr_func (expr);\n   else if (TREE_CODE (expr) == PTRMEM_CST)\n@@ -4833,7 +4833,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (! real_lvalue_p (expr))\n \t{\n \t  error (\"invalid cast of an rvalue expression of type \"\n-                 \"%qT to type %qT\", \n+                 \"%qT to type %qT\",\n \t\t intype, type);\n \t  return error_mark_node;\n \t}\n@@ -4862,7 +4862,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n      pointer-to-function and pointer-to-void types.  If\n      -Wno-pmf-conversions has not been specified,\n      convert_member_func_to_ptr will issue an error message.  */\n-  if ((TYPE_PTRMEMFUNC_P (intype) \n+  if ((TYPE_PTRMEMFUNC_P (intype)\n        || TREE_CODE (intype) == METHOD_TYPE)\n       && TYPE_PTR_P (type)\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n@@ -4873,7 +4873,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n      array-to-pointer, and function-to-pointer conversions are\n      performed.  */\n   expr = decay_conversion (expr);\n-  \n+\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n   if (TREE_CODE (expr) == NOP_EXPR\n@@ -4907,7 +4907,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n       if (!c_cast_p)\n-\tcheck_for_casting_away_constness (intype, type, error, \n+\tcheck_for_casting_away_constness (intype, type, error,\n \t\t\t\t\t  \"reinterpret_cast\");\n       /* Warn about possible alignment problems.  */\n       if (STRICT_ALIGNMENT && warn_cast_align\n@@ -4919,7 +4919,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \twarning (0, \"cast from %qT to %qT increases required alignment of \"\n \t\t \"target type\",\n \t\t intype, type);\n-      \n+\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n@@ -4944,7 +4944,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       error (\"invalid cast from type %qT to type %qT\", intype, type);\n       return error_mark_node;\n     }\n-      \n+\n   return cp_convert (type, expr);\n }\n \n@@ -4957,7 +4957,7 @@ build_reinterpret_cast (tree type, tree expr)\n   if (processing_template_decl)\n     {\n       tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n-      \n+\n       if (!TREE_SIDE_EFFECTS (t)\n \t  && type_dependent_expression_p (expr))\n \t/* There might turn out to be side effects inside expr.  */\n@@ -5071,7 +5071,7 @@ build_const_cast_1 (tree dst_type, tree expr, bool complain,\n     }\n \n   if (complain)\n-    error (\"invalid const_cast from type %qT to type %qT\", \n+    error (\"invalid const_cast from type %qT to type %qT\",\n \t   src_type, dst_type);\n   return error_mark_node;\n }\n@@ -5085,7 +5085,7 @@ build_const_cast (tree type, tree expr)\n   if (processing_template_decl)\n     {\n       tree t = build_min (CONST_CAST_EXPR, type, expr);\n-      \n+\n       if (!TREE_SIDE_EFFECTS (t)\n \t  && type_dependent_expression_p (expr))\n \t/* There might turn out to be side effects inside expr.  */\n@@ -5171,7 +5171,7 @@ build_c_cast (tree type, tree expr)\n \t\t\t\t       &valid_p);\n   /* The static_cast or reinterpret_cast may be followed by a\n      const_cast.  */\n-  if (valid_p \n+  if (valid_p\n       /* A valid cast may result in errors if, for example, a\n \t conversion to am ambiguous base class is required.  */\n       && !error_operand_p (result))\n@@ -5284,7 +5284,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \ttree preeval = NULL_TREE;\n \n \trhs = stabilize_expr (rhs, &preeval);\n-\t\n+\n \t/* Check this here to avoid odd errors when trying to convert\n \t   a throw to the type of the COND_EXPR.  */\n \tif (!lvalue_or_else (lhs, lv_assign))\n@@ -5307,7 +5307,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  cond = build2 (COMPOUND_EXPR, TREE_TYPE (lhs), preeval, cond);\n \treturn cond;\n       }\n-      \n+\n     default:\n       break;\n     }\n@@ -5372,7 +5372,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t\t     TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t      return error_mark_node;\n \t    }\n-\t  \n+\n \t  /* Now it looks like a plain assignment.  */\n \t  modifycode = NOP_EXPR;\n \t}\n@@ -5433,7 +5433,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n     {\n       int from_array;\n-      \n+\n       if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),\n \t\t\t\tTYPE_MAIN_VARIANT (TREE_TYPE (rhs))))\n \t{\n@@ -5550,7 +5550,7 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n    a pointer to member of FROM to a pointer to member of TO.  */\n \n static tree\n-get_delta_difference (tree from, tree to, \n+get_delta_difference (tree from, tree to,\n \t\t      bool allow_inverse_p,\n \t\t      bool c_cast_p)\n {\n@@ -5570,7 +5570,7 @@ get_delta_difference (tree from, tree to,\n       else\n \t{\n \t  tree virt_binfo = binfo_from_vbase (binfo);\n-\t  \n+\n \t  /* This is a reinterpret cast, we choose to do nothing.  */\n \t  if (allow_inverse_p)\n \t    warning (0, \"pointer to member cast via virtual base %qT\",\n@@ -5598,14 +5598,14 @@ get_delta_difference (tree from, tree to,\n \t    {\n \t      /* This is a reinterpret cast, we choose to do nothing.  */\n \t      tree virt_binfo = binfo_from_vbase (binfo);\n-\t  \n+\n \t      warning (0, \"pointer to member cast via virtual base %qT\",\n \t\t       BINFO_TYPE (virt_binfo));\n \t    }\n \t}\n     }\n \n-  return fold_if_not_in_template (convert_to_integer (ptrdiff_type_node, \n+  return fold_if_not_in_template (convert_to_integer (ptrdiff_type_node,\n \t\t\t\t\t\t      result));\n }\n \n@@ -5635,7 +5635,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   TREE_STATIC (u) = (TREE_CONSTANT (u)\n \t\t     && (initializer_constant_valid_p (pfn, TREE_TYPE (pfn))\n \t\t\t != NULL_TREE)\n-\t\t     && (initializer_constant_valid_p (delta, TREE_TYPE (delta)) \n+\t\t     && (initializer_constant_valid_p (delta, TREE_TYPE (delta))\n \t\t\t != NULL_TREE));\n   return u;\n }\n@@ -5671,9 +5671,9 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n       tree npfn = NULL_TREE;\n       tree n;\n \n-      if (!force \n+      if (!force\n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n-\terror (\"invalid conversion to type %qT from type %qT\", \n+\terror (\"invalid conversion to type %qT from type %qT\",\n                to_type, pfn_type);\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n@@ -5719,7 +5719,7 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n     {\n       pfn = build_c_cast (type, integer_zero_node);\n       return build_ptrmemfunc1 (to_type,\n-\t\t\t\tinteger_zero_node, \n+\t\t\t\tinteger_zero_node,\n \t\t\t\tpfn);\n     }\n \n@@ -5817,7 +5817,7 @@ pfn_from_ptrmemfunc (tree t)\n     {\n       tree delta;\n       tree pfn;\n-      \n+\n       expand_ptrmemfunc_cst (t, &delta, &pfn);\n       if (pfn)\n \treturn pfn;\n@@ -5905,8 +5905,8 @@ convert_for_assignment (tree type, tree rhs,\n       /* When -Wno-pmf-conversions is use, we just silently allow\n \t conversions from pointers-to-members to plain pointers.  If\n \t the conversion doesn't work, cp_convert will complain.  */\n-      if (!warn_pmf2ptr \n-\t  && TYPE_PTR_P (type) \n+      if (!warn_pmf2ptr\n+\t  && TYPE_PTR_P (type)\n \t  && TYPE_PTRMEMFUNC_P (rhstype))\n \trhs = cp_convert (strip_top_quals (type), rhs);\n       else\n@@ -5980,7 +5980,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \n   /* We accept references to incomplete types, so we can\n      return here before checking if RHS is of complete type.  */\n-     \n+\n   if (codel == REFERENCE_TYPE)\n     {\n       /* This should eventually happen in convert_arguments.  */\n@@ -5998,7 +5998,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \t    cp_error_at (\"in passing argument %P of %q+D\", parmnum, fndecl);\n \t}\n       return rhs;\n-    }      \n+    }\n \n   if (exp != 0)\n     exp = require_complete_type (exp);\n@@ -6038,7 +6038,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \n   if (TREE_CODE (whats_returned) != ADDR_EXPR)\n     return;\n-  whats_returned = TREE_OPERAND (whats_returned, 0);      \n+  whats_returned = TREE_OPERAND (whats_returned, 0);\n \n   if (TREE_CODE (valtype) == REFERENCE_TYPE)\n     {\n@@ -6048,7 +6048,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t  warning (0, \"returning reference to temporary\");\n \t  return;\n \t}\n-      if (TREE_CODE (whats_returned) == VAR_DECL \n+      if (TREE_CODE (whats_returned) == VAR_DECL\n \t  && DECL_NAME (whats_returned)\n \t  && TEMP_NAME_P (DECL_NAME (whats_returned)))\n \t{\n@@ -6064,10 +6064,10 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t   || TREE_PUBLIC (whats_returned)))\n     {\n       if (TREE_CODE (valtype) == REFERENCE_TYPE)\n-\tcp_warning_at (\"reference to local variable %qD returned\", \n+\tcp_warning_at (\"reference to local variable %qD returned\",\n \t\t       whats_returned);\n       else\n-\tcp_warning_at (\"address of local variable %qD returned\", \n+\tcp_warning_at (\"address of local variable %qD returned\",\n \t\t       whats_returned);\n       return;\n     }\n@@ -6117,7 +6117,7 @@ check_return_expr (tree retval)\n       current_function_returns_value = 1;\n       return retval;\n     }\n-  \n+\n   /* When no explicit return-value is given in a function with a named\n      return value, the named return value is used.  */\n   result = DECL_RESULT (current_function_decl);\n@@ -6141,7 +6141,7 @@ check_return_expr (tree retval)\n   /* Check for a return statement with a value in a function that\n      isn't supposed to return a value.  */\n   else if (retval && !fn_returns_value_p)\n-    {     \n+    {\n       if (VOID_TYPE_P (TREE_TYPE (retval)))\n \t/* You can return a `void' value from a function of `void'\n \t   type.  In that case, we have to evaluate the expression for\n@@ -6280,7 +6280,7 @@ check_return_expr (tree retval)\n       else\n \tmaybe_warn_about_returning_address_of_local (retval);\n     }\n-  \n+\n   /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n     retval = build2 (INIT_EXPR, TREE_TYPE (result), result, retval);\n@@ -6369,7 +6369,7 @@ ptr_reasonably_similar (tree to, tree from)\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n \t  && comptypes (TYPE_OFFSET_BASETYPE (to),\n-\t\t\tTYPE_OFFSET_BASETYPE (from), \n+\t\t\tTYPE_OFFSET_BASETYPE (from),\n \t\t\tCOMPARE_BASE | COMPARE_DERIVED))\n \tcontinue;\n \n@@ -6386,7 +6386,7 @@ ptr_reasonably_similar (tree to, tree from)\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn comptypes\n-\t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), \n+\t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from),\n \t   COMPARE_BASE | COMPARE_DERIVED);\n     }\n }\n@@ -6442,7 +6442,7 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n   if (type == error_mark_node)\n     return;\n \n-  if (TREE_CODE (type) == FUNCTION_TYPE \n+  if (TREE_CODE (type) == FUNCTION_TYPE\n       && type_quals != TYPE_UNQUALIFIED)\n     {\n       /* This was an error in C++98 (cv-qualifiers cannot be added to\n@@ -6465,7 +6465,7 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n       TYPE_NEEDS_CONSTRUCTING (type)\n       /* If the type isn't complete, we don't know yet if it will need\n \t constructing.  */\n-      || !COMPLETE_TYPE_P (type) \n+      || !COMPLETE_TYPE_P (type)\n       /* If the type has a mutable component, that component might be\n \t modified.  */\n       || TYPE_HAS_MUTABLE_P (type))\n@@ -6503,7 +6503,7 @@ casts_away_constness_r (tree *t1, tree *t2)\n      _conv_) from:\n \n             Tcv1,(N-K+1) * cv1,(N-K+2) * ... cv1,N *\n-      \n+\n      to\n \n             Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */\n@@ -6516,7 +6516,7 @@ casts_away_constness_r (tree *t1, tree *t2)\n \t\t\t\t     cp_type_quals (*t2));\n       return;\n     }\n-  \n+\n   quals1 = cp_type_quals (*t1);\n   quals2 = cp_type_quals (*t2);\n \n@@ -6545,7 +6545,7 @@ casts_away_constness (tree t1, tree t2)\n   if (TREE_CODE (t2) == REFERENCE_TYPE)\n     {\n       /* [expr.const.cast]\n-\t \n+\n \t Casting from an lvalue of type T1 to an lvalue of type T2\n \t using a reference cast casts away constness if a cast from an\n \t rvalue of type \"pointer to T1\" to the type \"pointer to T2\"\n@@ -6557,7 +6557,7 @@ casts_away_constness (tree t1, tree t2)\n \n   if (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n     /* [expr.const.cast]\n-       \n+\n        Casting from an rvalue of type \"pointer to data member of X\n        of type T1\" to the type \"pointer to data member of Y of type\n        T2\" casts away constness if a cast from an rvalue of type\n@@ -6569,7 +6569,7 @@ casts_away_constness (tree t1, tree t2)\n \n   /* Casting away constness is only something that makes sense for\n      pointer or reference types.  */\n-  if (TREE_CODE (t1) != POINTER_TYPE \n+  if (TREE_CODE (t1) != POINTER_TYPE\n       || TREE_CODE (t2) != POINTER_TYPE)\n     return false;\n "}, {"sha": "a3d9201af8aa62d2628be15be9a19ecd2cf5d3f1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8094d835f3b458cc3d47195966d944c89208396/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c8094d835f3b458cc3d47195966d944c89208396", "patch": "@@ -236,7 +236,7 @@ int\n abstract_virtuals_error (tree decl, tree type)\n {\n   VEC(tree,gc) *pure;\n-  \n+\n   /* This function applies only to classes. Any other entity can never\n      be abstract.  */\n   if (!CLASS_TYPE_P (type))\n@@ -251,11 +251,11 @@ abstract_virtuals_error (tree decl, tree type)\n       void **slot;\n       struct pending_abstract_type *pat;\n \n-      gcc_assert (!decl || DECL_P (decl) \n+      gcc_assert (!decl || DECL_P (decl)\n \t\t  || TREE_CODE (decl) == IDENTIFIER_NODE);\n \n       if (!abstract_pending_vars)\n-\tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash, \n+\tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash,\n \t\t\t\t\t\t&pat_compare, NULL);\n \n       slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n@@ -302,7 +302,7 @@ abstract_virtuals_error (tree decl, tree type)\n \tcp_error_at (\"invalid abstract return type for member function %q+#D\",\n \t\t     decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error_at (\"invalid abstract return type for function %q+#D\", \n+\tcp_error_at (\"invalid abstract return type for function %q+#D\",\n \t\t     decl);\n       else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n \t/* Here we do not have location information, so use error instead\n@@ -319,7 +319,7 @@ abstract_virtuals_error (tree decl, tree type)\n     {\n       unsigned ix;\n       tree fn;\n-      \n+\n       inform (\"%J  because the following virtual functions are pure \"\n \t      \"within %qT:\", TYPE_MAIN_DECL (type), type);\n \n@@ -331,7 +331,7 @@ abstract_virtuals_error (tree decl, tree type)\n       VEC_truncate (tree, pure, 0);\n     }\n   else\n-    inform (\"%J  since type %qT has pure virtual functions\", \n+    inform (\"%J  since type %qT has pure virtual functions\",\n \t    TYPE_MAIN_DECL (type), type);\n \n   return 1;\n@@ -365,7 +365,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n       p_msg = error;\n       p_msg_at = cp_error_at;\n     }\n-  \n+\n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n@@ -426,7 +426,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n       else\n         (*p_msg) (\"insufficient contextual information to determine type\");\n       break;\n-    \n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -519,7 +519,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n     }\n }\n \n-/* A subroutine of store_init_value.  Splits non-constant static \n+/* A subroutine of store_init_value.  Splits non-constant static\n    initializer INIT into a constant part and generates code to\n    perform the non-constant part of the initialization to DEST.\n    Returns the code for the runtime init.  */\n@@ -659,7 +659,7 @@ digest_init (tree type, tree init, tree* tail)\n   if (!complete_type_or_else (TREE_CODE (type) == ARRAY_TYPE\n \t\t\t      ? TREE_TYPE (type) : type, NULL_TREE))\n     return error_mark_node;\n-  \n+\n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n@@ -1233,7 +1233,7 @@ build_x_arrow (tree expr)\n \t\t\t\t\t  types_memoized);\n \t    }\n \t  last_rval = expr;\n-\t}     \n+\t}\n \n       if (last_rval == NULL_TREE)\n \t{\n@@ -1288,12 +1288,12 @@ build_m_component_ref (tree datum, tree component)\n   if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n     {\n       error (\"%qE cannot be used as a member pointer, since it is of \"\n-             \"type %qT\", \n+             \"type %qT\",\n \t     component, ptrmem_type);\n       return error_mark_node;\n     }\n-    \n-  objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));  \n+\n+  objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n   if (! IS_AGGR_TYPE (objtype))\n     {\n       error (\"cannot apply member pointer %qE to %qE, which is of \"\n@@ -1314,7 +1314,7 @@ build_m_component_ref (tree datum, tree component)\n   else\n     {\n       binfo = lookup_base (objtype, ctype, ba_check, NULL);\n-      \n+\n       if (!binfo)\n \t{\n \tmismatch:\n@@ -1334,15 +1334,15 @@ build_m_component_ref (tree datum, tree component)\n \t things are not as complex as they are for references to\n \t non-static data members.  */\n       type = cp_build_qualified_type (type,\n-\t\t\t\t      (cp_type_quals (type)  \n+\t\t\t\t      (cp_type_quals (type)\n \t\t\t\t       | cp_type_quals (TREE_TYPE (datum))));\n \n       datum = build_address (datum);\n-      \n+\n       /* Convert object to the correct base.  */\n       if (binfo)\n \tdatum = build_base_path (PLUS_EXPR, datum, binfo, 1);\n-      \n+\n       /* Build an expression for \"object + offset\" where offset is the\n \t value stored in the pointer-to-data-member.  */\n       datum = build2 (PLUS_EXPR, build_pointer_type (type),\n@@ -1391,9 +1391,9 @@ build_functional_cast (tree exp, tree parms)\n \n   /* Prepare to evaluate as a call to a constructor.  If this expression\n      is actually used, for example,\n-\t \n+\n      return X (arg1, arg2, ...);\n-\t \n+\n      then the slot being initialized will be filled in.  */\n \n   if (!complete_type_or_else (type, NULL_TREE))\n@@ -1435,12 +1435,12 @@ add_exception_specifier (tree list, tree spec, int complain)\n   tree core = spec;\n   bool is_ptr;\n   int diag_type = -1; /* none */\n-  \n+\n   if (spec == error_mark_node)\n     return list;\n-  \n+\n   gcc_assert (spec && (!list || TREE_VALUE (list)));\n-  \n+\n   /* [except.spec] 1, type in an exception specifier shall not be\n      incomplete, or pointer or ref to incomplete other than pointer\n      to cv void.  */\n@@ -1469,7 +1469,7 @@ add_exception_specifier (tree list, tree spec, int complain)\n   if (ok)\n     {\n       tree probe;\n-      \n+\n       for (probe = list; probe; probe = TREE_CHAIN (probe))\n         if (same_type_p (TREE_VALUE (probe), spec))\n           break;\n@@ -1478,7 +1478,7 @@ add_exception_specifier (tree list, tree spec, int complain)\n     }\n   else\n     diag_type = 0; /* error */\n-    \n+\n   if (diag_type >= 0 && complain)\n     cxx_incomplete_type_diagnostic (NULL_TREE, core, diag_type);\n \n@@ -1500,12 +1500,12 @@ merge_exception_specifiers (tree list, tree add)\n   else\n     {\n       tree orig_list = list;\n-      \n+\n       for (; add; add = TREE_CHAIN (add))\n         {\n           tree spec = TREE_VALUE (add);\n           tree probe;\n-          \n+\n           for (probe = orig_list; probe; probe = TREE_CHAIN (probe))\n             if (same_type_p (TREE_VALUE (probe), spec))\n               break;"}]}