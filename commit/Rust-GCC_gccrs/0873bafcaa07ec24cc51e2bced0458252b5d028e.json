{"sha": "0873bafcaa07ec24cc51e2bced0458252b5d028e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg3M2JhZmNhYTA3ZWMyNGNjNTFlMmJjZWQwNDU4MjUyYjVkMDI4ZQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:50:45Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:50:45Z"}, "message": "lib-xref.adb (Output_Refs): Don't output type references outside the main unit if...\n\n\t* lib-xref.adb (Output_Refs): Don't output type references outside\n\tthe main unit if they are not otherwise referenced.\n\n\t* sem_attr.adb (Analyze_attribute, case Address and Size): Simplify\n\tcode and diagnose additional illegal uses\n\n\t* sem_util.adb (Is_Object_Reference): An indexed component is an\n\tobject only if the prefix is.\n\n\t* g-diopit.adb: Initial version.\n\n\t* g-diopit.ads: Initial version.\n\n\t* g-dirope.adb:\n\t(Expand_Path): Avoid use of Unbounded_String\n\t(Find, Wildcard_Iterator): Moved to child package Iteration\n\n\t* Makefile.in: Added g-diopit.o to GNATRTL_NONTASKING_OBJS\n\n\t* sem_attr.adb: Minor reformatting\n\nFrom-SVN: r47901", "tree": {"sha": "b4ff6b95bcd0d7b38300eb8065cd673c688596c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ff6b95bcd0d7b38300eb8065cd673c688596c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0873bafcaa07ec24cc51e2bced0458252b5d028e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0873bafcaa07ec24cc51e2bced0458252b5d028e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0873bafcaa07ec24cc51e2bced0458252b5d028e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0873bafcaa07ec24cc51e2bced0458252b5d028e/comments", "author": null, "committer": null, "parents": [{"sha": "81217be921244ece2f9246bd4ed3991ba71ed68b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81217be921244ece2f9246bd4ed3991ba71ed68b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81217be921244ece2f9246bd4ed3991ba71ed68b"}], "stats": {"total": 1077, "additions": 652, "deletions": 425}, "files": [{"sha": "4424fc425d607c882a3966ee37c8c28aba35de05", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -1,3 +1,32 @@\n+2001-12-11  Robert Dewar <dewar@gnat.com>\n+\n+\t* lib-xref.adb (Output_Refs): Don't output type references outside \n+\tthe main unit if they are not otherwise referenced.\n+\t\n+2001-12-11  Ed Schonberg <schonber@gnat.com>\n+\n+\t* sem_attr.adb (Analyze_attribute, case Address and Size): Simplify \n+\tcode and diagnose additional illegal uses\n+\t\n+\t* sem_util.adb (Is_Object_Reference): An indexed component is an \n+\tobject only if the prefix is.\n+\t\n+2001-12-11  Vincent Celier <celier@gnat.com>\n+\n+\t* g-diopit.adb: Initial version.\n+\t\n+\t* g-diopit.ads: Initial version.\n+\t\n+\t* g-dirope.adb:\n+\t(Expand_Path): Avoid use of Unbounded_String\n+\t(Find, Wildcard_Iterator): Moved to child package Iteration\n+\t\n+\t* Makefile.in: Added g-diopit.o to GNATRTL_NONTASKING_OBJS\n+\t\n+2001-12-11  Richard Kenner <dewar@gnat.com>\n+\n+\t* sem_attr.adb: Minor reformatting\n+\n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \n \t* sem_ch3.adb: Clarify some ???."}, {"sha": "e2601a2454270f995d273df451882234be6f8a1d", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -1666,6 +1666,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-curexc.o \\\n   g-debuti.o \\\n   g-debpoo.o \\\n+  g-diopit.o \\\n   g-dirope.o \\\n   g-except.o \\\n   g-exctra.o \\\n@@ -3171,14 +3172,22 @@ g-comlin.o : ada.ads a-comlin.ads a-except.ads a-finali.ads a-filico.ads \\\n    s-parame.ads s-secsta.ads s-soflin.ads s-stache.ads s-stalib.ads \\\n    s-stoele.ads s-stratt.ads s-strops.ads s-unstyp.ads unchconv.ads \n \n-g-dirope.o : ada.ads a-charac.ads a-chahan.ads a-chlat1.ads a-except.ads \\\n+g-diopit.o : ada.ads a-charac.ads a-chahan.ads a-chlat1.ads a-except.ads \\\n    a-finali.ads a-filico.ads a-stream.ads a-string.ads a-strfix.ads \\\n-   a-strmap.ads a-strunb.ads a-tags.ads gnat.ads g-dirope.ads g-dirope.adb \\\n+   a-strmap.ads a-tags.ads gnat.ads g-dirope.ads g-dirope.adb \\\n    g-os_lib.ads g-regexp.ads system.ads s-exctab.ads s-finimp.ads \\\n    s-finroo.ads s-parame.ads s-secsta.ads s-soflin.ads s-stache.ads \\\n    s-stalib.ads s-stoele.ads s-stratt.ads s-strops.ads s-unstyp.ads \\\n    unchconv.ads unchdeal.ads \n \n+g-dirope.o : ada.ads a-charac.ads a-chahan.ads a-chlat1.ads a-except.ads \\\n+   a-finali.ads a-filico.ads a-stream.ads a-string.ads a-strfix.ads \\\n+   a-strmap.ads a-tags.ads gnat.ads g-dirope.ads g-dirope.adb \\\n+   g-os_lib.ads system.ads s-exctab.ads s-finimp.ads \\\n+   s-finroo.ads s-parame.ads s-secsta.ads s-soflin.ads s-stache.ads \\\n+   s-stalib.ads s-stoele.ads s-stratt.ads s-strops.ads s-unstyp.ads \\\n+   unchconv.ads unchdeal.ads \n+\n get_targ.o : get_targ.ads get_targ.adb system.ads s-exctab.ads \\\n    s-stalib.ads types.ads unchconv.ads unchdeal.ads \n "}, {"sha": "69c7e4a41dc68b559638d1f6c536a09d20a463c6", "filename": "gcc/ada/g-diopit.adb", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-diopit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-diopit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-diopit.adb?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -0,0 +1,394 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--  G N A T . D I R E C T O R Y _ O P E R A T I O N S . I T E R A T I O N   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--            Copyright (C) 2001 Ada Core Technologies, Inc.                --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling;\n+with Ada.Strings.Fixed;\n+with Ada.Strings.Maps;\n+with GNAT.OS_Lib;\n+with GNAT.Regexp;\n+\n+package body GNAT.Directory_Operations.Iteration is\n+\n+   use Ada;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   procedure Find\n+     (Root_Directory : Dir_Name_Str;\n+      File_Pattern   : String)\n+   is\n+      File_Regexp : constant Regexp.Regexp := Regexp.Compile (File_Pattern);\n+      Index       : Natural := 0;\n+\n+      procedure Read_Directory (Directory : Dir_Name_Str);\n+      --  Open Directory and read all entries. This routine is called\n+      --  recursively for each sub-directories.\n+\n+      function Make_Pathname (Dir, File : String) return String;\n+      --  Returns the pathname for File by adding Dir as prefix.\n+\n+      -------------------\n+      -- Make_Pathname --\n+      -------------------\n+\n+      function Make_Pathname (Dir, File : String) return String is\n+      begin\n+         if Dir (Dir'Last) = '/' or else Dir (Dir'Last) = '\\' then\n+            return Dir & File;\n+         else\n+            return Dir & Dir_Separator & File;\n+         end if;\n+      end Make_Pathname;\n+\n+      --------------------\n+      -- Read_Directory --\n+      --------------------\n+\n+      procedure Read_Directory (Directory : Dir_Name_Str) is\n+         Dir    : Dir_Type;\n+         Buffer : String (1 .. 2_048);\n+         Last   : Natural;\n+         Quit   : Boolean;\n+\n+      begin\n+         Open (Dir, Directory);\n+\n+         loop\n+            Read (Dir, Buffer, Last);\n+            exit when Last = 0;\n+\n+            declare\n+               Dir_Entry : constant String := Buffer (1 .. Last);\n+               Pathname  : constant String\n+                 := Make_Pathname (Directory, Dir_Entry);\n+            begin\n+               if Regexp.Match (Dir_Entry, File_Regexp) then\n+                  Quit  := False;\n+                  Index := Index + 1;\n+\n+                  begin\n+                     Action (Pathname, Index, Quit);\n+                  exception\n+                     when others =>\n+                        Close (Dir);\n+                        raise;\n+                  end;\n+\n+                  exit when Quit;\n+               end if;\n+\n+               --  Recursively call for sub-directories, except for . and ..\n+\n+               if not (Dir_Entry = \".\" or else Dir_Entry = \"..\")\n+                 and then OS_Lib.Is_Directory (Pathname)\n+               then\n+                  Read_Directory (Pathname);\n+               end if;\n+            end;\n+         end loop;\n+\n+         Close (Dir);\n+      end Read_Directory;\n+\n+   begin\n+      Read_Directory (Root_Directory);\n+   end Find;\n+\n+   -----------------------\n+   -- Wildcard_Iterator --\n+   -----------------------\n+\n+   procedure Wildcard_Iterator (Path : Path_Name) is\n+\n+      Index : Natural := 0;\n+\n+      procedure Read\n+        (Directory      : String;\n+         File_Pattern   : String;\n+         Suffix_Pattern : String);\n+      --  Read entries in Directory and call user's callback if the entry\n+      --  match File_Pattern and Suffix_Pattern is empty otherwise it will go\n+      --  down one more directory level by calling Next_Level routine above.\n+\n+      procedure Next_Level\n+        (Current_Path : String;\n+         Suffix_Path  : String);\n+      --  Extract next File_Pattern from Suffix_Path and call Read routine\n+      --  above.\n+\n+      ----------------\n+      -- Next_Level --\n+      ----------------\n+\n+      procedure Next_Level\n+        (Current_Path : String;\n+         Suffix_Path  : String)\n+      is\n+         DS : Natural;\n+         SP : String renames Suffix_Path;\n+\n+      begin\n+         if SP'Length > 2\n+           and then SP (SP'First) = '.'\n+           and then Strings.Maps.Is_In (SP (SP'First + 1), Dir_Seps)\n+         then\n+            --  Starting with \"./\"\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 2 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"./\"\n+\n+               Read (Current_Path & \".\", \"*\", \"\");\n+\n+            else\n+               --  We have \"./dir\"\n+\n+               Read (Current_Path & \".\",\n+                     SP (SP'First + 2 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         elsif SP'Length > 3\n+           and then SP (SP'First .. SP'First + 1) = \"..\"\n+           and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n+         then\n+            --  Starting with \"../\"\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 3 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"../\"\n+\n+               Read (Current_Path & \"..\", \"*\", \"\");\n+\n+            else\n+               --  We have \"../dir\"\n+\n+               Read (Current_Path & \"..\",\n+                     SP (SP'First + 4 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         elsif Current_Path = \"\"\n+           and then SP'Length > 1\n+           and then Characters.Handling.Is_Letter (SP (SP'First))\n+           and then SP (SP'First + 1) = ':'\n+         then\n+            --  Starting with \"<drive>:\"\n+\n+            if SP'Length > 2\n+              and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n+            then\n+               --  Starting with \"<drive>:\\\"\n+\n+               DS :=  Strings.Fixed.Index\n+                        (SP (SP'First + 3 .. SP'Last), Dir_Seps);\n+\n+               if DS = 0 then\n+\n+                  --  Se have \"<drive>:\\dir\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 3 .. SP'Last),\n+                        \"\");\n+\n+               else\n+                  --  We have \"<drive>:\\dir\\kkk\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 3 .. DS - 1),\n+                        SP (DS .. SP'Last));\n+               end if;\n+\n+            else\n+               --  Starting with \"<drive>:\"\n+\n+               DS :=  Strings.Fixed.Index\n+                        (SP (SP'First + 2 .. SP'Last), Dir_Seps);\n+\n+               if DS = 0 then\n+\n+                  --  We have \"<drive>:dir\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 2 .. SP'Last),\n+                        \"\");\n+\n+               else\n+                  --  We have \"<drive>:dir/kkk\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 2 .. DS - 1),\n+                        SP (DS .. SP'Last));\n+               end if;\n+\n+            end if;\n+\n+         elsif Strings.Maps.Is_In (SP (SP'First), Dir_Seps) then\n+\n+            --  Starting with a /\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 1 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"/dir\"\n+\n+               Read (Current_Path,\n+                     SP (SP'First + 1 .. SP'Last),\n+                     \"\");\n+            else\n+               --  We have \"/dir/kkk\"\n+\n+               Read (Current_Path,\n+                     SP (SP'First + 1 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         else\n+            --  Starting with a name\n+\n+            DS := Strings.Fixed.Index (SP, Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"dir\"\n+\n+               Read (Current_Path & '.',\n+                     SP,\n+                     \"\");\n+            else\n+               --  We have \"dir/kkk\"\n+\n+               Read (Current_Path & '.',\n+                     SP (SP'First .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         end if;\n+      end Next_Level;\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      Quit : Boolean := False;\n+      --  Global state to be able to exit all recursive calls.\n+\n+      procedure Read\n+        (Directory      : String;\n+         File_Pattern   : String;\n+         Suffix_Pattern : String)\n+      is\n+         File_Regexp : constant Regexp.Regexp :=\n+                         Regexp.Compile (File_Pattern, Glob => True);\n+         Dir    : Dir_Type;\n+         Buffer : String (1 .. 2_048);\n+         Last   : Natural;\n+\n+      begin\n+         if OS_Lib.Is_Directory (Directory) then\n+            Open (Dir, Directory);\n+\n+            Dir_Iterator : loop\n+               Read (Dir, Buffer, Last);\n+               exit Dir_Iterator when Last = 0;\n+\n+               declare\n+                  Dir_Entry : constant String := Buffer (1 .. Last);\n+                  Pathname  : constant String :=\n+                                Directory & Dir_Separator & Dir_Entry;\n+               begin\n+                  --  Handle \".\" and \"..\" only if explicit use in the\n+                  --  File_Pattern.\n+\n+                  if not\n+                    ((Dir_Entry = \".\" and then File_Pattern /= \".\")\n+                       or else\n+                     (Dir_Entry = \"..\" and then File_Pattern /= \"..\"))\n+                  then\n+                     if Regexp.Match (Dir_Entry, File_Regexp) then\n+\n+                        if Suffix_Pattern = \"\" then\n+\n+                           --  No more matching needed, call user's callback\n+\n+                           Index := Index + 1;\n+\n+                           begin\n+                              Action (Pathname, Index, Quit);\n+\n+                           exception\n+                              when others =>\n+                                 Close (Dir);\n+                                 raise;\n+                           end;\n+\n+                           exit Dir_Iterator when Quit;\n+\n+                        else\n+                           --  Down one level\n+\n+                           Next_Level\n+                             (Directory & Dir_Separator & Dir_Entry,\n+                              Suffix_Pattern);\n+                        end if;\n+                     end if;\n+                  end if;\n+               end;\n+\n+               exit Dir_Iterator when Quit;\n+\n+            end loop Dir_Iterator;\n+\n+            Close (Dir);\n+         end if;\n+      end Read;\n+\n+   begin\n+      Next_Level (\"\", Path);\n+   end Wildcard_Iterator;\n+\n+end GNAT.Directory_Operations.Iteration;"}, {"sha": "051c2814a547d831bf14e26fc8d2f349a1677d6d", "filename": "gcc/ada/g-diopit.ads", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-diopit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-diopit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-diopit.ads?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -0,0 +1,95 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--  G N A T . D I R E C T O R Y _ O P E R A T I O N S . I T E R A T I O N   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--            Copyright (C) 2001 Ada Core Technologies, Inc.                --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Iterators among files\n+\n+package GNAT.Directory_Operations.Iteration is\n+\n+   generic\n+      with procedure Action\n+        (Item  :        String;\n+         Index :        Positive;\n+         Quit  : in out Boolean);\n+   procedure Find\n+     (Root_Directory : Dir_Name_Str;\n+      File_Pattern   : String);\n+   --  Recursively searches the directory structure rooted at Root_Directory.\n+   --  This provides functionality similar to the UNIX 'find' command.\n+   --  Action will be called for every item matching the regular expression\n+   --  File_Pattern (see GNAT.Regexp). Item is the full pathname to the file\n+   --  starting with Root_Directory that has been matched. Index is set to one\n+   --  for the first call and is incremented by one at each call. The iterator\n+   --  will pass in the value False on each call to Action. The iterator will\n+   --  terminate after passing the last matched path to Action or after\n+   --  returning from a call to Action which sets Quit to True.\n+   --  Raises GNAT.Regexp.Error_In_Regexp if File_Pattern is ill formed.\n+\n+   generic\n+      with procedure Action\n+        (Item  :        String;\n+         Index :        Positive;\n+         Quit  : in out Boolean);\n+   procedure Wildcard_Iterator (Path : Path_Name);\n+   --  Calls Action for each path matching Path. Path can include wildcards '*'\n+   --  and '?' and [...]. The rules are:\n+   --\n+   --     *       can be replaced by any sequence of characters\n+   --     ?       can be replaced by a single character\n+   --     [a-z]   match one character in the range 'a' through 'z'\n+   --     [abc]   match either character 'a', 'b' or 'c'\n+   --\n+   --  Item is the filename that has been matched. Index is set to one for the\n+   --  first call and is incremented by one at each call. The iterator's\n+   --  termination can be controlled by setting Quit to True. It is by default\n+   --  set to False.\n+   --\n+   --  For example, if we have the following directory structure:\n+   --     /boo/\n+   --        foo.ads\n+   --     /sed/\n+   --        foo.ads\n+   --        file/\n+   --          foo.ads\n+   --     /sid/\n+   --        foo.ads\n+   --        file/\n+   --          foo.ads\n+   --     /life/\n+   --\n+   --  A call with expression \"/s*/file/*\" will call Action for the following\n+   --  items:\n+   --     /sed/file/foo.ads\n+   --     /sid/file/foo.ads\n+\n+end GNAT.Directory_Operations.Iteration;"}, {"sha": "7d212e8c71b6b2c1323c2cec8fd80bd204c83eb8", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 66, "deletions": 370, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.2 $\n+--                            $Revision$\n --                                                                          --\n --            Copyright (C) 1998-2001 Ada Core Technologies, Inc.           --\n --                                                                          --\n@@ -34,13 +34,11 @@\n \n with Ada.Characters.Handling;\n with Ada.Strings.Fixed;\n-with Ada.Strings.Unbounded;\n with Ada.Strings.Maps;\n with Unchecked_Deallocation;\n with Unchecked_Conversion;\n with System;  use System;\n \n-with GNAT.Regexp;\n with GNAT.OS_Lib;\n \n package body GNAT.Directory_Operations is\n@@ -51,10 +49,6 @@ package body GNAT.Directory_Operations is\n    --  This is the low-level address directory structure as returned by the C\n    --  opendir routine.\n \n-   Dir_Seps : constant Strings.Maps.Character_Set :=\n-                Strings.Maps.To_Set (\"/\\\");\n-   --  UNIX and DOS style directory separators.\n-\n    procedure Free is new\n      Unchecked_Deallocation (Dir_Type_Value, Dir_Type);\n \n@@ -220,7 +214,16 @@ package body GNAT.Directory_Operations is\n    -----------------\n \n    function Expand_Path (Path : Path_Name) return String is\n-      use Ada.Strings.Unbounded;\n+\n+      Result      : OS_Lib.String_Access := new String (1 .. 200);\n+      Result_Last : Natural := 0;\n+\n+      procedure Append (C : Character);\n+      procedure Append (S : String);\n+      --  Append to Result\n+\n+      procedure Double_Result_Size;\n+      --  Reallocate Result, doubling its size\n \n       procedure Read (K : in out Positive);\n       --  Update Result while reading current Path starting at position K. If\n@@ -230,10 +233,43 @@ package body GNAT.Directory_Operations is\n       --  Translate variable name starting at position K with the associated\n       --  environment value.\n \n-      procedure Free is\n-         new Unchecked_Deallocation (String, OS_Lib.String_Access);\n+      ------------\n+      -- Append --\n+      ------------\n+\n+      procedure Append (C : Character) is\n+      begin\n+         if Result_Last = Result'Last then\n+            Double_Result_Size;\n+         end if;\n+\n+         Result_Last := Result_Last + 1;\n+         Result (Result_Last) := C;\n+      end Append;\n \n-      Result : Unbounded_String;\n+      procedure Append (S : String) is\n+      begin\n+         while Result_Last + S'Length - 1 > Result'Last loop\n+            Double_Result_Size;\n+         end loop;\n+\n+         Result (Result_Last + 1 .. Result_Last + S'Length - 1) := S;\n+         Result_Last := Result_Last + S'Length - 1;\n+      end Append;\n+\n+      ------------------------\n+      -- Double_Result_Size --\n+      ------------------------\n+\n+      procedure Double_Result_Size is\n+         New_Result : constant OS_Lib.String_Access :=\n+           new String (1 .. 2 * Result'Last);\n+\n+      begin\n+         New_Result (1 .. Result_Last) := Result (1 .. Result_Last);\n+         OS_Lib.Free (Result);\n+         Result := New_Result;\n+      end Double_Result_Size;\n \n       ----------\n       -- Read --\n@@ -253,7 +289,7 @@ package body GNAT.Directory_Operations is\n                      --  Not a variable after all, this is a double $, just\n                      --  insert one in the result string.\n \n-                     Append (Result, '$');\n+                     Append ('$');\n                      K := K + 1;\n \n                   else\n@@ -266,13 +302,13 @@ package body GNAT.Directory_Operations is\n                else\n                   --  We have an ending $ sign\n \n-                  Append (Result, '$');\n+                  Append ('$');\n                end if;\n \n             else\n                --  This is a standard character, just add it to the result\n \n-               Append (Result, Path (K));\n+               Append (Path (K));\n             end if;\n \n             --  Skip to next character\n@@ -311,15 +347,16 @@ package body GNAT.Directory_Operations is\n                           OS_Lib.Getenv (Path (K + 1 .. E - 1));\n \n                begin\n-                  Append (Result, Env.all);\n-                  Free (Env);\n+                  Append (Env.all);\n+                  OS_Lib.Free (Env);\n                end;\n \n             else\n                --  No closing curly bracket, not a variable after all or a\n                --  syntax error, ignore it, insert string as-is.\n \n-               Append (Result, '$' & Path (K .. E));\n+               Append ('$');\n+               Append (Path (K .. E));\n             end if;\n \n          else\n@@ -350,14 +387,15 @@ package body GNAT.Directory_Operations is\n                   Env : OS_Lib.String_Access := OS_Lib.Getenv (Path (K .. E));\n \n                begin\n-                  Append (Result, Env.all);\n-                  Free (Env);\n+                  Append (Env.all);\n+                  OS_Lib.Free (Env);\n                end;\n \n             else\n                --  This is not a variable after all\n \n-               Append (Result, '$' & Path (E));\n+               Append ('$');\n+               Append (Path (E));\n             end if;\n \n          end if;\n@@ -373,7 +411,14 @@ package body GNAT.Directory_Operations is\n \n       begin\n          Read (K);\n-         return To_String (Result);\n+\n+         declare\n+            Returned_Value : constant String := Result (1 .. Result_Last);\n+\n+         begin\n+            OS_Lib.Free (Result);\n+            return Returned_Value;\n+         end;\n       end;\n    end Expand_Path;\n \n@@ -413,91 +458,6 @@ package body GNAT.Directory_Operations is\n       return Base_Name (Path);\n    end File_Name;\n \n-   ----------\n-   -- Find --\n-   ----------\n-\n-   procedure Find\n-     (Root_Directory : Dir_Name_Str;\n-      File_Pattern   : String)\n-   is\n-      File_Regexp : constant Regexp.Regexp := Regexp.Compile (File_Pattern);\n-      Index       : Natural := 0;\n-\n-      procedure Read_Directory (Directory : Dir_Name_Str);\n-      --  Open Directory and read all entries. This routine is called\n-      --  recursively for each sub-directories.\n-\n-      function Make_Pathname (Dir, File : String) return String;\n-      --  Returns the pathname for File by adding Dir as prefix.\n-\n-      -------------------\n-      -- Make_Pathname --\n-      -------------------\n-\n-      function Make_Pathname (Dir, File : String) return String is\n-      begin\n-         if Dir (Dir'Last) = '/' or else Dir (Dir'Last) = '\\' then\n-            return Dir & File;\n-         else\n-            return Dir & Dir_Separator & File;\n-         end if;\n-      end Make_Pathname;\n-\n-      --------------------\n-      -- Read_Directory --\n-      --------------------\n-\n-      procedure Read_Directory (Directory : Dir_Name_Str) is\n-         Dir    : Dir_Type;\n-         Buffer : String (1 .. 2_048);\n-         Last   : Natural;\n-         Quit   : Boolean;\n-\n-      begin\n-         Open (Dir, Directory);\n-\n-         loop\n-            Read (Dir, Buffer, Last);\n-            exit when Last = 0;\n-\n-            declare\n-               Dir_Entry : constant String := Buffer (1 .. Last);\n-               Pathname  : constant String\n-                 := Make_Pathname (Directory, Dir_Entry);\n-            begin\n-               if Regexp.Match (Dir_Entry, File_Regexp) then\n-                  Quit  := False;\n-                  Index := Index + 1;\n-\n-                  begin\n-                     Action (Pathname, Index, Quit);\n-                  exception\n-                     when others =>\n-                        Close (Dir);\n-                        raise;\n-                  end;\n-\n-                  exit when Quit;\n-               end if;\n-\n-               --  Recursively call for sub-directories, except for . and ..\n-\n-               if not (Dir_Entry = \".\" or else Dir_Entry = \"..\")\n-                 and then OS_Lib.Is_Directory (Pathname)\n-               then\n-                  Read_Directory (Pathname);\n-               end if;\n-            end;\n-         end loop;\n-\n-         Close (Dir);\n-      end Read_Directory;\n-\n-   begin\n-      Read_Directory (Root_Directory);\n-   end Find;\n-\n    ---------------------\n    -- Get_Current_Dir --\n    ---------------------\n@@ -717,268 +677,4 @@ package body GNAT.Directory_Operations is\n       rmdir (C_Dir_Name);\n    end Remove_Dir;\n \n-   -----------------------\n-   -- Wildcard_Iterator --\n-   -----------------------\n-\n-   procedure Wildcard_Iterator (Path : Path_Name) is\n-\n-      Index : Natural := 0;\n-\n-      procedure Read\n-        (Directory      : String;\n-         File_Pattern   : String;\n-         Suffix_Pattern : String);\n-      --  Read entries in Directory and call user's callback if the entry\n-      --  match File_Pattern and Suffix_Pattern is empty otherwise it will go\n-      --  down one more directory level by calling Next_Level routine above.\n-\n-      procedure Next_Level\n-        (Current_Path : String;\n-         Suffix_Path  : String);\n-      --  Extract next File_Pattern from Suffix_Path and call Read routine\n-      --  above.\n-\n-      ----------------\n-      -- Next_Level --\n-      ----------------\n-\n-      procedure Next_Level\n-        (Current_Path : String;\n-         Suffix_Path  : String)\n-      is\n-         DS : Natural;\n-         SP : String renames Suffix_Path;\n-\n-      begin\n-         if SP'Length > 2\n-           and then SP (SP'First) = '.'\n-           and then Strings.Maps.Is_In (SP (SP'First + 1), Dir_Seps)\n-         then\n-            --  Starting with \"./\"\n-\n-            DS := Strings.Fixed.Index\n-              (SP (SP'First + 2 .. SP'Last),\n-               Dir_Seps);\n-\n-            if DS = 0 then\n-\n-               --  We have \"./\"\n-\n-               Read (Current_Path & \".\", \"*\", \"\");\n-\n-            else\n-               --  We have \"./dir\"\n-\n-               Read (Current_Path & \".\",\n-                     SP (SP'First + 2 .. DS - 1),\n-                     SP (DS .. SP'Last));\n-            end if;\n-\n-         elsif SP'Length > 3\n-           and then SP (SP'First .. SP'First + 1) = \"..\"\n-           and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n-         then\n-            --  Starting with \"../\"\n-\n-            DS := Strings.Fixed.Index\n-              (SP (SP'First + 3 .. SP'Last),\n-               Dir_Seps);\n-\n-            if DS = 0 then\n-\n-               --  We have \"../\"\n-\n-               Read (Current_Path & \"..\", \"*\", \"\");\n-\n-            else\n-               --  We have \"../dir\"\n-\n-               Read (Current_Path & \"..\",\n-                     SP (SP'First + 4 .. DS - 1),\n-                     SP (DS .. SP'Last));\n-            end if;\n-\n-         elsif Current_Path = \"\"\n-           and then SP'Length > 1\n-           and then Characters.Handling.Is_Letter (SP (SP'First))\n-           and then SP (SP'First + 1) = ':'\n-         then\n-            --  Starting with \"<drive>:\"\n-\n-            if SP'Length > 2\n-              and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n-            then\n-               --  Starting with \"<drive>:\\\"\n-\n-               DS :=  Strings.Fixed.Index\n-                        (SP (SP'First + 3 .. SP'Last), Dir_Seps);\n-\n-               if DS = 0 then\n-\n-                  --  Se have \"<drive>:\\dir\"\n-\n-                  Read (SP (SP'First .. SP'First + 1),\n-                        SP (SP'First + 3 .. SP'Last),\n-                        \"\");\n-\n-               else\n-                  --  We have \"<drive>:\\dir\\kkk\"\n-\n-                  Read (SP (SP'First .. SP'First + 1),\n-                        SP (SP'First + 3 .. DS - 1),\n-                        SP (DS .. SP'Last));\n-               end if;\n-\n-            else\n-               --  Starting with \"<drive>:\"\n-\n-               DS :=  Strings.Fixed.Index\n-                        (SP (SP'First + 2 .. SP'Last), Dir_Seps);\n-\n-               if DS = 0 then\n-\n-                  --  We have \"<drive>:dir\"\n-\n-                  Read (SP (SP'First .. SP'First + 1),\n-                        SP (SP'First + 2 .. SP'Last),\n-                        \"\");\n-\n-               else\n-                  --  We have \"<drive>:dir/kkk\"\n-\n-                  Read (SP (SP'First .. SP'First + 1),\n-                        SP (SP'First + 2 .. DS - 1),\n-                        SP (DS .. SP'Last));\n-               end if;\n-\n-            end if;\n-\n-         elsif Strings.Maps.Is_In (SP (SP'First), Dir_Seps) then\n-\n-            --  Starting with a /\n-\n-            DS := Strings.Fixed.Index\n-              (SP (SP'First + 1 .. SP'Last),\n-               Dir_Seps);\n-\n-            if DS = 0 then\n-\n-               --  We have \"/dir\"\n-\n-               Read (Current_Path,\n-                     SP (SP'First + 1 .. SP'Last),\n-                     \"\");\n-            else\n-               --  We have \"/dir/kkk\"\n-\n-               Read (Current_Path,\n-                     SP (SP'First + 1 .. DS - 1),\n-                     SP (DS .. SP'Last));\n-            end if;\n-\n-         else\n-            --  Starting with a name\n-\n-            DS := Strings.Fixed.Index (SP, Dir_Seps);\n-\n-            if DS = 0 then\n-\n-               --  We have \"dir\"\n-\n-               Read (Current_Path & '.',\n-                     SP,\n-                     \"\");\n-            else\n-               --  We have \"dir/kkk\"\n-\n-               Read (Current_Path & '.',\n-                     SP (SP'First .. DS - 1),\n-                     SP (DS .. SP'Last));\n-            end if;\n-\n-         end if;\n-      end Next_Level;\n-\n-      ----------\n-      -- Read --\n-      ----------\n-\n-      Quit : Boolean := False;\n-      --  Global state to be able to exit all recursive calls.\n-\n-      procedure Read\n-        (Directory      : String;\n-         File_Pattern   : String;\n-         Suffix_Pattern : String)\n-      is\n-         File_Regexp : constant Regexp.Regexp :=\n-                         Regexp.Compile (File_Pattern, Glob => True);\n-         Dir    : Dir_Type;\n-         Buffer : String (1 .. 2_048);\n-         Last   : Natural;\n-\n-      begin\n-         if OS_Lib.Is_Directory (Directory) then\n-            Open (Dir, Directory);\n-\n-            Dir_Iterator : loop\n-               Read (Dir, Buffer, Last);\n-               exit Dir_Iterator when Last = 0;\n-\n-               declare\n-                  Dir_Entry : constant String := Buffer (1 .. Last);\n-                  Pathname  : constant String :=\n-                                Directory & Dir_Separator & Dir_Entry;\n-               begin\n-                  --  Handle \".\" and \"..\" only if explicit use in the\n-                  --  File_Pattern.\n-\n-                  if not\n-                    ((Dir_Entry = \".\" and then File_Pattern /= \".\")\n-                       or else\n-                     (Dir_Entry = \"..\" and then File_Pattern /= \"..\"))\n-                  then\n-                     if Regexp.Match (Dir_Entry, File_Regexp) then\n-\n-                        if Suffix_Pattern = \"\" then\n-\n-                           --  No more matching needed, call user's callback\n-\n-                           Index := Index + 1;\n-\n-                           begin\n-                              Action (Pathname, Index, Quit);\n-\n-                           exception\n-                              when others =>\n-                                 Close (Dir);\n-                                 raise;\n-                           end;\n-\n-                           exit Dir_Iterator when Quit;\n-\n-                        else\n-                           --  Down one level\n-\n-                           Next_Level\n-                             (Directory & Dir_Separator & Dir_Entry,\n-                              Suffix_Pattern);\n-                        end if;\n-                     end if;\n-                  end if;\n-               end;\n-\n-               exit Dir_Iterator when Quit;\n-\n-            end loop Dir_Iterator;\n-\n-            Close (Dir);\n-         end if;\n-      end Read;\n-\n-   begin\n-      Next_Level (\"\", Path);\n-   end Wildcard_Iterator;\n-\n end GNAT.Directory_Operations;"}, {"sha": "c49866f4af2c9529b838e258f4fdbc792ac9a726", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -751,7 +751,7 @@ package body Lib.Xref is\n \n                         if Sloc (Tref) = Standard_Location then\n \n-                           --  For now, output only if speial -gnatdM flag set\n+                           --  For now, output only if special -gnatdM flag set\n \n                            exit when not Debug_Flag_MM;\n \n@@ -769,6 +769,14 @@ package body Lib.Xref is\n \n                            exit when not (Debug_Flag_MM or else Left = '<');\n \n+                           --  Do not output type reference if referenced\n+                           --  entity is not in the main unit and is itself\n+                           --  not referenced, since otherwise the reference\n+                           --  will dangle.\n+\n+                           exit when not Referenced (Tref)\n+                             and then not In_Extended_Main_Source_Unit (Tref);\n+\n                            --  Output the reference\n \n                            Write_Info_Char (Left);"}, {"sha": "c0bc236c82263adcb0e7fa02281960af04a52786", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -1545,33 +1545,48 @@ package body Sem_Attr is\n          --  get the proper value, but if expansion is not active, then\n          --  the check here allows proper semantic analysis of the reference.\n \n-         if (Is_Entity_Name (P)\n-           and then\n-             (((Ekind (Entity (P)) = E_Task_Type\n-                 or else Ekind (Entity (P)) = E_Protected_Type)\n-                   and then Etype (Entity (P)) = Base_Type (Entity (P)))\n-               or else Ekind (Entity (P)) = E_Package\n-               or else Is_Generic_Unit (Entity (P))))\n-           or else\n-            (Nkind (P) = N_Attribute_Reference\n-              and then\n-             Attribute_Name (P) = Name_AST_Entry)\n+         --  An Address attribute created by expansion is legal even when it\n+         --  applies to other entity-denoting expressions.\n+\n+         if (Is_Entity_Name (P)) then\n+            if Is_Subprogram (Entity (P))\n+              or else Is_Object (Entity (P))\n+              or else Ekind (Entity (P)) = E_Label\n+            then\n+               Set_Address_Taken (Entity (P));\n+\n+            elsif ((Ekind (Entity (P)) = E_Task_Type\n+                      or else Ekind (Entity (P)) = E_Protected_Type)\n+                    and then Etype (Entity (P)) = Base_Type (Entity (P)))\n+              or else Ekind (Entity (P)) = E_Package\n+              or else Is_Generic_Unit (Entity (P))\n+            then\n+               Rewrite (N,\n+                 New_Occurrence_Of (RTE (RE_Null_Address), Sloc (N)));\n+\n+            else\n+               Error_Attr (\"invalid prefix for % attribute\", P);\n+            end if;\n+\n+         elsif Nkind (P) = N_Attribute_Reference\n+          and then Attribute_Name (P) = Name_AST_Entry\n          then\n             Rewrite (N,\n               New_Occurrence_Of (RTE (RE_Null_Address), Sloc (N)));\n \n-         --  The following logic is obscure, needs explanation ???\n+         elsif Is_Object_Reference (P) then\n+            null;\n \n-         elsif Nkind (P) = N_Attribute_Reference\n-           or else (Is_Entity_Name (P)\n-                      and then not Is_Subprogram (Entity (P))\n-                      and then not Is_Object (Entity (P))\n-                      and then Ekind (Entity (P)) /= E_Label)\n+         elsif Nkind (P) = N_Selected_Component\n+           and then Is_Subprogram (Entity (Selector_Name (P)))\n          then\n-            Error_Attr (\"invalid prefix for % attribute\", P);\n+            null;\n \n-         elsif Is_Entity_Name (P) then\n-            Set_Address_Taken (Entity (P));\n+         elsif not Comes_From_Source (N) then\n+            null;\n+\n+         else\n+            Error_Attr (\"invalid prefix for % attribute\", P);\n          end if;\n \n          Set_Etype (N, RTE (RE_Address));\n@@ -3138,22 +3153,21 @@ package body Sem_Attr is\n \n          if Is_Object_Reference (P)\n            or else (Is_Entity_Name (P)\n-                      and then\n-                    Ekind (Entity (P)) = E_Function)\n+                     and then Ekind (Entity (P)) = E_Function)\n          then\n             Check_Object_Reference (P);\n \n-         elsif Nkind (P) = N_Attribute_Reference\n-           or else\n-             (Nkind (P) = N_Selected_Component\n-               and then (Is_Entry (Entity (Selector_Name (P)))\n-                           or else\n-                         Is_Subprogram (Entity (Selector_Name (P)))))\n-           or else\n-             (Is_Entity_Name (P)\n-               and then not Is_Type (Entity (P))\n-               and then not Is_Object (Entity (P)))\n+         elsif Is_Entity_Name (P)\n+           and then Is_Type (Entity (P))\n          then\n+            null;\n+\n+         elsif Nkind (P) = N_Type_Conversion\n+           and then not Comes_From_Source (P)\n+         then\n+            null;\n+\n+         else\n             Error_Attr (\"invalid prefix for % attribute\", P);\n          end if;\n \n@@ -5490,7 +5504,7 @@ package body Sem_Attr is\n \n       when Attribute_Small =>\n \n-         --  The floating-point case is present only for Ada 83 compatibility.\n+         --  The floating-point case is present only for Ada 83 compatability.\n          --  Note that strictly this is an illegal addition, since we are\n          --  extending an Ada 95 defined attribute, but we anticipate an\n          --  ARG ruling that will permit this.\n@@ -6511,24 +6525,6 @@ package body Sem_Attr is\n                end if;\n             end if;\n \n-            --  Do not permit address to be applied to entry\n-\n-            if (Is_Entity_Name (P) and then Is_Entry (Entity (P)))\n-              or else Nkind (P) = N_Entry_Call_Statement\n-\n-              or else (Nkind (P) = N_Selected_Component\n-                and then Is_Entry (Entity (Selector_Name (P))))\n-\n-              or else (Nkind (P) = N_Indexed_Component\n-                and then Nkind (Prefix (P)) = N_Selected_Component\n-                and then Is_Entry (Entity (Selector_Name (Prefix (P)))))\n-            then\n-               Error_Msg_Name_1 := Aname;\n-               Error_Msg_N\n-                 (\"prefix of % attribute cannot be entry\", N);\n-               return;\n-            end if;\n-\n             if not Is_Entity_Name (P)\n                or else not Is_Overloadable (Entity (P))\n             then"}, {"sha": "53b9ce68d2a8ebc334d5f7bad18746e0412c4239", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0873bafcaa07ec24cc51e2bced0458252b5d028e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0873bafcaa07ec24cc51e2bced0458252b5d028e", "patch": "@@ -3053,7 +3053,7 @@ package body Sem_Util is\n       else\n          case Nkind (N) is\n             when N_Indexed_Component | N_Slice =>\n-               return True;\n+               return Is_Object_Reference (Prefix (N));\n \n             --  In Ada95, a function call is a constant object.\n "}]}