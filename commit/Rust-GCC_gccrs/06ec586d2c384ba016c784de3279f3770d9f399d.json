{"sha": "06ec586d2c384ba016c784de3279f3770d9f399d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYzU4NmQyYzM4NGJhMDE2Yzc4NGRlMzI3OWYzNzcwZDlmMzk5ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T10:37:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T10:37:03Z"}, "message": "Allow vector CONSTs\n\nThis patch allows (const ...) wrappers to be used for rtx vector\nconstants, as an alternative to const_vector.  This is useful\nfor SVE, where the number of elements isn't known until runtime.\n\nIt could also be useful in future for fixed-length vectors, to\nreduce the amount of memory needed to represent simple constants\nwith high element counts.  However, one nice thing about keeping\nit restricted to variable-length vectors is that there is never\nany need to handle combinations of (const ...) and CONST_VECTOR.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/rtl.texi (const): Update description of address constants.\n\tSay that vector constants are allowed too.\n\t* common.md (E, F): Use CONSTANT_P instead of checking for\n\tCONST_VECTOR.\n\t* emit-rtl.c (gen_lowpart_common): Use const_vec_p instead of\n\tchecking for CONST_VECTOR.\n\t* expmed.c (make_tree): Use build_vector_from_val for a CONST\n\tVEC_DUPLICATE.\n\t* expr.c (expand_expr_real_2): Check for vector modes instead\n\tof checking for CONST_VECTOR.\n\t* rtl.h (const_vec_p): New function.\n\t(const_vec_duplicate_p): Check for a CONST VEC_DUPLICATE.\n\t(unwrap_const_vec_duplicate): Handle them here too.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254296", "tree": {"sha": "fa771154bb36a0e333d0f1ec22f6a13d31021200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa771154bb36a0e333d0f1ec22f6a13d31021200"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ec586d2c384ba016c784de3279f3770d9f399d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec586d2c384ba016c784de3279f3770d9f399d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ec586d2c384ba016c784de3279f3770d9f399d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec586d2c384ba016c784de3279f3770d9f399d/comments", "author": null, "committer": null, "parents": [{"sha": "9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730"}], "stats": {"total": 80, "additions": 63, "deletions": 17}, "files": [{"sha": "0a30e383337b8601b6a4c82b24bc774f531215b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -1,3 +1,21 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/rtl.texi (const): Update description of address constants.\n+\tSay that vector constants are allowed too.\n+\t* common.md (E, F): Use CONSTANT_P instead of checking for\n+\tCONST_VECTOR.\n+\t* emit-rtl.c (gen_lowpart_common): Use const_vec_p instead of\n+\tchecking for CONST_VECTOR.\n+\t* expmed.c (make_tree): Use build_vector_from_val for a CONST\n+\tVEC_DUPLICATE.\n+\t* expr.c (expand_expr_real_2): Check for vector modes instead\n+\tof checking for CONST_VECTOR.\n+\t* rtl.h (const_vec_p): New function.\n+\t(const_vec_duplicate_p): Check for a CONST VEC_DUPLICATE.\n+\t(unwrap_const_vec_duplicate): Handle them here too.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    David Malcolm  <dmalcolm@redhat.com>\n \t    Alan Hayward  <alan.hayward@arm.com>"}, {"sha": "22c010ffb000464ee24a0680c4d1e10af8ec0209", "filename": "gcc/common.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fcommon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fcommon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.md?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -80,14 +80,14 @@\n (define_constraint \"E\"\n   \"Matches a floating-point constant.\"\n   (ior (match_test \"CONST_DOUBLE_AS_FLOAT_P (op)\")\n-       (match_test \"GET_CODE (op) == CONST_VECTOR\n+       (match_test \"CONSTANT_P (op)\n \t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT\")))\n \n ;; There is no longer a distinction between \"E\" and \"F\".\n (define_constraint \"F\"\n   \"Matches a floating-point constant.\"\n   (ior (match_test \"CONST_DOUBLE_AS_FLOAT_P (op)\")\n-       (match_test \"GET_CODE (op) == CONST_VECTOR\n+       (match_test \"CONSTANT_P (op)\n \t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT\")))\n \n (define_constraint \"X\""}, {"sha": "0a5623e619d3875623637830c1dfc78f2824e53b", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -1667,14 +1667,17 @@ Usually that is the only mode for which a label is directly valid.\n \n @findex const\n @item (const:@var{m} @var{exp})\n-Represents a constant that is the result of an assembly-time\n-arithmetic computation.  The operand, @var{exp}, is an expression that\n-contains only constants (@code{const_int}, @code{symbol_ref} and\n-@code{label_ref} expressions) combined with @code{plus} and\n-@code{minus}.  However, not all combinations are valid, since the\n-assembler cannot do arbitrary arithmetic on relocatable symbols.\n-\n-@var{m} should be @code{Pmode}.\n+Wraps an rtx computation @var{exp} whose inputs and result do not\n+change during the execution of a thread.  There are two valid uses.\n+The first is to represent a global or thread-local address calculation.\n+In this case @var{exp} should contain @code{const_int},\n+@code{symbol_ref}, @code{label_ref} or @code{unspec} expressions,\n+combined with @code{plus} and @code{minus}.  Any such @code{unspec}s\n+are target-specific and typically represent some form of relocation\n+operator.  @var{m} should be a valid address mode.\n+\n+The second use of @code{const} is to wrap a vector operation.\n+In this case @var{exp} must be a @code{vec_duplicate} expression.\n \n @findex high\n @item (high:@var{m} @var{exp})"}, {"sha": "10554ac8cfe7d2416d039ca571f200f9f8c13b67", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -1470,7 +1470,7 @@ gen_lowpart_common (machine_mode mode, rtx x)\n \treturn gen_rtx_fmt_e (GET_CODE (x), int_mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG || REG_P (x)\n-\t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR\n+\t   || GET_CODE (x) == CONCAT || const_vec_p (x)\n \t   || CONST_DOUBLE_AS_FLOAT_P (x) || CONST_SCALAR_INT_P (x))\n     return lowpart_subreg (mode, x, innermode);\n "}, {"sha": "da9a0a23d62b952390e4a61d5efb99f47e400103", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -5244,7 +5244,15 @@ make_tree (tree type, rtx x)\n       return fold_convert (type, make_tree (t, XEXP (x, 0)));\n \n     case CONST:\n-      return make_tree (type, XEXP (x, 0));\n+      {\n+\trtx op = XEXP (x, 0);\n+\tif (GET_CODE (op) == VEC_DUPLICATE)\n+\t  {\n+\t    tree elt_tree = make_tree (TREE_TYPE (type), XEXP (op, 0));\n+\t    return build_vector_from_val (type, elt_tree);\n+\t  }\n+\treturn make_tree (type, op);\n+      }\n \n     case SYMBOL_REF:\n       t = SYMBOL_REF_DECL (x);"}, {"sha": "cb294bb8a9fa960fc522dc33eee3bd5dd9d5de76", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -9429,7 +9429,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       /* Careful here: if the target doesn't support integral vector modes,\n \t a constant selection vector could wind up smooshed into a normal\n \t integral constant.  */\n-      if (CONSTANT_P (op2) && GET_CODE (op2) != CONST_VECTOR)\n+      if (CONSTANT_P (op2) && !VECTOR_MODE_P (GET_MODE (op2)))\n \t{\n \t  tree sel_type = TREE_TYPE (treeop2);\n \t  machine_mode vmode"}, {"sha": "373f8a247883fbcd255fc86213b1795f253fbc41", "filename": "gcc/rtl.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec586d2c384ba016c784de3279f3770d9f399d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=06ec586d2c384ba016c784de3279f3770d9f399d", "patch": "@@ -2749,12 +2749,22 @@ extern rtx shallow_copy_rtx (const_rtx CXX_MEM_STAT_INFO);\n extern int rtx_equal_p (const_rtx, const_rtx);\n extern bool rtvec_all_equal_p (const_rtvec);\n \n+/* Return true if X is some form of vector constant.  */\n+\n+inline bool\n+const_vec_p (const_rtx x)\n+{\n+  return VECTOR_MODE_P (GET_MODE (x)) && CONSTANT_P (x);\n+}\n+\n /* Return true if X is a vector constant with a duplicated element value.  */\n \n inline bool\n const_vec_duplicate_p (const_rtx x)\n {\n-  return GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0));\n+  return ((GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n+\t  || (GET_CODE (x) == CONST\n+\t      && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE));\n }\n \n /* Return true if X is a vector constant with a duplicated element value.\n@@ -2764,11 +2774,16 @@ template <typename T>\n inline bool\n const_vec_duplicate_p (T x, T *elt)\n {\n-  if (const_vec_duplicate_p (x))\n+  if (GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n     {\n       *elt = CONST_VECTOR_ELT (x, 0);\n       return true;\n     }\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE)\n+    {\n+      *elt = XEXP (XEXP (x, 0), 0);\n+      return true;\n+    }\n   return false;\n }\n \n@@ -2794,8 +2809,10 @@ template <typename T>\n inline T\n unwrap_const_vec_duplicate (T x)\n {\n-  if (const_vec_duplicate_p (x))\n-    x = CONST_VECTOR_ELT (x, 0);\n+  if (GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n+    return CONST_VECTOR_ELT (x, 0);\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE)\n+    return XEXP (XEXP (x, 0), 0);\n   return x;\n }\n "}]}