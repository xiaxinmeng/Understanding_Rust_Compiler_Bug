{"sha": "0875baa09e1786e1c6d8daaabcb65b8ee6309184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg3NWJhYTA5ZTE3ODZlMWM2ZDhkYWFhYmNiNjViOGVlNjMwOTE4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-16T13:57:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-16T13:57:17Z"}, "message": "flow.c (struct propagate_block_info): Add mem_set_list_len.\n\n        * flow.c (struct propagate_block_info): Add mem_set_list_len.\n        (MAX_MEM_SET_LIST_LEN): New.\n        (propagate_one_insn): Update mem_set_list_len.\n        (invalidate_mems_from_autoinc): Likewise.\n        (invalidate_mems_from_set): Likewise.\n        (mark_used_regs): Likewise.\n        (init_propagate_block_info): Likewise.  Stop collecting memories\n        when we reach MAX_MEM_SET_LIST_LEN.\n        (mark_set_1): Likewise.\n\nFrom-SVN: r39065", "tree": {"sha": "13b070b7d0c70bff21168ac998d0e82bd829891b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b070b7d0c70bff21168ac998d0e82bd829891b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0875baa09e1786e1c6d8daaabcb65b8ee6309184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0875baa09e1786e1c6d8daaabcb65b8ee6309184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0875baa09e1786e1c6d8daaabcb65b8ee6309184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0875baa09e1786e1c6d8daaabcb65b8ee6309184/comments", "author": null, "committer": null, "parents": [{"sha": "c55fa4d6b1c66960f3f75195ace7c6e030672ff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55fa4d6b1c66960f3f75195ace7c6e030672ff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c55fa4d6b1c66960f3f75195ace7c6e030672ff9"}], "stats": {"total": 39, "additions": 36, "deletions": 3}, "files": [{"sha": "063c8d4156285ca448f64850456abc904ee5a7d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0875baa09e1786e1c6d8daaabcb65b8ee6309184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0875baa09e1786e1c6d8daaabcb65b8ee6309184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0875baa09e1786e1c6d8daaabcb65b8ee6309184", "patch": "@@ -1,3 +1,15 @@\n+2001-01-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c (struct propagate_block_info): Add mem_set_list_len.\n+\t(MAX_MEM_SET_LIST_LEN): New.\n+\t(propagate_one_insn): Update mem_set_list_len.\n+\t(invalidate_mems_from_autoinc): Likewise.\n+\t(invalidate_mems_from_set): Likewise.\n+\t(mark_used_regs): Likewise.\n+\t(init_propagate_block_info): Likewise.  Stop collecting memories\n+\twhen we reach MAX_MEM_SET_LIST_LEN.\n+\t(mark_set_1): Likewise.\n+\n 2001-01-16  Richard Henderson  <rth@redhat.com>\n \n \t* unroll.c (precondition_loop_p): Fail if no iteration"}, {"sha": "acd25f2b410d9e6461cf80bcdcf483b75d6693b3", "filename": "gcc/flow.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0875baa09e1786e1c6d8daaabcb65b8ee6309184/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0875baa09e1786e1c6d8daaabcb65b8ee6309184/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0875baa09e1786e1c6d8daaabcb65b8ee6309184", "patch": "@@ -316,13 +316,20 @@ struct propagate_block_info\n   regset reg_cond_reg;\n #endif\n \n+  /* The length of mem_set_list.  */\n+  int mem_set_list_len;\n+\n   /* Non-zero if the value of CC0 is live.  */\n   int cc0_live;\n \n   /* Flags controling the set of information propagate_block collects.  */\n   int flags;\n };\n \n+/* Maximum length of pbi->mem_set_list before we start dropping\n+   new elements on the floor.  */\n+#define MAX_MEM_SET_LIST_LEN\t100\n+\n /* Store the data structures necessary for depth-first search.  */\n struct depth_first_search_dsS {\n   /* stack for backtracking during the algorithm */\n@@ -3877,7 +3884,10 @@ propagate_one_insn (pbi, insn)\n \n \t  /* Non-constant calls clobber memory.  */\n \t  if (! CONST_CALL_P (insn))\n-\t    free_EXPR_LIST_list (&pbi->mem_set_list);\n+\t    {\n+\t      free_EXPR_LIST_list (&pbi->mem_set_list);\n+\t      pbi->mem_set_list_len = 0;\n+\t    }\n \n \t  /* There may be extra registers to be clobbered.  */\n \t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n@@ -3967,6 +3977,7 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n   pbi->bb = bb;\n   pbi->reg_live = live;\n   pbi->mem_set_list = NULL_RTX;\n+  pbi->mem_set_list_len = 0;\n   pbi->local_set = local_set;\n   pbi->cond_local_set = cond_local_set;\n   pbi->cc0_live = 0;\n@@ -4111,6 +4122,8 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n \t\t  mem = shallow_copy_rtx (mem);\n #endif\n \t\tpbi->mem_set_list = alloc_EXPR_LIST (0, mem, pbi->mem_set_list);\n+\t\tif (++pbi->mem_set_list_len >= MAX_MEM_SET_LIST_LEN)\n+\t\t  break;\n \t      }\n \t  }\n     }\n@@ -4512,6 +4525,7 @@ invalidate_mems_from_autoinc (pbi, insn)\n \t\t  else\n \t\t    pbi->mem_set_list = next;\n \t\t  free_EXPR_LIST_node (temp);\n+\t\t  pbi->mem_set_list_len--;\n \t\t}\n \t      else\n \t\tprev = temp;\n@@ -4547,6 +4561,7 @@ invalidate_mems_from_set (pbi, exp)\n \t  else\n \t    pbi->mem_set_list = next;\n \t  free_EXPR_LIST_node (temp);\n+\t  pbi->mem_set_list_len--;\n \t}\n       else\n \tprev = temp;\n@@ -4743,7 +4758,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       if (insn && GET_CODE (reg) == MEM)\n \tinvalidate_mems_from_autoinc (pbi, insn);\n \n-      if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n+      if (pbi->mem_set_list_len < MAX_MEM_SET_LIST_LEN\n+\t  && GET_CODE (reg) == MEM && ! side_effects_p (reg)\n \t  /* ??? With more effort we could track conditional memory life.  */\n \t  && ! cond\n \t  /* We do not know the size of a BLKmode store, so we do not track\n@@ -4761,6 +4777,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t    reg = shallow_copy_rtx (reg);\n #endif\n \t  pbi->mem_set_list = alloc_EXPR_LIST (0, reg, pbi->mem_set_list);\n+\t  pbi->mem_set_list_len++;\n \t}\n     }\n \n@@ -5859,6 +5876,7 @@ mark_used_regs (pbi, x, cond, insn)\n \t\t      else\n \t\t\tpbi->mem_set_list = next;\n \t\t      free_EXPR_LIST_node (temp);\n+\t\t      pbi->mem_set_list_len--;\n \t\t    }\n \t\t  else\n \t\t    prev = temp;\n@@ -5996,7 +6014,10 @@ mark_used_regs (pbi, x, cond, insn)\n \t   So for now, just clear the memory set list and mark any regs\n \t   we can find in ASM_OPERANDS as used.  */\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n-\t  free_EXPR_LIST_list (&pbi->mem_set_list);\n+\t  {\n+\t    free_EXPR_LIST_list (&pbi->mem_set_list);\n+\t    pbi->mem_set_list_len = 0;\n+\t  }\n \n \t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused"}]}