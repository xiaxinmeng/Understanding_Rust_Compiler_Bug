{"sha": "2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMwN2YxM2IyYmNjZjQyYTg2MGU1ZDM2MzRlNzdmYjZhMjY0ZmE1NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-11-29T01:13:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-11-29T01:13:43Z"}, "message": "emit-rtl.c (set_used_flags): New.\n\n\n\t* emit-rtl.c (set_used_flags): New.\n\t(verify_rtx_sharing, verify_rtl_sharing): New.\n\t(unshare_all_rtl_1): Rename to....\n\t(unshare_all_rtl_in_chain): ... this one; make static.\n\t(copy_rtx_if_shared): LABEL_REF chan be shared.\n\t* ifcvt.c (unshare_ifcvt_sequence): New.\n\t(noce_try_move, noce_try_store_flag, noce_try_store_flag_constants,\n\tnoce_try_addcc, noce_try_addcc, noce_try_store_flag_mask,\n\tnoce_try_cmove, noce_try_store_flag_mask, noce_try_minmax,\n\tnoce_try_abs, noce_process_if_block, find_cond_trap\n\t* rtl.h (verify_rtl_sharing, set_used_flags, unshare_all_rtl_in_chain):\n\tDeclare.\n\nFrom-SVN: r74030", "tree": {"sha": "5b202ff1d341586b5f953e702a29102c1ff0041d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b202ff1d341586b5f953e702a29102c1ff0041d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/comments", "author": null, "committer": null, "parents": [{"sha": "58c5975b25b4ef84632ba66b6b6cc380b99bed56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c5975b25b4ef84632ba66b6b6cc380b99bed56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c5975b25b4ef84632ba66b6b6cc380b99bed56"}], "stats": {"total": 260, "additions": 248, "deletions": 12}, "files": [{"sha": "920f03b47e4952044dbe7647f9796ac83752e52a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "patch": "@@ -1,3 +1,18 @@\n+2003-11-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* emit-rtl.c (set_used_flags): New.\n+\t(verify_rtx_sharing, verify_rtl_sharing): New.\n+\t(unshare_all_rtl_1): Rename to....\n+\t(unshare_all_rtl_in_chain): ... this one; make static.\n+\t(copy_rtx_if_shared): LABEL_REF chan be shared.\n+\t* ifcvt.c (unshare_ifcvt_sequence): New.\n+\t(noce_try_move, noce_try_store_flag, noce_try_store_flag_constants,\n+\tnoce_try_addcc, noce_try_addcc, noce_try_store_flag_mask,\n+\tnoce_try_cmove, noce_try_store_flag_mask, noce_try_minmax,\n+\tnoce_try_abs, noce_process_if_block, find_cond_trap\n+\t* rtl.h (verify_rtl_sharing, set_used_flags, unshare_all_rtl_in_chain):\n+\tDeclare.\n+\n 2003-11-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md: Fix a comment typo.\n@@ -204,8 +219,8 @@\n \n 2003-11-24  Jan Hubicka  <jh@suse.cz>\n \n-\t* fold-const.c (fold):  Do not return early when optimizing COMPONENT_REF\n-\tand constant.\n+\t* fold-const.c (fold):  Do not return early when optimizing\n+\tCOMPONENT_REF and constant.\n \n 2003-11-24  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "0f7e677e3efd063a02c16a838d430aa9cd8af974", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 194, "deletions": 4, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "patch": "@@ -180,7 +180,6 @@ static rtx make_jump_insn_raw (rtx);\n static rtx make_call_insn_raw (rtx);\n static rtx find_line_note (rtx);\n static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n-static void unshare_all_rtl_1 (rtx);\n static void unshare_all_decls (tree);\n static void reset_used_decls (tree);\n static void mark_label_nuses (rtx);\n@@ -2450,7 +2449,7 @@ unshare_all_rtl (tree fndecl, rtx insn)\n   unshare_all_decls (DECL_INITIAL (fndecl));\n \n   /* Unshare just about everything else.  */\n-  unshare_all_rtl_1 (insn);\n+  unshare_all_rtl_in_chain (insn);\n \n   /* Make sure the addresses of stack slots found outside the insn chain\n      (such as, in DECL_RTL of a variable) are not shared\n@@ -2492,11 +2491,138 @@ unshare_all_rtl_again (rtx insn)\n   unshare_all_rtl (cfun->decl, insn);\n }\n \n+/* Check that ORIG is not marked when it should not be and mark ORIG as in use,\n+   Recursively does the same for subexpressions.  */\n+\n+static void\n+verify_rtx_sharing (rtx orig, rtx insn)\n+{\n+  rtx x = orig;\n+  int i;\n+  enum rtx_code code;\n+  const char *format_ptr;\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  /* These types may be freely shared.  */\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+      /* SCRATCH must be shared because they represent distinct values.  */\n+      return;\n+\n+    case CONST:\n+      /* CONST can be shared if it contains a SYMBOL_REF.  If it contains\n+\t a LABEL_REF, it isn't sharable.  */\n+      if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\treturn;\n+      break;\n+\n+    case MEM:\n+      /* A MEM is allowed to be shared if its address is constant.  */\n+      if (CONSTANT_ADDRESS_P (XEXP (x, 0))\n+\t  || reload_completed || reload_in_progress)\n+\treturn;\n+\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* This rtx may not be shared.  If it has already been seen,\n+     replace it with a copy of itself.  */\n+\n+  if (RTX_FLAG (x, used))\n+    {\n+      error (\"Invalid rtl sharing found in the insn\");\n+      debug_rtx (insn);\n+      error (\"Shared rtx\");\n+      debug_rtx (x);\n+      abort ();\n+    }\n+  RTX_FLAG (x, used) = 1;\n+\n+  /* Now scan the subexpressions recursively. */\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  verify_rtx_sharing (XEXP (x, i), insn);\n+\t  break;\n+\n+\tcase 'E':\n+\t  if (XVEC (x, i) != NULL)\n+\t    {\n+\t      int j;\n+\t      int len = XVECLEN (x, i);\n+\n+\t      for (j = 0; j < len; j++)\n+\t\t{\n+\t\t  /* We allow sharing of ASM_OPERANDS inside single instruction.  */\n+\t\t  if (j && GET_CODE (XVECEXP (x, i, j)) == SET\n+\t\t      && GET_CODE (SET_SRC (XVECEXP (x, i, j))) == ASM_OPERANDS)\n+\t\t    verify_rtx_sharing (SET_DEST (XVECEXP (x, i, j)), insn);\n+\t\t  else\n+\t\t    verify_rtx_sharing (XVECEXP (x, i, j), insn);\n+\t\t}\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  return;\n+}\n+\n+/* Go through all the RTL insn bodies and chec that there is no inexpected\n+   sharing in between the subexpressions.  */\n+\n+void\n+verify_rtl_sharing (void)\n+{\n+  rtx p;\n+\n+  for (p = get_insns (); p; p = NEXT_INSN (p))\n+    if (INSN_P (p))\n+      {\n+\treset_used_flags (PATTERN (p));\n+\treset_used_flags (REG_NOTES (p));\n+\treset_used_flags (LOG_LINKS (p));\n+      }\n+\n+  for (p = get_insns (); p; p = NEXT_INSN (p))\n+    if (INSN_P (p))\n+      {\n+\tverify_rtx_sharing (PATTERN (p), p);\n+\tverify_rtx_sharing (REG_NOTES (p), p);\n+\tverify_rtx_sharing (LOG_LINKS (p), p);\n+      }\n+}\n+\n /* Go through all the RTL insn bodies and copy any invalid shared structure.\n    Assumes the mark bits are cleared at entry.  */\n \n-static void\n-unshare_all_rtl_1 (rtx insn)\n+void\n+unshare_all_rtl_in_chain (rtx insn)\n {\n   for (; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -2668,6 +2794,7 @@ copy_rtx_if_shared (rtx orig)\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n     case SYMBOL_REF:\n+    case LABEL_REF:\n     case CODE_LABEL:\n     case PC:\n     case CC0:\n@@ -2804,6 +2931,69 @@ reset_used_flags (rtx x)\n \t}\n     }\n }\n+\n+/* Set all the USED bits in X to allow copy_rtx_if_shared to be used\n+   to look for shared sub-parts.  */\n+\n+void\n+set_used_flags (rtx x)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *format_ptr;\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  /* These types may be freely shared so we needn't do any resetting\n+     for them.  */\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return;\n+\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case NOTE:\n+    case LABEL_REF:\n+    case BARRIER:\n+      /* The chain of insns is not being copied.  */\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  RTX_FLAG (x, used) = 1;\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  set_used_flags (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    set_used_flags (XVECEXP (x, i, j));\n+\t  break;\n+\t}\n+    }\n+}\n \f\n /* Copy X if necessary so that it won't be altered by changes in OTHER.\n    Return X or the rtx for the pseudo reg the value of X was copied into."}, {"sha": "29f3f008f7fadaee58d9680aaebdaf2bb0fa4f43", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "patch": "@@ -700,6 +700,16 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t   GET_MODE_BITSIZE (inmode));\n }\n \n+/* Unshare sequence SEQ produced by if conversion.  We care to mark\n+   all arguments that may be shared with outer instruction stream.  */\n+static void\n+unshare_ifcvt_sequence (struct noce_if_info *if_info, rtx seq)\n+{\n+  set_used_flags (if_info->x);\n+  set_used_flags (if_info->cond);\n+  unshare_all_rtl_in_chain (seq);\n+}\n+\n /* Convert \"if (a != b) x = a; else x = b\" into \"x = a\" and\n    \"if (a == b) x = a; else x = b\" into \"x = b\".  */\n \n@@ -734,6 +744,7 @@ noce_try_move (struct noce_if_info *if_info)\n \t  start_sequence ();\n \t  noce_emit_move_insn (if_info->x, y);\n \t  seq = get_insns ();\n+\t  unshare_ifcvt_sequence (if_info, seq);\n \t  end_sequence ();\n \t  emit_insn_before_setloc (seq, if_info->jump,\n \t\t\t\t   INSN_LOCATOR (if_info->insn_a));\n@@ -777,6 +788,7 @@ noce_try_store_flag (struct noce_if_info *if_info)\n \tnoce_emit_move_insn (if_info->x, target);\n \n       seq = get_insns ();\n+      unshare_ifcvt_sequence (if_info, seq);\n       end_sequence ();\n       emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n \n@@ -907,6 +919,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \tnoce_emit_move_insn (if_info->x, target);\n \n       seq = get_insns ();\n+      unshare_ifcvt_sequence (if_info, seq);\n       end_sequence ();\n \n       if (seq_contains_jump (seq))\n@@ -944,9 +957,11 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t{\n \t  start_sequence ();\n \t  target = emit_conditional_add (if_info->x, code,\n-\t\t\t\t\t XEXP (cond, 0), XEXP (cond, 1),\n+\t\t\t\t\t XEXP (cond, 0),\n+\t\t\t\t\t XEXP (cond, 1),\n \t\t\t\t\t VOIDmode,\n-\t\t\t\t\t if_info->b, XEXP (if_info->a, 1),\n+\t\t\t\t\t if_info->b,\n+\t\t\t\t\t XEXP (if_info->a, 1),\n \t\t\t\t\t GET_MODE (if_info->x),\n \t\t\t\t\t (code == LTU || code == GEU\n \t\t\t\t\t  || code == LEU || code == GTU));\n@@ -956,6 +971,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = get_insns ();\n+\t      unshare_ifcvt_sequence (if_info, seq);\n \t      end_sequence ();\n \t      emit_insn_before_setloc (seq, if_info->jump,\n \t\t\t\t      INSN_LOCATOR (if_info->insn_a));\n@@ -994,6 +1010,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = get_insns ();\n+\t      unshare_ifcvt_sequence (if_info, seq);\n \t      end_sequence ();\n \n \t      if (seq_contains_jump (seq))\n@@ -1037,7 +1054,8 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \t\t\t\t     reversep, -1);\n       if (target)\n         target = expand_simple_binop (GET_MODE (if_info->x), AND,\n-\t\t\t\t      if_info->x, target, if_info->x, 0,\n+\t\t\t\t      if_info->x,\n+\t\t\t\t      target, if_info->x, 0,\n \t\t\t\t      OPTAB_WIDEN);\n \n       if (target)\n@@ -1046,6 +1064,7 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = get_insns ();\n+\t  unshare_ifcvt_sequence (if_info, seq);\n \t  end_sequence ();\n \n \t  if (seq_contains_jump (seq))\n@@ -1143,6 +1162,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = get_insns ();\n+\t  unshare_ifcvt_sequence (if_info, seq);\n \t  end_sequence ();\n \t  emit_insn_before_setloc (seq, if_info->jump,\n \t\t\t\t  INSN_LOCATOR (if_info->insn_a));\n@@ -1260,7 +1280,9 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       if (is_mem)\n \t{\n           tmp = gen_reg_rtx (GET_MODE (b));\n-\t  tmp = emit_insn (gen_rtx_SET (VOIDmode, tmp, b));\n+\t  tmp = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  \ttmp,\n+\t\t\t\t\tb));\n \t}\n       else if (! insn_b)\n \tgoto end_seq_and_fail;\n@@ -1305,6 +1327,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     noce_emit_move_insn (x, target);\n \n   tmp = get_insns ();\n+  unshare_ifcvt_sequence (if_info, tmp);\n   end_sequence ();\n   emit_insn_before_setloc (tmp, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n   return TRUE;\n@@ -1550,6 +1573,7 @@ noce_try_minmax (struct noce_if_info *if_info)\n     noce_emit_move_insn (if_info->x, target);\n \n   seq = get_insns ();\n+  unshare_ifcvt_sequence (if_info, seq);\n   end_sequence ();\n \n   if (seq_contains_jump (seq))\n@@ -1667,6 +1691,7 @@ noce_try_abs (struct noce_if_info *if_info)\n     noce_emit_move_insn (if_info->x, target);\n \n   seq = get_insns ();\n+  unshare_ifcvt_sequence (if_info, seq);\n   end_sequence ();\n \n   if (seq_contains_jump (seq))\n@@ -1988,8 +2013,10 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   if (orig_x != x)\n     {\n       start_sequence ();\n-      noce_emit_move_insn (copy_rtx (orig_x), x);\n+      noce_emit_move_insn (orig_x, x);\n       insn_b = get_insns ();\n+      set_used_flags (orig_x);\n+      unshare_all_rtl_in_chain (insn_b);\n       end_sequence ();\n \n       emit_insn_after_setloc (insn_b, test_bb->end, INSN_LOCATOR (insn_a));\n@@ -2585,7 +2612,8 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     }\n \n   /* Attempt to generate the conditional trap.  */\n-  seq = gen_cond_trap (code, XEXP (cond, 0), XEXP (cond, 1),\n+  seq = gen_cond_trap (code, XEXP (cond, 0),\n+\t\t       XEXP (cond, 1),\n \t\t       TRAP_CODE (PATTERN (trap)));\n   if (seq == NULL)\n     return FALSE;"}, {"sha": "44fd9652025a7d03b03c0d6c3e8a2ed3fde6fb21", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c07f13b2bccf42a860e5d3634e77fb6a264fa54/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2c07f13b2bccf42a860e5d3634e77fb6a264fa54", "patch": "@@ -2036,6 +2036,7 @@ extern void delete_insns_since (rtx);\n extern void mark_reg_pointer (rtx, int);\n extern void mark_user_reg (rtx);\n extern void reset_used_flags (rtx);\n+extern void set_used_flags (rtx);\n extern void reorder_insns (rtx, rtx, rtx);\n extern void reorder_insns_nobb (rtx, rtx, rtx);\n extern int get_max_uid (void);\n@@ -2051,6 +2052,8 @@ extern void set_new_first_and_last_insn (rtx, rtx);\n extern void set_new_first_and_last_label_num (int, int);\n extern void set_new_last_label_num (int);\n extern void unshare_all_rtl_again (rtx);\n+extern void unshare_all_rtl_in_chain (rtx);\n+extern void verify_rtl_sharing (void);\n extern void set_first_insn (rtx);\n extern void set_last_insn (rtx);\n extern void link_cc0_insns (rtx);"}]}