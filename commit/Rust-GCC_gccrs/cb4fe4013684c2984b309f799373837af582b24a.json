{"sha": "cb4fe4013684c2984b309f799373837af582b24a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0ZmU0MDEzNjg0YzI5ODRiMzA5Zjc5OTM3MzgzN2FmNTgyYjI0YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-26T14:18:26Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-26T14:18:26Z"}, "message": "re PR middle-end/80815 (wrong code because of broken runtime alias check in vectorizer)\n\n\tPR tree-optimization/80815\n\t* tree-data-ref.c (prune_runtime_alias_test_list): Simplify condition\n\tfor merging runtime alias checks.  Handle negative DR_STEPs.\n\tgcc/testsuite\n\t* gcc.dg/vect/pr80815-1.c: New test.\n\t* gcc.dg/vect/pr80815-2.c: New test.\n\nFrom-SVN: r248512", "tree": {"sha": "3a080810552bd1f2e2137d825f6c70a399518d5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a080810552bd1f2e2137d825f6c70a399518d5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4fe4013684c2984b309f799373837af582b24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4fe4013684c2984b309f799373837af582b24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4fe4013684c2984b309f799373837af582b24a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4fe4013684c2984b309f799373837af582b24a/comments", "author": null, "committer": null, "parents": [{"sha": "8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d44cf7275527abc86f33e6d6c51fc84fa9c877a"}], "stats": {"total": 239, "additions": 194, "deletions": 45}, "files": [{"sha": "14cde6af201c3edb98a82ed997b2a77658f1be55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4fe4013684c2984b309f799373837af582b24a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4fe4013684c2984b309f799373837af582b24a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb4fe4013684c2984b309f799373837af582b24a", "patch": "@@ -1,3 +1,9 @@\n+2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/80815\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): Simplify condition\n+\tfor merging runtime alias checks.  Handle negative DR_STEPs.\n+\n 2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-data-refs.c (Operator==, comp_dr_with_seg_len_pair):"}, {"sha": "5136e4ab6a51160306399a49edc2be427b6e6f6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb4fe4013684c2984b309f799373837af582b24a", "patch": "@@ -1,3 +1,9 @@\n+2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/80815\n+\t* gcc.dg/vect/pr80815-1.c: New test.\n+\t* gcc.dg/vect/pr80815-2.c: New test.\n+\n 2017-05-26  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/80663"}, {"sha": "98c06c0bb035deed556df88895a94380bdf95481", "filename": "gcc/testsuite/gcc.dg/vect/pr80815-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-1.c?ref=cb4fe4013684c2984b309f799373837af582b24a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+int arr[2048];\n+\n+__attribute__ ((noinline)) int\n+foo (int *a, int *b)\n+{\n+  int i;\n+  int *a1 = a;\n+  int *a0 = a1 - 512;\n+  for (i = 0; i < 500; i++)\n+    {\n+      *b = *a0 + *a1;\n+      b++;\n+      a0--;\n+      a1--;\n+    }\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int *a = &arr[1027];\n+  int *b = &arr[1024];\n+\n+  int i;\n+  for (i = 0; i < 2048; i++)\n+    arr[i] = i;\n+\n+  foo (a, b);\n+\n+  if (arr[1026] != 2053 || arr[1027] != 2054)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "83557daa6963632ccf2cf0a641a4106b4dc833f5", "filename": "gcc/testsuite/gcc.dg/vect/pr80815-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80815-2.c?ref=cb4fe4013684c2984b309f799373837af582b24a", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+int arr[2048];\n+int res[100] = { 13198, 13224, 12735, 12760, 12270, 12294,\n+\t\t 11803, 11826, 11334, 11356, 10863, 10884,\n+\t\t 10390, 10410, 9915, 9934, 9438, 9456,\n+\t\t 8959, 8976, 8478, 8494, 7995, 8010,\n+\t\t 7510, 7524, 7023, 7036, 6534, 6546,\n+\t\t 6043, 6054, 5550, 5560, 5055, 5064,\n+\t\t 4558, 4566, 4059, 4066, 3558, 3564,\n+\t\t 3055, 3060, 2550, 2554, 2043, 0};\n+\n+__attribute__ ((noinline)) int\n+foo (int *a, int *b)\n+{\n+  int i;\n+  int *a1 = a;\n+  int *a0 = a1 - 512;\n+  for (i = 0; i < 50; i++)\n+    {\n+      *b = *a0 + *a1;\n+      b--;\n+      a0--;\n+      a1--;\n+    }\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int *a = &arr[1024];\n+  int *b = &arr[1022];\n+\n+  int i;\n+  for (i = 0; i < 2048; i++)\n+    arr[i] = i;\n+\n+  foo (a, b);\n+\n+  for (i = 973; i < 1020; i++)\n+    if (arr[i] != res[i - 973])\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "cfff7c2a45c00a5d24fd9f330452b7988a08d2b9", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 98, "deletions": 45, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4fe4013684c2984b309f799373837af582b24a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=cb4fe4013684c2984b309f799373837af582b24a", "patch": "@@ -1340,63 +1340,115 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      != tree_int_cst_compare (DR_STEP (dr_a2->dr), size_zero_node))\n \t    continue;\n \n+\t  bool neg_step\n+\t    = (tree_int_cst_compare (DR_STEP (dr_a1->dr), size_zero_node) < 0);\n+\n+\t  /* We need to compute merged segment length at compilation time for\n+\t     dr_a1 and dr_a2, which is impossible if either one has non-const\n+\t     segment length.  */\n+\t  if ((!tree_fits_uhwi_p (dr_a1->seg_len)\n+\t       || !tree_fits_uhwi_p (dr_a2->seg_len))\n+\t      && tree_int_cst_compare (DR_STEP (dr_a1->dr),\n+\t\t\t\t       DR_STEP (dr_a2->dr)) != 0)\n+\t    continue;\n+\n \t  /* Make sure dr_a1 starts left of dr_a2.  */\n \t  if (tree_int_cst_lt (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr)))\n \t    std::swap (*dr_a1, *dr_a2);\n \n \t  bool do_remove = false;\n-\t  unsigned HOST_WIDE_INT diff\n-\t    = (tree_to_shwi (DR_INIT (dr_a2->dr))\n-               - tree_to_shwi (DR_INIT (dr_a1->dr)));\n-\n-\t  /* If the left segment does not extend beyond the start of the\n-\t     right segment the new segment length is that of the right\n-\t     plus the segment distance.  */\n-\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t      && compare_tree_int (dr_a1->seg_len, diff) <= 0)\n-\t    {\n-\t      dr_a1->seg_len = size_binop (PLUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t\t   size_int (diff));\n-\t      do_remove = true;\n-\t    }\n-\t  /* Generally the new segment length is the maximum of the\n-\t     left segment size and the right segment size plus the distance.\n-\t     ???  We can also build tree MAX_EXPR here but it's not clear this\n-\t     is profitable.  */\n-\t  else if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t   && tree_fits_uhwi_p (dr_a2->seg_len))\n+\t  wide_int diff = wi::sub (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr));\n+\t  wide_int min_seg_len_b;\n+\t  tree new_seg_len;\n+\n+\t  if (tree_fits_uhwi_p (dr_b1->seg_len))\n \t    {\n-\t      unsigned HOST_WIDE_INT seg_len_a1 = tree_to_uhwi (dr_a1->seg_len);\n-\t      unsigned HOST_WIDE_INT seg_len_a2 = tree_to_uhwi (dr_a2->seg_len);\n-\t      dr_a1->seg_len = size_int (MAX (seg_len_a1, diff + seg_len_a2));\n-\t      do_remove = true;\n+\t      min_seg_len_b = dr_b1->seg_len;\n+\t      if (tree_int_cst_sign_bit (dr_b1->seg_len))\n+\t\tmin_seg_len_b = wi::neg (min_seg_len_b);\n \t    }\n-\t  /* Now we check if the following condition is satisfied:\n+\t  else\n+\t    min_seg_len_b = wi::uhwi (factor, TYPE_PRECISION (sizetype));\n+\n+\t  /* Now we try to merge alias check dr_a1 & dr_b and dr_a2 & dr_b.\n+\n+\t     Case A:\n+\t       check if the following condition is satisfied:\n+\n+\t       DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n+\n+\t       where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n+\t       SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n+\t       have to make a best estimation.  We can get the minimum value\n+\t       of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n+\t       then either of the following two conditions can guarantee the\n+\t       one above:\n+\n+\t       1: DIFF <= MIN_SEG_LEN_B\n+\t       2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B\n+\t\t  Because DIFF - SEGMENT_LENGTH_A is done in sizetype, we need\n+\t\t  to take care of wrapping behavior in it.\n \n-\t     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n+\t     Case B:\n+\t       If the left segment does not extend beyond the start of the\n+\t       right segment the new segment length is that of the right\n+\t       plus the segment distance.  The condition is like:\n \n-\t     where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n-\t     SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n-\t     have to make a best estimation.  We can get the minimum value\n-\t     of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n-\t     then either of the following two conditions can guarantee the\n-\t     one above:\n+\t       DIFF >= SEGMENT_LENGTH_A   ;SEGMENT_LENGTH_A is a constant.\n \n-\t     1: DIFF <= MIN_SEG_LEN_B\n-\t     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B  */\n+\t     Note 1: Case A.2 and B combined together effectively merges every\n+\t     dr_a1 & dr_b and dr_a2 & dr_b when SEGMENT_LENGTH_A is const.\n+\n+\t     Note 2: Above description is based on positive DR_STEP, we need to\n+\t     take care of negative DR_STEP for wrapping behavior.  See PR80815\n+\t     for more information.  */\n+\t  if (neg_step)\n+\t    {\n+\t      /* Adjust diff according to access size of both references.  */\n+\t      tree size_a1 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a1->dr)));\n+\t      tree size_a2 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a2->dr)));\n+\t      diff = wi::add (diff, wi::sub (size_a2, size_a1));\n+\t      /* Case A.1.  */\n+\t      if (wi::leu_p (diff, min_seg_len_b)\n+\t\t  /* Case A.2 and B combined.  */\n+\t\t  || (tree_fits_uhwi_p (dr_a2->seg_len)))\n+\t\t{\n+\t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n+\t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n+\t\t    new_seg_len\n+\t\t      = wide_int_to_tree (sizetype,\n+\t\t\t\t\t  wi::umin (wi::sub (dr_a1->seg_len,\n+\t\t\t\t\t\t\t     diff),\n+\t\t\t\t\t\t    dr_a2->seg_len));\n+\t\t  else\n+\t\t    new_seg_len\n+\t\t      = size_binop (MINUS_EXPR, dr_a2->seg_len,\n+\t\t\t\t    wide_int_to_tree (sizetype, diff));\n+\n+\t\t  dr_a2->seg_len = new_seg_len;\n+\t\t  do_remove = true;\n+\t\t}\n+\t    }\n \t  else\n \t    {\n-\t      unsigned HOST_WIDE_INT min_seg_len_b\n-\t\t= (tree_fits_uhwi_p (dr_b1->seg_len)\n-\t\t   ? tree_to_uhwi (dr_b1->seg_len)\n-\t\t   : factor);\n-\n-\t      if (diff <= min_seg_len_b\n-\t\t  || (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t      && diff - tree_to_uhwi (dr_a1->seg_len) < min_seg_len_b))\n+\t      /* Case A.1.  */\n+\t      if (wi::leu_p (diff, min_seg_len_b)\n+\t\t  /* Case A.2 and B combined.  */\n+\t\t  || (tree_fits_uhwi_p (dr_a1->seg_len)))\n \t\t{\n-\t\t  dr_a1->seg_len = size_binop (PLUS_EXPR,\n-\t\t\t\t\t       dr_a2->seg_len, size_int (diff));\n+\t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n+\t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n+\t\t    new_seg_len\n+\t\t      = wide_int_to_tree (sizetype,\n+\t\t\t\t\t  wi::umax (wi::add (dr_a2->seg_len,\n+\t\t\t\t\t\t\t     diff),\n+\t\t\t\t\t\t    dr_a1->seg_len));\n+\t\t  else\n+\t\t    new_seg_len\n+\t\t      = size_binop (PLUS_EXPR, dr_a2->seg_len,\n+\t\t\t\t    wide_int_to_tree (sizetype, diff));\n+\n+\t\t  dr_a1->seg_len = new_seg_len;\n \t\t  do_remove = true;\n \t\t}\n \t    }\n@@ -1415,7 +1467,8 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n \t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n-\t      alias_pairs->ordered_remove (i--);\n+\t      alias_pairs->ordered_remove (neg_step ? i - 1 : i);\n+\t      i--;\n \t    }\n \t}\n     }"}]}