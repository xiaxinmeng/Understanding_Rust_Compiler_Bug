{"sha": "ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIxODRiMmE4ZmVkNTFkYTVhYmM4YWYwMWEzMjU4YjkwOTBmNGFhZg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2006-02-03T11:56:58Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2006-02-03T11:56:58Z"}, "message": "java-gimplify.c: Use gcc_assert and gcc_unreachable throughout.\n\n\t* java-gimplify.c: Use gcc_assert and gcc_unreachable throughout.\n\t* typeck.c: Likewise.\n\t* verify-impl.c: Likewise.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* jcf-parse.c: Likewise.\n\t* constants.c: Likewise.\n\t* check-init.c: Likewise.\n\t* jcf-write.c: Likewise.\n\t* verify-glue.c: Likewise.\n\t* mangle.c: Likewise.\n\t* expr.c: Likewise.\n\t* lang.c: Likewise.\n\t* boehm.c: Likewise.\n\nFrom-SVN: r110541", "tree": {"sha": "40ce1ffcebc96077b6c41500950d3961b6d3e03e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40ce1ffcebc96077b6c41500950d3961b6d3e03e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/comments", "author": null, "committer": null, "parents": [{"sha": "4a6c754b7a63dc27eda74622783b059029f85eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a6c754b7a63dc27eda74622783b059029f85eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a6c754b7a63dc27eda74622783b059029f85eb3"}], "stats": {"total": 274, "additions": 116, "deletions": 158}, "files": [{"sha": "95b380797a3f86102ef02b55463053bf35a76f39", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -1,3 +1,20 @@\n+2006-02-03  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* java-gimplify.c: Use gcc_assert and gcc_unreachable throughout.\n+\t* typeck.c: Likewise.\n+\t* verify-impl.c: Likewise.\n+\t* class.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* jcf-parse.c: Likewise.\n+\t* constants.c: Likewise.\n+\t* check-init.c: Likewise.\n+\t* jcf-write.c: Likewise.\n+\t* verify-glue.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* lang.c: Likewise.\n+\t* boehm.c: Likewise.\n+\n 2006-02-01  Jan Hubicka  <jh@suse.cz>\n \n \t* decl.c (end_java_method): Kill hack disabling unit-at-a-time."}, {"sha": "1bfe9e5f0e404f56b3ce3e10e7047446632f8548", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -101,8 +101,7 @@ mark_reference_fields (tree field,\n \n \t  /* If this reference slot appears to overlay a slot we think\n \t     we already covered, then we are doomed.  */\n-\t  if (offset <= *last_view_index)\n-\t    abort ();\n+\t  gcc_assert (offset > *last_view_index);\n \n \t  count = offset * BITS_PER_UNIT / POINTER_SIZE;\n \t  size_words = size_bytes * BITS_PER_UNIT / POINTER_SIZE;"}, {"sha": "312bd7becd9ff140c10beca46925011496f221f9", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -672,8 +672,7 @@ check_init (tree exp, words before)\n \tDECLARE_BUFFERS(when_true, 2);\n \twords when_false = when_true + num_current_words;\n #ifdef ENABLE_JC1_CHECKING\n-\tif (TREE_CODE (alt->block) != LOOP_EXPR)\n-\t  abort ();\n+\tgcc_assert (TREE_CODE (alt->block) == LOOP_EXPR);\n #endif\n \tcheck_bool_init (TREE_OPERAND (exp, 0), before, when_false, when_true);\n \tdone_alternative (when_true, alt);"}, {"sha": "e3eed98334589e520f7e3341acaf24bae3a053b7", "filename": "gcc/java/class.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -1014,7 +1014,7 @@ build_class_ref (tree type)\n \t      else if (type == void_type_node)\n                 prim_class_name = \"java.lang.Void\";\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \n \t      prim_class = lookup_class (get_identifier (prim_class_name));\n \t      /* We wrap the class in a NOP_EXPR, because it is a\n@@ -1207,7 +1207,7 @@ get_access_flags_from_decl (tree decl)\n \taccess_flags |= ACC_INVISIBLE;\n       return access_flags;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n static GTY (()) int alias_labelno = 0;\n@@ -2313,8 +2313,7 @@ get_interface_method_index (tree method, tree interface)\n     {\n       if (meth == method)\n \treturn i;\n-      if (meth == NULL_TREE)\n-\tabort ();\n+      gcc_assert (meth != NULL_TREE);\n     }\n }\n "}, {"sha": "98a05043e47b5b011e9b729cad693cc60f85ec5e", "filename": "gcc/java/constants.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -313,8 +313,7 @@ write_constant_pool (CPool *cpool, unsigned char *buffer, int length)\n \t}\n     }\n \n-  if (ptr != buffer + length)\n-    abort ();\n+  gcc_assert (ptr == buffer + length);\n }\n \n static GTY(()) tree tag_nodes[13];"}, {"sha": "fd5785944528b4cc6b1c53691493c899b01423e3", "filename": "gcc/java/decl.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -163,8 +163,7 @@ update_aliases (tree decl, int index, int pc)\n   tree decl_type = TREE_TYPE (decl);\n   tree tmp;\n \n-  if (debug_variable_p (decl))\n-    abort ();\n+  gcc_assert (! debug_variable_p (decl));\n \n   for (tmp = TREE_VEC_ELT (decl_map, index); \n        tmp != NULL_TREE; \n@@ -188,8 +187,7 @@ update_aliases (tree decl, int index, int pc)\n \t\t  && TREE_CODE (decl_type) == POINTER_TYPE)))\n \t{\n \t  tree src = build1 (NOP_EXPR, tmp_type, decl);\n-\t  if (LOCAL_VAR_OUT_OF_SCOPE_P (tmp))\n-\t    abort ();\n+\t  gcc_assert (! LOCAL_VAR_OUT_OF_SCOPE_P (tmp));\n \t  java_add_stmt (build2 (MODIFY_EXPR, tmp_type, tmp, src));\n \t}\n     }\n@@ -269,8 +267,7 @@ check_local_unnamed_variable (tree best, tree decl, tree type)\n {\n   tree decl_type = TREE_TYPE (decl);\n   \n-  if (LOCAL_VAR_OUT_OF_SCOPE_P (decl))\n-    abort ();\n+  gcc_assert (! LOCAL_VAR_OUT_OF_SCOPE_P (decl));\n \n   /* Use the same decl for all integer types <= 32 bits.  This is\n      necessary because sometimes a value is stored as (for example)\n@@ -411,9 +408,7 @@ java_replace_reference (tree var_decl, bool want_lvalue)\n \t  int index = DECL_LOCAL_SLOT_NUMBER (var_decl);\n \t  tree base_decl = TREE_VEC_ELT (base_decl_map, index); \n \n-\t  if (! base_decl)\n-\t    abort ();\n-\n+\t  gcc_assert (base_decl);\n \t  if (! want_lvalue)\n \t    base_decl = build1 (NOP_EXPR, decl_type, base_decl);\n \n@@ -2010,8 +2005,7 @@ start_java_method (tree fndecl)\n     {\n       tree parm_name = NULL_TREE, parm_decl;\n       tree parm_type = TREE_VALUE (tem);\n-      if (i >= DECL_MAX_LOCALS (fndecl))\n-\tabort ();\n+      gcc_assert (i < DECL_MAX_LOCALS (fndecl));\n \n       parm_decl = build_decl (PARM_DECL, parm_name, parm_type);\n       DECL_CONTEXT (parm_decl) = fndecl;\n@@ -2277,8 +2271,7 @@ get_stmts (void)\n void\n register_exception_range (struct eh_range *range, int pc, int end_pc)\n {\n-  if (current_binding_level->exception_range)\n-    abort ();\n+  gcc_assert (! current_binding_level->exception_range);\n   current_binding_level->exception_range = range;\n   current_binding_level->end_pc = end_pc;\n   current_binding_level->start_pc = pc;      "}, {"sha": "c28f6b253359b6a48c9fe2c4d2fd03fee5a9835a", "filename": "gcc/java/expr.c", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -273,8 +273,7 @@ push_type_0 (tree type)\n void\n push_type (tree type)\n {\n-  if (! push_type_0 (type))\n-    abort ();\n+  gcc_assert (push_type_0 (type));\n }\n \n static void\n@@ -606,15 +605,13 @@ java_stack_pop (int count)\n     {\n       tree type, val;\n \n-      if (stack_pointer == 0)\n-\tabort ();\n+      gcc_assert (stack_pointer != 0);\n \n       type = stack_type_map[stack_pointer - 1];\n       if (type == TYPE_SECOND)\n \t{\n \t  count--;\n-\t  if (stack_pointer == 1 || count <= 0)\n-\t    abort ();\n+\t  gcc_assert (stack_pointer != 1 && count > 0);\n \n \t  type = stack_type_map[stack_pointer - 2];\n \t}\n@@ -632,13 +629,12 @@ java_stack_swap (void)\n   tree temp;\n   tree decl1, decl2;\n \n-  if (stack_pointer < 2\n-      || (type1 = stack_type_map[stack_pointer - 1]) == TYPE_UNKNOWN\n-      || (type2 = stack_type_map[stack_pointer - 2]) == TYPE_UNKNOWN\n-      || type1 == TYPE_SECOND || type2 == TYPE_SECOND\n-      || TYPE_IS_WIDE (type1) || TYPE_IS_WIDE (type2))\n-    /* Bad stack swap.  */\n-    abort ();\n+  /* Bad stack swap.  */\n+  gcc_assert (stack_pointer >= 2\n+\t      && (type1 = stack_type_map[stack_pointer - 1]) != TYPE_UNKNOWN\n+\t      && (type2 = stack_type_map[stack_pointer - 2]) != TYPE_UNKNOWN\n+\t      && (type1 != TYPE_SECOND && type2 != TYPE_SECOND)\n+\t      && (! TYPE_IS_WIDE (type1) && ! TYPE_IS_WIDE (type2)));\n \n   flush_quick_stack ();\n   decl1 = find_stack_slot (stack_pointer - 1, type1);\n@@ -678,18 +674,16 @@ java_stack_dup (int size, int offset)\n       type = stack_type_map [src_index];\n       if (type == TYPE_SECOND)\n \t{\n-\t  if (src_index <= low_index)\n-\t    /* Dup operation splits 64-bit number.  */\n-\t    abort ();\n+\t  /* Dup operation splits 64-bit number.  */\n+\t  gcc_assert (src_index > low_index);\n \n \t  stack_type_map[dst_index] = type;\n \t  src_index--;  dst_index--;\n \t  type = stack_type_map[src_index];\n-\t  if (! TYPE_IS_WIDE (type))\n-\t    abort ();\n+\t  gcc_assert (TYPE_IS_WIDE (type));\n \t}\n-      else if (TYPE_IS_WIDE (type))\n-\tabort ();\n+      else\n+\tgcc_assert (! TYPE_IS_WIDE (type));\n \n       if (src_index != dst_index)\n \t{\n@@ -785,7 +779,7 @@ encode_newarray_type (tree type)\n   else if (type == long_type_node)\n     return 11;\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n /* Build a call to _Jv_ThrowBadArrayIndex(), the\n@@ -942,17 +936,15 @@ build_java_arraystore_check (tree array, tree object)\n     }\n   else\n     {\n-      if (! is_array_type_p (array_type_p))\n-\tabort ();\n+      gcc_assert (is_array_type_p (array_type_p));\n \n       /* Get the TYPE_DECL for ARRAY's element type. */\n       element_type\n \t= TYPE_NAME (TREE_TYPE (TREE_TYPE (TREE_TYPE (array_type_p))));\n     }\n \n-  if (TREE_CODE (element_type) != TYPE_DECL   \n-      || TREE_CODE (object_type) != TYPE_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (element_type) == TYPE_DECL\n+\t      && TREE_CODE (object_type) == TYPE_DECL);\n \n   if (!flag_store_check)\n     return build1 (NOP_EXPR, array_type_p, array);\n@@ -1235,7 +1227,7 @@ expand_java_pushc (int ival, tree type)\n       value = build_real (type, x);\n     }\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   push_value (value);\n }\n@@ -1492,9 +1484,7 @@ build_java_soft_divmod (enum tree_code op, tree type, tree op1, tree op2)\n \t}\n     }\n \n-  if (! call)\n-    abort ();\n-\t\t  \n+  gcc_assert (call);\n   call = build3 (CALL_EXPR, type,\n \t\t build_address_of (call),\n \t\t tree_cons (NULL_TREE, arg1,\n@@ -1890,7 +1880,7 @@ pop_arguments (tree arg_types)\n \targ = convert (integer_type_node, arg);\n       return tree_cons (NULL_TREE, arg, tail);\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Attach to PTR (a block) the declaration found in ENTRY. */\n@@ -2151,8 +2141,7 @@ build_invokevirtual (tree dtable, tree method)\n \n   if (flag_indirect_dispatch)\n     {\n-      if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n-\tabort ();\n+      gcc_assert (! CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))));\n \n       otable_index \n \t= build_int_cst (NULL_TREE, get_symbol_table_index \n@@ -2205,8 +2194,7 @@ build_invokeinterface (tree dtable, tree method)\n \t\t   lookup_field (&dtable_type, class_ident), NULL_TREE);\n \n   interface = DECL_CONTEXT (method);\n-  if (! CLASS_INTERFACE (TYPE_NAME (interface)))\n-    abort ();\n+  gcc_assert (CLASS_INTERFACE (TYPE_NAME (interface)));\n   layout_class_methods (interface);\n   \n   if (flag_indirect_dispatch)\n@@ -2447,8 +2435,7 @@ build_jni_stub (tree method)\n   int from_class = ! CLASS_FROM_SOURCE_P (klass);\n   klass = build_class_ref (klass);\n \n-  if (! METHOD_NATIVE (method) || ! flag_jni)\n-    abort ();\n+  gcc_assert (METHOD_NATIVE (method) && flag_jni);\n \n   DECL_ARTIFICIAL (method) = 1;\n   DECL_EXTERNAL (method) = 0;\n@@ -2602,8 +2589,7 @@ build_jni_stub (tree method)\n   if (res_var != NULL_TREE)\n     {\n       tree drt;\n-      if (! DECL_RESULT (method))\n-\tabort ();\n+      gcc_assert (DECL_RESULT (method));\n       /* Make sure we copy the result variable to the actual\n \t result.  We use the type of the DECL_RESULT because it\n \t might be different from the return type of the function:\n@@ -3482,8 +3468,7 @@ force_evaluation_order (tree node)\n \treturn node;\n \n       /* Not having a list of arguments here is an error. */ \n-      if (TREE_CODE (arg) != TREE_LIST)\n-        abort ();\n+      gcc_assert (TREE_CODE (arg) == TREE_LIST);\n \n       /* This reverses the evaluation order. This is a desired effect. */\n       for (cmp = NULL_TREE; arg; arg = TREE_CHAIN (arg))"}, {"sha": "f3f3cd97b8e1979b60b4a50c4a337c8f32dd3813", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -146,7 +146,7 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n     case CONDITIONAL_EXPR:\n     case INSTANCEOF_EXPR:\n     case CLASS_LITERAL:\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       /* Java insists on strict left-to-right evaluation of expressions."}, {"sha": "552c04ac94321a1a28c7e020f0b5a1c4b8e0fa92", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -120,7 +120,7 @@ handle_deprecated (void)\n   else\n     {\n       /* Shouldn't happen.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -285,12 +285,12 @@ set_source_filename (JCF *jcf, int index)\n tree\n parse_signature (JCF *jcf, int sig_index)\n {\n-  if (sig_index <= 0 || sig_index >= JPOOL_SIZE (jcf)\n-      || JPOOL_TAG (jcf, sig_index) != CONSTANT_Utf8)\n-    abort ();\n-  else\n-    return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n-\t\t\t\t   JPOOL_UTF_LENGTH (jcf, sig_index));\n+  gcc_assert (sig_index > 0\n+\t      && sig_index < JPOOL_SIZE (jcf)\n+\t      && JPOOL_TAG (jcf, sig_index) == CONSTANT_Utf8);\n+\n+  return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n+\t\t\t\t JPOOL_UTF_LENGTH (jcf, sig_index));\n }\n \n tree\n@@ -395,10 +395,7 @@ tree\n get_name_constant (JCF *jcf, int index)\n {\n   tree name = get_constant (jcf, index);\n-\n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n-    abort ();\n-\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   return name;\n }\n \n@@ -445,10 +442,10 @@ handle_innerclass_attribute (int count, JCF *jcf)\n static tree\n give_name_to_class (JCF *jcf, int i)\n {\n-  if (i <= 0 || i >= JPOOL_SIZE (jcf)\n-      || JPOOL_TAG (jcf, i) != CONSTANT_Class)\n-    abort ();\n-  else\n+  gcc_assert (i > 0\n+\t      && i < JPOOL_SIZE (jcf)\n+\t      && JPOOL_TAG (jcf, i) == CONSTANT_Class);\n+\n     {\n       tree package_name = NULL_TREE, tmp;\n       tree this_class;\n@@ -489,9 +486,9 @@ tree\n get_class_constant (JCF *jcf, int i)\n {\n   tree type;\n-  if (i <= 0 || i >= JPOOL_SIZE (jcf)\n-      || (JPOOL_TAG (jcf, i) & ~CONSTANT_ResolvedFlag) != CONSTANT_Class)\n-    abort ();\n+  gcc_assert (i > 0\n+\t      && i < JPOOL_SIZE (jcf)\n+\t      && (JPOOL_TAG (jcf, i) & ~CONSTANT_ResolvedFlag) == CONSTANT_Class);\n \n   if (JPOOL_TAG (jcf, i) != CONSTANT_ResolvedClass)\n     {\n@@ -1421,12 +1418,9 @@ parse_zip_file_entries (void)\n \t    \n \t    CLASS_FROM_CURRENTLY_COMPILED_P (current_class) = 1;\n \n-\t    if (TYPE_DUMMY (class))\n-\t      {\n-\t\t/* This is a dummy class, and now we're compiling it\n-\t\t   for real.  */\n-\t\tabort ();\n-\t      }\n+\t    /* This is a dummy class, and now we're compiling it for\n+\t       real.  */\n+\t    gcc_assert (! TYPE_DUMMY (class));\n \n \t    /* This is for a corner case where we have a superclass\n \t       but no superclass fields.  \n@@ -1501,7 +1495,7 @@ parse_zip_file_entries (void)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }"}, {"sha": "c0901739350af6de70eaaba5e4b0c48cca22c692", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -80,7 +80,7 @@ const char *jcf_write_base_directory = NULL;\n /* Macro to call each time we pop I words from the JVM stack. */\n \n #define NOTE_POP(I) \\\n-  do { state->code_SP -= (I); if (state->code_SP < 0) abort(); } while (0)\n+  do { state->code_SP -= (I); gcc_assert (state->code_SP >= 0); } while (0)\n \n /* A chunk or segment of a .class file. */\n \n@@ -356,10 +356,8 @@ static int CHECK_PUT (void *, struct jcf_partial *, int);\n static int\n CHECK_PUT (void *ptr, struct jcf_partial *state, int i)\n {\n-  if ((unsigned char *) ptr < state->chunk->data\n-      || (unsigned char *) ptr + i > state->chunk->data + state->chunk->size)\n-    abort ();\n-\n+  gcc_assert ((unsigned char *) ptr >= state->chunk->data\n+\t      && (unsigned char *) ptr + i <= state->chunk->data + state->chunk->size);\n   return 0;\n }\n #else\n@@ -406,9 +404,7 @@ static int CHECK_OP (struct jcf_partial *);\n static int\n CHECK_OP (struct jcf_partial *state)\n {\n-  if (state->bytecode.ptr > state->bytecode.limit)\n-    abort ();\n-\n+  gcc_assert (state->bytecode.ptr <= state->bytecode.limit);\n   return 0;\n }\n #else\n@@ -609,15 +605,13 @@ maybe_free_localvar (tree decl, struct jcf_partial *state, int really)\n \n   info->end_label = end_label;\n \n-  if (info->decl != decl)\n-    abort ();\n+  gcc_assert (info->decl == decl);\n   if (! really)\n     return;\n   ptr[0] = NULL;\n   if (wide)\n     {\n-      if (ptr[1] !=  (struct localvar_info *)(~0))\n-\tabort ();\n+      gcc_assert (ptr[1] == (struct localvar_info *) (~0));\n       ptr[1] = NULL;\n     }\n }\n@@ -667,7 +661,7 @@ get_access_flags (tree decl)\n \tflags |= ACC_STRICT;\n     }\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -827,7 +821,7 @@ find_constant_index (tree value, struct jcf_partial *state)\n     return find_string_constant (&state->cpool, value);\n \n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n /* Push 64-bit long constant on VM stack.\n@@ -902,7 +896,7 @@ adjust_typed_op (tree type, int max)\n     default:\n       break;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n static void\n@@ -942,7 +936,7 @@ emit_dup (int size, int offset, struct jcf_partial *state)\n   else if (offset == 2)\n     kind = size == 1 ? OPCODE_dup_x2 : OPCODE_dup2_x2;\n   else\n-    abort();\n+    gcc_unreachable ();\n   OP1 (kind);\n   NOTE_PUSH (size);\n }\n@@ -1134,8 +1128,7 @@ generate_bytecode_conditional (tree exp,\n \tgenerate_bytecode_conditional (TREE_OPERAND (exp, 2),\n \t\t\t\t       true_label, false_label,\n \t\t\t\t       true_branch_first, state);\n-\tif (state->code_SP != save_SP_after)\n-\t  abort ();\n+\tgcc_assert (state->code_SP == save_SP_after);\n       }\n       break;\n     case TRUTH_NOT_EXPR:\n@@ -1243,7 +1236,8 @@ generate_bytecode_conditional (tree exp,\n \t    {\n \t    case EQ_EXPR:  op = OPCODE_if_acmpeq;  break;\n \t    case NE_EXPR:  op = OPCODE_if_acmpne;  break;\n-\t    default:  abort();\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n \t  if (integer_zerop (exp1) || integer_zerop (exp0))\n \t    {\n@@ -1333,8 +1327,7 @@ generate_bytecode_conditional (tree exp,\n \t}\n       break;\n     }\n-  if (save_SP != state->code_SP)\n-    abort ();\n+  gcc_assert (save_SP == state->code_SP);\n }\n \n /* Call pending cleanups i.e. those for surrounding TRY_FINALLY_EXPRs.\n@@ -1496,8 +1489,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       if (target == IGNORE_TARGET) ; /* do nothing */\n       else if (TREE_CODE (type) == POINTER_TYPE)\n \t{\n-\t  if (! integer_zerop (exp))\n-\t    abort();\n+\t  gcc_assert (integer_zerop (exp));\n \t  RESERVE(1);\n \t  OP1 (OPCODE_aconst_null);\n \t  NOTE_PUSH (1);\n@@ -1834,7 +1826,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       if (exp == NULL_TREE)\n \texp = build_java_empty_stmt ();\n       else if (TREE_CODE (exp) != MODIFY_EXPR) \n-\tabort ();\n+\tgcc_unreachable ();\n       else\n \texp = TREE_OPERAND (exp, 1);\n       generate_bytecode_return (exp, state);\n@@ -1848,8 +1840,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \tend_label->u.labeled_block = exp;\n \tif (LABELED_BLOCK_BODY (exp))\n \t  generate_bytecode_insns (LABELED_BLOCK_BODY (exp), target, state);\n-\tif (state->labeled_blocks != end_label)\n-\t  abort();\n+\tgcc_assert (state->labeled_blocks == end_label);\n \tstate->labeled_blocks = end_label->next;\n \tdefine_jcf_label (end_label, state);\n       }\n@@ -1957,7 +1948,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t  offset = 0;\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       if (target != IGNORE_TARGET && post_op)\n \temit_dup (size, offset, state);\n@@ -2081,7 +2072,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t\tNOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (lhs)) ? 2 : 1);\n \t      }\n \t    else\n-\t      abort ();\n+\t      gcc_unreachable ();\n \n \t    /* This function correctly handles the case where the LHS\n \t       of a binary expression is NULL_TREE.  */\n@@ -2127,7 +2118,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 4 : 3);\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       break;\n     case PLUS_EXPR:\n       jopcode = OPCODE_iadd;\n@@ -2313,8 +2304,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \tstruct jcf_block *end_label;  /* End of try clause. */\n \tstruct jcf_block *finished_label = gen_jcf_label (state);\n \ttree clause = TREE_OPERAND (exp, 1);\n-\tif (target != IGNORE_TARGET)\n-\t  abort ();\n+\tgcc_assert (target == IGNORE_TARGET);\n \tgenerate_bytecode_insns (try_clause, IGNORE_TARGET, state);\n \tend_label = get_jcf_label_here (state);\n \tif (end_label == start_label)\n@@ -2369,8 +2359,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \n \tif (CAN_COMPLETE_NORMALLY (finally))\n \t  {\n-\t    if (state->labeled_blocks != finally_label)\n-\t      abort();\n+\t    gcc_assert (state->labeled_blocks == finally_label);\n \t    state->labeled_blocks = finally_label->next;\n \t  }\n \tend_label = get_jcf_label_here (state);\n@@ -2517,8 +2506,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \ttree op0 = TREE_OPERAND (exp, 0);\n \ttree op1 = TREE_OPERAND (exp, 1);\n \ttree x;\n-\tif (TREE_SIDE_EFFECTS (op0) || TREE_SIDE_EFFECTS (op1))\n-\t  abort ();\n+\tgcc_assert (! TREE_SIDE_EFFECTS (op0) && ! TREE_SIDE_EFFECTS (op1));\n \tx = build3 (COND_EXPR, TREE_TYPE (exp), \n \t\t    build2 (code, boolean_type_node, op0, op1), \n \t\t    op0, op1);\t  \n@@ -2645,9 +2633,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t    OP2 (index);\n \t    if (interface)\n \t      {\n-\t\tif (nargs <= 0)\n-\t\t  abort ();\n-\n+\t\tgcc_assert (nargs > 0);\n \t\tOP1 (nargs);\n \t\tOP1 (0);\n \t      }\n@@ -2863,8 +2849,7 @@ perform_relocations (struct jcf_partial *state)\n \t      *--new_ptr = - reloc->kind;\n \t    }\n \t}\n-      if (new_ptr != chunk->data)\n-\tabort ();\n+      gcc_assert (new_ptr == chunk->data);\n     }\n   state->code_length = pc;\n }\n@@ -3125,8 +3110,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t  generate_bytecode_insns (body, IGNORE_TARGET, state);\n \t  if (CAN_COMPLETE_NORMALLY (body))\n \t    {\n-\t      if (TREE_CODE (TREE_TYPE (type)) != VOID_TYPE)\n-\t\tabort();\n+\t      gcc_assert (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE);\n \t      RESERVE (1);\n \t      OP1 (OPCODE_return);\n \t    }"}, {"sha": "5f9a3701fdc4c4842375346744992b2a632f0063", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -335,7 +335,7 @@ java_handle_option (size_t scode, const char *arg, int value)\n     default:\n       if (cl_options[code].flags & CL_Java)\n \tbreak;\n-      abort();\n+      gcc_unreachable ();\n     }\n \n   return 1;\n@@ -781,8 +781,7 @@ merge_init_test_initialization (void **entry, void *x)\n   /* See if we have remapped this declaration.  If we haven't there's\n      a bug in the inliner.  */\n   n = splay_tree_lookup (decl_map, (splay_tree_key) ite->value);\n-  if (! n)\n-    abort ();\n+  gcc_assert (n);\n \n   /* Create a new entry for the class and its remapped boolean\n      variable.  If we already have a mapping for this class we've"}, {"sha": "a1b7518b7595bca7f796d7de21dd8ded5f603198", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -280,7 +280,7 @@ mangle_type (tree type)\n       break;\n     bad_type:\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -397,8 +397,7 @@ mangle_record_type (tree type, int for_pointer)\n #define ADD_N() \\\n   do { obstack_1grow (mangle_obstack, 'N'); nadded_p = 1; } while (0)\n \n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n \n   if (!TYPE_PACKAGE_LIST (type))\n     set_type_package_list (type);\n@@ -450,8 +449,7 @@ mangle_pointer_type (tree type)\n   /* This didn't work. We start by mangling the pointed-to type */\n   pointer_type = type;\n   type = TREE_TYPE (type);\n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n   \n   obstack_1grow (mangle_obstack, 'P');\n   if (mangle_record_type (type, /* for_pointer = */ 1))\n@@ -473,8 +471,7 @@ mangle_array_type (tree p_type)\n   int match;\n \n   type = TREE_TYPE (p_type);\n-  if (!type)\n-    abort ();\n+  gcc_assert (type);\n \n   elt_type = TYPE_ARRAY_ELEMENT (type);\n "}, {"sha": "737ca189b384c0b0298ed4986a2284ba2565f9a1", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -55,8 +55,7 @@ set_local_type (int slot, tree type)\n   int max_locals = DECL_MAX_LOCALS(current_function_decl);\n   int nslots = TYPE_IS_WIDE (type) ? 2 : 1;\n \n-  if (slot < 0 || slot + nslots - 1 >= max_locals)\n-    abort ();\n+  gcc_assert (slot >= 0 && (slot + nslots - 1 < max_locals));\n \n   type_map[slot] = type;\n   while (--nslots > 0)\n@@ -458,9 +457,7 @@ static tree\n parse_signature_type (const unsigned char **ptr, const unsigned char *limit)\n {\n   tree type;\n-\n-  if (*ptr >= limit)\n-    abort ();\n+  gcc_assert (*ptr < limit);\n \n   switch (**ptr)\n     {\n@@ -484,8 +481,7 @@ parse_signature_type (const unsigned char **ptr, const unsigned char *limit)\n \tconst unsigned char *str = start;\n \tfor ( ; ; str++)\n \t  {\n-\t    if (str >= limit)\n-\t      abort ();\n+\t    gcc_assert (str < limit);\n \t    if (*str == ';')\n \t      break;\n \t  }\n@@ -494,7 +490,7 @@ parse_signature_type (const unsigned char **ptr, const unsigned char *limit)\n \tbreak;\n       }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return promote_type (type);\n }\n@@ -662,7 +658,7 @@ build_java_signature (tree type)\n \t  break;\n \tbad_type:\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       TYPE_SIGNATURE (type) = sig;\n     }"}, {"sha": "737a19bd77003749a3151559b4b93d637451b2a6", "filename": "gcc/java/verify-glue.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -252,8 +252,7 @@ char\n vfy_get_primitive_char (vfy_jclass klass)\n {\n   tree sig;\n-  if (! vfy_is_primitive (klass))\n-    abort ();\n+  gcc_assert (vfy_is_primitive (klass));\n   sig = build_java_signature (klass);\n   return (IDENTIFIER_POINTER (sig))[0];\n }\n@@ -296,8 +295,7 @@ vfy_jclass\n vfy_get_component_type (vfy_jclass klass)\n {\n   vfy_jclass k;\n-  if (! vfy_is_array (klass))\n-    abort ();\n+  gcc_assert (vfy_is_array (klass));\n   k = TYPE_ARRAY_ELEMENT (klass);\n   if (TREE_CODE (k) == POINTER_TYPE)\n     k = TREE_TYPE (k);"}, {"sha": "fc15407627964a38bf03238c4b9e3de1e3e478de", "filename": "gcc/java/verify-impl.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab184b2a8fed51da5abc8af01a3258b9090f4aaf/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "patch": "@@ -3178,7 +3178,7 @@ collapse_type (type *t)\n       return vfy_object_type ();\n     }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n static void\n@@ -3220,8 +3220,7 @@ verify_instructions (void)\n \t\t\t\t   vfy_unsuitable_type ());\n \t    }\n \t}\n-      if (slot != curr->stackdepth)\n-\tabort ();\n+      gcc_assert (slot == curr->stackdepth);\n     }\n }\n "}]}