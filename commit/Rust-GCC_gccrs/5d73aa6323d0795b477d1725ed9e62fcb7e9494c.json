{"sha": "5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3M2FhNjMyM2QwNzk1YjQ3N2QxNzI1ZWQ5ZTYyZmNiN2U5NDk0Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-13T00:35:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-13T00:35:00Z"}, "message": "call.c (implicit_conversion): Robustify.\n\n\t* call.c (implicit_conversion): Robustify.  Handle OFFSET_REFs.\n\t* cvt.c (ocp_convert): Complete the from and destination types.\n\tAdjust warning about functions always being `true' in conditionals.\n\t* decl.c (duplicate_decls): Don't play funny games with abort.\n\t* error.c (dump_expr): Handle OVERLOADs.\n\t* spew.c (probe_obstack): Remove.\n\t* typeck.c (condition_conversion): Use perform_implicit_conversion.\n\nFrom-SVN: r29366", "tree": {"sha": "02c8222c4007f0db7778c4e35531928c28745894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02c8222c4007f0db7778c4e35531928c28745894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/comments", "author": null, "committer": null, "parents": [{"sha": "b7cf61b5b30586189e2a63777a8e2e910cabde39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7cf61b5b30586189e2a63777a8e2e910cabde39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7cf61b5b30586189e2a63777a8e2e910cabde39"}], "stats": {"total": 103, "additions": 67, "deletions": 36}, "files": [{"sha": "9e953ed284c57faef9bd27923d68ecaa12912f8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -1,3 +1,13 @@\n+1999-09-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (implicit_conversion): Robustify.  Handle OFFSET_REFs.\n+\t* cvt.c (ocp_convert): Complete the from and destination types.\n+\tAdjust warning about functions always being `true' in conditionals.\n+\t* decl.c (duplicate_decls): Don't play funny games with abort.\n+\t* error.c (dump_expr): Handle OVERLOADs.\n+\t* spew.c (probe_obstack): Remove.\n+\t* typeck.c (condition_conversion): Use perform_implicit_conversion.\n+\t\n 1999-09-12  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cp-tree.h (auto_function, define_function): Adjust prototypes."}, {"sha": "12f4b9bc7e26251cde4729899a3f564011b8955b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -1151,6 +1151,20 @@ implicit_conversion (to, from, expr, flags)\n   tree conv;\n   struct z_candidate *cand;\n \n+  /* Resolve expressions like `A::p' that we thought might become\n+     pointers-to-members.  */\n+  if (expr && TREE_CODE (expr) == OFFSET_REF)\n+    {\n+      expr = resolve_offset_ref (expr);\n+      from = TREE_TYPE (expr);\n+    }\n+\n+  if (from == error_mark_node || to == error_mark_node\n+      || expr == error_mark_node)\n+    return NULL_TREE;\n+\n+  /* Make sure both the FROM and TO types are complete so that\n+     user-defined conversions are available.  */\n   complete_type (from);\n   complete_type (to);\n "}, {"sha": "93d8a4346a7ffffec6e5cff2f3fb15aa7eb9a791", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -675,6 +675,9 @@ ocp_convert (type, expr, convtype, flags)\n       || TREE_TYPE (e) == error_mark_node)\n     return error_mark_node;\n \n+  complete_type (type);\n+  complete_type (TREE_TYPE (expr));\n+\n   if (TREE_READONLY_DECL_P (e))\n     e = decl_constant_value (e);\n \n@@ -742,10 +745,17 @@ ocp_convert (type, expr, convtype, flags)\n \t}\n       if (code == BOOLEAN_TYPE)\n \t{\n+\t  tree fn = NULL_TREE;\n+\n \t  /* Common Ada/Pascal programmer's mistake.  We always warn\n              about this since it is so bad.  */\n \t  if (TREE_CODE (expr) == FUNCTION_DECL)\n-\t    cp_warning (\"the address of `%D', will always be `true'\", expr);\n+\t    fn = expr;\n+\t  else if (TREE_CODE (expr) == ADDR_EXPR \n+\t\t   && TREE_CODE (TREE_OPERAND (expr, 0)) == FUNCTION_DECL)\n+\t    fn = TREE_OPERAND (expr, 0);\n+\t  if (fn)\n+\t    cp_warning (\"the address of `%D', will always be `true'\", fn);\n \t  return truthvalue_conversion (e);\n \t}\n       return fold (convert_to_integer (type, e));"}, {"sha": "08bf7eb06fefa9eb355fdc03e36764c5c367105a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -3414,12 +3414,8 @@ duplicate_decls (newdecl, olddecl)\n       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n \tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n \n-      /* Keep the old rtl since we can safely use it, unless it's the\n-\t call to abort() used for abstract virtuals.  */\n-      if ((DECL_LANG_SPECIFIC (olddecl)\n-\t   && !DECL_ABSTRACT_VIRTUAL_P (olddecl))\n-\t  || DECL_RTL (olddecl) != DECL_RTL (abort_fndecl))\n-\tDECL_RTL (newdecl) = DECL_RTL (olddecl);\n+      /* Keep the old rtl since we can safely use it.  */\n+      DECL_RTL (newdecl) = DECL_RTL (olddecl);\n \n       pop_obstacks ();\n     }"}, {"sha": "1d1716a01a6c7b5496bbd18cce89916556d439a6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -1272,6 +1272,7 @@ dump_expr (t, nop)\n     case FUNCTION_DECL:\n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n+    case OVERLOAD:\n       dump_decl (t, -1);\n       break;\n "}, {"sha": "ee9b70fb350990106bfeac78ac4aee7f3d8cf02a", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -47,7 +47,6 @@ struct token  {\n };\n \n static int do_aggr PROTO((void));\n-static int probe_obstack PROTO((struct obstack *, tree, unsigned int));\n static void scan_tokens PROTO((unsigned int));\n \n #ifdef SPEW_DEBUG\n@@ -198,30 +197,6 @@ scan_tokens (n)\n     }\n }\n \n-/* Like _obstack_allocated_p, but stop after checking NLEVELS chunks.  */\n-\n-static int\n-probe_obstack (h, obj, nlevels)\n-     struct obstack *h;\n-     tree obj;\n-     unsigned int nlevels;\n-{\n-  register struct _obstack_chunk*  lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk*  plp;\t/* point to previous chunk if any */\n-\n-  lp = (h)->chunk;\n-  /* We use >= rather than > since the object cannot be exactly at\n-     the beginning of the chunk but might be an empty object exactly\n-     at the end of an adjacent chunk.  */\n-  for (; nlevels != 0 && lp != 0 && ((tree)lp >= obj || (tree)lp->limit < obj);\n-       nlevels -= 1)\n-    {\n-      plp = lp->prev;\n-      lp = plp;      \n-    }\n-  return nlevels != 0 && lp != 0;\n-}\n-\n /* from lex.c: */\n /* Value is 1 (or 2) if we should try to make the next identifier look like\n    a typename (when it may be a local variable or a class variable)."}, {"sha": "f2be13afff52ec36d5c68307ff464d7a04ea7246", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -4336,7 +4336,7 @@ condition_conversion (expr)\n   tree t;\n   if (processing_template_decl)\n     return expr;\n-  t = cp_convert (boolean_type_node, expr);\n+  t = perform_implicit_conversion (boolean_type_node, expr);\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n   return t;\n }"}, {"sha": "d9a4484bff47636e166a92d162e890b38750aae9", "filename": "gcc/testsuite/g++.old-deja/g++.mike/warn8.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn8.C?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -10,10 +10,10 @@ void test() {\n   bool (foo::* pmf)() = &foo::test;\n   bool (*pf)() = func;\n \n-  if (A.test) ;\t\t\t// WARNING - \n+  if (A.test) ;\t\t\t// ERROR - \n   if (func) ;\t\t\t// WARNING - \n-  if (bool(A.test)) ;\t\t// WARNING - \n-  if (bool(func)) ;\n+  if (bool(A.test)) ;\t\t// ERROR - \n+  if (bool(func)) ;             // WARNING - \n   if (pmf) ;\n   if (pf) ;\n }"}, {"sha": "f73a49576415eb5276c3c5deb770e24716631973", "filename": "gcc/testsuite/g++.old-deja/g++.pt/cond3.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcond3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d73aa6323d0795b477d1725ed9e62fcb7e9494c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcond3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcond3.C?ref=5d73aa6323d0795b477d1725ed9e62fcb7e9494c", "patch": "@@ -0,0 +1,25 @@\n+// Build don't link:\n+// Origin: Loring Holden <lsh@lsh.cs.brown.edu>\n+\n+template <class T>\n+class REFptr {\n+   public:\n+      operator T* () const;\n+};\n+\n+class CamFocus;\n+typedef REFptr<CamFocus> CamFocusptr;\n+\n+class CamFocus {\n+   protected:\n+      static CamFocusptr  _focus;\n+   public :\n+      static CamFocusptr &cur() { return _focus; }\n+};\n+\n+void\n+test()  \n+{\n+   if (CamFocus::cur()) {\n+   }\n+}"}]}