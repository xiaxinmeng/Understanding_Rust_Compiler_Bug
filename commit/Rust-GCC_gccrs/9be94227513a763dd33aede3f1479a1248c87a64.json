{"sha": "9be94227513a763dd33aede3f1479a1248c87a64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJlOTQyMjc1MTNhNzYzZGQzM2FlZGUzZjE0NzlhMTI0OGM4N2E2NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-05-26T12:05:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-26T12:05:24Z"}, "message": "cfgcleanup.c (try_optimize_cfg): Do not delete forwarder blocks if CLEANUP_NO_INSN_DEL.\n\n\t* cfgcleanup.c (try_optimize_cfg): Do not delete forwarder blocks\n\tif CLEANUP_NO_INSN_DEL.\n\t* cfgrtl.c (unique_locus_on_edge_between_p): New function extracted\n\tfrom cfg_layout_merge_blocks.\n\t(emit_nop_for_unique_locus_between): New function.\n\t(rtl_merge_blocks): Invoke emit_nop_for_unique_locus_between.\n\t(cfg_layout_merge_blocks): Likewise.\n\nFrom-SVN: r187913", "tree": {"sha": "2e0ce944007433764dbb17fe53d32320bebbcfb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e0ce944007433764dbb17fe53d32320bebbcfb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9be94227513a763dd33aede3f1479a1248c87a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be94227513a763dd33aede3f1479a1248c87a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9be94227513a763dd33aede3f1479a1248c87a64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be94227513a763dd33aede3f1479a1248c87a64/comments", "author": null, "committer": null, "parents": [{"sha": "60ba49d0197a473294fe3353f1fa9840e64d2a9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ba49d0197a473294fe3353f1fa9840e64d2a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60ba49d0197a473294fe3353f1fa9840e64d2a9c"}], "stats": {"total": 108, "additions": 77, "deletions": 31}, "files": [{"sha": "3f89efc96fdb4b4314ca366bac140ad0c064688e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9be94227513a763dd33aede3f1479a1248c87a64", "patch": "@@ -1,3 +1,13 @@\n+2012-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cfgcleanup.c (try_optimize_cfg): Do not delete forwarder blocks\n+\tif CLEANUP_NO_INSN_DEL.\n+\t* cfgrtl.c (unique_locus_on_edge_between_p): New function extracted\n+\tfrom cfg_layout_merge_blocks.\n+\t(emit_nop_for_unique_locus_between): New function.\n+\t(rtl_merge_blocks): Invoke emit_nop_for_unique_locus_between.\n+\t(cfg_layout_merge_blocks): Likewise.\n+\n 2012-05-26  Dimitrios Apostolou  <jimis@gmx.net>\n \t    Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "6c56a041d75afb477f5a4e623b7280408527f06e", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9be94227513a763dd33aede3f1479a1248c87a64", "patch": "@@ -2644,7 +2644,7 @@ try_optimize_cfg (int mode)\n \t\t}\n \n \t      /* If we fall through an empty block, we can remove it.  */\n-\t      if (!(mode & CLEANUP_CFGLAYOUT)\n+\t      if (!(mode & (CLEANUP_CFGLAYOUT | CLEANUP_NO_INSN_DEL))\n \t\t  && single_pred_p (b)\n \t\t  && (single_pred_edge (b)->flags & EDGE_FALLTHRU)\n \t\t  && !LABEL_P (BB_HEAD (b))"}, {"sha": "3ee92d9a2aa6ae1a47d9c7f3caafd364d28849fc", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be94227513a763dd33aede3f1479a1248c87a64/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9be94227513a763dd33aede3f1479a1248c87a64", "patch": "@@ -603,6 +603,56 @@ rtl_split_block (basic_block bb, void *insnp)\n   return new_bb;\n }\n \n+/* Return true if the single edge between blocks A and B is the only place\n+   in RTL which holds some unique locus.  */\n+\n+static bool\n+unique_locus_on_edge_between_p (basic_block a, basic_block b)\n+{\n+  const int goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n+  rtx insn, end;\n+\n+  if (!goto_locus)\n+    return false;\n+\n+  /* First scan block A backward.  */\n+  insn = BB_END (a);\n+  end = PREV_INSN (BB_HEAD (a));\n+  while (insn != end && (!NONDEBUG_INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n+    insn = PREV_INSN (insn);\n+\n+  if (insn != end && locator_eq (INSN_LOCATOR (insn), goto_locus))\n+    return false;\n+\n+  /* Then scan block B forward.  */\n+  insn = BB_HEAD (b);\n+  if (insn)\n+    {\n+      end = NEXT_INSN (BB_END (b));\n+      while (insn != end && !NONDEBUG_INSN_P (insn))\n+\tinsn = NEXT_INSN (insn);\n+\n+      if (insn != end && INSN_LOCATOR (insn) != 0\n+\t  && locator_eq (INSN_LOCATOR (insn), goto_locus))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* If the single edge between blocks A and B is the only place in RTL which\n+   holds some unique locus, emit a nop with that locus between the blocks.  */\n+\n+static void\n+emit_nop_for_unique_locus_between (basic_block a, basic_block b)\n+{\n+  if (!unique_locus_on_edge_between_p (a, b))\n+    return;\n+\n+  BB_END (a) = emit_insn_after_noloc (gen_nop (), BB_END (a), a);\n+  INSN_LOCATOR (BB_END (a)) = EDGE_SUCC (a, 0)->goto_locus;\n+}\n+\n /* Blocks A and B are to be merged into a single block A.  The insns\n    are already contiguous.  */\n \n@@ -681,15 +731,25 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n   /* Delete everything marked above as well as crap that might be\n      hanging out between the two blocks.  */\n-  BB_HEAD (b) = NULL;\n+  BB_END (a) = a_end;\n+  BB_HEAD (b) = b_empty ? NULL_RTX : b_head;\n   delete_insn_chain (del_first, del_last, true);\n \n+  /* When not optimizing CFG and the edge is the only place in RTL which holds\n+     some unique locus, emit a nop with that locus in between.  */\n+  if (!optimize)\n+    {\n+      emit_nop_for_unique_locus_between (a, b);\n+      a_end = BB_END (a);\n+    }\n+\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n       update_bb_for_insn_chain (a_end, b_debug_end, a);\n \n-      a_end = b_debug_end;\n+      BB_END (a) = b_debug_end;\n+      BB_HEAD (b) = NULL_RTX;\n     }\n   else if (b_end != b_debug_end)\n     {\n@@ -701,11 +761,10 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \treorder_insns_nobb (NEXT_INSN (a_end), PREV_INSN (b_debug_start),\n \t\t\t    b_debug_end);\n       update_bb_for_insn_chain (b_debug_start, b_debug_end, a);\n-      a_end = b_debug_end;\n+      BB_END (a) = b_debug_end;\n     }\n \n   df_bb_delete (b->index);\n-  BB_END (a) = a_end;\n \n   /* If B was a forwarder block, propagate the locus on the edge.  */\n   if (forwarder_p && !EDGE_SUCC (b, 0)->goto_locus)\n@@ -2853,33 +2912,10 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     try_redirect_by_replacing_jump (EDGE_SUCC (a, 0), b, true);\n   gcc_assert (!JUMP_P (BB_END (a)));\n \n-  /* When not optimizing and the edge is the only place in RTL which holds\n+  /* When not optimizing CFG and the edge is the only place in RTL which holds\n      some unique locus, emit a nop with that locus in between.  */\n-  if (!optimize && EDGE_SUCC (a, 0)->goto_locus)\n-    {\n-      rtx insn = BB_END (a), end = PREV_INSN (BB_HEAD (a));\n-      int goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n-\n-      while (insn != end && (!INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n-\tinsn = PREV_INSN (insn);\n-      if (insn != end && locator_eq (INSN_LOCATOR (insn), goto_locus))\n-\tgoto_locus = 0;\n-      else\n-\t{\n-\t  insn = BB_HEAD (b);\n-\t  end = NEXT_INSN (BB_END (b));\n-\t  while (insn != end && !INSN_P (insn))\n-\t    insn = NEXT_INSN (insn);\n-\t  if (insn != end && INSN_LOCATOR (insn) != 0\n-\t      && locator_eq (INSN_LOCATOR (insn), goto_locus))\n-\t    goto_locus = 0;\n-\t}\n-      if (goto_locus)\n-\t{\n-\t  BB_END (a) = emit_insn_after_noloc (gen_nop (), BB_END (a), a);\n-\t  INSN_LOCATOR (BB_END (a)) = goto_locus;\n-\t}\n-    }\n+  if (!optimize)\n+    emit_nop_for_unique_locus_between (a, b);\n \n   /* Possible line number notes should appear in between.  */\n   if (BB_HEADER (b))"}]}