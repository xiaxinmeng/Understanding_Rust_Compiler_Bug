{"sha": "84a7b1fccfb7444fbee02496958ae8df5b90b15b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRhN2IxZmNjZmI3NDQ0ZmJlZTAyNDk2OTU4YWU4ZGY1YjkwYjE1Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-01-10T18:15:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-10T18:15:34Z"}, "message": "complex: New file...\n\n2006-01-10  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/complex: New file, hosts the additions to header\n\t<complex> described in TR1, Chapter 8 [tr.c99].\n\t* include/Makefile.am: Add.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/tr1/8_c_compatibility/complex/functions.cc: New.\n\nFrom-SVN: r109550", "tree": {"sha": "d004491e8cbf706ed84e71dc570b225f4b9cd398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d004491e8cbf706ed84e71dc570b225f4b9cd398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84a7b1fccfb7444fbee02496958ae8df5b90b15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a7b1fccfb7444fbee02496958ae8df5b90b15b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a7b1fccfb7444fbee02496958ae8df5b90b15b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a7b1fccfb7444fbee02496958ae8df5b90b15b/comments", "author": null, "committer": null, "parents": [{"sha": "db710e419a39d641ee5bde4be479719612422e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db710e419a39d641ee5bde4be479719612422e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db710e419a39d641ee5bde4be479719612422e88"}], "stats": {"total": 383, "additions": 375, "deletions": 8}, "files": [{"sha": "9f5713e7d3724600f69d899015ccdd0b61a3fa3d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=84a7b1fccfb7444fbee02496958ae8df5b90b15b", "patch": "@@ -1,3 +1,11 @@\n+2006-01-10  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/complex: New file, hosts the additions to header\n+\t<complex> described in TR1, Chapter 8 [tr.c99].\n+\t* include/Makefile.am: Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/tr1/8_c_compatibility/complex/functions.cc: New.\n+\n 2006-01-09  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/25658"}, {"sha": "68b1d81d80ac384e71afcb03fb736601011e269e", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=84a7b1fccfb7444fbee02496958ae8df5b90b15b", "patch": "@@ -483,21 +483,22 @@ tr1_headers = \\\n \t${tr1_srcdir}/bind_repeat.h \\\n \t${tr1_srcdir}/bind_iterate.h \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n-\t${tr1_srcdir}/mu_iterate.h \\\n+\t${tr1_srcdir}/complex \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n+\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/memory \\\n+\t${tr1_srcdir}/mu_iterate.h \\\n \t${tr1_srcdir}/ref_fwd.h \\\n \t${tr1_srcdir}/ref_wrap_iterate.h \\\n \t${tr1_srcdir}/repeat.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/tuple_iterate.h \\\n-\t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n \t${tr1_srcdir}/type_traits_fwd.h \\\n-\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/unordered_set \\\n-\t${tr1_srcdir}/unordered_map\n+\t${tr1_srcdir}/unordered_map \\\n+\t${tr1_srcdir}/utility\n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "9b9c82253b41c6ac8285b4a09045e499658d13b8", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=84a7b1fccfb7444fbee02496958ae8df5b90b15b", "patch": "@@ -701,21 +701,22 @@ tr1_headers = \\\n \t${tr1_srcdir}/bind_repeat.h \\\n \t${tr1_srcdir}/bind_iterate.h \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n-\t${tr1_srcdir}/mu_iterate.h \\\n+\t${tr1_srcdir}/complex \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n+\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/memory \\\n+\t${tr1_srcdir}/mu_iterate.h \\\n \t${tr1_srcdir}/ref_fwd.h \\\n \t${tr1_srcdir}/ref_wrap_iterate.h \\\n \t${tr1_srcdir}/repeat.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/tuple_iterate.h \\\n-\t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n \t${tr1_srcdir}/type_traits_fwd.h \\\n-\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/unordered_set \\\n-\t${tr1_srcdir}/unordered_map\n+\t${tr1_srcdir}/unordered_map \\\n+\t${tr1_srcdir}/utility\n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "5df17bb09b5fdf9327ba312590ffc7e0e102971d", "filename": "libstdc++-v3/include/tr1/complex", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex?ref=84a7b1fccfb7444fbee02496958ae8df5b90b15b", "patch": "@@ -0,0 +1,303 @@\n+// TR1 complex -*- C++ -*-\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef _TR1_COMPLEX\n+#define _TR1_COMPLEX 1\n+\n+#include \"../complex\"\n+\n+// namespace std::tr1\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(tr1)\n+\n+  // Forward declarations.\n+  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+\n+  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> fabs(const std::complex<_Tp>&);\n+\n+  /// @brief acos(__z) [8.1.2]\n+  //  Effects:  Behaves the same as C99 function cacos, defined\n+  //            in subclause 7.3.5.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_acos(const std::complex<_Tp>& __z)\n+    {\n+      const std::complex<_Tp> __t = std::tr1::asin(__z);\n+      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n+      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_acos(__complex__ float __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acos(__complex__ double __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acos(const __complex__ long double& __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z); }\n+#endif\n+\n+  /// @brief asin(__z) [8.1.3]\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.5.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_asin(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t(-__z.imag(), __z.real());\n+      __t = std::tr1::asinh(__t);\n+      return std::complex<_Tp>(__t.imag(), -__t.real());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_asin(__complex__ float __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asin(__complex__ double __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asin(const __complex__ long double& __z)\n+  { return __builtin_casinl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z); }\n+#endif\n+  \n+  /// @brief atan(__z) [8.1.4]\n+  //  Effects:  Behaves the same as C99 function catan, defined\n+  //            in subclause 7.3.5.3.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atan(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __r2 = __z.real() * __z.real();\n+      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n+\n+      _Tp __num = __z.imag() + _Tp(1.0);\n+      _Tp __den = __z.imag() - _Tp(1.0);\n+\n+      __num = __r2 + __num * __num;\n+      __den = __r2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n+\t\t\t       _Tp(0.25) * log(__num / __den));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_atan(__complex__ float __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atan(__complex__ double __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atan(const __complex__ long double& __z)\n+  { return __builtin_catanl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z); }\n+#endif\n+\n+  /// @brief acosh(__z) [8.1.5]\n+  //  Effects:  Behaves the same as C99 function cacosh, defined\n+  //            in subclause 7.3.6.1.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_acosh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_acosh(__complex__ float __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acosh(__complex__ double __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acosh(const __complex__ long double& __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z); }\n+#endif\n+\n+  /// @brief asinh(__z) [8.1.6]\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.6.2.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_asinh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_asinh(__complex__ float __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asinh(__complex__ double __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asinh(const __complex__ long double& __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z); }\n+#endif\n+\n+  /// @brief atanh(__z) [8.1.7]\n+  //  Effects:  Behaves the same as C99 function catanh, defined\n+  //            in subclause 7.3.6.3.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atanh(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __i2 = __z.imag() * __z.imag();\n+      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n+\n+      _Tp __num = _Tp(1.0) + __z.real();\n+      _Tp __den = _Tp(1.0) - __z.real();\n+\n+      __num = __i2 + __num * __num;\n+      __den = __i2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n+\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_atanh(__complex__ float __z)\n+  { return __builtin_catanhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atanh(__complex__ double __z)\n+  { return __builtin_catanh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atanh(const __complex__ long double& __z)\n+  { return __builtin_catanhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z); }\n+#endif\n+\n+  /// @brief fabs(__z) [8.1.8]\n+  //  Effects:  Behaves the same as C99 function cabs, defined\n+  //            in subclause 7.3.8.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    fabs(const std::complex<_Tp>& __z)\n+    { return std::abs(__z); }\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif"}, {"sha": "1fdd10848e35e621907233d13641497c782d6614", "filename": "libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/functions.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F8_c_compatibility%2Fcomplex%2Ffunctions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a7b1fccfb7444fbee02496958ae8df5b90b15b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F8_c_compatibility%2Fcomplex%2Ffunctions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F8_c_compatibility%2Fcomplex%2Ffunctions.cc?ref=84a7b1fccfb7444fbee02496958ae8df5b90b15b", "patch": "@@ -0,0 +1,54 @@\n+// 2006-01-10  Paolo Carlini  <pcarlini@suse.de>\n+//\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 8.1 Additions to header <complex>\n+\n+#include <tr1/complex>\n+\n+template<typename T>\n+  void test01_do()\n+  {\n+    using namespace std::tr1;\n+    typedef std::complex<T> cmplx_type;\n+\n+    cmplx_type ans;\n+\n+    ans = acos(cmplx_type(1.0, 1.0));\n+    ans = asin(cmplx_type(1.0, 1.0));\n+    ans = atan(cmplx_type(1.0, 1.0));\n+\n+    ans = acosh(cmplx_type(1.0, 1.0));\n+    ans = asinh(cmplx_type(1.0, 1.0));\n+    ans = atanh(cmplx_type(1.0, 1.0));\n+    ans = fabs(cmplx_type(1.0, 1.0));\n+  }\n+    \n+void test01()\n+{\n+  test01_do<float>();\n+  test01_do<double>();\n+  test01_do<long double>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}