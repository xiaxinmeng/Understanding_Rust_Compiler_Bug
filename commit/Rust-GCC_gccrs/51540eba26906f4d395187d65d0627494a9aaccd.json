{"sha": "51540eba26906f4d395187d65d0627494a9aaccd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1NDBlYmEyNjkwNmY0ZDM5NTE4N2Q2NWQwNjI3NDk0YTlhYWNjZA==", "commit": {"author": {"name": "Keith Besaw", "email": "kbesaw@us.ibm.com", "date": "2005-06-10T17:44:22Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-06-10T17:44:22Z"}, "message": "tree-ssa-alias.c (new_type_alias): Use existing type tag if VAR has just one in its may_aliases list.\n\n2005-06-10  Keith Besaw  <kbesaw@us.ibm.com>\n\n        * tree-ssa-alias.c (new_type_alias): Use existing type\n        tag if VAR has just one in its may_aliases list.\n\nFrom-SVN: r100824", "tree": {"sha": "dd8b83235bd417bca6942c0d14e7545203367143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd8b83235bd417bca6942c0d14e7545203367143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51540eba26906f4d395187d65d0627494a9aaccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51540eba26906f4d395187d65d0627494a9aaccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51540eba26906f4d395187d65d0627494a9aaccd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51540eba26906f4d395187d65d0627494a9aaccd/comments", "author": null, "committer": null, "parents": [{"sha": "73042643c746f696cc5543005060b70dec76c8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73042643c746f696cc5543005060b70dec76c8c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73042643c746f696cc5543005060b70dec76c8c9"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "3acacf3c6672555b8b24f408efb442f69d4516ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51540eba26906f4d395187d65d0627494a9aaccd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51540eba26906f4d395187d65d0627494a9aaccd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51540eba26906f4d395187d65d0627494a9aaccd", "patch": "@@ -1,3 +1,8 @@\n+2005-06-10  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* tree-ssa-alias.c (new_type_alias): Use existing type\n+\ttag if VAR has just one in its may_aliases list.\n+\n 2005-06-10  Fariborz Jahanian <fjahanian@apple.com>\n \t* rs6000/predicates.md (scc_operand): New.\n \t* rs6000/rs6000.md : Use scc_operand for eq:SI compares."}, {"sha": "3098549d881dddddfe96cce4a3286f4d97dd5433", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51540eba26906f4d395187d65d0627494a9aaccd/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51540eba26906f4d395187d65d0627494a9aaccd/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=51540eba26906f4d395187d65d0627494a9aaccd", "patch": "@@ -2787,8 +2787,11 @@ add_type_alias (tree ptr, tree var)\n }\n \n \n-/* Create a type tag for PTR.  Construct the may-alias list of this type tag\n-   so that it has the aliasing of VAR.  */\n+/* Create a new type tag for PTR.  Construct the may-alias list of this type\n+   tag so that it has the aliasing of VAR. \n+\n+   Note, the set of aliases represented by the new type tag are not marked\n+   for renaming.  */\n \n void\n new_type_alias (tree ptr, tree var)\n@@ -2801,22 +2804,53 @@ new_type_alias (tree ptr, tree var)\n \n   gcc_assert (p_ann->type_mem_tag == NULL_TREE);\n   gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG);\n-  tag = create_memory_tag (tag_type, true);\n-  p_ann->type_mem_tag = tag;\n \n   /* Add VAR to the may-alias set of PTR's new type tag.  If VAR has\n      subvars, add the subvars to the tag instead of the actual var.  */\n   if (var_can_have_subvars (var)\n       && (svars = get_subvars_for_var (var)))\n     {\n-      subvar_t sv;      \n+      subvar_t sv;\n+\n+      tag = create_memory_tag (tag_type, true);\n+      p_ann->type_mem_tag = tag;\n+\n       for (sv = svars; sv; sv = sv->next)\n         add_may_alias (tag, sv->var);\n     }\n   else\n-    add_may_alias (tag, var);\n+    {\n+      /* The following is based on code in add_stmt_operand to ensure that the\n+\t same defs/uses/vdefs/vuses will be found after replacing a reference\n+\t to var (or ARRAY_REF to var) with an INDIRECT_REF to ptr whose value\n+\t is the address of var.  */\n+      varray_type aliases = v_ann->may_aliases;\n+\n+      if ((aliases != NULL)\n+\t  && (VARRAY_ACTIVE_SIZE (aliases) == 1))\n+\t{\n+\t  tree ali = VARRAY_TREE (aliases, 0);\n \n-  /* Note, TAG and its set of aliases are not marked for renaming.  */\n+\t  if (get_var_ann (ali)->mem_tag_kind == TYPE_TAG)\n+\t    {\n+\t      p_ann->type_mem_tag = ali;\n+\t      return;\n+\t    }\n+\t}\n+\n+      tag = create_memory_tag (tag_type, true);\n+      p_ann->type_mem_tag = tag;\n+\n+      if (aliases == NULL)\n+\tadd_may_alias (tag, var);\n+      else\n+\t{\n+\t  size_t i;\n+\n+\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\t    add_may_alias (tag, VARRAY_TREE (aliases, i));\n+\t}\n+    }    \n }\n \n /* This represents the used range of a variable.  */"}]}