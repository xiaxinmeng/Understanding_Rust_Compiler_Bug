{"sha": "1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRkYmJiYzBhOGM1ZjFmZjA3MDAyYTMyODJiMDdkZDI0YzM2N2FjZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-10-17T17:06:24Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-10-17T17:06:24Z"}, "message": "re PR target/58673 (ICE in final_scan_insn for movti_ppc64 with base+offset address)\n\n[gcc]\n2013-10-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/58673\n\t* config/rs6000/rs6000.c (rs6000_legitimate_address_p): Only\n\trestrict TImode addresses to single indirect registers if both\n\t-mquad-memory and -mvsx-timode are used.\n\t(rs6000_output_move_128bit): Use quad_load_store_p to determine if\n\twe should emit load/store quad.  Remove using %y for quad memory\n\taddresses.\n\n\t* config/rs6000/rs6000.md (mov<mode>_ppc64, TI/PTImode): Add\n\tconstraints to allow load/store quad on machines where TImode is\n\tnot allowed in VSX registers.  Use 'n' instead of 'F' constraint\n\tfor TImode to load integer constants.\n\n[gcc/testsuite]\n2013-10-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/58673\n\t* gcc.target/powerpc/pr58673-1.c: New file to test whether\n\t-mquad-word + -mno-vsx-timode causes errors.\n\t* gcc.target/powerpc/pr58673-2.c: Likewise.\n\nFrom-SVN: r203781", "tree": {"sha": "3bc55cf98ca626982f1afea77e2a631b66ba7a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc55cf98ca626982f1afea77e2a631b66ba7a23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/comments", "author": null, "committer": null, "parents": [{"sha": "206b48e4e7fcc47d9877fe5aaae9eaecde21b3bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/206b48e4e7fcc47d9877fe5aaae9eaecde21b3bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/206b48e4e7fcc47d9877fe5aaae9eaecde21b3bf"}], "stats": {"total": 345, "additions": 323, "deletions": 22}, "files": [{"sha": "c413553f28323622b0f8831b968f7d4b15bb05c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "patch": "@@ -1,3 +1,18 @@\n+2013-10-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/58673\n+\t* config/rs6000/rs6000.c (rs6000_legitimate_address_p): Only\n+\trestrict TImode addresses to single indirect registers if both\n+\t-mquad-memory and -mvsx-timode are used.\n+\t(rs6000_output_move_128bit): Use quad_load_store_p to determine if\n+\twe should emit load/store quad.  Remove using %y for quad memory\n+\taddresses.\n+\n+\t* config/rs6000/rs6000.md (mov<mode>_ppc64, TI/PTImode): Add\n+\tconstraints to allow load/store quad on machines where TImode is\n+\tnot allowed in VSX registers.  Use 'n' instead of 'F' constraint\n+\tfor TImode to load integer constants.\n+\n 2013-10-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_print_operand): Handle 'c'."}, {"sha": "12124942b1a6ee05fc358d102af3b633e93301ba", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "patch": "@@ -7186,12 +7186,12 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n   if (reg_offset_p\n       && legitimate_constant_pool_address_p (x, mode, reg_ok_strict))\n     return 1;\n-  /* For TImode, if we have load/store quad, only allow register indirect\n-     addresses.  This will allow the values to go in either GPRs or VSX\n-     registers without reloading.  The vector types would tend to go into VSX\n-     registers, so we allow REG+REG, while TImode seems somewhat split, in that\n-     some uses are GPR based, and some VSX based.  */\n-  if (mode == TImode && TARGET_QUAD_MEMORY)\n+  /* For TImode, if we have load/store quad and TImode in VSX registers, only\n+     allow register indirect addresses.  This will allow the values to go in\n+     either GPRs or VSX registers without reloading.  The vector types would\n+     tend to go into VSX registers, so we allow REG+REG, while TImode seems\n+     somewhat split, in that some uses are GPR based, and some VSX based.  */\n+  if (mode == TImode && TARGET_QUAD_MEMORY && TARGET_VSX_TIMODE)\n     return 0;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n@@ -16064,13 +16064,8 @@ rs6000_output_move_128bit (rtx operands[])\n     {\n       if (dest_gpr_p)\n \t{\n-\t  if (TARGET_QUAD_MEMORY && (dest_regno & 1) == 0\n-\t      && quad_memory_operand (src, mode)\n-\t      && !reg_overlap_mentioned_p (dest, src))\n-\t    {\n-\t      /* lq/stq only has DQ-form, so avoid X-form that %y produces.  */\n-\t      return REG_P (XEXP (src, 0)) ? \"lq %0,%1\" : \"lq %0,%y1\";\n-\t    }\n+\t  if (TARGET_QUAD_MEMORY && quad_load_store_p (dest, src))\n+\t    return \"lq %0,%1\";\n \t  else\n \t    return \"#\";\n \t}\n@@ -16099,12 +16094,8 @@ rs6000_output_move_128bit (rtx operands[])\n     {\n       if (src_gpr_p)\n \t{\n-\t  if (TARGET_QUAD_MEMORY && (src_regno & 1) == 0\n-\t      && quad_memory_operand (dest, mode))\n-\t    {\n-\t      /* lq/stq only has DQ-form, so avoid X-form that %y produces.  */\n-\t      return REG_P (XEXP (dest, 0)) ? \"stq %1,%0\" : \"stq %1,%y0\";\n-\t    }\n+ \t  if (TARGET_QUAD_MEMORY && quad_load_store_p (dest, src))\n+\t    return \"stq %1,%0\";\n \t  else\n \t    return \"#\";\n \t}"}, {"sha": "567961a42e54b6eedf236006f334cdbbc7d792c9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "patch": "@@ -10312,15 +10312,15 @@\n \t\t\t\t\t  (const_string \"conditional\")))])\n \n (define_insn \"*mov<mode>_ppc64\"\n-  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=Y,r,r,r\")\n-\t(match_operand:TI2 1 \"input_operand\" \"r,Y,r,F\"))]\n+  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=wQ,Y,r,r,r,r\")\n+\t(match_operand:TI2 1 \"input_operand\" \"r,r,wQ,Y,r,n\"))]\n   \"(TARGET_POWERPC64 && VECTOR_MEM_NONE_P (<MODE>mode)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode)))\"\n {\n   return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"store,load,*,*\")\n+  [(set_attr \"type\" \"store,store,load,load,*,*\")\n    (set_attr \"length\" \"8\")])\n \n (define_split"}, {"sha": "6f7838f8ddece451e1db0270a90964641b7d0d86", "filename": "gcc/testsuite/gcc.target/powerpc/pr58673-1.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-1.c?ref=1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -m64 -O1\" } */\n+\n+enum typecode\n+{\n+  QIcode, QUcode, HIcode, HUcode, SIcode, SUcode, DIcode, DUcode, SFcode,\n+    DFcode, XFcode, Pcode, Tcode, LAST_AND_UNUSED_TYPECODE\n+};\n+enum bytecode_opcode\n+{\n+  neverneverland, drop, duplicate, over, setstackSI, adjstackSI, constQI,\n+    constHI, constSI, constDI, constSF, constDF, constXF, constP, loadQI,\n+    loadHI, loadSI, loadDI, loadSF, loadDF, loadXF, loadP, storeQI, storeHI,\n+    storeSI, storeDI, storeSF, storeDF, storeXF, storeP, storeBLK, clearBLK,\n+    addconstPSI, newlocalSI, localP, argP, convertQIHI, convertHISI,\n+    convertSIDI, convertQISI, convertQUHU, convertHUSU, convertSUDU,\n+    convertQUSU, convertSFDF, convertDFXF, convertHIQI, convertSIHI,\n+    convertDISI, convertSIQI, convertSUQU, convertDFSF, convertXFDF,\n+    convertSISF, convertSIDF, convertSIXF, convertSUSF, convertSUDF,\n+    convertSUXF, convertDISF, convertDIDF, convertDIXF, convertDUSF,\n+    convertDUDF, convertDUXF, convertSFSI, convertDFSI, convertXFSI,\n+    convertSFSU, convertDFSU, convertXFSU, convertSFDI, convertDFDI,\n+    convertXFDI, convertSFDU, convertDFDU, convertXFDU, convertPSI,\n+    convertSIP, convertSIT, convertDIT, convertSFT, convertDFT, convertXFT,\n+    convertPT, zxloadBI, sxloadBI, sstoreBI, addSI, addDI, addSF, addDF,\n+    addXF, addPSI, subSI, subDI, subSF, subDF, subXF, subPP, mulSI, mulDI,\n+    mulSU, mulDU, mulSF, mulDF, mulXF, divSI, divDI, divSU, divDU, divSF,\n+    divDF, divXF, modSI, modDI, modSU, modDU, andSI, andDI, iorSI, iorDI,\n+    xorSI, xorDI, lshiftSI, lshiftSU, lshiftDI, lshiftDU, rshiftSI, rshiftSU,\n+    rshiftDI, rshiftDU, ltSI, ltSU, ltDI, ltDU, ltSF, ltDF, ltXF, ltP, leSI,\n+    leSU, leDI, leDU, leSF, leDF, leXF, leP, geSI, geSU, geDI, geDU, geSF,\n+    geDF, geXF, geP, gtSI, gtSU, gtDI, gtDU, gtSF, gtDF, gtXF, gtP, eqSI,\n+    eqDI, eqSF, eqDF, eqXF, eqP, neSI, neDI, neSF, neDF, neXF, neP, negSI,\n+    negDI, negSF, negDF, negXF, notSI, notDI, notT, predecQI, predecHI,\n+    predecSI, predecDI, predecP, predecSF, predecDF, predecXF, predecBI,\n+    preincQI, preincHI, preincSI, preincDI, preincP, preincSF, preincDF,\n+    preincXF, preincBI, postdecQI, postdecHI, postdecSI, postdecDI, postdecP,\n+    postdecSF, postdecDF, postdecXF, postdecBI, postincQI, postincHI,\n+    postincSI, postincDI, postincP, postincSF, postincDF, postincXF,\n+    postincBI, xjumpif, xjumpifnot, jump, jumpP, caseSI, caseSU, caseDI,\n+    caseDU, call, returnP, ret, linenote, LAST_AND_UNUSED_OPCODE\n+};\n+struct binary_operator\n+{\n+  enum bytecode_opcode opcode;\n+  enum typecode arg0;\n+};\n+static struct conversion_recipe\n+{\n+  unsigned char *opcodes;\n+  int cost;\n+}\n+conversion_recipe[((int) LAST_AND_UNUSED_TYPECODE)][((int)\n+\t\t\t\t\t\t     LAST_AND_UNUSED_TYPECODE)];\n+static struct conversion_recipe\n+deduce_conversion (from, to)\n+     enum typecode from, to;\n+{\n+  (conversion_recipe[(int) from][(int) to].\n+   opcodes ? 0 : (conversion_recipe[(int) from][(int) to] =\n+\t\t  deduce_conversion (from, to), 0));\n+}\n+\n+void\n+bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n+     struct binary_operator optab[];\n+{\n+  int i, besti, cost, bestcost;\n+  enum typecode resultcode, arg0code;\n+  for (i = 0; optab[i].opcode != -1; ++i)\n+    {\n+      (conversion_recipe[(int) arg0code][(int) optab[i].arg0].\n+       opcodes ? 0 : (conversion_recipe[(int) arg0code][(int) optab[i].arg0] =\n+\t\t      deduce_conversion (arg0code, optab[i].arg0), 0));\n+    }\n+}"}, {"sha": "b70d2eed88ce8d3659854c07d6a3d7a57d07e1b8", "filename": "gcc/testsuite/gcc.target/powerpc/pr58673-2.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr58673-2.c?ref=1ddbbbc0a8c5f1ff07002a3282b07dd24c367acf", "patch": "@@ -0,0 +1,217 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O3 -m64 -funroll-loops\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <math.h>\n+#include <string.h>\n+\n+typedef long unsigned int size_t;\n+typedef struct _IO_FILE FILE;\n+typedef float real;\n+typedef real rvec[3];\n+typedef real matrix[3][3];\n+typedef real tensor[3][3];\n+enum\n+{\n+  F_BONDS, F_G96BONDS, F_MORSE, F_CUBICBONDS, F_CONNBONDS, F_HARMONIC,\n+    F_ANGLES, F_G96ANGLES, F_PDIHS, F_RBDIHS, F_IDIHS, F_LJ14, F_COUL14, F_LJ,\n+    F_BHAM, F_LJLR, F_DISPCORR, F_SR, F_LR, F_WPOL, F_POSRES, F_DISRES,\n+    F_DISRESVIOL, F_ORIRES, F_ORIRESDEV, F_ANGRES, F_ANGRESZ, F_SHAKE,\n+    F_SHAKENC, F_SETTLE, F_DUMMY2, F_DUMMY3, F_DUMMY3FD, F_DUMMY3FAD,\n+    F_DUMMY3OUT, F_DUMMY4FD, F_EQM, F_EPOT, F_EKIN, F_ETOT, F_TEMP, F_PRES,\n+    F_DVDL, F_DVDLKIN, F_NRE\n+};\n+typedef union\n+{\n+  struct\n+  {\n+  }\n+  bham;\n+  struct\n+  {\n+    real rA, krA, rB, krB;\n+  }\n+  harmonic;\n+}\n+t_iparams;\n+typedef struct\n+{\n+  t_iparams *iparams;\n+}\n+t_idef;\n+typedef struct\n+{\n+}\n+t_inputrec;\n+typedef struct\n+{\n+}\n+t_commrec;\n+typedef struct\n+{\n+}\n+t_forcerec;\n+typedef struct\n+{\n+}\n+t_mdatoms;\n+typedef struct\n+{\n+}\n+t_filenm;\n+enum\n+{\n+  eoPres, eoEpot, eoVir, eoDist, eoMu, eoForce, eoFx, eoFy, eoFz, eoPx, eoPy,\n+    eoPz, eoPolarizability, eoDipole, eoObsNR, eoMemory =\n+    eoObsNR, eoInter, eoUseVirial, eoNR\n+};\n+extern char *eoNames[eoNR];\n+typedef struct\n+{\n+  int bPrint;\n+}\n+t_coupl_LJ;\n+typedef struct\n+{\n+  int eObs;\n+  t_iparams xi;\n+}\n+t_coupl_iparams;\n+typedef struct\n+{\n+  real act_value[eoObsNR];\n+  real av_value[eoObsNR];\n+  real ref_value[eoObsNR];\n+  int bObsUsed[eoObsNR];\n+  int nLJ, nBU, nQ, nIP;\n+  t_coupl_LJ *tcLJ;\n+}\n+t_coupl_rec;\n+static void\n+pr_ff (t_coupl_rec * tcr, real time, t_idef * idef, t_commrec * cr, int nfile,\n+       t_filenm fnm[])\n+{\n+  static FILE *prop;\n+  static FILE **out = ((void *) 0);\n+  static FILE **qq = ((void *) 0);\n+  static FILE **ip = ((void *) 0);\n+  char buf[256];\n+  char *leg[] = {\n+    \"C12\", \"C6\"\n+  };\n+  char **raleg;\n+  int i, j, index;\n+  if ((prop == ((void *) 0)) && (out == ((void *) 0)) && (qq == ((void *) 0))\n+      && (ip == ((void *) 0)))\n+    {\n+      for (i = j = 0; (i < eoObsNR); i++)\n+\t{\n+\t  if (tcr->bObsUsed[i])\n+\t    {\n+\t      raleg[j++] =\n+\t\t(__extension__\n+\t\t (__builtin_constant_p (eoNames[i])\n+\t\t  && ((size_t) (const void *) ((eoNames[i]) + 1) -\n+\t\t      (size_t) (const void *) (eoNames[i]) ==\n+\t\t      1) ? (((const char *) (eoNames[i]))[0] ==\n+\t\t\t    '\\0' ? (char *) calloc ((size_t) 1,\n+\t\t\t\t\t\t    (size_t) 1) : (\n+\t\t\t\t\t\t\t\t\t   {\n+\t\t\t\t\t\t\t\t\t   size_t\n+\t\t\t\t\t\t\t\t\t   __len\n+\t\t\t\t\t\t\t\t\t   =\n+\t\t\t\t\t\t\t\t\t   strlen\n+\t\t\t\t\t\t\t\t\t   (eoNames\n+\t\t\t\t\t\t\t\t\t    [i])\n+\t\t\t\t\t\t\t\t\t   +\n+\t\t\t\t\t\t\t\t\t   1;\n+\t\t\t\t\t\t\t\t\t   char\n+\t\t\t\t\t\t\t\t\t   *__retval\n+\t\t\t\t\t\t\t\t\t   =\n+\t\t\t\t\t\t\t\t\t   (char\n+\t\t\t\t\t\t\t\t\t    *)\n+\t\t\t\t\t\t\t\t\t   malloc\n+\t\t\t\t\t\t\t\t\t   (__len);\n+\t\t\t\t\t\t\t\t\t   __retval;}\n+\t    )):\t    __strdup (eoNames[i])));\n+\t      raleg[j++] =\n+\t\t(__extension__\n+\t\t (__builtin_constant_p (buf)\n+\t\t  && ((size_t) (const void *) ((buf) + 1) -\n+\t\t      (size_t) (const void *) (buf) ==\n+\t\t      1) ? (((const char *) (buf))[0] ==\n+\t\t\t    '\\0' ? (char *) calloc ((size_t) 1,\n+\t\t\t\t\t\t    (size_t) 1) : (\n+\t\t\t\t\t\t\t\t\t   {\n+\t\t\t\t\t\t\t\t\t   size_t\n+\t\t\t\t\t\t\t\t\t   __len\n+\t\t\t\t\t\t\t\t\t   =\n+\t\t\t\t\t\t\t\t\t   strlen\n+\t\t\t\t\t\t\t\t\t   (buf)\n+\t\t\t\t\t\t\t\t\t   +\n+\t\t\t\t\t\t\t\t\t   1;\n+\t\t\t\t\t\t\t\t\t   char\n+\t\t\t\t\t\t\t\t\t   *__retval\n+\t\t\t\t\t\t\t\t\t   =\n+\t\t\t\t\t\t\t\t\t   (char\n+\t\t\t\t\t\t\t\t\t    *)\n+\t\t\t\t\t\t\t\t\t   malloc\n+\t\t\t\t\t\t\t\t\t   (__len);\n+\t\t\t\t\t\t\t\t\t   __retval;}\n+\t    )):\t    __strdup (buf)));\n+\t    }\n+\t}\n+      if (tcr->nLJ)\n+\t{\n+\t  for (i = 0; (i < tcr->nLJ); i++)\n+\t    {\n+\t      if (tcr->tcLJ[i].bPrint)\n+\t\t{\n+\t\t  xvgr_legend (out[i], (sizeof (leg) / sizeof ((leg)[0])),\n+\t\t\t       leg);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+do_coupling (FILE * log, int nfile, t_filenm fnm[], t_coupl_rec * tcr, real t,\n+\t     int step, real ener[], t_forcerec * fr, t_inputrec * ir,\n+\t     int bMaster, t_mdatoms * md, t_idef * idef, real mu_aver,\n+\t     int nmols, t_commrec * cr, matrix box, tensor virial,\n+\t     tensor pres, rvec mu_tot, rvec x[], rvec f[], int bDoIt)\n+{\n+  int i, j, ati, atj, atnr2, type, ftype;\n+  real deviation[eoObsNR], prdev[eoObsNR], epot0, dist, rmsf;\n+  real ff6, ff12, ffa, ffb, ffc, ffq, factor, dt, mu_ind;\n+  int bTest, bPrint;\n+  t_coupl_iparams *tip;\n+  if (bPrint)\n+    {\n+      pr_ff (tcr, t, idef, cr, nfile, fnm);\n+    }\n+  for (i = 0; (i < eoObsNR); i++)\n+    {\n+      deviation[i] =\n+\tcalc_deviation (tcr->av_value[i], tcr->act_value[i],\n+\t\t\ttcr->ref_value[i]);\n+      prdev[i] = tcr->ref_value[i] - tcr->act_value[i];\n+    }\n+  if (bPrint)\n+    pr_dev (tcr, t, prdev, cr, nfile, fnm);\n+  for (i = 0; (i < atnr2); i++)\n+    {\n+      factor = dt * deviation[tip->eObs];\n+      switch (ftype)\n+\t{\n+\tcase F_BONDS:\n+\t  if (fabs (tip->xi.harmonic.krA) > 1.2e-38)\n+\t    idef->iparams[type].harmonic.krA *=\n+\t      (1 + factor / tip->xi.harmonic.krA);\n+\t}\n+    }\n+}"}]}