{"sha": "105e29c5cf8729021614b152328bcfe054bed64d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1ZTI5YzVjZjg3MjkwMjE2MTRiMTUyMzI4YmNmZTA1NGJlZDY0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-27T12:10:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-27T12:10:34Z"}, "message": "cfgloop.c (record_niter_bound): Record likely upper bounds.\n\n\t* cfgloop.c (record_niter_bound): Record likely upper bounds.\n\t(likely_max_stmt_executions_int, get_likely_max_loop_iterations,\n\tget_likely_max_loop_iterations_int): New.\n\t* cfgloop.h (struct loop): Add nb_iterations_likely_upper_bound,\n\tany_likely_upper_bound.\n\t(get_likely_max_loop_iterations_int, get_likely_max_loop_iterations):\n\tDeclare.\n\t* cfgloopmanip.c (copy_loop_info): Copy likely upper bounds.\n\t* loop-unroll.c (unroll_loop_constant_iterations): Update likely\n\tupper bound.\n\t(unroll_loop_constant_iterations): Likewise.\n\t(unroll_loop_runtime_iterations): Likewise.\n\t* lto-streamer-in.c (input_cfg): Stream likely upper bounds.\n\t* lto-streamer-out.c (output_cfg): Likewise.\n\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Update likely upper\n\tbounds.\n\t(canonicalize_loop_induction_variables): Dump likely upper bounds.\n\t* tree-ssa-loop-niter.c (record_estimate): Record likely upper bounds.\n\t(likely_max_loop_iterations): New.\n\t(likely_max_loop_iterations_int): New.\n\t(likely_max_stmt_executions): New.\n\t* tree-ssa-loop-niter.h (likely_max_loop_iterations,\n\tlikely_max_loop_iterations_int, likely_max_stmt_executions_int,\n\tlikely_max_stmt_executions): Declare.\n\nFrom-SVN: r236816", "tree": {"sha": "9c8ce8178d2d6e5fb92b3271a8afae4b5b62e6c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c8ce8178d2d6e5fb92b3271a8afae4b5b62e6c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105e29c5cf8729021614b152328bcfe054bed64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105e29c5cf8729021614b152328bcfe054bed64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105e29c5cf8729021614b152328bcfe054bed64d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105e29c5cf8729021614b152328bcfe054bed64d/comments", "author": null, "committer": null, "parents": [{"sha": "3cee7e4e2badde2374fc77bb8f3a072e1698d1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cee7e4e2badde2374fc77bb8f3a072e1698d1fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cee7e4e2badde2374fc77bb8f3a072e1698d1fe"}], "stats": {"total": 210, "additions": 205, "deletions": 5}, "files": [{"sha": "eb34a284658ac1b1a1583b870f16f8e5f209cf96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -1,3 +1,30 @@\n+2016-05-27  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgloop.c (record_niter_bound): Record likely upper bounds.\n+\t(likely_max_stmt_executions_int, get_likely_max_loop_iterations,\n+\tget_likely_max_loop_iterations_int): New.\n+\t* cfgloop.h (struct loop): Add nb_iterations_likely_upper_bound,\n+\tany_likely_upper_bound.\n+\t(get_likely_max_loop_iterations_int, get_likely_max_loop_iterations):\n+\tDeclare.\n+\t* cfgloopmanip.c (copy_loop_info): Copy likely upper bounds.\n+\t* loop-unroll.c (unroll_loop_constant_iterations): Update likely\n+\tupper bound.\n+\t(unroll_loop_constant_iterations): Likewise.\n+\t(unroll_loop_runtime_iterations): Likewise.\n+\t* lto-streamer-in.c (input_cfg): Stream likely upper bounds.\n+\t* lto-streamer-out.c (output_cfg): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Update likely upper\n+\tbounds.\n+\t(canonicalize_loop_induction_variables): Dump likely upper bounds.\n+\t* tree-ssa-loop-niter.c (record_estimate): Record likely upper bounds.\n+\t(likely_max_loop_iterations): New.\n+\t(likely_max_loop_iterations_int): New.\n+\t(likely_max_stmt_executions): New.\n+\t* tree-ssa-loop-niter.h (likely_max_loop_iterations,\n+\tlikely_max_loop_iterations_int, likely_max_stmt_executions_int,\n+\tlikely_max_stmt_executions): Declare.\n+\n 2016-05-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/71308"}, {"sha": "27ccfb226c9778119046c3c95fff978533291451", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -1790,6 +1790,11 @@ record_niter_bound (struct loop *loop, const widest_int &i_bound,\n     {\n       loop->any_upper_bound = true;\n       loop->nb_iterations_upper_bound = i_bound;\n+      if (!loop->any_likely_upper_bound)\n+\t{\n+\t  loop->any_likely_upper_bound = true;\n+\t  loop->nb_iterations_likely_upper_bound = i_bound;\n+\t}\n     }\n   if (realistic\n       && (!loop->any_estimate\n@@ -1798,6 +1803,13 @@ record_niter_bound (struct loop *loop, const widest_int &i_bound,\n       loop->any_estimate = true;\n       loop->nb_iterations_estimate = i_bound;\n     }\n+  if (!realistic\n+      && (!loop->any_likely_upper_bound\n+          || wi::ltu_p (i_bound, loop->nb_iterations_likely_upper_bound)))\n+    {\n+      loop->any_likely_upper_bound = true;\n+      loop->nb_iterations_likely_upper_bound = i_bound;\n+    }\n \n   /* If an upper bound is smaller than the realistic estimate of the\n      number of iterations, use the upper bound instead.  */\n@@ -1806,6 +1818,11 @@ record_niter_bound (struct loop *loop, const widest_int &i_bound,\n       && wi::ltu_p (loop->nb_iterations_upper_bound,\n \t\t    loop->nb_iterations_estimate))\n     loop->nb_iterations_estimate = loop->nb_iterations_upper_bound;\n+  if (loop->any_upper_bound\n+      && loop->any_likely_upper_bound\n+      && wi::ltu_p (loop->nb_iterations_upper_bound,\n+\t\t    loop->nb_iterations_likely_upper_bound))\n+    loop->nb_iterations_likely_upper_bound = loop->nb_iterations_upper_bound;\n }\n \n /* Similar to get_estimated_loop_iterations, but returns the estimate only\n@@ -1847,6 +1864,25 @@ max_stmt_executions_int (struct loop *loop)\n   return snit < 0 ? -1 : snit;\n }\n \n+/* Returns an likely upper bound on the number of executions of statements\n+   in the LOOP.  For statements before the loop exit, this exceeds\n+   the number of execution of the latch by one.  */\n+\n+HOST_WIDE_INT\n+likely_max_stmt_executions_int (struct loop *loop)\n+{\n+  HOST_WIDE_INT nit = get_likely_max_loop_iterations_int (loop);\n+  HOST_WIDE_INT snit;\n+\n+  if (nit == -1)\n+    return -1;\n+\n+  snit = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) nit + 1);\n+\n+  /* If the computation overflows, return -1.  */\n+  return snit < 0 ? -1 : snit;\n+}\n+\n /* Sets NIT to the estimated number of executions of the latch of the\n    LOOP.  If we have no reliable estimate, the function returns false, otherwise\n    returns true.  */\n@@ -1905,6 +1941,40 @@ get_max_loop_iterations_int (struct loop *loop)\n   return hwi_nit < 0 ? -1 : hwi_nit;\n }\n \n+/* Sets NIT to an upper bound for the maximum number of executions of the\n+   latch of the LOOP.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+get_likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n+{\n+  if (!loop->any_likely_upper_bound)\n+    return false;\n+\n+  *nit = loop->nb_iterations_likely_upper_bound;\n+  return true;\n+}\n+\n+/* Similar to get_max_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+get_likely_max_loop_iterations_int (struct loop *loop)\n+{\n+  widest_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!get_likely_max_loop_iterations (loop, &nit))\n+    return -1;\n+\n+  if (!wi::fits_shwi_p (nit))\n+    return -1;\n+  hwi_nit = nit.to_shwi ();\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n+}\n+\n /* Returns the loop depth of the loop BB belongs to.  */\n \n int"}, {"sha": "aba2988c99e3d83d282f6583ce6ae2de6a4ca5c5", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -160,13 +160,16 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      valid if any_upper_bound is true.  */\n   widest_int nb_iterations_upper_bound;\n \n+  widest_int nb_iterations_likely_upper_bound;\n+\n   /* An integer giving an estimate on nb_iterations.  Unlike\n      nb_iterations_upper_bound, there is no guarantee that it is at least\n      nb_iterations.  */\n   widest_int nb_iterations_estimate;\n \n   bool any_upper_bound;\n   bool any_estimate;\n+  bool any_likely_upper_bound;\n \n   /* True if the loop can be parallel.  */\n   bool can_be_parallel;\n@@ -776,8 +779,10 @@ loop_outermost (struct loop *loop)\n extern void record_niter_bound (struct loop *, const widest_int &, bool, bool);\n extern HOST_WIDE_INT get_estimated_loop_iterations_int (struct loop *);\n extern HOST_WIDE_INT get_max_loop_iterations_int (struct loop *);\n+extern HOST_WIDE_INT get_likely_max_loop_iterations_int (struct loop *);\n extern bool get_estimated_loop_iterations (struct loop *loop, widest_int *nit);\n extern bool get_max_loop_iterations (struct loop *loop, widest_int *nit);\n+extern bool get_likely_max_loop_iterations (struct loop *loop, widest_int *nit);\n extern int bb_loop_depth (const_basic_block);\n \n /* Converts VAL to widest_int.  */"}, {"sha": "707a130d26a8b1452a16199fa9a5ce3dac8f21c5", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -1016,6 +1016,9 @@ copy_loop_info (struct loop *loop, struct loop *target)\n   gcc_checking_assert (!target->any_upper_bound && !target->any_estimate);\n   target->any_upper_bound = loop->any_upper_bound;\n   target->nb_iterations_upper_bound = loop->nb_iterations_upper_bound;\n+  target->any_likely_upper_bound = loop->any_likely_upper_bound;\n+  target->nb_iterations_likely_upper_bound\n+    = loop->nb_iterations_likely_upper_bound;\n   target->any_estimate = loop->any_estimate;\n   target->nb_iterations_estimate = loop->nb_iterations_estimate;\n   target->estimate_state = loop->estimate_state;"}, {"sha": "97735a89e5876188ce697554ae9bd5164bef0eeb", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -523,6 +523,11 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t    loop->nb_iterations_estimate -= exit_mod;\n \t  else\n \t    loop->any_estimate = false;\n+\t  if (loop->any_likely_upper_bound\n+\t      && wi::leu_p (exit_mod, loop->nb_iterations_likely_upper_bound))\n+\t    loop->nb_iterations_likely_upper_bound -= exit_mod;\n+\t  else\n+\t    loop->any_likely_upper_bound = false;\n \t}\n \n       bitmap_set_bit (wont_exit, 1);\n@@ -566,6 +571,11 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t    loop->nb_iterations_estimate -= exit_mod + 1;\n \t  else\n \t    loop->any_estimate = false;\n+\t  if (loop->any_likely_upper_bound\n+\t      && wi::leu_p (exit_mod + 1, loop->nb_iterations_likely_upper_bound))\n+\t    loop->nb_iterations_likely_upper_bound -= exit_mod + 1;\n+\t  else\n+\t    loop->any_likely_upper_bound = false;\n \t  desc->noloop_assumptions = NULL_RTX;\n \n \t  bitmap_set_bit (wont_exit, 0);\n@@ -619,6 +629,9 @@ unroll_loop_constant_iterations (struct loop *loop)\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n       = wi::udiv_trunc (loop->nb_iterations_estimate, max_unroll + 1);\n+  if (loop->any_likely_upper_bound)\n+    loop->nb_iterations_likely_upper_bound\n+      = wi::udiv_trunc (loop->nb_iterations_likely_upper_bound, max_unroll + 1);\n   desc->niter_expr = GEN_INT (desc->niter);\n \n   /* Remove the edges.  */\n@@ -1059,6 +1072,9 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n       = wi::udiv_trunc (loop->nb_iterations_estimate, max_unroll + 1);\n+  if (loop->any_likely_upper_bound)\n+    loop->nb_iterations_likely_upper_bound\n+      = wi::udiv_trunc (loop->nb_iterations_likely_upper_bound, max_unroll + 1);\n   if (exit_at_end)\n     {\n       desc->niter_expr =\n@@ -1070,6 +1086,11 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \t--loop->nb_iterations_estimate;\n       else\n \tloop->any_estimate = false;\n+      if (loop->any_likely_upper_bound\n+\t  && loop->nb_iterations_likely_upper_bound != 0)\n+\t--loop->nb_iterations_likely_upper_bound;\n+      else\n+\tloop->any_likely_upper_bound = false;\n     }\n \n   if (dump_file)"}, {"sha": "00db94eac6bead812e4b2c81fecec278ccdcf873", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -835,6 +835,9 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n       loop->any_upper_bound = streamer_read_hwi (ib);\n       if (loop->any_upper_bound)\n \tloop->nb_iterations_upper_bound = streamer_read_wi (ib);\n+      loop->any_likely_upper_bound = streamer_read_hwi (ib);\n+      if (loop->any_likely_upper_bound)\n+\tloop->nb_iterations_likely_upper_bound = streamer_read_wi (ib);\n       loop->any_estimate = streamer_read_hwi (ib);\n       if (loop->any_estimate)\n \tloop->nb_iterations_estimate = streamer_read_wi (ib);"}, {"sha": "ed6f7482dbdc5f13ad71b8e09f16932320a9a091", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -1925,6 +1925,9 @@ output_cfg (struct output_block *ob, struct function *fn)\n       streamer_write_hwi (ob, loop->any_upper_bound);\n       if (loop->any_upper_bound)\n \tstreamer_write_wi (ob, loop->nb_iterations_upper_bound);\n+      streamer_write_hwi (ob, loop->any_likely_upper_bound);\n+      if (loop->any_likely_upper_bound)\n+\tstreamer_write_wi (ob, loop->nb_iterations_likely_upper_bound);\n       streamer_write_hwi (ob, loop->any_estimate);\n       if (loop->any_estimate)\n \tstreamer_write_wi (ob, loop->nb_iterations_estimate);"}, {"sha": "de447f40e78576bf07894727b03db2b11332445b", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -1036,6 +1036,8 @@ try_peel_loop (struct loop *loop,\n     }\n   if (loop->any_upper_bound)\n     loop->nb_iterations_upper_bound -= npeel;\n+  if (loop->any_likely_upper_bound)\n+    loop->nb_iterations_likely_upper_bound -= npeel;\n   loop->nb_iterations_estimate = 0;\n   /* Make sure to mark loop cold so we do not try to peel it more.  */\n   scale_loop_profile (loop, 1, 0);\n@@ -1107,6 +1109,12 @@ canonicalize_loop_induction_variables (struct loop *loop,\n       fprintf (dump_file, \"Loop %d iterates at most %i times.\\n\", loop->num,\n \t       (int)maxiter);\n     }\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && likely_max_loop_iterations_int (loop) >= 0)\n+    {\n+      fprintf (dump_file, \"Loop likely %d iterates at most %i times.\\n\", loop->num,\n+\t       (int)likely_max_loop_iterations_int (loop));\n+    }\n \n   /* Remove exits that are known to be never taken based on loop bound.\n      Needs to be called after compilation of max_loop_iterations_int that"}, {"sha": "e38d2466bb470263fd9d9022f521973fe60f8eef", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -2289,7 +2289,11 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \n   /* If NITER has simplified into a constant, update MAX.  */\n   if (TREE_CODE (niter->niter) == INTEGER_CST)\n-    niter->max = wi::to_widest (niter->niter);\n+    {\n+      niter->max = wi::to_widest (niter->niter);\n+      record_niter_bound (loop, niter->max, loop_only_exit_p (loop, exit),\n+\t\t\t  true);\n+    }\n \n   if (integer_onep (niter->assumptions))\n     return true;\n@@ -2954,8 +2958,6 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n     realistic = false;\n   else\n     gcc_checking_assert (i_bound == wi::to_widest (bound));\n-  if (!upper && !realistic)\n-    return;\n \n   /* If we have a guaranteed upper bound, record it in the appropriate\n      list, unless this is an !is_exit bound (i.e. undefined behavior in\n@@ -2977,7 +2979,7 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n   /* If statement is executed on every path to the loop latch, we can directly\n      infer the upper bound on the # of iterations of the loop.  */\n   if (!dominated_by_p (CDI_DOMINATORS, loop->latch, gimple_bb (at_stmt)))\n-    return;\n+    upper = false;\n \n   /* Update the number of iteration estimates according to the bound.\n      If at_stmt is an exit then the loop latch is executed at most BOUND times,\n@@ -3850,6 +3852,41 @@ max_loop_iterations_int (struct loop *loop)\n   return hwi_nit < 0 ? -1 : hwi_nit;\n }\n \n+/* Sets NIT to an likely upper bound for the maximum number of executions of the\n+   latch of the LOOP.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n+{\n+  /* When SCEV information is available, try to update loop iterations\n+     estimate.  Otherwise just return whatever we recorded earlier.  */\n+  if (scev_initialized_p ())\n+    estimate_numbers_of_iterations_loop (loop);\n+\n+  return get_likely_max_loop_iterations (loop, nit);\n+}\n+\n+/* Similar to max_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+likely_max_loop_iterations_int (struct loop *loop)\n+{\n+  widest_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!likely_max_loop_iterations (loop, &nit))\n+    return -1;\n+\n+  if (!wi::fits_shwi_p (nit))\n+    return -1;\n+  hwi_nit = nit.to_shwi ();\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n+}\n+\n /* Returns an estimate for the number of executions of statements\n    in the LOOP.  For statements before the loop exit, this exceeds\n    the number of execution of the latch by one.  */\n@@ -3869,7 +3906,7 @@ estimated_stmt_executions_int (struct loop *loop)\n   return snit < 0 ? -1 : snit;\n }\n \n-/* Sets NIT to the estimated maximum number of executions of the latch of the\n+/* Sets NIT to the maximum number of executions of the latch of the\n    LOOP, plus one.  If we have no reliable estimate, the function returns\n    false, otherwise returns true.  */\n \n@@ -3888,6 +3925,25 @@ max_stmt_executions (struct loop *loop, widest_int *nit)\n   return wi::gtu_p (*nit, nit_minus_one);\n }\n \n+/* Sets NIT to the estimated maximum number of executions of the latch of the\n+   LOOP, plus one.  If we have no likely estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+likely_max_stmt_executions (struct loop *loop, widest_int *nit)\n+{\n+  widest_int nit_minus_one;\n+\n+  if (!likely_max_loop_iterations (loop, nit))\n+    return false;\n+\n+  nit_minus_one = *nit;\n+\n+  *nit += 1;\n+\n+  return wi::gtu_p (*nit, nit_minus_one);\n+}\n+\n /* Sets NIT to the estimated number of executions of the latch of the\n    LOOP, plus one.  If we have no reliable estimate, the function returns\n    false, otherwise returns true.  */"}, {"sha": "1b5d111bc3e665fe96f801035cff4c835455163d", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105e29c5cf8729021614b152328bcfe054bed64d/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=105e29c5cf8729021614b152328bcfe054bed64d", "patch": "@@ -35,9 +35,13 @@ extern bool estimated_loop_iterations (struct loop *, widest_int *);\n extern HOST_WIDE_INT estimated_loop_iterations_int (struct loop *);\n extern bool max_loop_iterations (struct loop *, widest_int *);\n extern HOST_WIDE_INT max_loop_iterations_int (struct loop *);\n+extern bool likely_max_loop_iterations (struct loop *, widest_int *);\n+extern HOST_WIDE_INT likely_max_loop_iterations_int (struct loop *);\n extern HOST_WIDE_INT max_stmt_executions_int (struct loop *);\n+extern HOST_WIDE_INT likely_max_stmt_executions_int (struct loop *);\n extern HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n extern bool max_stmt_executions (struct loop *, widest_int *);\n+extern bool likely_max_stmt_executions (struct loop *, widest_int *);\n extern bool estimated_stmt_executions (struct loop *, widest_int *);\n extern void estimate_numbers_of_iterations (void);\n extern bool stmt_dominates_stmt_p (gimple *, gimple *);"}]}