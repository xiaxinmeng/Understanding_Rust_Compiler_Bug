{"sha": "d9b7db1265b9f8285eabd73d6d9725db75ae309d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliN2RiMTI2NWI5ZjgyODVlYWJkNzNkNmQ5NzI1ZGI3NWFlMzA5ZA==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2004-01-26T17:40:06Z"}, "committer": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2004-01-26T17:40:06Z"}, "message": "Split slow unaligned load/store into smaller loads and stores.\n\nOKed by David Edelsohn.\n\nFrom-SVN: r76646", "tree": {"sha": "730f4f1d21d90dd65351ee7cc1f7b3fb7d097369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730f4f1d21d90dd65351ee7cc1f7b3fb7d097369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b7db1265b9f8285eabd73d6d9725db75ae309d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b7db1265b9f8285eabd73d6d9725db75ae309d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b7db1265b9f8285eabd73d6d9725db75ae309d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b7db1265b9f8285eabd73d6d9725db75ae309d/comments", "author": null, "committer": null, "parents": [{"sha": "11b25716763ef8ca1c8b8f05f11e9e7d0c093ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b25716763ef8ca1c8b8f05f11e9e7d0c093ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11b25716763ef8ca1c8b8f05f11e9e7d0c093ead"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "10a791e8dee80a8cf1bbc036b9ee0113b74a0677", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b7db1265b9f8285eabd73d6d9725db75ae309d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b7db1265b9f8285eabd73d6d9725db75ae309d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d9b7db1265b9f8285eabd73d6d9725db75ae309d", "patch": "@@ -3426,6 +3426,46 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t      adjust_address (operands[1], SImode, 4));\n       return;\n     }\n+    else if (mode == DImode && TARGET_POWERPC64\n+               && GET_CODE (operands[0]) == REG\n+               && GET_CODE (operands[1]) == MEM && optimize > 0\n+               && SLOW_UNALIGNED_ACCESS (DImode,\n+                                         MEM_ALIGN (operands[1]) > 32\n+                                         ? 32\n+                                         : MEM_ALIGN (operands[1]))\n+               && !no_new_pseudos)\n+      {\n+        rtx mem;\n+        rtx reg = gen_reg_rtx (SImode);\n+        mem = adjust_address (operands[1], SImode, 0);\n+        emit_insn (gen_rtx_SET (SImode, reg, mem));\n+        reg  = simplify_gen_subreg (DImode, reg, SImode, 0);\n+        emit_insn (gen_insvdi (operands[0], GEN_INT (32), const0_rtx, reg));\n+        reg = gen_reg_rtx (SImode);\n+        mem = adjust_address (operands[1], SImode, 4);\n+        emit_insn (gen_rtx_SET (SImode, reg, mem));\n+        reg  = simplify_gen_subreg (DImode, reg, SImode, 0);\n+        emit_insn (gen_insvdi (operands[0], GEN_INT (32), GEN_INT (32), reg));\n+        return;\n+      }\n+      else if (mode == DImode && TARGET_POWERPC64\n+               && GET_CODE (operands[1]) == REG\n+               && GET_CODE (operands[0]) == MEM && optimize > 0\n+               && SLOW_UNALIGNED_ACCESS (DImode,\n+                                         MEM_ALIGN (operands[0]) > 32\n+                                         ? 32\n+                                         : MEM_ALIGN (operands[0]))\n+               && !no_new_pseudos)\n+      {\n+        rtx mem;\n+        rtx reg = gen_reg_rtx (DImode);\n+        emit_move_insn (reg, gen_rtx_LSHIFTRT (DImode, operands[1], GEN_INT (32)));\n+        mem = adjust_address (operands[0], SImode, 0);\n+        emit_move_insn (mem, simplify_gen_subreg (SImode, reg, DImode, 0));\n+        mem = adjust_address (operands[0], SImode, 4);\n+        emit_move_insn (mem, simplify_gen_subreg (SImode, operands[1], DImode, 0));\n+        return;\n+      }\n   \n   if (!no_new_pseudos)\n     {"}]}