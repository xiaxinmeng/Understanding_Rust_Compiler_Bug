{"sha": "53d9622bda42facc4e456033b7a86e7bf102826a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkOTYyMmJkYTQyZmFjYzRlNDU2MDMzYjdhODZlN2JmMTAyODI2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-01-24T19:03:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-01-24T19:03:33Z"}, "message": "rtl.h (true_dependence, [...]): Remove varies parameter.\n\ngcc/\n\t* rtl.h (true_dependence, canon_true_dependence): Remove varies\n\tparameter.\n\t* alias.c (fixed_scalar_and_varying_struct_p): Delete.\n\t(true_dependence_1, write_dependence_p, may_alias_p): Don't call it.\n\t(true_dependence_1, true_dependence, canon_true_dependence): Remove\n\tvaries parameter.\n\t* cselib.c (cselib_rtx_varies_p): Delete.\n\t(cselib_invalidate_mem): Update call to canon_true_dependence.\n\t* dse.c (record_store, check_mem_read_rtx): Likewise.\n\t(scan_reads_nospill): Likewise.\n\t* cse.c (check_dependence): Likewise.\n\t(cse_rtx_varies_p): Delete.\n\t* expr.c (safe_from_p): Update call to true_dependence.\n\t* ira.c (validate_equiv_mem_from_store): Likewise.\n\t(memref_referenced_p): Likewise.\n\t* postreload-gcse.c (find_mem_conflicts): Likewise.\n\t* sched-deps.c (sched_analyze_2): Likewise.\n\t* store-motion.c (load_kills_store): Likewise.\n\t* config/frv/frv.c (frv_registers_conflict_p_1): Likewise.\n\t* gcse.c (mems_conflict_for_gcse_p): Likewise.\n\t(compute_transp): Update call to canon_true_dependence.\n\nFrom-SVN: r183485", "tree": {"sha": "6defecb75ee127af1ec9e7ad8fbce045bbce65f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6defecb75ee127af1ec9e7ad8fbce045bbce65f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53d9622bda42facc4e456033b7a86e7bf102826a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d9622bda42facc4e456033b7a86e7bf102826a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d9622bda42facc4e456033b7a86e7bf102826a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d9622bda42facc4e456033b7a86e7bf102826a/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8a27aa6319931d0d5317d8cd860e24a607cd442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a27aa6319931d0d5317d8cd860e24a607cd442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a27aa6319931d0d5317d8cd860e24a607cd442"}], "stats": {"total": 224, "additions": 53, "deletions": 171}, "files": [{"sha": "78160ad817217c01f3b0fd8fbb31936d9a6dea15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -1,3 +1,27 @@\n+2012-01-24  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (true_dependence, canon_true_dependence): Remove varies\n+\tparameter.\n+\t* alias.c (fixed_scalar_and_varying_struct_p): Delete.\n+\t(true_dependence_1, write_dependence_p, may_alias_p): Don't call it.\n+\t(true_dependence_1, true_dependence, canon_true_dependence): Remove\n+\tvaries parameter.\n+\t* cselib.c (cselib_rtx_varies_p): Delete.\n+\t(cselib_invalidate_mem): Update call to canon_true_dependence.\n+\t* dse.c (record_store, check_mem_read_rtx): Likewise.\n+\t(scan_reads_nospill): Likewise.\n+\t* cse.c (check_dependence): Likewise.\n+\t(cse_rtx_varies_p): Delete.\n+\t* expr.c (safe_from_p): Update call to true_dependence.\n+\t* ira.c (validate_equiv_mem_from_store): Likewise.\n+\t(memref_referenced_p): Likewise.\n+\t* postreload-gcse.c (find_mem_conflicts): Likewise.\n+\t* sched-deps.c (sched_analyze_2): Likewise.\n+\t* store-motion.c (load_kills_store): Likewise.\n+\t* config/frv/frv.c (frv_registers_conflict_p_1): Likewise.\n+\t* gcse.c (mems_conflict_for_gcse_p): Likewise.\n+\t(compute_transp): Update call to canon_true_dependence.\n+\n 2012-01-25  Richard Henderson  <rth@redhat.com>\n \n \t* optabs.c (CODE_FOR_atomic_test_and_set): Provide default."}, {"sha": "b9b9676b1736ec4e88a7abb14ae5c6ce1e70fc1b", "filename": "gcc/alias.c", "status": "modified", "additions": 8, "deletions": 67, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -157,8 +157,6 @@ static rtx find_base_value (rtx);\n static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n static int insert_subset_children (splay_tree_node, void*);\n static alias_set_entry get_alias_set_entry (alias_set_type);\n-static const_rtx fixed_scalar_and_varying_struct_p (const_rtx, const_rtx, rtx, rtx,\n-\t\t\t\t\t\t    bool (*) (const_rtx, bool));\n static int aliases_everything_p (const_rtx);\n static bool nonoverlapping_component_refs_p (const_tree, const_tree);\n static tree decl_for_component_ref (tree);\n@@ -2078,11 +2076,9 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n    changed.  A volatile and non-volatile reference can be interchanged\n    though.\n \n-   A MEM_IN_STRUCT reference at a non-AND varying address can never\n-   conflict with a non-MEM_IN_STRUCT reference at a fixed address.  We\n-   also must allow AND addresses, because they may generate accesses\n-   outside the object being referenced.  This is used to generate\n-   aligned addresses from unaligned addresses, for instance, the alpha\n+   We also must allow AND addresses, because they may generate accesses\n+   outside the object being referenced.  This is used to generate aligned\n+   addresses from unaligned addresses, for instance, the alpha\n    storeqi_unaligned pattern.  */\n \n /* Read dependence: X is read after read in MEM takes place.  There can\n@@ -2094,39 +2090,6 @@ read_dependence (const_rtx mem, const_rtx x)\n   return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n }\n \n-/* Returns MEM1 if and only if MEM1 is a scalar at a fixed address and\n-   MEM2 is a reference to a structure at a varying address, or returns\n-   MEM2 if vice versa.  Otherwise, returns NULL_RTX.  If a non-NULL\n-   value is returned MEM1 and MEM2 can never alias.  VARIES_P is used\n-   to decide whether or not an address may vary; it should return\n-   nonzero whenever variation is possible.\n-   MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */\n-\n-static const_rtx\n-fixed_scalar_and_varying_struct_p (const_rtx mem1, const_rtx mem2, rtx mem1_addr,\n-\t\t\t\t   rtx mem2_addr,\n-\t\t\t\t   bool (*varies_p) (const_rtx, bool))\n-{\n-  if (! flag_strict_aliasing)\n-    return NULL_RTX;\n-\n-  if (MEM_ALIAS_SET (mem2)\n-      && MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2)\n-      && !varies_p (mem1_addr, 1) && varies_p (mem2_addr, 1))\n-    /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a\n-       varying address.  */\n-    return mem1;\n-\n-  if (MEM_ALIAS_SET (mem1)\n-      && MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2)\n-      && varies_p (mem1_addr, 1) && !varies_p (mem2_addr, 1))\n-    /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a\n-       varying address.  */\n-    return mem2;\n-\n-  return NULL_RTX;\n-}\n-\n /* Returns nonzero if something about the mode or address format MEM1\n    indicates that it might well alias *anything*.  */\n \n@@ -2391,8 +2354,6 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n /* Helper for true_dependence and canon_true_dependence.\n    Checks for true dependence: X is read after store in MEM takes place.\n \n-   VARIES is the function that should be used as rtx_varies function.\n-\n    If MEM_CANONICALIZED is FALSE, then X_ADDR and MEM_ADDR should be\n    NULL_RTX, and the canonical addresses of MEM and X are both computed\n    here.  If MEM_CANONICALIZED, then MEM must be already canonicalized.\n@@ -2403,8 +2364,7 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n \n static int\n true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n-\t\t   const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool),\n-\t\t   bool mem_canonicalized)\n+\t\t   const_rtx x, rtx x_addr, bool mem_canonicalized)\n {\n   rtx base;\n   int ret;\n@@ -2496,21 +2456,16 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n     return 1;\n \n-  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr, varies))\n-    return 0;\n-\n   return rtx_refs_may_alias_p (x, mem, true);\n }\n \n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n-true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n-\t\t bool (*varies) (const_rtx, bool))\n+true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x)\n {\n   return true_dependence_1 (mem, mem_mode, NULL_RTX,\n-\t\t\t    x, NULL_RTX, varies,\n-\t\t\t    /*mem_canonicalized=*/false);\n+\t\t\t    x, NULL_RTX, /*mem_canonicalized=*/false);\n }\n \n /* Canonical true dependence: X is read after store in MEM takes place.\n@@ -2521,11 +2476,10 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n \n int\n canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n-\t\t       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))\n+\t\t       const_rtx x, rtx x_addr)\n {\n   return true_dependence_1 (mem, mem_mode, mem_addr,\n-\t\t\t    x, x_addr, varies,\n-\t\t\t    /*mem_canonicalized=*/true);\n+\t\t\t    x, x_addr, /*mem_canonicalized=*/true);\n }\n \n /* Returns nonzero if a write to X might alias a previous read from\n@@ -2535,7 +2489,6 @@ static int\n write_dependence_p (const_rtx mem, const_rtx x, int writep)\n {\n   rtx x_addr, mem_addr;\n-  const_rtx fixed_scalar;\n   rtx base;\n   int ret;\n \n@@ -2598,14 +2551,6 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   if (nonoverlapping_memrefs_p (x, mem, false))\n     return 0;\n \n-  fixed_scalar\n-    = fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n-\t\t\t\t\t rtx_addr_varies_p);\n-\n-  if ((fixed_scalar == mem && !aliases_everything_p (x))\n-      || (fixed_scalar == x && !aliases_everything_p (mem)))\n-    return 0;\n-\n   return rtx_refs_may_alias_p (x, mem, false);\n }\n \n@@ -2687,10 +2632,6 @@ may_alias_p (const_rtx mem, const_rtx x)\n   if (GET_CODE (mem_addr) == AND)\n     return 1;\n \n-  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n-                                         rtx_addr_varies_p))\n-    return 0;\n-\n   /* TBAA not valid for loop_invarint */\n   return rtx_refs_may_alias_p (x, mem, false);\n }"}, {"sha": "1354d374396d466a99a5ab08618ec28cd6937315", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -7229,8 +7229,7 @@ frv_registers_conflict_p_1 (rtx *x, void *data)\n       for (i = 0; i < frv_packet.num_mems; i++)\n \tif (frv_regstate_conflict_p (frv_packet.mems[i].cond, cond))\n \t  {\n-\t    if (true_dependence (frv_packet.mems[i].mem, VOIDmode,\n-\t\t\t\t *x, rtx_varies_p))\n+\t    if (true_dependence (frv_packet.mems[i].mem, VOIDmode, *x))\n \t      return 1;\n \n \t    if (output_dependence (frv_packet.mems[i].mem, *x))"}, {"sha": "6424bb1864f61e3b050ed31adea2c78908827dfe", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -573,7 +573,6 @@ static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n \t\t\t\t enum machine_mode);\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n static void invalidate (rtx, enum machine_mode);\n-static bool cse_rtx_varies_p (const_rtx, bool);\n static void remove_invalid_refs (unsigned int);\n static void remove_invalid_subreg_refs (unsigned int, unsigned int,\n \t\t\t\t\tenum machine_mode);\n@@ -1846,8 +1845,7 @@ check_dependence (rtx *x, void *data)\n {\n   struct check_dependence_data *d = (struct check_dependence_data *) data;\n   if (*x && MEM_P (*x))\n-    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX,\n-\t\t    \t\t  cse_rtx_varies_p);\n+    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX);\n   else\n     return 0;\n }\n@@ -2794,67 +2792,6 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n   return 1;\n }\n \f\n-/* Return 1 if X has a value that can vary even between two\n-   executions of the program.  0 means X can be compared reliably\n-   against certain constants or near-constants.  */\n-\n-static bool\n-cse_rtx_varies_p (const_rtx x, bool from_alias)\n-{\n-  /* We need not check for X and the equivalence class being of the same\n-     mode because if X is equivalent to a constant in some mode, it\n-     doesn't vary in any mode.  */\n-\n-  if (REG_P (x)\n-      && REGNO_QTY_VALID_P (REGNO (x)))\n-    {\n-      int x_q = REG_QTY (REGNO (x));\n-      struct qty_table_elem *x_ent = &qty_table[x_q];\n-\n-      if (GET_MODE (x) == x_ent->mode\n-\t  && x_ent->const_rtx != NULL_RTX)\n-\treturn 0;\n-    }\n-\n-  if (GET_CODE (x) == PLUS\n-      && CONST_INT_P (XEXP (x, 1))\n-      && REG_P (XEXP (x, 0))\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n-    {\n-      int x0_q = REG_QTY (REGNO (XEXP (x, 0)));\n-      struct qty_table_elem *x0_ent = &qty_table[x0_q];\n-\n-      if ((GET_MODE (XEXP (x, 0)) == x0_ent->mode)\n-\t  && x0_ent->const_rtx != NULL_RTX)\n-\treturn 0;\n-    }\n-\n-  /* This can happen as the result of virtual register instantiation, if\n-     the initial constant is too large to be a valid address.  This gives\n-     us a three instruction sequence, load large offset into a register,\n-     load fp minus a constant into a register, then a MEM which is the\n-     sum of the two `constant' registers.  */\n-  if (GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x, 0))\n-      && REG_P (XEXP (x, 1))\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n-    {\n-      int x0_q = REG_QTY (REGNO (XEXP (x, 0)));\n-      int x1_q = REG_QTY (REGNO (XEXP (x, 1)));\n-      struct qty_table_elem *x0_ent = &qty_table[x0_q];\n-      struct qty_table_elem *x1_ent = &qty_table[x1_q];\n-\n-      if ((GET_MODE (XEXP (x, 0)) == x0_ent->mode)\n-\t  && x0_ent->const_rtx != NULL_RTX\n-\t  && (GET_MODE (XEXP (x, 1)) == x1_ent->mode)\n-\t  && x1_ent->const_rtx != NULL_RTX)\n-\treturn 0;\n-    }\n-\n-  return rtx_varies_p (x, from_alias);\n-}\n-\f\n /* Subroutine of canon_reg.  Pass *XLOC through canon_reg, and validate\n    the result if necessary.  INSN is as for canon_reg.  */\n "}, {"sha": "0c3b3a38e06e7ecc9ba55b8d1b426f3aacd86c42", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -2172,20 +2172,6 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n     }\n }\n \f\n-/* Return 1 if X has a value that can vary even between two\n-   executions of the program.  0 means X can be compared reliably\n-   against certain constants or near-constants.  */\n-\n-static bool\n-cselib_rtx_varies_p (const_rtx x ATTRIBUTE_UNUSED, bool from_alias ATTRIBUTE_UNUSED)\n-{\n-  /* We actually don't need to verify very hard.  This is because\n-     if X has actually changed, we invalidate the memory anyway,\n-     so assume that all common memory addresses are\n-     invariant.  */\n-  return 0;\n-}\n-\n /* Invalidate any locations in the table which are changed because of a\n    store to MEM_RTX.  If this is called because of a non-const call\n    instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n@@ -2222,8 +2208,8 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t      continue;\n \t    }\n \t  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)\n-\t      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,\n-\t\t      \t\t\t  x, NULL_RTX, cselib_rtx_varies_p))\n+\t      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx),\n+\t\t\t\t\t  mem_addr, x, NULL_RTX))\n \t    {\n \t      has_mem = true;\n \t      num_mems++;"}, {"sha": "a9fe9249369c8c296cdfd04e89a87627341f6745", "filename": "gcc/dse.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -1682,7 +1682,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t  if (canon_true_dependence (s_info->mem,\n \t\t\t\t     GET_MODE (s_info->mem),\n \t\t\t\t     s_info->mem_addr,\n-\t\t\t\t     mem, mem_addr, rtx_varies_p))\n+\t\t\t\t     mem, mem_addr))\n \t    {\n \t      s_info->rhs = NULL;\n \t      s_info->const_rhs = NULL;\n@@ -2279,7 +2279,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t      = canon_true_dependence (store_info->mem,\n \t\t\t\t       GET_MODE (store_info->mem),\n \t\t\t\t       store_info->mem_addr,\n-\t\t\t\t       mem, mem_addr, rtx_varies_p);\n+\t\t\t\t       mem, mem_addr);\n \n \t  else if (group_id == store_info->group_id)\n \t    {\n@@ -2290,7 +2290,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t\t  = canon_true_dependence (store_info->mem,\n \t\t\t\t\t   GET_MODE (store_info->mem),\n \t\t\t\t\t   store_info->mem_addr,\n-\t\t\t\t\t   mem, mem_addr, rtx_varies_p);\n+\t\t\t\t\t   mem, mem_addr);\n \n \t      /* If this read is just reading back something that we just\n \t\t stored, rewrite the read.  */\n@@ -2377,7 +2377,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t    remove = canon_true_dependence (store_info->mem,\n \t\t\t\t\t    GET_MODE (store_info->mem),\n \t\t\t\t\t    store_info->mem_addr,\n-\t\t\t\t\t    mem, mem_addr, rtx_varies_p);\n+\t\t\t\t\t    mem, mem_addr);\n \n \t  if (remove)\n \t    {\n@@ -3276,8 +3276,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t\t      && canon_true_dependence (group->base_mem,\n \t\t\t\t\t\tGET_MODE (group->base_mem),\n \t\t\t\t\t\tgroup->canon_base_addr,\n-\t\t\t\t\t\tread_info->mem, NULL_RTX,\n-\t\t\t\t\t\trtx_varies_p))\n+\t\t\t\t\t\tread_info->mem, NULL_RTX))\n \t\t    {\n \t\t      if (kill)\n \t\t\tbitmap_ior_into (kill, group->group_kill);"}, {"sha": "df8bceb0f4862c859d6ec13e88663768e39c5ba5", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -7200,8 +7200,7 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n \t are memory and they conflict.  */\n       return ! (rtx_equal_p (x, exp_rtl)\n \t\t|| (MEM_P (x) && MEM_P (exp_rtl)\n-\t\t    && true_dependence (exp_rtl, VOIDmode, x,\n-\t\t\t\t\trtx_addr_varies_p)));\n+\t\t    && true_dependence (exp_rtl, VOIDmode, x)));\n     }\n \n   /* If we reach here, it is safe.  */"}, {"sha": "6f149bb402f8061ad36018b6a5fc2a9ff4cd8849", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -968,7 +968,7 @@ mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n       return;\n     }\n \n-  if (true_dependence (dest, GET_MODE (dest), mci->mem, rtx_addr_varies_p))\n+  if (true_dependence (dest, GET_MODE (dest), mci->mem))\n     mci->conflict = true;\n }\n \n@@ -1682,8 +1682,8 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n \t\t    rtx dest = pair->dest;\n \t\t    rtx dest_addr = pair->dest_addr;\n \n-\t\t    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n-\t\t\t\t\t       x, NULL_RTX, rtx_addr_varies_p))\n+\t\t    if (canon_true_dependence (dest, GET_MODE (dest),\n+\t\t\t\t\t       dest_addr, x, NULL_RTX))\n \t\t      RESET_BIT (bmap[bb_index], indx);\n \t          }\n \t      }"}, {"sha": "2bdf9fd7fb6d8fd5223b02005d7e6ea006e8c08e", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -2335,7 +2335,7 @@ validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n   if ((REG_P (dest)\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n       || (MEM_P (dest)\n-\t  && true_dependence (dest, VOIDmode, equiv_mem, rtx_varies_p)))\n+\t  && true_dependence (dest, VOIDmode, equiv_mem)))\n     equiv_mem_modified = 1;\n }\n \n@@ -2589,7 +2589,7 @@ memref_referenced_p (rtx memref, rtx x)\n \t\t\t\t      reg_equiv[REGNO (x)].replacement));\n \n     case MEM:\n-      if (true_dependence (memref, VOIDmode, x, rtx_varies_p))\n+      if (true_dependence (memref, VOIDmode, x))\n \treturn 1;\n       break;\n "}, {"sha": "16f3f68e571b23339eea2d0351337b883a3ee410", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -589,8 +589,7 @@ find_mem_conflicts (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n   if (! MEM_P (dest))\n     return;\n \n-  if (true_dependence (dest, GET_MODE (dest), mem_op,\n-\t\t       rtx_addr_varies_p))\n+  if (true_dependence (dest, GET_MODE (dest), mem_op))\n     mems_conflict_p = 1;\n }\n \f"}, {"sha": "858224da74c44d700dba79b433905b9a9087921e", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -2602,10 +2602,10 @@ extern bool read_rtx (const char *, rtx *);\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);\n-extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));\n+extern int true_dependence (const_rtx, enum machine_mode, const_rtx);\n extern rtx get_addr (rtx);\n-extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,\n-\t\t\t\t  rtx, bool (*)(const_rtx, bool));\n+extern int canon_true_dependence (const_rtx, enum machine_mode, rtx,\n+\t\t\t\t  const_rtx, rtx);\n extern int read_dependence (const_rtx, const_rtx);\n extern int anti_dependence (const_rtx, const_rtx);\n extern int output_dependence (const_rtx, const_rtx);"}, {"sha": "bf042a495229deddfa6266f6742d84459cf8014c", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -2636,8 +2636,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n \t    pending_mem = deps->pending_write_mems;\n \t    while (pending)\n \t      {\n-\t\tif (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n-\t\t\t\t     t, rtx_varies_p)\n+\t\tif (true_dependence (XEXP (pending_mem, 0), VOIDmode, t)\n \t\t    && ! sched_insns_conditions_mutex_p (insn,\n \t\t\t\t\t\t\t XEXP (pending, 0)))\n \t\t  note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),"}, {"sha": "03b2c3d4c841afd6362c8588c9441ef07e1474b4", "filename": "gcc/store-motion.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d9622bda42facc4e456033b7a86e7bf102826a/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=53d9622bda42facc4e456033b7a86e7bf102826a", "patch": "@@ -309,8 +309,7 @@ load_kills_store (const_rtx x, const_rtx store_pattern, int after)\n   if (after)\n     return anti_dependence (x, store_pattern);\n   else\n-    return true_dependence (store_pattern, GET_MODE (store_pattern), x,\n-\t\t\t    rtx_addr_varies_p);\n+    return true_dependence (store_pattern, GET_MODE (store_pattern), x);\n }\n \n /* Go through the entire rtx X, looking for any loads which might alias"}]}