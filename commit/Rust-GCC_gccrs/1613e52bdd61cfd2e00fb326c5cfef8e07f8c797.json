{"sha": "1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYxM2U1MmJkZDYxY2ZkMmUwMGZiMzI2YzVjZmVmOGUwN2Y4Yzc5Nw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-20T07:29:23Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-20T07:29:23Z"}, "message": "Makefile.in (LIBCPP_OBJS): Add cppcharset.o.\n\n\t* Makefile.in (LIBCPP_OBJS): Add cppcharset.o.\n\t(cppcharset.o): New target.\n\t* c-lex.c (is_extended_char): Move to cppcharset.c.\n\t(utf8_extend_token): Delete.\n\t* cppcharset.c: New file.\n\t* cpphash.h (_cpp_valid_ucn): New.\n\t* cpplex.c (lex_identifier): Update prototype.\n\t(continues_identifier_p): Rename forms_identifier_p.  Handle UCN\n\tescapes.\n\t(maybe_read_ucs): Rename maybe_read_ucn.  Update to use code\n\tin cppcharset.c.\n\t(lex_number, lex_identifier, cpp_parse_escape): Update.\n\t(_cpp_lex_direct): Update to handle UCNs.\n\t(cpp_avoid_paste): Don't paste to form a UCN.\ntestsuite:\n\t* ucs.c: Update diagnostic messages.\n\nFrom-SVN: r65845", "tree": {"sha": "01f484dfa9250821cfb9113a0a797ca2bec80e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01f484dfa9250821cfb9113a0a797ca2bec80e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a45ec5c78e634e129fe3e9bbcddf6b721a10ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a45ec5c78e634e129fe3e9bbcddf6b721a10ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a45ec5c78e634e129fe3e9bbcddf6b721a10ca8"}], "stats": {"total": 1129, "additions": 704, "deletions": 425}, "files": [{"sha": "b4c3a777fedcd6adcc26b41a3137fdca3f929036", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -1,3 +1,20 @@\n+2003-04-20  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in (LIBCPP_OBJS): Add cppcharset.o.\n+\t(cppcharset.o): New target.\n+\t* c-lex.c (is_extended_char): Move to cppcharset.c.\n+\t(utf8_extend_token): Delete.\n+\t* cppcharset.c: New file.\n+\t* cpphash.h (_cpp_valid_ucn): New.\n+\t* cpplex.c (lex_identifier): Update prototype.\n+\t(continues_identifier_p): Rename forms_identifier_p.  Handle UCN\n+\tescapes.\n+\t(maybe_read_ucs): Rename maybe_read_ucn.  Update to use code\n+\tin cppcharset.c.\n+\t(lex_number, lex_identifier, cpp_parse_escape): Update.\n+\t(_cpp_lex_direct): Update to handle UCNs.\n+\t(cpp_avoid_paste): Don't paste to form a UCN.\n+\n 2003-04-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (expand_builtin):  Don't expand a pure or const"}, {"sha": "ceff352623b5b796093f1499d2ccafc1b6e5a6af", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -2320,7 +2320,7 @@ PREPROCESSOR_DEFINES = \\\n   @TARGET_SYSTEM_ROOT_DEFINE@\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n-\t\tcpphash.o cpperror.o cppinit.o \\\n+\t\tcpphash.o cpperror.o cppinit.o cppcharset.o \\\n \t\thashtable.o line-map.o mkdeps.o mbchar.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n@@ -2333,6 +2333,7 @@ libcpp.a: $(LIBCPP_OBJS)\n \t$(AR) $(AR_FLAGS) libcpp.a $(LIBCPP_OBJS)\n \t-$(RANLIB) libcpp.a\n \n+cppcharset.o: cppcharset.c $(LIBCPP_DEPS)\n cpperror.o: cpperror.c $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(LIBCPP_DEPS) mbchar.h"}, {"sha": "ec16c15397f2c7a7ed15a656741c96fcb89bf5e3", "filename": "gcc/c-lex.c", "status": "modified", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -322,315 +322,6 @@ cb_undef (pfile, line, node)\n   (*debug_hooks->undef) (SOURCE_LINE (map, line),\n \t\t\t (const char *) NODE_NAME (node));\n }\n-\n-#if 0 /* not yet */\n-/* Returns nonzero if C is a universal-character-name.  Give an error if it\n-   is not one which may appear in an identifier, as per [extendid].\n-\n-   Note that extended character support in identifiers has not yet been\n-   implemented.  It is my personal opinion that this is not a desirable\n-   feature.  Portable code cannot count on support for more than the basic\n-   identifier character set.  */\n-\n-static inline int\n-is_extended_char (c)\n-     int c;\n-{\n-#ifdef TARGET_EBCDIC\n-  return 0;\n-#else\n-  /* ASCII.  */\n-  if (c < 0x7f)\n-    return 0;\n-\n-  /* None of the valid chars are outside the Basic Multilingual Plane (the\n-     low 16 bits).  */\n-  if (c > 0xffff)\n-    {\n-      error (\"universal-character-name '\\\\U%08x' not valid in identifier\", c);\n-      return 1;\n-    }\n-  \n-  /* Latin */\n-  if ((c >= 0x00c0 && c <= 0x00d6)\n-      || (c >= 0x00d8 && c <= 0x00f6)\n-      || (c >= 0x00f8 && c <= 0x01f5)\n-      || (c >= 0x01fa && c <= 0x0217)\n-      || (c >= 0x0250 && c <= 0x02a8)\n-      || (c >= 0x1e00 && c <= 0x1e9a)\n-      || (c >= 0x1ea0 && c <= 0x1ef9))\n-    return 1;\n-\n-  /* Greek */\n-  if ((c == 0x0384)\n-      || (c >= 0x0388 && c <= 0x038a)\n-      || (c == 0x038c)\n-      || (c >= 0x038e && c <= 0x03a1)\n-      || (c >= 0x03a3 && c <= 0x03ce)\n-      || (c >= 0x03d0 && c <= 0x03d6)\n-      || (c == 0x03da)\n-      || (c == 0x03dc)\n-      || (c == 0x03de)\n-      || (c == 0x03e0)\n-      || (c >= 0x03e2 && c <= 0x03f3)\n-      || (c >= 0x1f00 && c <= 0x1f15)\n-      || (c >= 0x1f18 && c <= 0x1f1d)\n-      || (c >= 0x1f20 && c <= 0x1f45)\n-      || (c >= 0x1f48 && c <= 0x1f4d)\n-      || (c >= 0x1f50 && c <= 0x1f57)\n-      || (c == 0x1f59)\n-      || (c == 0x1f5b)\n-      || (c == 0x1f5d)\n-      || (c >= 0x1f5f && c <= 0x1f7d)\n-      || (c >= 0x1f80 && c <= 0x1fb4)\n-      || (c >= 0x1fb6 && c <= 0x1fbc)\n-      || (c >= 0x1fc2 && c <= 0x1fc4)\n-      || (c >= 0x1fc6 && c <= 0x1fcc)\n-      || (c >= 0x1fd0 && c <= 0x1fd3)\n-      || (c >= 0x1fd6 && c <= 0x1fdb)\n-      || (c >= 0x1fe0 && c <= 0x1fec)\n-      || (c >= 0x1ff2 && c <= 0x1ff4)\n-      || (c >= 0x1ff6 && c <= 0x1ffc))\n-    return 1;\n-\n-  /* Cyrillic */\n-  if ((c >= 0x0401 && c <= 0x040d)\n-      || (c >= 0x040f && c <= 0x044f)\n-      || (c >= 0x0451 && c <= 0x045c)\n-      || (c >= 0x045e && c <= 0x0481)\n-      || (c >= 0x0490 && c <= 0x04c4)\n-      || (c >= 0x04c7 && c <= 0x04c8)\n-      || (c >= 0x04cb && c <= 0x04cc)\n-      || (c >= 0x04d0 && c <= 0x04eb)\n-      || (c >= 0x04ee && c <= 0x04f5)\n-      || (c >= 0x04f8 && c <= 0x04f9))\n-    return 1;\n-\n-  /* Armenian */\n-  if ((c >= 0x0531 && c <= 0x0556)\n-      || (c >= 0x0561 && c <= 0x0587))\n-    return 1;\n-\n-  /* Hebrew */\n-  if ((c >= 0x05d0 && c <= 0x05ea)\n-      || (c >= 0x05f0 && c <= 0x05f4))\n-    return 1;\n-\n-  /* Arabic */\n-  if ((c >= 0x0621 && c <= 0x063a)\n-      || (c >= 0x0640 && c <= 0x0652)\n-      || (c >= 0x0670 && c <= 0x06b7)\n-      || (c >= 0x06ba && c <= 0x06be)\n-      || (c >= 0x06c0 && c <= 0x06ce)\n-      || (c >= 0x06e5 && c <= 0x06e7))\n-    return 1;\n-\n-  /* Devanagari */\n-  if ((c >= 0x0905 && c <= 0x0939)\n-      || (c >= 0x0958 && c <= 0x0962))\n-    return 1;\n-\n-  /* Bengali */\n-  if ((c >= 0x0985 && c <= 0x098c)\n-      || (c >= 0x098f && c <= 0x0990)\n-      || (c >= 0x0993 && c <= 0x09a8)\n-      || (c >= 0x09aa && c <= 0x09b0)\n-      || (c == 0x09b2)\n-      || (c >= 0x09b6 && c <= 0x09b9)\n-      || (c >= 0x09dc && c <= 0x09dd)\n-      || (c >= 0x09df && c <= 0x09e1)\n-      || (c >= 0x09f0 && c <= 0x09f1))\n-    return 1;\n-\n-  /* Gurmukhi */\n-  if ((c >= 0x0a05 && c <= 0x0a0a)\n-      || (c >= 0x0a0f && c <= 0x0a10)\n-      || (c >= 0x0a13 && c <= 0x0a28)\n-      || (c >= 0x0a2a && c <= 0x0a30)\n-      || (c >= 0x0a32 && c <= 0x0a33)\n-      || (c >= 0x0a35 && c <= 0x0a36)\n-      || (c >= 0x0a38 && c <= 0x0a39)\n-      || (c >= 0x0a59 && c <= 0x0a5c)\n-      || (c == 0x0a5e))\n-    return 1;\n-\n-  /* Gujarati */\n-  if ((c >= 0x0a85 && c <= 0x0a8b)\n-      || (c == 0x0a8d)\n-      || (c >= 0x0a8f && c <= 0x0a91)\n-      || (c >= 0x0a93 && c <= 0x0aa8)\n-      || (c >= 0x0aaa && c <= 0x0ab0)\n-      || (c >= 0x0ab2 && c <= 0x0ab3)\n-      || (c >= 0x0ab5 && c <= 0x0ab9)\n-      || (c == 0x0ae0))\n-    return 1;\n-\n-  /* Oriya */\n-  if ((c >= 0x0b05 && c <= 0x0b0c)\n-      || (c >= 0x0b0f && c <= 0x0b10)\n-      || (c >= 0x0b13 && c <= 0x0b28)\n-      || (c >= 0x0b2a && c <= 0x0b30)\n-      || (c >= 0x0b32 && c <= 0x0b33)\n-      || (c >= 0x0b36 && c <= 0x0b39)\n-      || (c >= 0x0b5c && c <= 0x0b5d)\n-      || (c >= 0x0b5f && c <= 0x0b61))\n-    return 1;\n-\n-  /* Tamil */\n-  if ((c >= 0x0b85 && c <= 0x0b8a)\n-      || (c >= 0x0b8e && c <= 0x0b90)\n-      || (c >= 0x0b92 && c <= 0x0b95)\n-      || (c >= 0x0b99 && c <= 0x0b9a)\n-      || (c == 0x0b9c)\n-      || (c >= 0x0b9e && c <= 0x0b9f)\n-      || (c >= 0x0ba3 && c <= 0x0ba4)\n-      || (c >= 0x0ba8 && c <= 0x0baa)\n-      || (c >= 0x0bae && c <= 0x0bb5)\n-      || (c >= 0x0bb7 && c <= 0x0bb9))\n-    return 1;\n-\n-  /* Telugu */\n-  if ((c >= 0x0c05 && c <= 0x0c0c)\n-      || (c >= 0x0c0e && c <= 0x0c10)\n-      || (c >= 0x0c12 && c <= 0x0c28)\n-      || (c >= 0x0c2a && c <= 0x0c33)\n-      || (c >= 0x0c35 && c <= 0x0c39)\n-      || (c >= 0x0c60 && c <= 0x0c61))\n-    return 1;\n-\n-  /* Kannada */\n-  if ((c >= 0x0c85 && c <= 0x0c8c)\n-      || (c >= 0x0c8e && c <= 0x0c90)\n-      || (c >= 0x0c92 && c <= 0x0ca8)\n-      || (c >= 0x0caa && c <= 0x0cb3)\n-      || (c >= 0x0cb5 && c <= 0x0cb9)\n-      || (c >= 0x0ce0 && c <= 0x0ce1))\n-    return 1;\n-\n-  /* Malayalam */\n-  if ((c >= 0x0d05 && c <= 0x0d0c)\n-      || (c >= 0x0d0e && c <= 0x0d10)\n-      || (c >= 0x0d12 && c <= 0x0d28)\n-      || (c >= 0x0d2a && c <= 0x0d39)\n-      || (c >= 0x0d60 && c <= 0x0d61))\n-    return 1;\n-\n-  /* Thai */\n-  if ((c >= 0x0e01 && c <= 0x0e30)\n-      || (c >= 0x0e32 && c <= 0x0e33)\n-      || (c >= 0x0e40 && c <= 0x0e46)\n-      || (c >= 0x0e4f && c <= 0x0e5b))\n-    return 1;\n-\n-  /* Lao */\n-  if ((c >= 0x0e81 && c <= 0x0e82)\n-      || (c == 0x0e84)\n-      || (c == 0x0e87)\n-      || (c == 0x0e88)\n-      || (c == 0x0e8a)\n-      || (c == 0x0e0d)\n-      || (c >= 0x0e94 && c <= 0x0e97)\n-      || (c >= 0x0e99 && c <= 0x0e9f)\n-      || (c >= 0x0ea1 && c <= 0x0ea3)\n-      || (c == 0x0ea5)\n-      || (c == 0x0ea7)\n-      || (c == 0x0eaa)\n-      || (c == 0x0eab)\n-      || (c >= 0x0ead && c <= 0x0eb0)\n-      || (c == 0x0eb2)\n-      || (c == 0x0eb3)\n-      || (c == 0x0ebd)\n-      || (c >= 0x0ec0 && c <= 0x0ec4)\n-      || (c == 0x0ec6))\n-    return 1;\n-\n-  /* Georgian */\n-  if ((c >= 0x10a0 && c <= 0x10c5)\n-      || (c >= 0x10d0 && c <= 0x10f6))\n-    return 1;\n-\n-  /* Hiragana */\n-  if ((c >= 0x3041 && c <= 0x3094)\n-      || (c >= 0x309b && c <= 0x309e))\n-    return 1;\n-\n-  /* Katakana */\n-  if ((c >= 0x30a1 && c <= 0x30fe))\n-    return 1;\n-\n-  /* Bopmofo */\n-  if ((c >= 0x3105 && c <= 0x312c))\n-    return 1;\n-\n-  /* Hangul */\n-  if ((c >= 0x1100 && c <= 0x1159)\n-      || (c >= 0x1161 && c <= 0x11a2)\n-      || (c >= 0x11a8 && c <= 0x11f9))\n-    return 1;\n-\n-  /* CJK Unified Ideographs */\n-  if ((c >= 0xf900 && c <= 0xfa2d)\n-      || (c >= 0xfb1f && c <= 0xfb36)\n-      || (c >= 0xfb38 && c <= 0xfb3c)\n-      || (c == 0xfb3e)\n-      || (c >= 0xfb40 && c <= 0xfb41)\n-      || (c >= 0xfb42 && c <= 0xfb44)\n-      || (c >= 0xfb46 && c <= 0xfbb1)\n-      || (c >= 0xfbd3 && c <= 0xfd3f)\n-      || (c >= 0xfd50 && c <= 0xfd8f)\n-      || (c >= 0xfd92 && c <= 0xfdc7)\n-      || (c >= 0xfdf0 && c <= 0xfdfb)\n-      || (c >= 0xfe70 && c <= 0xfe72)\n-      || (c == 0xfe74)\n-      || (c >= 0xfe76 && c <= 0xfefc)\n-      || (c >= 0xff21 && c <= 0xff3a)\n-      || (c >= 0xff41 && c <= 0xff5a)\n-      || (c >= 0xff66 && c <= 0xffbe)\n-      || (c >= 0xffc2 && c <= 0xffc7)\n-      || (c >= 0xffca && c <= 0xffcf)\n-      || (c >= 0xffd2 && c <= 0xffd7)\n-      || (c >= 0xffda && c <= 0xffdc)\n-      || (c >= 0x4e00 && c <= 0x9fa5))\n-    return 1;\n-\n-  error (\"universal-character-name '\\\\u%04x' not valid in identifier\", c);\n-  return 1;\n-#endif\n-}\n-\n-/* Add the UTF-8 representation of C to the token_buffer.  */\n-\n-static void\n-utf8_extend_token (c)\n-     int c;\n-{\n-  int shift, mask;\n-\n-  if      (c <= 0x0000007f)\n-    {\n-      extend_token (c);\n-      return;\n-    }\n-  else if (c <= 0x000007ff)\n-    shift = 6, mask = 0xc0;\n-  else if (c <= 0x0000ffff)\n-    shift = 12, mask = 0xe0;\n-  else if (c <= 0x001fffff)\n-    shift = 18, mask = 0xf0;\n-  else if (c <= 0x03ffffff)\n-    shift = 24, mask = 0xf8;\n-  else\n-    shift = 30, mask = 0xfc;\n-\n-  extend_token (mask | (c >> shift));\n-  do\n-    {\n-      shift -= 6;\n-      extend_token ((unsigned char) (0x80 | (c >> shift)));\n-    }\n-  while (shift);\n-}\n-#endif\n \f\n int\n c_lex (value)"}, {"sha": "900e4516fbcf885668777b4044fe502bf7d6a96e", "filename": "gcc/cppcharset.c", "status": "added", "additions": 591, "deletions": 0, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -0,0 +1,591 @@\n+/* CPP Library - charsets\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n+\n+   Broken out of c-lex.c Apr 2003, adding valid C99 UCN ranges.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+static int ucn_valid_in_identifier PARAMS ((cpp_reader *, cppchar_t));\n+\n+/* [lex.charset]: The character designated by the universal character\n+   name \\UNNNNNNNN is that character whose character short name in\n+   ISO/IEC 10646 is NNNNNNNN; the character designated by the\n+   universal character name \\uNNNN is that character whose character\n+   short name in ISO/IEC 10646 is 0000NNNN.  If the hexadecimal value\n+   for a universal character name is less than 0x20 or in the range\n+   0x7F-0x9F (inclusive), or if the universal character name\n+   designates a character in the basic source character set, then the\n+   program is ill-formed.\n+\n+   *PSTR must be preceded by \"\\u\" or \"\\U\"; it is assumed that the\n+   buffer end is delimited by a non-hex digit.  Returns zero if UCNs\n+   are not part of the relevant standard, or if the string beginning\n+   at *PSTR doesn't syntactically match the form 'NNNN' or 'NNNNNNNN'.\n+\n+   Otherwise the non-zero value of the UCN, whether valid or invalid,\n+   is returned.  Diagnostics are emitted for invalid values.  PSTR\n+   is updated to point one beyond the UCN, or to the syntactically\n+   invalid character.\n+\n+   IDENTIFIER_POS is 0 when not in an identifier, 1 for the start of\n+   an identifier, or 2 otherwise.\n+*/\n+\n+cppchar_t\n+_cpp_valid_ucn (pfile, pstr, identifier_pos)\n+     cpp_reader *pfile;\n+     const uchar **pstr;\n+     int identifier_pos;\n+{\n+  cppchar_t result, c;\n+  unsigned int length;\n+  const uchar *str = *pstr;\n+  const uchar *base = str - 2;\n+\n+  /* Only attempt to interpret a UCS for C++ and C99.  */\n+  if (!CPP_OPTION (pfile, cplusplus) && !CPP_OPTION (pfile, c99))\n+    return 0;\n+\n+  /* We don't accept UCNs for an EBCDIC target.  */\n+  if (CPP_OPTION (pfile, EBCDIC))\n+    return 0;\n+\n+  if (str[-1] == 'u')\n+    length = 4;\n+  else if (str[-1] == 'U')\n+    length = 8;\n+  else\n+    abort();\n+\n+  result = 0;\n+  do\n+    {\n+      c = *str;\n+      if (!ISXDIGIT (c))\n+\tbreak;\n+      str++;\n+      result = (result << 4) + hex_value (c);\n+    }\n+  while (--length);\n+\n+  *pstr = str;\n+  if (length)\n+    /* We'll error when we try it out as the start of an identifier.  */\n+    cpp_error (pfile, DL_ERROR, \"incomplete universal character name %.*s\",\n+\t       str - base, base);\n+  /* The standard permits $, @ and ` to be specified as UCNs.  We use\n+     hex escapes so that this also works with EBCDIC hosts.  */\n+  else if ((result < 0xa0\n+\t    && (result != 0x24 && result != 0x40 && result != 0x60))\n+\t   || (result & 0x80000000)\n+\t   || (result >= 0xD800 && result <= 0xDFFF))\n+    {\n+      cpp_error (pfile, DL_ERROR, \"%.*s is not a valid universal character\",\n+\t\t str - base, base);\n+    }\n+  else if (identifier_pos)\n+    {\n+      int validity = ucn_valid_in_identifier (pfile, result);\n+\n+      if (validity == 0)\n+\tcpp_error (pfile, DL_ERROR,\n+\t\t   \"universal character %.*s is not valid in an identifier\",\n+\t\t   str - base, base);\n+      else if (validity == 2 && identifier_pos == 1)\n+\tcpp_error (pfile, DL_ERROR,\n+   \"universal character %.*s is not valid at the start of an identifier\",\n+\t\t   str - base, base);\n+    }\n+\n+  if (result == 0)\n+    result = 1;\n+\n+  return result;\n+}\n+\n+/* Returns 1 if C is valid in an identifier, 2 if C is valid except at\n+   the start of an identifier, and 0 if C is not valid in an\n+   identifier.  We assume C has already gone through the checks of\n+   _cpp_valid_ucn.  */\n+static int\n+ucn_valid_in_identifier (pfile, c)\n+     cpp_reader *pfile;\n+     cppchar_t c;\n+{\n+  /* None of the valid chars are outside the Basic Multilingual Plane (the\n+     low 16 bits).  */\n+  if (c > 0xffff)\n+    return 0;\n+\n+  if (CPP_OPTION (pfile, c99) || !CPP_PEDANTIC (pfile))\n+    {\n+      /* Latin.  */\n+      if (c == 0x0aa || c == 0x00ba || c == 0x207f || c == 0x1e9b)\n+\treturn 1;\n+\n+      /* Greek.  */\n+      if (c == 0x0386)\n+\treturn 1;\n+\n+      /* Cyrillic.  */\n+      if (c == 0x040c)\n+\treturn 1;\n+\n+      /* Hebrew.  */\n+      if ((c >= 0x05b0 && c <= 0x05b9)\n+\t  || (c >= 0x05bb && c <= 0x005bd)\n+\t  || c == 0x05bf\n+\t  || (c >= 0x05c1 && c <= 0x05c2))\n+\treturn 1;\n+\n+      /* Arabic.  */\n+      if ((c >= 0x06d0 && c <= 0x06dc)\n+\t  || c == 0x06e8\n+\t  || (c >= 0x06ea && c <= 0x06ed))\n+\treturn 1;\n+\n+      /* Devanagari */\n+      if ((c >= 0x0901 && c <= 0x0903)\n+\t  || (c >= 0x093e && c <= 0x094d)\n+\t  || (c >= 0x0950 && c <= 0x0952)\n+\t  || c == 0x0963)\n+\treturn 1;\n+\n+      /* Bengali */\n+      if ((c >= 0x0981 && c <= 0x0983)\n+\t  || (c >= 0x09be && c <= 0x09c4)\n+\t  || (c >= 0x09c7 && c <= 0x09c8)\n+\t  || (c >= 0x09cb && c <= 0x09cd)\n+\t  || (c >= 0x09e2 && c <= 0x09e3))\n+\treturn 1;\n+\n+      /* Gurmukhi */\n+      if (c == 0x0a02\n+\t  || (c >= 0x0a3e && c <= 0x0a42)\n+\t  || (c >= 0x0a47 && c <= 0x0a48)\n+\t  || (c >= 0x0a4b && c <= 0x0a4d)\n+\t  || (c == 0x0a74))\n+\treturn 1;\n+      \n+      /* Gujarati */\n+      if ((c >= 0x0a81 && c <= 0x0a83)\n+\t  || (c >= 0x0abd && c <= 0x0ac5)\n+\t  || (c >= 0x0ac7 && c <= 0x0ac9)\n+\t  || (c >= 0x0acb && c <= 0x0acd)\n+\t  || (c == 0x0ad0))\n+\treturn 1;\n+\n+      /* Oriya */\n+      if ((c >= 0x0b01 && c <= 0x0b03)\n+\t  || (c >= 0x0b3e && c <= 0x0b43)\n+\t  || (c >= 0x0b47 && c <= 0x0b48)\n+\t  || (c >= 0x0b4b && c <= 0x0b4d))\n+\treturn 1;\n+\n+      /* Tamil */\n+      if ((c >= 0x0b82 && c <= 0x0b83)\n+\t  || (c >= 0x0bbe && c <= 0x0bc2)\n+\t  || (c >= 0x0bc6 && c <= 0x0bc8)\n+\t  || (c >= 0x0bc8 && c <= 0x0bcd))\n+\treturn 1;\n+\n+      /* Telugu */\n+      if ((c >= 0x0c01 && c <= 0x0c03)\n+\t  || (c >= 0x0c3e && c <= 0x0c44)\n+\t  || (c >= 0x0c46 && c <= 0x0c48)\t\n+\t  || (c >= 0x0c4a && c <= 0x0c4d))\n+\treturn 1;\n+\n+      /* Kannada */\n+      if ((c >= 0x0c82 && c <= 0x0c83)\n+\t  || (c >= 0x0cbe && c <= 0x0cc4)\n+\t  || (c >= 0x0cc6 && c <= 0x0cc8)\n+\t  || (c >= 0x0cca && c <= 0x0ccd)\n+\t  || c == 0x0cde)\n+\treturn 1;\n+\n+      /* Malayalam */\n+      if ((c >= 0x0d02 && c <= 0x0d03)\n+\t  || (c >= 0x0d3e && c <= 0x0d43)\n+\t  || (c >= 0x0d46 && c <= 0x0d48)\n+\t  || (c >= 0x0d4a && c <= 0x0d4d))\n+\treturn 1;\n+\n+      /* Thai */\n+      if ((c >= 0x0e01 && c <= 0x0e3a)\n+\t  || (c >= 0x0e40 && c <= 0x0e5b))\n+\treturn 1;\n+\n+      /* Lao */\n+      if ((c >= 0x0ead && c <= 0x0eae)\n+\t  || (c >= 0x0eb0 && c <= 0x0eb9)\n+\t  || (c >= 0x0ebb && c <= 0x0ebd)\n+\t  || (c >= 0x0ec0 && c <= 0x0ec4)\n+\t  || c == 0x0ec6\n+\t  || (c >= 0x0ec8 && c <= 0x0ecd)\n+\t  || (c >= 0x0edc && c <= 0x0ed))\n+\treturn 1;\n+\n+      /* Tibetan.  */\n+      if (c == 0x0f00\n+\t  || (c >= 0x0f18 && c <= 0x0f19)\n+\t  || c == 0x0f35\n+\t  || c == 0x0f37\n+\t  || c == 0x0f39\n+\t  || (c >= 0x0f3e && c <= 0x0f47)\n+\t  || (c >= 0x0f49 && c <= 0x0f69)\n+\t  || (c >= 0x0f71 && c <= 0x0f84)\n+\t  || (c >= 0x0f86 && c <= 0x0f8b)\n+\t  || (c >= 0x0f90 && c <= 0x0f95)\n+\t  || c == 0x0f97\n+\t  || (c >= 0x0f99 && c <= 0x0fad)\n+\t  || (c >= 0x0fb1 && c <= 0x0fb7)\n+\t  || c == 0x0fb9)\n+\treturn 1;\n+\n+      /* Katakana */\n+      if ((c >= 0x30a1 && c <= 0x30f6)\n+\t  || (c >= 0x30fb && c <= 0x30fc))\n+\treturn 1;\n+\n+      /* CJK Unified Ideographs.  */\n+      if (c >= 0x4e00 && c <= 0x9fa5)\n+\treturn 1;\n+\n+      /* Hangul.  */\n+      if (c >= 0xac00 && c <= 0xd7a3)\n+\treturn 1;\n+\n+      /* Digits.  */\n+      if ((c >= 0x0660 && c <= 0x0669)\n+\t  || (c >= 0x06f0 && c <= 0x06f9)\n+\t  || (c >= 0x0966 && c <= 0x096f)\n+\t  || (c >= 0x09e6 && c <= 0x09ef)\n+\t  || (c >= 0x0a66 && c <= 0x0a6f)\n+\t  || (c >= 0x0ae6 && c <= 0x0aef)\n+\t  || (c >= 0x0b66 && c <= 0x0b6f)\n+\t  || (c >= 0x0be7 && c <= 0x0bef)\n+\t  || (c >= 0x0c66 && c <= 0x0c6f)\n+\t  || (c >= 0x0ce6 && c <= 0x0cef)\n+\t  || (c >= 0x0d66 && c <= 0x0d6f)\n+\t  || (c >= 0x0e50 && c <= 0x0e59)\n+\t  || (c >= 0x0ed0 && c <= 0x0ed9)\n+\t  || (c >= 0x0f20 && c <= 0x0f33))\n+\treturn 2;\n+\n+      /* Special characters.  */\n+      if (c == 0x00b5\n+\t  || c == 0x00b7\n+\t  || (c >= 0x02b0 && c <= 0x02b8)\n+\t  || c == 0x02bb\n+\t  || (c >= 0x02bd && c <= 0x02c1)\n+\t  || (c >= 0x02d0 && c <= 0x02d1)\n+\t  || (c >= 0x02e0 && c <= 0x02e4)\n+\t  || c == 0x037a\n+\t  || c == 0x0559\n+\t  || c == 0x093d\n+\t  || c == 0x0b3d\n+\t  || c == 0x1fbe\n+\t  || (c >= 0x203f && c <= 0x2040)\n+\t  || c == 0x2102\n+\t  || c == 0x2107\n+\t  || (c >= 0x210a && c <= 0x2113)\n+\t  || c == 0x2115\n+\t  || (c >= 0x2118 && c <= 0x211d)\n+\t  || c == 0x2124\n+\t  || c == 0x2126\n+\t  || c == 0x2128\n+\t  || (c >= 0x212a && c <= 0x2131)\n+\t  || (c >= 0x2133 && c <= 0x2138)\n+\t  || (c >= 0x2160 && c <= 0x2182)\n+\t  || (c >= 0x3005 && c <= 0x3007)\n+\t  || (c >= 0x3021 && c <= 0x3029))\n+\treturn 1;\t  \n+    }\n+  \n+  if (CPP_OPTION (pfile, cplusplus) || !CPP_PEDANTIC (pfile))\n+    {\n+      /* Greek.  */\n+      if (c == 0x0384)\n+\treturn 1;\n+\n+      /* Cyrillic.  */\n+      if (c == 0x040d)\n+\treturn 1;\n+\n+      /* Hebrew.  */\n+      if (c >= 0x05f3 && c <= 0x05f4)\n+\treturn 1;\n+\n+      /* Lao.  */\n+      if ((c >= 0x0ead && c <= 0x0eb0)\n+\t  || (c == 0x0eb2)\n+\t  || (c == 0x0eb3)\n+\t  || (c == 0x0ebd)\n+\t  || (c >= 0x0ec0 && c <= 0x0ec4)\n+\t  || (c == 0x0ec6))\n+\treturn 1;\n+\n+      /* Hiragana */\n+      if (c == 0x3094\n+\t  || (c >= 0x309d && c <= 0x309e))\n+\treturn 1;\n+\n+      /* Katakana */\n+      if ((c >= 0x30a1 && c <= 0x30fe))\n+\treturn 1;\n+\n+      /* Hangul */\n+      if ((c >= 0x1100 && c <= 0x1159)\n+\t  || (c >= 0x1161 && c <= 0x11a2)\n+\t  || (c >= 0x11a8 && c <= 0x11f9))\n+\treturn 1;\n+\n+      /* CJK Unified Ideographs */\n+      if ((c >= 0xf900 && c <= 0xfa2d)\n+\t  || (c >= 0xfb1f && c <= 0xfb36)\n+\t  || (c >= 0xfb38 && c <= 0xfb3c)\n+\t  || (c == 0xfb3e)\n+\t  || (c >= 0xfb40 && c <= 0xfb41)\n+\t  || (c >= 0xfb42 && c <= 0xfb44)\n+\t  || (c >= 0xfb46 && c <= 0xfbb1)\n+\t  || (c >= 0xfbd3 && c <= 0xfd3f)\n+\t  || (c >= 0xfd50 && c <= 0xfd8f)\n+\t  || (c >= 0xfd92 && c <= 0xfdc7)\n+\t  || (c >= 0xfdf0 && c <= 0xfdfb)\n+\t  || (c >= 0xfe70 && c <= 0xfe72)\n+\t  || (c == 0xfe74)\n+\t  || (c >= 0xfe76 && c <= 0xfefc)\n+\t  || (c >= 0xff21 && c <= 0xff3a)\n+\t  || (c >= 0xff41 && c <= 0xff5a)\n+\t  || (c >= 0xff66 && c <= 0xffbe)\n+\t  || (c >= 0xffc2 && c <= 0xffc7)\n+\t  || (c >= 0xffca && c <= 0xffcf)\n+\t  || (c >= 0xffd2 && c <= 0xffd7)\n+\t  || (c >= 0xffda && c <= 0xffdc)\n+\t  || (c >= 0x4e00 && c <= 0x9fa5))\n+\treturn 1;\n+    }\n+\n+  /* Latin */\n+  if ((c >= 0x00c0 && c <= 0x00d6)\n+      || (c >= 0x00d8 && c <= 0x00f6)\n+      || (c >= 0x00f8 && c <= 0x01f5)\n+      || (c >= 0x01fa && c <= 0x0217)\n+      || (c >= 0x0250 && c <= 0x02a8)\n+      || (c >= 0x1e00 && c <= 0x1e9a)\n+      || (c >= 0x1ea0 && c <= 0x1ef9))\n+    return 1;\n+\n+  /* Greek */\n+  if ((c >= 0x0388 && c <= 0x038a)\n+      || (c == 0x038c)\n+      || (c >= 0x038e && c <= 0x03a1)\n+      || (c >= 0x03a3 && c <= 0x03ce)\n+      || (c >= 0x03d0 && c <= 0x03d6)\n+      || (c == 0x03da)\n+      || (c == 0x03dc)\n+      || (c == 0x03de)\n+      || (c == 0x03e0)\n+      || (c >= 0x03e2 && c <= 0x03f3)\n+      || (c >= 0x1f00 && c <= 0x1f15)\n+      || (c >= 0x1f18 && c <= 0x1f1d)\n+      || (c >= 0x1f20 && c <= 0x1f45)\n+      || (c >= 0x1f48 && c <= 0x1f4d)\n+      || (c >= 0x1f50 && c <= 0x1f57)\n+      || (c == 0x1f59)\n+      || (c == 0x1f5b)\n+      || (c == 0x1f5d)\n+      || (c >= 0x1f5f && c <= 0x1f7d)\n+      || (c >= 0x1f80 && c <= 0x1fb4)\n+      || (c >= 0x1fb6 && c <= 0x1fbc)\n+      || (c >= 0x1fc2 && c <= 0x1fc4)\n+      || (c >= 0x1fc6 && c <= 0x1fcc)\n+      || (c >= 0x1fd0 && c <= 0x1fd3)\n+      || (c >= 0x1fd6 && c <= 0x1fdb)\n+      || (c >= 0x1fe0 && c <= 0x1fec)\n+      || (c >= 0x1ff2 && c <= 0x1ff4)\n+      || (c >= 0x1ff6 && c <= 0x1ffc))\n+    return 1;\n+\n+  /* Cyrillic */\n+  if ((c >= 0x0401 && c <= 0x040c)\n+      || (c >= 0x040f && c <= 0x044f)\n+      || (c >= 0x0451 && c <= 0x045c)\n+      || (c >= 0x045e && c <= 0x0481)\n+      || (c >= 0x0490 && c <= 0x04c4)\n+      || (c >= 0x04c7 && c <= 0x04c8)\n+      || (c >= 0x04cb && c <= 0x04cc)\n+      || (c >= 0x04d0 && c <= 0x04eb)\n+      || (c >= 0x04ee && c <= 0x04f5)\n+      || (c >= 0x04f8 && c <= 0x04f9))\n+    return 1;\n+\n+  /* Armenian */\n+  if ((c >= 0x0531 && c <= 0x0556)\n+      || (c >= 0x0561 && c <= 0x0587))\n+    return 1;\n+\n+  /* Hebrew */\n+  if ((c >= 0x05d0 && c <= 0x05ea)\n+      || (c >= 0x05f0 && c <= 0x05f2))\n+    return 1;\n+\n+  /* Arabic */\n+  if ((c >= 0x0621 && c <= 0x063a)\n+      || (c >= 0x0640 && c <= 0x0652)\n+      || (c >= 0x0670 && c <= 0x06b7)\n+      || (c >= 0x06ba && c <= 0x06be)\n+      || (c >= 0x06c0 && c <= 0x06ce)\n+      || (c >= 0x06e5 && c <= 0x06e7))\n+    return 1;\n+\n+  /* Devanagari */\n+  if ((c >= 0x0905 && c <= 0x0939)\n+      || (c >= 0x0958 && c <= 0x0962))\n+    return 1;\n+\n+  /* Bengali */\n+  if ((c >= 0x0985 && c <= 0x098c)\n+      || (c >= 0x098f && c <= 0x0990)\n+      || (c >= 0x0993 && c <= 0x09a8)\n+      || (c >= 0x09aa && c <= 0x09b0)\n+      || (c == 0x09b2)\n+      || (c >= 0x09b6 && c <= 0x09b9)\n+      || (c >= 0x09dc && c <= 0x09dd)\n+      || (c >= 0x09df && c <= 0x09e1)\n+      || (c >= 0x09f0 && c <= 0x09f1))\n+    return 1;\n+\n+  /* Gurmukhi */\n+  if ((c >= 0x0a05 && c <= 0x0a0a)\n+      || (c >= 0x0a0f && c <= 0x0a10)\n+      || (c >= 0x0a13 && c <= 0x0a28)\n+      || (c >= 0x0a2a && c <= 0x0a30)\n+      || (c >= 0x0a32 && c <= 0x0a33)\n+      || (c >= 0x0a35 && c <= 0x0a36)\n+      || (c >= 0x0a38 && c <= 0x0a39)\n+      || (c >= 0x0a59 && c <= 0x0a5c)\n+      || (c == 0x0a5e))\n+    return 1;\n+\n+  /* Gujarati */\n+  if ((c >= 0x0a85 && c <= 0x0a8b)\n+      || (c == 0x0a8d)\n+      || (c >= 0x0a8f && c <= 0x0a91)\n+      || (c >= 0x0a93 && c <= 0x0aa8)\n+      || (c >= 0x0aaa && c <= 0x0ab0)\n+      || (c >= 0x0ab2 && c <= 0x0ab3)\n+      || (c >= 0x0ab5 && c <= 0x0ab9)\n+      || (c == 0x0ae0))\n+    return 1;\n+\n+  /* Oriya */\n+  if ((c >= 0x0b05 && c <= 0x0b0c)\n+      || (c >= 0x0b0f && c <= 0x0b10)\n+      || (c >= 0x0b13 && c <= 0x0b28)\n+      || (c >= 0x0b2a && c <= 0x0b30)\n+      || (c >= 0x0b32 && c <= 0x0b33)\n+      || (c >= 0x0b36 && c <= 0x0b39)\n+      || (c >= 0x0b5c && c <= 0x0b5d)\n+      || (c >= 0x0b5f && c <= 0x0b61))\n+    return 1;\n+\n+  /* Tamil */\n+  if ((c >= 0x0b85 && c <= 0x0b8a)\n+      || (c >= 0x0b8e && c <= 0x0b90)\n+      || (c >= 0x0b92 && c <= 0x0b95)\n+      || (c >= 0x0b99 && c <= 0x0b9a)\n+      || (c == 0x0b9c)\n+      || (c >= 0x0b9e && c <= 0x0b9f)\n+      || (c >= 0x0ba3 && c <= 0x0ba4)\n+      || (c >= 0x0ba8 && c <= 0x0baa)\n+      || (c >= 0x0bae && c <= 0x0bb5)\n+      || (c >= 0x0bb7 && c <= 0x0bb9))\n+    return 1;\n+\n+  /* Telugu */\n+  if ((c >= 0x0c05 && c <= 0x0c0c)\n+      || (c >= 0x0c0e && c <= 0x0c10)\n+      || (c >= 0x0c12 && c <= 0x0c28)\n+      || (c >= 0x0c2a && c <= 0x0c33)\n+      || (c >= 0x0c35 && c <= 0x0c39)\n+      || (c >= 0x0c60 && c <= 0x0c61))\n+    return 1;\n+\n+  /* Kannada */\n+  if ((c >= 0x0c85 && c <= 0x0c8c)\n+      || (c >= 0x0c8e && c <= 0x0c90)\n+      || (c >= 0x0c92 && c <= 0x0ca8)\n+      || (c >= 0x0caa && c <= 0x0cb3)\n+      || (c >= 0x0cb5 && c <= 0x0cb9)\n+      || (c >= 0x0ce0 && c <= 0x0ce1))\n+    return 1;\n+\n+  /* Malayalam */\n+  if ((c >= 0x0d05 && c <= 0x0d0c)\n+      || (c >= 0x0d0e && c <= 0x0d10)\n+      || (c >= 0x0d12 && c <= 0x0d28)\n+      || (c >= 0x0d2a && c <= 0x0d39)\n+      || (c >= 0x0d60 && c <= 0x0d61))\n+    return 1;\n+\n+  /* Thai */\n+  if ((c >= 0x0e01 && c <= 0x0e30)\n+      || (c >= 0x0e32 && c <= 0x0e33)\n+      || (c >= 0x0e40 && c <= 0x0e46)\n+      || (c >= 0x0e4f && c <= 0x0e5b))\n+    return 1;\n+\n+  /* Lao */\n+  if ((c >= 0x0e81 && c <= 0x0e82)\n+      || (c == 0x0e84)\n+      || (c == 0x0e87)\n+      || (c == 0x0e88)\n+      || (c == 0x0e8a)\n+      || (c == 0x0e8d)\n+      || (c >= 0x0e94 && c <= 0x0e97)\n+      || (c >= 0x0e99 && c <= 0x0e9f)\n+      || (c >= 0x0ea1 && c <= 0x0ea3)\n+      || (c == 0x0ea5)\n+      || (c == 0x0ea7)\n+      || (c == 0x0eaa)\n+      || (c == 0x0eab))\n+    return 1;\n+\n+  /* Georgian */\n+  if ((c >= 0x10a0 && c <= 0x10c5)\n+      || (c >= 0x10d0 && c <= 0x10f6))\n+    return 1;\n+\n+  /* Hiragana */\n+  if ((c >= 0x3041 && c <= 0x3093)\n+      || (c >= 0x309b && c <= 0x309c))\n+    return 1;\n+\n+  /* Bopmofo */\n+  if ((c >= 0x3105 && c <= 0x312c))\n+    return 1;\n+\n+  return 0;\n+}"}, {"sha": "4eee9426a760e7fae8c69e90514a36e23e4c5b0e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -555,6 +555,10 @@ extern bool _cpp_expansions_different_trad PARAMS ((const cpp_macro *,\n extern uchar *_cpp_copy_replacement_text PARAMS ((const cpp_macro *, uchar *));\n extern size_t _cpp_replacement_text_len PARAMS ((const cpp_macro *));\n \n+/* In cppcharset.c.  */\n+cppchar_t _cpp_valid_ucn PARAMS ((cpp_reader *, const uchar **,\n+\t\t\t\t  int identifer_p));\n+\n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))"}, {"sha": "41e8a009a670471eb2ec8a2297fb2eb7ef2d96ef", "filename": "gcc/cpplex.c", "status": "modified", "additions": 82, "deletions": 111, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -59,15 +59,14 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n static void add_line_note PARAMS ((cpp_buffer *, const uchar *, unsigned int));\n static int skip_line_comment PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n-static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *));\n+static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static void lex_number PARAMS ((cpp_reader *, cpp_string *));\n-static bool continues_identifier_p PARAMS ((cpp_reader *));\n+static bool forms_identifier_p PARAMS ((cpp_reader *, int));\n static void lex_string PARAMS ((cpp_reader *, cpp_token *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n \t\t\t\t  cppchar_t));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n-static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n-\t\t\t\t   const unsigned char *, cppchar_t *));\n+static cppchar_t maybe_read_ucn PARAMS ((cpp_reader *, const uchar **));\n static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n \n static unsigned int hex_digit_value PARAMS ((unsigned int));\n@@ -361,33 +360,53 @@ name_p (pfile, string)\n }\n \n /* Returns TRUE if the sequence starting at buffer->cur is invalid in\n-   an identifier.  */\n+   an identifier.  FIRST is TRUE if this starts an identifier.  */\n static bool\n-continues_identifier_p (pfile)\n+forms_identifier_p (pfile, first)\n      cpp_reader *pfile;\n+     int first;\n {\n-  if (*pfile->buffer->cur != '$' || !CPP_OPTION (pfile, dollars_in_ident))\n-    return false;\n+  cpp_buffer *buffer = pfile->buffer;\n \n-  if (CPP_PEDANTIC (pfile) && !pfile->state.skipping && !pfile->warned_dollar)\n+  if (*buffer->cur == '$')\n     {\n-      pfile->warned_dollar = true;\n-      cpp_error (pfile, DL_PEDWARN, \"'$' in identifier or number\");\n+      if (!CPP_OPTION (pfile, dollars_in_ident))\n+\treturn false;\n+\n+      buffer->cur++;\n+      if (CPP_PEDANTIC (pfile)\n+\t  && !pfile->state.skipping\n+\t  && !pfile->warned_dollar)\n+\t{\n+\t  pfile->warned_dollar = true;\n+\t  cpp_error (pfile, DL_PEDWARN, \"'$' in identifier or number\");\n+\t}\n+\n+      return true;\n     }\n-  pfile->buffer->cur++;\n \n-  return true;\n+  /* Is this a syntactically valid UCN?  */\n+  if (0 && *buffer->cur == '\\\\'\n+      && (buffer->cur[1] == 'u' || buffer->cur[1] == 'U'))\n+    {\n+      buffer->cur += 2;\n+      if (_cpp_valid_ucn (pfile, &buffer->cur, 1 + !first))\n+\treturn true;\n+      buffer->cur -= 2;\n+    }\n+\n+  return false;\n }\n \n /* Lex an identifier starting at BUFFER->CUR - 1.  */\n static cpp_hashnode *\n-lex_identifier (pfile)\n+lex_identifier (pfile, base)\n      cpp_reader *pfile;\n+     const uchar *base;\n {\n   cpp_hashnode *result;\n-  const uchar *cur, *base;\n+  const uchar *cur;\n \n-  base = pfile->buffer->cur - 1;\n   do\n     {\n       cur = pfile->buffer->cur;\n@@ -398,7 +417,7 @@ lex_identifier (pfile)\n \n       pfile->buffer->cur = cur;\n     }\n-  while (continues_identifier_p (pfile));\n+  while (forms_identifier_p (pfile, false));\n \n   result = (cpp_hashnode *)\n     ht_lookup (pfile->hash_table, base, cur - base, HT_ALLOC);\n@@ -444,7 +463,7 @@ lex_number (pfile, number)\n \n       pfile->buffer->cur = cur;\n     }\n-  while (continues_identifier_p (pfile));\n+  while (forms_identifier_p (pfile, false));\n \n   number->len = cur - base;\n   dest = _cpp_unaligned_alloc (pfile, number->len + 1);\n@@ -803,7 +822,6 @@ _cpp_lex_direct (pfile)\n \t}\n       /* Fall through.  */\n \n-    start_ident:\n     case '_':\n     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n     case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n@@ -816,7 +834,7 @@ _cpp_lex_direct (pfile)\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;\n-      result->val.node = lex_identifier (pfile);\n+      result->val.node = lex_identifier (pfile, buffer->cur - 1);\n \n       /* Convert named operators to their proper types.  */\n       if (result->val.node->flags & NODE_OPERATOR)\n@@ -1044,14 +1062,23 @@ _cpp_lex_direct (pfile)\n     case '@': result->type = CPP_ATSIGN; break;\n \n     case '$':\n-      if (CPP_OPTION (pfile, dollars_in_ident))\n-\tgoto start_ident;\n-      /* Fall through...  */\n+    case '\\\\':\n+      {\n+\tconst uchar *base = --buffer->cur;\n \n-    default:\n-      result->type = CPP_OTHER;\n-      result->val.c = c;\n-      break;\n+\tif (forms_identifier_p (pfile, true))\n+\t  {\n+\t    result->type = CPP_NAME;\n+\t    result->val.node = lex_identifier (pfile, base);\n+\t    break;\n+\t  }\n+\tbuffer->cur++;\n+\n+      default:\n+\tresult->type = CPP_OTHER;\n+\tresult->val.c = c;\n+\tbreak;\n+      }\n     }\n \n   return result;\n@@ -1321,9 +1348,11 @@ cpp_avoid_paste (pfile, token1, token2)\n \t\t\t\t|| b == CPP_CHAR || b == CPP_STRING); /* L */\n     case CPP_NUMBER:\treturn (b == CPP_NUMBER || b == CPP_NAME\n \t\t\t\t|| c == '.' || c == '+' || c == '-');\n-    case CPP_OTHER:\treturn (CPP_OPTION (pfile, objc)\n-\t\t\t\t&& token1->val.c == '@'\n-\t\t\t\t&& (b == CPP_NAME || b == CPP_STRING));\n+\t\t\t\t      /* UCNs */\n+    case CPP_OTHER:\treturn ((token1->val.c == '\\\\' && b == CPP_NAME)\n+\t\t\t\t|| (CPP_OPTION (pfile, objc)\n+\t\t\t\t    && token1->val.c == '@'\n+\t\t\t\t    && (b == CPP_NAME || b == CPP_STRING)));\n     default:\t\tbreak;\n     }\n \n@@ -1363,93 +1392,31 @@ hex_digit_value (c)\n     abort ();\n }\n \n-/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence.  Returns 1 to indicate\n-   failure if cpplib is not parsing C++ or C99.  Such failure is\n-   silent, and no variables are updated.  Otherwise returns 0, and\n-   warns if -Wtraditional.\n-\n-   [lex.charset]: The character designated by the universal character\n-   name \\UNNNNNNNN is that character whose character short name in\n-   ISO/IEC 10646 is NNNNNNNN; the character designated by the\n-   universal character name \\uNNNN is that character whose character\n-   short name in ISO/IEC 10646 is 0000NNNN.  If the hexadecimal value\n-   for a universal character name is less than 0x20 or in the range\n-   0x7F-0x9F (inclusive), or if the universal character name\n-   designates a character in the basic source character set, then the\n-   program is ill-formed.\n-\n-   We assume that wchar_t is Unicode, so we don't need to do any\n-   mapping.  Is this ever wrong?\n-\n-   PC points to the 'u' or 'U', PSTR is points to the byte after PC,\n-   LIMIT is the end of the string or charconst.  PSTR is updated to\n-   point after the UCS on return, and the UCS is written into PC.  */\n-\n-static int\n-maybe_read_ucs (pfile, pstr, limit, pc)\n+/* Read a possible universal character name starting at *PSTR.  */\n+static cppchar_t\n+maybe_read_ucn (pfile, pstr)\n      cpp_reader *pfile;\n-     const unsigned char **pstr;\n-     const unsigned char *limit;\n-     cppchar_t *pc;\n+     const uchar **pstr;\n {\n-  const unsigned char *p = *pstr;\n-  unsigned int code = 0;\n-  unsigned int c = *pc, length;\n-\n-  /* Only attempt to interpret a UCS for C++ and C99.  */\n-  if (! (CPP_OPTION (pfile, cplusplus) || CPP_OPTION (pfile, c99)))\n-    return 1;\n+  cppchar_t result, c = (*pstr)[-1];\n \n-  if (CPP_WTRADITIONAL (pfile))\n-    cpp_error (pfile, DL_WARNING,\n-\t       \"the meaning of '\\\\%c' is different in traditional C\", c);\n-\n-  length = (c == 'u' ? 4: 8);\n-\n-  if ((size_t) (limit - p) < length)\n-    {\n-      cpp_error (pfile, DL_ERROR, \"incomplete universal-character-name\");\n-      /* Skip to the end to avoid more diagnostics.  */\n-      p = limit;\n-    }\n-  else\n+  result = _cpp_valid_ucn (pfile, pstr, false);\n+  if (result)\n     {\n-      for (; length; length--, p++)\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"the meaning of '\\\\%c' is different in traditional C\",\n+\t\t   (int) c);\n+\n+      if (CPP_OPTION (pfile, EBCDIC))\n \t{\n-\t  c = *p;\n-\t  if (ISXDIGIT (c))\n-\t    code = (code << 4) + hex_digit_value (c);\n-\t  else\n-\t    {\n-\t      cpp_error (pfile, DL_ERROR,\n-\t\t\t \"non-hex digit '%c' in universal-character-name\", c);\n-\t      /* We shouldn't skip in case there are multibyte chars.  */\n-\t      break;\n-\t    }\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"universal character with an EBCDIC target\");\n+\t  result = 0x3f;  /* EBCDIC invalid character */\n \t}\n     }\n \n-  if (CPP_OPTION (pfile, EBCDIC))\n-    {\n-      cpp_error (pfile, DL_ERROR, \"universal-character-name on EBCDIC target\");\n-      code = 0x3f;  /* EBCDIC invalid character */\n-    }\n-  /* True extended characters are OK.  */\n-  else if (code >= 0xa0\n-\t   && !(code & 0x80000000)\n-\t   && !(code >= 0xD800 && code <= 0xDFFF))\n-    ;\n-  /* The standard permits $, @ and ` to be specified as UCNs.  We use\n-     hex escapes so that this also works with EBCDIC hosts.  */\n-  else if (code == 0x24 || code == 0x40 || code == 0x60)\n-    ;\n-  /* Don't give another error if one occurred above.  */\n-  else if (length == 0)\n-    cpp_error (pfile, DL_ERROR, \"universal-character-name out of range\");\n-\n-  *pstr = p;\n-  *pc = code;\n-  return 0;\n+  return result;\n }\n \n /* Returns the value of an escape sequence, truncated to the correct\n@@ -1470,7 +1437,7 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n \n   int unknown = 0;\n   const unsigned char *str = *pstr, *charconsts;\n-  cppchar_t c, mask;\n+  cppchar_t c, ucn, mask;\n   unsigned int width;\n \n   if (CPP_OPTION (pfile, EBCDIC))\n@@ -1519,7 +1486,11 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n       break;\n \n     case 'u': case 'U':\n-      unknown = maybe_read_ucs (pfile, &str, limit, &c);\n+      ucn = maybe_read_ucn (pfile, &str);\n+      if (ucn)\n+\tc = ucn;\n+      else\n+\tunknown = true;\n       break;\n \n     case 'x':"}, {"sha": "41df38fa7aa1cce726779995b0f75bb223ff1224", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -1,3 +1,7 @@\n+2003-04-20  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* ucs.c: Update diagnostic messages.\n+\n 2003-04-19  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/truefalse.cpp: New test."}, {"sha": "d36e0dc517f8033b00c73685a5a2dda6b26029bf", "filename": "gcc/testsuite/gcc.dg/cpp/ucs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1613e52bdd61cfd2e00fb326c5cfef8e07f8c797/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c?ref=1613e52bdd61cfd2e00fb326c5cfef8e07f8c797", "patch": "@@ -51,7 +51,7 @@ void foo ()\n   c = L'\\ubad';\t\t/* { dg-error \"incomplete\" \"incompete UCN 1\" } */\n   c = L\"\\U1234\"[0];\t/* { dg-error \"incomplete\" \"incompete UCN 2\" } */\n \n-  c = L'\\u000x';\t/* { dg-error \"non-hex\" \"non-hex digit in UCN\" } */\n+  c = L'\\u000x';\t/* { dg-error \"incomplete\" \"non-hex digit in UCN\" } */\n   /* If sizeof(HOST_WIDE_INT) > sizeof(wchar_t), we can get a multi-character\n      constant warning even for wide characters.  */\n   /* { dg-warning \"too long|multi-character\" \"\" { target *-*-* } 54 } */\n@@ -61,7 +61,7 @@ void foo ()\n   c = '\\u00a0';\t\t/* { dg-bogus \"invalid\" \"00a0 is a valid UCN\" } */\n   c = '\\U00000060';\t/* { dg-bogus \"invalid\" \"0060 is a valid UCN\" } */\n \n-  c = '\\u0025';\t\t/* { dg-error \"range\" \"0025 is an invalid UCN\" } */\n-  c = L\"\\uD800\"[0];\t/* { dg-error \"range\" \"D800 is an invalid UCN\" } */\n-  c = L'\\U0000DFFF';\t/* { dg-error \"range\" \"DFFF is an invalid UCN\" } */\n+  c = '\\u0025';\t\t/* { dg-error \"not a valid\" \"0025 invalid UCN\" } */\n+  c = L\"\\uD800\"[0];\t/* { dg-error \"not a valid\" \"D800 invalid UCN\" } */\n+  c = L'\\U0000DFFF';\t/* { dg-error \"not a valid\" \"DFFF invalid UCN\" } */\n }"}]}