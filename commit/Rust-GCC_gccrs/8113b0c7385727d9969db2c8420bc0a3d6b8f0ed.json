{"sha": "8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExM2IwYzczODU3MjdkOTk2OWRiMmM4NDIwYmMwYTNkNmI4ZjBlZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-22T13:58:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:58:19Z"}, "message": "[Ada] Overhaul code implementing conversions involving fixed-point types\n\nThis ovehauls the code implementing conversions involving fixed-point\ntypes in the front-end because it leaks the Do_Range_Check flag in\nseveral places to the back-end, which is a violation of the documented\ninterface between front-end and back-end.\n\nThis also does a bit of housekeeping work throughout it in the process.\n\nThere should be essentially no functional changes.\n\n2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.adb (Apply_Type_Conversion_Checks): Do not set\n\tDo_Range_Check flag on conversions from fixed-point types\n\teither.\n\t* exp_attr.adb: Add use and with clause for Expander.\n\t(Expand_N_Attribute_Reference) <Fixed_Value, Integer_Value>: Set\n\tthe Conversion_OK flag and do not generate overflow/range checks\n\tmanually.\n\t* exp_ch4.adb (Expand_N_Qualified_Expression): Remove\n\tsuperfluous clearing of Do_Range_Check flag.\n\t(Discrete_Range_Check): New procedure to generate a range check\n\tfor discrete types.\n\t(Real_Range_Check): Remove redundant local variable and adjust.\n\tRemove useless shortcut.  Clear Do_Range_Check flag on all\n\tpaths.\n\t(Expand_N_Type_Conversion): Remove redundant test on\n\tConversion_OK.  Call Discrete_Range_Check to generate range\n\tchecks on discrete types.  Remove obsolete code for\n\tfloat-to-integer conversions.  Add code to generate range checks\n\tfor conversions involving fixed-point types.\n\nFrom-SVN: r273692", "tree": {"sha": "7867ec78d1a4964669ee03eb5e1741a1e0834d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7867ec78d1a4964669ee03eb5e1741a1e0834d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/comments", "author": null, "committer": null, "parents": [{"sha": "c936411fab42b991839ce8cd95a5d883867f9466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c936411fab42b991839ce8cd95a5d883867f9466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c936411fab42b991839ce8cd95a5d883867f9466"}], "stats": {"total": 352, "additions": 142, "deletions": 210}, "files": [{"sha": "8bb8d34f305f73e616f5839ce3f03bc4b70113c6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "patch": "@@ -1,3 +1,25 @@\n+2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Apply_Type_Conversion_Checks): Do not set\n+\tDo_Range_Check flag on conversions from fixed-point types\n+\teither.\n+\t* exp_attr.adb: Add use and with clause for Expander.\n+\t(Expand_N_Attribute_Reference) <Fixed_Value, Integer_Value>: Set\n+\tthe Conversion_OK flag and do not generate overflow/range checks\n+\tmanually.\n+\t* exp_ch4.adb (Expand_N_Qualified_Expression): Remove\n+\tsuperfluous clearing of Do_Range_Check flag.\n+\t(Discrete_Range_Check): New procedure to generate a range check\n+\tfor discrete types.\n+\t(Real_Range_Check): Remove redundant local variable and adjust.\n+\tRemove useless shortcut.  Clear Do_Range_Check flag on all\n+\tpaths.\n+\t(Expand_N_Type_Conversion): Remove redundant test on\n+\tConversion_OK.  Call Discrete_Range_Check to generate range\n+\tchecks on discrete types.  Remove obsolete code for\n+\tfloat-to-integer conversions.  Add code to generate range checks\n+\tfor conversions involving fixed-point types.\n+\n 2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sprint.ads: Fix pasto in comment."}, {"sha": "e1f7f9a5085e152c43437cd957075ba305fa6529", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "patch": "@@ -3622,13 +3622,14 @@ package body Checks is\n                   --  will not be generated.\n \n                   if GNATprove_Mode\n-                    or else not Is_Fixed_Point_Type (Expr_Type)\n+                    or else (not Is_Fixed_Point_Type (Expr_Type)\n+                              and then not Is_Fixed_Point_Type (Target_Type))\n                   then\n                      Apply_Scalar_Range_Check\n                        (Expr, Target_Type, Fixed_Int => Conv_OK);\n \n                   else\n-                     Set_Do_Range_Check (Expression (N), False);\n+                     Set_Do_Range_Check (Expr, False);\n                   end if;\n \n                   --  If the target type has predicates, we need to indicate"}, {"sha": "9d6da3348dc6ac1e38d293421fd9a300201507b8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 15, "deletions": 59, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "patch": "@@ -39,6 +39,7 @@ with Exp_Pakd; use Exp_Pakd;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n+with Expander; use Expander;\n with Freeze;   use Freeze;\n with Gnatvsn;  use Gnatvsn;\n with Itypes;   use Itypes;\n@@ -3540,7 +3541,7 @@ package body Exp_Attr is\n       --  We transform\n \n       --     fixtype'Fixed_Value (integer-value)\n-      --     inttype'Fixed_Value (fixed-value)\n+      --     inttype'Integer_Value (fixed-value)\n \n       --  into\n \n@@ -3549,75 +3550,30 @@ package body Exp_Attr is\n \n       --  respectively.\n \n-      --  We do all the required analysis of the conversion here, because we do\n-      --  not want this to go through the fixed-point conversion circuits. Note\n-      --  that the back end always treats fixed-point as equivalent to the\n-      --  corresponding integer type anyway.\n-      --  However, in order to remove the handling of Do_Range_Check from the\n-      --  backend, we force the generation of a check on the result by\n-      --  setting the result type appropriately. Apply_Conversion_Checks\n-      --  will generate the required expansion.\n+      --  We set Conversion_OK on the conversion because we do not want it\n+      --  to go through the fixed-point conversion circuits.\n \n       when Attribute_Fixed_Value\n          | Attribute_Integer_Value\n       =>\n-         Rewrite (N,\n-           Make_Type_Conversion (Loc,\n-             Subtype_Mark => New_Occurrence_Of (Entity (Pref), Loc),\n-             Expression   => Relocate_Node (First (Exprs))));\n+         Rewrite (N, OK_Convert_To (Entity (Pref), First (Exprs)));\n \n-         --  Indicate that the result of the conversion may require a\n-         --  range check (see below);\n-\n-         Set_Etype (N, Base_Type (Entity (Pref)));\n-         Set_Analyzed (N);\n-\n-         --  Note: it might appear that a properly analyzed unchecked\n+         --  Note that it might appear that a properly analyzed unchecked\n          --  conversion would be just fine here, but that's not the case,\n-         --  since the full range checks performed by the following code\n+         --  since the full range checks performed by the following calls\n          --  are critical.\n-         --  Given that Fixed-point conversions are not further expanded\n-         --  to prevent the involvement of real type operations we have to\n-         --  construct two checks explicitly: one on the operand, and one\n-         --  on the result. This used to be done in part in the back-end,\n-         --  but for other targets (E.g. LLVM) it is preferable to create\n-         --  the tests in full in the front-end.\n-\n-         if Is_Fixed_Point_Type (Etype (N)) then\n-            declare\n-               Loc     : constant Source_Ptr := Sloc (N);\n-               Equiv_T : constant Entity_Id  := Make_Temporary (Loc, 'T', N);\n-               Expr    : constant Node_Id    := Expression (N);\n-               Fst     : constant Entity_Id  := Root_Type (Etype (N));\n-               Decl    : Node_Id;\n \n-            begin\n-               Decl :=\n-                 Make_Full_Type_Declaration (Sloc (N),\n-                 Defining_Identifier => Equiv_T,\n-                 Type_Definition     =>\n-                   Make_Signed_Integer_Type_Definition (Loc,\n-                     Low_Bound  =>\n-                       Make_Integer_Literal (Loc,\n-                         Intval =>\n-                           Corresponding_Integer_Value\n-                             (Type_Low_Bound (Fst))),\n-                     High_Bound =>\n-                       Make_Integer_Literal (Loc,\n-                         Intval =>\n-                           Corresponding_Integer_Value\n-                             (Type_High_Bound (Fst)))));\n-               Insert_Action (N, Decl);\n-\n-               --  Verify that the conversion is possible\n+         Apply_Type_Conversion_Checks (N);\n \n-               Generate_Range_Check (Expr, Equiv_T, CE_Overflow_Check_Failed);\n+         --  Note that Apply_Type_Conversion_Checks only deals with the\n+         --  overflow checks on conversions involving fixed-point types\n+         --  so we must apply range checks manually on them and expand.\n \n-               --  and verify that the result is in range\n+         Apply_Scalar_Range_Check\n+           (Expression (N), Etype (N), Fixed_Int => True);\n \n-               Generate_Range_Check (N, Etype (N), CE_Range_Check_Failed);\n-            end;\n-         end if;\n+         Set_Analyzed (N);\n+         Expand (N);\n \n       -----------\n       -- Floor --"}, {"sha": "a062434018ab57270726610cf91a020a8680e541", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 102, "deletions": 149, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "patch": "@@ -10274,7 +10274,6 @@ package body Exp_Ch4 is\n       Apply_Constraint_Check (Operand, Target_Type, No_Sliding => True);\n \n       if Do_Range_Check (Operand) then\n-         Set_Do_Range_Check (Operand, False);\n          Generate_Range_Check (Operand, Target_Type, CE_Range_Check_Failed);\n       end if;\n    end Expand_N_Qualified_Expression;\n@@ -10929,9 +10928,12 @@ package body Exp_Ch4 is\n    procedure Expand_N_Type_Conversion (N : Node_Id) is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Operand      : constant Node_Id    := Expression (N);\n-      Target_Type  : constant Entity_Id  := Etype (N);\n+      Target_Type  : Entity_Id           := Etype (N);\n       Operand_Type : Entity_Id           := Etype (Operand);\n \n+      procedure Discrete_Range_Check;\n+      --  Handles generation of range check for discrete target value\n+\n       procedure Handle_Changed_Representation;\n       --  This is called in the case of record and array type conversions to\n       --  see if there is a change of representation to be handled. Change of\n@@ -10954,6 +10956,44 @@ package body Exp_Ch4 is\n       --  True iff Present (Effective_Extra_Accessibility (Id)) successfully\n       --  evaluates to True.\n \n+      --------------------------\n+      -- Discrete_Range_Check --\n+      --------------------------\n+\n+      --  Case of conversions to a discrete type\n+\n+      procedure Discrete_Range_Check is\n+         Expr : Node_Id;\n+         Ityp : Entity_Id;\n+\n+      begin\n+         --  Nothing to do if conversion was rewritten\n+\n+         if Nkind (N) /= N_Type_Conversion then\n+            return;\n+         end if;\n+\n+         Expr := Expression (N);\n+\n+         --  Before we do a range check, we have to deal with treating\n+         --  a fixed-point operand as an integer. The way we do this\n+         --  is simply to do an unchecked conversion to an appropriate\n+         --  integer type large enough to hold the result.\n+\n+         if Is_Fixed_Point_Type (Etype (Expr)) then\n+            if Esize (Base_Type (Etype (Expr))) > Esize (Standard_Integer) then\n+               Ityp := Standard_Long_Long_Integer;\n+            else\n+               Ityp := Standard_Integer;\n+            end if;\n+\n+            Set_Do_Range_Check (Expr, False);\n+            Rewrite (Expr, Unchecked_Convert_To (Ityp, Expr));\n+         end if;\n+\n+         Generate_Range_Check (Expr, Target_Type, CE_Range_Check_Failed);\n+      end Discrete_Range_Check;\n+\n       -----------------------------------\n       -- Handle_Changed_Representation --\n       -----------------------------------\n@@ -11169,7 +11209,6 @@ package body Exp_Ch4 is\n          Btyp : constant Entity_Id := Base_Type (Target_Type);\n          Lo   : constant Node_Id   := Type_Low_Bound  (Target_Type);\n          Hi   : constant Node_Id   := Type_High_Bound (Target_Type);\n-         Xtyp : constant Entity_Id := Etype (Operand);\n \n          Conv   : Node_Id;\n          Hi_Arg : Node_Id;\n@@ -11193,6 +11232,12 @@ package body Exp_Ch4 is\n                       and then\n                     Hi = Type_High_Bound (Btyp))\n          then\n+            --  Unset the range check flag on the current value of\n+            --  Expression (N), since the captured Operand may have\n+            --  been rewritten (such as for the case of a conversion\n+            --  to a fixed-point type).\n+\n+            Set_Do_Range_Check (Expression (N), False);\n             return;\n          end if;\n \n@@ -11202,6 +11247,7 @@ package body Exp_Ch4 is\n          if Is_Entity_Name (Operand)\n            and then Range_Checks_Suppressed (Entity (Operand))\n          then\n+            Set_Do_Range_Check (Expression (N), False);\n             return;\n          end if;\n \n@@ -11211,12 +11257,12 @@ package body Exp_Ch4 is\n          --  not trust it to be in range (might be infinite)\n \n          declare\n-            S_Lo : constant Node_Id := Type_Low_Bound (Xtyp);\n-            S_Hi : constant Node_Id := Type_High_Bound (Xtyp);\n+            S_Lo : constant Node_Id := Type_Low_Bound (Operand_Type);\n+            S_Hi : constant Node_Id := Type_High_Bound (Operand_Type);\n \n          begin\n-            if (not Is_Floating_Point_Type (Xtyp)\n-                 or else Is_Constrained (Xtyp))\n+            if (not Is_Floating_Point_Type (Operand_Type)\n+                 or else Is_Constrained (Operand_Type))\n               and then Compile_Time_Known_Value (S_Lo)\n               and then Compile_Time_Known_Value (S_Hi)\n               and then Compile_Time_Known_Value (Hi)\n@@ -11229,7 +11275,7 @@ package body Exp_Ch4 is\n                   S_Hiv : Ureal;\n \n                begin\n-                  if Is_Real_Type (Xtyp) then\n+                  if Is_Real_Type (Operand_Type) then\n                      S_Lov := Expr_Value_R (S_Lo);\n                      S_Hiv := Expr_Value_R (S_Hi);\n                   else\n@@ -11241,30 +11287,17 @@ package body Exp_Ch4 is\n                     and then S_Lov >= D_Lov\n                     and then S_Hiv <= D_Hiv\n                   then\n-                     --  Unset the range check flag on the current value of\n-                     --  Expression (N), since the captured Operand may have\n-                     --  been rewritten (such as for the case of a conversion\n-                     --  to a fixed-point type).\n-\n                      Set_Do_Range_Check (Expression (N), False);\n-\n                      return;\n                   end if;\n                end;\n             end if;\n          end;\n \n-         --  For float to float conversions, we are done\n-\n-         if Is_Floating_Point_Type (Xtyp)\n-              and then\n-            Is_Floating_Point_Type (Btyp)\n-         then\n-            return;\n-         end if;\n-\n          --  Otherwise rewrite the conversion as described above\n \n+         Set_Do_Range_Check (Expression (N), False);\n+\n          Conv := Relocate_Node (N);\n          Rewrite (Subtype_Mark (Conv), New_Occurrence_Of (Btyp, Loc));\n          Set_Etype (Conv, Btyp);\n@@ -11273,7 +11306,7 @@ package body Exp_Ch4 is\n          --  where it is never required, since we can never have overflow in\n          --  this case.\n \n-         if not Is_Integer_Type (Etype (Operand)) then\n+         if not Is_Integer_Type (Operand_Type) then\n             Enable_Overflow_Check (Conv);\n          end if;\n \n@@ -11895,31 +11928,21 @@ package body Exp_Ch4 is\n          then\n             Set_Rounded_Result (N);\n             Set_Etype (N, Etype (Parent (N)));\n+            Target_Type := Etype (N);\n          end if;\n \n-         --  Otherwise do correct fixed-conversion, but skip these if the\n-         --  Conversion_OK flag is set, because from a semantic point of view\n-         --  these are simple integer conversions needing no further processing\n-         --  (the backend will simply treat them as integers).\n-\n-         if not Conversion_OK (N) then\n-            if Is_Fixed_Point_Type (Etype (N)) then\n-               Expand_Convert_Fixed_To_Fixed (N);\n-               Real_Range_Check;\n-\n-            elsif Is_Integer_Type (Etype (N)) then\n-               Expand_Convert_Fixed_To_Integer (N);\n-\n-               --  The result of the conversion might need a range check, so do\n-               --  not assume that the result is in bounds.\n+         if Is_Fixed_Point_Type (Target_Type) then\n+            Expand_Convert_Fixed_To_Fixed (N);\n+            Real_Range_Check;\n \n-               Set_Etype (N, Base_Type (Target_Type));\n+         elsif Is_Integer_Type (Target_Type) then\n+            Expand_Convert_Fixed_To_Integer (N);\n+            Discrete_Range_Check;\n \n-            else\n-               pragma Assert (Is_Floating_Point_Type (Etype (N)));\n-               Expand_Convert_Fixed_To_Float (N);\n-               Real_Range_Check;\n-            end if;\n+         else\n+            pragma Assert (Is_Floating_Point_Type (Target_Type));\n+            Expand_Convert_Fixed_To_Float (N);\n+            Real_Range_Check;\n          end if;\n \n       --  Case of conversions to a fixed-point type\n@@ -11941,42 +11964,6 @@ package body Exp_Ch4 is\n             Real_Range_Check;\n          end if;\n \n-      --  Case of float-to-integer conversions\n-\n-      --  We also handle float-to-fixed conversions with Conversion_OK set\n-      --  since semantically the fixed-point target is treated as though it\n-      --  were an integer in such cases.\n-\n-      elsif Is_Floating_Point_Type (Operand_Type)\n-        and then\n-          (Is_Integer_Type (Target_Type)\n-            or else\n-          (Is_Fixed_Point_Type (Target_Type) and then Conversion_OK (N)))\n-      then\n-         --  One more check here, gcc is still not able to do conversions of\n-         --  this type with proper overflow checking, and so gigi is doing an\n-         --  approximation of what is required by doing floating-point compares\n-         --  with the end-point. But that can lose precision in some cases, and\n-         --  give a wrong result. Converting the operand to Universal_Real is\n-         --  helpful, but still does not catch all cases with 64-bit integers\n-         --  on targets with only 64-bit floats.\n-\n-         --  The above comment seems obsoleted by Apply_Float_Conversion_Check\n-         --  Can this code be removed ???\n-\n-         if Do_Range_Check (Operand) then\n-            Rewrite (Operand,\n-              Make_Type_Conversion (Loc,\n-                Subtype_Mark =>\n-                  New_Occurrence_Of (Universal_Real, Loc),\n-                Expression =>\n-                  Relocate_Node (Operand)));\n-\n-            Set_Etype (Operand, Universal_Real);\n-            Enable_Range_Check (Operand);\n-            Set_Do_Range_Check (Expression (Operand), False);\n-         end if;\n-\n       --  Case of array conversions\n \n       --  Expansion of array conversions, add required length/range checks but\n@@ -12059,11 +12046,6 @@ package body Exp_Ch4 is\n \n             Analyze_And_Resolve (N, Target_Type);\n          end if;\n-\n-      --  Case of conversions to floating-point\n-\n-      elsif Is_Floating_Point_Type (Target_Type) then\n-         Real_Range_Check;\n       end if;\n \n       --  At this stage, either the conversion node has been transformed into\n@@ -12081,80 +12063,51 @@ package body Exp_Ch4 is\n       --  Check: are these rules stated in sinfo??? if so, why restate here???\n \n       --  The only remaining step is to generate a range check if we still have\n-      --  a type conversion at this stage and Do_Range_Check is set. For now we\n-      --  do this only for conversions of discrete types and for float-to-float\n-      --  conversions.\n-\n-      if Nkind (N) = N_Type_Conversion then\n+      --  a type conversion at this stage and Do_Range_Check is set.\n \n-         --  For now we only support floating-point cases where both source\n-         --  and target are floating-point types. Conversions where the source\n-         --  and target involve integer or fixed-point types are still TBD,\n-         --  though not clear whether those can even happen at this point, due\n-         --  to transformations above. ???\n+      if Nkind (N) = N_Type_Conversion\n+        and then Do_Range_Check (Expression (N))\n+      then\n+         --  Float-to-float conversions\n \n-         if Is_Floating_Point_Type (Etype (N))\n+         if Is_Floating_Point_Type (Target_Type)\n            and then Is_Floating_Point_Type (Etype (Expression (N)))\n          then\n-            if Do_Range_Check (Expression (N))\n-              and then Is_Floating_Point_Type (Target_Type)\n-            then\n-               Generate_Range_Check\n-                 (Expression (N), Target_Type, CE_Range_Check_Failed);\n-            end if;\n-\n-         --  Discrete-to-discrete conversions\n+            Generate_Range_Check\n+              (Expression (N), Target_Type, CE_Range_Check_Failed);\n \n-         elsif Is_Discrete_Type (Etype (N)) then\n-            declare\n-               Expr : constant Node_Id := Expression (N);\n-               Ftyp : Entity_Id;\n-               Ityp : Entity_Id;\n+         --  Discrete-to-discrete conversions or fixed-point-to-discrete\n+         --  conversions when Conversion_OK is set.\n \n-            begin\n-               if Do_Range_Check (Expr)\n-                 and then Is_Discrete_Type (Etype (Expr))\n-               then\n-                  Set_Do_Range_Check (Expr, False);\n-\n-                  --  Before we do a range check, we have to deal with treating\n-                  --  a fixed-point operand as an integer. The way we do this\n-                  --  is simply to do an unchecked conversion to an appropriate\n-                  --  integer type large enough to hold the result.\n-\n-                  --  This code is not active yet, because we are only dealing\n-                  --  with discrete types so far ???\n-\n-                  if Nkind (Expr) in N_Has_Treat_Fixed_As_Integer\n-                    and then Treat_Fixed_As_Integer (Expr)\n-                  then\n-                     Ftyp := Base_Type (Etype (Expr));\n+         elsif Is_Discrete_Type (Target_Type)\n+           and then (Is_Discrete_Type (Etype (Expression (N)))\n+                      or else (Is_Fixed_Point_Type (Etype (Expression (N)))\n+                                and then Conversion_OK (N)))\n+         then\n+            --  Reset overflow flag, since the range check will include\n+            --  dealing with possible overflow, and generate the check.\n \n-                     if Esize (Ftyp) >= Esize (Standard_Integer) then\n-                        Ityp := Standard_Long_Long_Integer;\n-                     else\n-                        Ityp := Standard_Integer;\n-                     end if;\n+            Set_Do_Overflow_Check (N, False);\n \n-                     Rewrite (Expr, Unchecked_Convert_To (Ityp, Expr));\n-                  end if;\n+            --  If Address is either a source type or target type,\n+            --  suppress range check to avoid typing anomalies when\n+            --  it is a visible integer type.\n \n-                  --  Reset overflow flag, since the range check will include\n-                  --  dealing with possible overflow, and generate the check.\n-                  --  If Address is either a source type or target type,\n-                  --  suppress range check to avoid typing anomalies when\n-                  --  it is a visible integer type.\n+            if Is_Descendant_Of_Address (Etype (Expression (N)))\n+              or else Is_Descendant_Of_Address (Target_Type)\n+            then\n+               Set_Do_Range_Check (Expression (N), False);\n+            else\n+               Discrete_Range_Check;\n+            end if;\n \n-                  Set_Do_Overflow_Check (N, False);\n+         --  Conversions to floating- or fixed-point when Conversion_OK is set\n \n-                  if not Is_Descendant_Of_Address (Etype (Expr))\n-                    and then not Is_Descendant_Of_Address (Target_Type)\n-                  then\n-                     Generate_Range_Check\n-                       (Expr, Target_Type, CE_Range_Check_Failed);\n-                  end if;\n-               end if;\n-            end;\n+         elsif Is_Floating_Point_Type (Target_Type)\n+           or else (Is_Fixed_Point_Type (Target_Type)\n+                     and then Conversion_OK (N))\n+         then\n+            Real_Range_Check;\n          end if;\n       end if;\n "}]}