{"sha": "4241ecb0023443edeae332690c48851e140ef10b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI0MWVjYjAwMjM0NDNlZGVhZTMzMjY5MGM0ODg1MWUxNDBlZjEwYg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2006-03-17T14:29:08Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2006-03-17T14:29:08Z"}, "message": "sh.c (max_labelno_before_reorg): New variable.\n\n\t* sh.c (max_labelno_before_reorg): New variable.\n\t(sh_reorg): Initialize it.\n\t(find_barrier): Check max_labelno_before_reorg before using\n\tlabel_to_alignment.  Take length of explicit alignment insns\n\tinto account.  When seeing a UNSPECV_CONST_END, return it.\n\n\t* sh.c (fixup_mova): Set mode of affected label to QImode.\n\t(untangle_mova): New function.\n\t(find_barrier): Use it.  Check mode of label before decrementing\n\tnum_mova.\n\t(sh_reorg): Likewise.\n\tSet mode of all insns back to VOIDmode.\n\n\t* sh.c (MOVA_LABELREF): New macro.\n\t(mova_p, fixup_mova, sh_reorg): Use it.\n\t(find_barrier, sh_reorg): Don't count num_mova back to 0 unless\n\tADDR_DIFF_VEC matches mova.\n\nFrom-SVN: r112173", "tree": {"sha": "73548bcee7edd1013d549e4ff8be4ab5cde012b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73548bcee7edd1013d549e4ff8be4ab5cde012b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4241ecb0023443edeae332690c48851e140ef10b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4241ecb0023443edeae332690c48851e140ef10b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4241ecb0023443edeae332690c48851e140ef10b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4241ecb0023443edeae332690c48851e140ef10b/comments", "author": null, "committer": null, "parents": [{"sha": "79252435187c7a7183ae23ea76ec2c027074946c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79252435187c7a7183ae23ea76ec2c027074946c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79252435187c7a7183ae23ea76ec2c027074946c"}], "stats": {"total": 144, "additions": 125, "deletions": 19}, "files": [{"sha": "865f926a44e4fbf6b1f3a387e084ca369c6b42c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4241ecb0023443edeae332690c48851e140ef10b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4241ecb0023443edeae332690c48851e140ef10b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4241ecb0023443edeae332690c48851e140ef10b", "patch": "@@ -1,3 +1,23 @@\n+2006-03-17  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\t* sh.c (max_labelno_before_reorg): New variable.\n+\t(sh_reorg): Initialize it.\n+\t(find_barrier): Check max_labelno_before_reorg before using\n+\tlabel_to_alignment.  Take length of explicit alignment insns\n+\tinto account.  When seeing a UNSPECV_CONST_END, return it.\n+\n+\t* sh.c (fixup_mova): Set mode of affected label to QImode.\n+\t(untangle_mova): New function.\n+\t(find_barrier): Use it.  Check mode of label before decrementing\n+\tnum_mova.\n+\t(sh_reorg): Likewise.\n+\tSet mode of all insns back to VOIDmode.\n+\n+\t* sh.c (MOVA_LABELREF): New macro.\n+\t(mova_p, fixup_mova, sh_reorg): Use it.\n+\t(find_barrier, sh_reorg): Don't count num_mova back to 0 unless\n+\tADDR_DIFF_VEC matches mova.\n+\n 2006-03-17  Steven Bosscher  <stevenb.gcc@gmail.com>\n \n \t* dwarf2asm.c (dw2_asm_output_offset): Mark 'base' argument"}, {"sha": "b2d18ebe669266e4be4ed208fdd6a69530bd0199", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 105, "deletions": 19, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4241ecb0023443edeae332690c48851e140ef10b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4241ecb0023443edeae332690c48851e140ef10b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4241ecb0023443edeae332690c48851e140ef10b", "patch": "@@ -3048,6 +3048,8 @@ static int pool_size;\n static rtx pool_window_label;\n static int pool_window_last;\n \n+static int max_labelno_before_reorg;\n+\n /* ??? If we need a constant in HImode which is the truncated value of a\n    constant we need in SImode, we could combine the two entries thus saving\n    two bytes.  Is this common enough to be worth the effort of implementing\n@@ -3332,6 +3334,8 @@ hi_const (rtx src)\n \t  && INTVAL (src) <= 32767);\n }\n \n+#define MOVA_LABELREF(mova) XVECEXP (SET_SRC (PATTERN (mova)), 0, 0)\n+\n /* Nonzero if the insn is a move instruction which needs to be fixed.  */\n \n /* ??? For a DImode/DFmode moves, we don't need to fix it if each half of the\n@@ -3391,16 +3395,17 @@ mova_p (rtx insn)\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n \t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPEC_MOVA\n \t  /* Don't match mova_const.  */\n-\t  && GET_CODE (XVECEXP (SET_SRC (PATTERN (insn)), 0, 0)) == LABEL_REF);\n+\t  && GET_CODE (MOVA_LABELREF (insn)) == LABEL_REF);\n }\n \n /* Fix up a mova from a switch that went out of range.  */\n static void\n fixup_mova (rtx mova)\n {\n+  PUT_MODE (XEXP (MOVA_LABELREF (mova), 0), QImode);\n   if (! flag_pic)\n     {\n-      SET_SRC (PATTERN (mova)) = XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n+      SET_SRC (PATTERN (mova)) = MOVA_LABELREF (mova);\n       INSN_CODE (mova) = -1;\n     }\n   else\n@@ -3434,6 +3439,53 @@ fixup_mova (rtx mova)\n     }\n }\n \n+/* NEW_MOVA is a mova we've just encountered while scanning forward.  Update\n+   *num_mova, and check if the new mova is not nested within the first one.\n+   return 0 if *first_mova was replaced, 1 if new_mova was replaced,\n+   2 if new_mova has been assigned to *first_mova, -1 otherwise..  */\n+static int\n+untangle_mova (int *num_mova, rtx *first_mova, rtx new_mova)\n+{\n+  int n_addr;\n+  int f_target, n_target;\n+\n+  if (optimize)\n+    {\n+      n_addr = INSN_ADDRESSES (INSN_UID (new_mova));\n+      n_target = INSN_ADDRESSES (INSN_UID (XEXP (MOVA_LABELREF (new_mova), 0)));\n+      if (n_addr > n_target || n_addr + 1022 < n_target)\n+\t{\n+\t  /* Change the mova into a load.\n+\t     broken_move will then return true for it.  */\n+\t  fixup_mova (new_mova);\n+\t  return 1;\n+\t}\n+    }\n+  if (!(*num_mova)++)\n+    {\n+      *first_mova = new_mova;\n+      return 2;\n+    }\n+  if (!optimize\n+      || ((f_target\n+\t   = INSN_ADDRESSES (INSN_UID (XEXP (MOVA_LABELREF (*first_mova), 0))))\n+\t  >= n_target))\n+    return -1;\n+\n+  (*num_mova)--;\n+  if (f_target - INSN_ADDRESSES (INSN_UID (*first_mova))\n+      > n_target - n_addr)\n+    {\n+      fixup_mova (*first_mova);\n+      return 0;\n+    }\n+  else\n+    {\n+      fixup_mova (new_mova);\n+      return 1;\n+    }\n+}\n+\n /* Find the last barrier from insn FROM which is close enough to hold the\n    constant pool.  If we can't find one, then create one near the end of\n    the range.  */\n@@ -3477,7 +3529,12 @@ find_barrier (int num_mova, rtx mova, rtx from)\n       int inc = get_attr_length (from);\n       int new_align = 1;\n \n-      if (GET_CODE (from) == CODE_LABEL)\n+      /* If this is a label that existed at the time of the compute_alignments\n+\t call, determine the alignment.  N.B.  When find_barrier recurses for\n+\t an out-of-reach mova, we might see labels at the start of previously\n+\t inserted constant tables.  */\n+      if (GET_CODE (from) == CODE_LABEL\n+\t  && CODE_LABEL_NUMBER (from) <= max_labelno_before_reorg)\n \t{\n \t  if (optimize)\n \t    new_align = 1 << label_to_alignment (from);\n@@ -3487,6 +3544,22 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t    new_align = 1;\n \t  inc = 0;\n \t}\n+      /* In case we are scanning a constant table because of recursion, check\n+\t for explicit alignments.  If the table is long, we might be forced\n+\t to emit the new table in front of it; the length of the alignment\n+\t might be the last straw.  */\n+      else if (GET_CODE (from) == INSN\n+\t       && GET_CODE (PATTERN (from)) == UNSPEC_VOLATILE\n+\t       && XINT (PATTERN (from), 1) == UNSPECV_ALIGN)\n+\tnew_align = INTVAL (XVECEXP (PATTERN (from), 0, 0));\n+      /* When we find the end of a constant table, paste the new constant\n+\t at the end.  That is better than putting it in front because\n+\t this way, we don't need extra alignment for adding a 4-byte-aligned\n+\t mov(a) label to a 2/4 or 8/4 byte aligned table.  */\n+      else if (GET_CODE (from) == INSN\n+\t       && GET_CODE (PATTERN (from)) == UNSPEC_VOLATILE\n+\t       && XINT (PATTERN (from), 1) == UNSPECV_CONST_END)\n+\treturn from;\n \n       if (GET_CODE (from) == BARRIER)\n \t{\n@@ -3551,11 +3624,16 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \n       if (mova_p (from))\n \t{\n-\t  if (! num_mova++)\n+\t  switch (untangle_mova (&num_mova, &mova, from))\n \t    {\n-\t      leading_mova = 0;\n-\t      mova = from;\n-\t      barrier_before_mova = good_barrier ? good_barrier : found_barrier;\n+\t      case 0:\treturn find_barrier (0, 0, mova);\n+\t      case 2:\n+\t\t{\n+\t\t  leading_mova = 0;\n+\t\t  barrier_before_mova\n+\t\t    = good_barrier ? good_barrier : found_barrier;\n+\t\t}\n+\t      default:\tbreak;\n \t    }\n \t  if (found_si > count_si)\n \t    count_si = found_si;\n@@ -3564,7 +3642,10 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t       && (GET_CODE (PATTERN (from)) == ADDR_VEC\n \t\t   || GET_CODE (PATTERN (from)) == ADDR_DIFF_VEC))\n \t{\n-\t  if (num_mova)\n+\t  if ((num_mova > 1 && GET_MODE (prev_nonnote_insn (from)) == VOIDmode)\n+\t      || (num_mova\n+\t\t  && (prev_nonnote_insn (from)\n+\t\t      == XEXP (MOVA_LABELREF (mova), 0))))\n \t    num_mova--;\n \t  if (barrier_align (next_real_insn (from)) == align_jumps_log)\n \t    {\n@@ -4284,6 +4365,7 @@ sh_reorg (void)\n   rtx r0_inc_rtx = gen_rtx_POST_INC (Pmode, r0_rtx);\n \n   first = get_insns ();\n+  max_labelno_before_reorg = max_label_num ();\n \n   /* We must split call insns before introducing `mova's.  If we're\n      optimizing, they'll have already been split.  Otherwise, make\n@@ -4545,21 +4627,23 @@ sh_reorg (void)\n \t     below the switch table.  Check if that has happened.\n \t     We only have the addresses available when optimizing; but then,\n \t     this check shouldn't be needed when not optimizing.  */\n-\t  rtx label_ref = XVECEXP (SET_SRC (PATTERN (insn)), 0, 0);\n-\t  if (optimize\n-\t      && (INSN_ADDRESSES (INSN_UID (insn))\n-\t\t  > INSN_ADDRESSES (INSN_UID (XEXP (label_ref, 0)))))\n+\t  if (!untangle_mova (&num_mova, &mova, insn))\n \t    {\n-\t      /* Change the mova into a load.\n-\t\t broken_move will then return true for it.  */\n-\t      fixup_mova (insn);\n+\t      insn = mova;\n+\t      num_mova = 0;\n \t    }\n-\t  else if (! num_mova++)\n-\t    mova = insn;\n \t}\n       else if (GET_CODE (insn) == JUMP_INSN\n \t       && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t       && num_mova)\n+\t       && num_mova\n+\t       /* ??? loop invariant motion can also move a mova out of a\n+\t\t  loop.  Since loop does this code motion anyway, maybe we\n+\t\t  should wrap UNSPEC_MOVA into a CONST, so that reload can\n+\t\t  move it back.  */\n+\t       && ((num_mova > 1\n+\t\t    && GET_MODE (prev_nonnote_insn (insn)) == VOIDmode)\n+\t\t   || (prev_nonnote_insn (insn)\n+\t\t       == XEXP (MOVA_LABELREF (mova), 0))))\n \t{\n \t  rtx scan;\n \t  int total;\n@@ -4717,7 +4801,9 @@ sh_reorg (void)\n \t}\n     }\n   free_alloc_pool (label_ref_list_pool);\n-  \n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    PUT_MODE (insn, VOIDmode);\n+\n   mdep_reorg_phase = SH_SHORTEN_BRANCHES1;\n   INSN_ADDRESSES_FREE ();\n   split_branches (first);"}]}