{"sha": "672987e82f472b1a6805d451963e68dc3935a163", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyOTg3ZTgyZjQ3MmIxYTY4MDVkNDUxOTYzZTY4ZGMzOTM1YTE2Mw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-26T23:13:41Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-26T23:13:41Z"}, "message": "tree-cfgcleanup.c (cfgcleanup_altered_bbs): New global variable.\n\n\t* tree-cfgcleanup.c (cfgcleanup_altered_bbs): New global variable.\n\t(remove_fallthru_edge): Use remove_edge_and_dominated_blocks.\n\t(cleanup_control_expr_graph): Do not invalidate dominance info.\n\tRecord altered blocks.\n\t(cleanup_control_flow, cleanup_forwarder_blocks): Removed.\n\t(cleanup_control_flow_bb, split_bbs_on_noreturn_calls,\n\tcleanup_tree_cfg_bb): New functions.\n\t(remove_forwarder_block): Do not maintain the worklist of blocks.\n\tRecord altered blocks.\n\t(cleanup_tree_cfg_1): Iterate over cfgcleanup_altered_bbs,\n\tnot over whole cfg.\n\t(cleanup_tree_cfg): Do not iterate cleanup_tree_cfg_1.  Only call\n\tdelete_unreachable_blocks if dominators are not available.\n\t* tree-inline.c (optimize_inline_calls): Free dominance information\n\tearlier.\n\t* tree-flow.h (remove_edge_and_dominated_blocks,\n\tcfgcleanup_altered_bbs): Altered.\n\t* tree-cfg.c (replace_uses_by, tree_merge_blocks): Record altered\n\tblocks.\n\t(get_all_dominated_blocks, remove_edge_and_dominated_blocks): New\n\tfunctions.\n\t(tree_purge_dead_eh_edges): Use remove_edge_and_dominated_blocks,\n\tdo not invalidate dominators.\n\nFrom-SVN: r124203", "tree": {"sha": "8cbde9fc5c7d1dd0444af88b49453261ddc0ee67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cbde9fc5c7d1dd0444af88b49453261ddc0ee67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/672987e82f472b1a6805d451963e68dc3935a163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672987e82f472b1a6805d451963e68dc3935a163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672987e82f472b1a6805d451963e68dc3935a163", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672987e82f472b1a6805d451963e68dc3935a163/comments", "author": null, "committer": null, "parents": [{"sha": "468a823ba9314a5a852f4a62bc042b3a21bec119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468a823ba9314a5a852f4a62bc042b3a21bec119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468a823ba9314a5a852f4a62bc042b3a21bec119"}], "stats": {"total": 508, "additions": 349, "deletions": 159}, "files": [{"sha": "2b6d43c4c971883a30f3fb81e2a6c111751b21f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672987e82f472b1a6805d451963e68dc3935a163/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672987e82f472b1a6805d451963e68dc3935a163/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=672987e82f472b1a6805d451963e68dc3935a163", "patch": "@@ -1,3 +1,29 @@\n+2007-04-27  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-cfgcleanup.c (cfgcleanup_altered_bbs): New global variable.\n+\t(remove_fallthru_edge): Use remove_edge_and_dominated_blocks.\n+\t(cleanup_control_expr_graph): Do not invalidate dominance info.\n+\tRecord altered blocks.\n+\t(cleanup_control_flow, cleanup_forwarder_blocks): Removed.\n+\t(cleanup_control_flow_bb, split_bbs_on_noreturn_calls,\n+\tcleanup_tree_cfg_bb): New functions.\n+\t(remove_forwarder_block): Do not maintain the worklist of blocks.\n+\tRecord altered blocks.\n+\t(cleanup_tree_cfg_1): Iterate over cfgcleanup_altered_bbs,\n+\tnot over whole cfg.\n+\t(cleanup_tree_cfg): Do not iterate cleanup_tree_cfg_1.  Only call\n+\tdelete_unreachable_blocks if dominators are not available.\n+\t* tree-inline.c (optimize_inline_calls): Free dominance information\n+\tearlier.\n+\t* tree-flow.h (remove_edge_and_dominated_blocks,\n+\tcfgcleanup_altered_bbs): Altered.\n+\t* tree-cfg.c (replace_uses_by, tree_merge_blocks): Record altered\n+\tblocks.\n+\t(get_all_dominated_blocks, remove_edge_and_dominated_blocks): New\n+\tfunctions.\n+\t(tree_purge_dead_eh_edges): Use remove_edge_and_dominated_blocks,\n+\tdo not invalidate dominators.\n+\n 2007-04-26  Anatoly Sokolov <aesok@post.ru>\n \n \t* config/avr/avr.c (avr_mcu_types): Add support for ATmega8HVA and "}, {"sha": "878ba6fa808729ef953db3c1b2e1b52632ac30c4", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=672987e82f472b1a6805d451963e68dc3935a163", "patch": "@@ -1199,6 +1199,8 @@ replace_uses_by (tree name, tree val)\n \t  tree rhs;\n \n \t  fold_stmt_inplace (stmt);\n+\t  if (cfgcleanup_altered_bbs)\n+\t    bitmap_set_bit (cfgcleanup_altered_bbs, bb_for_stmt (stmt)->index);\n \n \t  /* FIXME.  This should go in pop_stmt_changes.  */\n \t  rhs = get_rhs (stmt);\n@@ -1312,6 +1314,9 @@ tree_merge_blocks (basic_block a, basic_block b)\n   last = tsi_last (bb_stmt_list (a));\n   tsi_link_after (&last, bb_stmt_list (b), TSI_NEW_STMT);\n   set_bb_stmt_list (b, NULL_TREE);\n+\n+  if (cfgcleanup_altered_bbs)\n+    bitmap_set_bit (cfgcleanup_altered_bbs, a->index);\n }\n \n \n@@ -5429,6 +5434,144 @@ tree_purge_dead_abnormal_call_edges (basic_block bb)\n   return changed;\n }\n \n+/* Stores all basic blocks dominated by BB to DOM_BBS.  */\n+\n+static void\n+get_all_dominated_blocks (basic_block bb, VEC (basic_block, heap) **dom_bbs)\n+{\n+  basic_block son;\n+\n+  VEC_safe_push (basic_block, heap, *dom_bbs, bb);\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    get_all_dominated_blocks (son, dom_bbs);\n+}\n+\n+/* Removes edge E and all the blocks dominated by it, and updates dominance\n+   information.  The IL in E->src needs to be updated separately.\n+   If dominance info is not available, only the edge E is removed.*/\n+\n+void\n+remove_edge_and_dominated_blocks (edge e)\n+{\n+  VEC (basic_block, heap) *bbs_to_remove = NULL;\n+  VEC (basic_block, heap) *bbs_to_fix_dom = NULL;\n+  bitmap df, df_idom;\n+  edge f;\n+  edge_iterator ei;\n+  bool none_removed = false;\n+  unsigned i;\n+  basic_block bb, dbb;\n+  bitmap_iterator bi;\n+\n+  if (!dom_computed[CDI_DOMINATORS])\n+    {\n+      remove_edge (e);\n+      return;\n+    }\n+\n+  /* No updating is needed for edges to exit.  */\n+  if (e->dest == EXIT_BLOCK_PTR)\n+    {\n+      if (cfgcleanup_altered_bbs)\n+\tbitmap_set_bit (cfgcleanup_altered_bbs, e->src->index);\n+      remove_edge (e);\n+      return;\n+    }\n+\n+  /* First, we find the basic blocks to remove.  If E->dest has a predecessor\n+     that is not dominated by E->dest, then this set is empty.  Otherwise,\n+     all the basic blocks dominated by E->dest are removed.\n+\n+     Also, to DF_IDOM we store the immediate dominators of the blocks in\n+     the dominance frontier of E (i.e., of the successors of the\n+     removed blocks, if there are any, and of E->dest otherwise).  */\n+  FOR_EACH_EDGE (f, ei, e->dest->preds)\n+    {\n+      if (f == e)\n+\tcontinue;\n+\n+      if (!dominated_by_p (CDI_DOMINATORS, f->src, e->dest))\n+\t{\n+\t  none_removed = true;\n+\t  break;\n+\t}\n+    }\n+\n+  df = BITMAP_ALLOC (NULL);\n+  df_idom = BITMAP_ALLOC (NULL);\n+\n+  if (none_removed)\n+    bitmap_set_bit (df_idom,\n+\t\t    get_immediate_dominator (CDI_DOMINATORS, e->dest)->index);\n+  else\n+    {\n+      get_all_dominated_blocks (e->dest, &bbs_to_remove);\n+      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n+\t{\n+\t  FOR_EACH_EDGE (f, ei, bb->succs)\n+\t    {\n+\t      if (f->dest != EXIT_BLOCK_PTR)\n+\t\tbitmap_set_bit (df, f->dest->index);\n+\t    }\n+\t}\n+      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n+\tbitmap_clear_bit (df, bb->index);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (df, 0, i, bi)\n+\t{\n+\t  bb = BASIC_BLOCK (i);\n+\t  bitmap_set_bit (df_idom,\n+\t\t\t  get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n+\t}\n+    }\n+\n+  if (cfgcleanup_altered_bbs)\n+    {\n+      /* Record the set of the altered basic blocks.  */\n+      bitmap_set_bit (cfgcleanup_altered_bbs, e->src->index);\n+      bitmap_ior_into (cfgcleanup_altered_bbs, df);\n+    }\n+\n+  /* Remove E and the cancelled blocks.  */\n+  if (none_removed)\n+    remove_edge (e);\n+  else\n+    {\n+      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n+\tdelete_basic_block (bb);\n+    }\n+\n+  /* Update the dominance information.  The immediate dominator may change only\n+     for blocks whose immediate dominator belongs to DF_IDOM:\n+   \n+     Suppose that idom(X) = Y before removal of E and idom(X) != Y after the\n+     removal.  Let Z the arbitrary block such that idom(Z) = Y and\n+     Z dominates X after the removal.  Before removal, there exists a path P\n+     from Y to X that avoids Z.  Let F be the last edge on P that is\n+     removed, and let W = F->dest.  Before removal, idom(W) = Y (since Y\n+     dominates W, and because of P, Z does not dominate W), and W belongs to\n+     the dominance frontier of E.  Therefore, Y belongs to DF_IDOM.  */ \n+  EXECUTE_IF_SET_IN_BITMAP (df_idom, 0, i, bi)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      for (dbb = first_dom_son (CDI_DOMINATORS, bb);\n+\t   dbb;\n+\t   dbb = next_dom_son (CDI_DOMINATORS, dbb))\n+\tVEC_safe_push (basic_block, heap, bbs_to_fix_dom, dbb);\n+    }\n+\n+  iterate_fix_dominators (CDI_DOMINATORS,\n+\t\t\t  VEC_address (basic_block, bbs_to_fix_dom),\n+\t\t\t  VEC_length (basic_block, bbs_to_fix_dom));\n+\n+  BITMAP_FREE (df);\n+  BITMAP_FREE (df_idom);\n+  VEC_free (basic_block, heap, bbs_to_remove);\n+  VEC_free (basic_block, heap, bbs_to_fix_dom);\n+}\n+\n /* Purge dead EH edges from basic block BB.  */\n \n bool\n@@ -5446,33 +5589,13 @@ tree_purge_dead_eh_edges (basic_block bb)\n     {\n       if (e->flags & EDGE_EH)\n \t{\n-\t  remove_edge (e);\n+\t  remove_edge_and_dominated_blocks (e);\n \t  changed = true;\n \t}\n       else\n \tei_next (&ei);\n     }\n \n-  /* Removal of dead EH edges might change dominators of not\n-     just immediate successors.  E.g. when bb1 is changed so that\n-     it no longer can throw and bb1->bb3 and bb1->bb4 are dead\n-     eh edges purged by this function in:\n-           0\n-\t  / \\\n-\t v   v\n-\t 1-->2\n-        / \\  |\n-       v   v |\n-       3-->4 |\n-        \\    v\n-\t --->5\n-\t     |\n-\t     -\n-     idom(bb5) must be recomputed.  For now just free the dominance\n-     info.  */\n-  if (changed)\n-    free_dominance_info (CDI_DOMINATORS);\n-\n   return changed;\n }\n "}, {"sha": "92ac2375026ccedb29c832cf64da826e152c11bf", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 173, "deletions": 135, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=672987e82f472b1a6805d451963e68dc3935a163", "patch": "@@ -48,6 +48,15 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-ssa-propagate.h\"\n #include \"tree-scalar-evolution.h\"\n \n+/* The set of blocks in that at least one of the following changes happened:\n+   -- the statement at the end of the block was changed\n+   -- the block was newly created\n+   -- the set of the predecessors of the block changed\n+   -- the set of the successors of the block changed\n+   ??? Maybe we could track these changes separately, since they determine\n+       what cleanups it makes sense to try on the block.  */\n+bitmap cfgcleanup_altered_bbs;\n+\n /* Remove any fallthru edge from EV.  Return true if an edge was removed.  */\n \n static bool\n@@ -59,7 +68,7 @@ remove_fallthru_edge (VEC(edge,gc) *ev)\n   FOR_EACH_EDGE (e, ei, ev)\n     if ((e->flags & EDGE_FALLTHRU) != 0)\n       {\n-\tremove_edge (e);\n+\tremove_edge_and_dominated_blocks (e);\n \treturn true;\n       }\n   return false;\n@@ -124,7 +133,7 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \n \t      taken_edge->probability += e->probability;\n \t      taken_edge->count += e->count;\n-\t      remove_edge (e);\n+\t      remove_edge_and_dominated_blocks (e);\n \t      retval = true;\n \t    }\n \t  else\n@@ -138,106 +147,82 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n   else\n     taken_edge = single_succ_edge (bb);\n \n+  bitmap_set_bit (cfgcleanup_altered_bbs, bb->index);\n   bsi_remove (&bsi, true);\n   taken_edge->flags = EDGE_FALLTHRU;\n \n-  /* We removed some paths from the cfg.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-\n   return retval;\n }\n \n-/* Try to remove superfluous control structures.  */\n+/* Try to remove superfluous control structures in basic block BB.  Returns\n+   true if anything changes.  */\n \n static bool\n-cleanup_control_flow (void)\n+cleanup_control_flow_bb (basic_block bb)\n {\n-  basic_block bb;\n   block_stmt_iterator bsi;\n   bool retval = false;\n   tree stmt;\n \n-  /* Detect cases where a mid-block call is now known not to return.  */\n-  if (cfun->gimple_df)\n-    while (VEC_length (tree, MODIFIED_NORETURN_CALLS (cfun)))\n-      {\n-\tstmt = VEC_pop (tree, MODIFIED_NORETURN_CALLS (cfun));\n-\tbb = bb_for_stmt (stmt);\n-\tif (bb != NULL && last_stmt (bb) != stmt && noreturn_call_p (stmt))\n-\t  split_block (bb, stmt);\n-      }\n-\n-  FOR_EACH_BB (bb)\n+  /* If the last statement of the block could throw and now cannot,\n+     we need to prune cfg.  */\n+  retval |= tree_purge_dead_eh_edges (bb);\n+\n+  bsi = bsi_last (bb);\n+  if (bsi_end_p (bsi))\n+    return retval;\n+\n+  stmt = bsi_stmt (bsi);\n+\n+  if (TREE_CODE (stmt) == COND_EXPR\n+      || TREE_CODE (stmt) == SWITCH_EXPR)\n+    retval |= cleanup_control_expr_graph (bb, bsi);\n+  /* If we had a computed goto which has a compile-time determinable\n+     destination, then we can eliminate the goto.  */\n+  else if (TREE_CODE (stmt) == GOTO_EXPR\n+\t   && TREE_CODE (GOTO_DESTINATION (stmt)) == ADDR_EXPR\n+\t   && (TREE_CODE (TREE_OPERAND (GOTO_DESTINATION (stmt), 0))\n+\t       == LABEL_DECL))\n     {\n-      bsi = bsi_last (bb);\n-\n-      /* If the last statement of the block could throw and now cannot,\n-\t we need to prune cfg.  */\n-      retval |= tree_purge_dead_eh_edges (bb);\n-\n-      if (bsi_end_p (bsi))\n-\tcontinue;\n+      edge e;\n+      tree label;\n+      edge_iterator ei;\n+      basic_block target_block;\n \n-      stmt = bsi_stmt (bsi);\n-\n-      if (TREE_CODE (stmt) == COND_EXPR\n-\t  || TREE_CODE (stmt) == SWITCH_EXPR)\n-\tretval |= cleanup_control_expr_graph (bb, bsi);\n-      /* If we had a computed goto which has a compile-time determinable\n-\t destination, then we can eliminate the goto.  */\n-      else if (TREE_CODE (stmt) == GOTO_EXPR\n-\t       && TREE_CODE (GOTO_DESTINATION (stmt)) == ADDR_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (GOTO_DESTINATION (stmt), 0))\n-\t\t   == LABEL_DECL))\n+      /* First look at all the outgoing edges.  Delete any outgoing\n+\t edges which do not go to the right block.  For the one\n+\t edge which goes to the right block, fix up its flags.  */\n+      label = TREE_OPERAND (GOTO_DESTINATION (stmt), 0);\n+      target_block = label_to_block (label);\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n-\t  edge e;\n-\t  tree label;\n-\t  edge_iterator ei;\n-\t  basic_block target_block;\n-\t  bool removed_edge = false;\n-\n-\t  /* First look at all the outgoing edges.  Delete any outgoing\n-\t     edges which do not go to the right block.  For the one\n-\t     edge which goes to the right block, fix up its flags.  */\n-\t  label = TREE_OPERAND (GOTO_DESTINATION (stmt), 0);\n-\t  target_block = label_to_block (label);\n-\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t  if (e->dest != target_block)\n+\t    remove_edge_and_dominated_blocks (e);\n+\t  else\n \t    {\n-\t      if (e->dest != target_block)\n-\t\t{\n-\t\t  removed_edge = true;\n-\t\t  remove_edge (e);\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  /* Turn off the EDGE_ABNORMAL flag.  */\n-\t\t  e->flags &= ~EDGE_ABNORMAL;\n-\n-\t\t  /* And set EDGE_FALLTHRU.  */\n-\t\t  e->flags |= EDGE_FALLTHRU;\n-\t\t  ei_next (&ei);\n-\t\t}\n-\t    }\n+\t      /* Turn off the EDGE_ABNORMAL flag.  */\n+\t      e->flags &= ~EDGE_ABNORMAL;\n \n-\t  /* If we removed one or more edges, then we will need to fix the\n-\t     dominators.  It may be possible to incrementally update them.  */\n-\t  if (removed_edge)\n-\t    free_dominance_info (CDI_DOMINATORS);\n-\n-\t  /* Remove the GOTO_EXPR as it is not needed.  The CFG has all the\n-\t     relevant information we need.  */\n-\t  bsi_remove (&bsi, true);\n-\t  retval = true;\n+\t      /* And set EDGE_FALLTHRU.  */\n+\t      e->flags |= EDGE_FALLTHRU;\n+\t      ei_next (&ei);\n+\t    }\n \t}\n \n-      /* Check for indirect calls that have been turned into\n-\t noreturn calls.  */\n-      else if (noreturn_call_p (stmt) && remove_fallthru_edge (bb->succs))\n-\t{\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t  retval = true;\n-\t}\n+      bitmap_set_bit (cfgcleanup_altered_bbs, bb->index);\n+      bitmap_set_bit (cfgcleanup_altered_bbs, target_block->index);\n+\n+      /* Remove the GOTO_EXPR as it is not needed.  The CFG has all the\n+\t relevant information we need.  */\n+      bsi_remove (&bsi, true);\n+      retval = true;\n     }\n+\n+  /* Check for indirect calls that have been turned into\n+     noreturn calls.  */\n+  else if (noreturn_call_p (stmt) && remove_fallthru_edge (bb->succs))\n+    retval = true;\n+\n   return retval;\n }\n \n@@ -366,12 +351,10 @@ phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n   return true;\n }\n \n-/* Removes forwarder block BB.  Returns false if this failed.  If a new\n-   forwarder block is created due to redirection of edges, it is\n-   stored to worklist.  */\n+/* Removes forwarder block BB.  Returns false if this failed.  */\n \n static bool\n-remove_forwarder_block (basic_block bb, basic_block **worklist)\n+remove_forwarder_block (basic_block bb)\n {\n   edge succ = single_succ_edge (bb), e, s;\n   basic_block dest = succ->dest;\n@@ -434,6 +417,8 @@ remove_forwarder_block (basic_block bb, basic_block **worklist)\n   /* Redirect the edges.  */\n   for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n     {\n+      bitmap_set_bit (cfgcleanup_altered_bbs, e->src->index);\n+\n       if (e->flags & EDGE_ABNORMAL)\n \t{\n \t  /* If there is an abnormal edge, redirect it anyway, and\n@@ -450,15 +435,6 @@ remove_forwarder_block (basic_block bb, basic_block **worklist)\n \t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n \t    add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);\n \t}\n-      else\n-\t{\n-\t  /* The source basic block might become a forwarder.  We know\n-\t     that it was not a forwarder before, since it used to have\n-\t     at least two outgoing edges, so we may just add it to\n-\t     worklist.  */\n-\t  if (tree_forwarder_block_p (s->src, false))\n-\t    *(*worklist)++ = s->src;\n-\t}\n     }\n \n   if (seen_abnormal_edge)\n@@ -476,6 +452,8 @@ remove_forwarder_block (basic_block bb, basic_block **worklist)\n \t}\n     }\n \n+  bitmap_set_bit (cfgcleanup_altered_bbs, dest->index);\n+\n   /* Update the dominators.  */\n   if (dom_info_available_p (CDI_DOMINATORS))\n     {\n@@ -501,86 +479,147 @@ remove_forwarder_block (basic_block bb, basic_block **worklist)\n   return true;\n }\n \n-/* Removes forwarder blocks.  */\n+/* Split basic blocks on calls in the middle of a basic block that are now\n+   known not to return, and remove the unreachable code.  */\n \n static bool\n-cleanup_forwarder_blocks (void)\n+split_bbs_on_noreturn_calls (void)\n {\n-  basic_block bb;\n   bool changed = false;\n-  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks);\n-  basic_block *current = worklist;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      if (tree_forwarder_block_p (bb, false))\n-\t*current++ = bb;\n-    }\n+  tree stmt;\n+  basic_block bb;\n \n-  while (current != worklist)\n-    {\n-      bb = *--current;\n-      changed |= remove_forwarder_block (bb, &current);\n-    }\n+  /* Detect cases where a mid-block call is now known not to return.  */\n+  if (cfun->gimple_df)\n+    while (VEC_length (tree, MODIFIED_NORETURN_CALLS (cfun)))\n+      {\n+\tstmt = VEC_pop (tree, MODIFIED_NORETURN_CALLS (cfun));\n+\tbb = bb_for_stmt (stmt);\n+\tif (bb == NULL\n+\t    || last_stmt (bb) == stmt\n+\t    || !noreturn_call_p (stmt))\n+\t  continue;\n+\n+\tchanged = true;\n+\tsplit_block (bb, stmt);\n+\tremove_fallthru_edge (bb->succs);\n+      }\n \n-  free (worklist);\n   return changed;\n }\n \n-/* Do one round of CFG cleanup.  */\n+/* Tries to cleanup cfg in basic block BB.  Returns true if anything\n+   changes.  */\n \n static bool\n-cleanup_tree_cfg_1 (void)\n+cleanup_tree_cfg_bb (basic_block bb)\n {\n-  bool retval;\n+  bool retval = false;\n \n-  retval = cleanup_control_flow ();\n-  retval |= delete_unreachable_blocks ();\n+  retval = cleanup_control_flow_bb (bb);\n \n   /* Forwarder blocks can carry line number information which is\n      useful when debugging, so we only clean them up when\n      optimizing.  */\n \n-  if (optimize > 0)\n-    {\n-      /* cleanup_forwarder_blocks can redirect edges out of\n-\t SWITCH_EXPRs, which can get expensive.  So we want to enable\n-\t recording of edge to CASE_LABEL_EXPR mappings around the call\n-\t to cleanup_forwarder_blocks.  */\n-      start_recording_case_labels ();\n-      retval |= cleanup_forwarder_blocks ();\n-      end_recording_case_labels ();\n-    }\n+  if (optimize > 0\n+      && tree_forwarder_block_p (bb, false)\n+      && remove_forwarder_block (bb))\n+    return true;\n \n   /* Merging the blocks may create new opportunities for folding\n      conditional branches (due to the elimination of single-valued PHI\n      nodes).  */\n-  retval |= merge_seq_blocks ();\n+  if (single_succ_p (bb)\n+      && can_merge_blocks_p (bb, single_succ (bb)))\n+    {\n+      merge_blocks (bb, single_succ (bb));\n+      return true;\n+    }\n \n   return retval;\n }\n \n+/* Iterate the cfg cleanups, while anything changes.  */\n+\n+static bool\n+cleanup_tree_cfg_1 (void)\n+{\n+  bool retval = false;\n+  basic_block bb;\n+  unsigned i, n;\n+\n+  retval |= split_bbs_on_noreturn_calls ();\n+\n+  /* Prepare the worklists of altered blocks.  */\n+  cfgcleanup_altered_bbs = BITMAP_ALLOC (NULL);\n+\n+  /* During forwarder block cleanup, we may redirect edges out of\n+     SWITCH_EXPRs, which can get expensive.  So we want to enable\n+     recording of edge to CASE_LABEL_EXPR.  */\n+  start_recording_case_labels ();\n+\n+  /* Start by iterating over all basic blocks.  We cannot use FOR_EACH_BB,\n+     since the basic blocks may get removed.  */\n+  n = last_basic_block;\n+  for (i = NUM_FIXED_BLOCKS; i < n; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      if (bb)\n+\tretval |= cleanup_tree_cfg_bb (bb);\n+    }\n+\n+  /* Now process the altered blocks, as long as any are available.  */\n+  while (!bitmap_empty_p (cfgcleanup_altered_bbs))\n+    {\n+      i = bitmap_first_set_bit (cfgcleanup_altered_bbs);\n+      bitmap_clear_bit (cfgcleanup_altered_bbs, i);\n+      if (i < NUM_FIXED_BLOCKS)\n+\tcontinue;\n+\n+      bb = BASIC_BLOCK (i);\n+      if (!bb)\n+\tcontinue;\n+\n+      retval |= cleanup_tree_cfg_bb (bb);\n+\n+      /* Rerun split_bbs_on_noreturn_calls, in case we have altered any noreturn\n+\t calls.  */\n+      retval |= split_bbs_on_noreturn_calls ();\n+    }\n+  \n+  end_recording_case_labels ();\n+  BITMAP_FREE (cfgcleanup_altered_bbs);\n+  return retval;\n+}\n+\n \n /* Remove unreachable blocks and other miscellaneous clean up work.\n    Return true if the flowgraph was modified, false otherwise.  */\n \n bool\n cleanup_tree_cfg (void)\n {\n-  bool retval, changed;\n+  bool changed;\n \n   timevar_push (TV_TREE_CLEANUP_CFG);\n \n   /* Iterate until there are no more cleanups left to do.  If any\n-     iteration changed the flowgraph, set CHANGED to true.  */\n-  changed = false;\n-  do\n+     iteration changed the flowgraph, set CHANGED to true.\n+\n+     If dominance information is available, there cannot be any unreachable\n+     blocks.  */\n+  if (!dom_computed[CDI_DOMINATORS])\n     {\n-      retval = cleanup_tree_cfg_1 ();\n-      changed |= retval;\n+      changed = delete_unreachable_blocks ();\n+      calculate_dominance_info (CDI_DOMINATORS);\n     }\n-  while (retval);\n+  else\n+    changed = false;\n \n+  changed |= cleanup_tree_cfg_1 ();\n+\n+  gcc_assert (dom_computed[CDI_DOMINATORS]);\n   compact_blocks ();\n \n #ifdef ENABLE_CHECKING\n@@ -602,7 +641,6 @@ cleanup_tree_cfg_loop (void)\n   if (changed && current_loops != NULL)\n     {\n       bitmap changed_bbs = BITMAP_ALLOC (NULL);\n-      calculate_dominance_info (CDI_DOMINATORS);\n       fix_loop_structure (changed_bbs);\n \n       /* This usually does nothing.  But sometimes parts of cfg that originally"}, {"sha": "b7f6585b9071384269622b4bbdd9d31140f7dfc9", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=672987e82f472b1a6805d451963e68dc3935a163", "patch": "@@ -778,8 +778,10 @@ extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);\n extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n \t\t\t\t           basic_block);\n+void remove_edge_and_dominated_blocks (edge);\n \n /* In tree-cfgcleanup.c  */\n+extern bitmap cfgcleanup_altered_bbs;\n extern bool cleanup_tree_cfg (void);\n extern bool cleanup_tree_cfg_loop (void);\n "}, {"sha": "ba8a71eeb87a617df9ba394e70999a7e4a7e146f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672987e82f472b1a6805d451963e68dc3935a163/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=672987e82f472b1a6805d451963e68dc3935a163", "patch": "@@ -2804,6 +2804,10 @@ optimize_inline_calls (tree fn)\n \n   push_gimplify_context ();\n \n+  /* We make no attempts to keep dominance info up-to-date.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n   /* Reach the trees by walking over the CFG, and note the\n      enclosing basic-blocks in the call edges.  */\n   /* We walk the blocks going forward, because inlined function bodies\n@@ -2840,9 +2844,6 @@ optimize_inline_calls (tree fn)\n   fold_cond_expr_cond ();\n   if (current_function_has_nonlocal_label)\n     make_nonlocal_label_edges ();\n-  /* We make no attempts to keep dominance info up-to-date.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n      not possible yet - the IPA passes might make various functions to not\n      throw and they don't care to proactively update local EH info.  This is"}]}