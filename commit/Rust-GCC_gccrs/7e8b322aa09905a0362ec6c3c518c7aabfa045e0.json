{"sha": "7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4YjMyMmFhMDk5MDVhMDM2MmVjNmMzYzUxOGM3YWFiZmEwNDVlMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-07-25T13:11:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-07-25T13:11:32Z"}, "message": "cgraphbuild.c (record_reference): Drop non-unit-at-a-time code.\n\n\n\n\t* cgraphbuild.c (record_reference): Drop non-unit-at-a-time code.\n\t(build_cgraph_edges): Likewise.\n\t* cgraph.c (cgraph_node): Do not update assembler hash.\n\t(cgraph_remove_node): Drop non-unit-at-a-time code.\n\t* tree-pass.h (pass_O0_always_inline): Remove.\n\t* ipa-reference.c (gate_reference): Remove unit-at-a-time check.\n\t* toplev.c (process_options): Flag unit-at-a-time does not imply\n\tno section anchors.\n\t* cgraphunit.c: Update comments.\n\t(decide_is_function_needed): Drop non-unit-at-a-time mode.\n\t(cgraph_assemble_pending_functions): Remove.\n\t(cgraph_reset_node): Drop non-unit-at-a-time code.\n\t(cgraph_finalize_function): Likewise.\n\t(cgraph_analyze_function): Likewise.\n\t(cgraph_finalize_compilation_unit): Likewise.\n\t(cgraph_expand_function): Likewise.\n\t(cgraph_optimize): Likesise.\n\t(save_inline_function_body): Likewise.\n\t* ipa-pure-const.c (gate_pure_const): Drop flag_unit_at_a_time check.\n\t* tree-ssa-alias.c (maybe_be_aliased): Likewise.\n\t* ipa-inline.c: Update comments.\n\t(enum inlining_mode): remove INLINE_SPEED.\n\t(cgraph_clone_inlined_nodes): Drop unit-at-a-time check.\n\t(cgraph_mark_inline_edge): Likewise.\n\t(try_inline): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t(cgraph_gate_inlining): Remove.\n\t(cgraph_early_inlining): Remove flag_unit_at_a_time checks.\n\t(cgraph_gate_early_inlining): Likewise.\n\t(gate_inline_passes): Remove.\n\t(pass_inline_parameters, pass_ipa_inline): Remove gates.\n\t(cgraph_gate_O0_always_inline, cgraph_O0_always_inline, \n\tpass_O0_always_inline): Remove.\n\t* c-pch.c (c_pch_matching): Remove -funit-at-a-time.\n\t* dwarf2out.c (reference_to_unused): Remove flag_unit_at_a_time check.\n\t* opts.c (no_unit_at_a_time_default): Remove.\n\t(decode_options): Remove flag_unit_at_a_time reset and warning.\n\t* opts.h (no_unit_at_a_time_default): Remove.\n\t* c-decl.c (diagnose_mismatched_decls): Do not require inline keyword\n\tearly in GNU dialect.\n\t(merge_decls): Update comment; drop unit-at-a-time check.\n\t(finish_decl): Likewise.\n\t(grok_declaration): Remove flag_inline_trees code.\n\t(finish_functions): Return on function returning non-void on all\n\tstatics.\n\t* ipa-tye-escape.c (gate_type_escape_vars): Remove.\n\t* cfgexpand.c (expand_one_static_var): Remove.\n\t(expand_one_var): Remove expand_one_static_var call.\n\t(expand_used_vars_for_block): Remove flag_unit_a_time check.\n\t* c-opts.c (c_common_post_options): Remove flag_inline_trees code\n\tand flag_unit_at_a-time compatibility checks.\n\t* varasm.c (assemble_alias): Remove flag_unit_at_a_time check.\n\t* tree-inline.c (flag_inline_trees): Remove.\n\t(inlinable_function_p): Don't check it.\n\t(expand_call_inline): Remove non-unit-at-a-time code.\n\t* tree-inline.h (flag_inline_trees): Remove.\n\t* tree-optimize.c (execute_early_local_optimizations): Remove\n\tunit-at-a-time checks.\n\t(tree_rest_of_compilation): Likewise.\n\t* combine.c (setup_incoming_promotions): Likewise.\n\t* tree-profile.c (tree_gen_ic_func_profiler): Likewise.\n\t* tree-ssa-structalias.c (delete_points_to_sets): Likewise.\n\t* passes.c (pass_inline_parameters): Update comments; remove\n\tO0_alwaysinline pass.\n\t(execute_one_ipa_transform_pass): Do not reset in_gimple_form.\n\t(execute_one_pass): Likewise.\n\t* i386.c (ix86_function_regparm): Remove unit-at-a-time check.\n\t(ix86_function_sseregparm): Likewise.\n\t* arm.c (arm_function_in_section_p): Likewise.\n\t* bfin.c (bfin_load_pic_reg, bfin_function_ok_for_sibcall): Likewise.\n\t* varpool.c: Update comments.\n\t(decide_is_variable_needed): Remove unit-at-a-time checks.\n\t(varpool_finalize_decl): Likewise.\n\n\t* ada/utils.c (end_subprog_body): Remove inline trees check.\n\t* ada/misc.c (gnat_post_options): Do not set flag_inline_trees.\n\n\t* fortran/options.c (gfc_post_options): Remove flag_unline_trees code.\n\n\t* gcc.dg/winline-4.c: Remove.\n\t* gcc.dg/pch/valid-3.hs: Remove.\n\t* gcc.dg/pch/valid-3.c: Remove.\n\t* g++.old-deja/g++.brendan/crash52.C: Accept returning void warning\n\t* g++.old-deja/g++.jason/report.C: Likewise.\n\t* testsuite/g++.dg/warn/pr23075.C: We get returning void warning\n\tinstead of control flow warning.\n\n\n\t* cp/decl.c (duplicate_decls): Update comment and unit-at-a-time.\n\t(grogfndecl): Drop flag_inline_trees code.\n\t* cp/pt.c (instantiate_decl): Drop flag_iline_trees code.\n\t* cp/lex.c (cxx_init): Do not set unit-at-a-time.\n\n\n\t* java/decl.c: Include cgraph.h\n\t(end_java_method): Remove non-unit-at-a-time code.\n\t(java_mark_decl_local): Likewise; sanity check that we don't touch\n\tfinalized nodes.\n\nFrom-SVN: r138140", "tree": {"sha": "9b604148723313647c631665054f4f32b0f747d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b604148723313647c631665054f4f32b0f747d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/comments", "author": null, "committer": null, "parents": [{"sha": "4a7bb85b7b613cf33e18c889234665a324283e71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7bb85b7b613cf33e18c889234665a324283e71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7bb85b7b613cf33e18c889234665a324283e71"}], "stats": {"total": 821, "additions": 222, "deletions": 599}, "files": [{"sha": "2972dc4c4dd2767efc0da5d4ba258d041ed2ab27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,79 @@\n+2008-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (record_reference): Drop non-unit-at-a-time code.\n+\t(build_cgraph_edges): Likewise.\n+\t* cgraph.c (cgraph_node): Do not update assembler hash.\n+\t(cgraph_remove_node): Drop non-unit-at-a-time code.\n+\t* tree-pass.h (pass_O0_always_inline): Remove.\n+\t* ipa-reference.c (gate_reference): Remove unit-at-a-time check.\n+\t* toplev.c (process_options): Flag unit-at-a-time does not imply\n+\tno section anchors.\n+\t* cgraphunit.c: Update comments.\n+\t(decide_is_function_needed): Drop non-unit-at-a-time mode.\n+\t(cgraph_assemble_pending_functions): Remove.\n+\t(cgraph_reset_node): Drop non-unit-at-a-time code.\n+\t(cgraph_finalize_function): Likewise.\n+\t(cgraph_analyze_function): Likewise.\n+\t(cgraph_finalize_compilation_unit): Likewise.\n+\t(cgraph_expand_function): Likewise.\n+\t(cgraph_optimize): Likesise.\n+\t(save_inline_function_body): Likewise.\n+\t* ipa-pure-const.c (gate_pure_const): Drop flag_unit_at_a_time check.\n+\t* tree-ssa-alias.c (maybe_be_aliased): Likewise.\n+\t* ipa-inline.c: Update comments.\n+\t(enum inlining_mode): remove INLINE_SPEED.\n+\t(cgraph_clone_inlined_nodes): Drop unit-at-a-time check.\n+\t(cgraph_mark_inline_edge): Likewise.\n+\t(try_inline): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t(cgraph_gate_inlining): Remove.\n+\t(cgraph_early_inlining): Remove flag_unit_at_a_time checks.\n+\t(cgraph_gate_early_inlining): Likewise.\n+\t(gate_inline_passes): Remove.\n+\t(pass_inline_parameters, pass_ipa_inline): Remove gates.\n+\t(cgraph_gate_O0_always_inline, cgraph_O0_always_inline, \n+\tpass_O0_always_inline): Remove.\n+\t* c-pch.c (c_pch_matching): Remove -funit-at-a-time.\n+\t* dwarf2out.c (reference_to_unused): Remove flag_unit_at_a_time check.\n+\t* opts.c (no_unit_at_a_time_default): Remove.\n+\t(decode_options): Remove flag_unit_at_a_time reset and warning.\n+\t* opts.h (no_unit_at_a_time_default): Remove.\n+\t* c-decl.c (diagnose_mismatched_decls): Do not require inline keyword\n+\tearly in GNU dialect.\n+\t(merge_decls): Update comment; drop unit-at-a-time check.\n+\t(finish_decl): Likewise.\n+\t(grok_declaration): Remove flag_inline_trees code.\n+\t(finish_functions): Return on function returning non-void on all\n+\tstatics.\n+\t* ipa-tye-escape.c (gate_type_escape_vars): Remove.\n+\t* cfgexpand.c (expand_one_static_var): Remove.\n+\t(expand_one_var): Remove expand_one_static_var call.\n+\t(expand_used_vars_for_block): Remove flag_unit_a_time check.\n+\t* c-opts.c (c_common_post_options): Remove flag_inline_trees code\n+\tand flag_unit_at_a-time compatibility checks.\n+\t* varasm.c (assemble_alias): Remove flag_unit_at_a_time check.\n+\t* tree-inline.c (flag_inline_trees): Remove.\n+\t(inlinable_function_p): Don't check it.\n+\t(expand_call_inline): Remove non-unit-at-a-time code.\n+\t* tree-inline.h (flag_inline_trees): Remove.\n+\t* tree-optimize.c (execute_early_local_optimizations): Remove\n+\tunit-at-a-time checks.\n+\t(tree_rest_of_compilation): Likewise.\n+\t* combine.c (setup_incoming_promotions): Likewise.\n+\t* tree-profile.c (tree_gen_ic_func_profiler): Likewise.\n+\t* tree-ssa-structalias.c (delete_points_to_sets): Likewise.\n+\t* passes.c (pass_inline_parameters): Update comments; remove\n+\tO0_alwaysinline pass.\n+\t(execute_one_ipa_transform_pass): Do not reset in_gimple_form.\n+\t(execute_one_pass): Likewise.\n+\t* i386.c (ix86_function_regparm): Remove unit-at-a-time check.\n+\t(ix86_function_sseregparm): Likewise.\n+\t* arm.c (arm_function_in_section_p): Likewise.\n+\t* bfin.c (bfin_load_pic_reg, bfin_function_ok_for_sibcall): Likewise.\n+\t* varpool.c: Update comments.\n+\t(decide_is_variable_needed): Remove unit-at-a-time checks.\n+\t(varpool_finalize_decl): Likewise.\n+\n 2008-07-24  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.h (OPTIMIZATION_OPTIONS): Set flag_omit_frame_pointer"}, {"sha": "137d6524c6e94ad64ad8655e3aa7fb16f3bbe43f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,8 @@\n+2008-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ada/utils.c (end_subprog_body): Remove inline trees check.\n+\t* ada/misc.c (gnat_post_options): Do not set flag_inline_trees.\n+\n 2008-07-25  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* raise-gcc.c: Move tsystem.h before tm.h."}, {"sha": "006da96b2b73656518fbc124a333b5b8ff908d76", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -340,12 +340,8 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n   /* ??? The warning machinery is outsmarted by Ada.  */\n   warn_unused_parameter = 0;\n \n-  flag_inline_trees = 1;\n-\n   if (!flag_no_inline)\n     flag_no_inline = 1;\n-  if (flag_inline_functions)\n-    flag_inline_trees = 2;\n \n   /* Force eliminate_unused_debug_types to 0 unless an explicit positive\n      -f has been passed.  This forces the default to 0 for Ada, which might"}, {"sha": "4668fa21c3644fe96e95b7d57a493c6dfd744002", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -2217,8 +2217,7 @@ end_subprog_body (tree body)\n \n   /* Deal with inline.  If declared inline or we should default to inline,\n      set the flag in the decl.  */\n-  DECL_INLINE (fndecl)\n-    = DECL_DECLARED_INLINE_P (fndecl) || flag_inline_trees == 2;\n+  DECL_INLINE (fndecl) = 1;\n \n   /* We handle pending sizes via the elaboration of types, so we don't\n      need to save them.  */"}, {"sha": "dd5f1ea08883b24000472dffaf561e90f9516962", "filename": "gcc/c-decl.c", "status": "modified", "additions": 7, "deletions": 38, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1515,30 +1515,6 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t   \"noinline follows inline declaration \", newdecl);\n \t  warned = true;\n \t}\n-\n-      /* Inline declaration after use or definition.\n-\t ??? Should we still warn about this now we have unit-at-a-time\n-\t mode and can get it right?\n-\t Definitely don't complain if the decls are in different translation\n-\t units.\n-\t C99 permits this, so don't warn in that case.  (The function\n-\t may not be inlined everywhere in function-at-a-time mode, but\n-\t we still shouldn't warn.)  */\n-      if (DECL_DECLARED_INLINE_P (newdecl) && !DECL_DECLARED_INLINE_P (olddecl)\n-\t  && same_translation_unit_p (olddecl, newdecl)\n-\t  && flag_gnu89_inline)\n-\t{\n-\t  if (TREE_USED (olddecl))\n-\t    {\n-\t      warning (0, \"%q+D declared inline after being called\", olddecl);\n-\t      warned = true;\n-\t    }\n-\t  else if (DECL_INITIAL (olddecl))\n-\t    {\n-\t      warning (0, \"%q+D declared inline after its definition\", olddecl);\n-\t      warned = true;\n-\t    }\n-\t}\n     }\n   else /* PARM_DECL, VAR_DECL */\n     {\n@@ -1801,9 +1777,9 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n       if (new_is_definition && DECL_INITIAL (olddecl))\n \t{\n \t  if (TREE_USED (olddecl)\n-\t      /* In unit-at-a-time mode we never inline re-defined extern\n-\t\t inline functions.  */\n-\t      && !flag_unit_at_a_time\n+\t      /* We never inline re-defined extern inline functions.\n+\t\t FIXME: This would be better handled by keeping both functions\n+\t\t as separate declarations.  */\n \t      && cgraph_function_possibly_inlined_p (olddecl))\n \t    (*debug_hooks->outlining_inline_function) (olddecl);\n \n@@ -3618,10 +3594,6 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t}\n     }\n \n-  /* If this was marked 'used', be sure it will be output.  */\n-  if (!flag_unit_at_a_time && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    mark_decl_referenced (decl);\n-\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n@@ -4878,10 +4850,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (initialized)\n \t      DECL_INLINE (decl) = 1;\n \t  }\n-\t/* If -finline-functions, assume it can be inlined.  This does\n-\t   two things: let the function be deferred until it is actually\n-\t   needed, and let dwarf2 know that the function is inlinable.  */\n-\telse if (flag_inline_trees == 2 && initialized)\n+\telse if (initialized)\n \t  DECL_INLINE (decl) = 1;\n       }\n     else\n@@ -6755,9 +6724,9 @@ finish_function (void)\n       && !MAIN_NAME_P (DECL_NAME (fndecl))\n       /* Or if they didn't actually specify a return type.  */\n       && !C_FUNCTION_IMPLICIT_INT (fndecl)\n-      /* Normally, with -Wreturn-type, flow will complain.  Unless we're an\n-\t inline function, as we might never be compiled separately.  */\n-      && DECL_INLINE (fndecl))\n+      /* Normally, with -Wreturn-type, flow will complain, but we might\n+         optimize out static functions.  */\n+      && !TREE_PUBLIC (fndecl))\n     {\n       warning (OPT_Wreturn_type,\n \t       \"no return statement in function returning non-void\");"}, {"sha": "258101c39cfaee7c7f03d30cae0876f4882002c3", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1018,13 +1018,9 @@ c_common_post_options (const char **pfilename)\n   C_COMMON_OVERRIDE_OPTIONS;\n #endif\n \n-  flag_inline_trees = 1;\n-\n   /* Use tree inlining.  */\n   if (!flag_no_inline)\n     flag_no_inline = 1;\n-  if (flag_inline_functions)\n-    flag_inline_trees = 2;\n \n   /* By default we use C99 inline semantics in GNU99 or C99 mode.  C99\n      inline semantics are not supported in GNU89 or C89 mode.  */\n@@ -1033,14 +1029,6 @@ c_common_post_options (const char **pfilename)\n   else if (!flag_gnu89_inline && !flag_isoc99)\n     error (\"-fno-gnu89-inline is only supported in GNU99 or C99 mode\");\n \n-  /* If we are given more than one input file, we must use\n-     unit-at-a-time mode.  */\n-  if (num_in_fnames > 1)\n-    flag_unit_at_a_time = 1;\n-\n-  if (pch_file && !flag_unit_at_a_time)\n-    sorry (\"Precompiled headers require -funit-at-a-time\");\n-\n   /* Default to ObjC sjlj exception handling if NeXT runtime.  */\n   if (flag_objc_sjlj_exceptions < 0)\n     flag_objc_sjlj_exceptions = flag_next_runtime;\n@@ -1091,12 +1079,7 @@ c_common_post_options (const char **pfilename)\n   if (c_dialect_cxx ())\n     {\n       if (!flag_no_inline)\n-\t{\n-\t  flag_inline_trees = 1;\n-\t  flag_no_inline = 1;\n-\t}\n-      if (flag_inline_functions)\n-\tflag_inline_trees = 2;\n+\tflag_no_inline = 1;\n     } \n \n   /* In C, -Wconversion enables -Wsign-conversion (unless disabled"}, {"sha": "3fde4611faba1cd1e5d27af0048efcbbd63c73a0", "filename": "gcc/c-pch.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -45,7 +45,6 @@ static const struct c_pch_matching\n   const char *flag_name;\n } pch_matching[] = {\n   { &flag_exceptions, \"-fexceptions\" },\n-  { &flag_unit_at_a_time, \"-funit-at-a-time\" }\n };\n \n enum {"}, {"sha": "69bd69c33d8d720de040ae8f61d8ef88a26e5824", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -617,28 +617,6 @@ expand_one_stack_var (tree var)\n   expand_one_stack_var_at (var, offset);\n }\n \n-/* A subroutine of expand_one_var.  Called to assign rtl\n-   to a TREE_STATIC VAR_DECL.  */\n-\n-static void\n-expand_one_static_var (tree var)\n-{\n-  /* In unit-at-a-time all the static variables are expanded at the end\n-     of compilation process.  */\n-  if (flag_unit_at_a_time)\n-    return;\n-  /* If this is an inlined copy of a static local variable,\n-     look up the original.  */\n-  var = DECL_ORIGIN (var);\n-\n-  /* If we've already processed this variable because of that, do nothing.  */\n-  if (TREE_ASM_WRITTEN (var))\n-    return;\n-\n-  /* Otherwise, just emit the variable.  */\n-  rest_of_decl_compilation (var, 0, 0);\n-}\n-\n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n    that will reside in a hard register.  */\n \n@@ -742,10 +720,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n   else if (DECL_HAS_VALUE_EXPR_P (var))\n     ;\n   else if (TREE_STATIC (var))\n-    {\n-      if (really_expand)\n-        expand_one_static_var (var);\n-    }\n+    ;\n   else if (DECL_RTL_SET_P (var))\n     ;\n   else if (TREE_TYPE (var) == error_mark_node)\n@@ -790,12 +765,7 @@ expand_used_vars_for_block (tree block, bool toplevel)\n \n   /* Expand all variables at this level.  */\n   for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n-    if (TREE_USED (t)\n-\t/* Force local static variables to be output when marked by\n-\t   used attribute.  For unit-at-a-time, cgraph code already takes\n-\t   care of this.  */\n-\t|| (!flag_unit_at_a_time && TREE_STATIC (t)\n-\t    && DECL_PRESERVE_P (t)))\n+    if (TREE_USED (t))\n       expand_one_var (t, toplevel, true);\n \n   this_sv_num = stack_vars_num;"}, {"sha": "c4ad33ef4b5d9c939409940cd8600760ab34f191", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -412,17 +412,6 @@ cgraph_node (tree decl)\n       node->master_clone = node;\n     }\n \n-  /* This code can go away once flag_unit_at_a_mode is removed.  */\n-  if (assembler_name_hash)\n-    {\n-      tree name = DECL_ASSEMBLER_NAME (node->decl);\n-      slot = ((struct cgraph_node **)\n-              htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t        decl_assembler_name_hash (name),\n-\t\t\t\t        INSERT));\n-      if (!*slot)\n-        *slot = node;\n-    }\n   return node;\n }\n \n@@ -894,7 +883,7 @@ cgraph_remove_node (struct cgraph_node *node)\n         htab_clear_slot (assembler_name_hash, slot);\n     }\n \n-  if (kill_body && flag_unit_at_a_time)\n+  if (kill_body)\n     cgraph_release_function_body (node);\n   node->decl = NULL;\n   if (node->call_site_hash)"}, {"sha": "60b691113d976a8b03eb9f006f602d397e5688e8", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -38,6 +38,7 @@ static tree\n record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp;\n+  tree decl;\n \n   switch (TREE_CODE (t))\n     {\n@@ -52,32 +53,23 @@ record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n     case FDESC_EXPR:\n     case ADDR_EXPR:\n-      if (flag_unit_at_a_time)\n-\t{\n-\t  /* Record dereferences to the functions.  This makes the\n-\t     functions reachable unconditionally.  */\n-\t  tree decl = TREE_OPERAND (*tp, 0);\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    cgraph_mark_needed_node (cgraph_node (decl));\n-\t}\n+      /* Record dereferences to the functions.  This makes the\n+\t functions reachable unconditionally.  */\n+      decl = TREE_OPERAND (*tp, 0);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tcgraph_mark_needed_node (cgraph_node (decl));\n       break;\n \n     case OMP_PARALLEL:\n-      if (flag_unit_at_a_time)\n-\t{\n-\t  if (OMP_PARALLEL_FN (*tp))\n-\t    cgraph_mark_needed_node (cgraph_node (OMP_PARALLEL_FN (*tp)));\n-\t}\n+      if (OMP_PARALLEL_FN (*tp))\n+\tcgraph_mark_needed_node (cgraph_node (OMP_PARALLEL_FN (*tp)));\n       break;\n \n     case OMP_TASK:\n-      if (flag_unit_at_a_time)\n-\t{\n-\t  if (OMP_TASK_FN (*tp))\n-\t    cgraph_mark_needed_node (cgraph_node (OMP_TASK_FN (*tp)));\n-\t  if (OMP_TASK_COPYFN (*tp))\n-\t    cgraph_mark_needed_node (cgraph_node (OMP_TASK_COPYFN (*tp)));\n-\t}\n+      if (OMP_TASK_FN (*tp))\n+\tcgraph_mark_needed_node (cgraph_node (OMP_TASK_FN (*tp)));\n+      if (OMP_TASK_COPYFN (*tp))\n+\tcgraph_mark_needed_node (cgraph_node (OMP_TASK_COPYFN (*tp)));\n       break;\n \n     default:\n@@ -187,8 +179,7 @@ build_cgraph_edges (void)\n     {\n       tree decl = TREE_VALUE (step);\n       if (TREE_CODE (decl) == VAR_DECL\n-\t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-\t  && flag_unit_at_a_time)\n+\t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl)))\n \tvarpool_finalize_decl (decl);\n       else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n \twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);"}, {"sha": "674d6da012fd31282c0efdbe03d88036852b1983", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 15, "deletions": 169, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n       This function is called once (source level) compilation unit is finalized\n       and it will no longer change.\n \n-      In the unit-at-a-time the call-graph construction and local function\n+      In the the call-graph construction and local function\n       analysis takes place here.  Bodies of unreachable functions are released\n       to conserve memory usage.\n \n@@ -77,9 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n       ??? On the tree-ssa genericizing should take place here and we will avoid\n       need for these hooks (replacing them by genericizing hook)\n \n-    We implement two compilation modes.\n-\n-      - unit-at-a-time:  In this mode analyzing of all functions is deferred\n+        Analyzing of all functions is deferred\n \tto cgraph_finalize_compilation_unit and expansion into cgraph_optimize.\n \n \tIn cgraph_finalize_compilation_unit the reachable functions are\n@@ -105,23 +103,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \t??? Reorganize code so variables are output very last and only if they\n \treally has been referenced by produced code, so we catch more cases\n-\twhere reference has been optimized out.\n-\n-      - non-unit-at-a-time\n-\n-\tAll functions are variables are output as early as possible to conserve\n-\tmemory consumption.  This may or may not result in less memory used but\n-\tit is still needed for some legacy code that rely on particular ordering\n-\tof things output from the compiler.\n-\n-\tVarpool data structures are not used and variables are output directly.\n-\n-\tFunctions are output early using call of\n-\tcgraph_assemble_pending_function from cgraph_finalize_function.  The\n-\tdecision on whether function is needed is made more conservative so\n-\tuninlinable static functions are needed too.  During the call-graph\n-\tconstruction the edge destinations are not marked as reachable and it\n-\tis completely relied upon assemble_variable to mark them.  */\n+\twhere reference has been optimized out.  */\n \n \n #include \"config.h\"\n@@ -326,13 +308,11 @@ cgraph_build_cdtor_fns (void)\n \n /* Determine if function DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n-   configury, or (if not doing unit-at-a-time) to something we haven't\n-   seen yet.  */\n+   configury.  */\n \n static bool\n decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n-  tree origin;\n   if (MAIN_NAME_P (DECL_NAME (decl))\n       && TREE_PUBLIC (decl))\n     {\n@@ -344,9 +324,6 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   if (node->local.externally_visible)\n     return true;\n \n-  if (!flag_unit_at_a_time && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    return true;\n-\n   /* ??? If the assembler name is set by hand, it is possible to assemble\n      the name later after finalizing the function and the fact is noticed\n      in assemble_name then.  This is arguably a bug.  */\n@@ -389,32 +366,6 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   if (DECL_STATIC_CONSTRUCTOR (decl) || DECL_STATIC_DESTRUCTOR (decl))\n     return true;\n \n-  if (flag_unit_at_a_time)\n-    return false;\n-\n-  /* If not doing unit at a time, then we'll only defer this function\n-     if its marked for inlining.  Otherwise we want to emit it now.  */\n-\n-  /* \"extern inline\" functions are never output locally.  */\n-  if (DECL_EXTERNAL (decl))\n-    return false;\n-  /* Nested functions of extern inline function shall not be emit unless\n-     we inlined the origin.  */\n-  for (origin = decl_function_context (decl); origin;\n-       origin = decl_function_context (origin))\n-    if (DECL_EXTERNAL (origin))\n-      return false;\n-  /* We want to emit COMDAT functions only when absolutely necessary.  */\n-  if (DECL_COMDAT (decl))\n-    return false;\n-  if (!DECL_INLINE (decl)\n-      || (!node->local.disregard_inline_limits\n-\t  /* When declared inline, defer even the uninlinable functions.\n-\t     This allows them to be eliminated when unused.  */\n-\t  && !DECL_DECLARED_INLINE_P (decl)\n-\t  && (!node->local.inlinable || !cgraph_default_inline_p (node, NULL))))\n-    return true;\n-\n   return false;\n }\n \n@@ -487,39 +438,6 @@ cgraph_process_new_functions (void)\n   return output;\n }\n \n-/* When not doing unit-at-a-time, output all functions enqueued.\n-   Return true when such a functions were found.  */\n-\n-static bool\n-cgraph_assemble_pending_functions (void)\n-{\n-  bool output = false;\n-\n-  if (flag_unit_at_a_time || errorcount || sorrycount)\n-    return false;\n-\n-  cgraph_output_pending_asms ();\n-\n-  while (cgraph_nodes_queue)\n-    {\n-      struct cgraph_node *n = cgraph_nodes_queue;\n-\n-      cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n-      n->next_needed = NULL;\n-      if (!n->global.inlined_to\n-\t  && !n->alias\n-\t  && !DECL_EXTERNAL (n->decl))\n-\t{\n-\t  cgraph_expand_function (n);\n-\t  output = true;\n-\t}\n-      output |= cgraph_process_new_functions ();\n-    }\n-\n-  return output;\n-}\n-\n-\n /* As an GCC extension we allow redefinition of the function.  The\n    semantics when both copies of bodies differ is not well defined.\n    We replace the old body with new body so in unit at a time mode\n@@ -533,12 +451,11 @@ cgraph_assemble_pending_functions (void)\n static void\n cgraph_reset_node (struct cgraph_node *node)\n {\n-  /* If node->output is set, then this is a unit-at-a-time compilation\n-     and we have already begun whole-unit analysis.  This is *not*\n-     testing for whether we've already emitted the function.  That\n-     case can be sort-of legitimately seen with real function\n-     redefinition errors.  I would argue that the front end should\n-     never present us with such a case, but don't enforce that for now.  */\n+  /* If node->output is set, then we have already begun whole-unit analysis.\n+     This is *not* testing for whether we've already emitted the function.\n+     That case can be sort-of legitimately seen with real function redefinition\n+     errors.  I would argue that the front end should never present us with\n+     such a case, but don't enforce that for now.  */\n   gcc_assert (!node->output);\n \n   /* Reset our data structures so we can analyze the function again.  */\n@@ -549,18 +466,6 @@ cgraph_reset_node (struct cgraph_node *node)\n   node->local.redefined_extern_inline = true;\n   node->local.finalized = false;\n \n-  if (!flag_unit_at_a_time)\n-    {\n-      struct cgraph_node *n, *next;\n-\n-      for (n = cgraph_nodes; n; n = next)\n-\t{\n-\t  next = n->next;\n-\t  if (n->global.inlined_to == node)\n-\t    cgraph_remove_node (n);\n-\t}\n-    }\n-\n   cgraph_node_remove_callees (node);\n \n   /* We may need to re-queue the node for assembling in case\n@@ -609,11 +514,6 @@ cgraph_finalize_function (tree decl, bool nested)\n     lower_nested_functions (decl);\n   gcc_assert (!node->nested);\n \n-  /* If not unit at a time, then we need to create the call graph\n-     now, so that called functions can be queued and emitted now.  */\n-  if (!flag_unit_at_a_time)\n-    cgraph_analyze_function (node);\n-\n   if (decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n \n@@ -623,21 +523,16 @@ cgraph_finalize_function (tree decl, bool nested)\n   if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl)))\n     cgraph_mark_reachable_node (node);\n \n-  /* If not unit at a time, go ahead and emit everything we've found\n-     to be reachable at this time.  */\n-  if (!nested)\n-    {\n-      if (!cgraph_assemble_pending_functions ())\n-\tggc_collect ();\n-    }\n-\n   /* If we've not yet emitted decl, tell the debug info about it.  */\n   if (!TREE_ASM_WRITTEN (decl))\n     (*debug_hooks->deferred_inline_function) (decl);\n \n   /* Possibly warn about unused parameters.  */\n   if (warn_unused_parameter)\n     do_warn_unused_parameter (decl);\n+\n+  if (!nested)\n+    ggc_collect ();\n }\n \n /* C99 extern inline keywords allow changing of declaration after function\n@@ -855,16 +750,6 @@ cgraph_analyze_function (struct cgraph_node *node)\n   cgraph_lower_function (node);\n   node->analyzed = true;\n \n-  if (!flag_unit_at_a_time && !sorrycount && !errorcount)\n-    {\n-      bitmap_obstack_initialize (NULL);\n-      tree_register_cfg_hooks ();\n-      execute_pass_list (pass_early_local_passes.pass.sub);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      free_dominance_info (CDI_DOMINATORS);\n-      bitmap_obstack_release (NULL);\n-    }\n-\n   pop_cfun ();\n   current_function_decl = NULL;\n }\n@@ -1072,14 +957,6 @@ cgraph_finalize_compilation_unit (void)\n \n   finish_aliases_1 ();\n \n-  if (!flag_unit_at_a_time)\n-    {\n-      cgraph_output_pending_asms ();\n-      cgraph_assemble_pending_functions ();\n-      varpool_output_debug_info ();\n-      return;\n-    }\n-\n   if (!quiet_flag)\n     {\n       fprintf (stderr, \"\\nAnalyzing compilation unit\\n\");\n@@ -1147,8 +1024,7 @@ cgraph_expand_function (struct cgraph_node *node)\n   /* We ought to not compile any inline clones.  */\n   gcc_assert (!node->global.inlined_to);\n \n-  if (flag_unit_at_a_time)\n-    announce_function (decl);\n+  announce_function (decl);\n \n   gcc_assert (node->lowered);\n \n@@ -1372,16 +1248,6 @@ cgraph_optimize (void)\n   /* Call functions declared with the \"constructor\" or \"destructor\"\n      attribute.  */\n   cgraph_build_cdtor_fns ();\n-  if (!flag_unit_at_a_time)\n-    {\n-      cgraph_assemble_pending_functions ();\n-      cgraph_process_new_functions ();\n-      cgraph_state = CGRAPH_STATE_FINISHED;\n-      cgraph_output_pending_asms ();\n-      varpool_assemble_pending_decls ();\n-      varpool_output_debug_info ();\n-      return;\n-    }\n \n   /* Frontend may output common variables after the unit has been finalized.\n      It is safe to deal with them here as they are always zero initialized.  */\n@@ -1453,8 +1319,7 @@ cgraph_optimize (void)\n   verify_cgraph ();\n   /* Double check that all inline clones are gone and that all\n      function bodies have been released from memory.  */\n-  if (flag_unit_at_a_time\n-      && !(sorrycount || errorcount))\n+  if (!(sorrycount || errorcount))\n     {\n       struct cgraph_node *node;\n       bool error_found = false;\n@@ -1683,29 +1548,10 @@ save_inline_function_body (struct cgraph_node *node)\n \n   cgraph_lower_function (node);\n \n-  /* In non-unit-at-a-time we construct full fledged clone we never output to\n-     assembly file.  This clone is pointed out by inline_decl of original function\n-     and inlining infrastructure knows how to deal with this.  */\n-  if (!flag_unit_at_a_time)\n-    {\n-      struct cgraph_edge *e;\n-\n-      first_clone = cgraph_clone_node (node, node->count, 0, CGRAPH_FREQ_BASE,\n-\t\t\t\t       false);\n-      first_clone->needed = 0;\n-      first_clone->reachable = 1;\n-      /* Recursively clone all bodies.  */\n-      for (e = first_clone->callees; e; e = e->next_callee)\n-\tif (!e->inline_failed)\n-\t  cgraph_clone_inlined_nodes (e, true, false);\n-    }\n-  else\n-    first_clone = node->next_clone;\n+  first_clone = node->next_clone;\n \n   first_clone->decl = copy_node (node->decl);\n   node->next_clone = NULL;\n-  if (!flag_unit_at_a_time)\n-    node->inline_decl = first_clone->decl;\n   first_clone->prev_clone = NULL;\n   cgraph_insert_node_to_hashtable (first_clone);\n   gcc_assert (first_clone == cgraph_node (first_clone->decl));"}, {"sha": "16cd040afd52f03457086237bb02f19a6b7ec4fc", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1340,8 +1340,7 @@ setup_incoming_promotions (rtx first)\n          function lie within the current compilation unit.  (This does\n \t take into account the exporting of a function via taking its\n \t address, and so forth.)  */\n-      if (flag_unit_at_a_time)\n-\tstrictly_local = cgraph_local_info (current_function_decl)->local;\n+      strictly_local = cgraph_local_info (current_function_decl)->local;\n \n       /* The mode and signedness of the argument before any promotions happen\n          (equal to the mode of the pseudo holding it at that stage).  */"}, {"sha": "dfee7c3740e404a4d922e97c99c3963d9868c131", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -3267,11 +3267,6 @@ arm_function_in_section_p (tree decl, section *section)\n   /* If DECL_SECTION_NAME is set, assume it is trustworthy.  */\n   if (!DECL_SECTION_NAME (decl))\n     {\n-      /* Only cater for unit-at-a-time mode, where we know that the user\n-\t cannot later specify a section for DECL.  */\n-      if (!flag_unit_at_a_time)\n-\treturn false;\n-\n       /* Make sure that we will not create a unique section for DECL.  */\n       if (flag_function_sections || DECL_ONE_ONLY (decl))\n \treturn false;"}, {"sha": "843726067b6d309a509b193513b83a970ed864bc", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1129,8 +1129,7 @@ bfin_load_pic_reg (rtx dest)\n   struct cgraph_local_info *i = NULL;\n   rtx addr, insn;\n  \n-  if (flag_unit_at_a_time)\n-    i = cgraph_local_info (current_function_decl);\n+  i = cgraph_local_info (current_function_decl);\n  \n   /* Functions local to the translation unit don't need to reload the\n      pic reg, since the caller always passes a usable one.  */\n@@ -1906,6 +1905,7 @@ static bool\n bfin_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \t\t\t      tree exp ATTRIBUTE_UNUSED)\n {\n+  struct cgraph_local_info *this_func, *called_func;\n   e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n   if (fkind != SUBROUTINE)\n     return false;\n@@ -1917,17 +1917,10 @@ bfin_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n      not need to reload P5 in the prologue, but the sibcall wil pop P5 in the\n      sibcall epilogue, and we end up with the wrong value in P5.  */\n \n-  if (!flag_unit_at_a_time || decl == NULL)\n-    /* Not enough information.  */\n-    return false;\n-\n-  {\n-    struct cgraph_local_info *this_func, *called_func;\n  \n-    this_func = cgraph_local_info (current_function_decl);\n-    called_func = cgraph_local_info (decl);\n-    return !called_func->local || this_func->local;\n-  }\n+  this_func = cgraph_local_info (current_function_decl);\n+  called_func = cgraph_local_info (decl);\n+  return !called_func->local || this_func->local;\n }\n \f\n /* Emit RTL insns to initialize the variable parts of a trampoline at"}, {"sha": "fb4963fb72135c630d662abc191b9616f7467940", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -4210,7 +4210,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \n   /* Use register calling convention for local functions when possible.  */\n   if (decl && TREE_CODE (decl) == FUNCTION_DECL\n-      && flag_unit_at_a_time && !profile_flag)\n+      && !profile_flag)\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n       struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n@@ -4297,7 +4297,7 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n \n   /* For local functions, pass up to SSE_REGPARM_MAX SFmode\n      (and DFmode for SSE2) arguments in SSE registers.  */\n-  if (decl && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n+  if (decl && TARGET_SSE_MATH && !profile_flag)\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n       struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));"}, {"sha": "b63655e91acb5d5126fd3d97cc1e9937b05a4c1e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,10 @@\n+2008-07-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cp/decl.c (duplicate_decls): Update comment and unit-at-a-time.\n+\t(grogfndecl): Drop flag_inline_trees code.\n+\t* cp/pt.c (instantiate_decl): Drop flag_iline_trees code.\n+\t* cp/lex.c (cxx_init): Do not set unit-at-a-time.\n+\n 2008-07-23  Jason Merrill  <jason@redhat.com>\n \n \tImplement defaulted/deleted functions as per N2346"}, {"sha": "1bc83d47a902e3b835d76b6c5fc4faf97e0e3024", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1954,8 +1954,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t}\n       else if (new_defines_function && DECL_INITIAL (olddecl))\n \t{\n-\t  /* C++ is always in in unit-at-a-time mode, so we never\n-\t     inline re-defined extern inline functions.  */\n+\t  /* Never inline re-defined extern inline functions.\n+\t     FIXME: this could be better handled by keeping both\n+\t     function as separate declarations.  */\n \t  DECL_INLINE (newdecl) = 0;\n \t  DECL_UNINLINABLE (newdecl) = 1;\n \t}\n@@ -6643,7 +6644,7 @@ grokfndecl (tree ctype,\n   /* We inline functions that are explicitly declared inline, or, when\n      the user explicitly asks us to, all functions.  */\n   if (DECL_DECLARED_INLINE_P (decl)\n-      || (flag_inline_trees == 2 && !DECL_INLINE (decl) && funcdef_flag))\n+      || (!DECL_INLINE (decl) && funcdef_flag))\n     DECL_INLINE (decl) = 1;\n \n   DECL_EXTERNAL (decl) = 1;"}, {"sha": "2c169d1bd7605d981a3f058549162cac73130673", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -247,17 +247,6 @@ cxx_init (void)\n \n   cxx_init_decl_processing ();\n \n-  /* The fact that G++ uses COMDAT for many entities (inline\n-     functions, template instantiations, virtual tables, etc.) mean\n-     that it is fundamentally unreliable to try to make decisions\n-     about whether or not to output a particular entity until the end\n-     of the compilation.  However, the inliner requires that functions\n-     be provided to the back end if they are to be inlined.\n-     Therefore, we always use unit-at-a-time mode; in that mode, we\n-     can provide entities to the back end and it will decide what to\n-     emit based on what is actually needed.  */\n-  flag_unit_at_a_time = 1;\n-\n   if (c_common_init () == false)\n     {\n       input_location = saved_loc;"}, {"sha": "ef4fa36be7ce69801e669d940983de5efefb96a5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -15222,7 +15222,6 @@ instantiate_decl (tree d, int defer_ok,\n \t job, even though we'll not be emitting a copy of this\n \t function.  */\n       if (!(TREE_CODE (d) == FUNCTION_DECL\n-\t    && flag_inline_trees\n \t    && DECL_DECLARED_INLINE_P (d)))\n \tgoto out;\n     }"}, {"sha": "d37a2c23a7d999b20c5f0666e4621210fbbcf14d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -10448,8 +10448,6 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)\n       && ! TREE_ASM_WRITTEN (*tp))\n     return *tp;\n-  else if (!flag_unit_at_a_time)\n-    return NULL_TREE;\n   /* ???  The C++ FE emits debug information for using decls, so\n      putting gcc_unreachable here falls over.  See PR31899.  For now\n      be conservative.  */"}, {"sha": "4569f523ca4cc60a63e350af8a1619f306f7b7f7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,7 @@\n+2008-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* fortran/options.c (gfc_post_options): Remove flag_unline_trees code.\n+\n 2008-07-24  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/33141"}, {"sha": "9bbb39a35c066e9262542c24a5c81a9297838b62", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -293,13 +293,9 @@ gfc_post_options (const char **pfilename)\n \tgfc_warning_now (\"'-fd-lines-as-code' has no effect in free form\");\n     }\n \n-  flag_inline_trees = 1;\n-\n   /* Use tree inlining.  */\n   if (!flag_no_inline)\n     flag_no_inline = 1;\n-  if (flag_inline_functions)\n-    flag_inline_trees = 2;\n \n   /* If -pedantic, warn about the use of GNU extensions.  */\n   if (pedantic && (gfc_option.allow_std & GFC_STD_GNU) != 0)"}, {"sha": "6d744c43c85fb6f98a1a6526d372f3585721ebdf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 17, "deletions": 101, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -60,7 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n \n       cgraph_decide_inlining implements heuristics taking whole callgraph\n       into account, while cgraph_decide_inlining_incrementally considers\n-      only one function at a time and is used in non-unit-at-a-time mode. \n+      only one function at a time and is used by early inliner.\n \n    The inliner itself is split into several passes:\n \n@@ -82,15 +82,13 @@ along with GCC; see the file COPYING3.  If not see\n      to do inlining expanding code size it might result in unbounded growth of\n      whole unit.\n \n-     This is the main inlining pass in non-unit-at-a-time.\n-\n-     With unit-at-a-time the pass is run during conversion into SSA form.\n-     Only functions already converted into SSA form are inlined, so the\n-     conversion must happen in topological order on the callgraph (that is\n-     maintained by pass manager).  The functions after inlining are early\n-     optimized so the early inliner sees unoptimized function itself, but\n-     all considered callees are already optimized allowing it to unfold\n-     abstraction penalty on C++ effectively and cheaply.\n+     The pass is run during conversion into SSA form.  Only functions already\n+     converted into SSA form are inlined, so the conversion must happen in\n+     topological order on the callgraph (that is maintained by pass manager).\n+     The functions after inlining are early optimized so the early inliner sees\n+     unoptimized function itself, but all considered callees are already\n+     optimized allowing it to unfold abstraction penalty on C++ effectively and\n+     cheaply.\n \n    pass_ipa_early_inlining\n \n@@ -150,16 +148,11 @@ along with GCC; see the file COPYING3.  If not see\n    In SIZE mode, only functions that reduce function body size after inlining\n    are inlined, this is used during early inlining.\n \n-   In SPEED mode, all small functions are inlined.  This might result in\n-   unbounded growth of compilation unit and is used only in non-unit-at-a-time\n-   mode.\n-\n    in ALL mode, everything is inlined.  This is used during flattening.  */\n enum inlining_mode {\n   INLINE_NONE = 0,\n   INLINE_ALWAYS_INLINE,\n   INLINE_SIZE,\n-  INLINE_SPEED,\n   INLINE_ALL\n };\n static bool\n@@ -211,8 +204,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_o\n \t In that case just go ahead and re-use it.  */\n       if (!e->callee->callers->next_caller\n \t  && !e->callee->needed\n-\t  && !cgraph_new_nodes\n-\t  && flag_unit_at_a_time)\n+\t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  if (DECL_SAVED_TREE (e->callee->decl))\n@@ -262,7 +254,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original)\n   gcc_assert (e->inline_failed);\n   e->inline_failed = NULL;\n \n-  if (!e->callee->global.inlined && flag_unit_at_a_time)\n+  if (!e->callee->global.inlined)\n     DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n   e->callee->global.inlined = true;\n \n@@ -1299,13 +1291,13 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n   if (e->inline_failed)\n     cgraph_mark_inline (e);\n \n-  /* In order to fully inline always_inline functions at -O0, we need to\n+  /* In order to fully inline always_inline functions, we need to\n      recurse here, since the inlined functions might not be processed by\n      incremental inlining at all yet.  \n \n      Also flattening needs to be done recursively.  */\n \n-  if (!flag_unit_at_a_time || mode == INLINE_ALL || always_inline)\n+  if (mode == INLINE_ALL || always_inline)\n     cgraph_decide_inlining_incrementally (e->callee, mode, depth + 1);\n   callee->aux = (void *)(size_t) callee_mode;\n   return true;\n@@ -1495,20 +1487,11 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  }\n \tif (cgraph_default_inline_p (e->callee, &failed_reason))\n \t  inlined |= try_inline (e, mode, depth);\n-\telse if (!flag_unit_at_a_time)\n-\t  e->inline_failed = failed_reason;\n       }\n   node->aux = (void *)(size_t) old_mode;\n   return inlined;\n }\n \n-/* When inlining shall be performed.  */\n-static bool\n-cgraph_gate_inlining (void)\n-{\n-  return flag_inline_trees;\n-}\n-\n /* Because inlining might remove no-longer reachable nodes, we need to\n    keep the array visible to garbage collector to avoid reading collected\n    out nodes.  */\n@@ -1526,9 +1509,7 @@ cgraph_early_inlining (void)\n \n   if (sorrycount || errorcount)\n     return 0;\n-  if (cgraph_decide_inlining_incrementally (node,\n-\t\t\t\t\t    flag_unit_at_a_time || optimize_size\n-\t\t\t\t\t    ? INLINE_SIZE : INLINE_SPEED, 0))\n+  if (cgraph_decide_inlining_incrementally (node, INLINE_SIZE, 0))\n     {\n       timevar_push (TV_INTEGRATION);\n       todo = optimize_inline_calls (current_function_decl);\n@@ -1541,7 +1522,7 @@ cgraph_early_inlining (void)\n static bool\n cgraph_gate_early_inlining (void)\n {\n-  return flag_inline_trees && flag_early_inlining;\n+  return flag_early_inlining;\n }\n \n struct gimple_opt_pass pass_early_inline = \n@@ -1567,7 +1548,7 @@ struct gimple_opt_pass pass_early_inline =\n static bool\n cgraph_gate_ipa_early_inlining (void)\n {\n-  return (flag_inline_trees && flag_early_inlining\n+  return (flag_early_inlining\n \t  && (flag_branch_probabilities || flag_test_coverage\n \t      || profile_arc_flag));\n }\n@@ -1626,19 +1607,12 @@ compute_inline_parameters_for_current (void)\n   return 0;\n }\n \n-/* When inlining shall be performed.  */\n-static bool\n-gate_inline_passes (void)\n-{\n-  return flag_inline_trees;\n-}\n-\n struct gimple_opt_pass pass_inline_parameters = \n {\n  {\n   GIMPLE_PASS,\n   NULL,\t \t\t\t\t/* name */\n-  gate_inline_passes,\t\t\t/* gate */\n+  NULL,\t\t\t\t\t/* gate */\n   compute_inline_parameters_for_current,/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n@@ -1746,7 +1720,7 @@ struct ipa_opt_pass pass_ipa_inline =\n  {\n   IPA_PASS,\n   \"inline\",\t\t\t\t/* name */\n-  cgraph_gate_inlining,\t\t\t/* gate */\n+  NULL,\t\t\t\t\t/* gate */\n   cgraph_decide_inlining,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n@@ -1769,62 +1743,4 @@ struct ipa_opt_pass pass_ipa_inline =\n };\n \n \n-/* When inlining shall be performed.  */\n-static bool\n-cgraph_gate_O0_always_inline (void)\n-{\n-  return !flag_unit_at_a_time || !flag_inline_trees;\n-}\n-\n-static unsigned int\n-cgraph_O0_always_inline (void)\n-{\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n-  unsigned int todo = 0;\n-  bool inlined;\n-\n-  if (sorrycount || errorcount)\n-    return 0;\n-  inlined = cgraph_decide_inlining_incrementally (node, INLINE_SPEED, 0);\n-  /* We might need the body of this function so that we can expand\n-     it inline somewhere else.  */\n-  if (cgraph_preserve_function_body_p (current_function_decl))\n-    save_inline_function_body (node);\n-  if (inlined || warn_inline)\n-    {\n-      timevar_push (TV_INTEGRATION);\n-      todo = optimize_inline_calls (current_function_decl);\n-      timevar_pop (TV_INTEGRATION);\n-    }\n-  /* In non-unit-at-a-time we must mark all referenced functions as needed.  */\n-  if (!flag_unit_at_a_time)\n-    {\n-      struct cgraph_edge *e;\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->analyzed)\n-          cgraph_mark_needed_node (e->callee);\n-    }\n-  return todo | execute_fixup_cfg ();\n-}\n-\n-struct gimple_opt_pass pass_O0_always_inline = \n-{\n- {\n-  GIMPLE_PASS,\n-  \"always_inline\",\t\t\t/* name */\n-  cgraph_gate_O0_always_inline,\t\t/* gate */\n-  cgraph_O0_always_inline,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  PROP_cfg,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_verify_flow\n-  | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n- }\n-};\n-\n #include \"gt-ipa-inline.h\""}, {"sha": "faa43dbd7c069392bce7e0a99de15e79799c6e21", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1212,7 +1212,7 @@ ipa_unregister_cgraph_hooks (void)\n void\n free_all_ipa_structures_after_ipa_cp (void)\n {\n-  if (!flag_indirect_inlining || !flag_inline_trees)\n+  if (!flag_indirect_inlining)\n     {\n       ipa_free_all_edge_args ();\n       ipa_free_all_node_params ();"}, {"sha": "578c48d3030d0aa543e53bed5750061e7d683594", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -771,7 +771,7 @@ static_execute (void)\n static bool\n gate_pure_const (void)\n {\n-  return (flag_unit_at_a_time != 0 && flag_ipa_pure_const \n+  return (flag_ipa_pure_const \n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }"}, {"sha": "872a4b4dc34e45bd31883db8ebf954113af59f1e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1314,7 +1314,7 @@ static_execute (void)\n static bool\n gate_reference (void)\n {\n-  return (flag_unit_at_a_time != 0  && flag_ipa_reference\n+  return (flag_ipa_reference\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }"}, {"sha": "81e6ddb635bc9d9f5666516f242219adfb454dac", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -2192,7 +2192,7 @@ type_escape_execute (void)\n static bool\n gate_type_escape_vars (void)\n {\n-  return (flag_unit_at_a_time != 0 && flag_ipa_type_escape\n+  return (flag_ipa_type_escape\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }"}, {"sha": "7fb266d850c56194f462a9c92239c9a0977a3ef5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,10 @@\n+2008-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* java/decl.c: Include cgraph.h\n+\t(end_java_method): Remove non-unit-at-a-time code.\n+\t(java_mark_decl_local): Likewise; sanity check that we don't touch\n+\tfinalized nodes.\n+\n 2008-07-15  Jan Hubicka  <jh@suse.cz>\n \n \t* lang.c (java_init_options): Enable unit-at-a-time by default."}, {"sha": "1768109414d10d8f9d1a5cb6af387f584751b156", "filename": "gcc/java/decl.c", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -49,6 +49,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"version.h\"\n #include \"tree-iterator.h\"\n #include \"langhooks.h\"\n+#include \"cgraph.h\"\n \n #if defined (DEBUG_JAVA_BINDING_LEVELS)\n extern void indent (void);\n@@ -1797,14 +1798,6 @@ end_java_method (void)\n \n   finish_method (fndecl);\n \n-  if (! flag_unit_at_a_time)\n-    {\n-      /* Nulling these fields when we no longer need them saves\n-\t memory.  */\n-      DECL_SAVED_TREE (fndecl) = NULL;\n-      DECL_STRUCT_FUNCTION (fndecl) = NULL;\n-      DECL_INITIAL (fndecl) = NULL_TREE;\n-    }\n   current_function_decl = NULL_TREE;\n }\n \n@@ -1854,15 +1847,12 @@ java_mark_decl_local (tree decl)\n {\n   DECL_EXTERNAL (decl) = 0;\n \n-  /* If we've already constructed DECL_RTL, give encode_section_info\n-     a second chance, now that we've changed the flags.  */\n-  /* ??? Ideally, we'd have flag_unit_at_a_time set, and not have done\n-     anything that would have referenced DECL_RTL so far.  But at the\n-     moment we force flag_unit_at_a_time off due to excessive memory\n-     consumption when compiling large jar files.  Which probably means\n-     that we need to re-order how we process jar files...  */\n-  if (DECL_RTL_SET_P (decl))\n-    make_decl_rtl (decl);\n+#ifdef ENABLE_CHECKING\n+  /* Double check that we didn't pass the function to the callgraph early.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    gcc_assert (!cgraph_node (decl)->local.finalized);\n+#endif\n+  gcc_assert (!DECL_RTL_SET_P (decl));\n }\n \n /* Given appropriate target support, G++ will emit hidden aliases for native"}, {"sha": "dde1b76573c0130313b30c2c313ec1657a989667", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -535,8 +535,6 @@ java_post_options (const char **pfilename)\n   /* Use tree inlining.  */\n   if (!flag_no_inline)\n     flag_no_inline = 1;\n-  if (flag_inline_functions)\n-    flag_inline_trees = 2;\n \n   /* An absolute requirement: if we're not using indirect dispatch, we\n      must always verify everything.  */"}, {"sha": "2a88ce2d1382686c143576772d474f196a1761f7", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -333,11 +333,6 @@ bool use_gnu_debug_info_extensions;\n /* The default visibility for all symbols (unless overridden) */\n enum symbol_visibility default_visibility = VISIBILITY_DEFAULT;\n \n-/* Disable unit-at-a-time for frontends that might be still broken in this\n-   respect.  */\n-\n-bool no_unit_at_a_time_default;\n-\n /* Global visibility options.  */\n struct visibility_flags visibility_options;\n \n@@ -872,13 +867,11 @@ decode_options (unsigned int argc, const char **argv)\n \t    }\n \t}\n     }\n-\n-\n+  \n   if (!flag_unit_at_a_time)\n     {\n       flag_section_anchors = 0;\n       flag_toplevel_reorder = 0;\n-      flag_unit_at_a_time = 1;\n     }\n   if (!flag_toplevel_reorder)\n     {\n@@ -1109,16 +1102,6 @@ decode_options (unsigned int argc, const char **argv)\n   if (flag_really_no_inline == 2)\n     flag_really_no_inline = flag_no_inline;\n \n-  /* Inlining of functions called just once will only work if we can look\n-     at the complete translation unit.  */\n-  if (flag_inline_functions_called_once && !flag_unit_at_a_time)\n-    {\n-      flag_inline_functions_called_once = 0;\n-      warning (OPT_Wdisabled_optimization,\n-\t       \"-funit-at-a-time is required for inlining of functions \"\n-\t       \"that are only called once\");\n-    }\n-\n   /* The optimization to partition hot and cold basic blocks into separate\n      sections of the .o and executable files does not work (currently)\n      with exception handling.  This is because there is no support for"}, {"sha": "62ad89aa5a5699e301f5f4c967a20204d0a153d3", "filename": "gcc/opts.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -64,7 +64,6 @@ extern const struct cl_option cl_options[];\n extern const unsigned int cl_options_count;\n extern const char *const lang_names[];\n extern const unsigned int cl_lang_count;\n-extern bool no_unit_at_a_time_default;\n \n #define CL_PARAMS               (1 << 18) /* Fake entry.  Used to display --param info with --help.  */\n #define CL_WARNING\t\t(1 << 19) /* Enables an (optional) warning message.  */"}, {"sha": "53d2985e9e4deaa2e54960e6b68abb27bd19c597", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -180,7 +180,7 @@ rest_of_decl_compilation (tree decl,\n       /* Don't output anything when a tentative file-scope definition\n \t is seen.  But at end of compilation, do output code for them.\n \n-\t We do output all variables when unit-at-a-time is active and rely on\n+\t We do output all variables and rely on\n \t callgraph code to defer them except for forward declarations\n \t (see gcc.c-torture/compile/920624-1.c) */\n       if ((at_end\n@@ -523,9 +523,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_inline_parameters);\n   *p = NULL;\n \n-  /* Interprocedural optimization passes. \n-     All these passes are ignored in -fno-unit-at-a-time\n-     except for subpasses of early_local_passes.  */\n+  /* Interprocedural optimization passes.  */\n   p = &all_ipa_passes;\n   NEXT_PASS (pass_ipa_function_and_variable_visibility);\n   NEXT_PASS (pass_ipa_early_inline);\n@@ -593,7 +591,6 @@ init_optimization_passes (void)\n   /* These passes are run after IPA passes on every function that is being\n      output to the assembler file.  */\n   p = &all_passes;\n-  NEXT_PASS (pass_O0_always_inline);\n   NEXT_PASS (pass_all_optimizations);\n     {\n       struct opt_pass **p = &pass_all_optimizations.pass.sub;\n@@ -1228,8 +1225,6 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n   pass_fini_dump_file (pass);\n \n   current_pass = NULL;\n-  /* Reset in_gimple_form to not break non-unit-at-a-time mode.  */\n-  in_gimple_form = false;\n }\n \n static bool\n@@ -1329,8 +1324,6 @@ execute_one_pass (struct opt_pass *pass)\n \t\t|| pass->type != RTL_PASS);\n \n   current_pass = NULL;\n-  /* Reset in_gimple_form to not break non-unit-at-a-time mode.  */\n-  in_gimple_form = false;\n \n   return true;\n }"}, {"sha": "020502ce3a5163f0fd76168437228133ceea2b27", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +1,13 @@\n+2008-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/winline-4.c: Remove.\n+\t* gcc.dg/pch/valid-3.hs: Remove.\n+\t* gcc.dg/pch/valid-3.c: Remove.\n+\t* g++.old-deja/g++.brendan/crash52.C: Accept returning void warning\n+\t* g++.old-deja/g++.jason/report.C: Likewise.\n+\t* testsuite/g++.dg/warn/pr23075.C: We get returning void warning\n+\tinstead of control flow warning.\n+\n 2008-07-24  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/33141"}, {"sha": "e5b1b483d767142d838aafbf9bc348532ff54459", "filename": "gcc/testsuite/g++.dg/warn/pr23075.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -6,4 +6,4 @@ int\n foo (void)\n {\n   return;\t// { dg-error \"with no value\" }\n-}\t\t// { dg-bogus \"control reaches end\" }\n+}\t\t// { dg-warning \"no return statement\" }"}, {"sha": "74df601554ef3d10927f52cda6bc67a312ea1f98", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash52.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash52.C?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -10,4 +10,4 @@ public:\n \n A &f(A &a) {// { dg-error \"\" }  new decl.*\n   std::cout << \"Blah\\n\";\n-}\n+} // { dg-error \"no return statement\" }"}, {"sha": "f4e02a4dc35eb11cec83a757f4680d91a7d2ac14", "filename": "gcc/testsuite/g++.old-deja/g++.jason/report.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -56,7 +56,7 @@ bar2 baz (X::Y y)\t        // { dg-error \"\" } in this context\n   bar2 wa [5];\n   wa[0] = baz(f);\n   undef2 (1); // { dg-error \"\" } implicit declaration\n-}\n+}\t\t\t\t// { dg-error \"no return statement\" }\n \n int ninny ()\n {\n@@ -71,4 +71,4 @@ int ninny ()\n int darg (char X::*p)\n {\n    undef3 (1); // { dg-error \"\" } implicit declaration\n-}\n+}\t\t\t\t// { dg-error \"no return statement\" }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/pch/valid-3.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,6 +0,0 @@\n-/* { dg-options \"-I. -Winvalid-pch -fno-unit-at-a-time\" } */\n-\n-#include \"valid-3.h\"/* { dg-warning \"settings for -funit-at-a-time do not match\" } */\n-/* { dg-error \"No such file\" \"no such file\" { target *-*-* } 3 } */\n-/* { dg-error \"they were invalid\" \"invalid files\" { target *-*-* } 3 } */\n-int x;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/pch/valid-3.hs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fvalid-3.hs?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,3 +0,0 @@\n-/* { dg-options \"-I. -Winvalid-pch -funit-at-a-time\" } */\n-\n-extern int x;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/winline-4.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-Winline -O1 -fno-unit-at-a-time\" } */\n-\n-inline int q(void);\t\t /* { dg-warning \"body not available\" } */\n-inline int t(void)\n-{\n-\treturn q();\t\t /* { dg-warning \"called from here\" } */\n-}\n-int q(void)\n-{\n-}"}, {"sha": "6ba0c83ac49baaac2688acab3a9653f3ec6b7013", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -1702,9 +1702,6 @@ process_options (void)\n   if (flag_asynchronous_unwind_tables)\n     flag_unwind_tables = 1;\n \n-  if (!flag_unit_at_a_time)\n-    flag_section_anchors = 0;\n-\n   if (flag_value_profile_transformations)\n     flag_profile_values = 1;\n "}, {"sha": "5eff3caaa18ec885d5379fac835b3395bf0d69a0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -90,13 +90,6 @@ along with GCC; see the file COPYING3.  If not see\n \n    See the CALL_EXPR handling case in copy_body_r ().  */\n \n-/* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.\n-   2 if we should consider *all* functions to be inline\n-   candidates.  */\n-\n-int flag_inline_trees = 0;\n-\n /* To Do:\n \n    o In order to make inlining-on-trees work, we pessimized\n@@ -2100,24 +2093,6 @@ inlinable_function_p (tree fn)\n   if (!DECL_SAVED_TREE (fn))\n     return false;\n \n-  /* If we're not inlining at all, then we cannot inline this function.  */\n-  else if (!flag_inline_trees)\n-    inlinable = false;\n-\n-  /* Only try to inline functions if DECL_INLINE is set.  This should be\n-     true for all functions declared `inline', and for all other functions\n-     as well with -finline-functions.\n-\n-     Don't think of disregarding DECL_INLINE when flag_inline_trees == 2;\n-     it's the front-end that must set DECL_INLINE in this case, because\n-     dwarf2out loses if a function that does not have DECL_INLINE set is\n-     inlined anyway.  That is why we have both DECL_INLINE and\n-     DECL_DECLARED_INLINE_P.  */\n-  /* FIXME: When flag_inline_trees dies, the check for flag_unit_at_a_time\n-\t    here should be redundant.  */\n-  else if (!DECL_INLINE (fn) && !flag_unit_at_a_time)\n-    inlinable = false;\n-\n   else if (inline_forbidden_p (fn))\n     {\n       /* See if we should warn about uninlinable functions.  Previously,\n@@ -2674,7 +2649,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n          where previous inlining turned indirect call into direct call by\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n-      gcc_assert (dest->needed || !flag_unit_at_a_time);\n+      gcc_assert (dest->needed);\n       cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t  bb->count, CGRAPH_FREQ_BASE,\n \t\t\t  bb->loop_depth)->inline_failed\n@@ -2699,7 +2674,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn))\n \t  /* Avoid warnings during early inline pass. */\n-\t  && (!flag_unit_at_a_time || cgraph_global_info_ready))\n+\t  && cgraph_global_info_ready)\n \t{\n \t  sorry (\"inlining failed in call to %q+F: %s\", fn, reason);\n \t  sorry (\"called from here\");\n@@ -2709,7 +2684,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \t       && strlen (reason)\n \t       && !lookup_attribute (\"noinline\", DECL_ATTRIBUTES (fn))\n \t       /* Avoid warnings during early inline pass. */\n-\t       && (!flag_unit_at_a_time || cgraph_global_info_ready))\n+\t       && cgraph_global_info_ready)\n \t{\n \t  warning (OPT_Winline, \"inlining failed in call to %q+F: %s\",\n \t\t   fn, reason);"}, {"sha": "ab03f7a20ad20657bada2671295dcdb8d6e7a628", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -157,11 +157,4 @@ extern tree remap_type (tree type, copy_body_data *id);\n \n extern HOST_WIDE_INT estimated_stack_frame_size (void);\n \n-/* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.\n-   2 if we should consider *all* functions to be inline\n-   candidates.  */\n-\n-extern int flag_inline_trees;\n-\n #endif /* GCC_TREE_INLINE_H */"}, {"sha": "820df4c2ce009a006fb3da18cba904cd8fcf5757", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -115,7 +115,7 @@ execute_early_local_optimizations (void)\n      cgraph state so newly inserted functions are also early optimized.\n      However we execute early local optimizations for lately inserted\n      functions, in that case don't reset cgraph state back to IPA_SSA.  */\n-  if (flag_unit_at_a_time && cgraph_state < CGRAPH_STATE_IPA_SSA)\n+  if (cgraph_state < CGRAPH_STATE_IPA_SSA)\n     cgraph_state = CGRAPH_STATE_IPA_SSA;\n   return 0;\n }\n@@ -391,7 +391,7 @@ tree_rest_of_compilation (tree fndecl)\n \n   timevar_push (TV_EXPAND);\n \n-  gcc_assert (!flag_unit_at_a_time || cgraph_global_info_ready);\n+  gcc_assert (cgraph_global_info_ready);\n \n   node = cgraph_node (fndecl);\n \n@@ -448,20 +448,17 @@ tree_rest_of_compilation (tree fndecl)\n \t}\n     }\n \n-  if (!flag_inline_trees)\n+  DECL_SAVED_TREE (fndecl) = NULL;\n+  if (DECL_STRUCT_FUNCTION (fndecl) == 0\n+      && !cgraph_node (fndecl)->origin)\n     {\n-      DECL_SAVED_TREE (fndecl) = NULL;\n-      if (DECL_STRUCT_FUNCTION (fndecl) == 0\n-\t  && !cgraph_node (fndecl)->origin)\n-\t{\n-\t  /* Stop pointing to the local nodes about to be freed.\n-\t     But DECL_INITIAL must remain nonzero so we know this\n-\t     was an actual function definition.\n-\t     For a nested function, this is done in c_pop_function_context.\n-\t     If rest_of_compilation set this to 0, leave it 0.  */\n-\t  if (DECL_INITIAL (fndecl) != 0)\n-\t    DECL_INITIAL (fndecl) = error_mark_node;\n-\t}\n+      /* Stop pointing to the local nodes about to be freed.\n+\t But DECL_INITIAL must remain nonzero so we know this\n+\t was an actual function definition.\n+\t For a nested function, this is done in c_pop_function_context.\n+\t If rest_of_compilation set this to 0, leave it 0.  */\n+      if (DECL_INITIAL (fndecl) != 0)\n+\tDECL_INITIAL (fndecl) = error_mark_node;\n     }\n \n   input_location = saved_loc;"}, {"sha": "8d50aacebf0a1c0c87c04bac4f96fe85c3f38c0d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -504,7 +504,6 @@ extern struct rtl_opt_pass pass_final;\n extern struct rtl_opt_pass pass_rtl_seqabstr;\n extern struct gimple_opt_pass pass_release_ssa_names;\n extern struct gimple_opt_pass pass_early_inline;\n-extern struct gimple_opt_pass pass_O0_always_inline;\n extern struct gimple_opt_pass pass_inline_parameters;\n extern struct gimple_opt_pass pass_all_early_optimizations;\n extern struct gimple_opt_pass pass_update_address_taken;"}, {"sha": "405f0d8553d5275dd2582d29e5dcfa18e3811eef", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -311,11 +311,8 @@ tree_gen_ic_func_profiler (void)\n   tree stmt1, stmt2;\n   tree tree_uid, cur_func;\n \n-  if (flag_unit_at_a_time)\n-    {\n-      if (!c_node->needed)\n-\treturn;\n-    }\n+  if (!c_node->needed)\n+    return;\n   \n   tree_init_edge_profiler ();\n   "}, {"sha": "2fec08dae8d4171ebdf6ba674ef6846c848bdf28", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -3714,17 +3714,7 @@ may_be_aliased (tree var)\n   if (!TREE_STATIC (var))\n     return false;\n \n-  /* If we're in unit-at-a-time mode, then we must have seen all\n-     occurrences of address-of operators, and so we can trust\n-     TREE_ADDRESSABLE.  Otherwise we can only be sure the variable\n-     isn't addressable if it's local to the current function.  */\n-  if (flag_unit_at_a_time)\n-    return false;\n-\n-  if (decl_function_context (var) == current_function_decl)\n-    return false;\n-\n-  return true;\n+  return false;\n }\n \n /* The following is based on code in add_stmt_operand to ensure that the"}, {"sha": "7c4cd3d680556141f555cc3aa28bf23fc4e0300e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -5559,8 +5559,7 @@ delete_points_to_sets (void)\n static bool\n gate_ipa_pta (void)\n {\n-  return (flag_unit_at_a_time != 0\n-\t  && flag_ipa_pta\n+  return (flag_ipa_pta\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }"}, {"sha": "941716f73bd352e0b9ab30dc83d8e9977f7ef545", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -2228,7 +2228,7 @@ contains_pointers_p (tree type)\n     }\n }\n \n-/* In unit-at-a-time mode, we delay assemble_external processing until\n+/* We delay assemble_external processing until\n    the compilation unit is finalized.  This is the best we can do for\n    right now (i.e. stage 3 of GCC 4.0) - the right thing is to delay\n    it all the way to final.  See PR 17982 for further discussion.  */\n@@ -5380,7 +5380,7 @@ assemble_alias (tree decl, tree target)\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n-  if (!flag_unit_at_a_time || cgraph_global_info_ready)\n+  if (cgraph_global_info_ready)\n     target_decl = find_decl_and_mark_needed (decl, target);\n   else\n     target_decl= NULL;"}, {"sha": "daa0c15259daec5f5a3233235b85c77c9d765c47", "filename": "gcc/varpool.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8b322aa09905a0362ec6c3c518c7aabfa045e0/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=7e8b322aa09905a0362ec6c3c518c7aabfa045e0", "patch": "@@ -61,7 +61,7 @@ struct varpool_node *varpool_nodes;\n    maintained in forward order.  GTY is needed to make it friendly to\n    PCH.\n  \n-   During unit-at-a-time compilation we construct the queue of needed variables\n+   During compilation we construct the queue of needed variables\n    twice: first time it is during cgraph construction, second time it is at the\n    end of compilation in VARPOOL_REMOVE_UNREFERENCED_DECLS so we can avoid\n    optimized out variables being output.\n@@ -214,17 +214,13 @@ varpool_reset_queue (void)\n \n /* Determine if variable DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n-   configury, or (if not doing unit-at-a-time) to something we haven't\n-   seen yet.  */\n+   configury */\n bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n   if (node->externally_visible || node->force_output)\n     return true;\n-  if (!flag_unit_at_a_time\n-      && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    return true;\n \n   /* ??? If the assembler name is set by hand, it is possible to assemble\n      the name later after finalizing the function and the fact is noticed\n@@ -257,7 +253,7 @@ decide_is_variable_needed (struct varpool_node *node, tree decl)\n \n   /* When not reordering top level variables, we have to assume that\n      we are going to keep everything.  */\n-  if (flag_unit_at_a_time && flag_toplevel_reorder)\n+  if (flag_toplevel_reorder)\n     return false;\n \n   /* We want to emit COMDAT variables only when absolutely necessary.  */\n@@ -280,7 +276,7 @@ varpool_finalize_decl (tree decl)\n      if this function has already run.  */\n   if (node->finalized)\n     {\n-      if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n+      if (cgraph_global_info_ready)\n \tvarpool_assemble_pending_decls ();\n       return;\n     }\n@@ -295,7 +291,7 @@ varpool_finalize_decl (tree decl)\n      there.  */\n   else if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     varpool_mark_needed_node (node);\n-  if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n+  if (cgraph_global_info_ready)\n     varpool_assemble_pending_decls ();\n }\n "}]}