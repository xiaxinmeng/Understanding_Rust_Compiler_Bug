{"sha": "08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhZDFkNmQ4MmU2NTMxYTAwZDc3M2JjM2YyNDU0OGI5OGMxZjg5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-07-20T12:15:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-07-20T12:15:02Z"}, "message": "cgraph.h (combined_args_to_skip): New field.\n\n2009-07-20  Jan Hubicka  <jh@suse.cz>\n            Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (combined_args_to_skip): New field.\n\t* cgraph.c (cgraph_create_virtual_clone): Properly handle\n\tcombined_args_to_skip and args_to_skip.\n\t* tree-inline.c (update_clone_info): New function.\n\t(tree_function_versioning): Call update_clone_info.\n\t* cgraphunit.c: (cgraph_materialize_clone): Dump materialized functions.\n\t(cgraph_materialize_all_clones): More extensive dumping, working\n\twith combined_args_to_skip rather than args_to_skip.\n\n\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r149808", "tree": {"sha": "7ffb62e406ff8a8c4d6703fbbf79fddf2716b7aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ffb62e406ff8a8c4d6703fbbf79fddf2716b7aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/comments", "author": null, "committer": null, "parents": [{"sha": "c4023c1903e09ab3f83785b8d38ba9ffd7e295e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4023c1903e09ab3f83785b8d38ba9ffd7e295e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4023c1903e09ab3f83785b8d38ba9ffd7e295e9"}], "stats": {"total": 123, "additions": 118, "deletions": 5}, "files": [{"sha": "82a3ab0e83b97e12933273e94303050381294acf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "patch": "@@ -1,3 +1,15 @@\n+2009-07-20  Jan Hubicka  <jh@suse.cz>\n+            Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (combined_args_to_skip): New field.\n+\t* cgraph.c (cgraph_create_virtual_clone): Properly handle\n+\tcombined_args_to_skip and args_to_skip.\n+\t* tree-inline.c (update_clone_info): New function.\n+\t(tree_function_versioning): Call update_clone_info.\n+\t* cgraphunit.c: (cgraph_materialize_clone): Dump materialized functions.\n+\t(cgraph_materialize_all_clones): More extensive dumping, working\n+\twith combined_args_to_skip rather than args_to_skip.\n+\n 2009-07-20  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vectorizer.h (vectorizable_condition): Add parameters."}, {"sha": "ea47aa32cdc37fcf0768dfe86fa4c4337e3f1ae9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "patch": "@@ -1716,6 +1716,31 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   DECL_WEAK (new_node->decl) = 0;\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n+  if (!args_to_skip)\n+    new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n+  else if (old_node->clone.combined_args_to_skip)\n+    {\n+      int newi = 0, oldi = 0;\n+      tree arg;\n+      bitmap new_args_to_skip = BITMAP_GGC_ALLOC ();\n+      struct cgraph_node *orig_node;\n+      for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n+        ;\n+      for (arg = DECL_ARGUMENTS (orig_node->decl); arg; arg = TREE_CHAIN (arg), oldi++)\n+\t{\n+\t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n+\t    {\n+\t      bitmap_set_bit (new_args_to_skip, oldi);\n+\t      continue;\n+\t    }\n+\t  if (bitmap_bit_p (args_to_skip, newi))\n+\t    bitmap_set_bit (new_args_to_skip, oldi);\n+\t  newi++;\n+\t}\n+      new_node->clone.combined_args_to_skip = new_args_to_skip;\n+    }\n+  else\n+    new_node->clone.combined_args_to_skip = args_to_skip;\n   new_node->local.externally_visible = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;"}, {"sha": "a05541d9c980ab719ce1f3ead552e7d552f610d5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "patch": "@@ -152,6 +152,7 @@ struct GTY(()) cgraph_clone_info\n {\n   VEC(ipa_replace_map_p,gc)* tree_map;\n   bitmap args_to_skip;\n+  bitmap combined_args_to_skip;\n };\n \n /* The cgraph data structure."}, {"sha": "eb7de103d4b33a5ecf4c8b5f7efcb77bc1421167", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "patch": "@@ -1725,6 +1725,11 @@ cgraph_materialize_clone (struct cgraph_node *node)\n   tree_function_versioning (node->clone_of->decl, node->decl,\n   \t\t\t    node->clone.tree_map, true,\n \t\t\t    node->clone.args_to_skip);\n+  if (cgraph_dump_file)\n+    {\n+      dump_function_to_file (node->clone_of->decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->decl, cgraph_dump_file, dump_flags);\n+    }\n \n   /* Function is no longer clone.  */\n   if (node->next_sibling_clone)\n@@ -1770,9 +1775,42 @@ cgraph_materialize_all_clones (void)\n \t      if (gimple_has_body_p (node->clone_of->decl))\n \t        {\n \t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file, \"  clonning %s to %s\",\n-\t\t\t     cgraph_node_name (node->clone_of),\n-\t\t\t     cgraph_node_name (node));\n+\t\t    {\n+\t\t      fprintf (cgraph_dump_file, \"clonning %s to %s\\n\",\n+\t\t\t       cgraph_node_name (node->clone_of),\n+\t\t\t       cgraph_node_name (node));\n+\t\t      if (node->clone.tree_map)\n+\t\t        {\n+\t\t\t  unsigned int i;\n+\t\t          fprintf (cgraph_dump_file, \"   replace map: \");\n+\t\t\t  for (i = 0; i < VEC_length (ipa_replace_map_p,\n+\t\t\t  \t\t\t      node->clone.tree_map);\n+\t\t\t\t\t\t      i++)\n+\t\t\t    {\n+\t\t\t      struct ipa_replace_map *replace_info;\n+\t\t\t      replace_info = VEC_index (ipa_replace_map_p,\n+\t\t\t      \t\t\t\tnode->clone.tree_map,\n+\t\t\t\t\t\t\ti);\n+\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->old_tree, 0);\n+\t\t\t      fprintf (cgraph_dump_file, \" -> \");\n+\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->new_tree, 0);\n+\t\t\t      fprintf (cgraph_dump_file, \"%s%s;\",\n+\t\t\t      \t       replace_info->replace_p ? \"(replace)\":\"\",\n+\t\t\t\t       replace_info->ref_p ? \"(ref)\":\"\");\n+\t\t\t    }\n+\t\t\t  fprintf (cgraph_dump_file, \"\\n\");\n+\t\t\t}\n+\t\t      if (node->clone.args_to_skip)\n+\t\t\t{\n+\t\t          fprintf (cgraph_dump_file, \"   args_to_skip: \");\n+\t\t          dump_bitmap (cgraph_dump_file, node->clone.args_to_skip);\n+\t\t\t}\n+\t\t      if (node->clone.args_to_skip)\n+\t\t\t{\n+\t\t          fprintf (cgraph_dump_file, \"   combined_args_to_skip:\");\n+\t\t          dump_bitmap (cgraph_dump_file, node->clone.combined_args_to_skip);\n+\t\t\t}\n+\t\t    }\n \t\t  cgraph_materialize_clone (node);\n \t        }\n \t      else\n@@ -1811,9 +1849,9 @@ cgraph_materialize_all_clones (void)\n       \t\t    print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n \t\t  }\n \n-\t\tif (e->callee->clone.args_to_skip)\n+\t\tif (e->callee->clone.combined_args_to_skip)\n \t\t  new_stmt = gimple_call_copy_skip_args (e->call_stmt,\n-\t\t\t\t\t\t\t e->callee->clone.args_to_skip);\n+\t\t\t\t\t\t\t e->callee->clone.combined_args_to_skip);\n \t\telse\n \t\t  new_stmt = e->call_stmt;\n \t\tif (gimple_vdef (new_stmt)"}, {"sha": "8b5e1ffeafcfbbb82b607a371656008cfb965314", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ad1d6d82e6531a00d773bc3f24548b98c1f89a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=08ad1d6d82e6531a00d773bc3f24548b98c1f89a", "patch": "@@ -4446,6 +4446,42 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n   return changed;\n }\n \n+/* Update clone info after duplication.  */\n+\n+static void\n+update_clone_info (copy_body_data * id)\n+{\n+  struct cgraph_node *node;\n+  if (!id->dst_node->clones)\n+    return;\n+  for (node = id->dst_node->clones; node != id->dst_node;)\n+    {\n+      /* First update replace maps to match the new body.  */\n+      if (node->clone.tree_map)\n+        {\n+\t  unsigned int i;\n+          for (i = 0; i < VEC_length (ipa_replace_map_p, node->clone.tree_map); i++)\n+\t    {\n+\t      struct ipa_replace_map *replace_info;\n+\t      replace_info = VEC_index (ipa_replace_map_p, node->clone.tree_map, i);\n+\t      walk_tree (&replace_info->old_tree, copy_tree_body_r, id, NULL);\n+\t      walk_tree (&replace_info->new_tree, copy_tree_body_r, id, NULL);\n+\t    }\n+\t}\n+      if (node->clones)\n+\tnode = node->clones;\n+      else if (node->next_sibling_clone)\n+\tnode = node->next_sibling_clone;\n+      else\n+\t{\n+\t  while (node != id->dst_node && !node->next_sibling_clone)\n+\t    node = node->clone_of;\n+\t  if (node != id->dst_node)\n+\t    node = node->next_sibling_clone;\n+\t}\n+    }\n+}\n+\n /* Create a copy of a function's tree.\n    OLD_DECL and NEW_DECL are FUNCTION_DECL tree nodes\n    of the original function and the new copied function\n@@ -4602,6 +4638,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       while (VEC_length (gimple, init_stmts))\n \tinsert_init_stmt (bb, VEC_pop (gimple, init_stmts));\n     }\n+  update_clone_info (&id);\n \n   /* Remap the nonlocal_goto_save_area, if any.  */\n   if (cfun->nonlocal_goto_save_area)"}]}