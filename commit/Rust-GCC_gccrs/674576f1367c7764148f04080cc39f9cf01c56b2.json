{"sha": "674576f1367c7764148f04080cc39f9cf01c56b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0NTc2ZjEzNjdjNzc2NDE0OGYwNDA4MGNjMzlmOWNmMDFjNTZiMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-06-09T02:41:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-06-09T02:41:29Z"}, "message": "elf.h (ASM_DECLARE_OBJECT_NAME): Define.\n\n        * mips/elf.h (ASM_DECLARE_OBJECT_NAME): Define.\n        (ASM_FINISH_DECLARE_OBJECT): Define;\n        * mips/elf64.h: Likewise.\n\nFrom-SVN: r20369", "tree": {"sha": "1696dcca4fd8b967a81478fd37df55be82b8a9b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1696dcca4fd8b967a81478fd37df55be82b8a9b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/674576f1367c7764148f04080cc39f9cf01c56b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674576f1367c7764148f04080cc39f9cf01c56b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674576f1367c7764148f04080cc39f9cf01c56b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674576f1367c7764148f04080cc39f9cf01c56b2/comments", "author": null, "committer": null, "parents": [{"sha": "5dd57225048e17e095afbe7c7c53f53d7222deec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd57225048e17e095afbe7c7c53f53d7222deec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd57225048e17e095afbe7c7c53f53d7222deec"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "2637c44161fb8e4bab7efd6763b42dd3511f2b2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=674576f1367c7764148f04080cc39f9cf01c56b2", "patch": "@@ -1,3 +1,9 @@\n+Tue Jun  9 02:40:49 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* mips/elf.h (ASM_DECLARE_OBJECT_NAME): Define.\n+\t(ASM_FINISH_DECLARE_OBJECT): Define;\n+\t* mips/elf64.h: Likewise.\n+\n Tue Jun  9 01:08:47 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* toplev.c (flag_new_exceptions): Remove extraneous `extern'."}, {"sha": "cfaa9d1f21f86410bd60b9b8ea76ce863836a227", "filename": "gcc/config/mips/elf.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2Fconfig%2Fmips%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2Fconfig%2Fmips%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf.h?ref=674576f1367c7764148f04080cc39f9cf01c56b2", "patch": "@@ -71,6 +71,73 @@ do {\t\t\t\t\t\t\t\t\\\n     fprintf (F, \"\\t.section %s,\\\"aw\\\",@progbits\\n\", (NAME));\t\\\n } while (0)\n \n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT        \"@%s\"\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#undef TYPE_ASM_OP\n+#undef SIZE_ASM_OP\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    mips_declare_object (FILE, NAME, \"\", \":\\n\", 0);\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#undef ASM_FINISH_DECLARE_OBJECT\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\", int_size_in_bytes (TREE_TYPE (DECL)));  \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)                            \\\n  do { fputc ( '\\t', FILE);                                            \\\n       assemble_name (FILE, LABEL1);                                   \\"}, {"sha": "503eb8717d8da42abeb8c812e6ef076e7b9d1037", "filename": "gcc/config/mips/elf64.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2Fconfig%2Fmips%2Felf64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674576f1367c7764148f04080cc39f9cf01c56b2/gcc%2Fconfig%2Fmips%2Felf64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf64.h?ref=674576f1367c7764148f04080cc39f9cf01c56b2", "patch": "@@ -97,6 +97,73 @@ do {\t\t\t\t\t\t\t\t\\\n     fprintf (F, \"\\t.section %s,\\\"aw\\\",@progbits\\n\", (NAME));\t\\\n } while (0)\n \n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT        \"@%s\"\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#undef TYPE_ASM_OP\n+#undef SIZE_ASM_OP\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    mips_declare_object (FILE, NAME, \"\", \":\\n\", 0);\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#undef ASM_FINISH_DECLARE_OBJECT\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\", int_size_in_bytes (TREE_TYPE (DECL)));  \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)                            \\\n  do { fputc ( '\\t', FILE);                                            \\\n       assemble_name (FILE, LABEL1);                                   \\"}]}