{"sha": "41e8659ef1cd6f069608490882ddcc179634283e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFlODY1OWVmMWNkNmYwNjk2MDg0OTA4ODJkZGNjMTc5NjM0MjgzZQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-12-23T16:07:53Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-12-23T16:07:53Z"}, "message": "combine.c (simplify_shift_const): Fix typo.\n\n2005-12-23  Paolo Bonzini  <bonzini@gnu.org>\n\n        * combine.c (simplify_shift_const): Fix typo.  Use, whenever\n\tapplicable, simplify_const_binary_operation.\n\n        (simplify_shift_const): Leave only the fallback\n        case when no simplification is possible.  Extract to...\n        (simplify_shift_const_1): ... here.  Always create a new\n        RTX instead of substituting.  Remove the signed_count variable.\n        Return NULL_RTX if no substitution is possible.\n\n        (simplify_and_const_int): Leave only the fallback\n        case when no simplification is possible.  Extract to...\n        (simplify_and_const_int_1): ... here.  Always create a new\n        RTX instead of substituting.  Return NULL_RTX if no substitution\n        is possible.\n\n        (force_to_mode, simplify_comparison): Don't pass a non-NULL first\n        parameter to simplify_and_const_int and simplify_shift_const,\n        unless it is equal to the expected non-simplified result.\n\nFrom-SVN: r109016", "tree": {"sha": "998c72bef1523c8d05cc6f1b61f8afc54b5b3c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/998c72bef1523c8d05cc6f1b61f8afc54b5b3c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41e8659ef1cd6f069608490882ddcc179634283e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41e8659ef1cd6f069608490882ddcc179634283e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41e8659ef1cd6f069608490882ddcc179634283e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41e8659ef1cd6f069608490882ddcc179634283e/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb29234501cd27d2d78a4a3040cc6a0890c96b32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb29234501cd27d2d78a4a3040cc6a0890c96b32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb29234501cd27d2d78a4a3040cc6a0890c96b32"}], "stats": {"total": 316, "additions": 173, "deletions": 143}, "files": [{"sha": "1053920e423afb3d749a05d3fe8a88e3c3c64a9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41e8659ef1cd6f069608490882ddcc179634283e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41e8659ef1cd6f069608490882ddcc179634283e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41e8659ef1cd6f069608490882ddcc179634283e", "patch": "@@ -1,3 +1,24 @@\n+2005-12-23  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * combine.c (simplify_shift_const): Fix typo.  Use, whenever\n+\tapplicable, simplify_const_binary_operation.\n+\n+        (simplify_shift_const): Leave only the fallback\n+        case when no simplification is possible.  Extract to...\n+        (simplify_shift_const_1): ... here.  Always create a new\n+        RTX instead of substituting.  Remove the signed_count variable.\n+        Return NULL_RTX if no substitution is possible.\n+\n+        (simplify_and_const_int): Leave only the fallback\n+        case when no simplification is possible.  Extract to...\n+        (simplify_and_const_int_1): ... here.  Always create a new\n+        RTX instead of substituting.  Return NULL_RTX if no substitution\n+        is possible.\n+\n+        (force_to_mode, simplify_comparison): Don't pass a non-NULL first\n+        parameter to simplify_and_const_int and simplify_shift_const,\n+        unless it is equal to the expected non-simplified result.\n+\n 2005-12-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/25005"}, {"sha": "2482bbd26e9a5e0cee224f7d496fbf5962ccfcf0", "filename": "gcc/combine.c", "status": "modified", "additions": 152, "deletions": 143, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41e8659ef1cd6f069608490882ddcc179634283e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41e8659ef1cd6f069608490882ddcc179634283e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=41e8659ef1cd6f069608490882ddcc179634283e", "patch": "@@ -394,11 +394,14 @@ static int rtx_equal_for_field_assignment_p (rtx, rtx);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n static rtx distribute_and_simplify_rtx (rtx, int);\n+static rtx simplify_and_const_int_1 (enum machine_mode, rtx,\n+\t\t\t\t     unsigned HOST_WIDE_INT);\n static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n \t\t\t    HOST_WIDE_INT, enum machine_mode, int *);\n-static rtx simplify_shift_const\t(rtx, enum rtx_code, enum machine_mode, rtx,\n+static rtx simplify_shift_const_1 (enum rtx_code, enum machine_mode, rtx, int);\n+static rtx simplify_shift_const (rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n@@ -6984,7 +6987,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  int i = -1;\n+\t  int i;\n \n \t  /* If the considered data is wider than HOST_WIDE_INT, we can't\n \t     represent a mask for all its bits in a single scalar.\n@@ -7011,13 +7014,19 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t      nonzero >>= INTVAL (XEXP (x, 1));\n \t    }\n \n-\t  if ((mask & ~nonzero) == 0\n-\t      || (i = exact_log2 (mask)) >= 0)\n+\t  if ((mask & ~nonzero) == 0)\n+\t    {\n+\t      x = simplify_shift_const (x, LSHIFTRT, GET_MODE (x),\n+\t\t\t\t\tXEXP (x, 0), INTVAL (XEXP (x, 1)));\n+\t      if (GET_CODE (x) != ASHIFTRT)\n+\t\treturn force_to_mode (x, mode, mask, next_select);\n+\t    }\n+\n+\t  else if ((i = exact_log2 (mask)) >= 0)\n \t    {\n \t      x = simplify_shift_const\n-\t\t(x, LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n-\t\t i < 0 ? INTVAL (XEXP (x, 1))\n-\t\t : GET_MODE_BITSIZE (GET_MODE (x)) - 1 - i);\n+\t\t  (NULL_RTX, LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n+\t\t   GET_MODE_BITSIZE (GET_MODE (x)) - 1 - i);\n \n \t      if (GET_CODE (x) != ASHIFTRT)\n \t\treturn force_to_mode (x, mode, mask, next_select);\n@@ -7904,19 +7913,24 @@ distribute_and_simplify_rtx (rtx x, int n)\n   return NULL_RTX;\n }\n \f\n-/* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done\n-   in MODE.\n-\n-   Return an equivalent form, if different from X.  Otherwise, return X.  If\n-   X is zero, we are to always construct the equivalent form.  */\n+/* Simplify a logical `and' of VAROP with the constant CONSTOP, to be done\n+   in MODE.  Return an equivalent form, if different from (and VAROP\n+   (const_int CONSTOP)).  Otherwise, return NULL_RTX.  */\n \n static rtx\n-simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n-\t\t\tunsigned HOST_WIDE_INT constop)\n+simplify_and_const_int_1 (enum machine_mode mode, rtx varop,\n+\t\t\t  unsigned HOST_WIDE_INT constop)\n {\n   unsigned HOST_WIDE_INT nonzero;\n+  unsigned HOST_WIDE_INT orig_constop;\n+  rtx orig_varop;\n   int i;\n \n+  orig_varop = varop;\n+  orig_constop = constop;\n+  if (GET_CODE (varop) == CLOBBER)\n+    return NULL_RTX;\n+\n   /* Simplify VAROP knowing that we will be only looking at some of the\n      bits in it.\n \n@@ -7995,40 +8009,42 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n \treturn o0;\n     }\n \n-  /* Get VAROP in MODE.  Try to get a SUBREG if not.  Don't make a new SUBREG\n-     if we already had one (just check for the simplest cases).  */\n-  if (x && GET_CODE (XEXP (x, 0)) == SUBREG\n-      && GET_MODE (XEXP (x, 0)) == mode\n-      && SUBREG_REG (XEXP (x, 0)) == varop)\n-    varop = XEXP (x, 0);\n-  else\n-    varop = gen_lowpart (mode, varop);\n-\n-  /* If we can't make the SUBREG, try to return what we were given.  */\n-  if (GET_CODE (varop) == CLOBBER)\n-    return x ? x : varop;\n+  /* Make a SUBREG if necessary.  If we can't make it, fail.  */\n+  varop = gen_lowpart (mode, varop);\n+  if (varop == NULL_RTX || GET_CODE (varop) == CLOBBER)\n+    return NULL_RTX;\n \n   /* If we are only masking insignificant bits, return VAROP.  */\n   if (constop == nonzero)\n-    x = varop;\n-  else\n-    {\n-      /* Otherwise, return an AND.  */\n-      constop = trunc_int_for_mode (constop, mode);\n-      /* See how much, if any, of X we can use.  */\n-      if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-\tx = simplify_gen_binary (AND, mode, varop, GEN_INT (constop));\n+    return varop;\n \n-      else\n-\t{\n-\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t      || (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) != constop)\n-\t    SUBST (XEXP (x, 1), GEN_INT (constop));\n+  if (varop == orig_varop && constop == orig_constop)\n+    return NULL_RTX;\n \n-\t  SUBST (XEXP (x, 0), varop);\n-\t}\n-    }\n+  /* Otherwise, return an AND.  */\n+  constop = trunc_int_for_mode (constop, mode);\n+  return simplify_gen_binary (AND, mode, varop, GEN_INT (constop));\n+}\n+\n+\n+/* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done\n+   in MODE.\n+\n+   Return an equivalent form, if different from X.  Otherwise, return X.  If\n+   X is zero, we are to always construct the equivalent form.  */\n+\n+static rtx\n+simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n+\t\t\tunsigned HOST_WIDE_INT constop)\n+{\n+  rtx tem = simplify_and_const_int_1 (mode, varop, constop);\n+  if (tem)\n+    return tem;\n \n+  if (!x)\n+    x = simplify_gen_binary (AND, GET_MODE (varop), varop, GEN_INT (constop));\n+  if (GET_MODE (x) != mode)\n+    x = gen_lowpart (mode, x);\n   return x;\n }\n \f\n@@ -8304,31 +8320,29 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n }\n \f\n /* Simplify a shift of VAROP by COUNT bits.  CODE says what kind of shift.\n-   The result of the shift is RESULT_MODE.  X, if nonzero, is an expression\n-   that we started with.\n+   The result of the shift is RESULT_MODE.  Return NULL_RTX if we cannot\n+   simplify it.  Otherwise, return a simplified value.\n \n    The shift is normally computed in the widest mode we find in VAROP, as\n    long as it isn't a different number of words than RESULT_MODE.  Exceptions\n-   are ASHIFTRT and ROTATE, which are always done in their original mode,  */\n+   are ASHIFTRT and ROTATE, which are always done in their original mode.  */\n \n static rtx\n-simplify_shift_const (rtx x, enum rtx_code code,\n-\t\t      enum machine_mode result_mode, rtx varop,\n-\t\t      int orig_count)\n+simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n+\t\t\trtx varop, int orig_count)\n {\n   enum rtx_code orig_code = code;\n-  unsigned int count;\n-  int signed_count;\n+  rtx orig_varop = varop;\n+  int count;\n   enum machine_mode mode = result_mode;\n   enum machine_mode shift_mode, tmode;\n   unsigned int mode_words\n     = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n   enum rtx_code outer_op = UNKNOWN;\n   HOST_WIDE_INT outer_const = 0;\n-  rtx const_rtx;\n   int complement_p = 0;\n-  rtx new;\n+  rtx new, x;\n \n   /* Make sure and truncate the \"natural\" shift on the way in.  We don't\n      want to do this inside the loop as it makes it more difficult to\n@@ -8340,12 +8354,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n      what was requested.  */\n \n   if (orig_count < 0 || orig_count >= (int) GET_MODE_BITSIZE (mode))\n-    {\n-      if (x)\n-\treturn x;\n-\n-      return gen_rtx_fmt_ee (code, mode, varop, GEN_INT (orig_count));\n-    }\n+    return NULL_RTX;\n \n   count = orig_count;\n \n@@ -8354,10 +8363,9 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \n   while (count != 0)\n     {\n-      /* If we have an operand of (clobber (const_int 0)), just return that\n-\t value.  */\n+      /* If we have an operand of (clobber (const_int 0)), fail.  */\n       if (GET_CODE (varop) == CLOBBER)\n-\treturn varop;\n+\treturn NULL_RTX;\n \n       /* If we discovered we had to complement VAROP, leave.  Making a NOT\n \t here would cause an infinite loop.  */\n@@ -8393,7 +8401,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t multiple operations, each of which are defined, we know what the\n \t result is supposed to be.  */\n \n-      if (count > (unsigned int) (GET_MODE_BITSIZE (shift_mode) - 1))\n+      if (count > (GET_MODE_BITSIZE (shift_mode) - 1))\n \t{\n \t  if (code == ASHIFTRT)\n \t    count = GET_MODE_BITSIZE (shift_mode) - 1;\n@@ -8567,7 +8575,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     interpreted as the sign bit in a narrower mode, so, if\n \t     the result is narrower, don't discard the shift.  */\n \t  if (code == LSHIFTRT\n-\t      && count == (unsigned int) (GET_MODE_BITSIZE (result_mode) - 1)\n+\t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n \t      && (GET_MODE_BITSIZE (result_mode)\n \t\t  >= GET_MODE_BITSIZE (GET_MODE (varop))))\n \t    {\n@@ -8601,8 +8609,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t\t (ashiftrt:M1 (ashift:M1 (and:M1 (subreg:M1 FOO 0 C2) C3) C1).\n \t\t This simplifies certain SIGN_EXTEND operations.  */\n \t      if (code == ASHIFT && first_code == ASHIFTRT\n-\t\t  && count == (unsigned int)\n-\t\t\t      (GET_MODE_BITSIZE (result_mode)\n+\t\t  && count == (GET_MODE_BITSIZE (result_mode)\n \t\t\t       - GET_MODE_BITSIZE (GET_MODE (varop))))\n \t\t{\n \t\t  /* C3 has the low-order C1 bits zero.  */\n@@ -8632,12 +8639,12 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t\t      > first_count))\n \t\t{\n \t\t  varop = XEXP (varop, 0);\n-\n-\t\t  signed_count = count - first_count;\n-\t\t  if (signed_count < 0)\n-\t\t    count = -signed_count, code = ASHIFT;\n-\t\t  else\n-\t\t    count = signed_count;\n+\t\t  count -= first_count;\n+\t\t  if (count < 0)\n+\t\t    {\n+\t\t      count = -count;\n+\t\t      code = ASHIFT;\n+\t\t    }\n \n \t\t  continue;\n \t\t}\n@@ -8685,8 +8692,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      mask_rtx = GEN_INT (nonzero_bits (varop, GET_MODE (varop)));\n \n \t      mask_rtx\n-\t\t= simplify_binary_operation (code, result_mode, mask_rtx,\n-\t\t\t\t\t     GEN_INT (count));\n+\t\t= simplify_const_binary_operation (code, result_mode, mask_rtx,\n+\t\t\t\t\t\t   GEN_INT (count));\n \n \t      /* Give up if we can't compute an outer operation to use.  */\n \t      if (mask_rtx == 0\n@@ -8698,25 +8705,22 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \n \t      /* If the shifts are in the same direction, we add the\n \t\t counts.  Otherwise, we subtract them.  */\n-\t      signed_count = count;\n \t      if ((code == ASHIFTRT || code == LSHIFTRT)\n \t\t  == (first_code == ASHIFTRT || first_code == LSHIFTRT))\n-\t\tsigned_count += first_count;\n+\t\tcount += first_count;\n \t      else\n-\t\tsigned_count -= first_count;\n+\t\tcount -= first_count;\n \n \t      /* If COUNT is positive, the new shift is usually CODE,\n \t\t except for the two exceptions below, in which case it is\n \t\t FIRST_CODE.  If the count is negative, FIRST_CODE should\n \t\t always be used  */\n-\t      if (signed_count > 0\n+\t      if (count > 0\n \t\t  && ((first_code == ROTATE && code == ASHIFT)\n \t\t      || (first_code == ASHIFTRT && code == LSHIFTRT)))\n-\t\tcode = first_code, count = signed_count;\n-\t      else if (signed_count < 0)\n-\t\tcode = first_code, count = -signed_count;\n-\t      else\n-\t\tcount = signed_count;\n+\t\tcode = first_code;\n+\t      else if (count < 0)\n+\t\tcode = first_code, count = -count;\n \n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -8727,12 +8731,12 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     B is not a constant.  */\n \n \t  else if (GET_CODE (varop) == code\n-\t\t   && GET_CODE (XEXP (varop, 1)) != CONST_INT\n-\t\t   && 0 != (new\n-\t\t\t    = simplify_binary_operation (code, mode,\n-\t\t\t\t\t\t\t XEXP (varop, 0),\n-\t\t\t\t\t\t\t GEN_INT (count))))\n+\t\t   && GET_CODE (XEXP (varop, 0)) == CONST_INT\n+\t\t   && GET_CODE (XEXP (varop, 1)) != CONST_INT)\n \t    {\n+\t      rtx new = simplify_const_binary_operation (code, mode,\n+\t\t\t\t\t\t\t XEXP (varop, 0),\n+\t\t\t\t\t\t\t GEN_INT (count));\n \t      varop = gen_rtx_fmt_ee (code, mode, new, XEXP (varop, 1));\n \t      count = 0;\n \t      continue;\n@@ -8759,8 +8763,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && XEXP (XEXP (varop, 0), 1) == constm1_rtx\n \t      && (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \t      && (code == LSHIFTRT || code == ASHIFTRT)\n-\t      && count == (unsigned int)\n-\t\t\t  (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)\n+\t      && count == (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)\n \t      && rtx_equal_p (XEXP (XEXP (varop, 0), 0), XEXP (varop, 1)))\n \t    {\n \t      count = 0;\n@@ -8785,9 +8788,9 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n \t\t   && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t      shift_mode))\n-\t      && (new = simplify_binary_operation (code, result_mode,\n-\t\t\t\t\t\t   XEXP (varop, 1),\n-\t\t\t\t\t\t   GEN_INT (count))) != 0\n+\t      && (new = simplify_const_binary_operation (code, result_mode,\n+\t\t\t\t\t\t         XEXP (varop, 1),\n+\t\t\t\t\t\t         GEN_INT (count))) != 0\n \t      && GET_CODE (new) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n@@ -8827,11 +8830,9 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t  if (code == LSHIFTRT\n \t      && XEXP (varop, 1) == const0_rtx\n \t      && GET_MODE (XEXP (varop, 0)) == result_mode\n-\t      && count == (unsigned int) (GET_MODE_BITSIZE (result_mode) - 1)\n+\t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n \t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n-\t      && ((STORE_FLAG_VALUE\n-\t\t   & ((HOST_WIDE_INT) 1\n-\t\t      < (GET_MODE_BITSIZE (result_mode) - 1))))\n+\t      && STORE_FLAG_VALUE == -1\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n@@ -8847,7 +8848,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t  /* (lshiftrt (neg A) C) where A is either 0 or 1 and C is one less\n \t     than the number of bits in the mode is equivalent to A.  */\n \t  if (code == LSHIFTRT\n-\t      && count == (unsigned int) (GET_MODE_BITSIZE (result_mode) - 1)\n+\t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1)\n \t    {\n \t      varop = XEXP (varop, 0);\n@@ -8872,7 +8873,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     is one less than the number of bits in the mode is\n \t     equivalent to (xor A 1).  */\n \t  if (code == LSHIFTRT\n-\t      && count == (unsigned int) (GET_MODE_BITSIZE (result_mode) - 1)\n+\t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n \t      && XEXP (varop, 1) == constm1_rtx\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n@@ -8915,10 +8916,9 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t  /* (ashift (plus foo C) N) is (plus (ashift foo N) C').  */\n \t  if (code == ASHIFT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n-\t      && (new = simplify_binary_operation (ASHIFT, result_mode,\n-\t\t\t\t\t\t   XEXP (varop, 1),\n-\t\t\t\t\t\t   GEN_INT (count))) != 0\n-\t      && GET_CODE (new) == CONST_INT\n+\t      && (new = simplify_const_binary_operation (ASHIFT, result_mode,\n+\t\t\t\t\t\t         XEXP (varop, 1),\n+\t\t\t\t\t\t         GEN_INT (count))) != 0\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n \t    {\n@@ -8934,10 +8934,9 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t  if (code == LSHIFTRT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && mode_signbit_p (result_mode, XEXP (varop, 1))\n-\t      && (new = simplify_binary_operation (code, result_mode,\n-\t\t\t\t\t\t   XEXP (varop, 1),\n-\t\t\t\t\t\t   GEN_INT (count))) != 0\n-\t      && GET_CODE (new) == CONST_INT\n+\t      && (new = simplify_const_binary_operation (code, result_mode,\n+\t\t\t\t\t\t         XEXP (varop, 1),\n+\t\t\t\t\t\t         GEN_INT (count))) != 0\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n \t    {\n@@ -8957,12 +8956,10 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \n \t  if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \t      && GET_CODE (XEXP (varop, 0)) == ASHIFTRT\n-\t      && count == (unsigned int)\n-\t\t\t  (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)\n+\t      && count == (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)\n \t      && (code == LSHIFTRT || code == ASHIFTRT)\n \t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (varop, 0), 1))\n-\t\t == count\n+\t      && INTVAL (XEXP (XEXP (varop, 0), 1)) == count\n \t      && rtx_equal_p (XEXP (XEXP (varop, 0), 0), XEXP (varop, 1)))\n \t    {\n \t      count = 0;\n@@ -9019,44 +9016,31 @@ simplify_shift_const (rtx x, enum rtx_code code,\n      a shift of type CODE with SHIFT_MODE shifting VAROP COUNT places.  If\n      OUTER_OP is non-UNKNOWN, it is an operation that needs to be applied\n      to the result of the shift.  OUTER_CONST is the relevant constant,\n-     but we must turn off all bits turned off in the shift.\n+     but we must turn off all bits turned off in the shift.  */\n \n-     If we were passed a value for X, see if we can use any pieces of\n-     it.  If not, make new rtx.  */\n-\n-  if (x && GET_RTX_CLASS (GET_CODE (x)) == RTX_BIN_ARITH\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) == count)\n-    const_rtx = XEXP (x, 1);\n-  else\n-    const_rtx = GEN_INT (count);\n-\n-  if (x && GET_CODE (XEXP (x, 0)) == SUBREG\n-      && GET_MODE (XEXP (x, 0)) == shift_mode\n-      && SUBREG_REG (XEXP (x, 0)) == varop)\n-    varop = XEXP (x, 0);\n-  else if (GET_MODE (varop) != shift_mode)\n-    varop = gen_lowpart (shift_mode, varop);\n-\n-  /* If we can't make the SUBREG, try to return what we were given.  */\n-  if (GET_CODE (varop) == CLOBBER)\n-    return x ? x : varop;\n+  if (outer_op == UNKNOWN\n+      && orig_code == code && orig_count == count\n+      && varop == orig_varop\n+      && shift_mode == GET_MODE (varop))\n+    return NULL_RTX;\n \n-  new = simplify_binary_operation (code, shift_mode, varop, const_rtx);\n-  if (new != 0)\n-    x = new;\n-  else\n-    x = gen_rtx_fmt_ee (code, shift_mode, varop, const_rtx);\n+  /* Make a SUBREG if necessary.  If we can't make it, fail.  */\n+  varop = gen_lowpart (shift_mode, varop);\n+  if (varop == NULL_RTX || GET_CODE (varop) == CLOBBER)\n+    return NULL_RTX;\n \n   /* If we have an outer operation and we just made a shift, it is\n      possible that we could have simplified the shift were it not\n      for the outer operation.  So try to do the simplification\n      recursively.  */\n \n-  if (outer_op != UNKNOWN && GET_CODE (x) == code\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    x = simplify_shift_const (x, code, shift_mode, XEXP (x, 0),\n-\t\t\t      INTVAL (XEXP (x, 1)));\n+  if (outer_op != UNKNOWN)\n+    x = simplify_shift_const_1 (code, shift_mode, varop, count);\n+  else\n+    x = NULL_RTX;\n+\n+  if (x == NULL_RTX)\n+    x = simplify_gen_binary (code, shift_mode, varop, GEN_INT (count));\n \n   /* If we were doing an LSHIFTRT in a wider mode than it was originally,\n      turn off all the bits that the shift would have turned off.  */\n@@ -9092,6 +9076,31 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \n   return x;\n }\n+\n+/* Simplify a shift of VAROP by COUNT bits.  CODE says what kind of shift.\n+   The result of the shift is RESULT_MODE.  If we cannot simplify it,\n+   return X or, if it is NULL, synthesize the expression with\n+   simplify_gen_binary.  Otherwise, return a simplified value.\n+\n+   The shift is normally computed in the widest mode we find in VAROP, as\n+   long as it isn't a different number of words than RESULT_MODE.  Exceptions\n+   are ASHIFTRT and ROTATE, which are always done in their original mode.  */\n+\n+static rtx\n+simplify_shift_const (rtx x, enum rtx_code code, enum machine_mode result_mode,\n+\t\t      rtx varop, int count)\n+{\n+  rtx tem = simplify_shift_const_1 (code, result_mode, varop, count);\n+  if (tem)\n+    return tem;\n+\n+  if (!x)\n+    x = simplify_gen_binary (code, GET_MODE (varop), varop, GEN_INT (count));\n+  if (GET_MODE (x) != result_mode)\n+    x = gen_lowpart (result_mode, x);\n+  return x;\n+}\n+\n \f\n /* Like recog, but we receive the address of a pointer to a new pattern.\n    We try to match the rtx that the pointer points to.\n@@ -10096,9 +10105,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && XEXP (XEXP (op0, 0), 0) == const1_rtx)\n \t    {\n \t      op0 = simplify_and_const_int\n-\t\t(op0, mode, gen_rtx_LSHIFTRT (mode,\n-\t\t\t\t\t      XEXP (op0, 1),\n-\t\t\t\t\t      XEXP (XEXP (op0, 0), 1)),\n+\t\t(NULL_RTX, mode, gen_rtx_LSHIFTRT (mode,\n+\t\t\t\t\t           XEXP (op0, 1),\n+\t\t\t\t\t           XEXP (XEXP (op0, 0), 1)),\n \t\t (HOST_WIDE_INT) 1);\n \t      continue;\n \t    }"}]}