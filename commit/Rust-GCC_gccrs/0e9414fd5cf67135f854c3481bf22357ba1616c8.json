{"sha": "0e9414fd5cf67135f854c3481bf22357ba1616c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5NDE0ZmQ1Y2Y2NzEzNWY4NTRjMzQ4MWJmMjIzNTdiYTE2MTZjOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-27T20:56:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-27T20:56:29Z"}, "message": "Allocate enough space for attr_printf; Use obstack_alloc instead of xmalloc.\n\nFrom-SVN: r1974", "tree": {"sha": "1ec4642b14c1c9e2e63dff0bff51671ef23ecaad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ec4642b14c1c9e2e63dff0bff51671ef23ecaad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e9414fd5cf67135f854c3481bf22357ba1616c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9414fd5cf67135f854c3481bf22357ba1616c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9414fd5cf67135f854c3481bf22357ba1616c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9414fd5cf67135f854c3481bf22357ba1616c8/comments", "author": null, "committer": null, "parents": [{"sha": "8696da340c88dc97b7fd08861bb81e1c886662b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8696da340c88dc97b7fd08861bb81e1c886662b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8696da340c88dc97b7fd08861bb81e1c886662b8"}], "stats": {"total": 60, "additions": 35, "deletions": 25}, "files": [{"sha": "f32965de97862ca609879f9070403556c95d1eec", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9414fd5cf67135f854c3481bf22357ba1616c8/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9414fd5cf67135f854c3481bf22357ba1616c8/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=0e9414fd5cf67135f854c3481bf22357ba1616c8", "patch": "@@ -118,6 +118,9 @@ extern rtx read_rtx ();\n static void fatal ();\n void fancy_abort ();\n \n+/* enough space to reserve for printing out ints */\n+#define MAX_DIGITS (HOST_BITS_PER_INT * 3 / 10 + 3)\n+\n /* Define structures used to record attributes and values.  */\n \n /* As each DEFINE_INSN, DEFINE_PEEPHOLE, or DEFINE_ASM_ATTRIBUTES is\n@@ -373,6 +376,9 @@ static void extend_range ();\n char *xrealloc ();\n char *xmalloc ();\n static void fatal ();\n+\n+#define oballoc(size) obstack_alloc (hash_obstack, size)\n+\n \f\n /* Hash table for sharing RTL and strings.  */\n \n@@ -1231,7 +1237,7 @@ convert_const_symbol_ref (exp, attr)\n       char *p, *string;\n       rtx value;\n \n-      string = p = (char *) xmalloc (2\n+      string = p = (char *) oballoc (2\n \t\t\t\t     + strlen (attr->name)\n \t\t\t\t     + strlen (XSTR (av->value, 0)));\n       strcpy (p, attr->name);\n@@ -1378,7 +1384,7 @@ get_attr_value (value, attr, insn_code)\n \t    || insn_alternatives[av->first_insn->insn_code]))\n       return av;\n \n-  av = (struct attr_value *) xmalloc (sizeof (struct attr_value));\n+  av = (struct attr_value *) oballoc (sizeof (struct attr_value));\n   av->value = value;\n   av->next = attr->first_value;\n   attr->first_value = av;\n@@ -1455,7 +1461,8 @@ expand_delays ()\n \t newexp = attr_rtx (IF_THEN_ELSE, condexp,\n \t\t\t    make_numeric_value (1), make_numeric_value (0));\n \n-\t p = attr_printf (13, \"*delay_%d_%d\", delay->num, i / 3);\n+\t p = attr_printf (sizeof (\"*delay__\") + MAX_DIGITS*2, \"*delay_%d_%d\",\n+\t\t\t  delay->num, i / 3);\n \t make_internal_attr (p, newexp, 1);\n \n \t if (have_annul_true)\n@@ -1465,7 +1472,8 @@ expand_delays ()\n \t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n \t\t\t\tmake_numeric_value (1),\n \t\t\t\tmake_numeric_value (0));\n-\t     p = attr_printf (18, \"*annul_true_%d_%d\", delay->num, i / 3);\n+\t     p = attr_printf (sizeof (\"*annul_true__\") + MAX_DIGITS*2,\n+\t\t\t      \"*annul_true_%d_%d\", delay->num, i / 3);\n \t     make_internal_attr (p, newexp, 1);\n \t   }\n \n@@ -1476,7 +1484,8 @@ expand_delays ()\n \t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n \t\t\t\tmake_numeric_value (1),\n \t\t\t\tmake_numeric_value (0));\n-\t     p = attr_printf (18, \"*annul_false_%d_%d\", delay->num, i / 3);\n+\t     p = attr_printf (sizeof (\"*annul_false__\") + MAX_DIGITS*2,\n+\t\t\t      \"*annul_false_%d_%d\", delay->num, i / 3);\n \t     make_internal_attr (p, newexp, 1);\n \t   }\n        }\n@@ -1735,8 +1744,8 @@ expand_units ()\n \t\t\t\t\t   != unit->issue_delay.max);\n \t  if (unit->needs_conflict_function)\n \t    {\n-\t      str = attr_printf (strlen (unit->name) + 11, \"*%s_cost_%d\",\n-\t\t\t\t unit->name, op->num);\n+\t      str = attr_printf (strlen (unit->name) + sizeof (\"*_cost_\") + MAX_DIGITS,\n+\t\t\t\t \"*%s_cost_%d\", unit->name, op->num);\n \t      make_internal_attr (str, issue_exp, 1);\n \t    }\n \n@@ -1939,8 +1948,8 @@ expand_units ()\n \t\t}\n \n \t      /* Make an attribute for use in the blockage function.  */\n-\t      str = attr_printf (strlen (unit->name) + 12, \"*%s_block_%d\",\n-\t\t\t\t unit->name, op->num);\n+\t      str = attr_printf (strlen (unit->name) + sizeof (\"*_block_\") + MAX_DIGITS,\n+\t\t\t\t \"*%s_block_%d\", unit->name, op->num);\n \t      make_internal_attr (str, blockage, 1);\n \t    }\n \n@@ -1969,13 +1978,13 @@ expand_units ()\n \t      newexp = operate_exp (RANGE_OP, min_blockage, max_blockage);\n \t      newexp = simplify_knowing (newexp, unit->condexp);\n \n-\t      str = attr_printf (strlen (unit->name) + 20,\n+\t      str = attr_printf (strlen (unit->name) + sizeof (\"*_unit_blockage_range\"),\n \t\t\t\t \"*%s_unit_blockage_range\", unit->name);\n \t      make_internal_attr (str, newexp, 4);\n \t    }\n \n-\t  str = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n-\t\t\t     unit->name);\n+\t  str = attr_printf (strlen (unit->name) + sizeof (\"*_unit_ready_cost\"),\n+\t\t\t     \"*%s_unit_ready_cost\", unit->name);\n \t}\n       else\n \tstr = \"*result_ready_cost\";\n@@ -2016,7 +2025,8 @@ expand_units ()\n \t}\n \n       /* Simplifying caseexp with simplify_by_exploding doesn't win.  */\n-      str = attr_printf (strlen (unit->name) + 8, \"*%s_cases\", unit->name);\n+      str = attr_printf (strlen (unit->name) + sizeof (\"*_cases\"),\n+\t\t\t \"*%s_cases\", unit->name);\n       make_internal_attr (str, caseexp, 1);\n     }\n }\n@@ -2064,7 +2074,7 @@ encode_units_mask (x)\n \t  ;\n       else\n \tj = ~i;\n-      return attr_rtx (CONST_STRING, attr_printf (4, \"%d\", j));\n+      return attr_rtx (CONST_STRING, attr_printf (MAX_DIGITS, \"%d\", j));\n \n     case REG:\n     case QUEUED:\n@@ -2135,7 +2145,7 @@ fill_attr (attr)\n       else\n \tav = get_attr_value (value, attr, id->insn_code);\n \n-      ie = (struct insn_ent *) xmalloc (sizeof (struct insn_ent));\n+      ie = (struct insn_ent *) oballoc (sizeof (struct insn_ent));\n       ie->insn_code = id->insn_code;\n       ie->insn_index = id->insn_code;\n       insert_insn_ent (av, ie);\n@@ -2263,7 +2273,7 @@ make_length_attrs ()\n \t\t\t\t\t\t\t no_address_fn[i],\n \t\t\t\t\t\t\t address_fn[i]),\n \t\t\t\t     new_attr, ie->insn_code);\n-\t    new_ie = (struct insn_ent *) xmalloc (sizeof (struct insn_ent));\n+\t    new_ie = (struct insn_ent *) oballoc (sizeof (struct insn_ent));\n \t    new_ie->insn_code = ie->insn_code;\n \t    new_ie->insn_index = ie->insn_index;\n \t    insert_insn_ent (new_av, new_ie);\n@@ -3926,7 +3936,7 @@ gen_attr (exp)\n       name_ptr = XSTR (exp, 1);\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t{\n-\t  av = (struct attr_value *) xmalloc (sizeof (struct attr_value));\n+\t  av = (struct attr_value *) oballoc (sizeof (struct attr_value));\n \t  av->value = attr_rtx (CONST_STRING, p);\n \t  av->next = attr->first_value;\n \t  attr->first_value = av;\n@@ -4066,7 +4076,7 @@ gen_insn (exp)\n {\n   struct insn_def *id;\n \n-  id = (struct insn_def *) xmalloc (sizeof (struct insn_def));\n+  id = (struct insn_def *) oballoc (sizeof (struct insn_def));\n   id->next = defs;\n   defs = id;\n   id->def = exp;\n@@ -4122,7 +4132,7 @@ gen_delay (def)\n \thave_annul_false = 1;\n     }\n   \n-  delay = (struct delay_desc *) xmalloc (sizeof (struct delay_desc));\n+  delay = (struct delay_desc *) oballoc (sizeof (struct delay_desc));\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n@@ -4163,7 +4173,7 @@ gen_unit (def)\n \n   if (unit == 0)\n     {\n-      unit = (struct function_unit *) xmalloc (sizeof (struct function_unit));\n+      unit = (struct function_unit *) oballoc (sizeof (struct function_unit));\n       unit->name = name;\n       unit->multiplicity = multiplicity;\n       unit->simultaneity = simultaneity;\n@@ -4177,7 +4187,7 @@ gen_unit (def)\n     }\n \n   /* Make a new operation class structure entry and initialize it.  */\n-  op = (struct function_unit_op *) xmalloc (sizeof (struct function_unit_op));\n+  op = (struct function_unit_op *) oballoc (sizeof (struct function_unit_op));\n   op->condexp = condexp;\n   op->num = unit->num_opclasses++;\n   op->ready = ready_cost;\n@@ -5211,7 +5221,7 @@ find_attr (name, create)\n   if (! create)\n     return NULL;\n \n-  attr = (struct attr_desc *) xmalloc (sizeof (struct attr_desc));\n+  attr = (struct attr_desc *) oballoc (sizeof (struct attr_desc));\n   attr->name = attr_string (name, strlen (name));\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->negative_ok = attr->is_const = attr->is_special = 0;\n@@ -5302,7 +5312,7 @@ make_numeric_value (n)\n   if (n < 20 && int_values[n])\n     return int_values[n];\n \n-  p = attr_printf ((n < 1000 ? 4 : HOST_BITS_PER_INT * 3 / 10 + 3), \"%d\", n);\n+  p = attr_printf (MAX_DIGITS, \"%d\", n);\n   exp = attr_rtx (CONST_STRING, p);\n \n   if (n < 20)\n@@ -5508,13 +5518,13 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#define operands recog_operand\\n\\n\");\n \n   /* Make `insn_alternatives'.  */\n-  insn_alternatives = (int *) xmalloc (insn_code_number * sizeof (int));\n+  insn_alternatives = (int *) oballoc (insn_code_number * sizeof (int));\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code] = (1 << id->num_alternatives) - 1;\n \n   /* Make `insn_n_alternatives'.  */\n-  insn_n_alternatives = (int *) xmalloc (insn_code_number * sizeof (int));\n+  insn_n_alternatives = (int *) oballoc (insn_code_number * sizeof (int));\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_n_alternatives[id->insn_code] = id->num_alternatives;"}]}