{"sha": "f07778f6f92111aa0abfd0f669b148a0bda537a9", "node_id": "C_kwDOANBUbNoAKGYwNzc3OGY2ZjkyMTExYWEwYWJmZDBmNjY5YjE0OGEwYmRhNTM3YTk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-13T18:01:28Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-13T18:01:28Z"}, "message": "c++: dependence of constrained memfn from current inst [PR105842]\n\nHere we incorrectly deem the calls to func1, func2 and tmpl2 as\nambiguous ahead of time ultimately because we mishandle dependence\nof a constrained member function from the current instantiation.\n\nIn type_dependent_expression_p, we already consider dependence of a\nTEMPLATE_DECL's constraints (via uses_outer_template_parms), but\nneglect to do the same for a FUNCTION_DECL (such as that for func1).\n\nAnd in satisfy_declaration_constraints, we give up if _any_ template\nargument is dependent, but for non-dependent member functions from\nthe current instantiation (such as func2 and tmpl2), we can and must\ncheck constraints as long as the innermost arguments aren't dependent.\n\n\tPR c++/105842\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (satisfy_declaration_constraints): Refine early\n\texit test for argument dependence.\n\t* cp-tree.h (uses_outer_template_parms_in_constraints): Declare.\n\t* pt.cc (template_class_depth): Handle TI_TEMPLATE being a\n\tFIELD_DECL.\n\t(usse_outer_template_parms): Factor out constraint dependence\n\ttest into ...\n\t(uses_outer_template_parms_in_constraints): ... here.\n\t(type_dependent_expression_p): Use it for FUNCTION_DECL.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-memtmpl6.C: New test.", "tree": {"sha": "109eb127acfee6b79ad4f08532b95ffb417f2357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/109eb127acfee6b79ad4f08532b95ffb417f2357"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f07778f6f92111aa0abfd0f669b148a0bda537a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07778f6f92111aa0abfd0f669b148a0bda537a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f07778f6f92111aa0abfd0f669b148a0bda537a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07778f6f92111aa0abfd0f669b148a0bda537a9/comments", "author": null, "committer": null, "parents": [{"sha": "f35d65517a59565758107c5b1a51a5fa382f8d1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35d65517a59565758107c5b1a51a5fa382f8d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35d65517a59565758107c5b1a51a5fa382f8d1a"}], "stats": {"total": 96, "additions": 84, "deletions": 12}, "files": [{"sha": "f2137eb7aa1cdb62a4ecf83614ab912181b45ca6", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=f07778f6f92111aa0abfd0f669b148a0bda537a9", "patch": "@@ -3176,9 +3176,15 @@ satisfy_declaration_constraints (tree t, sat_info info)\n \targs = regen_args;\n     }\n \n-  /* If any arguments depend on template parameters, we can't\n-     check constraints. Pretend they're satisfied for now.  */\n-  if (uses_template_parms (args))\n+  /* If the innermost arguments are dependent, or if the outer arguments\n+     are dependent and are needed by the constraints, we can't check\n+     satisfaction yet so pretend they're satisfied for now.  */\n+  if (uses_template_parms (args)\n+      && ((DECL_TEMPLATE_INFO (t)\n+\t   && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t))\n+\t   && (TMPL_ARGS_DEPTH (args) == 1\n+\t       || uses_template_parms (INNERMOST_TEMPLATE_ARGS (args))))\n+\t  || uses_outer_template_parms_in_constraints (t)))\n     return boolean_true_node;\n \n   /* Get the normalized constraints.  */\n@@ -3240,9 +3246,13 @@ satisfy_declaration_constraints (tree t, tree args, sat_info info)\n   else\n     args = add_outermost_template_args (t, args);\n \n-  /* If any arguments depend on template parameters, we can't\n-     check constraints. Pretend they're satisfied for now.  */\n-  if (uses_template_parms (args))\n+  /* If the innermost arguments are dependent, or if the outer arguments\n+     are dependent and are needed by the constraints, we can't check\n+     satisfaction yet so pretend they're satisfied for now.  */\n+  if (uses_template_parms (args)\n+      && (TMPL_ARGS_DEPTH (args) == 1\n+\t  || uses_template_parms (INNERMOST_TEMPLATE_ARGS (args))\n+\t  || uses_outer_template_parms_in_constraints (t)))\n     return boolean_true_node;\n \n   tree result = boolean_true_node;"}, {"sha": "bec98aa2ac3b4bdc8feb8934f35ffa03347fd165", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f07778f6f92111aa0abfd0f669b148a0bda537a9", "patch": "@@ -7297,6 +7297,7 @@ extern tree lookup_template_function\t\t(tree, tree);\n extern tree lookup_template_variable\t\t(tree, tree);\n extern bool uses_template_parms\t\t\t(tree);\n extern bool uses_template_parms_level\t\t(tree, int);\n+extern bool uses_outer_template_parms_in_constraints (tree);\n extern bool in_template_function\t\t(void);\n extern bool need_generic_capture\t\t(void);\n extern tree instantiate_class_template\t\t(tree);"}, {"sha": "da00ce1301a3b1d1d638c197e6d911d2ee26116d", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=f07778f6f92111aa0abfd0f669b148a0bda537a9", "patch": "@@ -391,7 +391,9 @@ template_class_depth (tree type)\n     {\n       tree tinfo = get_template_info (type);\n \n-      if (tinfo && PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo))\n+      if (tinfo\n+\t  && TREE_CODE (TI_TEMPLATE (tinfo)) == TEMPLATE_DECL\n+\t  && PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo))\n \t  && uses_template_parms (INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo))))\n \t++depth;\n \n@@ -11011,7 +11013,7 @@ uses_template_parms_level (tree t, int level)\n /* Returns true if the signature of DECL depends on any template parameter from\n    its enclosing class.  */\n \n-bool\n+static bool\n uses_outer_template_parms (tree decl)\n {\n   int depth = template_class_depth (CP_DECL_CONTEXT (decl));\n@@ -11042,13 +11044,27 @@ uses_outer_template_parms (tree decl)\n \t    return true;\n \t}\n     }\n+  if (uses_outer_template_parms_in_constraints (decl))\n+    return true;\n+  return false;\n+}\n+\n+/* Returns true if the constraints of DECL depend on any template parameters\n+   from its enclosing scope.  */\n+\n+bool\n+uses_outer_template_parms_in_constraints (tree decl)\n+{\n   tree ci = get_constraints (decl);\n   if (ci)\n     ci = CI_ASSOCIATED_CONSTRAINTS (ci);\n-  if (ci && for_each_template_parm (ci, template_parm_outer_level,\n-\t\t\t\t    &depth, NULL, /*nondeduced*/true))\n-    return true;\n-  return false;\n+  if (!ci)\n+    return false;\n+  int depth = template_class_depth (CP_DECL_CONTEXT (decl));\n+  if (depth == 0)\n+    return false;\n+  return for_each_template_parm (ci, template_parm_outer_level,\n+\t\t\t\t &depth, NULL, /*nondeduced*/true);\n }\n \n /* Returns TRUE iff INST is an instantiation we don't need to do in an\n@@ -28103,6 +28119,17 @@ type_dependent_expression_p (tree expression)\n       return false;\n     }\n \n+  /* Otherwise, its constraints could still depend on outer template parameters\n+     from its (dependent) scope.  */\n+  if (TREE_CODE (expression) == FUNCTION_DECL\n+      /* As an optimization, check this cheaper sufficient condition first.\n+\t (At this point we've established that we're looking at a member of\n+\t a dependent class, so it makes sense to start treating say undeduced\n+\t auto as dependent.)  */\n+      && !dependent_type_p (TREE_TYPE (expression))\n+      && uses_outer_template_parms_in_constraints (expression))\n+    return true;\n+\n   /* Always dependent, on the number of arguments if nothing else.  */\n   if (TREE_CODE (expression) == EXPR_PACK_EXPANSION)\n     return true;"}, {"sha": "0e09ae6ed4c3a77cad93d637ec28b768d168d5a4", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07778f6f92111aa0abfd0f669b148a0bda537a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl6.C?ref=f07778f6f92111aa0abfd0f669b148a0bda537a9", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/105842\n+// { dg-do compile { target c++20 } }\n+\n+template<class T>\n+struct S {\n+  static void func1() requires __is_same(T, int);\n+  static void func1() requires (!__is_same(T, int));\n+\n+  static void func2() requires false && false;\n+  static void func2() requires false;\n+\n+  template<class...> static void tmpl1() requires __is_same(T, int);\n+  template<class...> static void tmpl1() requires (!__is_same(T, int));\n+\n+  template<class... Us> static void tmpl2() requires (sizeof...(Us) == 1);\n+  template<class... Us> static void tmpl2() requires (sizeof...(Us) == 2);\n+\n+  static void foo() {\n+    // Both calls resolve to the first overload at instantiation time.\n+    func1();\n+    tmpl1();\n+  }\n+\n+  static void bar() {\n+    // We can check and reject both calls ahead of time since the functions'\n+    // constraints don't depend on outer template parameters.\n+    func2(); // { dg-error \"no match\" }\n+    tmpl2(); // { dg-error \"no match\" }\n+  }\n+};\n+\n+int main() {\n+  S<int>::foo();\n+}"}]}