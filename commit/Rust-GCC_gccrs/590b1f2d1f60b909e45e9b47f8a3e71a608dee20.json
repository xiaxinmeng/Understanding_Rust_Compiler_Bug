{"sha": "590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwYjFmMmQxZjYwYjkwOWU0NWU5YjQ3ZjhhM2U3MWE2MDhkZWUyMA==", "commit": {"author": {"name": "Dirk Mueller", "email": "dmueller@suse.de", "date": "2007-01-18T13:00:33Z"}, "committer": {"name": "Dirk Mueller", "email": "mueller@gcc.gnu.org", "date": "2007-01-18T13:00:33Z"}, "message": "\u00b7 Richard Guenther <rguenther@suse.de>\n\n2007-01-18  Dirk Mueller  <dmueller@suse.de>\n\u00b7           Richard Guenther <rguenther@suse.de>\n\n\u00b7       PR diagnostic/8268\n\u00b7       * doc/invoke.texi (Warray-bounds): Document -Warray-bounds.\n\u00b7       * common.opt (Warray-bounds): Add new warning option.\n\u00b7       * c-opts.c (c_common_handle_option): Define -Warray-bounds\n\u00b7       if -Wall is given.\n        * Makefile.in: make tree-vrp.o depend on toplev.h\n\u00b7       * tree-vrp.c (vrp_finalize): Call check_array_refs if -Warray-bounds\n\u00b7       is enabled.\n\u00b7       (check_array_refs, check_array_bounds, check_array_ref): New.\n\n\u00b7       * gcc.dg/Warray-bounds.c: New testcase.\n        * gcc.dg/Warray-bounds-2.c: New testcase.\n        * g++.dg/warn/Warray-bounds.C: New testcase.\n        * g++.dg/warn/Warray-bounds-2.C: New testcase.\n\nFrom-SVN: r120898", "tree": {"sha": "2d86bde5e9f2aefe4b2d4556eac1f4327318abb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d86bde5e9f2aefe4b2d4556eac1f4327318abb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/comments", "author": null, "committer": null, "parents": [{"sha": "eedeea04da0bbdf7e975a31c9c55f3929657b909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedeea04da0bbdf7e975a31c9c55f3929657b909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eedeea04da0bbdf7e975a31c9c55f3929657b909"}], "stats": {"total": 403, "additions": 400, "deletions": 3}, "files": [{"sha": "9d832473795a532d635dec22e6d1e9e49e2c70c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -1,3 +1,16 @@\n+2007-01-18  Dirk Mueller  <dmueller@suse.de>\n+\ufffd           Richard Guenther <rguenther@suse.de>\n+\n+\ufffd       PR diagnostic/8268\n+\ufffd       * doc/invoke.texi (Warray-bounds): Document -Warray-bounds.\n+\ufffd       * common.opt (Warray-bounds): Add new warning option.\n+\ufffd       * c-opts.c (c_common_handle_option): Define -Warray-bounds\n+\ufffd       if -Wall is given.\n+\t* Makefile.in: make tree-vrp.o depend on toplev.h\n+\ufffd       * tree-vrp.c (vrp_finalize): Call check_array_refs if -Warray-bounds\n+\ufffd       is enabled.\n+\ufffd       (check_array_refs, check_array_bounds, check_array_ref): New.\n+\n 18-01-2007  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-ccp.c (ccp_finalize): Return if something changed."}, {"sha": "c63dec01989d308f429c3bce869671d4fcd88c33", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -1862,7 +1862,7 @@ tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\\n-   $(CFGLOOP_H) $(SCEV_H) tree-chrec.h $(TIMEVAR_H)\n+   $(CFGLOOP_H) $(SCEV_H) tree-chrec.h $(TIMEVAR_H) toplev.h\n tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "85ea6bb27ff785810f186aa9ea58d8b23a693bf7", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -396,6 +396,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       warn_strict_aliasing = value;\n       warn_string_literal_comparison = value;\n       warn_always_true = value;\n+      warn_array_bounds = value;\n \n       /* Only warn about unknown pragmas that are not in system\n \t headers.  */"}, {"sha": "109de7bf3d4278604dd8381b586170b5752edfdd", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -61,6 +61,10 @@ Walways-true\n Common Var(warn_always_true)\n Warn about comparisons that always evaluate to true\n \n+Warray-bounds\n+Common Var(warn_array_bounds)\n+Warn if an array is accessed out of bounds\n+\n Wattributes\n Common Var(warn_attributes) Init(1)\n Warn about inappropriate attribute usage"}, {"sha": "3447ff83ac8dfade176925dd7e0e997ab18d8d26", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -222,8 +222,8 @@ Objective-C and Objective-C++ Dialects}.\n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n @gccoptlist{-fsyntax-only  -pedantic  -pedantic-errors @gol\n--w  -Wextra  -Wall  -Waggregate-return -Walways-true -Wno-attributes @gol\n--Wc++-compat -Wcast-align  -Wcast-qual  -Wchar-subscripts @gol\n+-w  -Wextra  -Wall  -Waggregate-return -Walways-true -Warray-bounds @gol\n+-Wno-attributes -Wc++-compat -Wcast-align  -Wcast-qual  -Wchar-subscripts @gol\n -Wclobbered  -Wcomment @gol\n -Wconversion  -Wno-deprecated-declarations @gol\n -Wdisabled-optimization  -Wno-div-by-zero  @gol\n@@ -2842,6 +2842,13 @@ compiler is using for optimization.  This warning catches more cases than\n @option{-Wstrict-aliasing}, but it will also give a warning for some ambiguous\n cases that are safe.\n \n+@item -Warray-bounds\n+@opindex Wno-array-bounds\n+@opindex Warray-bounds\n+This option is only active when @option{-ftree-vrp} is active\n+(default for -O2 and above). It warns about subscripts to arrays\n+that are always out of bounds. This warning is enabled by @option{-Wall}.\n+\n @item -Wall\n @opindex Wall\n All of the above @samp{-W} options combined.  This enables all the"}, {"sha": "66b6bd431cd8c83b8266b0f080e2b3b8444c0a70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -1,3 +1,12 @@\n+2007-01-18  Dirk Mueller  <dmueller@suse.de>\n+\ufffd           Richard Guenther <rguenther@suse.de>\n+\n+\ufffd       PR diagnostic/8268\n+\ufffd       * gcc.dg/Warray-bounds.c: New testcase.\n+\t* gcc.dg/Warray-bounds-2.c: New testcase.\n+\t* g++.dg/warn/Warray-bounds.C: New testcase.\n+\t* g++.dg/warn/Warray-bounds-2.C: New testcase.\n+\n 2007-01-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/30476"}, {"sha": "796483e0e491551f1168b9afb762913e8d3dc9ac", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-2.C?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* Test that -Warray-bounds is enabled by -Wall */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+int a[10];\n+\n+int* f(void) {\n+\n+    a[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+\n+    return a;\n+}\n+"}, {"sha": "0385516abd4e215467d9358c8dfce053c0c1fe6e", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds.C", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds.C?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+\n+int a[10];\n+\n+static inline int n(void) {\n+    __SIZE_TYPE__ strlen(const char *s);\n+    return strlen(\"12345\");\n+}\n+\n+void g(int *p);\n+void h(int p);\n+\n+int* f(void) {\n+    int b[10];\n+    int i;\n+    struct {\n+       int c[10];\n+    } c;\n+\n+    a[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[ 0] = 0;\n+    a[ 1] = 0;\n+\n+\n+    a[ 9] = 0;\n+    a[10] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[11] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[2 * n() - 11] = 0;    /* { dg-warning \"array subscript\" } */\n+    a[2 * n() - 10] = 0;\n+    a[2 * n() -  1] = 0;\n+    a[2 * n() -  0] = 0;    /* { dg-warning \"array subscript\" } */\n+\n+    b[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[ 0] = 0;\n+    b[ 1] = 0;\n+    b[ 9] = 0;\n+    b[10] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[11] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[2 * n() - 11] = 0;    /* { dg-warning \"array subscript\" } */\n+    b[2 * n() - 10] = 0;\n+    b[2 * n() -  1] = 0;\n+    b[2 * n() -  0] = 0;    /* { dg-warning \"array subscript\" } */\n+\n+    c.c[-1] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[ 0] = 0;\n+    c.c[ 1] = 0;\n+    c.c[ 9] = 0;\n+    c.c[10] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[11] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[2 * n() - 11] = 0;  /* { dg-warning \"array subscript\" } */\n+    c.c[2 * n() - 10] = 0;\n+    c.c[2 * n() -  1] = 0;\n+    c.c[2 * n() -  0] = 0;  /* { dg-warning \"array subscript\" } */\n+\n+    g(&a[8]);\n+    g(&a[9]);\n+    g(&a[10]);\n+    g(&a[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&a[-30]+10);             /* { dg-warning \"array subscript\" } */\n+    g(&a[-30]+30);\n+\n+    g(&b[10]);\n+    g(&c.c[10]);\n+    g(&a[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&b[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&c.c[11]);           /* { dg-warning \"array subscript\" } */\n+\n+    g(&a[0]);\n+    g(&b[0]);\n+    g(&c.c[0]);\n+\n+    g(&a[-1]);             /* { dg-warning \"array subscript\" } */\n+    g(&b[-1]);             /* { dg-warning \"array subscript\" } */ \n+    h(sizeof a[-1]);\n+    h(sizeof a[10]);\n+    h(sizeof b[-1]);\n+    h(sizeof b[10]);\n+    h(sizeof c.c[-1]);\n+    h(sizeof c.c[10]);\n+\n+    if (10 < 10)\n+       a[10] = 0;\n+    if (10 < 10)\n+       b[10] = 0;\n+    if (-1 >= 0)\n+       c.c[-1] = 0;\n+\n+    return a;\n+}\n+"}, {"sha": "796483e0e491551f1168b9afb762913e8d3dc9ac", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-2.c?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* Test that -Warray-bounds is enabled by -Wall */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+int a[10];\n+\n+int* f(void) {\n+\n+    a[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+\n+    return a;\n+}\n+"}, {"sha": "fde457036cb45d4c491c50ae707d35f0f8de4287", "filename": "gcc/testsuite/gcc.dg/Warray-bounds.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+\n+int a[10];\n+\n+static inline int n(void) {\n+    __SIZE_TYPE__ strlen(const char *s);\n+    return strlen(\"12345\");\n+}\n+\n+void g(int *p);\n+void h(int p);\n+\n+int* f(void) {\n+    int b[10];\n+    int i;\n+    struct {\n+       int c[10];\n+    } c;\n+\n+    a[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[ 0] = 0;\n+    a[ 1] = 0;\n+\n+\n+    a[ 9] = 0;\n+    a[10] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[11] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[2 * n() - 11] = 0;    /* { dg-warning \"array subscript\" } */\n+    a[2 * n() - 10] = 0;\n+    a[2 * n() -  1] = 0;\n+    a[2 * n() -  0] = 0;    /* { dg-warning \"array subscript\" } */\n+\n+    b[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[ 0] = 0;\n+    b[ 1] = 0;\n+    b[ 9] = 0;\n+    b[10] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[11] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[2 * n() - 11] = 0;    /* { dg-warning \"array subscript\" } */\n+    b[2 * n() - 10] = 0;\n+    b[2 * n() -  1] = 0;\n+    b[2 * n() -  0] = 0;    /* { dg-warning \"array subscript\" } */\n+\n+    c.c[-1] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[ 0] = 0;\n+    c.c[ 1] = 0;\n+    c.c[ 9] = 0;\n+    c.c[10] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[11] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[2 * n() - 11] = 0;  /* { dg-warning \"array subscript\" } */\n+    c.c[2 * n() - 10] = 0;\n+    c.c[2 * n() -  1] = 0;\n+    c.c[2 * n() -  0] = 0;  /* { dg-warning \"array subscript\" } */\n+\n+    g(&a[8]);\n+    g(&a[9]);\n+    g(&a[10]);\n+    g(&a[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&a[-30]+10);             /* { dg-warning \"array subscript\" } */\n+    g(&a[-30]+30);\n+\n+    g(&b[10]);\n+    g(&c.c[10]);\n+    g(&a[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&b[11]);             /* { dg-warning \"array subscript\" } */\n+    g(&c.c[11]);           /* { dg-warning \"array subscript\" } */\n+\n+    g(&a[0]);\n+    g(&b[0]);\n+    g(&c.c[0]);\n+\n+    g(&a[-1]);             /* { dg-warning \"array subscript\" } */\n+    g(&b[-1]);             /* { dg-warning \"array subscript\" } */ \n+    h(sizeof a[-1]);\n+    h(sizeof a[10]);\n+    h(sizeof b[-1]);\n+    h(sizeof b[10]);\n+    h(sizeof c.c[-1]);\n+    h(sizeof c.c[10]);\n+\n+    if (10 < 10)\n+       a[10] = 0;\n+    if (10 < 10)\n+       b[10] = 0;\n+    if (-1 >= 0)\n+       c.c[-1] = 0;\n+\n+    for (i = 20; i < 30; ++i)\n+             a[i] = 1;       /* { dg-warning \"array subscript\" } */\n+\n+    return a;\n+}\n+"}, {"sha": "e4f5e639c5142f77904e8c93b3a02c1c276bb934", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590b1f2d1f60b909e45e9b47f8a3e71a608dee20/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n+#include \"toplev.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n@@ -3478,6 +3479,154 @@ insert_range_assertions (void)\n   BITMAP_FREE (need_assert_for);\n }\n \n+/* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays\n+   and \"struct\" hacks. If VRP can determine that the\n+   array subscript is a contant, check if it is outside valid\n+   range. If the array subscript is a RANGE, warn if it is\n+   non-overlapping with valid range.\n+   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n+\n+static void\n+check_array_ref (tree ref, location_t* locus, bool ignore_off_by_one)\n+{\n+  value_range_t* vr = NULL;\n+  tree low_sub, up_sub;\n+  tree low_bound, up_bound = array_ref_up_bound (ref);\n+\n+  low_sub = up_sub = TREE_OPERAND (ref, 1);\n+\n+  if (!up_bound || !locus || TREE_NO_WARNING (ref)\n+      || TREE_CODE (up_bound) != INTEGER_CST\n+      /* Can not check flexible arrays.  */\n+      || (TYPE_SIZE (TREE_TYPE (ref)) == NULL_TREE\n+          && TYPE_DOMAIN (TREE_TYPE (ref)) != NULL_TREE\n+          && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (ref))) == NULL_TREE)\n+      /* Accesses after the end of arrays of size 0 (gcc\n+         extension) and 1 are likely intentional (\"struct\n+         hack\").  */\n+      || compare_tree_int (up_bound, 1) <= 0)\n+    return;\n+\n+  low_bound = array_ref_low_bound (ref);\n+\n+  if (TREE_CODE (low_sub) == SSA_NAME)\n+    {\n+      vr = get_value_range (low_sub);\n+      if (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n+        {\n+          low_sub = vr->type == VR_RANGE ? vr->max : vr->min;\n+          up_sub = vr->type == VR_RANGE ? vr->min : vr->max;\n+        }\n+    }\n+\n+  if (vr && vr->type == VR_ANTI_RANGE)\n+    {\n+      if (TREE_CODE (up_sub) == INTEGER_CST\n+          && tree_int_cst_lt (up_bound, up_sub)\n+          && TREE_CODE (low_sub) == INTEGER_CST\n+          && tree_int_cst_lt (low_sub, low_bound))\n+        {\n+          warning (OPT_Warray_bounds,\n+                   \"%Harray subscript is outside array bounds\", locus);\n+          TREE_NO_WARNING (ref) = 1;\n+        }\n+    }\n+  else if (TREE_CODE (up_sub) == INTEGER_CST\n+           && tree_int_cst_lt (up_bound, up_sub)\n+           && !tree_int_cst_equal (up_bound, up_sub)\n+           && (!ignore_off_by_one\n+               || !tree_int_cst_equal (int_const_binop (PLUS_EXPR,\n+                                                        up_bound,\n+                                                        integer_one_node,\n+                                                        0),\n+                                       up_sub)))\n+    {\n+      warning (OPT_Warray_bounds, \"%Harray subscript is above array bounds\",\n+               locus);\n+      TREE_NO_WARNING (ref) = 1;\n+    }\n+  else if (TREE_CODE (low_sub) == INTEGER_CST\n+           && tree_int_cst_lt (low_sub, low_bound))\n+    {\n+      warning (OPT_Warray_bounds, \"%Harray subscript is below array bounds\",\n+               locus);\n+      TREE_NO_WARNING (ref) = 1;\n+    }\n+}\n+\n+/* walk_tree() callback that checks if *TP is\n+   an ARRAY_REF inside an ADDR_EXPR (in which an array\n+   subscript one outside the valid range is allowed). Call\n+   check_array_ref for each ARRAY_REF found. The location is \n+   passed in DATA.  */\n+\n+static tree\n+check_array_bounds (tree *tp, int *walk_subtree, void *data)\n+{\n+  tree t = *tp;\n+  location_t *location = EXPR_LOCUS ((tree) data);\n+\n+  *walk_subtree = TRUE;\n+\n+  if (TREE_CODE (t) == ARRAY_REF)\n+    check_array_ref (t, location, false /*ignore_off_by_one*/);\n+  else if (TREE_CODE (t) == ADDR_EXPR)\n+    {\n+       t = TREE_OPERAND (t, 0);\n+\n+       /* Don't warn on statements like\n+          ssa_name = 500 + &array[-200] which are sometimes\n+          produced by various optimizing passes.  */\n+       if (TREE_CODE ((tree)data) == GIMPLE_MODIFY_STMT\n+           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND ((tree)data, 1)))\n+         {\n+           *walk_subtree = FALSE;\n+           return NULL_TREE;\n+         }\n+       while (handled_component_p (t))\n+         {\n+           if (TREE_CODE (t) == ARRAY_REF)\n+             check_array_ref (t, location, true /*ignore_off_by_one*/);\n+           t = TREE_OPERAND (t, 0);\n+         }\n+       *walk_subtree = FALSE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Walk over all statements of all reachable BBs and call check_array_bounds\n+   on them.  */\n+\n+static void\n+check_all_array_refs (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator si;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Skip bb's that are clearly unreachable.  */\n+      if (single_pred_p (bb))\n+      {\n+\tbasic_block pred_bb = EDGE_PRED (bb, 0)->src;\n+\ttree ls = NULL_TREE;\n+\n+\tif (!bsi_end_p (bsi_last (pred_bb)))\n+\t  ls = bsi_stmt (bsi_last (pred_bb));\n+\n+\tif (ls && TREE_CODE (ls) == COND_EXPR\n+\t    && ((COND_EXPR_COND (ls) == boolean_false_node\n+\t\t && (EDGE_PRED (bb, 0)->flags & EDGE_TRUE_VALUE))\n+\t\t|| (COND_EXPR_COND (ls) == boolean_true_node\n+\t\t    && (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE))))\n+\t  continue;\n+      }\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\twalk_tree (bsi_stmt_ptr (si), check_array_bounds,\n+\t\t   bsi_stmt (si), NULL);\n+    }\n+}\n \n /* Convert range assertion expressions into the implied copies and\n    copy propagate away the copies.  Doing the trivial copy propagation\n@@ -4797,6 +4946,9 @@ vrp_finalize (void)\n \n   substitute_and_fold (single_val_range, true);\n \n+  if (warn_array_bounds)\n+      check_all_array_refs();\n+\n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n   identify_jump_threads ();"}]}