{"sha": "c3583c4ab028a77ca104dc6972b974260398f3ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM1ODNjNGFiMDI4YTc3Y2ExMDRkYzY5NzJiOTc0MjYwMzk4ZjNhYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-12-12T09:56:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-12-12T09:56:22Z"}, "message": "re PR target/55659 ([SH] Build failure with ICE in dwarf2out_var_location, at dwarf2out.c:20748)\n\n\tPR target/55659\n\tRevert\n\t2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/43631\n\t* var-tracking.c (emit_note_insn_var_location): If insn is followed\n\tby BARRIER, put note after the BARRIER.\n\t(next_non_note_insn_var_location): Skip over BARRIERs.\n\t(emit_notes_in_bb): If call is followed by BARRIER, put note after\n\tthe BARRIER.\n\n\t2012-12-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/43631\n\t* var-tracking.c (emit_note_insn_var_location, emit_notes_in_bb):\n\tClear BLOCK_FOR_INSN on notes emitted in between basic blocks,\n\tdon't adjust BB_END when inserting note after BB_END of some bb.\n\nFrom-SVN: r194442", "tree": {"sha": "4193a0958fbce09cb3ad73bf3b0cfaf096e726cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4193a0958fbce09cb3ad73bf3b0cfaf096e726cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3583c4ab028a77ca104dc6972b974260398f3ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3583c4ab028a77ca104dc6972b974260398f3ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3583c4ab028a77ca104dc6972b974260398f3ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3583c4ab028a77ca104dc6972b974260398f3ac/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57dab7925d52135be54eec74f2b0ac569a7c48bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57dab7925d52135be54eec74f2b0ac569a7c48bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57dab7925d52135be54eec74f2b0ac569a7c48bf"}], "stats": {"total": 73, "additions": 27, "deletions": 46}, "files": [{"sha": "334a3ca384b1ed8acda3f2983241a2b423e5c3ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3583c4ab028a77ca104dc6972b974260398f3ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3583c4ab028a77ca104dc6972b974260398f3ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3583c4ab028a77ca104dc6972b974260398f3ac", "patch": "@@ -1,3 +1,23 @@\n+2012-12-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/55659\n+\tRevert\n+\t2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/43631\n+\t* var-tracking.c (emit_note_insn_var_location): If insn is followed\n+\tby BARRIER, put note after the BARRIER.\n+\t(next_non_note_insn_var_location): Skip over BARRIERs.\n+\t(emit_notes_in_bb): If call is followed by BARRIER, put note after\n+\tthe BARRIER.\n+\n+\t2012-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/43631\n+\t* var-tracking.c (emit_note_insn_var_location, emit_notes_in_bb):\n+\tClear BLOCK_FOR_INSN on notes emitted in between basic blocks,\n+\tdon't adjust BB_END when inserting note after BB_END of some bb.\n+\n 2012-12-12  Steven Bosscher  <steven@gcc.gnu.org>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "f5ba115bcfecf3bb84c4eb2103b459d9ecad7a28", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3583c4ab028a77ca104dc6972b974260398f3ac/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3583c4ab028a77ca104dc6972b974260398f3ac/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c3583c4ab028a77ca104dc6972b974260398f3ac", "patch": "@@ -8538,10 +8538,7 @@ emit_note_insn_var_location (void **varp, void *data)\n \n   if (where != EMIT_NOTE_BEFORE_INSN)\n     {\n-      rtx after = insn;\n-      while (NEXT_INSN (after) && BARRIER_P (NEXT_INSN (after)))\n-\tafter = NEXT_INSN (after);\n-      note = emit_note_after (NOTE_INSN_VAR_LOCATION, after);\n+      note = emit_note_after (NOTE_INSN_VAR_LOCATION, insn);\n       if (where == EMIT_NOTE_AFTER_CALL_INSN)\n \tNOTE_DURING_CALL_P (note) = true;\n     }\n@@ -8560,30 +8557,9 @@ emit_note_insn_var_location (void **varp, void *data)\n \t      || NOTE_KIND (insn) == NOTE_INSN_CALL_ARG_LOCATION))\n \tnote = emit_note_after (NOTE_INSN_VAR_LOCATION, insn);\n       else\n-\t{\n-\t  note = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n-\t  /* If insn is BB_HEAD of some bb, make sure the note\n-\t     doesn't have BLOCK_FOR_INSN set.  The notes don't\n-\t     extend the extents of a basic block, and e.g. notes emitted\n-\t     for differences in between basic blocks should live in between\n-\t     the basic blocks.  */\n-\t  if (BLOCK_FOR_INSN (note)\n-\t      && BB_HEAD (BLOCK_FOR_INSN (note)) == insn)\n-\t    set_block_for_insn (note, NULL);\n-\t}\n+\tnote = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n     }\n   NOTE_VAR_LOCATION (note) = note_vl;\n-  /* If insn is BB_END of some bb, make sure the note\n-     doesn't have BLOCK_FOR_INSN set.  The notes don't\n-     extend the extents of a basic block, and e.g. a noreturn\n-     call can still be followed by NOTE_INSN_CALL_ARG_LOCATION.  */\n-  if (BLOCK_FOR_INSN (note)\n-      && BB_END (BLOCK_FOR_INSN (note)) == note\n-      && PREV_INSN (note) == insn)\n-    {\n-      BB_END (BLOCK_FOR_INSN (note)) = insn;\n-      set_block_for_insn (note, NULL);\n-    }\n \n   set_dv_changed (var->dv, false);\n   gcc_assert (var->in_changed_variables);\n@@ -8895,11 +8871,9 @@ next_non_note_insn_var_location (rtx insn)\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n-      if (insn == 0)\n-\tbreak;\n-      if (BARRIER_P (insn))\n-\tcontinue;\n-      if (!NOTE_P (insn) || NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION)\n+      if (insn == 0\n+\t  || !NOTE_P (insn)\n+\t  || NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION)\n \tbreak;\n     }\n \n@@ -8928,7 +8902,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t    dataflow_set_clear_at_call (set);\n \t    emit_notes_for_changes (insn, EMIT_NOTE_AFTER_CALL_INSN, set->vars);\n \t    {\n-\t      rtx arguments = mo->u.loc, *p = &arguments, note, after;\n+\t      rtx arguments = mo->u.loc, *p = &arguments, note;\n \t      while (*p)\n \t\t{\n \t\t  XEXP (XEXP (*p, 0), 1)\n@@ -8952,21 +8926,8 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t\t  else\n \t\t    *p = XEXP (*p, 1);\n \t\t}\n-\t      after = insn;\n-\t      while (NEXT_INSN (after) && BARRIER_P (NEXT_INSN (after)))\n-\t\tafter = NEXT_INSN (after);\n-\t      note = emit_note_after (NOTE_INSN_CALL_ARG_LOCATION, after);\n+\t      note = emit_note_after (NOTE_INSN_CALL_ARG_LOCATION, insn);\n \t      NOTE_VAR_LOCATION (note) = arguments;\n-\t      /* If insn is BB_END of some bb, make sure the note\n-\t\t doesn't have BLOCK_FOR_INSN set.  The notes don't\n-\t\t extend the extents of a basic block, and e.g. a noreturn\n-\t\t call can still be followed by NOTE_INSN_CALL_ARG_LOCATION.  */\n-\t      if (BLOCK_FOR_INSN (note)\n-\t\t  && BB_END (BLOCK_FOR_INSN (note)) == note)\n-\t\t{\n-\t\t  BB_END (BLOCK_FOR_INSN (note)) = insn;\n-\t\t  set_block_for_insn (note, NULL);\n-\t\t}\n \t    }\n \t    break;\n "}]}