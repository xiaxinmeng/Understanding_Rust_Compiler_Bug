{"sha": "0ca91c77f47be118b5b2a0b97e986863c80beafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNhOTFjNzdmNDdiZTExOGI1YjJhMGI5N2U5ODY4NjNjODBiZWFmYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-02T16:09:23Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-02T16:09:23Z"}, "message": "tree-ssa-loop-ivopts.c (struct cost_pair): Rename depends_on to inv_vars.\n\n\t* tree-ssa-loop-ivopts.c (struct cost_pair): Rename depends_on to\n\tinv_vars.  Add inv_exprs.\n\t(struct iv_cand): Rename depends_on to inv_vars.\n\t(struct ivopts_data): Rename max_inv_id/n_invariant_uses to\n\tmax_inv_var_id/n_inv_var_uses.  Move max_inv_expr_id around.\n\tRefactor field used_inv_exprs from has_map to array n_inv_expr_uses.\n\t(dump_cand): Dump inv_vars.\n\t(tree_ssa_iv_optimize_init): Support inv_vars and inv_exprs.\n\t(record_invariant, find_depends, add_candidate_1): Ditto.\n\t(set_group_iv_cost, force_var_cost): Ditto.\n\t(split_address_cost, ptr_difference_cost, difference_cost): Ditto.\n\t(get_computation_cost_at, get_computation_cost): Ditto.\n\t(determine_group_iv_cost_generic): Ditto.\n\t(determine_group_iv_cost_address): Ditto.\n\t(determine_group_iv_cost_cond, autoinc_possible_for_pair): Ditto.\n\t(determine_group_iv_costs): Ditto.\n\t(iv_ca_recount_cost): Update call to ivopts_global_cost_for_size.\n\t(iv_ca_set_remove_invariants): Renamed to ...\n\t(iv_ca_set_remove_invs): ... this.  Support inv_vars and inv_exprs.\n\t(iv_ca_set_no_cp): Use iv_ca_set_remove_invs.\n\t(iv_ca_set_add_invariants):  Renamed to ...\n\t(iv_ca_set_add_invs): ... this.  Support inv_vars and inv_exprs.\n\t(iv_ca_set_cp): Use iv_ca_set_add_invs.\n\t(iv_ca_has_deps): Support inv_vars and inv_exprs.\n\t(iv_ca_new, iv_ca_free, iv_ca_dump, free_loop_data): Ditto.\n\t(create_new_ivs): Remove useless dump.\n\n\tgcc/testsuite\n\t* g++.dg/tree-ssa/ivopts-3.C: Adjust test string.\n\nFrom-SVN: r247512", "tree": {"sha": "9ce10a81be4d6cbaa85a5f5a8adb50b5702e729f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ce10a81be4d6cbaa85a5f5a8adb50b5702e729f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ca91c77f47be118b5b2a0b97e986863c80beafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca91c77f47be118b5b2a0b97e986863c80beafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca91c77f47be118b5b2a0b97e986863c80beafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca91c77f47be118b5b2a0b97e986863c80beafc/comments", "author": null, "committer": null, "parents": [{"sha": "c166202824f213256d6ef6409ac268defbd00a75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c166202824f213256d6ef6409ac268defbd00a75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c166202824f213256d6ef6409ac268defbd00a75"}], "stats": {"total": 372, "additions": 209, "deletions": 163}, "files": [{"sha": "4e18c1434ebed138f02c198fd17707dcfeff7ab5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ca91c77f47be118b5b2a0b97e986863c80beafc", "patch": "@@ -1,3 +1,32 @@\n+2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (struct cost_pair): Rename depends_on to\n+\tinv_vars.  Add inv_exprs.\n+\t(struct iv_cand): Rename depends_on to inv_vars.\n+\t(struct ivopts_data): Rename max_inv_id/n_invariant_uses to\n+\tmax_inv_var_id/n_inv_var_uses.  Move max_inv_expr_id around.\n+\tRefactor field used_inv_exprs from has_map to array n_inv_expr_uses.\n+\t(dump_cand): Dump inv_vars.\n+\t(tree_ssa_iv_optimize_init): Support inv_vars and inv_exprs.\n+\t(record_invariant, find_depends, add_candidate_1): Ditto.\n+\t(set_group_iv_cost, force_var_cost): Ditto.\n+\t(split_address_cost, ptr_difference_cost, difference_cost): Ditto.\n+\t(get_computation_cost_at, get_computation_cost): Ditto.\n+\t(determine_group_iv_cost_generic): Ditto.\n+\t(determine_group_iv_cost_address): Ditto.\n+\t(determine_group_iv_cost_cond, autoinc_possible_for_pair): Ditto.\n+\t(determine_group_iv_costs): Ditto.\n+\t(iv_ca_recount_cost): Update call to ivopts_global_cost_for_size.\n+\t(iv_ca_set_remove_invariants): Renamed to ...\n+\t(iv_ca_set_remove_invs): ... this.  Support inv_vars and inv_exprs.\n+\t(iv_ca_set_no_cp): Use iv_ca_set_remove_invs.\n+\t(iv_ca_set_add_invariants):  Renamed to ...\n+\t(iv_ca_set_add_invs): ... this.  Support inv_vars and inv_exprs.\n+\t(iv_ca_set_cp): Use iv_ca_set_add_invs.\n+\t(iv_ca_has_deps): Support inv_vars and inv_exprs.\n+\t(iv_ca_new, iv_ca_free, iv_ca_dump, free_loop_data): Ditto.\n+\t(create_new_ivs): Remove useless dump.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Remove pseudo"}, {"sha": "4a7c4e44a6b5f7e3644bc98fdc09937872129e4a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ca91c77f47be118b5b2a0b97e986863c80beafc", "patch": "@@ -1,3 +1,7 @@\n+2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* g++.dg/tree-ssa/ivopts-3.C: Adjust test string.\n+\n 2017-04-27  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.dg/lsr-div1.c: New testcase."}, {"sha": "07ff1b770f87e01354b3c1e7f3f6bf106868eaa8", "filename": "gcc/testsuite/g++.dg/tree-ssa/ivopts-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C?ref=0ca91c77f47be118b5b2a0b97e986863c80beafc", "patch": "@@ -72,4 +72,4 @@ int main ( int , char** ) {\n \n // Verify that on x86_64 and i?86 we use a single IV for the innermost loop\n \n-// { dg-final { scan-tree-dump \"Selected IV set for loop \\[0-9\\]* at \\[^ \\]*:64, 3 avg niters, 1 expressions, 1 IVs\" \"ivopts\" { target x86_64-*-* i?86-*-* } } }\n+// { dg-final { scan-tree-dump \"Selected IV set for loop \\[0-9\\]* at \\[^ \\]*:64, 3 avg niters, 1 IVs\" \"ivopts\" { target x86_64-*-* i?86-*-* } } }"}, {"sha": "f9914e0b60fbc0b47fa939c2b78606f024f1b503", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 175, "deletions": 162, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca91c77f47be118b5b2a0b97e986863c80beafc/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0ca91c77f47be118b5b2a0b97e986863c80beafc", "patch": "@@ -347,8 +347,9 @@ struct cost_pair\n   struct iv_cand *cand;\t/* The candidate.  */\n   comp_cost cost;\t/* The cost.  */\n   enum tree_code comp;\t/* For iv elimination, the comparison.  */\n-  bitmap depends_on;\t/* The list of invariants that have to be\n+  bitmap inv_vars;\t/* The list of invariants that have to be\n \t\t\t   preserved.  */\n+  bitmap inv_exprs;\t/* Loop invariant expressions.  */\n   tree value;\t\t/* For final value elimination, the expression for\n \t\t\t   the final value of the iv.  For iv elimination,\n \t\t\t   the new bound to compare with.  */\n@@ -418,7 +419,7 @@ struct iv_cand\n   unsigned cost_step;\t/* Cost of the candidate's increment operation.  */\n   struct iv_use *ainc_use; /* For IP_{BEFORE,AFTER}_USE candidates, the place\n \t\t\t      where it is incremented.  */\n-  bitmap depends_on;\t/* The list of invariants that are used in step of the\n+  bitmap inv_vars;\t/* The list of invariants that are used in step of the\n \t\t\t   biv.  */\n   struct iv *orig_iv;\t/* The original iv if this cand is added from biv with\n \t\t\t   smaller type.  */\n@@ -542,9 +543,6 @@ struct ivopts_data\n      by ivopt.  */\n   hash_table<iv_inv_expr_hasher> *inv_expr_tab;\n \n-  /* Loop invariant expression id.  */\n-  int max_inv_expr_id;\n-\n   /* The bitmap of indices in version_info whose value was changed.  */\n   bitmap relevant;\n \n@@ -566,8 +564,11 @@ struct ivopts_data\n   /* The common candidates.  */\n   vec<iv_common_cand *> iv_common_cands;\n \n-  /* The maximum invariant id.  */\n-  unsigned max_inv_id;\n+  /* The maximum invariant variable id.  */\n+  unsigned max_inv_var_id;\n+\n+  /* The maximum invariant expression id.  */\n+  unsigned max_inv_expr_id;\n \n   /* Number of no_overflow BIVs which are not used in memory address.  */\n   unsigned bivs_not_used_in_addr;\n@@ -620,11 +621,11 @@ struct iv_ca\n   /* Total cost of candidates.  */\n   unsigned cand_cost;\n \n-  /* Number of times each invariant is used.  */\n-  unsigned *n_invariant_uses;\n+  /* Number of times each invariant variable is used.  */\n+  unsigned *n_inv_var_uses;\n \n-  /* Hash set with used invariant expression.  */\n-  hash_map <iv_inv_expr_ent *, unsigned> *used_inv_exprs;\n+  /* Number of times each invariant expression is used.  */\n+  unsigned *n_inv_expr_uses;\n \n   /* Total cost of the assignment.  */\n   comp_cost cost;\n@@ -783,10 +784,10 @@ dump_cand (FILE *file, struct iv_cand *cand)\n   struct iv *iv = cand->iv;\n \n   fprintf (file, \"Candidate %d:\\n\", cand->id);\n-  if (cand->depends_on)\n+  if (cand->inv_vars)\n     {\n-      fprintf (file, \"  Depend on: \");\n-      dump_bitmap (file, cand->depends_on);\n+      fprintf (file, \"  Depend on inv.vars: \");\n+      dump_bitmap (file, cand->inv_vars);\n     }\n \n   if (cand->var_before)\n@@ -1059,12 +1060,12 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->version_info = XCNEWVEC (struct version_info, data->version_info_size);\n   data->relevant = BITMAP_ALLOC (NULL);\n   data->important_candidates = BITMAP_ALLOC (NULL);\n-  data->max_inv_id = 0;\n+  data->max_inv_var_id = 0;\n+  data->max_inv_expr_id = 0;\n   data->niters = NULL;\n   data->vgroups.create (20);\n   data->vcands.create (20);\n   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);\n-  data->max_inv_expr_id = 0;\n   data->name_expansion_cache = NULL;\n   data->iv_common_cand_tab = new hash_table<iv_common_cand_hasher> (10);\n   data->iv_common_cands.create (20);\n@@ -1536,7 +1537,7 @@ record_invariant (struct ivopts_data *data, tree op, bool nonlinear_use)\n   info->name = op;\n   info->has_nonlin_use |= nonlinear_use;\n   if (!info->inv_id)\n-    info->inv_id = ++data->max_inv_id;\n+    info->inv_id = ++data->max_inv_var_id;\n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (op));\n }\n \n@@ -2902,7 +2903,7 @@ static struct ivopts_data *fd_ivopts_data;\n static tree\n find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n {\n-  bitmap *depends_on = (bitmap *) data;\n+  bitmap *inv_vars = (bitmap *) data;\n   struct version_info *info;\n \n   if (TREE_CODE (*expr_p) != SSA_NAME)\n@@ -2912,9 +2913,9 @@ find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n   if (!info->inv_id || info->has_nonlin_use)\n     return NULL_TREE;\n \n-  if (!*depends_on)\n-    *depends_on = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (*depends_on, info->inv_id);\n+  if (!*inv_vars)\n+    *inv_vars = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (*inv_vars, info->inv_id);\n \n   return NULL_TREE;\n }\n@@ -2997,7 +2998,7 @@ add_candidate_1 (struct ivopts_data *data,\n       if (TREE_CODE (step) != INTEGER_CST)\n \t{\n \t  fd_ivopts_data = data;\n-\t  walk_tree (&step, find_depends, &cand->depends_on, NULL);\n+\t  walk_tree (&step, find_depends, &cand->inv_vars, NULL);\n \t}\n \n       if (pos == IP_AFTER_USE || pos == IP_BEFORE_USE)\n@@ -3432,31 +3433,32 @@ alloc_use_cost_map (struct ivopts_data *data)\n }\n \n /* Sets cost of (GROUP, CAND) pair to COST and record that it depends\n-   on invariants DEPENDS_ON and that the value used in expressing it\n-   is VALUE, and in case of iv elimination the comparison operator is COMP.  */\n+   on invariants INV_VARS and that the value used in expressing it is\n+   VALUE, and in case of iv elimination the comparison operator is COMP.  */\n \n static void\n set_group_iv_cost (struct ivopts_data *data,\n \t\t   struct iv_group *group, struct iv_cand *cand,\n-\t\t   comp_cost cost, bitmap depends_on, tree value,\n-\t\t   enum tree_code comp, iv_inv_expr_ent *inv_expr)\n+\t\t   comp_cost cost, bitmap inv_vars, tree value,\n+\t\t   enum tree_code comp, bitmap inv_exprs)\n {\n   unsigned i, s;\n \n   if (cost.infinite_cost_p ())\n     {\n-      BITMAP_FREE (depends_on);\n+      BITMAP_FREE (inv_vars);\n+      BITMAP_FREE (inv_exprs);\n       return;\n     }\n \n   if (data->consider_all_candidates)\n     {\n       group->cost_map[cand->id].cand = cand;\n       group->cost_map[cand->id].cost = cost;\n-      group->cost_map[cand->id].depends_on = depends_on;\n+      group->cost_map[cand->id].inv_vars = inv_vars;\n+      group->cost_map[cand->id].inv_exprs = inv_exprs;\n       group->cost_map[cand->id].value = value;\n       group->cost_map[cand->id].comp = comp;\n-      group->cost_map[cand->id].inv_expr = inv_expr;\n       return;\n     }\n \n@@ -3474,10 +3476,10 @@ set_group_iv_cost (struct ivopts_data *data,\n found:\n   group->cost_map[i].cand = cand;\n   group->cost_map[i].cost = cost;\n-  group->cost_map[i].depends_on = depends_on;\n+  group->cost_map[i].inv_vars = inv_vars;\n+  group->cost_map[i].inv_exprs = inv_exprs;\n   group->cost_map[i].value = value;\n   group->cost_map[i].comp = comp;\n-  group->cost_map[i].inv_expr = inv_expr;\n }\n \n /* Gets cost of (GROUP, CAND) pair.  */\n@@ -4480,31 +4482,31 @@ force_expr_to_var_cost (tree expr, bool speed)\n   return cost;\n }\n \n-/* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the\n+/* Estimates cost of forcing EXPR into a variable.  INV_VARS is a set of the\n    invariants the computation depends on.  */\n \n static comp_cost\n force_var_cost (struct ivopts_data *data,\n-\t\ttree expr, bitmap *depends_on)\n+\t\ttree expr, bitmap *inv_vars)\n {\n-  if (depends_on)\n+  if (inv_vars)\n     {\n       fd_ivopts_data = data;\n-      walk_tree (&expr, find_depends, depends_on, NULL);\n+      walk_tree (&expr, find_depends, inv_vars, NULL);\n     }\n \n   return force_expr_to_var_cost (expr, data->speed);\n }\n \n /* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n    value of offset is added to OFFSET, SYMBOL_PRESENT and VAR_PRESENT are set\n-   to false if the corresponding part is missing.  DEPENDS_ON is a set of the\n+   to false if the corresponding part is missing.  inv_vars is a set of the\n    invariants the computation depends on.  */\n \n static comp_cost\n split_address_cost (struct ivopts_data *data,\n \t\t    tree addr, bool *symbol_present, bool *var_present,\n-\t\t    unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n+\t\t    unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n {\n   tree core;\n   HOST_WIDE_INT bitsize;\n@@ -4524,8 +4526,8 @@ split_address_cost (struct ivopts_data *data,\n       *symbol_present = false;\n       *var_present = true;\n       fd_ivopts_data = data;\n-      if (depends_on)\n-\twalk_tree (&addr, find_depends, depends_on, NULL);\n+      if (inv_vars)\n+\twalk_tree (&addr, find_depends, inv_vars, NULL);\n \n       return comp_cost (target_spill_cost[data->speed], 0);\n     }\n@@ -4547,13 +4549,13 @@ split_address_cost (struct ivopts_data *data,\n /* Estimates cost of expressing difference of addresses E1 - E2 as\n    var + symbol + offset.  The value of offset is added to OFFSET,\n    SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding\n-   part is missing.  DEPENDS_ON is a set of the invariants the computation\n+   part is missing.  inv_vars is a set of the invariants the computation\n    depends on.  */\n \n static comp_cost\n ptr_difference_cost (struct ivopts_data *data,\n \t\t     tree e1, tree e2, bool *symbol_present, bool *var_present,\n-\t\t     unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n+\t\t     unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n {\n   HOST_WIDE_INT diff = 0;\n   aff_tree aff_e1, aff_e2;\n@@ -4571,7 +4573,7 @@ ptr_difference_cost (struct ivopts_data *data,\n \n   if (integer_zerop (e2))\n     return split_address_cost (data, TREE_OPERAND (e1, 0),\n-\t\t\t       symbol_present, var_present, offset, depends_on);\n+\t\t\t       symbol_present, var_present, offset, inv_vars);\n \n   *symbol_present = false;\n   *var_present = true;\n@@ -4582,19 +4584,19 @@ ptr_difference_cost (struct ivopts_data *data,\n   aff_combination_scale (&aff_e2, -1);\n   aff_combination_add (&aff_e1, &aff_e2);\n \n-  return force_var_cost (data, aff_combination_to_tree (&aff_e1), depends_on);\n+  return force_var_cost (data, aff_combination_to_tree (&aff_e1), inv_vars);\n }\n \n /* Estimates cost of expressing difference E1 - E2 as\n    var + symbol + offset.  The value of offset is added to OFFSET,\n    SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding\n-   part is missing.  DEPENDS_ON is a set of the invariants the computation\n+   part is missing.  INV_VARS is a set of the invariants the computation\n    depends on.  */\n \n static comp_cost\n difference_cost (struct ivopts_data *data,\n \t\t tree e1, tree e2, bool *symbol_present, bool *var_present,\n-\t\t unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n+\t\t unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n {\n   machine_mode mode = TYPE_MODE (TREE_TYPE (e1));\n   unsigned HOST_WIDE_INT off1, off2;\n@@ -4610,7 +4612,7 @@ difference_cost (struct ivopts_data *data,\n \n   if (TREE_CODE (e1) == ADDR_EXPR)\n     return ptr_difference_cost (data, e1, e2, symbol_present, var_present,\n-\t\t\t\toffset, depends_on);\n+\t\t\t\toffset, inv_vars);\n   *symbol_present = false;\n \n   if (operand_equal_p (e1, e2, 0))\n@@ -4622,11 +4624,11 @@ difference_cost (struct ivopts_data *data,\n   *var_present = true;\n \n   if (integer_zerop (e2))\n-    return force_var_cost (data, e1, depends_on);\n+    return force_var_cost (data, e1, inv_vars);\n \n   if (integer_zerop (e1))\n     {\n-      comp_cost cost = force_var_cost (data, e2, depends_on);\n+      comp_cost cost = force_var_cost (data, e2, inv_vars);\n       cost += mult_by_coeff_cost (-1, mode, data->speed);\n       return cost;\n     }\n@@ -4637,7 +4639,7 @@ difference_cost (struct ivopts_data *data,\n   aff_combination_scale (&aff_e2, -1);\n   aff_combination_add (&aff_e1, &aff_e2);\n \n-  return force_var_cost (data, aff_combination_to_tree (&aff_e1), depends_on);\n+  return force_var_cost (data, aff_combination_to_tree (&aff_e1), inv_vars);\n }\n \n /* Returns true if AFF1 and AFF2 are identical.  */\n@@ -4818,14 +4820,14 @@ get_scaled_computation_cost_at (ivopts_data *data, gimple *at, iv_cand *cand,\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n    register.  A set of invariants we depend on is stored in\n-   DEPENDS_ON.  AT is the statement at that the value is computed.\n+   INV_VARS.  AT is the statement at that the value is computed.\n    If CAN_AUTOINC is nonnull, use it to record whether autoinc\n    addressing is likely.  */\n \n static comp_cost\n get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t\t bool address_p, bitmap *depends_on, gimple *at,\n+\t\t\t bool address_p, bitmap *inv_vars, gimple *at,\n \t\t\t bool *can_autoinc,\n \t\t\t iv_inv_expr_ent **inv_expr)\n {\n@@ -4842,8 +4844,8 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t\t? TYPE_MODE (TREE_TYPE (*use->op_p))\n \t\t\t\t: VOIDmode);\n \n-  if (depends_on)\n-    *depends_on = NULL;\n+  if (inv_vars)\n+    *inv_vars = NULL;\n \n   cbase = cand->iv->base;\n   cstep = cand->iv->step;\n@@ -4915,7 +4917,7 @@ get_computation_cost_at (struct ivopts_data *data,\n       cost = difference_cost (data,\n \t\t\t      ubase, build_int_cst (utype, 0),\n \t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      depends_on);\n+\t\t\t      inv_vars);\n       cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (ratio == 1)\n@@ -4939,7 +4941,7 @@ get_computation_cost_at (struct ivopts_data *data,\n       cost = difference_cost (data,\n \t\t\t      ubase, real_cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      depends_on);\n+\t\t\t      inv_vars);\n       cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (address_p\n@@ -4962,29 +4964,29 @@ get_computation_cost_at (struct ivopts_data *data,\n       cost = difference_cost (data,\n \t\t\t      ubase, real_cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      depends_on);\n+\t\t\t      inv_vars);\n       cost /= avg_loop_niter (data->current_loop);\n     }\n   else\n     {\n-      cost = force_var_cost (data, cbase, depends_on);\n+      cost = force_var_cost (data, cbase, inv_vars);\n       cost += difference_cost (data, ubase, build_int_cst (utype, 0),\n \t\t\t       &symbol_present, &var_present, &offset,\n-\t\t\t       depends_on);\n+\t\t\t       inv_vars);\n       cost /= avg_loop_niter (data->current_loop);\n       cost += add_cost (data->speed, TYPE_MODE (ctype));\n     }\n \n   /* Record setup cost in scratch field.  */\n   cost.scratch = cost.cost;\n \n-  if (inv_expr && depends_on && *depends_on)\n+  if (inv_expr && inv_vars && *inv_vars)\n     {\n       *inv_expr = get_loop_invariant_expr (data, ubase, cbase, ratio,\n \t\t\t\t\t   address_p);\n       /* Clear depends on.  */\n       if (*inv_expr != NULL)\n-\tbitmap_clear (*depends_on);\n+\tbitmap_clear (*inv_vars);\n     }\n \n   /* If we are after the increment, the value of the candidate is higher by\n@@ -5054,17 +5056,17 @@ get_computation_cost_at (struct ivopts_data *data,\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n    register.  A set of invariants we depend on is stored in\n-   DEPENDS_ON.  If CAN_AUTOINC is nonnull, use it to record whether\n+   INV_VARS.  If CAN_AUTOINC is nonnull, use it to record whether\n    autoinc addressing is likely.  */\n \n static comp_cost\n get_computation_cost (struct ivopts_data *data,\n \t\t      struct iv_use *use, struct iv_cand *cand,\n-\t\t      bool address_p, bitmap *depends_on,\n+\t\t      bool address_p, bitmap *inv_vars,\n \t\t      bool *can_autoinc, iv_inv_expr_ent **inv_expr)\n {\n   return get_computation_cost_at (data,\n-\t\t\t\t  use, cand, address_p, depends_on, use->stmt,\n+\t\t\t\t  use, cand, address_p, inv_vars, use->stmt,\n \t\t\t\t  can_autoinc, inv_expr);\n }\n \n@@ -5077,7 +5079,7 @@ determine_group_iv_cost_generic (struct ivopts_data *data,\n {\n   comp_cost cost;\n   iv_inv_expr_ent *inv_expr = NULL;\n-  bitmap depends_on = NULL;\n+  bitmap inv_vars = NULL, inv_exprs = NULL;\n   struct iv_use *use = group->vuses[0];\n \n   /* The simple case first -- if we need to express value of the preserved\n@@ -5088,10 +5090,15 @@ determine_group_iv_cost_generic (struct ivopts_data *data,\n     cost = no_cost;\n   else\n     cost = get_computation_cost (data, use, cand, false,\n-\t\t\t\t &depends_on, NULL, &inv_expr);\n+\t\t\t\t &inv_vars, NULL, &inv_expr);\n \n-  set_group_iv_cost (data, group, cand, cost, depends_on,\n-\t\t     NULL_TREE, ERROR_MARK, inv_expr);\n+  if (inv_expr)\n+    {\n+      inv_exprs = BITMAP_ALLOC (NULL);\n+      bitmap_set_bit (inv_exprs, inv_expr->id);\n+    }\n+  set_group_iv_cost (data, group, cand, cost, inv_vars,\n+\t\t     NULL_TREE, ERROR_MARK, inv_exprs);\n   return !cost.infinite_cost_p ();\n }\n \n@@ -5102,15 +5109,20 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n \t\t\t\t struct iv_group *group, struct iv_cand *cand)\n {\n   unsigned i;\n-  bitmap depends_on;\n+  bitmap inv_vars = NULL, inv_exprs = NULL;\n   bool can_autoinc;\n   iv_inv_expr_ent *inv_expr = NULL;\n   struct iv_use *use = group->vuses[0];\n   comp_cost sum_cost = no_cost, cost;\n \n   cost = get_computation_cost (data, use, cand, true,\n-\t\t\t       &depends_on, &can_autoinc, &inv_expr);\n+\t\t\t       &inv_vars, &can_autoinc, &inv_expr);\n \n+  if (inv_expr)\n+    {\n+      inv_exprs = BITMAP_ALLOC (NULL);\n+      bitmap_set_bit (inv_exprs, inv_expr->id);\n+    }\n   sum_cost = cost;\n   if (!sum_cost.infinite_cost_p () && cand->ainc_use == use)\n     {\n@@ -5137,8 +5149,8 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n \t\t\t\t     NULL, &can_autoinc, NULL);\n       sum_cost += cost;\n     }\n-  set_group_iv_cost (data, group, cand, sum_cost, depends_on,\n-\t\t     NULL_TREE, ERROR_MARK, inv_expr);\n+  set_group_iv_cost (data, group, cand, sum_cost, inv_vars,\n+\t\t     NULL_TREE, ERROR_MARK, inv_exprs);\n \n   return !sum_cost.infinite_cost_p ();\n }\n@@ -5556,32 +5568,33 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n {\n   tree bound = NULL_TREE;\n   struct iv *cmp_iv;\n-  bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n+  bitmap inv_exprs = NULL;\n+  bitmap inv_vars_elim = NULL, inv_vars_express = NULL, inv_vars;\n   comp_cost elim_cost, express_cost, cost, bound_cost;\n   bool ok;\n-  iv_inv_expr_ent *elim_inv_expr = NULL, *express_inv_expr = NULL, *inv_expr;\n+  iv_inv_expr_ent *inv_expr_elim = NULL, *inv_expr_express = NULL, *inv_expr;\n   tree *control_var, *bound_cst;\n   enum tree_code comp = ERROR_MARK;\n   struct iv_use *use = group->vuses[0];\n \n   /* Try iv elimination.  */\n   if (may_eliminate_iv (data, use, cand, &bound, &comp))\n     {\n-      elim_cost = force_var_cost (data, bound, &depends_on_elim);\n+      elim_cost = force_var_cost (data, bound, &inv_vars_elim);\n       if (elim_cost.cost == 0)\n \telim_cost.cost = parm_decl_cost (data, bound);\n       else if (TREE_CODE (bound) == INTEGER_CST)\n \telim_cost.cost = 0;\n       /* If we replace a loop condition 'i < n' with 'p < base + n',\n-\t depends_on_elim will have 'base' and 'n' set, which implies\n-\t that both 'base' and 'n' will be live during the loop.\t More likely,\n+\t inv_vars_elim will have 'base' and 'n' set, which implies that both\n+\t 'base' and 'n' will be live during the loop.\t More likely,\n \t 'base + n' will be loop invariant, resulting in only one live value\n-\t during the loop.  So in that case we clear depends_on_elim and set\n-\telim_inv_expr_id instead.  */\n-      if (depends_on_elim && bitmap_count_bits (depends_on_elim) > 1)\n+\t during the loop.  So in that case we clear inv_vars_elim and set\n+\t inv_expr_elim instead.  */\n+      if (inv_vars_elim && bitmap_count_bits (inv_vars_elim) > 1)\n \t{\n-\t  elim_inv_expr = record_inv_expr (data, bound);\n-\t  bitmap_clear (depends_on_elim);\n+\t  inv_expr_elim = record_inv_expr (data, bound);\n+\t  bitmap_clear (inv_vars_elim);\n \t}\n       /* The bound is a loop invariant, so it will be only computed\n \t once.  */\n@@ -5609,10 +5622,10 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n     elim_cost -= 1;\n \n   express_cost = get_computation_cost (data, use, cand, false,\n-\t\t\t\t       &depends_on_express, NULL,\n-\t\t\t\t       &express_inv_expr);\n+\t\t\t\t       &inv_vars_express, NULL,\n+\t\t\t\t       &inv_expr_express);\n   fd_ivopts_data = data;\n-  walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n+  walk_tree (&cmp_iv->base, find_depends, &inv_vars_express, NULL);\n \n   /* Count the cost of the original bound as well.  */\n   bound_cost = force_var_cost (data, *bound_cst, NULL);\n@@ -5626,27 +5639,32 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n   if (elim_cost <= express_cost)\n     {\n       cost = elim_cost;\n-      depends_on = depends_on_elim;\n-      depends_on_elim = NULL;\n-      inv_expr = elim_inv_expr;\n+      inv_vars = inv_vars_elim;\n+      inv_vars_elim = NULL;\n+      inv_expr = inv_expr_elim;\n     }\n   else\n     {\n       cost = express_cost;\n-      depends_on = depends_on_express;\n-      depends_on_express = NULL;\n+      inv_vars = inv_vars_express;\n+      inv_vars_express = NULL;\n       bound = NULL_TREE;\n       comp = ERROR_MARK;\n-      inv_expr = express_inv_expr;\n+      inv_expr = inv_expr_express;\n     }\n \n+  if (inv_expr)\n+    {\n+      inv_exprs = BITMAP_ALLOC (NULL);\n+      bitmap_set_bit (inv_exprs, inv_expr->id);\n+    }\n   set_group_iv_cost (data, group, cand, cost,\n-\t\t     depends_on, bound, comp, inv_expr);\n+\t\t     inv_vars, bound, comp, inv_exprs);\n \n-  if (depends_on_elim)\n-    BITMAP_FREE (depends_on_elim);\n-  if (depends_on_express)\n-    BITMAP_FREE (depends_on_express);\n+  if (inv_vars_elim)\n+    BITMAP_FREE (inv_vars_elim);\n+  if (inv_vars_express)\n+    BITMAP_FREE (inv_vars_express);\n \n   return !cost.infinite_cost_p ();\n }\n@@ -5681,17 +5699,17 @@ static bool\n autoinc_possible_for_pair (struct ivopts_data *data, struct iv_use *use,\n \t\t\t   struct iv_cand *cand)\n {\n-  bitmap depends_on;\n+  bitmap inv_vars;\n   bool can_autoinc;\n   comp_cost cost;\n \n   if (use->type != USE_ADDRESS)\n     return false;\n \n-  cost = get_computation_cost (data, use, cand, true, &depends_on,\n+  cost = get_computation_cost (data, use, cand, true, &inv_vars,\n \t\t\t       &can_autoinc, NULL);\n \n-  BITMAP_FREE (depends_on);\n+  BITMAP_FREE (inv_vars);\n \n   return !cost.infinite_cost_p () && can_autoinc;\n }\n@@ -5843,7 +5861,7 @@ determine_group_iv_costs (struct ivopts_data *data)\n \n       for (i = 0; i < list.length (); ++i)\n \t{\n-\t  fprintf (dump_file, \"inv_expr %d: \\t\", i);\n+\t  fprintf (dump_file, \"inv_expr %d: \\t\", list[i]->id);\n \t  print_generic_expr (dump_file, list[i]->expr, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n@@ -5855,7 +5873,7 @@ determine_group_iv_costs (struct ivopts_data *data)\n \t  group = data->vgroups[i];\n \n \t  fprintf (dump_file, \"Group %d:\\n\", i);\n-\t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tinv.ex.\\tdepends on\\n\");\n+\t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tinv.expr.\\tinv.vars\\n\");\n \t  for (j = 0; j < group->n_map_members; j++)\n \t    {\n \t      if (!group->cost_map[j].cand\n@@ -5866,15 +5884,18 @@ determine_group_iv_costs (struct ivopts_data *data)\n \t\t       group->cost_map[j].cand->id,\n \t\t       group->cost_map[j].cost.cost,\n \t\t       group->cost_map[j].cost.complexity);\n-\t      if (group->cost_map[j].inv_expr != NULL)\n-\t\tfprintf (dump_file, \"%d\\t\",\n-\t\t\t group->cost_map[j].inv_expr->id);\n+\t      if (!group->cost_map[j].inv_exprs\n+\t\t  || bitmap_empty_p (group->cost_map[j].inv_exprs))\n+\t\tfprintf (dump_file, \"NIL;\\t\");\n \t      else\n-\t\tfprintf (dump_file, \"\\t\");\n-\t      if (group->cost_map[j].depends_on)\n \t\tbitmap_print (dump_file,\n-\t\t\t      group->cost_map[j].depends_on, \"\",\"\");\n-\t      fprintf (dump_file, \"\\n\");\n+\t\t\t      group->cost_map[j].inv_exprs, \"\", \";\\t\");\n+\t      if (!group->cost_map[j].inv_vars\n+\t\t  || bitmap_empty_p (group->cost_map[j].inv_vars))\n+\t\tfprintf (dump_file, \"NIL;\\n\");\n+\t      else\n+\t\tbitmap_print (dump_file,\n+\t\t\t      group->cost_map[j].inv_vars, \"\", \"\\n\");\n \t    }\n \n \t  fprintf (dump_file, \"\\n\");\n@@ -6066,28 +6087,28 @@ iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n \n   cost += ivs->cand_cost;\n \n-  cost += ivopts_global_cost_for_size (data,\n-\t\t\t\t       ivs->n_regs\n-\t\t\t\t       + ivs->used_inv_exprs->elements ());\n+  cost += ivopts_global_cost_for_size (data, ivs->n_regs);\n \n   ivs->cost = cost;\n }\n \n-/* Remove invariants in set INVS to set IVS.  */\n+/* Remove use of invariants in set INVS by decreasing counter in N_INV_USES\n+   and IVS.  */\n \n static void\n-iv_ca_set_remove_invariants (struct iv_ca *ivs, bitmap invs)\n+iv_ca_set_remove_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n {\n   bitmap_iterator bi;\n   unsigned iid;\n \n   if (!invs)\n     return;\n \n+  gcc_assert (n_inv_uses != NULL);\n   EXECUTE_IF_SET_IN_BITMAP (invs, 0, iid, bi)\n     {\n-      ivs->n_invariant_uses[iid]--;\n-      if (ivs->n_invariant_uses[iid] == 0)\n+      n_inv_uses[iid]--;\n+      if (n_inv_uses[iid] == 0)\n \tivs->n_regs--;\n     }\n }\n@@ -6117,38 +6138,32 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n       ivs->n_cands--;\n       ivs->cand_cost -= cp->cand->cost;\n \n-      iv_ca_set_remove_invariants (ivs, cp->cand->depends_on);\n+      iv_ca_set_remove_invs (ivs, cp->cand->inv_vars, ivs->n_inv_var_uses);\n     }\n \n   ivs->cand_use_cost -= cp->cost;\n-\n-  iv_ca_set_remove_invariants (ivs, cp->depends_on);\n-\n-  if (cp->inv_expr != NULL)\n-    {\n-      unsigned *slot = ivs->used_inv_exprs->get (cp->inv_expr);\n-      --(*slot);\n-      if (*slot == 0)\n-\tivs->used_inv_exprs->remove (cp->inv_expr);\n-    }\n+  iv_ca_set_remove_invs (ivs, cp->inv_vars, ivs->n_inv_var_uses);\n+  iv_ca_set_remove_invs (ivs, cp->inv_exprs, ivs->n_inv_expr_uses);\n   iv_ca_recount_cost (data, ivs);\n }\n \n-/* Add invariants in set INVS to set IVS.  */\n+/* Add use of invariants in set INVS by increasing counter in N_INV_USES and\n+   IVS.  */\n \n static void\n-iv_ca_set_add_invariants (struct iv_ca *ivs, bitmap invs)\n+iv_ca_set_add_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n {\n   bitmap_iterator bi;\n   unsigned iid;\n \n   if (!invs)\n     return;\n \n+  gcc_assert (n_inv_uses != NULL);\n   EXECUTE_IF_SET_IN_BITMAP (invs, 0, iid, bi)\n     {\n-      ivs->n_invariant_uses[iid]++;\n-      if (ivs->n_invariant_uses[iid] == 1)\n+      n_inv_uses[iid]++;\n+      if (n_inv_uses[iid] == 1)\n \tivs->n_regs++;\n     }\n }\n@@ -6181,17 +6196,12 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n \t  ivs->n_cands++;\n \t  ivs->cand_cost += cp->cand->cost;\n \n-\t  iv_ca_set_add_invariants (ivs, cp->cand->depends_on);\n+\t  iv_ca_set_add_invs (ivs, cp->cand->inv_vars, ivs->n_inv_var_uses);\n \t}\n \n       ivs->cand_use_cost += cp->cost;\n-      iv_ca_set_add_invariants (ivs, cp->depends_on);\n-\n-      if (cp->inv_expr != NULL)\n-\t{\n-\t  unsigned *slot = &ivs->used_inv_exprs->get_or_insert (cp->inv_expr);\n-\t  ++(*slot);\n-\t}\n+      iv_ca_set_add_invs (ivs, cp->inv_vars, ivs->n_inv_var_uses);\n+      iv_ca_set_add_invs (ivs, cp->inv_exprs, ivs->n_inv_expr_uses);\n       iv_ca_recount_cost (data, ivs);\n     }\n }\n@@ -6256,14 +6266,15 @@ iv_ca_has_deps (struct iv_ca *ivs, struct cost_pair *cp)\n   unsigned i;\n   bitmap_iterator bi;\n \n-  if (!cp->depends_on)\n-    return true;\n+  if (cp->inv_vars)\n+    EXECUTE_IF_SET_IN_BITMAP (cp->inv_vars, 0, i, bi)\n+      if (ivs->n_inv_var_uses[i] == 0)\n+\treturn false;\n \n-  EXECUTE_IF_SET_IN_BITMAP (cp->depends_on, 0, i, bi)\n-    {\n-      if (ivs->n_invariant_uses[i] == 0)\n+  if (cp->inv_exprs)\n+    EXECUTE_IF_SET_IN_BITMAP (cp->inv_exprs, 0, i, bi)\n+      if (ivs->n_inv_expr_uses[i] == 0)\n \treturn false;\n-    }\n \n   return true;\n }\n@@ -6399,8 +6410,8 @@ iv_ca_new (struct ivopts_data *data)\n   nw->n_regs = 0;\n   nw->cand_use_cost = no_cost;\n   nw->cand_cost = 0;\n-  nw->n_invariant_uses = XCNEWVEC (unsigned, data->max_inv_id + 1);\n-  nw->used_inv_exprs = new hash_map <iv_inv_expr_ent *, unsigned> (13);\n+  nw->n_inv_var_uses = XCNEWVEC (unsigned, data->max_inv_var_id + 1);\n+  nw->n_inv_expr_uses = XCNEWVEC (unsigned, data->max_inv_expr_id + 1);\n   nw->cost = no_cost;\n \n   return nw;\n@@ -6414,8 +6425,8 @@ iv_ca_free (struct iv_ca **ivs)\n   free ((*ivs)->cand_for_group);\n   free ((*ivs)->n_cand_uses);\n   BITMAP_FREE ((*ivs)->cands);\n-  free ((*ivs)->n_invariant_uses);\n-  delete ((*ivs)->used_inv_exprs);\n+  free ((*ivs)->n_inv_var_uses);\n+  free ((*ivs)->n_inv_expr_uses);\n   free (*ivs);\n   *ivs = NULL;\n }\n@@ -6449,21 +6460,21 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n \n   const char *pref = \"\";\n   fprintf (file, \"  invariant variables: \");\n-  for (i = 1; i <= data->max_inv_id; i++)\n-    if (ivs->n_invariant_uses[i])\n+  for (i = 1; i <= data->max_inv_var_id; i++)\n+    if (ivs->n_inv_var_uses[i])\n       {\n \tfprintf (file, \"%s%d\", pref, i);\n \tpref = \", \";\n       }\n \n   pref = \"\";\n   fprintf (file, \"\\n  invariant expressions: \");\n-  for (hash_map<iv_inv_expr_ent *, unsigned>::iterator it\n-       = ivs->used_inv_exprs->begin (); it != ivs->used_inv_exprs->end (); ++it)\n-    {\n-\tfprintf (file, \"%s%d\", pref, (*it).first->id);\n+  for (i = 1; i <= data->max_inv_expr_id; i++)\n+    if (ivs->n_inv_expr_uses[i])\n+      {\n+\tfprintf (file, \"%s%d\", pref, i);\n \tpref = \", \";\n-    }\n+      }\n \n   fprintf (file, \"\\n\\n\");\n }\n@@ -7127,8 +7138,6 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n \t\t LOCATION_LINE (data->loop_loc));\n       fprintf (dump_file, \", \" HOST_WIDE_INT_PRINT_DEC \" avg niters\",\n \t       avg_loop_niter (data->current_loop));\n-      fprintf (dump_file, \", \" HOST_WIDE_INT_PRINT_UNSIGNED \" expressions\",\n-\t       (unsigned HOST_WIDE_INT) set->used_inv_exprs->elements ());\n       fprintf (dump_file, \", %lu IVs:\\n\", bitmap_count_bits (set->cands));\n       EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n \t{\n@@ -7657,8 +7666,12 @@ free_loop_data (struct ivopts_data *data)\n \n       BITMAP_FREE (group->related_cands);\n       for (j = 0; j < group->n_map_members; j++)\n-\tif (group->cost_map[j].depends_on)\n-\t  BITMAP_FREE (group->cost_map[j].depends_on);\n+\t{\n+\t  if (group->cost_map[j].inv_vars)\n+\t    BITMAP_FREE (group->cost_map[j].inv_vars);\n+\t  if (group->cost_map[j].inv_exprs)\n+\t    BITMAP_FREE (group->cost_map[j].inv_exprs);\n+\t}\n \n       free (group->cost_map);\n       free (group);\n@@ -7669,8 +7682,8 @@ free_loop_data (struct ivopts_data *data)\n     {\n       struct iv_cand *cand = data->vcands[i];\n \n-      if (cand->depends_on)\n-\tBITMAP_FREE (cand->depends_on);\n+      if (cand->inv_vars)\n+\tBITMAP_FREE (cand->inv_vars);\n       free (cand);\n     }\n   data->vcands.truncate (0);\n@@ -7682,15 +7695,15 @@ free_loop_data (struct ivopts_data *data)\n       data->version_info = XCNEWVEC (struct version_info, data->version_info_size);\n     }\n \n-  data->max_inv_id = 0;\n+  data->max_inv_var_id = 0;\n+  data->max_inv_expr_id = 0;\n \n   FOR_EACH_VEC_ELT (decl_rtl_to_reset, i, obj)\n     SET_DECL_RTL (obj, NULL_RTX);\n \n   decl_rtl_to_reset.truncate (0);\n \n   data->inv_expr_tab->empty ();\n-  data->max_inv_expr_id = 0;\n \n   data->iv_common_cand_tab->empty ();\n   data->iv_common_cands.truncate (0);"}]}