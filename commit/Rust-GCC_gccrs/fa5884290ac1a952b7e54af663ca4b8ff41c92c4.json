{"sha": "fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1ODg0MjkwYWMxYTk1MmI3ZTU0YWY2NjNjYTRiOGZmNDFjOTJjNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-04T23:54:26Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2005-01-04T23:54:26Z"}, "message": "re PR tree-optimization/19158 (GNAT Bug Box compiling makegpr.adb of the GNAT tools)\n\n2005-01-04 Richard Henderson  <rth@redhat.com>\n\n        PR tree-opt/19158\n        * tree-sra.c (generate_one_element_init): Just\n        call gimplify_and_add.\n        (generate_element_init): Record the\n        new referenced variables and mark them for renaming\n        and split out to ...\n        (generate_element_init_1): This.\n        (scalarize_init): Don't call push_gimplify_context/\n        pop_gimplify_context.\n\nFrom-SVN: r92911", "tree": {"sha": "9965a02c3bb705b1a9ca72eef402a358018367b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9965a02c3bb705b1a9ca72eef402a358018367b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5884290ac1a952b7e54af663ca4b8ff41c92c4/comments", "author": null, "committer": null, "parents": [{"sha": "5f0c48ed9303fcc31955d4c11c2a26fa157ec3de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0c48ed9303fcc31955d4c11c2a26fa157ec3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0c48ed9303fcc31955d4c11c2a26fa157ec3de"}], "stats": {"total": 71, "additions": 49, "deletions": 22}, "files": [{"sha": "0c21f445439ca57259fa74cabb204d4206101ee9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5884290ac1a952b7e54af663ca4b8ff41c92c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5884290ac1a952b7e54af663ca4b8ff41c92c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "patch": "@@ -1,3 +1,15 @@\n+2005-01-04 Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/19158\n+\t* tree-sra.c (generate_one_element_init): Just\n+\tcall gimplify_and_add.\n+\t(generate_element_init): Record the\n+\tnew referenced variables and mark them for renaming\n+\tand split out to ...\n+\t(generate_element_init_1): This.\n+\t(scalarize_init): Don't call push_gimplify_context/\n+\tpop_gimplify_context.\n+\n 2005-01-04  Geoffrey Keating  <geoffk@apple.com>\n \n \t* toplev.c (get_src_pwd): Handle failure of getpwd()."}, {"sha": "1ac0ec0a0aeb4fe967f7a53c93789352ee655996", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5884290ac1a952b7e54af663ca4b8ff41c92c4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5884290ac1a952b7e54af663ca4b8ff41c92c4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fa5884290ac1a952b7e54af663ca4b8ff41c92c4", "patch": "@@ -1,7 +1,7 @@\n /* Scalar Replacement of Aggregates (SRA) converts some structure\n    references into scalar references, exposing them to the scalar\n    optimizers.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -1569,23 +1569,9 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n static void\n generate_one_element_init (tree var, tree init, tree *list_p)\n {\n-  tree stmt;\n-\n   /* The replacement can be almost arbitrarily complex.  Gimplify.  */\n-  stmt = build (MODIFY_EXPR, void_type_node, var, init);\n-  gimplify_stmt (&stmt);\n-\n-  /* The replacement can expose previously unreferenced variables.  */\n-  if (TREE_CODE (stmt) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator i;\n-      for (i = tsi_start (stmt); !tsi_end_p (i); tsi_next (&i))\n-\tfind_new_referenced_vars (tsi_stmt_ptr (i));\n-    }\n-  else\n-    find_new_referenced_vars (&stmt);\n-\n-  append_to_statement_list (stmt, list_p);\n+  tree stmt = build (MODIFY_EXPR, void_type_node, var, init);\n+  gimplify_and_add (stmt, list_p);\n }\n \n /* Generate a set of assignment statements in *LIST_P to set all instantiated\n@@ -1595,7 +1581,7 @@ generate_one_element_init (tree var, tree init, tree *list_p)\n    handle.  */\n \n static bool\n-generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n+generate_element_init_1 (struct sra_elt *elt, tree init, tree *list_p)\n {\n   bool result = true;\n   enum tree_code init_code;\n@@ -1629,7 +1615,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \t  else\n \t    t = (init_code == COMPLEX_EXPR\n \t\t ? TREE_OPERAND (init, 1) : TREE_IMAGPART (init));\n-\t  result &= generate_element_init (sub, t, list_p);\n+\t  result &= generate_element_init_1 (sub, t, list_p);\n \t}\n       break;\n \n@@ -1639,7 +1625,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \t  sub = lookup_element (elt, TREE_PURPOSE (t), NULL, NO_INSERT);\n \t  if (sub == NULL)\n \t    continue;\n-\t  result &= generate_element_init (sub, TREE_VALUE (t), list_p);\n+\t  result &= generate_element_init_1 (sub, TREE_VALUE (t), list_p);\n \t}\n       break;\n \n@@ -1651,6 +1637,37 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n   return result;\n }\n \n+/* A wrapper function for generate_element_init_1 that handles cleanup after\n+   gimplification.  */\n+\n+static bool\n+generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n+{\n+  bool ret;\n+\n+  push_gimplify_context ();\n+  ret = generate_element_init_1 (elt, init, list_p);\n+  pop_gimplify_context (NULL);\n+\n+  /* The replacement can expose previously unreferenced variables.  */\n+  if (ret && *list_p)\n+    {\n+      tree_stmt_iterator i;\n+      size_t old, new, j;\n+\n+      old = num_referenced_vars;\n+\n+      for (i = tsi_start (*list_p); !tsi_end_p (i); tsi_next (&i))\n+\tfind_new_referenced_vars (tsi_stmt_ptr (i));\n+\n+      new = num_referenced_vars;\n+      for (j = old; j < new; ++j)\n+\tbitmap_set_bit (vars_to_rename, j);\n+    }\n+\n+  return ret;\n+}\n+\n /* Insert STMT on all the outgoing edges out of BB.  Note that if BB\n    has more than one edge, STMT will be replicated for each edge.  Also,\n    abnormal edges will be ignored.  */\n@@ -1846,9 +1863,7 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n     {\n       /* Unshare the expression just in case this is from a decl's initial.  */\n       rhs = unshare_expr (rhs);\n-      push_gimplify_context ();\n       result = generate_element_init (lhs_elt, rhs, &list);\n-      pop_gimplify_context (NULL);\n     }\n \n   /* CONSTRUCTOR is defined such that any member not mentioned is assigned"}]}