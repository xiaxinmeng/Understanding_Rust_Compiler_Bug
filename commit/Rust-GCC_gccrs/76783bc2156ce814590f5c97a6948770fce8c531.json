{"sha": "76783bc2156ce814590f5c97a6948770fce8c531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY3ODNiYzIxNTZjZTgxNDU5MGY1Yzk3YTY5NDg3NzBmY2U4YzUzMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-04-12T07:51:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-04-12T07:51:18Z"}, "message": "profile.c (compute_branch_probabilities): Remove code encapsulated in !ir_type ()...\n\n2006-04-12  Richard Guenther  <rguenther@suse.de>\n\n\t* profile.c (compute_branch_probabilities): Remove code\n\tencapsulated in !ir_type (), which are remanents of the\n\tremoved RTL profiling code.\n\t* rtl-profile.c: Remove.\n\nFrom-SVN: r112884", "tree": {"sha": "80ae1d904e6b818aa1efcec96d149c538d27c7dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80ae1d904e6b818aa1efcec96d149c538d27c7dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76783bc2156ce814590f5c97a6948770fce8c531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76783bc2156ce814590f5c97a6948770fce8c531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76783bc2156ce814590f5c97a6948770fce8c531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76783bc2156ce814590f5c97a6948770fce8c531/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8eff378c612e592a3cc9e161e382c57e105be6f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eff378c612e592a3cc9e161e382c57e105be6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eff378c612e592a3cc9e161e382c57e105be6f5"}], "stats": {"total": 557, "additions": 45, "deletions": 512}, "files": [{"sha": "96027f892f022215ac712569170e7e368248e717", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76783bc2156ce814590f5c97a6948770fce8c531/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76783bc2156ce814590f5c97a6948770fce8c531/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76783bc2156ce814590f5c97a6948770fce8c531", "patch": "@@ -1,3 +1,10 @@\n+2006-04-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* profile.c (compute_branch_probabilities): Remove code\n+\tencapsulated in !ir_type (), which are remanents of the\n+\tremoved RTL profiling code.\n+\t* rtl-profile.c: Remove.\n+\n 2006-04-12  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Update"}, {"sha": "4e2213a6e2d992844f1f9553ac4fa875b2ba02de", "filename": "gcc/profile.c", "status": "modified", "additions": 38, "deletions": 142, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76783bc2156ce814590f5c97a6948770fce8c531/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76783bc2156ce814590f5c97a6948770fce8c531/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=76783bc2156ce814590f5c97a6948770fce8c531", "patch": "@@ -490,7 +490,6 @@ compute_branch_probabilities (void)\n     {\n       edge e;\n       edge_iterator ei;\n-      rtx note;\n \n       if (bb->count < 0)\n \t{\n@@ -546,37 +545,9 @@ compute_branch_probabilities (void)\n \t\tindex = 19;\n \t      hist_br_prob[index]++;\n \n-\t      /* Do this for RTL only.  */\n-\t      if (!ir_type ())\n-\t\t{\n-\t\t  note = find_reg_note (BB_END (bb), REG_BR_PROB, 0);\n-\t\t  /* There may be already note put by some other pass, such\n-\t\t     as builtin_expect expander.  */\n-\t\t  if (note)\n-\t\t    XEXP (note, 0) = GEN_INT (prob);\n-\t\t  else\n-\t\t    REG_NOTES (BB_END (bb))\n-\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t\t   REG_NOTES (BB_END (bb)));\n-\t\t}\n \t      num_branches++;\n \t    }\n \t}\n-      /* Otherwise try to preserve the existing REG_BR_PROB probabilities\n-         tree based profile guessing put into code.  BB can be the\n-\t ENTRY_BLOCK, and it can have multiple (fake) successors in\n-\t EH cases, but it still has no code; don't crash in this case.  */\n-      else if (profile_status == PROFILE_ABSENT\n-\t       && !ir_type ()\n-\t       && EDGE_COUNT (bb->succs) > 1\n-\t       && BB_END (bb)\n-\t       && (note = find_reg_note (BB_END (bb), REG_BR_PROB, 0)))\n-\t{\n-\t  int prob = INTVAL (XEXP (note, 0));\n-\n-\t  BRANCH_EDGE (bb)->probability = prob;\n-\t  FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - prob;\n-\t}\n       /* As a last resort, distribute the probabilities evenly.\n \t Use simple heuristics that if there are normal edges,\n \t give all abnormals frequency of 0, otherwise distribute the\n@@ -972,8 +943,7 @@ branch_prob (void)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \t\t  /* On trees we don't have fallthru flags, but we can\n \t\t     recompute them from CFG shape.  */\n-\t\t  if (ir_type ()\n-\t\t      && e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)\n+\t\t  if (e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)\n \t\t      && e->src->next_bb == e->dest)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \n@@ -989,116 +959,57 @@ branch_prob (void)\n   /* Line numbers.  */\n   if (coverage_begin_output ())\n     {\n+      gcov_position_t offset;\n+\n       /* Initialize the output.  */\n       output_location (NULL, 0, NULL, NULL);\n \n-      if (!ir_type ())\n+      FOR_EACH_BB (bb)\n \t{\n-\t  gcov_position_t offset;\n-\n-\t  FOR_EACH_BB (bb)\n-\t    {\n-\t      rtx insn = BB_HEAD (bb);\n-\t      int ignore_next_note = 0;\n-\n-\t      offset = 0;\n-\n-\t      /* We are looking for line number notes.  Search backward\n-\t\t before basic block to find correct ones.  */\n-\t      insn = prev_nonnote_insn (insn);\n-\t      if (!insn)\n-\t\tinsn = get_insns ();\n-\t      else\n-\t\tinsn = NEXT_INSN (insn);\n+\t  block_stmt_iterator bsi;\n \n-\t      while (insn != BB_END (bb))\n-\t\t{\n-\t\t  if (NOTE_P (insn))\n-\t\t    {\n-\t\t      /* Must ignore the line number notes that\n-\t\t\t immediately follow the end of an inline function\n-\t\t\t to avoid counting it twice.  There is a note\n-\t\t\t before the call, and one after the call.  */\n-\t\t      if (NOTE_LINE_NUMBER (insn)\n-\t\t\t  == NOTE_INSN_REPEATED_LINE_NUMBER)\n-\t\t\tignore_next_note = 1;\n-\t\t      else if (NOTE_LINE_NUMBER (insn) <= 0)\n-\t\t\t/*NOP*/;\n-\t\t      else if (ignore_next_note)\n-\t\t\tignore_next_note = 0;\n-\t\t      else\n-\t\t\t{\n-\t\t          expanded_location s;\n-\t\t          NOTE_EXPANDED_LOCATION (s, insn);\n-\t\t\t  output_location (s.file, s.line, &offset, bb);\n-\t\t\t}\n-\t\t    }\n-\t\t  insn = NEXT_INSN (insn);\n-\t\t}\n+\t  offset = 0;\n \n-\t      if (offset)\n-\t\t{\n-\t\t  /* A file of NULL indicates the end of run.  */\n-\t\t  gcov_write_unsigned (0);\n-\t\t  gcov_write_string (NULL);\n-\t\t  gcov_write_length (offset);\n-\t\t}\n+\t  if (bb == ENTRY_BLOCK_PTR->next_bb)\n+\t    {\n+\t      expanded_location curr_location = \n+\t\texpand_location (DECL_SOURCE_LOCATION (current_function_decl));\n+\t      output_location (curr_location.file, curr_location.line,\n+\t\t\t       &offset, bb);\n \t    }\n-\t}\n-      else\n-\t{\n-\t  gcov_position_t offset;\n \n-\t  FOR_EACH_BB (bb)\n+\t  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t    {\n-\t      block_stmt_iterator bsi;\n-\n-\t      offset = 0;\n-\n-\t      if (bb == ENTRY_BLOCK_PTR->next_bb)\n-\t\t{\n-\t\t  expanded_location curr_location = \n-\t\t    expand_location (DECL_SOURCE_LOCATION\n-\t\t\t\t     (current_function_decl));\n-\t\t  output_location (curr_location.file, curr_location.line,\n-\t\t\t\t   &offset, bb);\n-\t\t}\n-\n-\t      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t\t{\n-\t\t  tree stmt = bsi_stmt (bsi);\n-\t\t  if (EXPR_HAS_LOCATION (stmt))\n-\t\t    output_location (EXPR_FILENAME (stmt), \n-\t\t\t\t     EXPR_LINENO (stmt),\n-\t\t\t\t     &offset, bb);\n-\t\t}\n+\t      tree stmt = bsi_stmt (bsi);\n+\t      if (EXPR_HAS_LOCATION (stmt))\n+\t\toutput_location (EXPR_FILENAME (stmt), EXPR_LINENO (stmt),\n+\t\t\t\t &offset, bb);\n+\t    }\n \n-\t      /* Notice GOTO expressions we eliminated while constructing the\n-\t\t CFG.  */\n-\t      if (single_succ_p (bb) && single_succ_edge (bb)->goto_locus)\n-\t\t{\n-\t\t  /* ??? source_locus type is marked deprecated in input.h.  */\n-\t\t  source_locus curr_location = single_succ_edge (bb)->goto_locus;\n-\t\t  /* ??? The FILE/LINE API is inconsistent for these cases.  */\n+\t  /* Notice GOTO expressions we eliminated while constructing the\n+\t     CFG.  */\n+\t  if (single_succ_p (bb) && single_succ_edge (bb)->goto_locus)\n+\t    {\n+\t      /* ??? source_locus type is marked deprecated in input.h.  */\n+\t      source_locus curr_location = single_succ_edge (bb)->goto_locus;\n+\t      /* ??? The FILE/LINE API is inconsistent for these cases.  */\n #ifdef USE_MAPPED_LOCATION \n-\t\t  output_location (LOCATION_FILE (curr_location),\n-\t\t\t\t   LOCATION_LINE (curr_location),\n-\t\t\t\t   &offset, bb);\n+\t      output_location (LOCATION_FILE (curr_location),\n+\t\t\t       LOCATION_LINE (curr_location), &offset, bb);\n #else\n-\t\t  output_location (curr_location->file, curr_location->line,\n-\t\t\t\t   &offset, bb);\n+\t      output_location (curr_location->file, curr_location->line,\n+\t\t\t       &offset, bb);\n #endif\n-\t\t}\n+\t    }\n \n-\t      if (offset)\n-\t\t{\n-\t\t  /* A file of NULL indicates the end of run.  */\n-\t\t  gcov_write_unsigned (0);\n-\t\t  gcov_write_string (NULL);\n-\t\t  gcov_write_length (offset);\n-\t\t}\n+\t  if (offset)\n+\t    {\n+\t      /* A file of NULL indicates the end of run.  */\n+\t      gcov_write_unsigned (0);\n+\t      gcov_write_string (NULL);\n+\t      gcov_write_length (offset);\n \t    }\n-\t }\n+\t}\n     }\n \n   ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n@@ -1133,26 +1044,11 @@ branch_prob (void)\n \tinstrument_values (values);\n \n       /* Commit changes done by instrumentation.  */\n-      if (ir_type ())\n-\tbsi_commit_edge_inserts ();\n-      else\n-\t{\n-          commit_edge_insertions_watch_calls ();\n-\t  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-\t}\n+      bsi_commit_edge_inserts ();\n     }\n \n   free_aux_for_edges ();\n \n-  if (!ir_type ())\n-    {\n-      /* Re-merge split basic blocks and the mess introduced by\n-\t insert_insn_on_edge.  */\n-      cleanup_cfg (profile_arc_flag ? CLEANUP_EXPENSIVE : 0);\n-      if (dump_file)\n-\tdump_flow_info (dump_file, dump_flags);\n-    }\n-\n   free_edge_list (el);\n   if (flag_branch_probabilities)\n     profile_status = PROFILE_READ;"}, {"sha": "0da5ddd5fed804a87850bfe9b4b3bccf44ef7325", "filename": "gcc/rtl-profile.c", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -1,370 +0,0 @@\n-/* Calculate branch probabilities, and basic block execution counts.\n-   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n-   Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n-   based on some ideas from Dain Samples of UC Berkeley.\n-   Further mangling by Bob Manson, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301, USA.  */\n-\n-/* Generate basic block profile instrumentation and auxiliary files.\n-   RTL-based version.  See profile.c for overview.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"flags.h\"\n-#include \"output.h\"\n-#include \"regs.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n-#include \"toplev.h\"\n-#include \"coverage.h\"\n-#include \"value-prof.h\"\n-#include \"tree.h\"\n-#include \"ggc.h\"\n-\n-/* Do initialization work for the edge profiler.  */\n-\n-static void\n-rtl_init_edge_profiler (void)\n-{\n-  /* gen_edge_profiler calls safe_insert_insn_on_edge which needs\n-     register liveness data to be available.  */\n-  life_analysis (NULL, 0);\n-}\n-\n-/* Output instructions as RTL to increment the edge execution count.  */\n-\n-static void\n-rtl_gen_edge_profiler (int edgeno, edge e)\n-{\n-  rtx ref = rtl_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n-  rtx tmp;\n-  enum machine_mode mode = GET_MODE (ref);\n-  rtx sequence;\n-\n-  start_sequence ();\n-  ref = validize_mem (ref);\n-\n-  tmp = expand_simple_binop (mode, PLUS, ref, const1_rtx,\n-\t\t\t     ref, 0, OPTAB_WIDEN);\n-\n-  if (tmp != ref)\n-    emit_move_insn (copy_rtx (ref), tmp);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  safe_insert_insn_on_edge (sequence, e);\n-  rebuild_jump_labels (e->insns.r);\n-}\n-\n-/* Output instructions as RTL to increment the interval histogram counter.\n-   VALUE is the expression whose value is profiled.  TAG is the tag of the\n-   section for counters, BASE is offset of the counter position.  */\n-\n-static void\n-rtl_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n-{\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx mem_ref, tmp, tmp1, mr, val;\n-  rtx sequence;\n-  rtx more_label = gen_label_rtx ();\n-  rtx less_label = gen_label_rtx ();\n-  rtx end_of_code_label = gen_label_rtx ();\n-  int per_counter = GCOV_TYPE_SIZE / BITS_PER_UNIT;\n-  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n-\t\t   PREV_INSN (value->hvalue.rtl.insn));\n-\n-  start_sequence ();\n-\n-  if (value->hvalue.rtl.seq)\n-    emit_insn (value->hvalue.rtl.seq);\n-\n-  mr = gen_reg_rtx (Pmode);\n-\n-  tmp = rtl_coverage_counter_ref (tag, base);\n-  tmp = force_reg (Pmode, XEXP (tmp, 0));\n-\n-  val = expand_simple_binop (value->hvalue.rtl.mode, MINUS,\n-\t\t\t     copy_rtx (value->hvalue.rtl.value),\n-\t\t\t     GEN_INT (value->hdata.intvl.int_start),\n-\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n-\n-    do_compare_rtx_and_jump (copy_rtx (val), GEN_INT (value->hdata.intvl.steps),\n-\t\t\t   GE, 0, value->hvalue.rtl.mode, NULL_RTX, NULL_RTX, \n-\t\t\t   more_label);\n-  do_compare_rtx_and_jump (copy_rtx (val), const0_rtx, LT, 0, \n-\t\t\t   value->hvalue.rtl.mode,\n-\t\t\t     NULL_RTX, NULL_RTX, less_label);\n-\n-  /* We are in range.  */\n-  tmp1 = expand_simple_binop (value->hvalue.rtl.mode, MULT,\n-\t\t\t      copy_rtx (val), GEN_INT (per_counter),\n-\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n-  tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp), tmp1, mr,\n-\t\t\t      0, OPTAB_WIDEN);\n-  if (tmp1 != mr)\n-    emit_move_insn (copy_rtx (mr), tmp1);\n-\n-      emit_jump_insn (gen_jump (end_of_code_label));\n-      emit_barrier ();\n-\n-  /* Above the interval.  */\n-      emit_label (more_label);\n-      tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n-\t\t\t\t  GEN_INT (per_counter * value->hdata.intvl.steps),\n-\t\t\t\t  mr, 0, OPTAB_WIDEN);\n-      if (tmp1 != mr)\n-\temit_move_insn (copy_rtx (mr), tmp1);\n-\t  emit_jump_insn (gen_jump (end_of_code_label));\n-\t  emit_barrier ();\n-\n-  /* Below the interval.  */\n-      emit_label (less_label);\n-      tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n-\t\t\tGEN_INT (per_counter * (value->hdata.intvl.steps +1)),\n-\t\tmr, 0, OPTAB_WIDEN);\n-      if (tmp1 != mr)\n-\temit_move_insn (copy_rtx (mr), tmp1);\n-\n-    emit_label (end_of_code_label);\n-\n-  mem_ref = validize_mem (gen_rtx_MEM (mode, mr));\n-\n-  tmp = expand_simple_binop (mode, PLUS, copy_rtx (mem_ref), const1_rtx,\n-\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n-\n-  if (tmp != mem_ref)\n-    emit_move_insn (copy_rtx (mem_ref), tmp);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  safe_insert_insn_on_edge (sequence, e);\n-}\n-\n-/* Output instructions as RTL to increment the power of two histogram counter.\n-   VALUE is the expression whose value is profiled.  TAG is the tag of the\n-   section for counters, BASE is offset of the counter position.  */\n-\n-static void\n-rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n-{\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx mem_ref, tmp, mr, uval;\n-  rtx sequence;\n-  rtx end_of_code_label = gen_label_rtx ();\n-  int per_counter = GCOV_TYPE_SIZE / BITS_PER_UNIT;\n-  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n-\t\t\tPREV_INSN (value->hvalue.rtl.insn));\n-\n-  start_sequence ();\n-\n-  if (value->hvalue.rtl.seq)\n-    emit_insn (value->hvalue.rtl.seq);\n-\n-  mr = gen_reg_rtx (Pmode);\n-  tmp = rtl_coverage_counter_ref (tag, base);\n-  tmp = force_reg (Pmode, XEXP (tmp, 0));\n-  emit_move_insn (mr, tmp);\n-\n-  uval = gen_reg_rtx (value->hvalue.rtl.mode);\n-  emit_move_insn (uval, copy_rtx (value->hvalue.rtl.value));\n-\n-  /* Check for non-power of 2.  */\n-  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->hvalue.rtl.mode,\n-\t\t\t   NULL_RTX, NULL_RTX, end_of_code_label);\n-  tmp = expand_simple_binop (value->hvalue.rtl.mode, PLUS, copy_rtx (uval),\n-\t\t\t     constm1_rtx, NULL_RTX, 0, OPTAB_WIDEN);\n-  tmp = expand_simple_binop (value->hvalue.rtl.mode, AND, copy_rtx (uval), tmp,\n-\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n-  do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->hvalue.rtl.mode, NULL_RTX,\n-\t\t\t   NULL_RTX, end_of_code_label);\n-\n-  tmp = expand_simple_binop (Pmode, PLUS, copy_rtx (mr), GEN_INT (per_counter),\n-\t\t\t     mr, 0, OPTAB_WIDEN);\n-  if (tmp != mr)\n-    emit_move_insn (copy_rtx (mr), tmp);\n-\n-  /* Increase the counter.  */\n-  emit_label (end_of_code_label);\n-\n-  mem_ref = validize_mem (gen_rtx_MEM (mode, mr));\n-\n-  tmp = expand_simple_binop (mode, PLUS, copy_rtx (mem_ref), const1_rtx,\n-\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n-\n-  if (tmp != mem_ref)\n-    emit_move_insn (copy_rtx (mem_ref), tmp);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  safe_insert_insn_on_edge (sequence, e);\n-}\n-\n-/* Output instructions as RTL for code to find the most common value.\n-   VALUE is the expression whose value is profiled.  TAG is the tag of the\n-   section for counters, BASE is offset of the counter position.  */\n-\n-static rtx\n-rtl_gen_one_value_profiler_no_edge_manipulation (histogram_value value,\n-\t\t\t\t\t\t unsigned tag, unsigned base)\n-{\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx stored_value_ref, counter_ref, all_ref, stored_value, counter, all;\n-  rtx tmp, uval;\n-  rtx sequence;\n-  rtx same_label = gen_label_rtx ();\n-  rtx zero_label = gen_label_rtx ();\n-  rtx end_of_code_label = gen_label_rtx ();\n-\n-  start_sequence ();\n-\n-  if (value->hvalue.rtl.seq)\n-    emit_insn (value->hvalue.rtl.seq);\n-\n-  stored_value_ref = rtl_coverage_counter_ref (tag, base);\n-  counter_ref = rtl_coverage_counter_ref (tag, base + 1);\n-  all_ref = rtl_coverage_counter_ref (tag, base + 2);\n-  stored_value = validize_mem (stored_value_ref);\n-  counter = validize_mem (counter_ref);\n-  all = validize_mem (all_ref);\n-\n-  uval = gen_reg_rtx (mode);\n-  convert_move (uval, copy_rtx (value->hvalue.rtl.value), 0);\n-\n-  /* Check if the stored value matches.  */\n-  do_compare_rtx_and_jump (copy_rtx (uval), copy_rtx (stored_value), EQ,\n-\t\t\t   0, mode, NULL_RTX, NULL_RTX, same_label);\n-\n-  /* Does not match; check whether the counter is zero.  */\n-  do_compare_rtx_and_jump (copy_rtx (counter), const0_rtx, EQ, 0, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, zero_label);\n-\n-  /* The counter is not zero yet.  */\n-  tmp = expand_simple_binop (mode, PLUS, copy_rtx (counter), constm1_rtx,\n-\t\t\t     counter, 0, OPTAB_WIDEN);\n-\n-  if (tmp != counter)\n-    emit_move_insn (copy_rtx (counter), tmp);\n-\n-  emit_jump_insn (gen_jump (end_of_code_label));\n-  emit_barrier ();\n-\n-  emit_label (zero_label);\n-  /* Set new value.  */\n-  emit_move_insn (copy_rtx (stored_value), copy_rtx (uval));\n-\n-  emit_label (same_label);\n-  /* Increase the counter.  */\n-  tmp = expand_simple_binop (mode, PLUS, copy_rtx (counter), const1_rtx,\n-\t\t\t     counter, 0, OPTAB_WIDEN);\n-\n-  if (tmp != counter)\n-    emit_move_insn (copy_rtx (counter), tmp);\n-\n-  emit_label (end_of_code_label);\n-\n-  /* Increase the counter of all executions; this seems redundant given\n-     that ve have counts for edges in cfg, but it may happen that some\n-     optimization will change the counts for the block (either because\n-     it is unable to update them correctly, or because it will duplicate\n-     the block or its part).  */\n-  tmp = expand_simple_binop (mode, PLUS, copy_rtx (all), const1_rtx,\n-\t\t\t     all, 0, OPTAB_WIDEN);\n-\n-  if (tmp != all)\n-    emit_move_insn (copy_rtx (all), tmp);\n-  sequence = get_insns ();\n-  end_sequence ();\n-  return sequence;\n-}\n-\n-/* Output instructions as RTL for code to find the most common value.\n-   VALUE is the expression whose value is profiled.  TAG is the tag of the\n-   section for counters, BASE is offset of the counter position.  */\n-\n-static void\n-rtl_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n-{\n-  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n-\t\t   PREV_INSN (value->hvalue.rtl.insn));\n-  rtx sequence = rtl_gen_one_value_profiler_no_edge_manipulation (value, \n-\t\t\ttag, base);\n-  rebuild_jump_labels (sequence);\n-  safe_insert_insn_on_edge (sequence, e);\n-}\n-\n-/* Output instructions as RTL for code to find the most common value of\n-   a difference between two evaluations of an expression.\n-   VALUE is the expression whose value is profiled.  TAG is the tag of the\n-   section for counters, BASE is offset of the counter position.  */\n-\n-static void\n-rtl_gen_const_delta_profiler (histogram_value value, unsigned tag, unsigned base)\n-{\n-  histogram_value one_value_delta;\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx stored_value_ref, stored_value, tmp, uval;\n-  rtx sequence;\n-  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n-\t\t   PREV_INSN (value->hvalue.rtl.insn));\n-\n-  start_sequence ();\n-\n-  if (value->hvalue.rtl.seq)\n-    emit_insn (value->hvalue.rtl.seq);\n-\n-  stored_value_ref = rtl_coverage_counter_ref (tag, base);\n-  stored_value = validize_mem (stored_value_ref);\n-\n-  uval = gen_reg_rtx (mode);\n-  convert_move (uval, copy_rtx (value->hvalue.rtl.value), 0);\n-  tmp = expand_simple_binop (mode, MINUS,\n-\t\t\t     copy_rtx (uval), copy_rtx (stored_value),\n-\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n-\n-  one_value_delta = ggc_alloc (sizeof (*one_value_delta));\n-  one_value_delta->hvalue.rtl.value = tmp;\n-  one_value_delta->hvalue.rtl.mode = mode;\n-  one_value_delta->hvalue.rtl.seq = NULL_RTX;\n-  one_value_delta->hvalue.rtl.insn = value->hvalue.rtl.insn;\n-  one_value_delta->type = HIST_TYPE_SINGLE_VALUE;\n-  emit_insn (rtl_gen_one_value_profiler_no_edge_manipulation (one_value_delta,\n-\t\t\t\t\t\t\t      tag, base + 1));\n-  emit_move_insn (copy_rtx (stored_value), uval);\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  safe_insert_insn_on_edge (sequence, e);\n-}\n-\n-\f\n-struct profile_hooks rtl_profile_hooks =\n-{\n-  rtl_init_edge_profiler,\n-  rtl_gen_edge_profiler,\n-  rtl_gen_interval_profiler,\n-  rtl_gen_pow2_profiler,\n-  rtl_gen_one_value_profiler,\n-  rtl_gen_const_delta_profiler\n-};"}]}