{"sha": "2acb33103c4cbc6766d8707ad58aa5cc9a804719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFjYjMzMTAzYzRjYmM2NzY2ZDg3MDdhZDU4YWE1Y2M5YTgwNDcxOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-28T11:56:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-28T13:15:37Z"}, "message": "Change the way we split stores in BB vectorization\n\nThe following fixes missed optimizations due to the strange way we\nsplit stores in BB vectorization.  The solution is to split at\nthe failure boundary and not re-align that to the initial piece\nchosen vector size.  Also re-analyze any larger matching rest.\n\n2020-10-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_build_slp_instance): Split the store\n\tgroup at the failure boundary and also re-analyze a large enough\n\tmatching rest.\n\n\t* gcc.dg/vect/bb-slp-68.c: New testcase.", "tree": {"sha": "2ae9a8c3f1965c9c023d7cda958797c0027e62e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae9a8c3f1965c9c023d7cda958797c0027e62e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2acb33103c4cbc6766d8707ad58aa5cc9a804719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acb33103c4cbc6766d8707ad58aa5cc9a804719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2acb33103c4cbc6766d8707ad58aa5cc9a804719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acb33103c4cbc6766d8707ad58aa5cc9a804719/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac1724ccfdb9056d59fc21500c57c4edc963e653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1724ccfdb9056d59fc21500c57c4edc963e653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1724ccfdb9056d59fc21500c57c4edc963e653"}], "stats": {"total": 42, "additions": 35, "deletions": 7}, "files": [{"sha": "8718031cc717b5d68c0e8fdaa866b6f8932b40e1", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-68.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2acb33103c4cbc6766d8707ad58aa5cc9a804719/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2acb33103c4cbc6766d8707ad58aa5cc9a804719/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-68.c?ref=2acb33103c4cbc6766d8707ad58aa5cc9a804719", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-additional-options \"-mavx\" { target avx } } */\n+\n+double x[10], y[6], z[4];\n+\n+void foo ()\n+{\n+  x[0] = y[0];\n+  x[1] = y[1];\n+  x[2] = y[2];\n+  x[3] = y[3];\n+  x[4] = y[4];\n+  x[5] = y[5];\n+  x[6] = z[0] + 1.;\n+  x[7] = z[1] + 1.;\n+  x[8] = z[2] + 1.;\n+  x[9] = z[3] + 1.;\n+}\n+\n+/* We want to have the store group split into 4, 2, 4 when using 32byte vectors.  */\n+/* { dg-final { scan-tree-dump-not \"from scalars\" \"slp2\" } } */"}, {"sha": "50a2d37eb254c02e788ded0435f00ec0620302d1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2acb33103c4cbc6766d8707ad58aa5cc9a804719/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2acb33103c4cbc6766d8707ad58aa5cc9a804719/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2acb33103c4cbc6766d8707ad58aa5cc9a804719", "patch": "@@ -2412,15 +2412,21 @@ vect_build_slp_instance (vec_info *vinfo,\n \t\t\t\t\t\t\t       group1_size);\n \t      bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n \t\t\t\t\t\t    max_tree_size);\n-\t      /* If the first non-match was in the middle of a vector,\n-\t\t skip the rest of that vector.  Do not bother to re-analyze\n-\t\t single stmt groups.  */\n-\t      if (group1_size < i)\n+\t      /* Split the rest at the failure point and possibly\n+\t\t re-analyze the remaining matching part if it has\n+\t\t at least two lanes.  */\n+\t      if (group1_size < i\n+\t\t  && (i + 1 < group_size\n+\t\t      || i - group1_size > 1))\n \t\t{\n-\t\t  i = group1_size + const_nunits;\n-\t\t  if (i + 1 < group_size)\n-\t\t    rest = vect_split_slp_store_group (rest, const_nunits);\n+\t\t  stmt_vec_info rest2 = rest;\n+\t\t  rest = vect_split_slp_store_group (rest, i - group1_size);\n+\t\t  if (i - group1_size > 1)\n+\t\t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n+\t\t\t\t\t\t      rest2, max_tree_size);\n \t\t}\n+\t      /* Re-analyze the non-matching tail if it has at least\n+\t\t two lanes.  */\n \t      if (i + 1 < group_size)\n \t\tres |= vect_analyze_slp_instance (vinfo, bst_map,\n \t\t\t\t\t\t  rest, max_tree_size);"}]}