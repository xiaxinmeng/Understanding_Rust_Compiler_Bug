{"sha": "9727e468b1f04524bc4ff08bf96673e3eba55e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyN2U0NjhiMWYwNDUyNGJjNGZmMDhiZjk2NjczZTNlYmE1NWU0NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-09-26T08:38:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-09-26T08:38:29Z"}, "message": "re PR middle-end/15855 (g++ crash with -O2 and -O3 on input file)\n\n2005-09-26  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/15855\n\t* gcse.c: Include hashtab.h, define ldst entry hashtable.\n\t(pre_ldst_expr_hash, pre_ldst_expr_eq): New functions.\n\t(ldst_entry): Use the hashtable instead of list-walking.\n\t(find_rtx_in_ldst): Likewise.\n\t(free_ldst_entry): Free the hashtable.\n\t(compute_ld_motion_mems): Create the hashtable.\n\t(trim_ld_motion_mems): Remove entry from hashtable if\n\tremoving it from list.\n\t(compute_store_table): Likewise^2.\n\t(store_motion): Free hashtable in case we did not see\n\tany stores.\n\nFrom-SVN: r104641", "tree": {"sha": "6826afed42e7bcac33317919741d34240ac343da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6826afed42e7bcac33317919741d34240ac343da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9727e468b1f04524bc4ff08bf96673e3eba55e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9727e468b1f04524bc4ff08bf96673e3eba55e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9727e468b1f04524bc4ff08bf96673e3eba55e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9727e468b1f04524bc4ff08bf96673e3eba55e45/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f1dfb4145288595055e9fd06afa8a66fae4d86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1dfb4145288595055e9fd06afa8a66fae4d86d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1dfb4145288595055e9fd06afa8a66fae4d86d"}], "stats": {"total": 69, "additions": 59, "deletions": 10}, "files": [{"sha": "283ece3c3cf6b6ecb06d1428c86c896ac52d9a31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9727e468b1f04524bc4ff08bf96673e3eba55e45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9727e468b1f04524bc4ff08bf96673e3eba55e45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9727e468b1f04524bc4ff08bf96673e3eba55e45", "patch": "@@ -1,3 +1,18 @@\n+2005-09-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/15855\n+\t* gcse.c: Include hashtab.h, define ldst entry hashtable.\n+\t(pre_ldst_expr_hash, pre_ldst_expr_eq): New functions.\n+\t(ldst_entry): Use the hashtable instead of list-walking.\n+\t(find_rtx_in_ldst): Likewise.\n+\t(free_ldst_entry): Free the hashtable.\n+\t(compute_ld_motion_mems): Create the hashtable.\n+\t(trim_ld_motion_mems): Remove entry from hashtable if\n+\tremoving it from list.\n+\t(compute_store_table): Likewise^2.\n+\t(store_motion): Free hashtable in case we did not see\n+\tany stores.\n+\n 2005-09-25  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* fold-const.c (fold_binary): Use op0 and op1 instead of arg0"}, {"sha": "2ac9ca24c5251a023611145c9f3ef08b083ff392", "filename": "gcc/gcse.c", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9727e468b1f04524bc4ff08bf96673e3eba55e45/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9727e468b1f04524bc4ff08bf96673e3eba55e45/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9727e468b1f04524bc4ff08bf96673e3eba55e45", "patch": "@@ -170,6 +170,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"obstack.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n+#include \"hashtab.h\"\n \n /* Propagate flow information through back edges and thus enable PRE's\n    moving loop invariant calculations out of loops.\n@@ -471,6 +472,9 @@ static rtx *implicit_sets;\n /* Head of the list of load/store memory refs.  */\n static struct ls_expr * pre_ldst_mems = NULL;\n \n+/* Hashtable for the load/store memory refs.  */\n+static htab_t pre_ldst_table = NULL;\n+\n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n    the start of the basic block.  */\n@@ -5015,6 +5019,21 @@ one_code_hoisting_pass (void)\n     load towards the exit, and we end up with no loads or stores of 'i'\n     in the loop.  */\n \n+static hashval_t\n+pre_ldst_expr_hash (const void *p)\n+{\n+  int do_not_record_p = 0;\n+  const struct ls_expr *x = p;\n+  return hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n+}\n+\n+static int\n+pre_ldst_expr_eq (const void *p1, const void *p2)\n+{\n+  const struct ls_expr *ptr1 = p1, *ptr2 = p2;\n+  return expr_equiv_p (ptr1->pattern, ptr2->pattern);\n+}\n+\n /* This will search the ldst list for a matching expression. If it\n    doesn't find one, we create one and initialize it.  */\n \n@@ -5024,13 +5043,16 @@ ldst_entry (rtx x)\n   int do_not_record_p = 0;\n   struct ls_expr * ptr;\n   unsigned int hash;\n+  void **slot;\n+  struct ls_expr e;\n \n   hash = hash_rtx (x, GET_MODE (x), &do_not_record_p,\n \t\t   NULL,  /*have_reg_qty=*/false);\n \n-  for (ptr = pre_ldst_mems; ptr != NULL; ptr = ptr->next)\n-    if (ptr->hash_index == hash && expr_equiv_p (ptr->pattern, x))\n-      return ptr;\n+  e.pattern = x;\n+  slot = htab_find_slot_with_hash (pre_ldst_table, &e, hash, INSERT);\n+  if (*slot)\n+    return (struct ls_expr *)*slot;\n \n   ptr = xmalloc (sizeof (struct ls_expr));\n \n@@ -5045,6 +5067,7 @@ ldst_entry (rtx x)\n   ptr->index        = 0;\n   ptr->hash_index   = hash;\n   pre_ldst_mems     = ptr;\n+  *slot = ptr;\n \n   return ptr;\n }\n@@ -5065,6 +5088,9 @@ free_ldst_entry (struct ls_expr * ptr)\n static void\n free_ldst_mems (void)\n {\n+  htab_delete (pre_ldst_table);\n+  pre_ldst_table = NULL;\n+\n   while (pre_ldst_mems)\n     {\n       struct ls_expr * tmp = pre_ldst_mems;\n@@ -5117,13 +5143,13 @@ print_ldst_list (FILE * file)\n static struct ls_expr *\n find_rtx_in_ldst (rtx x)\n {\n-  struct ls_expr * ptr;\n-\n-  for (ptr = pre_ldst_mems; ptr != NULL; ptr = ptr->next)\n-    if (expr_equiv_p (ptr->pattern, x) && ! ptr->invalid)\n-      return ptr;\n-\n-  return NULL;\n+  struct ls_expr e;\n+  void **slot;\n+  e.pattern = x;\n+  slot = htab_find_slot (pre_ldst_table, &e, NO_INSERT);\n+  if (!slot || ((struct ls_expr *)*slot)->invalid)\n+    return NULL;\n+  return *slot;\n }\n \n /* Assign each element of the list of mems a monotonically increasing value.  */\n@@ -5244,6 +5270,8 @@ compute_ld_motion_mems (void)\n   rtx insn;\n \n   pre_ldst_mems = NULL;\n+  pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n+\t\t\t\tpre_ldst_expr_eq, NULL);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -5334,6 +5362,7 @@ trim_ld_motion_mems (void)\n       else\n \t{\n \t  *last = ptr->next;\n+\t  htab_remove_elt_with_hash (pre_ldst_table, ptr, ptr->hash_index);\n \t  free_ldst_entry (ptr);\n \t  ptr = * last;\n \t}\n@@ -5693,6 +5722,8 @@ compute_store_table (void)\n \t\t\t\t\t\t       max_gcse_regno);\n   sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n   pre_ldst_mems = 0;\n+  pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n+\t\t\t\tpre_ldst_expr_eq, NULL);\n   last_set_in = xcalloc (max_gcse_regno, sizeof (int));\n   already_set = xmalloc (sizeof (int) * max_gcse_regno);\n \n@@ -5780,6 +5811,7 @@ compute_store_table (void)\n       if (!AVAIL_STORE_LIST (ptr))\n \t{\n \t  *prev_next_ptr_ptr = ptr->next;\n+\t  htab_remove_elt_with_hash (pre_ldst_table, ptr, ptr->hash_index);\n \t  free_ldst_entry (ptr);\n \t}\n       else\n@@ -6399,6 +6431,8 @@ store_motion (void)\n   num_stores = compute_store_table ();\n   if (num_stores == 0)\n     {\n+      htab_delete (pre_ldst_table);\n+      pre_ldst_table = NULL;\n       sbitmap_vector_free (reg_set_in_block);\n       end_alias_analysis ();\n       return;"}]}