{"sha": "d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI1YTQ1ZDQ0YjFmYmRjNTcwMjQ2MWNlYWNlYjJjY2IyMGVjMTJjYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-15T17:09:19Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2000-09-15T17:09:19Z"}, "message": "gcc.c: Fix formatting.\n\n2000-09-15  Kazu Hirata  <kazu@hxi.com>\n\n\t* gcc.c: Fix formatting.\n\nFrom-SVN: r36439", "tree": {"sha": "46ff4a1436060c2ca9a534723246bd17edee294f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46ff4a1436060c2ca9a534723246bd17edee294f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb/comments", "author": null, "committer": null, "parents": [{"sha": "d7ce9a83bdd7c5406aab74f1707a4e111470cadd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ce9a83bdd7c5406aab74f1707a4e111470cadd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ce9a83bdd7c5406aab74f1707a4e111470cadd"}], "stats": {"total": 560, "additions": 285, "deletions": 275}, "files": [{"sha": "44a42614df4f28f4d1551a7f42126b6ae6af0d94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "patch": "@@ -1,6 +1,7 @@\n 2000-09-15  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/i386/i386.md: Fix a comment typo.\n+\t* gcc.c: Fix formatting.\n \n 2000-09-15  Bernd Schmidt  <bernds@redhat.co.uk>\n "}, {"sha": "66d70cf4156ebb706c91ec2d2f81bdf59b6a0bbb", "filename": "gcc/gcc.c", "status": "modified", "additions": 284, "deletions": 275, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=d25a45d44b1fbdc5702461ceaceb2ccb20ec12cb", "patch": "@@ -73,7 +73,7 @@ extern int getrusage PARAMS ((int, struct rusage *));\n #endif /* DIR_UP */\n #endif /* VMS */\n \n-static char dir_separator_str[] = {DIR_SEPARATOR, 0};\n+static char dir_separator_str[] = { DIR_SEPARATOR, 0 };\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -597,7 +597,7 @@ static const char *multilib_exclusions;\n #define MULTILIB_DEFAULTS { \"\" }\n #endif\n \n-static const  char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n+static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n \n struct user_specs\n {\n@@ -1027,7 +1027,8 @@ skip_whitespace (p)\n \tp++;\n       else if (*p == '#')\n \t{\n-\t  while (*p != '\\n') p++;\n+\t  while (*p != '\\n')\n+\t    p++;\n \t  p++;\n \t}\n       else\n@@ -1057,7 +1058,7 @@ struct spec_list\n };\n \n #define INIT_STATIC_SPEC(NAME,PTR) \\\n-{ NAME, NULL_PTR, PTR, (struct spec_list *) 0, sizeof (NAME)-1, 0 }\n+{ NAME, NULL_PTR, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }\n \n /* List of statically defined specs.  */\n static struct spec_list static_specs[] =\n@@ -1100,7 +1101,7 @@ struct spec_list_1\n };\n \n static struct spec_list_1 extra_specs_1[] = { EXTRA_SPECS };\n-static struct spec_list * extra_specs = (struct spec_list *) 0;\n+static struct spec_list *extra_specs = (struct spec_list *) 0;\n #endif\n \n /* List of dynamically allocates specs that have been defined so far.  */\n@@ -1378,7 +1379,7 @@ store_arg (arg, delete_always, delete_failure)\n    various different types of line-endings, \\r\\n, \\n\\r and just \\r, with\n    a single \\n.  */\n \n-static char*\n+static char *\n load_specs (filename)\n      const char *filename;\n {\n@@ -1415,10 +1416,10 @@ load_specs (filename)\n       int skip = 0;\n       char c = *buffer_p;\n       if (c == '\\r')\n-        {\n-\t  if (buffer_p > buffer && *(buffer_p-1) == '\\n')\t/* \\n\\r */\n+\t{\n+\t  if (buffer_p > buffer && *(buffer_p - 1) == '\\n')\t/* \\n\\r */\n \t    skip = 1;\n-\t  else if (*(buffer_p+1) == '\\n')\t\t\t/* \\r\\n */\n+\t  else if (*(buffer_p + 1) == '\\n')\t\t\t/* \\r\\n */\n \t    skip = 1;\n \t  else\t\t\t\t\t\t\t/* \\r */\n \t    c = '\\n';\n@@ -1475,9 +1476,10 @@ read_specs (filename, main_p)\n \t  while (*p && *p != '\\n')\n \t    p++;\n \n-\t  p++;\t\t\t/* Skip '\\n' */\n+\t  /* Skip '\\n'.  */\n+\t  p++;\n \n-\t  if (!strncmp (p1, \"%include\", sizeof (\"%include\")-1)\n+\t  if (!strncmp (p1, \"%include\", sizeof (\"%include\") - 1)\n \t      && (p1[sizeof \"%include\" - 1] == ' '\n \t\t  || p1[sizeof \"%include\" - 1] == '\\t'))\n \t    {\n@@ -1503,7 +1505,8 @@ read_specs (filename, main_p)\n \t      char *new_filename;\n \n \t      p1 += sizeof \"%include_noerr\";\n-\t      while (*p1 == ' ' || *p1 == '\\t') p1++;\n+\t      while (*p1 == ' ' || *p1 == '\\t')\n+\t\tp1++;\n \n \t      if (*p1++ != '<' || p[-2] != '>')\n \t\tfatal (\"specs %%include syntax malformed after %ld characters\",\n@@ -1550,12 +1553,12 @@ read_specs (filename, main_p)\n \t\tfatal (\"specs %%rename syntax malformed after %ld characters\",\n \t\t       (long) (p2 - buffer));\n \n-\t      /* Get new spec name */\n+\t      /* Get new spec name.  */\n \t      p3 = p2;\n \t      while (*p3 && !ISSPACE ((unsigned char) *p3))\n \t\tp3++;\n \n-\t      if (p3 != p-1)\n+\t      if (p3 != p - 1)\n \t\tfatal (\"specs %%rename syntax malformed after %ld characters\",\n \t\t       (long) (p3 - buffer));\n \t      *p3 = '\\0';\n@@ -1713,7 +1716,7 @@ record_temp_file (filename, always_delete, fail_delete)\n      int always_delete;\n      int fail_delete;\n {\n-  register char * const name = xstrdup (filename);\n+  register char *const name = xstrdup (filename);\n \n   if (always_delete)\n     {\n@@ -1842,16 +1845,15 @@ putenv (str)\n     }\n \n   /* Add a new environment variable */\n-  environ = (char **) xmalloc (sizeof (char *) * (num_envs+2));\n+  environ = (char **) xmalloc (sizeof (char *) * (num_envs + 2));\n   *environ = str;\n   memcpy ((char *) (environ + 1), (char *) old_environ,\n-\t sizeof (char *) * (num_envs+1));\n+\t  sizeof (char *) * (num_envs + 1));\n \n #endif\t/* VMS */\n }\n \n-#endif\t/* HAVE_PUTENV */\n-\n+#endif /* HAVE_PUTENV */\n \f\n /* Build a list of search directories from PATHS.\n    PREFIX is a string to prepend to the list.\n@@ -2014,7 +2016,7 @@ free_split_directories (dirs)\n   while (dirs[i] != NULL_PTR)\n     free (dirs[i++]);\n \n-  free ((char *)dirs);\n+  free ((char *) dirs);\n }\n \n /* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets\n@@ -2065,14 +2067,14 @@ make_relative_prefix (progname, bin_prefix, prefix)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      strncpy (nstore, startp, endp-startp);\n+\t\t      strncpy (nstore, startp, endp - startp);\n \t\t      if (! IS_DIR_SEPARATOR (endp[-1]))\n \t\t\t{\n-\t\t\t  nstore[endp-startp] = DIR_SEPARATOR;\n-\t\t\t  nstore[endp-startp+1] = 0;\n+\t\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n+\t\t\t  nstore[endp - startp + 1] = 0;\n \t\t\t}\n \t\t      else\n-\t\t\tnstore[endp-startp] = 0;\n+\t\t\tnstore[endp - startp] = 0;\n \t\t    }\n \t\t  strcat (nstore, progname);\n \t\t  if (! access (nstore, X_OK)\n@@ -2148,7 +2150,7 @@ make_relative_prefix (progname, bin_prefix, prefix)\n   /* Now build up the ..'s.  */\n   for (i = common; i < n; i++)\n     {\n-      obstack_grow (&obstack, DIR_UP, sizeof (DIR_UP)-1);\n+      obstack_grow (&obstack, DIR_UP, sizeof (DIR_UP) - 1);\n       obstack_1grow (&obstack, DIR_SEPARATOR);\n     }\n \n@@ -2401,11 +2403,11 @@ execute ()\n   int n_commands;\t\t/* # of command.  */\n   char *string;\n   struct command\n-    {\n-      const char *prog;\t\t/* program name.  */\n-      const char **argv;\t/* vector of args.  */\n-      int pid;\t\t\t/* pid of process for this command.  */\n-    };\n+  {\n+    const char *prog;\t\t/* program name.  */\n+    const char **argv;\t\t/* vector of args.  */\n+    int pid;\t\t\t/* pid of process for this command.  */\n+  };\n \n   struct command *commands;\t/* each command buffer with above info.  */\n \n@@ -2415,8 +2417,7 @@ execute ()\n       n_commands++;\n \n   /* Get storage for each command.  */\n-  commands\n-    = (struct command *) alloca (n_commands * sizeof (struct command));\n+  commands = (struct command *) alloca (n_commands * sizeof (struct command));\n \n   /* Split argbuf into its separate piped processes,\n      and record info about each one.\n@@ -2433,7 +2434,7 @@ execute ()\n     if (strcmp (argbuf[i], \"|\") == 0)\n       {\t\t\t\t/* each command.  */\n #if defined (__MSDOS__) || defined (OS2) || defined (VMS)\n-        fatal (\"-pipe not supported\");\n+\tfatal (\"-pipe not supported\");\n #endif\n \targbuf[i] = 0;\t/* termination of command args.  */\n \tcommands[n_commands].prog = argbuf[i + 1];\n@@ -2455,7 +2456,7 @@ execute ()\n \tfputc ('\\n', stderr);\n \n       /* Print each piped command as a separate line.  */\n-      for (i = 0; i < n_commands ; i++)\n+      for (i = 0; i < n_commands; i++)\n \t{\n \t  const char *const *j;\n \n@@ -2521,7 +2522,7 @@ execute ()\n     double ut = 0.0, st = 0.0;\n #endif\n \n-    for (i = 0; i < n_commands; )\n+    for (i = 0; i < n_commands;)\n       {\n \tint j;\n \tint status;\n@@ -2542,11 +2543,11 @@ execute ()\n \t    getrusage (RUSAGE_CHILDREN, &rus);\n \t    d.tv_sec = rus.ru_utime.tv_sec - prus.ru_utime.tv_sec;\n \t    d.tv_usec = rus.ru_utime.tv_usec - prus.ru_utime.tv_usec;\n-\t    ut = (double)d.tv_sec + (double)d.tv_usec / 1.0e6;\n+\t    ut = (double) d.tv_sec + (double) d.tv_usec / 1.0e6;\n \n \t    d.tv_sec = rus.ru_stime.tv_sec - prus.ru_stime.tv_sec;\n \t    d.tv_usec = rus.ru_stime.tv_usec - prus.ru_stime.tv_usec;\n-\t    st = (double)d.tv_sec + (double)d.tv_usec / 1.0e6;\n+\t    st = (double) d.tv_sec + (double) d.tv_usec / 1.0e6;\n \t  }\n #endif\n \n@@ -2767,7 +2768,7 @@ on to these processes the -W<letter> options must be used.\\n\\\n \n static void\n add_preprocessor_option (option, len)\n-     const char * option;\n+     const char *option;\n      int len;\n {\n   n_preprocessor_options++;\n@@ -2786,7 +2787,7 @@ add_preprocessor_option (option, len)\n \n static void\n add_assembler_option (option, len)\n-     const char * option;\n+     const char *option;\n      int len;\n {\n   n_assembler_options++;\n@@ -2804,8 +2805,8 @@ add_assembler_option (option, len)\n \n static void\n add_linker_option (option, len)\n-     const char * option;\n-     int    len;\n+     const char *option;\n+     int len;\n {\n   n_linker_options++;\n \n@@ -2873,14 +2874,14 @@ process_command (argc, argv)\n   if (gcc_exec_prefix)\n     {\n       int len = strlen (gcc_exec_prefix);\n-      if (len > (int) sizeof (\"/lib/gcc-lib/\")-1\n+      if (len > (int) sizeof (\"/lib/gcc-lib/\") - 1\n \t  && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))\n \t{\n \t  temp = gcc_exec_prefix + len - sizeof (\"/lib/gcc-lib/\") + 1;\n \t  if (IS_DIR_SEPARATOR (*temp)\n-\t      && strncmp (temp+1, \"lib\", 3) == 0\n+\t      && strncmp (temp + 1, \"lib\", 3) == 0\n \t      && IS_DIR_SEPARATOR (temp[4])\n-\t      && strncmp (temp+5, \"gcc-lib\", 7) == 0)\n+\t      && strncmp (temp + 5, \"gcc-lib\", 7) == 0)\n \t    len -= sizeof (\"/lib/gcc-lib/\") - 1;\n \t}\n \n@@ -2905,16 +2906,16 @@ process_command (argc, argv)\n \t{\n \t  if (*endp == PATH_SEPARATOR || *endp == 0)\n \t    {\n-\t      strncpy (nstore, startp, endp-startp);\n+\t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n \t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n-\t\t  nstore[endp-startp] = DIR_SEPARATOR;\n-\t\t  nstore[endp-startp+1] = 0;\n+\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n+\t\t  nstore[endp - startp + 1] = 0;\n \t\t}\n \t      else\n-\t\tnstore[endp-startp] = 0;\n+\t\tnstore[endp - startp] = 0;\n \t      add_prefix (&exec_prefixes, nstore, 0,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      add_prefix (&include_prefixes,\n@@ -2940,16 +2941,16 @@ process_command (argc, argv)\n \t{\n \t  if (*endp == PATH_SEPARATOR || *endp == 0)\n \t    {\n-\t      strncpy (nstore, startp, endp-startp);\n+\t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n \t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n-\t\t  nstore[endp-startp] = DIR_SEPARATOR;\n-\t\t  nstore[endp-startp+1] = 0;\n+\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n+\t\t  nstore[endp - startp + 1] = 0;\n \t\t}\n \t      else\n-\t\tnstore[endp-startp] = 0;\n+\t\tnstore[endp - startp] = 0;\n \t      add_prefix (&startfile_prefixes, nstore, NULL_PTR,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      if (*endp == 0)\n@@ -2973,16 +2974,16 @@ process_command (argc, argv)\n \t{\n \t  if (*endp == PATH_SEPARATOR || *endp == 0)\n \t    {\n-\t      strncpy (nstore, startp, endp-startp);\n+\t      strncpy (nstore, startp, endp - startp);\n \t      if (endp == startp)\n \t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (!IS_DIR_SEPARATOR (endp[-1]))\n \t\t{\n-\t\t  nstore[endp-startp] = DIR_SEPARATOR;\n-\t\t  nstore[endp-startp+1] = 0;\n+\t\t  nstore[endp - startp] = DIR_SEPARATOR;\n+\t\t  nstore[endp - startp + 1] = 0;\n \t\t}\n \t      else\n-\t\tnstore[endp-startp] = 0;\n+\t\tnstore[endp - startp] = 0;\n \t      add_prefix (&startfile_prefixes, nstore, NULL_PTR,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      if (*endp == 0)\n@@ -3012,8 +3013,8 @@ process_command (argc, argv)\n \t  init_spec ();\n \t  for (sl = specs; sl; sl = sl->next)\n \t    printf (\"*%s:\\n%s\\n\\n\", sl->name, *(sl->ptr_spec));\n-          if (link_command_spec)\n-            printf (\"*link_command:\\n%s\\n\\n\", link_command_spec);\n+\t  if (link_command_spec)\n+\t    printf (\"*link_command:\\n%s\\n\\n\", link_command_spec);\n \t  exit (0);\n \t}\n       else if (! strcmp (argv[i], \"-dumpversion\"))\n@@ -3024,7 +3025,7 @@ process_command (argc, argv)\n       else if (! strcmp (argv[i], \"-dumpmachine\"))\n \t{\n \t  printf (\"%s\\n\", spec_machine);\n-\t  exit  (0);\n+\t  exit (0);\n \t}\n       else if (strcmp (argv[i], \"-fhelp\") == 0)\n \t{\n@@ -3138,7 +3139,7 @@ process_command (argc, argv)\n \t    fatal (\"argument to `-specs=' is missing\");\n \n \t  user->next = (struct user_specs *) 0;\n-\t  user->filename = argv[i]+7;\n+\t  user->filename = argv[i] + 7;\n \t  if (user_specs_tail)\n \t    user_specs_tail->next = user;\n \t  else\n@@ -3155,7 +3156,7 @@ process_command (argc, argv)\n \t  switch (c)\n \t    {\n \t    case 'b':\n-              n_switches++;\n+\t      n_switches++;\n \t      if (p[1] == 0 && i + 1 == argc)\n \t\tfatal (\"argument to `-b' is missing\");\n \t      if (p[1] == 0)\n@@ -3207,7 +3208,7 @@ process_command (argc, argv)\n \t\t\t\t\t\t       NULL_PTR),\n \t\t\t    NULL_PTR,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n-                n_switches++;\n+\t\tn_switches++;\n \t      }\n \t      break;\n \n@@ -3305,7 +3306,7 @@ process_command (argc, argv)\n #endif\n #if defined(HAVE_EXECUTABLE_SUFFIX) || defined(HAVE_OBJECT_SUFFIX)\n \t      if (p[1] == 0)\n-\t\targv[i+1] = convert_filename (argv[i+1], ! have_c);\n+\t\targv[i + 1] = convert_filename (argv[i + 1], ! have_c);\n \t      else\n \t\targv[i] = convert_filename (argv[i], ! have_c);\n #endif\n@@ -3385,7 +3386,7 @@ process_command (argc, argv)\n     }\n \n   add_prefix (&exec_prefixes,\n-              concat (tooldir_prefix, \"bin\", dir_separator_str, NULL_PTR),\n+\t      concat (tooldir_prefix, \"bin\", dir_separator_str, NULL_PTR),\n \t      \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n   add_prefix (&startfile_prefixes,\n \t      concat (tooldir_prefix, \"lib\", dir_separator_str, NULL_PTR),\n@@ -3572,12 +3573,12 @@ process_command (argc, argv)\n \t  /* This is always valid, since gcc.c itself understands it.  */\n \t  if (!strcmp (p, \"save-temps\"))\n \t    switches[n_switches].validated = 1;\n-          else\n-            {\n-              char ch = switches[n_switches].part1[0];\n-              if (ch == 'V' || ch == 'b' || ch == 'B')\n-                switches[n_switches].validated = 1;\n-            }\n+\t  else\n+\t    {\n+\t      char ch = switches[n_switches].part1[0];\n+\t      if (ch == 'V' || ch == 'b' || ch == 'B')\n+\t\tswitches[n_switches].validated = 1;\n+\t    }\n \t  n_switches++;\n \t}\n       else\n@@ -3927,7 +3928,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    {\n \t      const char *q = p;\n \t      char *buf;\n-\t      while (*p != 0 && *p != '\\n') p++;\n+\t      while (*p != 0 && *p != '\\n')\n+\t\tp++;\n \t      buf = (char *) alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n@@ -3936,26 +3938,26 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    }\n \t    break;\n \n-          case 'j':\n-            {\n-              struct stat st;\n-\n-              /* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined,\n-                 and it is not a directory, and it is writable, use it.\n-                 Otherwise, fall through and treat this like any other\n-                 temporary file.  */\n-\n-              if ((!save_temps_flag)\n-                  && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\n-                  && (access (HOST_BIT_BUCKET, W_OK) == 0))\n-                {\n-                  obstack_grow (&obstack, HOST_BIT_BUCKET,\n-                                strlen (HOST_BIT_BUCKET));\n-                  delete_this_arg = 0;\n-                  arg_going = 1;\n-                  break;\n-                }\n-            }\n+\t  case 'j':\n+\t    {\n+\t      struct stat st;\n+\n+\t      /* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined,\n+\t\t and it is not a directory, and it is writable, use it.\n+\t\t Otherwise, fall through and treat this like any other\n+\t\t temporary file.  */\n+\n+\t      if ((!save_temps_flag)\n+\t\t  && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\n+\t\t  && (access (HOST_BIT_BUCKET, W_OK) == 0))\n+\t\t{\n+\t\t  obstack_grow (&obstack, HOST_BIT_BUCKET,\n+\t\t\t\tstrlen (HOST_BIT_BUCKET));\n+\t\t  delete_this_arg = 0;\n+\t\t  arg_going = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  case 'g':\n \t  case 'u':\n \t  case 'U':\n@@ -4272,9 +4274,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      *x++ = *y++;\n \n \t\t      if (*y != '_'\n-\t\t\t  || (*(y+1) != '_'\n-\t\t\t      && ! ISUPPER ((unsigned char) *(y+1))))\n-\t\t        {\n+\t\t\t  || (*(y + 1) != '_'\n+\t\t\t      && ! ISUPPER ((unsigned char) *(y + 1))))\n+\t\t\t{\n \t\t\t  /* Stick __ at front of macro name.  */\n \t\t\t  if (*y != '_')\n \t\t\t    *x++ = '_';\n@@ -4288,7 +4290,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t*x++ = *y++;\n \n \t\t      if (flag)\n-\t\t        {\n+\t\t\t{\n \t\t\t  if (x[-1] != '_')\n \t\t\t    {\n \t\t\t      if (x[-2] != '_')\n@@ -4320,9 +4322,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      y += 2;\n \n \t\t      if (*y != '_'\n-\t\t\t  || (*(y+1) != '_'\n-\t\t\t      && ! ISUPPER ((unsigned char) *(y+1))))\n-\t\t        {\n+\t\t\t  || (*(y + 1) != '_'\n+\t\t\t      && ! ISUPPER ((unsigned char) *(y + 1))))\n+\t\t\t{\n \t\t\t  /* Stick -D__ at front of macro name.  */\n \t\t\t  *x++ = '-';\n \t\t\t  *x++ = 'D';\n@@ -4468,14 +4470,15 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t      flag = 1;\n \t\t\t      continue;\n \t\t\t    }\n-                          else if (flag && (*y == ' ' || *y == '\\t' || *y == '='\n-                                            || *y == '}' || *y == 0))\n+\t\t\t  else if (flag\n+\t\t\t\t   && (*y == ' ' || *y == '\\t' || *y == '='\n+\t\t\t\t       || *y == '}' || *y == 0))\n \t\t\t    {\n \t\t\t      *x++ = '_';\n \t\t\t      *x++ = '_';\n \t\t\t      flag = 0;\n \t\t\t    }\n-                          if (*y == 0)\n+\t\t\t  if (*y == 0)\n \t\t\t    break;\n \t\t\t  else\n \t\t\t    *x++ = *y++;\n@@ -4530,8 +4533,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t    v++;\n \t\t  if ((*v != 0) && (*v != ' ') && (*v != '.') && (*v != '-'))\n \t\t    abort ();\n-                  if (*v != 0)\n-                      v++;\n+\t\t  if (*v != 0)\n+\t\t    v++;\n \t\t}\n \n \t      /* Set Q at the next period or at the end.  */\n@@ -4541,12 +4544,12 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      if (*q != 0 && q > v && *q != ' ' && *q != '.' && *q != '-')\n \t\tabort ();\n \n-              if (q > v)\n-\t        /* Put that part into the command.  */\n-\t        obstack_grow (&obstack, v, q - v);\n-              else\n-                /* Default to \"0\" */\n-                obstack_grow (&obstack, &zeroc, 1);\n+\t      if (q > v)\n+\t\t/* Put that part into the command.  */\n+\t\tobstack_grow (&obstack, v, q - v);\n+\t      else\n+\t\t/* Default to \"0\" */\n+\t\tobstack_grow (&obstack, &zeroc, 1);\n \t      arg_going = 1;\n \t    }\n \t    break;\n@@ -4573,7 +4576,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \targ_going = 1;\n       }\n \n-  return 0;\t\t/* End of string */\n+  /* End of string.  */\n+  return 0;\n }\n \n /* Return 0 if we call do_spec_1 and that returns -1.  */\n@@ -4639,41 +4643,43 @@ handle_braces (p)\n     }\n \n   filter = p;\n-  while (*p != ':' && *p != '}' && *p != '|') p++;\n+  while (*p != ':' && *p != '}' && *p != '|')\n+    p++;\n \n   if (*p == '|' && pipe_p)\n     abort ();\n \n   if (!body)\n     {\n       if (*p != '}')\n-        {\n+\t{\n \t  register int count = 1;\n \t  register const char *q = p;\n \n-\t  while (*q++ != ':') continue;\n+\t  while (*q++ != ':')\n+\t    continue;\n \t  body = q;\n \n \t  while (count > 0)\n \t    {\n \t      if (*q == '{')\n-\t        count++;\n+\t\tcount++;\n \t      else if (*q == '}')\n-\t        count--;\n+\t\tcount--;\n \t      else if (*q == 0)\n-\t        abort ();\n+\t\tabort ();\n \t      q++;\n \t    }\n \t  endbody = q;\n \t}\n       else\n-\tbody = p, endbody = p+1;\n+\tbody = p, endbody = p + 1;\n     }\n \n   if (suffix)\n     {\n       int found = (input_suffix != 0\n-\t\t   && (long) strlen (input_suffix) == (long)(p - filter)\n+\t\t   && (long) strlen (input_suffix) == (long) (p - filter)\n \t\t   && strncmp (input_suffix, filter, p - filter) == 0);\n \n       if (body[0] == '}')\n@@ -4839,13 +4845,13 @@ check_live_switch (switchnum, prefix_length)\n   switch (*name)\n     {\n     case 'O':\n-\tfor (i = switchnum + 1; i < n_switches; i++)\n-\t  if (switches[i].part1[0] == 'O')\n-\t    {\n-\t      switches[switchnum].validated = 1;\n-\t      switches[switchnum].live_cond = SWITCH_FALSE;\n-\t      return 0;\n-\t    }\n+      for (i = switchnum + 1; i < n_switches; i++)\n+\tif (switches[i].part1[0] == 'O')\n+\t  {\n+\t    switches[switchnum].validated = 1;\n+\t    switches[switchnum].live_cond = SWITCH_FALSE;\n+\t    return 0;\n+\t  }\n       break;\n \n     case 'W':  case 'f':  case 'm':\n@@ -4855,11 +4861,11 @@ check_live_switch (switchnum, prefix_length)\n \t  for (i = switchnum + 1; i < n_switches; i++)\n \t    if (switches[i].part1[0] == name[0]\n \t\t&& ! strcmp (&switches[i].part1[1], &name[4]))\n-\t    {\n-\t      switches[switchnum].validated = 1;\n-\t      switches[switchnum].live_cond = SWITCH_FALSE;\n-\t      return 0;\n-\t    }\n+\t      {\n+\t\tswitches[switchnum].validated = 1;\n+\t\tswitches[switchnum].live_cond = SWITCH_FALSE;\n+\t\treturn 0;\n+\t      }\n \t}\n       else\n \t{\n@@ -4870,11 +4876,11 @@ check_live_switch (switchnum, prefix_length)\n \t\t&& switches[i].part1[2] == 'o'\n \t\t&& switches[i].part1[3] == '-'\n \t\t&& !strcmp (&switches[i].part1[4], &name[1]))\n-\t    {\n-\t      switches[switchnum].validated = 1;\n-\t      switches[switchnum].live_cond = SWITCH_FALSE;\n-\t      return 0;\n-\t    }\n+\t      {\n+\t\tswitches[switchnum].validated = 1;\n+\t\tswitches[switchnum].live_cond = SWITCH_FALSE;\n+\t\treturn 0;\n+\t      }\n \t}\n       break;\n     }\n@@ -5031,7 +5037,8 @@ set_input (filename)\n   basename_length = strlen (input_basename);\n   suffixed_basename_length = basename_length;\n   p = input_basename + basename_length;\n-  while (p != input_basename && *p != '.') --p;\n+  while (p != input_basename && *p != '.')\n+    --p;\n   if (*p == '.' && p != input_basename)\n     {\n       basename_length = p - input_basename;\n@@ -5126,7 +5133,7 @@ main (argc, argv)\n \n     q = multilib_exclusions_raw;\n     while ((p = *q++) != (char *) 0)\n-\tobstack_grow (&multilib_obstack, p, strlen (p));\n+      obstack_grow (&multilib_obstack, p, strlen (p));\n \n     obstack_1grow (&multilib_obstack, 0);\n     multilib_exclusions = obstack_finish (&multilib_obstack);\n@@ -5150,8 +5157,8 @@ main (argc, argv)\n      needed for collect.  We use argv[0] instead of programname because\n      we need the complete pathname.  */\n   obstack_init (&collect_obstack);\n-  obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\")-1);\n-  obstack_grow (&collect_obstack, argv[0], strlen (argv[0])+1);\n+  obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\") - 1);\n+  obstack_grow (&collect_obstack, argv[0], strlen (argv[0]) + 1);\n   putenv (obstack_finish (&collect_obstack));\n \n #ifdef INIT_ENVIRONMENT\n@@ -5171,10 +5178,10 @@ main (argc, argv)\n     /* Build COLLECT_GCC_OPTIONS to have all of the options specified to\n        the compiler.  */\n     obstack_grow (&collect_obstack, \"COLLECT_GCC_OPTIONS=\",\n-\t\t  sizeof (\"COLLECT_GCC_OPTIONS=\")-1);\n+\t\t  sizeof (\"COLLECT_GCC_OPTIONS=\") - 1);\n \n     first_time = TRUE;\n-    for (i = 0; (int)i < n_switches; i++)\n+    for (i = 0; (int) i < n_switches; i++)\n       {\n \tconst char *const *args;\n \tconst char *p, *q;\n@@ -5183,23 +5190,23 @@ main (argc, argv)\n \n \tfirst_time = FALSE;\n \tobstack_grow (&collect_obstack, \"'-\", 2);\n-        q = switches[i].part1;\n-\twhile ((p = index (q,'\\'')))\n-          {\n-            obstack_grow (&collect_obstack, q, p-q);\n-            obstack_grow (&collect_obstack, \"'\\\\''\", 4);\n-            q = ++p;\n-          }\n-        obstack_grow (&collect_obstack, q, strlen (q));\n+\tq = switches[i].part1;\n+\twhile ((p = index (q, '\\'')))\n+\t  {\n+\t    obstack_grow (&collect_obstack, q, p - q);\n+\t    obstack_grow (&collect_obstack, \"'\\\\''\", 4);\n+\t    q = ++p;\n+\t  }\n+\tobstack_grow (&collect_obstack, q, strlen (q));\n \tobstack_grow (&collect_obstack, \"'\", 1);\n \n \tfor (args = switches[i].args; args && *args; args++)\n \t  {\n \t    obstack_grow (&collect_obstack, \" '\", 2);\n \t    q = *args;\n-\t    while ((p = index (q,'\\'')))\n+\t    while ((p = index (q, '\\'')))\n \t      {\n-\t\tobstack_grow (&collect_obstack, q, p-q);\n+\t\tobstack_grow (&collect_obstack, q, p - q);\n \t\tobstack_grow (&collect_obstack, \"'\\\\''\", 4);\n \t\tq = ++p;\n \t      }\n@@ -5321,9 +5328,9 @@ main (argc, argv)\n   /* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */\n   if (gcc_exec_prefix)\n     {\n-      char * temp = (char *) xmalloc (strlen (gcc_exec_prefix)\n-\t\t\t\t      + strlen (spec_version)\n-\t\t\t\t      + strlen (spec_machine) + 3);\n+      char *temp = (char *) xmalloc (strlen (gcc_exec_prefix)\n+\t\t\t\t     + strlen (spec_version)\n+\t\t\t\t     + strlen (spec_machine) + 3);\n       strcpy (temp, gcc_exec_prefix);\n       strcat (temp, spec_machine);\n       strcat (temp, dir_separator_str);\n@@ -5343,7 +5350,7 @@ main (argc, argv)\n \n   /* Warn about any switches that no pass was interested in.  */\n \n-  for (i = 0; (int)i < n_switches; i++)\n+  for (i = 0; (int) i < n_switches; i++)\n     if (! switches[i].validated)\n       error (\"unrecognized option `-%s'\", switches[i].part1);\n \n@@ -5438,7 +5445,7 @@ main (argc, argv)\n \n   explicit_link_files = xcalloc (1, n_infiles);\n \n-  for (i = 0; (int)i < n_infiles; i++)\n+  for (i = 0; (int) i < n_infiles; i++)\n     {\n       register struct compiler *cp = 0;\n       int this_file_error = 0;\n@@ -5530,7 +5537,7 @@ main (argc, argv)\n      complain about input files to be given to the linker.  */\n \n   if (! linker_was_run && error_count == 0)\n-    for (i = 0; (int)i < n_infiles; i++)\n+    for (i = 0; (int) i < n_infiles; i++)\n       if (explicit_link_files[i])\n \terror (\"%s: linker input file unused since linking not done\",\n \t       outfiles[i]);\n@@ -5627,8 +5634,8 @@ lookup_compiler (name, length, language)\n \f\n static char *\n save_string (s, len)\n-  const char *s;\n-  int len;\n+     const char *s;\n+     int len;\n {\n   register char *result = xmalloc (len + 1);\n \n@@ -5762,7 +5769,7 @@ validate_all_switches ()\n     }\n \n   /* Look through the linked list of specs read from the specs file.  */\n-  for (spec = specs; spec ; spec = spec->next)\n+  for (spec = specs; spec; spec = spec->next)\n     {\n       p = *(spec->ptr_spec);\n       while ((c = *p++))\n@@ -5800,7 +5807,8 @@ validate_switches (start)\n     suffix = 1, ++p;\n \n   filter = p;\n-  while (*p != ':' && *p != '}') p++;\n+  while (*p != ':' && *p != '}')\n+    p++;\n \n   if (suffix)\n     ;\n@@ -5850,13 +5858,14 @@ used_arg (p, len)\n       const char *q;\n       int cnt = 0;\n \n-      /* Break multilib_matches into the component strings of string and replacement\n-         string.  */\n+      /* Break multilib_matches into the component strings of string\n+         and replacement string.  */\n       for (q = multilib_matches; *q != '\\0'; q++)\n \tif (*q == ';')\n \t  cnt++;\n \n-      matches = (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);\n+      matches =\n+\t(struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);\n       i = 0;\n       q = multilib_matches;\n       while (*q != '\\0')\n@@ -5921,15 +5930,15 @@ default_arg (p, len)\n {\n   const char *start, *end;\n \n-  for (start = multilib_defaults; *start != '\\0'; start = end+1)\n+  for (start = multilib_defaults; *start != '\\0'; start = end + 1)\n     {\n       while (*start == ' ' || *start == '\\t')\n \tstart++;\n \n       if (*start == '\\0')\n \tbreak;\n \n-      for (end = start+1; *end != ' ' && *end != '\\t' && *end != '\\0'; end++)\n+      for (end = start + 1; *end != ' ' && *end != '\\t' && *end != '\\0'; end++)\n \t;\n \n       if ((end - start) == len && strncmp (p, start, len) == 0)\n@@ -5967,47 +5976,47 @@ set_multilib_dir ()\n     {\n       /* Ignore newlines.  */\n       if (*p == '\\n')\n-        {\n-          ++p;\n-          continue;\n-        }\n+\t{\n+\t  ++p;\n+\t  continue;\n+\t}\n \n       /* Check the arguments.  */\n       ok = 1;\n       while (*p != ';')\n-        {\n-          if (*p == '\\0')\n-            abort ();\n-\n-          if (! ok)\n-            {\n-              ++p;\n-              continue;\n-            }\n-\n-          this_arg = p;\n-          while (*p != ' ' && *p != ';')\n-            {\n-              if (*p == '\\0')\n-                abort ();\n-              ++p;\n-            }\n-\n-          if (*this_arg != '!')\n-            not_arg = 0;\n-          else\n-            {\n-              not_arg = 1;\n-              ++this_arg;\n-            }\n+\t{\n+\t  if (*p == '\\0')\n+\t    abort ();\n+\n+\t  if (! ok)\n+\t    {\n+\t      ++p;\n+\t      continue;\n+\t    }\n+\n+\t  this_arg = p;\n+\t  while (*p != ' ' && *p != ';')\n+\t    {\n+\t      if (*p == '\\0')\n+\t\tabort ();\n+\t      ++p;\n+\t    }\n+\n+\t  if (*this_arg != '!')\n+\t    not_arg = 0;\n+\t  else\n+\t    {\n+\t      not_arg = 1;\n+\t      ++this_arg;\n+\t    }\n \n \t  ok = used_arg (this_arg, p - this_arg);\n \t  if (not_arg)\n \t    ok = ! ok;\n \n-          if (*p == ' ')\n-            ++p;\n-        }\n+\t  if (*p == ' ')\n+\t    ++p;\n+\t}\n \n       if (ok)\n \treturn;\n@@ -6088,7 +6097,7 @@ set_multilib_dir ()\n \t  if (this_path_len != 1\n \t      || this_path[0] != '.')\n \t    {\n-\t      char * new_multilib_dir = xmalloc (this_path_len + 1);\n+\t      char *new_multilib_dir = xmalloc (this_path_len + 1);\n \t      strncpy (new_multilib_dir, this_path, this_path_len);\n \t      new_multilib_dir[this_path_len] = '\\0';\n \t      multilib_dir = new_multilib_dir;\n@@ -6140,99 +6149,99 @@ print_multilib_info ()\n       /* Check for matches with the multilib_exclusions. We don't bother\n          with the '!' in either list. If any of the exclusion rules match\n          all of its options with the select rule, we skip it.  */\n-        {\n-          const char *e = multilib_exclusions;\n-\t  const char *this_arg;\n+      {\n+\tconst char *e = multilib_exclusions;\n+\tconst char *this_arg;\n \n-\t  while (*e != '\\0')\n-\t    {\n-\t      int m = 1;\n-\t      /* Ignore newlines.  */\n-\t      if (*e == '\\n')\n-\t        {\n-\t          ++e;\n-\t          continue;\n-\t        }\n-\n-\t      /* Check the arguments.  */\n-\t      while (*e != ';')\n-\t        {\n-\t\t  const char *q;\n-\t\t  int mp = 0;\n-\n-\t          if (*e == '\\0')\n-\t            abort ();\n-\n-\t\t  if (! m)\n-\t\t    {\n-\t\t      ++e;\n-\t\t      continue;\n-\t\t    }\n+\twhile (*e != '\\0')\n+\t  {\n+\t    int m = 1;\n+\t    /* Ignore newlines.  */\n+\t    if (*e == '\\n')\n+\t      {\n+\t\t++e;\n+\t\tcontinue;\n+\t      }\n \n-\t          this_arg = e;\n+\t    /* Check the arguments.  */\n+\t    while (*e != ';')\n+\t      {\n+\t\tconst char *q;\n+\t\tint mp = 0;\n \n-\t          while (*e != ' ' && *e != ';')\n-\t            {\n-\t              if (*e == '\\0')\n-\t                abort ();\n-\t              ++e;\n-\t            }\n+\t\tif (*e == '\\0')\n+\t\t  abort ();\n \n-  \t\t  q = p + 1;\n-\t\t  while (*q != ';')\n-\t\t    {\n-\t\t      const char *arg;\n-\t\t      int len = e - this_arg;\n+\t\tif (! m)\n+\t\t  {\n+\t\t    ++e;\n+\t\t    continue;\n+\t\t  }\n \n-\t\t      if (*q == '\\0')\n-\t\t\tabort ();\n+\t\tthis_arg = e;\n \n-\t\t      arg = q;\n+\t\twhile (*e != ' ' && *e != ';')\n+\t\t  {\n+\t\t    if (*e == '\\0')\n+\t\t      abort ();\n+\t\t    ++e;\n+\t\t  }\n \n-\t\t      while (*q != ' ' && *q != ';')\n-\t\t\t{\n-\t\t\t  if (*q == '\\0')\n-\t\t\t    abort ();\n-\t\t\t    ++q;\n-\t\t\t}\n+\t\tq = p + 1;\n+\t\twhile (*q != ';')\n+\t\t  {\n+\t\t    const char *arg;\n+\t\t    int len = e - this_arg;\n \n-\t\t      if (! strncmp (arg, this_arg, (len < q - arg) ? q - arg : len) ||\n-\t\t\t  default_arg (this_arg, e - this_arg))\n-\t\t        {\n-\t\t\t  mp = 1;\n-\t\t\t  break;\n-\t\t\t}\n+\t\t    if (*q == '\\0')\n+\t\t      abort ();\n \n-\t\t      if (*q == ' ')\n+\t\t    arg = q;\n+\n+\t\t    while (*q != ' ' && *q != ';')\n+\t\t      {\n+\t\t\tif (*q == '\\0')\n+\t\t\t  abort ();\n \t\t\t++q;\n-\t    \t    }\n+\t\t      }\n+\n+\t\t    if (! strncmp (arg, this_arg, (len < q - arg) ? q - arg : len) ||\n+\t\t\tdefault_arg (this_arg, e - this_arg))\n+\t\t      {\n+\t\t\tmp = 1;\n+\t\t\tbreak;\n+\t\t      }\n \n-\t\t  if (! mp)\n-\t\t    m = 0;\n+\t\t    if (*q == ' ')\n+\t\t      ++q;\n+\t\t  }\n \n-\t          if (*e == ' ')\n-\t            ++e;\n-\t        }\n+\t\tif (! mp)\n+\t\t  m = 0;\n \n-\t      if (m)\n-\t        {\n-\t\t  skip = 1;\n-\t\t  break;\n-\t\t}\n+\t\tif (*e == ' ')\n+\t\t  ++e;\n+\t      }\n \n-\t      if (*e != '\\0')\n-\t\t++e;\n-\t    }\n-\t}\n+\t    if (m)\n+\t      {\n+\t\tskip = 1;\n+\t\tbreak;\n+\t      }\n+\n+\t    if (*e != '\\0')\n+\t      ++e;\n+\t  }\n+      }\n \n       if (! skip)\n-        {\n-          /* If this is a duplicate, skip it.  */\n-          skip = (last_path != 0 && (unsigned int)(p - this_path) == last_path_len\n-                  && ! strncmp (last_path, this_path, last_path_len));\n+\t{\n+\t  /* If this is a duplicate, skip it.  */\n+\t  skip = (last_path != 0 && (unsigned int) (p - this_path) == last_path_len\n+\t\t  && ! strncmp (last_path, this_path, last_path_len));\n \n-          last_path = this_path;\n-          last_path_len = p - this_path;\n+\t  last_path = this_path;\n+\t  last_path_len = p - this_path;\n \t}\n \n       /* If this directory requires any default arguments, we can skip"}]}