{"sha": "16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyMDdkZGQyZWJkYzkzNzlhOGZmOGIyNzRlNGQ4YmIzNWQ0ODVmNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-10T22:01:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-10T22:01:53Z"}, "message": "vr-values.h (VR_INITIALIZER): Move #define here.\n\n\t* vr-values.h (VR_INITIALIZER): Move #define here.\n\t* gimple-ssa-evrp.c: New file with contents extracted from tree-vrp.c\n\t* Makefile.in (OBJS): Add tree-evrp.o\n\t* tree-vrp.h (assert_info): Move structure definition here.\n\t(set_value_range_to_varying): Prototype.\n\t(vrp_operand_equal_p, range_includes_zero_p): Likewise.\n\t(infer_value_range, register_edge_assert_for): Likewise.\n\t(stmt_interesting_for_vrp): Likewise.\n\t* tree-vrp.c: Move all methods for evrp class into tree-evrp.c.\n\t(set_value_range_to_varying): No longer static.\n\t(vrp_operand_equal_p, range_includes_zero_p): Likewise.\n\t(infer_value_range, register_edge_assert_for): Likewise.\n\nFrom-SVN: r254639", "tree": {"sha": "3fcc1f25c5712068aedb4fa4f8da50ef59b400e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fcc1f25c5712068aedb4fa4f8da50ef59b400e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/comments", "author": null, "committer": null, "parents": [{"sha": "54df58853072de7f16cb4a30c3c04c3302ea534d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54df58853072de7f16cb4a30c3c04c3302ea534d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54df58853072de7f16cb4a30c3c04c3302ea534d"}], "stats": {"total": 1266, "additions": 672, "deletions": 594}, "files": [{"sha": "4ff82568cc44e5ff9e53290af383a6d4666e802a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -1,3 +1,18 @@\n+2017-11-10  Jeff Law  <law@redhat.com>\n+\n+\t* vr-values.h (VR_INITIALIZER): Move #define here.\n+\t* gimple-ssa-evrp.c: New file with contents extracted from tree-vrp.c\n+\t* Makefile.in (OBJS): Add tree-evrp.o\n+\t* tree-vrp.h (assert_info): Move structure definition here.\n+\t(set_value_range_to_varying): Prototype.\n+\t(vrp_operand_equal_p, range_includes_zero_p): Likewise.\n+\t(infer_value_range, register_edge_assert_for): Likewise.\n+\t(stmt_interesting_for_vrp): Likewise.\n+\t* tree-vrp.c: Move all methods for evrp class into tree-evrp.c.\n+\t(set_value_range_to_varying): No longer static.\n+\t(vrp_operand_equal_p, range_includes_zero_p): Likewise.\n+\t(infer_value_range, register_edge_assert_for): Likewise.\n+\n 2017-11-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* auto-profile.c (afdo_indirect_call): Drop frequency."}, {"sha": "824cf3e3ea0ae80777974c25693f70835bba4ca8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -1301,6 +1301,7 @@ OBJS = \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-backprop.o \\\n+\tgimple-ssa-evrp.o \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-nonnull-compare.o \\\n \tgimple-ssa-split-paths.o \\"}, {"sha": "13ba31d7cd7f08dae8384ad729fbac6cce726a24", "filename": "gcc/gimple-ssa-evrp.c", "status": "added", "additions": 624, "deletions": 0, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -0,0 +1,624 @@\n+/* Support routines for Value Range Propagation (VRP).\n+   Copyright (C) 2005-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfganal.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"alloc-pool.h\"\n+#include \"domwalk.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"vr-values.h\"\n+\n+class evrp_folder : public substitute_and_fold_engine\n+{\n+ public:\n+  tree get_value (tree) FINAL OVERRIDE;\n+\n+  class vr_values *vr_values;\n+};\n+\n+tree\n+evrp_folder::get_value (tree op)\n+{\n+  return vr_values->op_with_constant_singleton_value_range (op);\n+}\n+\n+/* evrp_dom_walker visits the basic blocks in the dominance order and set\n+   the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n+   discover more VRs.  */\n+\n+class evrp_dom_walker : public dom_walker\n+{\n+public:\n+  evrp_dom_walker ()\n+    : dom_walker (CDI_DOMINATORS), stack (10)\n+    {\n+      need_eh_cleanup = BITMAP_ALLOC (NULL);\n+    }\n+  ~evrp_dom_walker ()\n+    {\n+      BITMAP_FREE (need_eh_cleanup);\n+    }\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+  void push_value_range (tree var, value_range *vr);\n+  value_range *pop_value_range (tree var);\n+  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n+\n+  /* Cond_stack holds the old VR.  */\n+  auto_vec<std::pair <tree, value_range*> > stack;\n+  bitmap need_eh_cleanup;\n+  auto_vec<gimple *> stmts_to_fixup;\n+  auto_vec<gimple *> stmts_to_remove;\n+\n+  class vr_values vr_values;\n+\n+  /* Temporary delegators.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values.get_value_range (op); }\n+  bool update_value_range (const_tree op, value_range *vr)\n+    { return vr_values.update_value_range (op, vr); }\n+  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+    { vr_values.extract_range_from_phi_node (phi, vr); }\n+  void extract_range_for_var_from_comparison_expr (tree var,\n+\t\t\t\t\t\t   enum tree_code cond_code,\n+\t\t\t\t\t\t   tree op, tree limit,\n+\t\t\t\t\t\t   value_range *vr_p)\n+    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n+\t\t\t\t\t\t\t    op, limit, vr_p); }\n+  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n+\t\t\t       gimple *stmt, tree var)\n+    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n+  tree op_with_constant_singleton_value_range (tree op)\n+    { return vr_values.op_with_constant_singleton_value_range (op); }\n+  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+\t\t\t\ttree *output_p, value_range *vr)\n+    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n+  void set_defs_to_varying (gimple *stmt)\n+    { return vr_values.set_defs_to_varying (stmt); }\n+  void set_vr_value (tree name, value_range *vr)\n+    { vr_values.set_vr_value (name, vr); }\n+  void simplify_cond_using_ranges_2 (gcond *stmt)\n+    { vr_values.simplify_cond_using_ranges_2 (stmt); }\n+  void vrp_visit_cond_stmt (gcond *cond, edge *e)\n+    { vr_values.vrp_visit_cond_stmt (cond, e); }\n+};\n+\n+/*  Find new range for NAME such that (OP CODE LIMIT) is true.  */\n+\n+value_range *\n+evrp_dom_walker::try_find_new_range (tree name,\n+\t\t\t\t     tree op, tree_code code, tree limit)\n+{\n+  value_range vr = VR_INITIALIZER;\n+  value_range *old_vr = get_value_range (name);\n+\n+  /* Discover VR when condition is true.  */\n+  extract_range_for_var_from_comparison_expr (name, code, op,\n+\t\t\t\t\t      limit, &vr);\n+  /* If we found any usable VR, set the VR to ssa_name and create a\n+     PUSH old value in the stack with the old VR.  */\n+  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+    {\n+      if (old_vr->type == vr.type\n+\t  && vrp_operand_equal_p (old_vr->min, vr.min)\n+\t  && vrp_operand_equal_p (old_vr->max, vr.max))\n+\treturn NULL;\n+      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n+      *new_vr = vr;\n+      return new_vr;\n+    }\n+  return NULL;\n+}\n+\n+/* See if there is any new scope is entered with new VR and set that VR to\n+   ssa_name before visiting the statements in the scope.  */\n+\n+edge\n+evrp_dom_walker::before_dom_children (basic_block bb)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n+\n+  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+\n+  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n+  if (pred_e)\n+    {\n+      gimple *stmt = last_stmt (pred_e->src);\n+      tree op0 = NULL_TREE;\n+\n+      if (stmt\n+\t  && gimple_code (stmt) == GIMPLE_COND\n+\t  && (op0 = gimple_cond_lhs (stmt))\n+\t  && TREE_CODE (op0) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n+\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Visiting controlling predicate \");\n+\t      print_gimple_stmt (dump_file, stmt, 0);\n+\t    }\n+\t  /* Entering a new scope.  Try to see if we can find a VR\n+\t     here.  */\n+\t  tree op1 = gimple_cond_rhs (stmt);\n+\t  if (TREE_OVERFLOW_P (op1))\n+\t    op1 = drop_tree_overflow (op1);\n+\t  tree_code code = gimple_cond_code (stmt);\n+\n+\t  auto_vec<assert_info, 8> asserts;\n+\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n+\n+\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n+\t  for (unsigned i = 0; i < asserts.length (); ++i)\n+\t    {\n+\t      value_range *vr = try_find_new_range (asserts[i].name,\n+\t\t\t\t\t\t    asserts[i].expr,\n+\t\t\t\t\t\t    asserts[i].comp_code,\n+\t\t\t\t\t\t    asserts[i].val);\n+\t      if (vr)\n+\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n+\t    }\n+\t  /* Push updated ranges only after finding all of them to avoid\n+\t     ordering issues that can lead to worse ranges.  */\n+\t  for (unsigned i = 0; i < vrs.length (); ++i)\n+\t    push_value_range (vrs[i].first, vrs[i].second);\n+\t}\n+    }\n+\n+  /* Visit PHI stmts and discover any new VRs possible.  */\n+  bool has_unvisited_preds = false;\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_EXECUTABLE\n+\t&& !(e->src->flags & BB_VISITED))\n+      {\n+\thas_unvisited_preds = true;\n+\tbreak;\n+      }\n+\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      gphi *phi = gpi.phi ();\n+      tree lhs = PHI_RESULT (phi);\n+      if (virtual_operand_p (lhs))\n+\tcontinue;\n+      value_range vr_result = VR_INITIALIZER;\n+      bool interesting = stmt_interesting_for_vrp (phi);\n+      if (interesting && dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Visiting PHI node \");\n+\t  print_gimple_stmt (dump_file, phi, 0);\n+\t}\n+      if (!has_unvisited_preds\n+\t  && interesting)\n+\textract_range_from_phi_node (phi, &vr_result);\n+      else\n+\t{\n+\t  set_value_range_to_varying (&vr_result);\n+\t  /* When we have an unvisited executable predecessor we can't\n+\t     use PHI arg ranges which may be still UNDEFINED but have\n+\t     to use VARYING for them.  But we can still resort to\n+\t     SCEV for loop header PHIs.  */\n+\t  struct loop *l;\n+\t  if (interesting\n+\t      && (l = loop_containing_stmt (phi))\n+\t      && l->header == gimple_bb (phi))\n+\t    adjust_range_with_scev (&vr_result, l, phi, lhs);\n+\t}\n+      update_value_range (lhs, &vr_result);\n+\n+      /* Mark PHIs whose lhs we fully propagate for removal.  */\n+      tree val = op_with_constant_singleton_value_range (lhs);\n+      if (val && may_propagate_copy (lhs, val))\n+\t{\n+\t  stmts_to_remove.safe_push (phi);\n+\t  continue;\n+\t}\n+\n+      /* Set the SSA with the value range.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  if ((vr_result.type == VR_RANGE\n+\t       || vr_result.type == VR_ANTI_RANGE)\n+\t      && (TREE_CODE (vr_result.min) == INTEGER_CST)\n+\t      && (TREE_CODE (vr_result.max) == INTEGER_CST))\n+\t    set_range_info (lhs, vr_result.type,\n+\t\t\t    wi::to_wide (vr_result.min),\n+\t\t\t    wi::to_wide (vr_result.max));\n+\t}\n+      else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t       && ((vr_result.type == VR_RANGE\n+\t\t    && range_includes_zero_p (vr_result.min,\n+\t\t\t\t\t      vr_result.max) == 0)\n+\t\t   || (vr_result.type == VR_ANTI_RANGE\n+\t\t       && range_includes_zero_p (vr_result.min,\n+\t\t\t\t\t\t vr_result.max) == 1)))\n+\tset_ptr_nonnull (lhs);\n+    }\n+\n+  edge taken_edge = NULL;\n+\n+  /* Visit all other stmts and discover any new VRs possible.  */\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      tree output = NULL_TREE;\n+      gimple *old_stmt = stmt;\n+      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_noreturn_p (stmt));\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Visiting stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t}\n+\n+      if (gcond *cond = dyn_cast <gcond *> (stmt))\n+\t{\n+\t  vrp_visit_cond_stmt (cond, &taken_edge);\n+\t  if (taken_edge)\n+\t    {\n+\t      if (taken_edge->flags & EDGE_TRUE_VALUE)\n+\t\tgimple_cond_make_true (cond);\n+\t      else if (taken_edge->flags & EDGE_FALSE_VALUE)\n+\t\tgimple_cond_make_false (cond);\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+      else if (stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge taken_edge;\n+\t  value_range vr = VR_INITIALIZER;\n+\t  extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+\t  if (output\n+\t      && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n+\t    {\n+\t      update_value_range (output, &vr);\n+\t      vr = *get_value_range (output);\n+\n+\t      /* Mark stmts whose output we fully propagate for removal.  */\n+\t      tree val;\n+\t      if ((val = op_with_constant_singleton_value_range (output))\n+\t\t  && may_propagate_copy (output, val)\n+\t\t  && !stmt_could_throw_p (stmt)\n+\t\t  && !gimple_has_side_effects (stmt))\n+\t\t{\n+\t\t  stmts_to_remove.safe_push (stmt);\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Set the SSA with the value range.  */\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n+\t\t{\n+\t\t  if ((vr.type == VR_RANGE\n+\t\t       || vr.type == VR_ANTI_RANGE)\n+\t\t      && (TREE_CODE (vr.min) == INTEGER_CST)\n+\t\t      && (TREE_CODE (vr.max) == INTEGER_CST))\n+\t\t    set_range_info (output, vr.type,\n+\t\t\t\t    wi::to_wide (vr.min),\n+\t\t\t\t    wi::to_wide (vr.max));\n+\t\t}\n+\t      else if (POINTER_TYPE_P (TREE_TYPE (output))\n+\t\t       && ((vr.type == VR_RANGE\n+\t\t\t    && range_includes_zero_p (vr.min,\n+\t\t\t\t\t\t      vr.max) == 0)\n+\t\t\t   || (vr.type == VR_ANTI_RANGE\n+\t\t\t       && range_includes_zero_p (vr.min,\n+\t\t\t\t\t\t\t vr.max) == 1)))\n+\t\tset_ptr_nonnull (output);\n+\t    }\n+\t  else\n+\t    set_defs_to_varying (stmt);\n+\t}\n+      else\n+\tset_defs_to_varying (stmt);\n+\n+      /* See if we can derive a range for any of STMT's operands.  */\n+      tree op;\n+      ssa_op_iter i;\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+\t{\n+\t  tree value;\n+\t  enum tree_code comp_code;\n+\n+\t  /* If OP is used in such a way that we can infer a value\n+\t     range for it, and we don't find a previous assertion for\n+\t     it, create a new assertion location node for OP.  */\n+\t  if (infer_value_range (stmt, op, &comp_code, &value))\n+\t    {\n+\t      /* If we are able to infer a nonzero value range for OP,\n+\t\t then walk backwards through the use-def chain to see if OP\n+\t\t was set via a typecast.\n+\t\t If so, then we can also infer a nonzero value range\n+\t\t for the operand of the NOP_EXPR.  */\n+\t      if (comp_code == NE_EXPR && integer_zerop (value))\n+\t\t{\n+\t\t  tree t = op;\n+\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n+\t\t  while (is_gimple_assign (def_stmt)\n+\t\t\t && CONVERT_EXPR_CODE_P\n+\t\t\t      (gimple_assign_rhs_code (def_stmt))\n+\t\t\t && TREE_CODE\n+\t\t\t      (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n+\t\t\t && POINTER_TYPE_P\n+\t\t\t      (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n+\t\t    {\n+\t\t      t = gimple_assign_rhs1 (def_stmt);\n+\t\t      def_stmt = SSA_NAME_DEF_STMT (t);\n+\n+\t\t      /* Add VR when (T COMP_CODE value) condition is\n+\t\t\t true.  */\n+\t\t      value_range *op_range\n+\t\t\t= try_find_new_range (t, t, comp_code, value);\n+\t\t      if (op_range)\n+\t\t\tpush_value_range (t, op_range);\n+\t\t    }\n+\t\t}\n+\t      /* Add VR when (OP COMP_CODE value) condition is true.  */\n+\t      value_range *op_range = try_find_new_range (op, op,\n+\t\t\t\t\t\t\t  comp_code, value);\n+\t      if (op_range)\n+\t\tpush_value_range (op, op_range);\n+\t    }\n+\t}\n+\n+      /* Try folding stmts with the VR discovered.  */\n+      class evrp_folder evrp_folder;\n+      evrp_folder.vr_values = &vr_values;\n+      bool did_replace = evrp_folder.replace_uses_in (stmt);\n+      if (fold_stmt (&gsi, follow_single_use_edges)\n+\t  || did_replace)\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  update_stmt (stmt);\n+\t  did_replace = true;\n+\t}\n+\n+      if (did_replace)\n+\t{\n+\t  /* If we cleaned up EH information from the statement,\n+\t     remove EH edges.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\t    bitmap_set_bit (need_eh_cleanup, bb->index);\n+\n+\t  /* If we turned a not noreturn call into a noreturn one\n+\t     schedule it for fixup.  */\n+\t  if (!was_noreturn\n+\t      && is_gimple_call (stmt)\n+\t      && gimple_call_noreturn_p (stmt))\n+\t    stmts_to_fixup.safe_push (stmt);\n+\n+\t  if (gimple_assign_single_p (stmt))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t\trecompute_tree_invariant_for_addr_expr (rhs);\n+\t    }\n+\t}\n+    }\n+\n+  /* Visit BB successor PHI nodes and replace PHI args.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      for (gphi_iterator gpi = gsi_start_phis (e->dest);\n+\t   !gsi_end_p (gpi); gsi_next (&gpi))\n+\t{\n+\t  gphi *phi = gpi.phi ();\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  tree arg = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (arg) != SSA_NAME\n+\t      || virtual_operand_p (arg))\n+\t    continue;\n+\t  tree val = op_with_constant_singleton_value_range (arg);\n+\t  if (val && may_propagate_copy (arg, val))\n+\t    propagate_value (use_p, val);\n+\t}\n+    }\n+ \n+  bb->flags |= BB_VISITED;\n+\n+  return taken_edge;\n+}\n+\n+/* Restore/pop VRs valid only for BB when we leave BB.  */\n+\n+void\n+evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  gcc_checking_assert (!stack.is_empty ());\n+  while (stack.last ().first != NULL_TREE)\n+    pop_value_range (stack.last ().first);\n+  stack.pop ();\n+}\n+\n+/* Push the Value Range of VAR to the stack and update it with new VR.  */\n+\n+void\n+evrp_dom_walker::push_value_range (tree var, value_range *vr)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"pushing new range for \");\n+      print_generic_expr (dump_file, var);\n+      fprintf (dump_file, \": \");\n+      dump_value_range (dump_file, vr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  stack.safe_push (std::make_pair (var, get_value_range (var)));\n+  set_vr_value (var, vr);\n+}\n+\n+/* Pop the Value Range from the vrp_stack and update VAR with it.  */\n+\n+value_range *\n+evrp_dom_walker::pop_value_range (tree var)\n+{\n+  value_range *vr = stack.last ().second;\n+  gcc_checking_assert (var == stack.last ().first);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"popping range for \");\n+      print_generic_expr (dump_file, var);\n+      fprintf (dump_file, \", restoring \");\n+      dump_value_range (dump_file, vr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  set_vr_value (var, vr);\n+  stack.pop ();\n+  return vr;\n+}\n+\n+\n+/* Main entry point for the early vrp pass which is a simplified non-iterative\n+   version of vrp where basic blocks are visited in dominance order.  Value\n+   ranges discovered in early vrp will also be used by ipa-vrp.  */\n+\n+static unsigned int\n+execute_early_vrp ()\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block bb;\n+\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  scev_initialize ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bb->flags &= ~BB_VISITED;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+\n+  /* Walk stmts in dominance order and propagate VRP.  */\n+  evrp_dom_walker walker;\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n+      walker.vr_values.dump_all_value_ranges (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* Remove stmts in reverse order to make debug stmt creation possible.  */\n+  while (! walker.stmts_to_remove.is_empty ())\n+    {\n+      gimple *stmt = walker.stmts_to_remove.pop ();\n+      if (dump_file && dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Removing dead stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n+\t{\n+\t  unlink_stmt_vdef (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t}\n+    }\n+\n+  if (!bitmap_empty_p (walker.need_eh_cleanup))\n+    gimple_purge_all_dead_eh_edges (walker.need_eh_cleanup);\n+\n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!walker.stmts_to_fixup.is_empty ())\n+    {\n+      gimple *stmt = walker.stmts_to_fixup.pop ();\n+      fixup_noreturn_call (stmt);\n+    }\n+\n+  scev_finalize ();\n+  loop_optimizer_finalize ();\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_early_vrp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"evrp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_EARLY_VRP, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa | TODO_verify_all ),\n+};\n+\n+class pass_early_vrp : public gimple_opt_pass\n+{\n+public:\n+  pass_early_vrp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_vrp, ctxt)\n+    {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_early_vrp (m_ctxt); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_tree_vrp != 0;\n+    }\n+  virtual unsigned int execute (function *)\n+    { return execute_early_vrp (); }\n+\n+}; // class pass_vrp\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_vrp (gcc::context *ctxt)\n+{\n+  return new pass_early_vrp (ctxt);\n+}\n+"}, {"sha": "6fae6b2efb84ddb2fdd2a4a480df74f8bb0b321f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 594, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -66,8 +66,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"vr-values.h\"\n \n-#define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n-\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n@@ -85,21 +83,6 @@ live_on_edge (edge e, tree name)\n static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n \n-struct assert_info\n-{\n-  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n-  enum tree_code comp_code;\n-\n-  /* Name to register the assert for.  */\n-  tree name;\n-\n-  /* Value being compared against.  */\n-  tree val;\n-\n-  /* Expression to compare.  */\n-  tree expr;\n-};\n-\n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n    SSA name may have more than one assertion associated with it, these\n@@ -207,10 +190,9 @@ set_value_range_to_undefined (value_range *vr)\n     bitmap_clear (vr->equiv);\n }\n \n-\n /* Set value range VR to VR_VARYING.  */\n \n-static inline void\n+void\n set_value_range_to_varying (value_range *vr)\n {\n   vr->type = VR_VARYING;\n@@ -219,7 +201,6 @@ set_value_range_to_varying (value_range *vr)\n     bitmap_clear (vr->equiv);\n }\n \n-\n /* Set value range VR to {T, MIN, MAX, EQUIV}.  */\n \n static void\n@@ -582,7 +563,7 @@ vr_values::set_defs_to_varying (gimple *stmt)\n \n /* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n \n-static inline bool\n+bool\n vrp_operand_equal_p (const_tree val1, const_tree val2)\n {\n   if (val1 == val2)\n@@ -1201,7 +1182,7 @@ value_ranges_intersect_p (value_range *vr0, value_range *vr1)\n /* Return 1 if [MIN, MAX] includes the value zero, 0 if it does not\n    include the value zero, -2 if we cannot tell.  */\n \n-static inline int\n+int\n range_includes_zero_p (tree min, tree max)\n {\n   tree zero = build_int_cst (TREE_TYPE (min), 0);\n@@ -4524,7 +4505,7 @@ fp_predicate (gimple *stmt)\n    describes the inferred range.  Return true if a range could be\n    inferred.  */\n \n-static bool\n+bool\n infer_value_range (gimple *stmt, tree op, tree_code *comp_code_p, tree *val_p)\n {\n   *val_p = NULL_TREE;\n@@ -5696,7 +5677,7 @@ is_masked_range_test (tree name, tree valt, enum tree_code cond_code,\n    the condition COND contributing to the conditional jump pointed to by\n    SI.  */\n \n-static void\n+void\n register_edge_assert_for (tree name, edge e,\n \t\t\t  enum tree_code cond_code, tree cond_op0,\n \t\t\t  tree cond_op1, vec<assert_info> &asserts)\n@@ -7072,7 +7053,7 @@ remove_range_assertions (void)\n \n /* Return true if STMT is interesting for VRP.  */\n \n-static bool\n+bool\n stmt_interesting_for_vrp (gimple *stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_PHI)\n@@ -10920,423 +10901,6 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n     check_all_array_refs ();\n }\n \n-/* evrp_dom_walker visits the basic blocks in the dominance order and set\n-   the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n-   discover more VRs.  */\n-\n-class evrp_dom_walker : public dom_walker\n-{\n-public:\n-  evrp_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS), stack (10)\n-    {\n-      need_eh_cleanup = BITMAP_ALLOC (NULL);\n-    }\n-  ~evrp_dom_walker ()\n-    {\n-      BITMAP_FREE (need_eh_cleanup);\n-    }\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-  void push_value_range (tree var, value_range *vr);\n-  value_range *pop_value_range (tree var);\n-  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n-\n-  /* Cond_stack holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range*> > stack;\n-  bitmap need_eh_cleanup;\n-  auto_vec<gimple *> stmts_to_fixup;\n-  auto_vec<gimple *> stmts_to_remove;\n-\n-  class vr_values vr_values;\n-\n-  /* Temporary delegators.  */\n-  value_range *get_value_range (const_tree op)\n-    { return vr_values.get_value_range (op); }\n-  bool update_value_range (const_tree op, value_range *vr)\n-    { return vr_values.update_value_range (op, vr); }\n-  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n-    { vr_values.extract_range_from_phi_node (phi, vr); }\n-  void extract_range_for_var_from_comparison_expr (tree var,\n-\t\t\t\t\t\t   enum tree_code cond_code,\n-\t\t\t\t\t\t   tree op, tree limit,\n-\t\t\t\t\t\t   value_range *vr_p)\n-    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n-\t\t\t\t\t\t\t    op, limit, vr_p); }\n-  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n-\t\t\t       gimple *stmt, tree var)\n-    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n-  tree op_with_constant_singleton_value_range (tree op)\n-    { return vr_values.op_with_constant_singleton_value_range (op); }\n-  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\ttree *output_p, value_range *vr)\n-    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  void set_defs_to_varying (gimple *stmt)\n-    { return vr_values.set_defs_to_varying (stmt); }\n-  void set_vr_value (tree name, value_range *vr)\n-    { vr_values.set_vr_value (name, vr); }\n-  void simplify_cond_using_ranges_2 (gcond *stmt)\n-    { vr_values.simplify_cond_using_ranges_2 (stmt); }\n-  void vrp_visit_cond_stmt (gcond *cond, edge *e)\n-    { vr_values.vrp_visit_cond_stmt (cond, e); }\n-};\n-\n-/*  Find new range for NAME such that (OP CODE LIMIT) is true.  */\n-\n-value_range *\n-evrp_dom_walker::try_find_new_range (tree name,\n-\t\t\t\t     tree op, tree_code code, tree limit)\n-{\n-  value_range vr = VR_INITIALIZER;\n-  value_range *old_vr = get_value_range (name);\n-\n-  /* Discover VR when condition is true.  */\n-  extract_range_for_var_from_comparison_expr (name, code, op,\n-\t\t\t\t\t      limit, &vr);\n-  /* If we found any usable VR, set the VR to ssa_name and create a\n-     PUSH old value in the stack with the old VR.  */\n-  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n-    {\n-      if (old_vr->type == vr.type\n-\t  && vrp_operand_equal_p (old_vr->min, vr.min)\n-\t  && vrp_operand_equal_p (old_vr->max, vr.max))\n-\treturn NULL;\n-      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n-      *new_vr = vr;\n-      return new_vr;\n-    }\n-  return NULL;\n-}\n-\n-/* See if there is any new scope is entered with new VR and set that VR to\n-   ssa_name before visiting the statements in the scope.  */\n-\n-edge\n-evrp_dom_walker::before_dom_children (basic_block bb)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n-\n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n-\n-  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n-  if (pred_e)\n-    {\n-      gimple *stmt = last_stmt (pred_e->src);\n-      tree op0 = NULL_TREE;\n-\n-      if (stmt\n-\t  && gimple_code (stmt) == GIMPLE_COND\n-\t  && (op0 = gimple_cond_lhs (stmt))\n-\t  && TREE_CODE (op0) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n-\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Visiting controlling predicate \");\n-\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t    }\n-\t  /* Entering a new scope.  Try to see if we can find a VR\n-\t     here.  */\n-\t  tree op1 = gimple_cond_rhs (stmt);\n-\t  if (TREE_OVERFLOW_P (op1))\n-\t    op1 = drop_tree_overflow (op1);\n-\t  tree_code code = gimple_cond_code (stmt);\n-\n-\t  auto_vec<assert_info, 8> asserts;\n-\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n-\n-\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n-\t  for (unsigned i = 0; i < asserts.length (); ++i)\n-\t    {\n-\t      value_range *vr = try_find_new_range (asserts[i].name,\n-\t\t\t\t\t\t    asserts[i].expr,\n-\t\t\t\t\t\t    asserts[i].comp_code,\n-\t\t\t\t\t\t    asserts[i].val);\n-\t      if (vr)\n-\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n-\t    }\n-\t  /* Push updated ranges only after finding all of them to avoid\n-\t     ordering issues that can lead to worse ranges.  */\n-\t  for (unsigned i = 0; i < vrs.length (); ++i)\n-\t    push_value_range (vrs[i].first, vrs[i].second);\n-\t}\n-    }\n-\n-  /* Visit PHI stmts and discover any new VRs possible.  */\n-  bool has_unvisited_preds = false;\n-  edge_iterator ei;\n-  edge e;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_EXECUTABLE\n-\t&& !(e->src->flags & BB_VISITED))\n-      {\n-\thas_unvisited_preds = true;\n-\tbreak;\n-      }\n-\n-  for (gphi_iterator gpi = gsi_start_phis (bb);\n-       !gsi_end_p (gpi); gsi_next (&gpi))\n-    {\n-      gphi *phi = gpi.phi ();\n-      tree lhs = PHI_RESULT (phi);\n-      if (virtual_operand_p (lhs))\n-\tcontinue;\n-      value_range vr_result = VR_INITIALIZER;\n-      bool interesting = stmt_interesting_for_vrp (phi);\n-      if (interesting && dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Visiting PHI node \");\n-\t  print_gimple_stmt (dump_file, phi, 0);\n-\t}\n-      if (!has_unvisited_preds\n-\t  && interesting)\n-\textract_range_from_phi_node (phi, &vr_result);\n-      else\n-\t{\n-\t  set_value_range_to_varying (&vr_result);\n-\t  /* When we have an unvisited executable predecessor we can't\n-\t     use PHI arg ranges which may be still UNDEFINED but have\n-\t     to use VARYING for them.  But we can still resort to\n-\t     SCEV for loop header PHIs.  */\n-\t  struct loop *l;\n-\t  if (interesting\n-\t      && (l = loop_containing_stmt (phi))\n-\t      && l->header == gimple_bb (phi))\n-\t    adjust_range_with_scev (&vr_result, l, phi, lhs);\n-\t}\n-      update_value_range (lhs, &vr_result);\n-\n-      /* Mark PHIs whose lhs we fully propagate for removal.  */\n-      tree val = op_with_constant_singleton_value_range (lhs);\n-      if (val && may_propagate_copy (lhs, val))\n-\t{\n-\t  stmts_to_remove.safe_push (phi);\n-\t  continue;\n-\t}\n-\n-      /* Set the SSA with the value range.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-\t{\n-\t  if ((vr_result.type == VR_RANGE\n-\t       || vr_result.type == VR_ANTI_RANGE)\n-\t      && (TREE_CODE (vr_result.min) == INTEGER_CST)\n-\t      && (TREE_CODE (vr_result.max) == INTEGER_CST))\n-\t    set_range_info (lhs, vr_result.type,\n-\t\t\t    wi::to_wide (vr_result.min),\n-\t\t\t    wi::to_wide (vr_result.max));\n-\t}\n-      else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t       && ((vr_result.type == VR_RANGE\n-\t\t    && range_includes_zero_p (vr_result.min,\n-\t\t\t\t\t      vr_result.max) == 0)\n-\t\t   || (vr_result.type == VR_ANTI_RANGE\n-\t\t       && range_includes_zero_p (vr_result.min,\n-\t\t\t\t\t\t vr_result.max) == 1)))\n-\tset_ptr_nonnull (lhs);\n-    }\n-\n-  edge taken_edge = NULL;\n-\n-  /* Visit all other stmts and discover any new VRs possible.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n-       !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      tree output = NULL_TREE;\n-      gimple *old_stmt = stmt;\n-      bool was_noreturn = (is_gimple_call (stmt)\n-\t\t\t   && gimple_call_noreturn_p (stmt));\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Visiting stmt \");\n-\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t}\n-\n-      if (gcond *cond = dyn_cast <gcond *> (stmt))\n-\t{\n-\t  vrp_visit_cond_stmt (cond, &taken_edge);\n-\t  if (taken_edge)\n-\t    {\n-\t      if (taken_edge->flags & EDGE_TRUE_VALUE)\n-\t\tgimple_cond_make_true (cond);\n-\t      else if (taken_edge->flags & EDGE_FALSE_VALUE)\n-\t\tgimple_cond_make_false (cond);\n-\t      else\n-\t\tgcc_unreachable ();\n-\t      update_stmt (stmt);\n-\t    }\n-\t}\n-      else if (stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge taken_edge;\n-\t  value_range vr = VR_INITIALIZER;\n-\t  extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n-\t  if (output\n-\t      && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n-\t    {\n-\t      update_value_range (output, &vr);\n-\t      vr = *get_value_range (output);\n-\n-\t      /* Mark stmts whose output we fully propagate for removal.  */\n-\t      tree val;\n-\t      if ((val = op_with_constant_singleton_value_range (output))\n-\t\t  && may_propagate_copy (output, val)\n-\t\t  && !stmt_could_throw_p (stmt)\n-\t\t  && !gimple_has_side_effects (stmt))\n-\t\t{\n-\t\t  stmts_to_remove.safe_push (stmt);\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Set the SSA with the value range.  */\n-\t      if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n-\t\t{\n-\t\t  if ((vr.type == VR_RANGE\n-\t\t       || vr.type == VR_ANTI_RANGE)\n-\t\t      && (TREE_CODE (vr.min) == INTEGER_CST)\n-\t\t      && (TREE_CODE (vr.max) == INTEGER_CST))\n-\t\t    set_range_info (output, vr.type,\n-\t\t\t\t    wi::to_wide (vr.min),\n-\t\t\t\t    wi::to_wide (vr.max));\n-\t\t}\n-\t      else if (POINTER_TYPE_P (TREE_TYPE (output))\n-\t\t       && ((vr.type == VR_RANGE\n-\t\t\t    && range_includes_zero_p (vr.min,\n-\t\t\t\t\t\t      vr.max) == 0)\n-\t\t\t   || (vr.type == VR_ANTI_RANGE\n-\t\t\t       && range_includes_zero_p (vr.min,\n-\t\t\t\t\t\t\t vr.max) == 1)))\n-\t\tset_ptr_nonnull (output);\n-\t    }\n-\t  else\n-\t    set_defs_to_varying (stmt);\n-\t}\n-      else\n-\tset_defs_to_varying (stmt);\n-\n-      /* See if we can derive a range for any of STMT's operands.  */\n-      tree op;\n-      ssa_op_iter i;\n-      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-\t{\n-\t  tree value;\n-\t  enum tree_code comp_code;\n-\n-\t  /* If OP is used in such a way that we can infer a value\n-\t     range for it, and we don't find a previous assertion for\n-\t     it, create a new assertion location node for OP.  */\n-\t  if (infer_value_range (stmt, op, &comp_code, &value))\n-\t    {\n-\t      /* If we are able to infer a nonzero value range for OP,\n-\t\t then walk backwards through the use-def chain to see if OP\n-\t\t was set via a typecast.\n-\t\t If so, then we can also infer a nonzero value range\n-\t\t for the operand of the NOP_EXPR.  */\n-\t      if (comp_code == NE_EXPR && integer_zerop (value))\n-\t\t{\n-\t\t  tree t = op;\n-\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n-\t\t  while (is_gimple_assign (def_stmt)\n-\t\t\t && CONVERT_EXPR_CODE_P\n-\t\t\t      (gimple_assign_rhs_code (def_stmt))\n-\t\t\t && TREE_CODE\n-\t\t\t      (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n-\t\t\t && POINTER_TYPE_P\n-\t\t\t      (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n-\t\t    {\n-\t\t      t = gimple_assign_rhs1 (def_stmt);\n-\t\t      def_stmt = SSA_NAME_DEF_STMT (t);\n-\n-\t\t      /* Add VR when (T COMP_CODE value) condition is\n-\t\t\t true.  */\n-\t\t      value_range *op_range\n-\t\t\t= try_find_new_range (t, t, comp_code, value);\n-\t\t      if (op_range)\n-\t\t\tpush_value_range (t, op_range);\n-\t\t    }\n-\t\t}\n-\t      /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t      value_range *op_range = try_find_new_range (op, op,\n-\t\t\t\t\t\t\t  comp_code, value);\n-\t      if (op_range)\n-\t\tpush_value_range (op, op_range);\n-\t    }\n-\t}\n-\n-      /* Try folding stmts with the VR discovered.  */\n-      class vrp_folder vrp_folder;\n-      vrp_folder.vr_values = &vr_values;\n-      bool did_replace = vrp_folder.replace_uses_in (stmt);\n-      if (fold_stmt (&gsi, follow_single_use_edges)\n-\t  || did_replace)\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  update_stmt (stmt);\n-\t  did_replace = true;\n-\t}\n-\n-      if (did_replace)\n-\t{\n-\t  /* If we cleaned up EH information from the statement,\n-\t     remove EH edges.  */\n-\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n-\t    bitmap_set_bit (need_eh_cleanup, bb->index);\n-\n-\t  /* If we turned a not noreturn call into a noreturn one\n-\t     schedule it for fixup.  */\n-\t  if (!was_noreturn\n-\t      && is_gimple_call (stmt)\n-\t      && gimple_call_noreturn_p (stmt))\n-\t    stmts_to_fixup.safe_push (stmt);\n-\n-\t  if (gimple_assign_single_p (stmt))\n-\t    {\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t\trecompute_tree_invariant_for_addr_expr (rhs);\n-\t    }\n-\t}\n-    }\n-\n-  /* Visit BB successor PHI nodes and replace PHI args.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      for (gphi_iterator gpi = gsi_start_phis (e->dest);\n-\t   !gsi_end_p (gpi); gsi_next (&gpi))\n-\t{\n-\t  gphi *phi = gpi.phi ();\n-\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  tree arg = USE_FROM_PTR (use_p);\n-\t  if (TREE_CODE (arg) != SSA_NAME\n-\t      || virtual_operand_p (arg))\n-\t    continue;\n-\t  tree val = op_with_constant_singleton_value_range (arg);\n-\t  if (val && may_propagate_copy (arg, val))\n-\t    propagate_value (use_p, val);\n-\t}\n-    }\n- \n-  bb->flags |= BB_VISITED;\n-\n-  return taken_edge;\n-}\n-\n-/* Restore/pop VRs valid only for BB when we leave BB.  */\n-\n-void\n-evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  gcc_checking_assert (!stack.is_empty ());\n-  while (stack.last ().first != NULL_TREE)\n-    pop_value_range (stack.last ().first);\n-  stack.pop ();\n-}\n-\n void\n vr_values::set_vr_value (tree var, value_range *vr)\n {\n@@ -11345,117 +10909,6 @@ vr_values::set_vr_value (tree var, value_range *vr)\n   vr_value[SSA_NAME_VERSION (var)] = vr;\n }\n \n-/* Push the Value Range of VAR to the stack and update it with new VR.  */\n-\n-void\n-evrp_dom_walker::push_value_range (tree var, value_range *vr)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"pushing new range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \": \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  stack.safe_push (std::make_pair (var, get_value_range (var)));\n-  set_vr_value (var, vr);\n-}\n-\n-/* Pop the Value Range from the vrp_stack and update VAR with it.  */\n-\n-value_range *\n-evrp_dom_walker::pop_value_range (tree var)\n-{\n-  value_range *vr = stack.last ().second;\n-  gcc_checking_assert (var == stack.last ().first);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"popping range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \", restoring \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  set_vr_value (var, vr);\n-  stack.pop ();\n-  return vr;\n-}\n-\n-\n-/* Main entry point for the early vrp pass which is a simplified non-iterative\n-   version of vrp where basic blocks are visited in dominance order.  Value\n-   ranges discovered in early vrp will also be used by ipa-vrp.  */\n-\n-static unsigned int\n-execute_early_vrp ()\n-{\n-  edge e;\n-  edge_iterator ei;\n-  basic_block bb;\n-\n-  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-  scev_initialize ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bb->flags &= ~BB_VISITED;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\te->flags |= EDGE_EXECUTABLE;\n-    }\n-\n-  /* Walk stmts in dominance order and propagate VRP.  */\n-  evrp_dom_walker walker;\n-  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-      walker.vr_values.dump_all_value_ranges (dump_file);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* Remove stmts in reverse order to make debug stmt creation possible.  */\n-  while (! walker.stmts_to_remove.is_empty ())\n-    {\n-      gimple *stmt = walker.stmts_to_remove.pop ();\n-      if (dump_file && dump_flags & TDF_DETAILS)\n-\t{\n-\t  fprintf (dump_file, \"Removing dead stmt \");\n-\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tremove_phi_node (&gsi, true);\n-      else\n-\t{\n-\t  unlink_stmt_vdef (stmt);\n-\t  gsi_remove (&gsi, true);\n-\t  release_defs (stmt);\n-\t}\n-    }\n-\n-  if (!bitmap_empty_p (walker.need_eh_cleanup))\n-    gimple_purge_all_dead_eh_edges (walker.need_eh_cleanup);\n-\n-  /* Fixup stmts that became noreturn calls.  This may require splitting\n-     blocks and thus isn't possible during the dominator walk.  Do this\n-     in reverse order so we don't inadvertedly remove a stmt we want to\n-     fixup by visiting a dominating now noreturn call first.  */\n-  while (!walker.stmts_to_fixup.is_empty ())\n-    {\n-      gimple *stmt = walker.stmts_to_fixup.pop ();\n-      fixup_noreturn_call (stmt);\n-    }\n-\n-  scev_finalize ();\n-  loop_optimizer_finalize ();\n-  return 0;\n-}\n-\n-\n /* Main entry point to VRP (Value Range Propagation).  This pass is\n    loosely based on J. R. C. Patterson, ``Accurate Static Branch\n    Prediction by Value Range Propagation,'' in SIGPLAN Conference on\n@@ -11649,44 +11102,3 @@ make_pass_vrp (gcc::context *ctxt)\n {\n   return new pass_vrp (ctxt);\n }\n-\n-namespace {\n-\n-const pass_data pass_data_early_vrp =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"evrp\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_EARLY_VRP, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_update_ssa | TODO_verify_all ),\n-};\n-\n-class pass_early_vrp : public gimple_opt_pass\n-{\n-public:\n-  pass_early_vrp (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_early_vrp, ctxt)\n-    {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_early_vrp (m_ctxt); }\n-  virtual bool gate (function *)\n-    {\n-      return flag_tree_vrp != 0;\n-    }\n-  virtual unsigned int execute (function *)\n-    { return execute_early_vrp (); }\n-\n-}; // class pass_vrp\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_early_vrp (gcc::context *ctxt)\n-{\n-  return new pass_early_vrp (ctxt);\n-}\n-"}, {"sha": "455a9ac9252d858d18320ef7183c98594812dd4a", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -60,4 +60,28 @@ extern void extract_range_from_unary_expr (value_range *vr,\n \t\t\t\t\t   value_range *vr0_,\n \t\t\t\t\t   tree op0_type);\n \n+extern bool vrp_operand_equal_p (const_tree, const_tree);\n+\n+struct assert_info\n+{\n+  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n+  enum tree_code comp_code;\n+\n+  /* Name to register the assert for.  */\n+  tree name;\n+\n+  /* Value being compared against.  */\n+  tree val;\n+\n+  /* Expression to compare.  */\n+  tree expr;\n+};\n+\n+extern void register_edge_assert_for (tree, edge, enum tree_code,\n+\t\t\t\t      tree, tree, vec<assert_info> &);\n+extern bool stmt_interesting_for_vrp (gimple *);\n+extern void set_value_range_to_varying (value_range *);\n+extern int range_includes_zero_p (tree, tree);\n+extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n+\n #endif /* GCC_TREE_VRP_H */"}, {"sha": "20bd6c57a6ce7be5d7c316b6e8e2e3b975edbecb", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=16207ddd2ebdc9379a8ff8b274e4d8bb35d485f5", "patch": "@@ -116,4 +116,6 @@ class vr_values\n   bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n };\n \n+#define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n+\n #endif /* GCC_VR_VALUES_H */"}]}