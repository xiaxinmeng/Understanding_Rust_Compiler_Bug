{"sha": "41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmM2E5MzA3YTVhYTNkYjc4OWYxMzExZTA0ZmIyNGE2Zjg4MDdiMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-03-11T20:40:54Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-03-11T20:40:54Z"}, "message": "tm.texi (Frame Registers): Document DWARF_REG_TO_UNWIND_COLUMN.\n\n2003-03-11  Aldy Hernandez  <aldyh@redhat.com>\n\n        * doc/tm.texi (Frame Registers): Document DWARF_REG_TO_UNWIND_COLUMN.\n\n        * unwind-dw2.c (DWARF_REG_TO_UNWIND_COLUMN): Define.\n        (_Unwind_GetGR): Use DWARF_REG_TO_UNWIND_COLUMN.\n        (_Unwind_SetGR): Same.\n        (_Unwind_GetGRPtr): New.\n        (_Unwind_SetGRPtr): New.\n        (uw_update_context_1): Use accesor functions instead of accessing\n        context->reg[] directly.\n        (uw_install_context_1): Same.\n        (execute_cfa_program): Same.\n        (__frame_state_for): Same.\n\n        * config/rs6000/rs6000.c (spe_synthesize_frame_save): Use 1200 as\n        the synthetic register offset.\n\n        * config/rs6000/rs6000.h (DWARF_REG_TO_UNWIND_COLUMN): New.\n\nFrom-SVN: r64186", "tree": {"sha": "66d6d1fc63e82c5c7607b7557e4158015da4dca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66d6d1fc63e82c5c7607b7557e4158015da4dca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8e6c64afcc492a3b124a229e9b7774e032fdb9"}], "stats": {"total": 116, "additions": 93, "deletions": 23}, "files": [{"sha": "d488b35612a74a9ab53e15e53a1ef44a9f7599fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "patch": "@@ -1,3 +1,23 @@\n+2003-03-11  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * doc/tm.texi (Frame Registers): Document DWARF_REG_TO_UNWIND_COLUMN.\n+\n+        * unwind-dw2.c (DWARF_REG_TO_UNWIND_COLUMN): Define.\n+        (_Unwind_GetGR): Use DWARF_REG_TO_UNWIND_COLUMN.\n+        (_Unwind_SetGR): Same.\n+        (_Unwind_GetGRPtr): New.\n+        (_Unwind_SetGRPtr): New.\n+        (uw_update_context_1): Use accesor functions instead of accessing\n+        context->reg[] directly.\n+        (uw_install_context_1): Same.\n+        (execute_cfa_program): Same.\n+        (__frame_state_for): Same.\n+\n+        * config/rs6000/rs6000.c (spe_synthesize_frame_save): Use 1200 as\n+        the synthetic register offset.\n+\n+        * config/rs6000/rs6000.h (DWARF_REG_TO_UNWIND_COLUMN): New.\n+\n 2003-03-11  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.md: Remove lingering EGCS reference."}, {"sha": "17997fd0f929bdf06ef55c3a3c9149ef8b520b02", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "patch": "@@ -10235,7 +10235,7 @@ spe_synthesize_frame_save (real)\n \n   /* For the SPE, registers saved in 64-bits, get a PARALLEL for their\n      frame related note.  The parallel contains a set of the register\n-     being saved, and another set to a synthetic register (n+113).\n+     being saved, and another set to a synthetic register (n+1200).\n      This is so we can differentiate between 64-bit and 32-bit saves.\n      Words cannot describe this nastiness.  */\n \n@@ -10249,7 +10249,7 @@ spe_synthesize_frame_save (real)\n             (reg z))\n      into:\n        (set (mem (plus (reg x) (const y+4)))\n-            (reg z+113))\n+            (reg z+1200))\n   */\n \n   real2 = copy_rtx (real);\n@@ -10265,10 +10265,9 @@ spe_synthesize_frame_save (real)\n     }\n \n   reg = SET_SRC (synth);\n-  /* FIXME: the ABI says REGNO+1200, but this creates a huge hole\n-     in the unwinder tables.  I'm still unsure what to do.  */\n+\n   synth = replace_rtx (synth, reg,\n-\t\t       gen_rtx_REG (SImode, REGNO (reg) + 113));\n+\t\t       gen_rtx_REG (SImode, REGNO (reg) + 1200));\n \n   offset = XEXP (XEXP (SET_DEST (synth), 0), 1);\n   synth = replace_rtx (synth, offset,"}, {"sha": "e2c1f635180f9d52e4cf904a694dc6a2e343418f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "patch": "@@ -708,6 +708,16 @@ extern int rs6000_default_long_calls;\n    synthetic registers are 113 through 145.  */\n #define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER + 32)\n \n+/* The SPE has an additional 32 synthetic registers starting at 1200.\n+   We must map them here to sane values in the unwinder to avoid a\n+   huge hole in the unwind tables.\n+\n+   FIXME: the AltiVec ABI has AltiVec registers being 1124-1155, and\n+   the VRSAVE SPR (SPR256) assigned to register 356.  When AltiVec EH\n+   is verified to be working, this macro should be changed\n+   accordingly.  */\n+#define DWARF_REG_TO_UNWIND_COLUMN(r) ((r) > 1200 ? ((r) - 1200 + 113) : (r))\n+\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n "}, {"sha": "1723455535feadb168bb9fbaae96c1a509ab6903", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "patch": "@@ -3256,6 +3256,16 @@ for backward compatibility in pre GCC 3.0 compiled code.\n If this macro is not defined, it defaults to\n @code{DWARF_FRAME_REGISTERS}.\n \n+@findex DWARF_REG_TO_UNWIND_COLUMN\n+@item DWARF_REG_TO_UNWIND_COLUMN (@var{regno})\n+\n+Define this macro if the target's representation for dwarf registers\n+is different than the internal representation for unwind column.\n+Given a dwarf register, this macro should return the interal unwind\n+column number to use instead.\n+\n+See the PowerPC's SPE target for an example.  \n+\n @end table\n \n @node Elimination"}, {"sha": "88d8d3047ded5aad3bf916627b1fdfbc4133cb38", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f3a9307a5aa3db789f1311e04fb24a6f8807b0/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=41f3a9307a5aa3db789f1311e04fb24a6f8807b0", "patch": "@@ -50,6 +50,10 @@\n #define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS\n #endif\n \n+#ifndef DWARF_REG_TO_UNWIND_COLUMN\n+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n+#endif\n+\n /* This is the register and unwind state for a particular frame.  This\n    provides the information necessary to unwind up past a frame and return\n    to its caller.  */\n@@ -164,6 +168,7 @@ read_8s (const void *p) { const union unaligned *up = p; return up->s8; }\n inline _Unwind_Word\n _Unwind_GetGR (struct _Unwind_Context *context, int index)\n {\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   /* This will segfault if the register hasn't been saved.  */\n   return * (_Unwind_Word *) context->reg[index];\n }\n@@ -173,9 +178,28 @@ _Unwind_GetGR (struct _Unwind_Context *context, int index)\n inline void\n _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n {\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n   * (_Unwind_Word *) context->reg[index] = val;\n }\n \n+/* Get the pointer to a register INDEX as saved in CONTEXT.  */\n+\n+static inline void *\n+_Unwind_GetGRPtr (struct _Unwind_Context *context, int index)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  return context->reg[index];\n+}\n+\n+/* Set the pointer to a register INDEX as saved in CONTEXT.  */\n+\n+static inline void\n+_Unwind_SetGRPtr (struct _Unwind_Context *context, int index, void *p)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  context->reg[index] = p;\n+}\n+\n /* Retrieve the return address for CONTEXT.  */\n \n inline _Unwind_Ptr\n@@ -741,13 +765,14 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  reg = insn & 0x3f;\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Sword) utmp * fs->data_align;\n-\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[reg].loc.offset = offset;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n \t}\n       else if ((insn & 0xc0) == DW_CFA_restore)\n \t{\n \t  reg = insn & 0x3f;\n-\t  fs->regs.reg[reg].how = REG_UNSAVED;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_UNSAVED;\n \t}\n       else switch (insn)\n \t{\n@@ -773,13 +798,14 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Sword) utmp * fs->data_align;\n-\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[reg].loc.offset = offset;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n \t  break;\n \n \tcase DW_CFA_restore_extended:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  fs->regs.reg[reg].how = REG_UNSAVED;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n \t  break;\n \n \tcase DW_CFA_undefined:\n@@ -795,8 +821,8 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t    _Unwind_Word reg2;\n \t    insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t    insn_ptr = read_uleb128 (insn_ptr, &reg2);\n-\t    fs->regs.reg[reg].how = REG_SAVED_REG;\n-\t    fs->regs.reg[reg].loc.reg = reg2;\n+\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_REG;\n+\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.reg = reg2;\n \t  }\n \t  break;\n \n@@ -853,8 +879,8 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \tcase DW_CFA_expression:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n-\t  fs->regs.reg[reg].how = REG_SAVED_EXP;\n-\t  fs->regs.reg[reg].loc.exp = insn_ptr;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_EXP;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n \t  insn_ptr += utmp;\n \t  break;\n \n@@ -863,8 +889,9 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n \t  offset = stmp * fs->data_align;\n-\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[reg].loc.offset = offset;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n \t  break;\n \n \tcase DW_CFA_def_cfa_sf:\n@@ -897,8 +924,9 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n \t  offset = (_Unwind_Word) utmp * fs->data_align;\n-\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[reg].loc.offset = -offset;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = -offset;\n \t  break;\n \n \tdefault:\n@@ -1052,7 +1080,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t one frame to the next.  In this case, the stack pointer is never\n \t stored, so it has no saved address in the context.  What we do\n \t have is the CFA from the previous stack frame.  */\n-      if (context->reg[fs->cfa_reg] == NULL)\n+      if (_Unwind_GetGRPtr (context, fs->cfa_reg) == NULL)\n \tcfa = context->cfa;\n       else\n \tcfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (context, fs->cfa_reg);\n@@ -1086,10 +1114,12 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n       case REG_UNSAVED:\n \tbreak;\n       case REG_SAVED_OFFSET:\n-\tcontext->reg[i] = cfa + fs->regs.reg[i].loc.offset;\n+\t_Unwind_SetGRPtr (context, i, (void *) (cfa + fs->regs.reg[i].loc.offset));\n \tbreak;\n       case REG_SAVED_REG:\n-\tcontext->reg[i] = orig_context.reg[fs->regs.reg[i].loc.reg];\n+\t_Unwind_SetGRPtr\n+\t  (context, i,\n+\t   _Unwind_GetGRPtr (&orig_context, fs->regs.reg[i].loc.reg));\n \tbreak;\n       case REG_SAVED_EXP:\n \t{\n@@ -1100,7 +1130,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t  exp = read_uleb128 (exp, &len);\n \t  val = execute_stack_op (exp, exp + len, &orig_context,\n \t\t\t\t  (_Unwind_Ptr) cfa);\n-\t  context->reg[i] = (void *) val;\n+\t  _Unwind_SetGRPtr (context, i, (void *) val);\n \t}\n \tbreak;\n       }\n@@ -1205,6 +1235,7 @@ uw_install_context_1 (struct _Unwind_Context *current,\n     {\n       void *c = current->reg[i];\n       void *t = target->reg[i];\n+\n       if (t && c && t != c)\n \tmemcpy (c, t, dwarf_reg_size_table[i]);\n     }"}]}