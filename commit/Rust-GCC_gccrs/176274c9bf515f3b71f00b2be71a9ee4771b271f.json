{"sha": "176274c9bf515f3b71f00b2be71a9ee4771b271f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2Mjc0YzliZjUxNWYzYjcxZjAwYjJiZTcxYTllZTQ3NzFiMjcxZg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-02-06T19:19:49Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-02-06T19:19:49Z"}, "message": "sched: Do not move expensive insns speculatively (PR68664)\n\nScheduling should never move very expensive instructions to places they\nare executed more frequently.  This patch fixes that, reducing the\nexecution time of c-ray by over 40% (I tested on a BE Power7 system).\n\nThis introduces a new target hook sched.can_speculate_insn which returns\nwhether the scheduler is allowed to speculate a given instruction.  The\nrs6000 implementation disallows all divide and square root instructions.\n\n\n\tPR rtl-optimization/68664\n\t* target.def (can_speculate_insn): New hook.\n\t* doc/tm.texi.in (TARGET_SCHED_CAN_SPECULATE_INSN): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* sched-rgn.c (can_schedule_ready_p): Use the new hook.\n\t* config/rs6000/rs6000.c (TARGET_SCHED_CAN_SPECULATE_INSN): New macro.\n\t(rs6000_sched_can_speculate_insn): New function.\n\nFrom-SVN: r245215", "tree": {"sha": "eebb74792325dc6a931fd34554fc77bf0e7a321a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eebb74792325dc6a931fd34554fc77bf0e7a321a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/176274c9bf515f3b71f00b2be71a9ee4771b271f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176274c9bf515f3b71f00b2be71a9ee4771b271f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176274c9bf515f3b71f00b2be71a9ee4771b271f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176274c9bf515f3b71f00b2be71a9ee4771b271f/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2568d8a1f6d3912e53c457a1ea080050a834cf32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2568d8a1f6d3912e53c457a1ea080050a834cf32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2568d8a1f6d3912e53c457a1ea080050a834cf32"}], "stats": {"total": 68, "additions": 62, "deletions": 6}, "files": [{"sha": "7113dce7e1b44b170ea949e96030a49331ffd01e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -1,3 +1,13 @@\n+2017-02-06  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/68664\n+\t* target.def (can_speculate_insn): New hook.\n+\t* doc/tm.texi.in (TARGET_SCHED_CAN_SPECULATE_INSN): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* sched-rgn.c (can_schedule_ready_p): Use the new hook.\n+\t* config/rs6000/rs6000.c (TARGET_SCHED_CAN_SPECULATE_INSN): New macro.\n+\t(rs6000_sched_can_speculate_insn): New function.\n+\n 2017-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/79284"}, {"sha": "b1c9ef543150516e08e4f02a2fad269f88a94a46", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -1607,6 +1607,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_SCHED_FREE_SCHED_CONTEXT\n #define TARGET_SCHED_FREE_SCHED_CONTEXT rs6000_free_sched_context\n \n+#undef TARGET_SCHED_CAN_SPECULATE_INSN\n+#define TARGET_SCHED_CAN_SPECULATE_INSN rs6000_sched_can_speculate_insn\n+\n #undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD rs6000_builtin_mask_for_load\n #undef TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n@@ -34840,6 +34843,23 @@ rs6000_free_sched_context (void *_sc)\n   free (_sc);\n }\n \n+static bool\n+rs6000_sched_can_speculate_insn (rtx_insn *insn)\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_DIV:\n+    case TYPE_SDIV:\n+    case TYPE_DDIV:\n+    case TYPE_VECDIV:\n+    case TYPE_SSQRT:\n+    case TYPE_DSQRT:\n+      return false;\n+\n+    default:\n+      return true;\n+  }\n+}\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n "}, {"sha": "b34ee03278b62475bbbd74eab7606a7f0f89cba1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -7000,6 +7000,14 @@ The structure *@var{spec_info} should be filled in by the target.\n The structure describes speculation types that can be used in the scheduler.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SCHED_CAN_SPECULATE_INSN (rtx_insn *@var{insn})\n+Some instructions should never be speculated by the schedulers, usually\n+ because the instruction is too expensive to get this wrong.  Often such\n+ instructions have long latency, and often they are not fully modeled in the\n+ pipeline descriptions.  This hook should return @code{false} if @var{insn}\n+ should not be speculated.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_SCHED_SMS_RES_MII (struct ddg *@var{g})\n This hook is called by the swing modulo scheduler to calculate a\n resource-based lower bound which is based on the resources available in"}, {"sha": "756c1182493eeea3a50e3b07fb1f413c0f3a0148", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -4882,6 +4882,8 @@ them: try the first ones in this list first.\n \n @hook TARGET_SCHED_SET_SCHED_FLAGS\n \n+@hook TARGET_SCHED_CAN_SPECULATE_INSN\n+\n @hook TARGET_SCHED_SMS_RES_MII\n \n @hook TARGET_SCHED_DISPATCH"}, {"sha": "a09fc5d1066ac17a5cd2215d3f4552c51abc5dbe", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -2147,12 +2147,19 @@ static int\n can_schedule_ready_p (rtx_insn *insn)\n {\n   /* An interblock motion?  */\n-  if (INSN_BB (insn) != target_bb\n-      && IS_SPECULATIVE_INSN (insn)\n-      && !check_live (insn, INSN_BB (insn)))\n-    return 0;\n-  else\n-    return 1;\n+  if (INSN_BB (insn) != target_bb && IS_SPECULATIVE_INSN (insn))\n+    {\n+      /* Cannot schedule this insn unless all operands are live.  */\n+      if (!check_live (insn, INSN_BB (insn)))\n+\treturn 0;\n+\n+      /* Should not move expensive instructions speculatively.  */\n+      if (GET_CODE (PATTERN (insn)) != CLOBBER\n+\t  && !targetm.sched.can_speculate_insn (insn))\n+\treturn 0;\n+    }\n+\n+  return 1;\n }\n \n /* Updates counter and other information.  Split from can_schedule_ready_p ()"}, {"sha": "43600aecd3f30b0819c2dd6cd4b5fa282528405a", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176274c9bf515f3b71f00b2be71a9ee4771b271f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=176274c9bf515f3b71f00b2be71a9ee4771b271f", "patch": "@@ -1480,6 +1480,15 @@ DEFHOOK_UNDOC\n  \"Return speculation types that are checked for instruction @var{insn}\",\n  unsigned int, (rtx_insn *insn), NULL)\n \n+DEFHOOK\n+(can_speculate_insn,\n+ \"Some instructions should never be speculated by the schedulers, usually\\n\\\n+ because the instruction is too expensive to get this wrong.  Often such\\n\\\n+ instructions have long latency, and often they are not fully modeled in the\\n\\\n+ pipeline descriptions.  This hook should return @code{false} if @var{insn}\\n\\\n+ should not be speculated.\",\n+ bool, (rtx_insn *insn), hook_bool_rtx_insn_true)\n+\n DEFHOOK_UNDOC\n (skip_rtx_p,\n  \"Return bool if rtx scanning should just skip current layer and\\"}]}