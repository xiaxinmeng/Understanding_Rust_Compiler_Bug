{"sha": "ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "node_id": "C_kwDOANBUbNoAKGVhNGIyM2Q5YzgyZDliZTNiOTgyYzM1MTlmZTVlOGU5ZDgzM2E2YTg", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-10T12:42:08Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-10T12:42:08Z"}, "message": "libgomp: Handle OpenMP's reverse offloads\n\nThis commit enabled reverse offload for nvptx such that gomp_target_rev\nactually gets called.  And it fills the latter function to do all of\nthe following: finding the host function to the device func ptr and\ncopying the arguments to the host, processing the mapping/firstprivate,\ncalling the host function, copying back the data and freeing as needed.\n\nThe data handling is made easier by assuming that all host variables\neither existed before (and are in the mapping) or that those are\ndevices variables not yet available on the host. Thus, the reverse\nmapping can do without refcounts etc. Note that the spec disallows\ninside a target region device-affecting constructs other than target\nplus ancestor device-modifier and it also limits the clauses permitted\non this construct.\n\nFor the function addresses, an additional splay tree is used; for\nthe lookup of mapped variables, the existing splay-tree is used.\nUnfortunately, its data structure requires a full walk of the tree;\nAdditionally, the just mapped variables are recorded in a separate\ndata structure an extra lookup. While the lookup is slow, assuming\nthat only few variables get mapped in each reverse offload construct\nand that reverse offload is the exception and not performance critical,\nthis seems to be acceptable.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.h (struct target_mem_desc): Predeclare; move\n\tbelow after 'reverse_splay_tree_node' and add rev_array\n\tmember.\n\t(struct reverse_splay_tree_key_s, reverse_splay_compare): New.\n\t(reverse_splay_tree_node, reverse_splay_tree,\n\treverse_splay_tree_key): New typedef.\n\t(struct gomp_device_descr): Add mem_map_rev member.\n\t* oacc-host.c (host_dispatch): NULL init .mem_map_rev.\n\t* plugin/plugin-nvptx.c (GOMP_OFFLOAD_get_num_devices): Claim\n\tsupport for GOMP_REQUIRES_REVERSE_OFFLOAD.\n\t* splay-tree.h (splay_tree_callback_stop): New typedef; like\n\tsplay_tree_callback but returning int not void.\n\t(splay_tree_foreach_lazy): Define; like splay_tree_foreach but\n\ttaking splay_tree_callback_stop as argument.\n\t* splay-tree.c (splay_tree_foreach_internal_lazy,\n\tsplay_tree_foreach_lazy): New; but early exit if callback returns\n\tnonzero.\n\t* target.c: Instatiate splay_tree_c with splay_tree_prefix 'reverse'.\n\t(gomp_map_lookup_rev): New.\n\t(gomp_load_image_to_device): Handle reverse-offload function\n\tlookup table.\n\t(gomp_unload_image_from_device): Free devicep->mem_map_rev.\n\t(struct gomp_splay_tree_rev_lookup_data, gomp_splay_tree_rev_lookup,\n\tgomp_map_rev_lookup, struct cpy_data, gomp_map_cdata_lookup_int,\n\tgomp_map_cdata_lookup): New auxiliary structs and functions for\n\tgomp_target_rev.\n\t(gomp_target_rev): Implement reverse offloading and its mapping.\n\t(gomp_target_init): Init current_device.mem_map_rev.root.\n\t* testsuite/libgomp.fortran/reverse-offload-2.f90: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-3.f90: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-4.f90: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-5.f90: New test.\n\t* testsuite/libgomp.fortran/reverse-offload-5a.f90: New test without\n\tmapping of on-device allocated variables.", "tree": {"sha": "c347ecf7ff66c25cbf24f48afb44db0dc431d319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c347ecf7ff66c25cbf24f48afb44db0dc431d319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ee8a64ac17ded4ffda7a6ba4f387f40305e639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ee8a64ac17ded4ffda7a6ba4f387f40305e639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ee8a64ac17ded4ffda7a6ba4f387f40305e639"}], "stats": {"total": 1178, "additions": 1139, "deletions": 39}, "files": [{"sha": "8fc9379d1b3cc90c65d98f3e484dc47c2c9ecd27", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -1157,29 +1157,7 @@ struct target_var_desc {\n   uintptr_t length;\n };\n \n-struct target_mem_desc {\n-  /* Reference count.  */\n-  uintptr_t refcount;\n-  /* All the splay nodes allocated together.  */\n-  splay_tree_node array;\n-  /* Start of the target region.  */\n-  uintptr_t tgt_start;\n-  /* End of the targer region.  */\n-  uintptr_t tgt_end;\n-  /* Handle to free.  */\n-  void *to_free;\n-  /* Previous target_mem_desc.  */\n-  struct target_mem_desc *prev;\n-  /* Number of items in following list.  */\n-  size_t list_count;\n-\n-  /* Corresponding target device descriptor.  */\n-  struct gomp_device_descr *device_descr;\n-\n-  /* List of target items to remove (or decrease refcount)\n-     at the end of region.  */\n-  struct target_var_desc list[];\n-};\n+struct target_mem_desc;\n \n /* Special value for refcount - mask to indicate existence of special\n    values. Right now we allocate 3 bits.  */\n@@ -1273,6 +1251,58 @@ splay_compare (splay_tree_key x, splay_tree_key y)\n \n #include \"splay-tree.h\"\n \n+/* Reverse offload splay-tree handling (functions only). */\n+\n+struct reverse_splay_tree_key_s {\n+  /* Address of the device object.  */\n+  uint64_t dev;\n+  splay_tree_key k;\n+};\n+\n+typedef struct reverse_splay_tree_node_s *reverse_splay_tree_node;\n+typedef struct reverse_splay_tree_s *reverse_splay_tree;\n+typedef struct reverse_splay_tree_key_s *reverse_splay_tree_key;\n+\n+static inline int\n+reverse_splay_compare (reverse_splay_tree_key x, reverse_splay_tree_key y)\n+{\n+  if (x->dev < y->dev)\n+    return -1;\n+  if (x->dev > y->dev)\n+    return 1;\n+  return 0;\n+}\n+\n+#define splay_tree_prefix reverse\n+#include \"splay-tree.h\"\n+\n+struct target_mem_desc {\n+  /* Reference count.  */\n+  uintptr_t refcount;\n+  /* All the splay nodes allocated together.  */\n+  splay_tree_node array;\n+  /* Likewise for the reverse lookup device->host for reverse offload. */\n+  reverse_splay_tree_node rev_array;\n+  /* Start of the target region.  */\n+  uintptr_t tgt_start;\n+  /* End of the targer region.  */\n+  uintptr_t tgt_end;\n+  /* Handle to free.  */\n+  void *to_free;\n+  /* Previous target_mem_desc.  */\n+  struct target_mem_desc *prev;\n+  /* Number of items in following list.  */\n+  size_t list_count;\n+\n+  /* Corresponding target device descriptor.  */\n+  struct gomp_device_descr *device_descr;\n+\n+  /* List of target items to remove (or decrease refcount)\n+     at the end of region.  */\n+  struct target_var_desc list[];\n+};\n+\n+\n typedef struct acc_dispatch_t\n {\n   /* Execute.  */\n@@ -1367,6 +1397,7 @@ struct gomp_device_descr\n \n   /* Splay tree containing information about mapped memory regions.  */\n   struct splay_tree_s mem_map;\n+  struct reverse_splay_tree_s mem_map_rev;\n \n   /* Mutex for the mutable data.  */\n   gomp_mutex_t lock;"}, {"sha": "77a24279e2f2d612d772519d6c4ed1e407f5d80c", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -284,6 +284,7 @@ static struct gomp_device_descr host_dispatch =\n     .run_func = host_run,\n \n     .mem_map = { NULL },\n+    .mem_map_rev = { NULL },\n     /* .lock initialized in goacc_host_init.  */\n     .state = GOMP_DEVICE_UNINITIALIZED,\n "}, {"sha": "4f4c25a90baf17c351b2d27bd7ea605de352a414", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -1190,7 +1190,9 @@ GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n      devices were present.  Unified-shared address: see comment in\n      nvptx_open_device for CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING.  */\n   if (num_devices > 0\n-      && (omp_requires_mask & ~GOMP_REQUIRES_UNIFIED_ADDRESS) != 0)\n+      && ((omp_requires_mask\n+\t   & ~(GOMP_REQUIRES_UNIFIED_ADDRESS\n+\t       | GOMP_REQUIRES_REVERSE_OFFLOAD)) != 0))\n     return -1;\n   return num_devices;\n }"}, {"sha": "3809e90b68d39557cd3304c9c9cfefd6e652fcda", "filename": "libgomp/splay-tree.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.c?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -236,3 +236,25 @@ splay_tree_foreach (splay_tree sp, splay_tree_callback func, void *data)\n {\n   splay_tree_foreach_internal (sp->root, func, data);\n }\n+\n+/* Like above, except when func returns != 0, stop early.  */\n+\n+static int\n+splay_tree_foreach_internal_lazy (splay_tree_node node,\n+\t\t\t\t  splay_tree_callback_stop func, void *data)\n+{\n+  if (!node)\n+    return 0;\n+  if (func (&node->key, data))\n+    return 1;\n+  if (splay_tree_foreach_internal_lazy (node->left, func, data))\n+    return 1;\n+  /* Yeah, whatever.  GCC can fix my tail recursion.  */\n+  return splay_tree_foreach_internal_lazy (node->right, func, data);\n+}\n+\n+attribute_hidden void\n+splay_tree_foreach_lazy (splay_tree sp, splay_tree_callback_stop func, void *data)\n+{\n+  splay_tree_foreach_internal_lazy (sp->root, func, data);\n+}"}, {"sha": "7dea0cc87f7626f14ee028ff53d46031c4a97daf", "filename": "libgomp/splay-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.h?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -78,8 +78,12 @@ typedef struct splay_tree_key_s *splay_tree_key;\n     splay_tree_name (splay_tree_prefix, splay_tree_remove)\n # define splay_tree_foreach\t\\\n     splay_tree_name (splay_tree_prefix, splay_tree_foreach)\n+# define splay_tree_foreach_lazy \\\n+    splay_tree_name (splay_tree_prefix, splay_tree_foreach_lazy)\n # define splay_tree_callback\t\\\n     splay_tree_name (splay_tree_prefix, splay_tree_callback)\n+# define splay_tree_callback_stop\t\\\n+    splay_tree_name (splay_tree_prefix, splay_tree_callback_stop)\n #endif\n \n #ifndef splay_tree_c\n@@ -99,11 +103,13 @@ struct splay_tree_s {\n };\n \n typedef void (*splay_tree_callback) (splay_tree_key, void *);\n+typedef int (*splay_tree_callback_stop) (splay_tree_key, void *);\n \n extern splay_tree_key splay_tree_lookup (splay_tree, splay_tree_key);\n extern void splay_tree_insert (splay_tree, splay_tree_node);\n extern void splay_tree_remove (splay_tree, splay_tree_key);\n extern void splay_tree_foreach (splay_tree, splay_tree_callback, void *);\n+extern void splay_tree_foreach_lazy (splay_tree, splay_tree_callback_stop, void *);\n #else  /* splay_tree_c */\n #  ifdef splay_tree_prefix\n #    include \"splay-tree.c\"\n@@ -125,6 +131,8 @@ extern void splay_tree_foreach (splay_tree, splay_tree_callback, void *);\n #  undef splay_tree_insert\n #  undef splay_tree_remove\n #  undef splay_tree_foreach\n+#  undef splay_tree_foreach_lazy\n #  undef splay_tree_callback\n+#  undef splay_tree_callback_stop\n #  undef splay_tree_prefix\n #endif"}, {"sha": "e38cc3b6f1c19fac13135172bb56741465bbb263", "filename": "libgomp/target.c", "status": "modified", "additions": 584, "deletions": 15, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -45,6 +45,12 @@\n #include \"plugin-suffix.h\"\n #endif\n \n+/* Define another splay tree instantiation - for reverse offload.  */\n+#define splay_tree_prefix reverse\n+#define splay_tree_c\n+#include \"splay-tree.h\"\n+\n+\n typedef uintptr_t *hash_entry_type;\n static inline void * htab_alloc (size_t size) { return gomp_malloc (size); }\n static inline void htab_free (void *ptr) { free (ptr); }\n@@ -200,6 +206,12 @@ gomp_map_lookup (splay_tree mem_map, splay_tree_key key)\n   return splay_tree_lookup (mem_map, key);\n }\n \n+static inline reverse_splay_tree_key\n+gomp_map_lookup_rev (reverse_splay_tree mem_map_rev, reverse_splay_tree_key key)\n+{\n+  return reverse_splay_tree_lookup (mem_map_rev, key);\n+}\n+\n static inline splay_tree_key\n gomp_map_0len_lookup (splay_tree mem_map, splay_tree_key key)\n {\n@@ -1674,7 +1686,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t\t - k->host_start),\n \t\t\t\t\t      sizes[j], cbufp, false);\n \t\t\t  }\n-\t\t\t}\n+\t\t      }\n \t\t    i = j - 1;\n \t\t    break;\n \t\t  case GOMP_MAP_FORCE_PRESENT:\n@@ -2205,11 +2217,16 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n \n   /* Load image to device and get target addresses for the image.  */\n   struct addr_pair *target_table = NULL;\n+  uint64_t *rev_target_fn_table = NULL;\n   int i, num_target_entries;\n \n+  /* With reverse offload, insert also target-host addresses. */\n+  bool rev_lookup = omp_requires_mask & GOMP_REQUIRES_REVERSE_OFFLOAD;\n+\n   num_target_entries\n     = devicep->load_image_func (devicep->target_id, version,\n-\t\t\t\ttarget_data, &target_table, NULL);\n+\t\t\t\ttarget_data, &target_table,\n+\t\t\t\trev_lookup ? &rev_target_fn_table : NULL);\n \n   if (num_target_entries != num_funcs + num_vars\n       /* \"+1\" due to the additional ICV struct.  */\n@@ -2228,6 +2245,10 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n   /* \"+1\" due to the additional ICV struct.  */\n   tgt->array = gomp_malloc ((num_funcs + num_vars + 1)\n \t\t\t    * sizeof (*tgt->array));\n+  if (rev_target_fn_table)\n+    tgt->rev_array = gomp_malloc (num_funcs * sizeof (*tgt->rev_array));\n+  else\n+    tgt->rev_array = NULL;\n   tgt->refcount = REFCOUNT_INFINITY;\n   tgt->tgt_start = 0;\n   tgt->tgt_end = 0;\n@@ -2236,6 +2257,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n   tgt->list_count = 0;\n   tgt->device_descr = devicep;\n   splay_tree_node array = tgt->array;\n+  reverse_splay_tree_node rev_array = tgt->rev_array;\n \n   for (i = 0; i < num_funcs; i++)\n     {\n@@ -2250,6 +2272,17 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       array->left = NULL;\n       array->right = NULL;\n       splay_tree_insert (&devicep->mem_map, array);\n+      if (rev_target_fn_table)\n+\t{\n+\t  reverse_splay_tree_key k2 = &rev_array->key;\n+\t  k2->dev = rev_target_fn_table[i];\n+\t  k2->k = k;\n+\t  rev_array->left = NULL;\n+\t  rev_array->right = NULL;\n+\t  if (k2->dev != 0)\n+\t    reverse_splay_tree_insert (&devicep->mem_map_rev, rev_array);\n+\t  rev_array++;\n+\t}\n       array++;\n     }\n \n@@ -2369,6 +2402,15 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n       gomp_mutex_unlock (&devicep->lock);\n       gomp_fatal (\"image unload fail\");\n     }\n+  if (devicep->mem_map_rev.root)\n+    {\n+      /* Free reverse offload splay tree + data; 'tgt->rev_array' is the only\n+\t real allocation.  */\n+      assert (node && node->tgt && node->tgt->rev_array);\n+      assert (devicep->mem_map_rev.root->key.k->tgt == node->tgt);\n+      free (node->tgt->rev_array);\n+      devicep->mem_map_rev.root = NULL;\n+    }\n \n   /* Remove mappings from splay tree.  */\n   int i;\n@@ -3114,23 +3156,549 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \n }\n \n+\n+/* Reverse lookup (device addr -> host addr) for reverse offload.  We avoid\n+   keeping track of all variable handling - assuming that reverse offload occurs\n+   ony very rarely.  Downside is that the reverse search is slow.  */\n+\n+struct gomp_splay_tree_rev_lookup_data {\n+  uintptr_t tgt_start;\n+  uintptr_t tgt_end;\n+  splay_tree_key key;\n+};\n+\n+static int\n+gomp_splay_tree_rev_lookup (splay_tree_key key, void *d)\n+{\n+  struct gomp_splay_tree_rev_lookup_data *data;\n+  data = (struct gomp_splay_tree_rev_lookup_data *)d;\n+  uintptr_t tgt_start = key->tgt->tgt_start + key->tgt_offset;\n+\n+  if (tgt_start > data->tgt_start || key->tgt->list_count == 0)\n+    return 0;\n+\n+  size_t j;\n+  for (j = 0; j < key->tgt->list_count; j++)\n+    if (key->tgt->list[j].key == key)\n+      break;\n+  assert (j < key->tgt->list_count);\n+  uintptr_t tgt_end = tgt_start + key->tgt->list[j].length;\n+\n+  if ((tgt_start == data->tgt_start && tgt_end == data->tgt_end)\n+      || (tgt_end > data->tgt_start && tgt_start < data->tgt_end))\n+    {\n+      data->key = key;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+static inline splay_tree_key\n+gomp_map_rev_lookup (splay_tree mem_map, uint64_t tgt_start, uint64_t tgt_end,\n+\t\t     bool zero_len)\n+{\n+  struct gomp_splay_tree_rev_lookup_data data;\n+  data.key = NULL;\n+  data.tgt_start = tgt_start;\n+  data.tgt_end = tgt_end;\n+\n+  if (tgt_start != tgt_end)\n+    {\n+      splay_tree_foreach_lazy (mem_map, gomp_splay_tree_rev_lookup, &data);\n+      return data.key;\n+    }\n+\n+  data.tgt_end++;\n+  splay_tree_foreach_lazy (mem_map, gomp_splay_tree_rev_lookup, &data);\n+  if (data.key != NULL || zero_len)\n+    return data.key;\n+  data.tgt_end--;\n+\n+  data.tgt_start--;\n+  splay_tree_foreach_lazy (mem_map, gomp_splay_tree_rev_lookup, &data);\n+  return data.key;\n+}\n+\n+struct cpy_data\n+{\n+  uint64_t devaddr;\n+  bool present, aligned;\n+};\n+\n+\n+/* Search just mapped reverse-offload data; returns index if found,\n+   otherwise >= n.  */\n+\n+static inline int\n+gomp_map_cdata_lookup_int (struct cpy_data *d, uint64_t *devaddrs,\n+\t\t\t   unsigned short *kinds, uint64_t *sizes, size_t n,\n+\t\t\t   uint64_t tgt_start, uint64_t tgt_end)\n+{\n+  const bool short_mapkind = true;\n+  const int typemask = short_mapkind ? 0xff : 0x7;\n+  size_t i;\n+  for (i = 0; i < n; i++)\n+    {\n+      bool is_struct = ((get_kind (short_mapkind, kinds, i) & typemask)\n+\t\t\t== GOMP_MAP_STRUCT);\n+      uint64_t dev_end;\n+      if (!is_struct)\n+\tdev_end = d[i].devaddr + sizes[i];\n+      else\n+\t{\n+\t  if (i + sizes[i] < n)\n+\t    dev_end = d[i + sizes[i]].devaddr + sizes[i + sizes[i]];\n+\t  else\n+\t    dev_end = devaddrs[i + sizes[i]] + sizes[i + sizes[i]];\n+\t}\n+      if ((d[i].devaddr == tgt_start && dev_end == tgt_end)\n+\t  || (dev_end > tgt_start && d[i].devaddr < tgt_end))\n+\tbreak;\n+      if (is_struct)\n+\ti += sizes[i];\n+    }\n+  return i;\n+}\n+\n+static inline int\n+gomp_map_cdata_lookup (struct cpy_data *d, uint64_t *devaddrs,\n+\t\t       unsigned short *kinds, uint64_t *sizes,\n+\t\t       size_t n, uint64_t tgt_start, uint64_t tgt_end,\n+\t\t       bool zero_len)\n+{\n+  size_t i;\n+  if (tgt_start != tgt_end)\n+    return gomp_map_cdata_lookup_int (d, devaddrs, kinds, sizes, n,\n+\t\t\t\t      tgt_start, tgt_end);\n+  tgt_end++;\n+  i = gomp_map_cdata_lookup_int (d, devaddrs, kinds, sizes, n,\n+\t\t\t\t tgt_start, tgt_end);\n+  if (i < n || zero_len)\n+    return i;\n+  tgt_end--;\n+\n+  tgt_start--;\n+  return gomp_map_cdata_lookup_int (d, devaddrs, kinds, sizes, n,\n+\t\t\t\t    tgt_start, tgt_end);\n+}\n+\n /* Handle reverse offload.  This is called by the device plugins for a\n-   reverse offload; it is not called if the outer target runs on the host.  */\n+   reverse offload; it is not called if the outer target runs on the host.\n+   The mapping is simplified device-affecting constructs (except for target\n+   with device(ancestor:1)) must not be encountered; in particular not\n+   target (enter/exit) data.  */\n \n void\n-gomp_target_rev (uint64_t fn_ptr __attribute__ ((unused)),\n-\t\t uint64_t mapnum __attribute__ ((unused)),\n-\t\t uint64_t devaddrs_ptr __attribute__ ((unused)),\n-\t\t uint64_t sizes_ptr __attribute__ ((unused)),\n-\t\t uint64_t kinds_ptr __attribute__ ((unused)),\n-\t\t int dev_num __attribute__ ((unused)),\n-\t\t void (*dev_to_host_cpy) (void *, const void *, size_t,\n-\t\t\t\t\t  void *) __attribute__ ((unused)),\n-\t\t void (*host_to_dev_cpy) (void *, const void *, size_t,\n-\t\t\t\t\t  void *) __attribute__ ((unused)),\n-\t\t void *token __attribute__ ((unused)))\n+gomp_target_rev (uint64_t fn_ptr, uint64_t mapnum, uint64_t devaddrs_ptr,\n+\t\t uint64_t sizes_ptr, uint64_t kinds_ptr, int dev_num,\n+\t\t void (*dev_to_host_cpy) (void *, const void *, size_t, void*),\n+\t\t void (*host_to_dev_cpy) (void *, const void *, size_t, void*),\n+\t\t void *token)\n {\n-  __builtin_unreachable ();\n+  /* Return early if there is no offload code.  */\n+  if (sizeof (OFFLOAD_PLUGINS) == sizeof (\"\"))\n+    return;\n+  /* Currently, this fails because of calculate_firstprivate_requirements\n+     below; it could be fixed but additional code needs to be updated to\n+     handle 32bit hosts - thus, it is not worthwhile.  */\n+  if (sizeof (void *) != sizeof (uint64_t))\n+    gomp_fatal (\"Reverse offload of 32bit hosts not supported.\");\n+\n+  struct cpy_data *cdata = NULL;\n+  uint64_t *devaddrs;\n+  uint64_t *sizes;\n+  unsigned short *kinds;\n+  const bool short_mapkind = true;\n+  const int typemask = short_mapkind ? 0xff : 0x7;\n+  struct gomp_device_descr *devicep = resolve_device (dev_num, false);\n+\n+  reverse_splay_tree_key n;\n+  struct reverse_splay_tree_key_s k;\n+  k.dev = fn_ptr;\n+\n+  gomp_mutex_lock (&devicep->lock);\n+  n = gomp_map_lookup_rev (&devicep->mem_map_rev, &k);\n+  gomp_mutex_unlock (&devicep->lock);\n+\n+  if (n == NULL)\n+    gomp_fatal (\"Cannot find reverse-offload function\");\n+  void (*host_fn)() = (void (*)()) n->k->host_start;\n+\n+  if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+    {\n+      devaddrs = (uint64_t *) (uintptr_t) devaddrs_ptr;\n+      sizes = (uint64_t *) (uintptr_t) sizes_ptr;\n+      kinds = (unsigned short *) (uintptr_t) kinds_ptr;\n+    }\n+  else\n+    {\n+      devaddrs = (uint64_t *) gomp_malloc (mapnum * sizeof (uint64_t));\n+      sizes = (uint64_t *) gomp_malloc (mapnum * sizeof (uint64_t));\n+      kinds = (unsigned short *) gomp_malloc (mapnum * sizeof (unsigned short));\n+      if (dev_to_host_cpy)\n+\t{\n+\t  dev_to_host_cpy (devaddrs, (const void *) (uintptr_t) devaddrs_ptr,\n+\t\t\t   mapnum * sizeof (uint64_t), token);\n+\t  dev_to_host_cpy (sizes, (const void *) (uintptr_t) sizes_ptr,\n+\t\t\t   mapnum * sizeof (uint64_t), token);\n+\t  dev_to_host_cpy (kinds, (const void *) (uintptr_t) kinds_ptr,\n+\t\t\t   mapnum * sizeof (unsigned short), token);\n+\t}\n+      else\n+\t{\n+\t  gomp_copy_dev2host (devicep, NULL, devaddrs,\n+\t\t\t      (const void *) (uintptr_t) devaddrs_ptr,\n+\t\t\t      mapnum * sizeof (uint64_t));\n+\t  gomp_copy_dev2host (devicep, NULL, sizes,\n+\t\t\t      (const void *) (uintptr_t) sizes_ptr,\n+\t\t\t      mapnum * sizeof (uint64_t));\n+\t  gomp_copy_dev2host (devicep, NULL, kinds, (const void *) (uintptr_t) kinds_ptr,\n+\t\t\t      mapnum * sizeof (unsigned short));\n+\t}\n+    }\n+\n+  size_t tgt_align = 0, tgt_size = 0;\n+\n+  /* If actually executed on 32bit systems, the casts lead to wrong code;\n+     but 32bit with offloading is not supported; see top of this function.  */\n+  calculate_firstprivate_requirements (mapnum, (void *) (uintptr_t) sizes,\n+\t\t\t\t       (void *) (uintptr_t) kinds,\n+\t\t\t\t       &tgt_align, &tgt_size);\n+\n+  if (tgt_align)\n+    {\n+      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n+      uintptr_t al = (uintptr_t) tgt & (tgt_align - 1);\n+      if (al)\n+\ttgt += tgt_align - al;\n+      tgt_size = 0;\n+      for (uint64_t i = 0; i < mapnum; i++)\n+\tif (get_kind (short_mapkind, kinds, i) == GOMP_MAP_FIRSTPRIVATE\n+\t    && devaddrs[i] != 0)\n+\t  {\n+\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t    if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+\t      memcpy (tgt + tgt_size, (void *) (uintptr_t) devaddrs[i],\n+\t\t      (size_t) sizes[i]);\n+\t    else if (dev_to_host_cpy)\n+\t      dev_to_host_cpy (tgt + tgt_size, (void *) (uintptr_t) devaddrs[i],\n+\t\t\t       (size_t) sizes[i], token);\n+\t    else\n+\t      gomp_copy_dev2host (devicep, NULL, tgt + tgt_size,\n+\t\t\t\t  (void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t  (size_t) sizes[i]);\n+\t    devaddrs[i] = (uint64_t) (uintptr_t) tgt + tgt_size;\n+\t    tgt_size = tgt_size + sizes[i];\n+\t    if ((devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+\t\t&& i + 1 < mapnum\n+\t\t&& ((get_kind (short_mapkind, kinds, i) & typemask)\n+\t\t    == GOMP_MAP_ATTACH))\n+\t      {\n+\t\t*(uint64_t*) (uintptr_t) (devaddrs[i+1] + sizes[i+1])\n+\t\t  = (uint64_t) devaddrs[i];\n+\t\t++i;\n+\t      }\n+\t  }\n+    }\n+\n+  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM))\n+    {\n+      size_t j, struct_cpy = 0;\n+      splay_tree_key n2;\n+      cdata = gomp_alloca (sizeof (*cdata) * mapnum);\n+      memset (cdata, '\\0', sizeof (*cdata) * mapnum);\n+      gomp_mutex_lock (&devicep->lock);\n+      for (uint64_t i = 0; i < mapnum; i++)\n+\t{\n+\t  if (devaddrs[i] == 0)\n+\t    continue;\n+\t  n = NULL;\n+\t  int kind = get_kind (short_mapkind, kinds, i) & typemask;\n+\t  switch (kind)\n+\t    {\n+\t      case GOMP_MAP_FIRSTPRIVATE:\n+\t      case GOMP_MAP_FIRSTPRIVATE_INT:\n+\t\tcontinue;\n+\n+\t      case GOMP_MAP_DELETE:\n+\t      case GOMP_MAP_RELEASE:\n+\t      case GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION:\n+\t\t/* Assume it is present; look it up - but ignore otherwise. */\n+\t      case GOMP_MAP_ALLOC:\n+\t      case GOMP_MAP_FROM:\n+\t      case GOMP_MAP_FORCE_ALLOC:\n+\t      case GOMP_MAP_FORCE_FROM:\n+\t      case GOMP_MAP_ALWAYS_FROM:\n+\t      case GOMP_MAP_TO:\n+\t      case GOMP_MAP_TOFROM:\n+\t      case GOMP_MAP_FORCE_TO:\n+\t      case GOMP_MAP_FORCE_TOFROM:\n+\t      case GOMP_MAP_ALWAYS_TO:\n+\t      case GOMP_MAP_ALWAYS_TOFROM:\n+\t      case GOMP_MAP_ZERO_LEN_ARRAY_SECTION:\n+\t\tcdata[i].devaddr = devaddrs[i];\n+\t\tbool zero_len = (kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n+\t\t\t\t || kind == GOMP_MAP_ZERO_LEN_ARRAY_SECTION);\n+\t\tj = gomp_map_cdata_lookup (cdata, devaddrs, kinds, sizes, i,\n+\t\t\t\t\t   devaddrs[i],\n+\t\t\t\t\t   devaddrs[i] + sizes[i], zero_len);\n+\t\tif (j < i)\n+\t\t  {\n+\t\t    n2 = NULL;\n+\t\t    cdata[i].present = true;\n+\t\t    devaddrs[i] = devaddrs[j] + devaddrs[i] - cdata[j].devaddr;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    n2 = gomp_map_rev_lookup (&devicep->mem_map,\n+\t\t\t\t\t      devaddrs[i],\n+\t\t\t\t\t      devaddrs[i] + sizes[i], zero_len);\n+\t\t    cdata[i].present = n2 != NULL;\n+\t\t  }\n+\t\tif (!cdata[i].present\n+\t\t    && kind != GOMP_MAP_DELETE\n+\t\t    && kind != GOMP_MAP_RELEASE\n+\t\t    && kind != GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION)\n+\t\t  {\n+\t\t    cdata[i].aligned = true;\n+\t\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t\t    devaddrs[i]\n+\t\t      = (uint64_t) (uintptr_t) gomp_aligned_alloc (align,\n+\t\t\t\t\t\t\t\t   sizes[i]);\n+\t\t  }\n+\t\telse if (n2 != NULL)\n+\t\t  devaddrs[i] = (n2->host_start + cdata[i].devaddr\n+\t\t\t\t - (n2->tgt->tgt_start + n2->tgt_offset));\n+\t\tif (((!cdata[i].present || struct_cpy)\n+\t\t     && (kind == GOMP_MAP_TO || kind == GOMP_MAP_TOFROM))\n+\t\t    || kind == GOMP_MAP_FORCE_TO\n+\t\t    || kind == GOMP_MAP_FORCE_TOFROM\n+\t\t    || kind == GOMP_MAP_ALWAYS_TO\n+\t\t    || kind == GOMP_MAP_ALWAYS_TOFROM)\n+\t\t  {\n+\t\t    if (dev_to_host_cpy)\n+\t\t      dev_to_host_cpy ((void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t       (void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t       sizes[i], token);\n+\t\t    else\n+\t\t      gomp_copy_dev2host (devicep, NULL,\n+\t\t\t\t\t  (void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t\t  (void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t\t  sizes[i]);\n+\t\t  }\n+\t\tif (struct_cpy)\n+\t\t  struct_cpy--;\n+\t\tbreak;\n+\t      case GOMP_MAP_ATTACH:\n+\t      case GOMP_MAP_POINTER:\n+\t      case GOMP_MAP_ALWAYS_POINTER:\n+\t\tn2 = gomp_map_rev_lookup (&devicep->mem_map,\n+\t\t\t\t\t  devaddrs[i] + sizes[i],\n+\t\t\t\t\t  devaddrs[i] + sizes[i]\n+\t\t\t\t\t  + sizeof (void*), false);\n+\t\tcdata[i].present = n2 != NULL;\n+\t\tcdata[i].devaddr = devaddrs[i];\n+\t\tif (n2)\n+\t\t  devaddrs[i] = (n2->host_start + cdata[i].devaddr\n+\t\t\t\t - (n2->tgt->tgt_start + n2->tgt_offset));\n+\t\telse\n+\t\t  {\n+\t\t    j = gomp_map_cdata_lookup (cdata, devaddrs, kinds, sizes, i,\n+\t\t\t\t\t       devaddrs[i] + sizes[i],\n+\t\t\t\t\t       devaddrs[i] + sizes[i]\n+\t\t\t\t\t       + sizeof (void*), false);\n+\t\t    if (j < i)\n+\t\t      {\n+\t\t\tcdata[i].present = true;\n+\t\t\tdevaddrs[i] = (devaddrs[j] + devaddrs[i]\n+\t\t\t\t       - cdata[j].devaddr);\n+\t\t      }\n+\t\t  }\n+\t\tif (!cdata[i].present)\n+\t\t  devaddrs[i] = (uintptr_t) gomp_malloc (sizeof (void*));\n+\t\t/* Assume that when present, the pointer is already correct.  */\n+\t\tif (!n2)\n+\t\t  *(uint64_t *) (uintptr_t) (devaddrs[i] + sizes[i])\n+\t\t    = devaddrs[i-1];\n+\t\tbreak;\n+\t      case GOMP_MAP_TO_PSET:\n+\t\t/* Assume that when present, the pointers are fine and no 'to:'\n+\t\t   is required.  */\n+\t\tn2 = gomp_map_rev_lookup (&devicep->mem_map,\n+\t\t\t\t\t  devaddrs[i], devaddrs[i] + sizes[i],\n+\t\t\t\t\t  false);\n+\t\tcdata[i].present = n2 != NULL;\n+\t\tcdata[i].devaddr = devaddrs[i];\n+\t\tif (n2)\n+\t\t  devaddrs[i] = (n2->host_start + cdata[i].devaddr\n+\t\t\t\t - (n2->tgt->tgt_start + n2->tgt_offset));\n+\t\telse\n+\t\t  {\n+\t\t    j = gomp_map_cdata_lookup (cdata, devaddrs, kinds, sizes, i,\n+\t\t\t\t\t       devaddrs[i],\n+\t\t\t\t\t       devaddrs[i] + sizes[i], false);\n+\t\t    if (j < i)\n+\t\t      {\n+\t\t\tcdata[i].present = true;\n+\t\t\tdevaddrs[i] = (devaddrs[j] + devaddrs[i]\n+\t\t\t\t       - cdata[j].devaddr);\n+\t\t      }\n+\t\t  }\n+\t\tif (!cdata[i].present)\n+\t\t  {\n+\t\t    cdata[i].aligned = true;\n+\t\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t\t    devaddrs[i]\n+\t\t      = (uint64_t) (uintptr_t) gomp_aligned_alloc (align,\n+\t\t\t\t\t\t\t\t   sizes[i]);\n+\t\t    if (dev_to_host_cpy)\n+\t\t      dev_to_host_cpy ((void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t       (void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t       sizes[i], token);\n+\t\t    else\n+\t\t      gomp_copy_dev2host (devicep, NULL,\n+\t\t\t\t\t  (void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t\t  (void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t\t  sizes[i]);\n+\t\t  }\n+\t\tfor (j = i + 1; j < mapnum; j++)\n+\t\t  {\n+\t\t    kind = get_kind (short_mapkind, kinds, j) & typemask;\n+\t\t    if (!GOMP_MAP_ALWAYS_POINTER_P (kind)\n+\t\t\t&& !GOMP_MAP_POINTER_P (kind))\n+\t\t      break;\n+\t\t    if (devaddrs[j] < devaddrs[i])\n+\t\t      break;\n+\t\t    if (cdata[i].present)\n+\t\t      continue;\n+\t\t    if (devaddrs[j] == 0)\n+\t\t      {\n+\t\t\t*(uint64_t *) (uintptr_t) (devaddrs[i] + sizes[j]) = 0;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    int k;\n+\t\t    n2 = NULL;\n+\t\t    cdata[i].present = true;\n+\t\t    cdata[j].devaddr = devaddrs[j];\n+\t\t    k = gomp_map_cdata_lookup (cdata, devaddrs, kinds, sizes, j,\n+\t\t\t\t\t       devaddrs[j],\n+\t\t\t\t\t       devaddrs[j] + sizeof (void*),\n+\t\t\t\t\t       false);\n+\t\t    if (k < j)\n+\t\t      devaddrs[j] = (devaddrs[k] + devaddrs[j]\n+\t\t\t\t     - cdata[k].devaddr);\n+\t\t    else\n+\t\t      {\n+\t\t\tn2 = gomp_map_rev_lookup (&devicep->mem_map,\n+\t\t\t\t\t\t  devaddrs[j],\n+\t\t\t\t\t\t  devaddrs[j] + sizeof (void*),\n+\t\t\t\t\t\t  false);\n+\t\t\tif (n2 == NULL)\n+\t\t\t  {\n+\t\t\t    gomp_mutex_unlock (&devicep->lock);\n+\t\t\t    gomp_fatal (\"Pointer target wasn't mapped\");\n+\t\t\t  }\n+\t\t\tdevaddrs[j] = (n2->host_start + cdata[j].devaddr\n+\t\t\t\t       - (n2->tgt->tgt_start + n2->tgt_offset));\n+\t\t      }\n+\t\t    *(void **) (uintptr_t) (devaddrs[i] + sizes[j])\n+\t\t      = (void *) (uintptr_t) devaddrs[j];\n+\t\t  }\n+\t\ti = j -1;\n+\t\tbreak;\n+\t      case GOMP_MAP_STRUCT:\n+\t\tn2 = gomp_map_rev_lookup (&devicep->mem_map, devaddrs[i+1],\n+\t\t\t\t\t  devaddrs[i + sizes[i]]\n+\t\t\t\t\t  + sizes[i + sizes[i]], false);\n+\t\tcdata[i].present = n2 != NULL;\n+\t\tcdata[i].devaddr = devaddrs[i];\n+\t\tstruct_cpy = cdata[i].present ? 0 : sizes[i];\n+\t\tif (!n2)\n+\t\t  {\n+\t\t    size_t sz = (size_t) (devaddrs[i + sizes[i]]\n+\t\t\t\t\t  - devaddrs[i+1]\n+\t\t\t\t\t  + sizes[i + sizes[i]]);\n+\t\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t\t    cdata[i].aligned = true;\n+\t\t    devaddrs[i] = (uintptr_t) gomp_aligned_alloc (align, sz);\n+\t\t    devaddrs[i] -= devaddrs[i+1] - cdata[i].devaddr;\n+\t\t  }\n+\t\telse\n+\t\t  devaddrs[i] = (n2->host_start + cdata[i].devaddr\n+\t\t\t\t - (n2->tgt->tgt_start + n2->tgt_offset));\n+\t\tbreak;\n+\t      default:\n+\t\tgomp_mutex_unlock (&devicep->lock);\n+\t\tgomp_fatal (\"gomp_target_rev unhandled kind 0x%.4x\", kinds[i]);\n+\t    }\n+\t}\n+      gomp_mutex_unlock (&devicep->lock);\n+    }\n+\n+  host_fn (devaddrs);\n+\n+  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM))\n+    {\n+      uint64_t struct_cpy = 0;\n+      bool clean_struct = false;\n+      for (uint64_t i = 0; i < mapnum; i++)\n+\t{\n+\t  if (cdata[i].devaddr == 0)\n+\t    continue;\n+\t  int kind = get_kind (short_mapkind, kinds, i) & typemask;\n+\t  bool copy = !cdata[i].present || struct_cpy;\n+\t  switch (kind)\n+\t    {\n+\t      case GOMP_MAP_FORCE_FROM:\n+\t      case GOMP_MAP_FORCE_TOFROM:\n+\t      case GOMP_MAP_ALWAYS_FROM:\n+\t      case GOMP_MAP_ALWAYS_TOFROM:\n+\t\tcopy = true;\n+\t\t/* FALLTHRU */\n+\t      case GOMP_MAP_FROM:\n+\t      case GOMP_MAP_TOFROM:\n+\t\tif (copy && host_to_dev_cpy)\n+\t\t  host_to_dev_cpy ((void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t   (void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t   sizes[i], token);\n+\t\telse if (copy)\n+\t\t  gomp_copy_host2dev (devicep, NULL,\n+\t\t\t\t      (void *) (uintptr_t) cdata[i].devaddr,\n+\t\t\t\t      (void *) (uintptr_t) devaddrs[i],\n+\t\t\t\t      sizes[i], false, NULL);\n+\t      default:\n+\t\tbreak;\n+\t    }\n+\t  if (struct_cpy)\n+\t    {\n+\t      struct_cpy--;\n+\t      continue;\n+\t    }\n+\t  if (kind == GOMP_MAP_STRUCT && !cdata[i].present)\n+\t    {\n+\t      clean_struct = true;\n+\t      struct_cpy = sizes[i];\n+\t    }\n+\t  else if (cdata[i].aligned)\n+\t    gomp_aligned_free ((void *) (uintptr_t) devaddrs[i]);\n+\t  else if (!cdata[i].present)\n+\t    free ((void *) (uintptr_t) devaddrs[i]);\n+\t}\n+      if (clean_struct)\n+\tfor (uint64_t i = 0; i < mapnum; i++)\n+\t  if (!cdata[i].present\n+\t      && ((get_kind (short_mapkind, kinds, i) & typemask)\n+\t\t  == GOMP_MAP_STRUCT))\n+\t    {\n+\t      devaddrs[i] += cdata[i+1].devaddr - cdata[i].devaddr;\n+\t      gomp_aligned_free ((void *) (uintptr_t) devaddrs[i]);\n+\t    }\n+\n+      free (devaddrs);\n+      free (sizes);\n+      free (kinds);\n+    }\n }\n \n /* Host fallback for GOMP_target_data{,_ext} routines.  */\n@@ -4510,6 +5078,7 @@ gomp_target_init (void)\n \t\t/* current_device.capabilities has already been set.  */\n \t\tcurrent_device.type = current_device.get_type_func ();\n \t\tcurrent_device.mem_map.root = NULL;\n+\t\tcurrent_device.mem_map_rev.root = NULL;\n \t\tcurrent_device.state = GOMP_DEVICE_UNINITIALIZED;\n \t\tfor (i = 0; i < new_num_devs; i++)\n \t\t  {"}, {"sha": "067639bc67e20d83ee86bf47a43c47990f34e56e", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-2.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-2.f90?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -0,0 +1,72 @@\n+! { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } }\n+\n+implicit none\n+!$omp requires reverse_offload\n+integer :: A(50), A2(50)\n+integer :: i, error\n+logical :: shared_mem\n+\n+error = 0\n+shared_mem = .false.\n+A  = [(i, i=1,50)]\n+A2 = [(i, i=1,50)]\n+\n+!$omp target map(to: shared_mem)\n+  shared_mem = .true.\n+!$omp end target\n+\n+!$omp target map(to: A(20:40), A2(20:40)) map(from: error)\n+block\n+  integer :: B(10), C(10)\n+  B = 99\n+  C = 88\n+  A(20:40)  = -A(20:40)\n+  A2(20:40) = -A2(20:40)\n+\n+  !$omp target device (ancestor:1)  &\n+  !$omp&       map(to: A(25:35)) map(always, to: A2(25:35))  &\n+  !$omp&       map(from:B(4:8)) map(tofrom:C(4:8))\n+     if (shared_mem) then\n+       if (any (A(25:35)  /= [(-i,i=25,35)])) stop 20\n+     else\n+       if (any (A(25:35)  /= [( i,i=25,35)])) stop 21\n+     end if\n+    if (any (A2(25:35) /= [(-i,i=25,35)])) stop 22\n+    if (any (C(4:8) /= 88)) stop 23\n+\n+    A(25:35) = -A(25:35)*10\n+    A2(25:35) = -A2(25:35)*10\n+    B(4:8) = [4,5,6,7,8]\n+    C(4:8) = [-4,-5,-6,-7,-8]\n+  !$omp end target\n+\n+  if (any (B(1:3) /= 99) .or. any (B(9:10) /= 99)) then\n+    error = 30\n+  elseif (any (B(4:8) /= [4,5,6,7,8])) then\n+    error = 31\n+  elseif (any (C(1:3) /= 88) .or. any (C(9:10) /= 88)) then\n+    error = 32\n+  elseif (any (C(4:8) /= [-4,-5,-6,-7,-8])) then\n+    error = 33\n+  else\n+    error = 0\n+  endif\n+end block\n+\n+if (error /= 0) stop error\n+\n+if (shared_mem) then\n+  if (any (A(1:19)  /= [( i, i=1,19)])) stop 1\n+  if (any (A(20:24) /= [(-i, i=20,24)])) stop 2\n+  if (any (A(36:40) /= [(-i, i=36,40)])) stop 3\n+  if (any (A(41:50) /= [( i, i=41,50)])) stop 4\n+\n+  if (any (A(25:35) /= [( 10*i, i=25,35)])) stop 5\n+else\n+  if (any (A(1:24)  /= [( i, i=1,24)])) stop 6\n+  if (any (A(36:50) /= [( i, i=36,50)])) stop 7\n+\n+  if (any (A(25:35) /= [(-10*i, i=25,35)])) stop 8\n+end if\n+if (any (A2(25:35) /= [( 10*i, i=25,35)])) stop 9\n+end"}, {"sha": "2fd2f5b658956d42e3dcf4c69f7af9e45e4a5a7e", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-3.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-3.f90?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -0,0 +1,68 @@\n+! { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } }\n+\n+implicit none\n+!$omp requires reverse_offload\n+integer :: A(50), A2(50), A3(50)\n+integer :: i\n+logical :: shared_mem\n+\n+shared_mem = .false.\n+A  = [(3*i, i=1,50)]\n+A2 = [(7*i, i=1,50)]\n+A3 = [(11*i, i=1,50)]\n+\n+!$omp target map(to: shared_mem)\n+  shared_mem = .true.\n+!$omp end target\n+\n+!$omp target map(to: A(20:40), A2(20:40), A3(20:40))\n+block\n+  integer :: C(10)\n+  C = 88\n+  A(20:40)  = -2*A(20:40)\n+  A2(20:40) = -9*A2(20:40)\n+  A3(20:40) = -13*A3(20:40)\n+\n+  !$omp target device (ancestor:1)  &\n+  !$omp&       map(from: A(25:35)) map(always, from: A2(25:35))  &\n+  !$omp&       map(alloc: A3(25:35)) map(alloc:C(4:8))\n+    if (shared_mem) then\n+      if (any (A(25:35)  /= [(-2*3*i, i=25,35)])) stop 1\n+      if (any (A2(25:35) /= [(-9*7*i, i=25,35)])) stop 2\n+      if (any (A3(25:35) /= [(-13*11*i, i=25,35)])) stop 3\n+    else\n+      if (any (A(25:35)  /= [(3*i, i=25,35)])) stop 4\n+      if (any (A2(25:35) /= [(7*i, i=25,35)])) stop 5\n+      if (any (A3(25:35) /= [(11*i, i=25,35)])) stop 6\n+    end if\n+\n+    A(25:35) = A(25:35)*5\n+    A2(25:35) = A2(25:35)*8\n+    A3(25:35) = A3(25:35)*18\n+    C(4:8) = [4,5,6,7,8]\n+  !$omp end target\n+\n+  if (shared_mem) then\n+    if (any (A(25:35)  /= [(-2*3*5*i, i=25,35)])) stop 7\n+    if (any (A2(25:35) /= [(-9*7*8*i, i=25,35)])) stop 8\n+    if (any (A3(25:35) /= [(-13*11*18*i, i=25,35)])) stop 9\n+    if (any (C(4:8) /= [4,5,6,7,8])) stop 10\n+  else\n+    if (any (A(25:35)  /= [(-2*3*i, i=25,35)])) stop 11\n+    if (any (A2(25:35) /= [(7*8*i, i=25,35)])) stop 12\n+    if (any (A3(25:35) /= [(-13*11*i, i=25,35)])) stop 13\n+    if (any (C(4:8) /= 88)) stop 14\n+  end if\n+end block\n+\n+if (shared_mem) then\n+  if (any (A(25:35)  /= [(-2*3*5*i, i=25,35)])) stop\n+  if (any (A2(25:35) /= [(-9*7**8*i, i=25,35)])) stop\n+  if (any (A3(25:35) /= [(-13*11*18*i, i=25,35)])) stop\n+else\n+  if (any (A(25:35)  /= [(3*5*i, i=25,35)])) stop\n+  if (any (A2(25:35) /= [(7*8*i, i=25,35)])) stop\n+  if (any (A3(25:35) /= [(11*18*i, i=25,35)])) stop\n+end if\n+\n+end"}, {"sha": "fb27aa73ebae3d348d03fa8ab07b3e3f9b35cecd", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-4.f90", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-4.f90?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -0,0 +1,129 @@\n+! { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } }\n+\n+implicit none\n+!$omp requires reverse_offload\n+\n+type t2\n+  integer :: a, b, c\n+end type t2\n+\n+type t\n+ integer :: A(5), B(5), C(5)\n+ integer, pointer :: P(:), P2 !Just some padding\n+ type(t2) :: tt !Just some padding\n+end type t\n+\n+type(t) :: S1, S2\n+logical :: shared_mem\n+\n+shared_mem = .false.\n+\n+!$omp target map(to: shared_mem)\n+  shared_mem = .true.\n+!$omp end target\n+\n+s1%A = [1,2,3,4,5]\n+s1%B = [10,20,30,40,50]\n+s1%C = [11,22,33,44,55]\n+s2%A = 2*s1%A\n+s2%B = 2*s1%B\n+s2%C = 2*s1%C\n+\n+!$omp target &\n+!$omp&       map(to: s1%b, s1%c) &\n+!$omp&       map(to: s2%b, s2%c)\n+block\n+  type(t) :: si1, si2, si3, si4\n+\n+  s1%B = -10 * s1%B\n+  s1%C = -10 * s1%C\n+  s2%B = -15 * s2%B\n+  s2%C = -15 * s2%C\n+\n+  si1%A = -1 * [1,2,3,4,5]\n+  si1%B = -1 * [10,20,30,40,50]\n+  si1%C = -1 * [11,22,33,44,55]\n+  si2%A = -23 * [1,2,3,4,5]\n+  si2%B = -23 * [10,20,30,40,50]\n+  si2%C = -23 * [11,22,33,44,55]\n+\n+  !$omp target device (ancestor:1)  &\n+  !$omp&       map(to: si1%C, si1%B)  &\n+  !$omp&       map(tofrom: si2%C, si2%B)  &\n+  !$omp&       map(always, to: s1%B)  &\n+  !$omp&       map(        to: s2%B)\n+    if (any (s1%A /=       [1,2,3,4,5])) stop 1\n+    if (any (s1%B /= -10 * [10,20,30,40,50])) stop 2\n+    if (shared_mem) then\n+      if (any (s1%C /= -10 * [11,22,33,44,55])) stop 4\n+    else\n+      if (any (s1%C /=       [11,22,33,44,55])) stop 3\n+    endif\n+    if (any (s2%A /=   2 * [1,2,3,4,5])) stop 4\n+    if (shared_mem) then\n+      if (any (s2%B /= -15 * 2 * [10,20,30,40,50])) stop 5\n+      if (any (s2%C /= -15 * 2 * [11,22,33,44,55])) stop 6\n+    else\n+      if (any (s2%B /=   2 * [10,20,30,40,50])) stop 7\n+      if (any (s2%C /=   2 * [11,22,33,44,55])) stop 8\n+    endif\n+    if (any (si1%B /= -1 * [10,20,30,40,50])) stop 9\n+    if (any (si1%C /= -1 * [11,22,33,44,55])) stop 10\n+    if (any (si2%B /= -23 * [10,20,30,40,50])) stop 10\n+    if (any (si2%C /= -23 * [11,22,33,44,55])) stop 11\n+\n+    s1%A = 5 * s1%A\n+    s1%B = 7 * s1%B\n+    s1%C = 13 * s1%C\n+    s2%A = 9 * s2%A\n+    s2%B = 21 * s2%B\n+    s2%C = 31 * s2%C\n+    si1%B = -11 * si1%B\n+    si1%C = -13 * si1%C\n+    si2%B = -27 * si2%B\n+    si2%C = -29 * si2%C\n+  !$omp end target\n+\n+  if (shared_mem) then\n+    if (any (s1%B /= -10 * 7 * [10,20,30,40,50])) stop 20\n+    if (any (s1%C /= -10 * 13 * [11,22,33,44,55])) stop 21\n+  else\n+    if (any (s1%B /= -10 * [10,20,30,40,50])) stop 22\n+    if (any (s1%C /= -10 * [11,22,33,44,55])) stop 23\n+  endif\n+  if (shared_mem) then\n+    if (any (s2%B /= -15 * 2 * 21 * [10,20,30,40,50])) stop 24\n+    if (any (s2%C /= -15 * 2 * 31 * [11,22,33,44,55])) stop 25\n+  else\n+    if (any (s2%B /= -15 * 2 * [10,20,30,40,50])) stop 26\n+    if (any (s2%C /= -15 * 2 * [11,22,33,44,55])) stop 27\n+  endif\n+  if (any (si1%A /= -1 * [1,2,3,4,5])) stop 28\n+  if (shared_mem) then\n+    if (any (si1%B /= -1 * (-11) * [10,20,30,40,50])) stop 29\n+    if (any (si1%C /= -1 * (-13) * [11,22,33,44,55])) stop 30\n+  else\n+    if (any (si1%B /= -1 * [10,20,30,40,50])) stop 31\n+    if (any (si1%C /= -1 * [11,22,33,44,55])) stop 32\n+  endif\n+  if (any (si2%A /= -23 * [1,2,3,4,5])) stop 33\n+  if (any (si2%B /= -23 * (-27) * [10,20,30,40,50])) stop 34\n+  if (any (si2%C /= -23 * (-29) * [11,22,33,44,55])) stop 35\n+end block\n+\n+if (any (s1%A /=       5 * [1,2,3,4,5])) stop 40\n+if (any (s1%B /= -10 * 7 * [10,20,30,40,50])) stop 41\n+if (shared_mem) then\n+  if (any (s1%C /= -10 * 13 * [11,22,33,44,55])) stop 42\n+else\n+  if (any (s1%C /= 13 *    [11,22,33,44,55])) stop 43\n+endif\n+if (any (s2%A /=   2 * 9 * [1,2,3,4,5])) stop 44\n+if (shared_mem) then\n+  if (any (s2%B /= -15 * 2 * 21 * [10,20,30,40,50])) stop 45\n+  if (any (s2%C /= -15 * 2 * 31 * [11,22,33,44,55])) stop 46\n+else\n+  if (any (s2%B /=   2 * 21 * [10,20,30,40,50])) stop 47\n+  if (any (s2%C /=   2 * 31 * [11,22,33,44,55])) stop 48\n+endif\n+end"}, {"sha": "ef7eb7bdd52b17192291d2db0b2c6ebcc45c5b93", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-5.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5.f90?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -0,0 +1,100 @@\n+! { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } }\n+! { dg-xfail-run-if \"Copying on-device allocated memory fails with cuMemcpyDtoHAsync error: invalid argument\" { offload_device_nvptx } }\n+\n+! Because of the nvptx fail, a non-device alloc version has been\n+! created: reverse-offload-5a.f90\n+\n+implicit none\n+!$omp requires reverse_offload\n+\n+integer, allocatable :: A(:), A2(:), s1, s2\n+integer :: i\n+logical :: shared_mem\n+\n+shared_mem = .false.\n+\n+a = [1,2,3,4]\n+a2 = [8,7,6,5]\n+s1 = 532\n+s2 = 55\n+\n+!$omp target map(to: shared_mem)\n+  shared_mem = .true.\n+!$omp end target\n+\n+!$omp target map(to: A, A2, s1, s2)\n+block\n+  integer, allocatable :: ai(:), ai2(:), si1, si2\n+\n+  a = a * 2\n+  a2 = a2 * 3\n+  s1 = s1 * 4\n+  s2 = s2 * 5\n+\n+  ai = [23,35,86,43]\n+  ai2 = [8,4,7,1]\n+  si1 = 64\n+  si2 = 765\n+\n+  !$omp target device (ancestor:1)  &\n+  !$omp&       map(to: A, s1, ai, si1) map(always, to: a2, s2)  &\n+  !$omp&       map(tofrom: ai2, si2)\n+    if (shared_mem) then\n+      if (any (a  /= 2 * [1,2,3,4])) stop 1\n+      if (s1 /= 4 * 532) stop 2\n+    else\n+      if (any (a  /=     [1,2,3,4])) stop 3\n+      if (s1 /=     532) stop 4\n+    endif\n+    if (any (a2 /= 3 * [8,7,6,5])) stop 5\n+    if (s2 /= 5 * 55) stop 6\n+    if (any (ai /= [23,35,86,43])) stop 7\n+    if (any (ai2 /= [8,4,7,1])) stop 8\n+    if (si1 /= 64) stop 9\n+    if (si2 /= 765) stop 10\n+\n+    a = a*3\n+    a2 = a2*7\n+    s1 = s1*11\n+    s2 = s2*5\n+    ai = ai*13\n+    ai2 = ai2*21\n+    si1 = si1*27\n+    si2 = si2*31\n+  !$omp end target\n+\n+  if (shared_mem) then\n+    if (any (a  /= 3 * 2 * [1,2,3,4])) stop 11\n+    if (any (a2 /= 7 * 3 * [8,7,6,5])) stop 12\n+    if (s1 /= 11 * 4 * 532) stop 13\n+    if (s2 /= 5 * 5 * 55) stop 14\n+    if (any (ai /= 13 * [23,35,86,43])) stop 15\n+    if (si1 /= 27 * 64) stop 16\n+  else\n+    if (any (a  /= 2 * [1,2,3,4])) stop 17\n+    if (any (a2 /= 3 * [8,7,6,5])) stop 18\n+    if (s1 /= 4 * 532) stop 19\n+    if (s2 /= 5 * 55) stop 20\n+    if (any (ai /= [23,35,86,43])) stop 22\n+    if (si1 /= 64) stop 23\n+  endif\n+  if (any (ai2 /= 21 * [8,4,7,1])) stop 24\n+  if (si2 /= 31 * 765) stop 25\n+\n+  deallocate (ai, ai2, si1, si2)\n+end block\n+\n+if (shared_mem) then\n+  if (any (a  /= 3 * 2 * [1,2,3,4])) stop 30\n+  if (any (a2 /= 7 * 3 * [8,7,6,5])) stop 31\n+  if (s1 /= 11 * 4 * 532) stop 32\n+  if (s2 /= 5 * 5 * 55) stop 33\n+else\n+  if (any (a  /= 3 * [1,2,3,4])) stop 34\n+  if (any (a2 /= 3 * 7 * [8,7,6,5])) stop 35\n+  if (s1 /= 11 * 532) stop 36\n+  if (s2 /= 5 * 5 * 55) stop 37\n+endif\n+\n+deallocate (a, a2, s1, s2)\n+end"}, {"sha": "914d10d8144113592b2d35420fe763e590e0300f", "filename": "libgomp/testsuite/libgomp.fortran/reverse-offload-5a.f90", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freverse-offload-5a.f90?ref=ea4b23d9c82d9be3b982c3519fe5e8e9d833a6a8", "patch": "@@ -0,0 +1,98 @@\n+! { dg-additional-options \"-foffload-options=nvptx-none=-misa=sm_35\" { target { offload_target_nvptx } } }\n+\n+! Copying on-device allocated memory fails with cuMemcpyDtoHAsync error: invalid argument\n+! Hence, reverse-offload-5.f90 has been copied to *this* file,\n+! which uses on-host allocated vars - but only on the device side stack variables\n+\n+implicit none\n+!$omp requires reverse_offload\n+\n+integer, allocatable :: A(:), A2(:), s1, s2\n+integer :: i,D(4)\n+logical :: shared_mem\n+\n+shared_mem = .false.\n+\n+a = [1,2,3,4]\n+a2 = [8,7,6,5]\n+s1 = 532\n+s2 = 55\n+\n+!$omp target map(to: shared_mem)\n+  shared_mem = .true.\n+!$omp end target\n+\n+!$omp target map(to: A, A2, s1, s2)\n+block\n+  ! stack variables:\n+  integer :: ai(4), ai2(4), si1, si2\n+\n+  a = a * 2\n+  a2 = a2 * 3\n+  s1 = s1 * 4\n+  s2 = s2 * 5\n+\n+  ai = [23,35,86,43]\n+  ai2 = [8,4,7,1]\n+  si1 = 64\n+  si2 = 765\n+\n+  !$omp target device (ancestor:1)  &\n+  !$omp&       map(to: A, s1, ai, si1) map(always, to: a2, s2)  &\n+  !$omp&       map(tofrom: ai2, si2)\n+    if (shared_mem) then\n+      if (any (a  /= 2 * [1,2,3,4])) stop 1\n+      if (s1 /= 4 * 532) stop 2\n+    else\n+      if (any (a  /=     [1,2,3,4])) stop 3\n+      if (s1 /=     532) stop 4\n+    endif\n+    if (any (a2 /= 3 * [8,7,6,5])) stop 5\n+    if (s2 /= 5 * 55) stop 6\n+    if (any (ai /= [23,35,86,43])) stop 7\n+    if (any (ai2 /= [8,4,7,1])) stop 8\n+    if (si1 /= 64) stop 9\n+    if (si2 /= 765) stop 10\n+\n+    a = a*3\n+    a2 = a2*7\n+    s1 = s1*11\n+    s2 = s2*5\n+    ai = ai*13\n+    ai2 = ai2*21\n+    si1 = si1*27\n+    si2 = si2*31\n+  !$omp end target\n+\n+  if (shared_mem) then\n+    if (any (a  /= 3 * 2 * [1,2,3,4])) stop 11\n+    if (any (a2 /= 7 * 3 * [8,7,6,5])) stop 12\n+    if (s1 /= 11 * 4 * 532) stop 13\n+    if (s2 /= 5 * 5 * 55) stop 14\n+    if (any (ai /= 13 * [23,35,86,43])) stop 15\n+    if (si1 /= 27 * 64) stop 16\n+  else\n+    if (any (a  /= 2 * [1,2,3,4])) stop 17\n+    if (any (a2 /= 3 * [8,7,6,5])) stop 18\n+    if (s1 /= 4 * 532) stop 19\n+    if (s2 /= 5 * 55) stop 20\n+    if (any (ai /= [23,35,86,43])) stop 22\n+    if (si1 /= 64) stop 23\n+  endif\n+  if (any (ai2 /= 21 * [8,4,7,1])) stop 24\n+  if (si2 /= 31 * 765) stop 25\n+end block\n+if (shared_mem) then\n+  if (any (a  /= 3 * 2 * [1,2,3,4])) stop 30\n+  if (any (a2 /= 7 * 3 * [8,7,6,5])) stop 31\n+  if (s1 /= 11 * 4 * 532) stop 32\n+  if (s2 /= 5 * 5 * 55) stop 33\n+else\n+  if (any (a  /= 3 * [1,2,3,4])) stop 34\n+  if (any (a2 /= 3 * 7 * [8,7,6,5])) stop 35\n+  if (s1 /= 11 * 532) stop 36\n+  if (s2 /= 5 * 5 * 55) stop 37\n+endif\n+\n+deallocate (a, a2, s1, s2)\n+end"}]}