{"sha": "de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUzNTg5MWUyMTA1ZmRlOGNlMGYwYTJlM2E5ZjJmYWIwMWQ4N2NjZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-03T03:37:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-03T03:37:17Z"}, "message": "[multiple changes]\n\nTue Dec  2 19:18:50 1997  Mike Stump  <mrs@wrs.com>\n\n\t* class.c (prepare_fresh_vtable): Enable even more complex MI\n\tvtable names.\n\nTue Dec  2 01:37:19 1997  Jason Merrill  <jason@yorick.cygnus.com>\n\n\t* exception.cc (__check_eh_spec): Optimize a bit.\n\n\t* exception.cc (__cp_pop_exception): Lose handler arg.\n\t* except.c (do_pop_exception): Likewise.\n\t(push_eh_cleanup): Let the cleanup mechanism supply the handler.\n\t(expand_end_catch_block): Likewise.\n\nFrom-SVN: r16895", "tree": {"sha": "b4abd2c565f65c91be1f1496f0268eb329586c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4abd2c565f65c91be1f1496f0268eb329586c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/comments", "author": null, "committer": null, "parents": [{"sha": "9fb82071ffbee07329eeff32ee26f8170f672123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb82071ffbee07329eeff32ee26f8170f672123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb82071ffbee07329eeff32ee26f8170f672123"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "a91d9e30deb834e76da1677fb277f2cf23e7b5e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "patch": "@@ -1,3 +1,17 @@\n+Tue Dec  2 19:18:50 1997  Mike Stump  <mrs@wrs.com>\n+\n+\t* class.c (prepare_fresh_vtable): Enable even more complex MI\n+\tvtable names.\n+\n+Tue Dec  2 01:37:19 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* exception.cc (__check_eh_spec): Optimize a bit.\n+\n+\t* exception.cc (__cp_pop_exception): Lose handler arg.\n+\t* except.c (do_pop_exception): Likewise.\n+\t(push_eh_cleanup): Let the cleanup mechanism supply the handler.\n+\t(expand_end_catch_block): Likewise.\n+\n Fri Nov 28 01:58:14 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (check_explicit_specialization): Complain about using a "}, {"sha": "9eb619094f186842c887eda60738fa93d2b5d1de", "filename": "gcc/cp/class.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "patch": "@@ -784,7 +784,8 @@ prepare_fresh_vtable (binfo, for_type)\n \n   while (1)\n     {\n-      char *buf1 = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (for_type) + 1 + i);\n+      char *buf1 = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (for_type)\n+\t\t\t\t    + 1 + i);\n       char *new_buf2;\n \n       sprintf (buf1, \"%s%c%s\", TYPE_ASSEMBLER_NAME_STRING (for_type), joiner,\n@@ -808,8 +809,34 @@ prepare_fresh_vtable (binfo, for_type)\n \n       basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (path));\n \n-      /* We better not run out of stuff to make it unique.  */\n-      my_friendly_assert (for_type != basetype, 369);\n+      if (for_type == basetype)\n+\t{\n+\t  /* If we run out of basetypes in the path, we have already\n+\t     found created a vtable with that name before, we now\n+\t     resort to tacking on _%d to distinguish them.  */\n+\t  int j = 2;\n+\t  i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1 + i + 1 + 3;\n+\t  buf1 = (char *) alloca (i);\n+\t  do {\n+\t    sprintf (buf1, \"%s%c%s%c%d\",\n+\t\t     TYPE_ASSEMBLER_NAME_STRING (basetype), joiner,\n+\t\t     buf2, joiner, j);\n+\t    buf = (char *) alloca (strlen (VTABLE_NAME_FORMAT)\n+\t\t\t\t   + strlen (buf1) + 1);\n+\t    sprintf (buf, VTABLE_NAME_FORMAT, buf1);\n+\t    name = get_identifier (buf);\n+\n+\t    /* If this name doesn't clash, then we can use it,\n+\t       otherwise we add something different to the name until\n+\t       it is unique.  */\n+\t  } while (++j <= 999 && IDENTIFIER_GLOBAL_VALUE (name));\n+\n+\t  /* Hey, they really like MI don't they?  Increase the 3\n+             above to 6, and the 999 to 999999.  :-)  */\n+\t  my_friendly_assert (j <= 999, 369);\n+\n+\t  break;\n+\t}\n \n       i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1 + i;\n       new_buf2 = (char *) alloca (i);"}, {"sha": "6e7c876467f617e05a56d5348ee77963a0c865d1", "filename": "gcc/cp/except.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "patch": "@@ -440,8 +440,7 @@ build_eh_type (exp)\n    if it is, it avoids destroying the object on rethrow.  */\n \n static tree\n-do_pop_exception (handler)\n-     tree handler;\n+do_pop_exception ()\n {\n   tree fn, cleanup;\n   fn = get_identifier (\"__cp_pop_exception\");\n@@ -456,9 +455,7 @@ do_pop_exception (handler)\n       fn = build_lang_decl\n \t(FUNCTION_DECL, fn,\n \t build_function_type (void_type_node, tree_cons\n-\t\t\t      (NULL_TREE, ptr_type_node, tree_cons\n-\t\t\t       (NULL_TREE, boolean_type_node,\n-\t\t\t\tvoid_list_node))));\n+\t\t\t      (NULL_TREE, ptr_type_node, void_list_node)));\n       DECL_EXTERNAL (fn) = 1;\n       TREE_PUBLIC (fn) = 1;\n       DECL_ARTIFICIAL (fn) = 1;\n@@ -471,8 +468,7 @@ do_pop_exception (handler)\n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n   cleanup = lookup_name (get_identifier (\"__exception_info\"), 0);\n   cleanup = build_function_call (fn, expr_tree_cons\n-\t\t\t\t (NULL_TREE, cleanup, expr_tree_cons\n-\t\t\t\t  (NULL_TREE, handler, NULL_TREE)));\n+\t\t\t\t (NULL_TREE, cleanup, NULL_TREE));\n   return cleanup;\n }\n \n@@ -481,17 +477,15 @@ do_pop_exception (handler)\n static void\n push_eh_cleanup ()\n {\n-  /* All cleanups must last longer than normal.  */\n-  int yes = suspend_momentary ();\n-  expand_decl_cleanup_no_eh (NULL_TREE, do_pop_exception (boolean_false_node));\n-  resume_momentary (yes);\n+  int yes;\n \n   expand_expr (build_unary_op (PREINCREMENT_EXPR, get_eh_handlers (), 1),\n \t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* We don't destroy the exception object on rethrow, so we can't use\n-     the normal cleanup mechanism for it.  */\n-  expand_eh_region_start ();\n+  yes = suspend_momentary ();\n+  /* All cleanups must last longer than normal.  */\n+  expand_decl_cleanup (NULL_TREE, do_pop_exception ());\n+  resume_momentary (yes);\n }\n \n /* call this to start a catch block. Typename is the typename, and identifier\n@@ -657,9 +651,6 @@ expand_end_catch_block ()\n   expand_end_bindings (getdecls (), kept_level_p (), 0);\n   poplevel (kept_level_p (), 1, 0);\n       \n-  /* Matches push_eh_cleanup.  */\n-  expand_eh_region_end (do_pop_exception (boolean_true_node));\n-\n   /* Cleanup the EH object.  */\n   expand_end_bindings (getdecls (), kept_level_p (), 0);\n   poplevel (kept_level_p (), 1, 0);"}, {"sha": "aa5a46e2b266d8f333c2188a8c3f5468ad2012c7", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de35891e2105fde8ce0f0a2e3a9f2fab01d87cce/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=de35891e2105fde8ce0f0a2e3a9f2fab01d87cce", "patch": "@@ -126,17 +126,20 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n \n /* Compiler hook to pop an exception that has been finalized.  Used by\n    push_eh_cleanup().  P is the info for the exception caught by the\n-   current catch block, and HANDLER determines if we've been called from\n-   an exception handler; if so, we avoid destroying the object on rethrow.  */\n+   current catch block.  */\n \n extern \"C\" void\n-__cp_pop_exception (cp_eh_info *p, bool handler)\n+__cp_pop_exception (cp_eh_info *p)\n {\n   cp_eh_info **q = &__eh_info;\n \n   --p->handlers;\n \n-  if (p->handlers > 0 || (handler && p == *q))\n+  /* Don't really pop if there are still active handlers for our exception,\n+     or if our exception is being rethrown (i.e. if the active exception is\n+     our exception and it is uncaught).  */\n+  if (p->handlers != 0\n+      || (p == *q && !p->caught))\n     return;\n \n   for (; *q; q = &((*q)->next))\n@@ -198,11 +201,14 @@ __check_eh_spec (int n, const void **spec)\n   catch (...)\n     {\n       // __exception_info is an artificial var pushed into each catch block.\n-      p = __exception_info;\n-      for (int i = 0; i < n; ++i)\n+      if (p != __exception_info)\n \t{\n-\t  if (__throw_type_match_rtti (spec[i], p->type, p->value))\n-\t    throw;\n+\t  p = __exception_info;\n+\t  for (int i = 0; i < n; ++i)\n+\t    {\n+\t      if (__throw_type_match_rtti (spec[i], p->type, p->value))\n+\t\tthrow;\n+\t    }\n \t}\n \n       const type_info &bad_exc = typeid (bad_exception);"}]}