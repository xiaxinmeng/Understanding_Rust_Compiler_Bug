{"sha": "501699af1603287b1b47ac450fd6eeb826aa76b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAxNjk5YWYxNjAzMjg3YjFiNDdhYzQ1MGZkNmVlYjgyNmFhNzZiMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-02T20:01:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-02T20:01:37Z"}, "message": "libgo: Update to weekly.2012-02-22 release.\n\nFrom-SVN: r184819", "tree": {"sha": "3eeb8918d39d675108073c8b76d6dd10586a608c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eeb8918d39d675108073c8b76d6dd10586a608c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/501699af1603287b1b47ac450fd6eeb826aa76b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501699af1603287b1b47ac450fd6eeb826aa76b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/501699af1603287b1b47ac450fd6eeb826aa76b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501699af1603287b1b47ac450fd6eeb826aa76b1/comments", "author": null, "committer": null, "parents": [{"sha": "34c5f21a387dc461042bafc3052ce6e1af786a77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c5f21a387dc461042bafc3052ce6e1af786a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34c5f21a387dc461042bafc3052ce6e1af786a77"}], "stats": {"total": 6886, "additions": 4875, "deletions": 2011}, "files": [{"sha": "3c8e4232838e017faaf17d2c6a0f613cb9907369", "filename": "gcc/testsuite/go.test/test/env.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,6 +4,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Test that the Go environment variables are present and accessible through\n+// package os and package runtime.\n+\n package main\n \n import (\n@@ -12,18 +15,14 @@ import (\n )\n \n func main() {\n-\tga, e0 := os.Getenverror(\"GOARCH\")\n-\tif e0 != nil {\n-\t\tprint(\"$GOARCH: \", e0.Error(), \"\\n\")\n-\t\tos.Exit(1)\n-\t}\n+\tga := os.Getenv(\"GOARCH\")\n \tif ga != runtime.GOARCH {\n \t\tprint(\"$GOARCH=\", ga, \"!= runtime.GOARCH=\", runtime.GOARCH, \"\\n\")\n \t\tos.Exit(1)\n \t}\n-\txxx, e1 := os.Getenverror(\"DOES_NOT_EXIST\")\n-\tif e1 != os.ENOENV {\n-\t\tprint(\"$DOES_NOT_EXIST=\", xxx, \"; err = \", e1.Error(), \"\\n\")\n+\txxx := os.Getenv(\"DOES_NOT_EXIST\")\n+\tif xxx != \"\" {\n+\t\tprint(\"$DOES_NOT_EXIST=\", xxx, \"\\n\")\n \t\tos.Exit(1)\n \t}\n }"}, {"sha": "ebca7905f9ad3f4167c10d1826b0153546bc3e65", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug262.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,7 +7,7 @@\n package main\n \n import (\n-\t\"os\"\n+\t\"errors\"\n \t\"strconv\"\n )\n \n@@ -44,7 +44,7 @@ func main() {\n \t}\n \tmm := make(map[string]error)\n \ttrace = \"\"\n-\tmm[\"abc\"] = os.EINVAL\n+\tmm[\"abc\"] = errors.New(\"invalid\")\n \t*i(), mm[f()] = strconv.Atoi(h())\n \tif mm[\"abc\"] != nil || trace != \"ifh\" {\n \t\tprintln(\"BUG1\", mm[\"abc\"], trace)"}, {"sha": "9605a8a9040b295ee925be1680d303790adcdc6b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,4 +1,4 @@\n-43cf9b39b647\n+96bd78e7d35e\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "eb764df0eab88e16d24128bd0af4dbe27bae6ef9", "filename": "libgo/Makefile.am", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -504,7 +504,7 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \tmv -f $@.tmp $@\n \n sema.c: $(srcdir)/runtime/sema.goc goc2c\n-\t./goc2c --gcc --go-prefix libgo_runtime $< > $@.tmp\n+\t./goc2c --gcc --go-prefix libgo_sync $< > $@.tmp\n \tmv -f $@.tmp $@\n \n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n@@ -847,6 +847,7 @@ go_sync_files = \\\n \tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n+\tgo/sync/runtime.go \\\n \tgo/sync/rwmutex.go \\\n \tgo/sync/waitgroup.go\n \n@@ -878,6 +879,7 @@ go_time_files = \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo.go \\\n+\tgo/time/zoneinfo_read.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_unicode_files = \\\n@@ -1091,6 +1093,7 @@ go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n \tgo/exp/norm/input.go \\\n+\tgo/exp/norm/iter.go \\\n \tgo/exp/norm/normalize.go \\\n \tgo/exp/norm/readwriter.go \\\n \tgo/exp/norm/tables.go \\\n@@ -1132,7 +1135,8 @@ go_go_doc_files = \\\n \tgo/go/doc/example.go \\\n \tgo/go/doc/exports.go \\\n \tgo/go/doc/filter.go \\\n-\tgo/go/doc/reader.go\n+\tgo/go/doc/reader.go \\\n+\tgo/go/doc/synopsis.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1159,7 +1163,6 @@ go_hash_fnv_files = \\\n \n go_html_template_files = \\\n \tgo/html/template/attr.go \\\n-\tgo/html/template/clone.go \\\n \tgo/html/template/content.go \\\n \tgo/html/template/context.go \\\n \tgo/html/template/css.go \\"}, {"sha": "4604e560c9b6caf128a48b8b4d7e44a9d35e668b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1157,6 +1157,7 @@ go_sync_files = \\\n \tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n+\tgo/sync/runtime.go \\\n \tgo/sync/rwmutex.go \\\n \tgo/sync/waitgroup.go\n \n@@ -1182,6 +1183,7 @@ go_time_files = \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo.go \\\n+\tgo/time/zoneinfo_read.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_unicode_files = \\\n@@ -1427,6 +1429,7 @@ go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n \tgo/exp/norm/input.go \\\n+\tgo/exp/norm/iter.go \\\n \tgo/exp/norm/normalize.go \\\n \tgo/exp/norm/readwriter.go \\\n \tgo/exp/norm/tables.go \\\n@@ -1474,7 +1477,8 @@ go_go_doc_files = \\\n \tgo/go/doc/example.go \\\n \tgo/go/doc/exports.go \\\n \tgo/go/doc/filter.go \\\n-\tgo/go/doc/reader.go\n+\tgo/go/doc/reader.go \\\n+\tgo/go/doc/synopsis.go\n \n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n@@ -1508,7 +1512,6 @@ go_hash_fnv_files = \\\n \n go_html_template_files = \\\n \tgo/html/template/attr.go \\\n-\tgo/html/template/clone.go \\\n \tgo/html/template/content.go \\\n \tgo/html/template/context.go \\\n \tgo/html/template/css.go \\\n@@ -4318,7 +4321,7 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \tmv -f $@.tmp $@\n \n sema.c: $(srcdir)/runtime/sema.goc goc2c\n-\t./goc2c --gcc --go-prefix libgo_runtime $< > $@.tmp\n+\t./goc2c --gcc --go-prefix libgo_sync $< > $@.tmp\n \tmv -f $@.tmp $@\n \n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c"}, {"sha": "6f3b1eec9713a200f42517f0d79e34c4e1b13f29", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -106,9 +106,12 @@ func (b *Reader) Peek(n int) ([]byte, error) {\n \tif m > n {\n \t\tm = n\n \t}\n-\terr := b.readErr()\n-\tif m < n && err == nil {\n-\t\terr = ErrBufferFull\n+\tvar err error\n+\tif m < n {\n+\t\terr = b.readErr()\n+\t\tif err == nil {\n+\t\t\terr = ErrBufferFull\n+\t\t}\n \t}\n \treturn b.buf[b.r : b.r+m], err\n }"}, {"sha": "a43cbd23a64d0eae2fd5e2c0d2efaf18b80e8800", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -539,6 +539,27 @@ func TestPeek(t *testing.T) {\n \tif _, err := buf.Peek(1); err != io.EOF {\n \t\tt.Fatalf(\"want EOF got %v\", err)\n \t}\n+\n+\t// Test for issue 3022, not exposing a reader's error on a successful Peek.\n+\tbuf = NewReaderSize(dataAndEOFReader(\"abcd\"), 32)\n+\tif s, err := buf.Peek(2); string(s) != \"ab\" || err != nil {\n+\t\tt.Errorf(`Peek(2) on \"abcd\", EOF = %q, %v; want \"ab\", nil`, string(s), err)\n+\t}\n+\tif s, err := buf.Peek(4); string(s) != \"abcd\" || err != nil {\n+\t\tt.Errorf(`Peek(4) on \"abcd\", EOF = %q, %v; want \"abcd\", nil`, string(s), err)\n+\t}\n+\tif n, err := buf.Read(p[0:5]); string(p[0:n]) != \"abcd\" || err != nil {\n+\t\tt.Fatalf(\"Read after peek = %q, %v; want abcd, EOF\", p[0:n], err)\n+\t}\n+\tif n, err := buf.Read(p[0:1]); string(p[0:n]) != \"\" || err != io.EOF {\n+\t\tt.Fatalf(`second Read after peek = %q, %v; want \"\", EOF`, p[0:n], err)\n+\t}\n+}\n+\n+type dataAndEOFReader string\n+\n+func (r dataAndEOFReader) Read(p []byte) (int, error) {\n+\treturn copy(p, r), io.EOF\n }\n \n func TestPeekThenUnreadRune(t *testing.T) {"}, {"sha": "7d1426fb4174d8197b7370933a4947e5dc456115", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -13,6 +13,7 @@ import (\n \n // Compare returns an integer comparing the two byte arrays lexicographically.\n // The result will be 0 if a==b, -1 if a < b, and +1 if a > b\n+// A nil argument is equivalent to an empty slice.\n func Compare(a, b []byte) int {\n \tm := len(a)\n \tif m > len(b) {\n@@ -37,6 +38,7 @@ func Compare(a, b []byte) int {\n }\n \n // Equal returns a boolean reporting whether a == b.\n+// A nil argument is equivalent to an empty slice.\n func Equal(a, b []byte) bool\n \n func equalPortable(a, b []byte) bool {"}, {"sha": "000f235176df8d7a01f42dba4f095dd6cfa9ff4e", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -46,32 +46,39 @@ type BinOpTest struct {\n \ti int\n }\n \n-var comparetests = []BinOpTest{\n-\t{\"\", \"\", 0},\n-\t{\"a\", \"\", 1},\n-\t{\"\", \"a\", -1},\n-\t{\"abc\", \"abc\", 0},\n-\t{\"ab\", \"abc\", -1},\n-\t{\"abc\", \"ab\", 1},\n-\t{\"x\", \"ab\", 1},\n-\t{\"ab\", \"x\", -1},\n-\t{\"x\", \"a\", 1},\n-\t{\"b\", \"x\", -1},\n+var compareTests = []struct {\n+\ta, b []byte\n+\ti    int\n+}{\n+\t{[]byte(\"\"), []byte(\"\"), 0},\n+\t{[]byte(\"a\"), []byte(\"\"), 1},\n+\t{[]byte(\"\"), []byte(\"a\"), -1},\n+\t{[]byte(\"abc\"), []byte(\"abc\"), 0},\n+\t{[]byte(\"ab\"), []byte(\"abc\"), -1},\n+\t{[]byte(\"abc\"), []byte(\"ab\"), 1},\n+\t{[]byte(\"x\"), []byte(\"ab\"), 1},\n+\t{[]byte(\"ab\"), []byte(\"x\"), -1},\n+\t{[]byte(\"x\"), []byte(\"a\"), 1},\n+\t{[]byte(\"b\"), []byte(\"x\"), -1},\n+\t// nil tests\n+\t{nil, nil, 0},\n+\t{[]byte(\"\"), nil, 0},\n+\t{nil, []byte(\"\"), 0},\n+\t{[]byte(\"a\"), nil, 1},\n+\t{nil, []byte(\"a\"), -1},\n }\n \n func TestCompare(t *testing.T) {\n-\tfor _, tt := range comparetests {\n-\t\ta := []byte(tt.a)\n-\t\tb := []byte(tt.b)\n-\t\tcmp := Compare(a, b)\n+\tfor _, tt := range compareTests {\n+\t\tcmp := Compare(tt.a, tt.b)\n \t\tif cmp != tt.i {\n \t\t\tt.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)\n \t\t}\n-\t\teql := Equal(a, b)\n+\t\teql := Equal(tt.a, tt.b)\n \t\tif eql != (tt.i == 0) {\n \t\t\tt.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql)\n \t\t}\n-\t\teql = EqualPortable(a, b)\n+\t\teql = EqualPortable(tt.a, tt.b)\n \t\tif eql != (tt.i == 0) {\n \t\t\tt.Errorf(`EqualPortable(%q, %q) = %v`, tt.a, tt.b, eql)\n \t\t}"}, {"sha": "6fe8cd5a90cc3736eeb7ade9cd648cdf26ca9cef", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -11,18 +11,18 @@ import (\n \t\"os\"\n )\n \n-// Hello world!\n func ExampleBuffer() {\n \tvar b Buffer // A Buffer needs no initialization.\n \tb.Write([]byte(\"Hello \"))\n \tb.Write([]byte(\"world!\"))\n \tb.WriteTo(os.Stdout)\n+\t// Output: Hello world!\n }\n \n-// Gophers rule!\n func ExampleBuffer_reader() {\n \t// A Buffer can turn a string or a []byte into an io.Reader.\n \tbuf := NewBufferString(\"R29waGVycyBydWxlIQ==\")\n \tdec := base64.NewDecoder(base64.StdEncoding, buf)\n \tio.Copy(os.Stdout, dec)\n+\t// Output: Gophers rule!\n }"}, {"sha": "543c5950586ce3e31a49bdf6b1cc4fab8499e605", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -306,6 +306,9 @@ func TestDeflateInflateString(t *testing.T) {\n \t\t\tt.Error(err)\n \t\t}\n \t\ttestToFromWithLimit(t, gold, test.label, test.limit)\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n \n@@ -363,6 +366,10 @@ func TestWriterDict(t *testing.T) {\n \n // See http://code.google.com/p/go/issues/detail?id=2508\n func TestRegression2508(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"test disabled with -short\")\n+\t\treturn\n+\t}\n \tw, err := NewWriter(ioutil.Discard, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"NewWriter: %v\", err)"}, {"sha": "2050bc835915d1d3dab107af03354637d0fb37ce", "filename": "libgo/go/container/heap/example_test.go", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -57,11 +57,26 @@ func (pq *PriorityQueue) Pop() interface{} {\n \treturn item\n }\n \n-// 99:seven 88:five 77:zero 66:nine 55:three 44:two 33:six 22:one 11:four 00:eight\n-func ExampleInterface() {\n-\t// The full code of this example, including the methods that implement\n-\t// heap.Interface, is in the file src/pkg/container/heap/example_test.go.\n+// update is not used by the example but shows how to take the top item from\n+// the queue, update its priority and value, and put it back.\n+func (pq *PriorityQueue) update(value string, priority int) {\n+\titem := heap.Pop(pq).(*Item)\n+\titem.value = value\n+\titem.priority = priority\n+\theap.Push(pq, item)\n+}\n \n+// changePriority is not used by the example but shows how to change the\n+// priority of an arbitrary item.\n+func (pq *PriorityQueue) changePriority(item *Item, priority int) {\n+\theap.Remove(pq, item.index)\n+\titem.priority = priority\n+\theap.Push(pq, item)\n+}\n+\n+// This example pushes 10 items into a PriorityQueue and takes them out in\n+// order of priority.\n+func Example() {\n \tconst nItem = 10\n \t// Random priorities for the items (a permutation of 0..9, times 11)).\n \tpriorities := [nItem]int{\n@@ -85,21 +100,6 @@ func ExampleInterface() {\n \t\titem := heap.Pop(&pq).(*Item)\n \t\tfmt.Printf(\"%.2d:%s \", item.priority, item.value)\n \t}\n-}\n-\n-// update is not used by the example but shows how to take the top item from the queue,\n-// update its priority and value, and put it back.\n-func (pq *PriorityQueue) update(value string, priority int) {\n-\titem := heap.Pop(pq).(*Item)\n-\titem.value = value\n-\titem.priority = priority\n-\theap.Push(pq, item)\n-}\n-\n-// changePriority is not used by the example but shows how to change the priority of an arbitrary\n-// item.\n-func (pq *PriorityQueue) changePriority(item *Item, priority int) {\n-\theap.Remove(pq, item.index)\n-\titem.priority = priority\n-\theap.Push(pq, item)\n+\t// Output:\n+\t// 99:seven 88:five 77:zero 66:nine 55:three 44:two 33:six 22:one 11:four 00:eight\n }"}, {"sha": "05766a2f13684411e927eef28dd48ee28b11fd80", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3\n+// Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n package dsa\n \n import ("}, {"sha": "aae875464f92b486f81ca9463f7cffc537933a2a", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,9 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package md5\n+package md5_test\n \n import (\n+\t\"crypto/md5\"\n \t\"fmt\"\n \t\"io\"\n \t\"testing\"\n@@ -52,7 +53,7 @@ var golden = []md5Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n-\t\tc := New()\n+\t\tc := md5.New()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {\n \t\t\t\tio.WriteString(c, g.in)\n@@ -69,3 +70,11 @@ func TestGolden(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func ExampleNew() {\n+\th := md5.New()\n+\tio.WriteString(h, \"The fog is getting thicker!\")\n+\tio.WriteString(h, \"And Leon's getting laaarger!\")\n+\tfmt.Printf(\"%x\", h.Sum(nil))\n+\t// Output: e2c569be17396eca2a2e3c11578123ed\n+}"}, {"sha": "2dc14ac986807b058922cd6b1f71178238f0d4c6", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,9 +4,10 @@\n \n // SHA1 hash algorithm.  See RFC 3174.\n \n-package sha1\n+package sha1_test\n \n import (\n+\t\"crypto/sha1\"\n \t\"fmt\"\n \t\"io\"\n \t\"testing\"\n@@ -54,7 +55,7 @@ var golden = []sha1Test{\n func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n-\t\tc := New()\n+\t\tc := sha1.New()\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tif j < 2 {\n \t\t\t\tio.WriteString(c, g.in)\n@@ -71,3 +72,10 @@ func TestGolden(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func ExampleNew() {\n+\th := sha1.New()\n+\tio.WriteString(h, \"His money is twice tainted: 'taint yours and 'taint mine.\")\n+\tfmt.Printf(\"% x\", h.Sum(nil))\n+\t// Output: 59 7f 6a 54 00 10 f9 4c 15 d7 18 06 a9 9a 2c 87 10 e7 47 bd\n+}"}, {"sha": "0d7b806ff5b17da7b69d7b7eedf2c538e76a8a03", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -273,7 +273,7 @@ func (c *Conn) clientHandshake() error {\n \tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n \t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n-\tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */ )\n+\tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */)\n \tclientHash := suite.mac(c.vers, clientMAC)\n \tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n@@ -294,7 +294,7 @@ func (c *Conn) clientHandshake() error {\n \tfinishedHash.Write(finished.marshal())\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n-\tserverCipher := suite.cipher(serverKey, serverIV, true /* for reading */ )\n+\tserverCipher := suite.cipher(serverKey, serverIV, true /* for reading */)\n \tserverHash := suite.mac(c.vers, serverMAC)\n \tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.readRecord(recordTypeChangeCipherSpec)"}, {"sha": "23ec5587235b5d2eebe2aa961fffc7924c99e5ee", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -295,7 +295,7 @@ FindCipherSuite:\n \tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n \t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, clientHello.random, hello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n-\tclientCipher := suite.cipher(clientKey, clientIV, true /* for reading */ )\n+\tclientCipher := suite.cipher(clientKey, clientIV, true /* for reading */)\n \tclientHash := suite.mac(c.vers, clientMAC)\n \tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n@@ -333,7 +333,7 @@ FindCipherSuite:\n \n \tfinishedHash.Write(clientFinished.marshal())\n \n-\tserverCipher := suite.cipher(serverKey, serverIV, false /* not for reading */ )\n+\tserverCipher := suite.cipher(serverKey, serverIV, false /* not for reading */)\n \tserverHash := suite.mac(c.vers, serverMAC)\n \tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})"}, {"sha": "bfcb03ccf8d42ac627f6d207d0e0f773f78353e2", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -17,8 +17,8 @@ import (\n // subsetTypeArgs takes a slice of arguments from callers of the sql\n // package and converts them into a slice of the driver package's\n // \"subset types\".\n-func subsetTypeArgs(args []interface{}) ([]interface{}, error) {\n-\tout := make([]interface{}, len(args))\n+func subsetTypeArgs(args []interface{}) ([]driver.Value, error) {\n+\tout := make([]driver.Value, len(args))\n \tfor n, arg := range args {\n \t\tvar err error\n \t\tout[n], err = driver.DefaultParameterConverter.ConvertValue(arg)"}, {"sha": "7f986b80f2cb99e99c73102ea8b71f7da94731d4", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,21 +6,20 @@\n // drivers as used by package sql.\n //\n // Most code should use package sql.\n-//\n-// Drivers only need to be aware of a subset of Go's types.  The sql package\n-// will convert all types into one of the following:\n+package driver\n+\n+import \"errors\"\n+\n+// A driver Value is a value that drivers must be able to handle.\n+// A Value is either nil or an instance of one of these types:\n //\n //   int64\n //   float64\n //   bool\n-//   nil\n //   []byte\n //   string   [*] everywhere except from Rows.Next.\n //   time.Time\n-//\n-package driver\n-\n-import \"errors\"\n+type Value interface{}\n \n // Driver is the interface that must be implemented by a database\n // driver.\n@@ -50,11 +49,9 @@ var ErrSkip = errors.New(\"driver: skip fast-path; continue as if unimplemented\")\n // first prepare a query, execute the statement, and then close the\n // statement.\n //\n-// All arguments are of a subset type as defined in the package docs.\n-//\n // Exec may return ErrSkip.\n type Execer interface {\n-\tExec(query string, args []interface{}) (Result, error)\n+\tExec(query string, args []Value) (Result, error)\n }\n \n // Conn is a connection to a database. It is not used concurrently\n@@ -127,18 +124,17 @@ type Stmt interface {\n \tNumInput() int\n \n \t// Exec executes a query that doesn't return rows, such\n-\t// as an INSERT or UPDATE.  The args are all of a subset\n-\t// type as defined above.\n-\tExec(args []interface{}) (Result, error)\n+\t// as an INSERT or UPDATE.\n+\tExec(args []Value) (Result, error)\n \n \t// Exec executes a query that may return rows, such as a\n-\t// SELECT.  The args of all of a subset type as defined above.\n-\tQuery(args []interface{}) (Rows, error)\n+\t// SELECT.\n+\tQuery(args []Value) (Rows, error)\n }\n \n // ColumnConverter may be optionally implemented by Stmt if the\n // the statement is aware of its own columns' types and can\n-// convert from any type to a driver subset type.\n+// convert from any type to a driver Value.\n type ColumnConverter interface {\n \t// ColumnConverter returns a ValueConverter for the provided\n \t// column index.  If the type of a specific column isn't known\n@@ -162,12 +158,12 @@ type Rows interface {\n \t// the provided slice. The provided slice will be the same\n \t// size as the Columns() are wide.\n \t//\n-\t// The dest slice may be populated with only with values\n-\t// of subset types defined above, but excluding string.\n+\t// The dest slice may be populated only with\n+\t// a driver Value type, but excluding string.\n \t// All string values must be converted to []byte.\n \t//\n \t// Next should return io.EOF when there are no more rows.\n-\tNext(dest []interface{}) error\n+\tNext(dest []Value) error\n }\n \n // Tx is a transaction.\n@@ -190,18 +186,19 @@ func (v RowsAffected) RowsAffected() (int64, error) {\n \treturn int64(v), nil\n }\n \n-// DDLSuccess is a pre-defined Result for drivers to return when a DDL\n-// command succeeds.\n-var DDLSuccess ddlSuccess\n+// ResultNoRows is a pre-defined Result for drivers to return when a DDL\n+// command (such as a CREATE TABLE) succeeds. It returns an error for both\n+// LastInsertId and RowsAffected.\n+var ResultNoRows noRows\n \n-type ddlSuccess struct{}\n+type noRows struct{}\n \n-var _ Result = ddlSuccess{}\n+var _ Result = noRows{}\n \n-func (ddlSuccess) LastInsertId() (int64, error) {\n+func (noRows) LastInsertId() (int64, error) {\n \treturn 0, errors.New(\"no LastInsertId available after DDL statement\")\n }\n \n-func (ddlSuccess) RowsAffected() (int64, error) {\n+func (noRows) RowsAffected() (int64, error) {\n \treturn 0, errors.New(\"no RowsAffected available after DDL statement\")\n }"}, {"sha": "3305354dfd0d66183d96545bbae100d8c3d52450", "filename": "libgo/go/database/sql/driver/types.go", "status": "modified", "additions": 30, "deletions": 50, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -17,28 +17,28 @@ import (\n // driver package to provide consistent implementations of conversions\n // between drivers.  The ValueConverters have several uses:\n //\n-//  * converting from the subset types as provided by the sql package\n+//  * converting from the Value types as provided by the sql package\n //    into a database table's specific column type and making sure it\n //    fits, such as making sure a particular int64 fits in a\n //    table's uint16 column.\n //\n //  * converting a value as given from the database into one of the\n-//    subset types.\n+//    driver Value types.\n //\n-//  * by the sql package, for converting from a driver's subset type\n+//  * by the sql package, for converting from a driver's Value type\n //    to a user's type in a scan.\n type ValueConverter interface {\n-\t// ConvertValue converts a value to a restricted subset type.\n-\tConvertValue(v interface{}) (interface{}, error)\n+\t// ConvertValue converts a value to a driver Value.\n+\tConvertValue(v interface{}) (Value, error)\n }\n \n-// SubsetValuer is the interface providing the SubsetValue method.\n+// Valuer is the interface providing the Value method.\n //\n-// Types implementing SubsetValuer interface are able to convert\n-// themselves to one of the driver's allowed subset values.\n-type SubsetValuer interface {\n-\t// SubsetValue returns a driver parameter subset value.\n-\tSubsetValue() (interface{}, error)\n+// Types implementing Valuer interface are able to convert\n+// themselves to a driver Value.\n+type Valuer interface {\n+\t// Value returns a driver Value.\n+\tValue() (Value, error)\n }\n \n // Bool is a ValueConverter that converts input values to bools.\n@@ -59,7 +59,7 @@ var _ ValueConverter = boolType{}\n \n func (boolType) String() string { return \"Bool\" }\n \n-func (boolType) ConvertValue(src interface{}) (interface{}, error) {\n+func (boolType) ConvertValue(src interface{}) (Value, error) {\n \tswitch s := src.(type) {\n \tcase bool:\n \t\treturn s, nil\n@@ -104,7 +104,7 @@ type int32Type struct{}\n \n var _ ValueConverter = int32Type{}\n \n-func (int32Type) ConvertValue(v interface{}) (interface{}, error) {\n+func (int32Type) ConvertValue(v interface{}) (Value, error) {\n \trv := reflect.ValueOf(v)\n \tswitch rv.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n@@ -137,7 +137,7 @@ var String stringType\n \n type stringType struct{}\n \n-func (stringType) ConvertValue(v interface{}) (interface{}, error) {\n+func (stringType) ConvertValue(v interface{}) (Value, error) {\n \tswitch v.(type) {\n \tcase string, []byte:\n \t\treturn v, nil\n@@ -151,7 +151,7 @@ type Null struct {\n \tConverter ValueConverter\n }\n \n-func (n Null) ConvertValue(v interface{}) (interface{}, error) {\n+func (n Null) ConvertValue(v interface{}) (Value, error) {\n \tif v == nil {\n \t\treturn nil, nil\n \t}\n@@ -164,28 +164,17 @@ type NotNull struct {\n \tConverter ValueConverter\n }\n \n-func (n NotNull) ConvertValue(v interface{}) (interface{}, error) {\n+func (n NotNull) ConvertValue(v interface{}) (Value, error) {\n \tif v == nil {\n \t\treturn nil, fmt.Errorf(\"nil value not allowed\")\n \t}\n \treturn n.Converter.ConvertValue(v)\n }\n \n-// IsParameterSubsetType reports whether v is of a valid type for a\n-// parameter. These types are:\n-//\n-//   int64\n-//   float64\n-//   bool\n-//   nil\n-//   []byte\n-//   time.Time\n-//   string\n-//\n-// This is the same list as IsScanSubsetType, with the addition of\n-// string.\n-func IsParameterSubsetType(v interface{}) bool {\n-\tif IsScanSubsetType(v) {\n+// IsValue reports whether v is a valid Value parameter type.\n+// Unlike IsScanValue, IsValue permits the string type.\n+func IsValue(v interface{}) bool {\n+\tif IsScanValue(v) {\n \t\treturn true\n \t}\n \tif _, ok := v.(string); ok {\n@@ -194,18 +183,9 @@ func IsParameterSubsetType(v interface{}) bool {\n \treturn false\n }\n \n-// IsScanSubsetType reports whether v is of a valid type for a\n-// value populated by Rows.Next. These types are:\n-//\n-//   int64\n-//   float64\n-//   bool\n-//   nil\n-//   []byte\n-//   time.Time\n-//\n-// This is the same list as IsParameterSubsetType, without string.\n-func IsScanSubsetType(v interface{}) bool {\n+// IsScanValue reports whether v is a valid Value scan type.\n+// Unlike IsValue, IsScanValue does not permit the string type.\n+func IsScanValue(v interface{}) bool {\n \tif v == nil {\n \t\treturn true\n \t}\n@@ -221,7 +201,7 @@ func IsScanSubsetType(v interface{}) bool {\n // ColumnConverter.\n //\n // DefaultParameterConverter returns the given value directly if\n-// IsSubsetType(value).  Otherwise integer type are converted to\n+// IsValue(value).  Otherwise integer type are converted to\n // int64, floats to float64, and strings to []byte.  Other types are\n // an error.\n var DefaultParameterConverter defaultConverter\n@@ -230,18 +210,18 @@ type defaultConverter struct{}\n \n var _ ValueConverter = defaultConverter{}\n \n-func (defaultConverter) ConvertValue(v interface{}) (interface{}, error) {\n-\tif IsParameterSubsetType(v) {\n+func (defaultConverter) ConvertValue(v interface{}) (Value, error) {\n+\tif IsValue(v) {\n \t\treturn v, nil\n \t}\n \n-\tif svi, ok := v.(SubsetValuer); ok {\n-\t\tsv, err := svi.SubsetValue()\n+\tif svi, ok := v.(Valuer); ok {\n+\t\tsv, err := svi.Value()\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tif !IsParameterSubsetType(sv) {\n-\t\t\treturn nil, fmt.Errorf(\"non-subset type %T returned from SubsetValue\", sv)\n+\t\tif !IsValue(sv) {\n+\t\t\treturn nil, fmt.Errorf(\"non-Value type %T returned from Value\", sv)\n \t\t}\n \t\treturn sv, nil\n \t}"}, {"sha": "fc63f03740ac0a4e68310f0935231040e5dd4d36", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -217,7 +217,7 @@ func (c *fakeConn) Close() error {\n \treturn nil\n }\n \n-func checkSubsetTypes(args []interface{}) error {\n+func checkSubsetTypes(args []driver.Value) error {\n \tfor n, arg := range args {\n \t\tswitch arg.(type) {\n \t\tcase int64, float64, bool, nil, []byte, string, time.Time:\n@@ -228,7 +228,7 @@ func checkSubsetTypes(args []interface{}) error {\n \treturn nil\n }\n \n-func (c *fakeConn) Exec(query string, args []interface{}) (driver.Result, error) {\n+func (c *fakeConn) Exec(query string, args []driver.Value) (driver.Result, error) {\n \t// This is an optional interface, but it's implemented here\n \t// just to check that all the args of of the proper types.\n \t// ErrSkip is returned so the caller acts as if we didn't\n@@ -379,7 +379,7 @@ func (s *fakeStmt) Close() error {\n \n var errClosed = errors.New(\"fakedb: statement has been closed\")\n \n-func (s *fakeStmt) Exec(args []interface{}) (driver.Result, error) {\n+func (s *fakeStmt) Exec(args []driver.Value) (driver.Result, error) {\n \tif s.closed {\n \t\treturn nil, errClosed\n \t}\n@@ -392,20 +392,20 @@ func (s *fakeStmt) Exec(args []interface{}) (driver.Result, error) {\n \tswitch s.cmd {\n \tcase \"WIPE\":\n \t\tdb.wipe()\n-\t\treturn driver.DDLSuccess, nil\n+\t\treturn driver.ResultNoRows, nil\n \tcase \"CREATE\":\n \t\tif err := db.createTable(s.table, s.colName, s.colType); err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn driver.DDLSuccess, nil\n+\t\treturn driver.ResultNoRows, nil\n \tcase \"INSERT\":\n \t\treturn s.execInsert(args)\n \t}\n \tfmt.Printf(\"EXEC statement, cmd=%q: %#v\\n\", s.cmd, s)\n \treturn nil, fmt.Errorf(\"unimplemented statement Exec command type of %q\", s.cmd)\n }\n \n-func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, error) {\n+func (s *fakeStmt) execInsert(args []driver.Value) (driver.Result, error) {\n \tdb := s.c.db\n \tif len(args) != s.placeholders {\n \t\tpanic(\"error in pkg db; should only get here if size is correct\")\n@@ -441,7 +441,7 @@ func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, error) {\n \treturn driver.RowsAffected(1), nil\n }\n \n-func (s *fakeStmt) Query(args []interface{}) (driver.Rows, error) {\n+func (s *fakeStmt) Query(args []driver.Value) (driver.Rows, error) {\n \tif s.closed {\n \t\treturn nil, errClosed\n \t}\n@@ -548,7 +548,7 @@ func (rc *rowsCursor) Columns() []string {\n \treturn rc.cols\n }\n \n-func (rc *rowsCursor) Next(dest []interface{}) error {\n+func (rc *rowsCursor) Next(dest []driver.Value) error {\n \tif rc.closed {\n \t\treturn errors.New(\"fakedb: cursor is closed\")\n \t}"}, {"sha": "62b551d89b537ae098ce9f6723df850d660a85b4", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -62,8 +62,8 @@ func (ns *NullString) Scan(value interface{}) error {\n \treturn convertAssign(&ns.String, value)\n }\n \n-// SubsetValue implements the driver SubsetValuer interface.\n-func (ns NullString) SubsetValue() (interface{}, error) {\n+// Value implements the driver Valuer interface.\n+func (ns NullString) Value() (driver.Value, error) {\n \tif !ns.Valid {\n \t\treturn nil, nil\n \t}\n@@ -88,8 +88,8 @@ func (n *NullInt64) Scan(value interface{}) error {\n \treturn convertAssign(&n.Int64, value)\n }\n \n-// SubsetValue implements the driver SubsetValuer interface.\n-func (n NullInt64) SubsetValue() (interface{}, error) {\n+// Value implements the driver Valuer interface.\n+func (n NullInt64) Value() (driver.Value, error) {\n \tif !n.Valid {\n \t\treturn nil, nil\n \t}\n@@ -114,8 +114,8 @@ func (n *NullFloat64) Scan(value interface{}) error {\n \treturn convertAssign(&n.Float64, value)\n }\n \n-// SubsetValue implements the driver SubsetValuer interface.\n-func (n NullFloat64) SubsetValue() (interface{}, error) {\n+// Value implements the driver Valuer interface.\n+func (n NullFloat64) Value() (driver.Value, error) {\n \tif !n.Valid {\n \t\treturn nil, nil\n \t}\n@@ -140,8 +140,8 @@ func (n *NullBool) Scan(value interface{}) error {\n \treturn convertAssign(&n.Bool, value)\n }\n \n-// SubsetValue implements the driver SubsetValuer interface.\n-func (n NullBool) SubsetValue() (interface{}, error) {\n+// Value implements the driver Valuer interface.\n+func (n NullBool) Value() (driver.Value, error) {\n \tif !n.Valid {\n \t\treturn nil, nil\n \t}\n@@ -523,8 +523,13 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t}\n \tdefer tx.releaseConn()\n \n+\tsargs, err := subsetTypeArgs(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tif execer, ok := ci.(driver.Execer); ok {\n-\t\tresi, err := execer.Exec(query, args)\n+\t\tresi, err := execer.Exec(query, sargs)\n \t\tif err == nil {\n \t\t\treturn result{resi}, nil\n \t\t}\n@@ -539,11 +544,6 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t}\n \tdefer sti.Close()\n \n-\tsargs, err := subsetTypeArgs(args)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tresi, err := sti.Exec(sargs)\n \tif err != nil {\n \t\treturn nil, err\n@@ -618,19 +618,21 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t\treturn nil, fmt.Errorf(\"sql: expected %d arguments, got %d\", want, len(args))\n \t}\n \n+\tsargs := make([]driver.Value, len(args))\n+\n \t// Convert args to subset types.\n \tif cc, ok := si.(driver.ColumnConverter); ok {\n \t\tfor n, arg := range args {\n \t\t\t// First, see if the value itself knows how to convert\n \t\t\t// itself to a driver type.  For example, a NullString\n \t\t\t// struct changing into a string or nil.\n-\t\t\tif svi, ok := arg.(driver.SubsetValuer); ok {\n-\t\t\t\tsv, err := svi.SubsetValue()\n+\t\t\tif svi, ok := arg.(driver.Valuer); ok {\n+\t\t\t\tsv, err := svi.Value()\n \t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d from SubsetValue: %v\", n, err)\n+\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d from Value: %v\", n, err)\n \t\t\t\t}\n-\t\t\t\tif !driver.IsParameterSubsetType(sv) {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d: non-subset type %T returned from SubsetValue\", n, sv)\n+\t\t\t\tif !driver.IsValue(sv) {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d: non-subset type %T returned from Value\", n, sv)\n \t\t\t\t}\n \t\t\t\targ = sv\n \t\t\t}\n@@ -642,25 +644,25 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t\t\t// truncated), or that a nil can't go into a NOT NULL\n \t\t\t// column before going across the network to get the\n \t\t\t// same error.\n-\t\t\targs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n+\t\t\tsargs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n \t\t\t}\n-\t\t\tif !driver.IsParameterSubsetType(args[n]) {\n+\t\t\tif !driver.IsValue(sargs[n]) {\n \t\t\t\treturn nil, fmt.Errorf(\"sql: driver ColumnConverter error converted %T to unsupported type %T\",\n-\t\t\t\t\targ, args[n])\n+\t\t\t\t\targ, sargs[n])\n \t\t\t}\n \t\t}\n \t} else {\n \t\tfor n, arg := range args {\n-\t\t\targs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n+\t\t\tsargs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n \t\t\t}\n \t\t}\n \t}\n \n-\tresi, err := si.Exec(args)\n+\tresi, err := si.Exec(sargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -829,7 +831,7 @@ type Rows struct {\n \trowsi       driver.Rows\n \n \tclosed    bool\n-\tlastcols  []interface{}\n+\tlastcols  []driver.Value\n \tlasterr   error\n \tcloseStmt *Stmt // if non-nil, statement to Close on close\n }\n@@ -846,7 +848,7 @@ func (rs *Rows) Next() bool {\n \t\treturn false\n \t}\n \tif rs.lastcols == nil {\n-\t\trs.lastcols = make([]interface{}, len(rs.rowsi.Columns()))\n+\t\trs.lastcols = make([]driver.Value, len(rs.rowsi.Columns()))\n \t}\n \trs.lasterr = rs.rowsi.Next(rs.lastcols)\n \tif rs.lasterr == io.EOF {"}, {"sha": "37a518b6d376969e5371b88f72aad1779e4957f7", "filename": "libgo/go/debug/dwarf/open.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -31,8 +31,9 @@ type Data struct {\n }\n \n // New returns a new Data object initialized from the given parameters.\n-// Clients should typically use [TODO(rsc): method to be named later] instead of calling\n-// New directly.\n+// Rather than calling this function directly, clients should typically use\n+// the DWARF method of the File type of the appropriate package debug/elf,\n+// debug/macho, or debug/pe.\n //\n // The []byte arguments are the data from the corresponding debug section\n // in the object file; for example, for an ELF object, abbrev is the contents of"}, {"sha": "f05f01564ff8c5f090b8c1bad1ce638bf2f475ef", "filename": "libgo/go/debug/dwarf/testdata/typedef.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.c?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -28,8 +28,13 @@ typedef struct my_struct {\n \tvolatile int vi;\n \tchar x : 1;\n \tint y : 4;\n+\tint z[0];\n \tlong long array[40];\n+\tint zz[0];\n } t_my_struct;\n+typedef struct my_struct1 {\n+\tint zz [1];\n+} t_my_struct1;\n typedef union my_union {\n \tvolatile int vi;\n \tchar x : 1;\n@@ -65,7 +70,8 @@ t_func_void_of_char *a9;\n t_func_void_of_void *a10;\n t_func_void_of_ptr_char_dots *a11;\n t_my_struct *a12;\n-t_my_union *a12a;\n+t_my_struct1 *a12a;\n+t_my_union *a12b;\n t_my_enum *a13;\n t_my_list *a14;\n t_my_tree *a15;"}, {"sha": "b2062d2c4bb828dcb229f12869f77fd5d9522278", "filename": "libgo/go/debug/dwarf/testdata/typedef.elf", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.elf?ref=501699af1603287b1b47ac450fd6eeb826aa76b1"}, {"sha": "f75afcccbfc852d284a33c01a49eb1035b6dae9c", "filename": "libgo/go/debug/dwarf/testdata/typedef.macho", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Ftypedef.macho?ref=501699af1603287b1b47ac450fd6eeb826aa76b1"}, {"sha": "4502355022d60aafa499b1ac9ee6a1fd7b090cf1", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -426,6 +426,8 @@ func (d *Data) Type(off Offset) (Type, error) {\n \t\tt.StructName, _ = e.Val(AttrName).(string)\n \t\tt.Incomplete = e.Val(AttrDeclaration) != nil\n \t\tt.Field = make([]*StructField, 0, 8)\n+\t\tvar lastFieldType Type\n+\t\tvar lastFieldBitOffset int64\n \t\tfor kid := next(); kid != nil; kid = next() {\n \t\t\tif kid.Tag == TagMember {\n \t\t\t\tf := new(StructField)\n@@ -444,11 +446,32 @@ func (d *Data) Type(off Offset) (Type, error) {\n \t\t\t\t\t\tgoto Error\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\thaveBitOffset := false\n \t\t\t\tf.Name, _ = kid.Val(AttrName).(string)\n \t\t\t\tf.ByteSize, _ = kid.Val(AttrByteSize).(int64)\n-\t\t\t\tf.BitOffset, _ = kid.Val(AttrBitOffset).(int64)\n+\t\t\t\tf.BitOffset, haveBitOffset = kid.Val(AttrBitOffset).(int64)\n \t\t\t\tf.BitSize, _ = kid.Val(AttrBitSize).(int64)\n \t\t\t\tt.Field = append(t.Field, f)\n+\n+\t\t\t\tbito := f.BitOffset\n+\t\t\t\tif !haveBitOffset {\n+\t\t\t\t\tbito = f.ByteOffset * 8\n+\t\t\t\t}\n+\t\t\t\tif bito == lastFieldBitOffset && t.Kind != \"union\" {\n+\t\t\t\t\t// Last field was zero width.  Fix array length.\n+\t\t\t\t\t// (DWARF writes out 0-length arrays as if they were 1-length arrays.)\n+\t\t\t\t\tzeroArray(lastFieldType)\n+\t\t\t\t}\n+\t\t\t\tlastFieldType = f.Type\n+\t\t\t\tlastFieldBitOffset = bito\n+\t\t\t}\n+\t\t}\n+\t\tif t.Kind != \"union\" {\n+\t\t\tb, ok := e.Val(AttrByteSize).(int64)\n+\t\t\tif ok && b*8 == lastFieldBitOffset {\n+\t\t\t\t// Final field must be zero width.  Fix array length.\n+\t\t\t\tzeroArray(lastFieldType)\n \t\t\t}\n \t\t}\n \n@@ -579,3 +602,14 @@ Error:\n \tdelete(d.typeCache, off)\n \treturn nil, err\n }\n+\n+func zeroArray(t Type) {\n+\tfor {\n+\t\tat, ok := t.(*ArrayType)\n+\t\tif !ok {\n+\t\t\tbreak\n+\t\t}\n+\t\tat.Count = 0\n+\t\tt = at.Type\n+\t}\n+}"}, {"sha": "b5b255f6f4a600846b0e44c2ff452982df544fb3", "filename": "libgo/go/debug/dwarf/type_test.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -25,13 +25,22 @@ var typedefTests = map[string]string{\n \t\"t_func_void_of_char\":                   \"func(char) void\",\n \t\"t_func_void_of_void\":                   \"func() void\",\n \t\"t_func_void_of_ptr_char_dots\":          \"func(*char, ...) void\",\n-\t\"t_my_struct\":                           \"struct my_struct {vi volatile int@0; x char@4 : 1@7; y int@4 : 4@27; array [40]long long int@8}\",\n+\t\"t_my_struct\":                           \"struct my_struct {vi volatile int@0; x char@4 : 1@7; y int@4 : 4@27; z [0]int@8; array [40]long long int@8; zz [0]int@328}\",\n+\t\"t_my_struct1\":                          \"struct my_struct1 {zz [1]int@0}\",\n \t\"t_my_union\":                            \"union my_union {vi volatile int@0; x char@0 : 1@7; y int@0 : 4@28; array [40]long long int@0}\",\n \t\"t_my_enum\":                             \"enum my_enum {e1=1; e2=2; e3=-5; e4=1000000000000000}\",\n \t\"t_my_list\":                             \"struct list {val short int@0; next *t_my_list@8}\",\n \t\"t_my_tree\":                             \"struct tree {left *struct tree@0; right *struct tree@8; val long long unsigned int@16}\",\n }\n \n+// As Apple converts gcc to a clang-based front end\n+// they keep breaking the DWARF output.  This map lists the\n+// conversion from real answer to Apple answer.\n+var machoBug = map[string]string{\n+\t\"func(*char, ...) void\":                                 \"func(*char) void\",\n+\t\"enum my_enum {e1=1; e2=2; e3=-5; e4=1000000000000000}\": \"enum my_enum {e1=1; e2=2; e3=-5; e4=-1530494976}\",\n+}\n+\n func elfData(t *testing.T, name string) *Data {\n \tf, err := elf.Open(name)\n \tif err != nil {\n@@ -58,13 +67,13 @@ func machoData(t *testing.T, name string) *Data {\n \treturn d\n }\n \n-func TestTypedefsELF(t *testing.T) { testTypedefs(t, elfData(t, \"testdata/typedef.elf\")) }\n+func TestTypedefsELF(t *testing.T) { testTypedefs(t, elfData(t, \"testdata/typedef.elf\"), \"elf\") }\n \n func TestTypedefsMachO(t *testing.T) {\n-\ttestTypedefs(t, machoData(t, \"testdata/typedef.macho\"))\n+\ttestTypedefs(t, machoData(t, \"testdata/typedef.macho\"), \"macho\")\n }\n \n-func testTypedefs(t *testing.T, d *Data) {\n+func testTypedefs(t *testing.T, d *Data, kind string) {\n \tr := d.Reader()\n \tseen := make(map[string]bool)\n \tfor {\n@@ -93,7 +102,7 @@ func testTypedefs(t *testing.T, d *Data) {\n \t\t\t\t\tt.Errorf(\"multiple definitions for %s\", t1.Name)\n \t\t\t\t}\n \t\t\t\tseen[t1.Name] = true\n-\t\t\t\tif typstr != want {\n+\t\t\t\tif typstr != want && (kind != \"macho\" || typstr != machoBug[want]) {\n \t\t\t\t\tt.Errorf(\"%s:\\n\\thave %s\\n\\twant %s\", t1.Name, typstr, want)\n \t\t\t\t}\n \t\t\t}"}, {"sha": "b2400bb3ba7b99799998c3e321615b8670da3103", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,15 +6,37 @@ package gosym\n \n import (\n \t\"debug/elf\"\n+\t\"fmt\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n+var pclinetestBinary string\n+\n func dotest() bool {\n \t// For now, only works on ELF platforms.\n-\t// TODO: convert to work with new go tool\n-\treturn false && runtime.GOOS == \"linux\" && runtime.GOARCH == \"amd64\"\n+\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n+\t\treturn false\n+\t}\n+\tif pclinetestBinary != \"\" {\n+\t\treturn true\n+\t}\n+\t// This command builds pclinetest from pclinetest.asm;\n+\t// the resulting binary looks like it was built from pclinetest.s,\n+\t// but we have renamed it to keep it away from the go tool.\n+\tpclinetestBinary = os.TempDir() + \"/pclinetest\"\n+\tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -E main -o %s %s.6\",\n+\t\tpclinetestBinary, pclinetestBinary, pclinetestBinary)\n+\tcmd := exec.Command(\"sh\", \"-c\", command)\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn true\n }\n \n func getTable(t *testing.T) *Table {\n@@ -149,7 +171,7 @@ func TestPCLine(t *testing.T) {\n \t\treturn\n \t}\n \n-\tf, tab := crack(\"_test/pclinetest\", t)\n+\tf, tab := crack(pclinetestBinary, t)\n \ttext := f.Section(\".text\")\n \ttextdat, err := text.Data()\n \tif err != nil {\n@@ -163,10 +185,13 @@ func TestPCLine(t *testing.T) {\n \t\tfile, line, fn := tab.PCToLine(pc)\n \t\toff := pc - text.Addr // TODO(rsc): should not need off; bug in 8g\n \t\twantLine += int(textdat[off])\n+\t\tt.Logf(\"off is %d\", off)\n \t\tif fn == nil {\n \t\t\tt.Errorf(\"failed to get line of PC %#x\", pc)\n-\t\t} else if len(file) < 12 || file[len(file)-12:] != \"pclinetest.s\" || line != wantLine || fn != sym {\n-\t\t\tt.Errorf(\"expected %s:%d (%s) at PC %#x, got %s:%d (%s)\", \"pclinetest.s\", wantLine, sym.Name, pc, file, line, fn.Name)\n+\t\t} else if !strings.HasSuffix(file, \"pclinetest.asm\") {\n+\t\t\tt.Errorf(\"expected %s (%s) at PC %#x, got %s (%s)\", \"pclinetest.asm\", sym.Name, pc, file, fn.Name)\n+\t\t} else if line != wantLine || fn != sym {\n+\t\t\tt.Errorf(\"expected :%d (%s) at PC %#x, got :%d (%s)\", wantLine, sym.Name, pc, line, fn.Name)\n \t\t}\n \t}\n "}, {"sha": "a0bb985300f3b32adc784254f12bf7a250eb71ab", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -464,7 +464,7 @@ func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n // decodeSingle decodes a top-level value that is not a struct and stores it through p.\n // Such values are preceded by a zero, making them have the memory layout of a\n // struct field (although with an illegal field number).\n-func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uintptr) (err error) {\n+func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uintptr) {\n \tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n@@ -473,18 +473,17 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uint\n \t}\n \tinstr := &engine.instr[singletonField]\n \tif instr.indir != ut.indir {\n-\t\treturn errors.New(\"gob: internal error: inconsistent indirection\")\n+\t\terrorf(\"internal error: inconsistent indirection instr %d ut %d\", instr.indir, ut.indir)\n \t}\n \tptr := unsafe.Pointer(basep) // offset will be zero\n \tif instr.indir > 1 {\n \t\tptr = decIndirect(ptr, instr.indir)\n \t}\n \tinstr.op(instr, state, ptr)\n \tdec.freeDecoderState(state)\n-\treturn nil\n }\n \n-// decodeSingle decodes a top-level struct and stores it through p.\n+// decodeStruct decodes a top-level struct and stores it through p.\n // Indir is for the value, not the type.  At the time of the call it may\n // differ from ut.indir, which was computed when the engine was built.\n // This state cannot arise for decodeSingle, which is called directly\n@@ -839,11 +838,10 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t}\n \n \t\tcase reflect.Map:\n-\t\t\tname = \"element of \" + name\n \t\t\tkeyId := dec.wireType[wireId].MapT.Key\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n-\t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), name, inProgress)\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n+\t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), \"key of \"+name, inProgress)\n+\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), \"element of \"+name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tup := unsafe.Pointer(p)\n@@ -1151,7 +1149,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \n // getDecEnginePtr returns the engine for the specified type.\n func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePtr **decEngine, err error) {\n-\trt := ut.base\n+\trt := ut.user\n \tdecoderMap, ok := dec.decoderCache[rt]\n \tif !ok {\n \t\tdecoderMap = make(map[typeId]**decEngine)"}, {"sha": "3bfae30f39a88b8fafe2364602c563c784d2d896", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -685,3 +685,54 @@ func TestSliceIncompatibility(t *testing.T) {\n \t\tt.Error(\"expected compatibility error\")\n \t}\n }\n+\n+// Mutually recursive slices of structs caused problems.\n+type Bug3 struct {\n+\tNum      int\n+\tChildren []*Bug3\n+}\n+\n+func TestGobPtrSlices(t *testing.T) {\n+\tin := []*Bug3{\n+\t\t&Bug3{1, nil},\n+\t\t&Bug3{2, nil},\n+\t}\n+\tb := new(bytes.Buffer)\n+\terr := NewEncoder(b).Encode(&in)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\n+\tvar out []*Bug3\n+\terr = NewDecoder(b).Decode(&out)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif !reflect.DeepEqual(in, out) {\n+\t\tt.Fatal(\"got %v; wanted %v\", out, in)\n+\t}\n+}\n+\n+// getDecEnginePtr cached engine for ut.base instead of ut.user so we passed\n+// a *map and then tried to reuse its engine to decode the inner map.\n+func TestPtrToMapOfMap(t *testing.T) {\n+\tRegister(make(map[string]interface{}))\n+\tsubdata := make(map[string]interface{})\n+\tsubdata[\"bar\"] = \"baz\"\n+\tdata := make(map[string]interface{})\n+\tdata[\"foo\"] = subdata\n+\n+\tb := new(bytes.Buffer)\n+\terr := NewEncoder(b).Encode(data)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\tvar newData map[string]interface{}\n+\terr = NewDecoder(b).Decode(&newData)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif !reflect.DeepEqual(data, newData) {\n+\t\tt.Fatalf(\"expected %v got %v\", data, newData)\n+\t}\n+}"}, {"sha": "0dd7a0a770ea137956683f9e69c4ced123d1f2d3", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -152,6 +152,10 @@ var idToType = make(map[typeId]gobType)\n var builtinIdToType map[typeId]gobType // set in init() after builtins are established\n \n func setTypeId(typ gobType) {\n+\t// When building recursive types, someone may get there before us.\n+\tif typ.id() != 0 {\n+\t\treturn\n+\t}\n \tnextId++\n \ttyp.setId(nextId)\n \tidToType[nextId] = typ\n@@ -346,6 +350,11 @@ func newSliceType(name string) *sliceType {\n func (s *sliceType) init(elem gobType) {\n \t// Set our type id before evaluating the element's, in case it's our own.\n \tsetTypeId(s)\n+\t// See the comments about ids in newTypeObject. Only slices and\n+\t// structs have mutual recursion.\n+\tif elem.id() == 0 {\n+\t\tsetTypeId(elem)\n+\t}\n \ts.Elem = elem.id()\n }\n \n@@ -503,6 +512,13 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, err\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n+\t\t\t// Some mutually recursive types can cause us to be here while\n+\t\t\t// still defining the element. Fix the element type id here.\n+\t\t\t// We could do this more neatly by setting the id at the start of\n+\t\t\t// building every type, but that would break binary compatibility.\n+\t\t\tif gt.id() == 0 {\n+\t\t\t\tsetTypeId(gt)\n+\t\t\t}\n \t\t\tst.Field = append(st.Field, &fieldType{f.Name, gt.id()})\n \t\t}\n \t\treturn st, nil"}, {"sha": "110c6fd62386e5af5ad5871c9b31067c4175c569", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -496,6 +496,12 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\t\t\t// Pretend this field doesn't exist.\n \t\t\t\t\tcontinue\n \t\t\t\t}\n+\t\t\t\tif sf.Anonymous {\n+\t\t\t\t\t// Pretend this field doesn't exist,\n+\t\t\t\t\t// so that we can do a good job with\n+\t\t\t\t\t// these in a later version.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t\t// First, tag match\n \t\t\t\ttagName, _ := parseTag(tag)\n \t\t\t\tif tagName == key {\n@@ -963,3 +969,11 @@ func unquoteBytes(s []byte) (t []byte, ok bool) {\n \t}\n \treturn b[0:w], true\n }\n+\n+// The following is issue 3069.\n+\n+// BUG(rsc): This package ignores anonymous (embedded) struct fields\n+// during encoding and decoding.  A future version may assign meaning\n+// to them.  To force an anonymous field to be ignored in all future\n+// versions of this package, use an explicit `json:\"-\"` tag in the struct\n+// definition."}, {"sha": "0eec586a9bb73eee8fbe37ccb5d7529fc3116a75", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -619,3 +619,32 @@ func TestRefUnmarshal(t *testing.T) {\n \t\tt.Errorf(\"got %+v, want %+v\", got, want)\n \t}\n }\n+\n+// Test that anonymous fields are ignored.\n+// We may assign meaning to them later.\n+func TestAnonymous(t *testing.T) {\n+\ttype S struct {\n+\t\tT\n+\t\tN int\n+\t}\n+\n+\tdata, err := Marshal(new(S))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\twant := `{\"N\":0}`\n+\tif string(data) != want {\n+\t\tt.Fatalf(\"Marshal = %#q, want %#q\", string(data), want)\n+\t}\n+\n+\tvar s S\n+\tif err := Unmarshal([]byte(`{\"T\": 1, \"T\": {\"Y\": 1}, \"N\": 2}`), &s); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %v\", err)\n+\t}\n+\tif s.N != 2 {\n+\t\tt.Fatal(\"Unmarshal: did not set N\")\n+\t}\n+\tif s.T.Y != 0 {\n+\t\tt.Fatal(\"Unmarshal: did set T.Y\")\n+\t}\n+}"}, {"sha": "8a794b79bd5bb5c659466c70b75cf4886063351c", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -538,6 +538,11 @@ func encodeFields(t reflect.Type) []encodeField {\n \t\tif f.PkgPath != \"\" {\n \t\t\tcontinue\n \t\t}\n+\t\tif f.Anonymous {\n+\t\t\t// We want to do a better job with these later,\n+\t\t\t// so for now pretend they don't exist.\n+\t\t\tcontinue\n+\t\t}\n \t\tvar ef encodeField\n \t\tef.i = i\n \t\tef.tag = f.Name"}, {"sha": "6c3170bdda3d42074b9721b9ac21ebc401e7f82d", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -57,35 +57,14 @@ const (\n //       if the field value is empty. The empty values are false, 0, any\n //       nil pointer or interface value, and any array, slice, map, or\n //       string of length zero.\n+//     - a non-pointer anonymous struct field is handled as if the\n+//       fields of its value were part of the outer struct.\n //\n // If a field uses a tag \"a>b>c\", then the element c will be nested inside\n // parent elements a and b.  Fields that appear next to each other that name\n-// the same parent will be enclosed in one XML element.  For example:\n+// the same parent will be enclosed in one XML element.\n //\n-//\ttype Result struct {\n-//\t\tXMLName   xml.Name `xml:\"result\"`\n-//\t\tId        int      `xml:\"id,attr\"`\n-//\t\tFirstName string   `xml:\"person>name>first\"`\n-//\t\tLastName  string   `xml:\"person>name>last\"`\n-//\t\tAge       int      `xml:\"person>age\"`\n-//\t\tHeight    float    `xml:\"person>height,omitempty\"`\n-//\t\tMarried   bool     `xml:\"person>married\"`\n-//\t}\n-//\n-//\txml.Marshal(&Result{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42})\n-//\n-// would be marshalled as:\n-//\n-//\t<result>\n-//\t\t<person id=\"13\">\n-//\t\t\t<name>\n-//\t\t\t\t<first>John</first>\n-//\t\t\t\t<last>Doe</last>\n-//\t\t\t</name>\n-//\t\t\t<age>42</age>\n-//\t\t\t<married>false</married>\n-//\t\t</person>\n-//\t</result>\n+// See MarshalIndent for an example.\n //\n // Marshal will return an error if asked to marshal a channel, function, or map.\n func Marshal(v interface{}) ([]byte, error) {\n@@ -96,14 +75,30 @@ func Marshal(v interface{}) ([]byte, error) {\n \treturn b.Bytes(), nil\n }\n \n+// MarshalIndent works like Marshal, but each XML element begins on a new\n+// indented line that starts with prefix and is followed by one or more\n+// copies of indent according to the nesting depth.\n+func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n+\tvar b bytes.Buffer\n+\tenc := NewEncoder(&b)\n+\tenc.prefix = prefix\n+\tenc.indent = indent\n+\terr := enc.marshalValue(reflect.ValueOf(v), nil)\n+\tenc.Flush()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn b.Bytes(), nil\n+}\n+\n // An Encoder writes XML data to an output stream.\n type Encoder struct {\n \tprinter\n }\n \n // NewEncoder returns a new encoder that writes to w.\n func NewEncoder(w io.Writer) *Encoder {\n-\treturn &Encoder{printer{bufio.NewWriter(w)}}\n+\treturn &Encoder{printer{Writer: bufio.NewWriter(w)}}\n }\n \n // Encode writes the XML encoding of v to the stream.\n@@ -118,8 +113,14 @@ func (enc *Encoder) Encode(v interface{}) error {\n \n type printer struct {\n \t*bufio.Writer\n+\tindent     string\n+\tprefix     string\n+\tdepth      int\n+\tindentedIn bool\n }\n \n+// marshalValue writes one or more XML elements representing val.\n+// If val was obtained from a struct field, finfo must have its details.\n func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tif !val.IsValid() {\n \t\treturn nil\n@@ -177,6 +178,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\t}\n \t}\n \n+\tp.writeIndent(1)\n \tp.WriteByte('<')\n \tp.WriteString(name)\n \n@@ -216,6 +218,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\treturn err\n \t}\n \n+\tp.writeIndent(-1)\n \tp.WriteByte('<')\n \tp.WriteByte('/')\n \tp.WriteString(name)\n@@ -294,6 +297,7 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\tif vf.Len() == 0 {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tp.writeIndent(0)\n \t\t\tp.WriteString(\"<!--\")\n \t\t\tdashDash := false\n \t\t\tdashLast := false\n@@ -352,6 +356,33 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \treturn nil\n }\n \n+func (p *printer) writeIndent(depthDelta int) {\n+\tif len(p.prefix) == 0 && len(p.indent) == 0 {\n+\t\treturn\n+\t}\n+\tif depthDelta < 0 {\n+\t\tp.depth--\n+\t\tif p.indentedIn {\n+\t\t\tp.indentedIn = false\n+\t\t\treturn\n+\t\t}\n+\t\tp.indentedIn = false\n+\t}\n+\tp.WriteByte('\\n')\n+\tif len(p.prefix) > 0 {\n+\t\tp.WriteString(p.prefix)\n+\t}\n+\tif len(p.indent) > 0 {\n+\t\tfor i := 0; i < p.depth; i++ {\n+\t\t\tp.WriteString(p.indent)\n+\t\t}\n+\t}\n+\tif depthDelta > 0 {\n+\t\tp.depth++\n+\t\tp.indentedIn = true\n+\t}\n+}\n+\n type parentStack struct {\n \t*printer\n \tstack []string\n@@ -367,20 +398,20 @@ func (s *parentStack) trim(parents []string) {\n \t\t\tbreak\n \t\t}\n \t}\n-\n \tfor i := len(s.stack) - 1; i >= split; i-- {\n+\t\ts.writeIndent(-1)\n \t\ts.WriteString(\"</\")\n \t\ts.WriteString(s.stack[i])\n \t\ts.WriteByte('>')\n \t}\n-\n \ts.stack = parents[:split]\n }\n \n // push adds parent elements to the stack and writes open tags.\n func (s *parentStack) push(parents []string) {\n \tfor i := 0; i < len(parents); i++ {\n-\t\ts.WriteString(\"<\")\n+\t\ts.writeIndent(1)\n+\t\ts.WriteByte('<')\n \t\ts.WriteString(parents[i])\n \t\ts.WriteByte('>')\n \t}"}, {"sha": "c2168242091a493f3c7af28e182c6da2aa32048c", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 3, "deletions": 52, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -25,58 +25,6 @@ import (\n // slice, or string. Well-formed data that does not fit into v is\n // discarded.\n //\n-// For example, given these definitions:\n-//\n-//\ttype Email struct {\n-//\t\tWhere string `xml:\",attr\"`\n-//\t\tAddr  string\n-//\t}\n-//\n-//\ttype Result struct {\n-//\t\tXMLName xml.Name `xml:\"result\"`\n-//\t\tName\tstring\n-//\t\tPhone\tstring\n-//\t\tEmail\t[]Email\n-//\t\tGroups  []string `xml:\"group>value\"`\n-//\t}\n-//\n-//\tresult := Result{Name: \"name\", Phone: \"phone\", Email: nil}\n-//\n-// unmarshalling the XML input\n-//\n-//\t<result>\n-//\t\t<email where=\"home\">\n-//\t\t\t<addr>gre@example.com</addr>\n-//\t\t</email>\n-//\t\t<email where='work'>\n-//\t\t\t<addr>gre@work.com</addr>\n-//\t\t</email>\n-//\t\t<name>Grace R. Emlin</name>\n-// \t\t<group>\n-// \t\t\t<value>Friends</value>\n-// \t\t\t<value>Squash</value>\n-// \t\t</group>\n-//\t\t<address>123 Main Street</address>\n-//\t</result>\n-//\n-// via Unmarshal(data, &result) is equivalent to assigning\n-//\n-//\tr = Result{\n-//\t\txml.Name{Local: \"result\"},\n-//\t\t\"Grace R. Emlin\", // name\n-//\t\t\"phone\",\t  // no phone given\n-//\t\t[]Email{\n-//\t\t\tEmail{\"home\", \"gre@example.com\"},\n-//\t\t\tEmail{\"work\", \"gre@work.com\"},\n-//\t\t},\n-//\t\t[]string{\"Friends\", \"Squash\"},\n-//\t}\n-//\n-// Note that the field r.Phone has not been modified and\n-// that the XML <address> element was discarded. Also, the field\n-// Groups was assigned considering the element path provided in the\n-// field tag.\n-//\n // Because Unmarshal uses the reflect package, it can only assign\n // to exported (upper case) fields.  Unmarshal uses a case-sensitive\n // comparison to match XML element names to tag values and struct\n@@ -133,6 +81,9 @@ import (\n //      of the above rules and the struct has a field with tag \",any\",\n //      unmarshal maps the sub-element to that struct field.\n //\n+//   * A non-pointer anonymous struct field is handled as if the\n+//      fields of its value were part of the outer struct.\n+//\n //   * A struct field with tag \"-\" is never unmarshalled into.\n //\n // Unmarshal maps an XML element to a string or []byte by saving the"}, {"sha": "63c05d7185b8ef8c6e525b3c81c3c564849353ea", "filename": "libgo/go/errors/errors_test.go", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ferrors%2Ferrors_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ferrors%2Ferrors_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ferrors%2Ferrors_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -5,29 +5,49 @@\n package errors_test\n \n import (\n-\t. \"errors\"\n+\t\"errors\"\n+\t\"fmt\"\n \t\"testing\"\n )\n \n func TestNewEqual(t *testing.T) {\n \t// Different allocations should not be equal.\n-\tif New(\"abc\") == New(\"abc\") {\n+\tif errors.New(\"abc\") == errors.New(\"abc\") {\n \t\tt.Errorf(`New(\"abc\") == New(\"abc\")`)\n \t}\n-\tif New(\"abc\") == New(\"xyz\") {\n+\tif errors.New(\"abc\") == errors.New(\"xyz\") {\n \t\tt.Errorf(`New(\"abc\") == New(\"xyz\")`)\n \t}\n \n \t// Same allocation should be equal to itself (not crash).\n-\terr := New(\"jkl\")\n+\terr := errors.New(\"jkl\")\n \tif err != err {\n \t\tt.Errorf(`err != err`)\n \t}\n }\n \n func TestErrorMethod(t *testing.T) {\n-\terr := New(\"abc\")\n+\terr := errors.New(\"abc\")\n \tif err.Error() != \"abc\" {\n \t\tt.Errorf(`New(\"abc\").Error() = %q, want %q`, err.Error(), \"abc\")\n \t}\n }\n+\n+func ExampleNew() {\n+\terr := errors.New(\"emit macho dwarf: elf header corrupted\")\n+\tif err != nil {\n+\t\tfmt.Print(err)\n+\t}\n+\t// Output: emit macho dwarf: elf header corrupted\n+}\n+\n+// The fmt package's Errorf function lets us use the package's formatting\n+// features to create descriptive error messages.\n+func ExampleNew_errorf() {\n+\tconst name, id = \"bimmler\", 17\n+\terr := fmt.Errorf(\"user %q (id %d) not found\", name, id)\n+\tif err != nil {\n+\t\tfmt.Print(err)\n+\t}\n+\t// Output: user \"bimmler\" (id 17) not found\n+}"}, {"sha": "d41d66bfacd8d457ff4c7fa351c48baf55c0b160", "filename": "libgo/go/exp/inotify/inotify_linux_test.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,6 +7,7 @@\n package inotify\n \n import (\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n \t\"time\"\n@@ -16,16 +17,19 @@ func TestInotifyEvents(t *testing.T) {\n \t// Create an inotify watcher instance and initialize it\n \twatcher, err := NewWatcher()\n \tif err != nil {\n-\t\tt.Fatalf(\"NewWatcher() failed: %s\", err)\n+\t\tt.Fatalf(\"NewWatcher failed: %s\", err)\n \t}\n \n-\tt.Logf(\"NEEDS TO BE CONVERTED TO NEW GO TOOL\") // TODO\n-\treturn\n+\tdir, err := ioutil.TempDir(\"\", \"inotify\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"TempDir failed: %s\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n \n \t// Add a watch for \"_test\"\n-\terr = watcher.Watch(\"_test\")\n+\terr = watcher.Watch(dir)\n \tif err != nil {\n-\t\tt.Fatalf(\"Watcher.Watch() failed: %s\", err)\n+\t\tt.Fatalf(\"Watch failed: %s\", err)\n \t}\n \n \t// Receive errors on the error channel on a separate goroutine\n@@ -35,7 +39,7 @@ func TestInotifyEvents(t *testing.T) {\n \t\t}\n \t}()\n \n-\tconst testFile string = \"_test/TestInotifyEvents.testfile\"\n+\ttestFile := dir + \"/TestInotifyEvents.testfile\"\n \n \t// Receive events on the event channel on a separate goroutine\n \teventstream := watcher.Event\n@@ -58,7 +62,7 @@ func TestInotifyEvents(t *testing.T) {\n \t// This should add at least one event to the inotify event queue\n \t_, err = os.OpenFile(testFile, os.O_WRONLY|os.O_CREATE, 0666)\n \tif err != nil {\n-\t\tt.Fatalf(\"creating test file failed: %s\", err)\n+\t\tt.Fatalf(\"creating test file: %s\", err)\n \t}\n \n \t// We expect this event to be received almost immediately, but let's wait 1 s to be sure\n@@ -95,7 +99,7 @@ func TestInotifyClose(t *testing.T) {\n \t\tt.Fatal(\"double Close() test failed: second Close() call didn't return\")\n \t}\n \n-\terr := watcher.Watch(\"_test\")\n+\terr := watcher.Watch(os.TempDir())\n \tif err == nil {\n \t\tt.Fatal(\"expected error on Watch() after Close(), got nil\")\n \t}"}, {"sha": "2cbe1ac730e43a24f6de10c137c8353bb6eaf69c", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -66,6 +66,18 @@ func (rb *reorderBuffer) flush(out []byte) []byte {\n \treturn out\n }\n \n+// flushCopy copies the normalized segment to buf and resets rb.\n+// It returns the number of bytes written to buf.\n+func (rb *reorderBuffer) flushCopy(buf []byte) int {\n+\tp := 0\n+\tfor i := 0; i < rb.nrune; i++ {\n+\t\trunep := rb.rune[i]\n+\t\tp += copy(buf[p:], rb.byte[runep.pos:runep.pos+runep.size])\n+\t}\n+\trb.reset()\n+\treturn p\n+}\n+\n // insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class.\n // It returns false if the buffer is not large enough to hold the rune.\n // It is used internally by insert and insertString only.\n@@ -96,32 +108,41 @@ func (rb *reorderBuffer) insertOrdered(info runeInfo) bool {\n // insert inserts the given rune in the buffer ordered by CCC.\n // It returns true if the buffer was large enough to hold the decomposed rune.\n func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n-\tif info.size == 3 {\n-\t\tif rune := src.hangul(i); rune != 0 {\n-\t\t\treturn rb.decomposeHangul(rune)\n-\t\t}\n+\tif rune := src.hangul(i); rune != 0 {\n+\t\treturn rb.decomposeHangul(rune)\n \t}\n \tif info.hasDecomposition() {\n-\t\tdcomp := info.decomposition()\n-\t\trb.tmpBytes = inputBytes(dcomp)\n-\t\tfor i := 0; i < len(dcomp); {\n-\t\t\tinfo = rb.f.info(&rb.tmpBytes, i)\n-\t\t\tpos := rb.nbyte\n-\t\t\tif !rb.insertOrdered(info) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\tend := i + int(info.size)\n-\t\t\tcopy(rb.byte[pos:], dcomp[i:end])\n-\t\t\ti = end\n-\t\t}\n-\t} else {\n-\t\t// insertOrder changes nbyte\n+\t\treturn rb.insertDecomposed(info.decomposition())\n+\t}\n+\treturn rb.insertSingle(src, i, info)\n+}\n+\n+// insertDecomposed inserts an entry in to the reorderBuffer for each rune\n+// in dcomp.  dcomp must be a sequence of decomposed UTF-8-encoded runes.\n+func (rb *reorderBuffer) insertDecomposed(dcomp []byte) bool {\n+\tsaveNrune, saveNbyte := rb.nrune, rb.nbyte\n+\trb.tmpBytes = inputBytes(dcomp)\n+\tfor i := 0; i < len(dcomp); {\n+\t\tinfo := rb.f.info(&rb.tmpBytes, i)\n \t\tpos := rb.nbyte\n \t\tif !rb.insertOrdered(info) {\n+\t\t\trb.nrune, rb.nbyte = saveNrune, saveNbyte\n \t\t\treturn false\n \t\t}\n-\t\tsrc.copySlice(rb.byte[pos:], i, i+int(info.size))\n+\t\ti += copy(rb.byte[pos:], dcomp[i:i+int(info.size)])\n+\t}\n+\treturn true\n+}\n+\n+// insertSingle inserts an entry in the reorderBuffer for the rune at\n+// position i. info is the runeInfo for the rune at position i.\n+func (rb *reorderBuffer) insertSingle(src input, i int, info runeInfo) bool {\n+\t// insertOrder changes nbyte\n+\tpos := rb.nbyte\n+\tif !rb.insertOrdered(info) {\n+\t\treturn false\n \t}\n+\tsrc.copySlice(rb.byte[pos:], i, i+int(info.size))\n \treturn true\n }\n \n@@ -182,8 +203,12 @@ const (\n \tjamoLVTCount = 19 * 21 * 28\n )\n \n-// Caller must verify that len(b) >= 3.\n+const hangulUTF8Size = 3\n+\n func isHangul(b []byte) bool {\n+\tif len(b) < hangulUTF8Size {\n+\t\treturn false\n+\t}\n \tb0 := b[0]\n \tif b0 < hangulBase0 {\n \t\treturn false\n@@ -202,8 +227,10 @@ func isHangul(b []byte) bool {\n \treturn b1 == hangulEnd1 && b[2] < hangulEnd2\n }\n \n-// Caller must verify that len(b) >= 3.\n func isHangulString(b string) bool {\n+\tif len(b) < hangulUTF8Size {\n+\t\treturn false\n+\t}\n \tb0 := b[0]\n \tif b0 < hangulBase0 {\n \t\treturn false\n@@ -234,6 +261,22 @@ func isHangulWithoutJamoT(b []byte) bool {\n \treturn c < jamoLVTCount && c%jamoTCount == 0\n }\n \n+// decomposeHangul writes the decomposed Hangul to buf and returns the number\n+// of bytes written.  len(buf) should be at least 9.\n+func decomposeHangul(buf []byte, r rune) int {\n+\tconst JamoUTF8Len = 3\n+\tr -= hangulBase\n+\tx := r % jamoTCount\n+\tr /= jamoTCount\n+\tutf8.EncodeRune(buf, jamoLBase+r/jamoVCount)\n+\tutf8.EncodeRune(buf[JamoUTF8Len:], jamoVBase+r%jamoVCount)\n+\tif x != 0 {\n+\t\tutf8.EncodeRune(buf[2*JamoUTF8Len:], jamoTBase+x)\n+\t\treturn 3 * JamoUTF8Len\n+\t}\n+\treturn 2 * JamoUTF8Len\n+}\n+\n // decomposeHangul algorithmically decomposes a Hangul rune into\n // its Jamo components.\n // See http://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul."}, {"sha": "9de9eacfd653f308cc1032a25ad6daa06c4e96f5", "filename": "libgo/go/exp/norm/composition_test.go", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -47,14 +47,14 @@ func runTests(t *testing.T, name string, fm Form, f insertFunc, tests []TestCase\n \t}\n }\n \n-func TestFlush(t *testing.T) {\n+type flushFunc func(rb *reorderBuffer) []byte\n+\n+func testFlush(t *testing.T, name string, fn flushFunc) {\n \trb := reorderBuffer{}\n \trb.init(NFC, nil)\n-\tout := make([]byte, 0)\n-\n-\tout = rb.flush(out)\n+\tout := fn(&rb)\n \tif len(out) != 0 {\n-\t\tt.Errorf(\"wrote bytes on flush of empty buffer. (len(out) = %d)\", len(out))\n+\t\tt.Errorf(\"%s: wrote bytes on flush of empty buffer. (len(out) = %d)\", name, len(out))\n \t}\n \n \tfor _, r := range []rune(\"world!\") {\n@@ -65,16 +65,32 @@ func TestFlush(t *testing.T) {\n \tout = rb.flush(out)\n \twant := \"Hello world!\"\n \tif string(out) != want {\n-\t\tt.Errorf(`output after flush was \"%s\"; want \"%s\"`, string(out), want)\n+\t\tt.Errorf(`%s: output after flush was \"%s\"; want \"%s\"`, name, string(out), want)\n \t}\n \tif rb.nrune != 0 {\n-\t\tt.Errorf(\"flush: non-null size of info buffer (rb.nrune == %d)\", rb.nrune)\n+\t\tt.Errorf(\"%s: non-null size of info buffer (rb.nrune == %d)\", name, rb.nrune)\n \t}\n \tif rb.nbyte != 0 {\n-\t\tt.Errorf(\"flush: non-null size of byte buffer (rb.nbyte == %d)\", rb.nbyte)\n+\t\tt.Errorf(\"%s: non-null size of byte buffer (rb.nbyte == %d)\", name, rb.nbyte)\n \t}\n }\n \n+func flushF(rb *reorderBuffer) []byte {\n+\tout := make([]byte, 0)\n+\treturn rb.flush(out)\n+}\n+\n+func flushCopyF(rb *reorderBuffer) []byte {\n+\tout := make([]byte, MaxSegmentSize)\n+\tn := rb.flushCopy(out)\n+\treturn out[:n]\n+}\n+\n+func TestFlush(t *testing.T) {\n+\ttestFlush(t, \"flush\", flushF)\n+\ttestFlush(t, \"flushCopy\", flushCopyF)\n+}\n+\n var insertTests = []TestCase{\n \t{[]rune{'a'}, []rune{'a'}},\n \t{[]rune{0x300}, []rune{0x300}},"}, {"sha": "9c564d67718b5f7a6be2b374cce59cae2b415c75", "filename": "libgo/go/exp/norm/input.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,7 +7,7 @@ package norm\n import \"unicode/utf8\"\n \n type input interface {\n-\tskipASCII(p int) int\n+\tskipASCII(p, max int) int\n \tskipNonStarter(p int) int\n \tappendSlice(buf []byte, s, e int) []byte\n \tcopySlice(buf []byte, s, e int)\n@@ -18,8 +18,8 @@ type input interface {\n \n type inputString string\n \n-func (s inputString) skipASCII(p int) int {\n-\tfor ; p < len(s) && s[p] < utf8.RuneSelf; p++ {\n+func (s inputString) skipASCII(p, max int) int {\n+\tfor ; p < max && s[p] < utf8.RuneSelf; p++ {\n \t}\n \treturn p\n }\n@@ -59,8 +59,8 @@ func (s inputString) hangul(p int) rune {\n \n type inputBytes []byte\n \n-func (s inputBytes) skipASCII(p int) int {\n-\tfor ; p < len(s) && s[p] < utf8.RuneSelf; p++ {\n+func (s inputBytes) skipASCII(p, max int) int {\n+\tfor ; p < max && s[p] < utf8.RuneSelf; p++ {\n \t}\n \treturn p\n }"}, {"sha": "761ba90cdd4abac94cbe9ea9dfa155b64bce9fd1", "filename": "libgo/go/exp/norm/iter.go", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+const MaxSegmentSize = maxByteBufferSize\n+\n+// An Iter iterates over a string or byte slice, while normalizing it\n+// to a given Form.\n+type Iter struct {\n+\trb   reorderBuffer\n+\tinfo runeInfo // first character saved from previous iteration\n+\tnext iterFunc // implementation of next depends on form\n+\n+\tp        int // current position in input source\n+\toutStart int // start of current segment in output buffer\n+\tinStart  int // start of current segment in input source\n+\tmaxp     int // position in output buffer after which not to start a new segment\n+\tmaxseg   int // for tracking an excess of combining characters\n+\n+\ttccc uint8\n+\tdone bool\n+}\n+\n+type iterFunc func(*Iter, []byte) int\n+\n+// SetInput initializes i to iterate over src after normalizing it to Form f.\n+func (i *Iter) SetInput(f Form, src []byte) {\n+\ti.rb.init(f, src)\n+\tif i.rb.f.composing {\n+\t\ti.next = nextComposed\n+\t} else {\n+\t\ti.next = nextDecomposed\n+\t}\n+\ti.p = 0\n+\tif i.done = len(src) == 0; !i.done {\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t}\n+}\n+\n+// SetInputString initializes i to iterate over src after normalizing it to Form f.\n+func (i *Iter) SetInputString(f Form, src string) {\n+\ti.rb.initString(f, src)\n+\tif i.rb.f.composing {\n+\t\ti.next = nextComposed\n+\t} else {\n+\t\ti.next = nextDecomposed\n+\t}\n+\ti.p = 0\n+\tif i.done = len(src) == 0; !i.done {\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t}\n+}\n+\n+// Pos returns the byte position at which the next call to Next will commence processing.\n+func (i *Iter) Pos() int {\n+\treturn i.p\n+}\n+\n+// Done returns true if there is no more input to process.\n+func (i *Iter) Done() bool {\n+\treturn i.done\n+}\n+\n+// Next writes f(i.input[i.Pos():n]...) to buffer buf, where n is the\n+// largest boundary of i.input such that the result fits in buf.  \n+// It returns the number of bytes written to buf.\n+// len(buf) should be at least MaxSegmentSize. \n+// Done must be false before calling Next.\n+func (i *Iter) Next(buf []byte) int {\n+\treturn i.next(i, buf)\n+}\n+\n+func (i *Iter) initNext(outn, inStart int) {\n+\ti.outStart = 0\n+\ti.inStart = inStart\n+\ti.maxp = outn - MaxSegmentSize\n+\ti.maxseg = MaxSegmentSize\n+}\n+\n+// setStart resets the start of the new segment to the given position.\n+// It returns true if there is not enough room for the new segment.\n+func (i *Iter) setStart(outp, inp int) bool {\n+\tif outp > i.maxp {\n+\t\treturn true\n+\t}\n+\ti.outStart = outp\n+\ti.inStart = inp\n+\ti.maxseg = outp + MaxSegmentSize\n+\treturn false\n+}\n+\n+func min(a, b int) int {\n+\tif a < b {\n+\t\treturn a\n+\t}\n+\treturn b\n+}\n+\n+// nextDecomposed is the implementation of Next for forms NFD and NFKD.\n+func nextDecomposed(i *Iter, out []byte) int {\n+\tvar outp int\n+\ti.initNext(len(out), i.p)\n+doFast:\n+\tinCopyStart, outCopyStart := i.p, outp // invariant xCopyStart <= i.xStart\n+\tfor {\n+\t\tif sz := int(i.info.size); sz <= 1 {\n+\t\t\t// ASCII or illegal byte.  Either way, advance by 1.\n+\t\t\ti.p++\n+\t\t\toutp++\n+\t\t\tmax := min(i.rb.nsrc, len(out)-outp+i.p)\n+\t\t\tif np := i.rb.src.skipASCII(i.p, max); np > i.p {\n+\t\t\t\toutp += np - i.p\n+\t\t\t\ti.p = np\n+\t\t\t\tif i.p >= i.rb.nsrc {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\t// ASCII may combine with consecutive runes.\n+\t\t\t\tif i.setStart(outp-1, i.p-1) {\n+\t\t\t\t\ti.p--\n+\t\t\t\t\toutp--\n+\t\t\t\t\ti.info.size = 1\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if d := i.info.decomposition(); d != nil {\n+\t\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\t\t\tp := outp + len(d)\n+\t\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n+\t\t\t\treturn outp\n+\t\t\t}\n+\t\t\tcopy(out[outp:], d)\n+\t\t\toutp = p\n+\t\t\ti.p += sz\n+\t\t\tinCopyStart, outCopyStart = i.p, outp\n+\t\t} else if r := i.rb.src.hangul(i.p); r != 0 {\n+\t\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\t\t\tfor {\n+\t\t\t\toutp += decomposeHangul(out[outp:], r)\n+\t\t\t\ti.p += hangulUTF8Size\n+\t\t\t\tif r = i.rb.src.hangul(i.p); r == 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif i.setStart(outp, i.p) {\n+\t\t\t\t\treturn outp\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tinCopyStart, outCopyStart = i.p, outp\n+\t\t} else {\n+\t\t\tp := outp + sz\n+\t\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\toutp = p\n+\t\t\ti.p += sz\n+\t\t}\n+\t\tif i.p >= i.rb.nsrc {\n+\t\t\tbreak\n+\t\t}\n+\t\tprevCC := i.info.tccc\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t\tif cc := i.info.ccc; cc == 0 {\n+\t\t\tif i.setStart(outp, i.p) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t} else if cc < prevCC {\n+\t\t\tgoto doNorm\n+\t\t}\n+\t}\n+\tif inCopyStart != i.p {\n+\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\t}\n+\ti.done = i.p >= i.rb.nsrc\n+\treturn outp\n+doNorm:\n+\t// Insert what we have decomposed so far in the reorderBuffer.\n+\t// As we will only reorder, there will always be enough room.\n+\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\tif !i.rb.insertDecomposed(out[i.outStart:outp]) {\n+\t\t// Start over to prevent decompositions from crossing segment boundaries.\n+\t\t// This is a rare occurance.\n+\t\ti.p = i.inStart\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t}\n+\toutp = i.outStart\n+\tfor {\n+\t\tif !i.rb.insert(i.rb.src, i.p, i.info) {\n+\t\t\tbreak\n+\t\t}\n+\t\tif i.p += int(i.info.size); i.p >= i.rb.nsrc {\n+\t\t\toutp += i.rb.flushCopy(out[outp:])\n+\t\t\ti.done = true\n+\t\t\treturn outp\n+\t\t}\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t\tif i.info.ccc == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t// new segment or too many combining characters: exit normalization\n+\tif outp += i.rb.flushCopy(out[outp:]); i.setStart(outp, i.p) {\n+\t\treturn outp\n+\t}\n+\tgoto doFast\n+}\n+\n+// nextComposed is the implementation of Next for forms NFC and NFKC.\n+func nextComposed(i *Iter, out []byte) int {\n+\tvar outp int\n+\ti.initNext(len(out), i.p)\n+doFast:\n+\tinCopyStart, outCopyStart := i.p, outp // invariant xCopyStart <= i.xStart\n+\tvar prevCC uint8\n+\tfor {\n+\t\tif !i.info.isYesC() {\n+\t\t\tgoto doNorm\n+\t\t}\n+\t\tif cc := i.info.ccc; cc == 0 {\n+\t\t\tif i.setStart(outp, i.p) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t} else if cc < prevCC {\n+\t\t\tgoto doNorm\n+\t\t}\n+\t\tprevCC = i.info.tccc\n+\t\tsz := int(i.info.size)\n+\t\tif sz == 0 {\n+\t\t\tsz = 1 // illegal rune: copy byte-by-byte\n+\t\t}\n+\t\tp := outp + sz\n+\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n+\t\t\tbreak\n+\t\t}\n+\t\toutp = p\n+\t\ti.p += sz\n+\t\tmax := min(i.rb.nsrc, len(out)-outp+i.p)\n+\t\tif np := i.rb.src.skipASCII(i.p, max); np > i.p {\n+\t\t\toutp += np - i.p\n+\t\t\ti.p = np\n+\t\t\tif i.p >= i.rb.nsrc {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\t// ASCII may combine with consecutive runes.\n+\t\t\tif i.setStart(outp-1, i.p-1) {\n+\t\t\t\ti.p--\n+\t\t\t\toutp--\n+\t\t\t\ti.info = runeInfo{size: 1}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif i.p >= i.rb.nsrc {\n+\t\t\tbreak\n+\t\t}\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t}\n+\tif inCopyStart != i.p {\n+\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\t}\n+\ti.done = i.p >= i.rb.nsrc\n+\treturn outp\n+doNorm:\n+\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.inStart)\n+\toutp, i.p = i.outStart, i.inStart\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\tfor {\n+\t\tif !i.rb.insert(i.rb.src, i.p, i.info) {\n+\t\t\tbreak\n+\t\t}\n+\t\tif i.p += int(i.info.size); i.p >= i.rb.nsrc {\n+\t\t\ti.rb.compose()\n+\t\t\toutp += i.rb.flushCopy(out[outp:])\n+\t\t\ti.done = true\n+\t\t\treturn outp\n+\t\t}\n+\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\t\tif i.info.boundaryBefore() {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\ti.rb.compose()\n+\tif outp += i.rb.flushCopy(out[outp:]); i.setStart(outp, i.p) {\n+\t\treturn outp\n+\t}\n+\tgoto doFast\n+}"}, {"sha": "f6e8d8172510418f402297650afe8bd1104cdc39", "filename": "libgo/go/exp/norm/iter_test.go", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var iterBufSizes = []int{\n+\tMaxSegmentSize,\n+\t1.5 * MaxSegmentSize,\n+\t2 * MaxSegmentSize,\n+\t3 * MaxSegmentSize,\n+\t100 * MaxSegmentSize,\n+}\n+\n+func doIterNorm(f Form, buf []byte, s string) []byte {\n+\tacc := []byte{}\n+\ti := Iter{}\n+\ti.SetInputString(f, s)\n+\tfor !i.Done() {\n+\t\tn := i.Next(buf)\n+\t\tacc = append(acc, buf[:n]...)\n+\t}\n+\treturn acc\n+}\n+\n+func runIterTests(t *testing.T, name string, f Form, tests []AppendTest, norm bool) {\n+\tfor i, test := range tests {\n+\t\tin := test.left + test.right\n+\t\tgold := test.out\n+\t\tif norm {\n+\t\t\tgold = string(f.AppendString(nil, test.out))\n+\t\t}\n+\t\tfor _, sz := range iterBufSizes {\n+\t\t\tbuf := make([]byte, sz)\n+\t\t\tout := string(doIterNorm(f, buf, in))\n+\t\t\tif len(out) != len(gold) {\n+\t\t\t\tconst msg = \"%s:%d:%d: length is %d; want %d\"\n+\t\t\t\tt.Errorf(msg, name, i, sz, len(out), len(gold))\n+\t\t\t}\n+\t\t\tif out != gold {\n+\t\t\t\t// Find first rune that differs and show context.\n+\t\t\t\tir := []rune(out)\n+\t\t\t\tig := []rune(gold)\n+\t\t\t\tfor j := 0; j < len(ir) && j < len(ig); j++ {\n+\t\t\t\t\tif ir[j] == ig[j] {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tif j -= 3; j < 0 {\n+\t\t\t\t\t\tj = 0\n+\t\t\t\t\t}\n+\t\t\t\t\tfor e := j + 7; j < e && j < len(ir) && j < len(ig); j++ {\n+\t\t\t\t\t\tconst msg = \"%s:%d:%d: runeAt(%d) = %U; want %U\"\n+\t\t\t\t\t\tt.Errorf(msg, name, i, sz, j, ir[j], ig[j])\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func rep(r rune, n int) string {\n+\treturn strings.Repeat(string(r), n)\n+}\n+\n+var iterTests = []AppendTest{\n+\t{\"\", ascii, ascii},\n+\t{\"\", txt_all, txt_all},\n+\t{\"\", \"a\" + rep(0x0300, MaxSegmentSize/2), \"a\" + rep(0x0300, MaxSegmentSize/2)},\n+}\n+\n+var iterTestsD = []AppendTest{\n+\t{ // segment overflow on unchanged character\n+\t\t\"\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0316\\u0300\",\n+\t},\n+\t{ // segment overflow on unchanged character + start value\n+\t\t\"\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2+maxCombiningChars+4) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2+maxCombiningChars) + \"\\u0316\" + rep(0x300, 4),\n+\t},\n+\t{ // segment overflow on decomposition\n+\t\t\"\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0340\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2),\n+\t},\n+\t{ // segment overflow on decomposition + start value\n+\t\t\"\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0340\" + rep(0x300, maxCombiningChars+4) + \"\\u0320\",\n+\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + rep(0x300, maxCombiningChars+1) + \"\\u0320\" + rep(0x300, 4),\n+\t},\n+\t{ // start value after ASCII overflow\n+\t\t\"\",\n+\t\trep('a', MaxSegmentSize) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n+\t\trep('a', MaxSegmentSize) + rep(0x300, maxCombiningChars) + \"\\u0320\\u0300\\u0300\",\n+\t},\n+\t{ // start value after Hangul overflow\n+\t\t\"\",\n+\t\trep(0xAC00, MaxSegmentSize/6) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n+\t\tstrings.Repeat(\"\\u1100\\u1161\", MaxSegmentSize/6) + rep(0x300, maxCombiningChars-1) + \"\\u0320\" + rep(0x300, 3),\n+\t},\n+\t{ // start value after cc=0\n+\t\t\"\",\n+\t\t\"\u60a8\u60a8\" + rep(0x300, maxCombiningChars+4) + \"\\u0320\",\n+\t\t\"\u60a8\u60a8\" + rep(0x300, maxCombiningChars) + \"\\u0320\" + rep(0x300, 4),\n+\t},\n+\t{ // start value after normalization\n+\t\t\"\",\n+\t\t\"\\u0300\\u0320a\" + rep(0x300, maxCombiningChars+4) + \"\\u0320\",\n+\t\t\"\\u0320\\u0300a\" + rep(0x300, maxCombiningChars) + \"\\u0320\" + rep(0x300, 4),\n+\t},\n+}\n+\n+var iterTestsC = []AppendTest{\n+\t{ // ordering of non-composing combining characters\n+\t\t\"\",\n+\t\t\"\\u0305\\u0316\",\n+\t\t\"\\u0316\\u0305\",\n+\t},\n+\t{ // segment overflow\n+\t\t\"\",\n+\t\t\"a\" + rep(0x0305, MaxSegmentSize/2+4) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0305, MaxSegmentSize/2-1) + \"\\u0316\" + rep(0x305, 5),\n+\t},\n+}\n+\n+func TestIterNextD(t *testing.T) {\n+\trunIterTests(t, \"IterNextD1\", NFKD, appendTests, true)\n+\trunIterTests(t, \"IterNextD2\", NFKD, iterTests, true)\n+\trunIterTests(t, \"IterNextD3\", NFKD, iterTestsD, false)\n+}\n+\n+func TestIterNextC(t *testing.T) {\n+\trunIterTests(t, \"IterNextC1\", NFKC, appendTests, true)\n+\trunIterTests(t, \"IterNextC2\", NFKC, iterTests, true)\n+\trunIterTests(t, \"IterNextC3\", NFKC, iterTestsC, false)\n+}\n+\n+type SegmentTest struct {\n+\tin  string\n+\tout []string\n+}\n+\n+var segmentTests = []SegmentTest{\n+\t{rep('a', MaxSegmentSize), []string{rep('a', MaxSegmentSize), \"\"}},\n+\t{rep('a', MaxSegmentSize+2), []string{rep('a', MaxSegmentSize-1), \"aaa\", \"\"}},\n+\t{rep('a', MaxSegmentSize) + \"\\u0300aa\", []string{rep('a', MaxSegmentSize-1), \"a\\u0300\", \"aa\", \"\"}},\n+}\n+\n+// Note that, by design, segmentation is equal for composing and decomposing forms.\n+func TestIterSegmentation(t *testing.T) {\n+\tsegmentTest(t, \"SegmentTestD\", NFD, segmentTests)\n+\tsegmentTest(t, \"SegmentTestC\", NFC, segmentTests)\n+}\n+\n+func segmentTest(t *testing.T, name string, f Form, tests []SegmentTest) {\n+\titer := Iter{}\n+\tfor i, tt := range segmentTests {\n+\t\tbuf := make([]byte, MaxSegmentSize)\n+\t\titer.SetInputString(f, tt.in)\n+\t\tfor j, seg := range tt.out {\n+\t\t\tif seg == \"\" {\n+\t\t\t\tif !iter.Done() {\n+\t\t\t\t\tn := iter.Next(buf)\n+\t\t\t\t\tres := string(buf[:n])\n+\t\t\t\t\tt.Errorf(`%s:%d:%d: expected Done()==true, found segment \"%s\"`, name, i, j, res)\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif iter.Done() {\n+\t\t\t\tt.Errorf(\"%s:%d:%d: Done()==true, want false\", name, i, j)\n+\t\t\t}\n+\t\t\tn := iter.Next(buf)\n+\t\t\tseg = f.String(seg)\n+\t\t\tif res := string(buf[:n]); res != seg {\n+\t\t\t\tt.Errorf(`%s:%d:%d\" segment was \"%s\" (%d); want \"%s\" (%d)`, name, i, j, res, len(res), seg, len(seg))\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "b5cd44abfa0dc7af46366d1ff5e18bba7382236d", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -243,7 +243,7 @@ func quickSpan(rb *reorderBuffer, i int) int {\n \tlastSegStart := i\n \tsrc, n := rb.src, rb.nsrc\n \tfor i < n {\n-\t\tif j := src.skipASCII(i); i != j {\n+\t\tif j := src.skipASCII(i, n); i != j {\n \t\t\ti = j\n \t\t\tlastSegStart = i - 1\n \t\t\tlastCC = 0\n@@ -448,11 +448,16 @@ func decomposeToLastBoundary(rb *reorderBuffer, buf []byte) []byte {\n \t\t}\n \t\t// Check that decomposition doesn't result in overflow.\n \t\tif info.hasDecomposition() {\n-\t\t\tdcomp := info.decomposition()\n-\t\t\tfor i := 0; i < len(dcomp); {\n-\t\t\t\tinf := rb.f.info(inputBytes(dcomp), i)\n-\t\t\t\ti += int(inf.size)\n+\t\t\tif isHangul(buf) {\n+\t\t\t\ti += int(info.size)\n \t\t\t\tn++\n+\t\t\t} else {\n+\t\t\t\tdcomp := info.decomposition()\n+\t\t\t\tfor i := 0; i < len(dcomp); {\n+\t\t\t\t\tinf := rb.f.info(inputBytes(dcomp), i)\n+\t\t\t\t\ti += int(inf.size)\n+\t\t\t\t\tn++\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tn++"}, {"sha": "8b970598b4d1faed388067d6bda157eb1ec5afb4", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -5,6 +5,7 @@\n package norm\n \n import (\n+\t\"bytes\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -495,15 +496,40 @@ func TestAppend(t *testing.T) {\n \trunAppendTests(t, \"TestString\", NFKC, stringF, appendTests)\n }\n \n+func appendBench(f Form, in []byte) func() {\n+\tbuf := make([]byte, 0, 4*len(in))\n+\treturn func() {\n+\t\tf.Append(buf, in...)\n+\t}\n+}\n+\n+func iterBench(f Form, in []byte) func() {\n+\tbuf := make([]byte, 4*len(in))\n+\titer := Iter{}\n+\treturn func() {\n+\t\titer.SetInput(f, in)\n+\t\tfor !iter.Done() {\n+\t\t\titer.Next(buf)\n+\t\t}\n+\t}\n+}\n+\n+func appendBenchmarks(bm []func(), f Form, in []byte) []func() {\n+\t//bm = append(bm, appendBench(f, in))\n+\tbm = append(bm, iterBench(f, in))\n+\treturn bm\n+}\n+\n func doFormBenchmark(b *testing.B, inf, f Form, s string) {\n \tb.StopTimer()\n \tin := inf.Bytes([]byte(s))\n-\tbuf := make([]byte, 2*len(in))\n-\tb.SetBytes(int64(len(in)))\n+\tbm := appendBenchmarks(nil, f, in)\n+\tb.SetBytes(int64(len(in) * len(bm)))\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n-\t\tbuf = f.Append(buf[0:0], in...)\n-\t\tbuf = buf[0:0]\n+\t\tfor _, fn := range bm {\n+\t\t\tfn()\n+\t\t}\n \t}\n }\n \n@@ -549,17 +575,21 @@ func BenchmarkNormalizeHangulNFD2NFD(b *testing.B) {\n \tdoFormBenchmark(b, NFD, NFD, txt_kr)\n }\n \n+var forms = []Form{NFC, NFD, NFKC, NFKD}\n+\n func doTextBenchmark(b *testing.B, s string) {\n \tb.StopTimer()\n-\tb.SetBytes(int64(len(s)) * 4)\n \tin := []byte(s)\n-\tvar buf = make([]byte, 0, 2*len(in))\n+\tbm := []func(){}\n+\tfor _, f := range forms {\n+\t\tbm = appendBenchmarks(bm, f, in)\n+\t}\n+\tb.SetBytes(int64(len(s) * len(bm)))\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n-\t\tNFC.Append(buf, in...)\n-\t\tNFD.Append(buf, in...)\n-\t\tNFKC.Append(buf, in...)\n-\t\tNFKD.Append(buf, in...)\n+\t\tfor _, f := range bm {\n+\t\t\tf()\n+\t\t}\n \t}\n }\n \n@@ -584,6 +614,11 @@ func BenchmarkJapanese(b *testing.B) {\n func BenchmarkChinese(b *testing.B) {\n \tdoTextBenchmark(b, txt_cn)\n }\n+func BenchmarkOverflow(b *testing.B) {\n+\tdoTextBenchmark(b, overflow)\n+}\n+\n+var overflow = string(bytes.Repeat([]byte(\"\\u035D\"), 4096)) + \"\\u035B\"\n \n // Tests sampled from the Canonical ordering tests (Part 2) of\n // http://unicode.org/Public/UNIDATA/NormalizationTest.txt"}, {"sha": "507de1ae8340bed21f5aeb91285a569bb2189276", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -220,6 +220,17 @@ func cmpIsNormal(t *Test, name string, f norm.Form, test string, result, want bo\n func doTest(t *Test, f norm.Form, gold, test string) {\n \tresult := f.Bytes([]byte(test))\n \tcmpResult(t, \"Bytes\", f, gold, test, string(result))\n+\tsresult := f.String(test)\n+\tcmpResult(t, \"String\", f, gold, test, sresult)\n+\tbuf := make([]byte, norm.MaxSegmentSize)\n+\tacc := []byte{}\n+\ti := norm.Iter{}\n+\ti.SetInputString(f, test)\n+\tfor !i.Done() {\n+\t\tn := i.Next(buf)\n+\t\tacc = append(acc, buf[:n]...)\n+\t}\n+\tcmpResult(t, \"Iter.Next\", f, gold, test, string(acc))\n \tfor i := range test {\n \t\tout := f.Append(f.Bytes([]byte(test[:i])), []byte(test[i:])...)\n \t\tcmpResult(t, fmt.Sprintf(\":Append:%d\", i), f, gold, test, string(out))"}, {"sha": "62fa5c9296dc7672710d1a2a1da814ef938776b7", "filename": "libgo/go/exp/proxy/socks5.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -98,9 +98,9 @@ func (s *socks5) Dial(network, addr string) (net.Conn, error) {\n \n \tbuf = append(buf, socks5Version)\n \tif len(s.user) > 0 && len(s.user) < 256 && len(s.password) < 256 {\n-\t\tbuf = append(buf, 2, /* num auth methods */ socks5AuthNone, socks5AuthPassword)\n+\t\tbuf = append(buf, 2 /* num auth methods */, socks5AuthNone, socks5AuthPassword)\n \t} else {\n-\t\tbuf = append(buf, 1, /* num auth methods */ socks5AuthNone)\n+\t\tbuf = append(buf, 1 /* num auth methods */, socks5AuthNone)\n \t}\n \n \tif _, err = conn.Write(buf); err != nil {\n@@ -139,7 +139,7 @@ func (s *socks5) Dial(network, addr string) (net.Conn, error) {\n \t}\n \n \tbuf = buf[:0]\n-\tbuf = append(buf, socks5Version, socks5Connect, 0 /* reserved */ )\n+\tbuf = append(buf, socks5Version, socks5Connect, 0 /* reserved */)\n \n \tif ip := net.ParseIP(host); ip != nil {\n \t\tif len(ip) == 4 {"}, {"sha": "c1ed0c0c4437d69f51d28cecc32f58f1fd3d354e", "filename": "libgo/go/exp/terminal/terminal.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -389,12 +389,12 @@ func (t *Terminal) Write(buf []byte) (n int, err error) {\n \n \t// We have a prompt and possibly user input on the screen. We\n \t// have to clear it first.\n-\tt.move(0, /* up */ 0, /* down */ t.cursorX, /* left */ 0 /* right */ )\n+\tt.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)\n \tt.cursorX = 0\n \tt.clearLineToRight()\n \n \tfor t.cursorY > 0 {\n-\t\tt.move(1, /* up */ 0, 0, 0)\n+\t\tt.move(1 /* up */, 0, 0, 0)\n \t\tt.cursorY--\n \t\tt.clearLineToRight()\n \t}"}, {"sha": "4a1929a839715c01bd865124f3fc9b3a6a47ca68", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,6 +7,7 @@\n package winfsnotify\n \n import (\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n \t\"time\"\n@@ -115,7 +116,13 @@ func TestNotifyClose(t *testing.T) {\n \t\tt.Fatal(\"double Close() test failed: second Close() call didn't return\")\n \t}\n \n-\terr := watcher.Watch(\"_test\")\n+\tdir, err := ioutil.TempDir(\"\", \"wininotify\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"TempDir failed: %s\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\terr = watcher.Watch(dir)\n \tif err == nil {\n \t\tt.Fatal(\"expected error on Watch() after Close(), got nil\")\n \t}"}, {"sha": "a7e0e250a2e9d74a6e82d1f397e6f831794f8d35", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,28 +2,31 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Extract example functions from package ASTs.\n+// Extract example functions from file ASTs.\n \n package doc\n \n import (\n \t\"go/ast\"\n-\t\"go/printer\"\n \t\"go/token\"\n+\t\"regexp\"\n+\t\"sort\"\n \t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n type Example struct {\n-\tName   string                 // name of the item being demonstrated\n-\tBody   *printer.CommentedNode // code\n-\tOutput string                 // expected output\n+\tName     string // name of the item being exemplified\n+\tDoc      string // example function doc string\n+\tCode     ast.Node\n+\tComments []*ast.CommentGroup\n+\tOutput   string // expected output\n }\n \n-func Examples(pkg *ast.Package) []*Example {\n+func Examples(files ...*ast.File) []*Example {\n \tvar list []*Example\n-\tfor _, file := range pkg.Files {\n+\tfor _, file := range files {\n \t\thasTests := false // file contains tests or benchmarks\n \t\tnumDecl := 0      // number of non-import declarations in the file\n \t\tvar flist []*Example\n@@ -45,26 +48,54 @@ func Examples(pkg *ast.Package) []*Example {\n \t\t\tif !isTest(name, \"Example\") {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tvar doc string\n+\t\t\tif f.Doc != nil {\n+\t\t\t\tdoc = f.Doc.Text()\n+\t\t\t}\n \t\t\tflist = append(flist, &Example{\n-\t\t\t\tName: name[len(\"Example\"):],\n-\t\t\t\tBody: &printer.CommentedNode{\n-\t\t\t\t\tNode:     f.Body,\n-\t\t\t\t\tComments: file.Comments,\n-\t\t\t\t},\n-\t\t\t\tOutput: f.Doc.Text(),\n+\t\t\t\tName:     name[len(\"Example\"):],\n+\t\t\t\tDoc:      doc,\n+\t\t\t\tCode:     f.Body,\n+\t\t\t\tComments: file.Comments,\n+\t\t\t\tOutput:   exampleOutput(f, file.Comments),\n \t\t\t})\n \t\t}\n \t\tif !hasTests && numDecl > 1 && len(flist) == 1 {\n \t\t\t// If this file only has one example function, some\n \t\t\t// other top-level declarations, and no tests or\n \t\t\t// benchmarks, use the whole file as the example.\n-\t\t\tflist[0].Body.Node = file\n+\t\t\tflist[0].Code = file\n \t\t}\n \t\tlist = append(list, flist...)\n \t}\n+\tsort.Sort(exampleByName(list))\n \treturn list\n }\n \n+var outputPrefix = regexp.MustCompile(`(?i)^[[:space:]]*output:`)\n+\n+func exampleOutput(fun *ast.FuncDecl, comments []*ast.CommentGroup) string {\n+\t// find the last comment in the function\n+\tvar last *ast.CommentGroup\n+\tfor _, cg := range comments {\n+\t\tif cg.Pos() < fun.Pos() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif cg.End() > fun.End() {\n+\t\t\tbreak\n+\t\t}\n+\t\tlast = cg\n+\t}\n+\tif last != nil {\n+\t\t// test that it begins with the correct prefix\n+\t\ttext := last.Text()\n+\t\tif loc := outputPrefix.FindStringIndex(text); loc != nil {\n+\t\t\treturn strings.TrimSpace(text[loc[1]:])\n+\t\t}\n+\t}\n+\treturn \"\" // no suitable comment found\n+}\n+\n // isTest tells whether name looks like a test, example, or benchmark.\n // It is a Test (say) if there is a character after Test that is not a\n // lower-case letter. (We don't want Testiness.)\n@@ -78,3 +109,9 @@ func isTest(name, prefix string) bool {\n \trune, _ := utf8.DecodeRuneInString(name[len(prefix):])\n \treturn !unicode.IsLower(rune)\n }\n+\n+type exampleByName []*Example\n+\n+func (s exampleByName) Len() int           { return len(s) }\n+func (s exampleByName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n+func (s exampleByName) Less(i, j int) bool { return s[i].Name < s[j].Name }"}, {"sha": "3558892ebd0c2a411cf840ce2a290d37fc76ef2d", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -439,8 +439,10 @@ func (r *reader) readFile(src *ast.File) {\n \t\t\t\t\t\t// gets to (re-)use the declaration documentation\n \t\t\t\t\t\t// if there's none associated with the spec itself\n \t\t\t\t\t\tfake := &ast.GenDecl{\n-\t\t\t\t\t\t\td.Doc, d.Pos(), token.TYPE, token.NoPos,\n-\t\t\t\t\t\t\t[]ast.Spec{s}, token.NoPos,\n+\t\t\t\t\t\t\tDoc:    d.Doc,\n+\t\t\t\t\t\t\tTokPos: d.Pos(),\n+\t\t\t\t\t\t\tTok:    token.TYPE,\n+\t\t\t\t\t\t\tSpecs:  []ast.Spec{s},\n \t\t\t\t\t\t}\n \t\t\t\t\t\tr.readType(fake, s)\n \t\t\t\t\t}\n@@ -460,7 +462,7 @@ func (r *reader) readFile(src *ast.File) {\n \t\t\t\t// non-empty BUG comment; collect comment without BUG prefix\n \t\t\t\tlist := append([]*ast.Comment(nil), c.List...) // make a copy\n \t\t\t\tlist[0].Text = text[m[1]:]\n-\t\t\t\tr.bugs = append(r.bugs, (&ast.CommentGroup{list}).Text())\n+\t\t\t\tr.bugs = append(r.bugs, (&ast.CommentGroup{List: list}).Text())\n \t\t\t}\n \t\t}\n \t}\n@@ -530,7 +532,7 @@ func customizeRecv(f *Func, recvTypeName string, embeddedIsPtr bool, level int)\n \t_, origRecvIsPtr := newField.Type.(*ast.StarExpr)\n \tvar typ ast.Expr = ast.NewIdent(recvTypeName)\n \tif !embeddedIsPtr && origRecvIsPtr {\n-\t\ttyp = &ast.StarExpr{token.NoPos, typ}\n+\t\ttyp = &ast.StarExpr{X: typ}\n \t}\n \tnewField.Type = typ\n "}, {"sha": "2192d78c0cdec1942fe3ef4a7d9cfd4dd579d74b", "filename": "libgo/go/go/doc/synopsis.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import \"unicode\"\n+\n+// firstSentenceLen returns the length of the first sentence in s.\n+// The sentence ends after the first period followed by space and\n+// not preceded by exactly one uppercase letter.\n+//\n+func firstSentenceLen(s string) int {\n+\tvar ppp, pp, p rune\n+\tfor i, q := range s {\n+\t\tif q == '\\n' || q == '\\r' || q == '\\t' {\n+\t\t\tq = ' '\n+\t\t}\n+\t\tif q == ' ' && p == '.' && (!unicode.IsUpper(pp) || unicode.IsUpper(ppp)) {\n+\t\t\treturn i\n+\t\t}\n+\t\tppp, pp, p = pp, p, q\n+\t}\n+\treturn len(s)\n+}\n+\n+// Synopsis returns a cleaned version of the first sentence in s.\n+// That sentence ends after the first period followed by space and\n+// not preceded by exactly one uppercase letter. The result string\n+// has no \\n, \\r, or \\t characters and uses only single spaces between\n+// words.\n+//\n+func Synopsis(s string) string {\n+\tn := firstSentenceLen(s)\n+\tvar b []byte\n+\tp := byte(' ')\n+\tfor i := 0; i < n; i++ {\n+\t\tq := s[i]\n+\t\tif q == '\\n' || q == '\\r' || q == '\\t' {\n+\t\t\tq = ' '\n+\t\t}\n+\t\tif q != ' ' || p != ' ' {\n+\t\t\tb = append(b, q)\n+\t\t\tp = q\n+\t\t}\n+\t}\n+\t// remove trailing blank, if any\n+\tif n := len(b); n > 0 && p == ' ' {\n+\t\tb = b[0 : n-1]\n+\t}\n+\treturn string(b)\n+}"}, {"sha": "dfc6598af47ce331afab661cf6669eac603676d8", "filename": "libgo/go/go/doc/synopsis_test.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import \"testing\"\n+\n+var tests = []struct {\n+\ttxt string\n+\tfsl int\n+\tsyn string\n+}{\n+\t{\"\", 0, \"\"},\n+\t{\"foo\", 3, \"foo\"},\n+\t{\"foo.\", 4, \"foo.\"},\n+\t{\"foo.bar\", 7, \"foo.bar\"},\n+\t{\"  foo.  \", 6, \"foo.\"},\n+\t{\"  foo\\t  bar.\\n\", 12, \"foo bar.\"},\n+\t{\"  foo\\t  bar.\\n\", 12, \"foo bar.\"},\n+\t{\"a  b\\n\\nc\\r\\rd\\t\\t\", 12, \"a b c d\"},\n+\t{\"a  b\\n\\nc\\r\\rd\\t\\t  . BLA\", 15, \"a b c d .\"},\n+\t{\"Package poems by T.S.Eliot. To rhyme...\", 27, \"Package poems by T.S.Eliot.\"},\n+\t{\"Package poems by T. S. Eliot. To rhyme...\", 29, \"Package poems by T. S. Eliot.\"},\n+\t{\"foo implements the foo ABI. The foo ABI is...\", 27, \"foo implements the foo ABI.\"},\n+\t{\"Package\\nfoo. ..\", 12, \"Package foo.\"},\n+\t{\"P . Q.\", 3, \"P .\"},\n+\t{\"P. Q.   \", 8, \"P. Q.\"},\n+\t{\"Package \u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1 \u03ba\u03cc\u03c3\u03bc\u03b5.\", 36, \"Package \u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1 \u03ba\u03cc\u03c3\u03bc\u03b5.\"},\n+\t{\"Package \u3053\u3093\u306b\u3061\u306f \u4e16\u754c\\n\", 31, \"Package \u3053\u3093\u306b\u3061\u306f \u4e16\u754c\"},\n+}\n+\n+func TestSynopsis(t *testing.T) {\n+\tfor _, e := range tests {\n+\t\tfsl := firstSentenceLen(e.txt)\n+\t\tif fsl != e.fsl {\n+\t\t\tt.Errorf(\"got fsl = %d; want %d for %q\\n\", fsl, e.fsl, e.txt)\n+\t\t}\n+\t\tsyn := Synopsis(e.txt)\n+\t\tif syn != e.syn {\n+\t\t\tt.Errorf(\"got syn = %q; want %q for %q\\n\", syn, e.syn, e.txt)\n+\t\t}\n+\t}\n+}"}, {"sha": "0aded5bb4c74cf263b8b691e545675ba72df9806", "filename": "libgo/go/go/doc/testdata/benchmark.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -16,7 +16,7 @@ var matchBenchmarks = flag.String(\"test.bench\", \"\", \"regular expression to selec\n var benchTime = flag.Float64(\"test.benchtime\", 1, \"approximate run time for each benchmark, in seconds\")\n \n // An internal type but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of go test.\n type InternalBenchmark struct {\n \tName string\n \tF    func(b *B)\n@@ -213,7 +213,7 @@ func (r BenchmarkResult) String() string {\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of go test.\n func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) {\n \t// If no flag was specified, don't run benchmarks.\n \tif len(*matchBenchmarks) == 0 {\n@@ -281,7 +281,7 @@ func (b *B) trimOutput() {\n }\n \n // Benchmark benchmarks a single function. Useful for creating\n-// custom benchmarks that do not use gotest.\n+// custom benchmarks that do not use go test.\n func Benchmark(f func(b *B)) BenchmarkResult {\n \tb := &B{\n \t\tcommon: common{"}, {"sha": "d26a4685ca03ea04f8e0d45f9c10de1c364eba52", "filename": "libgo/go/go/doc/testdata/testing.1.golden", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -27,7 +27,7 @@ VARIABLES\n \t\t// The short flag requests that tests run more quickly, but its functionality\n \t\t// is provided by test writers themselves.  The testing package is just its\n \t\t// home.  The all.bash installation script sets it to make installation more\n-\t\t// efficient, but by default the flag is off so a plain \"gotest\" will do a\n+\t\t// efficient, but by default the flag is off so a plain \"go test\" will do a\n \t\t// full test of the package.\n \t\tshort\t= flag.Bool(\"test.short\", false, \"run smaller test suite to save time\")\n \t"}, {"sha": "71c1d1eaf0ea832e262eccd70d62386e3603a1a4", "filename": "libgo/go/go/doc/testdata/testing.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package testing provides support for automated testing of Go packages.\n-// It is intended to be used in concert with the ``gotest'' utility, which automates\n+// It is intended to be used in concert with the ``go test'' utility, which automates\n // execution of any function of the form\n //     func TestXxx(*testing.T)\n // where Xxx can be any alphanumeric string (but the first letter must not be in\n@@ -12,7 +12,7 @@\n //\n // Functions of the form\n //     func BenchmarkXxx(*testing.B)\n-// are considered benchmarks, and are executed by gotest when the -test.bench\n+// are considered benchmarks, and are executed by go test when the -test.bench\n // flag is provided.\n //\n // A sample benchmark function looks like this:\n@@ -53,7 +53,7 @@ var (\n \t// The short flag requests that tests run more quickly, but its functionality\n \t// is provided by test writers themselves.  The testing package is just its\n \t// home.  The all.bash installation script sets it to make installation more\n-\t// efficient, but by default the flag is off so a plain \"gotest\" will do a\n+\t// efficient, but by default the flag is off so a plain \"go test\" will do a\n \t// full test of the package.\n \tshort = flag.Bool(\"test.short\", false, \"run smaller test suite to save time\")\n \n@@ -205,7 +205,7 @@ func (t *T) Parallel() {\n }\n \n // An internal type but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of go test.\n type InternalTest struct {\n \tName string\n \tF    func(*T)\n@@ -227,7 +227,7 @@ func tRunner(t *T, test *InternalTest) {\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of go test.\n func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) {\n \tflag.Parse()\n \tparseCpuList()"}, {"sha": "c1e6190448641e9c50822d66b6c6604597b0a478", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 166, "deletions": 95, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -249,7 +249,7 @@ func (p *parser) consumeComment() (comment *ast.Comment, endline int) {\n \t\t}\n \t}\n \n-\tcomment = &ast.Comment{p.pos, p.lit}\n+\tcomment = &ast.Comment{Slash: p.pos, Text: p.lit}\n \tp.next0()\n \n \treturn\n@@ -270,7 +270,7 @@ func (p *parser) consumeCommentGroup() (comments *ast.CommentGroup, endline int)\n \t}\n \n \t// add comment group to the comments list\n-\tcomments = &ast.CommentGroup{list}\n+\tcomments = &ast.CommentGroup{List: list}\n \tp.comments = append(p.comments, comments)\n \n \treturn\n@@ -391,7 +391,7 @@ func (p *parser) parseIdent() *ast.Ident {\n \t} else {\n \t\tp.expect(token.IDENT) // use expect() error handling\n \t}\n-\treturn &ast.Ident{pos, name, nil}\n+\treturn &ast.Ident{NamePos: pos, Name: name}\n }\n \n func (p *parser) parseIdentList() (list []*ast.Ident) {\n@@ -469,7 +469,7 @@ func (p *parser) parseType() ast.Expr {\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"type\")\n \t\tp.next() // make progress\n-\t\treturn &ast.BadExpr{pos, p.pos}\n+\t\treturn &ast.BadExpr{From: pos, To: p.pos}\n \t}\n \n \treturn typ\n@@ -489,7 +489,7 @@ func (p *parser) parseTypeName() ast.Expr {\n \t\tp.next()\n \t\tp.resolve(ident)\n \t\tsel := p.parseIdent()\n-\t\treturn &ast.SelectorExpr{ident, sel}\n+\t\treturn &ast.SelectorExpr{X: ident, Sel: sel}\n \t}\n \n \treturn ident\n@@ -503,15 +503,15 @@ func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {\n \tlbrack := p.expect(token.LBRACK)\n \tvar len ast.Expr\n \tif ellipsisOk && p.tok == token.ELLIPSIS {\n-\t\tlen = &ast.Ellipsis{p.pos, nil}\n+\t\tlen = &ast.Ellipsis{Ellipsis: p.pos}\n \t\tp.next()\n \t} else if p.tok != token.RBRACK {\n \t\tlen = p.parseRhs()\n \t}\n \tp.expect(token.RBRACK)\n \telt := p.parseType()\n \n-\treturn &ast.ArrayType{lbrack, len, elt}\n+\treturn &ast.ArrayType{Lbrack: lbrack, Len: len, Elt: elt}\n }\n \n func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n@@ -521,7 +521,7 @@ func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n \t\tif !isIdent {\n \t\t\tpos := x.Pos()\n \t\t\tp.errorExpected(pos, \"identifier\")\n-\t\t\tident = &ast.Ident{pos, \"_\", nil}\n+\t\t\tident = &ast.Ident{NamePos: pos, Name: \"_\"}\n \t\t}\n \t\tidents[i] = ident\n \t}\n@@ -541,7 +541,7 @@ func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \t// optional tag\n \tvar tag *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\ttag = &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}\n \t\tp.next()\n \t}\n \n@@ -557,13 +557,13 @@ func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \t\tif n := len(list); n > 1 || !isTypeName(deref(typ)) {\n \t\t\tpos := typ.Pos()\n \t\t\tp.errorExpected(pos, \"anonymous field\")\n-\t\t\ttyp = &ast.BadExpr{pos, list[n-1].End()}\n+\t\t\ttyp = &ast.BadExpr{From: pos, To: list[n-1].End()}\n \t\t}\n \t}\n \n \tp.expectSemi() // call before accessing p.linecomment\n \n-\tfield := &ast.Field{doc, idents, typ, tag, p.lineComment}\n+\tfield := &ast.Field{Doc: doc, Names: idents, Type: typ, Tag: tag, Comment: p.lineComment}\n \tp.declare(field, nil, scope, ast.Var, idents...)\n \n \treturn field\n@@ -586,7 +586,14 @@ func (p *parser) parseStructType() *ast.StructType {\n \t}\n \trbrace := p.expect(token.RBRACE)\n \n-\treturn &ast.StructType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n+\treturn &ast.StructType{\n+\t\tStruct: pos,\n+\t\tFields: &ast.FieldList{\n+\t\t\tOpening: lbrace,\n+\t\t\tList:    list,\n+\t\t\tClosing: rbrace,\n+\t\t},\n+\t}\n }\n \n func (p *parser) parsePointerType() *ast.StarExpr {\n@@ -597,7 +604,7 @@ func (p *parser) parsePointerType() *ast.StarExpr {\n \tstar := p.expect(token.MUL)\n \tbase := p.parseType()\n \n-\treturn &ast.StarExpr{star, base}\n+\treturn &ast.StarExpr{Star: star, X: base}\n }\n \n func (p *parser) tryVarType(isParam bool) ast.Expr {\n@@ -607,9 +614,9 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \t\ttyp := p.tryIdentOrType(isParam) // don't use parseType so we can provide better error message\n \t\tif typ == nil {\n \t\t\tp.error(pos, \"'...' parameter is missing type\")\n-\t\t\ttyp = &ast.BadExpr{pos, p.pos}\n+\t\t\ttyp = &ast.BadExpr{From: pos, To: p.pos}\n \t\t}\n-\t\treturn &ast.Ellipsis{pos, typ}\n+\t\treturn &ast.Ellipsis{Ellipsis: pos, Elt: typ}\n \t}\n \treturn p.tryIdentOrType(false)\n }\n@@ -620,7 +627,7 @@ func (p *parser) parseVarType(isParam bool) ast.Expr {\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"type\")\n \t\tp.next() // make progress\n-\t\ttyp = &ast.BadExpr{pos, p.pos}\n+\t\ttyp = &ast.BadExpr{From: pos, To: p.pos}\n \t}\n \treturn typ\n }\n@@ -661,7 +668,7 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \tif typ != nil {\n \t\t// IdentifierList Type\n \t\tidents := p.makeIdentList(list)\n-\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\tfield := &ast.Field{Names: idents, Type: typ}\n \t\tparams = append(params, field)\n \t\t// Go spec: The scope of an identifier denoting a function\n \t\t// parameter or result variable is the function body.\n@@ -673,7 +680,7 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n \t\t\tidents := p.parseIdentList()\n \t\t\ttyp := p.parseVarType(ellipsisOk)\n-\t\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\t\tfield := &ast.Field{Names: idents, Type: typ}\n \t\t\tparams = append(params, field)\n \t\t\t// Go spec: The scope of an identifier denoting a function\n \t\t\t// parameter or result variable is the function body.\n@@ -708,7 +715,7 @@ func (p *parser) parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldLi\n \t}\n \trparen := p.expect(token.RPAREN)\n \n-\treturn &ast.FieldList{lparen, params, rparen}\n+\treturn &ast.FieldList{Opening: lparen, List: params, Closing: rparen}\n }\n \n func (p *parser) parseResult(scope *ast.Scope) *ast.FieldList {\n@@ -750,7 +757,7 @@ func (p *parser) parseFuncType() (*ast.FuncType, *ast.Scope) {\n \tscope := ast.NewScope(p.topScope) // function scope\n \tparams, results := p.parseSignature(scope)\n \n-\treturn &ast.FuncType{pos, params, results}, scope\n+\treturn &ast.FuncType{Func: pos, Params: params, Results: results}, scope\n }\n \n func (p *parser) parseMethodSpec(scope *ast.Scope) *ast.Field {\n@@ -767,15 +774,15 @@ func (p *parser) parseMethodSpec(scope *ast.Scope) *ast.Field {\n \t\tidents = []*ast.Ident{ident}\n \t\tscope := ast.NewScope(nil) // method scope\n \t\tparams, results := p.parseSignature(scope)\n-\t\ttyp = &ast.FuncType{token.NoPos, params, results}\n+\t\ttyp = &ast.FuncType{Func: token.NoPos, Params: params, Results: results}\n \t} else {\n \t\t// embedded interface\n \t\ttyp = x\n \t\tp.resolve(typ)\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n-\tspec := &ast.Field{doc, idents, typ, nil, p.lineComment}\n+\tspec := &ast.Field{Doc: doc, Names: idents, Type: typ, Comment: p.lineComment}\n \tp.declare(spec, nil, scope, ast.Fun, idents...)\n \n \treturn spec\n@@ -795,7 +802,14 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {\n \t}\n \trbrace := p.expect(token.RBRACE)\n \n-\treturn &ast.InterfaceType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n+\treturn &ast.InterfaceType{\n+\t\tInterface: pos,\n+\t\tMethods: &ast.FieldList{\n+\t\t\tOpening: lbrace,\n+\t\t\tList:    list,\n+\t\t\tClosing: rbrace,\n+\t\t},\n+\t}\n }\n \n func (p *parser) parseMapType() *ast.MapType {\n@@ -809,7 +823,7 @@ func (p *parser) parseMapType() *ast.MapType {\n \tp.expect(token.RBRACK)\n \tvalue := p.parseType()\n \n-\treturn &ast.MapType{pos, key, value}\n+\treturn &ast.MapType{Map: pos, Key: key, Value: value}\n }\n \n func (p *parser) parseChanType() *ast.ChanType {\n@@ -832,7 +846,7 @@ func (p *parser) parseChanType() *ast.ChanType {\n \t}\n \tvalue := p.parseType()\n \n-\treturn &ast.ChanType{pos, dir, value}\n+\treturn &ast.ChanType{Begin: pos, Dir: dir, Value: value}\n }\n \n // If the result is an identifier, it is not resolved.\n@@ -860,7 +874,7 @@ func (p *parser) tryIdentOrType(ellipsisOk bool) ast.Expr {\n \t\tp.next()\n \t\ttyp := p.parseType()\n \t\trparen := p.expect(token.RPAREN)\n-\t\treturn &ast.ParenExpr{lparen, typ, rparen}\n+\t\treturn &ast.ParenExpr{Lparen: lparen, X: typ, Rparen: rparen}\n \t}\n \n \t// no type found\n@@ -903,7 +917,7 @@ func (p *parser) parseBody(scope *ast.Scope) *ast.BlockStmt {\n \tp.closeScope()\n \trbrace := p.expect(token.RBRACE)\n \n-\treturn &ast.BlockStmt{lbrace, list, rbrace}\n+\treturn &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}\n }\n \n func (p *parser) parseBlockStmt() *ast.BlockStmt {\n@@ -917,7 +931,7 @@ func (p *parser) parseBlockStmt() *ast.BlockStmt {\n \tp.closeScope()\n \trbrace := p.expect(token.RBRACE)\n \n-\treturn &ast.BlockStmt{lbrace, list, rbrace}\n+\treturn &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}\n }\n \n // ----------------------------------------------------------------------------\n@@ -938,7 +952,7 @@ func (p *parser) parseFuncTypeOrLit() ast.Expr {\n \tbody := p.parseBody(scope)\n \tp.exprLev--\n \n-\treturn &ast.FuncLit{typ, body}\n+\treturn &ast.FuncLit{Type: typ, Body: body}\n }\n \n // parseOperand may return an expression or a raw type (incl. array\n@@ -959,7 +973,7 @@ func (p *parser) parseOperand(lhs bool) ast.Expr {\n \t\treturn x\n \n \tcase token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:\n-\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tx := &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}\n \t\tp.next()\n \t\treturn x\n \n@@ -970,7 +984,7 @@ func (p *parser) parseOperand(lhs bool) ast.Expr {\n \t\tx := p.parseRhsOrType() // types may be parenthesized: (some type)\n \t\tp.exprLev--\n \t\trparen := p.expect(token.RPAREN)\n-\t\treturn &ast.ParenExpr{lparen, x, rparen}\n+\t\treturn &ast.ParenExpr{Lparen: lparen, X: x, Rparen: rparen}\n \n \tcase token.FUNC:\n \t\treturn p.parseFuncTypeOrLit()\n@@ -987,7 +1001,7 @@ func (p *parser) parseOperand(lhs bool) ast.Expr {\n \tpos := p.pos\n \tp.errorExpected(pos, \"operand\")\n \tp.next() // make progress\n-\treturn &ast.BadExpr{pos, p.pos}\n+\treturn &ast.BadExpr{From: pos, To: p.pos}\n }\n \n func (p *parser) parseSelector(x ast.Expr) ast.Expr {\n@@ -997,7 +1011,7 @@ func (p *parser) parseSelector(x ast.Expr) ast.Expr {\n \n \tsel := p.parseIdent()\n \n-\treturn &ast.SelectorExpr{x, sel}\n+\treturn &ast.SelectorExpr{X: x, Sel: sel}\n }\n \n func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {\n@@ -1015,7 +1029,7 @@ func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {\n \t}\n \tp.expect(token.RPAREN)\n \n-\treturn &ast.TypeAssertExpr{x, typ}\n+\treturn &ast.TypeAssertExpr{X: x, Type: typ}\n }\n \n func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {\n@@ -1041,9 +1055,9 @@ func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {\n \trbrack := p.expect(token.RBRACK)\n \n \tif isSlice {\n-\t\treturn &ast.SliceExpr{x, lbrack, low, high, rbrack}\n+\t\treturn &ast.SliceExpr{X: x, Lbrack: lbrack, Low: low, High: high, Rbrack: rbrack}\n \t}\n-\treturn &ast.IndexExpr{x, lbrack, low, rbrack}\n+\treturn &ast.IndexExpr{X: x, Lbrack: lbrack, Index: low, Rbrack: rbrack}\n }\n \n func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n@@ -1069,7 +1083,7 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n \tp.exprLev--\n \trparen := p.expectClosing(token.RPAREN, \"argument list\")\n \n-\treturn &ast.CallExpr{fun, lparen, list, ellipsis, rparen}\n+\treturn &ast.CallExpr{Fun: fun, Lparen: lparen, Args: list, Ellipsis: ellipsis, Rparen: rparen}\n }\n \n func (p *parser) parseElement(keyOk bool) ast.Expr {\n@@ -1086,7 +1100,7 @@ func (p *parser) parseElement(keyOk bool) ast.Expr {\n \t\tif p.tok == token.COLON {\n \t\t\tcolon := p.pos\n \t\t\tp.next()\n-\t\t\treturn &ast.KeyValueExpr{x, colon, p.parseElement(false)}\n+\t\t\treturn &ast.KeyValueExpr{Key: x, Colon: colon, Value: p.parseElement(false)}\n \t\t}\n \t\tp.resolve(x) // not a map key\n \t}\n@@ -1123,7 +1137,7 @@ func (p *parser) parseLiteralValue(typ ast.Expr) ast.Expr {\n \t}\n \tp.exprLev--\n \trbrace := p.expectClosing(token.RBRACE, \"composite literal\")\n-\treturn &ast.CompositeLit{typ, lbrace, elts, rbrace}\n+\treturn &ast.CompositeLit{Type: typ, Lbrace: lbrace, Elts: elts, Rbrace: rbrace}\n }\n \n // checkExpr checks that x is an expression (and not a type).\n@@ -1152,7 +1166,7 @@ func (p *parser) checkExpr(x ast.Expr) ast.Expr {\n \tdefault:\n \t\t// all other nodes are not proper expressions\n \t\tp.errorExpected(x.Pos(), \"expression\")\n-\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\tx = &ast.BadExpr{From: x.Pos(), To: x.End()}\n \t}\n \treturn x\n }\n@@ -1215,7 +1229,7 @@ func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {\n \tcase *ast.ArrayType:\n \t\tif len, isEllipsis := t.Len.(*ast.Ellipsis); isEllipsis {\n \t\t\tp.error(len.Pos(), \"expected array length, found '...'\")\n-\t\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\t\tx = &ast.BadExpr{From: x.Pos(), To: x.End()}\n \t\t}\n \t}\n \n@@ -1247,7 +1261,7 @@ L:\n \t\t\t\tpos := p.pos\n \t\t\t\tp.next() // make progress\n \t\t\t\tp.errorExpected(pos, \"selector or type assertion\")\n-\t\t\t\tx = &ast.BadExpr{pos, p.pos}\n+\t\t\t\tx = &ast.BadExpr{From: pos, To: p.pos}\n \t\t\t}\n \t\tcase token.LBRACK:\n \t\t\tif lhs {\n@@ -1288,7 +1302,7 @@ func (p *parser) parseUnaryExpr(lhs bool) ast.Expr {\n \t\tpos, op := p.pos, p.tok\n \t\tp.next()\n \t\tx := p.parseUnaryExpr(false)\n-\t\treturn &ast.UnaryExpr{pos, op, p.checkExpr(x)}\n+\t\treturn &ast.UnaryExpr{OpPos: pos, Op: op, X: p.checkExpr(x)}\n \n \tcase token.ARROW:\n \t\t// channel type or receive expression\n@@ -1297,18 +1311,18 @@ func (p *parser) parseUnaryExpr(lhs bool) ast.Expr {\n \t\tif p.tok == token.CHAN {\n \t\t\tp.next()\n \t\t\tvalue := p.parseType()\n-\t\t\treturn &ast.ChanType{pos, ast.RECV, value}\n+\t\t\treturn &ast.ChanType{Begin: pos, Dir: ast.RECV, Value: value}\n \t\t}\n \n \t\tx := p.parseUnaryExpr(false)\n-\t\treturn &ast.UnaryExpr{pos, token.ARROW, p.checkExpr(x)}\n+\t\treturn &ast.UnaryExpr{OpPos: pos, Op: token.ARROW, X: p.checkExpr(x)}\n \n \tcase token.MUL:\n \t\t// pointer type or unary \"*\" expression\n \t\tpos := p.pos\n \t\tp.next()\n \t\tx := p.parseUnaryExpr(false)\n-\t\treturn &ast.StarExpr{pos, p.checkExprOrType(x)}\n+\t\treturn &ast.StarExpr{Star: pos, X: p.checkExprOrType(x)}\n \t}\n \n \treturn p.parsePrimaryExpr(lhs)\n@@ -1330,7 +1344,7 @@ func (p *parser) parseBinaryExpr(lhs bool, prec1 int) ast.Expr {\n \t\t\t\tlhs = false\n \t\t\t}\n \t\t\ty := p.parseBinaryExpr(false, prec+1)\n-\t\t\tx = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)}\n+\t\t\tx = &ast.BinaryExpr{X: p.checkExpr(x), OpPos: pos, Op: op, Y: p.checkExpr(y)}\n \t\t}\n \t}\n \n@@ -1392,12 +1406,12 @@ func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {\n \t\tif mode == rangeOk && p.tok == token.RANGE && (tok == token.DEFINE || tok == token.ASSIGN) {\n \t\t\tpos := p.pos\n \t\t\tp.next()\n-\t\t\ty = []ast.Expr{&ast.UnaryExpr{pos, token.RANGE, p.parseRhs()}}\n+\t\t\ty = []ast.Expr{&ast.UnaryExpr{OpPos: pos, Op: token.RANGE, X: p.parseRhs()}}\n \t\t\tisRange = true\n \t\t} else {\n \t\t\ty = p.parseRhsList()\n \t\t}\n-\t\tas := &ast.AssignStmt{x, pos, tok, y}\n+\t\tas := &ast.AssignStmt{Lhs: x, TokPos: pos, Tok: tok, Rhs: y}\n \t\tif tok == token.DEFINE {\n \t\t\tp.shortVarDecl(as, x)\n \t\t}\n@@ -1418,7 +1432,7 @@ func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {\n \t\t\t// Go spec: The scope of a label is the body of the function\n \t\t\t// in which it is declared and excludes the body of any nested\n \t\t\t// function.\n-\t\t\tstmt := &ast.LabeledStmt{label, colon, p.parseStmt()}\n+\t\t\tstmt := &ast.LabeledStmt{Label: label, Colon: colon, Stmt: p.parseStmt()}\n \t\t\tp.declare(stmt, nil, p.labelScope, ast.Lbl, label)\n \t\t\treturn stmt, false\n \t\t}\n@@ -1429,24 +1443,24 @@ func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {\n \t\t// before the ':' that caused the problem. Thus, use the (latest) colon\n \t\t// position for error reporting.\n \t\tp.error(colon, \"illegal label declaration\")\n-\t\treturn &ast.BadStmt{x[0].Pos(), colon + 1}, false\n+\t\treturn &ast.BadStmt{From: x[0].Pos(), To: colon + 1}, false\n \n \tcase token.ARROW:\n \t\t// send statement\n \t\tarrow := p.pos\n \t\tp.next()\n \t\ty := p.parseRhs()\n-\t\treturn &ast.SendStmt{x[0], arrow, y}, false\n+\t\treturn &ast.SendStmt{Chan: x[0], Arrow: arrow, Value: y}, false\n \n \tcase token.INC, token.DEC:\n \t\t// increment or decrement\n-\t\ts := &ast.IncDecStmt{x[0], p.pos, p.tok}\n+\t\ts := &ast.IncDecStmt{X: x[0], TokPos: p.pos, Tok: p.tok}\n \t\tp.next()\n \t\treturn s, false\n \t}\n \n \t// expression\n-\treturn &ast.ExprStmt{x[0]}, false\n+\treturn &ast.ExprStmt{X: x[0]}, false\n }\n \n func (p *parser) parseCallExpr() *ast.CallExpr {\n@@ -1467,10 +1481,10 @@ func (p *parser) parseGoStmt() ast.Stmt {\n \tcall := p.parseCallExpr()\n \tp.expectSemi()\n \tif call == nil {\n-\t\treturn &ast.BadStmt{pos, pos + 2} // len(\"go\")\n+\t\treturn &ast.BadStmt{From: pos, To: pos + 2} // len(\"go\")\n \t}\n \n-\treturn &ast.GoStmt{pos, call}\n+\treturn &ast.GoStmt{Go: pos, Call: call}\n }\n \n func (p *parser) parseDeferStmt() ast.Stmt {\n@@ -1482,10 +1496,10 @@ func (p *parser) parseDeferStmt() ast.Stmt {\n \tcall := p.parseCallExpr()\n \tp.expectSemi()\n \tif call == nil {\n-\t\treturn &ast.BadStmt{pos, pos + 5} // len(\"defer\")\n+\t\treturn &ast.BadStmt{From: pos, To: pos + 5} // len(\"defer\")\n \t}\n \n-\treturn &ast.DeferStmt{pos, call}\n+\treturn &ast.DeferStmt{Defer: pos, Call: call}\n }\n \n func (p *parser) parseReturnStmt() *ast.ReturnStmt {\n@@ -1501,7 +1515,7 @@ func (p *parser) parseReturnStmt() *ast.ReturnStmt {\n \t}\n \tp.expectSemi()\n \n-\treturn &ast.ReturnStmt{pos, x}\n+\treturn &ast.ReturnStmt{Return: pos, Results: x}\n }\n \n func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {\n@@ -1519,7 +1533,7 @@ func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {\n \t}\n \tp.expectSemi()\n \n-\treturn &ast.BranchStmt{pos, tok, label}\n+\treturn &ast.BranchStmt{TokPos: pos, Tok: tok, Label: label}\n }\n \n func (p *parser) makeExpr(s ast.Stmt) ast.Expr {\n@@ -1530,7 +1544,7 @@ func (p *parser) makeExpr(s ast.Stmt) ast.Expr {\n \t\treturn p.checkExpr(es.X)\n \t}\n \tp.error(s.Pos(), \"expected condition, found simple statement\")\n-\treturn &ast.BadExpr{s.Pos(), s.End()}\n+\treturn &ast.BadExpr{From: s.Pos(), To: s.End()}\n }\n \n func (p *parser) parseIfStmt() *ast.IfStmt {\n@@ -1572,7 +1586,7 @@ func (p *parser) parseIfStmt() *ast.IfStmt {\n \t\tp.expectSemi()\n \t}\n \n-\treturn &ast.IfStmt{pos, s, x, body, else_}\n+\treturn &ast.IfStmt{If: pos, Init: s, Cond: x, Body: body, Else: else_}\n }\n \n func (p *parser) parseTypeList() (list []ast.Expr) {\n@@ -1612,7 +1626,7 @@ func (p *parser) parseCaseClause(typeSwitch bool) *ast.CaseClause {\n \tbody := p.parseStmtList()\n \tp.closeScope()\n \n-\treturn &ast.CaseClause{pos, list, colon, body}\n+\treturn &ast.CaseClause{Case: pos, List: list, Colon: colon, Body: body}\n }\n \n func isTypeSwitchAssert(x ast.Expr) bool {\n@@ -1681,13 +1695,13 @@ func (p *parser) parseSwitchStmt() ast.Stmt {\n \t}\n \trbrace := p.expect(token.RBRACE)\n \tp.expectSemi()\n-\tbody := &ast.BlockStmt{lbrace, list, rbrace}\n+\tbody := &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}\n \n \tif typeSwitch {\n-\t\treturn &ast.TypeSwitchStmt{pos, s1, s2, body}\n+\t\treturn &ast.TypeSwitchStmt{Switch: pos, Init: s1, Assign: s2, Body: body}\n \t}\n \n-\treturn &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body}\n+\treturn &ast.SwitchStmt{Switch: pos, Init: s1, Tag: p.makeExpr(s2), Body: body}\n }\n \n func (p *parser) parseCommClause() *ast.CommClause {\n@@ -1710,7 +1724,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\tarrow := p.pos\n \t\t\tp.next()\n \t\t\trhs := p.parseRhs()\n-\t\t\tcomm = &ast.SendStmt{lhs[0], arrow, rhs}\n+\t\t\tcomm = &ast.SendStmt{Chan: lhs[0], Arrow: arrow, Value: rhs}\n \t\t} else {\n \t\t\t// RecvStmt\n \t\t\tif tok := p.tok; tok == token.ASSIGN || tok == token.DEFINE {\n@@ -1723,7 +1737,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\tpos := p.pos\n \t\t\t\tp.next()\n \t\t\t\trhs := p.parseRhs()\n-\t\t\t\tas := &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n+\t\t\t\tas := &ast.AssignStmt{Lhs: lhs, TokPos: pos, Tok: tok, Rhs: []ast.Expr{rhs}}\n \t\t\t\tif tok == token.DEFINE {\n \t\t\t\t\tp.shortVarDecl(as, lhs)\n \t\t\t\t}\n@@ -1734,7 +1748,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n \t\t\t\t\t// continue with first expression\n \t\t\t\t}\n-\t\t\t\tcomm = &ast.ExprStmt{lhs[0]}\n+\t\t\t\tcomm = &ast.ExprStmt{X: lhs[0]}\n \t\t\t}\n \t\t}\n \t} else {\n@@ -1745,7 +1759,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \tbody := p.parseStmtList()\n \tp.closeScope()\n \n-\treturn &ast.CommClause{pos, comm, colon, body}\n+\treturn &ast.CommClause{Case: pos, Comm: comm, Colon: colon, Body: body}\n }\n \n func (p *parser) parseSelectStmt() *ast.SelectStmt {\n@@ -1761,9 +1775,9 @@ func (p *parser) parseSelectStmt() *ast.SelectStmt {\n \t}\n \trbrace := p.expect(token.RBRACE)\n \tp.expectSemi()\n-\tbody := &ast.BlockStmt{lbrace, list, rbrace}\n+\tbody := &ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}\n \n-\treturn &ast.SelectStmt{pos, body}\n+\treturn &ast.SelectStmt{Select: pos, Body: body}\n }\n \n func (p *parser) parseForStmt() ast.Stmt {\n@@ -1812,16 +1826,30 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t\t\tkey = as.Lhs[0]\n \t\tdefault:\n \t\t\tp.errorExpected(as.Lhs[0].Pos(), \"1 or 2 expressions\")\n-\t\t\treturn &ast.BadStmt{pos, body.End()}\n+\t\t\treturn &ast.BadStmt{From: pos, To: body.End()}\n \t\t}\n \t\t// parseSimpleStmt returned a right-hand side that\n \t\t// is a single unary expression of the form \"range x\"\n \t\tx := as.Rhs[0].(*ast.UnaryExpr).X\n-\t\treturn &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, x, body}\n+\t\treturn &ast.RangeStmt{\n+\t\t\tFor:    pos,\n+\t\t\tKey:    key,\n+\t\t\tValue:  value,\n+\t\t\tTokPos: as.TokPos,\n+\t\t\tTok:    as.Tok,\n+\t\t\tX:      x,\n+\t\t\tBody:   body,\n+\t\t}\n \t}\n \n \t// regular for statement\n-\treturn &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}\n+\treturn &ast.ForStmt{\n+\t\tFor:  pos,\n+\t\tInit: s1,\n+\t\tCond: p.makeExpr(s2),\n+\t\tPost: s3,\n+\t\tBody: body,\n+\t}\n }\n \n func (p *parser) parseStmt() (s ast.Stmt) {\n@@ -1831,12 +1859,12 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n \n \tswitch p.tok {\n \tcase token.CONST, token.TYPE, token.VAR:\n-\t\ts = &ast.DeclStmt{p.parseDecl()}\n+\t\ts = &ast.DeclStmt{Decl: p.parseDecl()}\n \tcase\n-\t\t// tokens that may start a top-level expression\n-\t\ttoken.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operand\n-\t\ttoken.LBRACK, token.STRUCT, // composite type\n-\t\ttoken.MUL, token.AND, token.ARROW, token.ADD, token.SUB, token.XOR: // unary operators\n+\t\t// tokens that may start an expression\n+\t\ttoken.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands\n+\t\ttoken.LBRACK, token.STRUCT, // composite types\n+\t\ttoken.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators\n \t\ts, _ = p.parseSimpleStmt(labelOk)\n \t\t// because of the required look-ahead, labeled statements are\n \t\t// parsed by parseSimpleStmt - don't expect a semicolon after\n@@ -1864,17 +1892,17 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n \tcase token.FOR:\n \t\ts = p.parseForStmt()\n \tcase token.SEMICOLON:\n-\t\ts = &ast.EmptyStmt{p.pos}\n+\t\ts = &ast.EmptyStmt{Semicolon: p.pos}\n \t\tp.next()\n \tcase token.RBRACE:\n \t\t// a semicolon may be omitted before a closing \"}\"\n-\t\ts = &ast.EmptyStmt{p.pos}\n+\t\ts = &ast.EmptyStmt{Semicolon: p.pos}\n \tdefault:\n \t\t// no statement found\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"statement\")\n \t\tp.next() // make progress\n-\t\ts = &ast.BadStmt{pos, p.pos}\n+\t\ts = &ast.BadStmt{From: pos, To: p.pos}\n \t}\n \n \treturn\n@@ -1893,23 +1921,28 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tvar ident *ast.Ident\n \tswitch p.tok {\n \tcase token.PERIOD:\n-\t\tident = &ast.Ident{p.pos, \".\", nil}\n+\t\tident = &ast.Ident{NamePos: p.pos, Name: \".\"}\n \t\tp.next()\n \tcase token.IDENT:\n \t\tident = p.parseIdent()\n \t}\n \n \tvar path *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tpath = &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}\n \t\tp.next()\n \t} else {\n \t\tp.expect(token.STRING) // use expect() error handling\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n \t// collect imports\n-\tspec := &ast.ImportSpec{doc, ident, path, p.lineComment, token.NoPos}\n+\tspec := &ast.ImportSpec{\n+\t\tDoc:     doc,\n+\t\tName:    ident,\n+\t\tPath:    path,\n+\t\tComment: p.lineComment,\n+\t}\n \tp.imports = append(p.imports, spec)\n \n \treturn spec\n@@ -1933,7 +1966,13 @@ func parseConstSpec(p *parser, doc *ast.CommentGroup, iota int) ast.Spec {\n \t// a function begins at the end of the ConstSpec or VarSpec and ends at\n \t// the end of the innermost containing block.\n \t// (Global identifiers are resolved in a separate phase after parsing.)\n-\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tspec := &ast.ValueSpec{\n+\t\tDoc:     doc,\n+\t\tNames:   idents,\n+\t\tType:    typ,\n+\t\tValues:  values,\n+\t\tComment: p.lineComment,\n+\t}\n \tp.declare(spec, iota, p.topScope, ast.Con, idents...)\n \n \treturn spec\n@@ -1950,7 +1989,7 @@ func parseTypeSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \t// at the identifier in the TypeSpec and ends at the end of the innermost\n \t// containing block.\n \t// (Global identifiers are resolved in a separate phase after parsing.)\n-\tspec := &ast.TypeSpec{doc, ident, nil, nil}\n+\tspec := &ast.TypeSpec{Doc: doc, Name: ident}\n \tp.declare(spec, nil, p.topScope, ast.Typ, ident)\n \n \tspec.Type = p.parseType()\n@@ -1978,7 +2017,13 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \t// a function begins at the end of the ConstSpec or VarSpec and ends at\n \t// the end of the innermost containing block.\n \t// (Global identifiers are resolved in a separate phase after parsing.)\n-\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tspec := &ast.ValueSpec{\n+\t\tDoc:     doc,\n+\t\tNames:   idents,\n+\t\tType:    typ,\n+\t\tValues:  values,\n+\t\tComment: p.lineComment,\n+\t}\n \tp.declare(spec, nil, p.topScope, ast.Var, idents...)\n \n \treturn spec\n@@ -2005,7 +2050,14 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.Gen\n \t\tlist = append(list, f(p, nil, 0))\n \t}\n \n-\treturn &ast.GenDecl{doc, pos, keyword, lparen, list, rparen}\n+\treturn &ast.GenDecl{\n+\t\tDoc:    doc,\n+\t\tTokPos: pos,\n+\t\tTok:    keyword,\n+\t\tLparen: lparen,\n+\t\tSpecs:  list,\n+\t\tRparen: rparen,\n+\t}\n }\n \n func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n@@ -2018,7 +2070,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \t// must have exactly one receiver\n \tif par.NumFields() != 1 {\n \t\tp.errorExpected(par.Opening, \"exactly one receiver\")\n-\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{par.Opening, par.Closing + 1}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{From: par.Opening, To: par.Closing + 1}}}\n \t\treturn par\n \t}\n \n@@ -2027,7 +2079,7 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \tbase := deref(recv.Type)\n \tif _, isIdent := base.(*ast.Ident); !isIdent {\n \t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n-\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n+\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{From: recv.Pos(), To: recv.End()}}}\n \t}\n \n \treturn par\n@@ -2057,7 +2109,17 @@ func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \t}\n \tp.expectSemi()\n \n-\tdecl := &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body}\n+\tdecl := &ast.FuncDecl{\n+\t\tDoc:  doc,\n+\t\tRecv: recv,\n+\t\tName: ident,\n+\t\tType: &ast.FuncType{\n+\t\t\tFunc:    pos,\n+\t\t\tParams:  params,\n+\t\t\tResults: results,\n+\t\t},\n+\t\tBody: body,\n+\t}\n \tif recv == nil {\n \t\t// Go spec: The scope of an identifier denoting a constant, type,\n \t\t// variable, or function (but not method) declared at top level\n@@ -2096,7 +2158,7 @@ func (p *parser) parseDecl() ast.Decl {\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"declaration\")\n \t\tp.next() // make progress\n-\t\tdecl := &ast.BadDecl{pos, p.pos}\n+\t\tdecl := &ast.BadDecl{From: pos, To: p.pos}\n \t\treturn decl\n \t}\n \n@@ -2155,5 +2217,14 @@ func (p *parser) parseFile() *ast.File {\n \t\t}\n \t}\n \n-\treturn &ast.File{doc, pos, ident, decls, p.pkgScope, p.imports, p.unresolved[0:i], p.comments}\n+\treturn &ast.File{\n+\t\tDoc:        doc,\n+\t\tPackage:    pos,\n+\t\tName:       ident,\n+\t\tDecls:      decls,\n+\t\tScope:      p.pkgScope,\n+\t\tImports:    p.imports,\n+\t\tUnresolved: p.unresolved[0:i],\n+\t\tComments:   p.comments,\n+\t}\n }"}, {"sha": "cd5e075c16c9a0d84fc39fa19dd2843b29fbacc7", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 35, "deletions": 71, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -87,7 +87,6 @@ const (\n \tcommaSep                            // elements are separated by commas\n \tcommaTerm                           // list is optionally terminated by a comma\n \tnoIndent                            // no extra indentation in multi-line lists\n-\tperiodSep                           // elements are separated by periods\n )\n \n // Sets multiLine to true if the identifier list spans multiple lines.\n@@ -133,7 +132,9 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\tfor i, x := range list {\n \t\t\tif i > 0 {\n \t\t\t\tif mode&commaSep != 0 {\n-\t\t\t\t\tp.print(token.COMMA)\n+\t\t\t\t\t// use position of expression following the comma as\n+\t\t\t\t\t// comma position for correct comment placement\n+\t\t\t\t\tp.print(x.Pos(), token.COMMA)\n \t\t\t\t}\n \t\t\t\tp.print(blank)\n \t\t\t}\n@@ -213,14 +214,18 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t}\n \n \t\tif i > 0 {\n-\t\t\tswitch {\n-\t\t\tcase mode&commaSep != 0:\n+\t\t\tneedsLinebreak := prevLine < line && prevLine > 0 && line > 0\n+\t\t\tif mode&commaSep != 0 {\n+\t\t\t\t// use position of expression following the comma as\n+\t\t\t\t// comma position for correct comment placement, but\n+\t\t\t\t// only if the expression is on the same line\n+\t\t\t\tif !needsLinebreak {\n+\t\t\t\t\tp.print(x.Pos())\n+\t\t\t\t}\n \t\t\t\tp.print(token.COMMA)\n-\t\t\tcase mode&periodSep != 0:\n-\t\t\t\tp.print(token.PERIOD)\n \t\t\t}\n-\t\t\tneedsBlank := mode&periodSep == 0 // period-separated list elements don't need a blank\n-\t\t\tif prevLine < line && prevLine > 0 && line > 0 {\n+\t\t\tneedsBlank := true\n+\t\t\tif needsLinebreak {\n \t\t\t\t// lines are broken using newlines so comments remain aligned\n \t\t\t\t// unless forceFF is set or there are multiple expressions on\n \t\t\t\t// the same line in which case formfeed is used\n@@ -287,11 +292,18 @@ func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n \t\t\t\tparLineBeg = parLineEnd\n \t\t\t}\n \t\t\t// separating \",\" if needed\n+\t\t\tneedsLinebreak := 0 < prevLine && prevLine < parLineBeg\n \t\t\tif i > 0 {\n+\t\t\t\t// use position of parameter following the comma as\n+\t\t\t\t// comma position for correct comma placement, but\n+\t\t\t\t// only if the next parameter is on the same line\n+\t\t\t\tif !needsLinebreak {\n+\t\t\t\t\tp.print(par.Pos())\n+\t\t\t\t}\n \t\t\t\tp.print(token.COMMA)\n \t\t\t}\n \t\t\t// separator if needed (linebreak or blank)\n-\t\t\tif 0 < prevLine && prevLine < parLineBeg && p.linebreak(parLineBeg, 0, ws, true) {\n+\t\t\tif needsLinebreak && p.linebreak(parLineBeg, 0, ws, true) {\n \t\t\t\t// break line if the opening \"(\" or previous parameter ended on a different line\n \t\t\t\tws = ignore\n \t\t\t\t*multiLine = true\n@@ -316,7 +328,7 @@ func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n \t\t// if the closing \")\" is on a separate line from the last parameter,\n \t\t// print an additional \",\" and line break\n \t\tif closing := p.lineFor(fields.Closing); 0 < prevLine && prevLine < closing {\n-\t\t\tp.print(\",\")\n+\t\t\tp.print(token.COMMA)\n \t\t\tp.linebreak(closing, 0, ignore, true)\n \t\t}\n \t\t// unindent if we indented\n@@ -374,7 +386,7 @@ func (p *printer) isOneLineFieldList(list []*ast.Field) bool {\n }\n \n func (p *printer) setLineComment(text string) {\n-\tp.setComment(&ast.CommentGroup{[]*ast.Comment{{token.NoPos, text}}})\n+\tp.setComment(&ast.CommentGroup{List: []*ast.Comment{{Slash: token.NoPos, Text: text}}})\n }\n \n func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool) {\n@@ -397,6 +409,7 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \t\t\tf := list[0]\n \t\t\tfor i, x := range f.Names {\n \t\t\t\tif i > 0 {\n+\t\t\t\t\t// no comments so no need for comma position\n \t\t\t\t\tp.print(token.COMMA, blank)\n \t\t\t\t}\n \t\t\t\tp.expr(x, ignoreMultiLine)\n@@ -668,63 +681,6 @@ func isBinary(expr ast.Expr) bool {\n \treturn ok\n }\n \n-// If the expression contains one or more selector expressions, splits it into\n-// two expressions at the rightmost period. Writes entire expr to suffix when\n-// selector isn't found. Rewrites AST nodes for calls, index expressions and\n-// type assertions, all of which may be found in selector chains, to make them\n-// parts of the chain.\n-func splitSelector(expr ast.Expr) (body, suffix ast.Expr) {\n-\tswitch x := expr.(type) {\n-\tcase *ast.SelectorExpr:\n-\t\tbody, suffix = x.X, x.Sel\n-\t\treturn\n-\tcase *ast.CallExpr:\n-\t\tbody, suffix = splitSelector(x.Fun)\n-\t\tif body != nil {\n-\t\t\tsuffix = &ast.CallExpr{suffix, x.Lparen, x.Args, x.Ellipsis, x.Rparen}\n-\t\t\treturn\n-\t\t}\n-\tcase *ast.IndexExpr:\n-\t\tbody, suffix = splitSelector(x.X)\n-\t\tif body != nil {\n-\t\t\tsuffix = &ast.IndexExpr{suffix, x.Lbrack, x.Index, x.Rbrack}\n-\t\t\treturn\n-\t\t}\n-\tcase *ast.SliceExpr:\n-\t\tbody, suffix = splitSelector(x.X)\n-\t\tif body != nil {\n-\t\t\tsuffix = &ast.SliceExpr{suffix, x.Lbrack, x.Low, x.High, x.Rbrack}\n-\t\t\treturn\n-\t\t}\n-\tcase *ast.TypeAssertExpr:\n-\t\tbody, suffix = splitSelector(x.X)\n-\t\tif body != nil {\n-\t\t\tsuffix = &ast.TypeAssertExpr{suffix, x.Type}\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tsuffix = expr\n-\treturn\n-}\n-\n-// Convert an expression into an expression list split at the periods of\n-// selector expressions.\n-func selectorExprList(expr ast.Expr) (list []ast.Expr) {\n-\t// split expression\n-\tfor expr != nil {\n-\t\tvar suffix ast.Expr\n-\t\texpr, suffix = splitSelector(expr)\n-\t\tlist = append(list, suffix)\n-\t}\n-\n-\t// reverse list\n-\tfor i, j := 0, len(list)-1; i < j; i, j = i+1, j-1 {\n-\t\tlist[i], list[j] = list[j], list[i]\n-\t}\n-\n-\treturn\n-}\n-\n // Sets multiLine to true if the expression spans multiple lines.\n func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \tp.print(expr.Pos())\n@@ -798,8 +754,14 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \t\t}\n \n \tcase *ast.SelectorExpr:\n-\t\tparts := selectorExprList(expr)\n-\t\tp.exprList(token.NoPos, parts, depth, periodSep, multiLine, token.NoPos)\n+\t\tp.expr1(x.X, token.HighestPrec, depth, multiLine)\n+\t\tp.print(token.PERIOD)\n+\t\tif line := p.lineFor(x.Sel.Pos()); p.pos.IsValid() && p.pos.Line < line {\n+\t\t\tp.print(indent, newline, x.Sel.Pos(), x.Sel, unindent)\n+\t\t\t*multiLine = true\n+\t\t} else {\n+\t\t\tp.print(x.Sel.Pos(), x.Sel)\n+\t\t}\n \n \tcase *ast.TypeAssertExpr:\n \t\tp.expr1(x.X, token.HighestPrec, depth, multiLine)\n@@ -1180,7 +1142,9 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\tp.print(token.FOR, blank)\n \t\tp.expr(s.Key, multiLine)\n \t\tif s.Value != nil {\n-\t\t\tp.print(token.COMMA, blank)\n+\t\t\t// use position of value following the comma as\n+\t\t\t// comma position for correct comment placement\n+\t\t\tp.print(s.Value.Pos(), token.COMMA, blank)\n \t\t\tp.expr(s.Value, multiLine)\n \t\t}\n \t\tp.print(blank, s.TokPos, s.Tok, blank, token.RANGE, blank)"}, {"sha": "72f65a1d8526637fd1c56dcfcaf1d9e4a02f005c", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -686,9 +686,11 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (wro\n \t}\n \n \tif last != nil {\n-\t\tif last.Text[1] == '*' && p.lineFor(last.Pos()) == next.Line {\n-\t\t\t// the last comment is a /*-style comment and the next item\n-\t\t\t// follows on the same line: separate with an extra blank\n+\t\t// if the last comment is a /*-style comment and the next item\n+\t\t// follows on the same line but is not a comma or a \"closing\"\n+\t\t// token, add an extra blank for separation\n+\t\tif last.Text[1] == '*' && p.lineFor(last.Pos()) == next.Line && tok != token.COMMA &&\n+\t\t\ttok != token.RPAREN && tok != token.RBRACK && tok != token.RBRACE {\n \t\t\tp.writeByte(' ', 1)\n \t\t}\n \t\t// ensure that there is a line break after a //-style comment,"}, {"sha": "2d4f61356c19f6d67f3d0ad6b7a3dcdc40129886", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -283,10 +283,10 @@ func fibo(n int) {\n \t\tt.Error(\"expected offset 1\") // error in test\n \t}\n \n-\ttestComment(t, f, len(src), &ast.Comment{pos, \"//-style comment\"})\n-\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style comment */\"})\n-\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style \\n comment */\"})\n-\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style comment \\n\\n\\n */\"})\n+\ttestComment(t, f, len(src), &ast.Comment{Slash: pos, Text: \"//-style comment\"})\n+\ttestComment(t, f, len(src), &ast.Comment{Slash: pos, Text: \"/*-style comment */\"})\n+\ttestComment(t, f, len(src), &ast.Comment{Slash: pos, Text: \"/*-style \\n comment */\"})\n+\ttestComment(t, f, len(src), &ast.Comment{Slash: pos, Text: \"/*-style comment \\n\\n\\n */\"})\n }\n \n type visitor chan *ast.Ident"}, {"sha": "4c6f1ab82740d985859f8938989021ef09a403b1", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -405,16 +405,17 @@ func _() {\n }\n \n // Some interesting interspersed comments.\n+// See below for more common cases.\n func _( /* this */ x /* is */ /* an */ int) {\n }\n \n-func _( /* no params */ )\t{}\n+func _( /* no params */)\t{}\n \n func _() {\n-\tf( /* no args */ )\n+\tf( /* no args */)\n }\n \n-func ( /* comment1 */ T /* comment2 */ ) _()\t{}\n+func ( /* comment1 */ T /* comment2 */) _()\t{}\n \n func _() { /* one-line functions with comments are formatted as multi-line functions */\n }\n@@ -425,7 +426,7 @@ func _() {\n }\n \n func _() {\n-\t_ = []int{0, 1 /* don't introduce a newline after this comment - was issue 1365 */ }\n+\t_ = []int{0, 1 /* don't introduce a newline after this comment - was issue 1365 */}\n }\n \n // Test cases from issue 1542:\n@@ -448,8 +449,9 @@ func _() {\n \t_ = a\n }\n \n-// Comments immediately adjacent to punctuation (for which the go/printer\n-// may only have estimated position information) must remain after the punctuation.\n+// Comments immediately adjacent to punctuation followed by a newline\n+// remain after the punctuation (looks better and permits alignment of\n+// comments).\n func _() {\n \t_ = T{\n \t\t1,\t// comment after comma\n@@ -479,6 +481,35 @@ func _() {\n \t}\n }\n \n+// If there is no newline following punctuation, commas move before the punctuation.\n+// This way, commas interspersed in lists stay with the respective expression.\n+func f(x /* comment */, y int, z int /* comment */, u, v, w int /* comment */) {\n+\tf(x /* comment */, y)\n+\tf(x,\t/* comment */\n+\t\ty)\n+\tf(\n+\t\tx,\t/* comment */\n+\t)\n+}\n+\n+func g(\n+\tx int,\t/* comment */\n+) {\n+}\n+\n+type _ struct {\n+\ta, b /* comment */, c int\n+}\n+\n+type _ struct {\n+\ta, b /* comment */, c int\n+}\n+\n+func _() {\n+\tfor a /* comment */, b := range x {\n+\t}\n+}\n+\n // Print line directives correctly.\n \n // The following is a legal line directive."}, {"sha": "c0f8cca3a92babd7a89d03e624c384352d8c938f", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -411,6 +411,7 @@ func _() {\n \n \n // Some interesting interspersed comments.\n+// See below for more common cases.\n func _(/* this */x/* is *//* an */ int) {\n }\n \n@@ -453,8 +454,9 @@ func _() {\n \t_ = a\n }\n \n-// Comments immediately adjacent to punctuation (for which the go/printer\n-// may only have estimated position information) must remain after the punctuation.\n+// Comments immediately adjacent to punctuation followed by a newline\n+// remain after the punctuation (looks better and permits alignment of\n+// comments).\n func _() {\n \t_ = T{\n \t\t1,    // comment after comma\n@@ -486,6 +488,31 @@ func _() {\n \t}\n }\n \n+// If there is no newline following punctuation, commas move before the punctuation.\n+// This way, commas interspersed in lists stay with the respective expression.\n+func f(x/* comment */, y int, z int /* comment */, u, v, w int /* comment */) {\n+\tf(x /* comment */, y)\n+\tf(x /* comment */, \n+\ty)\n+\tf(\n+\t\tx /* comment */,\n+\t)\n+}\n+\n+func g(\n+\tx int /* comment */,\n+) {}\n+\n+type _ struct {\n+\ta, b /* comment */, c int\n+}\n+\n+type _ struct { a, b /* comment */, c int }\n+\n+func _() {\n+\tfor a /* comment */, b := range x {\n+\t}\n+}\n \n // Print line directives correctly.\n "}, {"sha": "95fdd95ffbba598e94b986fda2684286ba42eeb6", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -545,7 +545,7 @@ func _() {\n \t// handle multiline argument list correctly\n \t_ = new(T).\n \t\tfoo(\n-\t\t\t1).\n+\t\t1).\n \t\tfoo(2)\n \n \t_ = new(T).foo(\n@@ -587,12 +587,12 @@ func _() {\n \t_ = new(T).\n \t\tField.\n \t\tArray[3+\n-\t\t\t4].\n+\t\t4].\n \t\tTable[\"foo\"].\n \t\tBlob.(*Type).\n \t\tSlices[1:4].\n \t\tMethod(1, 2,\n-\t\t\t3).\n+\t\t3).\n \t\tThingy\n \n \t_ = a.b.c"}, {"sha": "3442ba9b9501da9e83b2c900ce03def1bfecbe74", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -545,7 +545,7 @@ func _() {\n \t// handle multiline argument list correctly\n \t_ = new(T).\n \t\tfoo(\n-\t\t\t1).\n+\t\t1).\n \t\tfoo(2)\n \n \t_ = new(T).foo(\n@@ -587,12 +587,12 @@ func _() {\n \t_ = new(T).\n \t\tField.\n \t\tArray[3+\n-\t\t\t4].\n+\t\t4].\n \t\tTable[\"foo\"].\n \t\tBlob.(*Type).\n \t\tSlices[1:4].\n \t\tMethod(1, 2,\n-\t\t\t3).\n+\t\t3).\n \t\tThingy\n \n \t_ = a.b.c"}, {"sha": "2395363b0ec88afb2b07b827113dd623f0ad02ba", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,21 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package scanner implements a scanner for Go source text. Takes a []byte as\n-// source which can then be tokenized through repeated calls to the Scan\n-// function. Typical use:\n-//\n-//\tvar s scanner.Scanner\n-//\tfset := token.NewFileSet()  // position information is relative to fset\n-//\tfile := fset.AddFile(filename, fset.Base(), len(src))  // register file\n-//\ts.Init(file, src, nil /* no error handler */, 0)\n-//\tfor {\n-//\t\tpos, tok, lit := s.Scan()\n-//\t\tif tok == token.EOF {\n-//\t\t\tbreak\n-//\t\t}\n-//\t\t// do something here with pos, tok, and lit\n-//\t}\n+// Package scanner implements a scanner for Go source text.\n+// It takes a []byte as source which can then be tokenized\n+// through repeated calls to the Scan method.\n //\n package scanner\n "}, {"sha": "d0d8ea46733f4aed2538603f619fec906c275f21", "filename": "libgo/go/html/template/clone.go", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c5f21a387dc461042bafc3052ce6e1af786a77/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c5f21a387dc461042bafc3052ce6e1af786a77/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone.go?ref=34c5f21a387dc461042bafc3052ce6e1af786a77", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package template\n-\n-import (\n-\t\"text/template/parse\"\n-)\n-\n-// clone clones a template Node.\n-func clone(n parse.Node) parse.Node {\n-\tswitch t := n.(type) {\n-\tcase *parse.ActionNode:\n-\t\treturn cloneAction(t)\n-\tcase *parse.IfNode:\n-\t\tb := new(parse.IfNode)\n-\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n-\t\treturn b\n-\tcase *parse.ListNode:\n-\t\treturn cloneList(t)\n-\tcase *parse.RangeNode:\n-\t\tb := new(parse.RangeNode)\n-\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n-\t\treturn b\n-\tcase *parse.TemplateNode:\n-\t\treturn cloneTemplate(t)\n-\tcase *parse.TextNode:\n-\t\treturn cloneText(t)\n-\tcase *parse.WithNode:\n-\t\tb := new(parse.WithNode)\n-\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n-\t\treturn b\n-\t}\n-\tpanic(\"cloning \" + n.String() + \" is unimplemented\")\n-}\n-\n-// cloneAction returns a deep clone of n.\n-func cloneAction(n *parse.ActionNode) *parse.ActionNode {\n-\t// We use keyless fields because they won't compile if a field is added.\n-\treturn &parse.ActionNode{n.NodeType, n.Line, clonePipe(n.Pipe)}\n-}\n-\n-// cloneList returns a deep clone of n.\n-func cloneList(n *parse.ListNode) *parse.ListNode {\n-\tif n == nil {\n-\t\treturn nil\n-\t}\n-\t// We use keyless fields because they won't compile if a field is added.\n-\tc := parse.ListNode{n.NodeType, make([]parse.Node, len(n.Nodes))}\n-\tfor i, child := range n.Nodes {\n-\t\tc.Nodes[i] = clone(child)\n-\t}\n-\treturn &c\n-}\n-\n-// clonePipe returns a shallow clone of n.\n-// The escaper does not modify pipe descendants in place so there's no need to\n-// clone deeply.\n-func clonePipe(n *parse.PipeNode) *parse.PipeNode {\n-\tif n == nil {\n-\t\treturn nil\n-\t}\n-\t// We use keyless fields because they won't compile if a field is added.\n-\treturn &parse.PipeNode{n.NodeType, n.Line, n.Decl, n.Cmds}\n-}\n-\n-// cloneTemplate returns a deep clone of n.\n-func cloneTemplate(n *parse.TemplateNode) *parse.TemplateNode {\n-\t// We use keyless fields because they won't compile if a field is added.\n-\treturn &parse.TemplateNode{n.NodeType, n.Line, n.Name, clonePipe(n.Pipe)}\n-}\n-\n-// cloneText clones the given node sharing its []byte.\n-func cloneText(n *parse.TextNode) *parse.TextNode {\n-\t// We use keyless fields because they won't compile if a field is added.\n-\treturn &parse.TextNode{n.NodeType, n.Text}\n-}\n-\n-// copyBranch clones src into dst.\n-func copyBranch(dst, src *parse.BranchNode) {\n-\t// We use keyless fields because they won't compile if a field is added.\n-\t*dst = parse.BranchNode{\n-\t\tsrc.NodeType,\n-\t\tsrc.Line,\n-\t\tclonePipe(src.Pipe),\n-\t\tcloneList(src.List),\n-\t\tcloneList(src.ElseList),\n-\t}\n-}"}, {"sha": "c612775d4f01fba832c3f195eebcc045b02809df", "filename": "libgo/go/html/template/clone_test.go", "status": "modified", "additions": 99, "deletions": 76, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,86 +7,109 @@ package template\n import (\n \t\"bytes\"\n \t\"testing\"\n+\t\"text/template/parse\"\n )\n \n+func TestAddParseTree(t *testing.T) {\n+\troot := Must(New(\"root\").Parse(`{{define \"a\"}} {{.}} {{template \"b\"}} {{.}} \"></a>{{end}}`))\n+\ttree, err := parse.Parse(\"t\", `{{define \"b\"}}<a href=\"{{end}}`, \"\", \"\", nil, nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tadded := Must(root.AddParseTree(\"b\", tree[\"b\"]))\n+\tb := new(bytes.Buffer)\n+\terr = added.ExecuteTemplate(b, \"a\", \"1>0\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := b.String(), ` 1&gt;0 <a href=\" 1%3e0 \"></a>`; got != want {\n+\t\tt.Errorf(\"got %q want %q\", got, want)\n+\t}\n+}\n+\n func TestClone(t *testing.T) {\n-\ttests := []struct {\n-\t\tinput, want, wantClone string\n-\t}{\n-\t\t{\n-\t\t\t`Hello, {{if true}}{{\"<World>\"}}{{end}}!`,\n-\t\t\t\"Hello, <World>!\",\n-\t\t\t\"Hello, &lt;World&gt;!\",\n-\t\t},\n-\t\t{\n-\t\t\t`Hello, {{if false}}{{.X}}{{else}}{{\"<World>\"}}{{end}}!`,\n-\t\t\t\"Hello, <World>!\",\n-\t\t\t\"Hello, &lt;World&gt;!\",\n-\t\t},\n-\t\t{\n-\t\t\t`Hello, {{with \"<World>\"}}{{.}}{{end}}!`,\n-\t\t\t\"Hello, <World>!\",\n-\t\t\t\"Hello, &lt;World&gt;!\",\n-\t\t},\n-\t\t{\n-\t\t\t`{{range .}}<p>{{.}}</p>{{end}}`,\n-\t\t\t\"<p>foo</p><p><bar></p><p>baz</p>\",\n-\t\t\t\"<p>foo</p><p>&lt;bar&gt;</p><p>baz</p>\",\n-\t\t},\n-\t\t{\n-\t\t\t`Hello, {{\"<World>\" | html}}!`,\n-\t\t\t\"Hello, &lt;World&gt;!\",\n-\t\t\t\"Hello, &lt;World&gt;!\",\n-\t\t},\n-\t\t{\n-\t\t\t`Hello{{if 1}}, World{{else}}{{template \"d\"}}{{end}}!`,\n-\t\t\t\"Hello, World!\",\n-\t\t\t\"Hello, World!\",\n-\t\t},\n+\t// The {{.}} will be executed with data \"<i>*/\" in different contexts.\n+\t// In the t0 template, it will be in a text context.\n+\t// In the t1 template, it will be in a URL context.\n+\t// In the t2 template, it will be in a JavaScript context.\n+\t// In the t3 template, it will be in a CSS context.\n+\tconst tmpl = `{{define \"a\"}}{{template \"lhs\"}}{{.}}{{template \"rhs\"}}{{end}}`\n+\tb := new(bytes.Buffer)\n+\n+\t// Create an incomplete template t0.\n+\tt0 := Must(New(\"t0\").Parse(tmpl))\n+\n+\t// Clone t0 as t1.\n+\tt1 := Must(t0.Clone())\n+\tMust(t1.Parse(`{{define \"lhs\"}} <a href=\" {{end}}`))\n+\tMust(t1.Parse(`{{define \"rhs\"}} \"></a> {{end}}`))\n+\n+\t// Execute t1.\n+\tb.Reset()\n+\tif err := t1.ExecuteTemplate(b, \"a\", \"<i>*/\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := b.String(), ` <a href=\" %3ci%3e*/ \"></a> `; got != want {\n+\t\tt.Errorf(\"t1: got %q want %q\", got, want)\n+\t}\n+\n+\t// Clone t0 as t2.\n+\tt2 := Must(t0.Clone())\n+\tMust(t2.Parse(`{{define \"lhs\"}} <p onclick=\"javascript: {{end}}`))\n+\tMust(t2.Parse(`{{define \"rhs\"}} \"></p> {{end}}`))\n+\n+\t// Execute t2.\n+\tb.Reset()\n+\tif err := t2.ExecuteTemplate(b, \"a\", \"<i>*/\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := b.String(), ` <p onclick=\"javascript: &#34;\\u003ci\\u003e*/&#34; \"></p> `; got != want {\n+\t\tt.Errorf(\"t2: got %q want %q\", got, want)\n \t}\n \n-\tfor _, test := range tests {\n-\t\ts, err := New(\"s\").Parse(test.input)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"input=%q: unexpected parse error %v\", test.input, err)\n-\t\t}\n-\n-\t\td, _ := New(\"d\").Parse(test.input)\n-\t\t// Hack: just replace the root of the tree.\n-\t\td.text.Root = cloneList(s.text.Root)\n-\n-\t\tif want, got := s.text.Root.String(), d.text.Root.String(); want != got {\n-\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n-\t\t}\n-\n-\t\terr = escapeTemplates(d, \"d\")\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%q: failed to escape: %s\", test.input, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif want, got := \"s\", s.Name(); want != got {\n-\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif want, got := \"d\", d.Name(); want != got {\n-\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tdata := []string{\"foo\", \"<bar>\", \"baz\"}\n-\n-\t\tvar b bytes.Buffer\n-\t\td.Execute(&b, data)\n-\t\tif got := b.String(); got != test.wantClone {\n-\t\t\tt.Errorf(\"input=%q: want %q, got %q\", test.input, test.wantClone, got)\n-\t\t}\n-\n-\t\t// Make sure escaping d did not affect s.\n-\t\tb.Reset()\n-\t\ts.text.Execute(&b, data)\n-\t\tif got := b.String(); got != test.want {\n-\t\t\tt.Errorf(\"input=%q: want %q, got %q\", test.input, test.want, got)\n-\t\t}\n+\t// Clone t0 as t3, but do not execute t3 yet.\n+\tt3 := Must(t0.Clone())\n+\tMust(t3.Parse(`{{define \"lhs\"}} <style> {{end}}`))\n+\tMust(t3.Parse(`{{define \"rhs\"}} </style> {{end}}`))\n+\n+\t// Complete t0.\n+\tMust(t0.Parse(`{{define \"lhs\"}} ( {{end}}`))\n+\tMust(t0.Parse(`{{define \"rhs\"}} ) {{end}}`))\n+\n+\t// Clone t0 as t4. Redefining the \"lhs\" template should fail.\n+\tt4 := Must(t0.Clone())\n+\tif _, err := t4.Parse(`{{define \"lhs\"}} FAIL {{end}}`); err == nil {\n+\t\tt.Error(`redefine \"lhs\": got nil err want non-nil`)\n+\t}\n+\n+\t// Execute t0.\n+\tb.Reset()\n+\tif err := t0.ExecuteTemplate(b, \"a\", \"<i>*/\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := b.String(), ` ( &lt;i&gt;*/ ) `; got != want {\n+\t\tt.Errorf(\"t0: got %q want %q\", got, want)\n+\t}\n+\n+\t// Clone t0. This should fail, as t0 has already executed.\n+\tif _, err := t0.Clone(); err == nil {\n+\t\tt.Error(`t0.Clone(): got nil err want non-nil`)\n+\t}\n+\n+\t// Similarly, cloning sub-templates should fail.\n+\tif _, err := t0.Lookup(\"a\").Clone(); err == nil {\n+\t\tt.Error(`t0.Lookup(\"a\").Clone(): got nil err want non-nil`)\n+\t}\n+\tif _, err := t0.Lookup(\"lhs\").Clone(); err == nil {\n+\t\tt.Error(`t0.Lookup(\"lhs\").Clone(): got nil err want non-nil`)\n+\t}\n+\n+\t// Execute t3.\n+\tb.Reset()\n+\tif err := t3.ExecuteTemplate(b, \"a\", \"<i>*/\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := b.String(), ` <style> ZgotmplZ </style> `; got != want {\n+\t\tt.Errorf(\"t3: got %q want %q\", got, want)\n \t}\n }"}, {"sha": "539664f9729a0dc6ac982d8e84bfa1e75624fac8", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -85,6 +85,22 @@ func indirect(a interface{}) interface{} {\n \treturn v.Interface()\n }\n \n+var (\n+\terrorType       = reflect.TypeOf((*error)(nil)).Elem()\n+\tfmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\n+)\n+\n+// indirectToStringerOrError returns the value, after dereferencing as many times\n+// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer\n+// or error,\n+func indirectToStringerOrError(a interface{}) interface{} {\n+\tv := reflect.ValueOf(a)\n+\tfor !v.Type().Implements(fmtStringerType) && !v.Type().Implements(errorType) && v.Kind() == reflect.Ptr && !v.IsNil() {\n+\t\tv = v.Elem()\n+\t}\n+\treturn v.Interface()\n+}\n+\n // stringify converts its arguments to a string and the type of the content.\n // All pointers are dereferenced, as in the text/template package.\n func stringify(args ...interface{}) (string, contentType) {\n@@ -107,7 +123,7 @@ func stringify(args ...interface{}) (string, contentType) {\n \t\t}\n \t}\n \tfor i, arg := range args {\n-\t\targs[i] = indirect(arg)\n+\t\targs[i] = indirectToStringerOrError(arg)\n \t}\n \treturn fmt.Sprint(args...), contentTypePlain\n }"}, {"sha": "3c32e5e89cfac3e524e70d5dbcac75f6bf993030", "filename": "libgo/go/html/template/content_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,6 +6,7 @@ package template\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -219,3 +220,42 @@ func TestTypedContent(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Test that we print using the String method. Was issue 3073.\n+type stringer struct {\n+\tv int\n+}\n+\n+func (s *stringer) String() string {\n+\treturn fmt.Sprintf(\"string=%d\", s.v)\n+}\n+\n+type errorer struct {\n+\tv int\n+}\n+\n+func (s *errorer) Error() string {\n+\treturn fmt.Sprintf(\"error=%d\", s.v)\n+}\n+\n+func TestStringer(t *testing.T) {\n+\ts := &stringer{3}\n+\tb := new(bytes.Buffer)\n+\ttmpl := Must(New(\"x\").Parse(\"{{.}}\"))\n+\tif err := tmpl.Execute(b, s); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tvar expect = \"string=3\"\n+\tif b.String() != expect {\n+\t\tt.Errorf(\"expected %q got %q\", expect, b.String())\n+\t}\n+\te := &errorer{7}\n+\tb.Reset()\n+\tif err := tmpl.Execute(b, e); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\texpect = \"error=7\"\n+\tif b.String() != expect {\n+\t\tt.Errorf(\"expected %q got %q\", expect, b.String())\n+\t}\n+}"}, {"sha": "7f60f3b9680fb537f42c3162db4e3dcaf5a0e3b1", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -17,11 +17,11 @@ Introduction\n This package wraps package text/template so you can share its template API\n to parse and execute HTML templates safely.\n \n-  set, err := new(template.Set).Parse(...)\n+  tmpl, err := template.New(\"name\").Parse(...)\n   // Error checking elided\n-  err = set.Execute(out, \"Foo\", data)\n+  err = tmpl.Execute(out, \"Foo\", data)\n \n-If successful, set will now be injection-safe. Otherwise, err is an error\n+If successful, tmpl will now be injection-safe. Otherwise, err is an error\n defined in the docs for ErrorCode.\n \n HTML templates treat data values as plain text which should be encoded so they\n@@ -172,18 +172,18 @@ This package assumes that template authors are trusted, that Execute's data\n parameter is not, and seeks to preserve the properties below in the face\n of untrusted data:\n \n-Structure Preservation Property\n+Structure Preservation Property:\n \"... when a template author writes an HTML tag in a safe templating language,\n the browser will interpret the corresponding portion of the output as a tag\n regardless of the values of untrusted data, and similarly for other structures\n such as attribute boundaries and JS and CSS string boundaries.\"\n \n-Code Effect Property\n+Code Effect Property:\n \"... only code specified by the template author should run as a result of\n injecting the template output into a page and all code specified by the\n template author should run as a result of the same.\"\n \n-Least Surprise Property\n+Least Surprise Property:\n \"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who\n knows that contextual autoescaping happens should be able to look at a {{.}}\n and correctly infer what sanitization happens.\""}, {"sha": "02fa3eaad6bdb3ff447c0670d87ce9056e199d91", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -46,30 +46,30 @@ func escapeTemplates(tmpl *Template, names ...string) error {\n \n // funcMap maps command names to functions that render their inputs safe.\n var funcMap = template.FuncMap{\n-\t\"exp_template_html_attrescaper\":     attrEscaper,\n-\t\"exp_template_html_commentescaper\":  commentEscaper,\n-\t\"exp_template_html_cssescaper\":      cssEscaper,\n-\t\"exp_template_html_cssvaluefilter\":  cssValueFilter,\n-\t\"exp_template_html_htmlnamefilter\":  htmlNameFilter,\n-\t\"exp_template_html_htmlescaper\":     htmlEscaper,\n-\t\"exp_template_html_jsregexpescaper\": jsRegexpEscaper,\n-\t\"exp_template_html_jsstrescaper\":    jsStrEscaper,\n-\t\"exp_template_html_jsvalescaper\":    jsValEscaper,\n-\t\"exp_template_html_nospaceescaper\":  htmlNospaceEscaper,\n-\t\"exp_template_html_rcdataescaper\":   rcdataEscaper,\n-\t\"exp_template_html_urlescaper\":      urlEscaper,\n-\t\"exp_template_html_urlfilter\":       urlFilter,\n-\t\"exp_template_html_urlnormalizer\":   urlNormalizer,\n+\t\"html_template_attrescaper\":     attrEscaper,\n+\t\"html_template_commentescaper\":  commentEscaper,\n+\t\"html_template_cssescaper\":      cssEscaper,\n+\t\"html_template_cssvaluefilter\":  cssValueFilter,\n+\t\"html_template_htmlnamefilter\":  htmlNameFilter,\n+\t\"html_template_htmlescaper\":     htmlEscaper,\n+\t\"html_template_jsregexpescaper\": jsRegexpEscaper,\n+\t\"html_template_jsstrescaper\":    jsStrEscaper,\n+\t\"html_template_jsvalescaper\":    jsValEscaper,\n+\t\"html_template_nospaceescaper\":  htmlNospaceEscaper,\n+\t\"html_template_rcdataescaper\":   rcdataEscaper,\n+\t\"html_template_urlescaper\":      urlEscaper,\n+\t\"html_template_urlfilter\":       urlFilter,\n+\t\"html_template_urlnormalizer\":   urlNormalizer,\n }\n \n // equivEscapers matches contextual escapers to equivalent template builtins.\n var equivEscapers = map[string]string{\n-\t\"exp_template_html_attrescaper\":    \"html\",\n-\t\"exp_template_html_htmlescaper\":    \"html\",\n-\t\"exp_template_html_nospaceescaper\": \"html\",\n-\t\"exp_template_html_rcdataescaper\":  \"html\",\n-\t\"exp_template_html_urlescaper\":     \"urlquery\",\n-\t\"exp_template_html_urlnormalizer\":  \"urlquery\",\n+\t\"html_template_attrescaper\":    \"html\",\n+\t\"html_template_htmlescaper\":    \"html\",\n+\t\"html_template_nospaceescaper\": \"html\",\n+\t\"html_template_rcdataescaper\":  \"html\",\n+\t\"html_template_urlescaper\":     \"urlquery\",\n+\t\"html_template_urlnormalizer\":  \"urlquery\",\n }\n \n // escaper collects type inferences about templates and changes needed to make\n@@ -147,17 +147,17 @@ func (e *escaper) escapeAction(c context, n *parse.ActionNode) context {\n \tcase stateURL, stateCSSDqStr, stateCSSSqStr, stateCSSDqURL, stateCSSSqURL, stateCSSURL:\n \t\tswitch c.urlPart {\n \t\tcase urlPartNone:\n-\t\t\ts = append(s, \"exp_template_html_urlfilter\")\n+\t\t\ts = append(s, \"html_template_urlfilter\")\n \t\t\tfallthrough\n \t\tcase urlPartPreQuery:\n \t\t\tswitch c.state {\n \t\t\tcase stateCSSDqStr, stateCSSSqStr:\n-\t\t\t\ts = append(s, \"exp_template_html_cssescaper\")\n+\t\t\t\ts = append(s, \"html_template_cssescaper\")\n \t\t\tdefault:\n-\t\t\t\ts = append(s, \"exp_template_html_urlnormalizer\")\n+\t\t\t\ts = append(s, \"html_template_urlnormalizer\")\n \t\t\t}\n \t\tcase urlPartQueryOrFrag:\n-\t\t\ts = append(s, \"exp_template_html_urlescaper\")\n+\t\t\ts = append(s, \"html_template_urlescaper\")\n \t\tcase urlPartUnknown:\n \t\t\treturn context{\n \t\t\t\tstate: stateError,\n@@ -167,27 +167,27 @@ func (e *escaper) escapeAction(c context, n *parse.ActionNode) context {\n \t\t\tpanic(c.urlPart.String())\n \t\t}\n \tcase stateJS:\n-\t\ts = append(s, \"exp_template_html_jsvalescaper\")\n+\t\ts = append(s, \"html_template_jsvalescaper\")\n \t\t// A slash after a value starts a div operator.\n \t\tc.jsCtx = jsCtxDivOp\n \tcase stateJSDqStr, stateJSSqStr:\n-\t\ts = append(s, \"exp_template_html_jsstrescaper\")\n+\t\ts = append(s, \"html_template_jsstrescaper\")\n \tcase stateJSRegexp:\n-\t\ts = append(s, \"exp_template_html_jsregexpescaper\")\n+\t\ts = append(s, \"html_template_jsregexpescaper\")\n \tcase stateCSS:\n-\t\ts = append(s, \"exp_template_html_cssvaluefilter\")\n+\t\ts = append(s, \"html_template_cssvaluefilter\")\n \tcase stateText:\n-\t\ts = append(s, \"exp_template_html_htmlescaper\")\n+\t\ts = append(s, \"html_template_htmlescaper\")\n \tcase stateRCDATA:\n-\t\ts = append(s, \"exp_template_html_rcdataescaper\")\n+\t\ts = append(s, \"html_template_rcdataescaper\")\n \tcase stateAttr:\n \t\t// Handled below in delim check.\n \tcase stateAttrName, stateTag:\n \t\tc.state = stateAttrName\n-\t\ts = append(s, \"exp_template_html_htmlnamefilter\")\n+\t\ts = append(s, \"html_template_htmlnamefilter\")\n \tdefault:\n \t\tif isComment(c.state) {\n-\t\t\ts = append(s, \"exp_template_html_commentescaper\")\n+\t\t\ts = append(s, \"html_template_commentescaper\")\n \t\t} else {\n \t\t\tpanic(\"unexpected state \" + c.state.String())\n \t\t}\n@@ -196,9 +196,9 @@ func (e *escaper) escapeAction(c context, n *parse.ActionNode) context {\n \tcase delimNone:\n \t\t// No extra-escaping needed for raw text content.\n \tcase delimSpaceOrTagEnd:\n-\t\ts = append(s, \"exp_template_html_nospaceescaper\")\n+\t\ts = append(s, \"html_template_nospaceescaper\")\n \tdefault:\n-\t\ts = append(s, \"exp_template_html_attrescaper\")\n+\t\ts = append(s, \"html_template_attrescaper\")\n \t}\n \te.editActionNode(n, s)\n \treturn c\n@@ -260,22 +260,22 @@ func ensurePipelineContains(p *parse.PipeNode, s []string) {\n // redundantFuncs[a][b] implies that funcMap[b](funcMap[a](x)) == funcMap[a](x)\n // for all x.\n var redundantFuncs = map[string]map[string]bool{\n-\t\"exp_template_html_commentescaper\": {\n-\t\t\"exp_template_html_attrescaper\":    true,\n-\t\t\"exp_template_html_nospaceescaper\": true,\n-\t\t\"exp_template_html_htmlescaper\":    true,\n+\t\"html_template_commentescaper\": {\n+\t\t\"html_template_attrescaper\":    true,\n+\t\t\"html_template_nospaceescaper\": true,\n+\t\t\"html_template_htmlescaper\":    true,\n \t},\n-\t\"exp_template_html_cssescaper\": {\n-\t\t\"exp_template_html_attrescaper\": true,\n+\t\"html_template_cssescaper\": {\n+\t\t\"html_template_attrescaper\": true,\n \t},\n-\t\"exp_template_html_jsregexpescaper\": {\n-\t\t\"exp_template_html_attrescaper\": true,\n+\t\"html_template_jsregexpescaper\": {\n+\t\t\"html_template_attrescaper\": true,\n \t},\n-\t\"exp_template_html_jsstrescaper\": {\n-\t\t\"exp_template_html_attrescaper\": true,\n+\t\"html_template_jsstrescaper\": {\n+\t\t\"html_template_attrescaper\": true,\n \t},\n-\t\"exp_template_html_urlescaper\": {\n-\t\t\"exp_template_html_urlnormalizer\": true,\n+\t\"html_template_urlescaper\": {\n+\t\t\"html_template_urlnormalizer\": true,\n \t},\n }\n \n@@ -505,7 +505,7 @@ func (e *escaper) escapeTree(c context, name string, line int) (context, string)\n \t\tdt := e.template(dname)\n \t\tif dt == nil {\n \t\t\tdt = template.New(dname)\n-\t\t\tdt.Tree = &parse.Tree{Name: dname, Root: cloneList(t.Root)}\n+\t\t\tdt.Tree = &parse.Tree{Name: dname, Root: t.Root.CopyList()}\n \t\t\te.derived[dname] = dt\n \t\t}\n \t\tt = dt"}, {"sha": "b0bae7a54fb35e4d47e0ced052c7832bbf60f9d2", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -50,7 +50,7 @@ func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n // ExecuteTemplate applies the template associated with t that has the given\n // name to the specified data object and writes the output to wr.\n func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error {\n-\ttmpl, err := t.lookupAndEscapeTemplate(wr, name)\n+\ttmpl, err := t.lookupAndEscapeTemplate(name)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -60,7 +60,7 @@ func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{})\n // lookupAndEscapeTemplate guarantees that the template with the given name\n // is escaped, or returns an error if it cannot be. It returns the named\n // template.\n-func (t *Template) lookupAndEscapeTemplate(wr io.Writer, name string) (tmpl *Template, err error) {\n+func (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err error) {\n \tt.nameSpace.mu.Lock()\n \tdefer t.nameSpace.mu.Unlock()\n \ttmpl = t.set[name]\n@@ -106,14 +106,71 @@ func (t *Template) Parse(src string) (*Template, error) {\n \treturn t, nil\n }\n \n-// AddParseTree is unimplemented.\n-func (t *Template) AddParseTree(name string, tree *parse.Tree) error {\n-\treturn fmt.Errorf(\"html/template: AddParseTree unimplemented\")\n+// AddParseTree creates a new template with the name and parse tree\n+// and associates it with t.\n+//\n+// It returns an error if t has already been executed.\n+func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error) {\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\tif t.escaped {\n+\t\treturn nil, fmt.Errorf(\"html/template: cannot AddParseTree to %q after it has executed\", t.Name())\n+\t}\n+\ttext, err := t.text.AddParseTree(name, tree)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tret := &Template{\n+\t\tfalse,\n+\t\ttext,\n+\t\tt.nameSpace,\n+\t}\n+\tt.set[name] = ret\n+\treturn ret, nil\n }\n \n-// Clone is unimplemented.\n-func (t *Template) Clone(name string) error {\n-\treturn fmt.Errorf(\"html/template: Clone unimplemented\")\n+// Clone returns a duplicate of the template, including all associated\n+// templates. The actual representation is not copied, but the name space of\n+// associated templates is, so further calls to Parse in the copy will add\n+// templates to the copy but not to the original. Clone can be used to prepare\n+// common templates and use them with variant definitions for other templates\n+// by adding the variants after the clone is made.\n+//\n+// It returns an error if t has already been executed.\n+func (t *Template) Clone() (*Template, error) {\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\tif t.escaped {\n+\t\treturn nil, fmt.Errorf(\"html/template: cannot Clone %q after it has executed\", t.Name())\n+\t}\n+\ttextClone, err := t.text.Clone()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tret := &Template{\n+\t\tfalse,\n+\t\ttextClone,\n+\t\t&nameSpace{\n+\t\t\tset: make(map[string]*Template),\n+\t\t},\n+\t}\n+\tfor _, x := range textClone.Templates() {\n+\t\tname := x.Name()\n+\t\tsrc := t.set[name]\n+\t\tif src == nil || src.escaped {\n+\t\t\treturn nil, fmt.Errorf(\"html/template: cannot Clone %q after it has executed\", t.Name())\n+\t\t}\n+\t\tx.Tree = &parse.Tree{\n+\t\t\tName: x.Tree.Name,\n+\t\t\tRoot: x.Tree.Root.CopyList(),\n+\t\t}\n+\t\tret.set[name] = &Template{\n+\t\t\tfalse,\n+\t\t\tx,\n+\t\t\tret.nameSpace,\n+\t\t}\n+\t}\n+\treturn ret, nil\n }\n \n // New allocates a new HTML template with the given name."}, {"sha": "aa5a841c0a59c34d1cd265c6ae5b408603420299", "filename": "libgo/go/image/decode_example_test.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fimage%2Fdecode_example_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fimage%2Fdecode_example_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_example_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This example demonstrates decoding a JPEG image and examining its pixels.\n+package image_test\n+\n+import (\n+\t\"fmt\"\n+\t\"image\"\n+\t\"log\"\n+\t\"os\"\n+\n+\t// Package image/jpeg is not used explicitly in the code below,\n+\t// but is imported for its initialization side-effect, which allows\n+\t// image.Decode to understand JPEG formatted images. Uncomment these\n+\t// two lines to also understand GIF and PNG images:\n+\t// _ \"image/gif\"\n+\t// _ \"image/png\"\n+\t_ \"image/jpeg\"\n+)\n+\n+func Example() {\n+\t// Open the file.\n+\tfile, err := os.Open(\"testdata/video-001.jpeg\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer file.Close()\n+\n+\t// Decode the image.\n+\tm, _, err := image.Decode(file)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tbounds := m.Bounds()\n+\n+\t// Calculate a 16-bin histogram for m's red, green, blue and alpha components.\n+\t//\n+\t// An image's bounds do not necessarily start at (0, 0), so the two loops start\n+\t// at bounds.Min.Y and bounds.Min.X. Looping over Y first and X second is more\n+\t// likely to result in better memory access patterns than X first and Y second.\n+\tvar histogram [16][4]int\n+\tfor y := bounds.Min.Y; y < bounds.Max.Y; y++ {\n+\t\tfor x := bounds.Min.X; x < bounds.Max.X; x++ {\n+\t\t\tr, g, b, a := m.At(x, y).RGBA()\n+\t\t\t// A color's RGBA method returns values in the range [0, 65535].\n+\t\t\t// Shifting by 12 reduces this to the range [0, 15].\n+\t\t\thistogram[r>>12][0]++\n+\t\t\thistogram[g>>12][1]++\n+\t\t\thistogram[b>>12][2]++\n+\t\t\thistogram[a>>12][3]++\n+\t\t}\n+\t}\n+\n+\t// Print the results.\n+\tfmt.Printf(\"%-14s %6s %6s %6s %6s\\n\", \"bin\", \"red\", \"green\", \"blue\", \"alpha\")\n+\tfor i, x := range histogram {\n+\t\tfmt.Printf(\"0x%04x-0x%04x: %6d %6d %6d %6d\\n\", i<<12, (i+1)<<12-1, x[0], x[1], x[2], x[3])\n+\t}\n+\t// Output:\n+\t// bin               red  green   blue  alpha\n+\t// 0x0000-0x0fff:    471    819   7596      0\n+\t// 0x1000-0x1fff:    576   2892    726      0\n+\t// 0x2000-0x2fff:   1038   2330    943      0\n+\t// 0x3000-0x3fff:    883   2321   1014      0\n+\t// 0x4000-0x4fff:    501   1295    525      0\n+\t// 0x5000-0x5fff:    302    962    242      0\n+\t// 0x6000-0x6fff:    219    358    150      0\n+\t// 0x7000-0x7fff:    352    281    192      0\n+\t// 0x8000-0x8fff:   3688    216    246      0\n+\t// 0x9000-0x9fff:   2277    237    283      0\n+\t// 0xa000-0xafff:    971    254    357      0\n+\t// 0xb000-0xbfff:    317    306    429      0\n+\t// 0xc000-0xcfff:    203    402    401      0\n+\t// 0xd000-0xdfff:    256    394    241      0\n+\t// 0xe000-0xefff:    378    343    173      0\n+\t// 0xf000-0xffff:   3018   2040   1932  15450\n+}"}, {"sha": "b2373f79ba3aeaa52cf339ea15f58ff291d9b5af", "filename": "libgo/go/image/ycbcr_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -50,6 +50,9 @@ func TestYCbCr(t *testing.T) {\n \t\t\t\ttestYCbCr(t, r, subsampleRatio, delta)\n \t\t\t}\n \t\t}\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "42d2e6758698186a0724f262199b4de5d3d2925f", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -49,7 +49,7 @@ func TempFile(dir, prefix string) (f *os.File, err error) {\n \tfor i := 0; i < 10000; i++ {\n \t\tname := filepath.Join(dir, prefix+nextSuffix())\n \t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n-\t\tif pe, ok := err.(*os.PathError); ok && pe.Err == os.EEXIST {\n+\t\tif os.IsExist(err) {\n \t\t\tif nconflict++; nconflict > 10 {\n \t\t\t\trand = reseed()\n \t\t\t}\n@@ -76,7 +76,7 @@ func TempDir(dir, prefix string) (name string, err error) {\n \tfor i := 0; i < 10000; i++ {\n \t\ttry := filepath.Join(dir, prefix+nextSuffix())\n \t\terr = os.Mkdir(try, 0700)\n-\t\tif pe, ok := err.(*os.PathError); ok && pe.Err == os.EEXIST {\n+\t\tif os.IsExist(err) {\n \t\t\tif nconflict++; nconflict > 10 {\n \t\t\t\trand = reseed()\n \t\t\t}"}, {"sha": "f53310cb0a1fd63c03958026ff10a50e5e1bc668", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !windows,!plan9\n+\n // Package syslog provides a simple interface to the system log service. It\n // can send messages to the syslog daemon using UNIX domain sockets, UDP, or\n // TCP connections."}, {"sha": "0fd6239059a3d0645eaf0376007ddc09612a8125", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,6 +1,9 @@\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n+\n+// +build !windows,!plan9\n+\n package syslog\n \n import ("}, {"sha": "46a164dd5773b07b4cb53c7a9d325a8f78966e63", "filename": "libgo/go/log/syslog/syslog_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !windows,!plan9\n+\n package syslog\n \n import ("}, {"sha": "7f3f76dc36f6ce97bbe98fde928a9edf17d59188", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -512,6 +512,9 @@ func TestStringPowers(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed at %d ** %d in base %d: %s != %s\", b, p, b, xs, xs2)\n \t\t\t}\n \t\t}\n+\t\tif b >= 3 && testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "94f84a85fbe14a0f2e1f8d62a6ca1d3fc546dc93", "filename": "libgo/go/math/rand/rand.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -49,9 +49,10 @@ func (r *Rand) Int() int {\n }\n \n // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func (r *Rand) Int63n(n int64) int64 {\n \tif n <= 0 {\n-\t\treturn 0\n+\t\tpanic(\"invalid argument to Int63n\")\n \t}\n \tmax := int64((1 << 63) - 1 - (1<<63)%uint64(n))\n \tv := r.Int63()\n@@ -62,9 +63,10 @@ func (r *Rand) Int63n(n int64) int64 {\n }\n \n // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func (r *Rand) Int31n(n int32) int32 {\n \tif n <= 0 {\n-\t\treturn 0\n+\t\tpanic(\"invalid argument to Int31n\")\n \t}\n \tmax := int32((1 << 31) - 1 - (1<<31)%uint32(n))\n \tv := r.Int31()\n@@ -75,7 +77,11 @@ func (r *Rand) Int31n(n int32) int32 {\n }\n \n // Intn returns, as an int, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func (r *Rand) Intn(n int) int {\n+\tif n <= 0 {\n+\t\tpanic(\"invalid argument to Intn\")\n+\t}\n \tif n <= 1<<31-1 {\n \t\treturn int(r.Int31n(int32(n)))\n \t}\n@@ -125,12 +131,15 @@ func Int31() int32 { return globalRand.Int31() }\n func Int() int { return globalRand.Int() }\n \n // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func Int63n(n int64) int64 { return globalRand.Int63n(n) }\n \n // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func Int31n(n int32) int32 { return globalRand.Int31n(n) }\n \n // Intn returns, as an int, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n func Intn(n int) int { return globalRand.Intn(n) }\n \n // Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)."}, {"sha": "bbd44e3f8b10657bdb8e6e4a54f009e14ada5901", "filename": "libgo/go/math/rand/rand_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -141,6 +141,9 @@ func TestNonStandardNormalValues(t *testing.T) {\n \t\tfor m := 0.5; m < mmax; m *= 2 {\n \t\t\tfor _, seed := range testSeeds {\n \t\t\t\ttestNormalDistribution(t, numTestSamples, m, sd, seed)\n+\t\t\t\tif testing.Short() {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -191,6 +194,9 @@ func TestNonStandardExponentialValues(t *testing.T) {\n \tfor rate := 0.05; rate < 10; rate *= 2 {\n \t\tfor _, seed := range testSeeds {\n \t\t\ttestExponentialDistribution(t, numTestSamples, rate, seed)\n+\t\t\tif testing.Short() {\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "14356da4ce368fe1d0e5f654e05e5a0c43b0cbf0", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -14,7 +14,7 @@ import (\n )\n \n // If an IPv6 tunnel is running, we can try dialing a real IPv6 address.\n-var ipv6 = flag.Bool(\"ipv6\", false, \"assume ipv6 tunnel is present\")\n+var testIPv6 = flag.Bool(\"ipv6\", false, \"assume ipv6 tunnel is present\")\n \n // fd is already connected to the destination, port 80.\n // Run an HTTP request to fetch the appropriate page.\n@@ -130,7 +130,7 @@ func TestDialGoogleIPv6(t *testing.T) {\n \t\treturn\n \t}\n \t// Only run tcp6 if the kernel will take it.\n-\tif !*ipv6 || !supportsIPv6 {\n+\tif !*testIPv6 || !supportsIPv6 {\n \t\treturn\n \t}\n "}, {"sha": "ae1bf2614a28b6f358f4a49049e265b952bded09", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -252,7 +252,9 @@ func (s *pollServer) Run() {\n \t\t} else {\n \t\t\tnetfd := s.LookupFD(fd, mode)\n \t\t\tif netfd == nil {\n-\t\t\t\tprint(\"pollServer: unexpected wakeup for fd=\", fd, \" mode=\", string(mode), \"\\n\")\n+\t\t\t\t// This can happen because the WaitFD runs without\n+\t\t\t\t// holding s's lock, so there might be a pending wakeup\n+\t\t\t\t// for an fd that has been evicted.  No harm done.\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\ts.WakeFD(netfd, mode, nil)\n@@ -506,7 +508,7 @@ func (fd *netFD) Write(p []byte) (int, error) {\n \t}\n \tdefer fd.decref()\n \tif fd.sysfile == nil {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \n \tvar err error"}, {"sha": "45f5c2d882f136dd3a48ba50836c6b7c4aeb008c", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -335,7 +335,7 @@ func (fd *netFD) Close() error {\n \n func (fd *netFD) shutdown(how int) error {\n \tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := syscall.Shutdown(fd.sysfd, how)\n \tif err != nil {\n@@ -369,7 +369,7 @@ func (o *readOp) Name() string {\n \n func (fd *netFD) Read(buf []byte) (int, error) {\n \tif fd == nil {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n@@ -378,7 +378,7 @@ func (fd *netFD) Read(buf []byte) (int, error) {\n \t}\n \tdefer fd.decref()\n \tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tvar o readOp\n \to.Init(fd, buf, 'r')\n@@ -408,7 +408,7 @@ func (o *readFromOp) Name() string {\n \n func (fd *netFD) ReadFrom(buf []byte) (n int, sa syscall.Sockaddr, err error) {\n \tif fd == nil {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tif len(buf) == 0 {\n \t\treturn 0, nil, nil\n@@ -447,7 +447,7 @@ func (o *writeOp) Name() string {\n \n func (fd *netFD) Write(buf []byte) (int, error) {\n \tif fd == nil {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n@@ -478,7 +478,7 @@ func (o *writeToOp) Name() string {\n \n func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \tif fd == nil {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif len(buf) == 0 {\n \t\treturn 0, nil\n@@ -490,7 +490,7 @@ func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \t}\n \tdefer fd.decref()\n \tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tvar o writeToOp\n \to.Init(fd, buf, 'w')\n@@ -578,10 +578,12 @@ func (fd *netFD) dup() (*os.File, error) {\n \treturn nil, os.NewSyscallError(\"dup\", syscall.EWINDOWS)\n }\n \n+var errNoSupport = errors.New(\"address family not supported\")\n+\n func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.Sockaddr, err error) {\n-\treturn 0, 0, 0, nil, os.EAFNOSUPPORT\n+\treturn 0, 0, 0, nil, errNoSupport\n }\n \n func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error) {\n-\treturn 0, 0, os.EAFNOSUPPORT\n+\treturn 0, 0, errNoSupport\n }"}, {"sha": "c95d16d64e796325db1cad4fa62daf623f95e6b5", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -28,7 +28,7 @@ func newFileFD(f *os.File) (*netFD, error) {\n \tswitch sa.(type) {\n \tdefault:\n \t\tclosesocket(fd)\n-\t\treturn nil, os.EINVAL\n+\t\treturn nil, syscall.EINVAL\n \tcase *syscall.SockaddrInet4:\n \t\tfamily = syscall.AF_INET\n \t\tif proto == syscall.SOCK_DGRAM {\n@@ -84,7 +84,7 @@ func FileConn(f *os.File) (c Conn, err error) {\n \t\treturn newIPConn(fd), nil\n \t}\n \tfd.Close()\n-\treturn nil, os.EINVAL\n+\treturn nil, syscall.EINVAL\n }\n \n // FileListener returns a copy of the network listener corresponding\n@@ -103,7 +103,7 @@ func FileListener(f *os.File) (l Listener, err error) {\n \t\treturn &UnixListener{fd, laddr.Name}, nil\n \t}\n \tfd.Close()\n-\treturn nil, os.EINVAL\n+\treturn nil, syscall.EINVAL\n }\n \n // FilePacketConn returns a copy of the packet network connection\n@@ -122,5 +122,5 @@ func FilePacketConn(f *os.File) (c PacketConn, err error) {\n \t\treturn newUnixConn(fd), nil\n \t}\n \tfd.Close()\n-\treturn nil, os.EINVAL\n+\treturn nil, syscall.EINVAL\n }"}, {"sha": "04f7ee0401b7f86a7fe0e6b71b00705aa00dffea", "filename": "libgo/go/net/file_plan9.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,28 +6,29 @@ package net\n \n import (\n \t\"os\"\n+\t\"syscall\"\n )\n \n // FileConn returns a copy of the network connection corresponding to\n // the open file f.  It is the caller's responsibility to close f when\n // finished.  Closing c does not affect f, and closing f does not\n // affect c.\n func FileConn(f *os.File) (c Conn, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // FileListener returns a copy of the network listener corresponding\n // to the open file f.  It is the caller's responsibility to close l\n // when finished.  Closing c does not affect l, and closing l does not\n // affect c.\n func FileListener(f *os.File) (l Listener, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // FilePacketConn returns a copy of the packet network connection\n // corresponding to the open file f.  It is the caller's\n // responsibility to close f when finished.  Closing c does not affect\n // f, and closing f does not affect c.\n func FilePacketConn(f *os.File) (c PacketConn, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }"}, {"sha": "064e7e432827f0c5c0c80ca9ed54cf736acc8c02", "filename": "libgo/go/net/hosts_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhosts_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhosts_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -34,7 +34,7 @@ var hosttests = []hostTest{\n \n func TestLookupStaticHost(t *testing.T) {\n \tp := hostsPath\n-\thostsPath = \"hosts_testdata\"\n+\thostsPath = \"testdata/hosts\"\n \tfor i := 0; i < len(hosttests); i++ {\n \t\ttt := hosttests[i]\n \t\tips := lookupStaticHost(tt.host)"}, {"sha": "1e9186a0581443dbca3080209a16ebfce177c4a3", "filename": "libgo/go/net/http/cookie_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -128,6 +128,34 @@ var readSetCookiesTests = []struct {\n \t\t\tRaw:        \"NID=99=YsDT5i3E-CXax-; expires=Wed, 23-Nov-2011 01:05:03 GMT; path=/; domain=.google.ch; HttpOnly\",\n \t\t}},\n \t},\n+\t{\n+\t\tHeader{\"Set-Cookie\": {\".ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly\"}},\n+\t\t[]*Cookie{{\n+\t\t\tName:       \".ASPXAUTH\",\n+\t\t\tValue:      \"7E3AA\",\n+\t\t\tPath:       \"/\",\n+\t\t\tExpires:    time.Date(2012, 3, 7, 14, 25, 6, 0, time.UTC),\n+\t\t\tRawExpires: \"Wed, 07-Mar-2012 14:25:06 GMT\",\n+\t\t\tHttpOnly:   true,\n+\t\t\tRaw:        \".ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly\",\n+\t\t}},\n+\t},\n+\t{\n+\t\tHeader{\"Set-Cookie\": {\"ASP.NET_SessionId=foo; path=/; HttpOnly\"}},\n+\t\t[]*Cookie{{\n+\t\t\tName:     \"ASP.NET_SessionId\",\n+\t\t\tValue:    \"foo\",\n+\t\t\tPath:     \"/\",\n+\t\t\tHttpOnly: true,\n+\t\t\tRaw:      \"ASP.NET_SessionId=foo; path=/; HttpOnly\",\n+\t\t}},\n+\t},\n+\n+\t// TODO(bradfitz): users have reported seeing this in the\n+\t// wild, but do browsers handle it? RFC 6265 just says \"don't\n+\t// do that\" (section 3) and then never mentions header folding\n+\t// again.\n+\t// Header{\"Set-Cookie\": {\"ASP.NET_SessionId=foo; path=/; HttpOnly, .ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly\"}},\n }\n \n func toJSON(v interface{}) string {"}, {"sha": "2584afc439ef160c7b3f70213da66fa7c1d1c7d8", "filename": "libgo/go/net/http/example_test.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http_test\n+\n+import (\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"net/http\"\n+)\n+\n+func ExampleHijacker() {\n+\thttp.HandleFunc(\"/hijack\", func(w http.ResponseWriter, r *http.Request) {\n+\t\thj, ok := w.(http.Hijacker)\n+\t\tif !ok {\n+\t\t\thttp.Error(w, \"webserver doesn't support hijacking\", http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tconn, bufrw, err := hj.Hijack()\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\t// Don't forget to close the connection:\n+\t\tdefer conn.Close()\n+\t\tbufrw.WriteString(\"Now we're speaking raw TCP. Say hi: \")\n+\t\tbufrw.Flush()\n+\t\ts, err := bufrw.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"error reading string: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Fprintf(bufrw, \"You said: %q\\nBye.\\n\", s)\n+\t\tbufrw.Flush()\n+\t})\n+}\n+\n+func ExampleGet() {\n+\tres, err := http.Get(\"http://www.google.com/robots.txt\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\trobots, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tres.Body.Close()\n+\tfmt.Printf(\"%s\", robots)\n+}"}, {"sha": "0409008b6755bb0aaa97121a4f4424075d346488", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,6 +6,7 @@ package http_test\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -131,7 +132,7 @@ func TestFileServerCleans(t *testing.T) {\n \tch := make(chan string, 1)\n \tfs := FileServer(&testFileSystem{func(name string) (File, error) {\n \t\tch <- name\n-\t\treturn nil, os.ENOENT\n+\t\treturn nil, errors.New(\"file does not exist\")\n \t}})\n \ttests := []struct {\n \t\treqPath, openArg string\n@@ -398,11 +399,15 @@ func TestLinuxSendfile(t *testing.T) {\n \t\treturn\n \t}\n \n-\t_, err = Get(fmt.Sprintf(\"http://%s/\", ln.Addr()))\n+\tres, err := Get(fmt.Sprintf(\"http://%s/\", ln.Addr()))\n \tif err != nil {\n-\t\tt.Errorf(\"http client error: %v\", err)\n-\t\treturn\n+\t\tt.Fatalf(\"http client error: %v\", err)\n+\t}\n+\t_, err = io.Copy(ioutil.Discard, res.Body)\n+\tif err != nil {\n+\t\tt.Fatalf(\"client body read error: %v\", err)\n \t}\n+\tres.Body.Close()\n \n \t// Force child to exit cleanly.\n \tGet(fmt.Sprintf(\"http://%s/quit\", ln.Addr()))"}, {"sha": "32f4662cc0e7f18f2b1a0301a8e4956a05d78bfa", "filename": "libgo/go/net/http/httputil/persist.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -13,12 +13,12 @@ import (\n \t\"net\"\n \t\"net/http\"\n \t\"net/textproto\"\n-\t\"os\"\n \t\"sync\"\n )\n \n var (\n \tErrPersistEOF = &http.ProtocolError{ErrorString: \"persistent connection closed\"}\n+\tErrClosed     = &http.ProtocolError{ErrorString: \"connection closed by user\"}\n \tErrPipeline   = &http.ProtocolError{ErrorString: \"pipeline error\"}\n )\n \n@@ -191,7 +191,7 @@ func (sc *ServerConn) Write(req *http.Request, resp *http.Response) error {\n \t}\n \tif sc.c == nil { // connection closed by user in the meantime\n \t\tdefer sc.lk.Unlock()\n-\t\treturn os.EBADF\n+\t\treturn ErrClosed\n \t}\n \tc := sc.c\n \tif sc.nread <= sc.nwritten {"}, {"sha": "06fcde1447fb6148bfa6a4b8c8ab323d89bb668f", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -22,9 +22,9 @@\n //\n //\tgo tool pprof http://localhost:6060/debug/pprof/profile\n //\n-// Or to look at the thread creation profile:\n+// Or to view all available profiles:\n //\n-//\tgo tool pprof http://localhost:6060/debug/pprof/thread\n+//\tgo tool pprof http://localhost:6060/debug/pprof/\n //\n // For a study of the facility in action, visit\n //\n@@ -36,7 +36,9 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n+\t\"html/template\"\n \t\"io\"\n+\t\"log\"\n \t\"net/http\"\n \t\"os\"\n \t\"runtime\"\n@@ -47,11 +49,10 @@ import (\n )\n \n func init() {\n+\thttp.Handle(\"/debug/pprof/\", http.HandlerFunc(Index))\n \thttp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(Cmdline))\n \thttp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(Profile))\n-\thttp.Handle(\"/debug/pprof/heap\", http.HandlerFunc(Heap))\n \thttp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(Symbol))\n-\thttp.Handle(\"/debug/pprof/thread\", http.HandlerFunc(Thread))\n }\n \n // Cmdline responds with the running program's\n@@ -62,20 +63,6 @@ func Cmdline(w http.ResponseWriter, r *http.Request) {\n \tfmt.Fprintf(w, strings.Join(os.Args, \"\\x00\"))\n }\n \n-// Heap responds with the pprof-formatted heap profile.\n-// The package initialization registers it as /debug/pprof/heap.\n-func Heap(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\tpprof.WriteHeapProfile(w)\n-}\n-\n-// Thread responds with the pprof-formatted thread creation profile.\n-// The package initialization registers it as /debug/pprof/thread.\n-func Thread(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\tpprof.WriteThreadProfile(w)\n-}\n-\n // Profile responds with the pprof-formatted cpu profile.\n // The package initialization registers it as /debug/pprof/profile.\n func Profile(w http.ResponseWriter, r *http.Request) {\n@@ -147,3 +134,61 @@ func Symbol(w http.ResponseWriter, r *http.Request) {\n \n \tw.Write(buf.Bytes())\n }\n+\n+// Handler returns an HTTP handler that serves the named profile.\n+func Handler(name string) http.Handler {\n+\treturn handler(name)\n+}\n+\n+type handler string\n+\n+func (name handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\tdebug, _ := strconv.Atoi(r.FormValue(\"debug\"))\n+\tp := pprof.Lookup(string(name))\n+\tif p == nil {\n+\t\tw.WriteHeader(404)\n+\t\tfmt.Fprintf(w, \"Unknown profile: %s\\n\", name)\n+\t\treturn\n+\t}\n+\tp.WriteTo(w, debug)\n+\treturn\n+}\n+\n+// Index responds with the pprof-formatted profile named by the request.\n+// For example, \"/debug/pprof/heap\" serves the \"heap\" profile.\n+// Index responds to a request for \"/debug/pprof/\" with an HTML page\n+// listing the available profiles.\n+func Index(w http.ResponseWriter, r *http.Request) {\n+\tif strings.HasPrefix(r.URL.Path, \"/debug/pprof/\") {\n+\t\tname := r.URL.Path[len(\"/debug/pprof/\"):]\n+\t\tif name != \"\" {\n+\t\t\thandler(name).ServeHTTP(w, r)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tprofiles := pprof.Profiles()\n+\tif err := indexTmpl.Execute(w, profiles); err != nil {\n+\t\tlog.Print(err)\n+\t}\n+}\n+\n+var indexTmpl = template.Must(template.New(\"index\").Parse(`<html>\n+<head>\n+<title>/debug/pprof/</title>\n+</head>\n+/debug/pprof/<br>\n+<br>\n+<body>\n+profiles:<br>\n+<table>\n+{{range .}}\n+<tr><td align=right>{{.Count}}<td><a href=\"/debug/pprof/{{.Name}}?debug=1\">{{.Name}}</a>\n+{{end}}\n+</table>\n+<br>\n+<a href=\"/debug/pprof/goroutine?debug=2\">full goroutine stack dump</a><br>\n+</body>\n+</html>\n+`))"}, {"sha": "5277657805d1df6615f76a2511b31ac0166a28e6", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -186,7 +186,7 @@ func (r *Request) Cookies() []*Cookie {\n \treturn readCookies(r.Header, \"\")\n }\n \n-var ErrNoCookie = errors.New(\"http: named cookied not present\")\n+var ErrNoCookie = errors.New(\"http: named cookie not present\")\n \n // Cookie returns the named cookie provided in the request or\n // ErrNoCookie if not found.\n@@ -486,7 +486,7 @@ func ReadRequest(b *bufio.Reader) (req *Request, err error) {\n \t\trawurl = \"http://\" + rawurl\n \t}\n \n-\tif req.URL, err = url.ParseRequest(rawurl); err != nil {\n+\tif req.URL, err = url.ParseRequestURI(rawurl); err != nil {\n \t\treturn nil, err\n \t}\n "}, {"sha": "b6a6b4c77d159eac5361e5eff6ad80c8950f31e0", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -245,8 +245,7 @@ func TestServerTimeouts(t *testing.T) {\n \t\tfmt.Fprintf(res, \"req=%d\", reqNum)\n \t})\n \n-\tconst second = 1000000000 /* nanos */\n-\tserver := &Server{Handler: handler, ReadTimeout: 0.25 * second, WriteTimeout: 0.25 * second}\n+\tserver := &Server{Handler: handler, ReadTimeout: 250 * time.Millisecond, WriteTimeout: 250 * time.Millisecond}\n \tgo server.Serve(l)\n \n \turl := fmt.Sprintf(\"http://%s/\", addr)\n@@ -277,7 +276,7 @@ func TestServerTimeouts(t *testing.T) {\n \tif n != 0 || err != io.EOF {\n \t\tt.Errorf(\"Read = %v, %v, wanted %v, %v\", n, err, 0, io.EOF)\n \t}\n-\tif latency < 200*time.Millisecond /* fudge from 0.25 above */ {\n+\tif latency < 200*time.Millisecond /* fudge from 250 ms above */ {\n \t\tt.Errorf(\"got EOF after %s, want >= %s\", latency, 200*time.Millisecond)\n \t}\n "}, {"sha": "fa0df54a236c2dfef8b9ddc99638e1e1b8fcac30", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -12,7 +12,6 @@ package http\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t\"crypto/rand\"\n \t\"crypto/tls\"\n \t\"errors\"\n \t\"fmt\"\n@@ -985,6 +984,7 @@ type Server struct {\n \tReadTimeout    time.Duration // maximum duration before timing out read of the request\n \tWriteTimeout   time.Duration // maximum duration before timing out write of the response\n \tMaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0\n+\tTLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS\n }\n \n // ListenAndServe listens on the TCP network address srv.Addr and then\n@@ -1121,9 +1121,12 @@ func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \tif addr == \"\" {\n \t\taddr = \":https\"\n \t}\n-\tconfig := &tls.Config{\n-\t\tRand:       rand.Reader,\n-\t\tNextProtos: []string{\"http/1.1\"},\n+\tconfig := &tls.Config{}\n+\tif srv.TLSConfig != nil {\n+\t\t*config = *srv.TLSConfig\n+\t}\n+\tif config.NextProtos == nil {\n+\t\tconfig.NextProtos = []string{\"http/1.1\"}\n \t}\n \n \tvar err error"}, {"sha": "1a629c1727c5282bb888c2eee998caf2ac20d1e2", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -648,7 +648,7 @@ func TestTransportPersistConnLeak(t *testing.T) {\n \ttr := &Transport{}\n \tc := &Client{Transport: tr}\n \n-\tn0 := runtime.Goroutines()\n+\tn0 := runtime.NumGoroutine()\n \n \tconst numReq = 25\n \tdidReqCh := make(chan bool)\n@@ -669,7 +669,7 @@ func TestTransportPersistConnLeak(t *testing.T) {\n \t\t<-gotReqCh\n \t}\n \n-\tnhigh := runtime.Goroutines()\n+\tnhigh := runtime.NumGoroutine()\n \n \t// Tell all handlers to unblock and reply.\n \tfor i := 0; i < numReq; i++ {\n@@ -685,7 +685,7 @@ func TestTransportPersistConnLeak(t *testing.T) {\n \ttime.Sleep(100 * time.Millisecond)\n \truntime.GC()\n \truntime.GC() // even more.\n-\tnfinal := runtime.Goroutines()\n+\tnfinal := runtime.NumGoroutine()\n \n \tgrowth := nfinal - n0\n "}, {"sha": "15c2f3781b1d8ef1a9dbadd4c3ef4873b6fc6fca", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -166,13 +166,13 @@ func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \t\t\treturn nil, err\n \t\t}\n \t}\n-\tifmat4 := parseProcNetIGMP(ifi)\n-\tifmat6 := parseProcNetIGMP6(ifi)\n+\tifmat4 := parseProcNetIGMP(\"/proc/net/igmp\", ifi)\n+\tifmat6 := parseProcNetIGMP6(\"/proc/net/igmp6\", ifi)\n \treturn append(ifmat4, ifmat6...), nil\n }\n \n-func parseProcNetIGMP(ifi *Interface) []Addr {\n-\tfd, err := open(\"/proc/net/igmp\")\n+func parseProcNetIGMP(path string, ifi *Interface) []Addr {\n+\tfd, err := open(path)\n \tif err != nil {\n \t\treturn nil\n \t}\n@@ -185,23 +185,26 @@ func parseProcNetIGMP(ifi *Interface) []Addr {\n \tfd.readLine() // skip first line\n \tb := make([]byte, IPv4len)\n \tfor l, ok := fd.readLine(); ok; l, ok = fd.readLine() {\n-\t\tf := getFields(l)\n-\t\tswitch len(f) {\n-\t\tcase 4:\n+\t\tf := splitAtBytes(l, \" :\\r\\t\\n\")\n+\t\tif len(f) < 4 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch {\n+\t\tcase l[0] != ' ' && l[0] != '\\t': // new interface line\n+\t\t\tname = f[1]\n+\t\tcase len(f[0]) == 8:\n \t\t\tif ifi == nil || name == ifi.Name {\n \t\t\t\tfmt.Sscanf(f[0], \"%08x\", &b)\n \t\t\t\tifma := IPAddr{IP: IPv4(b[3], b[2], b[1], b[0])}\n \t\t\t\tifmat = append(ifmat, ifma.toAddr())\n \t\t\t}\n-\t\tcase 5:\n-\t\t\tname = f[1]\n \t\t}\n \t}\n \treturn ifmat\n }\n \n-func parseProcNetIGMP6(ifi *Interface) []Addr {\n-\tfd, err := open(\"/proc/net/igmp6\")\n+func parseProcNetIGMP6(path string, ifi *Interface) []Addr {\n+\tfd, err := open(path)\n \tif err != nil {\n \t\treturn nil\n \t}\n@@ -210,7 +213,10 @@ func parseProcNetIGMP6(ifi *Interface) []Addr {\n \tvar ifmat []Addr\n \tb := make([]byte, IPv6len)\n \tfor l, ok := fd.readLine(); ok; l, ok = fd.readLine() {\n-\t\tf := getFields(l)\n+\t\tf := splitAtBytes(l, \" \\r\\t\\n\")\n+\t\tif len(f) < 6 {\n+\t\t\tcontinue\n+\t\t}\n \t\tif ifi == nil || f[1] == ifi.Name {\n \t\t\tfmt.Sscanf(f[2], \"%32x\", &b)\n \t\t\tifma := IPAddr{IP: IP{b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15]}}"}, {"sha": "769414e0eef8c78ff0be6ee9ced7095d138240a8", "filename": "libgo/go/net/interface_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Finterface_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Finterface_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -31,17 +31,17 @@ func TestInterfaces(t *testing.T) {\n \tfor _, ifi := range ift {\n \t\tifxi, err := InterfaceByIndex(ifi.Index)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"InterfaceByIndex(%#q) failed: %v\", ifi.Index, err)\n+\t\t\tt.Fatalf(\"InterfaceByIndex(%q) failed: %v\", ifi.Index, err)\n \t\t}\n \t\tif !sameInterface(ifxi, &ifi) {\n-\t\t\tt.Fatalf(\"InterfaceByIndex(%#q) = %v, want %v\", ifi.Index, *ifxi, ifi)\n+\t\t\tt.Fatalf(\"InterfaceByIndex(%q) = %v, want %v\", ifi.Index, *ifxi, ifi)\n \t\t}\n \t\tifxn, err := InterfaceByName(ifi.Name)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"InterfaceByName(%#q) failed: %v\", ifi.Name, err)\n+\t\t\tt.Fatalf(\"InterfaceByName(%q) failed: %v\", ifi.Name, err)\n \t\t}\n \t\tif !sameInterface(ifxn, &ifi) {\n-\t\t\tt.Fatalf(\"InterfaceByName(%#q) = %v, want %v\", ifi.Name, *ifxn, ifi)\n+\t\t\tt.Fatalf(\"InterfaceByName(%q) = %v, want %v\", ifi.Name, *ifxn, ifi)\n \t\t}\n \t\tt.Logf(\"%q: flags %q, ifindex %v, mtu %v\\n\", ifi.Name, ifi.Flags.String(), ifi.Index, ifi.MTU)\n \t\tt.Logf(\"\\thardware address %q\", ifi.HardwareAddr.String())"}, {"sha": "6136202727cfc70a4e5e4d1eea79564f1b670c1c", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,6 +7,7 @@ package net\n import (\n \t\"bytes\"\n \t\"os\"\n+\t\"syscall\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -15,7 +16,7 @@ var icmpTests = []struct {\n \tnet   string\n \tladdr string\n \traddr string\n-\tipv6  bool\n+\tipv6  bool // test with underlying AF_INET6 socket\n }{\n \t{\"ip4:icmp\", \"\", \"127.0.0.1\", false},\n \t{\"ip6:icmp\", \"\", \"::1\", true},\n@@ -34,28 +35,28 @@ func TestICMP(t *testing.T) {\n \t\t}\n \t\tid := os.Getpid() & 0xffff\n \t\tseqnum++\n-\t\techo := newICMPEchoRequest(tt.ipv6, id, seqnum, 128, []byte(\"Go Go Gadget Ping!!!\"))\n-\t\texchangeICMPEcho(t, tt.net, tt.laddr, tt.raddr, tt.ipv6, echo)\n+\t\techo := newICMPEchoRequest(tt.net, id, seqnum, 128, []byte(\"Go Go Gadget Ping!!!\"))\n+\t\texchangeICMPEcho(t, tt.net, tt.laddr, tt.raddr, echo)\n \t}\n }\n \n-func exchangeICMPEcho(t *testing.T, net, laddr, raddr string, ipv6 bool, echo []byte) {\n+func exchangeICMPEcho(t *testing.T, net, laddr, raddr string, echo []byte) {\n \tc, err := ListenPacket(net, laddr)\n \tif err != nil {\n-\t\tt.Errorf(\"ListenPacket(%#q, %#q) failed: %v\", net, laddr, err)\n+\t\tt.Errorf(\"ListenPacket(%q, %q) failed: %v\", net, laddr, err)\n \t\treturn\n \t}\n \tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n \tdefer c.Close()\n \n \tra, err := ResolveIPAddr(net, raddr)\n \tif err != nil {\n-\t\tt.Errorf(\"ResolveIPAddr(%#q, %#q) failed: %v\", net, raddr, err)\n+\t\tt.Errorf(\"ResolveIPAddr(%q, %q) failed: %v\", net, raddr, err)\n \t\treturn\n \t}\n \n \twaitForReady := make(chan bool)\n-\tgo icmpEchoTransponder(t, net, raddr, ipv6, waitForReady)\n+\tgo icmpEchoTransponder(t, net, raddr, waitForReady)\n \t<-waitForReady\n \n \t_, err = c.WriteTo(echo, ra)\n@@ -71,11 +72,15 @@ func exchangeICMPEcho(t *testing.T, net, laddr, raddr string, ipv6 bool, echo []\n \t\t\tt.Errorf(\"ReadFrom failed: %v\", err)\n \t\t\treturn\n \t\t}\n-\t\tif !ipv6 && reply[0] != ICMP4_ECHO_REPLY {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif ipv6 && reply[0] != ICMP6_ECHO_REPLY {\n-\t\t\tcontinue\n+\t\tswitch c.(*IPConn).fd.family {\n+\t\tcase syscall.AF_INET:\n+\t\t\tif reply[0] != ICMP4_ECHO_REPLY {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tcase syscall.AF_INET6:\n+\t\t\tif reply[0] != ICMP6_ECHO_REPLY {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n \t\txid, xseqnum := parseICMPEchoReply(echo)\n \t\trid, rseqnum := parseICMPEchoReply(reply)\n@@ -87,11 +92,11 @@ func exchangeICMPEcho(t *testing.T, net, laddr, raddr string, ipv6 bool, echo []\n \t}\n }\n \n-func icmpEchoTransponder(t *testing.T, net, raddr string, ipv6 bool, waitForReady chan bool) {\n+func icmpEchoTransponder(t *testing.T, net, raddr string, waitForReady chan bool) {\n \tc, err := Dial(net, raddr)\n \tif err != nil {\n \t\twaitForReady <- true\n-\t\tt.Errorf(\"Dial(%#q, %#q) failed: %v\", net, raddr, err)\n+\t\tt.Errorf(\"Dial(%q, %q) failed: %v\", net, raddr, err)\n \t\treturn\n \t}\n \tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n@@ -106,18 +111,23 @@ func icmpEchoTransponder(t *testing.T, net, raddr string, ipv6 bool, waitForRead\n \t\t\tt.Errorf(\"Read failed: %v\", err)\n \t\t\treturn\n \t\t}\n-\t\tif !ipv6 && echo[0] != ICMP4_ECHO_REQUEST {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif ipv6 && echo[0] != ICMP6_ECHO_REQUEST {\n-\t\t\tcontinue\n+\t\tswitch c.(*IPConn).fd.family {\n+\t\tcase syscall.AF_INET:\n+\t\t\tif echo[0] != ICMP4_ECHO_REQUEST {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tcase syscall.AF_INET6:\n+\t\t\tif echo[0] != ICMP6_ECHO_REQUEST {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n \t\tbreak\n \t}\n \n-\tif !ipv6 {\n+\tswitch c.(*IPConn).fd.family {\n+\tcase syscall.AF_INET:\n \t\techo[0] = ICMP4_ECHO_REPLY\n-\t} else {\n+\tcase syscall.AF_INET6:\n \t\techo[0] = ICMP6_ECHO_REPLY\n \t}\n \n@@ -135,11 +145,15 @@ const (\n \tICMP6_ECHO_REPLY   = 129\n )\n \n-func newICMPEchoRequest(ipv6 bool, id, seqnum, msglen int, filler []byte) []byte {\n-\tif !ipv6 {\n+func newICMPEchoRequest(net string, id, seqnum, msglen int, filler []byte) []byte {\n+\tafnet, _, _ := parseDialNetwork(net)\n+\tswitch afnet {\n+\tcase \"ip4\":\n \t\treturn newICMPv4EchoRequest(id, seqnum, msglen, filler)\n+\tcase \"ip6\":\n+\t\treturn newICMPv6EchoRequest(id, seqnum, msglen, filler)\n \t}\n-\treturn newICMPv6EchoRequest(id, seqnum, msglen, filler)\n+\treturn nil\n }\n \n func newICMPv4EchoRequest(id, seqnum, msglen int, filler []byte) []byte {"}, {"sha": "43719fc99cd0ccb252c8cb5d5a3314ce212ef9c9", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,7 +7,7 @@\n package net\n \n import (\n-\t\"os\"\n+\t\"syscall\"\n \t\"time\"\n )\n \n@@ -17,34 +17,34 @@ type IPConn bool\n \n // SetDeadline implements the Conn SetDeadline method.\n func (c *IPConn) SetDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *IPConn) SetReadDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *IPConn) SetWriteDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n // Read implements the Conn Read method.\n func (c *IPConn) Read(b []byte) (int, error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // Write implements the Conn Write method.\n func (c *IPConn) Write(b []byte) (int, error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // Close closes the IP connection.\n func (c *IPConn) Close() error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // LocalAddr returns the local network address.\n@@ -67,12 +67,12 @@ func (c *IPConn) RemoteAddr() Addr {\n // Timeout() == true after a fixed time limit; see SetDeadline and\n // SetReadDeadline.\n func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) {\n-\treturn 0, nil, os.EPLAN9\n+\treturn 0, nil, syscall.EPLAN9\n }\n \n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n-\treturn 0, nil, os.EPLAN9\n+\treturn 0, nil, syscall.EPLAN9\n }\n \n // WriteToIP writes a IP packet to addr via c, copying the payload from b.\n@@ -82,24 +82,24 @@ func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n // see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // WriteTo implements the PacketConn WriteTo method.\n func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // DialIP connects to the remote address raddr on the network protocol netProto,\n // which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon and a protocol number or name.\n func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // ListenIP listens for incoming IP packets addressed to the\n // local address laddr.  The returned connection c's ReadFrom\n // and WriteTo methods can be used to receive and send IP\n // packets with per-packet addressing.\n func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }"}, {"sha": "9caa86985a55a7205e5fc9b893d4ab386f433b11", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -66,15 +66,15 @@ func (c *IPConn) Read(b []byte) (int, error) {\n // Write implements the Conn Write method.\n func (c *IPConn) Write(b []byte) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Write(b)\n }\n \n // Close closes the IP connection.\n func (c *IPConn) Close() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := c.fd.Close()\n \tc.fd = nil\n@@ -100,23 +100,23 @@ func (c *IPConn) RemoteAddr() Addr {\n // SetDeadline implements the Conn SetDeadline method.\n func (c *IPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *IPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *IPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteDeadline(c.fd, t)\n }\n@@ -125,7 +125,7 @@ func (c *IPConn) SetWriteDeadline(t time.Time) error {\n // receive buffer associated with the connection.\n func (c *IPConn) SetReadBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadBuffer(c.fd, bytes)\n }\n@@ -134,7 +134,7 @@ func (c *IPConn) SetReadBuffer(bytes int) error {\n // transmit buffer associated with the connection.\n func (c *IPConn) SetWriteBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteBuffer(c.fd, bytes)\n }\n@@ -150,7 +150,7 @@ func (c *IPConn) SetWriteBuffer(bytes int) error {\n // SetReadDeadline.\n func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \t// TODO(cw,rsc): consider using readv if we know the family\n \t// type to avoid the header trim/copy\n@@ -173,7 +173,7 @@ func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) {\n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tn, uaddr, err := c.ReadFromIP(b)\n \treturn n, uaddr.toAddr(), err\n@@ -187,7 +187,7 @@ func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n // On packet-oriented connections, write timeouts are rare.\n func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tsa, err := addr.sockaddr(c.fd.family)\n \tif err != nil {\n@@ -199,11 +199,11 @@ func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error) {\n // WriteTo implements the PacketConn WriteTo method.\n func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \ta, ok := addr.(*IPAddr)\n \tif !ok {\n-\t\treturn 0, &OpError{\"write\", c.fd.net, addr, os.EINVAL}\n+\t\treturn 0, &OpError{\"write\", c.fd.net, addr, syscall.EINVAL}\n \t}\n \treturn c.WriteToIP(b, a)\n }"}, {"sha": "eab0bf3e899b5e291a9931884278ff80af25d787", "filename": "libgo/go/net/ipsock_plan9.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"errors\"\n \t\"io\"\n \t\"os\"\n+\t\"syscall\"\n \t\"time\"\n )\n \n@@ -83,7 +84,7 @@ func (c *plan9Conn) ok() bool { return c != nil && c.ctl != nil }\n // Read implements the Conn Read method.\n func (c *plan9Conn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif c.data == nil {\n \t\tc.data, err = os.OpenFile(c.dir+\"/data\", os.O_RDWR, 0)\n@@ -102,7 +103,7 @@ func (c *plan9Conn) Read(b []byte) (n int, err error) {\n // Write implements the Conn Write method.\n func (c *plan9Conn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif c.data == nil {\n \t\tc.data, err = os.OpenFile(c.dir+\"/data\", os.O_RDWR, 0)\n@@ -116,7 +117,7 @@ func (c *plan9Conn) Write(b []byte) (n int, err error) {\n // Close closes the connection.\n func (c *plan9Conn) Close() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := c.ctl.Close()\n \tif err != nil {\n@@ -148,17 +149,17 @@ func (c *plan9Conn) RemoteAddr() Addr {\n \n // SetDeadline implements the Conn SetDeadline method.\n func (c *plan9Conn) SetDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *plan9Conn) SetReadDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *plan9Conn) SetWriteDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n func startPlan9(net string, addr Addr) (ctl *os.File, dest, proto, name string, err error) {\n@@ -280,7 +281,7 @@ func (l *plan9Listener) Accept() (c Conn, err error) {\n \n func (l *plan9Listener) Close() error {\n \tif l == nil || l.ctl == nil {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn l.ctl.Close()\n }"}, {"sha": "4841057d6beca367b1cb23ead15db27671431456", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -105,21 +105,20 @@ type sockaddr interface {\n }\n \n func internetSocket(net string, laddr, raddr sockaddr, sotype, proto int, mode string, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n-\tvar oserr error\n \tvar la, ra syscall.Sockaddr\n \tfamily := favoriteAddrFamily(net, laddr, raddr, mode)\n \tif laddr != nil {\n-\t\tif la, oserr = laddr.sockaddr(family); oserr != nil {\n+\t\tif la, err = laddr.sockaddr(family); err != nil {\n \t\t\tgoto Error\n \t\t}\n \t}\n \tif raddr != nil {\n-\t\tif ra, oserr = raddr.sockaddr(family); oserr != nil {\n+\t\tif ra, err = raddr.sockaddr(family); err != nil {\n \t\t\tgoto Error\n \t\t}\n \t}\n-\tfd, oserr = socket(net, family, sotype, proto, la, ra, toAddr)\n-\tif oserr != nil {\n+\tfd, err = socket(net, family, sotype, proto, la, ra, toAddr)\n+\tif err != nil {\n \t\tgoto Error\n \t}\n \treturn fd, nil\n@@ -129,7 +128,7 @@ Error:\n \tif mode == \"listen\" {\n \t\taddr = laddr\n \t}\n-\treturn nil, &OpError{mode, net, addr, oserr}\n+\treturn nil, &OpError{mode, net, addr, err}\n }\n \n func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, error) {"}, {"sha": "b08a9fb98e042a50a0af31a1f714eec496bad0fa", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,6 +7,7 @@ package net\n import (\n \t\"errors\"\n \t\"os\"\n+\t\"syscall\"\n )\n \n func query(filename, query string, bufSize int) (res []string, err error) {\n@@ -71,7 +72,7 @@ func queryDNS(addr string, typ string) (res []string, err error) {\n \n func lookupProtocol(name string) (proto int, err error) {\n \t// TODO: Implement this\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n func lookupHost(host string) (addrs []string, err error) {"}, {"sha": "7b9ea844cd4f9a39f839d12ae5c9faa6d0d5f2c3", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,14 +8,14 @@\n package net\n \n import (\n-\t\"runtime\"\n+\t\"flag\"\n \t\"testing\"\n )\n \n-var avoidMacFirewall = runtime.GOOS == \"darwin\"\n+var testExternal = flag.Bool(\"external\", false, \"allow use of external networks during test\")\n \n func TestGoogleSRV(t *testing.T) {\n-\tif testing.Short() || avoidMacFirewall {\n+\tif testing.Short() || !*testExternal {\n \t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n@@ -38,7 +38,7 @@ func TestGoogleSRV(t *testing.T) {\n }\n \n func TestGmailMX(t *testing.T) {\n-\tif testing.Short() || avoidMacFirewall {\n+\tif testing.Short() || !*testExternal {\n \t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n@@ -52,7 +52,7 @@ func TestGmailMX(t *testing.T) {\n }\n \n func TestGmailTXT(t *testing.T) {\n-\tif testing.Short() || avoidMacFirewall {\n+\tif testing.Short() || !*testExternal {\n \t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n@@ -66,7 +66,7 @@ func TestGmailTXT(t *testing.T) {\n }\n \n func TestGoogleDNSAddr(t *testing.T) {\n-\tif testing.Short() || avoidMacFirewall {\n+\tif testing.Short() || !*testExternal {\n \t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}"}, {"sha": "1d760c21051ff5e0999ed2e7f0b49440bd95e8fb", "filename": "libgo/go/net/multicast_test.go", "status": "modified", "additions": 112, "deletions": 69, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -5,30 +5,46 @@\n package net\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"runtime\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n-var listenMulticastUDPTests = []struct {\n+var multicastListenerTests = []struct {\n \tnet   string\n \tgaddr *UDPAddr\n \tflags Flags\n-\tipv6  bool\n+\tipv6  bool // test with underlying AF_INET6 socket\n }{\n \t// cf. RFC 4727: Experimental Values in IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers\n+\n \t{\"udp\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n-\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, 0, false},\n \t{\"udp\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, 0, true},\n+\n+\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, 0, false},\n+\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff01::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff01::114\"), 12345}, 0, true},\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff02::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff02::114\"), 12345}, 0, true},\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff04::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff04::114\"), 12345}, 0, true},\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff05::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff05::114\"), 12345}, 0, true},\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff08::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff08::114\"), 12345}, 0, true},\n \t{\"udp6\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, 0, true},\n }\n \n-func TestListenMulticastUDP(t *testing.T) {\n+// TestMulticastListener tests both single and double listen to a test\n+// listener with same address family, same group address and same port.\n+func TestMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"netbsd\", \"openbsd\", \"plan9\", \"windows\":\n \t\treturn\n@@ -38,144 +54,171 @@ func TestListenMulticastUDP(t *testing.T) {\n \t\t}\n \t}\n \n-\tfor _, tt := range listenMulticastUDPTests {\n+\tfor _, tt := range multicastListenerTests {\n \t\tif tt.ipv6 && (!supportsIPv6 || os.Getuid() != 0) {\n \t\t\tcontinue\n \t\t}\n-\t\tift, err := Interfaces()\n+\t\tifi, err := availMulticastInterface(t, tt.flags)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n-\t\t}\n-\t\tvar ifi *Interface\n-\t\tfor _, x := range ift {\n-\t\t\tif x.Flags&tt.flags == tt.flags {\n-\t\t\t\tifi = &x\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif ifi == nil {\n-\t\t\tt.Logf(\"an appropriate multicast interface not found\")\n-\t\t\treturn\n+\t\t\tcontinue\n \t\t}\n-\t\tc, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n+\t\tc1, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"ListenMulticastUDP failed: %v\", err)\n+\t\t\tt.Fatalf(\"First ListenMulticastUDP failed: %v\", err)\n \t\t}\n-\t\tdefer c.Close() // test to listen concurrently across multiple listeners\n-\t\tif !tt.ipv6 {\n-\t\t\ttestIPv4MulticastSocketOptions(t, c.fd, ifi)\n-\t\t} else {\n-\t\t\ttestIPv6MulticastSocketOptions(t, c.fd, ifi)\n-\t\t}\n-\t\tifmat, err := ifi.MulticastAddrs()\n+\t\tcheckMulticastListener(t, err, c1, tt.gaddr)\n+\t\tc2, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"MulticastAddrs failed: %v\", err)\n-\t\t}\n-\t\tvar found bool\n-\t\tfor _, ifma := range ifmat {\n-\t\t\tif ifma.(*IPAddr).IP.Equal(tt.gaddr.IP) {\n-\t\t\t\tfound = true\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\t\tt.Fatalf(\"Second ListenMulticastUDP failed: %v\", err)\n \t\t}\n-\t\tif !found {\n-\t\t\tt.Fatalf(\"%q not found in RIB\", tt.gaddr.String())\n+\t\tcheckMulticastListener(t, err, c2, tt.gaddr)\n+\t\tc2.Close()\n+\t\tswitch c1.fd.family {\n+\t\tcase syscall.AF_INET:\n+\t\t\ttestIPv4MulticastSocketOptions(t, c1.fd, ifi)\n+\t\tcase syscall.AF_INET6:\n+\t\t\ttestIPv6MulticastSocketOptions(t, c1.fd, ifi)\n \t\t}\n+\t\tc1.Close()\n \t}\n }\n \n-func TestSimpleListenMulticastUDP(t *testing.T) {\n+func TestSimpleMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":\n \t\treturn\n \t}\n \n-\tfor _, tt := range listenMulticastUDPTests {\n+\tfor _, tt := range multicastListenerTests {\n \t\tif tt.ipv6 {\n \t\t\tcontinue\n \t\t}\n-\t\ttt.flags = FlagUp | FlagMulticast\n+\t\ttt.flags = FlagUp | FlagMulticast // for windows testing\n+\t\tifi, err := availMulticastInterface(t, tt.flags)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tc1, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"First ListenMulticastUDP failed: %v\", err)\n+\t\t}\n+\t\tcheckSimpleMulticastListener(t, err, c1, tt.gaddr)\n+\t\tc2, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Second ListenMulticastUDP failed: %v\", err)\n+\t\t}\n+\t\tcheckSimpleMulticastListener(t, err, c2, tt.gaddr)\n+\t\tc2.Close()\n+\t\tc1.Close()\n+\t}\n+}\n+\n+func checkMulticastListener(t *testing.T, err error, c *UDPConn, gaddr *UDPAddr) {\n+\tif !multicastRIBContains(t, gaddr.IP) {\n+\t\tt.Fatalf(\"%q not found in RIB\", gaddr.String())\n+\t}\n+\tif c.LocalAddr().String() != gaddr.String() {\n+\t\tt.Fatalf(\"LocalAddr returns %q, expected %q\", c.LocalAddr().String(), gaddr.String())\n+\t}\n+}\n+\n+func checkSimpleMulticastListener(t *testing.T, err error, c *UDPConn, gaddr *UDPAddr) {\n+\tif c.LocalAddr().String() != gaddr.String() {\n+\t\tt.Fatalf(\"LocalAddr returns %q, expected %q\", c.LocalAddr().String(), gaddr.String())\n+\t}\n+}\n+\n+func availMulticastInterface(t *testing.T, flags Flags) (*Interface, error) {\n+\tvar ifi *Interface\n+\tif flags != Flags(0) {\n \t\tift, err := Interfaces()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n \t\t}\n-\t\tvar ifi *Interface\n \t\tfor _, x := range ift {\n-\t\t\tif x.Flags&tt.flags == tt.flags {\n+\t\t\tif x.Flags&flags == flags {\n \t\t\t\tifi = &x\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t\tif ifi == nil {\n-\t\t\tt.Logf(\"an appropriate multicast interface not found\")\n-\t\t\treturn\n+\t\t\treturn nil, errors.New(\"an appropriate multicast interface not found\")\n \t\t}\n-\t\tc, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n+\t}\n+\treturn ifi, nil\n+}\n+\n+func multicastRIBContains(t *testing.T, ip IP) bool {\n+\tift, err := Interfaces()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n+\t}\n+\tfor _, ifi := range ift {\n+\t\tifmat, err := ifi.MulticastAddrs()\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"ListenMulticastUDP failed: %v\", err)\n+\t\t\tt.Fatalf(\"MulticastAddrs failed: %v\", err)\n+\t\t}\n+\t\tfor _, ifma := range ifmat {\n+\t\t\tif ifma.(*IPAddr).IP.Equal(ip) {\n+\t\t\t\treturn true\n+\t\t\t}\n \t\t}\n-\t\tc.Close()\n \t}\n+\treturn false\n }\n \n func testIPv4MulticastSocketOptions(t *testing.T, fd *netFD, ifi *Interface) {\n-\tifmc, err := ipv4MulticastInterface(fd)\n+\t_, err := ipv4MulticastInterface(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv4MulticastInterface failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv4 multicast interface: %v\", ifmc)\n-\terr = setIPv4MulticastInterface(fd, ifi)\n-\tif err != nil {\n-\t\tt.Fatalf(\"setIPv4MulticastInterface failed: %v\", err)\n+\tif ifi != nil {\n+\t\terr = setIPv4MulticastInterface(fd, ifi)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"setIPv4MulticastInterface failed: %v\", err)\n+\t\t}\n \t}\n-\n-\tttl, err := ipv4MulticastTTL(fd)\n+\t_, err = ipv4MulticastTTL(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv4MulticastTTL failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv4 multicast TTL: %v\", ttl)\n \terr = setIPv4MulticastTTL(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv4MulticastTTL failed: %v\", err)\n \t}\n-\n-\tloop, err := ipv4MulticastLoopback(fd)\n+\t_, err = ipv4MulticastLoopback(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv4MulticastLoopback failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv4 multicast loopback: %v\", loop)\n \terr = setIPv4MulticastLoopback(fd, false)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv4MulticastLoopback failed: %v\", err)\n \t}\n }\n \n func testIPv6MulticastSocketOptions(t *testing.T, fd *netFD, ifi *Interface) {\n-\tifmc, err := ipv6MulticastInterface(fd)\n+\t_, err := ipv6MulticastInterface(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv6MulticastInterface failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv6 multicast interface: %v\", ifmc)\n-\terr = setIPv6MulticastInterface(fd, ifi)\n-\tif err != nil {\n-\t\tt.Fatalf(\"setIPv6MulticastInterface failed: %v\", err)\n+\tif ifi != nil {\n+\t\terr = setIPv6MulticastInterface(fd, ifi)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"setIPv6MulticastInterface failed: %v\", err)\n+\t\t}\n \t}\n-\n-\thoplim, err := ipv6MulticastHopLimit(fd)\n+\t_, err = ipv6MulticastHopLimit(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv6MulticastHopLimit failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv6 multicast hop limit: %v\", hoplim)\n \terr = setIPv6MulticastHopLimit(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv6MulticastHopLimit failed: %v\", err)\n \t}\n-\n-\tloop, err := ipv6MulticastLoopback(fd)\n+\t_, err = ipv6MulticastLoopback(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv6MulticastLoopback failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv6 multicast loopback: %v\", loop)\n \terr = setIPv6MulticastLoopback(fd, false)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv6MulticastLoopback failed: %v\", err)"}, {"sha": "bf242ff8dd65419a8713201890484ee0ec3aa2c0", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,8 +2,41 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package net provides a portable interface to Unix networks sockets,\n-// including TCP/IP, UDP, domain name resolution, and Unix domain sockets.\n+/*\n+Package net provides a portable interface for network I/O, including\n+TCP/IP, UDP, domain name resolution, and Unix domain sockets.\n+\n+Although the package provides access to low-level networking\n+primitives, most clients will need only the basic interface provided\n+by the Dial, Listen, and Accept functions and the associated\n+Conn and Listener interfaces. The crypto/tls package uses\n+the same interfaces and similar Dial and Listen functions.\n+\n+The Dial function connects to a server:\n+\n+\tconn, err := net.Dial(\"tcp\", \"google.com:80\")\n+\tif err != nil {\n+\t\t// handle error\n+\t}\n+\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n+\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n+\t// ...\n+\n+The Listen function creates servers:\n+\n+\tln, err := net.Listen(\"tcp\", \":8080\")\n+\tif err != nil {\n+\t\t// handle error\n+\t}\n+\tfor {\n+\t\tconn, err := ln.Accept()\n+\t\tif err != nil {\n+\t\t\t// handle error\n+\t\t\tcontinue\n+\t\t}\n+\t\tgo handleConnection(conn)\n+\t}\n+*/\n package net\n \n // TODO(rsc):\n@@ -42,21 +75,28 @@ type Conn interface {\n \tRemoteAddr() Addr\n \n \t// SetDeadline sets the read and write deadlines associated\n-\t// with the connection.\n+\t// with the connection. It is equivalent to calling both\n+\t// SetReadDeadline and SetWriteDeadline.\n+\t//\n+\t// A deadline is an absolute time after which I/O operations\n+\t// fail with a timeout (see type Error) instead of\n+\t// blocking. The deadline applies to all future I/O, not just\n+\t// the immediately following call to Read or Write.\n+\t//\n+\t// An idle timeout can be implemented by repeatedly extending\n+\t// the deadline after successful Read or Write calls.\n+\t//\n+\t// A zero value for t means I/O operations will not time out.\n \tSetDeadline(t time.Time) error\n \n-\t// SetReadDeadline sets the deadline for all Read calls to return.\n-\t// If the deadline is reached, Read will fail with a timeout\n-\t// (see type Error) instead of blocking.\n+\t// SetReadDeadline sets the deadline for Read calls.\n \t// A zero value for t means Read will not time out.\n \tSetReadDeadline(t time.Time) error\n \n-\t// SetWriteDeadline sets the deadline for all Write calls to return.\n-\t// If the deadline is reached, Write will fail with a timeout\n-\t// (see type Error) instead of blocking.\n-\t// A zero value for t means Write will not time out.\n+\t// SetWriteDeadline sets the deadline for Write calls.\n \t// Even if write times out, it may return n > 0, indicating that\n \t// some of the data was successfully written.\n+\t// A zero value for t means Write will not time out.\n \tSetWriteDeadline(t time.Time) error\n }\n "}, {"sha": "7c87b42f6d9edbc3ddef05a105d282e7f724a9e1", "filename": "libgo/go/net/parse.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -67,7 +67,7 @@ func open(name string) (*file, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn &file{fd, make([]byte, 1024)[0:0], false}, nil\n+\treturn &file{fd, make([]byte, os.Getpagesize())[0:0], false}, nil\n }\n \n func byteIndex(s string, c byte) int {"}, {"sha": "62c7b1e60048d7dc63ac2f8eedf71268c5b33a1d", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -387,12 +387,12 @@ func (WriteFailCodec) WriteRequest(*Request, interface{}) error {\n }\n \n func (WriteFailCodec) ReadResponseHeader(*Response) error {\n-\ttime.Sleep(120 * time.Second)\n+\tselect {}\n \tpanic(\"unreachable\")\n }\n \n func (WriteFailCodec) ReadResponseBody(interface{}) error {\n-\ttime.Sleep(120 * time.Second)\n+\tselect {}\n \tpanic(\"unreachable\")\n }\n "}, {"sha": "b9862168153f96b6905594b6eb046ecb4fcf7d30", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -95,7 +95,7 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {\n \tt.Logf(\"Test %q %q %q\", network, listenaddr, dialaddr)\n \tswitch listenaddr {\n \tcase \"\", \"0.0.0.0\", \"[::]\", \"[::ffff:0.0.0.0]\":\n-\t\tif testing.Short() || avoidMacFirewall {\n+\t\tif testing.Short() || !*testExternal {\n \t\t\tt.Logf(\"skip wildcard listen during short test\")\n \t\t\treturn\n \t\t}"}, {"sha": "59f6449f0ab07d257e77464cb771d1d3f2f73fef", "filename": "libgo/go/net/smtp/smtp.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -50,15 +50,14 @@ func Dial(addr string) (*Client, error) {\n // server name to be used when authenticating.\n func NewClient(conn net.Conn, host string) (*Client, error) {\n \ttext := textproto.NewConn(conn)\n-\t_, msg, err := text.ReadResponse(220)\n+\t_, _, err := text.ReadResponse(220)\n \tif err != nil {\n \t\ttext.Close()\n \t\treturn nil, err\n \t}\n \tc := &Client{Text: text, conn: conn, serverName: host}\n-\tif strings.Contains(msg, \"ESMTP\") {\n-\t\terr = c.ehlo()\n-\t} else {\n+\terr = c.ehlo()\n+\tif err != nil {\n \t\terr = c.helo()\n \t}\n \treturn c, err"}, {"sha": "c315d185c9df0ed188503e99faf71059b9057f86", "filename": "libgo/go/net/smtp/smtp_test.go", "status": "modified", "additions": 92, "deletions": 3, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,9 +8,11 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"io\"\n+\t\"net\"\n \t\"net/textproto\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type authTest struct {\n@@ -59,9 +61,12 @@ type faker struct {\n \tio.ReadWriter\n }\n \n-func (f faker) Close() error {\n-\treturn nil\n-}\n+func (f faker) Close() error                     { return nil }\n+func (f faker) LocalAddr() net.Addr              { return nil }\n+func (f faker) RemoteAddr() net.Addr             { return nil }\n+func (f faker) SetDeadline(time.Time) error      { return nil }\n+func (f faker) SetReadDeadline(time.Time) error  { return nil }\n+func (f faker) SetWriteDeadline(time.Time) error { return nil }\n \n func TestBasic(t *testing.T) {\n \tbasicServer = strings.Join(strings.Split(basicServer, \"\\n\"), \"\\r\\n\")\n@@ -180,3 +185,87 @@ Goodbye.\n .\n QUIT\n `\n+\n+func TestNewClient(t *testing.T) {\n+\tnewClientServer = strings.Join(strings.Split(newClientServer, \"\\n\"), \"\\r\\n\")\n+\tnewClientClient = strings.Join(strings.Split(newClientClient, \"\\n\"), \"\\r\\n\")\n+\n+\tvar cmdbuf bytes.Buffer\n+\tbcmdbuf := bufio.NewWriter(&cmdbuf)\n+\tout := func() string {\n+\t\tbcmdbuf.Flush()\n+\t\treturn cmdbuf.String()\n+\t}\n+\tvar fake faker\n+\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(newClientServer)), bcmdbuf)\n+\tc, err := NewClient(fake, \"fake.host\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewClient: %v\\n(after %v)\", err, out())\n+\t}\n+\tif ok, args := c.Extension(\"aUtH\"); !ok || args != \"LOGIN PLAIN\" {\n+\t\tt.Fatalf(\"Expected AUTH supported\")\n+\t}\n+\tif ok, _ := c.Extension(\"DSN\"); ok {\n+\t\tt.Fatalf(\"Shouldn't support DSN\")\n+\t}\n+\tif err := c.Quit(); err != nil {\n+\t\tt.Fatalf(\"QUIT failed: %s\", err)\n+\t}\n+\n+\tactualcmds := out()\n+\tif newClientClient != actualcmds {\n+\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, newClientClient)\n+\t}\n+}\n+\n+var newClientServer = `220 hello world\n+250-mx.google.com at your service\n+250-SIZE 35651584\n+250-AUTH LOGIN PLAIN\n+250 8BITMIME\n+221 OK\n+`\n+\n+var newClientClient = `EHLO localhost\n+QUIT\n+`\n+\n+func TestNewClient2(t *testing.T) {\n+\tnewClient2Server = strings.Join(strings.Split(newClient2Server, \"\\n\"), \"\\r\\n\")\n+\tnewClient2Client = strings.Join(strings.Split(newClient2Client, \"\\n\"), \"\\r\\n\")\n+\n+\tvar cmdbuf bytes.Buffer\n+\tbcmdbuf := bufio.NewWriter(&cmdbuf)\n+\tvar fake faker\n+\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(newClient2Server)), bcmdbuf)\n+\tc, err := NewClient(fake, \"fake.host\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewClient: %v\", err)\n+\t}\n+\tif ok, _ := c.Extension(\"DSN\"); ok {\n+\t\tt.Fatalf(\"Shouldn't support DSN\")\n+\t}\n+\tif err := c.Quit(); err != nil {\n+\t\tt.Fatalf(\"QUIT failed: %s\", err)\n+\t}\n+\n+\tbcmdbuf.Flush()\n+\tactualcmds := cmdbuf.String()\n+\tif newClient2Client != actualcmds {\n+\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, newClient2Client)\n+\t}\n+}\n+\n+var newClient2Server = `220 hello world\n+502 EH?\n+250-mx.google.com at your service\n+250-SIZE 35651584\n+250-AUTH LOGIN PLAIN\n+250 8BITMIME\n+221 OK\n+`\n+\n+var newClient2Client = `EHLO localhost\n+HELO localhost\n+QUIT\n+`"}, {"sha": "dc139f04a259e34fc99a4e8246a2df0c2443b309", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -33,13 +33,14 @@ func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscal\n \t\treturn nil, err\n \t}\n \n+\tvar bla syscall.Sockaddr\n \tif la != nil {\n-\t\tla, err = listenerSockaddr(s, f, la, toAddr)\n+\t\tbla, err = listenerSockaddr(s, f, la, toAddr)\n \t\tif err != nil {\n \t\t\tclosesocket(s)\n \t\t\treturn nil, err\n \t\t}\n-\t\terr = syscall.Bind(s, la)\n+\t\terr = syscall.Bind(s, bla)\n \t\tif err != nil {\n \t\t\tclosesocket(s)\n \t\t\treturn nil, err\n@@ -61,7 +62,12 @@ func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscal\n \t}\n \n \tsa, _ := syscall.Getsockname(s)\n-\tladdr := toAddr(sa)\n+\tvar laddr Addr\n+\tif la != nil && bla != la {\n+\t\tladdr = toAddr(la)\n+\t} else {\n+\t\tladdr = toAddr(sa)\n+\t}\n \tsa, _ = syscall.Getpeername(s)\n \traddr := toAddr(sa)\n "}, {"sha": "35f56966eae66336bcd84d01735cf0906d60626b", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,7 +7,7 @@\n package net\n \n import (\n-\t\"os\"\n+\t\"syscall\"\n \t\"time\"\n )\n \n@@ -19,35 +19,35 @@ type TCPConn struct {\n \n // SetDeadline implements the Conn SetDeadline method.\n func (c *TCPConn) SetDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *TCPConn) SetReadDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // CloseRead shuts down the reading side of the TCP connection.\n // Most callers should just use Close.\n func (c *TCPConn) CloseRead() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // CloseWrite shuts down the writing side of the TCP connection.\n // Most callers should just use Close.\n func (c *TCPConn) CloseWrite() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // DialTCP connects to the remote address raddr on the network net,"}, {"sha": "e05bc10170e711d39b416733198c3c4222314355", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -9,6 +9,7 @@\n package net\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"syscall\"\n@@ -26,6 +27,11 @@ func sockaddrToTCP(sa syscall.Sockaddr) Addr {\n \t\treturn &TCPAddr{sa.Addr[0:], sa.Port}\n \tcase *syscall.SockaddrInet6:\n \t\treturn &TCPAddr{sa.Addr[0:], sa.Port}\n+\tdefault:\n+\t\tif sa != nil {\n+\t\t\t// Diagnose when we will turn a non-nil sockaddr into a nil.\n+\t\t\tpanic(fmt.Sprintf(\"unexpected type in sockaddrToTCP: %T\", sa))\n+\t\t}\n \t}\n \treturn nil\n }\n@@ -70,7 +76,7 @@ func (c *TCPConn) ok() bool { return c != nil && c.fd != nil }\n // Read implements the Conn Read method.\n func (c *TCPConn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Read(b)\n }\n@@ -86,15 +92,15 @@ func (c *TCPConn) ReadFrom(r io.Reader) (int64, error) {\n // Write implements the Conn Write method.\n func (c *TCPConn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Write(b)\n }\n \n // Close closes the TCP connection.\n func (c *TCPConn) Close() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := c.fd.Close()\n \tc.fd = nil\n@@ -105,7 +111,7 @@ func (c *TCPConn) Close() error {\n // Most callers should just use Close.\n func (c *TCPConn) CloseRead() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn c.fd.CloseRead()\n }\n@@ -114,7 +120,7 @@ func (c *TCPConn) CloseRead() error {\n // Most callers should just use Close.\n func (c *TCPConn) CloseWrite() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn c.fd.CloseWrite()\n }\n@@ -138,23 +144,23 @@ func (c *TCPConn) RemoteAddr() Addr {\n // SetDeadline implements the Conn SetDeadline method.\n func (c *TCPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *TCPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteDeadline(c.fd, t)\n }\n@@ -163,7 +169,7 @@ func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n // receive buffer associated with the connection.\n func (c *TCPConn) SetReadBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadBuffer(c.fd, bytes)\n }\n@@ -172,7 +178,7 @@ func (c *TCPConn) SetReadBuffer(bytes int) error {\n // transmit buffer associated with the connection.\n func (c *TCPConn) SetWriteBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteBuffer(c.fd, bytes)\n }\n@@ -190,7 +196,7 @@ func (c *TCPConn) SetWriteBuffer(bytes int) error {\n // data to be sent and acknowledged.\n func (c *TCPConn) SetLinger(sec int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setLinger(c.fd, sec)\n }\n@@ -199,7 +205,7 @@ func (c *TCPConn) SetLinger(sec int) error {\n // keepalive messages on the connection.\n func (c *TCPConn) SetKeepAlive(keepalive bool) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setKeepAlive(c.fd, keepalive)\n }\n@@ -210,7 +216,7 @@ func (c *TCPConn) SetKeepAlive(keepalive bool) error {\n // that data is sent as soon as possible after a Write.\n func (c *TCPConn) SetNoDelay(noDelay bool) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setNoDelay(c.fd, noDelay)\n }\n@@ -259,6 +265,17 @@ func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\n }\n \n func selfConnect(fd *netFD) bool {\n+\t// The socket constructor can return an fd with raddr nil under certain\n+\t// unknown conditions. The errors in the calls there to Getpeername\n+\t// are discarded, but we can't catch the problem there because those\n+\t// calls are sometimes legally erroneous with a \"socket not connected\".\n+\t// Since this code (selfConnect) is already trying to work around\n+\t// a problem, we make sure if this happens we recognize trouble and\n+\t// ask the DialTCP routine to try again.\n+\t// TODO: try to understand what's really going on.\n+\tif fd.laddr == nil || fd.raddr == nil {\n+\t\treturn true\n+\t}\n \tl := fd.laddr.(*TCPAddr)\n \tr := fd.raddr.(*TCPAddr)\n \treturn l.Port == r.Port && l.IP.Equal(r.IP)\n@@ -294,7 +311,7 @@ func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {\n // and the remote address.\n func (l *TCPListener) AcceptTCP() (c *TCPConn, err error) {\n \tif l == nil || l.fd == nil || l.fd.sysfd < 0 {\n-\t\treturn nil, os.EINVAL\n+\t\treturn nil, syscall.EINVAL\n \t}\n \tfd, err := l.fd.accept(sockaddrToTCP)\n \tif err != nil {\n@@ -317,7 +334,7 @@ func (l *TCPListener) Accept() (c Conn, err error) {\n // Already Accepted connections are not closed.\n func (l *TCPListener) Close() error {\n \tif l == nil || l.fd == nil {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn l.fd.Close()\n }\n@@ -329,7 +346,7 @@ func (l *TCPListener) Addr() Addr { return l.fd.laddr }\n // A zero time value disables the deadline.\n func (l *TCPListener) SetDeadline(t time.Time) error {\n \tif l == nil || l.fd == nil {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(l.fd, t)\n }"}, {"sha": "b601763898b7e27ded621cc207effa4a403cecc0", "filename": "libgo/go/net/testdata/hosts", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Fhosts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Fhosts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftestdata%2Fhosts?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,12 @@\n+255.255.255.255\tbroadcasthost\n+127.0.0.2\todin\n+127.0.0.3\todin  # inline comment \n+::2             odin\n+127.1.1.1\tthor\n+# aliases\n+127.1.1.2\tullr ullrhost\n+# Bogus entries that must be ignored.\n+123.123.123\tloki\n+321.321.321.321\n+# TODO(yvesj): Should we be able to parse this? From a Darwin system.\n+fe80::1%lo0\tlocalhost"}, {"sha": "5f380a2c7dbb5821fe7d0779a3a0309c7793d022", "filename": "libgo/go/net/testdata/igmp", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,24 @@\n+Idx\tDevice    : Count Querier\tGroup    Users Timer\tReporter\n+1\tlo        :     1      V3\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+2\teth0      :     2      V2\n+\t\t\t\tFB0000E0     1 0:00000000\t\t1\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+3\teth1      :     1      V3\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+4\teth2      :     1      V3\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+5\teth0.100  :     2      V3\n+\t\t\t\tFB0000E0     1 0:00000000\t\t0\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+6\teth0.101  :     2      V3\n+\t\t\t\tFB0000E0     1 0:00000000\t\t0\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+7\teth0.102  :     2      V3\n+\t\t\t\tFB0000E0     1 0:00000000\t\t0\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+8\teth0.103  :     2      V3\n+\t\t\t\tFB0000E0     1 0:00000000\t\t0\n+\t\t\t\t010000E0     1 0:00000000\t\t0\n+9\tdevice1tap2:     1      V3\n+\t\t\t\t010000E0     1 0:00000000\t\t0"}, {"sha": "6cd5a2d4d9d85b7e1827ba777549f08ba565217f", "filename": "libgo/go/net/testdata/igmp6", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftestdata%2Figmp6?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,18 @@\n+1    lo              ff020000000000000000000000000001     1 0000000C 0\n+2    eth0            ff0200000000000000000001ffac891e     1 00000006 0\n+2    eth0            ff020000000000000000000000000001     1 0000000C 0\n+3    eth1            ff0200000000000000000001ffac8928     2 00000006 0\n+3    eth1            ff020000000000000000000000000001     1 0000000C 0\n+4    eth2            ff0200000000000000000001ffac8932     2 00000006 0\n+4    eth2            ff020000000000000000000000000001     1 0000000C 0\n+5    eth0.100        ff0200000000000000000001ffac891e     1 00000004 0\n+5    eth0.100        ff020000000000000000000000000001     1 0000000C 0\n+6    pan0            ff020000000000000000000000000001     1 0000000C 0\n+7    eth0.101        ff0200000000000000000001ffac891e     1 00000004 0\n+7    eth0.101        ff020000000000000000000000000001     1 0000000C 0\n+8    eth0.102        ff0200000000000000000001ffac891e     1 00000004 0\n+8    eth0.102        ff020000000000000000000000000001     1 0000000C 0\n+9    eth0.103        ff0200000000000000000001ffac891e     1 00000004 0\n+9    eth0.103        ff020000000000000000000000000001     1 0000000C 0\n+10   device1tap2     ff0200000000000000000001ff4cc3a3     1 00000004 0\n+10   device1tap2     ff020000000000000000000000000001     1 0000000C 0"}, {"sha": "125feb3e885c39a986dda30e6a0450a5e845ba3c", "filename": "libgo/go/net/textproto/reader.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -454,10 +454,14 @@ func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {\n \n \t\t// Key ends at first colon; must not have spaces.\n \t\ti := bytes.IndexByte(kv, ':')\n-\t\tif i < 0 || bytes.IndexByte(kv[0:i], ' ') >= 0 {\n+\t\tif i < 0 {\n \t\t\treturn m, ProtocolError(\"malformed MIME header line: \" + string(kv))\n \t\t}\n-\t\tkey := CanonicalMIMEHeaderKey(string(kv[0:i]))\n+\t\tkey := string(kv[0:i])\n+\t\tif strings.Index(key, \" \") >= 0 {\n+\t\t\tkey = strings.TrimRight(key, \" \")\n+\t\t}\n+\t\tkey = CanonicalMIMEHeaderKey(key)\n \n \t\t// Skip initial spaces in value.\n \t\ti++ // skip colon\n@@ -503,6 +507,11 @@ MustRewrite:\n \ta := []byte(s)\n \tupper := true\n \tfor i, v := range a {\n+\t\tif v == ' ' {\n+\t\t\ta[i] = '-'\n+\t\t\tupper = true\n+\t\t\tcontinue\n+\t\t}\n \t\tif upper && 'a' <= v && v <= 'z' {\n \t\t\ta[i] = v + 'A' - 'a'\n \t\t}"}, {"sha": "7c5d16227ff95559362a91660852c2ae0e3f1d2f", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -164,6 +164,29 @@ func TestLargeReadMIMEHeader(t *testing.T) {\n \t}\n }\n \n+// Test that we read slightly-bogus MIME headers seen in the wild,\n+// with spaces before colons, and spaces in keys.\n+func TestReadMIMEHeaderNonCompliant(t *testing.T) {\n+\t// Invalid HTTP response header as sent by an Axis security\n+\t// camera: (this is handled by IE, Firefox, Chrome, curl, etc.)\n+\tr := reader(\"Foo: bar\\r\\n\" +\n+\t\t\"Content-Language: en\\r\\n\" +\n+\t\t\"SID : 0\\r\\n\" +\n+\t\t\"Audio Mode : None\\r\\n\" +\n+\t\t\"Privilege : 127\\r\\n\\r\\n\")\n+\tm, err := r.ReadMIMEHeader()\n+\twant := MIMEHeader{\n+\t\t\"Foo\":              {\"bar\"},\n+\t\t\"Content-Language\": {\"en\"},\n+\t\t\"Sid\":              {\"0\"},\n+\t\t\"Audio-Mode\":       {\"None\"},\n+\t\t\"Privilege\":        {\"127\"},\n+\t}\n+\tif !reflect.DeepEqual(m, want) || err != nil {\n+\t\tt.Fatalf(\"ReadMIMEHeader =\\n%v, %v; want:\\n%v\", m, err, want)\n+\t}\n+}\n+\n type readResponseTest struct {\n \tin       string\n \tinCode   int"}, {"sha": "ad5840cf7dafe882bdbeb365a6332d3f507e6ffd", "filename": "libgo/go/net/textproto/textproto.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -20,6 +20,9 @@\n //\n // Writer, to write dot-encoded text blocks.\n //\n+// Conn, a convenient packaging of Reader, Writer, and Pipeline for use\n+// with a single network connection.\n+//\n package textproto\n \n import ("}, {"sha": "4f298a42f878737bbfc0b6d4c694aeb08cf144fd", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -9,6 +9,7 @@ package net\n import (\n \t\"errors\"\n \t\"os\"\n+\t\"syscall\"\n \t\"time\"\n )\n \n@@ -20,17 +21,17 @@ type UDPConn struct {\n \n // SetDeadline implements the Conn SetDeadline method.\n func (c *UDPConn) SetDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UDPConn) SetReadDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // UDP-specific methods.\n@@ -43,7 +44,7 @@ func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n // after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tif c.data == nil {\n \t\tc.data, err = os.OpenFile(c.dir+\"/data\", os.O_RDWR, 0)\n@@ -69,7 +70,7 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \treturn c.ReadFromUDP(b)\n }\n@@ -82,7 +83,7 @@ func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n // On packet-oriented connections, write timeouts are rare.\n func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif c.data == nil {\n \t\tc.data, err = os.OpenFile(c.dir+\"/data\", os.O_RDWR, 0)\n@@ -106,11 +107,11 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n // WriteTo implements the PacketConn WriteTo method.\n func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \ta, ok := addr.(*UDPAddr)\n \tif !ok {\n-\t\treturn 0, &OpError{\"write\", c.dir, addr, os.EINVAL}\n+\t\treturn 0, &OpError{\"write\", c.dir, addr, syscall.EINVAL}\n \t}\n \treturn c.WriteToUDP(b, a)\n }\n@@ -191,5 +192,5 @@ func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err error) {\n // the interface to join.  ListenMulticastUDP uses default\n // multicast interface if ifi is nil.\n func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }"}, {"sha": "1f99dc53867826cfc29b61fd12569a7b5b507a3e", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -63,23 +63,23 @@ func (c *UDPConn) ok() bool { return c != nil && c.fd != nil }\n // Read implements the Conn Read method.\n func (c *UDPConn) Read(b []byte) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Read(b)\n }\n \n // Write implements the Conn Write method.\n func (c *UDPConn) Write(b []byte) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Write(b)\n }\n \n // Close closes the UDP connection.\n func (c *UDPConn) Close() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := c.fd.Close()\n \tc.fd = nil\n@@ -105,23 +105,23 @@ func (c *UDPConn) RemoteAddr() Addr {\n // SetDeadline implements the Conn SetDeadline method.\n func (c *UDPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UDPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteDeadline(c.fd, t)\n }\n@@ -130,7 +130,7 @@ func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n // receive buffer associated with the connection.\n func (c *UDPConn) SetReadBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadBuffer(c.fd, bytes)\n }\n@@ -139,7 +139,7 @@ func (c *UDPConn) SetReadBuffer(bytes int) error {\n // transmit buffer associated with the connection.\n func (c *UDPConn) SetWriteBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteBuffer(c.fd, bytes)\n }\n@@ -154,7 +154,7 @@ func (c *UDPConn) SetWriteBuffer(bytes int) error {\n // after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tn, sa, err := c.fd.ReadFrom(b)\n \tswitch sa := sa.(type) {\n@@ -169,7 +169,7 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tn, uaddr, err := c.ReadFromUDP(b)\n \treturn n, uaddr.toAddr(), err\n@@ -183,7 +183,7 @@ func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {\n // On packet-oriented connections, write timeouts are rare.\n func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif c.fd.isConnected {\n \t\treturn 0, &OpError{\"write\", c.fd.net, addr, ErrWriteToConnected}\n@@ -198,11 +198,11 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) {\n // WriteTo implements the PacketConn WriteTo method.\n func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \ta, ok := addr.(*UDPAddr)\n \tif !ok {\n-\t\treturn 0, &OpError{\"write\", c.fd.net, addr, os.EINVAL}\n+\t\treturn 0, &OpError{\"write\", c.fd.net, addr, syscall.EINVAL}\n \t}\n \treturn c.WriteToUDP(b, a)\n }\n@@ -262,7 +262,7 @@ func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, e\n \t\treturn nil, UnknownNetworkError(net)\n \t}\n \tif gaddr == nil || gaddr.IP == nil {\n-\t\treturn nil, &OpError{\"listenmulticastudp\", \"udp\", nil, errMissingAddress}\n+\t\treturn nil, &OpError{\"listenmulticast\", net, nil, errMissingAddress}\n \t}\n \tfd, err := internetSocket(net, gaddr.toAddr(), nil, syscall.SOCK_DGRAM, 0, \"listen\", sockaddrToUDP)\n \tif err != nil {"}, {"sha": "7b4ae6bd11619e673c49337996a8c643d4946531", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,7 +7,7 @@\n package net\n \n import (\n-\t\"os\"\n+\t\"syscall\"\n \t\"time\"\n )\n \n@@ -19,17 +19,17 @@ type UnixConn bool\n \n // Read implements the Conn Read method.\n func (c *UnixConn) Read(b []byte) (n int, err error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // Write implements the Conn Write method.\n func (c *UnixConn) Write(b []byte) (n int, err error) {\n-\treturn 0, os.EPLAN9\n+\treturn 0, syscall.EPLAN9\n }\n \n // Close closes the Unix domain connection.\n func (c *UnixConn) Close() error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // LocalAddr returns the local network address, a *UnixAddr.\n@@ -47,36 +47,36 @@ func (c *UnixConn) RemoteAddr() Addr {\n \n // SetDeadline implements the Conn SetDeadline method.\n func (c *UnixConn) SetDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UnixConn) SetReadDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n-\terr = os.EPLAN9\n+\terr = syscall.EPLAN9\n \treturn\n }\n \n // WriteTo implements the PacketConn WriteTo method.\n func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n-\terr = os.EPLAN9\n+\terr = syscall.EPLAN9\n \treturn\n }\n \n // DialUnix connects to the remote address raddr on the network net,\n // which must be \"unix\" or \"unixgram\".  If laddr is not nil, it is used\n // as the local address for the connection.\n func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // UnixListener is a Unix domain socket listener.\n@@ -87,19 +87,19 @@ type UnixListener bool\n // ListenUnix announces on the Unix domain socket laddr and returns a Unix listener.\n // Net must be \"unix\" (stream sockets).\n func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // Accept implements the Accept method in the Listener interface;\n // it waits for the next call and returns a generic Conn.\n func (l *UnixListener) Accept() (c Conn, err error) {\n-\treturn nil, os.EPLAN9\n+\treturn nil, syscall.EPLAN9\n }\n \n // Close stops listening on the Unix address.\n // Already accepted connections are not closed.\n func (l *UnixListener) Close() error {\n-\treturn os.EPLAN9\n+\treturn syscall.EPLAN9\n }\n \n // Addr returns the listener's network address."}, {"sha": "3a94cf5c5adb57cc33cc50e4dd4d0a99202d2d1a", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -59,8 +59,8 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err\n \t\tf = sockaddrToUnixpacket\n \t}\n \n-\tfd, oserr := socket(net, syscall.AF_UNIX, sotype, 0, la, ra, f)\n-\tif oserr != nil {\n+\tfd, err = socket(net, syscall.AF_UNIX, sotype, 0, la, ra, f)\n+\tif err != nil {\n \t\tgoto Error\n \t}\n \treturn fd, nil\n@@ -70,7 +70,7 @@ Error:\n \tif mode == \"listen\" {\n \t\taddr = laddr\n \t}\n-\treturn nil, &OpError{Op: mode, Net: net, Addr: addr, Err: oserr}\n+\treturn nil, &OpError{Op: mode, Net: net, Addr: addr, Err: err}\n }\n \n func sockaddrToUnix(sa syscall.Sockaddr) Addr {\n@@ -123,23 +123,23 @@ func (c *UnixConn) ok() bool { return c != nil && c.fd != nil }\n // Read implements the Conn Read method.\n func (c *UnixConn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Read(b)\n }\n \n // Write implements the Conn Write method.\n func (c *UnixConn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \treturn c.fd.Write(b)\n }\n \n // Close closes the Unix domain connection.\n func (c *UnixConn) Close() error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \terr := c.fd.Close()\n \tc.fd = nil\n@@ -168,23 +168,23 @@ func (c *UnixConn) RemoteAddr() Addr {\n // SetDeadline implements the Conn SetDeadline method.\n func (c *UnixConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n // SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UnixConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n // SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteDeadline(c.fd, t)\n }\n@@ -193,7 +193,7 @@ func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n // receive buffer associated with the connection.\n func (c *UnixConn) SetReadBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setReadBuffer(c.fd, bytes)\n }\n@@ -202,7 +202,7 @@ func (c *UnixConn) SetReadBuffer(bytes int) error {\n // transmit buffer associated with the connection.\n func (c *UnixConn) SetWriteBuffer(bytes int) error {\n \tif !c.ok() {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setWriteBuffer(c.fd, bytes)\n }\n@@ -216,7 +216,7 @@ func (c *UnixConn) SetWriteBuffer(bytes int) error {\n // see SetDeadline and SetReadDeadline.\n func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tn, sa, err := c.fd.ReadFrom(b)\n \tswitch sa := sa.(type) {\n@@ -229,7 +229,7 @@ func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error) {\n // ReadFrom implements the PacketConn ReadFrom method.\n func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, nil, os.EINVAL\n+\t\treturn 0, nil, syscall.EINVAL\n \t}\n \tn, uaddr, err := c.ReadFromUnix(b)\n \treturn n, uaddr.toAddr(), err\n@@ -243,10 +243,10 @@ func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n // On packet-oriented connections, write timeouts are rare.\n func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \tif addr.Net != sotypeToNet(c.fd.sotype) {\n-\t\treturn 0, os.EAFNOSUPPORT\n+\t\treturn 0, syscall.EAFNOSUPPORT\n \t}\n \tsa := &syscall.SockaddrUnix{Name: addr.Name}\n \treturn c.fd.WriteTo(b, sa)\n@@ -255,18 +255,18 @@ func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error) {\n // WriteTo implements the PacketConn WriteTo method.\n func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, syscall.EINVAL\n \t}\n \ta, ok := addr.(*UnixAddr)\n \tif !ok {\n-\t\treturn 0, &OpError{\"write\", c.fd.net, addr, os.EINVAL}\n+\t\treturn 0, &OpError{\"write\", c.fd.net, addr, syscall.EINVAL}\n \t}\n \treturn c.WriteToUnix(b, a)\n }\n \n func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error) {\n \tif !c.ok() {\n-\t\treturn 0, 0, 0, nil, os.EINVAL\n+\t\treturn 0, 0, 0, nil, syscall.EINVAL\n \t}\n \tn, oobn, flags, sa, err := c.fd.ReadMsg(b, oob)\n \tswitch sa := sa.(type) {\n@@ -278,11 +278,11 @@ func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAdd\n \n func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error) {\n \tif !c.ok() {\n-\t\treturn 0, 0, os.EINVAL\n+\t\treturn 0, 0, syscall.EINVAL\n \t}\n \tif addr != nil {\n \t\tif addr.Net != sotypeToNet(c.fd.sotype) {\n-\t\t\treturn 0, 0, os.EAFNOSUPPORT\n+\t\t\treturn 0, 0, syscall.EAFNOSUPPORT\n \t\t}\n \t\tsa := &syscall.SockaddrUnix{Name: addr.Name}\n \t\treturn c.fd.WriteMsg(b, oob, sa)\n@@ -339,7 +339,7 @@ func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n // and the remote address.\n func (l *UnixListener) AcceptUnix() (*UnixConn, error) {\n \tif l == nil || l.fd == nil {\n-\t\treturn nil, os.EINVAL\n+\t\treturn nil, syscall.EINVAL\n \t}\n \tfd, err := l.fd.accept(sockaddrToUnix)\n \tif err != nil {\n@@ -363,7 +363,7 @@ func (l *UnixListener) Accept() (c Conn, err error) {\n // Already accepted connections are not closed.\n func (l *UnixListener) Close() error {\n \tif l == nil || l.fd == nil {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \n \t// The operating system doesn't clean up\n@@ -391,7 +391,7 @@ func (l *UnixListener) Addr() Addr { return l.fd.laddr }\n // A zero time value disables the deadline.\n func (l *UnixListener) SetDeadline(t time.Time) (err error) {\n \tif l == nil || l.fd == nil {\n-\t\treturn os.EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \treturn setDeadline(l.fd, t)\n }"}, {"sha": "88ff7ebfef3d6ffc500568bc2f391000e5cd2163", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package URL parses URLs and implements query escaping.\n+// Package url parses URLs and implements query escaping.\n // See RFC 3986.\n package url\n \n@@ -321,19 +321,28 @@ func split(s string, c byte, cutc bool) (string, string) {\n }\n \n // Parse parses rawurl into a URL structure.\n-// The string rawurl is assumed not to have a #fragment suffix.\n-// (Web browsers strip #fragment before sending the URL to a web server.)\n // The rawurl may be relative or absolute.\n func Parse(rawurl string) (url *URL, err error) {\n-\treturn parse(rawurl, false)\n+\t// Cut off #frag\n+\tu, frag := split(rawurl, '#', true)\n+\tif url, err = parse(u, false); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif frag == \"\" {\n+\t\treturn url, nil\n+\t}\n+\tif url.Fragment, err = unescape(frag, encodeFragment); err != nil {\n+\t\treturn nil, &Error{\"parse\", rawurl, err}\n+\t}\n+\treturn url, nil\n }\n \n-// ParseRequest parses rawurl into a URL structure.  It assumes that\n-// rawurl was received from an HTTP request, so the rawurl is interpreted\n+// ParseRequestURI parses rawurl into a URL structure.  It assumes that\n+// rawurl was received in an HTTP request, so the rawurl is interpreted\n // only as an absolute URI or an absolute path.\n // The string rawurl is assumed not to have a #fragment suffix.\n // (Web browsers strip #fragment before sending the URL to a web server.)\n-func ParseRequest(rawurl string) (url *URL, err error) {\n+func ParseRequestURI(rawurl string) (url *URL, err error) {\n \treturn parse(rawurl, true)\n }\n \n@@ -415,22 +424,6 @@ func parseAuthority(authority string) (user *Userinfo, host string, err error) {\n \treturn\n }\n \n-// ParseWithReference is like Parse but allows a trailing #fragment.\n-func ParseWithReference(rawurlref string) (url *URL, err error) {\n-\t// Cut off #frag\n-\trawurl, frag := split(rawurlref, '#', true)\n-\tif url, err = Parse(rawurl); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif frag == \"\" {\n-\t\treturn url, nil\n-\t}\n-\tif url.Fragment, err = unescape(frag, encodeFragment); err != nil {\n-\t\treturn nil, &Error{\"parse\", rawurlref, err}\n-\t}\n-\treturn url, nil\n-}\n-\n // String reassembles the URL into a valid URL string.\n func (u *URL) String() string {\n \t// TODO: Rewrite to use bytes.Buffer\n@@ -589,15 +582,15 @@ func (u *URL) IsAbs() bool {\n \treturn u.Scheme != \"\"\n }\n \n-// Parse parses a URL in the context of a base URL.  The URL in ref\n+// Parse parses a URL in the context of the receiver.  The provided URL\n // may be relative or absolute.  Parse returns nil, err on parse\n // failure, otherwise its return value is the same as ResolveReference.\n-func (base *URL) Parse(ref string) (*URL, error) {\n+func (u *URL) Parse(ref string) (*URL, error) {\n \trefurl, err := Parse(ref)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn base.ResolveReference(refurl), nil\n+\treturn u.ResolveReference(refurl), nil\n }\n \n // ResolveReference resolves a URI reference to an absolute URI from\n@@ -606,13 +599,13 @@ func (base *URL) Parse(ref string) (*URL, error) {\n // URL instance, even if the returned URL is identical to either the\n // base or reference. If ref is an absolute URL, then ResolveReference\n // ignores base and returns a copy of ref.\n-func (base *URL) ResolveReference(ref *URL) *URL {\n+func (u *URL) ResolveReference(ref *URL) *URL {\n \tif ref.IsAbs() {\n \t\turl := *ref\n \t\treturn &url\n \t}\n \t// relativeURI = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n-\turl := *base\n+\turl := *u\n \turl.RawQuery = ref.RawQuery\n \turl.Fragment = ref.Fragment\n \tif ref.Opaque != \"\" {\n@@ -632,7 +625,7 @@ func (base *URL) ResolveReference(ref *URL) *URL {\n \t\turl.Path = ref.Path\n \t} else {\n \t\t// The \"rel_path\" case.\n-\t\tpath := resolvePath(base.Path, ref.Path)\n+\t\tpath := resolvePath(u.Path, ref.Path)\n \t\tif !strings.HasPrefix(path, \"/\") {\n \t\t\tpath = \"/\" + path\n \t\t}"}, {"sha": "2d911ed505a18911cdaa9b43ece9e1f8aa5abc8f", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -188,22 +188,6 @@ var urltests = []URLTest{\n \t\t},\n \t\t\"http://user:password@google.com\",\n \t},\n-}\n-\n-var urlnofragtests = []URLTest{\n-\t{\n-\t\t\"http://www.google.com/?q=go+language#foo\",\n-\t\t&URL{\n-\t\t\tScheme:   \"http\",\n-\t\t\tHost:     \"www.google.com\",\n-\t\t\tPath:     \"/\",\n-\t\t\tRawQuery: \"q=go+language#foo\",\n-\t\t},\n-\t\t\"\",\n-\t},\n-}\n-\n-var urlfragtests = []URLTest{\n \t{\n \t\t\"http://www.google.com/?q=go+language#foo\",\n \t\t&URL{\n@@ -257,12 +241,6 @@ func DoTest(t *testing.T, parse func(string) (*URL, error), name string, tests [\n \n func TestParse(t *testing.T) {\n \tDoTest(t, Parse, \"Parse\", urltests)\n-\tDoTest(t, Parse, \"Parse\", urlnofragtests)\n-}\n-\n-func TestParseWithReference(t *testing.T) {\n-\tDoTest(t, ParseWithReference, \"ParseWithReference\", urltests)\n-\tDoTest(t, ParseWithReference, \"ParseWithReference\", urlfragtests)\n }\n \n const pathThatLooksSchemeRelative = \"//not.a.user@not.a.host/just/a/path\"\n@@ -281,16 +259,16 @@ var parseRequestUrlTests = []struct {\n \t{\"../dir/\", false},\n }\n \n-func TestParseRequest(t *testing.T) {\n+func TestParseRequestURI(t *testing.T) {\n \tfor _, test := range parseRequestUrlTests {\n-\t\t_, err := ParseRequest(test.url)\n+\t\t_, err := ParseRequestURI(test.url)\n \t\tvalid := err == nil\n \t\tif valid != test.expectedValid {\n \t\t\tt.Errorf(\"Expected valid=%v for %q; got %v\", test.expectedValid, test.url, valid)\n \t\t}\n \t}\n \n-\turl, err := ParseRequest(pathThatLooksSchemeRelative)\n+\turl, err := ParseRequestURI(pathThatLooksSchemeRelative)\n \tif err != nil {\n \t\tt.Fatalf(\"Unexpected error %v\", err)\n \t}\n@@ -319,9 +297,6 @@ func DoTestString(t *testing.T, parse func(string) (*URL, error), name string, t\n \n func TestURLString(t *testing.T) {\n \tDoTestString(t, Parse, \"Parse\", urltests)\n-\tDoTestString(t, Parse, \"Parse\", urlnofragtests)\n-\tDoTestString(t, ParseWithReference, \"ParseWithReference\", urltests)\n-\tDoTestString(t, ParseWithReference, \"ParseWithReference\", urlfragtests)\n }\n \n type EscapeTest struct {\n@@ -538,7 +513,7 @@ var resolveReferenceTests = []struct {\n \n func TestResolveReference(t *testing.T) {\n \tmustParse := func(url string) *URL {\n-\t\tu, err := ParseWithReference(url)\n+\t\tu, err := Parse(url)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Expected URL to parse: %q, got error: %v\", url, err)\n \t\t}\n@@ -589,7 +564,7 @@ func TestResolveReference(t *testing.T) {\n \n func TestResolveReferenceOpaque(t *testing.T) {\n \tmustParse := func(url string) *URL {\n-\t\tu, err := ParseWithReference(url)\n+\t\tu, err := Parse(url)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Expected URL to parse: %q, got error: %v\", url, err)\n \t\t}"}, {"sha": "9a7c076d59c92303caa0001ba56288ef263ca7d8", "filename": "libgo/go/old/netchan/netchan_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fold%2Fnetchan%2Fnetchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fold%2Fnetchan%2Fnetchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fnetchan_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -291,6 +291,10 @@ func exportLoopback(exp *Exporter, t *testing.T) {\n // This test checks that channel operations can proceed\n // even when other concurrent operations are blocked.\n func TestIndependentSends(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"disabled test during -short\")\n+\t\treturn\n+\t}\n \texp, imp := pair(t)\n \n \texportLoopback(exp, t)\n@@ -378,6 +382,10 @@ const flowCount = 100\n \n // test flow control from exporter to importer.\n func TestExportFlowControl(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"disabled test during -short\")\n+\t\treturn\n+\t}\n \texp, imp := pair(t)\n \n \tsendDone := make(chan bool, 1)\n@@ -394,6 +402,10 @@ func TestExportFlowControl(t *testing.T) {\n \n // test flow control from importer to exporter.\n func TestImportFlowControl(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"disabled test during -short\")\n+\t\treturn\n+\t}\n \texp, imp := pair(t)\n \n \tch := make(chan int)"}, {"sha": "7fa4c7f4449b88781dc940ff5b3853bbed068f01", "filename": "libgo/go/os/dir_plan9.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,6 +10,9 @@ import (\n \t\"syscall\"\n )\n \n+var errShortStat = errors.New(\"short stat message\")\n+var errBadStat = errors.New(\"bad stat message format\")\n+\n func (file *File) readdir(n int) (fi []FileInfo, err error) {\n \t// If this file has no dirinfo, create one.\n \tif file.dirinfo == nil {\n@@ -35,15 +38,15 @@ func (file *File) readdir(n int) (fi []FileInfo, err error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif d.nbuf < syscall.STATFIXLEN {\n-\t\t\t\treturn result, &PathError{\"readdir\", file.name, Eshortstat}\n+\t\t\t\treturn result, &PathError{\"readdir\", file.name, errShortStat}\n \t\t\t}\n \t\t}\n \n \t\t// Get a record from buffer\n \t\tm, _ := gbit16(d.buf[d.bufp:])\n \t\tm += 2\n \t\tif m < syscall.STATFIXLEN {\n-\t\t\treturn result, &PathError{\"readdir\", file.name, Eshortstat}\n+\t\t\treturn result, &PathError{\"readdir\", file.name, errShortStat}\n \t\t}\n \t\tdir, e := UnmarshalDir(d.buf[d.bufp : d.bufp+int(m)])\n \t\tif e != nil {\n@@ -138,7 +141,7 @@ func UnmarshalDir(b []byte) (d *Dir, err error) {\n \tn, b = gbit16(b)\n \n \tif int(n) != len(b) {\n-\t\treturn nil, Ebadstat\n+\t\treturn nil, errBadStat\n \t}\n \n \td = new(Dir)\n@@ -155,7 +158,7 @@ func UnmarshalDir(b []byte) (d *Dir, err error) {\n \td.Muid, b = gstring(b)\n \n \tif len(b) != 0 {\n-\t\treturn nil, Ebadstat\n+\t\treturn nil, errBadStat\n \t}\n \n \treturn d, nil"}, {"sha": "eb265f24138f2337028a602e9e58c4a7c0e19793", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,10 +6,7 @@\n \n package os\n \n-import (\n-\t\"errors\"\n-\t\"syscall\"\n-)\n+import \"syscall\"\n \n // Expand replaces ${var} or $var in the string based on the mapping function.\n // Invocations of undefined variables are replaced with the empty string.\n@@ -77,26 +74,10 @@ func getShellName(s string) (string, int) {\n \treturn s[:i], i\n }\n \n-// ENOENV is the error indicating that an environment variable does not exist.\n-var ENOENV = errors.New(\"no such environment variable\")\n-\n-// Getenverror retrieves the value of the environment variable named by the key.\n-// It returns the value and an error, if any.\n-func Getenverror(key string) (value string, err error) {\n-\tif len(key) == 0 {\n-\t\treturn \"\", EINVAL\n-\t}\n-\tval, found := syscall.Getenv(key)\n-\tif !found {\n-\t\treturn \"\", ENOENV\n-\t}\n-\treturn val, nil\n-}\n-\n // Getenv retrieves the value of the environment variable named by the key.\n // It returns the value, which will be empty if the variable is not present.\n func Getenv(key string) string {\n-\tv, _ := Getenverror(key)\n+\tv, _ := syscall.Getenv(key)\n \treturn v\n }\n "}, {"sha": "e0b83b5c22cabf46a586d0235fa036f179b17ae9", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,6 +4,18 @@\n \n package os\n \n+import (\n+\t\"errors\"\n+)\n+\n+// Portable analogs of some common system call errors.\n+var (\n+\tErrInvalid    = errors.New(\"invalid argument\")\n+\tErrPermission = errors.New(\"permission denied\")\n+\tErrExist      = errors.New(\"file already exists\")\n+\tErrNotExist   = errors.New(\"file does not exist\")\n+)\n+\n // PathError records an error and the operation and file path that caused it.\n type PathError struct {\n \tOp   string"}, {"sha": "159d685e7cdb845b09212cfa3ae96ea657c37fd8", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,34 +4,38 @@\n \n package os\n \n-import (\n-\t\"errors\"\n-\t\"syscall\"\n-)\n+// IsExist returns whether the error is known to report that a file already exists.\n+func IsExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn contains(err.Error(), \" exists\")\n+}\n \n-var (\n-\tEshortstat = errors.New(\"stat buffer too small\")\n-\tEbadstat   = errors.New(\"malformed stat buffer\")\n-\tEbadfd     = errors.New(\"fd out of range or not open\")\n-\tEbadarg    = errors.New(\"bad arg in system call\")\n-\tEnotdir    = errors.New(\"not a directory\")\n-\tEnonexist  = errors.New(\"file does not exist\")\n-\tEexist     = errors.New(\"file already exists\")\n-\tEio        = errors.New(\"i/o error\")\n-\tEperm      = errors.New(\"permission denied\")\n+// IsNotExist returns whether the error is known to report that a file does not exist.\n+func IsNotExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn contains(err.Error(), \"does not exist\")\n+}\n \n-\tEINVAL  = Ebadarg\n-\tENOTDIR = Enotdir\n-\tENOENT  = Enonexist\n-\tEEXIST  = Eexist\n-\tEIO     = Eio\n-\tEACCES  = Eperm\n-\tEPERM   = Eperm\n-\tEISDIR  = syscall.EISDIR\n+// IsPermission returns whether the error is known to report that permission is denied.\n+func IsPermission(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn contains(err.Error(), \"permission denied\")\n+}\n \n-\tEBADF        = errors.New(\"bad file descriptor\")\n-\tENAMETOOLONG = errors.New(\"file name too long\")\n-\tERANGE       = errors.New(\"math result not representable\")\n-\tEPIPE        = errors.New(\"Broken Pipe\")\n-\tEPLAN9       = errors.New(\"not supported by plan 9\")\n-)\n+// contains is a local version of strings.Contains. It knows len(sep) > 1.\n+func contains(s, sep string) bool {\n+\tn := len(sep)\n+\tc := sep[0]\n+\tfor i := 0; i+n <= len(s); i++ {\n+\t\tif s[i] == c && s[i:i+n] == sep {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "74b75d1121836500e47365219e6f55b78ce87b67", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,44 +8,29 @@ package os\n \n import \"syscall\"\n \n-// Commonly known Unix errors.\n-var (\n-\tEPERM        error = syscall.EPERM\n-\tENOENT       error = syscall.ENOENT\n-\tESRCH        error = syscall.ESRCH\n-\tEINTR        error = syscall.EINTR\n-\tEIO          error = syscall.EIO\n-\tE2BIG        error = syscall.E2BIG\n-\tENOEXEC      error = syscall.ENOEXEC\n-\tEBADF        error = syscall.EBADF\n-\tECHILD       error = syscall.ECHILD\n-\tEDEADLK      error = syscall.EDEADLK\n-\tENOMEM       error = syscall.ENOMEM\n-\tEACCES       error = syscall.EACCES\n-\tEFAULT       error = syscall.EFAULT\n-\tEBUSY        error = syscall.EBUSY\n-\tEEXIST       error = syscall.EEXIST\n-\tEXDEV        error = syscall.EXDEV\n-\tENODEV       error = syscall.ENODEV\n-\tENOTDIR      error = syscall.ENOTDIR\n-\tEISDIR       error = syscall.EISDIR\n-\tEINVAL       error = syscall.EINVAL\n-\tENFILE       error = syscall.ENFILE\n-\tEMFILE       error = syscall.EMFILE\n-\tENOTTY       error = syscall.ENOTTY\n-\tEFBIG        error = syscall.EFBIG\n-\tENOSPC       error = syscall.ENOSPC\n-\tESPIPE       error = syscall.ESPIPE\n-\tEROFS        error = syscall.EROFS\n-\tEMLINK       error = syscall.EMLINK\n-\tEPIPE        error = syscall.EPIPE\n-\tEAGAIN       error = syscall.EAGAIN\n-\tEDOM         error = syscall.EDOM\n-\tERANGE       error = syscall.ERANGE\n-\tEADDRINUSE   error = syscall.EADDRINUSE\n-\tECONNREFUSED error = syscall.ECONNREFUSED\n-\tENAMETOOLONG error = syscall.ENAMETOOLONG\n-\tEAFNOSUPPORT error = syscall.EAFNOSUPPORT\n-\tETIMEDOUT    error = syscall.ETIMEDOUT\n-\tENOTCONN     error = syscall.ENOTCONN\n-)\n+// IsExist returns whether the error is known to report that a file already exists.\n+// It is satisfied by ErrExist as well as some syscall errors.\n+func IsExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.EEXIST || err == ErrExist\n+}\n+\n+// IsNotExist returns whether the error is known to report that a file does not exist.\n+// It is satisfied by ErrNotExist as well as some syscall errors.\n+func IsNotExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.ENOENT || err == ErrNotExist\n+}\n+\n+// IsPermission returns whether the error is known to report that permission is denied.\n+// It is satisfied by ErrPermission as well as some syscall errors.\n+func IsPermission(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.EACCES || err == syscall.EPERM || err == ErrPermission\n+}"}, {"sha": "ebe92a9fba39344c24c2c4350bc5870da6ed9413", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -79,9 +79,9 @@ type Cmd struct {\n \t// Process is the underlying process, once started.\n \tProcess *os.Process\n \n-\t// Waitmsg contains information about an exited process,\n+\t// ProcessState contains information about an exited process,\n \t// available after a call to Wait or Run.\n-\tWaitmsg *os.Waitmsg\n+\tProcessState *os.ProcessState\n \n \terr             error // last error (from LookPath, stdin, stdout, stderr)\n \tfinished        bool  // when Wait was called\n@@ -266,11 +266,11 @@ func (c *Cmd) Start() error {\n \n // An ExitError reports an unsuccessful exit by a command.\n type ExitError struct {\n-\t*os.Waitmsg\n+\t*os.ProcessState\n }\n \n func (e *ExitError) Error() string {\n-\treturn e.Waitmsg.String()\n+\treturn e.ProcessState.String()\n }\n \n // Wait waits for the command to exit.\n@@ -291,8 +291,8 @@ func (c *Cmd) Wait() error {\n \t\treturn errors.New(\"exec: Wait was already called\")\n \t}\n \tc.finished = true\n-\tmsg, err := c.Process.Wait(0)\n-\tc.Waitmsg = msg\n+\tstate, err := c.Process.Wait()\n+\tc.ProcessState = state\n \n \tvar copyError error\n \tfor _ = range c.goroutine {\n@@ -307,8 +307,8 @@ func (c *Cmd) Wait() error {\n \n \tif err != nil {\n \t\treturn err\n-\t} else if !msg.Exited() || msg.ExitStatus() != 0 {\n-\t\treturn &ExitError{msg}\n+\t} else if !state.Success() {\n+\t\treturn &ExitError{state}\n \t}\n \n \treturn copyError"}, {"sha": "0e229e03ee7045d0c20cab18db97946bdc9dda8d", "filename": "libgo/go/os/exec/lp_plan9.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"errors\"\n \t\"os\"\n \t\"strings\"\n+\t\"syscall\"\n )\n \n // ErrNotFound is the error resulting if a path search failed to find an executable file.\n@@ -21,7 +22,7 @@ func findExecutable(file string) error {\n \tif m := d.Mode(); !m.IsDir() && m&0111 != 0 {\n \t\treturn nil\n \t}\n-\treturn os.EPERM\n+\treturn syscall.EPERM\n }\n \n // LookPath searches for an executable binary named file"}, {"sha": "21632219972b365fd60af78674e2797dc38d3dec", "filename": "libgo/go/os/exec/lp_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -23,7 +23,7 @@ func findExecutable(file string) error {\n \tif m := d.Mode(); !m.IsDir() && m&0111 != 0 {\n \t\treturn nil\n \t}\n-\treturn os.EPERM\n+\treturn os.ErrPermission\n }\n \n // LookPath searches for an executable binary named file"}, {"sha": "d8351d7e6d39408f36406c4da367e561e89d22fa", "filename": "libgo/go/os/exec/lp_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -19,7 +19,7 @@ func chkStat(file string) error {\n \t\treturn err\n \t}\n \tif d.IsDir() {\n-\t\treturn os.EPERM\n+\t\treturn os.ErrPermission\n \t}\n \treturn nil\n }\n@@ -39,7 +39,7 @@ func findExecutable(file string, exts []string) (string, error) {\n \t\t\treturn f, nil\n \t\t}\n \t}\n-\treturn ``, os.ENOENT\n+\treturn ``, os.ErrNotExist\n }\n \n // LookPath searches for an executable binary named file"}, {"sha": "1c9e2b997f8d4192e70d980124987f90ea460cf7", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"errors\"\n \t\"runtime\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n // StartProcess starts a new process with the program, arguments and attributes\n@@ -20,18 +21,10 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \t\tSys: attr.Sys,\n \t}\n \n-\t// Create array of integer (system) fds.\n-\tintfd := make([]int, len(attr.Files))\n-\tfor i, f := range attr.Files {\n-\t\tif f == nil {\n-\t\t\tintfd[i] = -1\n-\t\t} else {\n-\t\t\tintfd[i] = f.Fd()\n-\t\t}\n+\tfor _, f := range attr.Files {\n+\t\tsysattr.Files = append(sysattr.Files, f.Fd())\n \t}\n \n-\tsysattr.Files = intfd\n-\n \tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n \tif e != nil {\n \t\treturn nil, &PathError{\"fork/exec\", name, e}\n@@ -72,19 +65,13 @@ func (p *Process) Kill() error {\n \treturn e\n }\n \n-// Waitmsg stores the information about an exited process as reported by Wait.\n-type Waitmsg struct {\n-\tsyscall.Waitmsg\n-}\n-\n // Wait waits for the Process to exit or stop, and then returns a\n-// Waitmsg describing its status and an error, if any. The options\n-// (WNOHANG etc.) affect the behavior of the Wait call.\n-func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n+// ProcessState describing its status and an error, if any.\n+func (p *Process) Wait() (ps *ProcessState, err error) {\n \tvar waitmsg syscall.Waitmsg\n \n \tif p.Pid == -1 {\n-\t\treturn nil, EINVAL\n+\t\treturn nil, ErrInvalid\n \t}\n \n \tfor true {\n@@ -100,21 +87,11 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \t\t}\n \t}\n \n-\treturn &Waitmsg{waitmsg}, nil\n-}\n-\n-// Wait waits for process pid to exit or stop, and then returns a\n-// Waitmsg describing its status and an error, if any. The options\n-// (WNOHANG etc.) affect the behavior of the Wait call.\n-// Wait is equivalent to calling FindProcess and then Wait\n-// and Release on the result.\n-func Wait(pid int, options int) (w *Waitmsg, err error) {\n-\tp, e := FindProcess(pid)\n-\tif e != nil {\n-\t\treturn nil, e\n+\tps = &ProcessState{\n+\t\tpid:    waitmsg.Pid,\n+\t\tstatus: &waitmsg,\n \t}\n-\tdefer p.Release()\n-\treturn p.Wait(options)\n+\treturn ps, nil\n }\n \n // Release releases any resources associated with the Process.\n@@ -131,9 +108,57 @@ func findProcess(pid int) (p *Process, err error) {\n \treturn newProcess(pid, 0), nil\n }\n \n-func (w *Waitmsg) String() string {\n-\tif w == nil {\n+// ProcessState stores information about process as reported by Wait.\n+type ProcessState struct {\n+\tpid    int              // The process's id.\n+\tstatus *syscall.Waitmsg // System-dependent status info.\n+}\n+\n+// Pid returns the process id of the exited process.\n+func (p *ProcessState) Pid() int {\n+\treturn p.pid\n+}\n+\n+// Exited returns whether the program has exited.\n+func (p *ProcessState) Exited() bool {\n+\treturn p.status.Exited()\n+}\n+\n+// Success reports whether the program exited successfully,\n+// such as with exit status 0 on Unix.\n+func (p *ProcessState) Success() bool {\n+\treturn p.status.ExitStatus() == 0\n+}\n+\n+// Sys returns system-dependent exit information about\n+// the process.  Convert it to the appropriate underlying\n+// type, such as *syscall.Waitmsg on Plan 9, to access its contents.\n+func (p *ProcessState) Sys() interface{} {\n+\treturn p.status\n+}\n+\n+// SysUsage returns system-dependent resource usage information about\n+// the exited process.  Convert it to the appropriate underlying\n+// type, such as *syscall.Waitmsg on Plan 9, to access its contents.\n+func (p *ProcessState) SysUsage() interface{} {\n+\treturn p.status\n+}\n+\n+// UserTime returns the user CPU time of the exited process and its children.\n+// It is always reported as 0 on Windows.\n+func (p *ProcessState) UserTime() time.Duration {\n+\treturn time.Duration(p.status.Time[0]) * time.Millisecond\n+}\n+\n+// SystemTime returns the system CPU time of the exited process and its children.\n+// It is always reported as 0 on Windows.\n+func (p *ProcessState) SystemTime() time.Duration {\n+\treturn time.Duration(p.status.Time[1]) * time.Millisecond\n+}\n+\n+func (p *ProcessState) String() string {\n+\tif p == nil {\n \t\treturn \"<nil>\"\n \t}\n-\treturn \"exit status: \" + w.Msg\n+\treturn \"exit status: \" + p.status.Msg\n }"}, {"sha": "4a75cb67fb5ef35cecd357aebb2144630405546b", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -42,32 +42,41 @@ func (p *Process) Kill() error {\n \treturn p.Signal(Kill)\n }\n \n-// TODO(rsc): Should os implement its own syscall.WaitStatus\n-// wrapper with the methods, or is exposing the underlying one enough?\n-//\n-// TODO(rsc): Certainly need to have Rusage struct,\n-// since syscall one might have different field types across\n-// different OS.\n-\n-// Waitmsg stores the information about an exited process as reported by Wait.\n-type Waitmsg struct {\n-\tPid                int             // The process's id.\n-\tsyscall.WaitStatus                 // System-dependent status info.\n-\tRusage             *syscall.Rusage // System-dependent resource usage info.\n+// ProcessState stores information about process as reported by Wait.\n+type ProcessState struct {\n+\tpid    int                // The process's id.\n+\tstatus syscall.WaitStatus // System-dependent status info.\n+\trusage *syscall.Rusage\n }\n \n-// Wait waits for process pid to exit or stop, and then returns a\n-// Waitmsg describing its status and an error, if any. The options\n-// (WNOHANG etc.) affect the behavior of the Wait call.\n-// Wait is equivalent to calling FindProcess and then Wait\n-// and Release on the result.\n-func Wait(pid int, options int) (w *Waitmsg, err error) {\n-\tp, e := FindProcess(pid)\n-\tif e != nil {\n-\t\treturn nil, e\n-\t}\n-\tdefer p.Release()\n-\treturn p.Wait(options)\n+// Pid returns the process id of the exited process.\n+func (p *ProcessState) Pid() int {\n+\treturn p.pid\n+}\n+\n+// Exited returns whether the program has exited.\n+func (p *ProcessState) Exited() bool {\n+\treturn p.status.Exited()\n+}\n+\n+// Success reports whether the program exited successfully,\n+// such as with exit status 0 on Unix.\n+func (p *ProcessState) Success() bool {\n+\treturn p.status.ExitStatus() == 0\n+}\n+\n+// Sys returns system-dependent exit information about\n+// the process.  Convert it to the appropriate underlying\n+// type, such as syscall.WaitStatus on Unix, to access its contents.\n+func (p *ProcessState) Sys() interface{} {\n+\treturn p.status\n+}\n+\n+// SysUsage returns system-dependent resource usage information about\n+// the exited process.  Convert it to the appropriate underlying\n+// type, such as *syscall.Rusage on Unix, to access its contents.\n+func (p *ProcessState) SysUsage() interface{} {\n+\treturn p.rusage\n }\n \n // Convert i to decimal string.\n@@ -97,26 +106,26 @@ func itod(i int) string {\n \treturn string(b[bp:])\n }\n \n-func (w *Waitmsg) String() string {\n-\tif w == nil {\n+func (p *ProcessState) String() string {\n+\tif p == nil {\n \t\treturn \"<nil>\"\n \t}\n-\t// TODO(austin) Use signal names when possible?\n+\tstatus := p.Sys().(syscall.WaitStatus)\n \tres := \"\"\n \tswitch {\n-\tcase w.Exited():\n-\t\tres = \"exit status \" + itod(w.ExitStatus())\n-\tcase w.Signaled():\n-\t\tres = \"signal \" + itod(int(w.Signal()))\n-\tcase w.Stopped():\n-\t\tres = \"stop signal \" + itod(int(w.StopSignal()))\n-\t\tif w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {\n-\t\t\tres += \" (trap \" + itod(w.TrapCause()) + \")\"\n+\tcase status.Exited():\n+\t\tres = \"exit status \" + itod(status.ExitStatus())\n+\tcase status.Signaled():\n+\t\tres = \"signal \" + itod(int(status.Signal()))\n+\tcase status.Stopped():\n+\t\tres = \"stop signal \" + itod(int(status.StopSignal()))\n+\t\tif status.StopSignal() == syscall.SIGTRAP && status.TrapCause() != 0 {\n+\t\t\tres += \" (trap \" + itod(status.TrapCause()) + \")\"\n \t\t}\n-\tcase w.Continued():\n+\tcase status.Continued():\n \t\tres = \"continued\"\n \t}\n-\tif w.CoreDump() {\n+\tif status.CoreDump() {\n \t\tres += \" (core dumped)\"\n \t}\n \treturn res"}, {"sha": "8d000e9ef15e6e1107e8477df59d70711af89afe", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,46 +10,30 @@ import (\n \t\"errors\"\n \t\"runtime\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n-// Options for Wait.\n-const (\n-\tWNOHANG   = syscall.WNOHANG   // Don't wait if no process has exited.\n-\tWSTOPPED  = syscall.WSTOPPED  // If set, status of stopped subprocesses is also reported.\n-\tWUNTRACED = syscall.WUNTRACED // Usually an alias for WSTOPPED.\n-\tWRUSAGE   = 1 << 20           // Record resource usage.\n-)\n-\n-// WRUSAGE must not be too high a bit, to avoid clashing with Linux's\n-// WCLONE, WALL, and WNOTHREAD flags, which sit in the top few bits of\n-// the options\n-\n // Wait waits for the Process to exit or stop, and then returns a\n-// Waitmsg describing its status and an error, if any. The options\n-// (WNOHANG etc.) affect the behavior of the Wait call.\n-func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n+// ProcessState describing its status and an error, if any.\n+func (p *Process) Wait() (ps *ProcessState, err error) {\n \tif p.Pid == -1 {\n-\t\treturn nil, EINVAL\n+\t\treturn nil, syscall.EINVAL\n \t}\n \tvar status syscall.WaitStatus\n-\tvar rusage *syscall.Rusage\n-\tif options&WRUSAGE != 0 {\n-\t\trusage = new(syscall.Rusage)\n-\t\toptions ^= WRUSAGE\n-\t}\n-\tpid1, e := syscall.Wait4(p.Pid, &status, options, rusage)\n+\tvar rusage syscall.Rusage\n+\tpid1, e := syscall.Wait4(p.Pid, &status, 0, &rusage)\n \tif e != nil {\n \t\treturn nil, NewSyscallError(\"wait\", e)\n \t}\n-\t// With WNOHANG pid is 0 if child has not exited.\n-\tif pid1 != 0 && options&WSTOPPED == 0 {\n+\tif pid1 != 0 {\n \t\tp.done = true\n \t}\n-\tw = new(Waitmsg)\n-\tw.Pid = pid1\n-\tw.WaitStatus = status\n-\tw.Rusage = rusage\n-\treturn w, nil\n+\tps = &ProcessState{\n+\t\tpid:    pid1,\n+\t\tstatus: status,\n+\t\trusage: &rusage,\n+\t}\n+\treturn ps, nil\n }\n \n // Signal sends a signal to the Process.\n@@ -80,3 +64,13 @@ func findProcess(pid int) (p *Process, err error) {\n \t// NOOP for unix.\n \treturn newProcess(pid, 0), nil\n }\n+\n+// UserTime returns the user CPU time of the exited process and its children.\n+func (p *ProcessState) UserTime() time.Duration {\n+\treturn time.Duration(p.rusage.Utime.Nano()) * time.Nanosecond\n+}\n+\n+// SystemTime returns the system CPU time of the exited process and its children.\n+func (p *ProcessState) SystemTime() time.Duration {\n+\treturn time.Duration(p.rusage.Stime.Nano()) * time.Nanosecond\n+}"}, {"sha": "dab0dc97571c7c185e34b8cae4eed96f1771f5d2", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,12 +8,13 @@ import (\n \t\"errors\"\n \t\"runtime\"\n \t\"syscall\"\n+\t\"time\"\n \t\"unsafe\"\n )\n \n // Wait waits for the Process to exit or stop, and then returns a\n-// Waitmsg describing its status and an error, if any.\n-func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n+// ProcessState describing its status and an error, if any.\n+func (p *Process) Wait() (ps *ProcessState, err error) {\n \ts, e := syscall.WaitForSingleObject(syscall.Handle(p.handle), syscall.INFINITE)\n \tswitch s {\n \tcase syscall.WAIT_OBJECT_0:\n@@ -29,7 +30,7 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \t\treturn nil, NewSyscallError(\"GetExitCodeProcess\", e)\n \t}\n \tp.done = true\n-\treturn &Waitmsg{p.Pid, syscall.WaitStatus{Status: s, ExitCode: ec}, new(syscall.Rusage)}, nil\n+\treturn &ProcessState{p.Pid, syscall.WaitStatus{Status: s, ExitCode: ec}, new(syscall.Rusage)}, nil\n }\n \n // Signal sends a signal to the Process.\n@@ -48,7 +49,7 @@ func (p *Process) Signal(sig Signal) error {\n // Release releases any resources associated with the Process.\n func (p *Process) Release() error {\n \tif p.handle == uintptr(syscall.InvalidHandle) {\n-\t\treturn EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \te := syscall.CloseHandle(syscall.Handle(p.handle))\n \tif e != nil {\n@@ -83,3 +84,15 @@ func init() {\n \t\tArgs[i] = string(syscall.UTF16ToString((*v)[:]))\n \t}\n }\n+\n+// UserTime returns the user CPU time of the exited process and its children.\n+// For now, it is always reported as 0 on Windows.\n+func (p *ProcessState) UserTime() time.Duration {\n+\treturn 0\n+}\n+\n+// SystemTime returns the system CPU time of the exited process and its children.\n+// For now, it is always reported as 0 on Windows.\n+func (p *ProcessState) SystemTime() time.Duration {\n+\treturn 0\n+}"}, {"sha": "1c3d0172d3433c0021b0bfa246d969f340f13a97", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -7,11 +7,33 @@\n // Go-like; failing calls return values of type error rather than error numbers.\n // Often, more information is available within the error. For example,\n // if a call that takes a file name fails, such as Open or Stat, the error\n-// will include failing file name when printed and will be of type *PathError,\n-// which may be unpacked for more information.\n+// will include the failing file name when printed and will be of type\n+// *PathError, which may be unpacked for more information.\n // \n // The os interface is intended to be uniform across all operating systems.\n // Features not generally available appear in the system-specific package syscall.\n+//\n+// Here is a simple example, opening a file and reading some of it.\n+//\n+//\tfile, err := os.Open(\"file.go\") // For read access.\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\n+// If the open fails, the error string will be self-explanatory, like\n+//\n+//\topen file.go: no such file or directory\n+//\n+// The file's data can then be read into a slice of bytes. Read and\n+// Write take their byte counts from the length of the artument slice.\n+//\n+//\tdata := make([]byte, 100)\n+//\tcount, err := file.Read(data)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n+//\n package os\n \n import (\n@@ -50,12 +72,25 @@ const (\n \tSEEK_END int = 2 // seek relative to the end\n )\n \n+// LinkError records an error during a link or symlink or rename\n+// system call and the paths that caused it.\n+type LinkError struct {\n+\tOp  string\n+\tOld string\n+\tNew string\n+\tErr error\n+}\n+\n+func (e *LinkError) Error() string {\n+\treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Err.Error()\n+}\n+\n // Read reads up to len(b) bytes from the File.\n // It returns the number of bytes read and an error, if any.\n // EOF is signaled by a zero count with err set to io.EOF.\n func (f *File) Read(b []byte) (n int, err error) {\n \tif f == nil {\n-\t\treturn 0, EINVAL\n+\t\treturn 0, ErrInvalid\n \t}\n \tn, e := f.read(b)\n \tif n < 0 {\n@@ -76,7 +111,7 @@ func (f *File) Read(b []byte) (n int, err error) {\n // At end of file, that error is io.EOF.\n func (f *File) ReadAt(b []byte, off int64) (n int, err error) {\n \tif f == nil {\n-\t\treturn 0, EINVAL\n+\t\treturn 0, ErrInvalid\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := f.pread(b, off)\n@@ -99,7 +134,7 @@ func (f *File) ReadAt(b []byte, off int64) (n int, err error) {\n // Write returns a non-nil error when n != len(b).\n func (f *File) Write(b []byte) (n int, err error) {\n \tif f == nil {\n-\t\treturn 0, EINVAL\n+\t\treturn 0, ErrInvalid\n \t}\n \tn, e := f.write(b)\n \tif n < 0 {\n@@ -119,7 +154,7 @@ func (f *File) Write(b []byte) (n int, err error) {\n // WriteAt returns a non-nil error when n != len(b).\n func (f *File) WriteAt(b []byte, off int64) (n int, err error) {\n \tif f == nil {\n-\t\treturn 0, EINVAL\n+\t\treturn 0, ErrInvalid\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := f.pwrite(b, off)\n@@ -153,7 +188,7 @@ func (f *File) Seek(offset int64, whence int) (ret int64, err error) {\n // an array of bytes.\n func (f *File) WriteString(s string) (ret int, err error) {\n \tif f == nil {\n-\t\treturn 0, EINVAL\n+\t\treturn 0, ErrInvalid\n \t}\n \treturn f.Write([]byte(s))\n }"}, {"sha": "cb0e9ef9289871690388086c6f328fdbb3e21216", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -5,11 +5,14 @@\n package os\n \n import (\n+\t\"errors\"\n \t\"runtime\"\n \t\"syscall\"\n \t\"time\"\n )\n \n+var ErrPlan9 = errors.New(\"unimplemented on Plan 9\")\n+\n // File represents an open file descriptor.\n type File struct {\n \t*file\n@@ -26,19 +29,20 @@ type file struct {\n }\n \n // Fd returns the integer Unix file descriptor referencing the open file.\n-func (file *File) Fd() int {\n-\tif file == nil {\n-\t\treturn -1\n+func (f *File) Fd() uintptr {\n+\tif f == nil {\n+\t\treturn ^(uintptr(0))\n \t}\n-\treturn file.fd\n+\treturn uintptr(f.fd)\n }\n \n // NewFile returns a new File with the given file descriptor and name.\n-func NewFile(fd int, name string) *File {\n-\tif fd < 0 {\n+func NewFile(fd uintptr, name string) *File {\n+\tfdi := int(fd)\n+\tif fdi < 0 {\n \t\treturn nil\n \t}\n-\tf := &File{&file{fd: fd, name: name}}\n+\tf := &File{&file{fd: fdi, name: name}}\n \truntime.SetFinalizer(f.file, (*file).close)\n \treturn f\n }\n@@ -128,7 +132,7 @@ func OpenFile(name string, flag int, perm FileMode) (file *File, err error) {\n \t\t}\n \t}\n \n-\treturn NewFile(fd, name), nil\n+\treturn NewFile(uintptr(fd), name), nil\n }\n \n // Close closes the File, rendering it unusable for I/O.\n@@ -139,7 +143,7 @@ func (file *File) Close() error {\n \n func (file *file) close() error {\n \tif file == nil || file.fd < 0 {\n-\t\treturn Ebadfd\n+\t\treturn ErrInvalid\n \t}\n \tvar err error\n \tsyscall.ForkLock.RLock()\n@@ -202,7 +206,7 @@ func (f *File) Chmod(mode FileMode) error {\n // of recently written data to disk.\n func (f *File) Sync() (err error) {\n \tif f == nil {\n-\t\treturn EINVAL\n+\t\treturn ErrInvalid\n \t}\n \n \tvar d Dir\n@@ -272,7 +276,6 @@ func Remove(name string) error {\n }\n \n // Rename renames a file.\n-// If there is an error, it will be of type *PathError.\n func Rename(oldname, newname string) error {\n \tvar d Dir\n \td.Null()\n@@ -330,34 +333,37 @@ func Pipe() (r *File, w *File, err error) {\n \t}\n \tsyscall.ForkLock.RUnlock()\n \n-\treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n+\treturn NewFile(uintptr(p[0]), \"|0\"), NewFile(uintptr(p[1]), \"|1\"), nil\n }\n \n // not supported on Plan 9\n \n // Link creates a hard link.\n+// If there is an error, it will be of type *LinkError.\n func Link(oldname, newname string) error {\n-\treturn EPLAN9\n+\treturn &LinkError{\"link\", oldname, newname, ErrPlan9}\n }\n \n+// Symlink creates newname as a symbolic link to oldname.\n+// If there is an error, it will be of type *LinkError.\n func Symlink(oldname, newname string) error {\n-\treturn EPLAN9\n+\treturn &LinkError{\"symlink\", oldname, newname, ErrPlan9}\n }\n \n func Readlink(name string) (string, error) {\n-\treturn \"\", EPLAN9\n+\treturn \"\", ErrPlan9\n }\n \n func Chown(name string, uid, gid int) error {\n-\treturn EPLAN9\n+\treturn ErrPlan9\n }\n \n func Lchown(name string, uid, gid int) error {\n-\treturn EPLAN9\n+\treturn ErrPlan9\n }\n \n func (f *File) Chown(uid, gid int) error {\n-\treturn EPLAN9\n+\treturn ErrPlan9\n }\n \n // TempDir returns the default directory to use for temporary files."}, {"sha": "073bd56a471d4bb21b1f7dc55620c11ac8565cf5", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -24,20 +24,8 @@ func epipecheck(file *File, e error) {\n \t}\n }\n \n-// LinkError records an error during a link or symlink or rename\n-// system call and the paths that caused it.\n-type LinkError struct {\n-\tOp  string\n-\tOld string\n-\tNew string\n-\tErr error\n-}\n-\n-func (e *LinkError) Error() string {\n-\treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Err.Error()\n-}\n-\n // Link creates newname as a hard link to the oldname file.\n+// If there is an error, it will be of type *LinkError.\n func Link(oldname, newname string) error {\n \te := syscall.Link(oldname, newname)\n \tif e != nil {\n@@ -47,6 +35,7 @@ func Link(oldname, newname string) error {\n }\n \n // Symlink creates newname as a symbolic link to oldname.\n+// If there is an error, it will be of type *LinkError.\n func Symlink(oldname, newname string) error {\n \te := syscall.Symlink(oldname, newname)\n \tif e != nil {\n@@ -160,7 +149,7 @@ func (f *File) Truncate(size int64) error {\n // of recently written data to disk.\n func (f *File) Sync() (err error) {\n \tif f == nil {\n-\t\treturn EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \tif e := syscall.Fsync(f.fd); e != nil {\n \t\treturn NewSyscallError(\"fsync\", e)"}, {"sha": "a69680cb8c908291cfd24f6b753116f1e974eb38", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -89,7 +89,7 @@ func (f *File) Close() error {\n \n func (file *file) close() error {\n \tif file == nil || file.fd < 0 {\n-\t\treturn EINVAL\n+\t\treturn syscall.EINVAL\n \t}\n \tvar err error\n \tif e := syscall.Close(file.fd); e != nil {"}, {"sha": "81d8fed926eeca8cd54d7972a4897386ba023894", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -52,7 +52,7 @@ func Getwd() (pwd string, err error) {\n \tpwd = \"\"\n \tfor parent := \"..\"; ; parent = \"../\" + parent {\n \t\tif len(parent) >= 1024 { // Sanity check\n-\t\t\treturn \"\", ENAMETOOLONG\n+\t\t\treturn \"\", syscall.ENAMETOOLONG\n \t\t}\n \t\tfd, err := Open(parent)\n \t\tif err != nil {\n@@ -74,7 +74,7 @@ func Getwd() (pwd string, err error) {\n \t\t\t}\n \t\t}\n \t\tfd.Close()\n-\t\treturn \"\", ENOENT\n+\t\treturn \"\", ErrNotExist\n \n \tFound:\n \t\tpd, err := fd.Stat()"}, {"sha": "cff35fcef75ce7b23f1c59dffb90e92163e794a2", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"syscall\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -538,7 +539,7 @@ func exec(t *testing.T, dir, cmd string, args []string, expect string) {\n \t\tt.Errorf(\"exec %q returned %q wanted %q\",\n \t\t\tstrings.Join(append([]string{cmd}, args...), \" \"), output, expect)\n \t}\n-\tp.Wait(0)\n+\tp.Wait()\n }\n \n func TestStartProcess(t *testing.T) {\n@@ -767,7 +768,7 @@ func TestSeek(t *testing.T) {\n \tfor i, tt := range tests {\n \t\toff, err := f.Seek(tt.in, tt.whence)\n \t\tif off != tt.out || err != nil {\n-\t\t\tif e, ok := err.(*PathError); ok && e.Err == EINVAL && tt.out > 1<<32 {\n+\t\t\tif e, ok := err.(*PathError); ok && e.Err == syscall.EINVAL && tt.out > 1<<32 {\n \t\t\t\t// Reiserfs rejects the big seeks.\n \t\t\t\t// http://code.google.com/p/go/issues/detail?id=91\n \t\t\t\tbreak\n@@ -787,17 +788,17 @@ var openErrorTests = []openErrorTest{\n \t{\n \t\tsfdir + \"/no-such-file\",\n \t\tO_RDONLY,\n-\t\tENOENT,\n+\t\tsyscall.ENOENT,\n \t},\n \t{\n \t\tsfdir,\n \t\tO_WRONLY,\n-\t\tEISDIR,\n+\t\tsyscall.EISDIR,\n \t},\n \t{\n \t\tsfdir + \"/\" + sfname + \"/no-such-file\",\n \t\tO_WRONLY,\n-\t\tENOTDIR,\n+\t\tsyscall.ENOTDIR,\n \t},\n }\n \n@@ -850,7 +851,7 @@ func run(t *testing.T, cmd []string) string {\n \n \tvar b bytes.Buffer\n \tio.Copy(&b, r)\n-\t_, err = p.Wait(0)\n+\t_, err = p.Wait()\n \tif err != nil {\n \t\tt.Fatalf(\"run hostname Wait: %v\", err)\n \t}\n@@ -983,32 +984,31 @@ func TestAppend(t *testing.T) {\n }\n \n func TestStatDirWithTrailingSlash(t *testing.T) {\n-\t// Create new dir, in _test so it will get\n-\t// cleaned up by make if not by us.\n-\tpath := \"_test/_TestStatDirWithSlash_\"\n-\terr := MkdirAll(path, 0777)\n+\t// Create new temporary directory and arrange to clean it up.\n+\tpath, err := ioutil.TempDir(\"\", \"/_TestStatDirWithSlash_\")\n \tif err != nil {\n-\t\tt.Fatalf(\"MkdirAll %q: %s\", path, err)\n+\t\tt.Fatalf(\"TempDir: %s\", err)\n \t}\n \tdefer RemoveAll(path)\n \n \t// Stat of path should succeed.\n \t_, err = Stat(path)\n \tif err != nil {\n-\t\tt.Fatal(\"stat failed:\", err)\n+\t\tt.Fatalf(\"stat %s failed: %s\", path, err)\n \t}\n \n \t// Stat of path+\"/\" should succeed too.\n-\t_, err = Stat(path + \"/\")\n+\tpath += \"/\"\n+\t_, err = Stat(path)\n \tif err != nil {\n-\t\tt.Fatal(\"stat failed:\", err)\n+\t\tt.Fatalf(\"stat %s failed: %s\", path, err)\n \t}\n }\n \n-func TestNilWaitmsgString(t *testing.T) {\n-\tvar w *Waitmsg\n-\ts := w.String()\n+func TestNilProcessStateString(t *testing.T) {\n+\tvar ps *ProcessState\n+\ts := ps.String()\n \tif s != \"<nil>\" {\n-\t\tt.Errorf(\"(*Waitmsg)(nil).String() = %q, want %q\", s, \"<nil>\")\n+\t\tt.Errorf(\"(*ProcessState)(nil).String() = %q, want %q\", s, \"<nil>\")\n \t}\n }"}, {"sha": "02a77ec805171ff4eeef187664c7fb8a7e1f6ec7", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,7 +4,10 @@\n \n package os\n \n-import \"io\"\n+import (\n+\t\"io\"\n+\t\"syscall\"\n+)\n \n // MkdirAll creates a directory named path,\n // along with any necessary parents, and returns nil,\n@@ -20,7 +23,7 @@ func MkdirAll(path string, perm FileMode) error {\n \t\tif dir.IsDir() {\n \t\t\treturn nil\n \t\t}\n-\t\treturn &PathError{\"mkdir\", path, ENOTDIR}\n+\t\treturn &PathError{\"mkdir\", path, syscall.ENOTDIR}\n \t}\n \n \t// Doesn't already exist; make sure parent does.\n@@ -70,7 +73,7 @@ func RemoveAll(path string) error {\n \t// Otherwise, is this a directory we need to recurse into?\n \tdir, serr := Lstat(path)\n \tif serr != nil {\n-\t\tif serr, ok := serr.(*PathError); ok && (serr.Err == ENOENT || serr.Err == ENOTDIR) {\n+\t\tif serr, ok := serr.(*PathError); ok && (IsNotExist(serr.Err) || serr.Err == syscall.ENOTDIR) {\n \t\t\treturn nil\n \t\t}\n \t\treturn serr"}, {"sha": "c1e3fb35436b96199956e329330d78c5f9856cfa", "filename": "libgo/go/os/path_test.go", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,18 +8,18 @@ import (\n \t. \"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n func TestMkdirAll(t *testing.T) {\n-\t// Create new dir, in _test so it will get\n-\t// cleaned up by make if not by us.\n-\tpath := \"_test/_TestMkdirAll_/dir/./dir2\"\n+\ttmpDir := TempDir()\n+\tpath := tmpDir + \"/_TestMkdirAll_/dir/./dir2\"\n \terr := MkdirAll(path, 0777)\n \tif err != nil {\n \t\tt.Fatalf(\"MkdirAll %q: %s\", path, err)\n \t}\n-\tdefer RemoveAll(\"_test/_TestMkdirAll_\")\n+\tdefer RemoveAll(tmpDir + \"/_TestMkdirAll_\")\n \n \t// Already exists, should succeed.\n \terr = MkdirAll(path, 0777)\n@@ -63,7 +63,7 @@ func TestMkdirAll(t *testing.T) {\n \t}\n \n \tif runtime.GOOS == \"windows\" {\n-\t\tpath := `_test\\_TestMkdirAll_\\dir\\.\\dir2\\`\n+\t\tpath := tmpDir + `\\_TestMkdirAll_\\dir\\.\\dir2\\`\n \t\terr := MkdirAll(path, 0777)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"MkdirAll %q: %s\", path, err)\n@@ -72,8 +72,9 @@ func TestMkdirAll(t *testing.T) {\n }\n \n func TestRemoveAll(t *testing.T) {\n+\ttmpDir := TempDir()\n \t// Work directory.\n-\tpath := \"_test/_TestRemoveAll_\"\n+\tpath := tmpDir + \"/_TestRemoveAll_\"\n \tfpath := path + \"/file\"\n \tdpath := path + \"/dir\"\n \n@@ -170,19 +171,22 @@ func TestMkdirAllWithSymlink(t *testing.T) {\n \t\treturn\n \t}\n \n-\terr := Mkdir(\"_test/dir\", 0755)\n+\ttmpDir := TempDir()\n+\tdir := tmpDir + \"/dir\"\n+\terr := Mkdir(dir, 0755)\n \tif err != nil {\n-\t\tt.Fatal(`Mkdir \"_test/dir\":`, err)\n+\t\tt.Fatalf(\"Mkdir %s: %s\", dir, err)\n \t}\n-\tdefer RemoveAll(\"_test/dir\")\n+\tdefer RemoveAll(dir)\n \n-\terr = Symlink(\"dir\", \"_test/link\")\n+\tlink := tmpDir + \"/link\"\n+\terr = Symlink(\"dir\", link)\n \tif err != nil {\n-\t\tt.Fatal(`Symlink \"dir\", \"_test/link\":`, err)\n+\t\tt.Fatalf(\"Symlink %s: %s\", link, err)\n \t}\n-\tdefer RemoveAll(\"_test/link\")\n+\tdefer RemoveAll(link)\n \n-\tpath := \"_test/link/foo\"\n+\tpath := link + \"/foo\"\n \terr = MkdirAll(path, 0755)\n \tif err != nil {\n \t\tt.Errorf(\"MkdirAll %q: %s\", path, err)\n@@ -198,7 +202,7 @@ func TestMkdirAllAtSlash(t *testing.T) {\n \tif err != nil {\n \t\tpathErr, ok := err.(*PathError)\n \t\t// common for users not to be able to write to /\n-\t\tif ok && pathErr.Err == EACCES {\n+\t\tif ok && pathErr.Err == syscall.EACCES {\n \t\t\treturn\n \t\t}\n \t\tt.Fatalf(`MkdirAll \"/_go_os_test/dir\": %v`, err)"}, {"sha": "fc227cf4c2d1861b5ec1c26f010cea776d0dd101", "filename": "libgo/go/os/signal/signal_stub.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_stub.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build plan9\n+\n+package signal\n+\n+import \"os\"\n+\n+func enableSignal(sig os.Signal) {}"}, {"sha": "a7990a359ece90f520bb17980d88fbb24814b2c8", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -62,7 +62,7 @@ func dirstat(arg interface{}) (d *Dir, err error) {\n \t\t\treturn nil, &PathError{\"stat\", name, err}\n \t\t}\n \t\tif n < syscall.STATFIXLEN {\n-\t\t\treturn nil, &PathError{\"stat\", name, Eshortstat}\n+\t\t\treturn nil, &PathError{\"stat\", name, errShortStat}\n \t\t}\n \n \t\t// Pull the real size out of the stat message.\n@@ -79,7 +79,7 @@ func dirstat(arg interface{}) (d *Dir, err error) {\n \t\t\treturn\n \t\t}\n \t}\n-\treturn nil, &PathError{\"stat\", name, Ebadstat}\n+\treturn nil, &PathError{\"stat\", name, errBadStat}\n }\n \n // Stat returns a FileInfo structure describing the named file."}, {"sha": "ca18b32305e68a8223977aafc99e0742d455c222", "filename": "libgo/go/path/example_test.go", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -11,17 +11,11 @@ import (\n \t\"path\"\n )\n \n-// b\n func ExampleBase() {\n \tfmt.Println(path.Base(\"/a/b\"))\n+\t// Output: b\n }\n \n-// Clean(\"a/c\") = \"a/c\"\n-// Clean(\"a//c\") = \"a/c\"\n-// Clean(\"a/c/.\") = \"a/c\"\n-// Clean(\"a/c/b/..\") = \"a/c\"\n-// Clean(\"/../a/c\") = \"/a/c\"\n-// Clean(\"/../a/b/../././/c\") = \"/a/c\"\n func ExampleClean() {\n \tpaths := []string{\n \t\t\"a/c\",\n@@ -35,31 +29,39 @@ func ExampleClean() {\n \tfor _, p := range paths {\n \t\tfmt.Printf(\"Clean(%q) = %q\\n\", p, path.Clean(p))\n \t}\n+\n+\t// Output:\n+\t// Clean(\"a/c\") = \"a/c\"\n+\t// Clean(\"a//c\") = \"a/c\"\n+\t// Clean(\"a/c/.\") = \"a/c\"\n+\t// Clean(\"a/c/b/..\") = \"a/c\"\n+\t// Clean(\"/../a/c\") = \"/a/c\"\n+\t// Clean(\"/../a/b/../././/c\") = \"/a/c\"\n }\n \n-// /a/b\n func ExampleDir() {\n \tfmt.Println(path.Dir(\"/a/b/c\"))\n+\t// Output: /a/b\n }\n \n-// .css\n func ExampleExt() {\n \tfmt.Println(path.Ext(\"/a/b/c/bar.css\"))\n+\t// Output: .css\n }\n \n-// true\n func ExampleIsAbs() {\n \tfmt.Println(path.IsAbs(\"/dev/null\"))\n+\t// Output: true\n }\n \n-// a/b/c\n func ExampleJoin() {\n \tfmt.Println(path.Join(\"a\", \"b\", \"c\"))\n+\t// Output: a/b/c\n }\n \n-// static/ myfile.css\n func ExampleSplit() {\n \tfmt.Println(path.Split(\"static/myfile.css\"))\n+\t// Output: static/ myfile.css\n }\n \n */"}, {"sha": "38d264fb97aa92cf8eb4090338ff70e679317269", "filename": "libgo/go/path/filepath/match.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n+// ErrBadPattern indicates a globbing pattern was malformed.\n var ErrBadPattern = errors.New(\"syntax error in pattern\")\n \n // Match returns true if name matches the shell file name pattern.\n@@ -33,7 +34,8 @@ var ErrBadPattern = errors.New(\"syntax error in pattern\")\n //\t\tlo '-' hi   matches character c for lo <= c <= hi\n //\n // Match requires pattern to match all of name, not just a substring.\n-// The only possible error return occurs when the pattern is malformed.\n+// The only possible returned error is ErrBadPattern, when pattern\n+// is malformed.\n //\n func Match(pattern, name string) (matched bool, err error) {\n Pattern:\n@@ -211,7 +213,6 @@ func getEsc(chunk string) (r rune, nchunk string, err error) {\n // if there is no matching file. The syntax of patterns is the same\n // as in Match. The pattern may describe hierarchical names such as\n // /usr/*/bin/ed (assuming the Separator is '/').\n-// The only possible error return occurs when the pattern is malformed.\n //\n func Glob(pattern string) (matches []string, err error) {\n \tif !hasMeta(pattern) {\n@@ -253,7 +254,6 @@ func Glob(pattern string) (matches []string, err error) {\n // and appends them to matches. If the directory cannot be\n // opened, it returns the existing matches. New matches are\n // added in lexicographical order.\n-// The only possible error return occurs when the pattern is malformed.\n func glob(dir, pattern string, matches []string) (m []string, e error) {\n \tm = matches\n \tfi, err := os.Stat(dir)"}, {"sha": "f468d33264bf50c2b9c0dcbf7e0d9e36f4299445", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -36,7 +36,7 @@ const (\n // returns the string \".\".\n //\n // See also Rob Pike, ``Lexical File Names in Plan 9 or\n-// Getting Dot-Dot right,''\n+// Getting Dot-Dot Right,''\n // http://plan9.bell-labs.com/sys/doc/lexnames.html\n func Clean(path string) string {\n \tvol := VolumeName(path)\n@@ -118,7 +118,8 @@ func Clean(path string) string {\n }\n \n // ToSlash returns the result of replacing each separator character\n-// in path with a slash ('/') character.\n+// in path with a slash ('/') character. Multiple separators are\n+// replaced by multiple slashes.\n func ToSlash(path string) string {\n \tif Separator == '/' {\n \t\treturn path\n@@ -127,15 +128,17 @@ func ToSlash(path string) string {\n }\n \n // FromSlash returns the result of replacing each slash ('/') character\n-// in path with a separator character.\n+// in path with a separator character. Multiple slashes are replaced\n+// by multiple separators.\n func FromSlash(path string) string {\n \tif Separator == '/' {\n \t\treturn path\n \t}\n \treturn strings.Replace(path, \"/\", string(Separator), -1)\n }\n \n-// SplitList splits a list of paths joined by the OS-specific ListSeparator.\n+// SplitList splits a list of paths joined by the OS-specific ListSeparator,\n+// usually found in PATH or GOPATH environment variables.\n func SplitList(path string) []string {\n \tif path == \"\" {\n \t\treturn []string{}\n@@ -158,7 +161,8 @@ func Split(path string) (dir, file string) {\n }\n \n // Join joins any number of path elements into a single path, adding\n-// a Separator if necessary.  All empty strings are ignored.\n+// a Separator if necessary. The result is Cleaned, in particular\n+// all empty strings are ignored.\n func Join(elem ...string) string {\n \tfor i, e := range elem {\n \t\tif e != \"\" {\n@@ -183,7 +187,8 @@ func Ext(path string) string {\n \n // EvalSymlinks returns the path name after the evaluation of any symbolic\n // links.\n-// If path is relative it will be evaluated relative to the current directory.\n+// If path is relative the result will be relative to the current directory,\n+// unless one of the components is an absolute symbolic link.\n func EvalSymlinks(path string) (string, error) {\n \tif runtime.GOOS == \"windows\" {\n \t\t// Symlinks are not supported under windows.\n@@ -443,7 +448,7 @@ func Base(path string) string {\n \treturn path\n }\n \n-// Dir returns the all but the last element of path, typically the path's directory.\n+// Dir returns all but the last element of path, typically the path's directory.\n // Trailing path separators are removed before processing.\n // If the path is empty, Dir returns \".\".\n // If the path consists entirely of separators, Dir returns a single separator."}, {"sha": "93cca1e4c2b141ec255a9a45d01353fb0f6c0980", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -558,6 +558,7 @@ var EvalSymlinksTestDirs = []EvalSymlinksTest{\n \t{\"test/dir/link3\", \"../../\"},\n \t{\"test/link1\", \"../test\"},\n \t{\"test/link2\", \"dir\"},\n+\t{\"test/linkabs\", \"/\"},\n }\n \n var EvalSymlinksTests = []EvalSymlinksTest{\n@@ -570,6 +571,7 @@ var EvalSymlinksTests = []EvalSymlinksTest{\n \t{\"test/link2/..\", \"test\"},\n \t{\"test/dir/link3\", \".\"},\n \t{\"test/link2/link3/test\", \"test\"},\n+\t{\"test/linkabs\", \"/\"},\n }\n \n var EvalSymlinksAbsWindowsTests = []EvalSymlinksTest{\n@@ -628,6 +630,9 @@ func TestEvalSymlinks(t *testing.T) {\n \tfor _, d := range tests {\n \t\tpath := simpleJoin(tmpDir, d.path)\n \t\tdest := simpleJoin(tmpDir, d.dest)\n+\t\tif filepath.IsAbs(d.dest) {\n+\t\t\tdest = d.dest\n+\t\t}\n \t\tif p, err := filepath.EvalSymlinks(path); err != nil {\n \t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n \t\t} else if filepath.Clean(p) != filepath.Clean(dest) {"}, {"sha": "8154bf6025162104d2f205322a0a3a36fb8115b8", "filename": "libgo/go/path/match.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fmatch.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n+// ErrBadPattern indicates a globbing pattern was malformed.\n var ErrBadPattern = errors.New(\"syntax error in pattern\")\n \n // Match returns true if name matches the shell file name pattern.\n@@ -31,7 +32,8 @@ var ErrBadPattern = errors.New(\"syntax error in pattern\")\n //\t\tlo '-' hi   matches character c for lo <= c <= hi\n //\n // Match requires pattern to match all of name, not just a substring.\n-// The only possible error return is when pattern is malformed.\n+// The only possible returned error is ErrBadPattern, when pattern\n+// is malformed.\n //\n func Match(pattern, name string) (matched bool, err error) {\n Pattern:"}, {"sha": "13abed0b09da25120f3d920d72b658abb9e2ba83", "filename": "libgo/go/path/path.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fpath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package path implements utility routines for manipulating slash-separated\n-// filename paths.\n+// paths.\n package path\n \n import (\n@@ -25,7 +25,7 @@ import (\n // returns the string \".\".\n //\n // See also Rob Pike, ``Lexical File Names in Plan 9 or\n-// Getting Dot-Dot right,''\n+// Getting Dot-Dot Right,''\n // http://plan9.bell-labs.com/sys/doc/lexnames.html\n func Clean(path string) string {\n \tif path == \"\" {\n@@ -100,17 +100,19 @@ func Clean(path string) string {\n \treturn string(buf[0:w])\n }\n \n-// Split splits path immediately following the final path separator,\n+// Split splits path immediately following the final slash.\n // separating it into a directory and file name component.\n-// If there is no separator in path, Split returns an empty dir and\n+// If there is no slash path, Split returns an empty dir and\n // file set to path.\n+// The returned values have the property that path = dir+file.\n func Split(path string) (dir, file string) {\n \ti := strings.LastIndex(path, \"/\")\n \treturn path[:i+1], path[i+1:]\n }\n \n // Join joins any number of path elements into a single path, adding a\n-// separating slash if necessary.  All empty strings are ignored.\n+// separating slash if necessary. The result is Cleaned; in particular,\n+// all empty strings are ignored.\n func Join(elem ...string) string {\n \tfor i, e := range elem {\n \t\tif e != \"\" {\n@@ -161,11 +163,12 @@ func IsAbs(path string) bool {\n \treturn len(path) > 0 && path[0] == '/'\n }\n \n-// Dir returns the all but the last element of path, typically the path's directory.\n-// Trailing path separators are removed before processing.\n+// Dir returns all but the last element of path, typically the path's directory.\n+// The path is Cleaned and trailing slashes are removed before processing.\n // If the path is empty, Dir returns \".\".\n-// If the path consists entirely of separators, Dir returns a single separator.\n-// The returned path does not end in a separator unless it is the root directory.\n+// If the path consists entirely of slashes followed by non-slash bytes, Dir\n+// returns a single slash. In any other case, the returned path does not end in a\n+// slash.\n func Dir(path string) string {\n \tdir, _ := Split(path)\n \tdir = Clean(dir)"}, {"sha": "b802fc63f71d32d08bdbab8534a79d4c24112c46", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -26,23 +26,11 @@ func GOMAXPROCS(n int) int\n // NumCPU returns the number of logical CPUs on the local machine.\n func NumCPU() int\n \n-// Cgocalls returns the number of cgo calls made by the current process.\n-func Cgocalls() int64\n+// NumCgoCall returns the number of cgo calls made by the current process.\n+func NumCgoCall() int64\n \n-// Goroutines returns the number of goroutines that currently exist.\n-func Goroutines() int32\n-\n-// Alloc allocates a block of the given size.\n-// FOR TESTING AND DEBUGGING ONLY.\n-func Alloc(uintptr) *byte\n-\n-// Free frees the block starting at the given pointer.\n-// FOR TESTING AND DEBUGGING ONLY.\n-func Free(*byte)\n-\n-// Lookup returns the base and size of the block containing the given pointer.\n-// FOR TESTING AND DEBUGGING ONLY.\n-func Lookup(*byte) (*byte, uintptr)\n+// NumGoroutine returns the number of goroutines that currently exist.\n+func NumGoroutine() int\n \n // MemProfileRate controls the fraction of memory allocations\n // that are recorded and reported in the memory profile.\n@@ -101,15 +89,14 @@ func (r *MemProfileRecord) Stack() []uintptr {\n // of calling MemProfile directly.\n func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\n \n-// A ThreadProfileRecord describes the execution stack that\n-// caused a new thread to be created.\n-type ThreadProfileRecord struct {\n+// A StackRecord describes a single execution stack.\n+type StackRecord struct {\n \tStack0 [32]uintptr // stack trace for this record; ends at first 0 entry\n }\n \n // Stack returns the stack trace associated with the record,\n // a prefix of r.Stack0.\n-func (r *ThreadProfileRecord) Stack() []uintptr {\n+func (r *StackRecord) Stack() []uintptr {\n \tfor i, v := range r.Stack0 {\n \t\tif v == 0 {\n \t\t\treturn r.Stack0[0:i]\n@@ -118,13 +105,21 @@ func (r *ThreadProfileRecord) Stack() []uintptr {\n \treturn r.Stack0[0:]\n }\n \n-// ThreadProfile returns n, the number of records in the current thread profile.\n-// If len(p) >= n, ThreadProfile copies the profile into p and returns n, true.\n-// If len(p) < n, ThreadProfile does not change p and returns n, false.\n+// ThreadCreateProfile returns n, the number of records in the thread creation profile.\n+// If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\n+// If len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n //\n // Most clients should use the runtime/pprof package instead\n-// of calling ThreadProfile directly.\n-func ThreadProfile(p []ThreadProfileRecord) (n int, ok bool)\n+// of calling ThreadCreateProfile directly.\n+func ThreadCreateProfile(p []StackRecord) (n int, ok bool)\n+\n+// GoroutineProfile returns n, the number of records in the active goroutine stack profile.\n+// If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\n+// If len(p) < n, GoroutineProfile does not change p and returns n, false.\n+//\n+// Most clients should use the runtime/pprof package instead\n+// of calling GoroutineProfile directly.\n+func GoroutineProfile(p []StackRecord) (n int, ok bool)\n \n // CPUProfile returns the next chunk of binary CPU profiling stack trace data,\n // blocking until data is available.  If profiling is turned off and all the profile\n@@ -142,3 +137,9 @@ func CPUProfile() []byte\n // the testing package's -test.cpuprofile flag instead of calling\n // SetCPUProfileRate directly.\n func SetCPUProfileRate(hz int)\n+\n+// Stack formats a stack trace of the calling goroutine into buf\n+// and returns the number of bytes written to buf.\n+// If all is true, Stack formats stack traces of all other goroutines\n+// into buf after the trace for the current goroutine.\n+func Stack(buf []byte, all bool) int"}, {"sha": "5fbfe547e46b485ecd20e292e8a1caf0f52f1530", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -68,17 +68,6 @@ func funcline_go(*Func, uintptr) (string, int)\n // mid returns the current os thread (m) id.\n func mid() uint32\n \n-// Semacquire waits until *s > 0 and then atomically decrements it.\n-// It is intended as a simple sleep primitive for use by the synchronization\n-// library and should not be used directly.\n-func Semacquire(s *uint32)\n-\n-// Semrelease atomically increments *s and notifies a waiting goroutine\n-// if one is blocked in Semacquire.\n-// It is intended as a simple wakeup primitive for use by the synchronization\n-// library and should not be used directly.\n-func Semrelease(s *uint32)\n-\n // SetFinalizer sets the finalizer associated with x to f.\n // When the garbage collector finds an unreachable block\n // with an associated finalizer, it clears the association and runs\n@@ -141,10 +130,10 @@ func Version() string {\n \treturn theVersion\n }\n \n-// GOOS is the Go tree's operating system target:\n+// GOOS is the running program's operating system target:\n // one of darwin, freebsd, linux, and so on.\n const GOOS string = theGoos\n \n-// GOARCH is the Go tree's architecture target:\n+// GOARCH is the running program's architecture target:\n // 386, amd64, or arm.\n const GOARCH string = theGoarch"}, {"sha": "da92f4c2fbf2470fd64f37ea159879eb593c4d29", "filename": "libgo/go/runtime/malloc1.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmalloc1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmalloc1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc1.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,9 +1,9 @@\n-// $G $D/$F.go && $L $F.$A && ./$A.out\n-\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // trivial malloc test\n \n package main", "previous_filename": "gcc/testsuite/go.test/test/malloc1.go"}, {"sha": "f1bcb89cfa43881b04c9f173a73cad9c02950581", "filename": "libgo/go/runtime/mallocrand.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmallocrand.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,9 +1,9 @@\n-// $G $D/$F.go && $L $F.$A && ./$A.out\n-\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Random malloc test.\n \n package main", "previous_filename": "gcc/testsuite/go.test/test/mallocrand.go"}, {"sha": "03ee71edb427988bfa5c0fd72c6270bdb82628f7", "filename": "libgo/go/runtime/mallocrep.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmallocrep.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,11 +1,11 @@\n-// $G $D/$F.go && $L $F.$A && ./$A.out\n-\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n // Repeated malloc test.\n \n+// +build ignore\n+\n package main\n \n import (", "previous_filename": "gcc/testsuite/go.test/test/mallocrep.go"}, {"sha": "41c104c0ba798331655702883ea8748b417395ff", "filename": "libgo/go/runtime/mallocrep1.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrep1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmallocrep1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmallocrep1.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,9 +1,9 @@\n-// $G $D/$F.go && $L $F.$A && ./$A.out\n-\n // Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Repeated malloc test.\n \n package main", "previous_filename": "gcc/testsuite/go.test/test/mallocrep1.go"}, {"sha": "95e8aa7a5337ff70100cfc02f20e353fc71d9560", "filename": "libgo/go/runtime/mem.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fmem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -17,11 +17,12 @@ type MemStats struct {\n \tFrees      uint64 // number of frees\n \n \t// Main allocation heap statistics.\n-\tHeapAlloc   uint64 // bytes allocated and still in use\n-\tHeapSys     uint64 // bytes obtained from system\n-\tHeapIdle    uint64 // bytes in idle spans\n-\tHeapInuse   uint64 // bytes in non-idle span\n-\tHeapObjects uint64 // total number of allocated objects\n+\tHeapAlloc    uint64 // bytes allocated and still in use\n+\tHeapSys      uint64 // bytes obtained from system\n+\tHeapIdle     uint64 // bytes in idle spans\n+\tHeapInuse    uint64 // bytes in non-idle span\n+\tHeapReleased uint64 // bytes released to the OS\n+\tHeapObjects  uint64 // total number of allocated objects\n \n \t// Low-level fixed-size structure allocator statistics.\n \t//\tInuse is bytes used now.\n@@ -35,7 +36,8 @@ type MemStats struct {\n \tBuckHashSys uint64 // profiling bucket hash table\n \n \t// Garbage collector statistics.\n-\tNextGC       uint64\n+\tNextGC       uint64 // next run in HeapAlloc time (bytes)\n+\tLastGC       uint64 // last run in absolute time (ns)\n \tPauseTotalNs uint64\n \tPauseNs      [256]uint64 // most recent GC pause times\n \tNumGC        uint32"}, {"sha": "099bb6a92f94f937f0803b6f74eb3027ba2dbe83", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 443, "deletions": 61, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,19 +10,354 @@ package pprof\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n \t\"runtime\"\n+\t\"sort\"\n+\t\"strings\"\n \t\"sync\"\n+\t\"text/tabwriter\"\n )\n \n // BUG(rsc): CPU profiling is broken on OS X, due to an Apple kernel bug.\n // For details, see http://code.google.com/p/go/source/detail?r=35b716c94225.\n \n-// WriteHeapProfile writes a pprof-formatted heap profile to w.\n-// If a write to w returns an error, WriteHeapProfile returns that error.\n-// Otherwise, WriteHeapProfile returns nil.\n+// A Profile is a collection of stack traces showing the call sequences\n+// that led to instances of a particular event, such as allocation.\n+// Packages can create and maintain their own profiles; the most common\n+// use is for tracking resources that must be explicitly closed, such as files\n+// or network connections.\n+//\n+// A Profile's methods can be called from multiple goroutines simultaneously.\n+//\n+// Each Profile has a unique name.  A few profiles are predefined:\n+//\n+//\tgoroutine    - stack traces of all current goroutines\n+//\theap         - a sampling of all heap allocations\n+//\tthreadcreate - stack traces that led to the creation of new OS threads\n+//\n+// These predefine profiles maintain themselves and panic on an explicit\n+// Add or Remove method call.\n+//\n+// The CPU profile is not available as a Profile.  It has a special API,\n+// the StartCPUProfile and StopCPUProfile functions, because it streams\n+// output to a writer during profiling.\n+//\n+type Profile struct {\n+\tname  string\n+\tmu    sync.Mutex\n+\tm     map[interface{}][]uintptr\n+\tcount func() int\n+\twrite func(io.Writer, int) error\n+}\n+\n+// profiles records all registered profiles.\n+var profiles struct {\n+\tmu sync.Mutex\n+\tm  map[string]*Profile\n+}\n+\n+var goroutineProfile = &Profile{\n+\tname:  \"goroutine\",\n+\tcount: countGoroutine,\n+\twrite: writeGoroutine,\n+}\n+\n+var threadcreateProfile = &Profile{\n+\tname:  \"threadcreate\",\n+\tcount: countThreadCreate,\n+\twrite: writeThreadCreate,\n+}\n+\n+var heapProfile = &Profile{\n+\tname:  \"heap\",\n+\tcount: countHeap,\n+\twrite: writeHeap,\n+}\n+\n+func lockProfiles() {\n+\tprofiles.mu.Lock()\n+\tif profiles.m == nil {\n+\t\t// Initial built-in profiles.\n+\t\tprofiles.m = map[string]*Profile{\n+\t\t\t\"goroutine\":    goroutineProfile,\n+\t\t\t\"threadcreate\": threadcreateProfile,\n+\t\t\t\"heap\":         heapProfile,\n+\t\t}\n+\t}\n+}\n+\n+func unlockProfiles() {\n+\tprofiles.mu.Unlock()\n+}\n+\n+// NewProfile creates a new profile with the given name.\n+// If a profile with that name already exists, NewProfile panics.\n+// The convention is to use a 'import/path.' prefix to create\n+// separate name spaces for each package.\n+func NewProfile(name string) *Profile {\n+\tlockProfiles()\n+\tdefer unlockProfiles()\n+\tif name == \"\" {\n+\t\tpanic(\"pprof: NewProfile with empty name\")\n+\t}\n+\tif profiles.m[name] != nil {\n+\t\tpanic(\"pprof: NewProfile name already in use: \" + name)\n+\t}\n+\tp := &Profile{\n+\t\tname: name,\n+\t\tm:    map[interface{}][]uintptr{},\n+\t}\n+\tprofiles.m[name] = p\n+\treturn p\n+}\n+\n+// Lookup returns the profile with the given name, or nil if no such profile exists.\n+func Lookup(name string) *Profile {\n+\tlockProfiles()\n+\tdefer unlockProfiles()\n+\treturn profiles.m[name]\n+}\n+\n+// Profiles returns a slice of all the known profiles, sorted by name.\n+func Profiles() []*Profile {\n+\tlockProfiles()\n+\tdefer unlockProfiles()\n+\n+\tvar all []*Profile\n+\tfor _, p := range profiles.m {\n+\t\tall = append(all, p)\n+\t}\n+\n+\tsort.Sort(byName(all))\n+\treturn all\n+}\n+\n+type byName []*Profile\n+\n+func (x byName) Len() int           { return len(x) }\n+func (x byName) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n+func (x byName) Less(i, j int) bool { return x[i].name < x[j].name }\n+\n+// Name returns this profile's name, which can be passed to Lookup to reobtain the profile.\n+func (p *Profile) Name() string {\n+\treturn p.name\n+}\n+\n+// Count returns the number of execution stacks currently in the profile.\n+func (p *Profile) Count() int {\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\tif p.count != nil {\n+\t\treturn p.count()\n+\t}\n+\treturn len(p.m)\n+}\n+\n+// Add adds the current execution stack to the profile, associated with value.\n+// Add stores value in an internal map, so value must be suitable for use as \n+// a map key and will not be garbage collected until the corresponding\n+// call to Remove.  Add panics if the profile already contains a stack for value.\n+//\n+// The skip parameter has the same meaning as runtime.Caller's skip\n+// and controls where the stack trace begins.  Passing skip=0 begins the\n+// trace in the function calling Add.  For example, given this\n+// execution stack:\n+//\n+//\tAdd\n+//\tcalled from rpc.NewClient\n+//\tcalled from mypkg.Run\n+//\tcalled from main.main\n+//\n+// Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient.\n+// Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.\n+//\n+func (p *Profile) Add(value interface{}, skip int) {\n+\tif p.name == \"\" {\n+\t\tpanic(\"pprof: use of uninitialized Profile\")\n+\t}\n+\tif p.write != nil {\n+\t\tpanic(\"pprof: Add called on built-in Profile \" + p.name)\n+\t}\n+\n+\tstk := make([]uintptr, 32)\n+\tn := runtime.Callers(skip+1, stk[:])\n+\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\tif p.m[value] != nil {\n+\t\tpanic(\"pprof: Profile.Add of duplicate value\")\n+\t}\n+\tp.m[value] = stk[:n]\n+}\n+\n+// Remove removes the execution stack associated with value from the profile.\n+// It is a no-op if the value is not in the profile.\n+func (p *Profile) Remove(value interface{}) {\n+\tp.mu.Lock()\n+\tdefer p.mu.Unlock()\n+\tdelete(p.m, value)\n+}\n+\n+// WriteTo writes a pprof-formatted snapshot of the profile to w.\n+// If a write to w returns an error, WriteTo returns that error.\n+// Otherwise, WriteTo returns nil.\n+//\n+// The debug parameter enables additional output.\n+// Passing debug=0 prints only the hexadecimal addresses that pprof needs.\n+// Passing debug=1 adds comments translating addresses to function names\n+// and line numbers, so that a programmer can read the profile without tools.\n+//\n+// The predefined profiles may assign meaning to other debug values;\n+// for example, when printing the \"goroutine\" profile, debug=2 means to\n+// print the goroutine stacks in the same form that a Go program uses\n+// when dying due to an unrecovered panic.\n+func (p *Profile) WriteTo(w io.Writer, debug int) error {\n+\tif p.name == \"\" {\n+\t\tpanic(\"pprof: use of zero Profile\")\n+\t}\n+\tif p.write != nil {\n+\t\treturn p.write(w, debug)\n+\t}\n+\n+\t// Obtain consistent snapshot under lock; then process without lock.\n+\tvar all [][]uintptr\n+\tp.mu.Lock()\n+\tfor _, stk := range p.m {\n+\t\tall = append(all, stk)\n+\t}\n+\tp.mu.Unlock()\n+\n+\t// Map order is non-deterministic; make output deterministic.\n+\tsort.Sort(stackProfile(all))\n+\n+\treturn printCountProfile(w, debug, p.name, stackProfile(all))\n+}\n+\n+type stackProfile [][]uintptr\n+\n+func (x stackProfile) Len() int              { return len(x) }\n+func (x stackProfile) Stack(i int) []uintptr { return x[i] }\n+func (x stackProfile) Swap(i, j int)         { x[i], x[j] = x[j], x[i] }\n+func (x stackProfile) Less(i, j int) bool {\n+\tt, u := x[i], x[j]\n+\tfor k := 0; k < len(t) && k < len(u); k++ {\n+\t\tif t[k] != u[k] {\n+\t\t\treturn t[k] < u[k]\n+\t\t}\n+\t}\n+\treturn len(t) < len(u)\n+}\n+\n+// A countProfile is a set of stack traces to be printed as counts\n+// grouped by stack trace.  There are multiple implementations:\n+// all that matters is that we can find out how many traces there are\n+// and obtain each trace in turn.\n+type countProfile interface {\n+\tLen() int\n+\tStack(i int) []uintptr\n+}\n+\n+// printCountProfile prints a countProfile at the specified debug level.\n+func printCountProfile(w io.Writer, debug int, name string, p countProfile) error {\n+\tb := bufio.NewWriter(w)\n+\tvar tw *tabwriter.Writer\n+\tw = b\n+\tif debug > 0 {\n+\t\ttw = tabwriter.NewWriter(w, 1, 8, 1, '\\t', 0)\n+\t\tw = tw\n+\t}\n+\n+\tfmt.Fprintf(w, \"%s profile: total %d\\n\", name, p.Len())\n+\n+\t// Build count of each stack.\n+\tvar buf bytes.Buffer\n+\tkey := func(stk []uintptr) string {\n+\t\tbuf.Reset()\n+\t\tfmt.Fprintf(&buf, \"@\")\n+\t\tfor _, pc := range stk {\n+\t\t\tfmt.Fprintf(&buf, \" %#x\", pc)\n+\t\t}\n+\t\treturn buf.String()\n+\t}\n+\tm := map[string]int{}\n+\tn := p.Len()\n+\tfor i := 0; i < n; i++ {\n+\t\tm[key(p.Stack(i))]++\n+\t}\n+\n+\t// Print stacks, listing count on first occurrence of a unique stack.\n+\tfor i := 0; i < n; i++ {\n+\t\tstk := p.Stack(i)\n+\t\ts := key(stk)\n+\t\tif count := m[s]; count != 0 {\n+\t\t\tfmt.Fprintf(w, \"%d %s\\n\", count, s)\n+\t\t\tif debug > 0 {\n+\t\t\t\tprintStackRecord(w, stk, false)\n+\t\t\t}\n+\t\t\tdelete(m, s)\n+\t\t}\n+\t}\n+\n+\tif tw != nil {\n+\t\ttw.Flush()\n+\t}\n+\treturn b.Flush()\n+}\n+\n+// printStackRecord prints the function + source line information\n+// for a single stack trace.\n+func printStackRecord(w io.Writer, stk []uintptr, allFrames bool) {\n+\tshow := allFrames\n+\tfor _, pc := range stk {\n+\t\tf := runtime.FuncForPC(pc)\n+\t\tif f == nil {\n+\t\t\tshow = true\n+\t\t\tfmt.Fprintf(w, \"#\\t%#x\\n\", pc)\n+\t\t} else {\n+\t\t\tfile, line := f.FileLine(pc)\n+\t\t\tname := f.Name()\n+\t\t\t// Hide runtime.goexit and any runtime functions at the beginning.\n+\t\t\t// This is useful mainly for allocation traces.\n+\t\t\tif name == \"runtime.goexit\" || !show && strings.HasPrefix(name, \"runtime.\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tshow = true\n+\t\t\tfmt.Fprintf(w, \"#\\t%#x\\t%s+%#x\\t%s:%d\\n\", pc, f.Name(), pc-f.Entry(), file, line)\n+\t\t}\n+\t}\n+\tif !show {\n+\t\t// We didn't print anything; do it again,\n+\t\t// and this time include runtime functions.\n+\t\tprintStackRecord(w, stk, true)\n+\t\treturn\n+\t}\n+\tfmt.Fprintf(w, \"\\n\")\n+}\n+\n+// Interface to system profiles.\n+\n+type byInUseBytes []runtime.MemProfileRecord\n+\n+func (x byInUseBytes) Len() int           { return len(x) }\n+func (x byInUseBytes) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n+func (x byInUseBytes) Less(i, j int) bool { return x[i].InUseBytes() > x[j].InUseBytes() }\n+\n+// WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\n+// It is preserved for backwards compatibility.\n func WriteHeapProfile(w io.Writer) error {\n+\treturn writeHeap(w, 0)\n+}\n+\n+// countHeap returns the number of records in the heap profile.\n+func countHeap() int {\n+\tn, _ := runtime.MemProfile(nil, false)\n+\treturn n\n+}\n+\n+// writeHeapProfile writes the current runtime heap profile to w.\n+func writeHeap(w io.Writer, debug int) error {\n \t// Find out how many records there are (MemProfile(nil, false)),\n \t// allocate that many records, and get the data.\n \t// There's a race\u2014more records might be added between\n@@ -44,6 +379,16 @@ func WriteHeapProfile(w io.Writer) error {\n \t\t// Profile grew; try again.\n \t}\n \n+\tsort.Sort(byInUseBytes(p))\n+\n+\tb := bufio.NewWriter(w)\n+\tvar tw *tabwriter.Writer\n+\tw = b\n+\tif debug > 0 {\n+\t\ttw = tabwriter.NewWriter(w, 1, 8, 1, '\\t', 0)\n+\t\tw = tw\n+\t}\n+\n \tvar total runtime.MemProfileRecord\n \tfor i := range p {\n \t\tr := &p[i]\n@@ -56,98 +401,135 @@ func WriteHeapProfile(w io.Writer) error {\n \t// Technically the rate is MemProfileRate not 2*MemProfileRate,\n \t// but early versions of the C++ heap profiler reported 2*MemProfileRate,\n \t// so that's what pprof has come to expect.\n-\tb := bufio.NewWriter(w)\n-\tfmt.Fprintf(b, \"heap profile: %d: %d [%d: %d] @ heap/%d\\n\",\n+\tfmt.Fprintf(w, \"heap profile: %d: %d [%d: %d] @ heap/%d\\n\",\n \t\ttotal.InUseObjects(), total.InUseBytes(),\n \t\ttotal.AllocObjects, total.AllocBytes,\n \t\t2*runtime.MemProfileRate)\n \n \tfor i := range p {\n \t\tr := &p[i]\n-\t\tfmt.Fprintf(b, \"%d: %d [%d: %d] @\",\n+\t\tfmt.Fprintf(w, \"%d: %d [%d: %d] @\",\n \t\t\tr.InUseObjects(), r.InUseBytes(),\n \t\t\tr.AllocObjects, r.AllocBytes)\n \t\tfor _, pc := range r.Stack() {\n-\t\t\tfmt.Fprintf(b, \" %#x\", pc)\n+\t\t\tfmt.Fprintf(w, \" %#x\", pc)\n+\t\t}\n+\t\tfmt.Fprintf(w, \"\\n\")\n+\t\tif debug > 0 {\n+\t\t\tprintStackRecord(w, r.Stack(), false)\n \t\t}\n-\t\tfmt.Fprintf(b, \"\\n\")\n \t}\n \n \t// Print memstats information too.\n-\t// Pprof will ignore, but useful for people.\n-\ts := new(runtime.MemStats)\n-\truntime.ReadMemStats(s)\n-\tfmt.Fprintf(b, \"\\n# runtime.MemStats\\n\")\n-\tfmt.Fprintf(b, \"# Alloc = %d\\n\", s.Alloc)\n-\tfmt.Fprintf(b, \"# TotalAlloc = %d\\n\", s.TotalAlloc)\n-\tfmt.Fprintf(b, \"# Sys = %d\\n\", s.Sys)\n-\tfmt.Fprintf(b, \"# Lookups = %d\\n\", s.Lookups)\n-\tfmt.Fprintf(b, \"# Mallocs = %d\\n\", s.Mallocs)\n-\n-\tfmt.Fprintf(b, \"# HeapAlloc = %d\\n\", s.HeapAlloc)\n-\tfmt.Fprintf(b, \"# HeapSys = %d\\n\", s.HeapSys)\n-\tfmt.Fprintf(b, \"# HeapIdle = %d\\n\", s.HeapIdle)\n-\tfmt.Fprintf(b, \"# HeapInuse = %d\\n\", s.HeapInuse)\n-\n-\tfmt.Fprintf(b, \"# Stack = %d / %d\\n\", s.StackInuse, s.StackSys)\n-\tfmt.Fprintf(b, \"# MSpan = %d / %d\\n\", s.MSpanInuse, s.MSpanSys)\n-\tfmt.Fprintf(b, \"# MCache = %d / %d\\n\", s.MCacheInuse, s.MCacheSys)\n-\tfmt.Fprintf(b, \"# BuckHashSys = %d\\n\", s.BuckHashSys)\n-\n-\tfmt.Fprintf(b, \"# NextGC = %d\\n\", s.NextGC)\n-\tfmt.Fprintf(b, \"# PauseNs = %d\\n\", s.PauseNs)\n-\tfmt.Fprintf(b, \"# NumGC = %d\\n\", s.NumGC)\n-\tfmt.Fprintf(b, \"# EnableGC = %v\\n\", s.EnableGC)\n-\tfmt.Fprintf(b, \"# DebugGC = %v\\n\", s.DebugGC)\n-\n-\tfmt.Fprintf(b, \"# BySize = Size * (Active = Mallocs - Frees)\\n\")\n-\tfmt.Fprintf(b, \"# (Excluding large blocks.)\\n\")\n-\tfor _, t := range s.BySize {\n-\t\tif t.Mallocs > 0 {\n-\t\t\tfmt.Fprintf(b, \"#   %d * (%d = %d - %d)\\n\", t.Size, t.Mallocs-t.Frees, t.Mallocs, t.Frees)\n-\t\t}\n+\t// Pprof will ignore, but useful for people\n+\tif debug > 0 {\n+\t\ts := new(runtime.MemStats)\n+\t\truntime.ReadMemStats(s)\n+\t\tfmt.Fprintf(w, \"\\n# runtime.MemStats\\n\")\n+\t\tfmt.Fprintf(w, \"# Alloc = %d\\n\", s.Alloc)\n+\t\tfmt.Fprintf(w, \"# TotalAlloc = %d\\n\", s.TotalAlloc)\n+\t\tfmt.Fprintf(w, \"# Sys = %d\\n\", s.Sys)\n+\t\tfmt.Fprintf(w, \"# Lookups = %d\\n\", s.Lookups)\n+\t\tfmt.Fprintf(w, \"# Mallocs = %d\\n\", s.Mallocs)\n+\n+\t\tfmt.Fprintf(w, \"# HeapAlloc = %d\\n\", s.HeapAlloc)\n+\t\tfmt.Fprintf(w, \"# HeapSys = %d\\n\", s.HeapSys)\n+\t\tfmt.Fprintf(w, \"# HeapIdle = %d\\n\", s.HeapIdle)\n+\t\tfmt.Fprintf(w, \"# HeapInuse = %d\\n\", s.HeapInuse)\n+\n+\t\tfmt.Fprintf(w, \"# Stack = %d / %d\\n\", s.StackInuse, s.StackSys)\n+\t\tfmt.Fprintf(w, \"# MSpan = %d / %d\\n\", s.MSpanInuse, s.MSpanSys)\n+\t\tfmt.Fprintf(w, \"# MCache = %d / %d\\n\", s.MCacheInuse, s.MCacheSys)\n+\t\tfmt.Fprintf(w, \"# BuckHashSys = %d\\n\", s.BuckHashSys)\n+\n+\t\tfmt.Fprintf(w, \"# NextGC = %d\\n\", s.NextGC)\n+\t\tfmt.Fprintf(w, \"# PauseNs = %d\\n\", s.PauseNs)\n+\t\tfmt.Fprintf(w, \"# NumGC = %d\\n\", s.NumGC)\n+\t\tfmt.Fprintf(w, \"# EnableGC = %v\\n\", s.EnableGC)\n+\t\tfmt.Fprintf(w, \"# DebugGC = %v\\n\", s.DebugGC)\n+\t}\n+\n+\tif tw != nil {\n+\t\ttw.Flush()\n \t}\n \treturn b.Flush()\n }\n \n-// WriteThreadProfile writes a pprof-formatted thread creation profile to w.\n-// If a write to w returns an error, WriteThreadProfile returns that error.\n-// Otherwise, WriteThreadProfile returns nil.\n-func WriteThreadProfile(w io.Writer) error {\n-\t// Find out how many records there are (ThreadProfile(nil)),\n+// countThreadCreate returns the size of the current ThreadCreateProfile.\n+func countThreadCreate() int {\n+\tn, _ := runtime.ThreadCreateProfile(nil)\n+\treturn n\n+}\n+\n+// writeThreadCreate writes the current runtime ThreadCreateProfile to w.\n+func writeThreadCreate(w io.Writer, debug int) error {\n+\treturn writeRuntimeProfile(w, debug, \"threadcreate\", runtime.ThreadCreateProfile)\n+}\n+\n+// countGoroutine returns the number of goroutines.\n+func countGoroutine() int {\n+\treturn runtime.NumGoroutine()\n+}\n+\n+// writeGoroutine writes the current runtime GoroutineProfile to w.\n+func writeGoroutine(w io.Writer, debug int) error {\n+\tif debug >= 2 {\n+\t\treturn writeGoroutineStacks(w)\n+\t}\n+\treturn writeRuntimeProfile(w, debug, \"goroutine\", runtime.GoroutineProfile)\n+}\n+\n+func writeGoroutineStacks(w io.Writer) error {\n+\t// We don't know how big the buffer needs to be to collect\n+\t// all the goroutines.  Start with 1 MB and try a few times, doubling each time.\n+\t// Give up and use a truncated trace if 64 MB is not enough.\n+\tbuf := make([]byte, 1<<20)\n+\tfor i := 0; ; i++ {\n+\t\tn := runtime.Stack(buf, true)\n+\t\tif n < len(buf) {\n+\t\t\tbuf = buf[:n]\n+\t\t\tbreak\n+\t\t}\n+\t\tif len(buf) >= 64<<20 {\n+\t\t\t// Filled 64 MB - stop there.\n+\t\t\tbreak\n+\t\t}\n+\t\tbuf = make([]byte, 2*len(buf))\n+\t}\n+\t_, err := w.Write(buf)\n+\treturn err\n+}\n+\n+func writeRuntimeProfile(w io.Writer, debug int, name string, fetch func([]runtime.StackRecord) (int, bool)) error {\n+\t// Find out how many records there are (fetch(nil)),\n \t// allocate that many records, and get the data.\n-\t// There's a race\u2014more records (threads) might be added between\n+\t// There's a race\u2014more records might be added between\n \t// the two calls\u2014so allocate a few extra records for safety\n \t// and also try again if we're very unlucky.\n \t// The loop should only execute one iteration in the common case.\n-\tvar p []runtime.ThreadProfileRecord\n-\tn, ok := runtime.ThreadProfile(nil)\n+\tvar p []runtime.StackRecord\n+\tn, ok := fetch(nil)\n \tfor {\n \t\t// Allocate room for a slightly bigger profile,\n \t\t// in case a few more entries have been added\n \t\t// since the call to ThreadProfile.\n-\t\tp = make([]runtime.ThreadProfileRecord, n+10)\n-\t\tn, ok = runtime.ThreadProfile(p)\n+\t\tp = make([]runtime.StackRecord, n+10)\n+\t\tn, ok = fetch(p)\n \t\tif ok {\n \t\t\tp = p[0:n]\n \t\t\tbreak\n \t\t}\n \t\t// Profile grew; try again.\n \t}\n \n-\tb := bufio.NewWriter(w)\n-\tfmt.Fprintf(b, \"thread creation profile: %d threads\\n\", n)\n-\tfor i := range p {\n-\t\tr := &p[i]\n-\t\tfmt.Fprintf(b, \"@\")\n-\t\tfor _, pc := range r.Stack() {\n-\t\t\tfmt.Fprintf(b, \" %#x\", pc)\n-\t\t}\n-\t\tfmt.Fprintf(b, \"\\n\")\n-\t}\n-\treturn b.Flush()\n+\treturn printCountProfile(w, debug, name, runtimeProfile(p))\n }\n \n+type runtimeProfile []runtime.StackRecord\n+\n+func (p runtimeProfile) Len() int              { return len(p) }\n+func (p runtimeProfile) Stack(i int) []uintptr { return p[i].Stack() }\n+\n var cpu struct {\n \tsync.Mutex\n \tprofiling bool"}, {"sha": "4c88821be7cbe223e030da97e92b04132addb9ae", "filename": "libgo/go/sort/example_interface_test.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_interface_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_interface_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fexample_interface_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sort_test\n+\n+import (\n+\t\"fmt\"\n+\t\"sort\"\n+)\n+\n+type Grams int\n+\n+func (g Grams) String() string { return fmt.Sprintf(\"%dg\", int(g)) }\n+\n+type Organ struct {\n+\tName   string\n+\tWeight Grams\n+}\n+\n+type Organs []*Organ\n+\n+func (s Organs) Len() int      { return len(s) }\n+func (s Organs) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n+\n+// ByName implements sort.Interface by providing Less and using the Len and\n+// Swap methods of the embedded Organs value.\n+type ByName struct{ Organs }\n+\n+func (s ByName) Less(i, j int) bool { return s.Organs[i].Name < s.Organs[j].Name }\n+\n+// ByWeight implements sort.Interface by providing Less and using the Len and\n+// Swap methods of the embedded Organs value.\n+type ByWeight struct{ Organs }\n+\n+func (s ByWeight) Less(i, j int) bool { return s.Organs[i].Weight < s.Organs[j].Weight }\n+\n+func ExampleInterface() {\n+\ts := []*Organ{\n+\t\t{\"brain\", 1340},\n+\t\t{\"heart\", 290},\n+\t\t{\"liver\", 1494},\n+\t\t{\"pancreas\", 131},\n+\t\t{\"prostate\", 62},\n+\t\t{\"spleen\", 162},\n+\t}\n+\n+\tsort.Sort(ByWeight{s})\n+\tfmt.Println(\"Organs by weight:\")\n+\tprintOrgans(s)\n+\n+\tsort.Sort(ByName{s})\n+\tfmt.Println(\"Organs by name:\")\n+\tprintOrgans(s)\n+\n+\t// Output:\n+\t// Organs by weight:\n+\t// prostate (62g)\n+\t// pancreas (131g)\n+\t// spleen   (162g)\n+\t// heart    (290g)\n+\t// brain    (1340g)\n+\t// liver    (1494g)\n+\t// Organs by name:\n+\t// brain    (1340g)\n+\t// heart    (290g)\n+\t// liver    (1494g)\n+\t// pancreas (131g)\n+\t// prostate (62g)\n+\t// spleen   (162g)\n+}\n+\n+func printOrgans(s []*Organ) {\n+\tfor _, o := range s {\n+\t\tfmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight)\n+\t}\n+}"}, {"sha": "7c7f05bf3a269beb96339de42e26417ba5f64915", "filename": "libgo/go/sort/example_reverse_test.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_reverse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_reverse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fexample_reverse_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sort_test\n+\n+import (\n+\t\"fmt\"\n+\t\"sort\"\n+)\n+\n+// Reverse embeds a sort.Interface value and implements a reverse sort over\n+// that value.\n+type Reverse struct {\n+\t// This embedded Interface permits Reverse to use the methods of\n+\t// another Interface implementation.\n+\tsort.Interface\n+}\n+\n+// Less returns the opposite of the embedded implementation's Less method.\n+func (r Reverse) Less(i, j int) bool {\n+\treturn r.Interface.Less(j, i)\n+}\n+\n+func ExampleInterface_reverse() {\n+\ts := []int{5, 2, 6, 3, 1, 4} // unsorted\n+\tsort.Sort(Reverse{sort.IntSlice(s)})\n+\tfmt.Println(s)\n+\t// Output: [6 5 4 3 2 1]\n+}"}, {"sha": "f57d02546f79aecc82e788ad2ede8ab01a3e7a66", "filename": "libgo/go/sort/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsort%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -9,9 +9,9 @@ import (\n \t\"sort\"\n )\n \n-// [1 2 3 4 5 6]\n func ExampleInts() {\n \ts := []int{5, 2, 6, 3, 1, 4} // unsorted\n \tsort.Ints(s)\n \tfmt.Println(s)\n+\t// Output: [1 2 3 4 5 6]\n }"}, {"sha": "d99117bed1d0b7878d8d5bc4655cae96269b9c39", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -13,6 +13,7 @@ package strconv\n //   3) Multiply by 2^precision and round to get mantissa.\n \n import \"math\"\n+import \"runtime\"\n \n var optimize = true // can change for testing\n \n@@ -300,6 +301,11 @@ func (d *decimal) atof64() (f float64, ok bool) {\n \tif d.nd > 15 {\n \t\treturn\n \t}\n+\t// gccgo gets this wrong on 32-bit i386 when not using -msse.\n+\t// See TestRoundTrip in atof_test.go for a test case.\n+\tif runtime.GOARCH == \"386\" {\n+\t\treturn\n+\t}\n \tswitch {\n \tcase d.dp == d.nd: // int\n \t\tf := d.atof64int()"}, {"sha": "63d2fa44e02729adc12393aabe73341ddcc4aed9", "filename": "libgo/go/strconv/itoa_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fitoa_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -127,6 +127,7 @@ func TestUitoa(t *testing.T) {\n }\n \n func numAllocations(f func()) int {\n+\truntime.GC()\n \tmemstats := new(runtime.MemStats)\n \truntime.ReadMemStats(memstats)\n \tn0 := memstats.Mallocs"}, {"sha": "0b583411331a0be0e92c1e77ee2625356d13a320", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -9,134 +9,142 @@ import (\n \t\"strings\"\n )\n \n-// Fields are: [\"foo\" \"bar\" \"baz\"]\n func ExampleFields() {\n \tfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \"))\n+\t// Output: Fields are: [\"foo\" \"bar\" \"baz\"]\n }\n \n-// true\n-// false\n-// true\n-// true\n func ExampleContains() {\n \tfmt.Println(strings.Contains(\"seafood\", \"foo\"))\n \tfmt.Println(strings.Contains(\"seafood\", \"bar\"))\n \tfmt.Println(strings.Contains(\"seafood\", \"\"))\n \tfmt.Println(strings.Contains(\"\", \"\"))\n+\t// Output:\n+\t// true\n+\t// false\n+\t// true\n+\t// true\n }\n \n-// false\n-// true\n-// false\n-// false\n func ExampleContainsAny() {\n \tfmt.Println(strings.ContainsAny(\"team\", \"i\"))\n \tfmt.Println(strings.ContainsAny(\"failure\", \"u & i\"))\n \tfmt.Println(strings.ContainsAny(\"foo\", \"\"))\n \tfmt.Println(strings.ContainsAny(\"\", \"\"))\n-\n+\t// Output:\n+\t// false\n+\t// true\n+\t// false\n+\t// false\n }\n \n-// 3\n-// 5\n func ExampleCount() {\n \tfmt.Println(strings.Count(\"cheese\", \"e\"))\n \tfmt.Println(strings.Count(\"five\", \"\")) // before & after each rune\n+\t// Output:\n+\t// 3\n+\t// 5\n }\n \n-// true\n func ExampleEqualFold() {\n \tfmt.Println(strings.EqualFold(\"Go\", \"go\"))\n+\t// Output: true\n }\n \n-// 4\n-// -1\n func ExampleIndex() {\n \tfmt.Println(strings.Index(\"chicken\", \"ken\"))\n \tfmt.Println(strings.Index(\"chicken\", \"dmr\"))\n+\t// Output:\n+\t// 4\n+\t// -1\n }\n \n-// 4\n-// -1\n func ExampleRune() {\n \tfmt.Println(strings.IndexRune(\"chicken\", 'k'))\n \tfmt.Println(strings.IndexRune(\"chicken\", 'd'))\n+\t// Output:\n+\t// 4\n+\t// -1\n }\n \n-// 0\n-// 3\n-// -1\n func ExampleLastIndex() {\n \tfmt.Println(strings.Index(\"go gopher\", \"go\"))\n \tfmt.Println(strings.LastIndex(\"go gopher\", \"go\"))\n \tfmt.Println(strings.LastIndex(\"go gopher\", \"rodent\"))\n+\t// Output:\n+\t// 0\n+\t// 3\n+\t// -1\n }\n \n-// foo, bar, baz\n func ExampleJoin() {\n \ts := []string{\"foo\", \"bar\", \"baz\"}\n \tfmt.Println(strings.Join(s, \", \"))\n+\t// Output: foo, bar, baz\n }\n \n-// banana\n func ExampleRepeat() {\n \tfmt.Println(\"ba\" + strings.Repeat(\"na\", 2))\n+\t// Output: banana\n }\n \n-// oinky oinky oink\n-// moo moo moo\n func ExampleReplace() {\n \tfmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2))\n \tfmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1))\n+\t// Output:\n+\t// oinky oinky oink\n+\t// moo moo moo\n }\n \n-// [\"a\" \"b\" \"c\"]\n-// [\"\" \"man \" \"plan \" \"canal panama\"]\n-// [\" \" \"x\" \"y\" \"z\" \" \"]\n-// [\"\"]\n func ExampleSplit() {\n \tfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))\n \tfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))\n \tfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))\n \tfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))\n+\t// Output:\n+\t// [\"a\" \"b\" \"c\"]\n+\t// [\"\" \"man \" \"plan \" \"canal panama\"]\n+\t// [\" \" \"x\" \"y\" \"z\" \" \"]\n+\t// [\"\"]\n }\n \n-// [\"a\" \"b,c\"]\n-// [] (nil = true)\n func ExampleSplitN() {\n \tfmt.Printf(\"%q\\n\", strings.SplitN(\"a,b,c\", \",\", 2))\n \tz := strings.SplitN(\"a,b,c\", \",\", 0)\n \tfmt.Printf(\"%q (nil = %v)\\n\", z, z == nil)\n+\t// Output:\n+\t// [\"a\" \"b,c\"]\n+\t// [] (nil = true)\n }\n \n-// [\"a,\" \"b,\" \"c\"]\n func ExampleSplitAfter() {\n \tfmt.Printf(\"%q\\n\", strings.SplitAfter(\"a,b,c\", \",\"))\n+\t// Output: [\"a,\" \"b,\" \"c\"]\n }\n \n-// [\"a,\" \"b,c\"]\n func ExampleSplitAfterN() {\n \tfmt.Printf(\"%q\\n\", strings.SplitAfterN(\"a,b,c\", \",\", 2))\n+\t// Output: [\"a,\" \"b,c\"]\n }\n \n-// Her Royal Highness\n func ExampleTitle() {\n \tfmt.Println(strings.Title(\"her royal highness\"))\n+\t// Output: Her Royal Highness\n }\n \n-// LOUD NOISES\n-// \u0425\u041b\u0415\u0411\n func ExampleToTitle() {\n \tfmt.Println(strings.ToTitle(\"loud noises\"))\n \tfmt.Println(strings.ToTitle(\"\u0445\u043b\u0435\u0431\"))\n+\t// Output:\n+\t// LOUD NOISES\n+\t// \u0425\u041b\u0415\u0411\n }\n \n-// [Achtung]\n func ExampleTrim() {\n-\tfmt.Printf(\"[%s]\", strings.Trim(\" !!! Achtung !!! \", \"! \"))\n+\tfmt.Printf(\"[%q]\", strings.Trim(\" !!! Achtung !!! \", \"! \"))\n+\t// Output: [\"Achtung\"]\n }\n \n-// 'Gjnf oevyyvt naq gur fyvgul tbcure...\n func ExampleMap() {\n \trot13 := func(r rune) rune {\n \t\tswitch {\n@@ -148,25 +156,26 @@ func ExampleMap() {\n \t\treturn r\n \t}\n \tfmt.Println(strings.Map(rot13, \"'Twas brillig and the slithy gopher...\"))\n+\t// Output: 'Gjnf oevyyvt naq gur fyvgul tbcure...\n }\n \n-// a lone gopher\n func ExampleTrimSpace() {\n \tfmt.Println(strings.TrimSpace(\" \\t\\n a lone gopher \\n\\t\\r\\n\"))\n+\t// Output: a lone gopher\n }\n \n-// This is &lt;b&gt;HTML&lt;/b&gt;!\n func ExampleNewReplacer() {\n \tr := strings.NewReplacer(\"<\", \"&lt;\", \">\", \"&gt;\")\n \tfmt.Println(r.Replace(\"This is <b>HTML</b>!\"))\n+\t// Output: This is &lt;b&gt;HTML&lt;/b&gt;!\n }\n \n-// GOPHER\n func ExampleToUpper() {\n \tfmt.Println(strings.ToUpper(\"Gopher\"))\n+\t// Output: GOPHER\n }\n \n-// gopher\n func ExampleToLower() {\n \tfmt.Println(strings.ToLower(\"Gopher\"))\n+\t// Output: gopher\n }"}, {"sha": "1fc3deaf1e0c40013cc9b53cc210bf8f551dd6b6", "filename": "libgo/go/sync/cond.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fcond.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fcond.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fcond.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,8 +4,6 @@\n \n package sync\n \n-import \"runtime\"\n-\n // Cond implements a condition variable, a rendezvous point\n // for goroutines waiting for or announcing the occurrence\n // of an event.\n@@ -43,9 +41,10 @@ func NewCond(l Locker) *Cond {\n \n // Wait atomically unlocks c.L and suspends execution\n // of the calling goroutine.  After later resuming execution,\n-// Wait locks c.L before returning.\n+// Wait locks c.L before returning.  Unlike in other systems,\n+// Wait cannot return unless awoken by Broadcast or Signal.\n //\n-// Because L is not locked when Wait first resumes, the caller\n+// Because c.L is not locked when Wait first resumes, the caller\n // typically cannot assume that the condition is true when\n // Wait returns.  Instead, the caller should Wait in a loop:\n //\n@@ -65,7 +64,7 @@ func (c *Cond) Wait() {\n \tc.newWaiters++\n \tc.m.Unlock()\n \tc.L.Unlock()\n-\truntime.Semacquire(s)\n+\truntime_Semacquire(s)\n \tc.L.Lock()\n }\n \n@@ -84,7 +83,7 @@ func (c *Cond) Signal() {\n \t}\n \tif c.oldWaiters > 0 {\n \t\tc.oldWaiters--\n-\t\truntime.Semrelease(c.oldSema)\n+\t\truntime_Semrelease(c.oldSema)\n \t}\n \tc.m.Unlock()\n }\n@@ -98,13 +97,13 @@ func (c *Cond) Broadcast() {\n \t// Wake both generations.\n \tif c.oldWaiters > 0 {\n \t\tfor i := 0; i < c.oldWaiters; i++ {\n-\t\t\truntime.Semrelease(c.oldSema)\n+\t\t\truntime_Semrelease(c.oldSema)\n \t\t}\n \t\tc.oldWaiters = 0\n \t}\n \tif c.newWaiters > 0 {\n \t\tfor i := 0; i < c.newWaiters; i++ {\n-\t\t\truntime.Semrelease(c.newSema)\n+\t\t\truntime_Semrelease(c.newSema)\n \t\t}\n \t\tc.newWaiters = 0\n \t\tc.newSema = nil"}, {"sha": "1424b1e79e66021dac04c6779161b6744b0e4f68", "filename": "libgo/go/sync/example_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sync_test\n+\n+import (\n+\t\"net/http\"\n+\t\"sync\"\n+)\n+\n+// This example fetches several URLs concurrently,\n+// using a WaitGroup to block until all the fetches are complete.\n+func ExampleWaitGroup() {\n+\tvar wg sync.WaitGroup\n+\tvar urls = []string{\n+\t\t\"http://www.golang.org/\",\n+\t\t\"http://www.google.com/\",\n+\t\t\"http://www.somestupidname.com/\",\n+\t}\n+\tfor _, url := range urls {\n+\t\t// Increment the WaitGroup counter.\n+\t\twg.Add(1)\n+\t\t// Launch a goroutine to fetch the URL.\n+\t\tgo func(url string) {\n+\t\t\t// Fetch the URL.\n+\t\t\thttp.Get(url)\n+\t\t\t// Decrement the counter.\n+\t\t\twg.Done()\n+\t\t}(url)\n+\t}\n+\t// Wait for all HTTP fetches to complete.\n+\twg.Wait()\n+}"}, {"sha": "fa5983a2d1e5d23ccf3abb0091a036b1badf5dbb", "filename": "libgo/go/sync/export_test.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fexport_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sync\n+\n+// Export for testing.\n+var Runtime_Semacquire = runtime_Semacquire\n+var Runtime_Semrelease = runtime_Semrelease"}, {"sha": "9494cc3f82679f6cf364d91bb519727c7cfb54a2", "filename": "libgo/go/sync/mutex.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -10,10 +10,7 @@\n // Values containing the types defined in this package should not be copied.\n package sync\n \n-import (\n-\t\"runtime\"\n-\t\"sync/atomic\"\n-)\n+import \"sync/atomic\"\n \n // A Mutex is a mutual exclusion lock.\n // Mutexes can be created as part of other structures;\n@@ -60,7 +57,7 @@ func (m *Mutex) Lock() {\n \t\t\tif old&mutexLocked == 0 {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\truntime.Semacquire(&m.sema)\n+\t\t\truntime_Semacquire(&m.sema)\n \t\t\tawoke = true\n \t\t}\n \t}\n@@ -89,7 +86,7 @@ func (m *Mutex) Unlock() {\n \t\t// Grab the right to wake someone.\n \t\tnew = (old - 1<<mutexWaiterShift) | mutexWoken\n \t\tif atomic.CompareAndSwapInt32(&m.state, old, new) {\n-\t\t\truntime.Semrelease(&m.sema)\n+\t\t\truntime_Semrelease(&m.sema)\n \t\t\treturn\n \t\t}\n \t\told = m.state"}, {"sha": "bf78c6f609ca67c7e0ce42822521900dc089ac61", "filename": "libgo/go/sync/mutex_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -15,8 +15,8 @@ import (\n \n func HammerSemaphore(s *uint32, loops int, cdone chan bool) {\n \tfor i := 0; i < loops; i++ {\n-\t\truntime.Semacquire(s)\n-\t\truntime.Semrelease(s)\n+\t\tRuntime_Semacquire(s)\n+\t\tRuntime_Semrelease(s)\n \t}\n \tcdone <- true\n }"}, {"sha": "e99599c11ae36f6d8d8134a83ae568647aa3d148", "filename": "libgo/go/sync/runtime.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fruntime.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sync\n+\n+// defined in package runtime\n+\n+// Semacquire waits until *s > 0 and then atomically decrements it.\n+// It is intended as a simple sleep primitive for use by the synchronization\n+// library and should not be used directly.\n+func runtime_Semacquire(s *uint32)\n+\n+// Semrelease atomically increments *s and notifies a waiting goroutine\n+// if one is blocked in Semacquire.\n+// It is intended as a simple wakeup primitive for use by the synchronization\n+// library and should not be used directly.\n+func runtime_Semrelease(s *uint32)"}, {"sha": "57a8dbee78398f7173384c49f849f17af3c6cb0b", "filename": "libgo/go/sync/runtime_sema_test.go", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fruntime_sema_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fruntime_sema_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fruntime_sema_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,10 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package runtime_test\n+package sync_test\n \n import (\n \t\"runtime\"\n+\t. \"sync\"\n \t\"sync/atomic\"\n \t\"testing\"\n )\n@@ -25,8 +26,8 @@ func BenchmarkSemaUncontended(b *testing.B) {\n \t\t\tfor atomic.AddInt32(&N, -1) >= 0 {\n \t\t\t\truntime.Gosched()\n \t\t\t\tfor g := 0; g < CallsPerSched; g++ {\n-\t\t\t\t\truntime.Semrelease(&sem.sem)\n-\t\t\t\t\truntime.Semacquire(&sem.sem)\n+\t\t\t\t\tRuntime_Semrelease(&sem.sem)\n+\t\t\t\t\tRuntime_Semacquire(&sem.sem)\n \t\t\t\t}\n \t\t\t}\n \t\t\tc <- true\n@@ -48,7 +49,7 @@ func benchmarkSema(b *testing.B, block, work bool) {\n \tif block {\n \t\tfor p := 0; p < procs/2; p++ {\n \t\t\tgo func() {\n-\t\t\t\truntime.Semacquire(&sem)\n+\t\t\t\tRuntime_Semacquire(&sem)\n \t\t\t\tc2 <- true\n \t\t\t}()\n \t\t}\n@@ -59,18 +60,18 @@ func benchmarkSema(b *testing.B, block, work bool) {\n \t\t\tfor atomic.AddInt32(&N, -1) >= 0 {\n \t\t\t\truntime.Gosched()\n \t\t\t\tfor g := 0; g < CallsPerSched; g++ {\n-\t\t\t\t\truntime.Semrelease(&sem)\n+\t\t\t\t\tRuntime_Semrelease(&sem)\n \t\t\t\t\tif work {\n \t\t\t\t\t\tfor i := 0; i < LocalWork; i++ {\n \t\t\t\t\t\t\tfoo *= 2\n \t\t\t\t\t\t\tfoo /= 2\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\truntime.Semacquire(&sem)\n+\t\t\t\t\tRuntime_Semacquire(&sem)\n \t\t\t\t}\n \t\t\t}\n \t\t\tc <- foo == 42\n-\t\t\truntime.Semrelease(&sem)\n+\t\t\tRuntime_Semrelease(&sem)\n \t\t}()\n \t}\n \tif block {", "previous_filename": "libgo/go/runtime/sema_test.go"}, {"sha": "782a9c319682b9bade8a0204363b9cbce8f27edc", "filename": "libgo/go/sync/rwmutex.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Frwmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Frwmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,10 +4,7 @@\n \n package sync\n \n-import (\n-\t\"runtime\"\n-\t\"sync/atomic\"\n-)\n+import \"sync/atomic\"\n \n // An RWMutex is a reader/writer mutual exclusion lock.\n // The lock can be held by an arbitrary number of readers\n@@ -29,7 +26,7 @@ const rwmutexMaxReaders = 1 << 30\n func (rw *RWMutex) RLock() {\n \tif atomic.AddInt32(&rw.readerCount, 1) < 0 {\n \t\t// A writer is pending, wait for it.\n-\t\truntime.Semacquire(&rw.readerSem)\n+\t\truntime_Semacquire(&rw.readerSem)\n \t}\n }\n \n@@ -42,7 +39,7 @@ func (rw *RWMutex) RUnlock() {\n \t\t// A writer is pending.\n \t\tif atomic.AddInt32(&rw.readerWait, -1) == 0 {\n \t\t\t// The last reader unblocks the writer.\n-\t\t\truntime.Semrelease(&rw.writerSem)\n+\t\t\truntime_Semrelease(&rw.writerSem)\n \t\t}\n \t}\n }\n@@ -60,7 +57,7 @@ func (rw *RWMutex) Lock() {\n \tr := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\n \t// Wait for active readers.\n \tif r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {\n-\t\truntime.Semacquire(&rw.writerSem)\n+\t\truntime_Semacquire(&rw.writerSem)\n \t}\n }\n \n@@ -75,7 +72,7 @@ func (rw *RWMutex) Unlock() {\n \tr := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)\n \t// Unblock blocked readers, if any.\n \tfor i := 0; i < int(r); i++ {\n-\t\truntime.Semrelease(&rw.readerSem)\n+\t\truntime_Semrelease(&rw.readerSem)\n \t}\n \t// Allow other writers to proceed.\n \trw.w.Unlock()"}, {"sha": "3e7d9d3c8f4099cdadb0a1e7b1b202c2cd509a69", "filename": "libgo/go/sync/waitgroup.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,10 +4,7 @@\n \n package sync\n \n-import (\n-\t\"runtime\"\n-\t\"sync/atomic\"\n-)\n+import \"sync/atomic\"\n \n // A WaitGroup waits for a collection of goroutines to finish.\n // The main goroutine calls Add to set the number of\n@@ -60,7 +57,7 @@ func (wg *WaitGroup) Add(delta int) {\n \t}\n \twg.m.Lock()\n \tfor i := int32(0); i < wg.waiters; i++ {\n-\t\truntime.Semrelease(wg.sema)\n+\t\truntime_Semrelease(wg.sema)\n \t}\n \twg.waiters = 0\n \twg.sema = nil\n@@ -93,5 +90,5 @@ func (wg *WaitGroup) Wait() {\n \t}\n \ts := wg.sema\n \twg.m.Unlock()\n-\truntime.Semacquire(s)\n+\truntime_Semacquire(s)\n }"}, {"sha": "adc8c09f2173356269cbeca32f1aa0639e232e79", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -38,16 +38,25 @@\n //         }\n //     }\n //\n-// The package also runs and verifies example code. Example functions\n-// include an introductory comment that is compared with the standard output\n-// of the function when the tests are run, as in this example of an example:\n+// The package also runs and verifies example code. Example functions may\n+// include a concluding comment that begins with \"Output:\" and is compared with\n+// the standard output of the function when the tests are run, as in these\n+// examples of an example:\n //\n-//     // hello\n //     func ExampleHello() {\n //             fmt.Println(\"hello\")\n+//             // Output: hello\n //     }\n //\n-// Example functions without comments are compiled but not executed.\n+//     func ExampleSalutations() {\n+//             fmt.Println(\"hello, and\")\n+//             fmt.Println(\"goodbye\")\n+//             // Output:\n+//             // hello, and\n+//             // goodbye\n+//     }\n+//\n+// Example functions without output comments are compiled but not executed.\n //\n // The naming convention to declare examples for a function F, a type T and\n // method M on type T are:"}, {"sha": "20443cb1ffb84affd1215ad8beccfdcbdc4066a2", "filename": "libgo/go/text/tabwriter/example_test.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tabwriter_test\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"text/tabwriter\"\n+)\n+\n+func ExampleWriter_Init() {\n+\tw := new(tabwriter.Writer)\n+\n+\t// Format in tab-separated columns with a tab stop of 8.\n+\tw.Init(os.Stdout, 0, 8, 0, '\\t', 0)\n+\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n+\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n+\tfmt.Fprintln(w)\n+\tw.Flush()\n+\n+\t// Format right-aligned in space-separated columns of minimal width 5\n+\t// and at least one blank of padding (so wider column entries do not\n+\t// touch each other).\n+\tw.Init(os.Stdout, 5, 0, 1, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n+\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n+\tfmt.Fprintln(w)\n+\tw.Flush()\n+\n+\t// output:\n+\t// a\tb\tc\td\t\t.\n+\t// 123\t12345\t1234567\t123456789\t.\n+\t//\n+\t//     a     b       c         d.\n+\t//   123 12345 1234567 123456789.\n+}"}, {"sha": "ce84600d6049562e877316456faaaf815acbe429", "filename": "libgo/go/text/tabwriter/tabwriter.go", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -169,12 +169,6 @@ const (\n //\t\t\tto the tab width in the viewer displaying the result)\n //\tflags\t\tformatting control\n //\n-// To format in tab-separated columns with a tab stop of 8:\n-//\tb.Init(w, 8, 1, 8, '\\t', 0);\n-//\n-// To format in space-separated columns with at least 4 spaces between columns:\n-//\tb.Init(w, 0, 4, 8, ' ', 0);\n-//\n func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {\n \tif minwidth < 0 || tabwidth < 0 || padding < 0 {\n \t\tpanic(\"negative minwidth, tabwidth, or padding\")"}, {"sha": "ace53564737acb36c3db2c60a24e33dfe4c5ab85", "filename": "libgo/go/text/tabwriter/tabwriter_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,11 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package tabwriter\n+package tabwriter_test\n \n import (\n \t\"io\"\n \t\"testing\"\n+\t. \"text/tabwriter\"\n )\n \n type buffer struct {"}, {"sha": "ae91f4a5419d3e92804be54ee637704ee2e93f5c", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -22,6 +22,20 @@ Actions may not span newlines, although comments can.\n \n Once constructed, a template may be executed safely in parallel.\n \n+Here is a trivial example that prints \"17 items are made of wool\".\n+\n+\ttype Inventory struct {\n+\t\tMaterial string\n+\t\tCount    uint\n+\t}\n+\tsweaters := Inventory{\"wool\", 17}\n+\ttmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\n+\tif err != nil { panic(err) }\n+\terr = tmpl.Execute(os.Stdout, sweaters)\n+\tif err != nil { panic(err) }\n+\n+More intricate examples appear below.\n+\n Actions\n \n Here is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of\n@@ -128,6 +142,11 @@ An argument is a simple value, denoted by one of the following.\n \t    .Field1.Key1.Method1.Field2.Key2.Method2\n \t  Methods can also be evaluated on variables, including chaining:\n \t    $x.Method1.Field\n+\t- The name of a niladic function-valued struct field of the data,\n+\t  preceded by a period, such as\n+\t\t.Function\n+\t  Function-valued fields behave like methods (of structs) but do not\n+\t  pass a receiver.\n \t- The name of a niladic function, such as\n \t\tfun\n \t  The result is the value of invoking the function, fun(). The return\n@@ -148,6 +167,9 @@ value (argument) or a function or method call, possibly with multiple arguments:\n \t\tThe result is the value of calling the method with the\n \t\targuments:\n \t\t\tdot.Method(Argument1, etc.)\n+\t.Function [Argument...]\n+\t\tA function-valued field of a struct works like a method but does\n+\t\tnot pass the receiver.\n \tfunctionName [Argument...]\n \t\tThe result is the value of calling the function associated\n \t\twith the name:\n@@ -303,7 +325,7 @@ produce the text\n By construction, a template may reside in only one association. If it's\n necessary to have a template addressable from multiple associations, the\n template definition must be parsed multiple times to create distinct *Template\n-values.\n+values, or must be copied with the Clone or AddParseTree method.\n \n Parse may be called multiple times to assemble the various associated templates;\n see the ParseFiles and ParseGlob functions and methods for simple ways to parse"}, {"sha": "af745286c0bc3f6bc553c2f0e4a55a30be18fcb1", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -419,10 +419,14 @@ func (s *state) evalField(dot reflect.Value, fieldName string, args []parse.Node\n \t\ttField, ok := receiver.Type().FieldByName(fieldName)\n \t\tif ok {\n \t\t\tfield := receiver.FieldByIndex(tField.Index)\n-\t\t\tif hasArgs {\n-\t\t\t\ts.errorf(\"%s is not a method but has arguments\", fieldName)\n-\t\t\t}\n \t\t\tif tField.PkgPath == \"\" { // field is exported\n+\t\t\t\t// If it's a function, we must call it.\n+\t\t\t\tif field.Type().Kind() == reflect.Func {\n+\t\t\t\t\treturn s.evalCall(dot, field, fieldName, args, final)\n+\t\t\t\t}\n+\t\t\t\tif hasArgs {\n+\t\t\t\t\ts.errorf(\"%s is not a method or function but has arguments\", fieldName)\n+\t\t\t\t}\n \t\t\t\treturn field\n \t\t\t}\n \t\t}"}, {"sha": "159cf5100d933eaf0217bf685bc6f20e05d0915a", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -59,6 +59,8 @@ type T struct {\n \tPI  *int\n \tPSI *[]int\n \tNIL *int\n+\t// Function (not method)\n+\tFunc func(...string) string\n \t// Template to test evaluation of templates.\n \tTmpl *Template\n }\n@@ -118,6 +120,7 @@ var tVal = &T{\n \tErr:               errors.New(\"erroozle\"),\n \tPI:                newInt(23),\n \tPSI:               newIntSlice(21, 22, 23),\n+\tFunc:              func(s ...string) string { return fmt.Sprint(\"<\", strings.Join(s, \"+\"), \">\") },\n \tTmpl:              Must(New(\"x\").Parse(\"test template\")), // \"x\" is the value of .X\n }\n \n@@ -297,8 +300,13 @@ var execTests = []execTest{\n \t\t\"{{with $x := .}}{{with .SI}}{{$.GetU.TrueFalse $.True}}{{end}}{{end}}\",\n \t\t\"true\", tVal, true},\n \n+\t// Function call\n+\t{\".Func\", \"-{{.Func}}-\", \"-<>-\", tVal, true},\n+\t{\".Func2\", \"-{{.Func `he` `llo`}}-\", \"-<he+llo>-\", tVal, true},\n+\n \t// Pipelines.\n \t{\"pipeline\", \"-{{.Method0 | .Method2 .U16}}-\", \"-Method2: 16 M0-\", tVal, true},\n+\t{\"pipeline func\", \"-{{.Func `llo` | .Func `he` }}-\", \"-<he+<llo>>-\", tVal, true},\n \n \t// If.\n \t{\"if true\", \"{{if true}}TRUE{{end}}\", \"TRUE\", tVal, true},"}, {"sha": "f205e6be1b4ebf9d5743443de0af1c3515650c1a", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -193,7 +193,7 @@ func TestClone(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tclone := root.Clone()\n+\tclone := Must(root.Clone())\n \t// Add variants to both.\n \t_, err = root.Parse(cloneText3)\n \tif err != nil {"}, {"sha": "35194f7dfdb5ebeb570a2da1af4b1405e77214e9", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -2,8 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package parse builds parse trees for templates.  The grammar is defined\n-// in the documents for the template package.\n+// Package parse builds parse trees for templates as defined by text/template\n+// and html/template. Clients should use those packages to construct templates\n+// rather than this one, which provides shared internal data structures not\n+// intended for general use.\n package parse\n \n import ("}, {"sha": "7494f9d8c45a4286e90bf22c9bb85357e3c91498", "filename": "libgo/go/text/template/template.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -69,9 +69,9 @@ func (t *Template) init() {\n // templates. The actual representation is not copied, but the name space of\n // associated templates is, so further calls to Parse in the copy will add\n // templates to the copy but not to the original. Clone can be used to prepare\n-// common templates and use them with variant definitions for other templates by\n-// adding the variants after the clone is made.\n-func (t *Template) Clone() *Template {\n+// common templates and use them with variant definitions for other templates\n+// by adding the variants after the clone is made.\n+func (t *Template) Clone() (*Template, error) {\n \tnt := t.copy(nil)\n \tnt.init()\n \tnt.tmpl[t.name] = nt\n@@ -89,7 +89,7 @@ func (t *Template) Clone() *Template {\n \tfor k, v := range t.execFuncs {\n \t\tnt.execFuncs[k] = v\n \t}\n-\treturn nt\n+\treturn nt, nil\n }\n \n // copy returns a shallow copy of t, with common set to the argument."}, {"sha": "944cc789c3167e21480ee31c02c144b017168996", "filename": "libgo/go/time/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexample_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -51,8 +51,8 @@ func ExampleMonth() {\n \t}\n }\n \n-// Go launched at 2009-11-10 15:00:00 -0800 PST\n func ExampleDate() {\n \tt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n \tfmt.Printf(\"Go launched at %s\\n\", t.Local())\n+\t// Output: Go launched at 2009-11-10 15:00:00 -0800 PST\n }"}, {"sha": "8484729448eb96ec155e4942b8e69f8dcf8d050c", "filename": "libgo/go/time/sys_plan9.go", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,7 +6,10 @@\n \n package time\n \n-import \"syscall\"\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n \n // for testing: whatever interrupts a sleep\n func interrupt() {\n@@ -38,3 +41,36 @@ func readFile(name string) ([]byte, error) {\n \t}\n \treturn ret, err\n }\n+\n+func open(name string) (uintptr, error) {\n+\tfd, err := syscall.Open(name, syscall.O_RDONLY)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn uintptr(fd), nil\n+}\n+\n+func closefd(fd uintptr) {\n+\tsyscall.Close(int(fd))\n+}\n+\n+func preadn(fd uintptr, buf []byte, off int) error {\n+\twhence := 0\n+\tif off < 0 {\n+\t\twhence = 2\n+\t}\n+\tif _, err := syscall.Seek(int(fd), int64(off), whence); err != nil {\n+\t\treturn err\n+\t}\n+\tfor len(buf) > 0 {\n+\t\tm, err := syscall.Read(int(fd), buf)\n+\t\tif m <= 0 {\n+\t\t\tif err == nil {\n+\t\t\t\treturn errors.New(\"short read\")\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t\tbuf = buf[m:]\n+\t}\n+\treturn nil\n+}"}, {"sha": "7f69b492c9fdb1536899007515687797690e561a", "filename": "libgo/go/time/sys_unix.go", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,7 +6,10 @@\n \n package time\n \n-import \"syscall\"\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n \n // for testing: whatever interrupts a sleep\n func interrupt() {\n@@ -38,3 +41,36 @@ func readFile(name string) ([]byte, error) {\n \t}\n \treturn ret, err\n }\n+\n+func open(name string) (uintptr, error) {\n+\tfd, err := syscall.Open(name, syscall.O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn uintptr(fd), nil\n+}\n+\n+func closefd(fd uintptr) {\n+\tsyscall.Close(int(fd))\n+}\n+\n+func preadn(fd uintptr, buf []byte, off int) error {\n+\twhence := 0\n+\tif off < 0 {\n+\t\twhence = 2\n+\t}\n+\tif _, err := syscall.Seek(int(fd), int64(off), whence); err != nil {\n+\t\treturn err\n+\t}\n+\tfor len(buf) > 0 {\n+\t\tm, err := syscall.Read(int(fd), buf)\n+\t\tif m <= 0 {\n+\t\t\tif err == nil {\n+\t\t\t\treturn errors.New(\"short read\")\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t\tbuf = buf[m:]\n+\t}\n+\treturn nil\n+}"}, {"sha": "de63b4bf4bb87be5b8c7b17f038a640358b31180", "filename": "libgo/go/time/sys_windows.go", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fsys_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_windows.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,6 +4,70 @@\n \n package time\n \n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n // for testing: whatever interrupts a sleep\n func interrupt() {\n }\n+\n+// readFile reads and returns the content of the named file.\n+// It is a trivial implementation of ioutil.ReadFile, reimplemented\n+// here to avoid depending on io/ioutil or os.\n+func readFile(name string) ([]byte, error) {\n+\tf, err := syscall.Open(name, syscall.O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.Close(f)\n+\tvar (\n+\t\tbuf [4096]byte\n+\t\tret []byte\n+\t\tn   int\n+\t)\n+\tfor {\n+\t\tn, err = syscall.Read(f, buf[:])\n+\t\tif n > 0 {\n+\t\t\tret = append(ret, buf[:n]...)\n+\t\t}\n+\t\tif n == 0 || err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn ret, err\n+}\n+\n+func open(name string) (uintptr, error) {\n+\tfd, err := syscall.Open(name, syscall.O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn uintptr(fd), nil\n+}\n+\n+func closefd(fd uintptr) {\n+\tsyscall.Close(syscall.Handle(fd))\n+}\n+\n+func preadn(fd uintptr, buf []byte, off int) error {\n+\twhence := 0\n+\tif off < 0 {\n+\t\twhence = 2\n+\t}\n+\tif _, err := syscall.Seek(syscall.Handle(fd), int64(off), whence); err != nil {\n+\t\treturn err\n+\t}\n+\tfor len(buf) > 0 {\n+\t\tm, err := syscall.Read(syscall.Handle(fd), buf)\n+\t\tif m <= 0 {\n+\t\t\tif err == nil {\n+\t\t\t\treturn errors.New(\"short read\")\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t\tbuf = buf[m:]\n+\t}\n+\treturn nil\n+}"}, {"sha": "914f02c861c556a13f7572dea0b36bba701fda61", "filename": "libgo/go/time/tick_test.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Ftick_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Ftick_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick_test.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -12,9 +12,6 @@ import (\n func TestTicker(t *testing.T) {\n \tconst Count = 10\n \tDelta := 100 * Millisecond\n-\tif testing.Short() {\n-\t\tDelta = 10 * Millisecond\n-\t}\n \tticker := NewTicker(Delta)\n \tt0 := Now()\n \tfor i := 0; i < Count; i++ {"}, {"sha": "3c57744043e24383c666e49e5e27169b873eee55", "filename": "libgo/go/time/zoneinfo.go", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -4,7 +4,10 @@\n \n package time\n \n-import \"sync\"\n+import (\n+\t\"sync\"\n+\t\"syscall\"\n+)\n \n // A Location maps time instants to the zone in use at that time.\n // Typically, the Location represents the collection of time offsets\n@@ -168,10 +171,7 @@ func (l *Location) lookupOffset(offset int) (name string, isDST bool, ok bool) {\n // NOTE(rsc): Eventually we will need to accept the POSIX TZ environment\n // syntax too, but I don't feel like implementing it today.\n \n-// NOTE(rsc): Using the IANA names below means ensuring we have access\n-// to the database.  Probably we will ship the files in $GOROOT/lib/zoneinfo/\n-// and only look there if there are no system files available (such as on Windows).\n-// The files total 200 kB.\n+var zoneinfo, _ = syscall.Getenv(\"ZONEINFO\")\n \n // LoadLocation returns the Location with the given name.\n //\n@@ -180,12 +180,25 @@ func (l *Location) lookupOffset(offset int) (name string, isDST bool, ok bool) {\n //\n // Otherwise, the name is taken to be a location name corresponding to a file\n // in the IANA Time Zone database, such as \"America/New_York\".\n+//\n+// The time zone database needed by LoadLocation may not be\n+// present on all systems, especially non-Unix systems.\n+// LoadLocation looks in the directory or uncompressed zip file\n+// named by the ZONEINFO environment variable, if any, then looks in\n+// known installation locations on Unix systems,\n+// and finally looks in $GOROOT/lib/time/zoneinfo.zip.\n func LoadLocation(name string) (*Location, error) {\n \tif name == \"\" || name == \"UTC\" {\n \t\treturn UTC, nil\n \t}\n \tif name == \"Local\" {\n \t\treturn Local, nil\n \t}\n+\tif zoneinfo != \"\" {\n+\t\tif z, err := loadZoneFile(zoneinfo, name); err == nil {\n+\t\t\tz.name = name\n+\t\t\treturn z, nil\n+\t\t}\n+\t}\n \treturn loadLocation(name)\n }"}, {"sha": "6855238dc84f0b4c2456b93d066fd5dc14504b1a", "filename": "libgo/go/time/zoneinfo_plan9.go", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -8,11 +8,10 @@ package time\n \n import (\n \t\"errors\"\n+\t\"runtime\"\n \t\"syscall\"\n )\n \n-var badData = errors.New(\"malformed time zone information\")\n-\n func isSpace(r rune) bool {\n \treturn r == ' ' || r == '\\t' || r == '\\n'\n }\n@@ -51,7 +50,7 @@ func fields(s string) []string {\n \treturn a\n }\n \n-func loadZoneData(s string) (l *Location, err error) {\n+func loadZoneDataPlan9(s string) (l *Location, err error) {\n \tf := fields(s)\n \tif len(f) < 4 {\n \t\tif len(f) == 2 && f[0] == \"GMT\" {\n@@ -112,33 +111,32 @@ func loadZoneData(s string) (l *Location, err error) {\n \treturn l, nil\n }\n \n-func loadZoneFile(name string) (*Location, error) {\n+func loadZoneFilePlan9(name string) (*Location, error) {\n \tb, err := readFile(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn loadZoneData(string(b))\n+\treturn loadZoneDataPlan9(string(b))\n }\n \n func initTestingZone() {\n-\tif z, err := loadZoneFile(\"/adm/timezone/US_Pacific\"); err == nil {\n-\t\tlocalLoc = *z\n-\t\treturn\n+\tz, err := loadLocation(\"America/Los_Angeles\")\n+\tif err != nil {\n+\t\tpanic(\"cannot load America/Los_Angeles for testing: \" + err.Error())\n \t}\n-\n-\t// Fall back to UTC.\n-\tlocalLoc.name = \"UTC\"\n+\tz.name = \"Local\"\n+\tlocalLoc = *z\n }\n \n func initLocal() {\n \tt, ok := syscall.Getenv(\"timezone\")\n \tif ok {\n-\t\tif z, err := loadZoneData(t); err == nil {\n+\t\tif z, err := loadZoneDataPlan9(t); err == nil {\n \t\t\tlocalLoc = *z\n \t\t\treturn\n \t\t}\n \t} else {\n-\t\tif z, err := loadZoneFile(\"/adm/timezone/local\"); err == nil {\n+\t\tif z, err := loadZoneFilePlan9(\"/adm/timezone/local\"); err == nil {\n \t\t\tlocalLoc = *z\n \t\t\tlocalLoc.name = \"Local\"\n \t\t\treturn\n@@ -150,7 +148,8 @@ func initLocal() {\n }\n \n func loadLocation(name string) (*Location, error) {\n-\tif z, err := loadZoneFile(\"/adm/timezone/\" + name); err == nil {\n+\tif z, err := loadZoneFile(runtime.GOROOT()+\"/lib/time/zoneinfo.zip\", name); err == nil {\n+\t\tz.name = name\n \t\treturn z, nil\n \t}\n \treturn nil, errors.New(\"unknown time zone \" + name)"}, {"sha": "ebb4205a98fd960bafa36f2fbff302e4f855eade", "filename": "libgo/go/time/zoneinfo_read.go", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -0,0 +1,341 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Parse \"zoneinfo\" time zone file.\n+// This is a fairly standard file format used on OS X, Linux, BSD, Sun, and others.\n+// See tzfile(5), http://en.wikipedia.org/wiki/Zoneinfo,\n+// and ftp://munnari.oz.au/pub/oldtz/\n+\n+package time\n+\n+import \"errors\"\n+\n+const (\n+\theaderSize = 4 + 16 + 4*7\n+)\n+\n+// Simple I/O interface to binary blob of data.\n+type data struct {\n+\tp     []byte\n+\terror bool\n+}\n+\n+func (d *data) read(n int) []byte {\n+\tif len(d.p) < n {\n+\t\td.p = nil\n+\t\td.error = true\n+\t\treturn nil\n+\t}\n+\tp := d.p[0:n]\n+\td.p = d.p[n:]\n+\treturn p\n+}\n+\n+func (d *data) big4() (n uint32, ok bool) {\n+\tp := d.read(4)\n+\tif len(p) < 4 {\n+\t\td.error = true\n+\t\treturn 0, false\n+\t}\n+\treturn uint32(p[0])<<24 | uint32(p[1])<<16 | uint32(p[2])<<8 | uint32(p[3]), true\n+}\n+\n+func (d *data) byte() (n byte, ok bool) {\n+\tp := d.read(1)\n+\tif len(p) < 1 {\n+\t\td.error = true\n+\t\treturn 0, false\n+\t}\n+\treturn p[0], true\n+}\n+\n+// Make a string by stopping at the first NUL\n+func byteString(p []byte) string {\n+\tfor i := 0; i < len(p); i++ {\n+\t\tif p[i] == 0 {\n+\t\t\treturn string(p[0:i])\n+\t\t}\n+\t}\n+\treturn string(p)\n+}\n+\n+var badData = errors.New(\"malformed time zone information\")\n+\n+func loadZoneData(bytes []byte) (l *Location, err error) {\n+\td := data{bytes, false}\n+\n+\t// 4-byte magic \"TZif\"\n+\tif magic := d.read(4); string(magic) != \"TZif\" {\n+\t\treturn nil, badData\n+\t}\n+\n+\t// 1-byte version, then 15 bytes of padding\n+\tvar p []byte\n+\tif p = d.read(16); len(p) != 16 || p[0] != 0 && p[0] != '2' {\n+\t\treturn nil, badData\n+\t}\n+\n+\t// six big-endian 32-bit integers:\n+\t//\tnumber of UTC/local indicators\n+\t//\tnumber of standard/wall indicators\n+\t//\tnumber of leap seconds\n+\t//\tnumber of transition times\n+\t//\tnumber of local time zones\n+\t//\tnumber of characters of time zone abbrev strings\n+\tconst (\n+\t\tNUTCLocal = iota\n+\t\tNStdWall\n+\t\tNLeap\n+\t\tNTime\n+\t\tNZone\n+\t\tNChar\n+\t)\n+\tvar n [6]int\n+\tfor i := 0; i < 6; i++ {\n+\t\tnn, ok := d.big4()\n+\t\tif !ok {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\tn[i] = int(nn)\n+\t}\n+\n+\t// Transition times.\n+\ttxtimes := data{d.read(n[NTime] * 4), false}\n+\n+\t// Time zone indices for transition times.\n+\ttxzones := d.read(n[NTime])\n+\n+\t// Zone info structures\n+\tzonedata := data{d.read(n[NZone] * 6), false}\n+\n+\t// Time zone abbreviations.\n+\tabbrev := d.read(n[NChar])\n+\n+\t// Leap-second time pairs\n+\td.read(n[NLeap] * 8)\n+\n+\t// Whether tx times associated with local time types\n+\t// are specified as standard time or wall time.\n+\tisstd := d.read(n[NStdWall])\n+\n+\t// Whether tx times associated with local time types\n+\t// are specified as UTC or local time.\n+\tisutc := d.read(n[NUTCLocal])\n+\n+\tif d.error { // ran out of data\n+\t\treturn nil, badData\n+\t}\n+\n+\t// If version == 2, the entire file repeats, this time using\n+\t// 8-byte ints for txtimes and leap seconds.\n+\t// We won't need those until 2106.\n+\n+\t// Now we can build up a useful data structure.\n+\t// First the zone information.\n+\t//\tutcoff[4] isdst[1] nameindex[1]\n+\tzone := make([]zone, n[NZone])\n+\tfor i := range zone {\n+\t\tvar ok bool\n+\t\tvar n uint32\n+\t\tif n, ok = zonedata.big4(); !ok {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\tzone[i].offset = int(n)\n+\t\tvar b byte\n+\t\tif b, ok = zonedata.byte(); !ok {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\tzone[i].isDST = b != 0\n+\t\tif b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\tzone[i].name = byteString(abbrev[b:])\n+\t}\n+\n+\t// Now the transition time info.\n+\ttx := make([]zoneTrans, n[NTime])\n+\tfor i := range tx {\n+\t\tvar ok bool\n+\t\tvar n uint32\n+\t\tif n, ok = txtimes.big4(); !ok {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\ttx[i].when = int64(int32(n))\n+\t\tif int(txzones[i]) >= len(zone) {\n+\t\t\treturn nil, badData\n+\t\t}\n+\t\ttx[i].index = txzones[i]\n+\t\tif i < len(isstd) {\n+\t\t\ttx[i].isstd = isstd[i] != 0\n+\t\t}\n+\t\tif i < len(isutc) {\n+\t\t\ttx[i].isutc = isutc[i] != 0\n+\t\t}\n+\t}\n+\n+\t// Commited to succeed.\n+\tl = &Location{zone: zone, tx: tx}\n+\n+\t// Fill in the cache with information about right now,\n+\t// since that will be the most common lookup.\n+\tsec, _ := now()\n+\tfor i := range tx {\n+\t\tif tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {\n+\t\t\tl.cacheStart = tx[i].when\n+\t\t\tl.cacheEnd = 1<<63 - 1\n+\t\t\tif i+1 < len(tx) {\n+\t\t\t\tl.cacheEnd = tx[i+1].when\n+\t\t\t}\n+\t\t\tl.cacheZone = &l.zone[tx[i].index]\n+\t\t}\n+\t}\n+\n+\treturn l, nil\n+}\n+\n+func loadZoneFile(dir, name string) (l *Location, err error) {\n+\tif len(dir) > 4 && dir[len(dir)-4:] == \".zip\" {\n+\t\treturn loadZoneZip(dir, name)\n+\t}\n+\tif dir != \"\" {\n+\t\tname = dir + \"/\" + name\n+\t}\n+\tbuf, err := readFile(name)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn loadZoneData(buf)\n+}\n+\n+// There are 500+ zoneinfo files.  Rather than distribute them all\n+// individually, we ship them in an uncompressed zip file.\n+// Used this way, the zip file format serves as a commonly readable\n+// container for the individual small files.  We choose zip over tar\n+// because zip files have a contiguous table of contents, making\n+// individual file lookups faster, and because the per-file overhead\n+// in a zip file is considerably less than tar's 512 bytes.\n+\n+// get4 returns the little-endian 32-bit value in b.\n+func get4(b []byte) int {\n+\tif len(b) < 4 {\n+\t\treturn 0\n+\t}\n+\treturn int(b[0]) | int(b[1])<<8 | int(b[2])<<16 | int(b[3])<<24\n+}\n+\n+// get2 returns the little-endian 16-bit value in b.\n+func get2(b []byte) int {\n+\tif len(b) < 2 {\n+\t\treturn 0\n+\t}\n+\treturn int(b[0]) | int(b[1])<<8\n+}\n+\n+func loadZoneZip(zipfile, name string) (l *Location, err error) {\n+\tfd, err := open(zipfile)\n+\tif err != nil {\n+\t\treturn nil, errors.New(\"open \" + zipfile + \": \" + err.Error())\n+\t}\n+\tdefer closefd(fd)\n+\n+\tconst (\n+\t\tzecheader = 0x06054b50\n+\t\tzcheader  = 0x02014b50\n+\t\tztailsize = 22\n+\n+\t\tzheadersize = 30\n+\t\tzheader     = 0x04034b50\n+\t)\n+\n+\tbuf := make([]byte, ztailsize)\n+\tif err := preadn(fd, buf, -ztailsize); err != nil || get4(buf) != zecheader {\n+\t\treturn nil, errors.New(\"corrupt zip file \" + zipfile)\n+\t}\n+\tn := get2(buf[10:])\n+\tsize := get4(buf[12:])\n+\toff := get4(buf[16:])\n+\n+\tbuf = make([]byte, size)\n+\tif err := preadn(fd, buf, off); err != nil {\n+\t\treturn nil, errors.New(\"corrupt zip file \" + zipfile)\n+\t}\n+\n+\tfor i := 0; i < n; i++ {\n+\t\t// zip entry layout:\n+\t\t//\t0\tmagic[4]\n+\t\t//\t4\tmadevers[1]\n+\t\t//\t5\tmadeos[1]\n+\t\t//\t6\textvers[1]\n+\t\t//\t7\textos[1]\n+\t\t//\t8\tflags[2]\n+\t\t//\t10\tmeth[2]\n+\t\t//\t12\tmodtime[2]\n+\t\t//\t14\tmoddate[2]\n+\t\t//\t16\tcrc[4]\n+\t\t//\t20\tcsize[4]\n+\t\t//\t24\tuncsize[4]\n+\t\t//\t28\tnamelen[2]\n+\t\t//\t30\txlen[2]\n+\t\t//\t32\tfclen[2]\n+\t\t//\t34\tdisknum[2]\n+\t\t//\t36\tiattr[2]\n+\t\t//\t38\teattr[4]\n+\t\t//\t42\toff[4]\n+\t\t//\t46\tname[namelen]\n+\t\t//\t46+namelen+xlen+fclen - next header\n+\t\t//\t\t\n+\t\tif get4(buf) != zcheader {\n+\t\t\tbreak\n+\t\t}\n+\t\tmeth := get2(buf[10:])\n+\t\tsize := get4(buf[24:])\n+\t\tnamelen := get2(buf[28:])\n+\t\txlen := get2(buf[30:])\n+\t\tfclen := get2(buf[32:])\n+\t\toff := get4(buf[42:])\n+\t\tzname := buf[46 : 46+namelen]\n+\t\tbuf = buf[46+namelen+xlen+fclen:]\n+\t\tif string(zname) != name {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif meth != 0 {\n+\t\t\treturn nil, errors.New(\"unsupported compression for \" + name + \" in \" + zipfile)\n+\t\t}\n+\n+\t\t// zip per-file header layout:\n+\t\t//\t0\tmagic[4]\n+\t\t//\t4\textvers[1]\n+\t\t//\t5\textos[1]\n+\t\t//\t6\tflags[2]\n+\t\t//\t8\tmeth[2]\n+\t\t//\t10\tmodtime[2]\n+\t\t//\t12\tmoddate[2]\n+\t\t//\t14\tcrc[4]\n+\t\t//\t18\tcsize[4]\n+\t\t//\t22\tuncsize[4]\n+\t\t//\t26\tnamelen[2]\n+\t\t//\t28\txlen[2]\n+\t\t//\t30\tname[namelen]\n+\t\t//\t30+namelen+xlen - file data\n+\t\t//\n+\t\tbuf = make([]byte, zheadersize+namelen)\n+\t\tif err := preadn(fd, buf, off); err != nil ||\n+\t\t\tget4(buf) != zheader ||\n+\t\t\tget2(buf[8:]) != meth ||\n+\t\t\tget2(buf[26:]) != namelen ||\n+\t\t\tstring(buf[30:30+namelen]) != name {\n+\t\t\treturn nil, errors.New(\"corrupt zip file \" + zipfile)\n+\t\t}\n+\t\txlen = get2(buf[28:])\n+\n+\t\tbuf = make([]byte, size)\n+\t\tif err := preadn(fd, buf, off+30+namelen+xlen); err != nil {\n+\t\t\treturn nil, errors.New(\"corrupt zip file \" + zipfile)\n+\t\t}\n+\n+\t\treturn loadZoneData(buf)\n+\t}\n+\n+\treturn nil, errors.New(\"cannot find \" + name + \" in zip file \" + zipfile)\n+}"}, {"sha": "1bf1f11e24f3bc3e867c8db6d0e78ca7f6c50852", "filename": "libgo/go/time/zoneinfo_unix.go", "status": "modified", "additions": 4, "deletions": 193, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -13,200 +13,10 @@ package time\n \n import (\n \t\"errors\"\n+\t\"runtime\"\n \t\"syscall\"\n )\n \n-const (\n-\theaderSize = 4 + 16 + 4*7\n-)\n-\n-// Simple I/O interface to binary blob of data.\n-type data struct {\n-\tp     []byte\n-\terror bool\n-}\n-\n-func (d *data) read(n int) []byte {\n-\tif len(d.p) < n {\n-\t\td.p = nil\n-\t\td.error = true\n-\t\treturn nil\n-\t}\n-\tp := d.p[0:n]\n-\td.p = d.p[n:]\n-\treturn p\n-}\n-\n-func (d *data) big4() (n uint32, ok bool) {\n-\tp := d.read(4)\n-\tif len(p) < 4 {\n-\t\td.error = true\n-\t\treturn 0, false\n-\t}\n-\treturn uint32(p[0])<<24 | uint32(p[1])<<16 | uint32(p[2])<<8 | uint32(p[3]), true\n-}\n-\n-func (d *data) byte() (n byte, ok bool) {\n-\tp := d.read(1)\n-\tif len(p) < 1 {\n-\t\td.error = true\n-\t\treturn 0, false\n-\t}\n-\treturn p[0], true\n-}\n-\n-// Make a string by stopping at the first NUL\n-func byteString(p []byte) string {\n-\tfor i := 0; i < len(p); i++ {\n-\t\tif p[i] == 0 {\n-\t\t\treturn string(p[0:i])\n-\t\t}\n-\t}\n-\treturn string(p)\n-}\n-\n-var badData = errors.New(\"malformed time zone information\")\n-\n-func loadZoneData(bytes []byte) (l *Location, err error) {\n-\td := data{bytes, false}\n-\n-\t// 4-byte magic \"TZif\"\n-\tif magic := d.read(4); string(magic) != \"TZif\" {\n-\t\treturn nil, badData\n-\t}\n-\n-\t// 1-byte version, then 15 bytes of padding\n-\tvar p []byte\n-\tif p = d.read(16); len(p) != 16 || p[0] != 0 && p[0] != '2' {\n-\t\treturn nil, badData\n-\t}\n-\n-\t// six big-endian 32-bit integers:\n-\t//\tnumber of UTC/local indicators\n-\t//\tnumber of standard/wall indicators\n-\t//\tnumber of leap seconds\n-\t//\tnumber of transition times\n-\t//\tnumber of local time zones\n-\t//\tnumber of characters of time zone abbrev strings\n-\tconst (\n-\t\tNUTCLocal = iota\n-\t\tNStdWall\n-\t\tNLeap\n-\t\tNTime\n-\t\tNZone\n-\t\tNChar\n-\t)\n-\tvar n [6]int\n-\tfor i := 0; i < 6; i++ {\n-\t\tnn, ok := d.big4()\n-\t\tif !ok {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\tn[i] = int(nn)\n-\t}\n-\n-\t// Transition times.\n-\ttxtimes := data{d.read(n[NTime] * 4), false}\n-\n-\t// Time zone indices for transition times.\n-\ttxzones := d.read(n[NTime])\n-\n-\t// Zone info structures\n-\tzonedata := data{d.read(n[NZone] * 6), false}\n-\n-\t// Time zone abbreviations.\n-\tabbrev := d.read(n[NChar])\n-\n-\t// Leap-second time pairs\n-\td.read(n[NLeap] * 8)\n-\n-\t// Whether tx times associated with local time types\n-\t// are specified as standard time or wall time.\n-\tisstd := d.read(n[NStdWall])\n-\n-\t// Whether tx times associated with local time types\n-\t// are specified as UTC or local time.\n-\tisutc := d.read(n[NUTCLocal])\n-\n-\tif d.error { // ran out of data\n-\t\treturn nil, badData\n-\t}\n-\n-\t// If version == 2, the entire file repeats, this time using\n-\t// 8-byte ints for txtimes and leap seconds.\n-\t// We won't need those until 2106.\n-\n-\t// Now we can build up a useful data structure.\n-\t// First the zone information.\n-\t//\tutcoff[4] isdst[1] nameindex[1]\n-\tzone := make([]zone, n[NZone])\n-\tfor i := range zone {\n-\t\tvar ok bool\n-\t\tvar n uint32\n-\t\tif n, ok = zonedata.big4(); !ok {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\tzone[i].offset = int(n)\n-\t\tvar b byte\n-\t\tif b, ok = zonedata.byte(); !ok {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\tzone[i].isDST = b != 0\n-\t\tif b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\tzone[i].name = byteString(abbrev[b:])\n-\t}\n-\n-\t// Now the transition time info.\n-\ttx := make([]zoneTrans, n[NTime])\n-\tfor i := range tx {\n-\t\tvar ok bool\n-\t\tvar n uint32\n-\t\tif n, ok = txtimes.big4(); !ok {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\ttx[i].when = int64(int32(n))\n-\t\tif int(txzones[i]) >= len(zone) {\n-\t\t\treturn nil, badData\n-\t\t}\n-\t\ttx[i].index = txzones[i]\n-\t\tif i < len(isstd) {\n-\t\t\ttx[i].isstd = isstd[i] != 0\n-\t\t}\n-\t\tif i < len(isutc) {\n-\t\t\ttx[i].isutc = isutc[i] != 0\n-\t\t}\n-\t}\n-\n-\t// Commited to succeed.\n-\tl = &Location{zone: zone, tx: tx}\n-\n-\t// Fill in the cache with information about right now,\n-\t// since that will be the most common lookup.\n-\tsec, _ := now()\n-\tfor i := range tx {\n-\t\tif tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {\n-\t\t\tl.cacheStart = tx[i].when\n-\t\t\tl.cacheEnd = 1<<63 - 1\n-\t\t\tif i+1 < len(tx) {\n-\t\t\t\tl.cacheEnd = tx[i+1].when\n-\t\t\t}\n-\t\t\tl.cacheZone = &l.zone[tx[i].index]\n-\t\t}\n-\t}\n-\n-\treturn l, nil\n-}\n-\n-func loadZoneFile(name string) (l *Location, err error) {\n-\tbuf, err := readFile(name)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\treturn loadZoneData(buf)\n-}\n-\n func initTestingZone() {\n \tsyscall.Setenv(\"TZ\", \"America/Los_Angeles\")\n \tinitLocal()\n@@ -218,6 +28,7 @@ var zoneDirs = []string{\n \t\"/usr/share/zoneinfo/\",\n \t\"/usr/share/lib/zoneinfo/\",\n \t\"/usr/lib/locale/TZ/\",\n+\truntime.GOROOT() + \"/lib/time/zoneinfo/\",\n }\n \n func initLocal() {\n@@ -229,7 +40,7 @@ func initLocal() {\n \ttz, ok := syscall.Getenv(\"TZ\")\n \tswitch {\n \tcase !ok:\n-\t\tz, err := loadZoneFile(\"/etc/localtime\")\n+\t\tz, err := loadZoneFile(\"\", \"/etc/localtime\")\n \t\tif err == nil {\n \t\t\tlocalLoc = *z\n \t\t\tlocalLoc.name = \"Local\"\n@@ -248,7 +59,7 @@ func initLocal() {\n \n func loadLocation(name string) (*Location, error) {\n \tfor _, zoneDir := range zoneDirs {\n-\t\tif z, err := loadZoneFile(zoneDir + name); err == nil {\n+\t\tif z, err := loadZoneFile(zoneDir, name); err == nil {\n \t\t\tz.name = name\n \t\t\treturn z, nil\n \t\t}"}, {"sha": "754e392decabe0c1304aa144f297cf1662409cd3", "filename": "libgo/go/time/zoneinfo_windows.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -6,6 +6,7 @@ package time\n \n import (\n \t\"errors\"\n+\t\"runtime\"\n \t\"syscall\"\n )\n \n@@ -151,7 +152,10 @@ func initLocal() {\n \tinitLocalFromTZI(&i)\n }\n \n-// TODO(rsc): Implement.\n func loadLocation(name string) (*Location, error) {\n+\tif z, err := loadZoneFile(runtime.GOROOT()+`\\lib\\time\\zoneinfo.zip`, name); err == nil {\n+\t\tz.name = name\n+\t\treturn z, nil\n+\t}\n \treturn nil, errors.New(\"unknown time zone \" + name)\n }"}, {"sha": "23641e8298f71dbdb565c9fda2562b0265d2bc6e", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -19,6 +19,7 @@ package runtime\n #include \"go-type.h\"\n \n MHeap runtime_mheap;\n+\n extern MStats mstats;\t// defined in extern.go\n \n extern volatile int32 runtime_MemProfileRate\n@@ -429,18 +430,6 @@ func new(typ *Type) (ret *uint8) {\n \tret = runtime_mallocgc(typ->__size, flag, 1, 1);\n }\n \n-func Alloc(n uintptr) (p *byte) {\n-\tp = runtime_malloc(n);\n-}\n-\n-func Free(p *byte) {\n-\truntime_free(p);\n-}\n-\n-func Lookup(p *byte) (base *byte, size uintptr) {\n-\truntime_mlookup(p, &base, &size, nil);\n-}\n-\n func GC() {\n \truntime_gc(1);\n }"}, {"sha": "4cb07477f1534ecbc59d09ae5702c97905c17d15", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -205,6 +205,7 @@ struct MStats\n \tuint64\theap_sys;\t// bytes obtained from system\n \tuint64\theap_idle;\t// bytes in idle spans\n \tuint64\theap_inuse;\t// bytes in non-idle spans\n+\tuint64\theap_released;\t// bytes released to the OS\n \tuint64\theap_objects;\t// total number of allocated objects\n \n \t// Statistics about allocation of low-level fixed-size structures.\n@@ -220,6 +221,7 @@ struct MStats\n \t// Statistics about garbage collector.\n \t// Protected by stopping the world during GC.\n \tuint64\tnext_gc;\t// next GC (in heap_alloc time)\n+\tuint64  last_gc;\t// last GC (in absolute time)\n \tuint64\tpause_total_ns;\n \tuint64\tpause_ns[256];\n \tuint32\tnumgc;\n@@ -304,14 +306,16 @@ struct MSpan\n {\n \tMSpan\t*next;\t\t// in a span linked list\n \tMSpan\t*prev;\t\t// in a span linked list\n-\tMSpan\t*allnext;\t\t// in the list of all spans\n+\tMSpan\t*allnext;\t// in the list of all spans\n \tPageID\tstart;\t\t// starting page number\n \tuintptr\tnpages;\t\t// number of pages in span\n \tMLink\t*freelist;\t// list of free objects\n \tuint32\tref;\t\t// number of allocated objects in this span\n \tuint32\tsizeclass;\t// size class\n \tuint32\tstate;\t\t// MSpanInUse etc\n-\tbyte\t*limit;\t// end of data in span\n+\tint64   unusedsince;\t// First time spotted by GC in MSpanFree state\n+\tuintptr npreleased;\t// number of pages released to the OS\n+\tbyte\t*limit;\t\t// end of data in span\n };\n \n void\truntime_MSpan_Init(MSpan *span, PageID start, uintptr npages);\n@@ -381,6 +385,7 @@ MSpan*\truntime_MHeap_LookupMaybe(MHeap *h, void *v);\n void\truntime_MGetSizeClassInfo(int32 sizeclass, uintptr *size, int32 *npages, int32 *nobj);\n void*\truntime_MHeap_SysAlloc(MHeap *h, uintptr n);\n void\truntime_MHeap_MapBits(MHeap *h);\n+void\truntime_MHeap_Scavenger(void*);\n \n void*\truntime_mallocgc(uintptr size, uint32 flag, int32 dogc, int32 zeroed);\n int32\truntime_mlookup(void *v, byte **base, uintptr *size, MSpan **s);\n@@ -406,19 +411,11 @@ enum\n \n void\truntime_MProf_Malloc(void*, uintptr);\n void\truntime_MProf_Free(void*, uintptr);\n+void\truntime_MProf_GC(void);\n void\truntime_MProf_Mark(void (*scan)(byte *, int64));\n int32\truntime_helpgc(bool*);\n void\truntime_gchelper(void);\n \n-// Malloc profiling settings.\n-// Must match definition in extern.go.\n-enum {\n-\tMProf_None = 0,\n-\tMProf_Sample = 1,\n-\tMProf_All = 2,\n-};\n-extern int32 runtime_malloc_profile;\n-\n struct __go_func_type;\n bool\truntime_getfinalizer(void *p, bool del, void (**fn)(void*), const struct __go_func_type **ft);\n void\truntime_walkfintab(void (*fn)(void*), void (*scan)(byte *, int64));"}, {"sha": "d852946cdbb6c6f3e9f7f3bb02febc5e88148b8c", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -61,6 +61,21 @@ enum {\n \n #define bitMask (bitBlockBoundary | bitAllocated | bitMarked | bitSpecial)\n \n+// Holding worldsema grants an M the right to try to stop the world.\n+// The procedure is:\n+//\n+//\truntime_semacquire(&runtime_worldsema);\n+//\tm->gcing = 1;\n+//\truntime_stoptheworld();\n+//\n+//\t... do stuff ...\n+//\n+//\tm->gcing = 0;\n+//\truntime_semrelease(&runtime_worldsema);\n+//\truntime_starttheworld();\n+//\n+uint32 runtime_worldsema = 1;\n+\n // TODO: Make these per-M.\n static uint64 nhandoff;\n \n@@ -92,7 +107,6 @@ struct FinBlock\n \tFinalizer fin[1];\n };\n \n-\n static G *fing;\n static FinBlock *finq; // list of finalizers that are to be executed\n static FinBlock *finc; // cache of free blocks\n@@ -778,9 +792,11 @@ sweep(void)\n \tbyte *p;\n \tMCache *c;\n \tbyte *arena_start;\n+\tint64 now;\n \n \tm = runtime_m();\n \tarena_start = runtime_mheap.arena_start;\n+\tnow = runtime_nanotime();\n \n \tfor(;;) {\n \t\ts = work.spans;\n@@ -789,6 +805,11 @@ sweep(void)\n \t\tif(!runtime_casp(&work.spans, s, s->allnext))\n \t\t\tcontinue;\n \n+\t\t// Stamp newly unused spans. The scavenger will use that\n+\t\t// info to potentially give back some pages to the OS.\n+\t\tif(s->state == MSpanFree && s->unusedsince == 0)\n+\t\t\ts->unusedsince = now;\n+\n \t\tif(s->state != MSpanInUse)\n \t\t\tcontinue;\n \n@@ -875,11 +896,6 @@ runtime_gchelper(void)\n \t\truntime_notewakeup(&work.alldone);\n }\n \n-// Semaphore, not Lock, so that the goroutine\n-// reschedules when there is contention rather\n-// than spinning.\n-static uint32 gcsema = 1;\n-\n // Initialized from $GOGC.  GOGC=off means no gc.\n //\n // Next gc is after we've allocated an extra amount of\n@@ -968,9 +984,9 @@ runtime_gc(int32 force)\n \tif(gcpercent < 0)\n \t\treturn;\n \n-\truntime_semacquire(&gcsema);\n+\truntime_semacquire(&runtime_worldsema);\n \tif(!force && mstats.heap_alloc < mstats.next_gc) {\n-\t\truntime_semrelease(&gcsema);\n+\t\truntime_semrelease(&runtime_worldsema);\n \t\treturn;\n \t}\n \n@@ -1032,6 +1048,7 @@ runtime_gc(int32 force)\n \tobj1 = mstats.nmalloc - mstats.nfree;\n \n \tt3 = runtime_nanotime();\n+\tmstats.last_gc = t3;\n \tmstats.pause_ns[mstats.numgc%nelem(mstats.pause_ns)] = t3 - t0;\n \tmstats.pause_total_ns += t3 - t0;\n \tmstats.numgc++;\n@@ -1045,8 +1062,9 @@ runtime_gc(int32 force)\n \t\t\t(unsigned long long) mstats.nmalloc, (unsigned long long)mstats.nfree,\n \t\t\t(unsigned long long) nhandoff);\n \t}\n-\n-\truntime_semrelease(&gcsema);\n+\t\n+\truntime_MProf_GC();\n+\truntime_semrelease(&runtime_worldsema);\n \n \t// If we could have used another helper proc, start one now,\n \t// in the hope that it will be available next time.\n@@ -1073,18 +1091,18 @@ runtime_ReadMemStats(MStats *stats)\n {\n \tM *m;\n \n-\t// Have to acquire gcsema to stop the world,\n+\t// Have to acquire worldsema to stop the world,\n \t// because stoptheworld can only be used by\n \t// one goroutine at a time, and there might be\n \t// a pending garbage collection already calling it.\n-\truntime_semacquire(&gcsema);\n+\truntime_semacquire(&runtime_worldsema);\n \tm = runtime_m();\n \tm->gcing = 1;\n \truntime_stoptheworld();\n \tcachestats();\n \t*stats = mstats;\n \tm->gcing = 0;\n-\truntime_semrelease(&gcsema);\n+\truntime_semrelease(&runtime_worldsema);\n \truntime_starttheworld(false);\n }\n "}, {"sha": "79359d9dfcafacf1ddfa064b5a4ce764efc819e7", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -103,6 +103,8 @@ MHeap_AllocLocked(MHeap *h, uintptr npage, int32 sizeclass)\n \truntime_MSpanList_Remove(s);\n \ts->state = MSpanInUse;\n \tmstats.heap_idle -= s->npages<<PageShift;\n+\tmstats.heap_released -= s->npreleased<<PageShift;\n+\ts->npreleased = 0;\n \n \tif(s->npages > npage) {\n \t\t// Trim extra and put it back in the heap.\n@@ -280,6 +282,8 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \t}\n \tmstats.heap_idle += s->npages<<PageShift;\n \ts->state = MSpanFree;\n+\ts->unusedsince = 0;\n+\ts->npreleased = 0;\n \truntime_MSpanList_Remove(s);\n \tsp = (uintptr*)(s->start<<PageShift);\n \n@@ -292,6 +296,7 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \t\t*tp |= *sp;\t// propagate \"needs zeroing\" mark\n \t\ts->start = t->start;\n \t\ts->npages += t->npages;\n+\t\ts->npreleased = t->npreleased; // absorb released pages\n \t\tp -= t->npages;\n \t\th->map[p] = s;\n \t\truntime_MSpanList_Remove(t);\n@@ -304,6 +309,7 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \t\ttp = (uintptr*)(t->start<<PageShift);\n \t\t*sp |= *tp;\t// propagate \"needs zeroing\" mark\n \t\ts->npages += t->npages;\n+\t\ts->npreleased += t->npreleased;\n \t\th->map[p + s->npages - 1] = s;\n \t\truntime_MSpanList_Remove(t);\n \t\tt->state = MSpanDead;\n@@ -317,8 +323,86 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \t\truntime_MSpanList_Insert(&h->free[s->npages], s);\n \telse\n \t\truntime_MSpanList_Insert(&h->large, s);\n+}\n \n-\t// TODO(rsc): IncrementalScavenge() to return memory to OS.\n+// Release (part of) unused memory to OS.\n+// Goroutine created in runtime_schedinit.\n+// Loop forever.\n+void\n+runtime_MHeap_Scavenger(void* dummy)\n+{\n+\tMHeap *h;\n+\tMSpan *s, *list;\n+\tuint64 tick, now, forcegc, limit;\n+\tuint32 k, i;\n+\tuintptr released, sumreleased;\n+\tconst byte *env;\n+\tbool trace;\n+\tNote note;\n+\n+\tUSED(dummy);\n+\n+\t// If we go two minutes without a garbage collection, force one to run.\n+\tforcegc = 2*60*1e9;\n+\t// If a span goes unused for 5 minutes after a garbage collection,\n+\t// we hand it back to the operating system.\n+\tlimit = 5*60*1e9;\n+\t// Make wake-up period small enough for the sampling to be correct.\n+\tif(forcegc < limit)\n+\t\ttick = forcegc/2;\n+\telse\n+\t\ttick = limit/2;\n+\n+\ttrace = false;\n+\tenv = runtime_getenv(\"GOGCTRACE\");\n+\tif(env != nil)\n+\t\ttrace = runtime_atoi(env) > 0;\n+\n+\th = &runtime_mheap;\n+\tfor(k=0;; k++) {\n+\t\truntime_noteclear(&note);\n+\t\truntime_entersyscall();\n+\t\truntime_notetsleep(&note, tick);\n+\t\truntime_exitsyscall();\n+\n+\t\truntime_lock(h);\n+\t\tnow = runtime_nanotime();\n+\t\tif(now - mstats.last_gc > forcegc) {\n+\t\t\truntime_unlock(h);\n+\t\t\truntime_gc(1);\n+\t\t\truntime_lock(h);\n+\t\t\tnow = runtime_nanotime();\n+\t\t\tif (trace)\n+\t\t\t\truntime_printf(\"scvg%d: GC forced\\n\", k);\n+\t\t}\n+\t\tsumreleased = 0;\n+\t\tfor(i=0; i < nelem(h->free)+1; i++) {\n+\t\t\tif(i < nelem(h->free))\n+\t\t\t\tlist = &h->free[i];\n+\t\t\telse\n+\t\t\t\tlist = &h->large;\n+\t\t\tif(runtime_MSpanList_IsEmpty(list))\n+\t\t\t\tcontinue;\n+\t\t\tfor(s=list->next; s != list; s=s->next) {\n+\t\t\t\tif(s->unusedsince != 0 && (now - s->unusedsince) > limit) {\n+\t\t\t\t\treleased = (s->npages - s->npreleased) << PageShift;\n+\t\t\t\t\tmstats.heap_released += released;\n+\t\t\t\t\tsumreleased += released;\n+\t\t\t\t\ts->npreleased = s->npages;\n+\t\t\t\t\truntime_SysUnused((void*)(s->start << PageShift), s->npages << PageShift);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\truntime_unlock(h);\n+\n+\t\tif(trace) {\n+\t\t\tif(sumreleased > 0)\n+\t\t\t\truntime_printf(\"scvg%d: %p MB released\\n\", k, (void*)(sumreleased>>20));\n+\t\t\truntime_printf(\"scvg%d: inuse: %lld, idle: %lld, sys: %lld, released: %lld, consumed: %lld (MB)\\n\",\n+\t\t\t\tk, (long long)(mstats.heap_inuse>>20), (long long)(mstats.heap_idle>>20), (long long)(mstats.heap_sys>>20),\n+\t\t\t\t(long long)(mstats.heap_released>>20), (long long)((mstats.heap_sys - mstats.heap_released)>>20));\n+\t\t}\n+\t}\n }\n \n // Initialize a new span with the given start and npages.\n@@ -333,6 +417,8 @@ runtime_MSpan_Init(MSpan *span, PageID start, uintptr npages)\n \tspan->ref = 0;\n \tspan->sizeclass = 0;\n \tspan->state = 0;\n+\tspan->unusedsince = 0;\n+\tspan->npreleased = 0;\n }\n \n // Initialize an empty doubly-linked list."}, {"sha": "e40dd61f7848c48178cf51e37c2b86a9925840e6", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 121, "deletions": 8, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -26,6 +26,10 @@ struct Bucket\n \tuintptr\tfrees;\n \tuintptr\talloc_bytes;\n \tuintptr\tfree_bytes;\n+\tuintptr\trecent_allocs;  // since last gc\n+\tuintptr\trecent_frees;\n+\tuintptr\trecent_alloc_bytes;\n+\tuintptr\trecent_free_bytes;\n \tuintptr\thash;\n \tuintptr\tnstk;\n \tuintptr\tstk[1];\n@@ -39,7 +43,7 @@ static uintptr bucketmem;\n \n // Return the bucket for stk[0:nstk], allocating new bucket if needed.\n static Bucket*\n-stkbucket(uintptr *stk, int32 nstk)\n+stkbucket(uintptr *stk, int32 nstk, bool alloc)\n {\n \tint32 i;\n \tuintptr h;\n@@ -66,6 +70,9 @@ stkbucket(uintptr *stk, int32 nstk)\n \t\t   runtime_mcmp((byte*)b->stk, (byte*)stk, nstk*sizeof stk[0]) == 0)\n \t\t\treturn b;\n \n+\tif(!alloc)\n+\t\treturn nil;\n+\n \tb = runtime_mallocgc(sizeof *b + nstk*sizeof stk[0], FlagNoProfiling, 0, 1);\n \tbucketmem += sizeof *b + nstk*sizeof stk[0];\n \truntime_memmove(b->stk, stk, nstk*sizeof stk[0]);\n@@ -78,6 +85,26 @@ stkbucket(uintptr *stk, int32 nstk)\n \treturn b;\n }\n \n+// Record that a gc just happened: all the 'recent' statistics are now real.\n+void\n+runtime_MProf_GC(void)\n+{\n+\tBucket *b;\n+\t\n+\truntime_lock(&proflock);\n+\tfor(b=buckets; b; b=b->allnext) {\n+\t\tb->allocs += b->recent_allocs;\n+\t\tb->frees += b->recent_frees;\n+\t\tb->alloc_bytes += b->recent_alloc_bytes;\n+\t\tb->free_bytes += b->recent_free_bytes;\n+\t\tb->recent_allocs = 0;\n+\t\tb->recent_frees = 0;\n+\t\tb->recent_alloc_bytes = 0;\n+\t\tb->recent_free_bytes = 0;\n+\t}\n+\truntime_unlock(&proflock);\n+}\n+\n // Map from pointer to Bucket* that allocated it.\n // Three levels:\n //\tLinked-list hash table for top N-20 bits.\n@@ -204,9 +231,9 @@ runtime_MProf_Malloc(void *p, uintptr size)\n \tnstk = 0;\n #endif\n \truntime_lock(&proflock);\n-\tb = stkbucket(stk, nstk);\n-\tb->allocs++;\n-\tb->alloc_bytes += size;\n+\tb = stkbucket(stk, nstk, true);\n+\tb->recent_allocs++;\n+\tb->recent_alloc_bytes += size;\n \tsetaddrbucket((uintptr)p, b);\n \truntime_unlock(&proflock);\n \tm = runtime_m();\n@@ -228,8 +255,8 @@ runtime_MProf_Free(void *p, uintptr size)\n \truntime_lock(&proflock);\n \tb = getaddrbucket((uintptr)p);\n \tif(b != nil) {\n-\t\tb->frees++;\n-\t\tb->free_bytes += size;\n+\t\tb->recent_frees++;\n+\t\tb->recent_free_bytes += size;\n \t}\n \truntime_unlock(&proflock);\n \tm = runtime_m();\n@@ -293,13 +320,13 @@ runtime_MProf_Mark(void (*scan)(byte *, int64))\n \tscan((byte*)&addrfree, sizeof addrfree);\n }\n \n-// Must match ThreadProfileRecord in debug.go.\n+// Must match StackRecord in debug.go.\n typedef struct TRecord TRecord;\n struct TRecord {\n \tuintptr stk[32];\n };\n \n-func ThreadProfile(p Slice) (n int32, ok bool) {\n+func ThreadCreateProfile(p Slice) (n int32, ok bool) {\n \tTRecord *r;\n \tM *first, *m;\n \t\n@@ -317,3 +344,89 @@ func ThreadProfile(p Slice) (n int32, ok bool) {\n \t\t}\n \t}\n }\n+\n+func Stack(b Slice, all bool) (n int32) {\n+\tbyte *pc, *sp;\n+\t\n+\tsp = runtime_getcallersp(&b);\n+\tpc = runtime_getcallerpc(&b);\n+\n+\tif(all) {\n+\t\truntime_semacquire(&runtime_worldsema);\n+\t\truntime_m()->gcing = 1;\n+\t\truntime_stoptheworld();\n+\t}\n+\n+\tif(b.__count == 0)\n+\t\tn = 0;\n+\telse{\n+\t\tG* g = runtime_g();\n+\t\tg->writebuf = (byte*)b.__values;\n+\t\tg->writenbuf = b.__count;\n+\t\tUSED(pc);\n+\t\tUSED(sp);\n+\t\t// runtime_goroutineheader(g);\n+\t\t// runtime_traceback(pc, sp, 0, g);\n+\t\t// if(all)\n+\t\t//\truntime_tracebackothers(g);\n+\t\tn = b.__count - g->writenbuf;\n+\t\tg->writebuf = nil;\n+\t\tg->writenbuf = 0;\n+\t}\n+\t\n+\tif(all) {\n+\t\truntime_m()->gcing = 0;\n+\t\truntime_semrelease(&runtime_worldsema);\n+\t\truntime_starttheworld(false);\n+\t}\n+}\n+\n+static void\n+saveg(byte *pc, byte *sp, G *g, TRecord *r)\n+{\n+\tint32 n;\n+\n+\tUSED(pc);\n+\tUSED(sp);\n+\tUSED(g);\n+\t// n = runtime_gentraceback(pc, sp, 0, g, 0, r->stk, nelem(r->stk));\n+\tn = 0;\n+\tif((size_t)n < nelem(r->stk))\n+\t\tr->stk[n] = 0;\n+}\n+\n+func GoroutineProfile(b Slice) (n int32, ok bool) {\n+\tbyte *pc, *sp;\n+\tTRecord *r;\n+\tG *gp;\n+\t\n+\tsp = runtime_getcallersp(&b);\n+\tpc = runtime_getcallerpc(&b);\n+\t\n+\tok = false;\n+\tn = runtime_gcount();\n+\tif(n <= b.__count) {\n+\t\truntime_semacquire(&runtime_worldsema);\n+\t\truntime_m()->gcing = 1;\n+\t\truntime_stoptheworld();\n+\n+\t\tn = runtime_gcount();\n+\t\tif(n <= b.__count) {\n+\t\t\tG* g = runtime_g();\n+\t\t\tok = true;\n+\t\t\tr = (TRecord*)b.__values;\n+\t\t\tsaveg(pc, sp, g, r++);\n+\t\t\tfor(gp = runtime_allg; gp != nil; gp = gp->alllink) {\n+\t\t\t\tif(gp == g || gp->status == Gdead)\n+\t\t\t\t\tcontinue;\n+\t\t\t\t//saveg(gp->sched.pc, gp->sched.sp, gp, r++);\n+\t\t\t\tr++;\n+\t\t\t}\n+\t\t}\n+\t\n+\t\truntime_m()->gcing = 0;\n+\t\truntime_semrelease(&runtime_worldsema);\n+\t\truntime_starttheworld(false);\n+\t}\n+}\n+"}, {"sha": "d0ae09c45a096a77a3b3df44b686489fca42f05b", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -362,6 +362,9 @@ runtime_mcall(void (*pfn)(G*))\n \t}\n }\n \n+// Keep trace of scavenger's goroutine for deadlock detection.\n+static G *scvg;\n+\n // The bootstrap sequence is:\n //\n //\tcall osinit\n@@ -413,6 +416,8 @@ runtime_schedinit(void)\n \t// Can not enable GC until all roots are registered.\n \t// mstats.enablegc = 1;\n \tm->nomemprof--;\n+\n+\tscvg = __go_go(runtime_MHeap_Scavenger, nil);\n }\n \n extern void main_init(void) __asm__ (\"__go_init_main\");\n@@ -547,7 +552,7 @@ mcommoninit(M *m)\n \t// Add to runtime_allm so garbage collector doesn't free m\n \t// when it is just in a register or thread-local storage.\n \tm->alllink = runtime_allm;\n-\t// runtime_Cgocalls() iterates over allm w/o schedlock,\n+\t// runtime_NumCgoCall() iterates over allm w/o schedlock,\n \t// so we need to publish it safely.\n \truntime_atomicstorep(&runtime_allm, m);\n }\n@@ -786,9 +791,12 @@ nextgandunlock(void)\n \t\tmput(m);\n \t}\n \n-\tv = runtime_atomicload(&runtime_sched.atomic);\n-\tif(runtime_sched.grunning == 0)\n-\t\truntime_throw(\"all goroutines are asleep - deadlock!\");\n+\t// Look for deadlock situation: one single active g which happens to be scvg.\n+\tif(runtime_sched.grunning == 1 && runtime_sched.gwait == 0) {\n+\t\tif(scvg->status == Grunning || scvg->status == Gsyscall)\n+\t\t\truntime_throw(\"all goroutines are asleep - deadlock!\");\n+\t}\n+\n \tm->nextg = nil;\n \tm->waitnextg = 1;\n \truntime_noteclear(&m->havenextg);\n@@ -797,6 +805,7 @@ nextgandunlock(void)\n \t// Entersyscall might have decremented mcpu too, but if so\n \t// it will see the waitstop and take the slow path.\n \t// Exitsyscall never increments mcpu beyond mcpumax.\n+\tv = runtime_atomicload(&runtime_sched.atomic);\n \tif(atomic_waitstop(v) && atomic_mcpu(v) <= atomic_mcpumax(v)) {\n \t\t// set waitstop = 0 (known to be 1)\n \t\truntime_xadd(&runtime_sched.atomic, -1<<waitstopShift);\n@@ -1472,11 +1481,17 @@ runtime_mid()\n \treturn m->id;\n }\n \n-int32 runtime_Goroutines (void)\n-  __asm__ (\"libgo_runtime.runtime.Goroutines\");\n+int32 runtime_NumGoroutine (void)\n+  __asm__ (\"libgo_runtime.runtime.NumGoroutine\");\n+\n+int32\n+runtime_NumGoroutine()\n+{\n+\treturn runtime_sched.gcount;\n+}\n \n int32\n-runtime_Goroutines()\n+runtime_gcount(void)\n {\n \treturn runtime_sched.gcount;\n }"}, {"sha": "113bb7163c524962b50449def4fd39540e4e088d", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -143,6 +143,8 @@ struct\tG\n \tM*\tlockedm;\n \tM*\tidlem;\n \t// int32\tsig;\n+\tint32\twritenbuf;\n+\tbyte*\twritebuf;\n \t// uintptr\tsigcode0;\n \t// uintptr\tsigcode1;\n \t// uintptr\tsigpc;\n@@ -189,9 +191,9 @@ struct\tSigTab\n enum\n {\n \tSigNotify = 1<<0,\t// let signal.Notify have signal, even if from kernel\n-\tSigKill = 1<<1,  // if signal.Notify doesn't take it, exit quietly\n-\tSigThrow = 1<<2,  // if signal.Notify doesn't take it, exit loudly\n-\tSigPanic = 1<<3,  // if the signal is from the kernel, panic\n+\tSigKill = 1<<1,\t\t// if signal.Notify doesn't take it, exit quietly\n+\tSigThrow = 1<<2,\t// if signal.Notify doesn't take it, exit loudly\n+\tSigPanic = 1<<3,\t// if the signal is from the kernel, panic\n \tSigDefault = 1<<4,\t// if the signal isn't explicitly requested, don't monitor it\n };\n \n@@ -277,6 +279,7 @@ void\truntime_panicstring(const char*) __attribute__ ((noreturn));\n void*\truntime_mal(uintptr);\n void\truntime_schedinit(void);\n void\truntime_initsig(void);\n+void\truntime_sigenable(uint32 sig);\n String\truntime_gostringnocopy(const byte*);\n void*\truntime_mstart(void*);\n G*\truntime_malg(int32, byte**, size_t*);\n@@ -296,6 +299,7 @@ int64\truntime_cputicks(void);\n \n void\truntime_stoptheworld(void);\n void\truntime_starttheworld(bool);\n+extern uint32 runtime_worldsema;\n G*\t__go_go(void (*pfn)(void*), void*);\n \n /*\n@@ -348,6 +352,7 @@ void\truntime_futexwakeup(uint32*, uint32);\n #define runtime_munmap munmap\n #define runtime_madvise madvise\n #define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n+#define runtime_getcallerpc(p) __builtin_return_address(0)\n \n #ifdef __rtems__\n void __wrap_rtems_task_variable_add(void **);\n@@ -373,8 +378,6 @@ void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n #define runtime_exit(s) exit(s)\n MCache*\truntime_allocmcache(void);\n void\tfree(void *v);\n-struct __go_func_type;\n-bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *);\n #define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_casp(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_xadd(p, v) __sync_add_and_fetch (p, v)\n@@ -384,6 +387,11 @@ bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *\n #define runtime_atomicloadp(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n #define runtime_atomicstorep(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n \n+struct __go_func_type;\n+bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *);\n+#define runtime_getcallersp(p) __builtin_frame_address(1)\n+int32\truntime_mcount(void);\n+int32\truntime_gcount(void);\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n void\truntime_startpanic(void);\n void\truntime_ready(G*);"}, {"sha": "ff9c4f2e19e5f64fc5d70950270da3ecc97ec16d", "filename": "libgo/runtime/sema.goc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fsema.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fsema.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsema.goc?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -17,7 +17,7 @@\n // See Mullender and Cox, ``Semaphores in Plan 9,''\n // http://swtch.com/semaphore.pdf\n \n-package runtime\n+package sync\n #include \"runtime.h\"\n #include \"arch.h\"\n \n@@ -172,10 +172,10 @@ runtime_semrelease(uint32 volatile *addr)\n \t\truntime_ready(s->g);\n }\n \n-func Semacquire(addr *uint32) {\n+func runtime_Semacquire(addr *uint32) {\n \truntime_semacquire(addr);\n }\n \n-func Semrelease(addr *uint32) {\n+func runtime_Semrelease(addr *uint32) {\n \truntime_semrelease(addr);\n }"}, {"sha": "be7c5920cbc5b4230fa1db2ea4f5b976a92a30d3", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -142,10 +142,12 @@ func signal_enable(s uint32) {\n \t\t// Special case: want everything.\n \t\tfor(i=0; (size_t)i<nelem(sig.wanted); i++)\n \t\t\tsig.wanted[i] = ~(uint32)0;\n+\t\truntime_sigenable(s);\n \t\treturn;\n \t}\n \n \tif(s >= nelem(sig.wanted)*32)\n \t\treturn;\n \tsig.wanted[s/32] |= 1U<<(s&31);\n+\truntime_sigenable(s);\n }"}]}