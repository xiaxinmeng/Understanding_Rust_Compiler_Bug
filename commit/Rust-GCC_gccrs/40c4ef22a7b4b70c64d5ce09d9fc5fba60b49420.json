{"sha": "40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjNGVmMjJhN2I0YjcwYzY0ZDVjZTA5ZDlmYzVmYmE2MGI0OTQyMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:18:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:18:02Z"}, "message": "[55/77] Use scalar_int_mode in simplify_const_unary_operation\n\nThe main scalar integer block in simplify_const_unary_operation\nhad the condition:\n\n  if (CONST_SCALAR_INT_P (op) && width > 0)\n\nwhere \"width > 0\" was a roundabout way of testing != VOIDmode.\nThis patch replaces it with a check for a scalar_int_mode instead.\nIt also uses the number of bits in the input rather than the output\nmode to determine the result of a \"count ... bits in zero\" operation.\n(At the momemnt these modes have to be the same, but it still seems\nconceptually wrong to use the number of bits in the output mode.)\n\nThe handling of float->integer ops also checked \"width > 0\",\nbut this was redundant with the earlier check for MODE_INT.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* simplify-rtx.c (simplify_const_unary_operation): Use\n\tis_a <scalar_int_mode> instead of checking for a nonzero\n\tprecision.  Forcibly convert op_mode to a scalar_int_mode\n\tin that case.  More clearly differentiate the operand and\n\tresult modes and use the former when deciding what the value\n\tof a count-bits operation should be.  Use is_int_mode instead\n\tof checking for a MODE_INT.  Remove redundant check for whether\n\tthis mode has a zero precision.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251507", "tree": {"sha": "57fa235f3897bab7e0a51a665855058d39d292d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57fa235f3897bab7e0a51a665855058d39d292d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420/comments", "author": null, "committer": null, "parents": [{"sha": "3c84109eae52da59c09e8a91bfb5e79bd0527809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c84109eae52da59c09e8a91bfb5e79bd0527809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c84109eae52da59c09e8a91bfb5e79bd0527809"}], "stats": {"total": 48, "additions": 32, "deletions": 16}, "files": [{"sha": "7d3d304117aa6c6b0cab006651a529574234c926", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* simplify-rtx.c (simplify_const_unary_operation): Use\n+\tis_a <scalar_int_mode> instead of checking for a nonzero\n+\tprecision.  Forcibly convert op_mode to a scalar_int_mode\n+\tin that case.  More clearly differentiate the operand and\n+\tresult modes and use the former when deciding what the value\n+\tof a count-bits operation should be.  Use is_int_mode instead\n+\tof checking for a MODE_INT.  Remove redundant check for whether\n+\tthis mode has a zero precision.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e729bd8ff894e5afc248035be23d4256811e644f", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=40c4ef22a7b4b70c64d5ce09d9fc5fba60b49420", "patch": "@@ -1694,7 +1694,7 @@ rtx\n simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t\t\t\trtx op, machine_mode op_mode)\n {\n-  unsigned int width = GET_MODE_PRECISION (mode);\n+  scalar_int_mode result_mode;\n \n   if (code == VEC_DUPLICATE)\n     {\n@@ -1809,10 +1809,13 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n       return const_double_from_real_value (d, mode);\n     }\n \n-  if (CONST_SCALAR_INT_P (op) && width > 0)\n+  if (CONST_SCALAR_INT_P (op) && is_a <scalar_int_mode> (mode, &result_mode))\n     {\n+      unsigned int width = GET_MODE_PRECISION (result_mode);\n       wide_int result;\n-      machine_mode imode = op_mode == VOIDmode ? mode : op_mode;\n+      scalar_int_mode imode = (op_mode == VOIDmode\n+\t\t\t       ? result_mode\n+\t\t\t       : as_a <scalar_int_mode> (op_mode));\n       rtx_mode_t op0 = rtx_mode_t (op, imode);\n       int int_value;\n \n@@ -1841,35 +1844,35 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t  break;\n \n \tcase FFS:\n-\t  result = wi::shwi (wi::ffs (op0), mode);\n+\t  result = wi::shwi (wi::ffs (op0), result_mode);\n \t  break;\n \n \tcase CLZ:\n \t  if (wi::ne_p (op0, 0))\n \t    int_value = wi::clz (op0);\n-\t  else if (! CLZ_DEFINED_VALUE_AT_ZERO (mode, int_value))\n-\t    int_value = GET_MODE_PRECISION (mode);\n-\t  result = wi::shwi (int_value, mode);\n+\t  else if (! CLZ_DEFINED_VALUE_AT_ZERO (imode, int_value))\n+\t    int_value = GET_MODE_PRECISION (imode);\n+\t  result = wi::shwi (int_value, result_mode);\n \t  break;\n \n \tcase CLRSB:\n-\t  result = wi::shwi (wi::clrsb (op0), mode);\n+\t  result = wi::shwi (wi::clrsb (op0), result_mode);\n \t  break;\n \n \tcase CTZ:\n \t  if (wi::ne_p (op0, 0))\n \t    int_value = wi::ctz (op0);\n-\t  else if (! CTZ_DEFINED_VALUE_AT_ZERO (mode, int_value))\n-\t    int_value = GET_MODE_PRECISION (mode);\n-\t  result = wi::shwi (int_value, mode);\n+\t  else if (! CTZ_DEFINED_VALUE_AT_ZERO (imode, int_value))\n+\t    int_value = GET_MODE_PRECISION (imode);\n+\t  result = wi::shwi (int_value, result_mode);\n \t  break;\n \n \tcase POPCOUNT:\n-\t  result = wi::shwi (wi::popcount (op0), mode);\n+\t  result = wi::shwi (wi::popcount (op0), result_mode);\n \t  break;\n \n \tcase PARITY:\n-\t  result = wi::shwi (wi::parity (op0), mode);\n+\t  result = wi::shwi (wi::parity (op0), result_mode);\n \t  break;\n \n \tcase BSWAP:\n@@ -1890,7 +1893,7 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t  return 0;\n \t}\n \n-      return immed_wide_int_const (result, mode);\n+      return immed_wide_int_const (result, result_mode);\n     }\n \n   else if (CONST_DOUBLE_AS_FLOAT_P (op) \n@@ -1950,9 +1953,9 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n     }\n   else if (CONST_DOUBLE_AS_FLOAT_P (op)\n \t   && SCALAR_FLOAT_MODE_P (GET_MODE (op))\n-\t   && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && width > 0)\n+\t   && is_int_mode (mode, &result_mode))\n     {\n+      unsigned int width = GET_MODE_PRECISION (result_mode);\n       /* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX\n \t operators are intentionally left unspecified (to ease implementation\n \t by target backends), for consistency, this routine implements the"}]}