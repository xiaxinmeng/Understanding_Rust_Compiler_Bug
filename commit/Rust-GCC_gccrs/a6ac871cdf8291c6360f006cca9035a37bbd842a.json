{"sha": "a6ac871cdf8291c6360f006cca9035a37bbd842a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhYzg3MWNkZjgyOTFjNjM2MGYwMDZjY2E5MDM1YTM3YmJkODQyYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-11-08T13:29:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-11-08T13:29:32Z"}, "message": "[AArch64] Optimized implementation of search_line_fast for the CPP lexer\n\n\t  * lex.c (search_line_fast): New implementation for AArch64.\n\nFrom-SVN: r241964", "tree": {"sha": "f5882c83842519c0bd1810e726a53985fa319331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5882c83842519c0bd1810e726a53985fa319331"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ac871cdf8291c6360f006cca9035a37bbd842a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ac871cdf8291c6360f006cca9035a37bbd842a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ac871cdf8291c6360f006cca9035a37bbd842a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ac871cdf8291c6360f006cca9035a37bbd842a/comments", "author": null, "committer": null, "parents": [{"sha": "1f069ef5a1899e119979b755c6627bb19176a4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f069ef5a1899e119979b755c6627bb19176a4f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f069ef5a1899e119979b755c6627bb19176a4f0"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "a298a2fcef6c564b4a84ffe830ff8c2740604471", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ac871cdf8291c6360f006cca9035a37bbd842a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ac871cdf8291c6360f006cca9035a37bbd842a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a6ac871cdf8291c6360f006cca9035a37bbd842a", "patch": "@@ -1,3 +1,7 @@\n+2016-11-08  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* lex.c (search_line_fast): New implementation for AArch64.\n+\n 2016-10-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* files.c (destroy_cpp_file): Free file->path."}, {"sha": "cea88488f36cc1708556d6345a8c791f2c488da7", "filename": "libcpp/lex.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ac871cdf8291c6360f006cca9035a37bbd842a/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ac871cdf8291c6360f006cca9035a37bbd842a/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=a6ac871cdf8291c6360f006cca9035a37bbd842a", "patch": "@@ -752,6 +752,101 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n   }\n }\n \n+#elif defined (__ARM_NEON) && defined (__ARM_64BIT_STATE)\n+#include \"arm_neon.h\"\n+\n+/* This doesn't have to be the exact page size, but no system may use\n+   a size smaller than this.  ARMv8 requires a minimum page size of\n+   4k.  The impact of being conservative here is a small number of\n+   cases will take the slightly slower entry path into the main\n+   loop.  */\n+\n+#define AARCH64_MIN_PAGE_SIZE 4096\n+\n+static const uchar *\n+search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  const uint8x16_t repl_nl = vdupq_n_u8 ('\\n');\n+  const uint8x16_t repl_cr = vdupq_n_u8 ('\\r');\n+  const uint8x16_t repl_bs = vdupq_n_u8 ('\\\\');\n+  const uint8x16_t repl_qm = vdupq_n_u8 ('?');\n+  const uint8x16_t xmask = (uint8x16_t) vdupq_n_u64 (0x8040201008040201ULL);\n+\n+#ifdef __AARCH64EB\n+  const int16x8_t shift = {8, 8, 8, 8, 0, 0, 0, 0};\n+#else\n+  const int16x8_t shift = {0, 0, 0, 0, 8, 8, 8, 8};\n+#endif\n+\n+  unsigned int found;\n+  const uint8_t *p;\n+  uint8x16_t data;\n+  uint8x16_t t;\n+  uint16x8_t m;\n+  uint8x16_t u, v, w;\n+\n+  /* Align the source pointer.  */\n+  p = (const uint8_t *)((uintptr_t)s & -16);\n+\n+  /* Assuming random string start positions, with a 4k page size we'll take\n+     the slow path about 0.37% of the time.  */\n+  if (__builtin_expect ((AARCH64_MIN_PAGE_SIZE\n+\t\t\t - (((uintptr_t) s) & (AARCH64_MIN_PAGE_SIZE - 1)))\n+\t\t\t< 16, 0))\n+    {\n+      /* Slow path: the string starts near a possible page boundary.  */\n+      uint32_t misalign, mask;\n+\n+      misalign = (uintptr_t)s & 15;\n+      mask = (-1u << misalign) & 0xffff;\n+      data = vld1q_u8 (p);\n+      t = vceqq_u8 (data, repl_nl);\n+      u = vceqq_u8 (data, repl_cr);\n+      v = vorrq_u8 (t, vceqq_u8 (data, repl_bs));\n+      w = vorrq_u8 (u, vceqq_u8 (data, repl_qm));\n+      t = vorrq_u8 (v, w);\n+      t = vandq_u8 (t, xmask);\n+      m = vpaddlq_u8 (t);\n+      m = vshlq_u16 (m, shift);\n+      found = vaddvq_u16 (m);\n+      found &= mask;\n+      if (found)\n+\treturn (const uchar*)p + __builtin_ctz (found);\n+    }\n+  else\n+    {\n+      data = vld1q_u8 ((const uint8_t *) s);\n+      t = vceqq_u8 (data, repl_nl);\n+      u = vceqq_u8 (data, repl_cr);\n+      v = vorrq_u8 (t, vceqq_u8 (data, repl_bs));\n+      w = vorrq_u8 (u, vceqq_u8 (data, repl_qm));\n+      t = vorrq_u8 (v, w);\n+      if (__builtin_expect (vpaddd_u64 ((uint64x2_t)t), 0))\n+\tgoto done;\n+    }\n+\n+  do\n+    {\n+      p += 16;\n+      data = vld1q_u8 (p);\n+      t = vceqq_u8 (data, repl_nl);\n+      u = vceqq_u8 (data, repl_cr);\n+      v = vorrq_u8 (t, vceqq_u8 (data, repl_bs));\n+      w = vorrq_u8 (u, vceqq_u8 (data, repl_qm));\n+      t = vorrq_u8 (v, w);\n+    } while (!vpaddd_u64 ((uint64x2_t)t));\n+\n+done:\n+  /* Now that we've found the terminating substring, work out precisely where\n+     we need to stop.  */\n+  t = vandq_u8 (t, xmask);\n+  m = vpaddlq_u8 (t);\n+  m = vshlq_u16 (m, shift);\n+  found = vaddvq_u16 (m);\n+  return (((((uintptr_t) p) < (uintptr_t) s) ? s : (const uchar *)p)\n+\t  + __builtin_ctz (found));\n+}\n+\n #elif defined (__ARM_NEON)\n #include \"arm_neon.h\"\n "}]}