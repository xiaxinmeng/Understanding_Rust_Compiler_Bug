{"sha": "666ff4f65d256dec0974941605cf76db0b138a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY2ZmY0ZjY1ZDI1NmRlYzA5NzQ5NDE2MDVjZjc2ZGIwYjEzOGE3Ng==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2007-03-05T17:27:44Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-03-05T17:27:44Z"}, "message": "Character.java: Re-merged with Classpath.\n\n2007-03-05  Mark Wielaard  <mark@klomp.org>\n\n\t* java/lang/Character.java: Re-merged with Classpath.\n\t* java/lang/natString.cc (nativeCompareTo): Renamed from\n\tcompareTo.\n\t* java/lang/StringBuilder.java: Re-merged with Classpath.\n\t* java/lang/String.java: Re-merged with Classpath.\n\t(nativeCompareTo): Renamed from compareTo.\n\t* java/lang/StringBuffer.java: Re-merged with Classpath.\n\t* jni.cc (_Jv_JNI_GetAnyMethodID): Split calls to append.\n\nFrom-SVN: r122560", "tree": {"sha": "7094a7844e13e49f92832894c3b7a7f8ff638d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7094a7844e13e49f92832894c3b7a7f8ff638d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/666ff4f65d256dec0974941605cf76db0b138a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666ff4f65d256dec0974941605cf76db0b138a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/666ff4f65d256dec0974941605cf76db0b138a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666ff4f65d256dec0974941605cf76db0b138a76/comments", "author": null, "committer": null, "parents": [{"sha": "b48a45922ddcdfd0aa2cd3ff24c7c158d20c1f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48a45922ddcdfd0aa2cd3ff24c7c158d20c1f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48a45922ddcdfd0aa2cd3ff24c7c158d20c1f2e"}], "stats": {"total": 855, "additions": 609, "deletions": 246}, "files": [{"sha": "6de135a543edaf95f0160121b26efc6a6e7c5a02", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -1,3 +1,14 @@\n+2007-03-05  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/lang/Character.java: Re-merged with Classpath.\n+\t* java/lang/natString.cc (nativeCompareTo): Renamed from\n+\tcompareTo.\n+\t* java/lang/StringBuilder.java: Re-merged with Classpath.\n+\t* java/lang/String.java: Re-merged with Classpath.\n+\t(nativeCompareTo): Renamed from compareTo.\n+\t* java/lang/StringBuffer.java: Re-merged with Classpath.\n+\t* jni.cc (_Jv_JNI_GetAnyMethodID): Split calls to append.\n+\n 2007-03-05  Andrew Haley  <aph@redhat.com>\n \n \t* java/lang/reflect/natVMProxy.cc (ncode_closure.meth): Delete."}, {"sha": "d37116643712881e7dde77675d5f3fa9ea0f6038", "filename": "libjava/classpath/lib/java/lang/Character$Subset.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24Subset.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24Subset.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24Subset.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "3f341aaa55097867bf35f737bbcae20d62e6d05a", "filename": "libjava/classpath/lib/java/lang/Character$UnicodeBlock$NameType.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "e339e2be66186e6d00a81143ee555d8ed67f86b9", "filename": "libjava/classpath/lib/java/lang/Character$UnicodeBlock.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter%24UnicodeBlock.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "68f96fbda0f98e40b6da34babb2e64c7e116b9fe", "filename": "libjava/classpath/lib/java/lang/Character.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FCharacter.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "3a0450c2ab7529676591774fb8da32f0520af5ef", "filename": "libjava/classpath/lib/java/lang/String$CaseInsensitiveComparator.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "27d3118a67ce18bab010d3a3090c83d9335eb29f", "filename": "libjava/classpath/lib/java/lang/String.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FString.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "60b7144904619f5f26220fc42d9ab6007fb81fe5", "filename": "libjava/classpath/lib/java/lang/StringBuffer.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuffer.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuffer.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuffer.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "90e6fab2565cd49207f3fed26af29f48a8891739", "filename": "libjava/classpath/lib/java/lang/StringBuilder.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuilder.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuilder.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Flang%2FStringBuilder.class?ref=666ff4f65d256dec0974941605cf76db0b138a76"}, {"sha": "2b83115b064b8cfed81eb6457078ffcae1ddb337", "filename": "libjava/java/lang/Character$UnicodeBlock$NameType.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock%24NameType.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -0,0 +1,29 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __java_lang_Character$UnicodeBlock$NameType__\n+#define __java_lang_Character$UnicodeBlock$NameType__\n+\n+#pragma interface\n+\n+#include <java/lang/Enum.h>\n+#include <gcj/array.h>\n+\n+\n+class java::lang::Character$UnicodeBlock$NameType : public ::java::lang::Enum\n+{\n+\n+  Character$UnicodeBlock$NameType(::java::lang::String *, jint);\n+public:\n+  static JArray< ::java::lang::Character$UnicodeBlock$NameType * > * values();\n+  static ::java::lang::Character$UnicodeBlock$NameType * valueOf(::java::lang::String *);\n+  static ::java::lang::Character$UnicodeBlock$NameType * CANONICAL;\n+  static ::java::lang::Character$UnicodeBlock$NameType * NO_SPACES;\n+  static ::java::lang::Character$UnicodeBlock$NameType * CONSTANT;\n+private:\n+  static JArray< ::java::lang::Character$UnicodeBlock$NameType * > * ENUM$VALUES;\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __java_lang_Character$UnicodeBlock$NameType__"}, {"sha": "b32f2121e61b392d5b5afe127cb1149efbedd178", "filename": "libjava/java/lang/Character$UnicodeBlock.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter%24UnicodeBlock.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -18,13 +18,12 @@ class java::lang::Character$UnicodeBlock : public ::java::lang::Character$Subset\n   static ::java::lang::Character$UnicodeBlock * of(jchar);\n   static ::java::lang::Character$UnicodeBlock * of(jint);\n   static ::java::lang::Character$UnicodeBlock * forName(::java::lang::String *);\n+public: // actually package-private\n+  static JArray< jint > * $SWITCH_TABLE$java$lang$Character$UnicodeBlock$NameType();\n private:\n   jint __attribute__((aligned(__alignof__( ::java::lang::Character$Subset)))) start;\n   jint end;\n   ::java::lang::String * canonicalName;\n-  static const jint CANONICAL_NAME = 0;\n-  static const jint NO_SPACES_NAME = 1;\n-  static const jint CONSTANT_NAME = 2;\n public:\n   static ::java::lang::Character$UnicodeBlock * BASIC_LATIN;\n   static ::java::lang::Character$UnicodeBlock * LATIN_1_SUPPLEMENT;\n@@ -154,6 +153,7 @@ class java::lang::Character$UnicodeBlock : public ::java::lang::Character$Subset\n   static ::java::lang::Character$UnicodeBlock * SURROGATES_AREA;\n private:\n   static JArray< ::java::lang::Character$UnicodeBlock * > * sets;\n+  static JArray< jint > * $SWITCH_TABLE$java$lang$Character$UnicodeBlock$NameType__;\n public:\n   static ::java::lang::Class class$;\n };"}, {"sha": "7c3a4b9ae3fcc9daca9c2c9c07432d521162dee8", "filename": "libjava/java/lang/Character.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -34,6 +34,10 @@ class java::lang::Character : public ::java::lang::Object\n   static jboolean isDefined(jint);\n   static jboolean isLetter(jchar);\n   static jboolean isLetter(jint);\n+  static jint offsetByCodePoints(::java::lang::CharSequence *, jint, jint);\n+  static jint offsetByCodePoints(JArray< jchar > *, jint, jint, jint, jint);\n+  static jint codePointCount(::java::lang::CharSequence *, jint, jint);\n+  static jint codePointCount(JArray< jchar > *, jint, jint);\n   static jboolean isLetterOrDigit(jchar);\n   static jboolean isLetterOrDigit(jint);\n   static jboolean isJavaLetter(jchar);\n@@ -72,8 +76,7 @@ class java::lang::Character : public ::java::lang::Object\n   static jbyte getDirectionality(jint);\n   static jboolean isMirrored(jchar);\n   static jboolean isMirrored(jint);\n-  jint compareTo(::java::lang::Character *);\n-  jint compareTo(::java::lang::Object *);\n+  jint target$compareTo(::java::lang::Character *);\n   static ::java::lang::Character * valueOf(jchar);\n   static jchar reverseBytes(jchar);\n   static JArray< jchar > * toChars(jint);\n@@ -91,6 +94,7 @@ class java::lang::Character : public ::java::lang::Object\n   static jint codePointBefore(JArray< jchar > *, jint);\n   static jint codePointBefore(JArray< jchar > *, jint, jint);\n   static jint codePointBefore(::java::lang::CharSequence *, jint);\n+  jint compareTo(::java::lang::Object *);\n private:\n   jchar __attribute__((aligned(__alignof__( ::java::lang::Object)))) value;\n   static const jlong serialVersionUID = 3786198910865385080LL;\n@@ -99,6 +103,15 @@ class java::lang::Character : public ::java::lang::Object\n   static const jint MAX_RADIX = 36;\n   static const jchar MIN_VALUE = 0;\n   static const jchar MAX_VALUE = 65535;\n+  static const jint MIN_CODE_POINT = 0;\n+  static const jint MAX_CODE_POINT = 1114111;\n+  static const jchar MIN_HIGH_SURROGATE = 55296;\n+  static const jchar MAX_HIGH_SURROGATE = 56319;\n+  static const jchar MIN_LOW_SURROGATE = 56320;\n+  static const jchar MAX_LOW_SURROGATE = 57343;\n+  static const jchar MIN_SURROGATE = 55296;\n+  static const jchar MAX_SURROGATE = 57343;\n+  static const jint MIN_SUPPLEMENTARY_CODE_POINT = 65536;\n   static ::java::lang::Class * TYPE;\n   static const jint SIZE = 16;\n private:\n@@ -160,15 +173,6 @@ class java::lang::Character : public ::java::lang::Object\n   static const jint NO_BREAK_MASK = 32;\n   static const jint MIRROR_MASK = 64;\n public:\n-  static const jint MIN_SUPPLEMENTARY_CODE_POINT = 65536;\n-  static const jint MIN_CODE_POINT = 0;\n-  static const jint MAX_CODE_POINT = 1114111;\n-  static const jchar MIN_HIGH_SURROGATE = 55296;\n-  static const jchar MAX_HIGH_SURROGATE = 56319;\n-  static const jchar MIN_LOW_SURROGATE = 56320;\n-  static const jchar MAX_LOW_SURROGATE = 57343;\n-  static const jchar MIN_SURROGATE = 55296;\n-  static const jchar MAX_SURROGATE = 57343;\n   static ::java::lang::Class class$;\n };\n "}, {"sha": "0cc9d3c57bdca9928bf7ed07ff58a8e1b7f66ce2", "filename": "libjava/java/lang/Character.java", "status": "modified", "additions": 316, "deletions": 132, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.java?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -1,5 +1,6 @@\n /* java.lang.Character -- Wrapper class for char, and Unicode subsets\n-   Copyright (C) 1998, 1999, 2001, 2002, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -54,15 +55,15 @@\n /**\n  * Wrapper class for the primitive char data type.  In addition, this class\n  * allows one to retrieve property information and perform transformations\n- * on the 57,707 defined characters in the Unicode Standard, Version 3.0.0.\n+ * on the defined characters in the Unicode Standard, Version 4.0.0.\n  * java.lang.Character is designed to be very dynamic, and as such, it\n  * retrieves information on the Unicode character set from a separate\n  * database, gnu.java.lang.CharData, which can be easily upgraded.\n  *\n  * <p>For predicates, boundaries are used to describe\n  * the set of characters for which the method will return true.\n  * This syntax uses fairly normal regular expression notation.\n- * See 5.13 of the Unicode Standard, Version 3.0, for the\n+ * See 5.13 of the Unicode Standard, Version 4.0, for the\n  * boundary specification.\n  *\n  * <p>See <a href=\"http://www.unicode.org\">http://www.unicode.org</a>\n@@ -72,10 +73,11 @@\n  * @author Paul N. Fisher\n  * @author Jochen Hoenicke\n  * @author Eric Blake (ebb9@email.byu.edu)\n+ * @author Andrew John Hughes (gnu_andrew@member.fsf.org)\n  * @since 1.0\n- * @status updated to 1.4\n+ * @status partly updated to 1.5; some things still missing\n  */\n-public final class Character implements Serializable, Comparable\n+public final class Character implements Serializable, Comparable<Character>\n {\n   /**\n    * A subset of Unicode blocks.\n@@ -160,10 +162,8 @@ public static final class UnicodeBlock extends Subset\n     /** The canonical name of the block according to the Unicode standard. */\n     private final String canonicalName;\n \n-    /** Constants for the <code>forName()</code> method */\n-    private static final int CANONICAL_NAME = 0;\n-    private static final int NO_SPACES_NAME = 1;\n-    private static final int CONSTANT_NAME = 2;\n+    /** Enumeration for the <code>forName()</code> method */\n+    private enum NameType { CANONICAL, NO_SPACES, CONSTANT; };\n \n     /**\n      * Constructor for strictly defined blocks.\n@@ -173,7 +173,7 @@ public static final class UnicodeBlock extends Subset\n      * @param name the block name\n      */\n     private UnicodeBlock(int start, int end, String name,\n-             String canonicalName)\n+\t\t\t String canonicalName)\n     {\n       super(name);\n       this.start = start;\n@@ -207,8 +207,8 @@ public static UnicodeBlock of(char ch)\n     public static UnicodeBlock of(int codePoint)\n     {\n       if (codePoint > MAX_CODE_POINT)\n-    throw new IllegalArgumentException(\"The supplied integer value is \" +\n-                       \"too large to be a codepoint.\");\n+\tthrow new IllegalArgumentException(\"The supplied integer value is \" +\n+\t\t\t\t\t   \"too large to be a codepoint.\");\n       // Simple binary search for the correct block.\n       int low = 0;\n       int hi = sets.length - 1;\n@@ -262,59 +262,51 @@ else if (codePoint > b.end)\n      */\n     public static final UnicodeBlock forName(String blockName)\n     {\n-      int type;\n+      NameType type;\n       if (blockName.indexOf(' ') != -1)\n-        type = CANONICAL_NAME;\n+        type = NameType.CANONICAL;\n       else if (blockName.indexOf('_') != -1)\n-        type = CONSTANT_NAME;\n+        type = NameType.CONSTANT;\n       else\n-        type = NO_SPACES_NAME;\n+        type = NameType.NO_SPACES;\n       Collator usCollator = Collator.getInstance(Locale.US);\n       usCollator.setStrength(Collator.PRIMARY);\n       /* Special case for deprecated blocks not in sets */\n       switch (type)\n       {\n-        case CANONICAL_NAME:\n+        case CANONICAL:\n           if (usCollator.compare(blockName, \"Surrogates Area\") == 0)\n             return SURROGATES_AREA;\n           break;\n-        case NO_SPACES_NAME:\n+        case NO_SPACES:\n           if (usCollator.compare(blockName, \"SurrogatesArea\") == 0)\n             return SURROGATES_AREA;\n           break;\n-        case CONSTANT_NAME:\n+        case CONSTANT:\n           if (usCollator.compare(blockName, \"SURROGATES_AREA\") == 0) \n             return SURROGATES_AREA;\n           break;\n       }\n       /* Other cases */\n-      int setLength = sets.length;\n       switch (type)\n       {\n-        case CANONICAL_NAME:\n-          for (int i = 0; i < setLength; i++)\n-            {\n-              UnicodeBlock block = sets[i];\n-              if (usCollator.compare(blockName, block.canonicalName) == 0)\n-                return block;\n-            }\n+        case CANONICAL:\n+          for (UnicodeBlock block : sets)\n+            if (usCollator.compare(blockName, block.canonicalName) == 0)\n+              return block;\n           break;\n-        case NO_SPACES_NAME:\n-          for (int i = 0; i < setLength; i++)\n-            {\n-              UnicodeBlock block = sets[i];\n-              String nsName = block.canonicalName.replaceAll(\" \",\"\");\n-              if (usCollator.compare(blockName, nsName) == 0)\n-                return block;\n-            }        \n-          break;\n-        case CONSTANT_NAME:\n-          for (int i = 0; i < setLength; i++)\n-            {\n-              UnicodeBlock block = sets[i];\n-              if (usCollator.compare(blockName, block.toString()) == 0)\n-                return block;\n-            }\n+        case NO_SPACES:\n+          for (UnicodeBlock block : sets)\n+\t    {\n+\t      String nsName = block.canonicalName.replaceAll(\" \",\"\");\n+\t      if (usCollator.compare(blockName, nsName) == 0)\n+\t\treturn block;\n+\t    }\n+\t  break;\n+        case CONSTANT:\n+          for (UnicodeBlock block : sets)\n+            if (usCollator.compare(blockName, block.toString()) == 0)\n+              return block;\n           break;\n       }\n       throw new IllegalArgumentException(\"No Unicode block found for \" +\n@@ -1517,10 +1509,11 @@ else if (blockName.indexOf('_') != -1)\n      * this.  These are also returned from calls to <code>of(int)</code>\n      * and <code>of(char)</code>.\n      */\n+    @Deprecated\n     public static final UnicodeBlock SURROGATES_AREA\n       = new UnicodeBlock(0xD800, 0xDFFF,\n                          \"SURROGATES_AREA\",\n-             \"Surrogates Area\");\n+\t\t\t \"Surrogates Area\");\n \n     /**\n      * The defined subsets.\n@@ -1698,12 +1691,79 @@ else if (blockName.indexOf('_') != -1)\n    */\n   public static final char MAX_VALUE = '\\uFFFF';\n \n+  /**\n+   * The minimum Unicode 4.0 code point.  This value is <code>0</code>.\n+   * @since 1.5\n+   */\n+  public static final int MIN_CODE_POINT = 0;\n+\n+  /**\n+   * The maximum Unicode 4.0 code point, which is greater than the range\n+   * of the char data type.\n+   * This value is <code>0x10FFFF</code>.\n+   * @since 1.5\n+   */\n+  public static final int MAX_CODE_POINT = 0x10FFFF;\n+\n+  /**\n+   * The minimum Unicode high surrogate code unit, or\n+   * <emph>leading-surrogate</emph>, in the UTF-16 character encoding.\n+   * This value is <code>'\\uD800'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MIN_HIGH_SURROGATE = '\\uD800';\n+\n+  /**\n+   * The maximum Unicode high surrogate code unit, or\n+   * <emph>leading-surrogate</emph>, in the UTF-16 character encoding.\n+   * This value is <code>'\\uDBFF'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MAX_HIGH_SURROGATE = '\\uDBFF';\n+\n+  /**\n+   * The minimum Unicode low surrogate code unit, or\n+   * <emph>trailing-surrogate</emph>, in the UTF-16 character encoding.\n+   * This value is <code>'\\uDC00'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MIN_LOW_SURROGATE = '\\uDC00';\n+\n+  /**\n+   * The maximum Unicode low surrogate code unit, or\n+   * <emph>trailing-surrogate</emph>, in the UTF-16 character encoding.\n+   * This value is <code>'\\uDFFF'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MAX_LOW_SURROGATE = '\\uDFFF';  \n+\n+  /**\n+   * The minimum Unicode surrogate code unit in the UTF-16 character encoding.\n+   * This value is <code>'\\uD800'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MIN_SURROGATE = MIN_HIGH_SURROGATE;\n+\n+  /**\n+   * The maximum Unicode surrogate code unit in the UTF-16 character encoding.\n+   * This value is <code>'\\uDFFF'</code>.\n+   * @since 1.5\n+   */\n+  public static final char MAX_SURROGATE = MAX_LOW_SURROGATE;\n+\n+  /**\n+   * The lowest possible supplementary Unicode code point (the first code\n+   * point outside the basic multilingual plane (BMP)).\n+   * This value is <code>0x10000</code>.\n+   */ \n+  public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x10000;\n+\n   /**\n    * Class object representing the primitive char data type.\n    *\n    * @since 1.1\n    */\n-  public static final Class TYPE = VMClassLoader.getPrimitiveClass('C');\n+  public static final Class<Character> TYPE = (Class<Character>) VMClassLoader.getPrimitiveClass('C');\n \n   /**\n    * The number of bits needed to represent a <code>char</code>.\n@@ -2088,71 +2148,6 @@ else if (blockName.indexOf('_') != -1)\n    */\n   private static final int MIRROR_MASK = 0x40;\n \n-  /**\n-   * Min value for supplementary code point.\n-   *\n-   * @since 1.5\n-   */\n-  public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x10000;\n-\n-  /**\n-   * Min value for code point.\n-   *\n-   * @since 1.5\n-   */\n-  public static final int MIN_CODE_POINT = 0; \n- \n- \n-  /**\n-   * Max value for code point.\n-   *\n-   * @since 1.5\n-   */\n-  public static final int MAX_CODE_POINT = 0x010ffff;\n-\n-\n-  /**\n-   * Minimum high surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MIN_HIGH_SURROGATE = '\\ud800';\n-\n-  /**\n-   * Maximum high surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MAX_HIGH_SURROGATE = '\\udbff';\n- \n-  /**\n-   * Minimum low surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MIN_LOW_SURROGATE = '\\udc00';\n-\n-  /**\n-   * Maximum low surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MAX_LOW_SURROGATE = '\\udfff';\n-\n-  /**\n-   * Minimum surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MIN_SURROGATE = MIN_HIGH_SURROGATE;\n-\n-  /**\n-   * Maximum low surrogate code in UTF-16 encoding.\n-   *\n-   * @since 1.5\n-   */\n-  public static final char MAX_SURROGATE = MAX_LOW_SURROGATE;\n-\n   /**\n    * Grabs an attribute offset from the Unicode attribute database. The lower\n    * 5 bits are the character type, the next 2 bits are flags, and the top\n@@ -2504,6 +2499,209 @@ public static boolean isLetter(int codePoint)\n                | (1 << MODIFIER_LETTER)\n                | (1 << OTHER_LETTER))) != 0;\n   }\n+  \n+  /**\n+   * Returns the index into the given CharSequence that is offset\n+   * <code>codePointOffset</code> code points from <code>index</code>.\n+   * @param seq the CharSequence\n+   * @param index the start position in the CharSequence\n+   * @param codePointOffset the number of code points offset from the start\n+   * position\n+   * @return the index into the CharSequence that is codePointOffset code \n+   * points offset from index\n+   * \n+   * @throws NullPointerException if seq is null\n+   * @throws IndexOutOfBoundsException if index is negative or greater than the\n+   * length of the sequence.\n+   * @throws IndexOutOfBoundsException if codePointOffset is positive and the \n+   * subsequence from index to the end of seq has fewer than codePointOffset\n+   * code points\n+   * @throws IndexOutOfBoundsException if codePointOffset is negative and the\n+   * subsequence from the start of seq to index has fewer than \n+   * (-codePointOffset) code points\n+   * @since 1.5\n+   */\n+  public static int offsetByCodePoints(CharSequence seq,\n+                                       int index,\n+                                       int codePointOffset)\n+  {\n+    int len = seq.length();\n+    if (index < 0 || index > len)\n+      throw new IndexOutOfBoundsException();\n+    \n+    int numToGo = codePointOffset;\n+    int offset = index;\n+    int adjust = 1;\n+    if (numToGo >= 0)\n+      {\n+        for (; numToGo > 0; offset++)\n+          {\n+            numToGo--;\n+            if (Character.isHighSurrogate(seq.charAt(offset))\n+                && (offset + 1) < len\n+                && Character.isLowSurrogate(seq.charAt(offset + 1)))\n+              offset++;\n+          }\n+        return offset;\n+      }\n+    else\n+      {\n+        numToGo *= -1;\n+        for (; numToGo > 0;)\n+          {\n+            numToGo--;\n+            offset--;\n+            if (Character.isLowSurrogate(seq.charAt(offset))\n+                && (offset - 1) >= 0\n+                && Character.isHighSurrogate(seq.charAt(offset - 1)))\n+              offset--;\n+          }\n+        return offset;\n+      }\n+  }\n+  \n+  /**\n+   * Returns the index into the given char subarray that is offset\n+   * <code>codePointOffset</code> code points from <code>index</code>.\n+   * @param a the char array\n+   * @param start the start index of the subarray\n+   * @param count the length of the subarray\n+   * @param index the index to be offset\n+   * @param codePointOffset the number of code points offset from <code>index\n+   * </code>\n+   * @return the index into the char array\n+   * \n+   * @throws NullPointerException if a is null\n+   * @throws IndexOutOfBoundsException if start or count is negative or if\n+   * start + count is greater than the length of the array\n+   * @throws IndexOutOfBoundsException if index is less than start or larger \n+   * than start + count\n+   * @throws IndexOutOfBoundsException if codePointOffset is positive and the\n+   * subarray from index to start + count - 1 has fewer than codePointOffset\n+   * code points.\n+   * @throws IndexOutOfBoundsException if codePointOffset is negative and the\n+   * subarray from start to index - 1 has fewer than (-codePointOffset) code\n+   * points\n+   * @since 1.5\n+\n+   */\n+  public static int offsetByCodePoints(char[] a,\n+                                       int start,\n+                                       int count,\n+                                       int index,\n+                                       int codePointOffset)\n+  {\n+    int len = a.length;\n+    int end = start + count;\n+    if (start < 0 || count < 0 || end > len || index < start || index > end)\n+      throw new IndexOutOfBoundsException();\n+    \n+    int numToGo = codePointOffset;\n+    int offset = index;\n+    int adjust = 1;\n+    if (numToGo >= 0)\n+      {\n+        for (; numToGo > 0; offset++)\n+          {\n+            numToGo--;\n+            if (Character.isHighSurrogate(a[offset])\n+                && (offset + 1) < len\n+                && Character.isLowSurrogate(a[offset + 1]))\n+              offset++;\n+          }\n+        return offset;\n+      }\n+    else\n+      {\n+        numToGo *= -1;\n+        for (; numToGo > 0;)\n+          {\n+            numToGo--;\n+            offset--;\n+            if (Character.isLowSurrogate(a[offset])\n+                && (offset - 1) >= 0\n+                && Character.isHighSurrogate(a[offset - 1]))\n+              offset--;\n+            if (offset < start)\n+              throw new IndexOutOfBoundsException();\n+          }\n+        return offset;\n+      }\n+\n+  }\n+\n+  /**\n+   * Returns the number of Unicode code points in the specified range of the\n+   * given CharSequence.  The first char in the range is at position\n+   * beginIndex and the last one is at position endIndex - 1.  Paired \n+   * surrogates (supplementary characters are represented by a pair of chars - \n+   * one from the high surrogates and one from the low surrogates) \n+   * count as just one code point.\n+   * @param seq the CharSequence to inspect\n+   * @param beginIndex the beginning of the range\n+   * @param endIndex the end of the range\n+   * @return the number of Unicode code points in the given range of the \n+   * sequence\n+   * @throws NullPointerException if seq is null\n+   * @throws IndexOutOfBoundsException if beginIndex is negative, endIndex is\n+   * larger than the length of seq, or if beginIndex is greater than endIndex.\n+   * @since 1.5\n+   */\n+  public static int codePointCount(CharSequence seq, int beginIndex,\n+                                   int endIndex)\n+  {\n+    int len = seq.length();\n+    if (beginIndex < 0 || endIndex > len || beginIndex > endIndex)\n+      throw new IndexOutOfBoundsException();\n+        \n+    int count = 0;\n+    for (int i = beginIndex; i < endIndex; i++)\n+      {\n+        count++;\n+        // If there is a pairing, count it only once.\n+        if (isHighSurrogate(seq.charAt(i)) && (i + 1) < endIndex\n+            && isLowSurrogate(seq.charAt(i + 1)))\n+          i ++;\n+      }    \n+    return count;\n+  }\n+\n+  /**\n+   * Returns the number of Unicode code points in the specified range of the\n+   * given char array.  The first char in the range is at position\n+   * offset and the length of the range is count.  Paired surrogates\n+   * (supplementary characters are represented by a pair of chars - \n+   * one from the high surrogates and one from the low surrogates) \n+   * count as just one code point.\n+   * @param a the char array to inspect\n+   * @param offset the beginning of the range\n+   * @param count the length of the range\n+   * @return the number of Unicode code points in the given range of the \n+   * array\n+   * @throws NullPointerException if a is null\n+   * @throws IndexOutOfBoundsException if offset or count is negative or if \n+   * offset + countendIndex is larger than the length of a.\n+   * @since 1.5\n+   */\n+  public static int codePointCount(char[] a, int offset,\n+                                   int count)\n+  {\n+    int len = a.length;\n+    int end = offset + count;\n+    if (offset < 0 || count < 0 || end > len)\n+      throw new IndexOutOfBoundsException();\n+        \n+    int counter = 0;\n+    for (int i = offset; i < end; i++)\n+      {\n+        counter++;\n+        // If there is a pairing, count it only once.\n+        if (isHighSurrogate(a[i]) && (i + 1) < end\n+            && isLowSurrogate(a[i + 1]))\n+          i ++;\n+      }    \n+    return counter;\n+  }\n \n   /**\n    * Determines if a character is a Unicode letter or a Unicode digit. This\n@@ -3496,31 +3694,14 @@ public int compareTo(Character anotherCharacter)\n     return value - anotherCharacter.value;\n   }\n \n-  /**\n-   * Compares an object to this Character.  Assuming the object is a\n-   * Character object, this method performs the same comparison as\n-   * compareTo(Character).\n-   *\n-   * @param o object to compare\n-   * @return the comparison value\n-   * @throws ClassCastException if o is not a Character object\n-   * @throws NullPointerException if o is null\n-   * @see #compareTo(Character)\n-   * @since 1.2\n-   */\n-  public int compareTo(Object o)\n-  {\n-    return compareTo((Character) o);\n-  }\n-\n   /**\n    * Returns an <code>Character</code> object wrapping the value.\n    * In contrast to the <code>Character</code> constructor, this method\n    * will cache some values.  It is used by boxing conversion.\n    *\n    * @param val the value to wrap\n    * @return the <code>Character</code>\n-   * \n+   *\n    * @since 1.5\n    */\n   public static Character valueOf(char val)\n@@ -3529,9 +3710,9 @@ public static Character valueOf(char val)\n       return new Character(val);\n     synchronized (charCache)\n       {\n-    if (charCache[val - MIN_VALUE] == null)\n-      charCache[val - MIN_VALUE] = new Character(val);\n-    return charCache[val - MIN_VALUE];\n+\tif (charCache[val - MIN_VALUE] == null)\n+\t  charCache[val - MIN_VALUE] = new Character(val);\n+\treturn charCache[val - MIN_VALUE];\n       }\n   }\n \n@@ -3559,6 +3740,9 @@ public static char reverseBytes(char val)\n    */\n   public static char[] toChars(int codePoint)\n   {\n+    if (!isValidCodePoint(codePoint))\n+      throw new IllegalArgumentException(\"Illegal Unicode code point : \"\n+                                         + codePoint);\n     char[] result = new char[charCount(codePoint)];\n     int ignore = toChars(codePoint, result, 0);\n     return result;\n@@ -3776,7 +3960,7 @@ public static int codePointAt(char[] chars, int index)\n    */\n   public static int codePointAt(char[] chars, int index, int limit)\n   {\n-    if (index < 0 || index >= limit || limit < 0 || limit >= chars.length)\n+    if (index < 0 || index >= limit || limit < 0 || limit > chars.length)\n       throw new IndexOutOfBoundsException();\n     char high = chars[index];\n     if (! isHighSurrogate(high) || ++index >= limit)"}, {"sha": "b0c3d620973fb12f689c50c1c08f6b27a738fe59", "filename": "libjava/java/lang/String$CaseInsensitiveComparator.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString%24CaseInsensitiveComparator.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -14,6 +14,7 @@ class java::lang::String$CaseInsensitiveComparator : public ::java::lang::Object\n public: // actually package-private\n   String$CaseInsensitiveComparator();\n public:\n+  jint target$compare(::java::lang::String *, ::java::lang::String *);\n   jint compare(::java::lang::Object *, ::java::lang::Object *);\n private:\n   static const jlong serialVersionUID = 8575799808933029326LL;"}, {"sha": "eea80fb9e16ce59d56df939544201a0c0658203f", "filename": "libjava/java/lang/String.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -62,8 +62,10 @@ class java::lang::String : public ::java::lang::Object\n   jboolean contentEquals(::java::lang::StringBuffer *);\n   jboolean contentEquals(::java::lang::CharSequence *);\n   jboolean equalsIgnoreCase(::java::lang::String *);\n-  jint compareTo(::java::lang::String *);\n-  jint compareTo(::java::lang::Object *);\n+  jint target$compareTo(::java::lang::String *);\n+private:\n+  jint nativeCompareTo(::java::lang::String *);\n+public:\n   jint compareToIgnoreCase(::java::lang::String *);\n   jboolean regionMatches(jint, ::java::lang::String *, jint, jint);\n   jboolean regionMatches(jboolean, jint, ::java::lang::String *, jint, jint);\n@@ -107,15 +109,22 @@ class java::lang::String : public ::java::lang::Object\n   static ::java::lang::String * valueOf(jlong);\n   static ::java::lang::String * valueOf(jfloat);\n   static ::java::lang::String * valueOf(jdouble);\n+  static ::java::lang::String * format(::java::util::Locale *, ::java::lang::String *, JArray< ::java::lang::Object * > *);\n+  static ::java::lang::String * format(::java::lang::String *, JArray< ::java::lang::Object * > *);\n   ::java::lang::String * intern();\n   jint codePointCount(jint, jint);\n   jboolean contains(::java::lang::CharSequence *);\n   ::java::lang::String * replace(::java::lang::CharSequence *, ::java::lang::CharSequence *);\n+  jint offsetByCodePoints(jint, jint);\n+  jboolean isEmpty();\n private:\n   void init(JArray< jchar > *, jint, jint, jboolean);\n   void init(JArray< jbyte > *, jint, jint, jint);\n   void init(JArray< jbyte > *, jint, jint, ::java::lang::String *);\n   void init(::gnu::gcj::runtime::StringBuffer *);\n+public:\n+  jint compareTo(::java::lang::Object *);\n+private:\n   static const jlong serialVersionUID = -6849794470754667710LL;\n   ::java::lang::Object * __attribute__((aligned(__alignof__( ::java::lang::Object)))) data;\n   jint boffset;"}, {"sha": "d5bb41502112d15cb5e9cdff51f86170ee395828", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 86, "deletions": 34, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -1,5 +1,5 @@\n /* String.java -- immutable character sequences; the object of string literals\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -41,9 +41,11 @@\n \n import java.io.Serializable;\n import java.io.UnsupportedEncodingException;\n-import java.lang.Comparable;\n import java.util.Comparator;\n+import java.text.Collator;\n+import java.util.Formatter;\n import java.util.Locale;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n \n@@ -70,10 +72,13 @@\n  * @author Paul N. Fisher\n  * @author Eric Blake (ebb9@email.byu.edu)\n  * @author Per Bothner (bothner@cygnus.com)\n+ * @author Tom Tromey (tromey@redhat.com)\n+ * @author Andrew John Hughes (gnu_andrew@member.fsf.org)\n  * @since 1.0\n  * @status updated to 1.4\n  */\n-public final class String implements Serializable, Comparable, CharSequence\n+public final class String\n+  implements Serializable, Comparable<String>, CharSequence\n {\n   // WARNING: String is a CORE class in the bootstrap cycle. See the comments\n   // in vm/reference/java/lang/Runtime for implications of this fact.\n@@ -113,12 +118,12 @@ public final class String implements Serializable, Comparable, CharSequence\n   private int cachedHashCode;\n \n   /**\n-   * An implementation for {@link CASE_INSENSITIVE_ORDER}.\n+   * An implementation for {@link #CASE_INSENSITIVE_ORDER}.\n    * This must be {@link Serializable}. The class name is dictated by\n    * compatibility with Sun's JDK.\n    */\n   private static final class CaseInsensitiveComparator\n-    implements Comparator, Serializable\n+    implements Comparator<String>, Serializable\n   {\n     /**\n      * Compatible with JDK 1.2.\n@@ -142,9 +147,9 @@ public final class String implements Serializable, Comparable, CharSequence\n      * @throws ClassCastException if either argument is not a String\n      * @see #compareToIgnoreCase(String)\n      */\n-    public int compare(Object o1, Object o2)\n+    public int compare(String o1, String o2)\n     {\n-      return ((String) o1).compareToIgnoreCase((String) o2);\n+      return o1.compareToIgnoreCase(o2);\n     }\n   } // class CaseInsensitiveComparator\n \n@@ -156,7 +161,7 @@ public int compare(Object o1, Object o2)\n    * @see Collator#compare(String, String)\n    * @since 1.2\n    */\n-  public static final Comparator CASE_INSENSITIVE_ORDER\n+  public static final Comparator<String> CASE_INSENSITIVE_ORDER\n     = new CaseInsensitiveComparator();\n \n   /**\n@@ -207,6 +212,7 @@ public String(char[] data)\n    * @param count the number of characters from data to copy\n    * @throws NullPointerException if data is null\n    * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count &lt; 0 (overflow)\n    *         || offset + count &gt; data.length)\n    *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    */\n@@ -230,6 +236,7 @@ public String(char[] data, int offset, int count)\n    * @param count the number of characters from ascii to copy\n    * @throws NullPointerException if ascii is null\n    * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count &lt; 0 (overflow)\n    *         || offset + count &gt; ascii.length)\n    *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    * @see #String(byte[])\n@@ -281,7 +288,7 @@ public String(byte[] ascii, int hibyte)\n    *\n    * @param data byte array to copy\n    * @param offset the offset to start at\n-   * @param count the number of characters in the array to use\n+   * @param count the number of bytes in the array to use\n    * @param encoding the name of the encoding to use\n    * @throws NullPointerException if data or encoding is null\n    * @throws IndexOutOfBoundsException if offset or count is incorrect\n@@ -330,7 +337,7 @@ public String(byte[] data, String encoding)\n    *\n    * @param data byte array to copy\n    * @param offset the offset to start at\n-   * @param count the number of characters in the array to use\n+   * @param count the number of bytes in the array to use\n    * @throws NullPointerException if data is null\n    * @throws IndexOutOfBoundsException if offset or count is incorrect\n    * @throws Error if the decoding fails\n@@ -644,23 +651,17 @@ public byte[] getBytes()\n    * @return the comparison\n    * @throws NullPointerException if anotherString is null\n    */\n-  public native int compareTo(String anotherString);\n+  public int compareTo(String anotherString)\n+  {\n+    return nativeCompareTo(anotherString);\n+  }\n \n   /**\n-   * Behaves like <code>compareTo(java.lang.String)</code> unless the Object\n-   * is not a <code>String</code>.  Then it throws a\n-   * <code>ClassCastException</code>.\n-   *\n-   * @param o the object to compare against\n-   * @return the comparison\n-   * @throws NullPointerException if o is null\n-   * @throws ClassCastException if o is not a <code>String</code>\n-   * @since 1.2\n+   * The native implementation of compareTo(). Must be named different\n+   * since cni doesn't understand the bridge method generated from\n+   * the compareTo() method because of the Comparable<String> interface.\n    */\n-  public int compareTo(Object o)\n-  {\n-    return compareTo((String) o);\n-  }\n+  private native int nativeCompareTo(String anotherString);\n \n   /**\n    * Compares this String and another String (case insensitive). This\n@@ -710,7 +711,7 @@ public native boolean regionMatches(int toffset,\n    * @param ignoreCase true if case should be ignored in comparision\n    * @param toffset index to start comparison at for this String\n    * @param other String to compare region to this String\n-   * @param oofset index to start comparison at for other\n+   * @param ooffset index to start comparison at for other\n    * @param len number of characters to compare\n    * @return true if regions match, false otherwise\n    * @throws NullPointerException if other is null\n@@ -1124,7 +1125,7 @@ public String toUpperCase()\n    * Trims all characters less than or equal to <code>'\\u0020'</code>\n    * (<code>' '</code>) from the beginning and end of this String. This\n    * includes many, but not all, ASCII control characters, and all\n-   * {@link Character#whitespace(char)}.\n+   * {@link Character#isWhitespace(char)}.\n    *\n    * @return new trimmed String, or this if nothing trimmed\n    */\n@@ -1204,6 +1205,7 @@ public static String valueOf(char[] data)\n    * @return String containing the chars from data[offset..offset+count]\n    * @throws NullPointerException if data is null\n    * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count &lt; 0 (overflow)\n    *         || offset + count &gt; data.length)\n    *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    * @see #String(char[], int, int)\n@@ -1294,12 +1296,27 @@ public static String valueOf(double d)\n     return Double.toString(d);\n   }\n \n+\n+  /** @since 1.5 */\n+  public static String format(Locale locale, String format, Object... args)\n+  {\n+    Formatter f = new Formatter(locale);\n+    return f.format(format, args).toString();\n+  }\n+\n+  /** @since 1.5 */\n+  public static String format(String format, Object... args)\n+  {\n+    return format(Locale.getDefault(), format, args);\n+  }\n+\n   /**\n-   * Fetches this String from the intern hashtable. If two Strings are\n-   * considered equal, by the equals() method, then intern() will return the\n-   * same String instance. ie. if (s1.equals(s2)) then\n-   * (s1.intern() == s2.intern()). All string literals and string-valued\n-   * constant expressions are already interned.\n+   * Fetches this String from the intern hashtable.\n+   * If two Strings are considered equal, by the equals() method, \n+   * then intern() will return the same String instance. ie. \n+   * if (s1.equals(s2)) then (s1.intern() == s2.intern()). \n+   * All string literals and string-valued constant expressions \n+   * are already interned.\n    *\n    * @return the interned String\n    */\n@@ -1345,20 +1362,20 @@ public synchronized int codePointCount(int start, int end)\n       }\n     return count;\n   }\n-\n+  \n   /**\n    * Returns true iff this String contains the sequence of Characters\n    * described in s.\n    * @param s the CharSequence\n    * @return true iff this String contains s\n-   *\n+   * \n    * @since 1.5\n    */\n   public boolean contains (CharSequence s)\n   {\n     return this.indexOf(s.toString()) != -1;\n   }\n-\n+  \n   /**\n    * Returns a string that is this string with all instances of the sequence\n    * represented by <code>target</code> replaced by the sequence in \n@@ -1386,7 +1403,42 @@ public String replace (CharSequence target, CharSequence replacement)\n       }\n     return result.toString();\n   }\n+  \n+  /**\n+   * Return the index into this String that is offset from the given index by \n+   * <code>codePointOffset</code> code points.\n+   * @param index the index at which to start\n+   * @param codePointOffset the number of code points to offset\n+   * @return the index into this String that is <code>codePointOffset</code>\n+   * code points offset from <code>index</code>.\n+   * \n+   * @throws IndexOutOfBoundsException if index is negative or larger than the\n+   * length of this string.\n+   * @throws IndexOutOfBoundsException if codePointOffset is positive and the\n+   * substring starting with index has fewer than codePointOffset code points.\n+   * @throws IndexOutOfBoundsException if codePointOffset is negative and the\n+   * substring ending with index has fewer than (-codePointOffset) code points.\n+   * @since 1.5\n+   */\n+  public int offsetByCodePoints(int index, int codePointOffset)\n+  {\n+    if (index < 0 || index > count)\n+      throw new IndexOutOfBoundsException();\n+    \n+    return Character.offsetByCodePoints(this, index, codePointOffset);\n+  }\n \n+  /**\n+   * Returns true if, and only if, {@link #length()}\n+   * is <code>0</code>.\n+   *\n+   * @return true if the length of the string is zero.\n+   * @since 1.6\n+   */\n+  public boolean isEmpty()\n+  {\n+    return count == 0;\n+  }\n \n   private native void init(char[] chars, int offset, int count,\n \t\t\t   boolean dont_copy);"}, {"sha": "07400f78060e88251f8b0b8c3ebf3869ac83794e", "filename": "libjava/java/lang/StringBuffer.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -30,13 +30,13 @@ class java::lang::StringBuffer : public ::java::lang::Object\n   ::java::lang::StringBuffer * append(::java::lang::Object *);\n   ::java::lang::StringBuffer * append(::java::lang::String *);\n   ::java::lang::StringBuffer * append(::java::lang::StringBuffer *);\n-  ::java::lang::StringBuffer * append(::java::lang::CharSequence *);\n-  ::java::lang::StringBuffer * append(::java::lang::CharSequence *, jint, jint);\n   ::java::lang::StringBuffer * append(JArray< jchar > *);\n   ::java::lang::StringBuffer * append(JArray< jchar > *, jint, jint);\n-  ::java::lang::StringBuffer * append(jboolean);\n-  ::java::lang::StringBuffer * append(jchar);\n   ::java::lang::StringBuffer * appendCodePoint(jint);\n+  ::java::lang::StringBuffer * append(jboolean);\n+  ::java::lang::StringBuffer * target$append(jchar);\n+  ::java::lang::StringBuffer * target$append(::java::lang::CharSequence *);\n+  ::java::lang::StringBuffer * target$append(::java::lang::CharSequence *, jint, jint);\n   ::java::lang::StringBuffer * append(jint);\n   ::java::lang::StringBuffer * append(jlong);\n   ::java::lang::StringBuffer * append(jfloat);\n@@ -71,6 +71,11 @@ class java::lang::StringBuffer : public ::java::lang::Object\n private:\n   void ensureCapacity_unsynchronized(jint);\n   jboolean regionMatches(jint, ::java::lang::String *);\n+public:\n+  ::java::lang::Appendable * append(::java::lang::CharSequence *, jint, jint);\n+  ::java::lang::Appendable * append(::java::lang::CharSequence *);\n+  ::java::lang::Appendable * append(jchar);\n+private:\n   static const jlong serialVersionUID = 3388685877147921107LL;\n public: // actually package-private\n   jint __attribute__((aligned(__alignof__( ::java::lang::Object)))) count;"}, {"sha": "57fd2ca8e813eb334b3f546d17723219ad003f0b", "filename": "libjava/java/lang/StringBuffer.java", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -1,5 +1,5 @@\n /* StringBuffer.java -- Growable strings\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -72,8 +72,12 @@\n  * @since 1.0\n  * @status updated to 1.4\n  */\n-public final class StringBuffer implements Serializable, CharSequence\n+public final class StringBuffer\n+  implements Serializable, CharSequence, Appendable\n {\n+  // Implementation note: if you change this class, you usually will\n+  // want to change StringBuilder as well.\n+\n   /**\n    * Compatible with JDK 1.0+.\n    */\n@@ -152,17 +156,16 @@ public StringBuffer(String str)\n    * specified <code>CharSequence</code>. Initial capacity will be the\n    * size of the CharSequence plus 16.\n    *\n-   * @param sequence the <code>String</code> to convert\n+   * @param seq the <code>String</code> to convert\n    * @throws NullPointerException if str is null\n-   *\n    * @since 1.5\n    */\n-  public StringBuffer(CharSequence sequence)\n+  public StringBuffer(CharSequence seq)\n   {\n-    count = Math.max(0, sequence.length());\n+    count = Math.max(0, seq.length());\n     value = new char[count + DEFAULT_CAPACITY];\n     for (int i = 0; i < count; ++i)\n-      value[i] = sequence.charAt(i);\n+      value[i] = seq.charAt(i);\n   }\n \n   /**\n@@ -390,46 +393,6 @@ public synchronized StringBuffer append(StringBuffer stringBuffer)\n     return this;\n   }\n \n-  /**\n-   * Append the <code>CharSequence</code> value of the argument to this\n-   * <code>StringBuffer</code>.\n-   *\n-   * @param sequence the <code>CharSequence</code> to append\n-   * @return this <code>StringBuffer</code>\n-   * @see #append(Object)\n-   * @since 1.5\n-   */\n-  public synchronized StringBuffer append(CharSequence sequence)\n-  {\n-    if (sequence == null)\n-      sequence = \"null\";\n-    return append(sequence, 0, sequence.length());\n-  }\n-\n-  /**\n-   * Append the specified subsequence of the <code>CharSequence</code>\n-   * argument to this <code>StringBuffer</code>.\n-   *\n-   * @param sequence the <code>CharSequence</code> to append\n-   * @param start the starting index\n-   * @param end one past the ending index\n-   * @return this <code>StringBuffer</code>\n-   * @see #append(Object)\n-   * @since 1.5\n-   */\n-  public synchronized StringBuffer append(CharSequence sequence,\n-\t\t\t\t\t  int start, int end)\n-  {\n-    if (sequence == null)\n-      sequence = \"null\";\n-    if (start < 0 || end < 0 || start > end || end > sequence.length())\n-      throw new IndexOutOfBoundsException();\n-    ensureCapacity_unsynchronized(this.count + end - start);\n-    for (int i = start; i < end; ++i)\n-      value[count++] = sequence.charAt(i);\n-    return this;\n-  }\n-\n   /**\n    * Append the <code>char</code> array to this <code>StringBuffer</code>.\n    * This is similar (but more efficient) than\n@@ -469,6 +432,25 @@ public synchronized StringBuffer append(char[] data, int offset, int count)\n     return this;\n   }\n \n+  /**\n+   * Append the code point to this <code>StringBuffer</code>.\n+   * This is like #append(char), but will append two characters\n+   * if a supplementary code point is given.\n+   *\n+   * @param code the code point to append\n+   * @return this <code>StringBuffer</code>\n+   * @see Character#toChars(int, char[], int)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer appendCodePoint(int code)\n+  {\n+    int len = Character.charCount(code);\n+    ensureCapacity_unsynchronized(count + len);\n+    Character.toChars(code, value, count);\n+    count += len;\n+    return this;\n+  }\n+\n   /**\n    * Append the <code>String</code> value of the argument to this\n    * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n@@ -497,21 +479,41 @@ public synchronized StringBuffer append(char ch)\n   }\n \n   /**\n-   * Append the code point to this <code>StringBuffer</code>.\n-   * This is like #append(char), but will append two characters\n-   * if a supplementary code point is given.\n+   * Append the <code>CharSequence</code> value of the argument to this\n+   * <code>StringBuffer</code>.\n    *\n-   * @param code the code point to append\n+   * @param seq the <code>CharSequence</code> to append\n    * @return this <code>StringBuffer</code>\n-   * @see Character#toChars(int, char[], int)\n+   * @see #append(Object)\n    * @since 1.5\n    */\n-  public synchronized StringBuffer appendCodePoint(int code)\n+  public synchronized StringBuffer append(CharSequence seq)\n   {\n-    int len = Character.charCount(code);\n-    ensureCapacity_unsynchronized(count + len);\n-    Character.toChars(code, value, count);\n-    count += len;\n+    if (seq == null)\n+      seq = \"null\";\n+    return append(seq, 0, seq.length());\n+  }\n+\n+  /**\n+   * Append the specified subsequence of the <code>CharSequence</code>\n+   * argument to this <code>StringBuffer</code>.\n+   *\n+   * @param seq the <code>CharSequence</code> to append\n+   * @param start the starting index\n+   * @param end one past the ending index\n+   * @return this <code>StringBuffer</code>\n+   * @see #append(Object)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer append(CharSequence seq, int start, int end)\n+  {\n+    if (seq == null)\n+      seq = \"null\";\n+    if (start < 0 || end < 0 || start > end || end > seq.length())\n+      throw new IndexOutOfBoundsException();\n+    ensureCapacity_unsynchronized(this.count + end - start);\n+    for (int i = start; i < end; ++i)\n+      value[count++] = seq.charAt(i);\n     return this;\n   }\n "}, {"sha": "d34cd86c0a62e1d9e3085b1f016a45d042abdcde", "filename": "libjava/java/lang/StringBuilder.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuilder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuilder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuilder.h?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -66,6 +66,10 @@ class java::lang::StringBuilder : public ::java::lang::Object\n private:\n   jboolean regionMatches(jint, ::java::lang::String *);\n public:\n+  jint codePointAt(jint);\n+  jint codePointBefore(jint);\n+  jint codePointCount(jint, jint);\n+  void trimToSize();\n   ::java::lang::Appendable * append(::java::lang::CharSequence *, jint, jint);\n   ::java::lang::Appendable * append(::java::lang::CharSequence *);\n   ::java::lang::Appendable * append(jchar);"}, {"sha": "55a49e6e15d4680344fb1ab212fd55dfbbbb0b10", "filename": "libjava/java/lang/StringBuilder.java", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuilder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FStringBuilder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuilder.java?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -1,5 +1,5 @@\n /* StringBuilder.java -- Unsynchronized growable strings\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -998,4 +998,65 @@ public String toString()\n    */\n   // GCJ LOCAL: Native to access String internals properly.\n   private native boolean regionMatches(int toffset, String other);\n+\n+  /**\n+   * Get the code point at the specified index.  This is like #charAt(int),\n+   * but if the character is the start of a surrogate pair, and the\n+   * following character completes the pair, then the corresponding\n+   * supplementary code point is returned.\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public int codePointAt(int index)\n+  {\n+    return Character.codePointAt(value, index, count);\n+  }\n+\n+    /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(int), but checks the characters at <code>index-1</code> and\n+   * <code>index-2</code> to see if they form a supplementary code point.\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public int codePointBefore(int index)\n+  {\n+    // Character.codePointBefore() doesn't perform this check.  We\n+    // could use the CharSequence overload, but this is just as easy.\n+    if (index >= count)\n+      throw new IndexOutOfBoundsException();\n+    return Character.codePointBefore(value, index, 1);\n+  }\n+\n+  /**\n+   * Returns the number of Unicode code points in the specified sub sequence.\n+   * Surrogate pairs count as one code point.\n+   * @param beginIndex the start of the subarray\n+   * @param endIndex the index after the last char in the subarray\n+   * @return the number of code points\n+   * @throws IndexOutOfBoundsException if beginIndex is less than zero or \n+   * greater than endIndex or if endIndex is greater than the length of this \n+   * StringBuilder\n+   */\n+  public int codePointCount(int beginIndex,int endIndex)\n+  {\n+    if (beginIndex < 0 || beginIndex > endIndex || endIndex > count)\n+      throw new IndexOutOfBoundsException(\"invalid indices: \" + beginIndex\n+                                          + \", \" + endIndex);\n+    return Character.codePointCount(value, beginIndex, endIndex - beginIndex);\n+  }\n+\n+  public void trimToSize()\n+  {\n+    if (count < value.length)\n+      {\n+        char[] newValue = new char[count];\n+        System.arraycopy(value, 0, newValue, 0, count);\n+        value = newValue;\n+      }\n+  }\n }"}, {"sha": "f86abd8bc2da9a9abd55bfaff0119d60f6d58ae5", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -707,7 +707,7 @@ java::lang::String::regionMatches (jint toffset,\n }\n \n jint\n-java::lang::String::compareTo (jstring anotherString)\n+java::lang::String::nativeCompareTo (jstring anotherString)\n {\n   jchar *tptr = JvGetStringChars (this);\n   jchar *optr = JvGetStringChars (anotherString);"}, {"sha": "9e33be6e69f925a21c0fbcd7ee81caa2685795c7", "filename": "libjava/jni.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666ff4f65d256dec0974941605cf76db0b138a76/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=666ff4f65d256dec0974941605cf76db0b138a76", "patch": "@@ -751,7 +751,8 @@ _Jv_JNI_GetAnyMethodID (JNIEnv *env, jclass clazz,\n \n       java::lang::StringBuffer *name_sig =\n         new java::lang::StringBuffer (JvNewStringUTF (name));\n-      name_sig->append ((jchar) ' ')->append (JvNewStringUTF (s));\n+      name_sig->append ((jchar) ' ');\n+      name_sig->append (JvNewStringUTF (s));\n       env->ex = new java::lang::NoSuchMethodError (name_sig->toString ());\n     }\n   catch (jthrowable t)"}]}