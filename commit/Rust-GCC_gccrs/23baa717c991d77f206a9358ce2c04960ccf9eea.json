{"sha": "23baa717c991d77f206a9358ce2c04960ccf9eea", "node_id": "C_kwDOANBUbNoAKDIzYmFhNzE3Yzk5MWQ3N2YyMDZhOTM1OGNlMmMwNDk2MGNjZjllZWE", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-02-16T17:15:39Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-14T13:59:55Z"}, "message": "OpenMP/OpenACC struct sibling list gimplification extension and rework\n\nThis patch refactors struct sibling-list processing in gimplify.cc, and\nadjusts some related mapping-clause processing in the Fortran FE and\nomp-low.cc accordingly.\n\n2022-09-13  Julian Brown  <julian@codesourcery.com>\n\ngcc/fortran/\n\t* trans-openmp.cc (gfc_trans_omp_clauses): Don't create\n\tGOMP_MAP_TO_PSET mappings for class metadata, nor GOMP_MAP_POINTER\n\tmappings for POINTER_TYPE_P decls.\n\ngcc/\n\t* gimplify.cc (gimplify_omp_var_data): Remove GOVD_MAP_HAS_ATTACHMENTS.\n\t(GOMP_FIRSTPRIVATE_IMPLICIT): Renumber.\n\t(insert_struct_comp_map): Refactor function into...\n\t(build_omp_struct_comp_nodes): This new function.  Remove list handling\n\tand improve self-documentation.\n\t(extract_base_bit_offset): Remove BASE_REF, OFFSETP parameters.  Move\n\tcode to strip outer parts of address out of function, but strip no-op\n\tconversions.\n\t(omp_mapping_group): Add DELETED field for use during reindexing.\n\t(omp_strip_components_and_deref, omp_strip_indirections): New functions.\n\t(omp_group_last, omp_group_base): Add GOMP_MAP_STRUCT handling.\n\t(omp_gather_mapping_groups): Initialise DELETED field for new groups.\n\t(omp_index_mapping_groups): Notice DELETED groups when (re)indexing.\n\t(omp_siblist_insert_node_after, omp_siblist_move_node_after,\n\tomp_siblist_move_nodes_after, omp_siblist_move_concat_nodes_after): New\n\thelper functions.\n\t(omp_accumulate_sibling_list): New function to build up GOMP_MAP_STRUCT\n\tnode groups for sibling lists. Outlined from gimplify_scan_omp_clauses.\n\t(omp_build_struct_sibling_lists): New function.\n\t(gimplify_scan_omp_clauses): Remove struct_map_to_clause,\n\tstruct_seen_clause, struct_deref_set.  Call\n\tomp_build_struct_sibling_lists as pre-pass instead of handling sibling\n\tlists in the function's main processing loop.\n\t(gimplify_adjust_omp_clauses_1): Remove GOVD_MAP_HAS_ATTACHMENTS\n\thandling, unused now.\n\t* omp-low.cc (scan_sharing_clauses): Handle pointer-type indirect\n\tstruct references, and references to pointers to structs also.\n\ngcc/testsuite/\n\t* g++.dg/goacc/member-array-acc.C: New test.\n\t* g++.dg/gomp/member-array-omp.C: New test.\n\t* g++.dg/gomp/target-3.C: Update expected output.\n\t* g++.dg/gomp/target-lambda-1.C: Likewise.\n\t* g++.dg/gomp/target-this-2.C: Likewise.\n\t* c-c++-common/goacc/deep-copy-arrayofstruct.c: Move test from here.\n\t* c-c++-common/gomp/target-50.c: New test.\n\nlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-15.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-16.c: New test.\n\t* testsuite/libgomp.oacc-c++/deep-copy-17.C: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-arrayofstruct.c: Move\n\ttest to here, make \"run\" test.", "tree": {"sha": "be13ced987f3606e9c0609a0af6fcb1237adec52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be13ced987f3606e9c0609a0af6fcb1237adec52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23baa717c991d77f206a9358ce2c04960ccf9eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23baa717c991d77f206a9358ce2c04960ccf9eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23baa717c991d77f206a9358ce2c04960ccf9eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23baa717c991d77f206a9358ce2c04960ccf9eea/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd14c97cd92ca11c66ee3d8dc4dd543c5aa8e024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd14c97cd92ca11c66ee3d8dc4dd543c5aa8e024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd14c97cd92ca11c66ee3d8dc4dd543c5aa8e024"}], "stats": {"total": 2000, "additions": 1352, "deletions": 648}, "files": [{"sha": "8e9d5346b05c40cd021d30ead5b34de7a8db6903", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -3125,30 +3125,16 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  tree present = gfc_omp_check_optional_argument (decl, true);\n \t\t  if (openacc && n->sym->ts.type == BT_CLASS)\n \t\t    {\n-\t\t      tree type = TREE_TYPE (decl);\n \t\t      if (n->sym->attr.optional)\n \t\t\tsorry (\"optional class parameter\");\n-\t\t      if (POINTER_TYPE_P (type))\n-\t\t\t{\n-\t\t\t  node4 = build_omp_clause (input_location,\n-\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n-\t\t\t  OMP_CLAUSE_DECL (node4) = decl;\n-\t\t\t  OMP_CLAUSE_SIZE (node4) = size_int (0);\n-\t\t\t  decl = build_fold_indirect_ref (decl);\n-\t\t\t}\n \t\t      tree ptr = gfc_class_data_get (decl);\n \t\t      ptr = build_fold_indirect_ref (ptr);\n \t\t      OMP_CLAUSE_DECL (node) = ptr;\n \t\t      OMP_CLAUSE_SIZE (node) = gfc_class_vtab_size_get (decl);\n \t\t      node2 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n-\t\t      OMP_CLAUSE_DECL (node2) = decl;\n-\t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n-\t\t      node3 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_ATTACH_DETACH);\n-\t\t      OMP_CLAUSE_DECL (node3) = gfc_class_data_get (decl);\n-\t\t      OMP_CLAUSE_SIZE (node3) = size_int (0);\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_ATTACH_DETACH);\n+\t\t      OMP_CLAUSE_DECL (node2) = gfc_class_data_get (decl);\n+\t\t      OMP_CLAUSE_SIZE (node2) = size_int (0);\n \t\t      goto finalize_map_clause;\n \t\t    }\n \t\t  else if (POINTER_TYPE_P (TREE_TYPE (decl))"}, {"sha": "e9b8aa8d55cb50bec74995ce15e4d0d1e4998f7a", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 881, "deletions": 623, "changes": 1504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -125,12 +125,8 @@ enum gimplify_omp_var_data\n   /* Flag for GOVD_REDUCTION: inscan seen in {in,ex}clusive clause.  */\n   GOVD_REDUCTION_INSCAN = 0x2000000,\n \n-  /* Flag for GOVD_MAP: (struct) vars that have pointer attachments for\n-     fields.  */\n-  GOVD_MAP_HAS_ATTACHMENTS = 0x4000000,\n-\n   /* Flag for GOVD_FIRSTPRIVATE: OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT.  */\n-  GOVD_FIRSTPRIVATE_IMPLICIT = 0x8000000,\n+  GOVD_FIRSTPRIVATE_IMPLICIT = 0x4000000,\n \n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n@@ -8795,73 +8791,66 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n   return 1;\n }\n \n-/* Insert a GOMP_MAP_ALLOC or GOMP_MAP_RELEASE node following a\n-   GOMP_MAP_STRUCT mapping.  C is an always_pointer mapping.  STRUCT_NODE is\n-   the struct node to insert the new mapping after (when the struct node is\n-   initially created).  PREV_NODE is the first of two or three mappings for a\n-   pointer, and is either:\n-     - the node before C, when a pair of mappings is used, e.g. for a C/C++\n-       array section.\n-     - not the node before C.  This is true when we have a reference-to-pointer\n-       type (with a mapping for the reference and for the pointer), or for\n-       Fortran derived-type mappings with a GOMP_MAP_TO_PSET.\n-   If SCP is non-null, the new node is inserted before *SCP.\n-   if SCP is null, the new node is inserted before PREV_NODE.\n-   The return type is:\n-     - PREV_NODE, if SCP is non-null.\n-     - The newly-created ALLOC or RELEASE node, if SCP is null.\n-     - The second newly-created ALLOC or RELEASE node, if we are mapping a\n-       reference to a pointer.  */\n+/* For a set of mappings describing an array section pointed to by a struct\n+   (or derived type, etc.) component, create an \"alloc\" or \"release\" node to\n+   insert into a list following a GOMP_MAP_STRUCT node.  For some types of\n+   mapping (e.g. Fortran arrays with descriptors), an additional mapping may\n+   be created that is inserted into the list of mapping nodes attached to the\n+   directive being processed -- not part of the sorted list of nodes after\n+   GOMP_MAP_STRUCT.\n+\n+   CODE is the code of the directive being processed.  GRP_START and GRP_END\n+   are the first and last of two or three nodes representing this array section\n+   mapping (e.g. a data movement node like GOMP_MAP_{TO,FROM}, optionally a\n+   GOMP_MAP_TO_PSET, and finally a GOMP_MAP_ALWAYS_POINTER).  EXTRA_NODE is\n+   filled with the additional node described above, if needed.\n+\n+   This function does not add the new nodes to any lists itself.  It is the\n+   responsibility of the caller to do that.  */\n \n static tree\n-insert_struct_comp_map (enum tree_code code, tree c, tree struct_node,\n-\t\t\ttree prev_node, tree *scp)\n+build_omp_struct_comp_nodes (enum tree_code code, tree grp_start, tree grp_end,\n+\t\t\t     tree *extra_node)\n {\n   enum gomp_map_kind mkind\n     = (code == OMP_TARGET_EXIT_DATA || code == OACC_EXIT_DATA)\n       ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n \n-  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-  tree cl = scp ? prev_node : c2;\n+  gcc_assert (grp_start != grp_end);\n+\n+  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (grp_end), OMP_CLAUSE_MAP);\n   OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n-  OMP_CLAUSE_DECL (c2) = unshare_expr (OMP_CLAUSE_DECL (c));\n-  OMP_CLAUSE_CHAIN (c2) = scp ? *scp : prev_node;\n-  if (OMP_CLAUSE_CHAIN (prev_node) != c\n-      && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (prev_node)) == OMP_CLAUSE_MAP\n-      && (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n-\t  == GOMP_MAP_TO_PSET))\n-    OMP_CLAUSE_SIZE (c2) = OMP_CLAUSE_SIZE (OMP_CLAUSE_CHAIN (prev_node));\n+  OMP_CLAUSE_DECL (c2) = unshare_expr (OMP_CLAUSE_DECL (grp_end));\n+  OMP_CLAUSE_CHAIN (c2) = NULL_TREE;\n+  tree grp_mid = NULL_TREE;\n+  if (OMP_CLAUSE_CHAIN (grp_start) != grp_end)\n+    grp_mid = OMP_CLAUSE_CHAIN (grp_start);\n+\n+  if (grp_mid\n+      && OMP_CLAUSE_CODE (grp_mid) == OMP_CLAUSE_MAP\n+      && OMP_CLAUSE_MAP_KIND (grp_mid) == GOMP_MAP_TO_PSET)\n+    OMP_CLAUSE_SIZE (c2) = OMP_CLAUSE_SIZE (grp_mid);\n   else\n     OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (ptr_type_node);\n-  if (struct_node)\n-    OMP_CLAUSE_CHAIN (struct_node) = c2;\n-\n-  /* We might need to create an additional mapping if we have a reference to a\n-     pointer (in C++).  Don't do this if we have something other than a\n-     GOMP_MAP_ALWAYS_POINTER though, i.e. a GOMP_MAP_TO_PSET.  */\n-  if (OMP_CLAUSE_CHAIN (prev_node) != c\n-      && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (prev_node)) == OMP_CLAUSE_MAP\n-      && ((OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n-\t   == GOMP_MAP_ALWAYS_POINTER)\n-\t  || (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (prev_node))\n-\t      == GOMP_MAP_ATTACH_DETACH)))\n-    {\n-      tree c4 = OMP_CLAUSE_CHAIN (prev_node);\n-      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+\n+  if (grp_mid\n+      && OMP_CLAUSE_CODE (grp_mid) == OMP_CLAUSE_MAP\n+      && (OMP_CLAUSE_MAP_KIND (grp_mid) == GOMP_MAP_ALWAYS_POINTER\n+\t  || OMP_CLAUSE_MAP_KIND (grp_mid) == GOMP_MAP_ATTACH_DETACH))\n+    {\n+      tree c3\n+\t= build_omp_clause (OMP_CLAUSE_LOCATION (grp_end), OMP_CLAUSE_MAP);\n       OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n-      OMP_CLAUSE_DECL (c3) = unshare_expr (OMP_CLAUSE_DECL (c4));\n+      OMP_CLAUSE_DECL (c3) = unshare_expr (OMP_CLAUSE_DECL (grp_mid));\n       OMP_CLAUSE_SIZE (c3) = TYPE_SIZE_UNIT (ptr_type_node);\n-      OMP_CLAUSE_CHAIN (c3) = prev_node;\n-      if (!scp)\n-\tOMP_CLAUSE_CHAIN (c2) = c3;\n-      else\n-\tcl = c3;\n-    }\n+      OMP_CLAUSE_CHAIN (c3) = NULL_TREE;\n \n-  if (scp)\n-    *scp = c2;\n+      *extra_node = c3;\n+    }\n+  else\n+    *extra_node = NULL_TREE;\n \n-  return cl;\n+  return c2;\n }\n \n /* Strip ARRAY_REFS or an indirect ref off BASE, find the containing object,\n@@ -8872,53 +8861,21 @@ insert_struct_comp_map (enum tree_code code, tree c, tree struct_node,\n    has array type, else return NULL.  */\n \n static tree\n-extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n-\t\t\t poly_offset_int *poffsetp, tree *offsetp)\n+extract_base_bit_offset (tree base, poly_int64 *bitposp,\n+\t\t\t poly_offset_int *poffsetp)\n {\n   tree offset;\n   poly_int64 bitsize, bitpos;\n   machine_mode mode;\n   int unsignedp, reversep, volatilep = 0;\n   poly_offset_int poffset;\n \n-  if (base_ref)\n-    {\n-      *base_ref = NULL_TREE;\n-\n-      while (TREE_CODE (base) == ARRAY_REF)\n-\tbase = TREE_OPERAND (base, 0);\n-\n-      if (TREE_CODE (base) == INDIRECT_REF)\n-\tbase = TREE_OPERAND (base, 0);\n-    }\n-  else\n-    {\n-      if (TREE_CODE (base) == ARRAY_REF)\n-\t{\n-\t  while (TREE_CODE (base) == ARRAY_REF)\n-\t    base = TREE_OPERAND (base, 0);\n-\t  if (TREE_CODE (base) != COMPONENT_REF\n-\t      || TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE)\n-\t    return NULL_TREE;\n-\t}\n-      else if (TREE_CODE (base) == INDIRECT_REF\n-\t       && TREE_CODE (TREE_OPERAND (base, 0)) == COMPONENT_REF\n-\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))\n-\t\t   == REFERENCE_TYPE))\n-\tbase = TREE_OPERAND (base, 0);\n-    }\n+  STRIP_NOPS (base);\n \n   base = get_inner_reference (base, &bitsize, &bitpos, &offset, &mode,\n \t\t\t      &unsignedp, &reversep, &volatilep);\n \n-  tree orig_base = base;\n-\n-  if ((TREE_CODE (base) == INDIRECT_REF\n-       || (TREE_CODE (base) == MEM_REF\n-\t   && integer_zerop (TREE_OPERAND (base, 1))))\n-      && DECL_P (TREE_OPERAND (base, 0))\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0))) == REFERENCE_TYPE)\n-    base = TREE_OPERAND (base, 0);\n+  STRIP_NOPS (base);\n \n   if (offset && poly_int_tree_p (offset))\n     {\n@@ -8933,11 +8890,6 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n \n   *bitposp = bitpos;\n   *poffsetp = poffset;\n-  *offsetp = offset;\n-\n-  /* Set *BASE_REF if BASE was a dereferenced reference variable.  */\n-  if (base_ref && orig_base != base)\n-    *base_ref = orig_base;\n \n   return base;\n }\n@@ -8961,6 +8913,9 @@ struct omp_mapping_group {\n   tree *grp_start;\n   tree grp_end;\n   omp_tsort_mark mark;\n+  /* If we've removed the group but need to reindex, mark the group as\n+     deleted.  */\n+  bool deleted;\n   struct omp_mapping_group *sibling;\n   struct omp_mapping_group *next;\n };\n@@ -9002,6 +8957,38 @@ omp_get_base_pointer (tree expr)\n   return NULL_TREE;\n }\n \n+/* Remove COMPONENT_REFS and indirections from EXPR.  */\n+\n+static tree\n+omp_strip_components_and_deref (tree expr)\n+{\n+  while (TREE_CODE (expr) == COMPONENT_REF\n+\t || TREE_CODE (expr) == INDIRECT_REF\n+\t || (TREE_CODE (expr) == MEM_REF\n+\t     && integer_zerop (TREE_OPERAND (expr, 1)))\n+\t || TREE_CODE (expr) == POINTER_PLUS_EXPR\n+\t || TREE_CODE (expr) == COMPOUND_EXPR)\n+      if (TREE_CODE (expr) == COMPOUND_EXPR)\n+\texpr = TREE_OPERAND (expr, 1);\n+      else\n+\texpr = TREE_OPERAND (expr, 0);\n+\n+  STRIP_NOPS (expr);\n+\n+  return expr;\n+}\n+\n+static tree\n+omp_strip_indirections (tree expr)\n+{\n+  while (TREE_CODE (expr) == INDIRECT_REF\n+\t || (TREE_CODE (expr) == MEM_REF\n+\t     && integer_zerop (TREE_OPERAND (expr, 1))))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  return expr;\n+}\n+\n /* An attach or detach operation depends directly on the address being\n    attached/detached.  Return that address, or none if there are no\n    attachments/detachments.  */\n@@ -9161,6 +9148,18 @@ omp_group_last (tree *start_p)\n \t      || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_DETACH))\n \tgrp_last_p = &OMP_CLAUSE_CHAIN (c);\n       break;\n+\n+    case GOMP_MAP_STRUCT:\n+      {\n+\tunsigned HOST_WIDE_INT num_mappings\n+\t  = tree_to_uhwi (OMP_CLAUSE_SIZE (c));\n+\tif (OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t    || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t  grp_last_p = &OMP_CLAUSE_CHAIN (*grp_last_p);\n+\tfor (unsigned i = 0; i < num_mappings; i++)\n+\t  grp_last_p = &OMP_CLAUSE_CHAIN (*grp_last_p);\n+      }\n+      break;\n     }\n \n   return grp_last_p;\n@@ -9188,6 +9187,7 @@ omp_gather_mapping_groups (tree *list_p)\n       grp.grp_end = *grp_last_p;\n       grp.mark = UNVISITED;\n       grp.sibling = NULL;\n+      grp.deleted = false;\n       grp.next = NULL;\n       groups->safe_push (grp);\n \n@@ -9294,6 +9294,21 @@ omp_group_base (omp_mapping_group *grp, unsigned int *chained,\n \tinternal_error (\"unexpected mapping node\");\n       return error_mark_node;\n \n+    case GOMP_MAP_STRUCT:\n+      {\n+\tunsigned HOST_WIDE_INT num_mappings\n+\t  = tree_to_uhwi (OMP_CLAUSE_SIZE (node));\n+\tnode = OMP_CLAUSE_CHAIN (node);\n+\tif (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t    || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t  {\n+\t    *firstprivate = OMP_CLAUSE_DECL (node);\n+\t    node = OMP_CLAUSE_CHAIN (node);\n+\t  }\n+\t*chained = num_mappings;\n+\treturn node;\n+      }\n+\n     case GOMP_MAP_FORCE_DEVICEPTR:\n     case GOMP_MAP_DEVICE_RESIDENT:\n     case GOMP_MAP_LINK:\n@@ -9335,6 +9350,9 @@ omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n \n   FOR_EACH_VEC_ELT (*groups, i, grp)\n     {\n+      if (grp->deleted)\n+\tcontinue;\n+\n       tree fpp;\n       unsigned int chained;\n       tree node = omp_group_base (grp, &chained, &fpp);\n@@ -9756,6 +9774,676 @@ omp_lastprivate_for_combined_outer_constructs (struct gimplify_omp_ctx *octx,\n     omp_notice_variable (octx, decl, true);\n }\n \n+/* Link node NEWNODE so it is pointed to by chain INSERT_AT.  NEWNODE's chain\n+   is linked to the previous node pointed to by INSERT_AT.  */\n+\n+static tree *\n+omp_siblist_insert_node_after (tree newnode, tree *insert_at)\n+{\n+  OMP_CLAUSE_CHAIN (newnode) = *insert_at;\n+  *insert_at = newnode;\n+  return &OMP_CLAUSE_CHAIN (newnode);\n+}\n+\n+/* Move NODE (which is currently pointed to by the chain OLD_POS) so it is\n+   pointed to by chain MOVE_AFTER instead.  */\n+\n+static void\n+omp_siblist_move_node_after (tree node, tree *old_pos, tree *move_after)\n+{\n+  gcc_assert (node == *old_pos);\n+  *old_pos = OMP_CLAUSE_CHAIN (node);\n+  OMP_CLAUSE_CHAIN (node) = *move_after;\n+  *move_after = node;\n+}\n+\n+/* Move nodes from FIRST_PTR (pointed to by previous node's chain) to\n+   LAST_NODE to after MOVE_AFTER chain.  Similar to below function, but no\n+   new nodes are prepended to the list before splicing into the new position.\n+   Return the position we should continue scanning the list at, or NULL to\n+   stay where we were.  */\n+\n+static tree *\n+omp_siblist_move_nodes_after (tree *first_ptr, tree last_node,\n+\t\t\t      tree *move_after)\n+{\n+  if (first_ptr == move_after)\n+    return NULL;\n+\n+  tree tmp = *first_ptr;\n+  *first_ptr = OMP_CLAUSE_CHAIN (last_node);\n+  OMP_CLAUSE_CHAIN (last_node) = *move_after;\n+  *move_after = tmp;\n+\n+  return first_ptr;\n+}\n+\n+/* Concatenate two lists described by [FIRST_NEW, LAST_NEW_TAIL] and\n+   [FIRST_PTR, LAST_NODE], and insert them in the OMP clause list after chain\n+   pointer MOVE_AFTER.\n+\n+   The latter list was previously part of the OMP clause list, and the former\n+   (prepended) part is comprised of new nodes.\n+\n+   We start with a list of nodes starting with a struct mapping node.  We\n+   rearrange the list so that new nodes starting from FIRST_NEW and whose last\n+   node's chain is LAST_NEW_TAIL comes directly after MOVE_AFTER, followed by\n+   the group of mapping nodes we are currently processing (from the chain\n+   FIRST_PTR to LAST_NODE).  The return value is the pointer to the next chain\n+   we should continue processing from, or NULL to stay where we were.\n+\n+   The transformation (in the case where MOVE_AFTER and FIRST_PTR are\n+   different) is worked through below.  Here we are processing LAST_NODE, and\n+   FIRST_PTR points at the preceding mapping clause:\n+\n+  #. mapping node\t\tchain\n+  ---------------------------------------------------\n+  A. struct_node\t\t[->B]\n+  B. comp_1\t\t\t[->C]\n+  C. comp_2\t\t\t[->D (move_after)]\n+  D. map_to_3\t\t\t[->E]\n+  E. attach_3\t\t\t[->F (first_ptr)]\n+  F. map_to_4\t\t\t[->G (continue_at)]\n+  G. attach_4 (last_node)\t[->H]\n+  H. ...\n+\n+     *last_new_tail = *first_ptr;\n+\n+  I. new_node (first_new)\t[->F (last_new_tail)]\n+\n+     *first_ptr = OMP_CLAUSE_CHAIN (last_node)\n+\n+  #. mapping node\t\tchain\n+  ----------------------------------------------------\n+  A. struct_node\t\t[->B]\n+  B. comp_1\t\t\t[->C]\n+  C. comp_2\t\t\t[->D (move_after)]\n+  D. map_to_3\t\t\t[->E]\n+  E. attach_3\t\t\t[->H (first_ptr)]\n+  F. map_to_4\t\t\t[->G (continue_at)]\n+  G. attach_4 (last_node)\t[->H]\n+  H. ...\n+\n+  I. new_node (first_new)\t[->F  (last_new_tail)]\n+\n+     OMP_CLAUSE_CHAIN (last_node) = *move_after;\n+\n+  #. mapping node\t\tchain\n+  ---------------------------------------------------\n+  A. struct_node\t\t[->B]\n+  B. comp_1\t\t\t[->C]\n+  C. comp_2\t\t\t[->D (move_after)]\n+  D. map_to_3\t\t\t[->E]\n+  E. attach_3\t\t\t[->H (continue_at)]\n+  F. map_to_4\t\t\t[->G]\n+  G. attach_4 (last_node)\t[->D]\n+  H. ...\n+\n+  I. new_node (first_new)\t[->F  (last_new_tail)]\n+\n+     *move_after = first_new;\n+\n+  #. mapping node\t\tchain\n+  ---------------------------------------------------\n+  A. struct_node\t\t[->B]\n+  B. comp_1\t\t\t[->C]\n+  C. comp_2\t\t\t[->I (move_after)]\n+  D. map_to_3\t\t\t[->E]\n+  E. attach_3\t\t\t[->H (continue_at)]\n+  F. map_to_4\t\t\t[->G]\n+  G. attach_4 (last_node)\t[->D]\n+  H. ...\n+  I. new_node (first_new)\t[->F (last_new_tail)]\n+\n+  or, in order:\n+\n+  #. mapping node\t\tchain\n+  ---------------------------------------------------\n+  A. struct_node\t\t[->B]\n+  B. comp_1\t\t\t[->C]\n+  C. comp_2\t\t\t[->I (move_after)]\n+  I. new_node (first_new)\t[->F (last_new_tail)]\n+  F. map_to_4\t\t\t[->G]\n+  G. attach_4 (last_node)\t[->D]\n+  D. map_to_3\t\t\t[->E]\n+  E. attach_3\t\t\t[->H (continue_at)]\n+  H. ...\n+*/\n+\n+static tree *\n+omp_siblist_move_concat_nodes_after (tree first_new, tree *last_new_tail,\n+\t\t\t\t     tree *first_ptr, tree last_node,\n+\t\t\t\t     tree *move_after)\n+{\n+  tree *continue_at = NULL;\n+  *last_new_tail = *first_ptr;\n+  if (first_ptr == move_after)\n+    *move_after = first_new;\n+  else\n+    {\n+      *first_ptr = OMP_CLAUSE_CHAIN (last_node);\n+      continue_at = first_ptr;\n+      OMP_CLAUSE_CHAIN (last_node) = *move_after;\n+      *move_after = first_new;\n+    }\n+  return continue_at;\n+}\n+\n+/* Mapping struct members causes an additional set of nodes to be created,\n+   starting with GOMP_MAP_STRUCT followed by a number of mappings equal to the\n+   number of members being mapped, in order of ascending position (address or\n+   bitwise).\n+\n+   We scan through the list of mapping clauses, calling this function for each\n+   struct member mapping we find, and build up the list of mappings after the\n+   initial GOMP_MAP_STRUCT node.  For pointer members, these will be\n+   newly-created ALLOC nodes.  For non-pointer members, the existing mapping is\n+   moved into place in the sorted list.\n+\n+     struct {\n+       int *a;\n+       int *b;\n+       int c;\n+       int *d;\n+     };\n+\n+     #pragma (acc|omp directive) copy(struct.a[0:n], struct.b[0:n], struct.c,\n+\t\t\t\t      struct.d[0:n])\n+\n+     GOMP_MAP_STRUCT (4)\n+     [GOMP_MAP_FIRSTPRIVATE_REFERENCE -- for refs to structs]\n+     GOMP_MAP_ALLOC  (struct.a)\n+     GOMP_MAP_ALLOC  (struct.b)\n+     GOMP_MAP_TO     (struct.c)\n+     GOMP_MAP_ALLOC  (struct.d)\n+     ...\n+\n+   In the case where we are mapping references to pointers, or in Fortran if\n+   we are mapping an array with a descriptor, additional nodes may be created\n+   after the struct node list also.\n+\n+   The return code is either a pointer to the next node to process (if the\n+   list has been rearranged), else NULL to continue with the next node in the\n+   original list.  */\n+\n+static tree *\n+omp_accumulate_sibling_list (enum omp_region_type region_type,\n+\t\t\t     enum tree_code code,\n+\t\t\t     hash_map<tree_operand_hash, tree>\n+\t\t\t       *&struct_map_to_clause, tree *grp_start_p,\n+\t\t\t     tree grp_end, tree *inner)\n+{\n+  poly_offset_int coffset;\n+  poly_int64 cbitpos;\n+  tree ocd = OMP_CLAUSE_DECL (grp_end);\n+  bool openmp = !(region_type & ORT_ACC);\n+  tree *continue_at = NULL;\n+\n+  while (TREE_CODE (ocd) == ARRAY_REF)\n+    ocd = TREE_OPERAND (ocd, 0);\n+\n+  if (TREE_CODE (ocd) == INDIRECT_REF)\n+    ocd = TREE_OPERAND (ocd, 0);\n+\n+  tree base = extract_base_bit_offset (ocd, &cbitpos, &coffset);\n+\n+  bool ptr = (OMP_CLAUSE_MAP_KIND (grp_end) == GOMP_MAP_ALWAYS_POINTER);\n+  bool attach_detach = ((OMP_CLAUSE_MAP_KIND (grp_end)\n+\t\t\t == GOMP_MAP_ATTACH_DETACH)\n+\t\t\t|| (OMP_CLAUSE_MAP_KIND (grp_end)\n+\t\t\t    == GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION));\n+  bool attach = (OMP_CLAUSE_MAP_KIND (grp_end) == GOMP_MAP_ATTACH\n+\t\t || OMP_CLAUSE_MAP_KIND (grp_end) == GOMP_MAP_DETACH);\n+\n+  /* FIXME: If we're not mapping the base pointer in some other clause on this\n+     directive, I think we want to create ALLOC/RELEASE here -- i.e. not\n+     early-exit.  */\n+  if (openmp && attach_detach)\n+    return NULL;\n+\n+  if (!struct_map_to_clause || struct_map_to_clause->get (base) == NULL)\n+    {\n+      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (grp_end), OMP_CLAUSE_MAP);\n+      gomp_map_kind k = attach ? GOMP_MAP_FORCE_PRESENT : GOMP_MAP_STRUCT;\n+\n+      OMP_CLAUSE_SET_MAP_KIND (l, k);\n+\n+      OMP_CLAUSE_DECL (l) = unshare_expr (base);\n+\n+      OMP_CLAUSE_SIZE (l)\n+\t= (!attach ? size_int (1)\n+\t   : (DECL_P (OMP_CLAUSE_DECL (l))\n+\t      ? DECL_SIZE_UNIT (OMP_CLAUSE_DECL (l))\n+\t      : TYPE_SIZE_UNIT (TREE_TYPE (OMP_CLAUSE_DECL (l)))));\n+      if (struct_map_to_clause == NULL)\n+\tstruct_map_to_clause = new hash_map<tree_operand_hash, tree>;\n+      struct_map_to_clause->put (base, l);\n+\n+      if (ptr || attach_detach)\n+\t{\n+\t  tree extra_node;\n+\t  tree alloc_node\n+\t    = build_omp_struct_comp_nodes (code, *grp_start_p, grp_end,\n+\t\t\t\t\t   &extra_node);\n+\t  OMP_CLAUSE_CHAIN (l) = alloc_node;\n+\n+\t  tree *insert_node_pos = grp_start_p;\n+\n+\t  if (extra_node)\n+\t    {\n+\t      OMP_CLAUSE_CHAIN (extra_node) = *insert_node_pos;\n+\t      OMP_CLAUSE_CHAIN (alloc_node) = extra_node;\n+\t    }\n+\t  else\n+\t    OMP_CLAUSE_CHAIN (alloc_node) = *insert_node_pos;\n+\n+\t  *insert_node_pos = l;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (*grp_start_p == grp_end);\n+\t  grp_start_p = omp_siblist_insert_node_after (l, grp_start_p);\n+\t}\n+\n+      tree noind = omp_strip_indirections (base);\n+\n+      if (!openmp\n+\t  && (region_type & ORT_TARGET)\n+\t  && TREE_CODE (noind) == COMPONENT_REF)\n+\t{\n+\t  /* The base for this component access is a struct component access\n+\t     itself.  Insert a node to be processed on the next iteration of\n+\t     our caller's loop, which will subsequently be turned into a new,\n+\t     inner GOMP_MAP_STRUCT mapping.\n+\n+\t     We need to do this else the non-DECL_P base won't be\n+\t     rewritten correctly in the offloaded region.  */\n+\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t\t      OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FORCE_PRESENT);\n+\t  OMP_CLAUSE_DECL (c2) = unshare_expr (noind);\n+\t  OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (TREE_TYPE (noind));\n+\t  *inner = c2;\n+\t  return NULL;\n+\t}\n+\n+      tree sdecl = omp_strip_components_and_deref (base);\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (sdecl)) && (region_type & ORT_TARGET))\n+\t{\n+\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t\t      OMP_CLAUSE_MAP);\n+\t  bool base_ref\n+\t    = (TREE_CODE (base) == INDIRECT_REF\n+\t       && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))\n+\t\t    == REFERENCE_TYPE)\n+\t\t   || ((TREE_CODE (TREE_OPERAND (base, 0))\n+\t\t\t== INDIRECT_REF)\n+\t\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t\t  (TREE_OPERAND (base, 0), 0)))\n+\t\t\t   == REFERENCE_TYPE))));\n+\t  enum gomp_map_kind mkind = base_ref ? GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\t\t\t\t\t      : GOMP_MAP_FIRSTPRIVATE_POINTER;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+\t  OMP_CLAUSE_DECL (c2) = sdecl;\n+\t  tree baddr = build_fold_addr_expr (base);\n+\t  baddr = fold_convert_loc (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t\t    ptrdiff_type_node, baddr);\n+\t  /* This isn't going to be good enough when we add support for more\n+\t     complicated lvalue expressions.  FIXME.  */\n+\t  if (TREE_CODE (TREE_TYPE (sdecl)) == REFERENCE_TYPE\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (sdecl))) == POINTER_TYPE)\n+\t    sdecl = build_simple_mem_ref (sdecl);\n+\t  tree decladdr = fold_convert_loc (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t\t\t    ptrdiff_type_node, sdecl);\n+\t  OMP_CLAUSE_SIZE (c2)\n+\t    = fold_build2_loc (OMP_CLAUSE_LOCATION (grp_end), MINUS_EXPR,\n+\t\t\t       ptrdiff_type_node, baddr, decladdr);\n+\t  /* Insert after struct node.  */\n+\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (l);\n+\t  OMP_CLAUSE_CHAIN (l) = c2;\n+\t}\n+\n+      return NULL;\n+    }\n+  else if (struct_map_to_clause)\n+    {\n+      tree *osc = struct_map_to_clause->get (base);\n+      tree *sc = NULL, *scp = NULL;\n+      sc = &OMP_CLAUSE_CHAIN (*osc);\n+      /* The struct mapping might be immediately followed by a\n+\t FIRSTPRIVATE_POINTER and/or FIRSTPRIVATE_REFERENCE -- if it's an\n+\t indirect access or a reference, or both.  (This added node is removed\n+\t in omp-low.c after it has been processed there.)  */\n+      if (*sc != grp_end\n+\t  && (OMP_CLAUSE_MAP_KIND (*sc) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t      || OMP_CLAUSE_MAP_KIND (*sc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n+\tsc = &OMP_CLAUSE_CHAIN (*sc);\n+      for (; *sc != grp_end; sc = &OMP_CLAUSE_CHAIN (*sc))\n+\tif ((ptr || attach_detach) && sc == grp_start_p)\n+\t  break;\n+\telse if (TREE_CODE (OMP_CLAUSE_DECL (*sc)) != COMPONENT_REF\n+\t\t && TREE_CODE (OMP_CLAUSE_DECL (*sc)) != INDIRECT_REF\n+\t\t && TREE_CODE (OMP_CLAUSE_DECL (*sc)) != ARRAY_REF)\n+\t  break;\n+\telse\n+\t  {\n+\t    tree sc_decl = OMP_CLAUSE_DECL (*sc);\n+\t    poly_offset_int offset;\n+\t    poly_int64 bitpos;\n+\n+\t    if (TREE_CODE (sc_decl) == ARRAY_REF)\n+\t      {\n+\t\twhile (TREE_CODE (sc_decl) == ARRAY_REF)\n+\t\t  sc_decl = TREE_OPERAND (sc_decl, 0);\n+\t\tif (TREE_CODE (sc_decl) != COMPONENT_REF\n+\t\t    || TREE_CODE (TREE_TYPE (sc_decl)) != ARRAY_TYPE)\n+\t\t  break;\n+\t      }\n+\t    else if (TREE_CODE (sc_decl) == INDIRECT_REF\n+\t\t     && TREE_CODE (TREE_OPERAND (sc_decl, 0)) == COMPONENT_REF\n+\t\t     && (TREE_CODE (TREE_TYPE (TREE_OPERAND (sc_decl, 0)))\n+\t\t\t == REFERENCE_TYPE))\n+\t      sc_decl = TREE_OPERAND (sc_decl, 0);\n+\n+\t    tree base2 = extract_base_bit_offset (sc_decl, &bitpos, &offset);\n+\t    if (!base2 || !operand_equal_p (base2, base, 0))\n+\t      break;\n+\t    if (scp)\n+\t      continue;\n+\t    if ((region_type & ORT_ACC) != 0)\n+\t      {\n+\t\t/* This duplicate checking code is currently only enabled for\n+\t\t   OpenACC.  */\n+\t\ttree d1 = OMP_CLAUSE_DECL (*sc);\n+\t\ttree d2 = OMP_CLAUSE_DECL (grp_end);\n+\t\twhile (TREE_CODE (d1) == ARRAY_REF)\n+\t\t  d1 = TREE_OPERAND (d1, 0);\n+\t\twhile (TREE_CODE (d2) == ARRAY_REF)\n+\t\t  d2 = TREE_OPERAND (d2, 0);\n+\t\tif (TREE_CODE (d1) == INDIRECT_REF)\n+\t\t  d1 = TREE_OPERAND (d1, 0);\n+\t\tif (TREE_CODE (d2) == INDIRECT_REF)\n+\t\t  d2 = TREE_OPERAND (d2, 0);\n+\t\twhile (TREE_CODE (d1) == COMPONENT_REF)\n+\t\t  if (TREE_CODE (d2) == COMPONENT_REF\n+\t\t      && TREE_OPERAND (d1, 1) == TREE_OPERAND (d2, 1))\n+\t\t    {\n+\t\t      d1 = TREE_OPERAND (d1, 0);\n+\t\t      d2 = TREE_OPERAND (d2, 0);\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\tif (d1 == d2)\n+\t\t  {\n+\t\t    error_at (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t      \"%qE appears more than once in map clauses\",\n+\t\t\t      OMP_CLAUSE_DECL (grp_end));\n+\t\t    return NULL;\n+\t\t  }\n+\t      }\n+\t    if (maybe_lt (coffset, offset)\n+\t\t|| (known_eq (coffset, offset)\n+\t\t    && maybe_lt (cbitpos, bitpos)))\n+\t      {\n+\t\tif (ptr || attach_detach)\n+\t\t  scp = sc;\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t  }\n+\n+      if (!attach)\n+\tOMP_CLAUSE_SIZE (*osc)\n+\t  = size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc), size_one_node);\n+      if (ptr || attach_detach)\n+\t{\n+\t  tree cl = NULL_TREE, extra_node;\n+\t  tree alloc_node = build_omp_struct_comp_nodes (code, *grp_start_p,\n+\t\t\t\t\t\t\t grp_end, &extra_node);\n+\t  tree *tail_chain = NULL;\n+\n+\t  /* Here, we have:\n+\n+\t     grp_end : the last (or only) node in this group.\n+\t     grp_start_p : pointer to the first node in a pointer mapping group\n+\t\t\t   up to and including GRP_END.\n+\t     sc : pointer to the chain for the end of the struct component\n+\t\t  list.\n+\t     scp : pointer to the chain for the sorted position at which we\n+\t\t   should insert in the middle of the struct component list\n+\t\t   (else NULL to insert at end).\n+\t     alloc_node : the \"alloc\" node for the structure (pointer-type)\n+\t\t\t  component. We insert at SCP (if present), else SC\n+\t\t\t  (the end of the struct component list).\n+\t     extra_node : a newly-synthesized node for an additional indirect\n+\t\t\t  pointer mapping or a Fortran pointer set, if needed.\n+\t     cl : first node to prepend before grp_start_p.\n+\t     tail_chain : pointer to chain of last prepended node.\n+\n+\t     The general idea is we move the nodes for this struct mapping\n+\t     together: the alloc node goes into the sorted list directly after\n+\t     the struct mapping, and any extra nodes (together with the nodes\n+\t     mapping arrays pointed to by struct components) get moved after\n+\t     that list.  When SCP is NULL, we insert the nodes at SC, i.e. at\n+\t     the end of the struct component mapping list.  It's important that\n+\t     the alloc_node comes first in that case because it's part of the\n+\t     sorted component mapping list (but subsequent nodes are not!).  */\n+\n+\t  if (scp)\n+\t    omp_siblist_insert_node_after (alloc_node, scp);\n+\n+\t  /* Make [cl,tail_chain] a list of the alloc node (if we haven't\n+\t     already inserted it) and the extra_node (if it is present).  The\n+\t     list can be empty if we added alloc_node above and there is no\n+\t     extra node.  */\n+\t  if (scp && extra_node)\n+\t    {\n+\t      cl = extra_node;\n+\t      tail_chain = &OMP_CLAUSE_CHAIN (extra_node);\n+\t    }\n+\t  else if (extra_node)\n+\t    {\n+\t      OMP_CLAUSE_CHAIN (alloc_node) = extra_node;\n+\t      cl = alloc_node;\n+\t      tail_chain = &OMP_CLAUSE_CHAIN (extra_node);\n+\t    }\n+\t  else if (!scp)\n+\t    {\n+\t      cl = alloc_node;\n+\t      tail_chain = &OMP_CLAUSE_CHAIN (alloc_node);\n+\t    }\n+\n+\t  continue_at\n+\t    = cl ? omp_siblist_move_concat_nodes_after (cl, tail_chain,\n+\t\t\t\t\t\t\tgrp_start_p, grp_end,\n+\t\t\t\t\t\t\tsc)\n+\t\t : omp_siblist_move_nodes_after (grp_start_p, grp_end, sc);\n+\t}\n+      else if (*sc != grp_end)\n+\t{\n+\t  gcc_assert (*grp_start_p == grp_end);\n+\n+\t  /* We are moving the current node back to a previous struct node:\n+\t     the node that used to point to the current node will now point to\n+\t     the next node.  */\n+\t  continue_at = grp_start_p;\n+\t  /* In the non-pointer case, the mapping clause itself is moved into\n+\t     the correct position in the struct component list, which in this\n+\t     case is just SC.  */\n+\t  omp_siblist_move_node_after (*grp_start_p, grp_start_p, sc);\n+\t}\n+    }\n+  return continue_at;\n+}\n+\n+/* Scan through GROUPS, and create sorted structure sibling lists without\n+   gimplifying.  */\n+\n+static bool\n+omp_build_struct_sibling_lists (enum tree_code code,\n+\t\t\t\tenum omp_region_type region_type,\n+\t\t\t\tvec<omp_mapping_group> *groups,\n+\t\t\t\thash_map<tree_operand_hash, omp_mapping_group *>\n+\t\t\t\t  **grpmap)\n+{\n+  unsigned i;\n+  omp_mapping_group *grp;\n+  hash_map<tree_operand_hash, tree> *struct_map_to_clause = NULL;\n+  bool success = true;\n+  tree *new_next = NULL;\n+  tree *tail = &OMP_CLAUSE_CHAIN ((*groups)[groups->length () - 1].grp_end);\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      tree c = grp->grp_end;\n+      tree decl = OMP_CLAUSE_DECL (c);\n+      tree *grp_start_p = new_next ? new_next : grp->grp_start;\n+      tree grp_end = grp->grp_end;\n+\n+      new_next = NULL;\n+\n+      if (DECL_P (decl))\n+\tcontinue;\n+\n+      if (OMP_CLAUSE_CHAIN (*grp_start_p)\n+\t  && OMP_CLAUSE_CHAIN (*grp_start_p) != grp_end)\n+\t{\n+\t  /* Don't process an array descriptor that isn't inside a derived type\n+\t     as a struct (the GOMP_MAP_POINTER following will have the form\n+\t     \"var.data\", but such mappings are handled specially).  */\n+\t  tree grpmid = OMP_CLAUSE_CHAIN (*grp_start_p);\n+\t  if (OMP_CLAUSE_CODE (grpmid) == OMP_CLAUSE_MAP\n+\t      && OMP_CLAUSE_MAP_KIND (grpmid) == GOMP_MAP_TO_PSET\n+\t      && DECL_P (OMP_CLAUSE_DECL (grpmid)))\n+\t    continue;\n+\t}\n+\n+      tree d = decl;\n+      if (TREE_CODE (d) == ARRAY_REF)\n+\t{\n+\t  while (TREE_CODE (d) == ARRAY_REF)\n+\t    d = TREE_OPERAND (d, 0);\n+\t  if (TREE_CODE (d) == COMPONENT_REF\n+\t      && TREE_CODE (TREE_TYPE (d)) == ARRAY_TYPE)\n+\t    decl = d;\n+\t}\n+      if (d == decl\n+\t  && TREE_CODE (decl) == INDIRECT_REF\n+\t  && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n+\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t      == REFERENCE_TYPE)\n+\t  && (OMP_CLAUSE_MAP_KIND (c)\n+\t      != GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION))\n+\tdecl = TREE_OPERAND (decl, 0);\n+\n+      STRIP_NOPS (decl);\n+\n+      if (TREE_CODE (decl) != COMPONENT_REF)\n+\tcontinue;\n+\n+      omp_mapping_group **wholestruct = NULL;\n+      tree wsdecl = omp_containing_struct (OMP_CLAUSE_DECL (c));\n+\n+      if (!(region_type & ORT_ACC) && wsdecl != OMP_CLAUSE_DECL (c))\n+\t{\n+\t  wholestruct = (*grpmap)->get (wsdecl);\n+\t  if (!wholestruct\n+\t      && TREE_CODE (wsdecl) == MEM_REF\n+\t      && integer_zerop (TREE_OPERAND (wsdecl, 1)))\n+\t    {\n+\t      tree deref = TREE_OPERAND (wsdecl, 0);\n+\t      deref = build1 (INDIRECT_REF, TREE_TYPE (wsdecl), deref);\n+\t      wholestruct = (*grpmap)->get (deref);\n+\t    }\n+\t}\n+\n+      if (wholestruct)\n+\t{\n+\t  if (*grp_start_p == grp_end)\n+\t    {\n+\t      /* Remove the whole of this mapping -- redundant.  */\n+\t      if (i + 1 < groups->length ())\n+\t\t{\n+\t\t  omp_mapping_group *nextgrp = &(*groups)[i + 1];\n+\t\t  nextgrp->grp_start = grp_start_p;\n+\t\t}\n+\t      grp->deleted = true;\n+\t      new_next = grp_start_p;\n+\t      *grp_start_p = OMP_CLAUSE_CHAIN (grp_end);\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n+      if (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n+\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n+\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n+\t  && code != OACC_UPDATE\n+\t  && code != OMP_TARGET_UPDATE)\n+\t{\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      success = false;\n+\t      goto error_out;\n+\t    }\n+\n+\t  tree stype = TREE_TYPE (decl);\n+\t  if (TREE_CODE (stype) == REFERENCE_TYPE)\n+\t    stype = TREE_TYPE (stype);\n+\t  if (TYPE_SIZE_UNIT (stype) == NULL\n+\t      || TREE_CODE (TYPE_SIZE_UNIT (stype)) != INTEGER_CST)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"mapping field %qE of variable length \"\n+\t\t\t\"structure\", OMP_CLAUSE_DECL (c));\n+\t      success = false;\n+\t      goto error_out;\n+\t    }\n+\n+\t  tree inner = NULL_TREE;\n+\n+\t  new_next\n+\t    = omp_accumulate_sibling_list (region_type, code,\n+\t\t\t\t\t   struct_map_to_clause, grp_start_p,\n+\t\t\t\t\t   grp_end, &inner);\n+\n+\t  if (inner)\n+\t    {\n+\t      if (new_next && *new_next == NULL_TREE)\n+\t\t*new_next = inner;\n+\t      else\n+\t\t*tail = inner;\n+\n+\t      OMP_CLAUSE_CHAIN (inner) = NULL_TREE;\n+\n+\t      omp_mapping_group newgrp;\n+\t      newgrp.grp_start = new_next ? new_next : tail;\n+\t      newgrp.grp_end = inner;\n+\t      newgrp.mark = UNVISITED;\n+\t      newgrp.sibling = NULL;\n+\t      newgrp.deleted = false;\n+\t      newgrp.next = NULL;\n+\t      groups->safe_push (newgrp);\n+\n+\t      /* !!! Growing GROUPS might invalidate the pointers in the group\n+\t\t map.  Rebuild it here.  This is a bit inefficient, but\n+\t\t shouldn't happen very often.  */\n+\t      delete (*grpmap);\n+\t      *grpmap = omp_index_mapping_groups (groups);\n+\n+\t      tail = &OMP_CLAUSE_CHAIN (inner);\n+\t    }\n+\t}\n+    }\n+\n+error_out:\n+  if (struct_map_to_clause)\n+    delete struct_map_to_clause;\n+\n+  return success;\n+}\n+\n /* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n@@ -9766,9 +10454,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n {\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n-  hash_map<tree_operand_hash, tree> *struct_map_to_clause = NULL;\n-  hash_map<tree_operand_hash, tree *> *struct_seen_clause = NULL;\n-  hash_set<tree> *struct_deref_set = NULL;\n   tree *prev_list_p = NULL, *orig_list_p = list_p;\n   int handled_depend_iterators = -1;\n   int nowait = -1;\n@@ -9800,29 +10485,59 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tbreak;\n       }\n \n-  /* Topological sorting may fail if we have duplicate nodes, which\n-     we should have detected and shown an error for already.  Skip\n-     sorting in that case.  */\n-  if (!seen_error ()\n-      && (code == OMP_TARGET\n-\t  || code == OMP_TARGET_DATA\n-\t  || code == OMP_TARGET_ENTER_DATA\n-\t  || code == OMP_TARGET_EXIT_DATA))\n+  if (code == OMP_TARGET\n+      || code == OMP_TARGET_DATA\n+      || code == OMP_TARGET_ENTER_DATA\n+      || code == OMP_TARGET_EXIT_DATA)\n     {\n       vec<omp_mapping_group> *groups;\n       groups = omp_gather_mapping_groups (list_p);\n       if (groups)\n \t{\n \t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n-\t  omp_mapping_group *outlist\n-\t    = omp_tsort_mapping_groups (groups, grpmap);\n+\n+\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap);\n+\n+\t  omp_mapping_group *outlist = NULL;\n+\n+\t  /* Topological sorting may fail if we have duplicate nodes, which\n+\t     we should have detected and shown an error for already.  Skip\n+\t     sorting in that case.  */\n+\t  if (seen_error ())\n+\t    goto failure;\n+\n+\t  delete grpmap;\n+\t  delete groups;\n+\n+\t  /* Rebuild now we have struct sibling lists.  */\n+\t  groups = omp_gather_mapping_groups (list_p);\n+\t  grpmap = omp_index_mapping_groups (groups);\n+\n+\t  outlist = omp_tsort_mapping_groups (groups, grpmap);\n \t  outlist = omp_segregate_mapping_groups (outlist);\n \t  list_p = omp_reorder_mapping_groups (groups, outlist, list_p);\n+\n+\tfailure:\n \t  delete grpmap;\n \t  delete groups;\n \t}\n     }\n+  else if (region_type & ORT_ACC)\n+    {\n+      vec<omp_mapping_group> *groups;\n+      groups = omp_gather_mapping_groups (list_p);\n+      if (groups)\n+\t{\n+\t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n+\t  grpmap = omp_index_mapping_groups (groups);\n+\n+\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap);\n+\n+\t  delete groups;\n+\t  delete grpmap;\n+\t}\n+    }\n \n   while ((c = *list_p) != NULL)\n     {\n@@ -10229,6 +10944,28 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t  GOVD_FIRSTPRIVATE | GOVD_SEEN);\n \t    }\n \n+\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT)\n+\t    {\n+\t      tree base = omp_strip_components_and_deref (decl);\n+\t      if (DECL_P (base))\n+\t\t{\n+\t\t  decl = base;\n+\t\t  splay_tree_node n\n+\t\t    = splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t (splay_tree_key) decl);\n+\t\t  if (seen_error ()\n+\t\t      && n\n+\t\t      && (n->value & (GOVD_MAP | GOVD_FIRSTPRIVATE)) != 0)\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  flags = GOVD_MAP | GOVD_EXPLICIT;\n+\n+\t\t  goto do_add_decl;\n+\t\t}\n+\t    }\n+\n \t  if (TREE_CODE (decl) == TARGET_EXPR)\n \t    {\n \t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n@@ -10259,487 +10996,56 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  pd = &TREE_OPERAND (decl, 0);\n \t\t  decl = TREE_OPERAND (decl, 0);\n \t\t}\n-\t      bool indir_p = false;\n-\t      bool component_ref_p = false;\n-\t      tree indir_base = NULL_TREE;\n-\t      tree orig_decl = decl;\n-\t      tree decl_ref = NULL_TREE;\n-\t      if ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA)) != 0\n-\t\t  && TREE_CODE (*pd) == COMPONENT_REF\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH\n-\t\t  && code != OACC_UPDATE)\n-\t\t{\n-\t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n-\t\t    {\n-\t\t      decl = TREE_OPERAND (decl, 0);\n-\t\t      component_ref_p = true;\n-\t\t      if (((TREE_CODE (decl) == MEM_REF\n-\t\t\t    && integer_zerop (TREE_OPERAND (decl, 1)))\n-\t\t\t   || INDIRECT_REF_P (decl))\n-\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n-\t\t\t      == POINTER_TYPE))\n-\t\t\t{\n-\t\t\t  indir_p = true;\n-\t\t\t  indir_base = decl;\n-\t\t\t  decl = TREE_OPERAND (decl, 0);\n-\t\t\t  STRIP_NOPS (decl);\n-\t\t\t}\n-\t\t      if (TREE_CODE (decl) == INDIRECT_REF\n-\t\t\t  && DECL_P (TREE_OPERAND (decl, 0))\n-\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n-\t\t\t      == REFERENCE_TYPE))\n-\t\t\t{\n-\t\t\t  decl_ref = decl;\n-\t\t\t  decl = TREE_OPERAND (decl, 0);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else if (TREE_CODE (decl) == COMPONENT_REF\n-\t\t       && (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t   != GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION))\n-\t\t{\n-\t\t  component_ref_p = true;\n-\t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n-\t\t    decl = TREE_OPERAND (decl, 0);\n-\t\t  if (TREE_CODE (decl) == INDIRECT_REF\n-\t\t      && DECL_P (TREE_OPERAND (decl, 0))\n-\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n-\t\t\t  == REFERENCE_TYPE))\n-\t\t    decl = TREE_OPERAND (decl, 0);\n-\t\t}\n-\t      if (decl != orig_decl && DECL_P (decl) && indir_p\n-\t\t  && (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n-\t\t      || (decl_ref\n-\t\t\t  && TREE_CODE (TREE_TYPE (decl_ref)) == POINTER_TYPE)))\n-\t\t{\n-\t\t  gomp_map_kind k\n-\t\t    = ((code == OACC_EXIT_DATA || code == OMP_TARGET_EXIT_DATA)\n-\t\t       ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n-\t\t  /* We have a dereference of a struct member.  Make this an\n-\t\t     attach/detach operation, and ensure the base pointer is\n-\t\t     mapped as a FIRSTPRIVATE_POINTER.  */\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (c, k);\n-\t\t  flags = GOVD_MAP | GOVD_SEEN | GOVD_EXPLICIT;\n-\t\t  tree next_clause = OMP_CLAUSE_CHAIN (c);\n-\t\t  if (k == GOMP_MAP_ATTACH\n-\t\t      && code != OACC_ENTER_DATA\n-\t\t      && code != OMP_TARGET_ENTER_DATA\n-\t\t      && (!next_clause\n-\t\t\t   || (OMP_CLAUSE_CODE (next_clause) != OMP_CLAUSE_MAP)\n-\t\t\t   || (OMP_CLAUSE_MAP_KIND (next_clause)\n-\t\t\t       != GOMP_MAP_POINTER)\n-\t\t\t   || OMP_CLAUSE_DECL (next_clause) != decl)\n-\t\t      && (!struct_deref_set\n-\t\t\t  || !struct_deref_set->contains (decl))\n-\t\t      && (!struct_map_to_clause\n-\t\t\t  || !struct_map_to_clause->get (indir_base)))\n-\t\t    {\n-\t\t      if (!struct_deref_set)\n-\t\t\tstruct_deref_set = new hash_set<tree> ();\n-\t\t      /* As well as the attach, we also need a\n-\t\t\t FIRSTPRIVATE_POINTER clause to properly map the\n-\t\t\t pointer to the struct base.  */\n-\t\t      tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALLOC);\n-\t\t      OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c2)\n-\t\t\t= 1;\n-\t\t      tree charptr_zero\n-\t\t\t= build_int_cst (build_pointer_type (char_type_node),\n-\t\t\t\t\t 0);\n-\t\t      OMP_CLAUSE_DECL (c2)\n-\t\t\t= build2 (MEM_REF, char_type_node,\n-\t\t\t\t  decl_ref ? decl_ref : decl, charptr_zero);\n-\t\t      OMP_CLAUSE_SIZE (c2) = size_zero_node;\n-\t\t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (c3,\n-\t\t\t\t\t       GOMP_MAP_FIRSTPRIVATE_POINTER);\n-\t\t      OMP_CLAUSE_DECL (c3) = decl;\n-\t\t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n-\t\t      tree mapgrp = *prev_list_p;\n-\t\t      *prev_list_p = c2;\n-\t\t      OMP_CLAUSE_CHAIN (c3) = mapgrp;\n-\t\t      OMP_CLAUSE_CHAIN (c2) = c3;\n-\n-\t\t      struct_deref_set->add (decl);\n-\t\t    }\n-\t\t  goto do_add_decl;\n-\t\t}\n \t      /* An \"attach/detach\" operation on an update directive should\n \t\t behave as a GOMP_MAP_ALWAYS_POINTER.  Beware that\n \t\t unlike attach or detach map kinds, GOMP_MAP_ALWAYS_POINTER\n \t\t depends on the previous mapping.  */\n \t      if (code == OACC_UPDATE\n \t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\tOMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALWAYS_POINTER);\n-\t      if ((DECL_P (decl)\n-\t\t   || (component_ref_p\n-\t\t       && (INDIRECT_REF_P (decl)\n-\t\t\t   || TREE_CODE (decl) == MEM_REF\n-\t\t\t   || TREE_CODE (decl) == ARRAY_REF)))\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n-\t\t  && code != OACC_UPDATE\n-\t\t  && code != OMP_TARGET_UPDATE)\n-\t\t{\n-\t\t  if (error_operand_p (decl))\n-\t\t    {\n-\t\t      remove = true;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  tree stype = TREE_TYPE (decl);\n-\t\t  if (TREE_CODE (stype) == REFERENCE_TYPE)\n-\t\t    stype = TREE_TYPE (stype);\n-\t\t  if (TYPE_SIZE_UNIT (stype) == NULL\n-\t\t      || TREE_CODE (TYPE_SIZE_UNIT (stype)) != INTEGER_CST)\n-\t\t    {\n-\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\"mapping field %qE of variable length \"\n-\t\t\t\t\"structure\", OMP_CLAUSE_DECL (c));\n-\t\t      remove = true;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER\n-\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n-\t\t    {\n-\t\t      /* Error recovery.  */\n-\t\t      if (prev_list_p == NULL)\n-\t\t\t{\n-\t\t\t  remove = true;\n-\t\t\t  break;\n-\t\t\t}\n-\n-\t\t      /* The below prev_list_p based error recovery code is\n-\t\t\t currently no longer valid for OpenMP.  */\n-\t\t      if (code != OMP_TARGET\n-\t\t\t  && code != OMP_TARGET_DATA\n-\t\t\t  && code != OMP_TARGET_UPDATE\n-\t\t\t  && code != OMP_TARGET_ENTER_DATA\n-\t\t\t  && code != OMP_TARGET_EXIT_DATA\n-\t\t\t  && OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n-\t\t\t{\n-\t\t\t  tree ch = OMP_CLAUSE_CHAIN (*prev_list_p);\n-\t\t\t  if (ch == NULL_TREE || OMP_CLAUSE_CHAIN (ch) != c)\n-\t\t\t    {\n-\t\t\t      remove = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  poly_offset_int offset1;\n-\t\t  poly_int64 bitpos1;\n-\t\t  tree tree_offset1;\n-\t\t  tree base_ref;\n-\n-\t\t  tree base\n-\t\t    = extract_base_bit_offset (OMP_CLAUSE_DECL (c), &base_ref,\n-\t\t\t\t\t       &bitpos1, &offset1,\n-\t\t\t\t\t       &tree_offset1);\n-\n-\t\t  bool do_map_struct = (base == decl && !tree_offset1);\n-\n-\t\t  splay_tree_node n\n-\t\t    = (DECL_P (decl)\n-\t\t       ? splay_tree_lookup (ctx->variables,\n-\t\t\t\t\t    (splay_tree_key) decl)\n-\t\t       : NULL);\n-\t\t  bool ptr = (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t      == GOMP_MAP_ALWAYS_POINTER);\n-\t\t  bool attach_detach = (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t\t\t== GOMP_MAP_ATTACH_DETACH);\n-\t\t  bool attach = OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n-\t\t\t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH;\n-\t\t  bool has_attachments = false;\n-\t\t  /* For OpenACC, pointers in structs should trigger an\n-\t\t     attach action.  */\n-\t\t  if (attach_detach\n-\t\t      && ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA))\n-\t\t\t  || code == OMP_TARGET_ENTER_DATA\n-\t\t\t  || code == OMP_TARGET_EXIT_DATA))\n \n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n+\t\t      == ARRAY_TYPE)\n+\t\t    remove = true;\n+\t\t  else\n \t\t    {\n-\t\t      /* Turn a GOMP_MAP_ATTACH_DETACH clause into a\n-\t\t\t GOMP_MAP_ATTACH or GOMP_MAP_DETACH clause after we\n-\t\t\t have detected a case that needs a GOMP_MAP_STRUCT\n-\t\t\t mapping added.  */\n-\t\t      gomp_map_kind k\n-\t\t\t= ((code == OACC_EXIT_DATA || code == OMP_TARGET_EXIT_DATA)\n-\t\t\t   ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n+\t\t      gomp_map_kind k = ((code == OACC_EXIT_DATA\n+\t\t\t\t\t  || code == OMP_TARGET_EXIT_DATA)\n+\t\t\t\t\t ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (c, k);\n-\t\t      has_attachments = true;\n \t\t    }\n+\t\t}\n \n-\t\t  /* We currently don't handle non-constant offset accesses wrt to\n-\t\t     GOMP_MAP_STRUCT elements.  */\n-\t\t  if (!do_map_struct)\n-\t\t    goto skip_map_struct;\n-\n-\t\t  /* Nor for attach_detach for OpenMP.  */\n-\t\t  if ((code == OMP_TARGET\n-\t\t       || code == OMP_TARGET_DATA\n-\t\t       || code == OMP_TARGET_UPDATE\n-\t\t       || code == OMP_TARGET_ENTER_DATA\n-\t\t       || code == OMP_TARGET_EXIT_DATA)\n-\t\t      && attach_detach)\n-\t\t    {\n-\t\t      if (DECL_P (decl))\n-\t\t\t{\n-\t\t\t  if (struct_seen_clause == NULL)\n-\t\t\t    struct_seen_clause\n-\t\t\t      = new hash_map<tree_operand_hash, tree *>;\n-\t\t\t  if (!struct_seen_clause->get (decl))\n-\t\t\t    struct_seen_clause->put (decl, list_p);\n-\t\t\t}\n+\t      tree cref = decl;\n \n-\t\t      goto skip_map_struct;\n-\t\t    }\n+\t      while (TREE_CODE (cref) == ARRAY_REF)\n+\t\tcref = TREE_OPERAND (cref, 0);\n \n-\t\t  if ((DECL_P (decl)\n-\t\t       && (n == NULL || (n->value & GOVD_MAP) == 0))\n-\t\t      || (!DECL_P (decl)\n-\t\t\t  && (!struct_map_to_clause\n-\t\t\t      || struct_map_to_clause->get (decl) == NULL)))\n-\t\t    {\n-\t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t OMP_CLAUSE_MAP);\n-\t\t      gomp_map_kind k = attach ? GOMP_MAP_FORCE_PRESENT\n-\t\t\t\t\t       : GOMP_MAP_STRUCT;\n-\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (l, k);\n-\t\t      if (base_ref)\n-\t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (base_ref);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  OMP_CLAUSE_DECL (l) = unshare_expr (decl);\n-\t\t\t  if (!DECL_P (OMP_CLAUSE_DECL (l))\n-\t\t\t      && (gimplify_expr (&OMP_CLAUSE_DECL (l),\n-\t\t\t\t\t\t pre_p, NULL, is_gimple_lvalue,\n-\t\t\t\t\t\t fb_lvalue)\n-\t\t\t\t  == GS_ERROR))\n-\t\t\t    {\n-\t\t\t      remove = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      OMP_CLAUSE_SIZE (l)\n-\t\t\t= (!attach\n-\t\t\t   ? size_int (1)\n-\t\t\t   : DECL_P (OMP_CLAUSE_DECL (l))\n-\t\t\t   ? DECL_SIZE_UNIT (OMP_CLAUSE_DECL (l))\n-\t\t\t   : TYPE_SIZE_UNIT (TREE_TYPE (OMP_CLAUSE_DECL (l))));\n-\t\t      if (struct_map_to_clause == NULL)\n-\t\t\tstruct_map_to_clause\n-\t\t\t  = new hash_map<tree_operand_hash, tree>;\n-\t\t      struct_map_to_clause->put (decl, l);\n-\t\t      if (ptr || attach_detach)\n-\t\t\t{\n-\t\t\t  tree **sc = (struct_seen_clause\n-\t\t\t\t       ? struct_seen_clause->get (decl)\n-\t\t\t\t       : NULL);\n-\t\t\t  tree *insert_node_pos = sc ? *sc : prev_list_p;\n-\n-\t\t\t  insert_struct_comp_map (code, c, l, *insert_node_pos,\n-\t\t\t\t\t\t  NULL);\n-\t\t\t  *insert_node_pos = l;\n-\t\t\t  prev_list_p = NULL;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  OMP_CLAUSE_CHAIN (l) = c;\n-\t\t\t  *list_p = l;\n-\t\t\t  list_p = &OMP_CLAUSE_CHAIN (l);\n-\t\t\t}\n-\t\t      if (base_ref && code == OMP_TARGET)\n-\t\t\t{\n-\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n-\t\t\t  enum gomp_map_kind mkind\n-\t\t\t    = GOMP_MAP_FIRSTPRIVATE_REFERENCE;\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n-\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n-\t\t\t  OMP_CLAUSE_SIZE (c2) = size_zero_node;\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (l);\n-\t\t\t  OMP_CLAUSE_CHAIN (l) = c2;\n-\t\t\t}\n-\t\t      flags = GOVD_MAP | GOVD_EXPLICIT;\n-\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n-\t\t\t  || ptr\n-\t\t\t  || attach_detach)\n-\t\t\tflags |= GOVD_SEEN;\n-\t\t      if (has_attachments)\n-\t\t\tflags |= GOVD_MAP_HAS_ATTACHMENTS;\n-\n-\t\t      /* If this is a *pointer-to-struct expression, make sure a\n-\t\t\t firstprivate map of the base-pointer exists.  */\n-\t\t      if (component_ref_p\n-\t\t\t  && ((TREE_CODE (decl) == MEM_REF\n-\t\t\t       && integer_zerop (TREE_OPERAND (decl, 1)))\n-\t\t\t      || INDIRECT_REF_P (decl))\n-\t\t\t  && DECL_P (TREE_OPERAND (decl, 0))\n-\t\t\t  && !splay_tree_lookup (ctx->variables,\n-\t\t\t\t\t\t ((splay_tree_key)\n-\t\t\t\t\t\t  TREE_OPERAND (decl, 0))))\n-\t\t\t{\n-\t\t\t  decl = TREE_OPERAND (decl, 0);\n-\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n-\t\t\t  enum gomp_map_kind mkind\n-\t\t\t    = GOMP_MAP_FIRSTPRIVATE_POINTER;\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n-\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n-\t\t\t  OMP_CLAUSE_SIZE (c2) = size_zero_node;\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n-\t\t\t  OMP_CLAUSE_CHAIN (c) = c2;\n-\t\t\t}\n+\t      if (TREE_CODE (cref) == INDIRECT_REF)\n+\t\tcref = TREE_OPERAND (cref, 0);\n \n-\t\t      if (DECL_P (decl))\n-\t\t\tgoto do_add_decl;\n-\t\t    }\n-\t\t  else if (struct_map_to_clause)\n+\t      if (TREE_CODE (cref) == COMPONENT_REF)\n+\t\t{\n+\t\t  tree base = cref;\n+\t\t  while (base && !DECL_P (base))\n \t\t    {\n-\t\t      tree *osc = struct_map_to_clause->get (decl);\n-\t\t      tree *sc = NULL, *scp = NULL;\n-\t\t      if (n != NULL\n-\t\t\t  && (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n-\t\t\t      || ptr\n-\t\t\t      || attach_detach))\n-\t\t\tn->value |= GOVD_SEEN;\n-\t\t      sc = &OMP_CLAUSE_CHAIN (*osc);\n-\t\t      if (*sc != c\n-\t\t\t  && (OMP_CLAUSE_MAP_KIND (*sc)\n-\t\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n-\t\t\tsc = &OMP_CLAUSE_CHAIN (*sc);\n-\t\t      /* Here \"prev_list_p\" is the end of the inserted\n-\t\t\t alloc/release nodes after the struct node, OSC.  */\n-\t\t      for (; *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))\n-\t\t\tif ((ptr || attach_detach) && sc == prev_list_p)\n-\t\t\t  break;\n-\t\t\telse if (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n-\t\t\t\t != COMPONENT_REF\n-\t\t\t\t && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n-\t\t\t\t     != INDIRECT_REF)\n-\t\t\t\t && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n-\t\t\t\t     != ARRAY_REF))\n-\t\t\t  break;\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    tree sc_decl = OMP_CLAUSE_DECL (*sc);\n-\t\t\t    poly_offset_int offsetn;\n-\t\t\t    poly_int64 bitposn;\n-\t\t\t    tree tree_offsetn;\n-\t\t\t    tree base\n-\t\t\t      = extract_base_bit_offset (sc_decl, NULL,\n-\t\t\t\t\t\t\t &bitposn, &offsetn,\n-\t\t\t\t\t\t\t &tree_offsetn);\n-\t\t\t    if (base != decl)\n-\t\t\t      break;\n-\t\t\t    if (scp)\n-\t\t\t      continue;\n-\t\t\t    if ((region_type & ORT_ACC) != 0)\n-\t\t\t      {\n-\t\t\t\t/* This duplicate checking code is currently only\n-\t\t\t\t   enabled for OpenACC.  */\n-\t\t\t\ttree d1 = OMP_CLAUSE_DECL (*sc);\n-\t\t\t\ttree d2 = OMP_CLAUSE_DECL (c);\n-\t\t\t\twhile (TREE_CODE (d1) == ARRAY_REF)\n-\t\t\t\t  d1 = TREE_OPERAND (d1, 0);\n-\t\t\t\twhile (TREE_CODE (d2) == ARRAY_REF)\n-\t\t\t\t  d2 = TREE_OPERAND (d2, 0);\n-\t\t\t\tif (TREE_CODE (d1) == INDIRECT_REF)\n-\t\t\t\t  d1 = TREE_OPERAND (d1, 0);\n-\t\t\t\tif (TREE_CODE (d2) == INDIRECT_REF)\n-\t\t\t\t  d2 = TREE_OPERAND (d2, 0);\n-\t\t\t\twhile (TREE_CODE (d1) == COMPONENT_REF)\n-\t\t\t\t  if (TREE_CODE (d2) == COMPONENT_REF\n-\t\t\t\t      && TREE_OPERAND (d1, 1)\n-\t\t\t\t      == TREE_OPERAND (d2, 1))\n-\t\t\t\t    {\n-\t\t\t\t      d1 = TREE_OPERAND (d1, 0);\n-\t\t\t\t      d2 = TREE_OPERAND (d2, 0);\n-\t\t\t\t    }\n-\t\t\t\t  else\n-\t\t\t\t    break;\n-\t\t\t\tif (d1 == d2)\n-\t\t\t\t  {\n-\t\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t      \"%qE appears more than once in map \"\n-\t\t\t\t\t      \"clauses\", OMP_CLAUSE_DECL (c));\n-\t\t\t\t    remove = true;\n-\t\t\t\t    break;\n-\t\t\t\t  }\n-\t\t\t      }\n-\t\t\t    if (maybe_lt (offset1, offsetn)\n-\t\t\t\t|| (known_eq (offset1, offsetn)\n-\t\t\t\t    && maybe_lt (bitpos1, bitposn)))\n-\t\t\t      {\n-\t\t\t\tif (ptr || attach_detach)\n-\t\t\t\t  scp = sc;\n-\t\t\t\telse\n-\t\t\t\t  break;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t      if (remove)\n+\t\t      tree innerbase = omp_get_base_pointer (base);\n+\t\t      if (!innerbase)\n \t\t\tbreak;\n-\t\t      if (!attach)\n-\t\t\tOMP_CLAUSE_SIZE (*osc)\n-\t\t\t  = size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n-\t\t\t\t\tsize_one_node);\n-\t\t      if (ptr || attach_detach)\n-\t\t\t{\n-\t\t\t  tree cl = insert_struct_comp_map (code, c, NULL,\n-\t\t\t\t\t\t\t    *prev_list_p, scp);\n-\t\t\t  if (sc == prev_list_p)\n-\t\t\t    {\n-\t\t\t      *sc = cl;\n-\t\t\t      prev_list_p = NULL;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      *prev_list_p = OMP_CLAUSE_CHAIN (c);\n-\t\t\t      list_p = prev_list_p;\n-\t\t\t      prev_list_p = NULL;\n-\t\t\t      OMP_CLAUSE_CHAIN (c) = *sc;\n-\t\t\t      *sc = cl;\n-\t\t\t      continue;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else if (*sc != c)\n-\t\t\t{\n-\t\t\t  if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue,\n-\t\t\t\t\t     fb_lvalue)\n-\t\t\t      == GS_ERROR)\n-\t\t\t    {\n-\t\t\t      remove = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t  *list_p = OMP_CLAUSE_CHAIN (c);\n-\t\t\t  OMP_CLAUSE_CHAIN (c) = *sc;\n-\t\t\t  *sc = c;\n-\t\t\t  continue;\n-\t\t\t}\n+\t\t      base = innerbase;\n+\t\t    }\n+\t\t  if (base\n+\t\t      && DECL_P (base)\n+\t\t      && GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (base)))\n+\t\t    {\n+\t\t      splay_tree_node n\n+\t\t\t= splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t     (splay_tree_key) base);\n+\t\t      n->value |= GOVD_SEEN;\n \t\t    }\n-\t\tskip_map_struct:\n-\t\t  ;\n-\t\t}\n-\t      else if ((code == OACC_ENTER_DATA\n-\t\t\t|| code == OACC_EXIT_DATA\n-\t\t\t|| code == OACC_DATA\n-\t\t\t|| code == OACC_PARALLEL\n-\t\t\t|| code == OACC_KERNELS\n-\t\t\t|| code == OACC_SERIAL\n-\t\t\t|| code == OMP_TARGET_ENTER_DATA\n-\t\t\t|| code == OMP_TARGET_EXIT_DATA)\n-\t\t       && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n-\t\t{\n-\t\t  gomp_map_kind k = ((code == OACC_EXIT_DATA\n-\t\t\t\t      || code == OMP_TARGET_EXIT_DATA)\n-\t\t\t\t     ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (c, k);\n \t\t}\n \n \t      if (code == OMP_TARGET && OMP_CLAUSE_MAP_IN_REDUCTION (c))\n@@ -10857,24 +11163,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  break;\n \t\t}\n \n-\t      /* If this was of the form map(*pointer_to_struct), then the\n-\t\t 'pointer_to_struct' DECL should be considered deref'ed.  */\n-\t      if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALLOC\n-\t\t   || GOMP_MAP_COPY_TO_P (OMP_CLAUSE_MAP_KIND (c))\n-\t\t   || GOMP_MAP_COPY_FROM_P (OMP_CLAUSE_MAP_KIND (c)))\n-\t\t  && INDIRECT_REF_P (orig_decl)\n-\t\t  && DECL_P (TREE_OPERAND (orig_decl, 0))\n-\t\t  && TREE_CODE (TREE_TYPE (orig_decl)) == RECORD_TYPE)\n-\t\t{\n-\t\t  tree ptr = TREE_OPERAND (orig_decl, 0);\n-\t\t  if (!struct_deref_set || !struct_deref_set->contains (ptr))\n-\t\t    {\n-\t\t      if (!struct_deref_set)\n-\t\t\tstruct_deref_set = new hash_set<tree> ();\n-\t\t      struct_deref_set->add (ptr);\n-\t\t    }\n-\t\t}\n-\n \t      if (!remove\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_POINTER\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH_DETACH\n@@ -10891,28 +11179,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \t      break;\n \t    }\n-\t  else\n-\t    {\n-\t      /* DECL_P (decl) == true  */\n-\t      tree *sc;\n-\t      if (struct_map_to_clause\n-\t\t  && (sc = struct_map_to_clause->get (decl)) != NULL\n-\t\t  && OMP_CLAUSE_MAP_KIND (*sc) == GOMP_MAP_STRUCT\n-\t\t  && decl == OMP_CLAUSE_DECL (*sc))\n-\t\t{\n-\t\t  /* We have found a map of the whole structure after a\n-\t\t     leading GOMP_MAP_STRUCT has been created, so refill the\n-\t\t     leading clause into a map of the whole structure\n-\t\t     variable, and remove the current one.\n-\t\t     TODO: we should be able to remove some maps of the\n-\t\t     following structure element maps if they are of\n-\t\t     compatible TO/FROM/ALLOC type.  */\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (*sc, OMP_CLAUSE_MAP_KIND (c));\n-\t\t  OMP_CLAUSE_SIZE (*sc) = unshare_expr (OMP_CLAUSE_SIZE (c));\n-\t\t  remove = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n \t  flags = GOVD_MAP | GOVD_EXPLICIT;\n \t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TO\n \t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TOFROM)\n@@ -11582,12 +11848,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n   ctx->clauses = *orig_list_p;\n   gimplify_omp_ctxp = ctx;\n-  if (struct_seen_clause)\n-    delete struct_seen_clause;\n-  if (struct_map_to_clause)\n-    delete struct_map_to_clause;\n-  if (struct_deref_set)\n-    delete struct_deref_set;\n }\n \n /* Return true if DECL is a candidate for shared to firstprivate\n@@ -11736,8 +11996,6 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     return 0;\n   if ((flags & GOVD_SEEN) == 0)\n     return 0;\n-  if ((flags & GOVD_MAP_HAS_ATTACHMENTS) != 0)\n-    return 0;\n   if (flags & GOVD_DEBUG_PRIVATE)\n     {\n       gcc_assert ((flags & GOVD_DATA_SHARE_CLASS) == GOVD_SHARED);"}, {"sha": "f0469d20b3dbbc63e7248f3882f5c794b8367deb", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -1636,8 +1636,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      if (TREE_CODE (decl) == COMPONENT_REF\n \t\t  || (TREE_CODE (decl) == INDIRECT_REF\n \t\t      && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n-\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n-\t\t\t  == REFERENCE_TYPE)))\n+\t\t      && (((TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t    == REFERENCE_TYPE)\n+\t\t\t   || (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t       == POINTER_TYPE)))))\n \t\tbreak;\n \t      if (DECL_SIZE (decl)\n \t\t  && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n@@ -14015,6 +14017,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tif (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n \t\t  is_ref = false;\n \t\tbool ref_to_array = false;\n+\t\tbool ref_to_ptr = false;\n \t\tif (is_ref)\n \t\t  {\n \t\t    type = TREE_TYPE (type);\n@@ -14033,6 +14036,12 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    new_var = decl2;\n \t\t    type = TREE_TYPE (new_var);\n \t\t  }\n+\t\telse if (TREE_CODE (type) == REFERENCE_TYPE\n+\t\t\t && TREE_CODE (TREE_TYPE (type)) == POINTER_TYPE)\n+\t\t  {\n+\t\t    type = TREE_TYPE (type);\n+\t\t    ref_to_ptr = true;\n+\t\t  }\n \t\tx = build_receiver_ref (OMP_CLAUSE_DECL (prev), false, ctx);\n \t\tx = fold_convert_loc (clause_loc, type, x);\n \t\tif (!integer_zerop (OMP_CLAUSE_SIZE (c)))\n@@ -14049,7 +14058,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tif (ref_to_array)\n \t\t  x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n \t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n-\t\tif (is_ref && !ref_to_array)\n+\t\tif ((is_ref && !ref_to_array)\n+\t\t    || ref_to_ptr)\n \t\t  {\n \t\t    tree t = create_tmp_var_raw (type, get_name (var));\n \t\t    gimple_add_tmp_var (t);"}, {"sha": "a30a25e0893633f5b2e05f3af72a4ea17199592e", "filename": "gcc/testsuite/c-c++-common/gomp/target-50.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-50.c?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+typedef struct\n+{\n+  int *arr;\n+} L;\n+\n+int main()\n+{\n+  L *tmp;\n+\n+  /* There shouldn't be an order dependency here...  */\n+\n+  #pragma omp target map(to: tmp->arr) map(tofrom: tmp->arr[0:10])\n+  { }\n+\n+  #pragma omp target map(tofrom: tmp->arr[0:10]) map(to: tmp->arr)\n+  { }\n+/* { dg-final { scan-tree-dump-times {map\\(struct:\\*tmp \\[len: 1\\]\\) map\\(alloc:tmp[._0-9]*->arr \\[len: [0-9]+\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(attach:tmp[._0-9]*->arr \\[bias: 0\\]\\)} 2 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+\n+  return 0;\n+}"}, {"sha": "9993768ef20b140a3e034d43874d3b09edd86b0f", "filename": "gcc/testsuite/g++.dg/goacc/member-array-acc.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmember-array-acc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmember-array-acc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmember-array-acc.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+struct Foo {\n+  float *a;\n+  void init(int N) {\n+    a = new float[N];\n+    #pragma acc enter data create(a[0:N])\n+  }\n+};\n+int main() { Foo x; x.init(1024); }\n+\n+/* { dg-final { scan-tree-dump {struct:\\*\\(struct Foo \\*\\) this \\[len: 1\\]\\) map\\(alloc:this->a \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: _[0-9]+\\]\\) map\\(attach:this->a \\[bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "a53aa44592dd51a32d0aed74aeb30a68367ec002", "filename": "gcc/testsuite/g++.dg/gomp/member-array-omp.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-array-omp.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-array-omp.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-array-omp.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+struct Foo {\n+  float *a;\n+  void init(int N) {\n+    a = new float[N];\n+    #pragma omp target enter data map(alloc:a[0:N])\n+  }\n+};\n+int main() { Foo x; x.init(1024); }\n+\n+/* { dg-final { scan-tree-dump {map\\(alloc:\\*_[0-9]+ \\[len: _[0-9]+\\]\\) map\\(attach:this->a \\[bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "432f02614d82ad04777ad43f7bd0eb76dc627014", "filename": "gcc/testsuite/g++.dg/gomp/target-3.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -33,4 +33,6 @@ T<N>::bar (int x)\n \n template struct T<0>;\n \n-/* { dg-final { scan-tree-dump-times \"map\\\\(struct:\\\\*this \\\\\\[len: 2\\\\\\]\\\\) map\\\\(alloc:this->a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:this->b \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" 4 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"map\\\\(struct:\\\\*\\\\(struct S \\\\*\\\\) this \\\\\\[len: 2\\\\\\]\\\\) map\\\\(alloc:this->a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:this->b \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" 2 \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"map\\\\(struct:\\\\*\\\\(struct T \\\\*\\\\) this \\\\\\[len: 2\\\\\\]\\\\) map\\\\(alloc:this->a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:this->b \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" 2 \"gimple\" } } */"}, {"sha": "bff7fa7c669241048682cf026f9fdf029a9eec57", "filename": "gcc/testsuite/g++.dg/gomp/target-lambda-1.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -87,8 +87,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) \n-} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\)} \"gimple\" } } */\n \n /* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:loop\\.__data1 \\[bias: 0\\]\\)} \"gimple\" } } */\n "}, {"sha": "cc08e7e8693490f61e60a1b83a1a3e3ac7f31ea5", "filename": "gcc/testsuite/g++.dg/gomp/target-this-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -46,4 +46,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(m\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:v \\[len: [0-9]+\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {map\\(alloc:MEM\\[\\(char \\*\\)_[0-9]+\\] \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(m\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:v \\[len: [0-9]+\\]\\)} \"gimple\" } } */"}, {"sha": "dacbb520f3d892e7e6c0cc94ae7d8693e856be42", "filename": "libgomp/testsuite/libgomp.oacc-c++/deep-copy-17.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fdeep-copy-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fdeep-copy-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fdeep-copy-17.C?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,101 @@\n+#include <cassert>\n+\n+/* Test attach/detach operation with pointers and references to structs.  */\n+\n+typedef struct mystruct {\n+  int *a;\n+  int b;\n+  int *c;\n+  int d;\n+  int *e;\n+} mystruct;\n+\n+void str (void)\n+{\n+  int a[10], c[10], e[10];\n+  mystruct m = { .a = a, .c = c, .e = e };\n+  a[0] = 5;\n+  c[0] = 7;\n+  e[0] = 9;\n+  #pragma acc parallel copy(m.a[0:10], m.b, m.c[0:10], m.d, m.e[0:10])\n+  {\n+    m.a[0] = m.c[0] + m.e[0];\n+  }\n+  assert (m.a[0] == 7 + 9);\n+}\n+\n+void strp (void)\n+{\n+  int *a = new int[10];\n+  int *c = new int[10];\n+  int *e = new int[10];\n+  mystruct *m = new mystruct;\n+  m->a = a;\n+  m->c = c;\n+  m->e = e;\n+  a[0] = 6;\n+  c[0] = 8;\n+  e[0] = 10;\n+  #pragma acc parallel copy(m->a[0:10], m->b, m->c[0:10], m->d, m->e[0:10])\n+  {\n+    m->a[0] = m->c[0] + m->e[0];\n+  }\n+  assert (m->a[0] == 8 + 10);\n+  delete m;\n+  delete[] a;\n+  delete[] c;\n+  delete[] e;\n+}\n+\n+void strr (void)\n+{\n+  int *a = new int[10];\n+  int *c = new int[10];\n+  int *e = new int[10];\n+  mystruct m;\n+  mystruct &n = m;\n+  n.a = a;\n+  n.c = c;\n+  n.e = e;\n+  a[0] = 7;\n+  c[0] = 9;\n+  e[0] = 11;\n+  #pragma acc parallel copy(n.a[0:10], n.b, n.c[0:10], n.d, n.e[0:10])\n+  {\n+    n.a[0] = n.c[0] + n.e[0];\n+  }\n+  assert (n.a[0] == 9 + 11);\n+  delete[] a;\n+  delete[] c;\n+  delete[] e;\n+}\n+\n+void strrp (void)\n+{\n+  int a[10], c[10], e[10];\n+  mystruct *m = new mystruct;\n+  mystruct *&n = m;\n+  n->a = a;\n+  n->b = 3;\n+  n->c = c;\n+  n->d = 5;\n+  n->e = e;\n+  a[0] = 8;\n+  c[0] = 10;\n+  e[0] = 12;\n+  #pragma acc parallel copy(n->a[0:10], n->c[0:10], n->e[0:10])\n+  {\n+    n->a[0] = n->c[0] + n->e[0];\n+  }\n+  assert (n->a[0] == 10 + 12);\n+  delete m;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  str ();\n+  strp ();\n+  strr ();\n+  strrp ();\n+  return 0;\n+}"}, {"sha": "27fe1a9d07ddb2b3dd70c085dd4719573db7064f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deep-copy-15.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-15.c?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,68 @@\n+#include <stdlib.h>\n+\n+/* Test multiple struct dereferences on one directive, and slices starting at\n+   non-zero.  */\n+\n+typedef struct {\n+  int *a;\n+  int *b;\n+  int *c;\n+} mystruct;\n+\n+int main(int argc, char* argv[])\n+{\n+  const int N = 1024;\n+  mystruct *m = (mystruct *) malloc (sizeof (*m));\n+  int i;\n+\n+  m->a = (int *) malloc (N * sizeof (int));\n+  m->b = (int *) malloc (N * sizeof (int));\n+  m->c = (int *) malloc (N * sizeof (int));\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      m->a[i] = 0;\n+      m->b[i] = 0;\n+      m->c[i] = 0;\n+    }\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+      int j;\n+#pragma acc parallel loop copy(m->a[0:N])\n+      for (j = 0; j < N; j++)\n+\tm->a[j]++;\n+#pragma acc parallel loop copy(m->b[0:N], m->c[5:N-10])\n+      for (j = 0; j < N; j++)\n+\t{\n+\t  m->b[j]++;\n+\t  if (j > 5 && j < N - 5)\n+\t    m->c[j]++;\n+\t}\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (m->a[i] != 99)\n+\tabort ();\n+      if (m->b[i] != 99)\n+\tabort ();\n+      if (i > 5 && i < N-5)\n+\t{\n+\t  if (m->c[i] != 99)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  if (m->c[i] != 0)\n+\t    abort ();\n+\t}\n+    }\n+\n+  free (m->a);\n+  free (m->b);\n+  free (m->c);\n+  free (m);\n+\n+  return 0;\n+}"}, {"sha": "a7308e8c98b95cf7102d0da865796cf2fa2b2ff9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deep-copy-16.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-16.c?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -0,0 +1,231 @@\n+#include <stdlib.h>\n+\n+/* Test mapping chained indirect struct accesses, mixed in different ways.  */\n+\n+typedef struct {\n+  int *a;\n+  int b;\n+  int *c;\n+} str1;\n+\n+typedef struct {\n+  int d;\n+  int *e;\n+  str1 *f;\n+} str2;\n+\n+typedef struct {\n+  int g;\n+  int h;\n+  str2 *s2;\n+} str3;\n+\n+typedef struct {\n+  str3 m;\n+  str3 n;\n+} str4;\n+\n+void\n+zero_arrays (str4 *s, int N)\n+{\n+  for (int i = 0; i < N; i++)\n+    {\n+      s->m.s2->e[i] = 0;\n+      s->m.s2->f->a[i] = 0;\n+      s->m.s2->f->c[i] = 0;\n+      s->n.s2->e[i] = 0;\n+      s->n.s2->f->a[i] = 0;\n+      s->n.s2->f->c[i] = 0;\n+    }\n+}\n+\n+void\n+alloc_s2 (str2 **s, int N)\n+{\n+  (*s) = (str2 *) malloc (sizeof (str2));\n+  (*s)->f = (str1 *) malloc (sizeof (str1));\n+  (*s)->e = (int *) malloc (sizeof (int) * N);\n+  (*s)->f->a = (int *) malloc (sizeof (int) * N);\n+  (*s)->f->c = (int *) malloc (sizeof (int) * N);\n+}\n+\n+int main (int argc, char* argv[])\n+{\n+  const int N = 1024;\n+  str4 p, *q;\n+  int i;\n+\n+  alloc_s2 (&p.m.s2, N);\n+  alloc_s2 (&p.n.s2, N);\n+  q = (str4 *) malloc (sizeof (str4));\n+  alloc_s2 (&q->m.s2, N);\n+  alloc_s2 (&q->n.s2, N);\n+\n+  zero_arrays (&p, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(p.m.s2[:1])\n+#pragma acc parallel loop copy(p.m.s2->e[:N])\n+      for (int j = 0; j < N; j++)\n+\tp.m.s2->e[j]++;\n+#pragma acc exit data delete(p.m.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (p.m.s2->e[i] != 99)\n+      abort ();\n+\n+  zero_arrays (&p, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(p.m.s2[:1])\n+#pragma acc enter data copyin(p.m.s2->f[:1])\n+#pragma acc parallel loop copy(p.m.s2->f->a[:N]) copy(p.m.s2->f->c[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    p.m.s2->f->a[j]++;\n+\t    p.m.s2->f->c[j]++;\n+\t  }\n+#pragma acc exit data delete(p.m.s2->f[:1])\n+#pragma acc exit data delete(p.m.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (p.m.s2->f->a[i] != 99 || p.m.s2->f->c[i] != 99)\n+      abort ();\n+\n+  zero_arrays (&p, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(p.m.s2[:1]) copyin(p.n.s2[:1])\n+#pragma acc enter data copyin(p.m.s2->f[:1]) copyin(p.n.s2->f[:1])\n+#pragma acc parallel loop copy(p.m.s2->f->a[:N]) copy(p.m.s2->f->c[:N]) \\\n+\t\t\t  copy(p.n.s2->f->a[:N]) copy(p.n.s2->f->c[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    p.m.s2->f->a[j]++;\n+\t    p.m.s2->f->c[j]++;\n+\t    p.n.s2->f->a[j]++;\n+\t    p.n.s2->f->c[j]++;\n+\t  }\n+#pragma acc exit data delete(p.m.s2->f[:1]) delete(p.n.s2->f[:1])\n+#pragma acc exit data delete(p.m.s2[:1]) delete(p.n.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (p.m.s2->f->a[i] != 99 || p.m.s2->f->c[i] != 99\n+\t|| p.n.s2->f->a[i] != 99 || p.n.s2->f->c[i] != 99)\n+      abort ();\n+\n+  zero_arrays (&p, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(p.m.s2[:1]) copyin(p.n.s2[:1])\n+#pragma acc enter data copyin(p.n.s2->e[:N]) copyin(p.n.s2->f[:1]) \\\n+\t\t       copyin(p.m.s2->f[:1])\n+#pragma acc parallel loop copy(p.m.s2->f->a[:N]) copy(p.n.s2->f->a[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    p.m.s2->f->a[j]++;\n+\t    p.n.s2->f->a[j]++;\n+\t    p.n.s2->e[j]++;\n+\t  }\n+#pragma acc exit data delete(p.m.s2->f[:1]) delete(p.n.s2->f[:1]) \\\n+\t\t      copyout(p.n.s2->e[:N])\n+#pragma acc exit data delete(p.m.s2[:1]) delete(p.n.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (p.m.s2->f->a[i] != 99 || p.n.s2->f->a[i] != 99\n+\t|| p.n.s2->e[i] != 99)\n+      abort ();\n+\n+  zero_arrays (q, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(q->m.s2[:1])\n+#pragma acc parallel loop copy(q->m.s2->e[:N])\n+      for (int j = 0; j < N; j++)\n+\tq->m.s2->e[j]++;\n+#pragma acc exit data delete(q->m.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (q->m.s2->e[i] != 99)\n+      abort ();\n+\n+  zero_arrays (q, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(q->m.s2[:1])\n+#pragma acc enter data copyin(q->m.s2->f[:1])\n+#pragma acc parallel loop copy(q->m.s2->f->a[:N]) copy(q->m.s2->f->c[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    q->m.s2->f->a[j]++;\n+\t    q->m.s2->f->c[j]++;\n+\t  }\n+#pragma acc exit data delete(q->m.s2->f[:1])\n+#pragma acc exit data delete(q->m.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (q->m.s2->f->a[i] != 99 || q->m.s2->f->c[i] != 99)\n+      abort ();\n+\n+  zero_arrays (q, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(q->m.s2[:1]) copyin(q->n.s2[:1])\n+#pragma acc enter data copyin(q->m.s2->f[:1]) copyin(q->n.s2->f[:1])\n+#pragma acc parallel loop copy(q->m.s2->f->a[:N]) copy(q->m.s2->f->c[:N]) \\\n+\t\t\t  copy(q->n.s2->f->a[:N]) copy(q->n.s2->f->c[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    q->m.s2->f->a[j]++;\n+\t    q->m.s2->f->c[j]++;\n+\t    q->n.s2->f->a[j]++;\n+\t    q->n.s2->f->c[j]++;\n+\t  }\n+#pragma acc exit data delete(q->m.s2->f[:1]) delete(q->n.s2->f[:1])\n+#pragma acc exit data delete(q->m.s2[:1]) delete(q->n.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (q->m.s2->f->a[i] != 99 || q->m.s2->f->c[i] != 99\n+\t|| q->n.s2->f->a[i] != 99 || q->n.s2->f->c[i] != 99)\n+      abort ();\n+\n+  zero_arrays (q, N);\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+#pragma acc enter data copyin(q->m.s2[:1]) copyin(q->n.s2[:1])\n+#pragma acc enter data copyin(q->n.s2->e[:N]) copyin(q->m.s2->f[:1]) \\\n+\t\t       copyin(q->n.s2->f[:1])\n+#pragma acc parallel loop copy(q->m.s2->f->a[:N]) copy(q->n.s2->f->a[:N])\n+\tfor (int j = 0; j < N; j++)\n+\t  {\n+\t    q->m.s2->f->a[j]++;\n+\t    q->n.s2->f->a[j]++;\n+\t    q->n.s2->e[j]++;\n+\t  }\n+#pragma acc exit data delete(q->m.s2->f[:1]) delete(q->n.s2->f[:1]) \\\n+\t\t      copyout(q->n.s2->e[:N])\n+#pragma acc exit data delete(q->m.s2[:1]) delete(q->n.s2[:1])\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    if (q->m.s2->f->a[i] != 99 || q->n.s2->f->a[i] != 99\n+\t|| q->n.s2->e[i] != 99)\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "a11c64749cca678a88ca5b56c891c3de5100ba8d", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deep-copy-arrayofstruct.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-arrayofstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23baa717c991d77f206a9358ce2c04960ccf9eea/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-arrayofstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-arrayofstruct.c?ref=23baa717c991d77f206a9358ce2c04960ccf9eea", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile } */\n+/* { dg-do run } */\n \n #include <stdlib.h>\n #include <stdio.h>", "previous_filename": "gcc/testsuite/c-c++-common/goacc/deep-copy-arrayofstruct.c"}]}