{"sha": "a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxZDA2NGQ5NmFhMzNkZTJjYmM1ZWU2YmYxZjNmOWZjNzZlZjUyOA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-07-16T17:46:30Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-07-16T17:46:30Z"}, "message": "builtins.c (do_mpc_arg2): New.\n\n\t* builtins.c (do_mpc_arg2): New.\n\t(fold_builtin_2): Fold builtin cpow.\n\t* real.h (HAVE_mpc_pow): New.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-5.c: Add more cases.\n\t* gcc.dg/torture/builtin-math-6.c: Likewise.  Depend on\n\teffective target \"mpc_pow\".\n\t* lib/target-supports.exp (check_effective_target_mpc_pow): New.\n\nFrom-SVN: r149716", "tree": {"sha": "4349ce005fc992ee956833590b2672bb085de620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4349ce005fc992ee956833590b2672bb085de620"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/comments", "author": null, "committer": null, "parents": [{"sha": "d19cb53b51428dd2ec0913545ab3b1f4d404b397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19cb53b51428dd2ec0913545ab3b1f4d404b397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19cb53b51428dd2ec0913545ab3b1f4d404b397"}], "stats": {"total": 431, "additions": 351, "deletions": 80}, "files": [{"sha": "3e6a75f2a15bafdba5c50d201fb5d305afd6949c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -1,3 +1,9 @@\n+2009-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (do_mpc_arg2): New.\n+\t(fold_builtin_2): Fold builtin cpow.\n+\t* real.h (HAVE_mpc_pow): New.\n+\n 2009-07-16  Bingfeng Mei  <bmei@broadcom.com>\n \n \t* modulo-sched.c (sms_schedule): stage_count <= 1 as correct comparison"}, {"sha": "a94a37901a7c32c6fce6ae7ad65f3c20449d060d", "filename": "gcc/builtins.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -60,6 +60,9 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n #ifdef HAVE_mpc\n static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n+#ifdef HAVE_mpc_pow\n+static tree do_mpc_arg2 (tree, tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n+#endif\n #endif\n \n /* Define the names of the builtin function types and codes.  */\n@@ -10647,6 +10650,16 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_HYPOT):\n       return fold_builtin_hypot (fndecl, arg0, arg1, type);\n \n+#ifdef HAVE_mpc_pow\n+    CASE_FLT_FN (BUILT_IN_CPOW):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE\n+\t  && validate_arg (arg1, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE) \n+\treturn do_mpc_arg2 (arg0, arg1, type, mpc_pow);\n+    break;\n+#endif\n+\n     CASE_FLT_FN (BUILT_IN_LDEXP):\n       return fold_builtin_load_exponent (arg0, arg1, type, /*ldexp=*/true);\n     CASE_FLT_FN (BUILT_IN_SCALBN):\n@@ -13715,6 +13728,64 @@ do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n \n   return result;\n }\n+\n+/* If arguments ARG0 and ARG1 are a COMPLEX_CST, call the two-argument\n+   mpc function FUNC on it and return the resulting value as a tree\n+   with type TYPE.  The mpfr precision is set to the precision of\n+   TYPE.  We assume that function FUNC returns zero if the result\n+   could be calculated exactly within the requested precision.  */\n+\n+#ifdef HAVE_mpc_pow\n+static tree\n+do_mpc_arg2 (tree arg0, tree arg1, tree type,\n+\t     int (*func)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t))\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg0);\n+  STRIP_NOPS (arg1);\n+\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (TREE_CODE (arg0) == COMPLEX_CST && !TREE_OVERFLOW (arg0)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE\n+      && TREE_CODE (arg1) == COMPLEX_CST && !TREE_OVERFLOW (arg1)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE\n+      && REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0))))->b == 2)\n+    {\n+      const REAL_VALUE_TYPE *const re0 = TREE_REAL_CST_PTR (TREE_REALPART (arg0));\n+      const REAL_VALUE_TYPE *const im0 = TREE_REAL_CST_PTR (TREE_IMAGPART (arg0));\n+      const REAL_VALUE_TYPE *const re1 = TREE_REAL_CST_PTR (TREE_REALPART (arg1));\n+      const REAL_VALUE_TYPE *const im1 = TREE_REAL_CST_PTR (TREE_IMAGPART (arg1));\n+\n+      if (real_isfinite (re0) && real_isfinite (im0)\n+\t  && real_isfinite (re1) && real_isfinite (im1))\n+        {\n+\t  const struct real_format *const fmt =\n+\t    REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (type)));\n+\t  const int prec = fmt->p;\n+\t  const mp_rnd_t rnd = fmt->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+\t  const mpc_rnd_t crnd = fmt->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n+\t  int inexact;\n+\t  mpc_t m0, m1;\n+\t  \n+\t  mpc_init2 (m0, prec);\n+\t  mpc_init2 (m1, prec);\n+\t  mpfr_from_real (mpc_realref(m0), re0, rnd);\n+\t  mpfr_from_real (mpc_imagref(m0), im0, rnd);\n+\t  mpfr_from_real (mpc_realref(m1), re1, rnd);\n+\t  mpfr_from_real (mpc_imagref(m1), im1, rnd);\n+\t  mpfr_clear_flags ();\n+\t  inexact = func (m0, m0, m1, crnd);\n+\t  result = do_mpc_ckconv (m0, type, inexact);\n+\t  mpc_clear (m0);\n+\t  mpc_clear (m1);\n+\t}\n+    }\n+\n+  return result;\n+}\n+# endif\n #endif /* HAVE_mpc */\n \n /* FIXME tuples."}, {"sha": "884a663c83f74021d510c357aff9dd9c352d26aa", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -26,6 +26,9 @@\n #include <mpfr.h>\n #ifdef HAVE_mpc\n #include <mpc.h>\n+# if MPC_VERSION >= MPC_VERSION_NUM(0,6,1)\n+#  define HAVE_mpc_pow\n+# endif\n #endif\n #endif\n #include \"machmode.h\""}, {"sha": "989f5772fab0064b06654960d2a88afe710201eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -1,3 +1,10 @@\n+2009-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-5.c: Add more cases.\n+\t* gcc.dg/torture/builtin-math-6.c: Likewise.  Depend on\n+\teffective target \"mpc_pow\".\n+\t* lib/target-supports.exp (check_effective_target_mpc_pow): New.\n+\n 2009-07-16  Richard Henderson  <rth@redhat.com>\n \n \t* g++.dg/opt/eh4.C: New test."}, {"sha": "259164107d879c2340cd2258bda8713258039659", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-5.c", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -18,6 +18,12 @@ extern void fool (_Complex long double);\n   fool (__builtin_##FUNC##l (ARG##L)); \\\n } while (0)\n \n+#define TESTIT2(FUNC, ARG0, ARG1) do { \\\n+  foof (__builtin_##FUNC##f (ARG0##F, ARG1##F)); \\\n+  foo (__builtin_##FUNC (ARG0, ARG1)); \\\n+  fool (__builtin_##FUNC##l (ARG0##L, ARG1##L)); \\\n+} while (0)\n+\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n@@ -38,9 +44,80 @@ void bar()\n #endif\n   foo (__builtin_csqrt (-__builtin_inf()));\n   fool (__builtin_csqrtl (-__builtin_infl()));\n+\n+  /* Check for overflow/underflow.  */\n+  TESTIT (cexp, 1e20);\n+  TESTIT (cexp, -1e20);\n+  \n+  /* An argument of NaN is not evaluated at compile-time.  */\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (__builtin_nanf(\"\"), 2.5F));\n+#endif\n+  foo (__builtin_cpow (__builtin_nan(\"\"), 2.5));\n+  fool (__builtin_cpowl (__builtin_nanl(\"\"), 2.5L));\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (2.5F, __builtin_nanf(\"\")));\n+#endif\n+  foo (__builtin_cpow (2.5, __builtin_nan(\"\")));\n+  fool (__builtin_cpowl (2.5L, __builtin_nanl(\"\")));\n+\n+  /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (__builtin_inff(), 2.5F));\n+#endif\n+  foo (__builtin_cpow (__builtin_inf(), 2.5));\n+  fool (__builtin_cpowl (__builtin_infl(), 2.5L));\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (-__builtin_inff(), 2.5F));\n+#endif\n+  foo (__builtin_cpow (-__builtin_inf(), 2.5));\n+  fool (__builtin_cpowl (-__builtin_infl(), 2.5L));\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (2.5F, __builtin_inff()));\n+#endif\n+  foo (__builtin_cpow (2.5, __builtin_inf()));\n+  fool (__builtin_cpowl (2.5L, __builtin_infl()));\n+#ifndef __SPU__\n+  foof (__builtin_cpowf (2.5F, -__builtin_inff()));\n+#endif\n+  foo (__builtin_cpow (2.5, -__builtin_inf()));\n+  fool (__builtin_cpowl (2.5L, -__builtin_infl()));\n+\n+  /* Check for Inv/NaN return values.  */\n+  TESTIT2 (cpow, -0.0, -4.5); /* Returns Inf */\n+  TESTIT2 (cpow, 0.0, -4.5); /* Returns Inf */\n+\n+  /* Check for overflow/underflow.  */\n+  foof (__builtin_cpowf (__FLT_MAX__, 3.5F));\n+  foof (__builtin_cpowf (__FLT_MAX__ * 1.FI, 3.5F));\n+  foo (__builtin_cpow (__DBL_MAX__, 3.5));\n+  foo (__builtin_cpow (__DBL_MAX__ * 1.I, 3.5));\n+  fool (__builtin_cpowl (__LDBL_MAX__, 3.5L));\n+  fool (__builtin_cpowl (__LDBL_MAX__ * 1.LI, 3.5L));\n+  TESTIT2 (cpow, 2.0, 0x1p50);\n+  TESTIT2 (cpow, 2.0, 0x1p28);\n+  TESTIT2 (cpow, 2.0, 0x1p24);\n+  foof (__builtin_cpowf (__FLT_MAX__, -3.5F));\n+  foof (__builtin_cpowf (__FLT_MAX__ * 1.FI, -3.5F));\n+  foo (__builtin_cpow (__DBL_MAX__, -3.5));\n+  foo (__builtin_cpow (__DBL_MAX__ * 1.I, -3.5));\n+  fool (__builtin_cpowl (__LDBL_MAX__, -3.5L));\n+  fool (__builtin_cpowl (__LDBL_MAX__ * 1.LI, -3.5L));\n+  TESTIT2 (cpow, 2.0, -0x1p50);\n+  TESTIT2 (cpow, 2.0, -0x1p28);\n+  TESTIT2 (cpow, 2.0, -0x1p24);\n+\n }\n \n-/* { dg-final { scan-tree-dump-times \"csqrtf\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"csqrtf\" 3 \"original\" { target { ! { spu*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump-times \"csqrtf\" 0 \"original\" { target { spu*-*-* } } } } */\n /* { dg-final { scan-tree-dump-times \"csqrt \" 3 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"csqrtl\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"cexpf\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"cexp \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"cexpl\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"cpowf\" 18 \"original\" { target { ! { spu*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump-times \"cpowf\" 12 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"cpow \" 18 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"cpowl\" 18 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "2c9b02b63d17363c8faa787bc54a3f94f52274e4", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-6.c", "status": "modified", "additions": 173, "deletions": 79, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -6,11 +6,13 @@\n    Origin: Kaveh R. Ghazi,  January 28, 2009.  */\n \n /* { dg-do link } */\n-/* { dg-require-effective-target mpc } */\n+/* { dg-require-effective-target mpc_pow } */\n \n /* All references to link_error should go away at compile-time.  */\n extern void link_error(int);\n \n+#define CONJ(X) __builtin_conjf(X)\n+\n /* Return TRUE if the signs of floating point values X and Y are not\n    equal.  This is important when comparing signed zeros.  */\n #define CKSGN_F(X,Y) \\\n@@ -42,6 +44,59 @@ extern void link_error(int);\n       link_error(__LINE__); \\\n   } while (0)\n \n+/* For complex numbers, call the TESTIT_COMPLEX macro for all\n+   combinations of neg and conj.  */\n+#define TESTIT_COMPLEX_ALLNEG(FUNC, ARG, RES1, RES2, RES3, RES4) do { \\\n+  TESTIT_COMPLEX(FUNC, (_Complex float)(ARG), RES1); \\\n+  TESTIT_COMPLEX(FUNC, -CONJ(ARG), RES2); \\\n+  TESTIT_COMPLEX(FUNC, CONJ(ARG), RES3); \\\n+  TESTIT_COMPLEX(FUNC, -(_Complex float)(ARG), RES4); \\\n+} while (0)\n+\n+/* For complex numbers, call the TESTIT_COMPLEX_R macro for all\n+   combinations of neg and conj.  */\n+#define TESTIT_COMPLEX_R_ALLNEG(FUNC, ARG, RES1, RES2, RES3, RES4) do { \\\n+  TESTIT_COMPLEX_R(FUNC, (_Complex float)(ARG), RES1); \\\n+  TESTIT_COMPLEX_R(FUNC, -CONJ(ARG), RES2); \\\n+  TESTIT_COMPLEX_R(FUNC, CONJ(ARG), RES3); \\\n+  TESTIT_COMPLEX_R(FUNC, -(_Complex float)(ARG), RES4); \\\n+} while (0)\n+\n+/* For complex numbers, test that FUNC(ARG0, ARG1) == (RES).  */\n+#define TESTIT_COMPLEX2(FUNC, ARG0, ARG1, RES) do { \\\n+  if (__builtin_##FUNC##f(ARG0, ARG1) != (RES) \\\n+    || COMPLEX_CKSGN_F(__builtin_##FUNC##f(ARG0, ARG1), (RES))) \\\n+      link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG0, ARG1) != (RES) \\\n+    || COMPLEX_CKSGN(__builtin_##FUNC(ARG0, ARG1), (RES))) \\\n+      link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG0, ARG1) != (RES) \\\n+    || COMPLEX_CKSGN_L(__builtin_##FUNC##l(ARG0, ARG1), (RES))) \\\n+      link_error(__LINE__); \\\n+  } while (0)\n+\n+/* For complex numbers, call the TESTIT_COMPLEX2 macro for all\n+   combinations of neg and conj.  */\n+#define TESTIT_COMPLEX2_ALLNEG(FUNC, ARG0, ARG1, RES1, RES2, RES3, RES4, RES5,\\\n+ RES6, RES7, RES8, RES9, RES10, RES11, RES12, RES13, RES14, RES15, RES16) do{ \\\n+  TESTIT_COMPLEX2(FUNC, (_Complex float)(ARG0),(_Complex float)(ARG1), RES1);\\\n+  TESTIT_COMPLEX2(FUNC, (_Complex float)(ARG0),CONJ(ARG1), RES2); \\\n+  TESTIT_COMPLEX2(FUNC, (_Complex float)(ARG0),-(_Complex float)(ARG1), RES3); \\\n+  TESTIT_COMPLEX2(FUNC, (_Complex float)(ARG0),-CONJ(ARG1), RES4); \\\n+  TESTIT_COMPLEX2(FUNC, -(_Complex float)(ARG0),(_Complex float)(ARG1), RES5); \\\n+  TESTIT_COMPLEX2(FUNC, -(_Complex float)(ARG0),CONJ(ARG1), RES6); \\\n+  TESTIT_COMPLEX2(FUNC, -(_Complex float)(ARG0),-(_Complex float)(ARG1), RES7); \\\n+  TESTIT_COMPLEX2(FUNC, -(_Complex float)(ARG0),-CONJ(ARG1), RES8); \\\n+  TESTIT_COMPLEX2(FUNC, CONJ(ARG0),(_Complex float)(ARG1), RES9); \\\n+  TESTIT_COMPLEX2(FUNC, CONJ(ARG0),CONJ(ARG1), RES10); \\\n+  TESTIT_COMPLEX2(FUNC, CONJ(ARG0),-(_Complex float)(ARG1), RES11); \\\n+  TESTIT_COMPLEX2(FUNC, CONJ(ARG0),-CONJ(ARG1), RES12); \\\n+  TESTIT_COMPLEX2(FUNC, -CONJ(ARG0),(_Complex float)(ARG1), RES13); \\\n+  TESTIT_COMPLEX2(FUNC, -CONJ(ARG0),CONJ(ARG1), RES14); \\\n+  TESTIT_COMPLEX2(FUNC, -CONJ(ARG0),-(_Complex float)(ARG1), RES15); \\\n+  TESTIT_COMPLEX2(FUNC, -CONJ(ARG0),-CONJ(ARG1), RES16); \\\n+} while (0)\n+\n /* Return TRUE if X differs from EXPECTED by more than 1%.  If\n    EXPECTED is zero, then any difference may return TRUE.  We don't\n    worry about signed zeros.  */\n@@ -81,87 +136,126 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   } while (0)\n \n+/* Range test, for complex numbers check that FUNC(ARG0, ARG1) is\n+   within 1% of RES.  This is NOT a test for accuracy to the last-bit,\n+   we're merely checking that we get relatively sane results.\n+   I.e. the GCC builtin is hooked up to the correct MPC function call.\n+   We first check the magnitude and then the sign.  */\n+#define TESTIT_COMPLEX_R2(FUNC, ARG0, ARG1, RES) do { \\\n+  if (COMPLEX_DIFF1PCT_F (__builtin_##FUNC##f(ARG0, ARG1), (RES)) \\\n+      || COMPLEX_CKSGN_F (__builtin_##FUNC##f(ARG0, ARG1), (RES))) \\\n+    link_error(__LINE__); \\\n+  if (COMPLEX_DIFF1PCT (__builtin_##FUNC(ARG0, ARG1), (RES)) \\\n+      || COMPLEX_CKSGN (__builtin_##FUNC(ARG0, ARG1), (RES))) \\\n+    link_error(__LINE__); \\\n+  if (COMPLEX_DIFF1PCT_L (__builtin_##FUNC##l(ARG0, ARG1), (RES)) \\\n+      || COMPLEX_CKSGN_L (__builtin_##FUNC##l(ARG0, ARG1), (RES))) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* For complex numbers, call the TESTIT_COMPLEX_R2 macro for all\n+   combinations of neg and conj.  */\n+#define TESTIT_COMPLEX_R2_ALLNEG(FUNC, ARG0, ARG1, RES1, RES2, RES3, RES4, RES5,\\\n+ RES6, RES7, RES8, RES9, RES10, RES11, RES12, RES13, RES14, RES15, RES16) do{ \\\n+  TESTIT_COMPLEX_R2(FUNC, (_Complex float)(ARG0),(_Complex float)(ARG1), RES1);\\\n+  TESTIT_COMPLEX_R2(FUNC, (_Complex float)(ARG0),CONJ(ARG1), RES2); \\\n+  TESTIT_COMPLEX_R2(FUNC, (_Complex float)(ARG0),-(_Complex float)(ARG1), RES3); \\\n+  TESTIT_COMPLEX_R2(FUNC, (_Complex float)(ARG0),-CONJ(ARG1), RES4); \\\n+  TESTIT_COMPLEX_R2(FUNC, -(_Complex float)(ARG0),(_Complex float)(ARG1), RES5); \\\n+  TESTIT_COMPLEX_R2(FUNC, -(_Complex float)(ARG0),CONJ(ARG1), RES6); \\\n+  TESTIT_COMPLEX_R2(FUNC, -(_Complex float)(ARG0),-(_Complex float)(ARG1), RES7); \\\n+  TESTIT_COMPLEX_R2(FUNC, -(_Complex float)(ARG0),-CONJ(ARG1), RES8); \\\n+  TESTIT_COMPLEX_R2(FUNC, CONJ(ARG0),(_Complex float)(ARG1), RES9); \\\n+  TESTIT_COMPLEX_R2(FUNC, CONJ(ARG0),CONJ(ARG1), RES10); \\\n+  TESTIT_COMPLEX_R2(FUNC, CONJ(ARG0),-(_Complex float)(ARG1), RES11); \\\n+  TESTIT_COMPLEX_R2(FUNC, CONJ(ARG0),-CONJ(ARG1), RES12); \\\n+  TESTIT_COMPLEX_R2(FUNC, -CONJ(ARG0),(_Complex float)(ARG1), RES13); \\\n+  TESTIT_COMPLEX_R2(FUNC, -CONJ(ARG0),CONJ(ARG1), RES14); \\\n+  TESTIT_COMPLEX_R2(FUNC, -CONJ(ARG0),-(_Complex float)(ARG1), RES15); \\\n+  TESTIT_COMPLEX_R2(FUNC, -CONJ(ARG0),-CONJ(ARG1), RES16); \\\n+} while (0)\n+\n int main (void)\n {\n-  TESTIT_COMPLEX (csin, 0.0F, 0.0F);\n-  TESTIT_COMPLEX (csin, -0.0F, -0.0F);\n-  TESTIT_COMPLEX (csin, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n-  TESTIT_COMPLEX (csin, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n-\n-  TESTIT_COMPLEX_R (csin, 3.45678F + 2.34567FI, -1.633059F - 4.917448FI);\n-  TESTIT_COMPLEX_R (csin, 3.45678F - 2.34567FI, -1.633059F + 4.917448FI);\n-  TESTIT_COMPLEX_R (csin, -3.45678F + 2.34567FI, 1.633059F - 4.917448FI);\n-  TESTIT_COMPLEX_R (csin, -3.45678F - 2.34567FI, 1.633059F + 4.917448FI);\n+  TESTIT_COMPLEX_ALLNEG (csin, 0,\n+\t\t\t 0, -0.F,\n+\t\t\t CONJ(0), CONJ(-0.F));\n+  TESTIT_COMPLEX_R_ALLNEG (csin, 3.45678F + 2.34567FI,\n+\t\t\t   -1.633059F - 4.917448FI, 1.633059F - 4.917448FI,\n+\t\t\t   -1.633059F + 4.917448FI, 1.633059F + 4.917448FI);\n+\n+  TESTIT_COMPLEX_ALLNEG (ccos, 0,\n+\t\t\t CONJ(1), 1, 1, CONJ(1));\n+  TESTIT_COMPLEX_R_ALLNEG (ccos, 3.45678F + 2.34567FI,\n+\t\t\t   -5.008512F + 1.603367FI, -5.008512F - 1.603367FI,\n+\t\t\t   -5.008512F - 1.603367FI, -5.008512F + 1.603367FI);\n+\n+  TESTIT_COMPLEX_ALLNEG (ctan, 0,\n+\t\t\t 0, -0.F, CONJ(0), CONJ(-0.F));\n+  TESTIT_COMPLEX_R_ALLNEG (ctan, 3.45678F + 2.34567FI,\n+\t\t\t   0.010657F + 0.985230FI, -0.010657F + 0.985230FI,\n+\t\t\t   0.010657F - 0.985230FI, -0.010657F - 0.985230FI);\n+  \n+  TESTIT_COMPLEX_ALLNEG (csinh, 0,\n+\t\t\t 0, -0.F, CONJ(0), CONJ(-0.F));\n+  TESTIT_COMPLEX_R_ALLNEG (csinh, 3.45678F + 2.34567FI,\n+\t\t\t   -11.083178F + 11.341487FI, 11.083178F +11.341487FI,\n+\t\t\t   -11.083178F - 11.341487FI, 11.083178F -11.341487FI);\n   \n-  TESTIT_COMPLEX (ccos, 0.0F, __builtin_conjf(1.0F));\n-  TESTIT_COMPLEX (ccos, -0.0F, 1.0F);\n-  TESTIT_COMPLEX (ccos, __builtin_conjf(0.0F), 1.0F);\n-  TESTIT_COMPLEX (ccos, __builtin_conjf(-0.0F), __builtin_conjf(1.0F));\n-\n-  TESTIT_COMPLEX_R (ccos, 3.45678F + 2.34567FI, -5.008512F + 1.603367FI);\n-  TESTIT_COMPLEX_R (ccos, 3.45678F - 2.34567FI, -5.008512F - 1.603367FI);\n-  TESTIT_COMPLEX_R (ccos, -3.45678F + 2.34567FI, -5.008512F - 1.603367FI);\n-  TESTIT_COMPLEX_R (ccos, -3.45678F - 2.34567FI, -5.008512F + 1.603367FI);\n-\n-  TESTIT_COMPLEX (ctan, 0.0F, 0.0F);\n-  TESTIT_COMPLEX (ctan, -0.0F, -0.0F);\n-  TESTIT_COMPLEX (ctan, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n-  TESTIT_COMPLEX (ctan, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n-\n-  TESTIT_COMPLEX_R (ctan, 3.45678F + 2.34567FI, 0.010657F + 0.985230FI);\n-  TESTIT_COMPLEX_R (ctan, 3.45678F - 2.34567FI, 0.010657F - 0.985230FI);\n-  TESTIT_COMPLEX_R (ctan, -3.45678F + 2.34567FI, -0.010657F + 0.985230FI);\n-  TESTIT_COMPLEX_R (ctan, -3.45678F - 2.34567FI, -0.010657F - 0.985230FI);\n-\n-  TESTIT_COMPLEX (csinh, 0.0F, 0.0F);\n-  TESTIT_COMPLEX (csinh, -0.0F, -0.0F);\n-  TESTIT_COMPLEX (csinh, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n-  TESTIT_COMPLEX (csinh, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n-\n-  TESTIT_COMPLEX_R (csinh, 3.45678F + 2.34567FI, -11.083178F + 11.341487FI);\n-  TESTIT_COMPLEX_R (csinh, 3.45678F - 2.34567FI, -11.083178F - 11.341487FI);\n-  TESTIT_COMPLEX_R (csinh, -3.45678F + 2.34567FI, 11.083178F + 11.341487FI);\n-  TESTIT_COMPLEX_R (csinh, -3.45678F - 2.34567FI, 11.083178F - 11.341487FI);\n-\n-  TESTIT_COMPLEX (ccosh, 0.0F, 1.0F);\n-  TESTIT_COMPLEX (ccosh, -0.0F, __builtin_conjf(1.0F));\n-  TESTIT_COMPLEX (ccosh, __builtin_conjf(0.0F), __builtin_conjf(1.0F));\n-  TESTIT_COMPLEX (ccosh, __builtin_conjf(-0.0F), 1.0F);\n-\n-  TESTIT_COMPLEX_R (ccosh, 3.45678F + 2.34567FI, -11.105238F + 11.318958FI);\n-  TESTIT_COMPLEX_R (ccosh, 3.45678F - 2.34567FI, -11.105238F - 11.318958FI);\n-  TESTIT_COMPLEX_R (ccosh, -3.45678F + 2.34567FI, -11.105238F - 11.318958FI);\n-  TESTIT_COMPLEX_R (ccosh, -3.45678F - 2.34567FI, -11.105238F + 11.318958FI);\n-\n-  TESTIT_COMPLEX (ctanh, 0.0F, 0.0F);\n-  TESTIT_COMPLEX (ctanh, -0.0F, -0.0F);\n-  TESTIT_COMPLEX (ctanh, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n-  TESTIT_COMPLEX (ctanh, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n-\n-  TESTIT_COMPLEX_R (ctanh, 3.45678F + 2.34567FI, 1.000040F - 0.001988FI);\n-  TESTIT_COMPLEX_R (ctanh, 3.45678F - 2.34567FI, 1.000040F + 0.001988FI);\n-  TESTIT_COMPLEX_R (ctanh, -3.45678F + 2.34567FI, -1.000040F - 0.001988FI);\n-  TESTIT_COMPLEX_R (ctanh, -3.45678F - 2.34567FI, -1.000040F + 0.001988FI);\n-\n-  TESTIT_COMPLEX (clog, 1.0F, 0.0F);\n-  TESTIT_COMPLEX_R (clog, -1.0F, 3.141593FI);\n-  TESTIT_COMPLEX (clog, __builtin_conjf(1.0F), __builtin_conjf(0.0F)); /* Fails with mpc-0.6.  */\n-  TESTIT_COMPLEX_R (clog, __builtin_conjf(-1.0F), __builtin_conjf(3.141593FI)); /* Fails with mpc-0.6.  */\n-\n-  TESTIT_COMPLEX_R (clog, 3.45678F + 2.34567FI, 1.429713F + 0.596199FI);\n-  TESTIT_COMPLEX_R (clog, 3.45678F - 2.34567FI, 1.429713F - 0.596199FI);\n-  TESTIT_COMPLEX_R (clog, -3.45678F + 2.34567FI, 1.429713F + 2.545394FI);\n-  TESTIT_COMPLEX_R (clog, -3.45678F - 2.34567FI, 1.429713F - 2.545394FI);\n-\n-  TESTIT_COMPLEX (csqrt, 0.0F, 0.0F);\n-  TESTIT_COMPLEX (csqrt, -0.0F, 0.0F);\n-  TESTIT_COMPLEX (csqrt, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n-  TESTIT_COMPLEX (csqrt, __builtin_conjf(-0.0F), __builtin_conjf(0.0F));\n-\n-  TESTIT_COMPLEX_R (csqrt, 3.45678F + 2.34567FI, 1.953750F + 0.600299FI);\n-  TESTIT_COMPLEX_R (csqrt, 3.45678F - 2.34567FI, 1.953750F - 0.600299FI);\n-  TESTIT_COMPLEX_R (csqrt, -3.45678F + 2.34567FI, 0.600299F + 1.953750FI);\n-  TESTIT_COMPLEX_R (csqrt, -3.45678F - 2.34567FI, 0.600299F - 1.953750FI);\n+  TESTIT_COMPLEX_ALLNEG (ccosh, 0,\n+\t\t\t 1, CONJ(1), CONJ(1), 1);\n+  TESTIT_COMPLEX_R_ALLNEG (ccosh, 3.45678F + 2.34567FI,\n+\t\t\t   -11.105238F + 11.318958FI,-11.105238F -11.318958FI,\n+\t\t\t   -11.105238F - 11.318958FI,-11.105238F +11.318958FI);\n+  \n+  TESTIT_COMPLEX_ALLNEG (ctanh, 0,\n+\t\t\t 0, -0.F, CONJ(0), CONJ(-0.F));\n+  TESTIT_COMPLEX_R_ALLNEG (ctanh, 3.45678F + 2.34567FI,\n+\t\t\t   1.000040F - 0.001988FI, -1.000040F - 0.001988FI,\n+\t\t\t   1.000040F + 0.001988FI, -1.000040F + 0.001988FI);\n+\n+  TESTIT_COMPLEX (clog, 1, 0);\n+  TESTIT_COMPLEX_R (clog, -1, 3.141593FI);\n+  TESTIT_COMPLEX (clog, CONJ(1), CONJ(0)); /* Fails with mpc-0.6.  */\n+  TESTIT_COMPLEX_R (clog, CONJ(-1), CONJ(3.141593FI)); /* Fails with mpc-0.6.  */\n+  TESTIT_COMPLEX_R_ALLNEG (clog, 3.45678F + 2.34567FI,\n+\t\t\t   1.429713F + 0.596199FI, 1.429713F + 2.545394FI,\n+\t\t\t   1.429713F - 0.596199FI, 1.429713F - 2.545394FI);\n+\n+  TESTIT_COMPLEX_ALLNEG (csqrt, 0,\n+\t\t\t 0, 0, CONJ(0), CONJ(0));\n+  TESTIT_COMPLEX_R_ALLNEG (csqrt, 3.45678F + 2.34567FI,\n+\t\t\t   1.953750F + 0.600299FI, 0.600299F + 1.953750FI,\n+\t\t\t   1.953750F - 0.600299FI, 0.600299F - 1.953750FI);\n+  \n+  TESTIT_COMPLEX2_ALLNEG (cpow, 1, 0,\n+\t\t\t  1, 1, CONJ(1), CONJ(1), 1, CONJ(1), 1, 1,\n+\t\t\t  CONJ(1), CONJ(1), 1, 1, 1, 1, CONJ(1), 1);\n+  TESTIT_COMPLEX2_ALLNEG (cpow, 1.FI, 0,\n+\t\t\t  1, 1, CONJ(1), 1, 1, CONJ(1), 1, 1,\n+\t\t\t  1, CONJ(1), 1, 1, 1, 1, CONJ(1), 1);\n+  TESTIT_COMPLEX_R2_ALLNEG (cpow, 2, 3,\n+\t\t\t    8, 8, CONJ(1/8.F), 1/8.F, CONJ(-8), -8, -1/8.F, -1/8.F,\n+\t\t\t    8, CONJ(8), 1/8.F, 1/8.F, -8, -8, -1/8.F, CONJ(-1/8.F));\n+  TESTIT_COMPLEX_R2_ALLNEG (cpow, 3, 4,\n+\t\t\t    81, 81, CONJ(1/81.F), 1/81.F, 81, 81, CONJ(1/81.F), 1/81.F,\n+\t\t\t    81, CONJ(81), 1/81.F, 1/81.F, 81, CONJ(81), 1/81.F, 1/81.F);\n+  TESTIT_COMPLEX_R2_ALLNEG (cpow, 3, 5,\n+\t\t\t    243, 243, CONJ(1/243.F), 1/243.F, CONJ(-243), -243, -1/243.F, -1/243.F,\n+\t\t\t    243, CONJ(243), 1/243.F, 1/243.F, -243, -243, -1/243.F, CONJ(-1/243.F));\n+  TESTIT_COMPLEX_R2_ALLNEG (cpow, 4, 2,\n+\t\t\t    16, 16, CONJ(1/16.F), 1/16.F, 16, 16, CONJ(1/16.F), 1/16.F,\n+\t\t\t    16, CONJ(16), 1/16.F, 1/16.F, 16, CONJ(16), 1/16.F, 1/16.F);\n+  TESTIT_COMPLEX_R2_ALLNEG (cpow, 1.5, 3,\n+\t\t\t    3.375F, 3.375F, CONJ(1/3.375F), 1/3.375F, CONJ(-3.375F), -3.375F, -1/3.375F, -1/3.375F,\n+\t\t\t    3.375F, CONJ(3.375F), 1/3.375F, 1/3.375F, -3.375F, -3.375F, -1/3.375F, CONJ(-1/3.375F));\n+  \n+  TESTIT_COMPLEX2 (cpow, 16, 0.25F, 2);\n \n+  TESTIT_COMPLEX_R2 (cpow, 3.45678F + 2.34567FI, 1.23456 + 4.56789FI, 0.212485F + 0.319304FI);\n+  TESTIT_COMPLEX_R2 (cpow, 3.45678F - 2.34567FI, 1.23456 + 4.56789FI, 78.576402F + -41.756208FI);\n+  TESTIT_COMPLEX_R2 (cpow, -1.23456F + 2.34567FI, 2.34567 - 1.23456FI, -110.629847F + -57.021655FI);\n+  TESTIT_COMPLEX_R2 (cpow, -1.23456F - 2.34567FI, 2.34567 - 1.23456FI, 0.752336F + 0.199095FI);\n+  \n   return 0;\n }"}, {"sha": "306e78fcbb166f67542ae82b3b1a14eec83a9ad3", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=a41d064d96aa33de2cbc5ee6bf1f3f9fc76ef528", "patch": "@@ -2998,3 +2998,16 @@ proc check_effective_target_mpc { } {\n \t}\n     }]\n }\n+\n+# Return 1 if the MPC library with mpc_pow is integrated with GCC, 0 otherwise.\n+\n+proc check_effective_target_mpc_pow { } {\n+    return [check_no_compiler_messages mpc executable {\n+\textern void link_error(void);\n+\tint main ()\n+\t{\n+\t  if (__builtin_cpow(1,1) != 1)\n+\t    link_error();\n+\t}\n+    }]\n+}"}]}