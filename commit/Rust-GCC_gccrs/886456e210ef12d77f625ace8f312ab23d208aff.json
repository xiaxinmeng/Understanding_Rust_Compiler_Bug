{"sha": "886456e210ef12d77f625ace8f312ab23d208aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg2NDU2ZTIxMGVmMTJkNzdmNjI1YWNlOGYzMTJhYjIzZDIwOGFmZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-12-02T09:06:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-12-02T09:06:28Z"}, "message": "Check for invalid FAILs\n\nThis patch makes it a compile-time error for an internal-fn optab\nto FAIL.  There are certainly other optabs and patterns besides these\nthat aren't allowed to fail, but this at least deals with the immediate\npoint of controversy.\n\nTested normally on x86_64-linux-gnu.  Also tested by building one\nconfiguration per cpu directory.  arc-elf and pdp11 didn't build\nfor unrelated reasons, but I checked that insn-emit.o built for\nboth without error.\n\ngcc/\n\t* Makefile.in (GENSUPPORT_H): New macro.\n\t(build/gensupport.o, build/read-rtl.o, build/genattr.o)\n\t(build/genattr-common.o, build/genattrtab.o, build/genautomata.o)\n\t(build/gencodes.o, build/genconditions.o, build/genconfig.o)\n\t(build/genconstants.o, build/genextract.o, build/genflags.o)\n\t(build/gentarget-def.o): Use it.\n\t(build/genemit.o): Likewise.  Depend on internal-fn.def.\n\t* genopinit.c: Move block comment to optabs.def.\n\t(optab_tag, optab_def): Move to gensupport.h\n\t(pattern): Likewise, renaming to optab_pattern.\n\t(match_pattern): Move to gensupport.c\n\t(gen_insn): Use find_optab.\n\t(patterns, pattern_cmp): Replace pattern with optab_pattern.\n\t(main): Likewise.  Use num_optabs.\n\t* optabs.def: Add comment that was previously in genopinit.c.\n\t* gensupport.h (optab_tag): Moved from genopinit.c\n\t(optab_def): Likewise, expanding commentary.\n\t(optab_pattern): Likewise, after renaming from pattern.\n\t(optabs, num_optabs, find_optab): Declare.\n\t* gensupport.c (optabs): Moved from genopinit.c.\n\t(num_optabs): New variable.\n\t(match_pattern): Moved from genopinit.c.\n\t(find_optab): New function, extracted from genopinit.c:gen_insn.\n\t* genemit.c (nofail_optabs): New variable.\n\t(emit_c_code): New function.\n\t(gen_expand): Check whether the instruction is an optab that isn't\n\tallowed to fail.  Call emit_c_code.\n\t(gen_split): Call emit_c_code here too.\n\t(main): Initialize nofail_optabs.  Don't emit FAIL and DONE here.\n\nFrom-SVN: r231160", "tree": {"sha": "5b44d07d2d4f3d21be039ca6d049269722224bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b44d07d2d4f3d21be039ca6d049269722224bbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/886456e210ef12d77f625ace8f312ab23d208aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886456e210ef12d77f625ace8f312ab23d208aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886456e210ef12d77f625ace8f312ab23d208aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886456e210ef12d77f625ace8f312ab23d208aff/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e970b4b0002d0bc24cf4461fb0eadd7ee2241cab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e970b4b0002d0bc24cf4461fb0eadd7ee2241cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e970b4b0002d0bc24cf4461fb0eadd7ee2241cab"}], "stats": {"total": 626, "additions": 365, "deletions": 261}, "files": [{"sha": "09bc243ef7fa81388d4c05f44cdf46ad7c1fd0d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -1,3 +1,35 @@\n+2015-12-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* Makefile.in (GENSUPPORT_H): New macro.\n+\t(build/gensupport.o, build/read-rtl.o, build/genattr.o)\n+\t(build/genattr-common.o, build/genattrtab.o, build/genautomata.o)\n+\t(build/gencodes.o, build/genconditions.o, build/genconfig.o)\n+\t(build/genconstants.o, build/genextract.o, build/genflags.o)\n+\t(build/gentarget-def.o): Use it.\n+\t(build/genemit.o): Likewise.  Depend on internal-fn.def.\n+\t* genopinit.c: Move block comment to optabs.def.\n+\t(optab_tag, optab_def): Move to gensupport.h\n+\t(pattern): Likewise, renaming to optab_pattern.\n+\t(match_pattern): Move to gensupport.c\n+\t(gen_insn): Use find_optab.\n+\t(patterns, pattern_cmp): Replace pattern with optab_pattern.\n+\t(main): Likewise.  Use num_optabs.\n+\t* optabs.def: Add comment that was previously in genopinit.c.\n+\t* gensupport.h (optab_tag): Moved from genopinit.c\n+\t(optab_def): Likewise, expanding commentary.\n+\t(optab_pattern): Likewise, after renaming from pattern.\n+\t(optabs, num_optabs, find_optab): Declare.\n+\t* gensupport.c (optabs): Moved from genopinit.c.\n+\t(num_optabs): New variable.\n+\t(match_pattern): Moved from genopinit.c.\n+\t(find_optab): New function, extracted from genopinit.c:gen_insn.\n+\t* genemit.c (nofail_optabs): New variable.\n+\t(emit_c_code): New function.\n+\t(gen_expand): Check whether the instruction is an optab that isn't\n+\tallowed to fail.  Call emit_c_code.\n+\t(gen_split): Call emit_c_code here too.\n+\t(main): Initialize nofail_optabs.  Don't emit FAIL and DONE here.\n+\n 2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/predicates.md (const_mask_operand): New predicate."}, {"sha": "d2d09f64f5fb0b1b3dbac387187b55ea798181dc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -978,6 +978,7 @@ GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h plugin.def \\\n PLUGIN_H = plugin.h $(GCC_PLUGIN_H)\n PLUGIN_VERSION_H = plugin-version.h configargs.h\n CONTEXT_H = context.h\n+GENSUPPORT_H = gensupport.h read-md.h optabs.def\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -2476,7 +2477,7 @@ build/version.o:  version.c version.h \\\n build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h\n build/gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) errors.h $(HASHTAB_H)\t\t\\\n-  $(READ_MD_H) gensupport.h\n+  $(READ_MD_H) $(GENSUPPORT_H)\n build/ggc-none.o : ggc-none.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \t\\\n   $(GGC_H)\n build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n@@ -2487,7 +2488,7 @@ build/read-md.o: read-md.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n   $(HASHTAB_H) errors.h $(READ_MD_H)\n build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) $(READ_MD_H)\t\t\\\n-  gensupport.h\n+  $(GENSUPPORT_H)\n build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) $(GGC_H) errors.h\n build/vec.o : vec.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H)\t\\\n@@ -2509,38 +2510,38 @@ build/gencondmd.o : \\\n \n # ...these are the programs themselves.\n build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genattr-common.o : genattr-common.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  $(READ_MD_H) gensupport.h $(FNMATCH_H)\n+  $(READ_MD_H) $(GENSUPPORT_H) $(FNMATCH_H)\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VEC_H)\t\\\n-  $(HASHTAB_H) gensupport.h $(FNMATCH_H)\n+  $(HASHTAB_H) $(GENSUPPORT_H) $(FNMATCH_H)\n build/gencheck.o : gencheck.c all-tree.def $(BCONFIG_H) $(GTM_H)\t\\\n \t$(SYSTEM_H) coretypes.h tree.def c-family/c-common.def\t\t\\\n \t$(lang_tree_files) gimple.def\n build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)\n build/gencodes.o : gencodes.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(GENSUPPORT_H)\n build/genconditions.o : genconditions.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(HASHTAB_H) $(READ_MD_H)\t\\\n-  gensupport.h\n+  $(GENSUPPORT_H)\n build/genconfig.o : genconfig.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(GENSUPPORT_H)\n build/genconstants.o : genconstants.c $(BCONFIG_H) $(SYSTEM_H)\t\t\\\n   coretypes.h errors.h $(READ_MD_H)\n build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H) internal-fn.def\n build/genenums.o : genenums.c $(BCONFIG_H) $(SYSTEM_H)\t\t\t\\\n   coretypes.h errors.h $(READ_MD_H)\n build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/gentarget-def.o : gentarget-def.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) $(RTL_BASE_H) errors.h $(READ_MD_H) gensupport.h\t\\\n+  coretypes.h $(GTM_H) $(RTL_BASE_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\t\\\n   $(HASH_TABLE_H) target-insns.def\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n \n@@ -2582,20 +2583,20 @@ build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\\n   $(HASHTAB_H) machmode.def $(extra_modes_file)\n build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h optabs.def\n+  coretypes.h $(GTM_H) errors.h $(GENSUPPORT_H) optabs.def\n build/genoutput.o : genoutput.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genpeep.o : genpeep.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h toplev.h $(DIAGNOSTIC_CORE_H)\n+  coretypes.h $(GTM_H) errors.h $(GENSUPPORT_H) toplev.h $(DIAGNOSTIC_CORE_H)\n build/genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h $(OBSTACK_H)\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H) $(OBSTACK_H)\n build/genrecog.o : genrecog.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\t\t\\\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\t\t\\\n   $(HASH_TABLE_H) inchash.h\n build/genhooks.o : genhooks.c $(TARGET_DEF) $(C_TARGET_DEF)\t\t\\\n   $(COMMON_TARGET_DEF) $(BCONFIG_H) $(SYSTEM_H) errors.h\n build/genmddump.o : genmddump.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genmatch.o : genmatch.c $(BCONFIG_H) $(SYSTEM_H) \\\n   coretypes.h errors.h $(HASH_TABLE_H) hash-map.h $(GGC_H) is-a.h \\\n   tree.def builtins.def internal-fn.def"}, {"sha": "cd85a809ae101d70db4127be479c63c622a60867", "filename": "gcc/genemit.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -51,6 +51,8 @@ struct clobber_ent\n \n static void output_peephole2_scratches\t(rtx);\n \n+/* True for <X>_optab if that optab isn't allowed to fail.  */\n+static bool nofail_optabs[NUM_OPTABS];\n \f\n static void\n print_code (RTX_CODE code)\n@@ -285,6 +287,28 @@ gen_emit_seq (rtvec vec, char *used)\n     }\n }\n \f\n+/* Emit the given C code to the output file.  The code is allowed to\n+   fail if CAN_FAIL_P.  NAME describes what we're generating,\n+   for use in error messages.  */\n+\n+static void\n+emit_c_code (const char *code, bool can_fail_p, const char *name)\n+{\n+  if (can_fail_p)\n+    printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n+  else\n+    printf (\"#define FAIL _Pragma (\\\"GCC error \\\\\\\"%s cannot FAIL\\\\\\\"\\\")\"\n+\t    \" (void)0\\n\", name);\n+  printf (\"#define DONE return (_val = get_insns (),\"\n+\t  \"end_sequence (), _val)\\n\");\n+\n+  print_md_ptr_loc (code);\n+  printf (\"%s\\n\", code);\n+\n+  printf (\"#undef DONE\\n\");\n+  printf (\"#undef FAIL\\n\");\n+}\n+\f\n /* Generate the `gen_...' function for a DEFINE_INSN.  */\n \n static void\n@@ -478,8 +502,15 @@ gen_expand (md_rtx_info *info)\n \n       /* Output the special code to be executed before the sequence\n \t is generated.  */\n-      print_md_ptr_loc (XSTR (expand, 3));\n-      printf (\"%s\\n\", XSTR (expand, 3));\n+      optab_pattern p;\n+      bool can_fail_p = true;\n+      if (find_optab (&p, XSTR (expand, 0)))\n+\t{\n+\t  gcc_assert (p.op < NUM_OPTABS);\n+\t  if (nofail_optabs[p.op])\n+\t    can_fail_p = false;\n+\t}\n+      emit_c_code (XSTR (expand, 3), can_fail_p, XSTR (expand, 0));\n \n       /* Output code to copy the arguments back out of `operands'\n \t (unless we aren't going to use them at all).  */\n@@ -569,10 +600,7 @@ gen_split (md_rtx_info *info)\n      before the actual construction.  */\n \n   if (XSTR (split, 3))\n-    {\n-      print_md_ptr_loc (XSTR (split, 3));\n-      printf (\"%s\\n\", XSTR (split, 3));\n-    }\n+    emit_c_code (XSTR (split, 3), true, name);\n \n   /* Output code to copy the arguments back out of `operands'  */\n   for (i = 0; i < stats.num_operand_vars; i++)\n@@ -724,6 +752,10 @@ main (int argc, char **argv)\n   if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n+#define DEF_INTERNAL_OPTAB_FN(NAME, FLAGS, OPTAB, TYPE) \\\n+  nofail_optabs[OPTAB##_optab] = true;\n+#include \"internal-fn.def\"\n+\n   /* Assign sequential codes to all entries in the machine description\n      in parallel with the tables in insn-output.c.  */\n \n@@ -764,8 +796,6 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"ggc.h\\\"\\n\");\n   printf (\"#include \\\"dumpfile.h\\\"\\n\");\n   printf (\"#include \\\"target.h\\\"\\n\\n\");\n-  printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n-  printf (\"#define DONE return (_val = get_insns (), end_sequence (), _val)\\n\\n\");\n \n   /* Read the machine description.  */\n "}, {"sha": "3b91112e9ec34ef8cca2a71928203a195659a4ae", "filename": "gcc/genopinit.c", "status": "modified", "additions": 8, "deletions": 232, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -35,246 +35,22 @@ static const char * const rtx_upname[] = {\n \n #undef DEF_RTL_EXPR\n \n-\n-/* The entries in optabs.def are categorized:\n-     C: A \"conversion\" optab, which uses two modes; has libcall data.\n-     N: A \"normal\" optab, which uses one mode; has libcall data.\n-     D: A \"direct\" optab, which uses one mode; does not have libcall data.\n-     V: An \"oVerflow\" optab.  Like N, but does not record its code in\n-        code_to_optab.\n-\n-     CX, NX, VX: An extra pattern entry for a conversion or normal optab.\n-\n-   These patterns may be present in the MD file with names that contain\n-   the mode(s) used and the name of the operation.  This array contains\n-   a list of optabs that need to be initialized.  Within each name,\n-   $a and $b are used to match a short mode name (the part of the mode\n-   name not including `mode' and converted to lower-case).\n-\n-   $I means that only full integer modes should be considered for the\n-   next mode, and $F means that only float modes should be considered.\n-   $P means that both full and partial integer modes should be considered.\n-   $Q means that only fixed-point modes should be considered.\n-\n-   The pattern may be NULL if the optab exists only for the libcalls\n-   that we plan to attach to it, and there are no named patterns in\n-   the md files.  */\n-\n-#define OPTAB_CL(name, pat, c, b, l)\t\tname,\n-#define OPTAB_CX(name, pat)\n-#define OPTAB_CD(name, pat)\t\t\tname,\n-#define OPTAB_NL(name, pat, c, b, s, l)\t\tname,\n-#define OPTAB_NC(name, pat, c)\t\t\tname,\n-#define OPTAB_NX(name, pat)\n-#define OPTAB_VL(name, pat, c, b, s, l)\t\tname,\n-#define OPTAB_VC(name, pat, c)\t\t\tname,\n-#define OPTAB_VX(name, pat)\n-#define OPTAB_DC(name, pat, c)\t\t\tname,\n-#define OPTAB_D(name, pat)\t\t\tname,\n-\n-typedef enum optab_tag {\n-  unknown_optab,\n-#include \"optabs.def\"\n-  NUM_OPTABS\n-} optab;\n-\n-#undef OPTAB_CL\n-#undef OPTAB_CX\n-#undef OPTAB_CD\n-#undef OPTAB_NL\n-#undef OPTAB_NC\n-#undef OPTAB_NX\n-#undef OPTAB_VL\n-#undef OPTAB_VC\n-#undef OPTAB_VX\n-#undef OPTAB_DC\n-#undef OPTAB_D\n-\n-#define NS \"NULL\"\n-#define ZS \"'\\\\0'\"\n-#define OPTAB_CL(o, p, c, b, l)    { #o, p, #b, ZS, #l, o, c, UNKNOWN, 1 },\n-#define OPTAB_CX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 1 },\n-#define OPTAB_CD(o, p) { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 2 },\n-#define OPTAB_NL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, c, 3 },\n-#define OPTAB_NC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 3 },\n-#define OPTAB_NX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n-#define OPTAB_VL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, UNKNOWN, 3 },\n-#define OPTAB_VC(o, p, c)          { #o, p, NS, ZS, NS, o, c, UNKNOWN, 3 },\n-#define OPTAB_VX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n-#define OPTAB_DC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 4 },\n-#define OPTAB_D(o, p)  { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 4 },\n-\n-struct optab_def\n-{\n-  const char *name;\n-  const char *pattern;\n-  const char *base;\n-  const char *suffix;\n-  const char *libcall;\n-  unsigned int op;\n-  enum rtx_code fcode;\n-  enum rtx_code rcode;\n-  unsigned int kind;\n-};\n-\n-static optab_def optabs[] = {\n-  { \"unknown_optab\", NULL, NS, ZS, NS, unknown_optab, UNKNOWN, UNKNOWN, 0 },\n-#include \"optabs.def\"\n-};\n-\n-#undef OPTAB_CL\n-#undef OPTAB_CX\n-#undef OPTAB_CD\n-#undef OPTAB_NL\n-#undef OPTAB_NC\n-#undef OPTAB_NX\n-#undef OPTAB_VL\n-#undef OPTAB_VC\n-#undef OPTAB_VX\n-#undef OPTAB_DC\n-#undef OPTAB_D\n-\n /* Vector in which to collect insns that match.  */\n-\n-struct pattern\n-{\n-  const char *name;\n-  unsigned int op;\n-  unsigned int m1, m2;\n-  unsigned int sort_num;\n-};\n-\n-\n-static vec<pattern> patterns;\n-\n-static bool\n-match_pattern (pattern *p, const char *name, const char *pat)\n-{\n-  bool force_float = false;\n-  bool force_int = false;\n-  bool force_partial_int = false;\n-  bool force_fixed = false;\n-\n-  if (pat == NULL)\n-    return false;\n-  for (; ; ++pat)\n-    {\n-      if (*pat != '$')\n-\t{\n-\t  if (*pat != *name++)\n-\t    return false;\n-\t  if (*pat == '\\0')\n-\t    return true;\n-\t  continue;\n-\t}\n-      switch (*++pat)\n-\t{\n-\tcase 'I':\n-\t  force_int = 1;\n-\t  break;\n-\tcase 'P':\n-\t  force_partial_int = 1;\n-\t  break;\n-\tcase 'F':\n-\t  force_float = 1;\n-\t  break;\n-\tcase 'Q':\n-\t  force_fixed = 1;\n-\t  break;\n-\n-\tcase 'a':\n-\tcase 'b':\n-\t  {\n-\t    int i;\n-\n-\t    /* This loop will stop at the first prefix match, so\n-\t       look through the modes in reverse order, in case\n-\t       there are extra CC modes and CC is a prefix of the\n-\t       CC modes (as it should be).  */\n-\t    for (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n-\t      {\n-\t\tconst char *p, *q;\n-\t\tfor (p = GET_MODE_NAME (i), q = name; *p; p++, q++)\n-\t\t  if (TOLOWER (*p) != *q)\n-\t\t    break;\n-\t\tif (*p == 0\n-\t\t    && (! force_int || mode_class[i] == MODE_INT\n-\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n-\t\t    && (! force_partial_int\n-\t\t\t|| mode_class[i] == MODE_INT\n-\t\t\t|| mode_class[i] == MODE_PARTIAL_INT\n-\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n-\t\t    && (! force_float\n-\t\t\t|| mode_class[i] == MODE_FLOAT\n-\t\t\t|| mode_class[i] == MODE_DECIMAL_FLOAT\n-\t\t\t|| mode_class[i] == MODE_COMPLEX_FLOAT\n-\t\t\t|| mode_class[i] == MODE_VECTOR_FLOAT)\n-\t\t    && (! force_fixed\n-\t\t\t|| mode_class[i] == MODE_FRACT\n-\t\t\t|| mode_class[i] == MODE_UFRACT\n-\t\t\t|| mode_class[i] == MODE_ACCUM\n-\t\t\t|| mode_class[i] == MODE_UACCUM\n-\t\t\t|| mode_class[i] == MODE_VECTOR_FRACT\n-\t\t\t|| mode_class[i] == MODE_VECTOR_UFRACT\n-\t\t\t|| mode_class[i] == MODE_VECTOR_ACCUM\n-\t\t\t|| mode_class[i] == MODE_VECTOR_UACCUM))\n-\t\t  break;\n-\t      }\n-\n-\t    if (i < 0)\n-\t      return false;\n-\t    name += strlen (GET_MODE_NAME (i));\n-\t    if (*pat == 'a')\n-\t      p->m1 = i;\n-\t    else\n-\t      p->m2 = i;\n-\n-\t    force_int = false;\n-\t    force_partial_int = false;\n-\t    force_float = false;\n-\t    force_fixed = false;\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-}\n+static vec<optab_pattern> patterns;\n \n static void\n gen_insn (md_rtx_info *info)\n {\n-  rtx insn = info->def;\n-  const char *name = XSTR (insn, 0);\n-  pattern p;\n-  unsigned pindex;\n-\n-  /* Don't mention \"unnamed\" instructions.  */\n-  if (*name == 0 || *name == '*')\n-    return;\n-  p.name = name;\n-\n-  /* See if NAME matches one of the patterns we have for the optabs\n-     we know about.  */\n-  for (pindex = 0; pindex < ARRAY_SIZE (optabs); pindex++)\n-    {\n-      p.m1 = p.m2 = 0;\n-      if (match_pattern (&p, name, optabs[pindex].pattern))\n-\t{\n-\t  p.op = optabs[pindex].op;\n-\t  p.sort_num = (p.op << 16) | (p.m2 << 8) | p.m1;\n-\t  patterns.safe_push (p);\n-\t  return;\n-\t}\n-    }\n+  optab_pattern p;\n+  if (find_optab (&p, XSTR (info->def, 0)))\n+    patterns.safe_push (p);\n }\n \n static int\n pattern_cmp (const void *va, const void *vb)\n {\n-  const pattern *a = (const pattern *)va;\n-  const pattern *b = (const pattern *)vb;\n+  const optab_pattern *a = (const optab_pattern *)va;\n+  const optab_pattern *b = (const optab_pattern *)vb;\n   return a->sort_num - b->sort_num;\n }\n \n@@ -333,7 +109,7 @@ main (int argc, char **argv)\n {\n   FILE *h_file, *s_file;\n   unsigned int i, j, n, last_kind[5];\n-  pattern *p;\n+  optab_pattern *p;\n \n   progname = \"genopinit\";\n \n@@ -365,7 +141,7 @@ main (int argc, char **argv)\n \n   /* Now that we've handled the \"extra\" patterns, eliminate them from\n      the optabs array.  That way they don't get in the way below.  */\n-  n = ARRAY_SIZE (optabs);\n+  n = num_optabs;\n   for (i = 0; i < n; )\n     if (optabs[i].base == NULL)\n       optabs[i] = optabs[--n];"}, {"sha": "7969060c117f7d207bb667ef907998513c489ccd", "filename": "gcc/gensupport.c", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -3061,3 +3061,161 @@ needs_barrier_p (rtx x)\n \t  && GET_CODE (SET_DEST (x)) == PC\n \t  && GET_CODE (SET_SRC (x)) == LABEL_REF);\n }\n+\n+#define NS \"NULL\"\n+#define ZS \"'\\\\0'\"\n+#define OPTAB_CL(o, p, c, b, l)    { #o, p, #b, ZS, #l, o, c, UNKNOWN, 1 },\n+#define OPTAB_CX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 1 },\n+#define OPTAB_CD(o, p) { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 2 },\n+#define OPTAB_NL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, c, 3 },\n+#define OPTAB_NC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 3 },\n+#define OPTAB_NX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n+#define OPTAB_VL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, UNKNOWN, 3 },\n+#define OPTAB_VC(o, p, c)          { #o, p, NS, ZS, NS, o, c, UNKNOWN, 3 },\n+#define OPTAB_VX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n+#define OPTAB_DC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 4 },\n+#define OPTAB_D(o, p)  { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 4 },\n+\n+/* An array of all optabs.  Note that the same optab can appear more\n+   than once, with a different pattern.  */\n+optab_def optabs[] = {\n+  { \"unknown_optab\", NULL, NS, ZS, NS, unknown_optab, UNKNOWN, UNKNOWN, 0 },\n+#include \"optabs.def\"\n+};\n+\n+/* The number of entries in optabs[].  */\n+unsigned int num_optabs = ARRAY_SIZE (optabs);\n+\n+#undef OPTAB_CL\n+#undef OPTAB_CX\n+#undef OPTAB_CD\n+#undef OPTAB_NL\n+#undef OPTAB_NC\n+#undef OPTAB_NX\n+#undef OPTAB_VL\n+#undef OPTAB_VC\n+#undef OPTAB_VX\n+#undef OPTAB_DC\n+#undef OPTAB_D\n+\n+/* Return true if instruction NAME matches pattern PAT, storing information\n+   about the match in P if so.  */\n+\n+static bool\n+match_pattern (optab_pattern *p, const char *name, const char *pat)\n+{\n+  bool force_float = false;\n+  bool force_int = false;\n+  bool force_partial_int = false;\n+  bool force_fixed = false;\n+\n+  if (pat == NULL)\n+    return false;\n+  for (; ; ++pat)\n+    {\n+      if (*pat != '$')\n+\t{\n+\t  if (*pat != *name++)\n+\t    return false;\n+\t  if (*pat == '\\0')\n+\t    return true;\n+\t  continue;\n+\t}\n+      switch (*++pat)\n+\t{\n+\tcase 'I':\n+\t  force_int = 1;\n+\t  break;\n+\tcase 'P':\n+\t  force_partial_int = 1;\n+\t  break;\n+\tcase 'F':\n+\t  force_float = 1;\n+\t  break;\n+\tcase 'Q':\n+\t  force_fixed = 1;\n+\t  break;\n+\n+\tcase 'a':\n+\tcase 'b':\n+\t  {\n+\t    int i;\n+\n+\t    /* This loop will stop at the first prefix match, so\n+\t       look through the modes in reverse order, in case\n+\t       there are extra CC modes and CC is a prefix of the\n+\t       CC modes (as it should be).  */\n+\t    for (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n+\t      {\n+\t\tconst char *p, *q;\n+\t\tfor (p = GET_MODE_NAME (i), q = name; *p; p++, q++)\n+\t\t  if (TOLOWER (*p) != *q)\n+\t\t    break;\n+\t\tif (*p == 0\n+\t\t    && (! force_int || mode_class[i] == MODE_INT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n+\t\t    && (! force_partial_int\n+\t\t\t|| mode_class[i] == MODE_INT\n+\t\t\t|| mode_class[i] == MODE_PARTIAL_INT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n+\t\t    && (! force_float\n+\t\t\t|| mode_class[i] == MODE_FLOAT\n+\t\t\t|| mode_class[i] == MODE_DECIMAL_FLOAT\n+\t\t\t|| mode_class[i] == MODE_COMPLEX_FLOAT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_FLOAT)\n+\t\t    && (! force_fixed\n+\t\t\t|| mode_class[i] == MODE_FRACT\n+\t\t\t|| mode_class[i] == MODE_UFRACT\n+\t\t\t|| mode_class[i] == MODE_ACCUM\n+\t\t\t|| mode_class[i] == MODE_UACCUM\n+\t\t\t|| mode_class[i] == MODE_VECTOR_FRACT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_UFRACT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_ACCUM\n+\t\t\t|| mode_class[i] == MODE_VECTOR_UACCUM))\n+\t\t  break;\n+\t      }\n+\n+\t    if (i < 0)\n+\t      return false;\n+\t    name += strlen (GET_MODE_NAME (i));\n+\t    if (*pat == 'a')\n+\t      p->m1 = i;\n+\t    else\n+\t      p->m2 = i;\n+\n+\t    force_int = false;\n+\t    force_partial_int = false;\n+\t    force_float = false;\n+\t    force_fixed = false;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* Return true if NAME is the name of an optab, describing it in P if so.  */\n+\n+bool\n+find_optab (optab_pattern *p, const char *name)\n+{\n+  if (*name == 0 || *name == '*')\n+    return false;\n+\n+  /* See if NAME matches one of the patterns we have for the optabs\n+     we know about.  */\n+  for (unsigned int pindex = 0; pindex < ARRAY_SIZE (optabs); pindex++)\n+    {\n+      p->m1 = p->m2 = 0;\n+      if (match_pattern (p, name, optabs[pindex].pattern))\n+\t{\n+\t  p->name = name;\n+\t  p->op = optabs[pindex].op;\n+\t  p->sort_num = (p->op << 16) | (p->m2 << 8) | p->m1;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}"}, {"sha": "456efa0c7d1558113ae1cb8db69d27b71f537073", "filename": "gcc/gensupport.h", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -39,6 +39,91 @@ struct md_rtx_info {\n   int index;\n };\n \n+#define OPTAB_CL(name, pat, c, b, l)\t\tname,\n+#define OPTAB_CX(name, pat)\n+#define OPTAB_CD(name, pat)\t\t\tname,\n+#define OPTAB_NL(name, pat, c, b, s, l)\t\tname,\n+#define OPTAB_NC(name, pat, c)\t\t\tname,\n+#define OPTAB_NX(name, pat)\n+#define OPTAB_VL(name, pat, c, b, s, l)\t\tname,\n+#define OPTAB_VC(name, pat, c)\t\t\tname,\n+#define OPTAB_VX(name, pat)\n+#define OPTAB_DC(name, pat, c)\t\t\tname,\n+#define OPTAB_D(name, pat)\t\t\tname,\n+\n+/* Enumerates all optabs.  */\n+typedef enum optab_tag {\n+  unknown_optab,\n+#include \"optabs.def\"\n+  NUM_OPTABS\n+} optab;\n+\n+#undef OPTAB_CL\n+#undef OPTAB_CX\n+#undef OPTAB_CD\n+#undef OPTAB_NL\n+#undef OPTAB_NC\n+#undef OPTAB_NX\n+#undef OPTAB_VL\n+#undef OPTAB_VC\n+#undef OPTAB_VX\n+#undef OPTAB_DC\n+#undef OPTAB_D\n+\n+/* Describes one entry in optabs.def.  */\n+struct optab_def\n+{\n+  /* The name of the optab (e.g. \"add_optab\").  */\n+  const char *name;\n+\n+  /* The pattern that matching define_expands and define_insns have.\n+     See the comment at the head of optabs.def for details.  */\n+  const char *pattern;\n+\n+  /* The initializers (in the form of C code) for the libcall_basename,\n+     libcall_suffix and libcall_gen fields of (convert_)optab_libcall_d.  */\n+  const char *base;\n+  const char *suffix;\n+  const char *libcall;\n+\n+  /* The optab's enum value.  */\n+  unsigned int op;\n+\n+  /* The value returned by optab_to_code (OP).  */\n+  enum rtx_code fcode;\n+\n+  /* CODE if code_to_optab (CODE) should return OP, otherwise UNKNOWN.  */\n+  enum rtx_code rcode;\n+\n+  /* 1: conversion optabs with libcall data,\n+     2: conversion optabs without libcall data,\n+     3: non-conversion optabs with libcall data (\"normal\" and \"overflow\"\n+        optabs in the optabs.def comment)\n+     4: non-conversion optabs without libcall data (\"direct\" optabs).  */\n+  unsigned int kind;\n+};\n+\n+extern optab_def optabs[];\n+extern unsigned int num_optabs;\n+\n+/* Information about an instruction name that matches an optab pattern.  */\n+struct optab_pattern\n+{\n+  /* The name of the instruction.  */\n+  const char *name;\n+\n+  /* The matching optab.  */\n+  unsigned int op;\n+\n+  /* The optab modes.  M2 is only significant for conversion optabs;\n+     it is zero otherwise.  */\n+  unsigned int m1, m2;\n+\n+  /* An index that provides a lexicographical sort of (OP, M2, M1).\n+     Used by genopinit.c.  */\n+  unsigned int sort_num;\n+};\n+\n extern rtx add_implicit_parallel (rtvec);\n extern bool init_rtx_reader_args_cb (int, char **, bool (*)(const char *));\n extern bool init_rtx_reader_args (int, char **);\n@@ -135,5 +220,6 @@ extern void compute_test_codes (rtx, file_location, char *);\n extern file_location get_file_location (rtx);\n extern const char *get_emit_function (rtx);\n extern bool needs_barrier_p (rtx);\n+extern bool find_optab (optab_pattern *, const char *);\n \n #endif /* GCC_GENSUPPORT_H */"}, {"sha": "8feb3942ac5fa893ac323d5bae216d4108e1fcf9", "filename": "gcc/optabs.def", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886456e210ef12d77f625ace8f312ab23d208aff/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=886456e210ef12d77f625ace8f312ab23d208aff", "patch": "@@ -17,8 +17,29 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Entries here are categorized C, D, N, V.  See genopinit.c for details\n-   on the meaning of the categories and for the pattern dollar codes.  */\n+/* The entries in optabs.def are categorized:\n+     C: A \"conversion\" optab, which uses two modes; has libcall data.\n+     N: A \"normal\" optab, which uses one mode; has libcall data.\n+     D: A \"direct\" optab, which uses one mode; does not have libcall data.\n+     V: An \"oVerflow\" optab.  Like N, but does not record its code in\n+        code_to_optab.\n+\n+     CX, NX, VX: An extra pattern entry for a conversion or normal optab.\n+\n+   These patterns may be present in the MD file with names that contain\n+   the mode(s) used and the name of the operation.  This array contains\n+   a list of optabs that need to be initialized.  Within each name,\n+   $a and $b are used to match a short mode name (the part of the mode\n+   name not including `mode' and converted to lower-case).\n+\n+   $I means that only full integer modes should be considered for the\n+   next mode, and $F means that only float modes should be considered.\n+   $P means that both full and partial integer modes should be considered.\n+   $Q means that only fixed-point modes should be considered.\n+\n+   The pattern may be NULL if the optab exists only for the libcalls\n+   that we plan to attach to it, and there are no named patterns in\n+   the md files.  */\n \n /* The extension libcalls are used for float extension.  */\n OPTAB_CL(sext_optab, \"extend$b$a2\", SIGN_EXTEND, \"extend\", gen_extend_conv_libfunc)"}]}