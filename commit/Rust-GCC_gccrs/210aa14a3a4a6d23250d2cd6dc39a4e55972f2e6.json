{"sha": "210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEwYWExNGEzYTRhNmQyMzI1MGQyY2Q2ZGMzOWE0ZTU1OTcyZjJlNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-30T03:54:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-30T03:54:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r635", "tree": {"sha": "e0d18c2398f739db2bcce7aab6aff331cea95025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d18c2398f739db2bcce7aab6aff331cea95025"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6/comments", "author": null, "committer": null, "parents": [{"sha": "4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b69d2a3aeaf2766156fba35589a804ffb9d30e0"}], "stats": {"total": 120, "additions": 95, "deletions": 25}, "files": [{"sha": "3f72b3464a825e60f725059b19e37445527bb158", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=210aa14a3a4a6d23250d2cd6dc39a4e55972f2e6", "patch": "@@ -20,6 +20,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <stdio.h>\n #include \"config.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -1425,6 +1426,7 @@ output_block_move (operands)\n   rtx sizertx = operands[2];\n   rtx alignrtx = operands[3];\n   int align = INTVAL (alignrtx);\n+  char label3[30], label5[30];\n \n   xoperands[0] = operands[0];\n   xoperands[1] = operands[1];\n@@ -1523,6 +1525,9 @@ output_block_move (operands)\n   xoperands[4] = gen_rtx (CONST_INT, VOIDmode, align);\n   xoperands[5] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n \n+  ASM_GENERATE_INTERNAL_LABEL (label3, \"Lm\", INTVAL (xoperands[3]));\n+  ASM_GENERATE_INTERNAL_LABEL (label5, \"Lm\", INTVAL (xoperands[5]));\n+\n   /* This is the size of the transfer.  Emit code to decrement the size\n      value by ALIGN, and store the result in the temp1 register.  */\n   output_size_for_block_move (sizertx, temp1, alignrtx);\n@@ -1538,11 +1543,12 @@ output_block_move (operands)\n      be a harmless insn between the branch here and the next label emitted\n      below.  */\n \n-#ifdef NO_UNDERSCORES\n-  output_asm_insn (\"cmp %2,0\\n\\tbl .Lm%5\", xoperands);\n-#else\n-  output_asm_insn (\"cmp %2,0\\n\\tbl Lm%5\", xoperands);\n-#endif\n+  {\n+    char pattern[100];\n+\n+    sprintf (pattern, \"cmp %%2,0\\n\\tbl %s\", &label5[1]);\n+    output_asm_insn (pattern, xoperands);\n+  }\n \n   zoperands[0] = operands[0];\n   zoperands[3] = plus_constant_for_output (operands[0], align);\n@@ -1558,29 +1564,18 @@ output_block_move (operands)\n \n   /* Output the first label separately, so that it is spaced properly.  */\n \n-#ifdef NO_UNDERSCORES\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \".Lm\", INTVAL (xoperands[3]));\n-#else\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"Lm\", INTVAL (xoperands[3]));\n-#endif\n \n-#ifdef NO_UNDERSCORES\n-  if (align == 1)\n-    output_asm_insn (\"ldub [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tstb %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n-  else if (align == 2)\n-    output_asm_insn (\"lduh [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tsth %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n-  else\n-    output_asm_insn (\"ld [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge .Lm%3\\n\\tst %%g1,[%0+%2]\\n.Lm%5:\", xoperands);\n-  return \"\";\n-#else\n-  if (align == 1)\n-    output_asm_insn (\"ldub [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tstb %%g1,[%0+%2]\\nLm%5:\", xoperands);\n-  else if (align == 2)\n-    output_asm_insn (\"lduh [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tsth %%g1,[%0+%2]\\nLm%5:\", xoperands);\n-  else\n-    output_asm_insn (\"ld [%1+%2],%%g1\\n\\tsubcc %2,%4,%2\\n\\tbge Lm%3\\n\\tst %%g1,[%0+%2]\\nLm%5:\", xoperands);\n+  {\n+    char pattern[200];\n+    register char *ld_suffix = (align == 1) ? \"ub\" : (align == 2) ? \"uh\" : \"\";\n+    register char *st_suffix = (align == 1) ? \"b\" : (align == 2) ? \"h\" : \"\";\n+\n+    sprintf (pattern, \"ld%s [%%1+%%2],%%%%g1\\n\\tsubcc %%2,%%4,%%2\\n\\tbge %s\\n\\tst%s %%%%g1,[%%0+%%2]\\n%s:\", ld_suffix, &label3[1], st_suffix, &label5[1]);\n+    output_asm_insn (pattern, xoperands);\n+  }\n+\n   return \"\";\n-#endif\n }\n \f\n /* Output reasonable peephole for set-on-condition-code insns.\n@@ -2571,4 +2566,79 @@ output_double_int (file, value)\n   else\n     abort ();\n }\n+\f\n+/* Compute the code to put in the .proc statement\n+   for a function that returns type TYPE.  */\n+\n+unsigned long\n+sparc_type_code (type)\n+     register tree type;\n+{\n+  register unsigned long qualifiers = 0;\n+  register unsigned shift = 6;\n+\n+  for (;;)\n+    {\n+      switch (TREE_CODE (type))\n+\t{\n+\tcase ERROR_MARK:\n+\t  return qualifiers;\n+  \n+\tcase ARRAY_TYPE:\n+\t  qualifiers |= (3 << shift);\n+\t  shift += 2;\n+\t  type = TREE_TYPE (type);\n+\t  break;\n+\n+\tcase FUNCTION_TYPE:\n+\tcase METHOD_TYPE:\n+\t  qualifiers |= (2 << shift);\n+\t  shift += 2;\n+\t  type = TREE_TYPE (type);\n+\t  break;\n+\n+\tcase POINTER_TYPE:\n+\tcase REFERENCE_TYPE:\n+\tcase OFFSET_TYPE:\n+\t  qualifiers |= (1 << shift);\n+\t  shift += 2;\n+\t  type = TREE_TYPE (type);\n+\t  break;\n \n+\tcase RECORD_TYPE:\n+\t  return (qualifiers | 8);\n+\n+\tcase UNION_TYPE:\n+\t  return (qualifiers | 9);\n+\n+\tcase ENUMERAL_TYPE:\n+\t  return (qualifiers | 10);\n+\n+\tcase VOID_TYPE:\n+\t  return (qualifiers | 16);\n+\n+\tcase INTEGER_TYPE:\n+        /* This return value is not always completely the same as Sun's\n+           but the Sun assembler's peephole optimizer probably doesn't\n+           care.  */\n+        return (qualifiers | 4);\n+  \n+\tcase REAL_TYPE:\n+\t  if (TYPE_PRECISION (type) == 32)\n+\t    return (qualifiers | 6);\n+\t  else\n+\t    return (qualifiers | 7);\t/* Who knows? */\n+  \n+\tcase COMPLEX_TYPE:\t/* GNU Fortran COMPLEX type.  */\n+\tcase CHAR_TYPE:\t\t/* GNU Pascal CHAR type.  Not used in C.  */\n+\tcase BOOLEAN_TYPE:\t/* GNU Fortran BOOLEAN type.  */\n+\tcase FILE_TYPE:\t\t/* GNU Pascal FILE type.  */\n+\tcase STRING_TYPE:\t/* GNU Fortran STRING type. */\n+\tcase LANG_TYPE:\t\t/* ? */\n+\t  abort ();\n+  \n+\tdefault:\n+\t  abort ();\t\t/* Not a type! */\n+        }\n+    }\n+}"}]}