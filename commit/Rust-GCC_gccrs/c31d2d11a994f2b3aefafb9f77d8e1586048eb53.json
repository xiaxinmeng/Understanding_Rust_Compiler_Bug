{"sha": "c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxZDJkMTFhOTk0ZjJiM2FlZmFmYjlmNzdkOGUxNTg2MDQ4ZWI1Mw==", "commit": {"author": {"name": "Robert Suchanek", "email": "robert.suchanek@imgtec.com", "date": "2014-06-18T19:50:00Z"}, "committer": {"name": "Matthew Fortune", "email": "mpf@gcc.gnu.org", "date": "2014-06-18T19:50:00Z"}, "message": "Add support for reloading a frame address with an invalid base\n\ngcc/\n\n\t* lra-constraints.c (base_to_reg): New function.\n\t(process_address): Use new function.\n\nFrom-SVN: r211802", "tree": {"sha": "389f1006b29e705c3c3e92328e7820427aa705ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/389f1006b29e705c3c3e92328e7820427aa705ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31d2d11a994f2b3aefafb9f77d8e1586048eb53/comments", "author": null, "committer": null, "parents": [{"sha": "786077082ee3d554cc3dc22212b77c67e378d3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786077082ee3d554cc3dc22212b77c67e378d3aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786077082ee3d554cc3dc22212b77c67e378d3aa"}], "stats": {"total": 49, "additions": 47, "deletions": 2}, "files": [{"sha": "988122e825eb6425363b7872e0b02e572e5d1eba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31d2d11a994f2b3aefafb9f77d8e1586048eb53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31d2d11a994f2b3aefafb9f77d8e1586048eb53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "patch": "@@ -1,3 +1,8 @@\n+2014-06-18  Robert Suchanek  <robert.suchanek@imgtec.com>\n+\n+\t* lra-constraints.c (base_to_reg): New function.       \n+\t(process_address): Use new function.                   \n+\n 2014-06-18  Tom de Vries  <tom@codesourcery.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_emit_call_insn): Declare."}, {"sha": "baed7e7d57c2e8840bd52bb74d24a27b0fd4a13d", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31d2d11a994f2b3aefafb9f77d8e1586048eb53/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31d2d11a994f2b3aefafb9f77d8e1586048eb53/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=c31d2d11a994f2b3aefafb9f77d8e1586048eb53", "patch": "@@ -2556,6 +2556,39 @@ process_alt_operands (int only_alternative)\n   return ok_p;\n }\n \n+/* Make reload base reg from address AD.  */\n+static rtx\n+base_to_reg (struct address_info *ad)\n+{\n+  enum reg_class cl;\n+  int code = -1;\n+  rtx new_inner = NULL_RTX;\n+  rtx new_reg = NULL_RTX;\n+  rtx insn;\n+  rtx last_insn = get_last_insn();\n+\n+  lra_assert (ad->base == ad->base_term && ad->disp == ad->disp_term);\n+  cl = base_reg_class (ad->mode, ad->as, ad->base_outer_code,\n+                       get_index_code (ad));\n+  new_reg = lra_create_new_reg (GET_MODE (*ad->base_term), NULL_RTX,\n+                                cl, \"base\");\n+  new_inner = simplify_gen_binary (PLUS, GET_MODE (new_reg), new_reg,\n+                                   ad->disp_term == NULL\n+                                   ? gen_int_mode (0, ad->mode)\n+                                   : *ad->disp_term);\n+  if (!valid_address_p (ad->mode, new_inner, ad->as))\n+    return NULL_RTX;\n+  insn = emit_insn (gen_rtx_SET (ad->mode, new_reg, *ad->base_term));\n+  code = recog_memoized (insn);\n+  if (code < 0)\n+    {\n+      delete_insns_since (last_insn);\n+      return NULL_RTX;\n+    }\n+\n+  return new_inner;\n+}\n+\n /* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n static rtx\n base_plus_disp_to_reg (struct address_info *ad)\n@@ -2775,6 +2808,8 @@ process_address_1 (int nop, rtx *before, rtx *after)\n \n      3) the address is a frame address with an invalid offset.\n \n+     4) the address is a frame address with an invalid base.\n+\n      All these cases involve a non-autoinc address, so there is no\n      point revalidating other types.  */\n   if (ad.autoinc_p || valid_address_p (&ad))\n@@ -2856,14 +2891,19 @@ process_address_1 (int nop, rtx *before, rtx *after)\n       int regno;\n       enum reg_class cl;\n       rtx set, insns, last_insn;\n+      /* Try to reload base into register only if the base is invalid\n+         for the address but with valid offset, case (4) above.  */\n+      start_sequence ();\n+      new_reg = base_to_reg (&ad);\n+\n       /* base + disp => new base, cases (1) and (3) above.  */\n       /* Another option would be to reload the displacement into an\n \t index register.  However, postreload has code to optimize\n \t address reloads that have the same base and different\n \t displacements, so reloading into an index register would\n \t not necessarily be a win.  */\n-      start_sequence ();\n-      new_reg = base_plus_disp_to_reg (&ad);\n+      if (new_reg == NULL_RTX)\n+        new_reg = base_plus_disp_to_reg (&ad);\n       insns = get_insns ();\n       last_insn = get_last_insn ();\n       /* If we generated at least two insns, try last insn source as"}]}