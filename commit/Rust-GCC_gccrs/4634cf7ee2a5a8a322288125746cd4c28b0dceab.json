{"sha": "4634cf7ee2a5a8a322288125746cd4c28b0dceab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzNGNmN2VlMmE1YThhMzIyMjg4MTI1NzQ2Y2Q0YzI4YjBkY2VhYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-01-08T16:13:22Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-01-08T16:13:22Z"}, "message": "tree.c (int_fits_type_p): Always honor integer constant TYPE_MIN_VALUE and TYPE_MAX_VALUE if they exist.\n\n\n\t* tree.c (int_fits_type_p): Always honor integer constant\n\tTYPE_MIN_VALUE and TYPE_MAX_VALUE if they exist.\n\nFrom-SVN: r93086", "tree": {"sha": "153da8865020a4a1dbf41c9ed27dbb1b38b0cfec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/153da8865020a4a1dbf41c9ed27dbb1b38b0cfec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4634cf7ee2a5a8a322288125746cd4c28b0dceab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4634cf7ee2a5a8a322288125746cd4c28b0dceab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4634cf7ee2a5a8a322288125746cd4c28b0dceab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4634cf7ee2a5a8a322288125746cd4c28b0dceab/comments", "author": null, "committer": null, "parents": [{"sha": "88c0f1c63f152af3577ed3a99f37db01995bd22d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c0f1c63f152af3577ed3a99f37db01995bd22d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c0f1c63f152af3577ed3a99f37db01995bd22d"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "f1133b36da861b497eb1a9aed3df7a7ff3b54445", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4634cf7ee2a5a8a322288125746cd4c28b0dceab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4634cf7ee2a5a8a322288125746cd4c28b0dceab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4634cf7ee2a5a8a322288125746cd4c28b0dceab", "patch": "@@ -1,3 +1,8 @@\n+2005-01-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.c (int_fits_type_p): Always honor integer constant\n+\tTYPE_MIN_VALUE and TYPE_MAX_VALUE if they exist.\n+\n 2005-01-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* ifcvt.c (find_if_case_1): Reinstate 2005-01-04 change, now that"}, {"sha": "39309ffbfe512f9cf626b259c592c4b91e7f4bd9", "filename": "gcc/tree.c", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4634cf7ee2a5a8a322288125746cd4c28b0dceab/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4634cf7ee2a5a8a322288125746cd4c28b0dceab/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4634cf7ee2a5a8a322288125746cd4c28b0dceab", "patch": "@@ -4874,23 +4874,8 @@ int_fits_type_p (tree c, tree type)\n {\n   tree type_low_bound = TYPE_MIN_VALUE (type);\n   tree type_high_bound = TYPE_MAX_VALUE (type);\n-  int ok_for_low_bound, ok_for_high_bound;\n-\n-  /* Perform some generic filtering first, which may allow making a decision\n-     even if the bounds are not constant.  First, negative integers never fit\n-     in unsigned types, */\n-  if (TYPE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n-    return 0;\n-\n-  /* Second, narrower types always fit in wider ones.  */\n-  if (TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (c)))\n-    return 1;\n-\n-  /* Third, unsigned integers with top bit set never fit signed types.  */\n-  if (! TYPE_UNSIGNED (type)\n-      && TYPE_UNSIGNED (TREE_TYPE (c))\n-      && tree_int_cst_msb (c))\n-    return 0;\n+  bool ok_for_low_bound, ok_for_high_bound;\n+  tree tmp;\n \n   /* If at least one bound of the type is a constant integer, we can check\n      ourselves and maybe make a decision. If no such decision is possible, but\n@@ -4902,43 +4887,57 @@ int_fits_type_p (tree c, tree type)\n      for \"unknown if constant fits\", 0 for \"constant known *not* to fit\" and 1\n      for \"constant known to fit\".  */\n \n-  ok_for_low_bound = -1;\n-  ok_for_high_bound = -1;\n-\n   /* Check if C >= type_low_bound.  */\n   if (type_low_bound && TREE_CODE (type_low_bound) == INTEGER_CST)\n     {\n-      ok_for_low_bound = ! tree_int_cst_lt (c, type_low_bound);\n-      if (! ok_for_low_bound)\n+      if (tree_int_cst_lt (c, type_low_bound))\n \treturn 0;\n+      ok_for_low_bound = true;\n     }\n+  else\n+    ok_for_low_bound = false;\n \n   /* Check if c <= type_high_bound.  */\n   if (type_high_bound && TREE_CODE (type_high_bound) == INTEGER_CST)\n     {\n-      ok_for_high_bound = ! tree_int_cst_lt (type_high_bound, c);\n-      if (! ok_for_high_bound)\n+      if (tree_int_cst_lt (type_high_bound, c))\n \treturn 0;\n+      ok_for_high_bound = true;\n     }\n+  else\n+    ok_for_high_bound = false;\n \n   /* If the constant fits both bounds, the result is known.  */\n-  if (ok_for_low_bound == 1 && ok_for_high_bound == 1)\n+  if (ok_for_low_bound && ok_for_high_bound)\n     return 1;\n \n+  /* Perform some generic filtering which may allow making a decision\n+     even if the bounds are not constant.  First, negative integers\n+     never fit in unsigned types, */\n+  if (TYPE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n+    return 0;\n+\n+  /* Second, narrower types always fit in wider ones.  */\n+  if (TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (c)))\n+    return 1;\n+\n+  /* Third, unsigned integers with top bit set never fit signed types.  */\n+  if (! TYPE_UNSIGNED (type)\n+      && TYPE_UNSIGNED (TREE_TYPE (c))\n+      && tree_int_cst_msb (c))\n+    return 0;\n+\n   /* If we haven't been able to decide at this point, there nothing more we\n      can check ourselves here. Look at the base type if we have one.  */\n-  else if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != 0)\n+  if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != 0)\n     return int_fits_type_p (c, TREE_TYPE (type));\n \n   /* Or to force_fit_type, if nothing else.  */\n-  else\n-    {\n-      tree n = copy_node (c);\n-      TREE_TYPE (n) = type;\n-      n = force_fit_type (n, -1, false, false);\n-      return TREE_INT_CST_HIGH (n) == TREE_INT_CST_HIGH (c)\n-             && TREE_INT_CST_LOW (n) == TREE_INT_CST_LOW (c);\n-    }\n+  tmp = copy_node (c);\n+  TREE_TYPE (tmp) = type;\n+  tmp = force_fit_type (tmp, -1, false, false);\n+  return TREE_INT_CST_HIGH (tmp) == TREE_INT_CST_HIGH (c)\n+         && TREE_INT_CST_LOW (tmp) == TREE_INT_CST_LOW (c);\n }\n \n /* Subprogram of following function.  Called by walk_tree."}]}