{"sha": "64fde7010b6a3a678df227c06df09815d3aaec2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRmZGU3MDEwYjZhM2E2NzhkZjIyN2MwNmRmMDk4MTVkM2FhZWMyYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-11-09T08:35:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-09T08:35:46Z"}, "message": "flags.h (flag_rerun_loop_opt): Declare.\n\n        * flags.h (flag_rerun_loop_opt): Declare.\n        * loop.c (invariant_p, case LABEL_REF): Check flag_rerun_loop_opt.\n        * toplev.c (flag_rerum_loop_opt): Delete static.\n\nFrom-SVN: r16389", "tree": {"sha": "12af167c241103efc33f01c8678cdd994064d5a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12af167c241103efc33f01c8678cdd994064d5a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64fde7010b6a3a678df227c06df09815d3aaec2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64fde7010b6a3a678df227c06df09815d3aaec2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64fde7010b6a3a678df227c06df09815d3aaec2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64fde7010b6a3a678df227c06df09815d3aaec2b/comments", "author": null, "committer": null, "parents": [{"sha": "69f9c1f69e285e99979f61452634874744998481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f9c1f69e285e99979f61452634874744998481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f9c1f69e285e99979f61452634874744998481"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "aaaa939c8210903b4dc74b2220db331fc1156407", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64fde7010b6a3a678df227c06df09815d3aaec2b", "patch": "@@ -1,3 +1,9 @@\n+Sun Nov  9 01:37:11 1997  Jim Wilson  (wilson@cygnus.com)\n+\n+\t* flags.h (flag_rerun_loop_opt): Declare.\n+\t* loop.c (invariant_p, case LABEL_REF): Check flag_rerun_loop_opt.\n+\t* toplev.c (flag_rerum_loop_opt): Delete static.\n+\n Sat Nov  8 18:20:21 1997  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.h (ENABLE_REGMOVE_PASS): Define."}, {"sha": "ba057204dede483656eeeb5295fb2bb532ee5b32", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=64fde7010b6a3a678df227c06df09815d3aaec2b", "patch": "@@ -275,6 +275,10 @@ extern int flag_volatile_global;\n \n extern int flag_fast_math;\n \n+/* Nonzero means to run loop optimizations twice.  */\n+\n+extern int flag_rerun_loop_opt;\n+\n /* Nonzero means make functions that look like good inline candidates\n    go inline.  */\n "}, {"sha": "e43d58518d167aae9648ea46cb1b0e49d540915a", "filename": "gcc/loop.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=64fde7010b6a3a678df227c06df09815d3aaec2b", "patch": "@@ -2847,7 +2847,12 @@ invariant_p (x)\n \n \t We don't know the loop bounds here though, so just fail for all\n \t labels.  */\n-      if (flag_unroll_loops)\n+      /* ??? This is also necessary if flag_rerun_loop_opt is true, because in\n+\t this case we may be doing loop unrolling the second time we run loop,\n+\t and hence the first loop run also needs this check.  There is no way\n+\t to check here whether the second run will actually do loop unrolling\n+\t though, as that info is in a local var in rest_of_compilation.  */\n+      if (flag_unroll_loops || flag_rerun_loop_opt)\n \treturn 0;\n       else\n \treturn 1;"}, {"sha": "aeffbb3a85c83bfb2466fa75b4994c9dea5bc3fe", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fde7010b6a3a678df227c06df09815d3aaec2b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=64fde7010b6a3a678df227c06df09815d3aaec2b", "patch": "@@ -508,7 +508,7 @@ static int flag_rerun_cse_after_loop;\n \n /* Nonzero means to run loop optimizations twice.  */\n \n-static int flag_rerun_loop_opt;\n+int flag_rerun_loop_opt;\n \n /* Nonzero for -finline-functions: ok to inline functions that look like\n    good inline candidates.  */"}]}