{"sha": "180295ed63192b951a6ed9dae07eefc7fd55a3d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwMjk1ZWQ2MzE5MmI5NTFhNmVkOWRhZTA3ZWVmYzdmZDU1YTNkMQ==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@tuliptree.org", "date": "2017-10-29T22:45:41Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2017-10-29T22:45:41Z"}, "message": "Delete obsolete SDB debug info support.\n\n\tgcc/\n\t* Makefile.in (OBJS): Delete sdbout.o.\n\t(GTFILES): Delete $(srcdir)/sdbout.c.\n\t* debug.h: Delete sdb_debug_hooks.\n\t* final.c: Delete sdbout.h include.\n\t(final_scan_insn): Delete SDB_DEBUG check.\n\t(rest_of_clean_state): Likewise.\n\t* output.h: Delete sdb_begin_function_line.\n\t* sdbout.c: Delete.\n\t* sdbout.h: Delete.\n\t* toplev.c: Delete sdbout.h include.\n\t(process_options): Delete SDB_DEBUG check.\n\t* tree-core.h (tree_type_common): Delete pointer field of\n\ttree_type_symtab.\n\t* tree.c (copy_node): Clear TYPE_SYMTAB_DIE instead of\n\tTYPE_SYMTAB_POINTER.\n\t* tree.h (TYPE_SYMTAB_POINTER): Delete.\n\t(TYPE_SYMTAB_IS_POINTER): Delete.\n\t(TYPE_SYMTAB_IS_DIE): Renumber.\n\t* xcoffout.c: Refer to former sdbout.c file.\n\t(xcoffout_begin_prologue): Use past tense for sdbout.c reference.\n\n\t* doc/install.texi (--with-stabs): Delete COFF and ECOFF info.\n\t* doc/invoke.texi (SEEALSO): Delete adb and sdb references.\n\t(Debugging Options): Delete -gcoff.\n\t(-gstabs): Delete SDB reference.\n\t(-gcoff): Delete.\n\t(-gcoff@var{level}): Delete.\n\t* doc/passes.texi (Debugging information output): Delete SDB and\n\tsdbout.c references.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (DWARF_CIE_DATA_ALIGNMENT): Delete SDB from xref.\n\t(SDB and DWARF): Change node name to DWARF and delete SDB and COFF\n\treferences.\n\t(DEBUGGER_AUTO_OFFSET): Delete COFF and SDB references.\n\t(PREFERRED_DEBUGGING_TYPE): Delete SDB_DEBUG and -gcoff references.\n\t(SDB_DEBUGGING_INFO): Delete.\n\t(PUT_SDB_@dots{}, SDB_DELIM, SDB_ALLOW_UNKNOWN_REFERENCES)\n\tSDB_ALLOW_FORWARD_REFERENCES, SDB_OUTPUT_SOURCE_LINE): Delete.\n\t* target.def (output_source_filename): Delete COFF reference.\n\n\t* common.opt (gcoff): Delete.\n\t(gxcoff+): Update Negative chain.\n\t* defaults.h: Delete all references to SDB_DEBUGGING_INFO and\n\tSDB_DEBUG.\n\t* dwarf2out.c (gen_array_type_die): Change SDB to debuggers.\n\t* flag-types.h (enum debug_info_type): Delete SDB_DEBUG.\n\t* function.c (number_blocks): Delete SDB_DEBUGGING_INFO, SDB_DEBUG,\n\tand SDB references.\n\t(expand_function_start): Change sdb reference to past tense.\n\t(expand_function_end): Change sdb reference to past tense.\n\t* gcc.c (cpp_unique_options): Delete gcoff3 reference.\n\t* opts.c (debug_type_names): Delete coff entry.\n\t(common_handle_option): Delete OPT_gcoff case.\n\t* system.h (SDB_DEBUG, SDB_DEBUGGING_INFO): Poison.\n\n\t* config/dbxcoff.h (PREFERRED_DEBUGGING_TYPE): Set to DBX_DEBUG.\n\t* config/cris/cris.h: Delete SDB reference in comment.\n\t* config/i386/cygming.h: Don't define SDB_DEBUGGING_INFO.\n\t(ASM_DECLARE_FUNCTION_NAME): Delete SDB reference from comment.\n\t* config/i386/gas.h: Don't define SDB_DEBUGGING_INFO.\n\t* config/i386/i386.c (svr4_dbx_register_map): Change SDB references\n\tto past tense.\n\t(ix86_expand_prologue): Likewise.\n\t* config/i386/winnt.c (i386_pe_start_function): Don't check SDB_DEBUG.\n\t* config/ia64/ia64.h: Likewise.\n\t* config/m68k/m68kelf.h (DBX_REGISTER_NUMBER): Delete SDB reference.\n\t* config/mips/mips.h (SUBTARGET_ASM_DEBUGGING_SPEC): Delete gcoff*\n\tsupport.\n\t* config/mmix/mmix.h: Likewise.\n\t* config/nds32/nds32.c: Likewise.\n\t* config/stormy/storym16.h: Likewise.\n\t* config/visium/visium.h: Likewise.\n\t* config/vx-common.h (SDB_DEBUGGING_INFO): Delete undef.\n\n\tgcc/fortran/\n\t* invoke.texi: Delete adb and sdb references.\n\n\tgccc/testsuite/\n\t* lib/gcc-dg.exp (gcc-dg-debug-runtest): Delete -gcoff.\n\t* lib/gfortran-dg.exp (gfortran-dg-debug-runtest): Delete\n\t-gcoff.\n\nFrom-SVN: r254206", "tree": {"sha": "e6ae923948b53e9d5fb61161023e0929f1c6519b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6ae923948b53e9d5fb61161023e0929f1c6519b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/180295ed63192b951a6ed9dae07eefc7fd55a3d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180295ed63192b951a6ed9dae07eefc7fd55a3d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/180295ed63192b951a6ed9dae07eefc7fd55a3d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180295ed63192b951a6ed9dae07eefc7fd55a3d1/comments", "author": {"login": "jim-wilson", "id": 11654017, "node_id": "MDQ6VXNlcjExNjU0MDE3", "avatar_url": "https://avatars.githubusercontent.com/u/11654017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jim-wilson", "html_url": "https://github.com/jim-wilson", "followers_url": "https://api.github.com/users/jim-wilson/followers", "following_url": "https://api.github.com/users/jim-wilson/following{/other_user}", "gists_url": "https://api.github.com/users/jim-wilson/gists{/gist_id}", "starred_url": "https://api.github.com/users/jim-wilson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jim-wilson/subscriptions", "organizations_url": "https://api.github.com/users/jim-wilson/orgs", "repos_url": "https://api.github.com/users/jim-wilson/repos", "events_url": "https://api.github.com/users/jim-wilson/events{/privacy}", "received_events_url": "https://api.github.com/users/jim-wilson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7719f04695a5acf661ebd9229215eb9ce8c2bf5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7719f04695a5acf661ebd9229215eb9ce8c2bf5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7719f04695a5acf661ebd9229215eb9ce8c2bf5f"}], "stats": {"total": 2089, "additions": 160, "deletions": 1929}, "files": [{"sha": "0af15fcd7e25247490c513aa01f0706a9367849b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1,3 +1,79 @@\n+2017-10-29  Jim Wilson  <wilson@tuliptree.org>\n+\n+\t* Makefile.in (OBJS): Delete sdbout.o.\n+\t(GTFILES): Delete $(srcdir)/sdbout.c.\n+\t* debug.h: Delete sdb_debug_hooks.\n+\t* final.c: Delete sdbout.h include.\n+\t(final_scan_insn): Delete SDB_DEBUG check.\n+\t(rest_of_clean_state): Likewise.\n+\t* output.h: Delete sdb_begin_function_line.\n+\t* sdbout.c: Delete.\n+\t* sdbout.h: Delete.\n+\t* toplev.c: Delete sdbout.h include.\n+\t(process_options): Delete SDB_DEBUG check.\n+\t* tree-core.h (tree_type_common): Delete pointer field of\n+\ttree_type_symtab.\n+\t* tree.c (copy_node): Clear TYPE_SYMTAB_DIE instead of\n+\tTYPE_SYMTAB_POINTER.\n+\t* tree.h (TYPE_SYMTAB_POINTER): Delete.\n+\t(TYPE_SYMTAB_IS_POINTER): Delete.\n+\t(TYPE_SYMTAB_IS_DIE): Renumber.\n+\t* xcoffout.c: Refer to former sdbout.c file.\n+\t(xcoffout_begin_prologue): Use past tense for sdbout.c reference.\n+\n+\t* doc/install.texi (--with-stabs): Delete COFF and ECOFF info.\n+\t* doc/invoke.texi (SEEALSO): Delete adb and sdb references.\n+\t(Debugging Options): Delete -gcoff.\n+\t(-gstabs): Delete SDB reference.\n+\t(-gcoff): Delete.\n+\t(-gcoff@var{level}): Delete.\n+\t* doc/passes.texi (Debugging information output): Delete SDB and\n+\tsdbout.c references.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (DWARF_CIE_DATA_ALIGNMENT): Delete SDB from xref.\n+\t(SDB and DWARF): Change node name to DWARF and delete SDB and COFF\n+\treferences.\n+\t(DEBUGGER_AUTO_OFFSET): Delete COFF and SDB references.\n+\t(PREFERRED_DEBUGGING_TYPE): Delete SDB_DEBUG and -gcoff references.\n+\t(SDB_DEBUGGING_INFO): Delete.\n+\t(PUT_SDB_@dots{}, SDB_DELIM, SDB_ALLOW_UNKNOWN_REFERENCES)\n+\tSDB_ALLOW_FORWARD_REFERENCES, SDB_OUTPUT_SOURCE_LINE): Delete.\n+\t* target.def (output_source_filename): Delete COFF reference.\n+\n+\t* common.opt (gcoff): Delete.\n+\t(gxcoff+): Update Negative chain.\n+\t* defaults.h: Delete all references to SDB_DEBUGGING_INFO and\n+\tSDB_DEBUG.\n+\t* dwarf2out.c (gen_array_type_die): Change SDB to debuggers.\n+\t* flag-types.h (enum debug_info_type): Delete SDB_DEBUG.\n+\t* function.c (number_blocks): Delete SDB_DEBUGGING_INFO, SDB_DEBUG,\n+\tand SDB references.\n+\t(expand_function_start): Change sdb reference to past tense.\n+\t(expand_function_end): Change sdb reference to past tense.\n+\t* gcc.c (cpp_unique_options): Delete gcoff3 reference.\n+\t* opts.c (debug_type_names): Delete coff entry.\n+\t(common_handle_option): Delete OPT_gcoff case.\n+\t* system.h (SDB_DEBUG, SDB_DEBUGGING_INFO): Poison.\n+\n+\t* config/dbxcoff.h (PREFERRED_DEBUGGING_TYPE): Set to DBX_DEBUG.\n+\t* config/cris/cris.h: Delete SDB reference in comment.\n+\t* config/i386/cygming.h: Don't define SDB_DEBUGGING_INFO.\n+\t(ASM_DECLARE_FUNCTION_NAME): Delete SDB reference from comment.\n+\t* config/i386/gas.h: Don't define SDB_DEBUGGING_INFO.\n+\t* config/i386/i386.c (svr4_dbx_register_map): Change SDB references\n+\tto past tense.\n+\t(ix86_expand_prologue): Likewise.\n+\t* config/i386/winnt.c (i386_pe_start_function): Don't check SDB_DEBUG.\n+\t* config/ia64/ia64.h: Likewise.\n+\t* config/m68k/m68kelf.h (DBX_REGISTER_NUMBER): Delete SDB reference.\n+\t* config/mips/mips.h (SUBTARGET_ASM_DEBUGGING_SPEC): Delete gcoff*\n+\tsupport.\n+\t* config/mmix/mmix.h: Likewise.\n+\t* config/nds32/nds32.c: Likewise.\n+\t* config/stormy/storym16.h: Likewise.\n+\t* config/visium/visium.h: Likewise.\n+\t* config/vx-common.h (SDB_DEBUGGING_INFO): Delete undef.\n+\n 2017-10-28  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/nios2/nios2.h (FRAME_GROWS_DOWNWARD): Define to 1."}, {"sha": "9b4cedf3df4c46c8bfaf3b4ede32e03bab9b2b23", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1446,7 +1446,6 @@ OBJS = \\\n \tsched-deps.o \\\n \tsched-ebb.o \\\n \tsched-rgn.o \\\n-\tsdbout.o \\\n \tsel-sched-ir.o \\\n \tsel-sched-dump.o \\\n \tsel-sched.o \\\n@@ -2525,7 +2524,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/lists.c $(srcdir)/optabs-libfuncs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfgrtl.c \\\n-  $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n+  $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/gimple.h \\\n   $(srcdir)/gimple-ssa.h \\"}, {"sha": "5abd32286d905a08d7c8dc3b4778846caa869856", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -2872,10 +2872,6 @@ g\n Common Driver RejectNegative JoinedOrMissing\n Generate debug information in default format.\n \n-gcoff\n-Common Driver JoinedOrMissing Negative(gdwarf)\n-Generate debug information in COFF format.\n-\n gcolumn-info\n Common Driver Var(debug_column_info,1) Init(1)\n Record DW_AT_decl_column and DW_AT_call_column in DWARF.\n@@ -2941,7 +2937,7 @@ Common Driver JoinedOrMissing Negative(gxcoff+)\n Generate debug information in XCOFF format.\n \n gxcoff+\n-Common Driver JoinedOrMissing Negative(gcoff)\n+Common Driver JoinedOrMissing Negative(gdwarf)\n Generate debug information in extended XCOFF format.\n \n Enum"}, {"sha": "892a3724393de372e37f919e8c56dc8df2861463", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -998,7 +998,7 @@ enum cris_symbol_type\n /* (no definitions) */\n \n \n-/* Node: SDB and DWARF */\n+/* Node: DWARF */\n /* (no definitions) */\n \n /* Node: Misc */"}, {"sha": "c20b4fe77b1d428a3cf8e9c43d86c10575feca7a", "filename": "gcc/config/dbxcoff.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fdbxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fdbxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdbxcoff.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -25,10 +25,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #define DBX_DEBUGGING_INFO 1\n \n-/* Generate SDB debugging information by default.  */\n+/* Generate DBX debugging information by default.  */\n \n #ifndef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n #endif\n \n /* Be function-relative for block and source line stab directives.  */"}, {"sha": "1ed9b170d435dd2034fff0825ef0c8287225d46c", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -19,7 +19,6 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #define DBX_DEBUGGING_INFO 1\n-#define SDB_DEBUGGING_INFO 1\n #if TARGET_64BIT_DEFAULT || defined (HAVE_GAS_PE_SECREL32_RELOC)\n #define DWARF2_DEBUGGING_INFO 1\n #endif\n@@ -308,8 +307,7 @@ do {\t\t\t\t\t\t\\\n #define TARGET_SECTION_TYPE_FLAGS  i386_pe_section_type_flags\n \n /* Write the extra assembler code needed to declare a function\n-   properly.  If we are generating SDB debugging information, this\n-   will happen automatically, so we only need to handle other cases.  */\n+   properly.  */\n #undef ASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n   i386_pe_start_function (FILE, NAME, DECL)"}, {"sha": "862c1c2cb83756de0bde88fc4e885f8f806419ce", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -40,10 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n #undef DBX_NO_XREFS\n #undef DBX_CONTIN_LENGTH\n \n-/* Ask for COFF symbols.  */\n-\n-#define SDB_DEBUGGING_INFO 1\n-\n /* Output #ident as a .ident.  */\n \n #undef TARGET_ASM_OUTPUT_IDENT"}, {"sha": "a66b433d78d40f4b48f00c96df88d08033395f10", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -301,28 +301,28 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n \t7 for %edi (gcc regno = 5)\n    The following three DWARF register numbers are never generated by\n    the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n-   believes these numbers have these meanings.\n+   believed these numbers have these meanings.\n \t8  for %eip    (no gcc equivalent)\n \t9  for %eflags (gcc regno = 17)\n \t10 for %trapno (no gcc equivalent)\n    It is not at all clear how we should number the FP stack registers\n    for the x86 architecture.  If the version of SDB on x86/svr4 were\n    a bit less brain dead with respect to floating-point then we would\n    have a precedent to follow with respect to DWARF register numbers\n-   for x86 FP registers, but the SDB on x86/svr4 is so completely\n+   for x86 FP registers, but the SDB on x86/svr4 was so completely\n    broken with respect to FP registers that it is hardly worth thinking\n    of it as something to strive for compatibility with.\n-   The version of x86/svr4 SDB I have at the moment does (partially)\n+   The version of x86/svr4 SDB I had does (partially)\n    seem to believe that DWARF register number 11 is associated with\n    the x86 register %st(0), but that's about all.  Higher DWARF\n    register numbers don't seem to be associated with anything in\n-   particular, and even for DWARF regno 11, SDB only seems to under-\n+   particular, and even for DWARF regno 11, SDB only seemed to under-\n    stand that it should say that a variable lives in %st(0) (when\n    asked via an `=' command) if we said it was in DWARF regno 11,\n-   but SDB still prints garbage when asked for the value of the\n+   but SDB still printed garbage when asked for the value of the\n    variable in question (via a `/' command).\n-   (Also note that the labels SDB prints for various FP stack regs\n-   when doing an `x' command are all wrong.)\n+   (Also note that the labels SDB printed for various FP stack regs\n+   when doing an `x' command were all wrong.)\n    Note that these problems generally don't affect the native SVR4\n    C compiler because it doesn't allow the use of -O with -g and\n    because when it is *not* optimizing, it allocates a memory\n@@ -13020,7 +13020,7 @@ ix86_expand_prologue (void)\n   if (frame_pointer_needed && !m->fs.fp_valid)\n     {\n       /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n-         slower on all targets.  Also sdb doesn't like it.  */\n+         slower on all targets.  Also sdb didn't like it.  */\n       insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n "}, {"sha": "61d94d264f036a8916c1410b27cfab06485b490a", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1215,8 +1215,7 @@ void\n i386_pe_start_function (FILE *f, const char *name, tree decl)\n {\n   i386_pe_maybe_record_exported_symbol (decl, name, 0);\n-  if (write_symbols != SDB_DEBUG)\n-    i386_pe_declare_function_type (f, name, TREE_PUBLIC (decl));\n+  i386_pe_declare_function_type (f, name, TREE_PUBLIC (decl));\n   /* In case section was altered by debugging output.  */\n   if (decl != NULL_TREE)\n     switch_to_section (function_section (decl));"}, {"sha": "eceab5f23b661a2c3da46c1e649561e081e65f91", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1470,7 +1470,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Likewise.  */\n \n \f\n-/* Macros for SDB and Dwarf Output.  */\n+/* Macros for Dwarf Output.  */\n \n /* Define this macro if GCC should produce dwarf version 2 format debugging\n    output in response to the `-g' option.  */"}, {"sha": "159223f64c7ab8376cb123ac98dbdb7671f6de4a", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -97,7 +97,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Define how the m68k registers should be numbered for Dwarf output.\n    The numbering provided here should be compatible with the native\n-   SVR4 SDB debugger in the m68k/SVR4 reference port, where d0-d7\n+   SVR4 debugger in the m68k/SVR4 reference port, where d0-d7\n    are 0-7, a0-a8 are 8-15, and fp0-fp7 are 16-23.  */\n \n #undef DBX_REGISTER_NUMBER"}, {"sha": "f5c28bf70e3f4ab6836dbed82033e351a81a713b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1314,9 +1314,7 @@ struct mips_cpu_info {\n %{g} %{g0} %{g1} %{g2} %{g3} \\\n %{ggdb:-g} %{ggdb0:-g0} %{ggdb1:-g1} %{ggdb2:-g2} %{ggdb3:-g3} \\\n %{gstabs:-g} %{gstabs0:-g0} %{gstabs1:-g1} %{gstabs2:-g2} %{gstabs3:-g3} \\\n-%{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3} \\\n-%{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3} \\\n-%{gcoff*:-mdebug} %{!gcoff*:-no-mdebug}\"\n+%{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3}\"\n #endif\n \n /* FP_ASM_SPEC represents the floating-point options that must be passed"}, {"sha": "2ee3592f3c8d1f0d737f3bb30d10834737374db8", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -761,7 +761,7 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n /* (empty) */\n \n \n-/* Node: SDB and DWARF */\n+/* Node: DWARF */\n #define DWARF2_DEBUGGING_INFO 1\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n "}, {"sha": "b0d5e48a6516e6ea09678c3151af10bacf186c6f", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -3763,7 +3763,7 @@ nds32_target_alignment (rtx_insn *label)\n \n /* -- File Names in DBX Format.  */\n \n-/* -- Macros for SDB and DWARF Output.  */\n+/* -- Macros for DWARF Output.  */\n \n /* -- Macros for VMS Debug Format.  */\n "}, {"sha": "1d7045759c526ca8ee57a0b050769e73faa227db", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -446,7 +446,7 @@ enum reg_class\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n \f\n-/* Macros for SDB and Dwarf Output.  */\n+/* Macros for Dwarf Output.  */\n \n /* Define this macro if addresses in Dwarf 2 debugging info should not\n    be the same size as pointers on the target architecture.  The"}, {"sha": "85735953968d558a3d934bda0ef57cfab4f2f226", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1527,9 +1527,8 @@ do\t\t\t\t\t\t\t\t\t\\\n    automatic variable having address X (an RTL expression).  The\n    default computation assumes that X is based on the frame-pointer\n    and gives the offset from the frame-pointer.  This is required for\n-   targets that produce debugging output for DBX or COFF-style\n-   debugging output for SDB and allow the frame-pointer to be\n-   eliminated when the `-g' options is used. */\n+   targets that produce debugging output for DBX and allow the frame-pointer\n+   to be eliminated when the `-g' options is used. */\n #define DEBUGGER_AUTO_OFFSET(X) \\\n   (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n "}, {"sha": "d8f04eced4d67e7b8b4d6564fcb3e7a741153c95", "filename": "gcc/config/vx-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fvx-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fconfig%2Fvx-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvx-common.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -72,7 +72,6 @@ along with GCC; see the file COPYING3.  If not see\n /* None of these other formats is supported.  */\n #undef DWARF_DEBUGGING_INFO\n #undef DBX_DEBUGGING_INFO\n-#undef SDB_DEBUGGING_INFO\n #undef XCOFF_DEBUGGING_INFO\n #undef VMS_DEBUGGING_INFO\n "}, {"sha": "19b27848ca8b86a911cb2f1c1ad685b928fcf7a4", "filename": "gcc/debug.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -228,7 +228,6 @@ extern void debug_nothing_tree_charstar_uhwi (tree, const char *,\n /* Hooks for various debug formats.  */\n extern const struct gcc_debug_hooks do_nothing_debug_hooks;\n extern const struct gcc_debug_hooks dbx_debug_hooks;\n-extern const struct gcc_debug_hooks sdb_debug_hooks;\n extern const struct gcc_debug_hooks xcoff_debug_hooks;\n extern const struct gcc_debug_hooks dwarf2_debug_hooks;\n extern const struct gcc_debug_hooks dwarf2_lineno_debug_hooks;"}, {"sha": "768c9879df9364589870409459c6bf25480269cc", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -894,14 +894,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define DEFAULT_GDB_EXTENSIONS 1\n #endif\n \n-#ifndef SDB_DEBUGGING_INFO\n-#define SDB_DEBUGGING_INFO 0\n-#endif\n-\n /* If more than one debugging type is supported, you must define\n    PREFERRED_DEBUGGING_TYPE to choose the default.  */\n \n-#if 1 < (defined (DBX_DEBUGGING_INFO) + (SDB_DEBUGGING_INFO) \\\n+#if 1 < (defined (DBX_DEBUGGING_INFO) \\\n          + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO) \\\n          + defined (VMS_DEBUGGING_INFO))\n #ifndef PREFERRED_DEBUGGING_TYPE\n@@ -913,9 +909,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #elif defined DBX_DEBUGGING_INFO\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n-#elif SDB_DEBUGGING_INFO\n-#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n-\n #elif defined DWARF2_DEBUGGING_INFO || defined DWARF2_LINENO_DEBUGGING_INFO\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n "}, {"sha": "49737ad9fc64d55f0e0b3526114fbbfcefeca31f", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1007,31 +1007,6 @@ Specify that stabs debugging\n information should be used instead of whatever format the host normally\n uses.  Normally GCC uses the same debug format as the host system.\n \n-On MIPS based systems and on Alphas, you must specify whether you want\n-GCC to create the normal ECOFF debugging format, or to use BSD-style\n-stabs passed through the ECOFF symbol table.  The normal ECOFF debug\n-format cannot fully handle languages other than C@.  BSD stabs format can\n-handle other languages, but it only works with the GNU debugger GDB@.\n-\n-Normally, GCC uses the ECOFF debugging format by default; if you\n-prefer BSD stabs, specify @option{--with-stabs} when you configure GCC@.\n-\n-No matter which default you choose when you configure GCC, the user\n-can use the @option{-gcoff} and @option{-gstabs+} options to specify explicitly\n-the debug format for a particular compilation.\n-\n-@option{--with-stabs} is meaningful on the ISC system on the 386, also, if\n-@option{--with-gas} is used.  It selects use of stabs debugging\n-information embedded in COFF output.  This kind of debugging information\n-supports C++ well; ordinary COFF debugging information does not.\n-\n-@option{--with-stabs} is also meaningful on 386 systems running SVR4.  It\n-selects use of stabs debugging information embedded in ELF output.  The\n-C++ compiler currently (2.6.0) does not support the DWARF debugging\n-information normally used on 386 SVR4 platforms; stabs provide a\n-workable alternative.  This requires gas and gdb, as the normal SVR4\n-tools can not generate or interpret stabs.\n-\n @item --with-tls=@var{dialect}\n Specify the default TLS dialect, for systems were there is a choice.\n For ARM targets, possible values for @var{dialect} are @code{gnu} or"}, {"sha": "8df09020f1472ede49bffa28d90d6fa85e2f95c2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -45,7 +45,7 @@ remainder.  @command{g++} accepts mostly the same options as @command{gcc}.\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7),\n-cpp(1), gcov(1), as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1)\n+cpp(1), gcov(1), as(1), ld(1), gdb(1), dbx(1)\n and the Info entries for @file{gcc}, @file{cpp}, @file{as},\n @file{ld}, @file{binutils} and @file{gdb}.\n @c man end\n@@ -342,7 +342,7 @@ Objective-C and Objective-C++ Dialects}.\n \n @item Debugging Options\n @xref{Debugging Options,,Options for Debugging Your Program}.\n-@gccoptlist{-g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-@var{version} @gol\n+@gccoptlist{-g  -g@var{level}  -gdwarf  -gdwarf-@var{version} @gol\n -ggdb  -grecord-gcc-switches  -gno-record-gcc-switches @gol\n -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol\n -gcolumn-info  -gno-column-info @gol\n@@ -6901,7 +6901,7 @@ in their names, but apply to all currently-supported versions of DWARF.\n Produce debugging information in stabs format (if that is supported),\n without GDB extensions.  This is the format used by DBX on most BSD\n systems.  On MIPS, Alpha and System V Release 4 systems this option\n-produces stabs debugging output that is not understood by DBX or SDB@.\n+produces stabs debugging output that is not understood by DBX@.\n On System V Release 4 systems this option requires the GNU assembler.\n \n @item -gstabs+\n@@ -6911,12 +6911,6 @@ using GNU extensions understood only by the GNU debugger (GDB)@.  The\n use of these extensions is likely to make other debuggers crash or\n refuse to read the program.\n \n-@item -gcoff\n-@opindex gcoff\n-Produce debugging information in COFF format (if that is supported).\n-This is the format used by SDB on most System V systems prior to\n-System V Release 4.\n-\n @item -gxcoff\n @opindex gxcoff\n Produce debugging information in XCOFF format (if that is supported).\n@@ -6938,7 +6932,6 @@ supported).  This is the format used by DEBUG on Alpha/VMS systems.\n @item -g@var{level}\n @itemx -ggdb@var{level}\n @itemx -gstabs@var{level}\n-@itemx -gcoff@var{level}\n @itemx -gxcoff@var{level}\n @itemx -gvms@var{level}\n Request debugging information and also use @var{level} to specify how"}, {"sha": "2bf786c2568fef4d5aec870a6c030991b3fb3350", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -981,11 +981,10 @@ these files.\n \n This is run after final because it must output the stack slot offsets\n for pseudo registers that did not get hard registers.  Source files\n-are @file{dbxout.c} for DBX symbol table format, @file{sdbout.c} for\n-SDB symbol table format, @file{dwarfout.c} for DWARF symbol table\n-format, files @file{dwarf2out.c} and @file{dwarf2asm.c} for DWARF2\n-symbol table format, and @file{vmsdbgout.c} for VMS debug symbol table\n-format.\n+are @file{dbxout.c} for DBX symbol table format, @file{dwarfout.c} for\n+DWARF symbol table format, files @file{dwarf2out.c} and @file{dwarf2asm.c}\n+for DWARF2 symbol table format, and @file{vmsdbgout.c} for VMS debug\n+symbol table format.\n \n @end itemize\n "}, {"sha": "be8b3620684465b9e155d4365f9d2937e9f5d7c0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -7699,7 +7699,7 @@ for the file format in use is appropriate.\n @end defmac\n \n @deftypefn {Target Hook} void TARGET_ASM_OUTPUT_SOURCE_FILENAME (FILE *@var{file}, const char *@var{name})\n-Output COFF information or DWARF debugging information which indicates that filename @var{name} is the current source file to the stdio stream @var{file}.\n+Output DWARF debugging information which indicates that filename @var{name} is the current source file to the stdio stream @var{file}.\n  \n  This target hook need not be defined if the standard form of output for the file format in use is appropriate.\n @end deftypefn\n@@ -9347,7 +9347,7 @@ This macro need only be defined if the target might save registers in the\n function prologue at an offset to the stack pointer that is not aligned to\n @code{UNITS_PER_WORD}.  The definition should be the negative minimum\n alignment if @code{STACK_GROWS_DOWNWARD} is true, and the positive\n-minimum alignment otherwise.  @xref{SDB and DWARF}.  Only applicable if\n+minimum alignment otherwise.  @xref{DWARF}.  Only applicable if\n the target supports DWARF 2 frame unwind information.\n @end defmac\n \n@@ -9521,7 +9521,7 @@ This describes how to specify debugging information.\n * DBX Options::        Macros enabling specific options in DBX format.\n * DBX Hooks::          Hook macros for varying DBX format.\n * File Names and DBX:: Macros controlling output of file names in DBX format.\n-* SDB and DWARF::      Macros for SDB (COFF) and DWARF formats.\n+* DWARF::              Macros for DWARF format.\n * VMS Debug::          Macros for VMS debug format.\n @end menu\n \n@@ -9555,9 +9555,8 @@ A C expression that returns the integer offset value for an automatic\n variable having address @var{x} (an RTL expression).  The default\n computation assumes that @var{x} is based on the frame-pointer and\n gives the offset from the frame-pointer.  This is required for targets\n-that produce debugging output for DBX or COFF-style debugging output\n-for SDB and allow the frame-pointer to be eliminated when the\n-@option{-g} options is used.\n+that produce debugging output for DBX and allow the frame-pointer to be\n+eliminated when the @option{-g} option is used.\n @end defmac\n \n @defmac DEBUGGER_ARG_OFFSET (@var{offset}, @var{x})\n@@ -9571,7 +9570,7 @@ A C expression that returns the type of debugging output GCC should\n produce when the user specifies just @option{-g}.  Define\n this if you have arranged for GCC to support more than one format of\n debugging output.  Currently, the allowable values are @code{DBX_DEBUG},\n-@code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG},\n+@code{DWARF_DEBUG}, @code{DWARF2_DEBUG},\n @code{XCOFF_DEBUG}, @code{VMS_DEBUG}, and @code{VMS_AND_DWARF2_DEBUG}.\n \n When the user specifies @option{-ggdb}, GCC normally also uses the\n@@ -9582,7 +9581,7 @@ defined, GCC uses @code{DBX_DEBUG}.\n \n The value of this macro only affects the default debugging output; the\n user can always get a specific type of output by using @option{-gstabs},\n-@option{-gcoff}, @option{-gdwarf-2}, @option{-gxcoff}, or @option{-gvms}.\n+@option{-gdwarf-2}, @option{-gxcoff}, or @option{-gvms}.\n @end defmac\n \n @node DBX Options\n@@ -9800,16 +9799,11 @@ whose value is the highest absolute text address in the file.\n @end defmac\n \n @need 2000\n-@node SDB and DWARF\n-@subsection Macros for SDB and DWARF Output\n+@node DWARF\n+@subsection Macros for DWARF Output\n \n @c prevent bad page break with this line\n-Here are macros for SDB and DWARF output.\n-\n-@defmac SDB_DEBUGGING_INFO\n-Define this macro to 1 if GCC should produce COFF-style debugging output\n-for SDB in response to the @option{-g} option.\n-@end defmac\n+Here are macros for DWARF output.\n \n @defmac DWARF2_DEBUGGING_INFO\n Define this macro if GCC should produce dwarf version 2 format\n@@ -9915,40 +9909,6 @@ If defined, this target hook is a function which outputs a DTP-relative\n reference to the given TLS symbol of the specified size.\n @end deftypefn\n \n-@defmac PUT_SDB_@dots{}\n-Define these macros to override the assembler syntax for the special\n-SDB assembler directives.  See @file{sdbout.c} for a list of these\n-macros and their arguments.  If the standard syntax is used, you need\n-not define them yourself.\n-@end defmac\n-\n-@defmac SDB_DELIM\n-Some assemblers do not support a semicolon as a delimiter, even between\n-SDB assembler directives.  In that case, define this macro to be the\n-delimiter to use (usually @samp{\\n}).  It is not necessary to define\n-a new set of @code{PUT_SDB_@var{op}} macros if this is the only change\n-required.\n-@end defmac\n-\n-@defmac SDB_ALLOW_UNKNOWN_REFERENCES\n-Define this macro to allow references to unknown structure,\n-union, or enumeration tags to be emitted.  Standard COFF does not\n-allow handling of unknown references, MIPS ECOFF has support for\n-it.\n-@end defmac\n-\n-@defmac SDB_ALLOW_FORWARD_REFERENCES\n-Define this macro to allow references to structure, union, or\n-enumeration tags that have not yet been seen to be handled.  Some\n-assemblers choke if forward tags are used, while some require it.\n-@end defmac\n-\n-@defmac SDB_OUTPUT_SOURCE_LINE (@var{stream}, @var{line})\n-A C statement to output SDB debugging information before code for line\n-number @var{line} of the current source file to the stdio stream\n-@var{stream}.  The default is to emit an @code{.ln} directive.\n-@end defmac\n-\n @need 2000\n @node VMS Debug\n @subsection Macros for VMS Debug Format"}, {"sha": "d433e3a9c6b478fda78d8b4f8cc4e5d24dfb0ccf", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 9, "deletions": 49, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -6450,7 +6450,7 @@ This macro need only be defined if the target might save registers in the\n function prologue at an offset to the stack pointer that is not aligned to\n @code{UNITS_PER_WORD}.  The definition should be the negative minimum\n alignment if @code{STACK_GROWS_DOWNWARD} is true, and the positive\n-minimum alignment otherwise.  @xref{SDB and DWARF}.  Only applicable if\n+minimum alignment otherwise.  @xref{DWARF}.  Only applicable if\n the target supports DWARF 2 frame unwind information.\n @end defmac\n \n@@ -6574,7 +6574,7 @@ This describes how to specify debugging information.\n * DBX Options::        Macros enabling specific options in DBX format.\n * DBX Hooks::          Hook macros for varying DBX format.\n * File Names and DBX:: Macros controlling output of file names in DBX format.\n-* SDB and DWARF::      Macros for SDB (COFF) and DWARF formats.\n+* DWARF::              Macros for DWARF format.\n * VMS Debug::          Macros for VMS debug format.\n @end menu\n \n@@ -6608,9 +6608,8 @@ A C expression that returns the integer offset value for an automatic\n variable having address @var{x} (an RTL expression).  The default\n computation assumes that @var{x} is based on the frame-pointer and\n gives the offset from the frame-pointer.  This is required for targets\n-that produce debugging output for DBX or COFF-style debugging output\n-for SDB and allow the frame-pointer to be eliminated when the\n-@option{-g} options is used.\n+that produce debugging output for DBX and allow the frame-pointer to be\n+eliminated when the @option{-g} option is used.\n @end defmac\n \n @defmac DEBUGGER_ARG_OFFSET (@var{offset}, @var{x})\n@@ -6624,7 +6623,7 @@ A C expression that returns the type of debugging output GCC should\n produce when the user specifies just @option{-g}.  Define\n this if you have arranged for GCC to support more than one format of\n debugging output.  Currently, the allowable values are @code{DBX_DEBUG},\n-@code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG},\n+@code{DWARF_DEBUG}, @code{DWARF2_DEBUG},\n @code{XCOFF_DEBUG}, @code{VMS_DEBUG}, and @code{VMS_AND_DWARF2_DEBUG}.\n \n When the user specifies @option{-ggdb}, GCC normally also uses the\n@@ -6635,7 +6634,7 @@ defined, GCC uses @code{DBX_DEBUG}.\n \n The value of this macro only affects the default debugging output; the\n user can always get a specific type of output by using @option{-gstabs},\n-@option{-gcoff}, @option{-gdwarf-2}, @option{-gxcoff}, or @option{-gvms}.\n+@option{-gdwarf-2}, @option{-gxcoff}, or @option{-gvms}.\n @end defmac\n \n @node DBX Options\n@@ -6853,16 +6852,11 @@ whose value is the highest absolute text address in the file.\n @end defmac\n \n @need 2000\n-@node SDB and DWARF\n-@subsection Macros for SDB and DWARF Output\n+@node DWARF\n+@subsection Macros for DWARF Output\n \n @c prevent bad page break with this line\n-Here are macros for SDB and DWARF output.\n-\n-@defmac SDB_DEBUGGING_INFO\n-Define this macro to 1 if GCC should produce COFF-style debugging output\n-for SDB in response to the @option{-g} option.\n-@end defmac\n+Here are macros for DWARF output.\n \n @defmac DWARF2_DEBUGGING_INFO\n Define this macro if GCC should produce dwarf version 2 format\n@@ -6938,40 +6932,6 @@ is referenced by a function.\n \n @hook TARGET_ASM_OUTPUT_DWARF_DTPREL\n \n-@defmac PUT_SDB_@dots{}\n-Define these macros to override the assembler syntax for the special\n-SDB assembler directives.  See @file{sdbout.c} for a list of these\n-macros and their arguments.  If the standard syntax is used, you need\n-not define them yourself.\n-@end defmac\n-\n-@defmac SDB_DELIM\n-Some assemblers do not support a semicolon as a delimiter, even between\n-SDB assembler directives.  In that case, define this macro to be the\n-delimiter to use (usually @samp{\\n}).  It is not necessary to define\n-a new set of @code{PUT_SDB_@var{op}} macros if this is the only change\n-required.\n-@end defmac\n-\n-@defmac SDB_ALLOW_UNKNOWN_REFERENCES\n-Define this macro to allow references to unknown structure,\n-union, or enumeration tags to be emitted.  Standard COFF does not\n-allow handling of unknown references, MIPS ECOFF has support for\n-it.\n-@end defmac\n-\n-@defmac SDB_ALLOW_FORWARD_REFERENCES\n-Define this macro to allow references to structure, union, or\n-enumeration tags that have not yet been seen to be handled.  Some\n-assemblers choke if forward tags are used, while some require it.\n-@end defmac\n-\n-@defmac SDB_OUTPUT_SOURCE_LINE (@var{stream}, @var{line})\n-A C statement to output SDB debugging information before code for line\n-number @var{line} of the current source file to the stdio stream\n-@var{stream}.  The default is to emit an @code{.ln} directive.\n-@end defmac\n-\n @need 2000\n @node VMS Debug\n @subsection Macros for VMS Debug Format"}, {"sha": "54a47d516182b7112168db2fb827748757a2168f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -20939,10 +20939,10 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_col_major);\n \n #if 0\n-  /* We default the array ordering.  SDB will probably do\n-     the right things even if DW_AT_ordering is not present.  It's not even\n-     an issue until we start to get into multidimensional arrays anyway.  If\n-     SDB is ever caught doing the Wrong Thing for multi-dimensional arrays,\n+  /* We default the array ordering.  Debuggers will probably do the right\n+     things even if DW_AT_ordering is not present.  It's not even an issue\n+     until we start to get into multidimensional arrays anyway.  If a debugger\n+     is ever caught doing the Wrong Thing for multi-dimensional arrays,\n      then we'll have to put the DW_AT_ordering attribute back in.  (But if\n      and when we find out that we need to put these in, we will only do so\n      for multidimensional arrays.  */"}, {"sha": "840931ba516d1a324e5b9cf1e61a183e0c1b74ab", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -92,8 +92,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbxout.h\"\n #endif\n \n-#include \"sdbout.h\"\n-\n /* Most ports that aren't using cc0 don't need to define CC_STATUS_INIT.\n    So define a null default for it to save conditionalization later.  */\n #ifndef CC_STATUS_INIT\n@@ -2328,8 +2326,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;\n \t      BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn)) = in_cold_section_p;\n \t    }\n-\t  if (write_symbols == DBX_DEBUG\n-\t      || write_symbols == SDB_DEBUG)\n+\t  if (write_symbols == DBX_DEBUG)\n \t    {\n \t      location_t *locus_ptr\n \t\t= block_nonartificial_location (NOTE_BLOCK (insn));\n@@ -2363,8 +2360,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t      gcc_assert (BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn))\n \t\t\t  == in_cold_section_p);\n \t    }\n-\t  if (write_symbols == DBX_DEBUG\n-\t      || write_symbols == SDB_DEBUG)\n+\t  if (write_symbols == DBX_DEBUG)\n \t    {\n \t      tree outer_block = BLOCK_SUPERCONTEXT (NOTE_BLOCK (insn));\n \t      location_t *locus_ptr\n@@ -4684,12 +4680,6 @@ rest_of_clean_state (void)\n \t}\n     }\n \n-  /* In case the function was not output,\n-     don't leave any temporary anonymous types\n-     queued up for sdb output.  */\n-  if (SDB_DEBUGGING_INFO && write_symbols == SDB_DEBUG)\n-    sdbout_types (NULL_TREE);\n-\n   flag_rerun_cse_after_global_opts = 0;\n   reload_completed = 0;\n   epilogue_completed = 0;"}, {"sha": "591b74457cdd24e942c5901d7db380da4fe54a49", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -24,7 +24,6 @@ enum debug_info_type\n {\n   NO_DEBUG,\t    /* Write no debug info.  */\n   DBX_DEBUG,\t    /* Write BSD .stabs for DBX (using dbxout.c).  */\n-  SDB_DEBUG,\t    /* Write COFF for (old) SDB (using sdbout.c).  */\n   DWARF2_DEBUG,\t    /* Write Dwarf v2 debug info (using dwarf2out.c).  */\n   XCOFF_DEBUG,\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n   VMS_DEBUG,        /* Write VMS debug info (using vmsdbgout.c).  */"}, {"sha": "67ebf7bc2f15e30889230b68dc4e0728f6222f1d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1,3 +1,7 @@\n+2017-10-29  Jim Wilson  <wilson@tuliptree.org>\n+\n+\t* invoke.texi: Delete adb and sdb references.\n+\n 2017-10-28  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* check.c (gfc_check_co_reduce): Clarify error message."}, {"sha": "261f2535bb584a74b19b256947b6e213b5758d04", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -41,7 +41,7 @@ remainder.\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7),\n-cpp(1), gcov(1), gcc(1), as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1)\n+cpp(1), gcov(1), gcc(1), as(1), ld(1), gdb(1), dbx(1)\n and the Info entries for @file{gcc}, @file{cpp}, @file{gfortran}, @file{as},\n @file{ld}, @file{binutils} and @file{gdb}.\n @c man end"}, {"sha": "fe3d9c1bbf3a9bc16f4e9b84aac98cb6d7ad12b8", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -4709,11 +4709,11 @@ number_blocks (tree fn)\n   int n_blocks;\n   tree *block_vector;\n \n-  /* For SDB and XCOFF debugging output, we start numbering the blocks\n+  /* For XCOFF debugging output, we start numbering the blocks\n      from 1 within each function, rather than keeping a running\n      count.  */\n-#if SDB_DEBUGGING_INFO || defined (XCOFF_DEBUGGING_INFO)\n-  if (write_symbols == SDB_DEBUG || write_symbols == XCOFF_DEBUG)\n+#if defined (XCOFF_DEBUGGING_INFO)\n+  if (write_symbols == XCOFF_DEBUG)\n     next_block_index = 1;\n #endif\n \n@@ -5248,7 +5248,7 @@ expand_function_start (tree subr)\n     }\n \n   /* The following was moved from init_function_start.\n-     The move is supposed to make sdb output more accurate.  */\n+     The move was supposed to make sdb output more accurate.  */\n   /* Indicate the beginning of the function body,\n      as opposed to parm setup.  */\n   emit_note (NOTE_INSN_FUNCTION_BEG);\n@@ -5439,7 +5439,7 @@ expand_function_end (void)\n   do_pending_stack_adjust ();\n \n   /* Output a linenumber for the end of the function.\n-     SDB depends on this.  */\n+     SDB depended on this.  */\n   set_curr_insn_location (input_location);\n \n   /* Before the return label (if any), clobber the return"}, {"sha": "184f2b321e0f53f3fda9f027ba976c00e54639cc", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1117,7 +1117,7 @@ static const char *cpp_unique_options =\n  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\\\n  %{!E:%{!M:%{!MM:%{!MT:%{!MQ:%{MD|MMD:%{o*:-MQ %*}}}}}}}\\\n- %{remap} %{g3|ggdb3|gstabs3|gcoff3|gxcoff3|gvms3:-dD}\\\n+ %{remap} %{g3|ggdb3|gstabs3|gxcoff3|gvms3:-dD}\\\n  %{!iplugindir*:%{fplugin*:%:find-plugindir()}}\\\n  %{H} %C %{D*&U*&A*} %{i*} %Z %i\\\n  %{E|M|MM:%W{o*}}\";"}, {"sha": "ac383d48ec18d8f9c6f00ada4b96cb5d310bcf20", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -37,7 +37,7 @@ static void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);\n /* Indexed by enum debug_info_type.  */\n const char *const debug_type_names[] =\n {\n-  \"none\", \"stabs\", \"coff\", \"dwarf-2\", \"xcoff\", \"vms\"\n+  \"none\", \"stabs\", \"dwarf-2\", \"xcoff\", \"vms\"\n };\n \n /* Parse the -femit-struct-debug-detailed option value\n@@ -2351,10 +2351,6 @@ common_handle_option (struct gcc_options *opts,\n                        loc);\n       break;\n \n-    case OPT_gcoff:\n-      set_debug_level (SDB_DEBUG, false, arg, opts, opts_set, loc);\n-      break;\n-\n     case OPT_gdwarf:\n       if (arg && strlen (arg) != 0)\n         {"}, {"sha": "ede44476a76c6b3ba5010c31d10abd2cfcd4273d", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -308,11 +308,6 @@ extern void output_quoted_string (FILE *, const char *);\n    This variable is defined  in final.c.  */\n extern rtx_sequence *final_sequence;\n \n-/* The line number of the beginning of the current function.  Various\n-   md code needs this so that it can output relative linenumbers.  */\n-\n-extern int sdb_begin_function_line;\n-\n /* File in which assembler code is being written.  */\n \n #ifdef BUFSIZ"}, {"sha": "acd25a3c7658eae14609fffabab9963da2d53965", "filename": "gcc/sdbout.c", "status": "removed", "additions": 0, "deletions": 1661, "changes": 1661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7719f04695a5acf661ebd9229215eb9ce8c2bf5f/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7719f04695a5acf661ebd9229215eb9ce8c2bf5f/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=7719f04695a5acf661ebd9229215eb9ce8c2bf5f", "patch": "@@ -1,1661 +0,0 @@\n-/* Output sdb-format symbol table information from GNU compiler.\n-   Copyright (C) 1988-2017 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/*  mike@tredysvr.Tredydev.Unisys.COM says:\n-I modified the struct.c example and have a nm of a .o resulting from the\n-AT&T C compiler.  From the example below I would conclude the following:\n-\n-1. All .defs from structures are emitted as scanned.  The example below\n-   clearly shows the symbol table entries for BoxRec2 are after the first\n-   function.\n-\n-2. All functions and their locals (including statics) are emitted as scanned.\n-\n-3. All nested unnamed union and structure .defs must be emitted before\n-   the structure in which they are nested.  The AT&T assembler is a\n-   one pass beast as far as symbolics are concerned.\n-\n-4. All structure .defs are emitted before the typedefs that refer to them.\n-\n-5. All top level static and external variable definitions are moved to the\n-   end of file with all top level statics occurring first before externs.\n-\n-6. All undefined references are at the end of the file.\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"gsyms.h\"\n-#include \"tm.h\"\n-#include \"debug.h\"\n-#include \"tree.h\"\n-#include \"varasm.h\"\n-#include \"stor-layout.h\"\n-\n-static GTY(()) tree anonymous_types;\n-\n-/* Counter to generate unique \"names\" for nameless struct members.  */\n-\n-static GTY(()) int unnamed_struct_number;\n-\n-/* Declarations whose debug info was deferred till end of compilation.  */\n-\n-static GTY(()) vec<tree, va_gc> *deferred_global_decls;\n-\n-/* The C front end may call sdbout_symbol before sdbout_init runs.\n-   We save all such decls in this list and output them when we get\n-   to sdbout_init.  */\n-\n-static GTY(()) tree preinit_symbols;\n-static GTY(()) bool sdbout_initialized;\n-\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"function.h\"\n-#include \"memmodel.h\"\n-#include \"emit-rtl.h\"\n-#include \"flags.h\"\n-#include \"insn-config.h\"\n-#include \"reload.h\"\n-#include \"output.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tm_p.h\"\n-#include \"langhooks.h\"\n-#include \"target.h\"\n-\n-/* 1 if PARM is passed to this function in memory.  */\n-\n-#define PARM_PASSED_IN_MEMORY(PARM) \\\n- (MEM_P (DECL_INCOMING_RTL (PARM)))\n-\n-/* A C expression for the integer offset value of an automatic variable\n-   (C_AUTO) having address X (an RTX).  */\n-#ifndef DEBUGGER_AUTO_OFFSET\n-#define DEBUGGER_AUTO_OFFSET(X) \\\n-  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n-#endif\n-\n-/* A C expression for the integer offset value of an argument (C_ARG)\n-   having address X (an RTX).  The nominal offset is OFFSET.  */\n-#ifndef DEBUGGER_ARG_OFFSET\n-#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n-#endif\n-\n-/* Line number of beginning of current function, minus one.\n-   Negative means not in a function or not using sdb.  */\n-\n-int sdb_begin_function_line = -1;\n-\n-\n-extern FILE *asm_out_file;\n-\n-extern tree current_function_decl;\n-\n-#include \"sdbout.h\"\n-\n-static void sdbout_init\t\t\t(const char *);\n-static void sdbout_finish\t\t(const char *);\n-static void sdbout_start_source_file\t(unsigned int, const char *);\n-static void sdbout_end_source_file\t(unsigned int);\n-static void sdbout_begin_block\t\t(unsigned int, unsigned int);\n-static void sdbout_end_block\t\t(unsigned int, unsigned int);\n-static void sdbout_source_line\t\t(unsigned int, unsigned int,\n-\t\t\t\t\t const char *, int, bool);\n-static void sdbout_end_epilogue\t\t(unsigned int, const char *);\n-static void sdbout_early_global_decl\t(tree);\n-static void sdbout_late_global_decl\t(tree);\n-static void sdbout_begin_prologue\t(unsigned int, unsigned int,\n-\t\t\t\t\t const char *);\n-static void sdbout_end_prologue\t\t(unsigned int, const char *);\n-static void sdbout_begin_function\t(tree);\n-static void sdbout_end_function\t\t(unsigned int);\n-static void sdbout_toplevel_data\t(tree);\n-static void sdbout_label\t\t(rtx_code_label *);\n-static char *gen_fake_label\t\t(void);\n-static int plain_type\t\t\t(tree);\n-static int template_name_p\t\t(tree);\n-static void sdbout_record_type_name\t(tree);\n-static int plain_type_1\t\t\t(tree, int);\n-static void sdbout_block\t\t(tree);\n-static void sdbout_syms\t\t\t(tree);\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-static void sdbout_queue_anonymous_type\t(tree);\n-static void sdbout_dequeue_anonymous_types (void);\n-#endif\n-static void sdbout_type\t\t\t(tree);\n-static void sdbout_field_types\t\t(tree);\n-static void sdbout_one_type\t\t(tree);\n-static void sdbout_parms\t\t(tree);\n-static void sdbout_reg_parms\t\t(tree);\n-\n-/* Random macros describing parts of SDB data.  */\n-\n-/* Default value of delimiter is \";\".  */\n-#ifndef SDB_DELIM\n-#define SDB_DELIM\t\";\"\n-#endif\n-\n-/* Maximum number of dimensions the assembler will allow.  */\n-#ifndef SDB_MAX_DIM\n-#define SDB_MAX_DIM 4\n-#endif\n-\n-#ifndef PUT_SDB_SCL\n-#define PUT_SDB_SCL(a) fprintf (asm_out_file, \"\\t.scl\\t%d%s\", (a), SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_INT_VAL\n-#define PUT_SDB_INT_VAL(a) \\\n- do {\t\t\t\t\t\t\t\t\t\\\n-   fprintf (asm_out_file, \"\\t.val\\t\" HOST_WIDE_INT_PRINT_DEC \"%s\",\t\\\n-\t    (HOST_WIDE_INT) (a), SDB_DELIM);\t\t\t\t\\\n- } while (0)\n-\n-#endif\n-\n-#ifndef PUT_SDB_VAL\n-#define PUT_SDB_VAL(a)\t\t\t\t\\\n-( fputs (\"\\t.val\\t\", asm_out_file),\t\t\\\n-  output_addr_const (asm_out_file, (a)),\t\\\n-  fprintf (asm_out_file, SDB_DELIM))\n-#endif\n-\n-#ifndef PUT_SDB_DEF\n-#define PUT_SDB_DEF(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\t.def\\t\");\t\\\n-     assemble_name (asm_out_file, a);\t\\\n-     fprintf (asm_out_file, SDB_DELIM); } while (0)\n-#endif\n-\n-#ifndef PUT_SDB_PLAIN_DEF\n-#define PUT_SDB_PLAIN_DEF(a) \\\n-  fprintf (asm_out_file, \"\\t.def\\t.%s%s\", a, SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_ENDEF\n-#define PUT_SDB_ENDEF fputs (\"\\t.endef\\n\", asm_out_file)\n-#endif\n-\n-#ifndef PUT_SDB_TYPE\n-#define PUT_SDB_TYPE(a) fprintf (asm_out_file, \"\\t.type\\t0%o%s\", a, SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_SIZE\n-#define PUT_SDB_SIZE(a) \\\n- do {\t\t\t\t\t\t\t\t\t\\\n-   fprintf (asm_out_file, \"\\t.size\\t\" HOST_WIDE_INT_PRINT_DEC \"%s\",\t\\\n-\t    (HOST_WIDE_INT) (a), SDB_DELIM);\t\t\t\t\\\n- } while (0)\n-#endif\n-\n-#ifndef PUT_SDB_START_DIM\n-#define PUT_SDB_START_DIM fprintf (asm_out_file, \"\\t.dim\\t\")\n-#endif\n-\n-#ifndef PUT_SDB_NEXT_DIM\n-#define PUT_SDB_NEXT_DIM(a) fprintf (asm_out_file, \"%d,\", a)\n-#endif\n-\n-#ifndef PUT_SDB_LAST_DIM\n-#define PUT_SDB_LAST_DIM(a) fprintf (asm_out_file, \"%d%s\", a, SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_TAG\n-#define PUT_SDB_TAG(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\t.tag\\t\");\t\\\n-     assemble_name (asm_out_file, a);\t\\\n-     fprintf (asm_out_file, SDB_DELIM); } while (0)\n-#endif\n-\n-#ifndef PUT_SDB_BLOCK_START\n-#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.def\\t.bb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_BLOCK_END\n-#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.def\\t.eb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\",  \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_FUNCTION_START\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.def\\t.bf%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-#endif\n-\n-#ifndef PUT_SDB_FUNCTION_END\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.def\\t.ef%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-#endif\n-\n-/* Return the sdb tag identifier string for TYPE\n-   if TYPE has already been defined; otherwise return a null pointer.  */\n-\n-#define KNOWN_TYPE_TAG(type)  TYPE_SYMTAB_POINTER (type)\n-\n-/* Set the sdb tag identifier string for TYPE to NAME.  */\n-\n-#define SET_KNOWN_TYPE_TAG(TYPE, NAME) \\\n-  TYPE_SYMTAB_POINTER (TYPE) = (const char *)(NAME)\n-\n-/* Return the name (a string) of the struct, union or enum tag\n-   described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */\n-\n-#define TAG_NAME(link) \\\n-  (((link) && TREE_PURPOSE ((link)) \\\n-    && IDENTIFIER_POINTER (TREE_PURPOSE ((link)))) \\\n-   ? IDENTIFIER_POINTER (TREE_PURPOSE ((link))) : (char *) 0)\n-\n-/* Ensure we don't output a negative line number.  */\n-#define MAKE_LINE_SAFE(line)  \\\n-  if ((int) line <= sdb_begin_function_line) \\\n-    line = sdb_begin_function_line + 1\n-\n-/* The debug hooks structure.  */\n-const struct gcc_debug_hooks sdb_debug_hooks =\n-{\n-  sdbout_init,\t\t\t         /* init */\n-  sdbout_finish,\t\t         /* finish */\n-  debug_nothing_charstar,\t\t /* early_finish */\n-  debug_nothing_void,\t\t\t /* assembly_start */\n-  debug_nothing_int_charstar,\t         /* define */\n-  debug_nothing_int_charstar,\t         /* undef */\n-  sdbout_start_source_file,\t         /* start_source_file */\n-  sdbout_end_source_file,\t         /* end_source_file */\n-  sdbout_begin_block,\t\t         /* begin_block */\n-  sdbout_end_block,\t\t         /* end_block */\n-  debug_true_const_tree,\t         /* ignore_block */\n-  sdbout_source_line,\t\t         /* source_line */\n-  sdbout_begin_prologue,\t         /* begin_prologue */\n-  debug_nothing_int_charstar,\t         /* end_prologue */\n-  debug_nothing_int_charstar,\t         /* begin_epilogue */\n-  sdbout_end_epilogue,\t\t         /* end_epilogue */\n-  sdbout_begin_function,\t         /* begin_function */\n-  sdbout_end_function,\t\t         /* end_function */\n-  debug_nothing_tree,\t\t         /* register_main_translation_unit */\n-  debug_nothing_tree,\t\t         /* function_decl */\n-  sdbout_early_global_decl,\t\t /* early_global_decl */\n-  sdbout_late_global_decl,\t\t /* late_global_decl */\n-  sdbout_symbol,\t\t\t /* type_decl */\n-  debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n-  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n-  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n-  debug_nothing_tree,\t\t         /* deferred_inline_function */\n-  debug_nothing_tree,\t\t         /* outlining_inline_function */\n-  sdbout_label,\t\t\t         /* label */\n-  debug_nothing_int,\t\t         /* handle_pch */\n-  debug_nothing_rtx_insn,\t         /* var_location */\n-  debug_nothing_tree,\t\t\t /* size_function */\n-  debug_nothing_void,                    /* switch_text_section */\n-  debug_nothing_tree_tree,\t\t /* set_name */\n-  0,                                     /* start_end_main_source_file */\n-  TYPE_SYMTAB_IS_POINTER                 /* tree_type_symtab_field */\n-};\n-\n-/* Return a unique string to name an anonymous type.  */\n-\n-static char *\n-gen_fake_label (void)\n-{\n-  char label[10];\n-  char *labelstr;\n-  sprintf (label, \".%dfake\", unnamed_struct_number);\n-  unnamed_struct_number++;\n-  labelstr = xstrdup (label);\n-  return labelstr;\n-}\n-\n-/* Return the number which describes TYPE for SDB.\n-   For pointers, etc., this function is recursive.\n-   Each record, union or enumeral type must already have had a\n-   tag number output.  */\n-\n-/* The number is given by d6d5d4d3d2d1bbbb\n-   where bbbb is 4 bit basic type, and di indicate  one of notype,ptr,fn,array.\n-   Thus, char *foo () has bbbb=T_CHAR\n-\t\t\t  d1=D_FCN\n-\t\t\t  d2=D_PTR\n- N_BTMASK=     017       1111     basic type field.\n- N_TSHIFT=       2                derived type shift\n- N_BTSHFT=       4                Basic type shift */\n-\n-/* Produce the number that describes a pointer, function or array type.\n-   PREV is the number describing the target, value or element type.\n-   DT_type describes how to transform that type.  */\n-#define PUSH_DERIVED_LEVEL(DT_type,PREV)\t\t\\\n-  ((((PREV) & ~(int) N_BTMASK) << (int) N_TSHIFT)\t\t\\\n-   | ((int) DT_type << (int) N_BTSHFT)\t\t\t\\\n-   | ((PREV) & (int) N_BTMASK))\n-\n-/* Number of elements used in sdb_dims.  */\n-static int sdb_n_dims = 0;\n-\n-/* Table of array dimensions of current type.  */\n-static int sdb_dims[SDB_MAX_DIM];\n-\n-/* Size of outermost array currently being processed.  */\n-static int sdb_type_size = -1;\n-\n-static int\n-plain_type (tree type)\n-{\n-  int val = plain_type_1 (type, 0);\n-\n-  /* If we have already saved up some array dimensions, print them now.  */\n-  if (sdb_n_dims > 0)\n-    {\n-      int i;\n-      PUT_SDB_START_DIM;\n-      for (i = sdb_n_dims - 1; i > 0; i--)\n-\tPUT_SDB_NEXT_DIM (sdb_dims[i]);\n-      PUT_SDB_LAST_DIM (sdb_dims[0]);\n-      sdb_n_dims = 0;\n-\n-      sdb_type_size = int_size_in_bytes (type);\n-      /* Don't kill sdb if type is not laid out or has variable size.  */\n-      if (sdb_type_size < 0)\n-\tsdb_type_size = 0;\n-    }\n-  /* If we have computed the size of an array containing this type,\n-     print it now.  */\n-  if (sdb_type_size >= 0)\n-    {\n-      PUT_SDB_SIZE (sdb_type_size);\n-      sdb_type_size = -1;\n-    }\n-  return val;\n-}\n-\n-static int\n-template_name_p (tree name)\n-{\n-  const char *ptr = IDENTIFIER_POINTER (name);\n-  while (*ptr && *ptr != '<')\n-    ptr++;\n-\n-  return *ptr != '\\0';\n-}\n-\n-static void\n-sdbout_record_type_name (tree type)\n-{\n-  const char *name = 0;\n-  int no_name;\n-\n-  if (KNOWN_TYPE_TAG (type))\n-    return;\n-\n-  if (TYPE_NAME (type) != 0)\n-    {\n-      tree t = 0;\n-\n-      /* Find the IDENTIFIER_NODE for the type name.  */\n-      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\tt = TYPE_NAME (type);\n-      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n-\t{\n-\t  t = DECL_NAME (TYPE_NAME (type));\n-\t  /* The DECL_NAME for templates includes \"<>\", which breaks\n-\t     most assemblers.  Use its assembler name instead, which\n-\t     has been mangled into being safe.  */\n-\t  if (t && template_name_p (t))\n-\t    t = DECL_ASSEMBLER_NAME (TYPE_NAME (type));\n-\t}\n-\n-      /* Now get the name as a string, or invent one.  */\n-      if (t != NULL_TREE)\n-\tname = IDENTIFIER_POINTER (t);\n-    }\n-\n-  no_name = (name == 0 || *name == 0);\n-  if (no_name)\n-    name = gen_fake_label ();\n-\n-  SET_KNOWN_TYPE_TAG (type, name);\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-  if (no_name)\n-    sdbout_queue_anonymous_type (type);\n-#endif\n-}\n-\n-/* Return the .type value for type TYPE.\n-\n-   LEVEL indicates how many levels deep we have recursed into the type.\n-   The SDB debug format can only represent 6 derived levels of types.\n-   After that, we must output inaccurate debug info.  We deliberately\n-   stop before the 7th level, so that ADA recursive types will not give an\n-   infinite loop.  */\n-\n-static int\n-plain_type_1 (tree type, int level)\n-{\n-  if (type == 0)\n-    type = void_type_node;\n-  else if (type == error_mark_node)\n-    type = integer_type_node;\n-  else\n-    type = TYPE_MAIN_VARIANT (type);\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case VOID_TYPE:\n-    case NULLPTR_TYPE:\n-      return T_VOID;\n-    case BOOLEAN_TYPE:\n-    case INTEGER_TYPE:\n-      {\n-\tint size = int_size_in_bytes (type) * BITS_PER_UNIT;\n-\n-\t/* Carefully distinguish all the standard types of C,\n-\t   without messing up if the language is not C.\n-\t   Note that we check only for the names that contain spaces;\n-\t   other names might occur by coincidence in other languages.  */\n-\tif (TYPE_NAME (type) != 0\n-\t    && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t    && DECL_NAME (TYPE_NAME (type)) != 0\n-\t    && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n-\t  {\n-\t    const char *const name\n-\t      = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\n-\t    if (!strcmp (name, \"char\"))\n-\t      return T_CHAR;\n-\t    if (!strcmp (name, \"unsigned char\"))\n-\t      return T_UCHAR;\n-\t    if (!strcmp (name, \"signed char\"))\n-\t      return T_CHAR;\n-\t    if (!strcmp (name, \"int\"))\n-\t      return T_INT;\n-\t    if (!strcmp (name, \"unsigned int\"))\n-\t      return T_UINT;\n-\t    if (!strcmp (name, \"short int\"))\n-\t      return T_SHORT;\n-\t    if (!strcmp (name, \"short unsigned int\"))\n-\t      return T_USHORT;\n-\t    if (!strcmp (name, \"long int\"))\n-\t      return T_LONG;\n-\t    if (!strcmp (name, \"long unsigned int\"))\n-\t      return T_ULONG;\n-\t  }\n-\n-\tif (size == INT_TYPE_SIZE)\n-\t  return (TYPE_UNSIGNED (type) ? T_UINT : T_INT);\n-\tif (size == CHAR_TYPE_SIZE)\n-\t  return (TYPE_UNSIGNED (type) ? T_UCHAR : T_CHAR);\n-\tif (size == SHORT_TYPE_SIZE)\n-\t  return (TYPE_UNSIGNED (type) ? T_USHORT : T_SHORT);\n-\tif (size == LONG_TYPE_SIZE)\n-\t  return (TYPE_UNSIGNED (type) ? T_ULONG : T_LONG);\n-\tif (size == LONG_LONG_TYPE_SIZE)\t/* better than nothing */\n-\t  return (TYPE_UNSIGNED (type) ? T_ULONG : T_LONG);\n-\treturn 0;\n-      }\n-\n-    case REAL_TYPE:\n-      {\n-\tint precision = TYPE_PRECISION (type);\n-\tif (precision == FLOAT_TYPE_SIZE)\n-\t  return T_FLOAT;\n-\tif (precision == DOUBLE_TYPE_SIZE)\n-\t  return T_DOUBLE;\n-\tif (precision == LONG_DOUBLE_TYPE_SIZE)\n-\t  return T_DOUBLE;\t/* better than nothing */\n-\n-\treturn 0;\n-      }\n-\n-    case ARRAY_TYPE:\n-      {\n-\tint m;\n-\tif (level >= 6)\n-\t  return T_VOID;\n-\telse\n-\t  m = plain_type_1 (TREE_TYPE (type), level+1);\n-\tif (sdb_n_dims < SDB_MAX_DIM)\n-\t  sdb_dims[sdb_n_dims++]\n-\t    = (TYPE_DOMAIN (type)\n-\t       && TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != 0\n-\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != 0\n-\t       && tree_fits_shwi_p (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t       && tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type)))\n-\t       ? (tree_to_shwi (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t\t  - tree_to_shwi (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1)\n-\t       : 0);\n-\n-\treturn PUSH_DERIVED_LEVEL (DT_ARY, m);\n-      }\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-    case ENUMERAL_TYPE:\n-      {\n-\tconst char *tag;\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-\tsdbout_record_type_name (type);\n-#endif\n-#ifndef SDB_ALLOW_UNKNOWN_REFERENCES\n-\tif ((TREE_ASM_WRITTEN (type) && KNOWN_TYPE_TAG (type) != 0)\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-\t    || TYPE_MODE (type) != VOIDmode\n-#endif\n-\t    )\n-#endif\n-\t  {\n-\t    /* Output the referenced structure tag name\n-\t       only if the .def has already been finished.\n-\t       At least on 386, the Unix assembler\n-\t       cannot handle forward references to tags.  */\n-\t    /* But the 88100, it requires them, sigh...  */\n-\t    /* And the MIPS requires unknown refs as well...  */\n-\t    tag = KNOWN_TYPE_TAG (type);\n-\t    PUT_SDB_TAG (tag);\n-\t    /* These 3 lines used to follow the close brace.\n-\t       However, a size of 0 without a tag implies a tag of 0,\n-\t       so if we don't know a tag, we can't mention the size.  */\n-\t    sdb_type_size = int_size_in_bytes (type);\n-\t    if (sdb_type_size < 0)\n-\t      sdb_type_size = 0;\n-\t  }\n-\treturn ((TREE_CODE (type) == RECORD_TYPE) ? T_STRUCT\n-\t\t: (TREE_CODE (type) == UNION_TYPE) ? T_UNION\n-\t\t: (TREE_CODE (type) == QUAL_UNION_TYPE) ? T_UNION\n-\t\t: T_ENUM);\n-      }\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      {\n-\tint m;\n-\tif (level >= 6)\n-\t  return T_VOID;\n-\telse\n-\t  m = plain_type_1 (TREE_TYPE (type), level+1);\n-\treturn PUSH_DERIVED_LEVEL (DT_PTR, m);\n-      }\n-    case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-      {\n-\tint m;\n-\tif (level >= 6)\n-\t  return T_VOID;\n-\telse\n-\t  m = plain_type_1 (TREE_TYPE (type), level+1);\n-\treturn PUSH_DERIVED_LEVEL (DT_FCN, m);\n-      }\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Output the symbols defined in block number DO_BLOCK.\n-\n-   This function works by walking the tree structure of blocks,\n-   counting blocks until it finds the desired block.  */\n-\n-static int do_block = 0;\n-\n-static void\n-sdbout_block (tree block)\n-{\n-  while (block)\n-    {\n-      /* Ignore blocks never expanded or otherwise marked as real.  */\n-      if (TREE_USED (block))\n-\t{\n-\t  /* When we reach the specified block, output its symbols.  */\n-\t  if (BLOCK_NUMBER (block) == do_block)\n-\t    sdbout_syms (BLOCK_VARS (block));\n-\n-\t  /* If we are past the specified block, stop the scan.  */\n-\t  if (BLOCK_NUMBER (block) > do_block)\n-\t    return;\n-\n-\t  /* Scan the blocks within this block.  */\n-\t  sdbout_block (BLOCK_SUBBLOCKS (block));\n-\t}\n-\n-      block = BLOCK_CHAIN (block);\n-    }\n-}\n-\n-/* Call sdbout_symbol on each decl in the chain SYMS.  */\n-\n-static void\n-sdbout_syms (tree syms)\n-{\n-  while (syms)\n-    {\n-      if (TREE_CODE (syms) != LABEL_DECL)\n-\tsdbout_symbol (syms, 1);\n-      syms = TREE_CHAIN (syms);\n-    }\n-}\n-\n-/* Output SDB information for a symbol described by DECL.\n-   LOCAL is nonzero if the symbol is not file-scope.  */\n-\n-void\n-sdbout_symbol (tree decl, int local)\n-{\n-  tree type = TREE_TYPE (decl);\n-  tree context = NULL_TREE;\n-  rtx value;\n-  int regno = -1;\n-  const char *name;\n-\n-  /* If we are called before sdbout_init is run, just save the symbol\n-     for later.  */\n-  if (!sdbout_initialized)\n-    {\n-      preinit_symbols = tree_cons (0, decl, preinit_symbols);\n-      return;\n-    }\n-\n-  sdbout_one_type (type);\n-\n-  switch (TREE_CODE (decl))\n-    {\n-    case CONST_DECL:\n-      /* Enum values are defined by defining the enum type.  */\n-      return;\n-\n-    case FUNCTION_DECL:\n-      /* Don't mention a nested function under its parent.  */\n-      context = decl_function_context (decl);\n-      if (context == current_function_decl)\n-\treturn;\n-      /* Check DECL_INITIAL to distinguish declarations from definitions.\n-\t Don't output debug info here for declarations; they will have\n-\t a DECL_INITIAL value of 0.  */\n-      if (! DECL_INITIAL (decl))\n-\treturn;\n-      if (!MEM_P (DECL_RTL (decl))\n-\t  || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n-\treturn;\n-      PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-      PUT_SDB_VAL (XEXP (DECL_RTL (decl), 0));\n-      PUT_SDB_SCL (TREE_PUBLIC (decl) ? C_EXT : C_STAT);\n-      break;\n-\n-    case TYPE_DECL:\n-      /* Done with tagged types.  */\n-      if (DECL_NAME (decl) == 0)\n-\treturn;\n-      if (DECL_IGNORED_P (decl))\n-\treturn;\n-      /* Don't output intrinsic types.  GAS chokes on SDB .def\n-\t statements that contain identifiers with embedded spaces\n-\t (eg \"unsigned long\").  */\n-      if (DECL_IS_BUILTIN (decl))\n-\treturn;\n-\n-      /* Output typedef name.  */\n-      if (template_name_p (DECL_NAME (decl)))\n-\tPUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-      else\n-\tPUT_SDB_DEF (IDENTIFIER_POINTER (DECL_NAME (decl)));\n-      PUT_SDB_SCL (C_TPDEF);\n-      break;\n-\n-    case PARM_DECL:\n-      /* Parm decls go in their own separate chains\n-\t and are output by sdbout_reg_parms and sdbout_parms.  */\n-      gcc_unreachable ();\n-\n-    case VAR_DECL:\n-      /* Don't mention a variable that is external.\n-\t Let the file that defines it describe it.  */\n-      if (DECL_EXTERNAL (decl))\n-\treturn;\n-\n-      /* Ignore __FUNCTION__, etc.  */\n-      if (DECL_IGNORED_P (decl))\n-\treturn;\n-\n-      /* If there was an error in the declaration, don't dump core\n-\t if there is no RTL associated with the variable doesn't\n-\t exist.  */\n-      if (!DECL_RTL_SET_P (decl))\n-\treturn;\n-\n-      value = DECL_RTL (decl);\n-\n-      if (!is_global_var (decl))\n-\tvalue = eliminate_regs (value, VOIDmode, NULL_RTX);\n-\n-      SET_DECL_RTL (decl, value);\n-#ifdef LEAF_REG_REMAP\n-      if (crtl->uses_only_leaf_regs)\n-\tleaf_renumber_regs_insn (value);\n-#endif\n-\n-      /* Don't mention a variable at all\n-\t if it was completely optimized into nothingness.\n-\n-\t If DECL was from an inline function, then its rtl\n-\t is not identically the rtl that was used in this\n-\t particular compilation.  */\n-      if (REG_P (value))\n-\t{\n-\t  regno = REGNO (value);\n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t    return;\n-\t}\n-      else if (GET_CODE (value) == SUBREG)\n-\t{\n-\t  while (GET_CODE (value) == SUBREG)\n-\t    value = SUBREG_REG (value);\n-\t  if (REG_P (value))\n-\t    {\n-\t      if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n-\t\treturn;\n-\t    }\n-\t  regno = REGNO (alter_subreg (&value, true));\n-\t  SET_DECL_RTL (decl, value);\n-\t}\n-      /* Don't output anything if an auto variable\n-\t gets RTL that is static.\n-\t GAS version 2.2 can't handle such output.  */\n-      else if (MEM_P (value) && CONSTANT_P (XEXP (value, 0))\n-\t       && ! TREE_STATIC (decl))\n-\treturn;\n-\n-      /* Emit any structure, union, or enum type that has not been output.\n-\t This occurs for tag-less structs (et al) used to declare variables\n-\t within functions.  */\n-      if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t  || TREE_CODE (type) == RECORD_TYPE\n-\t  || TREE_CODE (type) == UNION_TYPE\n-\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t{\n-\t  if (COMPLETE_TYPE_P (type)\t\t/* not a forward reference */\n-\t      && KNOWN_TYPE_TAG (type) == 0)\t/* not yet declared */\n-\t    sdbout_one_type (type);\n-\t}\n-\n-      /* Defer SDB information for top-level initialized variables! */\n-      if (! local\n-\t  && MEM_P (value)\n-\t  && DECL_INITIAL (decl))\n-\treturn;\n-\n-      /* C++ in 2.3 makes nameless symbols.  That will be fixed later.\n-\t For now, avoid crashing.  */\n-      if (DECL_NAME (decl) == NULL_TREE)\n-\treturn;\n-\n-      /* Record the name for, starting a symtab entry.  */\n-      if (local)\n-\tname = IDENTIFIER_POINTER (DECL_NAME (decl));\n-      else\n-\tname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-      if (MEM_P (value)\n-\t  && GET_CODE (XEXP (value, 0)) == SYMBOL_REF)\n-\t{\n-\t  PUT_SDB_DEF (name);\n-\t  if (TREE_PUBLIC (decl))\n-\t    {\n-\t      PUT_SDB_VAL (XEXP (value, 0));\n-\t      PUT_SDB_SCL (C_EXT);\n-\t    }\n-\t  else\n-\t    {\n-\t      PUT_SDB_VAL (XEXP (value, 0));\n-\t      PUT_SDB_SCL (C_STAT);\n-\t    }\n-\t}\n-      else if (regno >= 0)\n-\t{\n-\t  PUT_SDB_DEF (name);\n-\t  PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (regno));\n-\t  PUT_SDB_SCL (C_REG);\n-\t}\n-      else if (MEM_P (value)\n-\t       && (MEM_P (XEXP (value, 0))\n-\t\t   || (REG_P (XEXP (value, 0))\n-\t\t       && REGNO (XEXP (value, 0)) != HARD_FRAME_POINTER_REGNUM\n-\t\t       && REGNO (XEXP (value, 0)) != STACK_POINTER_REGNUM)))\n-\t/* If the value is indirect by memory or by a register\n-\t   that isn't the frame pointer\n-\t   then it means the object is variable-sized and address through\n-\t   that register or stack slot.  COFF has no way to represent this\n-\t   so all we can do is output the variable as a pointer.  */\n-\t{\n-\t  PUT_SDB_DEF (name);\n-\t  if (REG_P (XEXP (value, 0)))\n-\t    {\n-\t      PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (XEXP (value, 0))));\n-\t      PUT_SDB_SCL (C_REG);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* DECL_RTL looks like (MEM (MEM (PLUS (REG...)\n-\t\t (CONST_INT...)))).\n-\t\t We want the value of that CONST_INT.  */\n-\t      /* Encore compiler hates a newline in a macro arg, it seems.  */\n-\t      PUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET\n-\t\t\t       (XEXP (XEXP (value, 0), 0)));\n-\t      PUT_SDB_SCL (C_AUTO);\n-\t    }\n-\n-\t  /* Effectively do build_pointer_type, but don't cache this type,\n-\t     since it might be temporary whereas the type it points to\n-\t     might have been saved for inlining.  */\n-\t  /* Don't use REFERENCE_TYPE because dbx can't handle that.  */\n-\t  type = make_node (POINTER_TYPE);\n-\t  TREE_TYPE (type) = TREE_TYPE (decl);\n-\t}\n-      else if (MEM_P (value)\n-\t       && ((GET_CODE (XEXP (value, 0)) == PLUS\n-\t\t    && REG_P (XEXP (XEXP (value, 0), 0))\n-\t\t    && CONST_INT_P (XEXP (XEXP (value, 0), 1)))\n-\t\t   /* This is for variables which are at offset zero from\n-\t\t      the frame pointer.  This happens on the Alpha.\n-\t\t      Non-frame pointer registers are excluded above.  */\n-\t\t   || (REG_P (XEXP (value, 0)))))\n-\t{\n-\t  /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n-\t     or (MEM (REG...)).  We want the value of that CONST_INT\n-\t     or zero.  */\n-\t  PUT_SDB_DEF (name);\n-\t  PUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET (XEXP (value, 0)));\n-\t  PUT_SDB_SCL (C_AUTO);\n-\t}\n-      else\n-\t{\n-\t  /* It is something we don't know how to represent for SDB.  */\n-\t  return;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  PUT_SDB_TYPE (plain_type (type));\n-  PUT_SDB_ENDEF;\n-}\n-\n-/* Output SDB information for a top-level initialized variable\n-   that has been delayed.  */\n-\n-static void\n-sdbout_toplevel_data (tree decl)\n-{\n-  tree type = TREE_TYPE (decl);\n-\n-  if (DECL_IGNORED_P (decl))\n-    return;\n-\n-  gcc_assert (VAR_P (decl));\n-  gcc_assert (MEM_P (DECL_RTL (decl)));\n-  gcc_assert (DECL_INITIAL (decl));\n-\n-  PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-  PUT_SDB_VAL (XEXP (DECL_RTL (decl), 0));\n-  if (TREE_PUBLIC (decl))\n-    {\n-      PUT_SDB_SCL (C_EXT);\n-    }\n-  else\n-    {\n-      PUT_SDB_SCL (C_STAT);\n-    }\n-  PUT_SDB_TYPE (plain_type (type));\n-  PUT_SDB_ENDEF;\n-}\n-\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-\n-/* Machinery to record and output anonymous types.  */\n-\n-static void\n-sdbout_queue_anonymous_type (tree type)\n-{\n-  anonymous_types = tree_cons (NULL_TREE, type, anonymous_types);\n-}\n-\n-static void\n-sdbout_dequeue_anonymous_types (void)\n-{\n-  tree types, link;\n-\n-  while (anonymous_types)\n-    {\n-      types = nreverse (anonymous_types);\n-      anonymous_types = NULL_TREE;\n-\n-      for (link = types; link; link = TREE_CHAIN (link))\n-\t{\n-\t  tree type = TREE_VALUE (link);\n-\n-\t  if (type && ! TREE_ASM_WRITTEN (type))\n-\t    sdbout_one_type (type);\n-\t}\n-    }\n-}\n-\n-#endif\n-\n-/* Given a chain of ..._TYPE nodes, all of which have names,\n-   output definitions of those names, as typedefs.  */\n-\n-void\n-sdbout_types (tree types)\n-{\n-  tree link;\n-\n-  for (link = types; link; link = TREE_CHAIN (link))\n-    sdbout_one_type (link);\n-\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-  sdbout_dequeue_anonymous_types ();\n-#endif\n-}\n-\n-static void\n-sdbout_type (tree type)\n-{\n-  if (type == error_mark_node)\n-    type = integer_type_node;\n-  PUT_SDB_TYPE (plain_type (type));\n-}\n-\n-/* Output types of the fields of type TYPE, if they are structs.\n-\n-   Formerly did not chase through pointer types, since that could be circular.\n-   They must come before TYPE, since forward refs are not allowed.\n-   Now james@bigtex.cactus.org says to try them.  */\n-\n-static void\n-sdbout_field_types (tree type)\n-{\n-  tree tail;\n-\n-  for (tail = TYPE_FIELDS (type); tail; tail = TREE_CHAIN (tail))\n-    /* This condition should match the one for emitting the actual\n-       members below.  */\n-    if (TREE_CODE (tail) == FIELD_DECL\n-\t&& DECL_NAME (tail)\n-\t&& DECL_SIZE (tail)\n-\t&& tree_fits_uhwi_p (DECL_SIZE (tail))\n-\t&& tree_fits_shwi_p (bit_position (tail)))\n-      {\n-\tif (POINTER_TYPE_P (TREE_TYPE (tail)))\n-\t  sdbout_one_type (TREE_TYPE (TREE_TYPE (tail)));\n-\telse\n-\t  sdbout_one_type (TREE_TYPE (tail));\n-      }\n-}\n-\n-/* Use this to put out the top level defined record and union types\n-   for later reference.  If this is a struct with a name, then put that\n-   name out.  Other unnamed structs will have .xxfake labels generated so\n-   that they may be referred to later.\n-   The label will be stored in the KNOWN_TYPE_TAG slot of a type.\n-   It may NOT be called recursively.  */\n-\n-static void\n-sdbout_one_type (tree type)\n-{\n-  if (current_function_decl != NULL_TREE\n-      && DECL_SECTION_NAME (current_function_decl) != NULL)\n-    ; /* Don't change section amid function.  */\n-  else\n-    switch_to_section (current_function_section ());\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-    case ENUMERAL_TYPE:\n-      type = TYPE_MAIN_VARIANT (type);\n-      /* Don't output a type twice.  */\n-      if (TREE_ASM_WRITTEN (type))\n-\t/* James said test TREE_ASM_BEING_WRITTEN here.  */\n-\treturn;\n-\n-      /* Output nothing if type is not yet defined.  */\n-      if (!COMPLETE_TYPE_P (type))\n-\treturn;\n-\n-      TREE_ASM_WRITTEN (type) = 1;\n-\n-      /* This is reputed to cause trouble with the following case,\n-\t but perhaps checking TYPE_SIZE above will fix it.  */\n-\n-      /* Here is a testcase:\n-\n-\tstruct foo {\n-\t  struct badstr *bbb;\n-\t} forwardref;\n-\n-\ttypedef struct intermediate {\n-\t  int aaaa;\n-\t} intermediate_ref;\n-\n-\ttypedef struct badstr {\n-\t  int ccccc;\n-\t} badtype;   */\n-\n-      /* This change, which ought to make better output,\n-\t used to make the COFF assembler unhappy.\n-\t Changes involving KNOWN_TYPE_TAG may fix the problem.  */\n-      /* Before really doing anything, output types we want to refer to.  */\n-      /* Note that in version 1 the following two lines\n-\t are not used if forward references are in use.  */\n-      if (TREE_CODE (type) != ENUMERAL_TYPE)\n-\tsdbout_field_types (type);\n-\n-      /* Output a structure type.  */\n-      {\n-\tint size = int_size_in_bytes (type);\n-\tint member_scl = 0;\n-\ttree tem;\n-\n-\t/* Record the type tag, but not in its permanent place just yet.  */\n-\tsdbout_record_type_name (type);\n-\n-\tPUT_SDB_DEF (KNOWN_TYPE_TAG (type));\n-\n-\tswitch (TREE_CODE (type))\n-\t  {\n-\t  case UNION_TYPE:\n-\t  case QUAL_UNION_TYPE:\n-\t    PUT_SDB_SCL (C_UNTAG);\n-\t    PUT_SDB_TYPE (T_UNION);\n-\t    member_scl = C_MOU;\n-\t    break;\n-\n-\t  case RECORD_TYPE:\n-\t    PUT_SDB_SCL (C_STRTAG);\n-\t    PUT_SDB_TYPE (T_STRUCT);\n-\t    member_scl = C_MOS;\n-\t    break;\n-\n-\t  case ENUMERAL_TYPE:\n-\t    PUT_SDB_SCL (C_ENTAG);\n-\t    PUT_SDB_TYPE (T_ENUM);\n-\t    member_scl = C_MOE;\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\n-\tPUT_SDB_SIZE (size);\n-\tPUT_SDB_ENDEF;\n-\n-\t/* Print out the base class information with fields\n-\t   named after the types they hold.  */\n-\t/* This is only relevant to aggregate types.  TYPE_BINFO is used\n-\t   for other purposes in an ENUMERAL_TYPE, so we must exclude that\n-\t   case.  */\n-\tif (TREE_CODE (type) != ENUMERAL_TYPE && TYPE_BINFO (type))\n-\t  {\n-\t    int i;\n-\t    tree binfo, child;\n-\n-\t    for (binfo = TYPE_BINFO (type), i = 0;\n-\t\t BINFO_BASE_ITERATE (binfo, i, child); i++)\n-\t      {\n-\t\ttree child_type = BINFO_TYPE (child);\n-\t\ttree child_type_name;\n-\n-\t\tif (TYPE_NAME (child_type) == 0)\n-\t\t  continue;\n-\t\tif (TREE_CODE (TYPE_NAME (child_type)) == IDENTIFIER_NODE)\n-\t\t  child_type_name = TYPE_NAME (child_type);\n-\t\telse if (TREE_CODE (TYPE_NAME (child_type)) == TYPE_DECL)\n-\t\t  {\n-\t\t    child_type_name = DECL_NAME (TYPE_NAME (child_type));\n-\t\t    if (child_type_name && template_name_p (child_type_name))\n-\t\t      child_type_name\n-\t\t\t= DECL_ASSEMBLER_NAME (TYPE_NAME (child_type));\n-\t\t  }\n-\t\telse\n-\t\t  continue;\n-\n-\t\tPUT_SDB_DEF (IDENTIFIER_POINTER (child_type_name));\n-\t\tPUT_SDB_INT_VAL (tree_to_shwi (BINFO_OFFSET (child)));\n-\t\tPUT_SDB_SCL (member_scl);\n-\t\tsdbout_type (BINFO_TYPE (child));\n-\t\tPUT_SDB_ENDEF;\n-\t      }\n-\t  }\n-\n-\t/* Output the individual fields.  */\n-\n-\tif (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t  {\n-\t    for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n-\t      {\n-\t        tree value = TREE_VALUE (tem);\n-\n-\t        if (TREE_CODE (value) == CONST_DECL)\n-\t          value = DECL_INITIAL (value);\n-\n-\t        if (tree_fits_shwi_p (value))\n-\t\t  {\n-\t\t    PUT_SDB_DEF (IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n-\t\t    PUT_SDB_INT_VAL (tree_to_shwi (value));\n-\t\t    PUT_SDB_SCL (C_MOE);\n-\t\t    PUT_SDB_TYPE (T_MOE);\n-\t\t    PUT_SDB_ENDEF;\n-\t\t  }\n-\t      }\n-\t  }\n-\telse\t\t\t/* record or union type */\n-\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n-\t    /* Output the name, type, position (in bits), size (in bits)\n-\t       of each field.  */\n-\n-\t    /* Omit here the nameless fields that are used to skip bits.\n-\t       Also omit fields with variable size or position.\n-\t       Also omit non FIELD_DECL nodes that GNU C++ may put here.  */\n-\t    if (TREE_CODE (tem) == FIELD_DECL\n-\t\t&& DECL_NAME (tem)\n-\t\t&& DECL_SIZE (tem)\n-\t\t&& tree_fits_uhwi_p (DECL_SIZE (tem))\n-\t\t&& tree_fits_shwi_p (bit_position (tem)))\n-\t      {\n-\t\tconst char *name;\n-\n-\t\tname = IDENTIFIER_POINTER (DECL_NAME (tem));\n-\t\tPUT_SDB_DEF (name);\n-\t\tif (DECL_BIT_FIELD_TYPE (tem))\n-\t\t  {\n-\t\t    PUT_SDB_INT_VAL (int_bit_position (tem));\n-\t\t    PUT_SDB_SCL (C_FIELD);\n-\t\t    sdbout_type (DECL_BIT_FIELD_TYPE (tem));\n-\t\t    PUT_SDB_SIZE (tree_to_uhwi (DECL_SIZE (tem)));\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    PUT_SDB_INT_VAL (int_bit_position (tem) / BITS_PER_UNIT);\n-\t\t    PUT_SDB_SCL (member_scl);\n-\t\t    sdbout_type (TREE_TYPE (tem));\n-\t\t  }\n-\t\tPUT_SDB_ENDEF;\n-\t      }\n-\t/* Output end of a structure,union, or enumeral definition.  */\n-\n-\tPUT_SDB_PLAIN_DEF (\"eos\");\n-\tPUT_SDB_INT_VAL (size);\n-\tPUT_SDB_SCL (C_EOS);\n-\tPUT_SDB_TAG (KNOWN_TYPE_TAG (type));\n-\tPUT_SDB_SIZE (size);\n-\tPUT_SDB_ENDEF;\n-\tbreak;\n-      }\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-/* The following two functions output definitions of function parameters.\n-   Each parameter gets a definition locating it in the parameter list.\n-   Each parameter that is a register variable gets a second definition\n-   locating it in the register.\n-\n-   Printing or argument lists in gdb uses the definitions that\n-   locate in the parameter list.  But reference to the variable in\n-   expressions uses preferentially the definition as a register.  */\n-\n-/* Output definitions, referring to storage in the parmlist,\n-   of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */\n-\n-static void\n-sdbout_parms (tree parms)\n-{\n-  for (; parms; parms = TREE_CHAIN (parms))\n-    if (DECL_NAME (parms)\n-\t&& TREE_TYPE (parms) != error_mark_node\n-\t&& DECL_RTL_SET_P (parms)\n-\t&& DECL_INCOMING_RTL (parms))\n-      {\n-\tint current_sym_value = 0;\n-\tconst char *name = IDENTIFIER_POINTER (DECL_NAME (parms));\n-\n-\tif (name == 0 || *name == 0)\n-\t  name = gen_fake_label ();\n-\n-\t/* Perform any necessary register eliminations on the parameter's rtl,\n-\t   so that the debugging output will be accurate.  */\n-\tDECL_INCOMING_RTL (parms)\n-\t  = eliminate_regs (DECL_INCOMING_RTL (parms), VOIDmode, NULL_RTX);\n-\tSET_DECL_RTL (parms,\n-\t\t      eliminate_regs (DECL_RTL (parms), VOIDmode, NULL_RTX));\n-\n-\tif (PARM_PASSED_IN_MEMORY (parms))\n-\t  {\n-\t    rtx addr = XEXP (DECL_INCOMING_RTL (parms), 0);\n-\t    tree type;\n-\n-\t    /* ??? Here we assume that the parm address is indexed\n-\t       off the frame pointer or arg pointer.\n-\t       If that is not true, we produce meaningless results,\n-\t       but do not crash.  */\n-\t    if (GET_CODE (addr) == PLUS\n-\t\t&& CONST_INT_P (XEXP (addr, 1)))\n-\t      current_sym_value = INTVAL (XEXP (addr, 1));\n-\t    else\n-\t      current_sym_value = 0;\n-\n-\t    if (REG_P (DECL_RTL (parms))\n-\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n-\t      type = DECL_ARG_TYPE (parms);\n-\t    else\n-\t      {\n-\t\tint original_sym_value = current_sym_value;\n-\n-\t\t/* This is the case where the parm is passed as an int or\n-\t\t   double and it is converted to a char, short or float\n-\t\t   and stored back in the parmlist.  In this case, describe\n-\t\t   the parm with the variable's declared type, and adjust\n-\t\t   the address if the least significant bytes (which we are\n-\t\t   using) are not the first ones.  */\n-\t\tscalar_mode from_mode, to_mode;\n-\t\tif (BYTES_BIG_ENDIAN\n-\t\t    && TREE_TYPE (parms) != DECL_ARG_TYPE (parms)\n-\t\t    && is_a <scalar_mode> (TYPE_MODE (DECL_ARG_TYPE (parms)),\n-\t\t\t\t\t   &from_mode)\n-\t\t    && is_a <scalar_mode> (GET_MODE (DECL_RTL (parms)),\n-\t\t\t\t\t   &to_mode))\n-\t\t  current_sym_value += (GET_MODE_SIZE (from_mode)\n-\t\t\t\t\t- GET_MODE_SIZE (to_mode));\n-\n-\t\tif (MEM_P (DECL_RTL (parms))\n-\t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n-\t\t    && (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n-\t\t\t== CONST_INT)\n-\t\t    && (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n-\t\t\t== current_sym_value))\n-\t\t  type = TREE_TYPE (parms);\n-\t\telse\n-\t\t  {\n-\t\t    current_sym_value = original_sym_value;\n-\t\t    type = DECL_ARG_TYPE (parms);\n-\t\t  }\n-\t      }\n-\n-\t    PUT_SDB_DEF (name);\n-\t    PUT_SDB_INT_VAL (DEBUGGER_ARG_OFFSET (current_sym_value, addr));\n-\t    PUT_SDB_SCL (C_ARG);\n-\t    PUT_SDB_TYPE (plain_type (type));\n-\t    PUT_SDB_ENDEF;\n-\t  }\n-\telse if (REG_P (DECL_RTL (parms)))\n-\t  {\n-\t    rtx best_rtl;\n-\t    /* Parm passed in registers and lives in registers or nowhere.  */\n-\n-\t    /* If parm lives in a register, use that register;\n-\t       pretend the parm was passed there.  It would be more consistent\n-\t       to describe the register where the parm was passed,\n-\t       but in practice that register usually holds something else.  */\n-\t    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n-\t      best_rtl = DECL_RTL (parms);\n-\t    /* If the parm lives nowhere,\n-\t       use the register where it was passed.  */\n-\t    else\n-\t      best_rtl = DECL_INCOMING_RTL (parms);\n-\n-\t    PUT_SDB_DEF (name);\n-\t    PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (best_rtl)));\n-\t    PUT_SDB_SCL (C_REGPARM);\n-\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms)));\n-\t    PUT_SDB_ENDEF;\n-\t  }\n-\telse if (MEM_P (DECL_RTL (parms))\n-\t\t && XEXP (DECL_RTL (parms), 0) != const0_rtx)\n-\t  {\n-\t    /* Parm was passed in registers but lives on the stack.  */\n-\n-\t    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),\n-\t       in which case we want the value of that CONST_INT,\n-\t       or (MEM (REG ...)) or (MEM (MEM ...)),\n-\t       in which case we use a value of zero.  */\n-\t    if (REG_P (XEXP (DECL_RTL (parms), 0))\n-\t\t|| MEM_P (XEXP (DECL_RTL (parms), 0)))\n-\t      current_sym_value = 0;\n-\t    else\n-\t      current_sym_value = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n-\n-\t    /* Again, this assumes the offset is based on the arg pointer.  */\n-\t    PUT_SDB_DEF (name);\n-\t    PUT_SDB_INT_VAL (DEBUGGER_ARG_OFFSET (current_sym_value,\n-\t\t\t\t\t\t  XEXP (DECL_RTL (parms), 0)));\n-\t    PUT_SDB_SCL (C_ARG);\n-\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms)));\n-\t    PUT_SDB_ENDEF;\n-\t  }\n-      }\n-}\n-\n-/* Output definitions for the places where parms live during the function,\n-   when different from where they were passed, when the parms were passed\n-   in memory.\n-\n-   It is not useful to do this for parms passed in registers\n-   that live during the function in different registers, because it is\n-   impossible to look in the passed register for the passed value,\n-   so we use the within-the-function register to begin with.\n-\n-   PARMS is a chain of PARM_DECL nodes.  */\n-\n-static void\n-sdbout_reg_parms (tree parms)\n-{\n-  for (; parms; parms = TREE_CHAIN (parms))\n-    if (DECL_NAME (parms)\n-        && TREE_TYPE (parms) != error_mark_node\n-        && DECL_RTL_SET_P (parms)\n-        && DECL_INCOMING_RTL (parms))\n-      {\n-\tconst char *name = IDENTIFIER_POINTER (DECL_NAME (parms));\n-\n-\t/* Report parms that live in registers during the function\n-\t   but were passed in memory.  */\n-\tif (REG_P (DECL_RTL (parms))\n-\t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n-\t    && PARM_PASSED_IN_MEMORY (parms))\n-\t  {\n-\t    if (name == 0 || *name == 0)\n-\t      name = gen_fake_label ();\n-\t    PUT_SDB_DEF (name);\n-\t    PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (DECL_RTL (parms))));\n-\t    PUT_SDB_SCL (C_REG);\n-\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms)));\n-\t    PUT_SDB_ENDEF;\n-\t  }\n-\t/* Report parms that live in memory but not where they were passed.  */\n-\telse if (MEM_P (DECL_RTL (parms))\n-\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n-\t\t && CONST_INT_P (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n-\t\t && PARM_PASSED_IN_MEMORY (parms)\n-\t\t && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))\n-\t  {\n-#if 0 /* ??? It is not clear yet what should replace this.  */\n-\t    int offset = DECL_OFFSET (parms) / BITS_PER_UNIT;\n-\t    /* A parm declared char is really passed as an int,\n-\t       so it occupies the least significant bytes.\n-\t       On a big-endian machine those are not the low-numbered ones.  */\n-\t    if (BYTES_BIG_ENDIAN\n-\t\t&& offset != -1\n-\t\t&& TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n-\t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n-\t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-\t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n-#endif\n-\t      {\n-\t\tif (name == 0 || *name == 0)\n-\t\t  name = gen_fake_label ();\n-\t\tPUT_SDB_DEF (name);\n-\t\tPUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET\n-\t\t\t\t (XEXP (DECL_RTL (parms), 0)));\n-\t\tPUT_SDB_SCL (C_AUTO);\n-\t\tPUT_SDB_TYPE (plain_type (TREE_TYPE (parms)));\n-\t\tPUT_SDB_ENDEF;\n-\t      }\n-\t  }\n-      }\n-}\n-\n-/* Output early debug information for a global DECL.  Called from\n-   rest_of_decl_compilation during parsing.  */\n-\n-static void\n-sdbout_early_global_decl (tree decl ATTRIBUTE_UNUSED)\n-{\n-  /* NYI for non-dwarf.  */\n-}\n-\n-/* Output late debug information for a global DECL after location\n-   information is available.  */\n-\n-static void\n-sdbout_late_global_decl (tree decl)\n-{\n-  if (VAR_P (decl) && !DECL_EXTERNAL (decl) && DECL_RTL_SET_P (decl))\n-    {\n-      /* The COFF linker can move initialized global vars to the end.\n-\t And that can screw up the symbol ordering.  Defer those for\n-\t sdbout_finish ().  */\n-      if (!DECL_INITIAL (decl) || !TREE_PUBLIC (decl))\n-\tsdbout_symbol (decl, 0);\n-      else\n-\tvec_safe_push (deferred_global_decls, decl);\n-\n-      /* Output COFF information for non-global file-scope initialized\n-\t variables.  */\n-      if (DECL_INITIAL (decl) && MEM_P (DECL_RTL (decl)))\n-\tsdbout_toplevel_data (decl);\n-    }\n-}\n-\n-/* Output initialized global vars at the end, in the order of\n-   definition.  See comment in sdbout_global_decl.  */\n-\n-static void\n-sdbout_finish (const char *main_filename ATTRIBUTE_UNUSED)\n-{\n-  size_t i;\n-  tree decl;\n-\n-  FOR_EACH_VEC_SAFE_ELT (deferred_global_decls, i, decl)\n-    sdbout_symbol (decl, 0);\n-}\n-\n-/* Describe the beginning of an internal block within a function.\n-   Also output descriptions of variables defined in this block.\n-\n-   N is the number of the block, by order of beginning, counting from 1,\n-   and not counting the outermost (function top-level) block.\n-   The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),\n-   if the count starts at 0 for the outermost one.  */\n-\n-static void\n-sdbout_begin_block (unsigned int line, unsigned int n)\n-{\n-  tree decl = current_function_decl;\n-  MAKE_LINE_SAFE (line);\n-\n-  /* The SCO compiler does not emit a separate block for the function level\n-     scope, so we avoid it here also.  */\n-  PUT_SDB_BLOCK_START (line - sdb_begin_function_line);\n-\n-  if (n == 1)\n-    {\n-      /* Include the outermost BLOCK's variables in block 1.  */\n-      do_block = BLOCK_NUMBER (DECL_INITIAL (decl));\n-      sdbout_block (DECL_INITIAL (decl));\n-    }\n-  /* If -g1, suppress all the internal symbols of functions\n-     except for arguments.  */\n-  if (debug_info_level != DINFO_LEVEL_TERSE)\n-    {\n-      do_block = n;\n-      sdbout_block (DECL_INITIAL (decl));\n-    }\n-\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-  sdbout_dequeue_anonymous_types ();\n-#endif\n-}\n-\n-/* Describe the end line-number of an internal block within a function.  */\n-\n-static void\n-sdbout_end_block (unsigned int line, unsigned int n ATTRIBUTE_UNUSED)\n-{\n-  MAKE_LINE_SAFE (line);\n-\n-  /* The SCO compiler does not emit a separate block for the function level\n-     scope, so we avoid it here also.  */\n-  if (n != 1)\n-    PUT_SDB_BLOCK_END (line - sdb_begin_function_line);\n-}\n-\n-/* Output a line number symbol entry for source file FILENAME and line\n-   number LINE.  */\n-\n-static void\n-sdbout_source_line (unsigned int line, unsigned int column ATTRIBUTE_UNUSED,\n-\t\t    const char *filename ATTRIBUTE_UNUSED,\n-                    int discriminator ATTRIBUTE_UNUSED,\n-                    bool is_stmt ATTRIBUTE_UNUSED)\n-{\n-  /* COFF relative line numbers must be positive.  */\n-  if ((int) line > sdb_begin_function_line)\n-    {\n-#ifdef SDB_OUTPUT_SOURCE_LINE\n-      SDB_OUTPUT_SOURCE_LINE (asm_out_file, line);\n-#else\n-      fprintf (asm_out_file, \"\\t.ln\\t%d\\n\",\n-\t       ((sdb_begin_function_line > -1)\n-\t\t? line - sdb_begin_function_line : 1));\n-#endif\n-    }\n-}\n-\n-/* Output sdb info for the current function name.\n-   Called from assemble_start_function.  */\n-\n-static void\n-sdbout_begin_function (tree decl ATTRIBUTE_UNUSED)\n-{\n-  sdbout_symbol (current_function_decl, 0);\n-}\n-\n-/* Called at beginning of function body after prologue.  Record the\n-   function's starting line number, so we can output relative line numbers\n-   for the other lines.  Describe beginning of outermost block.  Also\n-   describe the parameter list.  */\n-\n-static void\n-sdbout_begin_prologue (unsigned int line, unsigned int column ATTRIBUTE_UNUSED,\n-\t\t       const char *file ATTRIBUTE_UNUSED)\n-{\n-  sdbout_end_prologue (line, file);\n-}\n-\n-static void\n-sdbout_end_prologue (unsigned int line, const char *file ATTRIBUTE_UNUSED)\n-{\n-  sdb_begin_function_line = line - 1;\n-  PUT_SDB_FUNCTION_START (line);\n-  sdbout_parms (DECL_ARGUMENTS (current_function_decl));\n-  sdbout_reg_parms (DECL_ARGUMENTS (current_function_decl));\n-}\n-\n-/* Called at end of function (before epilogue).\n-   Describe end of outermost block.  */\n-\n-static void\n-sdbout_end_function (unsigned int line)\n-{\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-  sdbout_dequeue_anonymous_types ();\n-#endif\n-\n-  MAKE_LINE_SAFE (line);\n-  PUT_SDB_FUNCTION_END (line - sdb_begin_function_line);\n-\n-  /* Indicate we are between functions, for line-number output.  */\n-  sdb_begin_function_line = -1;\n-}\n-\n-/* Output sdb info for the absolute end of a function.\n-   Called after the epilogue is output.  */\n-\n-static void\n-sdbout_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,\n-\t\t     const char *file ATTRIBUTE_UNUSED)\n-{\n-  const char *const name ATTRIBUTE_UNUSED\n-    = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n-\n-#ifdef PUT_SDB_EPILOGUE_END\n-  PUT_SDB_EPILOGUE_END (name);\n-#else\n-  fprintf (asm_out_file, \"\\t.def\\t\");\n-  assemble_name (asm_out_file, name);\n-  fprintf (asm_out_file, \"%s\\t.val\\t.%s\\t.scl\\t-1%s\\t.endef\\n\",\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM);\n-#endif\n-}\n-\n-/* Output sdb info for the given label.  Called only if LABEL_NAME (insn)\n-   is present.  */\n-\n-static void\n-sdbout_label (rtx_code_label *insn)\n-{\n-  PUT_SDB_DEF (LABEL_NAME (insn));\n-  PUT_SDB_VAL (insn);\n-  PUT_SDB_SCL (C_LABEL);\n-  PUT_SDB_TYPE (T_NULL);\n-  PUT_SDB_ENDEF;\n-}\n-\n-/* Change to reading from a new source file.  */\n-\n-static void\n-sdbout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n-\t\t\t  const char *filename ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* Revert to reading a previous source file.  */\n-\n-static void\n-sdbout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* Set up for SDB output at the start of compilation.  */\n-\n-static void\n-sdbout_init (const char *input_file_name ATTRIBUTE_UNUSED)\n-{\n-  tree t;\n-\n-  vec_alloc (deferred_global_decls, 12);\n-\n-  /* Emit debug information which was queued by sdbout_symbol before\n-     we got here.  */\n-  sdbout_initialized = true;\n-\n-  for (t = nreverse (preinit_symbols); t; t = TREE_CHAIN (t))\n-    sdbout_symbol (TREE_VALUE (t), 0);\n-  preinit_symbols = 0;\n-}\n-\n-#include \"gt-sdbout.h\""}, {"sha": "204b68790ce87488fba6ef3affbab0b90e548aab", "filename": "gcc/sdbout.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7719f04695a5acf661ebd9229215eb9ce8c2bf5f/gcc%2Fsdbout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7719f04695a5acf661ebd9229215eb9ce8c2bf5f/gcc%2Fsdbout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.h?ref=7719f04695a5acf661ebd9229215eb9ce8c2bf5f", "patch": "@@ -1,26 +0,0 @@\n-/* sdbout.h - Various declarations for functions found in sdbout.c\n-   Copyright (C) 1998-2017 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_SDBOUT_H\n-#define GCC_SDBOUT_H\n-\n-extern void sdbout_symbol (tree, int);\n-extern void sdbout_types (tree);\n-\n-#endif /* GCC_SDBOUT_H */"}, {"sha": "187193ff48576a54ed90dbef8927f10c0218a037", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1018,7 +1018,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tROUND_TOWARDS_ZERO SF_SIZE DF_SIZE XF_SIZE TF_SIZE LIBGCC2_TF_CEXT \\\n \tLIBGCC2_LONG_DOUBLE_TYPE_SIZE STRUCT_VALUE\t\t\t   \\\n \tEH_FRAME_IN_DATA_SECTION TARGET_FLT_EVAL_METHOD_NON_DEFAULT\t   \\\n-\tJCR_SECTION_NAME TARGET_USE_JCR_SECTION\n+\tJCR_SECTION_NAME TARGET_USE_JCR_SECTION SDB_DEBUGGING_INFO\t   \\\n+\tSDB_DEBUG\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "7bddb8b170a30aea63dd834788a5bf78965c6e7b", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -876,9 +876,8 @@ to generate it on the spot.\",\n \n DEFHOOK\n (output_source_filename,\n- \"Output COFF information or DWARF debugging information which indicates\\\n- that filename @var{name} is the current source file to the stdio\\\n- stream @var{file}.\\n\\\n+ \"Output DWARF debugging information which indicates that filename\\\n+ @var{name} is the current source file to the stdio stream @var{file}.\\n\\\n  \\n\\\n  This target hook need not be defined if the standard form of output\\\n  for the file format in use is appropriate.\","}, {"sha": "cd3e7f5b01b44ac02bf1685bd11090f2e2840dad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1,3 +1,9 @@\n+2017-10-29  Jim Wilson  <wilson@tuliptree.org>\n+\n+\t* lib/gcc-dg.exp (gcc-dg-debug-runtest): Delete -gcoff.\n+\t* lib/gfortran-dg.exp (gfortran-dg-debug-runtest): Delete\n+\t-gcoff.\n+\n 2017-10-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/70971"}, {"sha": "d8f9b7bd2bbfcb0ce07156758a587b717d7f9a21", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -560,7 +560,7 @@ proc gcc-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n \n     if ![info exists DEBUG_TORTURE_OPTIONS] {\n \tset DEBUG_TORTURE_OPTIONS \"\"\n-\tforeach type {-gdwarf-2 -gstabs -gstabs+ -gxcoff -gxcoff+ -gcoff} {\n+\tforeach type {-gdwarf-2 -gstabs -gstabs+ -gxcoff -gxcoff+} {\n \t    set comp_output [$target_compile \\\n \t\t    \"$srcdir/$subdir/$trivial\" \"trivial.S\" assembly \\\n \t\t    \"additional_flags=$type\"]"}, {"sha": "6f190092f28ec861d6fcb3d78ccf0a756994c6f2", "filename": "gcc/testsuite/lib/gfortran-dg.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -162,7 +162,7 @@ proc gfortran-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n \n     if ![info exists DEBUG_TORTURE_OPTIONS] {\n        set DEBUG_TORTURE_OPTIONS \"\"\n-       set type_list [list \"-gstabs\" \"-gstabs+\" \"-gxcoff\" \"-gxcoff+\" \"-gcoff\" \"-gdwarf-2\" ]\n+       set type_list [list \"-gstabs\" \"-gstabs+\" \"-gxcoff\" \"-gxcoff+\" \"-gdwarf-2\" ]\n        foreach type $type_list {\n            set comp_output [$target_compile \\\n                    \"$srcdir/$subdir/$trivial\" \"trivial.S\" assembly \\"}, {"sha": "81a7cf6b7dcb55f8b2ea107fc0de28d51c799704", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -88,8 +88,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbxout.h\"\n #endif\n \n-#include \"sdbout.h\"\n-\n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data declarations. */\n #endif\n@@ -1467,8 +1465,6 @@ process_options (void)\n   else if (write_symbols == XCOFF_DEBUG)\n     debug_hooks = &xcoff_debug_hooks;\n #endif\n-  else if (SDB_DEBUGGING_INFO && write_symbols == SDB_DEBUG)\n-    debug_hooks = &sdb_debug_hooks;\n #ifdef DWARF2_DEBUGGING_INFO\n   else if (write_symbols == DWARF2_DEBUG)\n     debug_hooks = &dwarf2_debug_hooks;"}, {"sha": "f74f1453de6d73d61f31a0be044a225a2eb31c9a", "filename": "gcc/tree-core.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1538,7 +1538,6 @@ struct GTY(()) tree_type_common {\n   tree reference_to;\n   union tree_type_symtab {\n     int GTY ((tag (\"TYPE_SYMTAB_IS_ADDRESS\"))) address;\n-    const char * GTY ((tag (\"TYPE_SYMTAB_IS_POINTER\"))) pointer;\n     struct die_struct * GTY ((tag (\"TYPE_SYMTAB_IS_DIE\"))) die;\n   } GTY ((desc (\"debug_hooks->tree_type_symtab_field\"))) symtab;\n   tree canonical;"}, {"sha": "28e157f5fd2862a5e3e173b6bb5068d5ccf81aa2", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -1206,8 +1206,8 @@ copy_node (tree node MEM_STAT_DECL)\n \t The two statements usually duplicate each other\n \t (because they clear fields of the same union),\n \t but the optimizer should catch that.  */\n-      TYPE_SYMTAB_POINTER (t) = 0;\n       TYPE_SYMTAB_ADDRESS (t) = 0;\n+      TYPE_SYMTAB_DIE (t) = 0;\n \n       /* Do not copy the values cache.  */\n       if (TYPE_CACHED_VALUES_P (t))"}, {"sha": "277aa919780e6de7c682c221cea33f57b74b6aa3", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -2072,11 +2072,6 @@ extern machine_mode vector_type_mode (const_tree);\n #define TYPE_SYMTAB_ADDRESS(NODE) \\\n   (TYPE_CHECK (NODE)->type_common.symtab.address)\n \n-/* Symtab field as a string.  Used by COFF generator in sdbout.c to\n-   hold struct/union type tag names.  */\n-#define TYPE_SYMTAB_POINTER(NODE) \\\n-  (TYPE_CHECK (NODE)->type_common.symtab.pointer)\n-\n /* Symtab field as a pointer to a DWARF DIE.  Used by DWARF generator\n    in dwarf2out.c to point to the DIE generated for the type.  */\n #define TYPE_SYMTAB_DIE(NODE) \\\n@@ -2087,8 +2082,7 @@ extern machine_mode vector_type_mode (const_tree);\n    union.  */\n \n #define TYPE_SYMTAB_IS_ADDRESS (0)\n-#define TYPE_SYMTAB_IS_POINTER (1)\n-#define TYPE_SYMTAB_IS_DIE (2)\n+#define TYPE_SYMTAB_IS_DIE (1)\n \n #define TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_CHECK (NODE)->type_with_lang_specific.lang_specific)"}, {"sha": "cf2064d5ba5138a145ccd689a5326759270fcbb7", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180295ed63192b951a6ed9dae07eefc7fd55a3d1/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=180295ed63192b951a6ed9dae07eefc7fd55a3d1", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Output xcoff-format symbol table data.  The main functionality is contained\n    in dbxout.c.  This file implements the sdbout-like parts of the xcoff\n    interface.  Many functions are very similar to their counterparts in\n-   sdbout.c.  */\n+   the former sdbout.c file.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -452,7 +452,7 @@ xcoffout_begin_prologue (unsigned int line,\n   ASM_OUTPUT_LFB (asm_out_file, line);\n   dbxout_parms (DECL_ARGUMENTS (current_function_decl));\n \n-  /* Emit the symbols for the outermost BLOCK's variables.  sdbout.c does this\n+  /* Emit the symbols for the outermost BLOCK's variables.  sdbout.c did this\n      in sdbout_begin_block, but there is no guarantee that there will be any\n      inner block 1, so we must do it here.  This gives a result similar to\n      dbxout, so it does make some sense.  */"}]}