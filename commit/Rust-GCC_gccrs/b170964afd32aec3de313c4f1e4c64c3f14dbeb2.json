{"sha": "b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3MDk2NGFmZDMyYWVjM2RlMzEzYzRmMWU0YzY0YzNmMTRkYmViMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-30T12:30:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-30T12:30:30Z"}, "message": "dyn-string.h: New file.\n\n\t* dyn-string.h: New file.\n\t* dyn-string.c: Likewise.\n\t* Makefile.in (OBJS): Add dyn-string.o.\n\t(dwarf2out.o): Add dyn-string.h dependency.\n\t(dyn-string.o): List dependencies.\n\t* dwarf2out.c: Include dyn-string.h.\n\t(ASM_NAME_TO_STRING): Use dyn_string_append, rather than strcpy.\n\t(addr_const_to_string): Take a dyn_string_t, not a char* as a\n\tprototype.  Use dyn_string_append rather than strcat, throughout.\n\t(addr_to_string): Use dyn_string_t.\n\nFrom-SVN: r21496", "tree": {"sha": "304a4a5b0923ec3d13e6852847a161df2f910e2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/304a4a5b0923ec3d13e6852847a161df2f910e2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/comments", "author": null, "committer": null, "parents": [{"sha": "07417085a14349cde788c5cc10663815da40c26f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07417085a14349cde788c5cc10663815da40c26f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07417085a14349cde788c5cc10663815da40c26f"}], "stats": {"total": 227, "additions": 182, "deletions": 45}, "files": [{"sha": "17cf01a443ccbfbd1ee32d5755fcdfa028153791", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "patch": "@@ -1,3 +1,16 @@\n+Thu Jul 30 12:29:12 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* dyn-string.h: New file.\n+\t* dyn-string.c: Likewise.\n+\t* Makefile.in (OBJS): Add dyn-string.o.\n+\t(dwarf2out.o): Add dyn-string.h dependency.\n+\t(dyn-string.o): List dependencies.\n+\t* dwarf2out.c: Include dyn-string.h.\n+\t(ASM_NAME_TO_STRING): Use dyn_string_append, rather than strcpy.\n+\t(addr_const_to_string): Take a dyn_string_t, not a char* as a\n+\tprototype.  Use dyn_string_append rather than strcat, throughout.\n+\t(addr_to_string): Use dyn_string_t.\n+\n Thu Jul 30 13:08:07 1998  Ken Raeburn  <raeburn@cygnus.com>\n \n \tFunction entry/exit profiling instrumentation:"}, {"sha": "e62bc91ebc0bcf84e39149f693115e6a9544dbf3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "patch": "@@ -642,7 +642,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o\n+ mbchar.o dyn-string.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1415,7 +1415,7 @@ dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h defaults.h toplev.h dwarfout.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n    flags.h insn-config.h reload.h output.h defaults.h \\\n-   hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h\n+   hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h dyn-string.h\n xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n@@ -1491,6 +1491,7 @@ recog.o : recog.c $(CONFIG_H) system.h $(RTL_H)  \\\n    insn-flags.h insn-codes.h real.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h\n+dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h gansidecl.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "26283cbaa077e34b11c530f19787297d9db1fc99", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "patch": "@@ -42,6 +42,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"dwarf2.h\"\n #include \"dwarf2out.h\"\n #include \"toplev.h\"\n+#include \"dyn-string.h\"\n \n /* We cannot use <assert.h> in GCC source, since that would include\n    GCC's assert.h, which may not be compatible with the host compiler.  */\n@@ -2374,7 +2375,7 @@ static tree dwarf_last_decl;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static void addr_const_to_string\tPROTO((char *, rtx));\n+static void addr_const_to_string\tPROTO((dyn_string_t, rtx));\n static char *addr_to_string\t\tPROTO((rtx));\n static int is_pseudo_reg\t\tPROTO((rtx));\n static tree type_main_variant\t\tPROTO((tree));\n@@ -2639,9 +2640,9 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #define ASM_NAME_TO_STRING(STR, NAME) \\\n   do {\t\t\t\t\t\t\t\t\t      \\\n       if ((NAME)[0] == '*')\t\t\t\t\t\t      \\\n-\tstrcpy (STR, NAME+1);\t\t\t\t\t\t      \\\n+\tdyn_string_append (STR, NAME + 1);\t\t\t\t      \\\n       else\t\t\t\t\t\t\t\t      \\\n-\tstrcpy (STR, NAME);                                                   \\\n+\tdyn_string_append (STR, NAME);                                        \\\n   }                                                                           \\\n   while (0)\n #endif\n@@ -2654,50 +2655,44 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n static void\n addr_const_to_string (str, x)\n-     char *str;\n+     dyn_string_t str;\n      rtx x;\n {\n   char buf1[256];\n-  char buf2[256];\n \n restart:\n-  str[0] = '\\0';\n   switch (GET_CODE (x))\n     {\n     case PC:\n       if (flag_pic)\n-\tstrcat (str, \",\");\n+\tdyn_string_append (str, \",\");\n       else\n \tabort ();\n       break;\n \n     case SYMBOL_REF:\n-      ASM_NAME_TO_STRING (buf1, XSTR (x, 0));\n-      strcat (str, buf1);\n+      ASM_NAME_TO_STRING (str, XSTR (x, 0));\n       break;\n \n     case LABEL_REF:\n       ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n-      ASM_NAME_TO_STRING (buf2, buf1);\n-      strcat (str, buf2);\n+      ASM_NAME_TO_STRING (str, buf1);\n       break;\n \n     case CODE_LABEL:\n       ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (x));\n-      ASM_NAME_TO_STRING (buf2, buf1);\n-      strcat (str, buf2);\n+      ASM_NAME_TO_STRING (str, buf1);\n       break;\n \n     case CONST_INT:\n       sprintf (buf1, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n-      strcat (str, buf1);\n+      dyn_string_append (str, buf1);\n       break;\n \n     case CONST:\n       /* This used to output parentheses around the expression, but that does \n          not work on the 386 (either ATT or BSD assembler).  */\n-      addr_const_to_string (buf1, XEXP (x, 0));\n-      strcat (str, buf1);\n+      addr_const_to_string (str, XEXP (x, 0));\n       break;\n \n     case CONST_DOUBLE:\n@@ -2712,7 +2707,7 @@ addr_const_to_string (str, x)\n \t  else\n \t    sprintf (buf1, HOST_WIDE_INT_PRINT_DEC,\n \t\t     CONST_DOUBLE_LOW (x));\n-\t  strcat (str, buf1);\n+\t  dyn_string_append (str, buf1);\n \t}\n       else\n \t/* We can't handle floating point constants; PRINT_OPERAND must\n@@ -2724,23 +2719,19 @@ addr_const_to_string (str, x)\n       /* Some assemblers need integer constants to appear last (eg masm).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \t{\n-\t  addr_const_to_string (buf1, XEXP (x, 1));\n-\t  strcat (str, buf1);\n+\t  addr_const_to_string (str, XEXP (x, 1));\n \t  if (INTVAL (XEXP (x, 0)) >= 0)\n-\t    strcat (str, \"+\");\n+\t    dyn_string_append (str, \"+\");\n \n-\t  addr_const_to_string (buf1, XEXP (x, 0));\n-\t  strcat (str, buf1);\n+\t  addr_const_to_string (str, XEXP (x, 0));\n \t}\n       else\n \t{\n-\t  addr_const_to_string (buf1, XEXP (x, 0));\n-\t  strcat (str, buf1);\n+\t  addr_const_to_string (str, XEXP (x, 0));\n \t  if (INTVAL (XEXP (x, 1)) >= 0)\n-\t    strcat (str, \"+\");\n+\t    dyn_string_append (str, \"+\");\n \n-\t  addr_const_to_string (buf1, XEXP (x, 1));\n-\t  strcat (str, buf1);\n+\t  addr_const_to_string (str, XEXP (x, 1));\n \t}\n       break;\n \n@@ -2751,28 +2742,22 @@ addr_const_to_string (str, x)\n       if (GET_CODE (x) != MINUS)\n \tgoto restart;\n \n-      addr_const_to_string (buf1, XEXP (x, 0));\n-      strcat (str, buf1);\n-      strcat (str, \"-\");\n+      addr_const_to_string (str, XEXP (x, 0));\n+      dyn_string_append (str, \"-\");\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) < 0)\n \t{\n-\t  strcat (str, ASM_OPEN_PAREN);\n-\t  addr_const_to_string (buf1, XEXP (x, 1));\n-\t  strcat (str, buf1);\n-\t  strcat (str, ASM_CLOSE_PAREN);\n+\t  dyn_string_append (str, ASM_OPEN_PAREN);\n+\t  addr_const_to_string (str, XEXP (x, 1));\n+\t  dyn_string_append (str, ASM_CLOSE_PAREN);\n \t}\n       else\n-\t{\n-\t  addr_const_to_string (buf1, XEXP (x, 1));\n-\t  strcat (str, buf1);\n-\t}\n+\taddr_const_to_string (str, XEXP (x, 1));\n       break;\n \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\n-      addr_const_to_string (buf1, XEXP (x, 0));\n-      strcat (str, buf1);\n+      addr_const_to_string (str, XEXP (x, 0));\n       break;\n \n     default:\n@@ -2787,9 +2772,16 @@ static char *\n addr_to_string (x)\n      rtx x;\n {\n-  char buf[1024];\n-  addr_const_to_string (buf, x);\n-  return xstrdup (buf);\n+  dyn_string_t ds = dyn_string_new (256);\n+  char *s;\n+\n+  addr_const_to_string (ds, x);\n+  \n+  /* Return the dynamically allocated string, but free the\n+     dyn_string_t itself.  */\n+  s = ds->s;\n+  free (ds);\n+  return s;\n }\n \n /* Test if rtl node points to a pseudo register.  */"}, {"sha": "cfcace955849791df0208f2781fc5096113739d8", "filename": "gcc/dyn-string.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.c?ref=b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "patch": "@@ -0,0 +1,100 @@\n+/* An abstract string datatype.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gansidecl.h\"\n+#include \"dyn-string.h\"\n+\n+extern char *xmalloc ();\n+extern char *xrealloc ();\n+\n+/* Create a new dynamic string capable of holding at least SPACE\n+   characters, including the terminating NUL.  If SPACE is 0, it\n+   will be silently increased to 1.  */\n+\n+dyn_string_t \n+dyn_string_new (space)\n+     int space;\n+{\n+  dyn_string_t result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n+ \n+  if (space == 0)\n+    /* We need at least one byte in which to store the terminating\n+       NUL.  */\n+    space = 1;\n+\n+  result->allocated = space;\n+  result->s = (char*) xmalloc (space);\n+  result->length = 0;\n+  result->s[0] = '\\0';\n+\n+  return result;\n+}\n+\n+/* Free the memory used by DS.  */\n+\n+void \n+dyn_string_delete (ds)\n+     dyn_string_t ds;\n+{\n+  free (ds->s);\n+  free (ds);\n+}\n+\n+/* Append the NUL-terminated string S to DS, resizing DS if\n+   necessary.  */\n+\n+dyn_string_t \n+dyn_string_append (ds, s)\n+     dyn_string_t ds;\n+     char *s;\n+{\n+  int len = strlen (s);\n+  dyn_string_resize (ds, ds->length + len + 1 /* '\\0' */);\n+  strcpy (ds->s + ds->length, s);\n+  ds->length += len;\n+\n+  return ds;\n+}\n+\n+/* Increase the capacity of DS so that it can hold at least SPACE\n+   characters, including the terminating NUL.  This function will not\n+   (at present) reduce the capacity of DS.  */\n+\n+dyn_string_t \n+dyn_string_resize (ds, space)\n+     dyn_string_t ds;\n+     int space;\n+{\n+  int new_allocated = ds->allocated;\n+\n+  while (space > new_allocated)\n+    new_allocated *= 2;\n+    \n+  if (new_allocated != ds->allocated)\n+    {\n+      /* We actually need more space.  */\n+      ds->allocated = new_allocated;\n+      ds->s = (char*) xrealloc (ds->s, ds->allocated);\n+    }\n+\n+  return ds;\n+}"}, {"sha": "ed8071f8b086be47868ce054a030d364cf12fdca", "filename": "gcc/dyn-string.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b170964afd32aec3de313c4f1e4c64c3f14dbeb2/gcc%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.h?ref=b170964afd32aec3de313c4f1e4c64c3f14dbeb2", "patch": "@@ -0,0 +1,31 @@\n+/* An abstract string datatype.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+typedef struct dyn_string\n+{\n+  int allocated; /* The amount of space allocated for the string.  */\n+  int length; /* The actual length of the string.  */\n+  char *s; /* The string itself, NUL-terminated.  */\n+}* dyn_string_t;\n+\n+extern dyn_string_t dyn_string_new      PROTO((int));\n+extern void dyn_string_delete           PROTO((dyn_string_t));\n+extern dyn_string_t dyn_string_append   PROTO((dyn_string_t, char*));\n+extern dyn_string_t dyn_string_resize   PROTO((dyn_string_t, int));"}]}