{"sha": "15d72060874c9714f5df3d6693a2a4f9b6c06528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkNzIwNjA4NzRjOTcxNGY1ZGYzZDY2OTNhMmE0ZjliNmMwNjUyOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-02-06T21:32:48Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-02-06T21:32:48Z"}, "message": "stl_construct.h: Wrap overlong lines, reformat according to the coding standards.\n\n2004-02-06  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_construct.h: Wrap overlong lines, reformat\n\taccording to the coding standards.\n\t* include/bits/stl_pair.h: Likewise.\n\t* include/bits/stl_raw_storage_iter.h: Likewise.\n\t* include/bits/stl_stack.h: Likewise.\n\t* include/bits/stl_uninitialized.h: Likewise.\n\t* include/bits/stream_iterator.h: Likewise.\n\t* include/bits/streambuf_iterator.h: Likewise.\n\t* include/bits/type_traits.h: Likewise.\n\nFrom-SVN: r77425", "tree": {"sha": "eff285e44af06c1d0a4181989246021552c8db5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eff285e44af06c1d0a4181989246021552c8db5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15d72060874c9714f5df3d6693a2a4f9b6c06528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d72060874c9714f5df3d6693a2a4f9b6c06528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15d72060874c9714f5df3d6693a2a4f9b6c06528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d72060874c9714f5df3d6693a2a4f9b6c06528/comments", "author": null, "committer": null, "parents": [{"sha": "0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e"}], "stats": {"total": 783, "additions": 439, "deletions": 344}, "files": [{"sha": "d56df036a1692639a9b36205c61ad21c3bab5762", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,3 +1,15 @@\n+2004-02-06  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_construct.h: Wrap overlong lines, reformat\n+\taccording to the coding standards.\n+\t* include/bits/stl_pair.h: Likewise.\n+\t* include/bits/stl_raw_storage_iter.h: Likewise.\n+\t* include/bits/stl_stack.h: Likewise.\n+\t* include/bits/stl_uninitialized.h: Likewise.\n+\t* include/bits/stream_iterator.h: Likewise.\n+\t* include/bits/streambuf_iterator.h: Likewise.\n+\t* include/bits/type_traits.h: Likewise.\n+\n 2004-02-06  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/27_io/basic_filebuf/open/char/9507.cc:"}, {"sha": "6db195b29a293f7689171fc0a82cb480a81ce11a", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // nonstandard construct and destroy functions -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -115,7 +115,8 @@ namespace std\n    */\n   template<typename _ForwardIterator>\n     inline void\n-    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)\n+    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t  __false_type)\n     { for ( ; __first != __last; ++__first) std::_Destroy(&*__first); }\n \n   /**"}, {"sha": "46eabb311c95a3dbb4510891c183f4344c0d07aa", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 81, "deletions": 78, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // Pair implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -64,85 +64,88 @@\n namespace std\n {\n \n-/// pair holds two objects of arbitrary type.\n-template <class _T1, class _T2>\n-struct pair {\n-  typedef _T1 first_type;    ///<  @c first_type is the first bound type\n-  typedef _T2 second_type;   ///<  @c second_type is the second bound type\n+  /// pair holds two objects of arbitrary type.\n+  template <class _T1, class _T2>\n+    struct pair\n+    {\n+      typedef _T1 first_type;    ///<  @c first_type is the first bound type\n+      typedef _T2 second_type;   ///<  @c second_type is the second bound type\n+\n+      _T1 first;                 ///< @c first is a copy of the first object\n+      _T2 second;                ///< @c second is a copy of the second object\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 265.  std::pair::pair() effects overly restrictive\n+      /** The default constructor creates @c first and @c second using their\n+       *  respective default constructors.  */\n+      pair()\n+      : first(), second() {}\n+\n+      /** Two objects may be passed to a @c pair constructor to be copied.  */\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) {}\n+\n+      /** There is also a templated copy ctor for the @c pair class itself.  */\n+      template <class _U1, class _U2>\n+        pair(const pair<_U1, _U2>& __p)\n+\t: first(__p.first), second(__p.second) {}\n+    };\n+\n+  /// Two pairs of the same type are equal iff their members are equal.\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __x.first == __y.first && __x.second == __y.second; }\n+\n+  /// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __x.first < __y.first\n+\t     || (!(__y.first < __x.first) && __x.second < __y.second); }\n+\n+  /// Uses @c operator== to find the result.\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__x == __y); }\n+\n+  /// Uses @c operator< to find the result.\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __y < __x; }\n+\n+  /// Uses @c operator< to find the result.\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__y < __x); }\n+\n+  /// Uses @c operator< to find the result.\n+  template <class _T1, class _T2>\n+    inline bool\n+    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__x < __y); }\n+\n+  /**\n+   *  @brief A convenience wrapper for creating a pair from two objects.\n+   *  @param  x  The first object.\n+   *  @param  y  The second object.\n+   *  @return   A newly-constructed pair<> object of the appropriate type.\n+   *\n+   *  The standard requires that the objects be passed by reference-to-const,\n+   *  but LWG issue #181 says they should be passed by const value.  We follow\n+   *  the LWG by default.\n+   */\n+  template <class _T1, class _T2>\n \n-  _T1 first;                 ///< @c first is a copy of the first object\n-  _T2 second;                ///< @c second is a copy of the second object\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 265.  std::pair::pair() effects overly restrictive\n-  /** The default constructor creates @c first and @c second using their\n-   *  respective default constructors.  */\n-  pair() : first(), second() {}\n-\n-  /** Two objects may be passed to a @c pair constructor to be copied.  */\n-  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}\n-\n-  /** There is also a templated copy ctor for the @c pair class itself.  */\n-  template <class _U1, class _U2>\n-  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n-};\n-\n-/// Two pairs of the same type are equal iff their members are equal.\n-template <class _T1, class _T2>\n-inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n-{ \n-  return __x.first == __y.first && __x.second == __y.second; \n-}\n-\n-/// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>\n-template <class _T1, class _T2>\n-inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n-{ \n-  return __x.first < __y.first || \n-         (!(__y.first < __x.first) && __x.second < __y.second); \n-}\n-\n-/// Uses @c operator== to find the result.\n-template <class _T1, class _T2>\n-inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n-  return !(__x == __y);\n-}\n-\n-/// Uses @c operator< to find the result.\n-template <class _T1, class _T2>\n-inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n-  return __y < __x;\n-}\n-\n-/// Uses @c operator< to find the result.\n-template <class _T1, class _T2>\n-inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n-  return !(__y < __x);\n-}\n-\n-/// Uses @c operator< to find the result.\n-template <class _T1, class _T2>\n-inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n-  return !(__x < __y);\n-}\n-\n-/**\n- *  @brief A convenience wrapper for creating a pair from two objects.\n- *  @param  x  The first object.\n- *  @param  y  The second object.\n- *  @return   A newly-constructed pair<> object of the appropriate type.\n- *\n- *  The standard requires that the objects be passed by reference-to-const,\n- *  but LWG issue #181 says they should be passed by const value.  We follow\n- *  the LWG by default.\n-*/\n-template <class _T1, class _T2>\n-// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-// 181.  make_pair() unintended behavior\n-inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)\n-{\n-  return pair<_T1, _T2>(__x, __y);\n-}\n-\n+  // 181.  make_pair() unintended behavior\n+  inline pair<_T1, _T2>\n+  make_pair(_T1 __x, _T2 __y)\n+  { return pair<_T1, _T2>(__x, __y); }\n+  \n } // namespace std\n \n #endif /* _PAIR_H */"}, {"sha": "5b40e0a46cb18fd0b7f7719cf4c0cc9dd8db1df9", "filename": "libstdc++-v3/include/bits/stl_raw_storage_iter.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -68,15 +68,16 @@ namespace std\n    *  uninitialized memory.\n   */\n   template <class _ForwardIterator, class _Tp>\n-  class raw_storage_iterator \n+    class raw_storage_iterator \n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     protected:\n       _ForwardIterator _M_iter;\n \n     public:\n       explicit \n-      raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}\n+      raw_storage_iterator(_ForwardIterator __x)\n+      : _M_iter(__x) {}\n \n       raw_storage_iterator& \n       operator*() { return *this; }"}, {"sha": "953b78fee7bb83e59c143133cccd6de5491c62c5", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // Stack implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -79,7 +79,6 @@ namespace std\n     inline bool \n     operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n   \n-  \n   /**\n    *  @brief  A standard container giving FILO behavior.\n    *\n@@ -116,9 +115,9 @@ namespace std\n       __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n   \n-\ttemplate<typename _Tp1, typename _Seq1>\n-          friend bool \n-          operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n+      template<typename _Tp1, typename _Seq1>\n+        friend bool \n+        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n \n       template<typename _Tp1, typename _Seq1>\n         friend bool \n@@ -141,17 +140,20 @@ namespace std\n        *  @brief  Default constructor creates no elements.\n        */\n       explicit\n-      stack(const _Sequence& __c = _Sequence()) : c(__c) {}\n+      stack(const _Sequence& __c = _Sequence())\n+      : c(__c) {}\n       \n       /**\n        *  Returns true if the %stack is empty.\n        */\n       bool\n-      empty() const { return c.empty(); }\n+      empty() const\n+      { return c.empty(); }\n       \n       /**  Returns the number of elements in the %stack.  */\n       size_type\n-      size() const { return c.size(); }\n+      size() const\n+      { return c.size(); }\n       \n       /**\n        *  Returns a read/write reference to the data at the first\n@@ -185,7 +187,8 @@ namespace std\n        *  underlying sequence.\n        */\n       void\n-      push(const value_type& __x) { c.push_back(__x); }\n+      push(const value_type& __x)\n+      { c.push_back(__x); }\n   \n       /**\n        *  @brief  Removes first element.\n@@ -206,7 +209,6 @@ namespace std\n       }\n     };\n   \n-  \n   /**\n    *  @brief  Stack equality comparison.\n    *  @param  x  A %stack.\n@@ -221,7 +223,7 @@ namespace std\n   */\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __x.c == __y.c; }\n   \n   /**\n@@ -239,31 +241,31 @@ namespace std\n   */\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __x.c < __y.c; }\n   \n   /// Based on operator==\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return !(__x == __y); }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __y < __x; }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return !(__y < __x); }\n   \n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool\n-    operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return !(__x < __y); }\n } // namespace std\n "}, {"sha": "ecf6981232bc552d360918dc24daa0ac5e8cc593", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // Raw memory manipulators -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -109,7 +109,8 @@ namespace std\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n       typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;\n-      return std::__uninitialized_copy_aux(__first, __last, __result, _Is_POD());\n+      return std::__uninitialized_copy_aux(__first, __last, __result,\n+\t\t\t\t\t   _Is_POD());\n     }\n \n   inline char*\n@@ -138,15 +139,15 @@ namespace std\n \n   template<typename _ForwardIterator, typename _Tp>\n     void\n-    __uninitialized_fill_aux(_ForwardIterator __first, \n-\t\t\t     _ForwardIterator __last, \n+    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last, \n \t\t\t     const _Tp& __x, __false_type)\n     {\n       _ForwardIterator __cur = __first;\n-      try {\n-\tfor ( ; __cur != __last; ++__cur)\n-\t  std::_Construct(&*__cur, __x);\n-      }\n+      try\n+\t{\n+\t  for ( ; __cur != __last; ++__cur)\n+\t    std::_Construct(&*__cur, __x);\n+\t}\n       catch(...)\n \t{\n \t  std::_Destroy(__first, __cur);\n@@ -235,10 +236,12 @@ namespace std\n \t\t\t      _InputIterator2 __last2,\n \t\t\t      _ForwardIterator __result)\n     {\n-      _ForwardIterator __mid = std::uninitialized_copy(__first1, __last1, __result);\n-      try {\n-\treturn std::uninitialized_copy(__first2, __last2, __mid);\n-      }\n+      _ForwardIterator __mid = std::uninitialized_copy(__first1, __last1,\n+\t\t\t\t\t\t       __result);\n+      try\n+\t{\n+\t  return std::uninitialized_copy(__first2, __last2, __mid);\n+\t}\n       catch(...)\n \t{ \n \t  std::_Destroy(__result, __mid);\n@@ -252,13 +255,14 @@ namespace std\n   template<typename _ForwardIterator, typename _Tp, typename _InputIterator>\n     inline _ForwardIterator \n     __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,\n-\t\t\t      const _Tp& __x,\n-\t\t\t      _InputIterator __first, _InputIterator __last)\n+\t\t\t      const _Tp& __x, _InputIterator __first,\n+\t\t\t      _InputIterator __last)\n     {\n       std::uninitialized_fill(__result, __mid, __x);\n-      try {\n-\treturn std::uninitialized_copy(__first, __last, __mid);\n-      }\n+      try\n+\t{\n+\t  return std::uninitialized_copy(__first, __last, __mid);\n+\t}\n       catch(...)\n \t{\n \t  std::_Destroy(__result, __mid);\n@@ -272,8 +276,8 @@ namespace std\n   template<typename _InputIterator, typename _ForwardIterator, typename _Tp>\n     inline void\n     __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,\n-\t\t\t      _ForwardIterator __first2, _ForwardIterator __last2,\n-\t\t\t      const _Tp& __x)\n+\t\t\t      _ForwardIterator __first2,\n+\t\t\t      _ForwardIterator __last2, const _Tp& __x)\n     {\n       _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1, \n \t\t\t\t\t\t\t__first2);"}, {"sha": "0433fe0de3a39a7735dd28a9ebbe988b59291c60", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -45,7 +45,7 @@ namespace std\n   template<typename _Tp, typename _CharT = char, \n            typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t> \n     class istream_iterator \n-      : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>\n+    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>\n     {\n     public:\n       typedef _CharT                         char_type;\n@@ -59,10 +59,13 @@ namespace std\n \n     public:\n       ///  Construct end of input stream iterator.\n-      istream_iterator() : _M_stream(0), _M_ok(false) {}\n+      istream_iterator()\n+      : _M_stream(0), _M_ok(false) {}\n \n       ///  Construct start of input stream iterator.\n-      istream_iterator(istream_type& __s) : _M_stream(&__s) { _M_read(); }\n+      istream_iterator(istream_type& __s)\n+      : _M_stream(&__s)\n+      { _M_read(); }\n \n       istream_iterator(const istream_iterator& __obj) \n       : _M_stream(__obj._M_stream), _M_value(__obj._M_value), \n@@ -104,14 +107,14 @@ namespace std\n \n       bool \n       _M_equal(const istream_iterator& __x) const\n-      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);}\n+      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }\n \n     private:      \n       void \n       _M_read() \n       {\n \t_M_ok = (_M_stream && *_M_stream) ? true : false;\n-\tif (_M_ok) \n+\tif (_M_ok)\n \t  {\n \t    *_M_stream >> _M_value;\n \t    _M_ok = *_M_stream ? true : false;\n@@ -133,7 +136,6 @@ namespace std\n \t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) \n     { return !__x._M_equal(__y); }\n \n-\n   /**\n    *  @brief  Provides output iterator semantics for streams.\n    *\n@@ -148,7 +150,7 @@ namespace std\n   template<typename _Tp, typename _CharT = char, \n            typename _Traits = char_traits<_CharT> >\n     class ostream_iterator \n-      : public iterator<output_iterator_tag, void, void, void, void>\n+    : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     public:\n       //@{\n@@ -197,13 +199,16 @@ namespace std\n       }\n       \n       ostream_iterator& \n-      operator*() { return *this; }\n+      operator*()\n+      { return *this; }\n       \n       ostream_iterator& \n-      operator++() { return *this; } \n+      operator++()\n+      { return *this; } \n       \n       ostream_iterator& \n-      operator++(int) { return *this; } \n+      operator++(int)\n+      { return *this; } \n     };\n } // namespace std\n #endif"}, {"sha": "b11d24c6a2c07be5325610fa966c8d1a5fcf7803", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -159,9 +159,9 @@ namespace std\n \t  { \n \t    if (!traits_type::eq_int_type(_M_c, __eof))\n \t      __ret = _M_c;\n-\t    else \n-\t      if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), __eof))\n-\t\t_M_sbuf = 0;\n+\t    else if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),\n+\t\t\t\t\t      __eof))\n+\t      _M_sbuf = 0;\n \t  }\n \treturn __ret;\n       }\n@@ -248,7 +248,8 @@ namespace std\n       _M_put(const _CharT* __ws, streamsize __len)\n       {\n \tif (__builtin_expect(!_M_failed, true)\n-\t    && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))\n+\t    && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,\n+\t\t\t\tfalse))\n \t  _M_failed = true;\n \treturn *this;\n       }"}, {"sha": "be82c4bf2d283cafe54758129cb20c97afdafb93", "filename": "libstdc++-v3/include/bits/type_traits.h", "status": "modified", "additions": 278, "deletions": 212, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d72060874c9714f5df3d6693a2a4f9b6c06528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h?ref=15d72060874c9714f5df3d6693a2a4f9b6c06528", "patch": "@@ -1,6 +1,6 @@\n // Type traits implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -91,13 +91,14 @@ struct __true_type {};\n struct __false_type {};\n \n template <class _Tp>\n-struct __type_traits { \n-   typedef __true_type     this_dummy_member_must_be_first;\n-                   /* Do not remove this member. It informs a compiler which\n-                      automatically specializes __type_traits that this\n-                      __type_traits template is special. It just makes sure that\n-                      things work if an implementation is using a template\n-                      called __type_traits for something unrelated. */\n+  struct __type_traits\n+  { \n+    typedef __true_type     this_dummy_member_must_be_first;\n+    /* Do not remove this member. It informs a compiler which\n+       automatically specializes __type_traits that this\n+       __type_traits template is special. It just makes sure that\n+       things work if an implementation is using a template\n+       called __type_traits for something unrelated. */\n \n    /* The following restrictions should be observed for the sake of\n       compilers which automatically produce type specific specializations \n@@ -110,227 +111,292 @@ struct __type_traits {\n             you add the appropriate support in the compiler. */\n  \n \n-   typedef __false_type    has_trivial_default_constructor;\n-   typedef __false_type    has_trivial_copy_constructor;\n-   typedef __false_type    has_trivial_assignment_operator;\n-   typedef __false_type    has_trivial_destructor;\n-   typedef __false_type    is_POD_type;\n-};\n+    typedef __false_type    has_trivial_default_constructor;\n+    typedef __false_type    has_trivial_copy_constructor;\n+    typedef __false_type    has_trivial_assignment_operator;\n+    typedef __false_type    has_trivial_destructor;\n+    typedef __false_type    is_POD_type;\n+  };\n \n \n // Provide some specializations.\n \n-template<> struct __type_traits<bool> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<char> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<signed char> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<unsigned char> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<wchar_t> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<short> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<unsigned short> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<int> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<unsigned int> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<long> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<unsigned long> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<long long> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<unsigned long long> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<float> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<double> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-template<> struct __type_traits<long double> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n+template<>\n+  struct __type_traits<bool>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<char>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<signed char>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<unsigned char>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<wchar_t>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<short>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<unsigned short>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<int>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<unsigned int>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<long>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<unsigned long>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<long long>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<unsigned long long>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<float>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<double>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n+\n+template<>\n+  struct __type_traits<long double>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n \n template <class _Tp>\n-struct __type_traits<_Tp*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n+  struct __type_traits<_Tp*>\n+  {\n+    typedef __true_type    has_trivial_default_constructor;\n+    typedef __true_type    has_trivial_copy_constructor;\n+    typedef __true_type    has_trivial_assignment_operator;\n+    typedef __true_type    has_trivial_destructor;\n+    typedef __true_type    is_POD_type;\n+  };\n \n // The following could be written in terms of numeric_limits.  \n // We're doing it separately to reduce the number of dependencies.\n \n-template <class _Tp> struct _Is_integer {\n-  typedef __false_type _Integral;\n-};\n-\n-template<> struct _Is_integer<bool> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<char> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<signed char> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<unsigned char> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<wchar_t> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<short> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<unsigned short> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<int> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<unsigned int> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<long> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<unsigned long> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<long long> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<> struct _Is_integer<unsigned long long> {\n-  typedef __true_type _Integral;\n-};\n-\n-template<typename _Tp> struct _Is_normal_iterator {\n-   typedef __false_type _Normal;\n-};\n+template <class _Tp>\n+  struct _Is_integer\n+  {\n+    typedef __false_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<bool>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<char>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<signed char>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<unsigned char>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<wchar_t>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<short>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<unsigned short>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<int>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<unsigned int>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<long>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<unsigned long>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<long long>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<>\n+  struct _Is_integer<unsigned long long>\n+  {\n+    typedef __true_type _Integral;\n+  };\n+\n+template<typename _Tp>\n+  struct _Is_normal_iterator\n+  {\n+    typedef __false_type _Normal;\n+  };\n \n // Forward declaration hack, should really include this from somewhere.\n namespace __gnu_cxx\n {\n-  template<typename _Iterator, typename _Container> class __normal_iterator;\n+  template<typename _Iterator, typename _Container>\n+    class __normal_iterator;\n }\n \n template<typename _Iterator, typename _Container>\n-struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator, _Container> > {\n-   typedef __true_type _Normal;\n-};\n+  struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,\n+\t\t\t\t\t\t\t   _Container> >\n+  {\n+    typedef __true_type _Normal;\n+  };\n \n #endif /* _TYPE_TRAITS_H */\n "}]}