{"sha": "a687e8971c51d7dfe8ba671126ccc52e197ffba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4N2U4OTcxYzUxZDdkZmU4YmE2NzExMjZjY2M1MmUxOTdmZmJhOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T11:07:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T11:07:22Z"}, "message": "(simplify_comparison): Add a few more cases where we can do the\ncomparison in a wider mode.\n\n(distribute_notes, REG_EQUAL): Don't put back a note with a\nnon-constant expression since it may no longer be valid.\n\nFrom-SVN: r1894", "tree": {"sha": "5d44a5d39ff2679333fee5028b33e0740a819a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d44a5d39ff2679333fee5028b33e0740a819a56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a687e8971c51d7dfe8ba671126ccc52e197ffba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a687e8971c51d7dfe8ba671126ccc52e197ffba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a687e8971c51d7dfe8ba671126ccc52e197ffba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a687e8971c51d7dfe8ba671126ccc52e197ffba9/comments", "author": null, "committer": null, "parents": [{"sha": "5c0628165586764d029e4b762565f2dbdd3eb082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0628165586764d029e4b762565f2dbdd3eb082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0628165586764d029e4b762565f2dbdd3eb082"}], "stats": {"total": 91, "additions": 72, "deletions": 19}, "files": [{"sha": "55b9dd77e1e2e555319fbdfe130b62f92611a107", "filename": "gcc/combine.c", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a687e8971c51d7dfe8ba671126ccc52e197ffba9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a687e8971c51d7dfe8ba671126ccc52e197ffba9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a687e8971c51d7dfe8ba671126ccc52e197ffba9", "patch": "@@ -7547,6 +7547,35 @@ simplify_comparison (code, pop0, pop1)\n \t  /* If the inner mode is narrower and we are extracting the low part,\n \t     we can treat the SUBREG as if it were a ZERO_EXTEND.  */\n \t  if (subreg_lowpart_p (op0)\n+\t  /* Check for the case where we are comparing A - C1 with C2,\n+\t     both constants are smaller than 1/2 the maxium positive\n+\t     value in MODE, and the comparison is equality or unsigned.\n+\t     In that case, if A is either zero-extended to MODE or has\n+\t     sufficient sign bits so that the high-order bit in MODE\n+\t     is a copy of the sign in the inner mode, we can prove that it is\n+\t     safe to do the operation in the wider mode.  This simplifies\n+\t     many range checks.  */\n+\n+\t  if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t      && subreg_lowpart_p (op0)\n+\t      && GET_CODE (SUBREG_REG (op0)) == PLUS\n+\t      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT\n+\t      && INTVAL (XEXP (SUBREG_REG (op0), 1)) < 0\n+\t      && (- INTVAL (XEXP (SUBREG_REG (op0), 1))\n+\t\t  < GET_MODE_MASK (mode) / 2)\n+\t      && (unsigned) const_op < GET_MODE_MASK (mode) / 2\n+\t      && (0 == (significant_bits (XEXP (SUBREG_REG (op0), 0),\n+\t\t\t\t\t  GET_MODE (SUBREG_REG (op0)))\n+\t\t\t& ~ GET_MODE_MASK (mode))\n+\t\t  || (num_sign_bit_copies (XEXP (SUBREG_REG (op0), 0),\n+\t\t\t\t\t   GET_MODE (SUBREG_REG (op0)))\n+\t\t      > (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n+\t\t\t - GET_MODE_BITSIZE (mode)))))\n+\t    {\n+\t      op0 = SUBREG_REG (op0);\n+\t      continue;\n+\t    }\n+\n \t      && GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0))) < mode_width)\n \t    /* Fall through */ ;\n \t  else\n@@ -7890,11 +7919,8 @@ simplify_comparison (code, pop0, pop1)\n   /* We now do the opposite procedure: Some machines don't have compare\n      insns in all modes.  If OP0's mode is an integer mode smaller than a\n      word and we can't do a compare in that mode, see if there is a larger\n-     mode for which we can do the compare and where the only significant\n-     bits in OP0 and OP1 are those in the narrower mode.  We can do\n-     this if this is an equality comparison, in which case we can\n-     merely widen the operation, or if we are testing the sign bit, in\n-     which case we can explicitly put in the test.  */\n+     mode for which we can do the compare.  There are a number of cases in\n+     which we can use the wider mode.  */\n \n   mode = GET_MODE (op0);\n   if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT\n@@ -7904,25 +7930,43 @@ simplify_comparison (code, pop0, pop1)\n \t (tmode != VOIDmode\n \t  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT);\n \t tmode = GET_MODE_WIDER_MODE (tmode))\n-      if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing\n-\t  && (significant_bits (op0, tmode) & ~ GET_MODE_MASK (mode)) == 0\n-\t  && (significant_bits (op1, tmode) & ~ GET_MODE_MASK (mode)) == 0\n-\t  && (code == EQ || code == NE\n-\t      || (op1 == const0_rtx && (code == LT || code == GE)\n-\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)))\n+      if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n \t{\n-\t  op0 = gen_lowpart_for_combine (tmode, op0);\n-\t  op1 = gen_lowpart_for_combine (tmode, op1);\n+\t  /* If the only significant bits in OP0 and OP1 are those in the\n+\t     narrower mode and this is an equality or unsigned comparison,\n+\t     we can use the wider mode.  Similarly for sign-extended\n+\t     values and equality or signed comparisons.  */\n+\t  if (((code == EQ || code == NE\n+\t\t|| code == GEU || code == GTU || code == LEU || code == LTU)\n+\t       && ((significant_bits (op0, tmode) & ~ GET_MODE_MASK (mode))\n+\t\t   == 0)\n+\t       && ((significant_bits (op1, tmode) & ~ GET_MODE_MASK (mode))\n+\t\t   == 0))\n+\t      || ((code == EQ || code == NE\n+\t\t   || code == GE || code == GT || code == LE || code == LT)\n+\t\t  && (num_sign_bit_copies (op0, tmode)\n+\t\t      >= GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))\n+\t\t  && (num_sign_bit_copies (op1, tmode)\n+\t\t      >= GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))))\n+\t    {\n+\t      op0 = gen_lowpart_for_combine (tmode, op0);\n+\t      op1 = gen_lowpart_for_combine (tmode, op1);\n+\t      break;\n+\t    }\n \n-\t  if (code == LT || code == GE)\n+\t  /* If this is a test for negative, we can make an explicit\n+\t     test of the sign bit.  */\n+\n+\t  if (op1 == const0_rtx && (code == LT || code == GE)\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = gen_binary (AND, tmode, op0,\n+\t      op0 = gen_binary (AND, tmode,\n+\t\t\t\tgen_lowpart_for_combine (tmode, op0),\n \t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n \t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n \t      code = (code == LT) ? NE : EQ;\n+\t      break;\n \t    }\n-\n-\t  break;\n \t}\n \n   *pop0 = op0;\n@@ -8624,8 +8668,17 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \tcase REG_NONNEG:\n \t  /* These notes say something about results of an insn.  We can\n \t     only support them if they used to be on I3 in which case they\n-\t     remain on I3.  Otherwise they are ignored.  */\n-\t  if (from_insn == i3)\n+\t     remain on I3.  Otherwise they are ignored.\n+\n+\t     If the note refers to an expression that is not a constant, we\n+\t     must also ignore the note since we cannot tell whether the\n+\t     equivalence is still true.  It might be possible to do\n+\t     slightly better than this (we only have a problem if I2DEST\n+\t     or I1DEST is present in the expression), but it doesn't\n+\t     seem worth the trouble.  */\n+\n+\t  if (from_insn == i3\n+\t      && (XEXP (note, 0) == 0 || CONSTANT_P (XEXP (note, 0))))\n \t    place = i3;\n \t  break;\n "}]}