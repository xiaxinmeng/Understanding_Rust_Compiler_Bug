{"sha": "a4242737202af64a394f5271c06b8be1979cbcfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyNDI3MzcyMDJhZjY0YTM5NGY1MjcxYzA2YjhiZTE5NzljYmNmYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-05-14T13:52:18Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-05-14T13:52:18Z"}, "message": "m68k-protos.h: Rename m68k_interrupt_function_p to m68k_get_function_kind.\n\ngcc/\n\t* config/m68k/m68k-protos.h: Rename m68k_interrupt_function_p\n\tto m68k_get_function_kind.  Update its prototype.\n\t* config/m68k/m68k.c (m68k_attribute_table): Add an entry for\n\tinterrupt_thread.\n\t(m68k_interrupt_function_p): Return enum m68k_function_type\n\tinstead of bool.  Rename to m68k_get_function_kind.\n\t(m68k_handle_fndecl_attribute): Reject interrupt_thread if the\n\ttarget is not fido.\n\t(m68k_compute_frame_layout): Don't mark any register for save\n\tif an interrupt_thread attribute is specified.\n\t(m68k_hard_regno_rename_ok): Update a use of\n\tm68k_interrupt_function_p.\n\t* config/m68k/m68k.h (EPILOGUE_USES): Update a use of\n\tm68k_interrupt_function_p.\n\t(m68k_function_type): New.\n\t* config/m68k/m68k.md (*return): Output a 'sleep' instruction\n\tfor a function with an interrupt_thread attribute.\n\t* doc/extend.texi: Document the interrupt_thread attribute.\n\ngcc/testsuite/\n\t* gcc.target/m68k/interrupt_thread-1.c,\n\tgcc.target/m68k/interrupt_thread-2.c,\n\tgcc.target/m68k/interrupt_thread-3.c: New.\n\t* gcc.target/m68k/m68k.exp: Accept fido.\n\nFrom-SVN: r124713", "tree": {"sha": "cffefaf9bacdbe3a58b51e69c4fd92063f10a19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cffefaf9bacdbe3a58b51e69c4fd92063f10a19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4242737202af64a394f5271c06b8be1979cbcfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4242737202af64a394f5271c06b8be1979cbcfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4242737202af64a394f5271c06b8be1979cbcfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4242737202af64a394f5271c06b8be1979cbcfb/comments", "author": null, "committer": null, "parents": [{"sha": "ab6bd6931e768e2348d83da9188d75f24247ff04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6bd6931e768e2348d83da9188d75f24247ff04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6bd6931e768e2348d83da9188d75f24247ff04"}], "stats": {"total": 145, "additions": 115, "deletions": 30}, "files": [{"sha": "d470dabc4e31e29913b1015c8dea9b2e47004384", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -1,3 +1,24 @@\n+2007-05-14  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/m68k/m68k-protos.h: Rename m68k_interrupt_function_p\n+\tto m68k_get_function_kind.  Update its prototype.\n+\t* config/m68k/m68k.c (m68k_attribute_table): Add an entry for\n+\tinterrupt_thread.\n+\t(m68k_interrupt_function_p): Return enum m68k_function_type\n+\tinstead of bool.  Rename to m68k_get_function_kind.\n+\t(m68k_handle_fndecl_attribute): Reject interrupt_thread if the\n+\ttarget is not fido.\n+\t(m68k_compute_frame_layout): Don't mark any register for save\n+\tif an interrupt_thread attribute is specified.\n+\t(m68k_hard_regno_rename_ok): Update a use of\n+\tm68k_interrupt_function_p.\n+\t* config/m68k/m68k.h (EPILOGUE_USES): Update a use of\n+\tm68k_interrupt_function_p.\n+\t(m68k_function_type): New.\n+\t* config/m68k/m68k.md (*return): Output a 'sleep' instruction\n+\tfor a function with an interrupt_thread attribute.\n+\t* doc/extend.texi: Document the interrupt_thread attribute.\n+\n 2007-05-13  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/31911"}, {"sha": "f5d6c3af76e4dff7654b1866cd92f55197c89916", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -21,7 +21,7 @@ Boston, MA 02110-1301, USA.  */\n /* Define functions defined in aux-output.c and used in templates.  */\n \n #ifdef RTX_CODE\n-extern bool m68k_interrupt_function_p (tree);\n+extern enum m68k_function_kind m68k_get_function_kind (tree);\n extern HOST_WIDE_INT m68k_initial_elimination_offset (int from, int to);\n \n extern void split_di (rtx[], int, rtx[], rtx[]);"}, {"sha": "87665596726f734cde3704f8d8b3aad19a3995fb", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -223,6 +223,7 @@ static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"interrupt_handler\", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },\n+  { \"interrupt_thread\", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },\n   { NULL,                0, 0, false, false, false, NULL }\n };\n \n@@ -633,18 +634,27 @@ m68k_cpp_cpu_family (const char *prefix)\n   return concat (\"__m\", prefix, \"_family_\", m68k_cpu_entry->family, NULL);\n }\n \f\n-/* Return nonzero if FUNC is an interrupt function as specified by the\n-   \"interrupt_handler\" attribute.  */\n-bool\n-m68k_interrupt_function_p (tree func)\n+/* Return m68k_fk_interrupt_handler if FUNC has an \"interrupt_handler\"\n+   attribute and interrupt_thread if FUNC has an \"interrupt_thread\"\n+   attribute.  Otherwise, return m68k_fk_normal_function.  */\n+\n+enum m68k_function_kind\n+m68k_get_function_kind (tree func)\n {\n   tree a;\n \n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return false;\n \n   a = lookup_attribute (\"interrupt_handler\", DECL_ATTRIBUTES (func));\n-  return (a != NULL_TREE);\n+  if (a != NULL_TREE)\n+    return m68k_fk_interrupt_handler;\n+\n+  a = lookup_attribute (\"interrupt_thread\", DECL_ATTRIBUTES (func));\n+  if (a != NULL_TREE)\n+    return m68k_fk_interrupt_thread;\n+\n+  return m68k_fk_normal_function;\n }\n \n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n@@ -662,6 +672,19 @@ m68k_handle_fndecl_attribute (tree *node, tree name,\n       *no_add_attrs = true;\n     }\n \n+  if (m68k_get_function_kind (*node) != m68k_fk_normal_function)\n+    {\n+      error (\"multiple interrupt attributes not allowed\");\n+      *no_add_attrs = true;\n+    }\n+\n+  if (!TARGET_FIDOA\n+      && !strcmp (IDENTIFIER_POINTER (name), \"interrupt_thread\"))\n+    {\n+      error (\"interrupt_thread is available only on fido\");\n+      *no_add_attrs = true;\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -670,7 +693,10 @@ m68k_compute_frame_layout (void)\n {\n   int regno, saved;\n   unsigned int mask;\n-  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n+  enum m68k_function_kind func_kind =\n+    m68k_get_function_kind (current_function_decl);\n+  bool interrupt_handler = func_kind == m68k_fk_interrupt_handler;\n+  bool interrupt_thread = func_kind == m68k_fk_interrupt_thread;\n \n   /* Only compute the frame once per function.\n      Don't cache information until reload has been completed.  */\n@@ -681,12 +707,15 @@ m68k_compute_frame_layout (void)\n   current_frame.size = (get_frame_size () + 3) & -4;\n \n   mask = saved = 0;\n-  for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno, interrupt_handler))\n-      {\n-\tmask |= 1 << (regno - D0_REG);\n-\tsaved++;\n-      }\n+\n+  /* Interrupt thread does not need to save any register.  */\n+  if (!interrupt_thread)\n+    for (regno = 0; regno < 16; regno++)\n+      if (m68k_save_reg (regno, interrupt_handler))\n+\t{\n+\t  mask |= 1 << (regno - D0_REG);\n+\t  saved++;\n+\t}\n   current_frame.offset = saved * 4;\n   current_frame.reg_no = saved;\n   current_frame.reg_mask = mask;\n@@ -695,12 +724,14 @@ m68k_compute_frame_layout (void)\n   mask = saved = 0;\n   if (TARGET_HARD_FLOAT)\n     {\n-      for (regno = 16; regno < 24; regno++)\n-\tif (m68k_save_reg (regno, interrupt_handler))\n-\t  {\n-\t    mask |= 1 << (regno - FP0_REG);\n-\t    saved++;\n-\t  }\n+      /* Interrupt thread does not need to save any register.  */\n+      if (!interrupt_thread)\n+\tfor (regno = 16; regno < 24; regno++)\n+\t  if (m68k_save_reg (regno, interrupt_handler))\n+\t    {\n+\t      mask |= 1 << (regno - FP0_REG);\n+\t      saved++;\n+\t    }\n       current_frame.foffset = saved * TARGET_FP_REG_SIZE;\n       current_frame.offset += current_frame.foffset;\n     }\n@@ -4211,7 +4242,8 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n      saved by the prologue, even if they would normally be\n      call-clobbered.  */\n \n-  if (m68k_interrupt_function_p (current_function_decl)\n+  if ((m68k_get_function_kind (current_function_decl)\n+       == m68k_fk_interrupt_handler)\n       && !regs_ever_live[new_reg])\n     return 0;\n "}, {"sha": "1b19b4c80957072b0d30b8fd90bcbecde62248ee", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -903,8 +903,10 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n #define INCOMING_FRAME_SP_OFFSET 4\n \n /* All registers are live on exit from an interrupt routine.  */\n-#define EPILOGUE_USES(REGNO) \\\n-  (reload_completed && m68k_interrupt_function_p (current_function_decl))\n+#define EPILOGUE_USES(REGNO)\t\t\t\t\t\\\n+  (reload_completed\t\t\t\t\t\t\\\n+   && (m68k_get_function_kind (current_function_decl)\t\\\n+       == m68k_fk_interrupt_handler))\n \n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) \\\n@@ -1098,6 +1100,13 @@ enum fpu_type\n   FPUTYPE_COLDFIRE\n };\n \n+enum m68k_function_kind\n+{\n+  m68k_fk_normal_function,\n+  m68k_fk_interrupt_handler,\n+  m68k_fk_interrupt_thread\n+};\n+\n /* Variables in m68k.c; see there for details.  */\n extern const char *m68k_library_id_string;\n extern int m68k_last_compare_had_fp_operands;"}, {"sha": "19abe624c293c0043313aa0bed5f80352afc5ec1", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -6833,15 +6833,23 @@\n   [(return)]\n   \"\"\n {\n-  if (m68k_interrupt_function_p (current_function_decl))\n-    return \"rte\";\n-  else if (current_function_pops_args)\n+  switch (m68k_get_function_kind (current_function_decl))\n     {\n-      operands[0] = GEN_INT (current_function_pops_args);\n-      return \"rtd %0\";\n+    case m68k_fk_interrupt_handler:\n+      return \"rte\";\n+\n+    case m68k_fk_interrupt_thread:\n+      return \"sleep\";\n+\n+    default:\n+      if (current_function_pops_args)\n+\t{\n+\t  operands[0] = GEN_INT (current_function_pops_args);\n+\t  return \"rtd %0\";\n+\t}\n+      else\n+\treturn \"rts\";\n     }\n-  else\n-    return \"rts\";\n })\n \n (define_insn \"*m68k_store_multiple\""}, {"sha": "4a8f67455cccf027844160a1e1ec7f22caddbb04", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -2047,6 +2047,14 @@ indicate that the specified function is an interrupt handler.  The compiler\n will generate function entry and exit sequences suitable for use in an\n interrupt handler when this attribute is present.\n \n+@item interrupt_thread\n+@cindex interrupt thread functions on fido\n+Use this attribute on fido, a subarchitecture of the m68k, to indicate\n+that the specified function is an interrupt handler that is designed\n+to run as a thread.  The compiler omits generate prologue/epilogue\n+sequences and replaces the return instruction with a @code{sleep}\n+instruction.  This attribute is available only on fido.\n+\n @item kspisusp\n @cindex User stack pointer in interrupts on the Blackfin\n When used together with @code{interrupt_handler}, @code{exception_handler}"}, {"sha": "0c3111793de653a1c4deb0702f3f3e3c42b32a4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -1,3 +1,10 @@\n+2007-05-14  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* gcc.target/m68k/interrupt_thread-1.c,\n+\tgcc.target/m68k/interrupt_thread-2.c,\n+\tgcc.target/m68k/interrupt_thread-3.c: New.\n+\t* gcc.target/m68k/m68k.exp: Accept fido.\n+\n 2007-05-13  Dominique d'Humi\u00e8res  <dominiq@lps.ens.fr>\n \n \t* alloc_comp_basics_1.f90: Fix dg directive."}, {"sha": "872802d958630fdcd9aed7345150bb437b8c0cf2", "filename": "gcc/testsuite/gcc.target/m68k/m68k.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fm68k.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4242737202af64a394f5271c06b8be1979cbcfb/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fm68k.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fm68k.exp?ref=a4242737202af64a394f5271c06b8be1979cbcfb", "patch": "@@ -17,7 +17,7 @@\n # GCC testsuite that uses the `dg.exp' driver.\n \n # Exit immediately if this isn't an m68k target.\n-if ![istarget m68k*-*-*] then {\n+if { ![istarget m68k*-*-*] && ![istarget fido*-*-*] } then {\n   return\n }\n "}]}