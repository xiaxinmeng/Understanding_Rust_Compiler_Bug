{"sha": "1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkNmU5MDRkNGZiYWQ3MTZiYzY1YWM0ZDBiYmRlZWNmM2Y1NTJiYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-01-11T20:49:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-01-11T20:49:40Z"}, "message": "re PR target/83203 (Inefficient int to avx2 vector conversion)\n\n\tPR target/83203\n\t* config/i386/i386.c (ix86_expand_vector_init_one_nonzero): If one_var\n\tis 0, for V{8,16}S[IF] and V[48]D[IF]mode use gen_vec_set<mode>_0.\n\t* config/i386/sse.md (VI8_AVX_AVX512F, VI4F_256_512): New mode\n\titerators.\n\t(ssescalarmodesuffix): Add 512-bit vectors.  Use \"d\" or \"q\" for\n\tintegral modes instead of \"ss\" and \"sd\".\n\t(vec_set<mode>_0): New define_insns for 256-bit and 512-bit\n\tvectors with 32-bit and 64-bit elements.\n\t(vecdupssescalarmodesuffix): New mode attribute.\n\t(vec_dup<mode>): Use it.\n\nFrom-SVN: r256556", "tree": {"sha": "77ec76733b526b9d1f30881e7026cbc4c872d8ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77ec76733b526b9d1f30881e7026cbc4c872d8ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7a61831d6ecec501acf0da0a227bd954e1d8922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a61831d6ecec501acf0da0a227bd954e1d8922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a61831d6ecec501acf0da0a227bd954e1d8922"}], "stats": {"total": 114, "additions": 111, "deletions": 3}, "files": [{"sha": "3a37576a7a92e83605a22bdd35211445e0719bfd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "patch": "@@ -1,3 +1,17 @@\n+2018-01-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/83203\n+\t* config/i386/i386.c (ix86_expand_vector_init_one_nonzero): If one_var\n+\tis 0, for V{8,16}S[IF] and V[48]D[IF]mode use gen_vec_set<mode>_0.\n+\t* config/i386/sse.md (VI8_AVX_AVX512F, VI4F_256_512): New mode\n+\titerators.\n+\t(ssescalarmodesuffix): Add 512-bit vectors.  Use \"d\" or \"q\" for\n+\tintegral modes instead of \"ss\" and \"sd\".\n+\t(vec_set<mode>_0): New define_insns for 256-bit and 512-bit\n+\tvectors with 32-bit and 64-bit elements.\n+\t(vecdupssescalarmodesuffix): New mode attribute.\n+\t(vec_dup<mode>): Use it.\n+\n 2018-01-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/83330"}, {"sha": "d625670c35ca849b0877fe14ce34e04a564e7920", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "patch": "@@ -41767,6 +41767,7 @@ ix86_expand_vector_init_one_nonzero (bool mmx_ok, machine_mode mode,\n   rtx new_target;\n   rtx x, tmp;\n   bool use_vector_set = false;\n+  rtx (*gen_vec_set_0) (rtx, rtx, rtx) = NULL;\n \n   switch (mode)\n     {\n@@ -41791,21 +41792,54 @@ ix86_expand_vector_init_one_nonzero (bool mmx_ok, machine_mode mode,\n       break;\n     case E_V32QImode:\n     case E_V16HImode:\n+      use_vector_set = TARGET_AVX;\n+      break;\n     case E_V8SImode:\n+      use_vector_set = TARGET_AVX;\n+      gen_vec_set_0 = gen_vec_setv8si_0;\n+      break;\n     case E_V8SFmode:\n+      use_vector_set = TARGET_AVX;\n+      gen_vec_set_0 = gen_vec_setv8sf_0;\n+      break;\n     case E_V4DFmode:\n       use_vector_set = TARGET_AVX;\n+      gen_vec_set_0 = gen_vec_setv4df_0;\n       break;\n     case E_V4DImode:\n       /* Use ix86_expand_vector_set in 64bit mode only.  */\n       use_vector_set = TARGET_AVX && TARGET_64BIT;\n+      gen_vec_set_0 = gen_vec_setv4di_0;\n+      break;\n+    case E_V16SImode:\n+      use_vector_set = TARGET_AVX512F && one_var == 0;\n+      gen_vec_set_0 = gen_vec_setv16si_0;\n+      break;\n+    case E_V16SFmode:\n+      use_vector_set = TARGET_AVX512F && one_var == 0;\n+      gen_vec_set_0 = gen_vec_setv16sf_0;\n+      break;\n+    case E_V8DFmode:\n+      use_vector_set = TARGET_AVX512F && one_var == 0;\n+      gen_vec_set_0 = gen_vec_setv8df_0;\n+      break;\n+    case E_V8DImode:\n+      /* Use ix86_expand_vector_set in 64bit mode only.  */\n+      use_vector_set = TARGET_AVX512F && TARGET_64BIT && one_var == 0;\n+      gen_vec_set_0 = gen_vec_setv8di_0;\n       break;\n     default:\n       break;\n     }\n \n   if (use_vector_set)\n     {\n+      if (gen_vec_set_0 && one_var == 0)\n+\t{\n+\t  var = force_reg (GET_MODE_INNER (mode), var);\n+\t  emit_insn (gen_vec_set_0 (target, CONST0_RTX (mode), var));\n+\t  return true;\n+\t}\n       emit_insn (gen_rtx_SET (target, CONST0_RTX (mode)));\n       var = force_reg (GET_MODE_INNER (mode), var);\n       ix86_expand_vector_set (mmx_ok, target, var, one_var);"}, {"sha": "24197a8b3c38a7d7cab5295161d3c5f0aed94b38", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=1ad6e904d4fbad716bc65ac4d0bbdeecf3f552bc", "patch": "@@ -401,6 +401,9 @@\n (define_mode_iterator VI8_AVX2_AVX512F\n   [(V8DI \"TARGET_AVX512F\") (V4DI \"TARGET_AVX2\") V2DI])\n \n+(define_mode_iterator VI8_AVX_AVX512F\n+  [(V8DI \"TARGET_AVX512F\") (V4DI \"TARGET_AVX\")])\n+\n (define_mode_iterator VI4_128_8_256\n   [V4SI V4DI])\n \n@@ -622,6 +625,9 @@\n (define_mode_iterator VI8F_128 [V2DI V2DF])\n (define_mode_iterator VI4F_256 [V8SI V8SF])\n (define_mode_iterator VI8F_256 [V4DI V4DF])\n+(define_mode_iterator VI4F_256_512\n+  [V8SI V8SF\n+   (V16SI \"TARGET_AVX512F\") (V16SF \"TARGET_AVX512F\")])\n (define_mode_iterator VI48F_256_512\n   [V8SI V8SF\n   (V16SI \"TARGET_AVX512F\") (V16SF \"TARGET_AVX512F\")\n@@ -838,10 +844,12 @@\n ;; SSE scalar suffix for vector modes\n (define_mode_attr ssescalarmodesuffix\n   [(SF \"ss\") (DF \"sd\")\n+   (V16SF \"ss\") (V8DF \"sd\")\n    (V8SF \"ss\") (V4DF \"sd\")\n    (V4SF \"ss\") (V2DF \"sd\")\n-   (V8SI \"ss\") (V4DI \"sd\")\n-   (V4SI \"d\")])\n+   (V16SI \"d\") (V8DI \"q\")\n+   (V8SI \"d\") (V4DI \"q\")\n+   (V4SI \"d\") (V2DI \"q\")])\n \n ;; Pack/unpack vector modes\n (define_mode_attr sseunpackmode\n@@ -7092,6 +7100,26 @@\n    (set_attr \"prefix\" \"orig,orig,maybe_evex\")\n    (set_attr \"mode\" \"V4SF\")])\n \n+;; All of vinsertps, vmovss, vmovd clear also the higher bits.\n+(define_insn \"vec_set<mode>_0\"\n+  [(set (match_operand:VI4F_256_512 0 \"register_operand\" \"=v,v,Yi\")\n+\t(vec_merge:VI4F_256_512\n+\t  (vec_duplicate:VI4F_256_512\n+\t    (match_operand:<ssescalarmode> 2 \"general_operand\" \"v,m,r\"))\n+\t  (match_operand:VI4F_256_512 1 \"const0_operand\" \"C,C,C\")\n+\t  (const_int 1)))]\n+  \"TARGET_AVX\"\n+  \"@\n+   vinsertps\\t{$0xe, %2, %2, %x0|%x0, %2, %2, 0xe}\n+   vmov<ssescalarmodesuffix>\\t{%x2, %x0|%x0, %2}\n+   vmovd\\t{%2, %x0|%x0, %2}\"\n+  [(set (attr \"type\")\n+     (if_then_else (eq_attr \"alternative\" \"0\")\n+\t\t   (const_string \"sselog\")\n+\t\t   (const_string \"ssemov\")))\n+   (set_attr \"prefix\" \"maybe_evex\")\n+   (set_attr \"mode\" \"SF,<ssescalarmode>,SI\")])\n+\n (define_insn \"sse4_1_insertps\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=Yr,*x,v\")\n \t(unspec:V4SF [(match_operand:V4SF 2 \"nonimmediate_operand\" \"Yrm,*xm,vm\")\n@@ -9220,6 +9248,20 @@\n \t   (const_string \"orig\")))\n    (set_attr \"mode\" \"V2DF,V2DF,V2DF, DF, DF, V1DF,V1DF,DF,V4SF,V2SF\")])\n \n+;; vmovq clears also the higher bits.\n+(define_insn \"vec_set<mode>_0\"\n+  [(set (match_operand:VF2_512_256 0 \"register_operand\" \"=v\")\n+\t(vec_merge:VF2_512_256\n+\t  (vec_duplicate:VF2_512_256\n+\t    (match_operand:<ssescalarmode> 2 \"general_operand\" \"xm\"))\n+\t  (match_operand:VF2_512_256 1 \"const0_operand\" \"C\")\n+\t  (const_int 1)))]\n+  \"TARGET_AVX\"\n+  \"vmovq\\t{%2, %x0|%x0, %2}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix\" \"maybe_evex\")\n+   (set_attr \"mode\" \"DF\")])\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel integer down-conversion operations\n@@ -13993,6 +14035,22 @@\n \t   (const_string \"orig\")))\n    (set_attr \"mode\" \"TI,TI,TI,TI,TI,TI,TI,TI,TI,V4SF,V2SF,V2SF\")])\n \n+;; vmovq clears also the higher bits.\n+(define_insn \"vec_set<mode>_0\"\n+  [(set (match_operand:VI8_AVX_AVX512F 0 \"register_operand\" \"=Yi,v\")\n+\t(vec_merge:VI8_AVX_AVX512F\n+\t  (vec_duplicate:VI8_AVX_AVX512F\n+\t    (match_operand:<ssescalarmode> 2 \"general_operand\" \"r,vm\"))\n+\t  (match_operand:VI8_AVX_AVX512F 1 \"const0_operand\" \"C,C\")\n+\t  (const_int 1)))]\n+  \"TARGET_AVX\"\n+  \"vmovq\\t{%2, %x0|%x0, %2}\"\n+  [(set_attr \"isa\" \"x64,*\")\n+   (set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix_rex\" \"1,*\")\n+   (set_attr \"prefix\" \"maybe_evex\")\n+   (set_attr \"mode\" \"TI\")])\n+\n (define_expand \"vec_unpacks_lo_<mode>\"\n   [(match_operand:<sseunpackmode> 0 \"register_operand\")\n    (match_operand:VI124_AVX2_24_AVX512F_1_AVX512BW 1 \"register_operand\")]\n@@ -17743,6 +17801,8 @@\n ;; Modes handled by AVX vec_dup patterns.\n (define_mode_iterator AVX_VEC_DUP_MODE\n   [V8SI V8SF V4DI V4DF])\n+(define_mode_attr vecdupssescalarmodesuffix\n+  [(V8SF \"ss\") (V4DF \"sd\") (V8SI \"ss\") (V4DI \"sd\")])\n ;; Modes handled by AVX2 vec_dup patterns.\n (define_mode_iterator AVX2_VEC_DUP_MODE\n   [V32QI V16QI V16HI V8HI V8SI V4SI])\n@@ -17769,7 +17829,7 @@\n   \"TARGET_AVX\"\n   \"@\n    v<sseintprefix>broadcast<bcstscalarsuff>\\t{%1, %0|%0, %1}\n-   vbroadcast<ssescalarmodesuffix>\\t{%1, %0|%0, %1}\n+   vbroadcast<vecdupssescalarmodesuffix>\\t{%1, %0|%0, %1}\n    v<sseintprefix>broadcast<bcstscalarsuff>\\t{%x1, %0|%0, %x1}\n    v<sseintprefix>broadcast<bcstscalarsuff>\\t{%x1, %g0|%g0, %x1}\n    #\""}]}