{"sha": "4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "node_id": "C_kwDOANBUbNoAKDRiNzk2NjE5MWE2OTIzOGM2ZDZmZDU1MzdiM2U3N2MzYTQwMjdlYjI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-13T14:22:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-13T14:22:21Z"}, "message": "machmode: Introduce GET_MODE_NEXT_MODE with previous GET_MODE_WIDER_MODE meaning, add new GET_MODE_WIDER_MODE\n\nOn Wed, Oct 05, 2022 at 04:02:25PM -0400, Jason Merrill wrote:\n> > > > @@ -5716,7 +5716,13 @@ emit_store_flag_1 (rtx target, enum rtx_\n> > > >        {\n> > > >         machine_mode optab_mode = mclass == MODE_CC ? CCmode : compare_mode;\n> > > >         icode = optab_handler (cstore_optab, optab_mode);\n> > > > -     if (icode != CODE_FOR_nothing)\n> > > > +     if (icode != CODE_FOR_nothing\n> > > > +        /* Don't consider [BH]Fmode as usable wider mode, as neither is\n> > > > +           a subset or superset of the other.  */\n> > > > +        && (compare_mode == mode\n> > > > +            || !SCALAR_FLOAT_MODE_P (compare_mode)\n> > > > +            || maybe_ne (GET_MODE_PRECISION (compare_mode),\n> > > > +                         GET_MODE_PRECISION (mode))))\n> > >\n> > > Why do you need to do this here (and in prepare_cmp_insn, and similarly in\n> > > can_compare_p)?  Shouldn't get_wider skip over modes that are not actually\n> > > wider?\n> >\n> > I'm afraid too many places rely on all modes of a certain class to be\n> > visible when walking from \"narrowest\" to \"widest\" mode, say\n> > FOR_EACH_MODE_IN_CLASS/FOR_EACH_MODE/FOR_EACH_MODE_UNTIL/FOR_EACH_WIDER_MODE\n> > etc. wouldn't work at all if GET_MODE_WIDER_MODE (BFmode) == SFmode\n> > && GET_MODE_WIDER_MODE (HFmode) == SFmode.\n>\n> Yes, it seems they need to change now that their assumptions have been\n> violated.  I suppose FOR_EACH_MODE_IN_CLASS would need to change to not use\n> get_wider, and users of FOR_EACH_MODE/FOR_EACH_MODE_UNTIL need to decide\n> whether they want an iteration that uses get_wider (likely with a new name)\n> or not.\n\nHere is a patch which does that.\n\nThough I admit I didn't go carefully through all 24 GET_MODE_WIDER_MODE\nuses, 54 FOR_EACH_MODE_IN_CLASS uses, 3 FOR_EACH_MODE uses, 24\nFOR_EACH_MODE_FROM, 6 FOR_EACH_MODE_UNTIL and 15 FOR_EACH_WIDER_MODE uses.\nIt is more important to go through the GET_MODE_WIDER_MODE and\nFOR_EACH_WIDER_MODE uses because the patch changes behavior for those,\nthe rest keep their previous meaning and so can be changed incrementally\nif the other meaning is desirable to them (I've of course changed the 3\nspots I had to change in the previous BFmode patch and whatever triggered\nduring the bootstraps).\n\n2022-10-13  Jakub Jelinek  <jakub@redhat.com>\n\n\t* genmodes.cc (emit_mode_wider): Emit previous content of\n\tmode_wider array into mode_next array and for mode_wider\n\temit always VOIDmode for !CLASS_HAS_WIDER_MODES_P classes,\n\totherwise skip through modes with the same precision.\n\t* machmode.h (mode_next): Declare.\n\t(GET_MODE_NEXT_MODE): New inline function.\n\t(mode_iterator::get_next, mode_iterator::get_known_next): New\n\tfunction templates.\n\t(FOR_EACH_MODE_IN_CLASS): Use get_next instead of get_wider.\n\t(FOR_EACH_MODE): Use get_known_next instead of get_known_wider.\n\t(FOR_EACH_MODE_FROM): Use get_next instead of get_wider.\n\t(FOR_EACH_WIDER_MODE_FROM): Define.\n\t(FOR_EACH_NEXT_MODE): Define.\n\t* expmed.cc (emit_store_flag_1): Use FOR_EACH_WIDER_MODE_FROM\n\tinstead of FOR_EACH_MODE_FROM.\n\t* optabs.cc (prepare_cmp_insn): Likewise.  Remove redundant\n\t!CLASS_HAS_WIDER_MODES_P check.\n\t(prepare_float_lib_cmp): Use FOR_EACH_WIDER_MODE_FROM instead of\n\tFOR_EACH_MODE_FROM.\n\t* config/i386/i386-expand.cc (get_mode_wider_vector): Use\n\tGET_MODE_NEXT_MODE instead of GET_MODE_WIDER_MODE.", "tree": {"sha": "b6fce294975ce8d312679e78238629a801646b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6fce294975ce8d312679e78238629a801646b1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cccf644ff92ac1145abdbf255d1862dd787875b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cccf644ff92ac1145abdbf255d1862dd787875b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cccf644ff92ac1145abdbf255d1862dd787875b"}], "stats": {"total": 115, "additions": 101, "deletions": 14}, "files": [{"sha": "a0f8a98986ee9a5cb14504d18c8261da36f9e176", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "patch": "@@ -14941,7 +14941,7 @@ static machine_mode\n get_mode_wider_vector (machine_mode o)\n {\n   /* ??? Rely on the ordering that genmodes.cc gives to vectors.  */\n-  machine_mode n = GET_MODE_WIDER_MODE (o).require ();\n+  machine_mode n = GET_MODE_NEXT_MODE (o).require ();\n   gcc_assert (GET_MODE_NUNITS (o) == GET_MODE_NUNITS (n) * 2);\n   gcc_assert (GET_MODE_SIZE (o) == GET_MODE_SIZE (n));\n   return n;"}, {"sha": "6f7f99ad51433aabb10d8b5ee06d71c8b6508878", "filename": "gcc/expmed.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fexpmed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fexpmed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.cc?ref=4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "patch": "@@ -5712,7 +5712,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* Next try expanding this via the backend's cstore<mode>4.  */\n   mclass = GET_MODE_CLASS (mode);\n-  FOR_EACH_MODE_FROM (compare_mode, mode)\n+  FOR_EACH_WIDER_MODE_FROM (compare_mode, mode)\n     {\n      machine_mode optab_mode = mclass == MODE_CC ? CCmode : compare_mode;\n      icode = optab_handler (cstore_optab, optab_mode);"}, {"sha": "9f0cc9c317dede0729989a868b1c51394b826e19", "filename": "gcc/genmodes.cc", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fgenmodes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fgenmodes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.cc?ref=4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "patch": "@@ -1527,13 +1527,44 @@ emit_mode_wider (void)\n   int c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned char\", \"mode_wider\", \"NUM_MACHINE_MODES\");\n+  print_decl (\"unsigned char\", \"mode_next\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n     tagged_printf (\"E_%smode\",\n \t\t   m->wider ? m->wider->name : void_mode->name,\n \t\t   m->name);\n \n+  print_closer ();\n+  print_decl (\"unsigned char\", \"mode_wider\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    {\n+      struct mode_data *m2 = 0;\n+\n+      if (m->cl == MODE_INT\n+\t  || m->cl == MODE_PARTIAL_INT\n+\t  || m->cl == MODE_FLOAT\n+\t  || m->cl == MODE_DECIMAL_FLOAT\n+\t  || m->cl == MODE_COMPLEX_FLOAT\n+\t  || m->cl == MODE_FRACT\n+\t  || m->cl == MODE_UFRACT\n+\t  || m->cl == MODE_ACCUM\n+\t  || m->cl == MODE_UACCUM)\n+\tfor (m2 = m->wider; m2 && m2 != void_mode; m2 = m2->wider)\n+\t  {\n+\t    if (m2->bytesize == m->bytesize\n+\t\t&& m2->precision == m->precision)\n+\t      continue;\n+\t    break;\n+\t  }\n+\n+      if (m2 == void_mode)\n+\tm2 = 0;\n+      tagged_printf (\"E_%smode\",\n+\t\t     m2 ? m2->name : void_mode->name,\n+\t\t     m->name);\n+    }\n+\n   print_closer ();\n   print_decl (\"unsigned char\", \"mode_2xwider\", \"NUM_MACHINE_MODES\");\n "}, {"sha": "99b0e4677d6521069626383fc55bf9d38774c83c", "filename": "gcc/machmode.h", "status": "modified", "additions": 64, "deletions": 6, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "patch": "@@ -28,6 +28,7 @@ extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n extern CONST_MODE_NUNITS poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n+extern const unsigned char mode_next[NUM_MACHINE_MODES];\n extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n \n@@ -760,7 +761,23 @@ GET_MODE_NUNITS (const T &mode)\n }\n #endif\n \n-/* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n+/* Get the next natural mode (not narrower, eg, QI -> HI -> SI -> DI -> TI\n+   or HF -> BF -> SF -> DF -> XF -> TF).  */\n+\n+template<typename T>\n+ALWAYS_INLINE opt_mode<T>\n+GET_MODE_NEXT_MODE (const T &m)\n+{\n+  return typename opt_mode<T>::from_int (mode_next[m]);\n+}\n+\n+/* Get the next wider mode (eg, QI -> HI -> SI -> DI -> TI\n+   or { HF, BF } -> SF -> DF -> XF -> TF).\n+   This is similar to GET_MODE_NEXT_MODE, but while GET_MODE_NEXT_MODE\n+   can include mode that have the same precision (e.g.\n+   GET_MODE_NEXT_MODE (HFmode) can be BFmode even when both have the same\n+   precision), this one will skip those.  And always VOIDmode for\n+   modes whose class is !CLASS_HAS_WIDER_MODES_P.  */\n \n template<typename T>\n ALWAYS_INLINE opt_mode<T>\n@@ -1098,7 +1115,33 @@ namespace mode_iterator\n     return *iter != E_VOIDmode;\n   }\n \n-  /* Set mode iterator *ITER to the next widest mode in the same class,\n+  /* Set mode iterator *ITER to the next mode in the same class,\n+     if any.  */\n+\n+  template<typename T>\n+  inline void\n+  get_next (opt_mode<T> *iter)\n+  {\n+    *iter = GET_MODE_NEXT_MODE (iter->require ());\n+  }\n+\n+  inline void\n+  get_next (machine_mode *iter)\n+  {\n+    *iter = GET_MODE_NEXT_MODE (*iter).else_void ();\n+  }\n+\n+  /* Set mode iterator *ITER to the next mode in the same class.\n+     Such a mode is known to exist.  */\n+\n+  template<typename T>\n+  inline void\n+  get_known_next (T *iter)\n+  {\n+    *iter = GET_MODE_NEXT_MODE (*iter).require ();\n+  }\n+\n+  /* Set mode iterator *ITER to the next wider mode in the same class,\n      if any.  */\n \n   template<typename T>\n@@ -1114,7 +1157,7 @@ namespace mode_iterator\n     *iter = GET_MODE_WIDER_MODE (*iter).else_void ();\n   }\n \n-  /* Set mode iterator *ITER to the next widest mode in the same class.\n+  /* Set mode iterator *ITER to the next wider mode in the same class.\n      Such a mode is known to exist.  */\n \n   template<typename T>\n@@ -1146,18 +1189,25 @@ namespace mode_iterator\n #define FOR_EACH_MODE_IN_CLASS(ITERATOR, CLASS)  \\\n   for (mode_iterator::start (&(ITERATOR), CLASS); \\\n        mode_iterator::iterate_p (&(ITERATOR)); \\\n-       mode_iterator::get_wider (&(ITERATOR)))\n+       mode_iterator::get_next (&(ITERATOR)))\n \n /* Make ITERATOR iterate over all the modes in the range [START, END),\n    in order of increasing width.  */\n #define FOR_EACH_MODE(ITERATOR, START, END) \\\n   for ((ITERATOR) = (START); \\\n        (ITERATOR) != (END); \\\n-       mode_iterator::get_known_wider (&(ITERATOR)))\n+       mode_iterator::get_known_next (&(ITERATOR)))\n \n-/* Make ITERATOR iterate over START and all wider modes in the same\n+/* Make ITERATOR iterate over START and all non-narrower modes in the same\n    class, in order of increasing width.  */\n #define FOR_EACH_MODE_FROM(ITERATOR, START) \\\n+  for ((ITERATOR) = (START); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_next (&(ITERATOR)))\n+\n+/* Make ITERATOR iterate over START and all wider modes in the same\n+   class, in order of strictly increasing width.  */\n+#define FOR_EACH_WIDER_MODE_FROM(ITERATOR, START) \\\n   for ((ITERATOR) = (START); \\\n        mode_iterator::iterate_p (&(ITERATOR)); \\\n        mode_iterator::get_wider (&(ITERATOR)))\n@@ -1168,6 +1218,14 @@ namespace mode_iterator\n #define FOR_EACH_MODE_UNTIL(ITERATOR, END) \\\n   FOR_EACH_MODE (ITERATOR, get_narrowest_mode (END), END)\n \n+/* Make ITERATOR iterate over modes in the same class as MODE, in order\n+   of non-decreasing width.  Start at next such mode after START,\n+   or don't iterate at all if there is no such mode.  */\n+#define FOR_EACH_NEXT_MODE(ITERATOR, START) \\\n+  for ((ITERATOR) = (START), mode_iterator::get_next (&(ITERATOR)); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_next (&(ITERATOR)))\n+\n /* Make ITERATOR iterate over modes in the same class as MODE, in order\n    of increasing width.  Start at the first mode wider than START,\n    or don't iterate at all if there is no wider mode.  */"}, {"sha": "c2a6f971d742ef79a0efb9bf65f8fe9078270158", "filename": "gcc/optabs.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Foptabs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7966191a69238c6d6fd5537b3e77c3a4027eb2/gcc%2Foptabs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.cc?ref=4b7966191a69238c6d6fd5537b3e77c3a4027eb2", "patch": "@@ -4384,7 +4384,6 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n   machine_mode mode = *pmode;\n   rtx libfunc, test;\n   machine_mode cmp_mode;\n-  enum mode_class mclass;\n \n   /* The other methods are not needed.  */\n   gcc_assert (methods == OPTAB_DIRECT || methods == OPTAB_WIDEN\n@@ -4490,9 +4489,8 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n       return;\n     }\n \n-  mclass = GET_MODE_CLASS (mode);\n   test = gen_rtx_fmt_ee (comparison, VOIDmode, x, y);\n-  FOR_EACH_MODE_FROM (cmp_mode, mode)\n+  FOR_EACH_WIDER_MODE_FROM (cmp_mode, mode)\n     {\n       enum insn_code icode;\n       icode = optab_handler (cbranch_optab, cmp_mode);\n@@ -4515,7 +4513,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t  delete_insns_since (last);\n \t}\n \n-      if (methods == OPTAB_DIRECT || !CLASS_HAS_WIDER_MODES_P (mclass))\n+      if (methods == OPTAB_DIRECT)\n \tbreak;\n     }\n \n@@ -4711,7 +4709,7 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n   bool reversed_p = false;\n   scalar_int_mode cmp_mode = targetm.libgcc_cmp_return_mode ();\n \n-  FOR_EACH_MODE_FROM (mode, orig_mode)\n+  FOR_EACH_WIDER_MODE_FROM (mode, orig_mode)\n     {\n       if (code_to_optab (comparison)\n \t  && (libfunc = optab_libfunc (code_to_optab (comparison), mode)))"}]}