{"sha": "dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiMmMzOWE5OTVkMjEwZmU0MzkzMGQ3YmM1MWM1YjUxMzBkZmE3OQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2005-05-15T18:17:10Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-05-15T18:17:10Z"}, "message": "* ylwrap: Import from Automake 1.9.5.\n\nFrom-SVN: r99738", "tree": {"sha": "6587a6c68585e5aa93d6f65bf9064ea9dfac8b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6587a6c68585e5aa93d6f65bf9064ea9dfac8b4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb2c39a995d210fe43930d7bc51c5b5130dfa79/comments", "author": null, "committer": null, "parents": [{"sha": "766643be53ba51844276cf468da4c605f9e1fbc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766643be53ba51844276cf468da4c605f9e1fbc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766643be53ba51844276cf468da4c605f9e1fbc2"}], "stats": {"total": 245, "additions": 174, "deletions": 71}, "files": [{"sha": "a81cc0add82ed0b1a1b26835cd7351d55238af38", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb2c39a995d210fe43930d7bc51c5b5130dfa79/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb2c39a995d210fe43930d7bc51c5b5130dfa79/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "patch": "@@ -1,3 +1,7 @@\n+2005-05-15  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* ylwrap: Import from Automake 1.9.5.\n+\n 2005-05-13  David Ung  <davidu@mips.com>\n \n \t* MAINTAINERS (Write After Approval): Add self."}, {"sha": "10e4368b35f1c6e009caa923f5bc8dc5ff82f196", "filename": "ylwrap", "status": "modified", "additions": 170, "deletions": 71, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb2c39a995d210fe43930d7bc51c5b5130dfa79/ylwrap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb2c39a995d210fe43930d7bc51c5b5130dfa79/ylwrap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ylwrap?ref=dfb2c39a995d210fe43930d7bc51c5b5130dfa79", "patch": "@@ -1,6 +1,11 @@\n #! /bin/sh\n # ylwrap - wrapper for lex/yacc invocations.\n-# Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+\n+scriptversion=2005-02-02.22\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005\n+#   Free Software Foundation, Inc.\n+#\n # Written by Tom Tromey <tromey@cygnus.com>.\n #\n # This program is free software; you can redistribute it and/or modify\n@@ -17,107 +22,201 @@\n # along with this program; if not, write to the Free Software\n # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n-# Usage:\n-#     ylwrap PROGRAM INPUT [OUTPUT DESIRED]... -- [ARGS]...\n-# * PROGRAM is program to run.\n-# * INPUT is the input file\n-# * OUTPUT is file PROG generates\n-# * DESIRED is file we actually want\n-# * ARGS are passed to PROG\n-# Any number of OUTPUT,DESIRED pairs may be used.\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n \n-# The program to run.\n-prog=\"$1\"\n-shift\n-# Make any relative path in $prog absolute.\n-case \"$prog\" in\n- /* | [A-Za-z]:\\\\*) ;;\n- */*) prog=\"`pwd`/$prog\" ;;\n+# This file is maintained in Automake, please report\n+# bugs to <bug-automake@gnu.org> or send patches to\n+# <automake-patches@gnu.org>.\n+\n+case \"$1\" in\n+  '')\n+    echo \"$0: No files given.  Try \\`$0 --help' for more information.\" 1>&2\n+    exit 1\n+    ;;\n+  --basedir)\n+    basedir=$2\n+    shift 2\n+    ;;\n+  -h|--h*)\n+    cat <<\\EOF\n+Usage: ylwrap [--help|--version] INPUT [OUTPUT DESIRED]... -- PROGRAM [ARGS]...\n+\n+Wrapper for lex/yacc invocations, renaming files as desired.\n+\n+  INPUT is the input file\n+  OUTPUT is one file PROG generates\n+  DESIRED is the file we actually want instead of OUTPUT\n+  PROGRAM is program to run\n+  ARGS are passed to PROG\n+\n+Any number of OUTPUT,DESIRED pairs may be used.\n+\n+Report bugs to <bug-automake@gnu.org>.\n+EOF\n+    exit $?\n+    ;;\n+  -v|--v*)\n+    echo \"ylwrap $scriptversion\"\n+    exit $?\n+    ;;\n esac\n \n+\n # The input.\n input=\"$1\"\n shift\n case \"$input\" in\n- /* | [A-Za-z]:\\\\*)\n+  [\\\\/]* | ?:[\\\\/]*)\n     # Absolute path; do nothing.\n     ;;\n- *)\n-    # Relative path.  Make it absolute.  Why?  Because otherwise any\n-    # debugging info in the generated file will point to the wrong\n-    # place.  This is really gross.\n+  *)\n+    # Relative path.  Make it absolute.\n     input=\"`pwd`/$input\"\n     ;;\n esac\n \n-# We don't want to use the absolute path if the input in the current\n-# directory like when making a tar ball.\n-input_base=`echo $input | sed -e 's|.*/||'`\n-if test -f $input_base && cmp $input_base $input >/dev/null 2>&1; then\n-  input=$input_base\n-fi\n-\n pairlist=\n while test \"$#\" -ne 0; do\n-   if test \"$1\" = \"--\"; then\n-      shift\n-      break\n-   fi\n-   pairlist=\"$pairlist $1\"\n-   shift\n+  if test \"$1\" = \"--\"; then\n+    shift\n+    break\n+  fi\n+  pairlist=\"$pairlist $1\"\n+  shift\n done\n \n+# The program to run.\n+prog=\"$1\"\n+shift\n+# Make any relative path in $prog absolute.\n+case \"$prog\" in\n+  [\\\\/]* | ?:[\\\\/]*) ;;\n+  *[\\\\/]*) prog=\"`pwd`/$prog\" ;;\n+esac\n+\n # FIXME: add hostname here for parallel makes that run commands on\n # other machines.  But that might take us over the 14-char limit.\n dirname=ylwrap$$\n trap \"cd `pwd`; rm -rf $dirname > /dev/null 2>&1\" 1 2 3 15\n mkdir $dirname || exit 1\n \n cd $dirname\n-case \"$input\" in\n- /* | [A-Za-z]:\\\\*)\n-    # Absolute path; do nothing.\n-    ;;\n- *)\n-    # Make a symbolic link, hard link or hardcopy.\n-    ln -s ../\"$input\" . > /dev/null 2>&1 || ln ../\"$input\" . > /dev/null 2>&1 || cp ../\"$input\" .\n-    ;;\n+\n+case $# in\n+  0) $prog \"$input\" ;;\n+  *) $prog \"$@\" \"$input\" ;;\n esac\n-$prog ${1+\"$@\"} \"$input\"\n-status=$?\n-\n-if test $status -eq 0; then\n-   set X $pairlist\n-   shift\n-   first=yes\n-   while test \"$#\" -ne 0; do\n-      if test -f \"$1\"; then\n-         # If $2 is an absolute path name, then just use that,\n-         # otherwise prepend `../'.\n-         case \"$2\" in\n-\t   /* | [A-Za-z]:\\\\*) target=\"$2\";;\n-\t   *) target=\"../$2\";;\n-\t esac\n-\t mv \"$1\" \"$target\" || status=$?\n+ret=$?\n+\n+if test $ret -eq 0; then\n+  set X $pairlist\n+  shift\n+  first=yes\n+  # Since DOS filename conventions don't allow two dots,\n+  # the DOS version of Bison writes out y_tab.c instead of y.tab.c\n+  # and y_tab.h instead of y.tab.h. Test to see if this is the case.\n+  y_tab_nodot=\"no\"\n+  if test -f y_tab.c || test -f y_tab.h; then\n+    y_tab_nodot=\"yes\"\n+  fi\n+\n+  # The directory holding the input.\n+  input_dir=`echo \"$input\" | sed -e 's,\\([\\\\/]\\)[^\\\\/]*$,\\1,'`\n+  # Quote $INPUT_DIR so we can use it in a regexp.\n+  # FIXME: really we should care about more than `.' and `\\'.\n+  input_rx=`echo \"$input_dir\" | sed 's,\\\\\\\\,\\\\\\\\\\\\\\\\,g;s,\\\\.,\\\\\\\\.,g'`\n+\n+  while test \"$#\" -ne 0; do\n+    from=\"$1\"\n+    # Handle y_tab.c and y_tab.h output by DOS\n+    if test $y_tab_nodot = \"yes\"; then\n+      if test $from = \"y.tab.c\"; then\n+    \tfrom=\"y_tab.c\"\n       else\n-\t # A missing file is only an error for the first file.  This\n-\t # is a blatant hack to let us support using \"yacc -d\".  If -d\n-\t # is not specified, we don't want an error when the header\n-\t # file is \"missing\".\n-\t if test $first = yes; then\n-\t    status=1\n-\t fi\n+    \tif test $from = \"y.tab.h\"; then\n+    \t  from=\"y_tab.h\"\n+    \tfi\n+      fi\n+    fi\n+    if test -f \"$from\"; then\n+      # If $2 is an absolute path name, then just use that,\n+      # otherwise prepend `../'.\n+      case \"$2\" in\n+    \t[\\\\/]* | ?:[\\\\/]*) target=\"$2\";;\n+    \t*) target=\"../$2\";;\n+      esac\n+\n+      # We do not want to overwrite a header file if it hasn't\n+      # changed.  This avoid useless recompilations.  However the\n+      # parser itself (the first file) should always be updated,\n+      # because it is the destination of the .y.c rule in the\n+      # Makefile.  Divert the output of all other files to a temporary\n+      # file so we can compare them to existing versions.\n+      if test $first = no; then\n+\trealtarget=\"$target\"\n+\ttarget=\"tmp-`echo $target | sed s/.*[\\\\/]//g`\"\n       fi\n-      shift\n-      shift\n-      first=no\n-   done\n+      # Edit out `#line' or `#' directives.\n+      #\n+      # We don't want the resulting debug information to point at\n+      # an absolute srcdir; it is better for it to just mention the\n+      # .y file with no path.\n+      #\n+      # We want to use the real output file name, not yy.lex.c for\n+      # instance.\n+      #\n+      # We want the include guards to be adjusted too.\n+      FROM=`echo \"$from\" | sed \\\n+            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\\\n+            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`\n+      TARGET=`echo \"$2\" | sed \\\n+            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\\\n+            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`\n+\n+      sed -e \"/^#/!b\" -e \"s,$input_rx,,\" -e \"s,$from,$2,\" \\\n+          -e \"s,$FROM,$TARGET,\" \"$from\" >\"$target\" || ret=$?\n+\n+      # Check whether header files must be updated.\n+      if test $first = no; then\n+\tif test -f \"$realtarget\" && cmp -s \"$realtarget\" \"$target\"; then\n+\t  echo \"$2\" is unchanged\n+\t  rm -f \"$target\"\n+\telse\n+          echo updating \"$2\"\n+          mv -f \"$target\" \"$realtarget\"\n+        fi\n+      fi\n+    else\n+      # A missing file is only an error for the first file.  This\n+      # is a blatant hack to let us support using \"yacc -d\".  If -d\n+      # is not specified, we don't want an error when the header\n+      # file is \"missing\".\n+      if test $first = yes; then\n+        ret=1\n+      fi\n+    fi\n+    shift\n+    shift\n+    first=no\n+  done\n else\n-   status=$?\n+  ret=$?\n fi\n \n # Remove the directory.\n cd ..\n rm -rf $dirname\n \n-exit $status\n+exit $ret\n+\n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 2\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-end: \"$\"\n+# End:"}]}